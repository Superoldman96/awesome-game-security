Project Path: arc_gmh5225_libmdmp_m_vb72jf

Source Tree:

```txt
arc_gmh5225_libmdmp_m_vb72jf
├── AUTHORS
├── COPYING
├── COPYING.LESSER
├── ChangeLog
├── Makefile.am
├── NEWS
├── README
├── acinclude.m4
├── appveyor.yml
├── autogen.ps1
├── autogen.sh
├── build.ps1
├── common
│   ├── Makefile.am
│   ├── byte_stream.h
│   ├── common.h
│   ├── config_borlandc.h
│   ├── config_msc.h
│   ├── config_winapi.h
│   ├── file_stream.h
│   ├── memory.h
│   ├── narrow_string.h
│   ├── system_string.h
│   ├── types.h.in
│   └── wide_string.h
├── configure.ac
├── documentation
│   └── Minidump (MDMP) format.asciidoc
├── dpkg
│   ├── changelog.in
│   ├── compat
│   ├── control
│   ├── copyright
│   ├── libmdmp-dev.install
│   ├── libmdmp-tools.install
│   ├── libmdmp.install
│   ├── rules
│   └── source
│       └── format
├── include
│   ├── Makefile.am
│   ├── libmdmp
│   │   ├── codepage.h
│   │   ├── definitions.h.in
│   │   ├── error.h
│   │   ├── extern.h
│   │   ├── features.h.in
│   │   └── types.h.in
│   └── libmdmp.h.in
├── libmdmp
│   ├── Makefile.am
│   ├── libmdmp.c
│   ├── libmdmp.rc.in
│   ├── libmdmp_codepage.h
│   ├── libmdmp_debug.c
│   ├── libmdmp_debug.h
│   ├── libmdmp_definitions.h.in
│   ├── libmdmp_error.c
│   ├── libmdmp_error.h
│   ├── libmdmp_extern.h
│   ├── libmdmp_file.c
│   ├── libmdmp_file.h
│   ├── libmdmp_file_header.c
│   ├── libmdmp_file_header.h
│   ├── libmdmp_io_handle.c
│   ├── libmdmp_io_handle.h
│   ├── libmdmp_libbfio.h
│   ├── libmdmp_libcdata.h
│   ├── libmdmp_libcerror.h
│   ├── libmdmp_libclocale.h
│   ├── libmdmp_libcnotify.h
│   ├── libmdmp_libfdata.h
│   ├── libmdmp_libfdatetime.h
│   ├── libmdmp_libuna.h
│   ├── libmdmp_notify.c
│   ├── libmdmp_notify.h
│   ├── libmdmp_stream.c
│   ├── libmdmp_stream.h
│   ├── libmdmp_stream_descriptor.c
│   ├── libmdmp_stream_descriptor.h
│   ├── libmdmp_stream_io_handle.c
│   ├── libmdmp_stream_io_handle.h
│   ├── libmdmp_support.c
│   ├── libmdmp_support.h
│   ├── libmdmp_types.h
│   ├── libmdmp_unused.h
│   └── mdmp_file_header.h
├── libmdmp.ini
├── libmdmp.pc.in
├── libmdmp.spec.in
├── m4
│   ├── common.m4
│   ├── libbfio.m4
│   ├── libcdata.m4
│   ├── libcerror.m4
│   ├── libcfile.m4
│   ├── libclocale.m4
│   ├── libcnotify.m4
│   ├── libcpath.m4
│   ├── libcsplit.m4
│   ├── libcthreads.m4
│   ├── libfcache.m4
│   ├── libfdata.m4
│   ├── libfdatetime.m4
│   ├── libuna.m4
│   ├── pthread.m4
│   ├── tests.m4
│   └── types.m4
├── manuals
│   ├── Makefile.am
│   ├── libmdmp.3
│   └── mdmpinfo.1
├── mdmptools
│   ├── Makefile.am
│   ├── info_handle.c
│   ├── info_handle.h
│   ├── mdmpinfo.c
│   ├── mdmpinput.c
│   ├── mdmpinput.h
│   ├── mdmptools_getopt.c
│   ├── mdmptools_getopt.h
│   ├── mdmptools_i18n.h
│   ├── mdmptools_libbfio.h
│   ├── mdmptools_libcerror.h
│   ├── mdmptools_libclocale.h
│   ├── mdmptools_libcnotify.h
│   ├── mdmptools_libmdmp.h
│   ├── mdmptools_libuna.h
│   ├── mdmptools_output.c
│   ├── mdmptools_output.h
│   ├── mdmptools_signal.c
│   ├── mdmptools_signal.h
│   └── mdmptools_unused.h
├── msvscpp
│   ├── Makefile.am
│   ├── libbfio
│   │   └── libbfio.vcproj
│   ├── libcdata
│   │   └── libcdata.vcproj
│   ├── libcerror
│   │   └── libcerror.vcproj
│   ├── libcfile
│   │   └── libcfile.vcproj
│   ├── libclocale
│   │   └── libclocale.vcproj
│   ├── libcnotify
│   │   └── libcnotify.vcproj
│   ├── libcpath
│   │   └── libcpath.vcproj
│   ├── libcsplit
│   │   └── libcsplit.vcproj
│   ├── libcthreads
│   │   └── libcthreads.vcproj
│   ├── libfcache
│   │   └── libfcache.vcproj
│   ├── libfdata
│   │   └── libfdata.vcproj
│   ├── libfdatetime
│   │   └── libfdatetime.vcproj
│   ├── libmdmp
│   │   └── libmdmp.vcproj
│   ├── libmdmp.sln
│   ├── libuna
│   │   └── libuna.vcproj
│   ├── mdmp_test_error
│   │   └── mdmp_test_error.vcproj
│   ├── mdmp_test_file
│   │   └── mdmp_test_file.vcproj
│   ├── mdmp_test_io_handle
│   │   └── mdmp_test_io_handle.vcproj
│   ├── mdmp_test_notify
│   │   └── mdmp_test_notify.vcproj
│   ├── mdmp_test_stream
│   │   └── mdmp_test_stream.vcproj
│   ├── mdmp_test_stream_descriptor
│   │   └── mdmp_test_stream_descriptor.vcproj
│   ├── mdmp_test_stream_io_handle
│   │   └── mdmp_test_stream_io_handle.vcproj
│   ├── mdmp_test_support
│   │   └── mdmp_test_support.vcproj
│   ├── mdmp_test_tools_info_handle
│   │   └── mdmp_test_tools_info_handle.vcproj
│   ├── mdmp_test_tools_output
│   │   └── mdmp_test_tools_output.vcproj
│   ├── mdmp_test_tools_signal
│   │   └── mdmp_test_tools_signal.vcproj
│   └── mdmpinfo
│       └── mdmpinfo.vcproj
├── ossfuzz
│   ├── Makefile.am
│   ├── file_fuzzer.cc
│   ├── ossfuzz_libbfio.h
│   └── ossfuzz_libmdmp.h
├── po
│   ├── ChangeLog
│   ├── Makevars.in
│   └── POTFILES.in
├── runtests.ps1
├── runtests.sh
├── synclibs.ps1
├── synclibs.sh
├── synctestdata.ps1
├── synctestdata.sh
└── tests
    ├── Makefile.am
    ├── build.sh
    ├── lsan.suppressions
    ├── mdmp_test_error.c
    ├── mdmp_test_file.c
    ├── mdmp_test_file_header.c
    ├── mdmp_test_functions.c
    ├── mdmp_test_functions.h
    ├── mdmp_test_getopt.c
    ├── mdmp_test_getopt.h
    ├── mdmp_test_io_handle.c
    ├── mdmp_test_libbfio.h
    ├── mdmp_test_libcerror.h
    ├── mdmp_test_libclocale.h
    ├── mdmp_test_libcnotify.h
    ├── mdmp_test_libmdmp.h
    ├── mdmp_test_libuna.h
    ├── mdmp_test_macros.h
    ├── mdmp_test_memory.c
    ├── mdmp_test_memory.h
    ├── mdmp_test_notify.c
    ├── mdmp_test_stream.c
    ├── mdmp_test_stream_descriptor.c
    ├── mdmp_test_stream_io_handle.c
    ├── mdmp_test_support.c
    ├── mdmp_test_tools_info_handle.c
    ├── mdmp_test_tools_output.c
    ├── mdmp_test_tools_signal.c
    ├── mdmp_test_unused.h
    ├── pkgbuild.sh
    ├── runtests.sh
    ├── syncsharedlibs.sh
    ├── test_library.ps1
    ├── test_library.sh
    ├── test_manpage.sh
    ├── test_mdmpinfo.ps1
    ├── test_mdmpinfo.sh
    ├── test_runner.sh
    ├── test_tools.ps1
    └── test_tools.sh

```

`AUTHORS`:

```
Acknowledgements: libmdmp

Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>


```

`COPYING`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`COPYING.LESSER`:

```LESSER
                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.

```

`ChangeLog`:

```
TODO:
* mdmpinfo
  - print file flags
  - print general system information
  - print module information
* export the memory allocation information stream?
* add python bindings
* update manuals

20141026
* changes for deployment
* removed README.macosx
* changes for project site move
* see `git log' for more recent change log

20140726
* updated dependencies

20140407
* worked on format

20140402
* Initial version based on libpf


```

`Makefile.am`:

```am
ACLOCAL_AMFLAGS = -I m4

SUBDIRS = \
	include \
	common \
	libcerror \
	libcthreads \
	libcdata \
	libclocale \
	libcnotify \
	libcsplit \
	libuna \
	libcfile \
	libcpath \
	libbfio \
	libfcache \
	libfdata \
	libfdatetime \
	libmdmp \
	mdmptools \
	po \
	manuals \
	tests \
	ossfuzz \
	msvscpp

DPKG_FILES = \
	dpkg/changelog \
	dpkg/changelog.in \
	dpkg/compat \
	dpkg/control \
	dpkg/copyright \
	dpkg/rules \
	dpkg/libagdb-dev.install \
	dpkg/libagdb.install \
	dpkg/libagdb-tools.install \
	dpkg/source/format

GETTEXT_FILES = \
	config.rpath \
	po/Makevars.in

PKGCONFIG_FILES = \
	libmdmp.pc.in

SPEC_FILES = \
	libmdmp.spec \
	libmdmp.spec.in

EXTRA_DIST = \
	$(DPKG_FILES) \
	$(GETTEXT_FILES) \
	$(PKGCONFIG_FILES) \
	$(SPEC_FILES)

MAINTAINERCLEANFILES = \
	Makefile.in

pkgconfigdir = $(libdir)/pkgconfig

pkgconfig_DATA = \
	libmdmp.pc

libtool: @LIBTOOL_DEPS@
	cd $(srcdir) && $(SHELL) ./config.status --recheck

lib: library

library:
	(cd $(srcdir)/common && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libcerror && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libcthreads && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libcdata && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libclocale && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libcnotify && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libcsplit && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libuna && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libcfile && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libcpath && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libbfio && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libfcache && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libfdata && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libfdatetime && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/libmdmp && $(MAKE) $(AM_MAKEFLAGS))
	(cd $(srcdir)/po && $(MAKE) $(AM_MAKEFLAGS))

distclean: clean
	-rm -f Makefile
	-rm -f config.status
	-rm -f config.cache
	-rm -f config.log
	-rm -f libmdmp.pc
	-rm -f libmdmp.spec
	@for dir in ${subdirs}; do \
		(cd $$dir && $(MAKE) distclean) \
		|| case "$(MFLAGS)" in *k*) fail=yes;; *) exit 1;; esac; \
	done && test -z "$$fail"


```

`README`:

```
libmdmp is a library to access the Windows Minidump (MDMP) format.

Note that this project currently only focuses on the analysis of the format.

Project information:

* Status: experimental
* Licence: LGPLv3+

For more information see:

* Project documentation: https://github.com/libyal/libmdmp/wiki/Home
* How to build from source: https://github.com/libyal/libmdmp/wiki/Building


```

`acinclude.m4`:

```m4
dnl Checks for required headers and functions
dnl
dnl Version: 20200713

dnl Function to detect if libmdmp dependencies are available
AC_DEFUN([AX_LIBMDMP_CHECK_LOCAL],
  [dnl Check for internationalization functions in libmdmp/libmdmp_i18n.c
  AC_CHECK_FUNCS([bindtextdomain])
])

dnl Function to detect if mdmptools dependencies are available
AC_DEFUN([AX_MDMPTOOLS_CHECK_LOCAL],
  [AC_CHECK_HEADERS([signal.h sys/signal.h unistd.h])

  AC_CHECK_FUNCS([close getopt setvbuf])

  AS_IF(
   [test "x$ac_cv_func_close" != xyes],
   [AC_MSG_FAILURE(
     [Missing function: close],
     [1])
  ])
])

dnl Function to check if DLL support is needed
AC_DEFUN([AX_LIBMDMP_CHECK_DLL_SUPPORT],
  [AS_IF(
    [test "x$enable_shared" = xyes && test "x$ac_cv_enable_static_executables" = xno],
    [AS_CASE(
      [$host],
      [*cygwin* | *mingw* | *msys*],
      [AC_DEFINE(
        [HAVE_DLLMAIN],
        [1],
        [Define to 1 to enable the DllMain function.])
      AC_SUBST(
        [HAVE_DLLMAIN],
        [1])

      AC_SUBST(
        [LIBMDMP_DLL_EXPORT],
        ["-DLIBMDMP_DLL_EXPORT"])

      AC_SUBST(
        [LIBMDMP_DLL_IMPORT],
        ["-DLIBMDMP_DLL_IMPORT"])
      ])
    ])
  ])


```

`appveyor.yml`:

```yml
environment:
  matrix:
  - TARGET: vs2008
    BUILD_ENVIRONMENT: msbuild
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2013
    VisualStudioVersion: 9.0
    platform: Win32
    configuration: Release
    PYTHON_PATH: "C:\\Python37"
  - TARGET: vs2010
    BUILD_ENVIRONMENT: msbuild
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2013
    VisualStudioVersion: 10.0
    platform: Win32
    configuration: Release
    PYTHON_PATH: "C:\\Python37"
  - TARGET: vs2012
    BUILD_ENVIRONMENT: msbuild
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2013
    VisualStudioVersion: 11.0
    platform: Win32
    configuration: Release
    PYTHON_PATH: "C:\\Python37"
  - TARGET: vs2013
    BUILD_ENVIRONMENT: msbuild
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2013
    VisualStudioVersion: 12.0
    platform: Win32
    configuration: Release
    PYTHON_PATH: "C:\\Python37"
  - TARGET: vs2015
    BUILD_ENVIRONMENT: msbuild
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2015
    VisualStudioVersion: 14.0
    platform: Win32
    configuration: Release
    PYTHON_PATH: "C:\\Python38"
  - TARGET: vs2017
    BUILD_ENVIRONMENT: msbuild
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017
    VisualStudioVersion: 15.0
    platform: Win32
    configuration: Release
    PYTHON_PATH: "C:\\Python38"
  - TARGET: vs2019
    BUILD_ENVIRONMENT: msbuild
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019
    VisualStudioVersion: 16.0
    platform: Win32
    configuration: Release
    PYTHON_PATH: "C:\\Python311"
  - TARGET: vs2022
    BUILD_ENVIRONMENT: msbuild
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022
    VisualStudioVersion: 17.0
    platform: Win32
    configuration: Release
    PYTHON_PATH: "C:\\Python311"
  - TARGET: vs2022-vsdebug
    BUILD_ENVIRONMENT: msbuild
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022
    VisualStudioVersion: 17.0
    platform: Win32
    configuration: VSDebug
    PYTHON_PATH: "C:\\Python311"
  - TARGET: vs2022-x64
    BUILD_ENVIRONMENT: msbuild
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022
    VisualStudioVersion: 17.0
    platform: x64
    configuration: Release
    PYTHON_PATH: "C:\\Python311"
  - TARGET: macos-x64-clang
    BUILD_ENVIRONMENT: xcode
    APPVEYOR_BUILD_WORKER_IMAGE: macos-monterey
    HOMEBREW_NO_INSTALL_CLEANUP: 1
    CC: clang
    CFLAGS: "-I/usr/local/include"
    LDFLAGS: "-L/usr/local/lib"
    CONFIGURE_OPTIONS: ""
  - TARGET: macos-x64-gcc
    BUILD_ENVIRONMENT: xcode
    APPVEYOR_BUILD_WORKER_IMAGE: macos-monterey
    HOMEBREW_NO_INSTALL_CLEANUP: 1
    CC: gcc
    CFLAGS: "-I/usr/local/include"
    LDFLAGS: "-L/usr/local/lib"
    CONFIGURE_OPTIONS: ""
  - TARGET: macos-pkgbuild
    BUILD_ENVIRONMENT: xcode
    APPVEYOR_BUILD_WORKER_IMAGE: macos-monterey
    HOMEBREW_NO_INSTALL_CLEANUP: 1
    CONFIGURE_OPTIONS: "--disable-dependency-tracking --prefix=/usr/local --with-pyprefix"
  - TARGET: cygwin64-gcc
    BUILD_ENVIRONMENT: cygwin64
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022
    CONFIGURE_OPTIONS: ""
  - TARGET: cygwin64-gcc-no-optimization
    BUILD_ENVIRONMENT: cygwin64
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022
    CONFIGURE_OPTIONS: "--enable-shared=no"
    CFLAGS: "--coverage -O0"
    CPPFLAGS: "-DOPTIMIZATION_DISABLED"
    LDFLAGS: "--coverage"
  - TARGET: cygwin64-gcc-static-executables
    BUILD_ENVIRONMENT: cygwin64
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022
    CONFIGURE_OPTIONS: "--enable-static-executables"
  - TARGET: mingw-w64-gcc
    BUILD_ENVIRONMENT: mingw-w64
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022
    CONFIGURE_OPTIONS: ""
  - TARGET: mingw-w64-gcc-no-optimization
    BUILD_ENVIRONMENT: mingw-w64
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022
    CONFIGURE_OPTIONS: "--enable-shared=no"
    CFLAGS: "--coverage -O0"
    CPPFLAGS: "-DOPTIMIZATION_DISABLED"
    LDFLAGS: "--coverage"
  - TARGET: mingw-w64-gcc-static-executables
    BUILD_ENVIRONMENT: mingw-w64
    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022
    CONFIGURE_OPTIONS: "--enable-static-executables"

install:
- cmd: if [%BUILD_ENVIRONMENT%]==[msbuild] (
    git clone https://github.com/libyal/vstools.git ..\vstools )
- sh: if ( test `uname -s` = "Darwin" && test ${BUILD_ENVIRONMENT} = "python-tox" ) || test ${BUILD_ENVIRONMENT} = "xcode"; then brew update-reset && brew update -q; fi
- sh: if ( test `uname -s` = "Darwin" && test ${BUILD_ENVIRONMENT} = "python-tox" ) || test ${BUILD_ENVIRONMENT} = "xcode"; then brew install -q autoconf automake gettext gnu-sed libtool pkg-config || true; fi
- ps: If ($env:BUILD_ENVIRONMENT -eq "cygwin64") {
    (New-Object Net.WebClient).DownloadFile("https://cygwin.com/setup-x86_64.exe", "C:\\cygwin64\\setup-x86_64.exe") }
- cmd: if [%BUILD_ENVIRONMENT%]==[cygwin64] (
    C:\cygwin64\setup-x86_64.exe -qgnNdO -l C:\cygwin64\var\cache\setup -R c:\cygwin64 -s http://cygwin.mirror.constant.com -P gettext-devel -P wget )
- cmd: if [%BUILD_ENVIRONMENT%]==[mingw-w64] (
    C:\msys64\usr\bin\pacman -S --noconfirm --needed autoconf automake gettext-devel libtool make mingw-w64-x86_64-gcc )
- ps: If ( ( "cygwin64-gcc-no-optimization", "mingw-w64-gcc-no-optimization" ).Contains( $env:TARGET ) ) {
    $ProgressPreference = 'SilentlyContinue'; Invoke-WebRequest -Uri https://uploader.codecov.io/latest/windows/codecov.exe -Outfile ..\codecov.exe }

build_script:
- ps: If ($env:BUILD_ENVIRONMENT -eq "msbuild" -or ($env:BUILD_ENVIRONMENT -eq "python-tox" -and $isWindows)) {
    .\synclibs.ps1;
    .\autogen.ps1 }
- ps: If ($env:TARGET -eq "vs2008") {
    .\build.ps1 -VisualStudioVersion 2008 -PythonPath $env:PYTHON_PATH -VSToolsOptions "--no-python-dll" }
- ps: If ( ( "vs2010", "vs2012", "vs2013", "vs2015" ).Contains( $env:TARGET ) ) {
    .\build.ps1 -VisualStudioVersion $env:TARGET.Substring(2, 4) -Configuration $env:CONFIGURATION -Platform $env:PLATFORM -PythonPath $env:PYTHON_PATH -VSToolsOptions "--extend-with-x64 --no-python-dll" }
- ps: If ( ( "vs2017", "vs2019", "vs2022", "vs2022-vsdebug", "vs2022-x64" ).Contains( $env:TARGET ) ) {
    .\build.ps1 -VisualStudioVersion $env:TARGET.Substring(2, 4) -Configuration $env:CONFIGURATION -Platform $env:PLATFORM -PythonPath $env:PYTHON_PATH -VSToolsOptions "--extend-with-x64 --no-python-dll --with-dokany" }
- sh: if test ${BUILD_ENVIRONMENT} = "xcode"; then export PATH="/usr/local/opt/gettext/bin:$PATH"; export SED="/usr/local/bin/gsed"; tests/build.sh ${CONFIGURE_OPTIONS}; fi
- cmd: if [%BUILD_ENVIRONMENT%]==[cygwin64] (
    xcopy /i /q /s C:\projects\libmdmp C:\cygwin64\home\appveyor\libmdmp &&
    C:\cygwin64\bin\bash -e -l -c "cd libmdmp && wget -q 'http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD' -O './config.guess' && wget -q 'http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD' -O './config.sub'" &&
    C:\cygwin64\bin\bash -e -l -c "cd libmdmp && tests/build.sh ${CONFIGURE_OPTIONS}" )
- cmd: if [%BUILD_ENVIRONMENT%]==[mingw-w64] (
    xcopy /i /q /s C:\projects\libmdmp C:\msys64\home\appveyor\libmdmp &&
    C:\msys64\usr\bin\bash -e -l -c "cd libmdmp && tests/build.sh ${CONFIGURE_OPTIONS}" )

test_script:
- cmd: rem Run tests
- ps: If ($env:BUILD_ENVIRONMENT -eq "msbuild") {
    .\runtests.ps1 }
- sh: if test ${BUILD_ENVIRONMENT} = "xcode" && test ${TARGET} != "macos-pkgbuild"; then tests/runtests.sh; fi
- sh: if test ${TARGET} = "macos-pkgbuild"; then tests/pkgbuild.sh; fi
- cmd: if [%BUILD_ENVIRONMENT%]==[cygwin64] (
    C:\cygwin64\bin\bash -l -c "cd libmdmp && tests/runtests.sh" )
- cmd: if [%BUILD_ENVIRONMENT%]==[mingw-w64] (
    C:\msys64\usr\bin\bash -l -c "cd libmdmp && tests/runtests.sh" )

after_test:
- cmd: if [%TARGET%]==[cygwin64-gcc-no-optimization] (
    C:\cygwin64\bin\bash -e -l -c "cd libmdmp && for DIRECTORY in `find . -maxdepth 1 -type d`; do (cd ${DIRECTORY} && find . -maxdepth 1 -name \*.gcno -type f -exec gcov -pb {} \;) done" &&
    C:\projects\codecov.exe -R \cygwin64\home\appveyor\libmdmp --name %TARGET% )
- cmd: if [%TARGET%]==[mingw-w64-gcc-no-optimization] (
    C:\msys64\usr\bin\bash -e -l -c "cd libmdmp && for DIRECTORY in `find . -maxdepth 1 -type d`; do (cd ${DIRECTORY} && find . -maxdepth 1 -name \*.gcno -type f -exec gcov -pb {} \;) done" &&
    C:\projects\codecov.exe -R \msys64\home\appveyor\libmdmp --name %TARGET% )


```

`autogen.ps1`:

```ps1
# Script to generate the necessary files for a msvscpp build
#
# Version: 20230118

$WinFlex = "..\win_flex_bison\win_flex.exe"
$WinBison = "..\win_flex_bison\win_bison.exe"

$Library = Get-Content -Path configure.ac | select -skip 3 -first 1 | % { $_ -Replace " \[","" } | % { $_ -Replace "\],","" }
$Version = Get-Content -Path configure.ac | select -skip 4 -first 1 | % { $_ -Replace " \[","" } | % { $_ -Replace "\],","" }
$Prefix = ${Library}.Substring(3)

Get-Content -Path "include\${Library}.h.in" | Out-File -Encoding ascii "include\${Library}.h"
Get-Content -Path "include\${Library}\definitions.h.in" | % { $_ -Replace "@VERSION@","${Version}" } | Out-File -Encoding ascii "include\${Library}\definitions.h"
Get-Content -Path "include\${Library}\features.h.in" | % { $_ -Replace "@[A-Z0-9_]*@","0" } | Out-File -Encoding ascii "include\${Library}\features.h"
Get-Content -Path "include\${Library}\types.h.in" | % { $_ -Replace "@[A-Z0-9_]*@","0" } | Out-File -Encoding ascii "include\${Library}\types.h"
Get-Content -Path "common\types.h.in" | % { $_ -Replace "@PACKAGE@","${Library}" } | Out-File -Encoding ascii "common\types.h"
Get-Content -Path "${Library}\${Library}_definitions.h.in" | % { $_ -Replace "@VERSION@","${Version}" } | Out-File -Encoding ascii "${Library}\${Library}_definitions.h"
Get-Content -Path "${Library}\${Library}.rc.in" | % { $_ -Replace "@VERSION@","${Version}" } | Out-File -Encoding ascii "${Library}\${Library}.rc"

If (Test-Path "setup.cfg.in")
{
	Get-Content -Path "setup.cfg.in" | % { $_ -Replace "@VERSION@","${Version}" } | Out-File -Encoding ascii "setup.cfg"
}

If (Test-Path "${Prefix}.net")
{
	Get-Content -Path "${Prefix}.net\${Prefix}.net.rc.in" | % { $_ -Replace "@VERSION@","${Version}" } | Out-File -Encoding ascii "${Prefix}.net\${Prefix}.net.rc"
}

$NamePrefix = ""

ForEach (${DirectoryElement} in Get-ChildItem -Path "${Library}\*.l")
{
	$OutputFile = ${DirectoryElement} -Replace ".l$",".c"

	$NamePrefix = Split-Path -path ${DirectoryElement} -leaf
	$NamePrefix = ${NamePrefix} -Replace ".l$","_"

	Write-Host "Running: ${WinFlex} -Cf ${DirectoryElement}"

	# PowerShell will raise NativeCommandError if win_flex writes to stdout or stderr
	# therefore 2>&1 is added and the output is stored in a variable.
	$Output = Invoke-Expression -Command "& '${WinFlex}' -Cf ${DirectoryElement} 2>&1"
	Write-Host ${Output}

	# Moving manually since `win_flex -o filename' does not provide the expected behavior.
	Move-Item "lex.yy.c" ${OutputFile} -force
}

ForEach (${DirectoryElement} in Get-ChildItem -Path "${Library}\*.y")
{
	$OutputFile = ${DirectoryElement} -Replace ".y$",".c"

	Write-Host "Running: ${WinBison} -d -v -l -p ${NamePrefix} -o ${OutputFile} ${DirectoryElement}"

	# PowerShell will raise NativeCommandError if win_bison writes to stdout or stderr
	# therefore 2>&1 is added and the output is stored in a variable.
	$Output = Invoke-Expression -Command "& '${WinBison}' -d -v -l -p ${NamePrefix} -o ${OutputFile} ${DirectoryElement} 2>&1"
	Write-Host ${Output}
}


```

`autogen.sh`:

```sh
#!/bin/sh
# Script to generate ./configure using the autotools
#
# Version: 20230405

EXIT_SUCCESS=0;
EXIT_FAILURE=1;

BINDIR="/usr/bin";

if ! test -x "${BINDIR}/aclocal";
then
	BINDIR="/usr/local/bin";
fi
if ! test -x "${BINDIR}/aclocal";
then
	BINDIR="/usr/local/bin";
fi
if ! test -x "${BINDIR}/aclocal";
then
	# Default location of MacPorts installed binaries.
	BINDIR="/opt/local/bin";
fi
if ! test -x "${BINDIR}/aclocal";
then
	# Default location of 32-bit MSYS2-MinGW installed binaries.
	BINDIR="/mingw32/bin";
fi
if ! test -x "${BINDIR}/aclocal";
then
	# Default location of 64-bit MSYS2-MinGW installed binaries.
	BINDIR="/mingw64/bin";
fi

if ! test -x "${BINDIR}/aclocal";
then
	echo "Unable to find autotools";

	exit ${EXIT_FAILURE};
fi

ACLOCAL="${BINDIR}/aclocal";
AUTOCONF="${BINDIR}/autoconf";
AUTOHEADER="${BINDIR}/autoheader";
AUTOMAKE="${BINDIR}/automake";
AUTOPOINT="${BINDIR}/autopoint";
AUTORECONF="${BINDIR}/autoreconf";
LIBTOOLIZE="${BINDIR}/libtoolize";
PKGCONFIG="${BINDIR}/pkg-config";

if test "${OSTYPE}" = "msys";
then
	# Work-around for autopoint failing to detect gettext version
	# using func_trace (which is not available) on MSYS by writing
	# the gettext version to intl/VERSION.
	if ! test -d intl;
	then
		mkdir intl;
	fi
	GETTEXT_VERSION=`gettext --version | head -n1 | sed 's/^.* //'`;

	echo "gettext-${GETTEXT_VERSION}" > intl/VERSION;

elif ! test -x "${PKGCONFIG}";
then
	if test "${BINDIR}" != "/usr/bin";
	then
		# On OpenBSD most of the autotools are located in
		# /usr/local/bin while pkg-config is located in /usr/bin
		PKGCONFIG="/usr/bin/pkg-config";
	fi
	if ! test -x "${PKGCONFIG}";
	then
		echo "Unable to find: pkg-config";

		exit ${EXIT_FAILURE};
	fi
fi

if test -x "${AUTORECONF}";
then
	${AUTORECONF} --force --install
	if test $? -ne 0;
	then
		exit $?;
	fi
else
	if ! test -x "${ACLOCAL}";
	then
		echo "Unable to find: aclocal";

		exit ${EXIT_FAILURE};
	fi

	if ! test -x "${AUTOCONF}";
		then
		echo "Unable to find: autoconf";

		exit ${EXIT_FAILURE};
	fi

	if ! test -x "${AUTOHEADER}";
	then
		echo "Unable to find: autoheader";

		exit ${EXIT_FAILURE};
	fi

	if ! test -x "${AUTOMAKE}";
	then
		echo "Unable to find: automake";

		exit ${EXIT_FAILURE};
	fi

	if ! test -x "${AUTOPOINT}";
	then
		echo "Unable to find: autopoint";

		exit ${EXIT_FAILURE};
	fi

	if ! test -x "${LIBTOOLIZE}";
	then
		echo "Unable to find: libtoolize";

		exit ${EXIT_FAILURE};
	fi

	${AUTOPOINT} --force;
	if test $? -ne 0;
	then
		exit $?;
	fi

	${ACLOCAL} --force --install -I m4;
	if test $? -ne 0;
	then
		exit $?;
	fi

	${LIBTOOLIZE} --force;
	if test $? -ne 0;
	then
		exit $?;
	fi

	${AUTOHEADER} --force;
	if test $? -ne 0;
	then
		exit $?;
	fi

	${AUTOCONF} --force;
	if test $? -ne 0;
	then
		exit $?;
	fi

	${AUTOMAKE} --force --add-missing;
	if test $? -ne 0;
	then
		exit $?;
	fi

fi

exit ${EXIT_SUCCESS};


```

`build.ps1`:

```ps1
# Script that builds libmdmp
#
# Version: 20230411

Param (
	[string]$Configuration = ${Env:Configuration},
	[string]$Platform = ${Env:Platform},
	[string]$PlatformToolset = "",
	[string]$PythonPath = "C:\Python311",
	[string]$VisualStudioVersion = "",
	[string]$VSToolsOptions = "--extend-with-x64",
	[string]$VSToolsPath = "..\vstools"
)

$ExitSuccess = 0
$ExitFailure = 1

$Python = "${PythonPath}\python.exe"

$Git = "git"
$GitUrl = "https://github.com/libyal/vstools.git"

$MSVSCppConvert = "${VSToolsPath}\scripts\msvscpp-convert.py"

If (-Not (Test-Path $Python))
{
    Write-Host "Missing Python: ${Python}" -foreground Red

    Exit ${ExitFailure}
}
If (-Not (Test-Path ${VSToolsPath}))
{
	# PowerShell will raise NativeCommandError if git writes to stdout or stderr
	# therefore 2>&1 is added and the output is stored in a variable.
	$Output = Invoke-Expression -Command "${Git} clone ${GitUrl} ${VSToolsPath} 2>&1" | %{ "$_" }
}
Else
{
	Push-Location "${VSToolsPath}"

	Try
	{
		# Make sure vstools are up to date.
		$Output = Invoke-Expression -Command "${Git} pull 2>&1" | %{ "$_" }
	}
	Finally
	{
		Pop-Location
	}
}
If (-Not (Test-Path ${MSVSCppConvert}))
{
	Write-Host "Missing msvscpp-convert.py: ${MSVSCppConvert}" -foreground Red

	Exit ${ExitFailure}
}
If (-Not ${VisualStudioVersion})
{
	$VisualStudioVersion = "2022"

	Write-Host "Visual Studio version not set defauting to: ${VisualStudioVersion}" -foreground Red
}
If ((${VisualStudioVersion} -ne "2008") -And (${VisualStudioVersion} -ne "2010") -And (${VisualStudioVersion} -ne "2012") -And (${VisualStudioVersion} -ne "2013") -And (${VisualStudioVersion} -ne "2015") -And (${VisualStudioVersion} -ne "2017") -And (${VisualStudioVersion} -ne "2019") -And (${VisualStudioVersion} -ne "2022"))
{
	Write-Host "Unsupported Visual Studio version: ${VisualStudioVersion}" -foreground Red

	Exit ${ExitFailure}
}
$MSBuild = ""

If (${VisualStudioVersion} -eq "2008")
{
	$MSBuild = "C:\Windows\Microsoft.NET\Framework\v3.5\MSBuild.exe"
}
ElseIf ((${VisualStudioVersion} -eq "2010") -Or (${VisualStudioVersion} -eq "2012"))
{
	$MSBuild = "C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe"
}
ElseIf (${VisualStudioVersion} -eq "2013")
{
	$MSBuild = "C:\Program Files (x86)\MSBuild\12.0\Bin\MSBuild.exe"
}
ElseIf (${VisualStudioVersion} -eq "2015")
{
	$MSBuild = "C:\Program Files (x86)\MSBuild\14.0\Bin\MSBuild.exe"
}
ElseIf (${VisualStudioVersion} -eq "2017")
{
	$Results = Get-ChildItem -Path "C:\Program Files\Microsoft Visual Studio\${VisualStudioVersion}\*\MSBuild\15.0\Bin\MSBuild.exe" -Recurse -ErrorAction SilentlyContinue -Force

	If ($Results.Count -eq 0)
	{
		$Results = Get-ChildItem -Path "C:\Program Files (x86)\Microsoft Visual Studio\${VisualStudioVersion}\*\MSBuild\15.0\Bin\MSBuild.exe" -Recurse -ErrorAction SilentlyContinue -Force
	}
	If ($Results.Count -gt 0)
	{
		$MSBuild = $Results[0].FullName
	}
}
ElseIf (${VisualStudioVersion} -eq "2019" -Or ${VisualStudioVersion} -eq "2022")
{
	$Results = Get-ChildItem -Path "C:\Program Files\Microsoft Visual Studio\${VisualStudioVersion}\*\MSBuild\Current\Bin\MSBuild.exe" -Recurse -ErrorAction SilentlyContinue -Force

	If ($Results.Count -eq 0)
	{
		$Results = Get-ChildItem -Path "C:\Program Files (x86)\Microsoft Visual Studio\${VisualStudioVersion}\*\MSBuild\Current\Bin\MSBuild.exe" -Recurse -ErrorAction SilentlyContinue -Force
	}
	If ($Results.Count -gt 0)
	{
		$MSBuild = $Results[0].FullName
	}
}
If (-Not ${MSBuild})
{
	Write-Host "Unable to determine path to msbuild.exe" -foreground Red

	Exit ${ExitFailure}
}
ElseIf (-Not (Test-Path ${MSBuild}))
{
	Write-Host "Missing msbuild.exe: ${MSBuild}" -foreground Red

	Exit ${ExitFailure}
}

If (${VisualStudioVersion} -eq "2008")
{
	$VSSolutionPath = "msvscpp"
}
Else
{
	$VSSolutionPath = "vs${VisualStudioVersion}"

	If (-Not (Test-Path "${VSSolutionPath}"))
	{
		${Env:PYTHONPATH} = ${VSToolsPath}

		Invoke-Expression -Command "& '${Python}' ${MSVSCppConvert} --output-format ${VisualStudioVersion} ${VSToolsOptions} msvscpp\libmdmp.sln 2>&1" | %{ "$_" }
	}
}
$VSSolutionFile = "${VSSolutionPath}\libmdmp.sln"

If (-Not (Test-Path "${VSSolutionFile}"))
{
	Write-Host "Missing Visual Studio ${VisualStudioVersion} solution file: ${VSSolutionFile}" -foreground Red

	Exit ${ExitFailure}
}
If (-Not ${Configuration})
{
	$Configuration = "Release"

	Write-Host "Configuration not set defauting to: ${Configuration}"
}
If (-Not ${Platform})
{
	$Platform = "Win32"

	Write-Host "Platform not set defauting to: ${Platform}"
}
$PlatformToolset = ""

If (-Not ${PlatformToolset})
{
	If (${VisualStudioVersion} -eq "2015")
	{
		$PlatformToolset = "v140"
	}
	ElseIf (${VisualStudioVersion} -eq "2017")
	{
		$PlatformToolset = "v141"
	}
	ElseIf (${VisualStudioVersion} -eq "2019")
	{
		$PlatformToolset = "v142"
	}
	ElseIf (${VisualStudioVersion} -eq "2022")
	{
		$PlatformToolset = "v143"
	}
	Write-Host "PlatformToolset not set defauting to: ${PlatformToolset}"
}
$MSBuildOptions = "/verbosity:quiet /target:Build /property:Configuration=${Configuration},Platform=${Platform}"

If (${PlatformToolset})
{
	$MSBuildOptions = "${MSBuildOptions} /property:PlatformToolset=${PlatformToolset}"
}
If (${Env:APPVEYOR} -eq "True")
{
	Invoke-Expression -Command "& '${MSBuild}' ${MSBuildOptions} ${VSSolutionFile} /logger:'C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll' 2>&1" | %{ "$_" }
}
Else
{
	Invoke-Expression -Command "& '${MSBuild}' ${MSBuildOptions} ${VSSolutionFile} 2>&1" | %{ "$_" }
}

Exit ${ExitSuccess}

```

`common/Makefile.am`:

```am
AM_CPPFLAGS = -I$(top_srcdir)/include

EXTRA_DIST = \
	byte_stream.h \
	common.h \
	config.h \
	config_borlandc.h \
	config_msc.h \
	config_winapi.h \
	file_stream.h \
	memory.h \
	narrow_string.h \
	system_string.h \
	types.h \
	types.h.in \
	wide_string.h

MAINTAINERCLEANFILES = \
	Makefile.in

distclean: clean
	-rm -f config.h
	-rm -f types.h
	-rm -f Makefile


```

`common/byte_stream.h`:

```h
/*
 * Byte stream functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _BYTE_STREAM_H )
#define _BYTE_STREAM_H

#include "common.h"
#include "types.h"

#if defined( __cplusplus )
extern "C" {
#endif

#define _BYTE_STREAM_HOST_IS_ENDIAN_BIG		( *((uint32_t *) "\x01\x02\x03\x04" ) == 0x01020304 )
#define _BYTE_STREAM_HOST_IS_ENDIAN_LITTLE	( *((uint32_t *) "\x01\x02\x03\x04" ) == 0x04030201 )
#define _BYTE_STREAM_HOST_IS_ENDIAN_MIDDLE	( *((uint32_t *) "\x01\x02\x03\x04" ) == 0x02010403 )

#define _BYTE_STREAM_ENDIAN_BIG			(uint8_t) 'b'
#define _BYTE_STREAM_ENDIAN_LITTLE		(uint8_t) 'l'
#define _BYTE_STREAM_ENDIAN_MIDDLE		(uint8_t) 'm'

typedef union byte_stream_float32
{
	float floating_point;
	uint32_t integer;

} byte_stream_float32_t;

typedef union byte_stream_float64
{
	double floating_point;
	uint64_t integer;

} byte_stream_float64_t;

#define byte_stream_copy_to_uint16_big_endian( byte_stream, value ) \
	( value )   = ( byte_stream )[ 0 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 1 ];

#define byte_stream_copy_to_uint16_little_endian( byte_stream, value ) \
	( value )   = ( byte_stream )[ 1 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 0 ];

#define byte_stream_copy_to_uint24_big_endian( byte_stream, value ) \
	( value )   = ( byte_stream )[ 0 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 1 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 2 ];

#define byte_stream_copy_to_uint24_little_endian( byte_stream, value ) \
	( value )   = ( byte_stream )[ 2 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 1 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 0 ];

#define byte_stream_copy_to_uint32_big_endian( byte_stream, value ) \
	( value )   = ( byte_stream )[ 0 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 1 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 2 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 3 ];

#define byte_stream_copy_to_uint32_little_endian( byte_stream, value ) \
	( value )   = ( byte_stream )[ 3 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 2 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 1 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 0 ];

#define byte_stream_copy_to_uint48_big_endian( byte_stream, value ) \
	( value )   = ( byte_stream )[ 0 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 1 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 2 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 3 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 4 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 5 ];

#define byte_stream_copy_to_uint48_little_endian( byte_stream, value ) \
	( value )  |= ( byte_stream )[ 5 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 4 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 3 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 2 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 1 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 0 ];

#define byte_stream_copy_to_uint64_big_endian( byte_stream, value ) \
	( value )   = ( byte_stream )[ 0 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 1 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 2 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 3 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 4 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 5 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 6 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 7 ];

#define byte_stream_copy_to_uint64_little_endian( byte_stream, value ) \
	( value )   = ( byte_stream )[ 7 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 6 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 5 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 4 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 3 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 2 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 1 ]; \
	( value ) <<= 8; \
	( value )  |= ( byte_stream )[ 0 ];

#define byte_stream_copy_from_uint16_big_endian( byte_stream, value ) \
	( byte_stream )[ 0 ] = (uint8_t) ( ( ( value ) >> 8 ) & 0x0ff ); \
	( byte_stream )[ 1 ] = (uint8_t) ( ( value ) & 0x0ff )

#define byte_stream_copy_from_uint16_little_endian( byte_stream, value ) \
	( byte_stream )[ 1 ] = (uint8_t) ( ( ( value ) >> 8 ) & 0x0ff ); \
	( byte_stream )[ 0 ] = (uint8_t) ( ( value ) & 0x0ff )

#define byte_stream_copy_from_uint24_big_endian( byte_stream, value ) \
	( byte_stream )[ 0 ] = (uint8_t) ( ( ( value ) >> 16 ) & 0x0ff ); \
	( byte_stream )[ 1 ] = (uint8_t) ( ( ( value ) >> 8 ) & 0x0ff ); \
	( byte_stream )[ 2 ] = (uint8_t) ( ( value ) & 0x0ff )

#define byte_stream_copy_from_uint24_little_endian( byte_stream, value ) \
	( byte_stream )[ 2 ] = (uint8_t) ( ( ( value ) >> 16 ) & 0x0ff ); \
	( byte_stream )[ 1 ] = (uint8_t) ( ( ( value ) >> 8 ) & 0x0ff ); \
	( byte_stream )[ 0 ] = (uint8_t) ( ( value ) & 0x0ff )

#define byte_stream_copy_from_uint32_big_endian( byte_stream, value ) \
	( byte_stream )[ 0 ] = (uint8_t) ( ( ( value ) >> 24 ) & 0x0ff ); \
	( byte_stream )[ 1 ] = (uint8_t) ( ( ( value ) >> 16 ) & 0x0ff ); \
	( byte_stream )[ 2 ] = (uint8_t) ( ( ( value ) >> 8 ) & 0x0ff ); \
	( byte_stream )[ 3 ] = (uint8_t) ( ( value ) & 0x0ff )

#define byte_stream_copy_from_uint32_little_endian( byte_stream, value ) \
	( byte_stream )[ 3 ] = (uint8_t) ( ( ( value ) >> 24 ) & 0x0ff ); \
	( byte_stream )[ 2 ] = (uint8_t) ( ( ( value ) >> 16 ) & 0x0ff ); \
	( byte_stream )[ 1 ] = (uint8_t) ( ( ( value ) >> 8 ) & 0x0ff ); \
	( byte_stream )[ 0 ] = (uint8_t) ( ( value ) & 0x0ff )

#define byte_stream_copy_from_uint48_big_endian( byte_stream, value ) \
	( byte_stream )[ 0 ] = (uint8_t) ( ( ( value ) >> 40 ) & 0x0ff ); \
	( byte_stream )[ 1 ] = (uint8_t) ( ( ( value ) >> 32 ) & 0x0ff ); \
	( byte_stream )[ 2 ] = (uint8_t) ( ( ( value ) >> 24 ) & 0x0ff ); \
	( byte_stream )[ 3 ] = (uint8_t) ( ( ( value ) >> 16 ) & 0x0ff ); \
	( byte_stream )[ 4 ] = (uint8_t) ( ( ( value ) >> 8 ) & 0x0ff ); \
	( byte_stream )[ 5 ] = (uint8_t) ( ( value ) & 0x0ff )

#define byte_stream_copy_from_uint48_little_endian( byte_stream, value ) \
	( byte_stream )[ 5 ] = (uint8_t) ( ( ( value ) >> 40 ) & 0x0ff ); \
	( byte_stream )[ 4 ] = (uint8_t) ( ( ( value ) >> 32 ) & 0x0ff ); \
	( byte_stream )[ 3 ] = (uint8_t) ( ( ( value ) >> 24 ) & 0x0ff ); \
	( byte_stream )[ 2 ] = (uint8_t) ( ( ( value ) >> 16 ) & 0x0ff ); \
	( byte_stream )[ 1 ] = (uint8_t) ( ( ( value ) >> 8 ) & 0x0ff ); \
	( byte_stream )[ 0 ] = (uint8_t) ( ( value ) & 0x0ff )

#define byte_stream_copy_from_uint64_big_endian( byte_stream, value ) \
	( byte_stream )[ 0 ] = (uint8_t) ( ( ( value ) >> 56 ) & 0x0ff ); \
	( byte_stream )[ 1 ] = (uint8_t) ( ( ( value ) >> 48 ) & 0x0ff ); \
	( byte_stream )[ 2 ] = (uint8_t) ( ( ( value ) >> 40 ) & 0x0ff ); \
	( byte_stream )[ 3 ] = (uint8_t) ( ( ( value ) >> 32 ) & 0x0ff ); \
	( byte_stream )[ 4 ] = (uint8_t) ( ( ( value ) >> 24 ) & 0x0ff ); \
	( byte_stream )[ 5 ] = (uint8_t) ( ( ( value ) >> 16 ) & 0x0ff ); \
	( byte_stream )[ 6 ] = (uint8_t) ( ( ( value ) >> 8 ) & 0x0ff ); \
	( byte_stream )[ 7 ] = (uint8_t) ( ( value ) & 0x0ff )

#define byte_stream_copy_from_uint64_little_endian( byte_stream, value ) \
	( byte_stream )[ 7 ] = (uint8_t) ( ( ( value ) >> 56 ) & 0x0ff ); \
	( byte_stream )[ 6 ] = (uint8_t) ( ( ( value ) >> 48 ) & 0x0ff ); \
	( byte_stream )[ 5 ] = (uint8_t) ( ( ( value ) >> 40 ) & 0x0ff ); \
	( byte_stream )[ 4 ] = (uint8_t) ( ( ( value ) >> 32 ) & 0x0ff ); \
	( byte_stream )[ 3 ] = (uint8_t) ( ( ( value ) >> 24 ) & 0x0ff ); \
	( byte_stream )[ 2 ] = (uint8_t) ( ( ( value ) >> 16 ) & 0x0ff ); \
	( byte_stream )[ 1 ] = (uint8_t) ( ( ( value ) >> 8 ) & 0x0ff ); \
	( byte_stream )[ 0 ] = (uint8_t) ( ( value ) & 0x0ff )

#define byte_stream_bit_rotate_left_8bit( byte_stream, number_of_bits ) \
	( ( ( byte_stream ) << ( number_of_bits ) ) | ( ( byte_stream ) >> ( 8 - ( number_of_bits ) ) ) )

#define byte_stream_bit_rotate_right_8bit( byte_stream, number_of_bits ) \
	( ( ( byte_stream ) >> ( number_of_bits ) ) | ( ( byte_stream ) << ( 8 - ( number_of_bits ) ) ) )

#define byte_stream_bit_rotate_left_16bit( byte_stream, number_of_bits ) \
	( ( ( byte_stream ) << ( number_of_bits ) ) | ( ( byte_stream ) >> ( 16 - ( number_of_bits ) ) ) )

#define byte_stream_bit_rotate_right_16bit( byte_stream, number_of_bits ) \
	( ( ( byte_stream ) >> ( number_of_bits ) ) | ( ( byte_stream ) << ( 16 - ( number_of_bits ) ) ) )

#define byte_stream_bit_rotate_left_32bit( byte_stream, number_of_bits ) \
	( ( ( byte_stream ) << ( number_of_bits ) ) | ( ( byte_stream ) >> ( 32 - ( number_of_bits ) ) ) )

#define byte_stream_bit_rotate_right_32bit( byte_stream, number_of_bits ) \
	( ( ( byte_stream ) >> ( number_of_bits ) ) | ( ( byte_stream ) << ( 32 - ( number_of_bits ) ) ) )

#define byte_stream_bit_rotate_left_64bit( byte_stream, number_of_bits ) \
	( ( ( byte_stream ) << ( number_of_bits ) ) | ( ( byte_stream ) >> ( 64 - ( number_of_bits ) ) ) )

#define byte_stream_bit_rotate_right_64bit( byte_stream, number_of_bits ) \
	( ( ( byte_stream ) >> ( number_of_bits ) ) | ( ( byte_stream ) << ( 64 - ( number_of_bits ) ) ) )

#define byte_stream_bit_rotate_left( value, number_of_bits ) \
	( ( ( value ) << ( number_of_bits ) ) | ( ( value ) >> ( ( sizeof( value ) << 3 ) - ( number_of_bits ) ) ) )

#define byte_stream_bit_rotate_right( value, number_of_bits ) \
	( ( ( value ) >> ( number_of_bits ) ) | ( ( value ) << ( ( sizeof( value ) << 3 ) - ( number_of_bits ) ) ) )

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _BYTE_STREAM_H ) */


```

`common/common.h`:

```h
/*
 * Common include file
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _COMMON_H )
#define _COMMON_H

#if defined( HAVE_CONFIG_H )
#include "config.h"
#endif

/* Include the Borland/CodeGear C++ Builder compiler specific configuration
 */
#if defined( __BORLANDC__ )
#include "config_borlandc.h"

/* Include the Microsoft Visual Studio C++ compiler specific configuration
 */
#elif defined( _MSC_VER )
#include "config_msc.h"
#endif

#include "config_winapi.h"

#endif /* !defined( _COMMON_H ) */


```

`common/config_borlandc.h`:

```h
/*
 * Configuration for the Borland/CodeGear C++ Builder compiler
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _CONFIG_BORLANDC_H )
#define _CONFIG_BORLANDC_H

#endif /* !defined( _CONFIG_BORLANDC_H ) */


```

`common/config_msc.h`:

```h
/*
 * Configuration for the Microsoft Visual Studio C++ compiler
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _CONFIG_MSC_H )
#define _CONFIG_MSC_H

/* Disable warning C4127: conditional expression is constant
 */
#pragma warning( disable : 4127 )

/* Disable warning C4201: nonstandard extension used : nameless struct/union
 */
#pragma warning( disable : 4201 )

#endif /* !defined( _CONFIG_MSC_H ) */


```

`common/config_winapi.h`:

```h
/*
 * Configuration file for WINAPI
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _CONFIG_WINAPI_H )
#define _CONFIG_WINAPI_H

/* Define the earliest supported WINAPI version
#define WINVER				0x0501
 */

/* If necessary make sure WINAPI is defined
 */
#if defined( HAVE_WINDOWS_H ) || defined( __BORLANDC__ ) || defined( _MSC_VER )
#include <windows.h>
#endif

#if defined( WINAPI )

/* Define to the address where bug reports for this package should be sent.
 */
#define PACKAGE_BUGREPORT		"joachim.metz@gmail.com"

/* Define the size of the integer for WINAPI
 */
#if !defined( SIZEOF_INT )
#define SIZEOF_INT			4
#endif

/* Define the size of size_t for WINAPI
 * Do not define when pyconfig.h has been included via python.h
 */
#if !defined( HAVE_PYCONFIG_H )

#if !defined( SIZEOF_SIZE_T )
#if __WORDSIZE == 64
#define SIZEOF_SIZE_T			8
#else
#define SIZEOF_SIZE_T			4
#endif
#endif

#endif /* !defined( HAVE_PYCONFIG_H ) */

/* Define the size of the wide character for WINAPI
 */
#if !defined( SIZEOF_WCHAR_T )
#define SIZEOF_WCHAR_T			2
#endif

/* Enable the DllMain function
 */
#define HAVE_DLLMAIN			1

/* Enable verbose output
#define HAVE_VERBOSE_OUTPUT		1
 */

/* Enable debug output
#define HAVE_DEBUG_OUTPUT		1
 */

/* Enable both the narrow and wide character functions
 */
#if !defined( HAVE_WIDE_CHARACTER_TYPE )
#define HAVE_WIDE_CHARACTER_TYPE	1
#endif

/* If not controlled by config.h enable multi-thread support
 */
#if !defined( HAVE_CONFIG_H ) && !defined( HAVE_MULTI_THREAD_SUPPORT )
#define HAVE_MULTI_THREAD_SUPPORT	1
#endif

#endif /* defined( WINAPI ) */

#endif /* !defined( _CONFIG_WINAPI_H ) */


```

`common/file_stream.h`:

```h
/*
 * FILE stream functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _FILE_STREAM_H )
#define _FILE_STREAM_H

#include "common.h"

#if defined( HAVE_GLIB_H )
#include <glib.h>
#include <glib/gstdio.h>
#endif

#include <stdio.h>

#if defined( __cplusplus )
extern "C" {
#endif

#define FILE_STREAM_OPEN_APPEND			"a"
#define FILE_STREAM_OPEN_READ			"r"
#define FILE_STREAM_OPEN_WRITE			"w"

#if defined( WINAPI )
#define FILE_STREAM_BINARY_OPEN_APPEND		"ab"
#define FILE_STREAM_BINARY_OPEN_READ		"rb"
#define FILE_STREAM_BINARY_OPEN_WRITE		"wb"

#else
#define FILE_STREAM_BINARY_OPEN_APPEND		"a"
#define FILE_STREAM_BINARY_OPEN_READ		"r"
#define FILE_STREAM_BINARY_OPEN_WRITE		"w"

#endif

/* narrow character FILE stream open
 */
#if defined( HAVE_GLIB_H )
#define file_stream_open( filename, mode ) \
	g_fopen( filename, mode )

#elif defined( HAVE_FOPEN ) || defined( WINAPI )
#define file_stream_open( filename, mode ) \
	fopen( filename, mode )
#endif

/* wide character FILE stream open
 */
#if defined( WINAPI )
#define file_stream_open_wide( filename, mode ) \
	_wfopen( filename, mode )
#endif

/* FILE stream close
 */
#if defined( HAVE_FCLOSE ) || defined( WINAPI )
#define file_stream_close( stream ) \
	fclose( stream )
#endif

/* FILE stream read
 */
#if defined( HAVE_FREAD ) || defined( WINAPI )
#define file_stream_read( stream, data, size ) \
	fread( data, 1, size, stream )
#endif

/* FILE stream write
 */
#if defined( HAVE_FWRITE ) || defined( WINAPI )
#define file_stream_write( stream, data, size ) \
	fwrite( data, 1, size, stream )
#endif

/* FILE stream seek
 */
#if defined( WINAPI )
#define file_stream_seek_offset( stream, offset, whence ) \
	fseek( stream, offset, whence )

#elif defined( HAVE_FSEEKO )
#define file_stream_seek_offset( stream, offset, whence ) \
	fseeko( stream, offset, whence )

#elif defined( HAVE_FSEEKO64 )
#define file_stream_seek_offset( stream, offset, whence ) \
	fseeko64( stream, offset, whence )
#endif

/* End of FILE stream
 */
#if defined( HAVE_FEOF ) || defined( WINAPI )
#define file_stream_at_end( stream ) \
        feof( stream )
#endif

/* Get narrow character string from FILE stream
 */
#if defined( HAVE_FGETS ) || defined( WINAPI )
#define file_stream_get_string( stream, string, size ) \
        fgets( string, size, stream )
#endif

/* Get wide characters string from FILE stream
 */
#if defined( HAVE_FGETWS ) || defined( WINAPI )
#define file_stream_get_string_wide( stream, string, size ) \
        fgetws( string, size, stream )
#endif

/* Variable arguments formatted print to stream function
 */
#if defined( HAVE_GLIB_H )
#define file_stream_vfprintf( stream, format, ... ) \
	g_vfprintf( stream, format, __VA_ARGS__ )

/* Borland BCC previous to version 5.6.0 cannot handle the macro form: MACRO( ... )
 */
#elif defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define file_stream_vfprintf \
	vfprintf

#elif defined( HAVE_VFPRINTF ) || defined( WINAPI )
#define file_stream_vfprintf( stream, format, ... ) \
	vfprintf( stream, format, __VA_ARGS__ )
#endif

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _FILE_STREAM_H ) */


```

`common/memory.h`:

```h
/*
 * Memory functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MEMORY_H )
#define _MEMORY_H

#include "common.h"

#if defined( HAVE_GLIB_H )
#include <glib.h>
#endif

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#if defined( HAVE_STRING_H ) || defined( WINAPI )
#include <string.h>
#endif

#if defined( __cplusplus )
extern "C" {
#endif

/* Note that 128 MiB is an arbitrary selected upper limit here
 */
#define MEMORY_MAXIMUM_ALLOCATION_SIZE \
	( 128 * 1024 * 1024 )

/* Memory allocation
 */
#if defined( HAVE_GLIB_H )
#define memory_allocate( size ) \
	g_malloc( (gsize) size )

#elif defined( WINAPI )
#define memory_allocate( size ) \
	HeapAlloc( GetProcessHeap(), 0, (SIZE_T) size )

#elif defined( HAVE_MALLOC )
#define memory_allocate( size ) \
	malloc( size )
#endif

#define memory_allocate_structure( type ) \
	(type *) memory_allocate( sizeof( type ) )

#define memory_allocate_structure_as_value( type ) \
	(intptr_t *) memory_allocate( sizeof( type ) )

/* Memory reallocation
 */
#if defined( HAVE_GLIB_H )
#define memory_reallocate( buffer, size ) \
	g_realloc( (gpointer) buffer, (gsize) size )

#elif defined( WINAPI )
/* HeapReAlloc does not allocate empty (NULL) buffers as realloc does
 */
#define memory_reallocate( buffer, size ) \
	( buffer == NULL ) ? \
	HeapAlloc( GetProcessHeap(), 0, (SIZE_T) size ) : \
	HeapReAlloc( GetProcessHeap(), 0, (LPVOID) buffer, (SIZE_T) size )

#elif defined( HAVE_REALLOC )
#define memory_reallocate( buffer, size ) \
	realloc( (void *) buffer, size )
#endif

/* Memory free
 */
#if defined( HAVE_GLIB_H )
#define memory_free( buffer ) \
	g_free( (gpointer) buffer )

#elif defined( WINAPI )
#define memory_free( buffer ) \
	( buffer == NULL ) ? TRUE : HeapFree( GetProcessHeap(), 0, (LPVOID) buffer )

#elif defined( HAVE_FREE )
#define memory_free( buffer ) \
	free( (void *) buffer )
#endif

/* Memory compare
 */
#if defined( HAVE_MEMCMP ) || defined( WINAPI )
#define memory_compare( buffer1, buffer2, size ) \
	memcmp( (const void *) buffer1, (const void *) buffer2, size )
#endif

/* Memory copy
 */
#if defined( HAVE_MEMCPY ) || defined( WINAPI )
#define memory_copy( destination, source, count ) \
	memcpy( (void *) destination, (void *) source, count )
#endif

/* Memory set
 */
#if defined( HAVE_MEMSET ) || defined( WINAPI )
#define memory_set( buffer, value, count ) \
	memset( (void *) buffer, (int) value, count )
#endif

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _MEMORY_H ) */


```

`common/narrow_string.h`:

```h
/*
 * Narrow character string functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _NARROW_STRING_H )
#define _NARROW_STRING_H

#include "common.h"
#include "memory.h"
#include "types.h"

#if defined( HAVE_GLIB_H )
#include <glib.h>
#endif

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#if defined( HAVE_STRING_H ) || defined( WINAPI )
#include <string.h>
#endif

#if defined( __cplusplus )
extern "C" {
#endif

/* String allocation
 */
#define narrow_string_allocate( size ) \
	(char *) memory_allocate( sizeof( char ) * ( size ) )

/* String reallocation
 */
#define narrow_string_reallocate( string, size ) \
	(char *) memory_reallocate( string, ( sizeof( char ) * ( size ) ) )

/* String length
 */
#if defined( HAVE_STRLEN ) || defined( WINAPI )
#define narrow_string_length( string ) \
	strlen( string )
#endif

/* String compare
 */
#if defined( HAVE_MEMCMP ) || defined( WINAPI )
#define narrow_string_compare( string1, string2, size ) \
	memcmp( (void *) string1, (void *) string2, size )

#elif defined( HAVE_STRNCMP )
#define narrow_string_compare( string1, string2, size ) \
	strncmp( string1, string2, size )
#endif

/* Caseless string compare
 */
#if defined( HAVE_GLIB_H )
#define narrow_string_compare_no_case( string1, string2, size ) \
	g_ascii_strncasecmp( string1, string2, size )

#elif defined( _MSC_VER )
#define narrow_string_compare_no_case( string1, string2, size ) \
	_strnicmp( string1, string2, size )

#elif ( defined( WINAPI ) && !defined( __CYGWIN__ ) ) || defined( HAVE_STRNICMP )
#define narrow_string_compare_no_case( string1, string2, size ) \
	strnicmp( string1, string2, size )

#elif defined( HAVE_STRNCASECMP )
#define narrow_string_compare_no_case( string1, string2, size ) \
	strncasecmp( string1, string2, size )

#elif defined( HAVE_STRCASECMP )
#define narrow_string_compare_no_case( string1, string2, size ) \
	strcasecmp( string1, string2 )
#endif

/* String copy
 */
#if defined( HAVE_MEMCPY ) || defined( WINAPI )
#define narrow_string_copy( destination, source, size ) \
	(char *) memcpy( (void *) destination, (void *) source, size )

#elif defined( HAVE_STRNCPY )
#define narrow_string_copy( destination, source, size ) \
	strncpy( destination, source, size )
#endif

/* String character search
 */
#if defined( HAVE_MEMCHR ) || defined( WINAPI )
#define narrow_string_search_character( string, character, size ) \
	(char *) memchr( (void *) string, (int) character, size )

#elif defined( HAVE_STRCHR )
#define narrow_string_search_character( string, character, size ) \
	strchr( string, (int) character )
#endif

/* String reverse character search
 */
#if defined( HAVE_MEMRCHR ) && ( HAVE_DECL_MEMRCHR == 1 )
#define narrow_string_search_character_reverse( string, character, size ) \
	(char *) memrchr( (void *) string, (int) character, size )

#elif defined( HAVE_STRRCHR ) || defined( WINAPI )
/* (void)(size) is used to suppress unused variable warnings */
#define narrow_string_search_character_reverse( string, character, size ) \
	strrchr( string, (int) character ); (void)(size)
#endif

/* String sub-string search
 */
#if defined( HAVE_STRSTR ) || defined( WINAPI )
#define narrow_string_search_string( string, substring, size ) \
	strstr( string, substring )
#endif

/* String formatted print (snprintf)
 */
#if defined( HAVE_GLIB_H )
#define narrow_string_snprintf( target, size, ... ) \
	g_snprintf( target, size, __VA_ARGS__ )

#elif defined( _MSC_VER )
#define narrow_string_snprintf( target, size, ... ) \
	sprintf_s( target, size, __VA_ARGS__ )

#elif defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define narrow_string_snprintf \
	snprintf

#elif defined( HAVE_SNPRINTF ) || defined( WINAPI )
#define narrow_string_snprintf( target, size, ... ) \
	snprintf( target, size, __VA_ARGS__ )
#endif

/* String input conversion (sscanf)
 */
#if defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define narrow_string_sscanf \
	sscanf

#elif defined( HAVE_SSCANF ) || defined( WINAPI )
#define narrow_string_sscanf( string, format, ... ) \
	sscanf( string, format, __VA_ARGS__ )
#endif

/* Variable arguments formatted print to string function (vsnprintf)
 */
#if defined( HAVE_GLIB_H )
#define narrow_string_vsnprintf( string, size, format, ... ) \
	g_vsnprintf( string, size, format, __VA_ARGS__ )

#elif defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define narrow_string_vsnprintf \
	vsnprintf

#elif defined( HAVE_VSNPRINTF ) || defined( WINAPI )
#define narrow_string_vsnprintf( string, size, format, ... ) \
	vsnprintf( string, size, format, __VA_ARGS__ )
#endif

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _NARROW_STRING_H ) */


```

`common/system_string.h`:

```h
/*
 * System character string functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _SYSTEM_STRING_H )
#define _SYSTEM_STRING_H

#include "common.h"
#include "narrow_string.h"
#include "types.h"
#include "wide_string.h"

#if defined( _cplusplus )
extern "C" {
#endif

#if defined( HAVE_WIDE_SYSTEM_CHARACTER )

#if SIZEOF_WCHAR_T != 2
#error Unsupported wide system character size
#endif

/* Intermediate version of the macro required
 * for correct evaluation predefined string
 */
#define _SYSTEM_STRING_INTERMEDIATE( string ) \
	L ## string

#define _SYSTEM_STRING( string ) \
	_SYSTEM_STRING_INTERMEDIATE( string )

#define system_string_allocate( size ) \
	wide_string_allocate( size )

#define system_string_reallocate( string, size ) \
	wide_string_reallocate( string, size )

#define system_string_compare( destination, source, size ) \
	wide_string_compare( destination, source, size )

#define system_string_compare_no_case( destination, source, size ) \
	wide_string_compare_no_case( destination, source, size )

#define system_string_copy( destination, source, size ) \
	wide_string_copy( destination, source, size )

#define system_string_length( string ) \
	wide_string_length( string )

#define system_string_search_character( string, character, size ) \
	wide_string_search_character( string, character, size )

#define system_string_search_character_reverse( string, character, size ) \
	wide_string_search_character_reverse( string, character, size )

#define system_string_search_string( string, substring, size ) \
	wide_string_search_string( string, substring, size )

#if defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define system_string_sprintf \
	wide_string_snwprintf

#else
#define system_string_sprintf( string, size, format, ... ) \
	wide_string_snwprintf( string, size, format, __VA_ARGS__ )
#endif

#if defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define system_string_vsnprintf \
	wide_string_vsnwprintf

#else
#define system_string_vsnprintf( string, size, format, ... ) \
	wide_string_vsnwprintf( string, size, format, __VA_ARGS__ )
#endif

#else

#define _SYSTEM_STRING( string ) \
	string

#define system_string_allocate( size ) \
	narrow_string_allocate( size )

#define system_string_reallocate( string, size ) \
	narrow_string_reallocate( string, size )

#define system_string_compare( destination, source, size ) \
	narrow_string_compare( destination, source, size )

#define system_string_compare_no_case( destination, source, size ) \
	narrow_string_compare_no_case( destination, source, size )

#define system_string_copy( destination, source, size ) \
	narrow_string_copy( destination, source, size )

#define system_string_length( string ) \
	narrow_string_length( string )

#define system_string_search_character( string, character, size ) \
	narrow_string_search_character( string, character, size )

#define system_string_search_character_reverse( string, character, size ) \
	narrow_string_search_character_reverse( string, character, size )

#define system_string_search_string( string, substring, size ) \
	narrow_string_search_string( string, substring, size )

#if defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define system_string_sprintf \
	narrow_string_snprintf

#else
#define system_string_sprintf( string, size, format, ... ) \
	narrow_string_snprintf( string, size, format, __VA_ARGS__ )
#endif

#if defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define system_string_vsnprintf \
	narrow_string_vsnprintf

#else
#define system_string_vsnprintf( string, size, format, ... ) \
	narrow_string_vsnprintf( string, size, format, __VA_ARGS__ )
#endif

#endif /* defined( HAVE_WIDE_SYSTEM_CHARACTER ) */

/* For backwards compatibility */
#define system_string_vsprintf system_string_vsnprintf

#if defined( _cplusplus )
}
#endif

#endif /* !defined( _SYSTEM_STRING_H ) */


```

`common/types.h.in`:

```in
/*
 * Type and type-support definitions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _TYPES_H )
#define _TYPES_H

#include "common.h"

#if defined( HAVE_LIMITS_H ) || defined( WINAPI )
#include <limits.h>
#endif

/* Make sure to include inttypes.h or stdint.h before
 * PRI definitions are defined
 */
#include <@PACKAGE@/types.h>

#if defined( WINAPI ) && ( defined( _UNICODE ) || defined( UNICODE ) )

#define HAVE_WIDE_SYSTEM_CHARACTER 1

/* The system character type is wide
 * A system string contains either UTF-16 or UTF-32
 */
typedef wchar_t system_character_t;
typedef wint_t system_integer_t;

#define PRIc_SYSTEM "lc"
#define PRIs_SYSTEM "ls"

#else

/* The system character type is narrow
 * A system string contains either UTF-8 or extended ASCII with a codepage
 */
typedef char system_character_t;
typedef int system_integer_t;

#define PRIc_SYSTEM "c"
#define PRIs_SYSTEM "s"

#endif /* defined( WINAPI ) && ( defined( _UNICODE ) || defined( UNICODE ) ) */

/* Fallback for systems without PRI definitions
 * Do not define when pyconfig.h has been included via python.h
 */
#if !defined( HAVE_PYCONFIG_H )

#if !defined( PRId8 )
#define PRId8 "d"
#endif

#if !defined( PRId16 )
#define PRId16 "d"
#endif

#if !defined( PRId32 )
#if defined( WINAPI )
#define PRId32 "I32d"

#else
#define PRId32 "d"

#endif
#endif /* !defined( PRId32 ) */

#if !defined( PRId64 )
#if defined( WINAPI )
#define PRId64 "I64d"

#elif __WORDSIZE == 64
#define PRId64 "ld"

#else
#define PRId64 "lld"

#endif
#endif /* !defined( PRId64 ) */

#if !defined( PRIi8 )
#define PRIi8 "i"
#endif

#if !defined( PRIi16 )
#define PRIi16 "i"
#endif

#if !defined( PRIi32 )
#if defined( WINAPI )
#define PRIi32 "I32i"

#else
#define PRIi32 "i"

#endif
#endif /* !defined( PRIi32 ) */

#if !defined( PRIi64 )
#if defined( WINAPI )
#define PRIi64 "I64i"

#elif __WORDSIZE == 64
#define PRIi64 "li"

#else
#define PRIi64 "lli"

#endif
#endif /* !defined( PRIi64 ) */

#if !defined( PRIu8 )
#define PRIu8 "u"
#endif

#if !defined( PRIu16 )
#define PRIu16 "u"
#endif

#if !defined( PRIu32 )
#if defined( WINAPI )
#define PRIu32 "I32u"

#else
#define PRIu32 "u"

#endif
#endif /* !defined( PRIu32 ) */

#if !defined( PRIu64 )
#if defined( WINAPI )
#define PRIu64 "I64u"

#elif __WORDSIZE == 64
#define PRIu64 "lu"

#else
#define PRIu64 "llu"

#endif
#endif /* !defined( PRIu64 ) */

#if !defined( PRIo8 )
#define PRIo8 "o"
#endif

#if !defined( PRIo16 )
#define PRIo16 "o"
#endif

#if !defined( PRIo32 )
#if defined( WINAPI )
#define PRIo32 "I32o"

#else
#define PRIo32 "o"

#endif
#endif /* !defined( PRIo32 ) */

#if !defined( PRIo64 )
#if defined( WINAPI )
#define PRIo64 "I64o"

#elif __WORDSIZE == 64
#define PRIo64 "lo"

#else
#define PRIo64 "llo"

#endif
#endif /* !defined( PRIo64 ) */

#if !defined( PRIx8 )
#define PRIx8 "x"
#endif

#if !defined( PRIx16 )
#define PRIx16 "x"
#endif

#if !defined( PRIx32 )
#if defined( WINAPI )
#define PRIx32 "I32x"

#else
#define PRIx32 "x"

#endif
#endif /* !defined( PRIx32 ) */

#if !defined( PRIx64 )
#if defined( WINAPI )
#define PRIx64 "I64x"

#elif __WORDSIZE == 64
#define PRIx64 "lx"

#else
#define PRIx64 "llx"

#endif
#endif /* !defined( PRIx64 ) */

#endif /* !defined( HAVE_PYCONFIG_H ) */

/* Fallback for systems without printf %jd definition
 */
#if defined( HAVE_PRINTF_JD )
#define PRIjd	"jd"
#define PRIji	"ji"
#define PRIju	"ju"
#define PRIjx	"jx"

#elif SIZEOF_OFF_T == 8
#define PRIjd	PRId64
#define PRIji	PRIi64
#define PRIju	PRIu64
#define PRIjx	PRIx64

#else
#define PRIjd	PRId32
#define PRIji	PRIi32
#define PRIju	PRIu32
#define PRIjx	PRIx32

#endif /* defined( HAVE_PRINTF_JD ) */

/* Fallback for systems without printf %zd definition
 */
#if defined( HAVE_PRINTF_ZD )
#define PRIzd	"zd"
#define PRIzi	"zi"
#define PRIzu	"zu"
#define PRIzx	"zx"

#elif defined( _MSC_VER )
#define PRIzd	"Id"
#define PRIzi	"Ii"
#define PRIzu	"Iu"
#define PRIzx	"Ix"

#elif SIZEOF_SIZE_T == 8
#define PRIzd	PRId64
#define PRIzi	PRIi64
#define PRIzu	PRIu64
#define PRIzx	PRIx64

#else
#define PRIzd	PRId32
#define PRIzi	PRIi32
#define PRIzu	PRIu32
#define PRIzx	PRIx32

#endif /* defined( HAVE_PRINTF_ZD ) */

/* Fallback for systems without (U)INTx_MAX definitions
 */

/* The maximum signed 8-bit integer is 127 (0x7f)
 */
#if !defined( INT8_MAX )
#define INT8_MAX (0x7f)
#endif

/* The maximum unsigned 8-bit integer is 256 (0xff)
 */
#if !defined( UINT8_MAX )
#define UINT8_MAX (0xff)
#endif

/* The maximum signed 16-bit integer is 32767 (0x7ffff)
 */
#if !defined( INT16_MAX )
#define INT16_MAX (0x7fff)
#endif

/* The maximum unsigned 16-bit integer is 65535 (0xffff)
 */
#if !defined( UINT16_MAX )
#define UINT16_MAX (0xffff)
#endif

/* The maximum signed 32-bit integer is 2147483647 (0x7fffffff)
 */
#if !defined( INT32_MAX )
#define INT32_MAX (0x7fffffffL)
#endif

/* The maximum unsigned 32-bit integer is 4294967295 (0xffffffff)
 */
#if !defined( UINT32_MAX )
#define UINT32_MAX (0xffffffffUL)
#endif

/* The minimum signed 64-bit integer is -9223372036854775808 (0x8000000000000000)
 */
#if !defined( INT64_MIN )
#if defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define INT64_MIN (0x8000000000000000UL)
#else
#define INT64_MIN (0x8000000000000000ULL)
#endif
#endif /* !defined( INT64_MIN ) */

/* The maximum signed 64-bit integer is 9223372036854775807 (0x7fffffffffffffff)
 */
#if !defined( INT64_MAX )
#if defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define INT64_MAX (0x7fffffffffffffffUL)
#else
#define INT64_MAX (0x7fffffffffffffffULL)
#endif
#endif /* !defined( INT64_MAX ) */

/* The maximum unsigned 64-bit integer is 18446744073709551615 (0xffffffffffffffff)
 */
#if !defined( UINT64_MAX )
#if defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define UINT64_MAX (0xffffffffffffffffUL)
#else
#define UINT64_MAX (0xffffffffffffffffULL)
#endif
#endif /* !defined( UINT64_MAX ) */

/* The maximum signed integer
 */
#if !defined( INT_MAX )
#define INT_MAX INT32_MAX
#endif

/* The maximum unsigned integer
 */
#if !defined( UINT_MAX )
#define UINT_MAX UINT32_MAX
#endif

/* The maximum signed long integer
 */
#if !defined( LONG_MAX )
#define LONG_MAX INT32_MAX
#endif

/* The maximum unsigned long integer
 */
#if !defined( ULONG_MAX )
#define ULONG_MAX UINT32_MAX
#endif

/* The maximum signed size type is platform dependent
 */
#if !defined( SSIZE_MAX )

#if defined( WINAPI )

#if defined( _WIN64 )
#define SSIZE_MAX INT64_MAX
#else
#define SSIZE_MAX INT32_MAX
#endif

#else

#if __WORDSIZE == 64
#define SSIZE_MAX INT64_MAX
#else
#define SSIZE_MAX INT32_MAX
#endif

#endif /* WINAPI */

#endif /* SSIZE_MAX */

#endif /* !defined( _TYPES_H ) */


```

`common/wide_string.h`:

```h
/*
 * Wide character string functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _WIDE_STRING_H )
#define _WIDE_STRING_H

#include "common.h"
#include "memory.h"
#include "types.h"

#if defined( HAVE_WCHAR_H ) || defined( WINAPI )
#include <wchar.h>
#endif

#if defined( __cplusplus )
extern "C" {
#endif

/* Intermediate version of the macro required
 * for correct evaluation predefined string
 */
#define _WIDE_STRING_INTERMEDIATE( string ) \
	L ## string

#define _WIDE_STRING( string ) \
	_WIDE_STRING_INTERMEDIATE( string )

/* String allocation
 */
#define wide_string_allocate( size ) \
	(wchar_t *) memory_allocate( sizeof( wchar_t ) * ( size ) )

/* String reallocation
 */
#define wide_string_reallocate( string, size ) \
	(wchar_t *) memory_reallocate( string, ( sizeof( wchar_t ) * ( size ) ) )

/* String length
 */
#if defined( HAVE_WCSLEN ) || defined( WINAPI )
#define wide_string_length( string ) \
	wcslen( string )
#endif

/* String compare
 */
#if defined( HAVE_WMEMCMP )
#define wide_string_compare( string1, string2, size ) \
	wmemcmp( (void *) string1, (void *) string2, size )

#elif defined( HAVE_WCSNCMP ) || defined( WINAPI )
#define wide_string_compare( string1, string2, size ) \
	wcsncmp( string1, string2, size )
#endif

/* Caseless string compare
 */
#if defined( _MSC_VER ) || ( defined( __BORLANDC__ ) && ( __BORLANDC__ >= 0x0551 ) )
#define wide_string_compare_no_case( string1, string2, size ) \
	_wcsnicmp( string1, string2, size )

#elif ( defined( WINAPI ) && !defined( __CYGWIN__ ) ) || defined( HAVE_WCSNICMP )
#define wide_string_compare_no_case( string1, string2, size ) \
	wcsnicmp( string1, string2, size )

#elif defined( HAVE_WCSNCASECMP )
#define wide_string_compare_no_case( string1, string2, size ) \
	wcsncasecmp( string1, string2, size )

#elif defined( HAVE_WCSCASECMP )
#define wide_string_compare_no_case( string1, string2, size ) \
	wcscasecmp( string1, string2 )
#endif

/* String copy
 */
#if defined( HAVE_WMEMCPY )
#define wide_string_copy( destination, source, size ) \
	(wchar_t *) wmemcpy( (void *) destination, (void *) source, size )

#elif defined( HAVE_WCSNCPY ) || defined( WINAPI )
#define wide_string_copy( destination, source, size ) \
	wcsncpy( destination, source, size )
#endif

/* String character search
 */
#if defined( HAVE_WMEMCHR )
#define wide_string_search_character( string, character, size ) \
	(wchar_t *) wmemchr( (void *) string, (wchar_t) character, size )

#elif defined( HAVE_WCSCHR ) || defined( WINAPI )
#define wide_string_search_character( string, character, size ) \
	wcschr( string, (wchar_t) character )

#endif

/* String reverse character search
 */
#if defined( HAVE_WMEMRCHR )
#define wide_string_search_character_reverse( string, character, size ) \
	(wchar_t *) wmemrchr( (void *) string, (wchar_t) character, size )

#elif defined( HAVE_WCSRCHR ) || defined( WINAPI )
/* (void)(size) is used to suppress unused variable warnings */
#define wide_string_search_character_reverse( string, character, size ) \
	wcsrchr( string, (wchar_t) character ); (void)(size)
#endif

/* String sub-string search
 */
#if defined( HAVE_WCSSTR ) || defined( WINAPI )
#define wide_string_search_string( string, substring, size ) \
	wcsstr( string, substring )

#endif

/* String formatted print (snwprintf)
 */
#if defined( _MSC_VER )
#define wide_string_snwprintf( target, size, ... ) \
	swprintf_s( target, size, __VA_ARGS__ )

#elif defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define wide_string_snwprintf \
	snwprintf

#elif defined( WINAPI )
#define wide_string_snwprintf( target, size, ... ) \
	snwprintf( target, size, __VA_ARGS__ )

#elif defined( HAVE_SWPRINTF )
#define wide_string_snwprintf( target, size, ... ) \
	swprintf( target, size, __VA_ARGS__ )
#endif

/* Variable arguments formatted print to string function (vsnwprintf)
 */
#if defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x0560 )
#define wide_string_vsnwprintf \
	_vsnwprintf

#elif defined( WINAPI )
#define wide_string_vsnwprintf( string, size, format, ... ) \
	_vsnwprintf( string, size, format, __VA_ARGS__ )

#elif defined( HAVE_VSWPRINTF )
#define wide_string_vsnwprintf( string, size, format, ... ) \
	vswprintf( string, size, format, __VA_ARGS__ )
#endif

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _WIDE_STRING_H ) */


```

`configure.ac`:

```ac
AC_PREREQ([2.71])

AC_INIT(
 [libmdmp],
 [20240208],
 [joachim.metz@gmail.com])

AC_CONFIG_SRCDIR(
 [include/libmdmp.h.in])

AM_INIT_AUTOMAKE([gnu 1.6 tar-ustar])
AM_EXTRA_RECURSIVE_TARGETS([sources splint])

AC_CONFIG_MACRO_DIR([m4])

dnl Check for host type
AC_CANONICAL_HOST

dnl Check for libtool DLL support
LT_INIT([win32-dll])

dnl Checks for programs
AC_PROG_CC
AC_PROG_GCC_TRADITIONAL
AC_PROG_CXX
AC_PROG_MAKE_SET
AC_PROG_INSTALL

dnl Check for libtool
AC_SUBST(LIBTOOL_DEPS)

dnl Check for pkg-config
AC_PATH_PROG(PKGCONFIG,[pkg-config])

dnl Support of internationalization (i18n)
AM_GNU_GETTEXT([external])
AM_GNU_GETTEXT_VERSION([0.21])

dnl Check for compiler language support
AC_C_CONST
AC_C_VOLATILE

dnl Check for large file support
AC_SYS_LARGEFILE

dnl Check if shared library support should be disabled
AX_COMMON_CHECK_DISABLE_SHARED_LIBS

dnl Check if tools should be build as static executables
AX_COMMON_CHECK_ENABLE_STATIC_EXECUTABLES

dnl Check if WINAPI support should be enabled
AX_COMMON_CHECK_ENABLE_WINAPI

dnl Check if wide character type should be enabled
AX_COMMON_CHECK_ENABLE_WIDE_CHARACTER_TYPE

dnl Check if verbose output should be enabled
AX_COMMON_CHECK_ENABLE_VERBOSE_OUTPUT

dnl Check if debug output should be enabled
AX_COMMON_CHECK_ENABLE_DEBUG_OUTPUT

dnl Check for type definitions
AX_TYPES_CHECK_LOCAL

dnl Check if common required headers and functions are available
AX_COMMON_CHECK_LOCAL

dnl Check if libcerror or required headers and functions are available
AX_LIBCERROR_CHECK_ENABLE

dnl Check if libcthreads or required headers and functions are available
AX_LIBCTHREADS_CHECK_ENABLE

dnl Check if libcdata or required headers and functions are available
AX_LIBCDATA_CHECK_ENABLE

dnl Check if libclocale or required headers and functions are available
AX_LIBCLOCALE_CHECK_ENABLE

dnl Check if libcnotify or required headers and functions are available
AX_LIBCNOTIFY_CHECK_ENABLE

dnl Check if libcsplit or required headers and functions are available
AX_LIBCSPLIT_CHECK_ENABLE

dnl Check if libuna or required headers and functions are available
AX_LIBUNA_CHECK_ENABLE

dnl Check if libcfile or required headers and functions are available
AX_LIBCFILE_CHECK_ENABLE

dnl Check if libcpath or required headers and functions are available
AX_LIBCPATH_CHECK_ENABLE

dnl Check if libbfio or required headers and functions are available
AX_LIBBFIO_CHECK_ENABLE

dnl Check if libfcache or required headers and functions are available
AX_LIBFCACHE_CHECK_ENABLE

dnl Check if libfdata or required headers and functions are available
AX_LIBFDATA_CHECK_ENABLE

dnl Check if libfdatetime or required headers and functions are available
AX_LIBFDATETIME_CHECK_ENABLE

dnl Check if libmdmp required headers and functions are available
AX_LIBMDMP_CHECK_LOCAL

dnl Check if mdmptools required headers and functions are available
AX_MDMPTOOLS_CHECK_LOCAL

dnl Check if DLL support is needed
AX_LIBMDMP_CHECK_DLL_SUPPORT

dnl Check if tests required headers and functions are available
AX_TESTS_CHECK_LOCAL
AX_TESTS_CHECK_OSSFUZZ

dnl Set additional compiler flags
CFLAGS="$CFLAGS -Wall";

dnl Check if requires and build requires should be set in spec file
AS_IF(
 [test "x$ac_cv_libcerror" = xyes || test "x$ac_cv_libcthreads" = xyes || test "x$ac_cv_libcdata" = xyes || test "x$ac_cv_libclocale" = xyes || test "x$ac_cv_libcnotify" = xyes || test "x$ac_cv_libcsplit" = xyes || test "x$ac_cv_libuna" = xyes || test "x$ac_cv_libcfile" = xyes || test "x$ac_cv_libcpath" = xyes || test "x$ac_cv_libbfio" = xyes || test "x$ac_cv_libfcache" = xyes || test "x$ac_cv_libfdata" = xyes || test "x$ac_cv_libfdatetime" = xyes],
 [AC_SUBST(
  [libmdmp_spec_requires],
  [Requires:])
 ])

dnl Set the date for the dpkg files
AC_SUBST(
 [DPKG_DATE],
 [`date -R 2> /dev/null`])

dnl Set the date for the spec file
AC_SUBST(
 [SPEC_DATE],
 [`date +"%a %b %e %Y" 2> /dev/null`])

dnl Generate Makefiles
AC_CONFIG_FILES([Makefile])
AC_CONFIG_FILES([include/Makefile])
AC_CONFIG_FILES([common/Makefile])
AC_CONFIG_FILES([libcerror/Makefile])
AC_CONFIG_FILES([libcthreads/Makefile])
AC_CONFIG_FILES([libcdata/Makefile])
AC_CONFIG_FILES([libclocale/Makefile])
AC_CONFIG_FILES([libcnotify/Makefile])
AC_CONFIG_FILES([libcsplit/Makefile])
AC_CONFIG_FILES([libuna/Makefile])
AC_CONFIG_FILES([libcfile/Makefile])
AC_CONFIG_FILES([libcpath/Makefile])
AC_CONFIG_FILES([libbfio/Makefile])
AC_CONFIG_FILES([libfcache/Makefile])
AC_CONFIG_FILES([libfdata/Makefile])
AC_CONFIG_FILES([libfdatetime/Makefile])
AC_CONFIG_FILES([libmdmp/Makefile])
AC_CONFIG_FILES([mdmptools/Makefile])
AC_CONFIG_FILES([po/Makefile.in])
AC_CONFIG_FILES([po/Makevars])
AC_CONFIG_FILES([manuals/Makefile])
AC_CONFIG_FILES([tests/Makefile])
AC_CONFIG_FILES([ossfuzz/Makefile])
AC_CONFIG_FILES([msvscpp/Makefile])
dnl Generate header files
AC_CONFIG_FILES([include/libmdmp.h])
AC_CONFIG_FILES([include/libmdmp/definitions.h])
AC_CONFIG_FILES([include/libmdmp/features.h])
AC_CONFIG_FILES([include/libmdmp/types.h])
AC_CONFIG_FILES([libmdmp/libmdmp_definitions.h])
dnl Generate distribution specific files
AC_CONFIG_FILES([common/types.h])
AC_CONFIG_FILES([dpkg/changelog])
AC_CONFIG_FILES([libmdmp/libmdmp.rc])
AC_CONFIG_FILES([libmdmp.pc])
AC_CONFIG_FILES([libmdmp.spec])
dnl Generate a source configuration file
AC_CONFIG_HEADERS([common/config.h])

AC_OUTPUT

dnl Print a summary
AC_MSG_NOTICE([
Building:
   libcerror support:                         $ac_cv_libcerror
   libcthreads support:                       $ac_cv_libcthreads
   libcdata support:                          $ac_cv_libcdata
   libclocale support:                        $ac_cv_libclocale
   libcnotify support:                        $ac_cv_libcnotify
   libcsplit support:                         $ac_cv_libcsplit
   libuna support:                            $ac_cv_libuna
   libcfile support:                          $ac_cv_libcfile
   libcpath support:                          $ac_cv_libcpath
   libbfio support:                           $ac_cv_libbfio
   libfcache support:                         $ac_cv_libfcache
   libfdata support:                          $ac_cv_libfdata
   libfdatetime support:                      $ac_cv_libfdatetime

Features:
   Multi-threading support:                   $ac_cv_libcthreads_multi_threading
   Wide character type support:               $ac_cv_enable_wide_character_type
   mdmptools are build as static executables: $ac_cv_enable_static_executables
   Verbose output:                            $ac_cv_enable_verbose_output
   Debug output:                              $ac_cv_enable_debug_output
]);


```

`documentation/Minidump (MDMP) format.asciidoc`:

```asciidoc
= Minidump (MDMP) format
Analysis the Windows Minidump format

:toc:
:toclevels: 4

:numbered!:
[abstract]
== Summary
[yellow-background]*TODO: add text*

This document is intended as a working document for the Minidump (MDPM) format. 
Which should allow existing Open Source forensic tooling to be able to process 
this type of volume format.

[preface]
== Document information
[cols="1,5"]
|===
| Author(s): | Joachim Metz <joachim.metz@gmail.com>
| Abstract: | This document contains information about the Minidump (MDPM) format
| Classification: | Public
| Keywords: | Minidump, MDPM
|===

[preface]
== License
....
Copyright (C) 2014-2015, Joachim Metz <joachim.metz@gmail.com>.
Permission is granted to copy, distribute and/or modify this document under the 
terms of the GNU Free Documentation License, Version 1.3 or any later version 
published by the Free Software Foundation; with no Invariant Sections, no 
Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included 
in the section entitled "GNU Free Documentation License".
....

[preface]
== Revision history
[cols="1,1,1,5",options="header"]
|===
| Version | Author | Date | Comments
| 0.0.1 | J.B. Metz | March 2014 | Initial version.
| 0.0.2 | J.B. Metz | November 2015 | Switched to asccidoc format.
|===

:numbered:
== Overview
[yellow-background]*TODO: add text*

Minidump file:

* File header
* Streams directory
* Streams and other data

[cols="1,5",options="header"]
|===
| Characteristics | Description
| Byte order | little-endian
| Date and time values | POSIX timestamp in UTC +
Number of seconds since Jan 1, 1970 00:00:00 UTC
| Character strings | ASCII strings are Single Byte Character (SBC) or Multi Byte Character (MBC) string stored with a codepage. Sometimes referred to as ANSI string representation. +
Though technically maybe incorrect, this document will use term (extended) ASCII string. +
Unicode strings are stored in UTF-16 little-endian without the byte order mark (BOM).
|===

=== Test version
The following version of programs were used to test the information within this 
document:

* Windows 7

[yellow-background]*TODO: check more versions of Windows*

== File header
The file header (MINIDUMP_HEADER) is 32 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | "MDMP" | Signature (MINIDUMP_SIGNATURE)
| 4 | 2 | 0xa793 | Format version (MINIDUMP_VERSION)
| 6 | 2 | | Implementation specific version
| 8 | 4 | | Number of streams
| 12 | 4 | | Streams directory RVA +
Contains an offset relative to the start of the file
| 16 | 4 | | Checksum +
[yellow-background]*(Which type of checksum? What data does it check?)* +
[yellow-background]*0 if not set*
4+| _Unknown criteria_
| 20 | 4 | 0 | [yellow-background]*Unknown (reserved)*
4+| _Unknown criteria_
| 20 | 4 | | Timestamp +
[yellow-background]*What purpose does the timestamp have?* +
Contains a POSIX timestamp
4+| _Common_
| 24 | 8 | | File flags +
See section: <<file_flags,File flags>>
|===

=== Format version

[cols="1,5",options="header"]
|===
| Implementation version
| Description
| 0x61b0 +
0x61b1 | Used on Windows 7 +
[yellow-background]*32-bit location descriptors?*
|===

=== [[file_flags]]File flags
The file flags (MINIDUMP_TYPE) are defined as:

[yellow-background]*TODO: clean up descriptions*

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0x00000000 | MiniDumpNormal | Include just the information necessary to capture stack traces for all existing threads in a process.
| 0x00000001 | MiniDumpWithDataSegs | Include the data sections from all loaded modules. This results in the inclusion of global variables, which can make the minidump file significantly larger. For per-module control, use the ModuleWriteDataSeg enumeration value from MODULE_WRITE_FLAGS.
| 0x00000002 | MiniDumpWithFullMemory | Include all accessible memory in the process. The raw memory data is included at the end, so that the initial structures can be mapped directly without the raw memory information. This option can result in a very large file.
| 0x00000004 | MiniDumpWithHandleData | Include high-level information about the operating system handles that are active when the minidump is made.
| 0x00000008 | MiniDumpFilterMemory | Stack and backing store memory written to the minidump file should be filtered to remove all but the pointer values necessary to reconstruct a stack trace.
| 0x00000010 | MiniDumpScanMemory | Stack and backing store memory should be scanned for pointer references to modules in the module list. If a module is referenced by stack or backing store memory, the ModuleWriteFlags member of the MINIDUMP_CALLBACK_OUTPUT structure is set to ModuleReferencedByMemory.
3+| _Values not supported in DbgHelp 5.1_
| 0x00000020 | MiniDumpWithUnloadedModules | Include information from the list of modules that were recently unloaded, if this information is maintained by the operating system. +
Windows Server 2003 and Windows XP:  The operating system does not maintain information for unloaded modules until Windows Server 2003 with SP1 and Windows XP with SP2.
| 0x00000040 | MiniDumpWithIndirectlyReferencedMemory | Include pages with data referenced by locals or other stack memory. This option can increase the size of the minidump file significantly.
| 0x00000080 | MiniDumpFilterModulePaths | Filter module paths for information such as user names or important directories. This option may prevent the system from locating the image file and should be used only in special situations.
| 0x00000100 | MiniDumpWithProcessThreadData | Include complete per-process and per-thread information from the operating system.
| 0x00000200 | MiniDumpWithPrivateReadWriteMemory | Scan the virtual address space for PAGE_READWRITE memory to be included.
3+| _Values not supported in DbgHelp 6.1 and earlier_
| 0x00000400 | MiniDumpWithoutOptionalData | Reduce the data that is dumped by eliminating memory regions that are not essential to meet criteria specified for the dump. This can avoid dumping memory that may contain data that is private to the user. However, it is not a guarantee that no private information will be present.
| 0x00000800 | MiniDumpWithFullMemoryInfo | Include memory region information. For more information, see MINIDUMP_MEMORY_INFO_LIST.
| 0x00001000 | MiniDumpWithThreadInfo | Include thread state information. For more information, see MINIDUMP_THREAD_INFO_LIST.
| 0x00002000 | MiniDumpWithCodeSegs | Include all code and code-related sections from loaded modules to capture executable content. For per-module control, use the ModuleWriteCodeSegs enumeration value from MODULE_WRITE_FLAGS.
3+| _Common_
| 0x00004000 | MiniDumpWithoutAuxiliaryState | Turns off secondary auxiliary-supported memory gathering.
| 0x00008000 | MiniDumpWithFullAuxiliaryState | Requests that auxiliary data providers include their state in the dump image; the state data that is included is provider dependent. This option can result in a large dump image.
| 0x00010000 | MiniDumpWithPrivateWriteCopyMemory | Scans the virtual address space for PAGE_WRITECOPY memory to be included.
3+| _Values not supported before DbgHelp 6.1_
| 0x00020000 | MiniDumpIgnoreInaccessibleMemory | If you specify MiniDumpWithFullMemory, the MiniDumpWriteDump function will fail if the function cannot read the memory regions; however, if you include MiniDumpIgnoreInaccessibleMemory, the MiniDumpWriteDump function will ignore the memory read failures and continue to generate the dump. Note that the inaccessible memory regions are not included in the dump.
| 0x00040000 | MiniDumpWithTokenInformation | Adds security token related data. This will make the "!token" extension work when processing a user-mode dump.
| 0x00080000 | MiniDumpWithModuleHeaders | Adds module header related data.
| 0x00100000 | MiniDumpFilterTriage | Adds filter triage related data.
3+| _Common_
| 0x001fffff | MiniDumpValidTypeFlags | Indicates which flags are valid.
|===

== Stream directory
The stream directory is an array of stream directory entries.

=== Stream directory entry
The stream directory entry (MINIDUMP_DIRECTORY) is X bytes of size and consist of:

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0 | 4 | | Stream type +
See section: <<stream_type,Stream type>>
| 4 | ... | | Location descriptor +
See section: <<location_descriptor,Location descriptor>>
|===

=== [[stream_type]]Stream type
The stream type (MINIDUMP_STREAM_TYPE) is defined as:

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0 | UnusedStream | Reserved +
According to MSDN this should not be used.
| 1 | ReservedStream0 | Reserved +
According to MSDN this should not be used.
| 2 | ReservedStream1 | Reserved +
According to MSDN this should not be used.
| 3 | ThreadListStream | The thread information stream +
See section: <<thread_information_stream,Thread information stream>>
| 4 | ModuleListStream | The module information stream +
See section: <<module_information_stream,Module information stream>>
| 5 | MemoryListStream | The memory allocation information stream +
See section: <<memory_allocation_information_stream_32bit,32-bit memory allocation information stream>>
| 6 | ExceptionStream | The exception information stream +
See section: <<exception_information_stream,Exception information stream>>
| 7 | SystemInfoStream | The general system information stream +
See section: <<general_system_information_stream,General system information stream>>
| 8 | ThreadExListStream | The extended thread information stream +
See section: <<extended_thread_information_stream,Extended thread information stream>>
| 9 | Memory64ListStream | The 64-bit memory allocation information stream +
See section: <<memory_allocation_information_stream_64bit,64-bit memory allocation information stream>>
| 10 | CommentStreamA | The ASCII comment stream +
This stream is used for documentation purposes
| 11 | CommentStreamW | The Unicode comment stream +
This stream is used for documentation purposes
| 12 | HandleDataStream | The active operating system handles stream +
See section: <<active_operating_system_handles_stream,Active operating system handles stream>>
| 13 | FunctionTableStream | The function table information stream +
See section: <<function_table_information_stream,Function table information stream>>
3+| _Introduced after DbgHelp 5.1_
| 14 | UnloadedModuleListStream | The unloaded module information stream +
See section: <<unloaded_module_information_stream,Unloaded module information stream>>
| 15 | MiscInfoStream | The miscellaneous information stream +
See section: <<miscellaneous_information_stream,Miscellaneous information stream>>
3+| _Introduced after DbgHelp 6.1_
| 16 | MemoryInfoListStream | The memory region description information stream +
It corresponds to the information that would be returned for the process from the VirtualQuery function +
See section: <<memory_region_description_information_stream,Memory region description information stream>>
| 17 | ThreadInfoListStream | The thread state information stream +
See section: <<thread_state_information_stream,Thread state information stream>>
3+| _Introduced after DbgHelp 6.4_
| 18 | HandleOperationListStream | The operation list information stream +
See section: <<operation_list_information_stream,Operation list information stream>>
| 19 | TokenStream | [yellow-background]*Unknown seen in Windows 7*
3+| _Common_
| 0xffff | LastReservedStream | [yellow-background]*Any value greater than this value will not be used by the system and can be used to represent application-defined data streams.* +
[yellow-background]*For more information, see MINIDUMP_USER_STREAM*
|===

== Common types
[yellow-background]*TODO: add missing text*

=== [[location_descriptor]]Location descriptor
[yellow-background]*This structure uses 32-bit locations for RVAs in the first 
4GB and 64-bit locations are used for larger RVAs.*

==== 32-bit location descriptor
The 32-bit location descriptor (MINIDUMP_LOCATION_DESCRIPTOR) is 8 bytes of 
size and consist of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Data size
| 4 | 4 | | RVA +
Contains an offset relative to the start of the file
|===

==== 64-bit location descriptor
The 64-bit location descriptor (MINIDUMP_LOCATION_DESCRIPTOR64) is 16 bytes of 
size and consist of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 8 | | Data size
| 8 | 8 | | RVA +
Contains an offset relative to the start of the file
|===

=== String
[yellow-background]*TODO: add text (MINIDUMP_STRING)*

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | [yellow-background]*Length (number of characters or bytes)*
| 4 | ... | | String data +
Contain an [yellow-background]*UTF-16 little-endian string (with or without an end-of-string character)*
|===

== Streams
[yellow-background]*TODO: add missing text*

=== [[active_operating_system_handles_stream]]Active operating system handles stream
The active operating system handles information stream consists of:

* operating system handles information header
* array of operating system handle descriptors

The operating system handles header (MINIDUMP_HANDLE_DATA_STREAM) is 16 bytes 
of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | 16 | Header size +
Includes the header size value itself
| 4 | 4 | 32 or 40 | Descriptor size
| 8 | 4 | | Number of descriptors
| 12 | 4 | 0 | [yellow-background]*Unknown (Reserved)*
|===

The operating system handle descriptor - version 1 (MINIDUMP_HANDLE_DESCRIPTOR) 
or operating system handle descriptor - version 2 
(MINIDUMP_HANDLE_DESCRIPTOR_2) are respectively 32 or 40 bytes of size and 
consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 8 | | [yellow-background]*Unknown (Handle?)*
| 8 | 4 | | Type name RVA +
Contains an offset relative to the start of the file
| 12 | 4 | | Handle object name RVA +
Contains an offset relative to the start of the file
| 16 | 4 | | Attributes
| 20 | 4 | | [yellow-background]*Unknown (Granted access?)*
| 24 | 4 | | Handle count
| 28 | 4 | | Pointer count
4+| [yellow-background]*If handle descriptor size > 32?*
| 32 | 4 | | Handle object information RVA +
Contains an offset relative to the start of the file
| See section: [yellow-background]*TODO*
| 36 | 4 | 0 | [yellow-background]*Unknown (Reserved)*
|===

[yellow-background]*TODO: add text*

Object information RVA point to: MINIDUMP_HANDLE_OBJECT_INFORMATION
[yellow-background]*TODO add cross reference*

==== Handle object information
The handle object information (MINIDUMP_HANDLE_OBJECT_INFORMATION) is [yellow-background]*TODO*

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Next handle object information RVA +
Contains an offset relative to the start of the file
| 4 | 4 | | Handle object information type
| 8 | 4 | | Handle object information data size
|===

[yellow-background]*TODO followed by data?*

==== Handle object information type
The handle object information type (MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE) is 
defined as:

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0 | MiniHandleObjectInformationNone | There is no object-specific information for this handle type.
| 1 | MiniThreadInformation1 | The information is specific to thread objects.
| 2 | MiniMutantInformation1 | The information is specific to mutant objects.
| 3 | MiniMutantInformation2 | The information is specific to mutant objects.
| 4 | MiniProcessInformation1 | The information is specific to process objects.
| 5 | MiniProcessInformation2 | The information is specific to process objects.
|===

=== [[exception_information_stream]]Exception information stream
The exception information stream (MINIDUMP_EXCEPTION_STREAM) is variable of 
size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Thread identifier
| 4 | 4 | | [yellow-background]*Unknown (Alignment padding)*
| 8 | ... | | Exception record +
See action: [yellow-background]*TODO: add cross reference*
| ... | ... | | Thread context location descriptor +
See section: <<location_descriptor,Location descriptor>>
|===

The exception record (MINIDUMP_EXCEPTION) is variable of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Exception code
| 4 | 4 | | Exception flags
| 8 | 8 | | Exception record
| 16 | 8 | | Exception address
| 24 | 4 | | Number of exception information entries (or parameters) +
The maximum number of entries is 15 (EXCEPTION_MAXIMUM_PARAMETERS)
| 28 | 4 | | Alignment padding +
Reserved for cross-platform structure member alignment
| 32 | 8 x ... | | Array of exception information entries +
Where an exception information entry is an 64-bit integer
|===

[yellow-background]*TODO: add text*
....
EXCEPTION_RECORD:  00135da4 -- (.exr 0x135da4)
ExceptionAddress: 001363c0 (0x001363c0)
  ExceptionCode: c0000005 (Access violation)
 ExceptionFlags: 00000000
NumberParameters: 2
  Parameter[0]: 00000008
  Parameter[1]: 001363c0
Attempt to execute non-executable address 001363c0
....

==== Exception codes
[yellow-background]*TODO: add text*

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0xc0000005 | EXCEPTION_ACCESS_VIOLATION | [yellow-background]*The thread tried to read from or write to a virtual address for which it does not have the appropriate access.*
| | | 
| 0xc000008c | EXCEPTION_ARRAY_BOUNDS_EXCEEDED | [yellow-background]*The thread tried to access an array element that is out of bounds and the underlying hardware supports bounds checking.*
| | EXCEPTION_BREAKPOINT | [yellow-background]*A breakpoint was encountered.*
| | EXCEPTION_DATATYPE_MISALIGNMENT | [yellow-background]*The thread tried to read or write data that is misaligned on hardware that does not provide alignment. For example, 16-bit values must be aligned on 2-byte boundaries; 32-bit values on 4-byte boundaries, and so on.*
| | EXCEPTION_FLT_DENORMAL_OPERAND | [yellow-background]*One of the operands in a floating-point operation is denormal. A denormal value is one that is too small to represent as a standard floating-point value.*
| | EXCEPTION_FLT_DIVIDE_BY_ZERO | [yellow-background]*The thread tried to divide a floating-point value by a floating-point divisor of zero.*
| | EXCEPTION_FLT_INEXACT_RESULT | [yellow-background]*The result of a floating-point operation cannot be represented exactly as a decimal fraction.*
| | EXCEPTION_FLT_INVALID_OPERATION | [yellow-background]*This exception represents any floating-point exception not included in this list.*
| | EXCEPTION_FLT_OVERFLOW | [yellow-background]*The exponent of a floating-point operation is greater than the magnitude allowed by the corresponding type.*
| | EXCEPTION_FLT_STACK_CHECK | [yellow-background]*The stack overflowed or underflowed as the result of a floating-point operation.*
| | EXCEPTION_FLT_UNDERFLOW | [yellow-background]*The exponent of a floating-point operation is less than the magnitude allowed by the corresponding type.*
| 0xc000001d | EXCEPTION_ILLEGAL_INSTRUCTION | [yellow-background]*The thread tried to execute an invalid instruction.*
| | EXCEPTION_IN_PAGE_ERROR | [yellow-background]*The thread tried to access a page that was not present, and the system was unable to load the page. For example, this exception might occur if a network connection is lost while running a program over the network.*
| 0xc0000094 | EXCEPTION_INT_DIVIDE_BY_ZERO | [yellow-background]*The thread tried to divide an integer value by an integer divisor of zero.*
| 0xc0000095 | EXCEPTION_INT_OVERFLOW | [yellow-background]*The result of an integer operation caused a carry out of the most significant bit of the result.*
| 0xc0000026 | EXCEPTION_INVALID_DISPOSITION | [yellow-background]*An exception handler returned an invalid disposition to the exception dispatcher. Programmers using a high-level language such as C should never encounter this exception.*
| 0xc0000025 | EXCEPTION_NONCONTINUABLE_EXCEPTION | [yellow-background]*The thread tried to continue execution after a non-continuable exception occurred.*
| | EXCEPTION_PRIV_INSTRUCTION | [yellow-background]*The thread tried to execute an instruction whose operation is not allowed in the current machine mode.*
| | EXCEPTION_SINGLE_STEP | [yellow-background]*A trace trap or other single-instruction mechanism signaled that one instruction has been executed.*
| 0xc00000fd | EXCEPTION_STACK_OVERFLOW | [yellow-background]*The thread used up its stack.*
|===

==== Exception flags

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0 | EXCEPTION_CONTINUABLE | A continuable exception
| 1 | EXCEPTION_NONCONTINUABLE (EH_NONCONTINUABLE) | A non-continuable exception
|===

=== [[extended_thread_information_stream]]Extended thread information stream
The extended thread information stream (MINIDUMP_THREAD_EX_LIST) is variable of 
size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Number of threads
| 4 | ... | | Array of thread information entries
|===

The extended thread information entry (MINIDUMP_THREAD_EX) is [yellow-background]*TODO*

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Thread identifier
| 4 | 4 | | Suspend count
| 8 | 4 | | Priority class
| 12 | 4 | | Priority
| 16 | 8 | | Thread Environment Block (TEB)
| 24 | ... | | Stack memory descriptor +
See section: [yellow-background]*TODO add cross reference*
| ... | ... | | Thread context location descriptor +
See section: <<location_descriptor,Location descriptor>>
| ... | ... | | Backing store memory descriptor +
See section: [yellow-background]*TODO add cross reference*
|===

=== [[function_table_information_stream]]Function table information stream
The function table information stream consists of:

* function table information header
* array of function table information descriptors

The function table information header (MINIDUMP_FUNCTION_TABLE_STREAM) is 24 
bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | 24 | Header size +
Includes the header size value itself
| 4 | 4 | | Descriptor size
| 8 | 4 | | Native descriptor size
| 12 | 4 | | Function entry size
| 16 | 4 | | Number of function table descriptors
| 20 | 4 | | Alignment padding size
|===

==== Function table infomration descriptor
The function table information descriptor (MINIDUMP_FUNCTION_TABLE_DESCRIPTOR) 
is [yellow-background]*TODO*

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 8 | | [yellow-background]*Unknown (Minimum address)*
| 8 | 8 | | [yellow-background]*Unknown (Maximum address)*
| 16 | 8 | | [yellow-background]*Unknown (Base address)*
| 24 | 4 | | [yellow-background]*Unknown (Entry count)*
| 28 | 4 | | [yellow-background]*Unknown (Alignment padding size)*
|===

=== [[general_system_information_stream]]General system information stream
The general system information stream (MINIDUMP_SYSTEM_INFO) is 56 bytes of 
size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 2 | | Processor architecture
| 2 | 2 | | Processor level
| 4 | 2 | | Processor revision
4+| [yellow-background]*Unknown criteria*
| 6 | 2 | | [yellow-background]*Unknown (reserved)*
4+| [yellow-background]*Unknown criteria*
| 6 | 1 | | Number of processors or reserved
| 7 | 1 | | Product type or reserved
4+| [yellow-background]*Common*
| 8 | 4 | | Major version
| 12 | 4 | | Minor version
| 16 | 4 | | Build number
| 20 | 4 | | Platform identifier
| 24 | 4 | | CSD version RVA +
Contains an offset relative to the start of the file
4+| [yellow-background]*Unknown criteria*
| 28 | 4 | | [yellow-background]*Unknown (reserved)*
4+| [yellow-background]*Unknown criteria*
| 28 | 2 | | Suite mask
| 30 | 2 | | [yellow-background]*Unknown (reserved)* +
4+| [yellow-background]*X86CpuInfo: Unknown criteria*
| 32 | 3 x 4 | | Vendor identifier
| 44 | 4 | | Version information
| 48 | 4 | | Feature information
| 52 | 4 | | AMD extended CPU features
4+| [yellow-background]*OtherCpuInfo: Unknown criteria*
| 32 | 2 x 8 | | Processor features
| 48 | 8 | | [yellow-background]*Unknown (padding)* +
[yellow-background]*Not sure if this value exists the MSDN information suggests it*
|===

=== [[memory_allocation_information_stream_32bit]]32-bit memory allocation information stream
The 32-bit memory allocation information stream (MINIDUMP_MEMORY_LIST) is 
variable of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Number of memory ranges
| 4 | ... | | Array of memory range descriptors
|===

=== 32-bit memory range descriptor
The 32-bit memory range descriptor (MINIDUMP_MEMORY_DESCRIPTOR) is [yellow-background]*TODO: add text*

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 8 | | [yellow-background]*Unknown (Start of memory range?)* +
[yellow-background]*Does this value contain a file offset or memory address?*
| 8 | ... | | [yellow-background]*Unknown (Memory location descriptor)* +
See section: <<location_descriptor,Location descriptor>>
|===

=== [[memory_allocation_information_stream_64bit]]64-bit memory allocation information stream
The 64-bit memory allocation information stream (MINIDUMP_MEMORY64_LIST) is 
variable of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 8 | | Number of memory ranges
| 8 | 8 | | Base RVA +
Contains an offset relative to the start of the file
| 16 | ... | | Array of memory ranges
|===

=== 64-bit memory range descriptor
The 64-bit memory range descriptro (MINIDUMP_MEMORY_DESCRIPTOR64) is 16 bytes 
of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 8 | | [yellow-background]*Unknown (Start of memory range?)* +
[yellow-background]*Does this value contain a file offset or memory address?*
| 8 | 16 | | Data size
|===

=== [[memory_region_description_information_stream]]Memory region description information stream
The memory region description information stream consists of:

* memory information header
* array of memory information entries

The memory information header (MINIDUMP_MEMORY_INFO_LIST) is 16 bytes of size 
and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | 16 | Header size +
Includes the header size value itself
| 4 | 4 | 48 | Entry size
| 8 | 8 | | Number of entries
|===

The memory information entry (MINIDUMP_MEMORY_INFO) is 48 bytes of size and 
consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 8 | | [yellow-background]*Unknown (Base address)*
| 8 | 8 | | [yellow-background]*Unknown (Allocation base)*
| 16 | 4 | | [yellow-background]*Unknown (Allocation protect)*
| 20 | 4 | | [yellow-background]*Unknown (Alignment padding)*
| 24 | 8 | | [yellow-background]*Unknown (Region size)*
| 32 | 4 | | [yellow-background]*Unknown (State)*
| 36 | 4 | | [yellow-background]*Unknown (Protect)*
| 40 | 4 | | [yellow-background]*Unknown (Type)*
| 44 | 4 | | [yellow-background]*Unknown (Alignment padding)*
|===

=== [[miscellaneous_information_stream]]Miscellaneous information stream
The miscellaneous information stream - version 1 (MINIDUMP_MISC_INFO) or the 
miscellaneous information stream - version 2 (MINIDUMP_MISC_INFO_2) are 
respectively 24 or 44 bytes of size and consist of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Stream data size
| 4 | 4 | | Miscellaneous information flags +
See section: [yellow-background]*TODO add cross reference*
| 8 | 4 | | Process identifier (PID)
| 12 | 4 | | Process creation time +
Contains a POSIX timestamp
| 16 | 4 | | Process user time +
Contains a POSIX timestamp
| 20 | 4 | | Process kernel time +
Contains a POSIX timestamp
4+| [yellow-background]*If stream data size > 24?*
| 24 | 4 | | Processor maximum MHz
| 28 | 4 | | Processor current MHz
| 32 | 4 | | Processor MHz limit
| 36 | 4 | | Processor maximum idle state
| 40 | 4 | | Processor current idle state
|===

[yellow-background]*TODO what about additional data?*

....
00000100  e8 00 00 00 d7 00 00 00  b8 18 00 00 44 76 6d 50  |............DvmP| 
00000110  78 04 00 00 6e 04 00 00  c5 09 00 00 c5 09 00 00  |x...n...........| 
00000120  c5 09 00 00 03 00 00 00  01 00 00 00              |............. ..| 

00000120                                       10 20 00 00  |............. ..| 
00000130  0d 00 00 d0 00 00 00 00  01 00 00 00 b4 00 00 00  |................| 
00000140  45 00 2e 00 20 00 53 00  6f 00 75 00 74 00 68 00  |E... .S.o.u.t.h.| 
00000150  20 00 41 00 6d 00 65 00  72 00 69 00 63 00 61 00  | .A.m.e.r.i.c.a.| 
00000160  20 00 53 00 74 00 61 00  6e 00 64 00 61 00 72 00  | .S.t.a.n.d.a.r.| 
00000170  64 00 20 00 54 00 69 00  6d 00 65 00 00 00 00 00  |d. .T.i.m.e.....| 
00000180  00 00 02 00 06 00 04 00  17 00 3b 00 3b 00 e7 03  |..........;.;...| 
00000190  00 00 00 00 45 00 2e 00  20 00 53 00 6f 00 75 00  |....E... .S.o.u.| 
000001a0  74 00 68 00 20 00 41 00  6d 00 65 00 72 00 69 00  |t.h. .A.m.e.r.i.| 
000001b0  63 00 61 00 20 00 44 00  61 00 79 00 6c 00 69 00  |c.a. .D.a.y.l.i.| 
000001c0  67 00 68 00 74 00 20 00  54 00 69 00 6d 00 65 00  |g.h.t. .T.i.m.e.| 
000001d0  00 00 00 00 00 00 0a 00  06 00 03 00 17 00 3b 00  |..............;.| 
000001e0  3b 00 e7 03 c4 ff ff ff                           |;...............| 
....

==== Miscellaneous information flags

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0x00000001 | MINIDUMP_MISC1_PROCESS_ID | The process identifier (PID) value in the miscellaneous information stream is set
| 0x00000002 | MINIDUMP_MISC1_PROCESS_TIMES | The process creation time, process user time and process kernel time values in the miscellaneous information stream are set
| 0x00000004 | MINIDUMP_MISC1_PROCESSOR_POWER_INFO | The processor maximum MHz, processor current MHz, processor MHz limit, processor maximum idle state and processor current idle state values in the miscellaneous information stream are set
|===

=== [[module_information_stream]]Module information stream
The module information stream (MINIDUMP_MODULE_LIST) is variable of size and 
consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Number of modules
| 4 | ... | | Array of module information entries
|===

The thread information entry (MINIDUMP_MODULE) is [yellow-background]*TODO: add text*

[yellow-background]*TODO: check the offset and sizes*

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 8 | | [yellow-background]*Unknown (Image base)*
| 8 | 4 | | Image size
| 12 | 4 | | Checksum +
[yellow-background]*TODO: determine which type of checksum and what data it checks*
| 16 | 4 | | Timestamp +
Contains a POSIX timestamp
| 20 | 4 | | Module name RVA +
Contains an offset relative to the start of the file
| 24 | 52 | | Version information +
PE/COFF fixed file version information +
Also see: `[LIBEXE]`
| 76 | [yellow-background]*8* | | CodeView record location descriptor +
See section: <<location_description,Location descriptor>> +
The location descriptor points to a PDB RSDS structure
| | [yellow-background]*8* | | Miscellaneous record location descriptor +
See section: <<location_description,Location descriptor>>
| | 8 | | [yellow-background]*Unknown (Reserved)*
| | 8 | | [yellow-background]*Unknown (Reserved)*
|===

=== [[operation_list_information_stream]]Operation list information stream
The operation list information stream consists of:

* operation list information header
* array of operation list information entries

The operation list information header (MINIDUMP_HANDLE_OPERATION_LIST) is 16 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | 16 | Header size +
Includes the header size value itself
| 4 | 4 | | Entry size
| 8 | 4 | | Number of entries
| 12 | 4 | | [yellow-background]*Unknown (reserved)*
|===

The operation list information entry (AVRF_HANDLE_OPERATION) is [yellow-background]*TODO*
....
typedef struct {
  ULONG64                    Handle;
  ULONG                      ProcessId;
  ULONG                      ThreadId;
  ULONG                      OperationType;
  ULONG                      Spare0;
  AVRF_BACKTRACE_INFORMATION BackTraceInformation;
} AVRF_HANDLE_OPERATION;
....

=== [[thread_information_stream]]Thread information stream
The thread information stream (MINIDUMP_THREAD_LIST) is variable of size and 
consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Number of threads
| 4 | ... | | Array of thread information entries
|===

=== Thread information entry
The thread information entry (MINIDUMP_THREAD) is [yellow-background]*TODO: add text*

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Thread identifier
| 4 | 4 | | Suspend count
| 8 | 4 | | Priority class
| 12 | 4 | | Priority
| 16 | 8 | | Thread Environment Block (TEB)
| 24 | ... | | Stack memory descriptor +
See section: [yellow-background]*TODO: add text*
| ... | ... | | Thread context location descriptor +
See section: <<locaton_descriptor,Location descriptor>>
|===

=== [[thread_state_information_stream]]Thread state information stream
The thread state information stream consists of:

* thread state information header
* array of thread state information entries

The thread state information header (MINIDUMP_THREAD_INFO_LIST) is 12 bytes of 
size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | 12 | Header size +
Includes the header size value itself
| 4 | 4 | | Entry size
| 8 | 4 | | Number of entries
|===

The thread state information entry (MINIDUMP_THREAD_INFO) is [yellow-background]*TODO*

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Thread identifier
| 4 | 4 | | [yellow-background]*Unknown (Dump flags)*
| 8 | 4 | | [yellow-background]*Unknown (Dump error)*
| 12 | 4 | | [yellow-background]*Unknown (Exit status)*
| 16 | 8 | | Creation time +
[yellow-background]*Contains a FILETIME?*
| 24 | 8 | | Exit time +
[yellow-background]*Contains a FILETIME?*
| 32 | 8 | | Kernel time +
[yellow-background]*Contains a FILETIME?*
| 40 | 8 | | User time +
[yellow-background]*Contains a FILETIME?*
| 48 | 8 | | [yellow-background]*Unknown (Start address)*
| 56 | 8 | | [yellow-background]*Unknown (Affinity)*
|===

=== [[unloaded_module_information_stream]]Unloaded module information stream
The unloaded module information stream consists of:

* unloaded module information header
* array of unloaded module information entries

The unloaded module information header (MINIDUMP_UNLOADED_MODULE_LIST) is 12 
bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | 12 | Header size +
Includes the header size value itself
| 4 | 4 | | Entry size
| 8 | 4 | | Number of entries
|===

The unloaded module information entry (MINIDUMP_UNLOADED_MODULE) is [yellow-background]*TODO*

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 8 | | [yellow-background]*Unknown (Image base)*
| 8 | 4 | | [yellow-background]*Unknown (Image size)*
| 12 | 4 | | [yellow-background]*Unknown (Checksum)* +
[yellow-background]*TODO: determine which type of checksum and what data it checks*
| 16 | 4 | | [yellow-background]*Unknown (Timestamp)* +
[yellow-background]*TODO: What does it signify?*
| 20 | 4 | | [yellow-background]*Unknown (Module name RVA)* +
[yellow-background]*Contains an offset relative to the start of the file*
|===

=== [[user_defined_stream]]User defined stream

[yellow-background]*TODO: add text (MINIDUMP_USER_STREAM)*

== Notes
....
dumpchk -v file.mdmp
....

:numbered!:
[appendix]
== References

`[LIBEXE]`

[cols="1,5",options="header"]
|===
| Title: | MZ, PE-COFF executable file format (EXE)
| Author(s): | Joachim Metz
| Date: | October 2011 
| URL: | [yellow-background]*TODO: add URL*
|===

`[MSDN]`

[cols="1,5",options="header"]
|===
| Title: | MINIDUMP_HEADER structure
| URL: | http://msdn.microsoft.com/en-us/library/windows/desktop/ms680378(v=vs.85).aspx
|===

`[REACTOS]`

[cols="1,5",options="header"]
|===
| Title: | compat.h
| URL: | http://doxygen.reactos.org/d5/db1/dll_2win32_2dbghelp_2compat_8h_source.html
|===

[appendix]
== GNU Free Documentation License
Version 1.3, 3 November 2008
Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc. 
<http://fsf.org/>

Everyone is permitted to copy and distribute verbatim copies of this license 
document, but changing it is not allowed.

=== 0. PREAMBLE
The purpose of this License is to make a manual, textbook, or other functional 
and useful document "free" in the sense of freedom: to assure everyone the 
effective freedom to copy and redistribute it, with or without modifying it, 
either commercially or noncommercially. Secondarily, this License preserves for 
the author and publisher a way to get credit for their work, while not being 
considered responsible for modifications made by others.

This License is a kind of "copyleft", which means that derivative works of the 
document must themselves be free in the same sense. It complements the GNU 
General Public License, which is a copyleft license designed for free software.

We have designed this License in order to use it for manuals for free software, 
because free software needs free documentation: a free program should come with 
manuals providing the same freedoms that the software does. But this License is 
not limited to software manuals; it can be used for any textual work, 
regardless of subject matter or whether it is published as a printed book. We 
recommend this License principally for works whose purpose is instruction or 
reference.

=== 1. APPLICABILITY AND DEFINITIONS
This License applies to any manual or other work, in any medium, that contains 
a notice placed by the copyright holder saying it can be distributed under the 
terms of this License. Such a notice grants a world-wide, royalty-free license, 
unlimited in duration, to use that work under the conditions stated herein. The 
"Document", below, refers to any such manual or work. Any member of the public 
is a licensee, and is addressed as "you". You accept the license if you copy, 
modify or distribute the work in a way requiring permission under copyright law.

A "Modified Version" of the Document means any work containing the Document or 
a portion of it, either copied verbatim, or with modifications and/or 
translated into another language.

A "Secondary Section" is a named appendix or a front-matter section of the 
Document that deals exclusively with the relationship of the publishers or 
authors of the Document to the Document's overall subject (or to related 
matters) and contains nothing that could fall directly within that overall 
subject. (Thus, if the Document is in part a textbook of mathematics, a 
Secondary Section may not explain any mathematics.) The relationship could be a 
matter of historical connection with the subject or with related matters, or of 
legal, commercial, philosophical, ethical or political position regarding them.

The "Invariant Sections" are certain Secondary Sections whose titles are 
designated, as being those of Invariant Sections, in the notice that says that 
the Document is released under this License. If a section does not fit the 
above definition of Secondary then it is not allowed to be designated as 
Invariant. The Document may contain zero Invariant Sections. If the Document 
does not identify any Invariant Sections then there are none.

The "Cover Texts" are certain short passages of text that are listed, as 
Front-Cover Texts or Back-Cover Texts, in the notice that says that the 
Document is released under this License. A Front-Cover Text may be at most 5 
words, and a Back-Cover Text may be at most 25 words.

A "Transparent" copy of the Document means a machine-readable copy, represented 
in a format whose specification is available to the general public, that is 
suitable for revising the document straightforwardly with generic text editors 
or (for images composed of pixels) generic paint programs or (for drawings) 
some widely available drawing editor, and that is suitable for input to text 
formatters or for automatic translation to a variety of formats suitable for 
input to text formatters. A copy made in an otherwise Transparent file format 
whose markup, or absence of markup, has been arranged to thwart or discourage 
subsequent modification by readers is not Transparent. An image format is not 
Transparent if used for any substantial amount of text. A copy that is not 
"Transparent" is called "Opaque".

Examples of suitable formats for Transparent copies include plain ASCII without 
markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly 
available DTD, and standard-conforming simple HTML, PostScript or PDF designed 
for human modification. Examples of transparent image formats include PNG, XCF 
and JPG. Opaque formats include proprietary formats that can be read and edited 
only by proprietary word processors, SGML or XML for which the DTD and/or 
processing tools are not generally available, and the machine-generated HTML, 
PostScript or PDF produced by some word processors for output purposes only.

The "Title Page" means, for a printed book, the title page itself, plus such 
following pages as are needed to hold, legibly, the material this License 
requires to appear in the title page. For works in formats which do not have 
any title page as such, "Title Page" means the text near the most prominent 
appearance of the work's title, preceding the beginning of the body of the text.

The "publisher" means any person or entity that distributes copies of the 
Document to the public.

A section "Entitled XYZ" means a named subunit of the Document whose title 
either is precisely XYZ or contains XYZ in parentheses following text that 
translates XYZ in another language. (Here XYZ stands for a specific section 
name mentioned below, such as "Acknowledgements", "Dedications", 
"Endorsements", or "History".) To "Preserve the Title" of such a section when 
you modify the Document means that it remains a section "Entitled XYZ" 
according to this definition.

The Document may include Warranty Disclaimers next to the notice which states 
that this License applies to the Document. These Warranty Disclaimers are 
considered to be included by reference in this License, but only as regards 
disclaiming warranties: any other implication that these Warranty Disclaimers 
may have is void and has no effect on the meaning of this License.

=== 2. VERBATIM COPYING
You may copy and distribute the Document in any medium, either commercially or 
noncommercially, provided that this License, the copyright notices, and the 
license notice saying this License applies to the Document are reproduced in 
all copies, and that you add no other conditions whatsoever to those of this 
License. You may not use technical measures to obstruct or control the reading 
or further copying of the copies you make or distribute. However, you may 
accept compensation in exchange for copies. If you distribute a large enough 
number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and you may 
publicly display copies.

=== 3. COPYING IN QUANTITY
If you publish printed copies (or copies in media that commonly have printed 
covers) of the Document, numbering more than 100, and the Document's license 
notice requires Cover Texts, you must enclose the copies in covers that carry, 
clearly and legibly, all these Cover Texts: Front-Cover Texts on the front 
cover, and Back-Cover Texts on the back cover. Both covers must also clearly 
and legibly identify you as the publisher of these copies. The front cover must 
present the full title with all words of the title equally prominent and 
visible. You may add other material on the covers in addition. Copying with 
changes limited to the covers, as long as they preserve the title of the 
Document and satisfy these conditions, can be treated as verbatim copying in 
other respects.

If the required texts for either cover are too voluminous to fit legibly, you 
should put the first ones listed (as many as fit reasonably) on the actual 
cover, and continue the rest onto adjacent pages.

If you publish or distribute Opaque copies of the Document numbering more than 
100, you must either include a machine-readable Transparent copy along with 
each Opaque copy, or state in or with each Opaque copy a computer-network 
location from which the general network-using public has access to download 
using public-standard network protocols a complete Transparent copy of the 
Document, free of added material. If you use the latter option, you must take 
reasonably prudent steps, when you begin distribution of Opaque copies in 
quantity, to ensure that this Transparent copy will remain thus accessible at 
the stated location until at least one year after the last time you distribute 
an Opaque copy (directly or through your agents or retailers) of that edition 
to the public.

It is requested, but not required, that you contact the authors of the Document 
well before redistributing any large number of copies, to give them a chance to 
provide you with an updated version of the Document.

=== 4. MODIFICATIONS
You may copy and distribute a Modified Version of the Document under the 
conditions of sections 2 and 3 above, provided that you release the Modified 
Version under precisely this License, with the Modified Version filling the 
role of the Document, thus licensing distribution and modification of the 
Modified Version to whoever possesses a copy of it. In addition, you must do 
these things in the Modified Version:

A. Use in the Title Page (and on the covers, if any) a title distinct from that 
of the Document, and from those of previous versions (which should, if there 
were any, be listed in the History section of the Document). You may use the 
same title as a previous version if the original publisher of that version 
gives permission. 

B. List on the Title Page, as authors, one or more persons or entities 
responsible for authorship of the modifications in the Modified Version, 
together with at least five of the principal authors of the Document (all of 
its principal authors, if it has fewer than five), unless they release you from 
this requirement. 

C. State on the Title page the name of the publisher of the Modified Version, 
as the publisher. 

D. Preserve all the copyright notices of the Document. 

E. Add an appropriate copyright notice for your modifications adjacent to the 
other copyright notices. 

F. Include, immediately after the copyright notices, a license notice giving 
the public permission to use the Modified Version under the terms of this 
License, in the form shown in the Addendum below. 

G. Preserve in that license notice the full lists of Invariant Sections and 
required Cover Texts given in the Document's license notice. 

H. Include an unaltered copy of this License. 

I. Preserve the section Entitled "History", Preserve its Title, and add to it 
an item stating at least the title, year, new authors, and publisher of the 
Modified Version as given on the Title Page. If there is no section Entitled 
"History" in the Document, create one stating the title, year, authors, and 
publisher of the Document as given on its Title Page, then add an item 
describing the Modified Version as stated in the previous sentence. 

J. Preserve the network location, if any, given in the Document for public 
access to a Transparent copy of the Document, and likewise the network 
locations given in the Document for previous versions it was based on. These 
may be placed in the "History" section. You may omit a network location for a 
work that was published at least four years before the Document itself, or if 
the original publisher of the version it refers to gives permission. 

K. For any section Entitled "Acknowledgements" or "Dedications", Preserve the 
Title of the section, and preserve in the section all the substance and tone of 
each of the contributor acknowledgements and/or dedications given therein. 

L. Preserve all the Invariant Sections of the Document, unaltered in their text 
and in their titles. Section numbers or the equivalent are not considered part 
of the section titles. 

M. Delete any section Entitled "Endorsements". Such a section may not be 
included in the Modified Version. 

N. Do not retitle any existing section to be Entitled "Endorsements" or to 
conflict in title with any Invariant Section. 

O. Preserve any Warranty Disclaimers. 

If the Modified Version includes new front-matter sections or appendices that 
qualify as Secondary Sections and contain no material copied from the Document, 
you may at your option designate some or all of these sections as invariant. To 
do this, add their titles to the list of Invariant Sections in the Modified 
Version's license notice. These titles must be distinct from any other section 
titles.

You may add a section Entitled "Endorsements", provided it contains nothing but 
endorsements of your Modified Version by various parties—for example, 
statements of peer review or that the text has been approved by an organization 
as the authoritative definition of a standard.

You may add a passage of up to five words as a Front-Cover Text, and a passage 
of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts 
in the Modified Version. Only one passage of Front-Cover Text and one of 
Back-Cover Text may be added by (or through arrangements made by) any one 
entity. If the Document already includes a cover text for the same cover, 
previously added by you or by arrangement made by the same entity you are 
acting on behalf of, you may not add another; but you may replace the old one, 
on explicit permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License give 
permission to use their names for publicity for or to assert or imply 
endorsement of any Modified Version.

=== 5. COMBINING DOCUMENTS
You may combine the Document with other documents released under this License, 
under the terms defined in section 4 above for modified versions, provided that 
you include in the combination all of the Invariant Sections of all of the 
original documents, unmodified, and list them all as Invariant Sections of your 
combined work in its license notice, and that you preserve all their Warranty 
Disclaimers.

The combined work need only contain one copy of this License, and multiple 
identical Invariant Sections may be replaced with a single copy. If there are 
multiple Invariant Sections with the same name but different contents, make the 
title of each such section unique by adding at the end of it, in parentheses, 
the name of the original author or publisher of that section if known, or else 
a unique number. Make the same adjustment to the section titles in the list of 
Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections Entitled "History" in the 
various original documents, forming one section Entitled "History"; likewise 
combine any sections Entitled "Acknowledgements", and any sections Entitled 
"Dedications". You must delete all sections Entitled "Endorsements".

=== 6. COLLECTIONS OF DOCUMENTS
You may make a collection consisting of the Document and other documents 
released under this License, and replace the individual copies of this License 
in the various documents with a single copy that is included in the collection, 
provided that you follow the rules of this License for verbatim copying of each 
of the documents in all other respects.

You may extract a single document from such a collection, and distribute it 
individually under this License, provided you insert a copy of this License 
into the extracted document, and follow this License in all other respects 
regarding verbatim copying of that document.

=== 7. AGGREGATION WITH INDEPENDENT WORKS
A compilation of the Document or its derivatives with other separate and 
independent documents or works, in or on a volume of a storage or distribution 
medium, is called an "aggregate" if the copyright resulting from the 
compilation is not used to limit the legal rights of the compilation's users 
beyond what the individual works permit. When the Document is included in an 
aggregate, this License does not apply to the other works in the aggregate 
which are not themselves derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these copies of the 
Document, then if the Document is less than one half of the entire aggregate, 
the Document's Cover Texts may be placed on covers that bracket the Document 
within the aggregate, or the electronic equivalent of covers if the Document is 
in electronic form. Otherwise they must appear on printed covers that bracket 
the whole aggregate.

=== 8. TRANSLATION
Translation is considered a kind of modification, so you may distribute 
translations of the Document under the terms of section 4. Replacing Invariant 
Sections with translations requires special permission from their copyright 
holders, but you may include translations of some or all Invariant Sections in 
addition to the original versions of these Invariant Sections. You may include 
a translation of this License, and all the license notices in the Document, and 
any Warranty Disclaimers, provided that you also include the original English 
version of this License and the original versions of those notices and 
disclaimers. In case of a disagreement between the translation and the original 
version of this License or a notice or disclaimer, the original version will 
prevail.

If a section in the Document is Entitled "Acknowledgements", "Dedications", or 
"History", the requirement (section 4) to Preserve its Title (section 1) will 
typically require changing the actual title.

=== 9. TERMINATION
You may not copy, modify, sublicense, or distribute the Document except as 
expressly provided under this License. Any attempt otherwise to copy, modify, 
sublicense, or distribute it is void, and will automatically terminate your 
rights under this License.

However, if you cease all violation of this License, then your license from a 
particular copyright holder is reinstated (a) provisionally, unless and until 
the copyright holder explicitly and finally terminates your license, and (b) 
permanently, if the copyright holder fails to notify you of the violation by 
some reasonable means prior to 60 days after the cessation.

Moreover, your license from a particular copyright holder is reinstated 
permanently if the copyright holder notifies you of the violation by some 
reasonable means, this is the first time you have received notice of violation 
of this License (for any work) from that copyright holder, and you cure the 
violation prior to 30 days after your receipt of the notice.

Termination of your rights under this section does not terminate the licenses 
of parties who have received copies or rights from you under this License. If 
your rights have been terminated and not permanently reinstated, receipt of a 
copy of some or all of the same material does not give you any rights to use it.

=== 10. FUTURE REVISIONS OF THIS LICENSE
The Free Software Foundation may publish new, revised versions of the GNU Free 
Documentation License from time to time. Such new versions will be similar in 
spirit to the present version, but may differ in detail to address new problems 
or concerns. See http://www.gnu.org/copyleft/.

Each version of the License is given a distinguishing version number. If the 
Document specifies that a particular numbered version of this License "or any 
later version" applies to it, you have the option of following the terms and 
conditions either of that specified version or of any later version that has 
been published (not as a draft) by the Free Software Foundation. If the 
Document does not specify a version number of this License, you may choose any 
version ever published (not as a draft) by the Free Software Foundation. If the 
Document specifies that a proxy can decide which future versions of this 
License can be used, that proxy's public statement of acceptance of a version 
permanently authorizes you to choose that version for the Document.

=== 11. RELICENSING
"Massive Multiauthor Collaboration Site" (or "MMC Site") means any World Wide 
Web server that publishes copyrightable works and also provides prominent 
facilities for anybody to edit those works. A public wiki that anybody can edit 
is an example of such a server. A "Massive Multiauthor Collaboration" (or 
"MMC") contained in the site means any set of copyrightable works thus 
published on the MMC site.

"CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0 license 
published by Creative Commons Corporation, a not-for-profit corporation with a 
principal place of business in San Francisco, California, as well as future 
copyleft versions of that license published by that same organization.

"Incorporate" means to publish or republish a Document, in whole or in part, as 
part of another Document.

An MMC is "eligible for relicensing" if it is licensed under this License, and 
if all works that were first published under this License somewhere other than 
this MMC, and subsequently incorporated in whole or in part into the MMC, (1) 
had no cover texts or invariant sections, and (2) were thus incorporated prior 
to November 1, 2008.

The operator of an MMC Site may republish an MMC contained in the site under 
CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC 
is eligible for relicensing.


```

`dpkg/changelog.in`:

```in
libmdmp (@VERSION@-1) unstable; urgency=low

  * Auto-generated

 -- Joachim Metz <joachim.metz@gmail.com>  @DPKG_DATE@

```

`dpkg/compat`:

```
10

```

`dpkg/control`:

```
Source: libmdmp
Priority: extra
Maintainer: Joachim Metz <joachim.metz@gmail.com>
Build-Depends: debhelper (>= 9), dh-autoreconf, pkg-config
Standards-Version: 4.1.4
Section: libs
Homepage: https://github.com/libyal/libmdmp
Vcs-Git: https://github.com/libyal/libmdmp.git

Package: libmdmp
Architecture: any
Depends: ${shlibs:Depends}, ${misc:Depends}
Conflicts: libmdmp1
Replaces: libmdmp1
Suggests: libmdmp-dbg
Description: Library to access the Windows Minidump (MDMP) format
 libmdmp is a library to access the Windows Minidump (MDMP) format.

Package: libmdmp-dbg
Architecture: any
Section: debug
Depends: libmdmp (= ${binary:Version}), ${misc:Depends}
Description: Debugging symbols for libmdmp
 Debugging symbols for libmdmp.

Package: libmdmp-dev
Section: libdevel
Architecture: any
Depends: libmdmp (= ${binary:Version}), ${misc:Depends}
Description: Header files and libraries for developing applications for libmdmp
 Header files and libraries for developing applications for libmdmp.

Package: libmdmp-tools
Section: utils
Architecture: any
Depends: libmdmp (= ${binary:Version}), ${shlibs:Depends}, ${misc:Depends}
Conflicts: libmdmp-utils
Replaces: libmdmp-utils
Description: Several tools for reading Windows Minidump (MDMP) files
 Several tools for reading Windows Minidump (MDMP) files.

Package: libmdmp-tools-dbg
Section: debug
Architecture: any
Depends: libmdmp-tools (= ${binary:Version}), ${misc:Depends}
Description: Debugging symbols for libmdmp-tools
 Debugging symbols for libmdmp-tools.


```

`dpkg/copyright`:

```
Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
Upstream-Name: libmdmp
Source: https://github.com/libyal/libmdmp

Files: *
Copyright: 2014-2024, Joachim Metz <joachim.metz@gmail.com>
License: LGPL-3.0+

License: LGPL-3.0+
 This package is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 3 of the License, or (at your option) any later version.
 .
 This package is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 .
 You should have received a copy of the GNU General Public License
 along with this program. If not, see <http://www.gnu.org/licenses/>.
 .
 On Debian systems, the complete text of the GNU Lesser General
 Public License can be found in "/usr/share/common-licenses/LGPL-3".


```

`dpkg/libmdmp-dev.install`:

```install
usr/include/*
usr/lib/*-*/lib*.a
usr/lib/*-*/lib*.so
usr/lib/*-*/pkgconfig/*
usr/share/man/man3

```

`dpkg/libmdmp-tools.install`:

```install
usr/bin
usr/share/man/man1

```

`dpkg/libmdmp.install`:

```install
usr/lib/*-*/lib*.so.*

```

`dpkg/rules`:

```
#!/usr/bin/make -f
# -*- makefile -*-

# Uncomment for debhelper verbose output.
# export DH_VERBOSE=1

%:
	dh $@ --buildsystem=autoconf --with=autoreconf

.PHONY: override_dh_auto_configure
override_dh_auto_configure:
	dh_auto_configure -- CFLAGS="-g"

.PHONY: override_dh_install
override_dh_install:
	dh_install --fail-missing -X.la

.PHONY: override_dh_strip
override_dh_strip:
ifeq (,$(filter nostrip,$(DEB_BUILD_OPTIONS)))
	dh_strip -plibmdmp --dbg-package=libmdmp-dbg
	dh_strip -plibmdmp-tools --dbg-package=libmdmp-tools-dbg
endif


```

`dpkg/source/format`:

```
3.0 (quilt)

```

`include/Makefile.am`:

```am
include_HEADERS = \
	libmdmp.h

pkginclude_HEADERS = \
	libmdmp/codepage.h \
	libmdmp/definitions.h \
	libmdmp/error.h \
	libmdmp/extern.h \
	libmdmp/features.h \
	libmdmp/types.h

EXTRA_DIST = \
	libmdmp.h.in \
	libmdmp/definitions.h.in \
	libmdmp/features.h.in \
	libmdmp/types.h.in

MAINTAINERCLEANFILES = \
	Makefile.in

distclean: clean
	-rm -f libmdmp.h
	-rm -f libmdmp/definitions.h
	-rm -f libmdmp/features.h
	-rm -f libmdmp/types.h
	-rm -f Makefile


```

`include/libmdmp.h.in`:

```in
/*
 * Library to access the Windows Minidump (MDMP) file format
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_H )
#define _LIBMDMP_H

#include <libmdmp/codepage.h>
#include <libmdmp/definitions.h>
#include <libmdmp/error.h>
#include <libmdmp/extern.h>
#include <libmdmp/features.h>
#include <libmdmp/types.h>

#include <stdio.h>

#if defined( LIBMDMP_HAVE_BFIO )
#include <libbfio.h>
#endif

#if defined( __cplusplus )
extern "C" {
#endif

/* -------------------------------------------------------------------------
 * Support functions
 * ------------------------------------------------------------------------- */

/* Returns the library version
 */
LIBMDMP_EXTERN \
const char *libmdmp_get_version(
             void );

/* Returns the access flags for reading
 */
LIBMDMP_EXTERN \
int libmdmp_get_access_flags_read(
     void );

/* Retrieves the narrow system string codepage
 * A value of 0 represents no codepage, UTF-8 encoding is used instead
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_get_codepage(
     int *codepage,
     libmdmp_error_t **error );

/* Sets the narrow system string codepage
 * A value of 0 represents no codepage, UTF-8 encoding is used instead
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_set_codepage(
     int codepage,
     libmdmp_error_t **error );

/* Determines if a file contains a MDMP file signature
 * Returns 1 if true, 0 if not or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_check_file_signature(
     const char *filename,
     libmdmp_error_t **error );

#if defined( LIBMDMP_HAVE_WIDE_CHARACTER_TYPE )

/* Determines if a file contains a MDMP file signature
 * Returns 1 if true, 0 if not or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_check_file_signature_wide(
     const wchar_t *filename,
     libmdmp_error_t **error );

#endif /* defined( LIBMDMP_HAVE_WIDE_CHARACTER_TYPE ) */

#if defined( LIBMDMP_HAVE_BFIO )

/* Determines if a file contains a MDMP file signature using a Basic File IO (bfio) handle
 * Returns 1 if true, 0 if not or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_check_file_signature_file_io_handle(
     libbfio_handle_t *file_io_handle,
     libmdmp_error_t **error );

#endif /* defined( LIBMDMP_HAVE_BFIO ) */

/* -------------------------------------------------------------------------
 * Notify functions
 * ------------------------------------------------------------------------- */

/* Sets the verbose notification
 */
LIBMDMP_EXTERN \
void libmdmp_notify_set_verbose(
      int verbose );

/* Sets the notification stream
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_notify_set_stream(
     FILE *stream,
     libmdmp_error_t **error );

/* Opens the notification stream using a filename
 * The stream is opened in append mode
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_notify_stream_open(
     const char *filename,
     libmdmp_error_t **error );

/* Closes the notification stream if opened using a filename
 * Returns 0 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_notify_stream_close(
     libmdmp_error_t **error );

/* -------------------------------------------------------------------------
 * Error functions
 * ------------------------------------------------------------------------- */

/* Frees an error
 */
LIBMDMP_EXTERN \
void libmdmp_error_free(
      libmdmp_error_t **error );

/* Prints a descriptive string of the error to the stream
 * Returns the number of printed characters if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_error_fprint(
     libmdmp_error_t *error,
     FILE *stream );

/* Prints a descriptive string of the error to the string
 * The end-of-string character is not included in the return value
 * Returns the number of printed characters if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_error_sprint(
     libmdmp_error_t *error,
     char *string,
     size_t size );

/* Prints a backtrace of the error to the stream
 * Returns the number of printed characters if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_error_backtrace_fprint(
     libmdmp_error_t *error,
     FILE *stream );

/* Prints a backtrace of the error to the string
 * The end-of-string character is not included in the return value
 * Returns the number of printed characters if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_error_backtrace_sprint(
     libmdmp_error_t *error,
     char *string,
     size_t size );

/* -------------------------------------------------------------------------
 * File functions
 * ------------------------------------------------------------------------- */

/* Creates a file
 * Make sure the value file is referencing, is set to NULL
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_file_initialize(
     libmdmp_file_t **file,
     libmdmp_error_t **error );

/* Frees a file
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_file_free(
     libmdmp_file_t **file,
     libmdmp_error_t **error );

/* Signals the libmdmp file to abort its current activity
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_file_signal_abort(
     libmdmp_file_t *file,
     libmdmp_error_t **error );

/* Opens a file
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_file_open(
     libmdmp_file_t *file,
     const char *filename,
     int access_flags,
     libmdmp_error_t **error );

#if defined( LIBMDMP_HAVE_WIDE_CHARACTER_TYPE )

/* Opens a file
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_file_open_wide(
     libmdmp_file_t *file,
     const wchar_t *filename,
     int access_flags,
     libmdmp_error_t **error );

#endif /* defined( LIBMDMP_HAVE_WIDE_CHARACTER_TYPE ) */

#if defined( LIBMDMP_HAVE_BFIO )

/* Opens a file using a Basic File IO (bfio) handle
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_file_open_file_io_handle(
     libmdmp_file_t *file,
     libbfio_handle_t *file_io_handle,
     int access_flags,
     libmdmp_error_t **error );

#endif /* defined( LIBMDMP_HAVE_BFIO ) */

/* Closes a file
 * Returns 0 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_file_close(
     libmdmp_file_t *file,
     libmdmp_error_t **error );

/* Retrieves the number of streams
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_file_get_number_of_streams(
     libmdmp_file_t *file,
     int *number_of_streams,
     libmdmp_error_t **error );

/* Retrieves a specific stream
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_file_get_stream(
     libmdmp_file_t *file,
     int stream_index,
     libmdmp_stream_t **stream,
     libmdmp_error_t **error );

/* Retrieves a specific stream by type
 * Returns 1 if successful, 0 if no such stream or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_file_get_stream_by_type(
     libmdmp_file_t *file,
     uint32_t stream_type,
     libmdmp_stream_t **stream,
     libmdmp_error_t **error );

/* -------------------------------------------------------------------------
 * Stream functions
 * ------------------------------------------------------------------------- */

/* Frees a stream
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_stream_free(
     libmdmp_stream_t **stream,
     libmdmp_error_t **error );

/* Retrieves the type
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_stream_get_type(
     libmdmp_stream_t *stream,
     uint32_t *type,
     libmdmp_error_t **error );

/* Reads data at the current offset into a buffer
 * Returns the number of bytes read or -1 on error
 */
LIBMDMP_EXTERN \
ssize_t libmdmp_stream_read_buffer(
         libmdmp_stream_t *stream,
         void *buffer,
         size_t buffer_size,
         libmdmp_error_t **error );

/* Reads data at a specific offset into a buffer
 * Returns the number of bytes read or -1 on error
 */
LIBMDMP_EXTERN \
ssize_t libmdmp_stream_read_buffer_at_offset(
         libmdmp_stream_t *stream,
         void *buffer,
         size_t buffer_size,
         off64_t offset,
         libmdmp_error_t **error );

/* Seeks a certain offset of the data
 * Returns the offset if seek is successful or -1 on error
 */
LIBMDMP_EXTERN \
off64_t libmdmp_stream_seek_offset(
         libmdmp_stream_t *stream,
         off64_t offset,
         int whence,
         libmdmp_error_t **error );

/* Retrieves the (current) offset
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_stream_get_offset(
     libmdmp_stream_t *stream,
     off64_t *offset,
     libmdmp_error_t **error );

/* Retrieves the size
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_stream_get_size(
     libmdmp_stream_t *stream,
     size64_t *size,
     libmdmp_error_t **error );

/* Retrieves the start offset
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_stream_get_start_offset(
     libmdmp_stream_t *stream,
     off64_t *start_offset,
     libmdmp_error_t **error );

/* Retrieves the virtual address
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_stream_get_virtual_address(
     libmdmp_stream_t *stream,
     uint32_t *virtual_address,
     libmdmp_error_t **error );

#if defined( LIBMDMP_HAVE_BFIO )
/* Retrieves the stream data file io handle
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_stream_get_data_file_io_handle(
     libmdmp_stream_t *stream,
     libbfio_handle_t **file_io_handle,
     libmdmp_error_t **error );
#endif

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_H ) */


```

`include/libmdmp/codepage.h`:

```h
/*
 * Codepage definitions for libmdmp
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_CODEPAGE_H )
#define _LIBMDMP_CODEPAGE_H

#include <libmdmp/types.h>

#if defined( __cplusplus )
extern "C" {
#endif

/* The codepage definitions
 */
enum LIBMDMP_CODEPAGES
{
	LIBMDMP_CODEPAGE_ASCII				= 20127,

	LIBMDMP_CODEPAGE_ISO_8859_1			= 28591,
	LIBMDMP_CODEPAGE_ISO_8859_2			= 28592,
	LIBMDMP_CODEPAGE_ISO_8859_3			= 28593,
	LIBMDMP_CODEPAGE_ISO_8859_4			= 28594,
	LIBMDMP_CODEPAGE_ISO_8859_5			= 28595,
	LIBMDMP_CODEPAGE_ISO_8859_6			= 28596,
	LIBMDMP_CODEPAGE_ISO_8859_7			= 28597,
	LIBMDMP_CODEPAGE_ISO_8859_8			= 28598,
	LIBMDMP_CODEPAGE_ISO_8859_9			= 28599,
	LIBMDMP_CODEPAGE_ISO_8859_10			= 28600,
	LIBMDMP_CODEPAGE_ISO_8859_11			= 28601,
	LIBMDMP_CODEPAGE_ISO_8859_13			= 28603,
	LIBMDMP_CODEPAGE_ISO_8859_14			= 28604,
	LIBMDMP_CODEPAGE_ISO_8859_15			= 28605,
	LIBMDMP_CODEPAGE_ISO_8859_16			= 28606,

	LIBMDMP_CODEPAGE_KOI8_R				= 20866,
	LIBMDMP_CODEPAGE_KOI8_U				= 21866,

	LIBMDMP_CODEPAGE_WINDOWS_874			= 874,
	LIBMDMP_CODEPAGE_WINDOWS_932			= 932,
	LIBMDMP_CODEPAGE_WINDOWS_936			= 936,
	LIBMDMP_CODEPAGE_WINDOWS_949			= 949,
	LIBMDMP_CODEPAGE_WINDOWS_950			= 950,
	LIBMDMP_CODEPAGE_WINDOWS_1250			= 1250,
	LIBMDMP_CODEPAGE_WINDOWS_1251			= 1251,
	LIBMDMP_CODEPAGE_WINDOWS_1252			= 1252,
	LIBMDMP_CODEPAGE_WINDOWS_1253			= 1253,
	LIBMDMP_CODEPAGE_WINDOWS_1254			= 1254,
	LIBMDMP_CODEPAGE_WINDOWS_1255			= 1255,
	LIBMDMP_CODEPAGE_WINDOWS_1256			= 1256,
	LIBMDMP_CODEPAGE_WINDOWS_1257			= 1257,
	LIBMDMP_CODEPAGE_WINDOWS_1258			= 1258
};

#define LIBMDMP_CODEPAGE_US_ASCII			LIBMDMP_CODEPAGE_ASCII

#define LIBMDMP_CODEPAGE_ISO_WESTERN_EUROPEAN		LIBMDMP_CODEPAGE_ISO_8859_1
#define LIBMDMP_CODEPAGE_ISO_CENTRAL_EUROPEAN		LIBMDMP_CODEPAGE_ISO_8859_2
#define LIBMDMP_CODEPAGE_ISO_SOUTH_EUROPEAN		LIBMDMP_CODEPAGE_ISO_8859_3
#define LIBMDMP_CODEPAGE_ISO_NORTH_EUROPEAN		LIBMDMP_CODEPAGE_ISO_8859_4
#define LIBMDMP_CODEPAGE_ISO_CYRILLIC			LIBMDMP_CODEPAGE_ISO_8859_5
#define LIBMDMP_CODEPAGE_ISO_ARABIC			LIBMDMP_CODEPAGE_ISO_8859_6
#define LIBMDMP_CODEPAGE_ISO_GREEK			LIBMDMP_CODEPAGE_ISO_8859_7
#define LIBMDMP_CODEPAGE_ISO_HEBREW			LIBMDMP_CODEPAGE_ISO_8859_8
#define LIBMDMP_CODEPAGE_ISO_TURKISH			LIBMDMP_CODEPAGE_ISO_8859_9
#define LIBMDMP_CODEPAGE_ISO_NORDIC			LIBMDMP_CODEPAGE_ISO_8859_10
#define LIBMDMP_CODEPAGE_ISO_THAI			LIBMDMP_CODEPAGE_ISO_8859_11
#define LIBMDMP_CODEPAGE_ISO_BALTIC			LIBMDMP_CODEPAGE_ISO_8859_13
#define LIBMDMP_CODEPAGE_ISO_CELTIC			LIBMDMP_CODEPAGE_ISO_8859_14

#define LIBMDMP_CODEPAGE_ISO_LATIN_1			LIBMDMP_CODEPAGE_ISO_8859_1
#define LIBMDMP_CODEPAGE_ISO_LATIN_2			LIBMDMP_CODEPAGE_ISO_8859_2
#define LIBMDMP_CODEPAGE_ISO_LATIN_3			LIBMDMP_CODEPAGE_ISO_8859_3
#define LIBMDMP_CODEPAGE_ISO_LATIN_4			LIBMDMP_CODEPAGE_ISO_8859_4
#define LIBMDMP_CODEPAGE_ISO_LATIN_5			LIBMDMP_CODEPAGE_ISO_8859_9
#define LIBMDMP_CODEPAGE_ISO_LATIN_6			LIBMDMP_CODEPAGE_ISO_8859_10
#define LIBMDMP_CODEPAGE_ISO_LATIN_7			LIBMDMP_CODEPAGE_ISO_8859_13
#define LIBMDMP_CODEPAGE_ISO_LATIN_8			LIBMDMP_CODEPAGE_ISO_8859_14
#define LIBMDMP_CODEPAGE_ISO_LATIN_9			LIBMDMP_CODEPAGE_ISO_8859_15
#define LIBMDMP_CODEPAGE_ISO_LATIN_10			LIBMDMP_CODEPAGE_ISO_8859_16

#define LIBMDMP_CODEPAGE_KOI8_RUSSIAN			LIBMDMP_CODEPAGE_KOI8_R
#define LIBMDMP_CODEPAGE_KOI8_UKRAINIAN			LIBMDMP_CODEPAGE_KOI8_U

#define LIBMDMP_CODEPAGE_WINDOWS_THAI			LIBMDMP_CODEPAGE_WINDOWS_874
#define LIBMDMP_CODEPAGE_WINDOWS_JAPANESE		LIBMDMP_CODEPAGE_WINDOWS_932
#define LIBMDMP_CODEPAGE_WINDOWS_CHINESE_SIMPLIFIED	LIBMDMP_CODEPAGE_WINDOWS_936
#define LIBMDMP_CODEPAGE_WINDOWS_KOREAN			LIBMDMP_CODEPAGE_WINDOWS_949
#define LIBMDMP_CODEPAGE_WINDOWS_CHINESE_TRADITIONAL	LIBMDMP_CODEPAGE_WINDOWS_950
#define LIBMDMP_CODEPAGE_WINDOWS_CENTRAL_EUROPEAN	LIBMDMP_CODEPAGE_WINDOWS_1250
#define LIBMDMP_CODEPAGE_WINDOWS_CYRILLIC		LIBMDMP_CODEPAGE_WINDOWS_1251
#define LIBMDMP_CODEPAGE_WINDOWS_WESTERN_EUROPEAN	LIBMDMP_CODEPAGE_WINDOWS_1252
#define LIBMDMP_CODEPAGE_WINDOWS_GREEK			LIBMDMP_CODEPAGE_WINDOWS_1253
#define LIBMDMP_CODEPAGE_WINDOWS_TURKISH		LIBMDMP_CODEPAGE_WINDOWS_1254
#define LIBMDMP_CODEPAGE_WINDOWS_HEBREW			LIBMDMP_CODEPAGE_WINDOWS_1255
#define LIBMDMP_CODEPAGE_WINDOWS_ARABIC			LIBMDMP_CODEPAGE_WINDOWS_1256
#define LIBMDMP_CODEPAGE_WINDOWS_BALTIC			LIBMDMP_CODEPAGE_WINDOWS_1257
#define LIBMDMP_CODEPAGE_WINDOWS_VIETNAMESE		LIBMDMP_CODEPAGE_WINDOWS_1258

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_CODEPAGE_H ) */


```

`include/libmdmp/definitions.h.in`:

```in
/*
 * Definitions for libmdmp
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_DEFINITIONS_H )
#define _LIBMDMP_DEFINITIONS_H

#include <libmdmp/types.h>

#define LIBMDMP_VERSION			@VERSION@

/* The version string
 */
#define LIBMDMP_VERSION_STRING		"@VERSION@"

/* The access flags definitions
 * bit 1        set to 1 for read access
 * bit 2        set to 1 for write access
 * bit 3-8      not used
 */
enum LIBMDMP_ACCESS_FLAGS
{
	LIBMDMP_ACCESS_FLAG_READ	= 0x01,
/* Reserved: not supported yet */
	LIBMDMP_ACCESS_FLAG_WRITE	= 0x02
};

/* The file access macros
 */
#define LIBMDMP_OPEN_READ		( LIBMDMP_ACCESS_FLAG_READ )
/* Reserved: not supported yet */
#define LIBMDMP_OPEN_WRITE		( LIBMDMP_ACCESS_FLAG_WRITE )
/* Reserved: not supported yet */
#define LIBMDMP_OPEN_READ_WRITE		( LIBMDMP_ACCESS_FLAG_READ | LIBMDMP_ACCESS_FLAG_WRITE )

#endif /* !defined( _LIBMDMP_DEFINITIONS_H ) */


```

`include/libmdmp/error.h`:

```h
/*
 * The error code definitions for libmdmp
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_ERROR_H )
#define _LIBMDMP_ERROR_H

#include <libmdmp/types.h>

/* External error type definition hides internal structure
 */
typedef intptr_t libmdmp_error_t;

/* The error domains
 */
enum LIBMDMP_ERROR_DOMAINS
{
	LIBMDMP_ERROR_DOMAIN_ARGUMENTS			= (int) 'a',
	LIBMDMP_ERROR_DOMAIN_CONVERSION			= (int) 'c',
	LIBMDMP_ERROR_DOMAIN_COMPRESSION		= (int) 'C',
	LIBMDMP_ERROR_DOMAIN_IO				= (int) 'I',
	LIBMDMP_ERROR_DOMAIN_INPUT			= (int) 'i',
	LIBMDMP_ERROR_DOMAIN_MEMORY			= (int) 'm',
	LIBMDMP_ERROR_DOMAIN_OUTPUT			= (int) 'o',
	LIBMDMP_ERROR_DOMAIN_RUNTIME			= (int) 'r'
};

/* The argument error codes
 * to signify errors regarding arguments passed to a function
 */
enum LIBMDMP_ARGUMENT_ERROR
{
	LIBMDMP_ARGUMENT_ERROR_GENERIC			= 0,

	/* The argument contains an invalid value
	 */
	LIBMDMP_ARGUMENT_ERROR_INVALID_VALUE		= 1,

	/* The argument contains a value less than zero
	 */
	LIBMDMP_ARGUMENT_ERROR_VALUE_LESS_THAN_ZERO	= 2,

	/* The argument contains a value zero or less
	 */
	LIBMDMP_ARGUMENT_ERROR_VALUE_ZERO_OR_LESS	= 3,

	/* The argument contains a value that exceeds the maximum
	 * for the specific type
	 */
	LIBMDMP_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM	= 4,

	/* The argument contains a value that is too small
	 */
	LIBMDMP_ARGUMENT_ERROR_VALUE_TOO_SMALL		= 5,

	/* The argument contains a value that is too large
	 */
	LIBMDMP_ARGUMENT_ERROR_VALUE_TOO_LARGE		= 6,

	/* The argument contains a value that is out of bounds
	 */
	LIBMDMP_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS	= 7,

	/* The argument contains a value that is not supported
	 */
	LIBMDMP_ARGUMENT_ERROR_UNSUPPORTED_VALUE	= 8,

	/* The argument contains a value that conficts with another argument
	 */
	LIBMDMP_ARGUMENT_ERROR_CONFLICTING_VALUE	= 9
};

/* The conversion error codes
 * to signify errors regarding conversions
 */
enum LIBMDMP_CONVERSION_ERROR
{
	LIBMDMP_CONVERSION_ERROR_GENERIC		= 0,

	/* The conversion failed on the input
	 */
	LIBMDMP_CONVERSION_ERROR_INPUT_FAILED		= 1,

	/* The conversion failed on the output
	 */
	LIBMDMP_CONVERSION_ERROR_OUTPUT_FAILED		= 2
};

/* The compression error codes
 * to signify errors regarding compression
 */
enum LIBMDMP_COMPRESSION_ERROR
{
	LIBMDMP_COMPRESSION_ERROR_GENERIC		= 0,

	/* The compression failed
	 */
	LIBMDMP_COMPRESSION_ERROR_COMPRESS_FAILED	= 1,

	/* The decompression failed
	 */
	LIBMDMP_COMPRESSION_ERROR_DECOMPRESS_FAILED	= 2
};

/* The input/output error codes
 * to signify errors regarding input/output
 */
enum LIBMDMP_IO_ERROR
{
	LIBMDMP_IO_ERROR_GENERIC			= 0,

	/* The open failed
	 */
	LIBMDMP_IO_ERROR_OPEN_FAILED			= 1,

	/* The close failed
	 */
	LIBMDMP_IO_ERROR_CLOSE_FAILED			= 2,

	/* The seek failed
	 */
	LIBMDMP_IO_ERROR_SEEK_FAILED			= 3,

	/* The read failed
	 */
	LIBMDMP_IO_ERROR_READ_FAILED			= 4,

	/* The write failed
	 */
	LIBMDMP_IO_ERROR_WRITE_FAILED			= 5,

	/* Access denied
	 */
	LIBMDMP_IO_ERROR_ACCESS_DENIED			= 6,

	/* The resource is invalid i.e. a missing file
	 */
	LIBMDMP_IO_ERROR_INVALID_RESOURCE		= 7,

	/* The ioctl failed
	 */
	LIBMDMP_IO_ERROR_IOCTL_FAILED			= 8,

	/* The unlink failed
	 */
	LIBMDMP_IO_ERROR_UNLINK_FAILED			= 9
};

/* The input error codes
 * to signify errors regarding handing input data
 */
enum LIBMDMP_INPUT_ERROR
{
	LIBMDMP_INPUT_ERROR_GENERIC			= 0,

	/* The input contains invalid data
	 */
	LIBMDMP_INPUT_ERROR_INVALID_DATA		= 1,

	/* The input contains an unsupported signature
	 */
	LIBMDMP_INPUT_ERROR_SIGNATURE_MISMATCH		= 2,

	/* A checksum in the input did not match
	 */
	LIBMDMP_INPUT_ERROR_CHECKSUM_MISMATCH		= 3,

	/* A value in the input did not match a previously
	 * read value or calculated value
	 */
	LIBMDMP_INPUT_ERROR_VALUE_MISMATCH		= 4
};

/* The memory error codes
 * to signify errors regarding memory
 */
enum LIBMDMP_MEMORY_ERROR
{
	LIBMDMP_MEMORY_ERROR_GENERIC			= 0,

	/* There is insufficient memory available
	 */
	LIBMDMP_MEMORY_ERROR_INSUFFICIENT		= 1,

	/* The memory failed to be copied
	 */
	LIBMDMP_MEMORY_ERROR_COPY_FAILED		= 2,

	/* The memory failed to be set
	 */
	LIBMDMP_MEMORY_ERROR_SET_FAILED			= 3
};

/* The output error codes
 */
enum LIBMDMP_OUTPUT_ERROR
{
	LIBMDMP_OUTPUT_ERROR_GENERIC			= 0,

	/* There is insuficient space to write the output
	 */
	LIBMDMP_OUTPUT_ERROR_INSUFFICIENT_SPACE		= 1
};

/* The runtime error codes
 * to signify errors regarding runtime processing
 */
enum LIBMDMP_RUNTIME_ERROR
{
	LIBMDMP_RUNTIME_ERROR_GENERIC			= 0,

	/* The value is missing
	 */
	LIBMDMP_RUNTIME_ERROR_VALUE_MISSING		= 1,

	/* The value was already set
	 */
	LIBMDMP_RUNTIME_ERROR_VALUE_ALREADY_SET		= 2,

	/* The creation and/or initialization of an internal structure failed
	 */
	LIBMDMP_RUNTIME_ERROR_INITIALIZE_FAILED		= 3,

	/* The resize of an internal structure failed
	 */
	LIBMDMP_RUNTIME_ERROR_RESIZE_FAILED		= 4,

	/* The free and/or finalization of an internal structure failed
	 */
	LIBMDMP_RUNTIME_ERROR_FINALIZE_FAILED		= 5,

	/* The value could not be determined
	 */
	LIBMDMP_RUNTIME_ERROR_GET_FAILED		= 6,

	/* The value could not be set
	 */
	LIBMDMP_RUNTIME_ERROR_SET_FAILED		= 7,

	/* The value could not be appended/prepended
	 */
	LIBMDMP_RUNTIME_ERROR_APPEND_FAILED		= 8,

	/* The value could not be copied
	 */
	LIBMDMP_RUNTIME_ERROR_COPY_FAILED		= 9,

	/* The value could not be removed
	 */
	LIBMDMP_RUNTIME_ERROR_REMOVE_FAILED		= 10,

	/* The value could not be printed
	 */
	LIBMDMP_RUNTIME_ERROR_PRINT_FAILED		= 11,

	/* The value was out of bounds
	 */
	LIBMDMP_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS	= 12,

	/* The value exceeds the maximum for its specific type
	 */
	LIBMDMP_RUNTIME_ERROR_VALUE_EXCEEDS_MAXIMUM	= 13,

	/* The value is unsupported
	 */
	LIBMDMP_RUNTIME_ERROR_UNSUPPORTED_VALUE		= 14,

	/* An abort was requested
	 */
	LIBMDMP_RUNTIME_ERROR_ABORT_REQUESTED		= 15
};

#endif /* !defined( _LIBMDMP_ERROR_H ) */


```

`include/libmdmp/extern.h`:

```h
/*
 * The extern definition
 *
 * This header should be included in header files that export or import
 * library functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_EXTERN_H )
#define _LIBMDMP_EXTERN_H

/* To export functions from the libmdmp DLL define LIBMDMP_DLL_EXPORT
 * To import functions from the libmdmp DLL define LIBMDMP_DLL_IMPORT
 * Otherwise use default extern statement
 */
#if defined( LIBMDMP_DLL_EXPORT )
#define LIBMDMP_EXTERN __declspec(dllexport)

#elif defined( LIBMDMP_DLL_IMPORT )
#define LIBMDMP_EXTERN extern __declspec(dllimport)

#else
#define LIBMDMP_EXTERN extern

#endif

#endif /* !defined( _LIBMDMP_EXTERN_H ) */


```

`include/libmdmp/features.h.in`:

```in
/*
 * Features of libmdmp
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_FEATURES_H )
#define _LIBMDMP_FEATURES_H

/* The libmdmp type support features
 */
#if defined( WINAPI ) || @HAVE_WIDE_CHARACTER_TYPE@
#define LIBMDMP_HAVE_WIDE_CHARACTER_TYPE	1
#endif

#if defined( WINAPI ) || @HAVE_MULTI_THREAD_SUPPORT@
#define LIBMDMP_HAVE_MULTI_THREAD_SUPPORT	1
#endif

#if defined( HAVE_LIBBFIO ) || ( !defined( WINAPI ) && @HAVE_LIBBFIO@ )
#define LIBMDMP_HAVE_BFIO			1
#endif

#if !defined( LIBMDMP_DEPRECATED )
#if defined( __GNUC__ ) && __GNUC__ >= 3
#define LIBMDMP_DEPRECATED	__attribute__ ((__deprecated__))
#elif defined( _MSC_VER )
#define LIBMDMP_DEPRECATED	__declspec(deprecated)
#else
#define LIBMDMP_DEPRECATED
#endif
#endif

#endif /* !defined( _LIBMDMP_FEATURES_H ) */


```

`include/libmdmp/types.h.in`:

```in
/*
 * Type definitions for libmdmp
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_TYPES_H )
#define _LIBMDMP_TYPES_H

#include <libmdmp/features.h>

/* Integer type definitions
 */
#if ( defined( _MSC_VER ) && ( _MSC_VER < 1600 ) ) || ( defined( __BORLANDC__ ) && ( __BORLANDC__ <= 0x0560 ) )

#ifdef __cplusplus
extern "C" {
#endif

/* Microsoft Visual Studio C++ before Visual Studio 2010 or earlier versions of the Borland C++ Builder
 * do not support the (u)int#_t type definitions but have __int# definitions instead
 */
#if !defined( HAVE_INT8_T )
#define HAVE_INT8_T
typedef __int8 int8_t;
#endif

#if !defined( HAVE_UINT8_T )
#define HAVE_UINT8_T
typedef unsigned __int8 uint8_t;
#endif

#if !defined( HAVE_INT16_T )
#define HAVE_INT16_T
typedef __int16 int16_t;
#endif

#if !defined( HAVE_UINT16_T )
#define HAVE_UINT16_T
typedef unsigned __int16 uint16_t;
#endif

#if !defined( HAVE_INT32_T )
#define HAVE_INT32_T
typedef __int32 int32_t;
#endif

#if !defined( HAVE_UINT32_T )
#define HAVE_UINT32_T
typedef unsigned __int32 uint32_t;
#endif

#if !defined( HAVE_INT64_T )
#define HAVE_INT64_T
typedef __int64 int64_t;
#endif

#if !defined( HAVE_UINT64_T )
#define HAVE_UINT64_T
typedef unsigned __int64 uint64_t;
#endif

#ifdef __cplusplus
}
#endif

#elif defined( _MSC_VER ) || defined( __BORLANDC__ )

/* Later versions of Microsoft Visual Studio C++ and Borland C/C++ define the types in <stdint.h>
 */
#include <stdint.h>

#else

#if @HAVE_SYS_TYPES_H@ || defined( HAVE_SYS_TYPES_H )
#include <sys/types.h>

#else
#error Missing system type definitions (sys/types.h)
#endif

/* Type definitions for compilers that have access to
 * <inttypes.h> or <stdint.h>
 */
#if @HAVE_INTTYPES_H@ || defined( HAVE_INTTYPES_H )
#include <inttypes.h>

#elif @HAVE_STDINT_H@ || defined( HAVE_STDINT_H )
#include <stdint.h>

#else
#error Missing integer type definitions (inttypes.h, stdint.h)
#endif

#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined( _MSC_VER ) || ( defined( __BORLANDC__ ) && ( __BORLANDC__ <= 0x0560 ) )

/* Microsoft Visual Studio C++ or earlier versions of the Borland C++ Builder
 * do not support the ssize_t type definition
 */
#if !defined( HAVE_SSIZE_T )
#define HAVE_SSIZE_T

#if defined( _WIN64 )
typedef __int64 ssize_t;
#else
typedef __int32 ssize_t;
#endif

#endif /* !defined( HAVE_SSIZE_T ) */

#endif /* defined( _MSC_VER ) || ( defined( __BORLANDC__ ) && ( __BORLANDC__ <= 0x0560 ) ) */

#if defined( __BORLANDC__ ) && ( __BORLANDC__ <= 0x0560 )

/* Earlier versions of Borland C++ Builder do not support the intptr_t type definition
 */
#if !defined( HAVE_INTPTR_T )
#define HAVE_INTPTR_T

#if defined( _WIN64 )
typedef __int64	intptr_t;
#else
typedef __int32	intptr_t;
#endif

#endif /* !defined( HAVE_INTPTR_T ) */

#endif /* defined( __BORLANDC__ ) && ( __BORLANDC__ <= 0x0560 ) */

#if ( !defined( HAVE_SIZE32_T ) && ! @HAVE_SIZE32_T@ ) || HAVE_SIZE32_T == 0
#define HAVE_SIZE32_T	1
typedef uint32_t size32_t;
#endif

#if ( !defined( HAVE_SSIZE32_T ) && ! @HAVE_SSIZE32_T@ ) || HAVE_SSIZE32_T == 0
#define HAVE_SSIZE32_T	1
typedef int32_t ssize32_t;
#endif

#if ( !defined( HAVE_SIZE64_T ) && ! @HAVE_SIZE64_T@ ) || HAVE_SIZE64_T == 0
#define HAVE_SIZE64_T	1
typedef uint64_t size64_t;
#endif

#if ( !defined( HAVE_SSIZE64_T ) && ! @HAVE_SSIZE64_T@ ) || HAVE_SSIZE64_T == 0
#define HAVE_SSIZE64_T	1
typedef int64_t ssize64_t;
#endif

#if ( !defined( HAVE_OFF64_T ) && ! @HAVE_OFF64_T@ ) || HAVE_OFF64_T == 0
#define HAVE_OFF64_T	1
typedef int64_t off64_t;
#endif

/* Wide character definition
 */
#if defined( __BORLANDC__ ) && ( __BORLANDC__ <= 0x0520 )
#include <string.h>

#elif defined( WINAPI )
#include <wchar.h>

#elif @HAVE_WCHAR_H@ || defined( HAVE_WCHAR_H )

/* __USE_UNIX98 is required to add swprintf definition
 */
#if !defined( __USE_UNIX98 )
#define __USE_UNIX98
#define LIBMDMP_DEFINITION_UNIX98
#endif

#include <wchar.h>

#if defined( LIBMDMP_DEFINITION_UNIX98 )
#undef __USE_UNIX98
#undef LIBMDMP_DEFINITION_UNIX98
#endif

#endif

/* The following type definitions hide internal data structures
 */
typedef intptr_t libmdmp_file_t;
typedef intptr_t libmdmp_stream_t;

#ifdef __cplusplus
}
#endif

#endif /* !defined( _LIBMDMP_TYPES_H ) */


```

`libmdmp.ini`:

```ini
[project]
description: "libmdmp is a library to access the Windows Minidump (MDMP) format."
name: "libmdmp"
status: "experimental"
year_of_creation: "2014"
features: ["debug_output"]

[library]
description: "Library to access the Windows Minidump (MDMP) format"
public_types: ["file", "stream"]

[tools]
description: "Several tools for reading Windows Minidump (MDMP) files"
names: ["mdmpinfo"]

[tests]
profiles: ["libmdmp", "mdmpinfo"]
info_tool_options_per_profile: [""]
info_tool_profiles: ["mdmpinfo"]
example_filename1: "file1.dmp"
example_filename2: "file2.dmp"


```

`libmdmp.pc.in`:

```in
prefix=@prefix@
exec_prefix=@exec_prefix@
libdir=@libdir@
includedir=@includedir@

Name: libmdmp
Description: Library to access the Windows Minidump (MDMP) format
Version: @VERSION@
Libs: -L${libdir} -lmdmp
Libs.private: @ax_libbfio_pc_libs_private@ @ax_libcdata_pc_libs_private@ @ax_libcerror_pc_libs_private@ @ax_libcfile_pc_libs_private@ @ax_libclocale_pc_libs_private@ @ax_libcnotify_pc_libs_private@ @ax_libcpath_pc_libs_private@ @ax_libcsplit_pc_libs_private@ @ax_libcthreads_pc_libs_private@ @ax_libfcache_pc_libs_private@ @ax_libfdata_pc_libs_private@ @ax_libfdatetime_pc_libs_private@ @ax_libuna_pc_libs_private@ @ax_pthread_pc_libs_private@
Cflags: -I${includedir}


```

`libmdmp.spec.in`:

```in
Name: libmdmp
Version: @VERSION@
Release: 1
Summary: Library to access the Windows Minidump (MDMP) format
Group: System Environment/Libraries
License: LGPL-3.0-or-later
Source: %{name}-%{version}.tar.gz
URL: https://github.com/libyal/libmdmp
@libmdmp_spec_requires@ @ax_libbfio_spec_requires@ @ax_libcdata_spec_requires@ @ax_libcerror_spec_requires@ @ax_libcfile_spec_requires@ @ax_libclocale_spec_requires@ @ax_libcnotify_spec_requires@ @ax_libcpath_spec_requires@ @ax_libcsplit_spec_requires@ @ax_libcthreads_spec_requires@ @ax_libfcache_spec_requires@ @ax_libfdata_spec_requires@ @ax_libfdatetime_spec_requires@ @ax_libuna_spec_requires@
BuildRequires: gcc @ax_libbfio_spec_build_requires@ @ax_libcdata_spec_build_requires@ @ax_libcerror_spec_build_requires@ @ax_libcfile_spec_build_requires@ @ax_libclocale_spec_build_requires@ @ax_libcnotify_spec_build_requires@ @ax_libcpath_spec_build_requires@ @ax_libcsplit_spec_build_requires@ @ax_libcthreads_spec_build_requires@ @ax_libfcache_spec_build_requires@ @ax_libfdata_spec_build_requires@ @ax_libfdatetime_spec_build_requires@ @ax_libuna_spec_build_requires@

%description -n libmdmp
Library to access the Windows Minidump (MDMP) format

%package -n libmdmp-static
Summary: Library to access the Windows Minidump (MDMP) format
Group: Development/Libraries
Requires: libmdmp = %{version}-%{release}

%description -n libmdmp-static
Static library version of libmdmp.

%package -n libmdmp-devel
Summary: Header files and libraries for developing applications for libmdmp
Group: Development/Libraries
Requires: libmdmp = %{version}-%{release}

%description -n libmdmp-devel
Header files and libraries for developing applications for libmdmp.

%package -n libmdmp-tools
Summary: Several tools for reading Windows Minidump (MDMP) files
Group: Applications/System
Requires: libmdmp = %{version}-%{release}

%description -n libmdmp-tools
Several tools for reading Windows Minidump (MDMP) files

%prep
%setup -q

%build
%configure --prefix=/usr --libdir=%{_libdir} --mandir=%{_mandir}
make %{?_smp_mflags}

%install
rm -rf %{buildroot}
%make_install

%clean
rm -rf %{buildroot}

%post -p /sbin/ldconfig

%postun -p /sbin/ldconfig

%files -n libmdmp
%license COPYING COPYING.LESSER
%doc AUTHORS README
%{_libdir}/*.so.*

%files -n libmdmp-static
%license COPYING COPYING.LESSER
%doc AUTHORS README
%{_libdir}/*.a

%files -n libmdmp-devel
%license COPYING COPYING.LESSER
%doc AUTHORS README
%{_libdir}/*.so
%{_libdir}/pkgconfig/libmdmp.pc
%{_includedir}/*
%{_mandir}/man3/*

%files -n libmdmp-tools
%license COPYING COPYING.LESSER
%doc AUTHORS README
%{_bindir}/*
%{_mandir}/man1/*

%changelog
* @SPEC_DATE@ Joachim Metz <joachim.metz@gmail.com> @VERSION@-1
- Auto-generated


```

`libmdmp/Makefile.am`:

```am
AM_CPPFLAGS = \
	-I$(top_srcdir)/include \
	-I$(top_srcdir)/common \
	@LIBCERROR_CPPFLAGS@ \
	@LIBCTHREADS_CPPFLAGS@ \
	@LIBCDATA_CPPFLAGS@ \
	@LIBCLOCALE_CPPFLAGS@ \
	@LIBCNOTIFY_CPPFLAGS@ \
	@LIBCSPLIT_CPPFLAGS@ \
	@LIBUNA_CPPFLAGS@ \
	@LIBCFILE_CPPFLAGS@ \
	@LIBCPATH_CPPFLAGS@ \
	@LIBBFIO_CPPFLAGS@ \
	@LIBFCACHE_CPPFLAGS@ \
	@LIBFDATA_CPPFLAGS@ \
	@LIBFDATETIME_CPPFLAGS@ \
	@PTHREAD_CPPFLAGS@ \
	@LIBMDMP_DLL_EXPORT@

lib_LTLIBRARIES = libmdmp.la

libmdmp_la_SOURCES = \
	libmdmp.c \
	libmdmp_codepage.h \
	libmdmp_debug.c libmdmp_debug.h \
	libmdmp_definitions.h \
	libmdmp_error.c libmdmp_error.h \
	libmdmp_extern.h \
	libmdmp_file.c libmdmp_file.h \
	libmdmp_file_header.c libmdmp_file_header.h \
	libmdmp_io_handle.c libmdmp_io_handle.h \
	libmdmp_libbfio.h \
	libmdmp_libcdata.h \
	libmdmp_libcerror.h \
	libmdmp_libclocale.h \
	libmdmp_libcnotify.h \
	libmdmp_libfdata.h \
	libmdmp_libfdatetime.h \
	libmdmp_libuna.h \
	libmdmp_notify.c libmdmp_notify.h \
	libmdmp_stream.c libmdmp_stream.h \
	libmdmp_stream_descriptor.c libmdmp_stream_descriptor.h \
	libmdmp_stream_io_handle.c libmdmp_stream_io_handle.h \
	libmdmp_support.c libmdmp_support.h \
	libmdmp_types.h \
	libmdmp_unused.h \
	mdmp_file_header.h

libmdmp_la_LIBADD = \
	@LIBCERROR_LIBADD@ \
	@LIBCTHREADS_LIBADD@ \
	@LIBCDATA_LIBADD@ \
	@LIBCLOCALE_LIBADD@ \
	@LIBCNOTIFY_LIBADD@ \
	@LIBCSPLIT_LIBADD@ \
	@LIBUNA_LIBADD@ \
	@LIBCFILE_LIBADD@ \
	@LIBCPATH_LIBADD@ \
	@LIBBFIO_LIBADD@ \
	@LIBFCACHE_LIBADD@ \
	@LIBFDATA_LIBADD@ \
	@LIBFDATETIME_LIBADD@ \
	@PTHREAD_LIBADD@

libmdmp_la_LDFLAGS = -no-undefined -version-info 1:0:0

EXTRA_DIST = \
	libmdmp_definitions.h.in \
	libmdmp.rc \
	libmdmp.rc.in

MAINTAINERCLEANFILES = \
	Makefile.in

distclean: clean
	-rm -f libmdmp_definitions.h
	-rm -f libmdmp.rc
	-rm -f Makefile

sources-local: $(BUILT_SOURCES)

splint-local:
	@echo "Running splint on libmdmp ..."
	-splint -preproc -redef $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(libmdmp_la_SOURCES)


```

`libmdmp/libmdmp.c`:

```c
/*
 * Library to access the Windows Minidump (MDMP) format
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>

#if defined( WINAPI )
#include <windows.h>
#endif

#include "libmdmp_unused.h"

/* Define HAVE_LOCAL_LIBMDMP for local use of libmdmp
 */
#if !defined( HAVE_LOCAL_LIBMDMP )

#if defined( WINAPI ) && defined( HAVE_DLLMAIN )

#if defined( _MANAGED )
#pragma managed( push, off )
#endif

/* Defines the entry point for the DLL
 */
BOOL WINAPI DllMain(
             HINSTANCE hinstDLL,
             DWORD fdwReason,
             LPVOID lpvReserved )
{
	LIBMDMP_UNREFERENCED_PARAMETER( lpvReserved )

	switch( fdwReason )
	{
		case DLL_PROCESS_ATTACH:
			DisableThreadLibraryCalls(
			 hinstDLL );
			break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_THREAD_DETACH:
			break;

		case DLL_PROCESS_DETACH:
			break;
	}
	return( TRUE );
}

/* Function that indicates the library is a DLL
 * Returns 1
 */
int libmdmp_is_dll(
     void )
{
	return( 1 );
}

#endif /* defined( WINAPI ) && defined( HAVE_DLLMAIN ) */

#endif /* !defined( HAVE_LOCAL_LIBMDMP ) */


```

`libmdmp/libmdmp.rc.in`:

```in
#include <windows.h>

#ifdef GCC_WINDRES
VS_VERSION_INFO				VERSIONINFO
#else
VS_VERSION_INFO				VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
#endif
  FILEVERSION				1,0,0,0
  PRODUCTVERSION			1,0,0,0
  FILEFLAGSMASK				VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
  FILEFLAGS				0x1L
#else
  FILEFLAGS				0x0L
#endif
  FILEOS				VOS__WINDOWS32
  FILETYPE				VFT_DLL
  FILESUBTYPE				0x0L
BEGIN
  BLOCK "StringFileInfo"
  BEGIN
    BLOCK "040904E4"
    BEGIN
      VALUE "FileDescription",		"Library to access the Windows Minidump (MDMP) format\0"
      VALUE "FileVersion",		"@VERSION@" "\0"
      VALUE "InternalName",		"libmdmp.dll\0"
      VALUE "LegalCopyright",		"(C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>\0"
      VALUE "OriginalFilename",		"libmdmp.dll\0"
      VALUE "ProductName",		"libmdmp\0"
      VALUE "ProductVersion",		"@VERSION@" "\0"
      VALUE "Comments",			"For more information visit https://github.com/libyal/libmdmp/\0"
    END
  END
  BLOCK "VarFileInfo"
  BEGIN
    VALUE "Translation", 0x0409, 1200
  END
END

```

`libmdmp/libmdmp_codepage.h`:

```h
/*
 * Codepage functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_INTERNAL_CODEPAGE_H )
#define _LIBMDMP_INTERNAL_CODEPAGE_H

#include <common.h>
#include <types.h>

#if defined( __cplusplus )
extern "C" {
#endif

/* Define HAVE_LOCAL_LIBMDMP for local use of libmdmp
 * The definitions in <libmdmp/codepage.h> are copied here
 * for local use of libmdmp
 */
#if !defined( HAVE_LOCAL_LIBMDMP )

#include <libmdmp/codepage.h>

#else

/* The codepage definitions
 */
enum LIBMDMP_CODEPAGES
{
	LIBMDMP_CODEPAGE_ASCII		= 20127,

	LIBMDMP_CODEPAGE_ISO_8859_1	= 28591,
	LIBMDMP_CODEPAGE_ISO_8859_2	= 28592,
	LIBMDMP_CODEPAGE_ISO_8859_3	= 28593,
	LIBMDMP_CODEPAGE_ISO_8859_4	= 28594,
	LIBMDMP_CODEPAGE_ISO_8859_5	= 28595,
	LIBMDMP_CODEPAGE_ISO_8859_6	= 28596,
	LIBMDMP_CODEPAGE_ISO_8859_7	= 28597,
	LIBMDMP_CODEPAGE_ISO_8859_8	= 28598,
	LIBMDMP_CODEPAGE_ISO_8859_9	= 28599,
	LIBMDMP_CODEPAGE_ISO_8859_10	= 28600,
	LIBMDMP_CODEPAGE_ISO_8859_11	= 28601,
	LIBMDMP_CODEPAGE_ISO_8859_13	= 28603,
	LIBMDMP_CODEPAGE_ISO_8859_14	= 28604,
	LIBMDMP_CODEPAGE_ISO_8859_15	= 28605,
	LIBMDMP_CODEPAGE_ISO_8859_16	= 28606,

	LIBMDMP_CODEPAGE_KOI8_R		= 20866,
	LIBMDMP_CODEPAGE_KOI8_U		= 21866,

	LIBMDMP_CODEPAGE_WINDOWS_874	= 874,
	LIBMDMP_CODEPAGE_WINDOWS_932	= 932,
	LIBMDMP_CODEPAGE_WINDOWS_936	= 936,
	LIBMDMP_CODEPAGE_WINDOWS_949	= 949,
	LIBMDMP_CODEPAGE_WINDOWS_950	= 950,
	LIBMDMP_CODEPAGE_WINDOWS_1250	= 1250,
	LIBMDMP_CODEPAGE_WINDOWS_1251	= 1251,
	LIBMDMP_CODEPAGE_WINDOWS_1252	= 1252,
	LIBMDMP_CODEPAGE_WINDOWS_1253	= 1253,
	LIBMDMP_CODEPAGE_WINDOWS_1254	= 1254,
	LIBMDMP_CODEPAGE_WINDOWS_1255	= 1255,
	LIBMDMP_CODEPAGE_WINDOWS_1256	= 1256,
	LIBMDMP_CODEPAGE_WINDOWS_1257	= 1257,
	LIBMDMP_CODEPAGE_WINDOWS_1258	= 1258
};

#endif /* !defined( HAVE_LOCAL_LIBMDMP ) */

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_INTERNAL_CODEPAGE_H ) */


```

`libmdmp/libmdmp_debug.c`:

```c
/*
 * Debug functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <types.h>

#include "libmdmp_debug.h"
#include "libmdmp_definitions.h"
#include "libmdmp_libbfio.h"
#include "libmdmp_libcerror.h"
#include "libmdmp_libcnotify.h"

#if defined( HAVE_DEBUG_OUTPUT )

/* Prints the page flags
 */
void libmdmp_debug_print_file_flags(
      uint32_t file_flags )
{
	if( file_flags == 0x00000000UL )
	{
		libcnotify_printf(
		 "\t(MiniDumpNormal)\n" );
	}
	if( ( file_flags & 0x00000001 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithDataSegs)\n" );
	}
	if( ( file_flags & 0x00000002 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithFullMemory)\n" );
	}
	if( ( file_flags & 0x00000004 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithHandleData)\n" );
	}
	if( ( file_flags & 0x00000008 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpFilterMemory)\n" );
	}
	if( ( file_flags & 0x00000010 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpScanMemory)\n" );
	}
	if( ( file_flags & 0x00000020 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithUnloadedModules)\n" );
	}
	if( ( file_flags & 0x00000040 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithIndirectlyReferencedMemory)\n" );
	}
	if( ( file_flags & 0x00000080 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpFilterModulePaths)\n" );
	}
	if( ( file_flags & 0x00000100 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithProcessThreadData)\n" );
	}
	if( ( file_flags & 0x00000200 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithPrivateReadWriteMemory)\n" );
	}
	if( ( file_flags & 0x00000400 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithoutOptionalData)\n" );
	}
	if( ( file_flags & 0x00000800 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithFullMemoryInfo)\n" );
	}
	if( ( file_flags & 0x00001000 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithThreadInfo)\n" );
	}
	if( ( file_flags & 0x00002000 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithCodeSegs)\n" );
	}
	if( ( file_flags & 0x00004000 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithoutAuxiliaryState)\n" );
	}
	if( ( file_flags & 0x00008000 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithFullAuxiliaryState)\n" );
	}
	if( ( file_flags & 0x00010000 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithPrivateWriteCopyMemory)\n" );
	}
	if( ( file_flags & 0x00020000 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpIgnoreInaccessibleMemory)\n" );
	}
	if( ( file_flags & 0x00040000 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithTokenInformation)\n" );
	}
	if( ( file_flags & 0x00080000 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpWithModuleHeaders)\n" );
	}
	if( ( file_flags & 0x00100000 ) != 0 )
	{
		libcnotify_printf(
		 "\t(MiniDumpFilterTriage)\n" );
	}
}

/* Returns a string with the stream type description
 */
const char *libmdmp_debug_get_stream_type(
             uint32_t stream_type )
{
	switch( stream_type )
	{
/* TODO add descriptive names */
		case 0:
			return( "UnusedStream" );
		case 1:
			return( "ReservedStream0" );
		case 2:
			return( "ReservedStream1" );
		case 3:
			return( "ThreadListStream" );
		case 4:
			return( "ModuleListStream" );
		case 5:
			return( "MemoryListStream" );
		case 6:
			return( "ExceptionStream" );
		case 7:
			return( "SystemInfoStream" );
		case 8:
			return( "ThreadExListStream" );
		case 9:
			return( "Memory64ListStream" );
		case 10:
			return( "CommentStreamA" );
		case 11:
			return( "CommentStreamW" );
		case 12:
			return( "HandleDataStream" );
		case 13:
			return( "FunctionTableStream" );
		case 14:
			return( "UnloadedModuleListStream" );
		case 15:
			return( "MiscInfoStream" );
		case 16:
			return( "MemoryInfoListStream" );
		case 17:
			return( "ThreadInfoListStream" );
		case 18:
			return( "HandleOperationListStream" );

		default:
			break;
	}
	return( "UNKNOWN" );
}

/* Prints the read offsets
 * Returns 1 if successful or -1 on error
 */
int libmdmp_debug_print_read_offsets(
     libbfio_handle_t *file_io_handle,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_debug_print_read_offsets";
	off64_t offset        = 0;
	size64_t size         = 0;
	int number_of_offsets = 0;
	int offset_iterator   = 0;

	if( file_io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file io handle.",
		 function );

		return( -1 );
	}
	if( libbfio_handle_get_number_of_offsets_read(
	     file_io_handle,
	     &number_of_offsets,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to retrieve number of offsets read.",
		 function );

		return( -1 );
	}
	libcnotify_printf(
	 "Offsets read:\n" );

	for( offset_iterator = 0;
	     offset_iterator < number_of_offsets;
	     offset_iterator++ )
	{
		if( libbfio_handle_get_offset_read(
		     file_io_handle,
		     offset_iterator,
		     &offset,
		     &size,
		     error ) != 1 )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
			 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
			 "%s: unable to retrieve offset: %d.",
			 function,
			 ( offset_iterator + 1 ) );

			return( -1 );
		}
		libcnotify_printf(
		 "%08" PRIi64 " ( 0x%08" PRIx64 " ) - %08" PRIi64 " ( 0x%08" PRIx64 " ) size: %" PRIu64 "\n",
		 offset,
		 offset,
		 offset + size,
		 offset + size,
		 size );
	}
	libcnotify_printf(
	 "\n" );

	return( 1 );
}

#endif


```

`libmdmp/libmdmp_debug.h`:

```h
/*
 * Debug functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_DEBUG_H )
#define _LIBMDMP_DEBUG_H

#include <common.h>
#include <types.h>

#include "libmdmp_libbfio.h"
#include "libmdmp_libcerror.h"

#if defined( __cplusplus )
extern "C" {
#endif

#if defined( HAVE_DEBUG_OUTPUT )

void libmdmp_debug_print_file_flags(
      uint32_t file_flags );

const char *libmdmp_debug_get_stream_type(
             uint32_t stream_type );

int libmdmp_debug_print_read_offsets(
     libbfio_handle_t *file_io_handle,
     libcerror_error_t **error );

#endif

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_DEBUG_H ) */


```

`libmdmp/libmdmp_definitions.h.in`:

```in
/*
 * The internal definitions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_INTERNAL_DEFINITIONS_H )
#define _LIBMDMP_INTERNAL_DEFINITIONS_H

#include <common.h>
#include <byte_stream.h>

#define LIBMDMP_ENDIAN_BIG				_BYTE_STREAM_ENDIAN_BIG
#define LIBMDMP_ENDIAN_LITTLE				_BYTE_STREAM_ENDIAN_LITTLE

/* Define HAVE_LOCAL_LIBMDMP for local use of libmdmp
 */
#if !defined( HAVE_LOCAL_LIBMDMP )
#include <libmdmp/definitions.h>

/* The definitions in <libmdmp/definitions.h> are copied here
 * for local use of libmdmp
 */
#else
#define LIBMDMP_VERSION					@VERSION@

/* The version string
 */
#define LIBMDMP_VERSION_STRING				"@VERSION@"

/* The access flags definitions
 * bit 1        set to 1 for read access
 * bit 2        set to 1 for write access
 * bit 3-8      not used
 */
enum LIBMDMP_ACCESS_FLAGS
{
	LIBMDMP_ACCESS_FLAG_READ			= 0x01,
/* Reserved: not supported yet */
	LIBMDMP_ACCESS_FLAG_WRITE			= 0x02
};

/* The file access macros
 */
#define LIBMDMP_OPEN_READ				( LIBMDMP_ACCESS_FLAG_READ )
/* Reserved: not supported yet */
#define LIBMDMP_OPEN_WRITE				( LIBMDMP_ACCESS_FLAG_WRITE )
/* Reserved: not supported yet */
#define LIBMDMP_OPEN_READ_WRITE				( LIBMDMP_ACCESS_FLAG_READ | LIBMDMP_ACCESS_FLAG_WRITE )

#endif

#endif


```

`libmdmp/libmdmp_error.c`:

```c
/*
 * Error functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <types.h>

#include "libmdmp_error.h"
#include "libmdmp_libcerror.h"

#if !defined( HAVE_LOCAL_LIBMDMP )

/* Free an error and its elements
 */
void libmdmp_error_free(
      libmdmp_error_t **error )
{
	libcerror_error_free(
	 (libcerror_error_t **) error );
}

/* Prints a descriptive string of the error to the stream
 * Returns the number of printed characters if successful or -1 on error
 */
int libmdmp_error_fprint(
     libmdmp_error_t *error,
     FILE *stream )
{
	int print_count = 0;

	print_count = libcerror_error_fprint(
	               (libcerror_error_t *) error,
	               stream );

	return( print_count );
}

/* Prints a descriptive string of the error to the string
 * The end-of-string character is not included in the return value
 * Returns the number of printed characters if successful or -1 on error
 */
int libmdmp_error_sprint(
     libmdmp_error_t *error,
     char *string,
     size_t size )
{
	int print_count = 0;

	print_count = libcerror_error_sprint(
	               (libcerror_error_t *) error,
	               string,
	               size );

	return( print_count );
}

/* Prints a backtrace of the error to the stream
 * Returns the number of printed characters if successful or -1 on error
 */
int libmdmp_error_backtrace_fprint(
     libmdmp_error_t *error,
      FILE *stream )
{
	int print_count = 0;

	print_count = libcerror_error_backtrace_fprint(
	               (libcerror_error_t *) error,
	               stream );

	return( print_count );
}

/* Prints a backtrace of the error to the string
 * The end-of-string character is not included in the return value
 * Returns the number of printed characters if successful or -1 on error
 */
int libmdmp_error_backtrace_sprint(
     libmdmp_error_t *error,
     char *string,
     size_t size )
{
	int print_count = 0;

	print_count = libcerror_error_backtrace_sprint(
	               (libcerror_error_t *) error,
	               string,
	               size );

	return( print_count );
}

#endif /* !defined( HAVE_LOCAL_LIBMDMP ) */


```

`libmdmp/libmdmp_error.h`:

```h
/*
 * Error functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_INTERNAL_ERROR_H )
#define _LIBMDMP_INTERNAL_ERROR_H

#include <common.h>
#include <file_stream.h>
#include <types.h>

#if !defined( HAVE_LOCAL_LIBMDMP )
#include <libmdmp/error.h>
#endif

#include "libmdmp_extern.h"

#if defined( __cplusplus )
extern "C" {
#endif

#if !defined( HAVE_LOCAL_LIBMDMP )

LIBMDMP_EXTERN \
void libmdmp_error_free(
      libmdmp_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_error_fprint(
     libmdmp_error_t *error,
     FILE *stream );

LIBMDMP_EXTERN \
int libmdmp_error_sprint(
     libmdmp_error_t *error,
     char *string,
     size_t size );

LIBMDMP_EXTERN \
int libmdmp_error_backtrace_fprint(
     libmdmp_error_t *error,
     FILE *stream );

LIBMDMP_EXTERN \
int libmdmp_error_backtrace_sprint(
     libmdmp_error_t *error,
     char *string,
     size_t size );

#endif /* !defined( HAVE_LOCAL_LIBMDMP ) */

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_INTERNAL_ERROR_H ) */


```

`libmdmp/libmdmp_extern.h`:

```h
/*
 * The internal extern definition
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_INTERNAL_EXTERN_H )
#define _LIBMDMP_INTERNAL_EXTERN_H

#include <common.h>

/* Define HAVE_LOCAL_LIBMDMP for local use of libmdmp
 */
#if !defined( HAVE_LOCAL_LIBMDMP )

#include <libmdmp/extern.h>

#if defined( __CYGWIN__ ) || defined( __MINGW32__ )
#define LIBMDMP_EXTERN_VARIABLE	extern
#else
#define LIBMDMP_EXTERN_VARIABLE	LIBMDMP_EXTERN
#endif

#else
#define LIBMDMP_EXTERN		/* extern */
#define LIBMDMP_EXTERN_VARIABLE	extern

#endif /* !defined( HAVE_LOCAL_LIBMDMP ) */

#endif /* !defined( _LIBMDMP_INTERNAL_EXTERN_H ) */


```

`libmdmp/libmdmp_file.c`:

```c
/*
 * File functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <memory.h>
#include <narrow_string.h>
#include <types.h>
#include <wide_string.h>

#include "libmdmp_codepage.h"
#include "libmdmp_debug.h"
#include "libmdmp_definitions.h"
#include "libmdmp_io_handle.h"
#include "libmdmp_file.h"
#include "libmdmp_file_header.h"
#include "libmdmp_libbfio.h"
#include "libmdmp_libcdata.h"
#include "libmdmp_libcerror.h"
#include "libmdmp_libcnotify.h"
#include "libmdmp_stream.h"
#include "libmdmp_stream_descriptor.h"

/* Creates a file
 * Make sure the value file is referencing, is set to NULL
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_initialize(
     libmdmp_file_t **file,
     libcerror_error_t **error )
{
	libmdmp_internal_file_t *internal_file = NULL;
	static char *function                  = "libmdmp_file_initialize";

	if( file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	if( *file != NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: invalid file value already set.",
		 function );

		return( -1 );
	}
	internal_file = memory_allocate_structure(
	                 libmdmp_internal_file_t );

	if( internal_file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,
		 "%s: unable to create file.",
		 function );

		goto on_error;
	}
	if( memory_set(
	     internal_file,
	     0,
	     sizeof( libmdmp_internal_file_t ) ) == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_SET_FAILED,
		 "%s: unable to clear file.",
		 function );

		memory_free(
		 internal_file );

		return( -1 );
	}
	if( libcdata_array_initialize(
	     &( internal_file->streams_array ),
	     0,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create streams array.",
		 function );

		goto on_error;
	}
	if( libmdmp_io_handle_initialize(
	     &( internal_file->io_handle ),
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create IO handle.",
		 function );

		goto on_error;
	}
	*file = (libmdmp_file_t *) internal_file;

	return( 1 );

on_error:
	if( internal_file != NULL )
	{
		if( internal_file->streams_array != NULL )
		{
			libcdata_array_free(
			 &( internal_file->streams_array ),
			 NULL,
			 NULL );
		}
		memory_free(
		 internal_file );
	}
	return( -1 );
}

/* Frees a file
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_free(
     libmdmp_file_t **file,
     libcerror_error_t **error )
{
	libmdmp_internal_file_t *internal_file = NULL;
	static char *function                  = "libmdmp_file_free";
	int result                             = 1;

	if( file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	if( *file != NULL )
	{
		internal_file = (libmdmp_internal_file_t *) *file;

		if( internal_file->file_io_handle != NULL )
		{
			if( libmdmp_file_close(
			     *file,
			     error ) != 0 )
			{
				libcerror_error_set(
				 error,
				 LIBCERROR_ERROR_DOMAIN_IO,
				 LIBCERROR_IO_ERROR_CLOSE_FAILED,
				 "%s: unable to close file.",
				 function );

				result = -1;
			}
		}
		*file = NULL;

		if( libcdata_array_free(
		     &( internal_file->streams_array ),
		     (int (*)(intptr_t **, libcerror_error_t **)) &libmdmp_stream_descriptor_free,
		     error ) != 1 )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
			 LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,
			 "%s: unable to free streams array.",
			 function );

			result = -1;
		}
		if( libmdmp_io_handle_free(
		     &( internal_file->io_handle ),
		     error ) != 1 )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
			 LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,
			 "%s: unable to free IO handle.",
			 function );

			result = -1;
		}
		memory_free(
		 internal_file );
	}
	return( result );
}

/* Signals the file to abort its current activity
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_signal_abort(
     libmdmp_file_t *file,
     libcerror_error_t **error )
{
	libmdmp_internal_file_t *internal_file = NULL;
	static char *function                  = "libmdmp_file_signal_abort";

	if( file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	internal_file = (libmdmp_internal_file_t *) file;

	if( internal_file->io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid file - missing IO handle.",
		 function );

		return( -1 );
	}
	internal_file->io_handle->abort = 1;

	return( 1 );
}

/* Opens a file
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_open(
     libmdmp_file_t *file,
     const char *filename,
     int access_flags,
     libcerror_error_t **error )
{
	libbfio_handle_t *file_io_handle       = NULL;
	libmdmp_internal_file_t *internal_file = NULL;
	static char *function                  = "libmdmp_file_open";
	size_t filename_length                 = 0;

	if( file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	internal_file = (libmdmp_internal_file_t *) file;

	if( filename == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid filename.",
		 function );

		return( -1 );
	}
	if( ( ( access_flags & LIBMDMP_ACCESS_FLAG_READ ) == 0 )
	 && ( ( access_flags & LIBMDMP_ACCESS_FLAG_WRITE ) == 0 ) )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,
		 "%s: unsupported access flags.",
		 function );

		return( -1 );
	}
	if( ( access_flags & LIBMDMP_ACCESS_FLAG_WRITE ) != 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,
		 "%s: write access currently not supported.",
		 function );

		return( -1 );
	}
	if( libbfio_file_initialize(
	     &file_io_handle,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create file IO handle.",
		 function );

		goto on_error;
	}
#if defined( HAVE_DEBUG_OUTPUT )
	if( libbfio_handle_set_track_offsets_read(
	     file_io_handle,
	     1,
	     error ) != 1 )
	{
                libcerror_error_set(
                 error,
                 LIBCERROR_ERROR_DOMAIN_RUNTIME,
                 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
                 "%s: unable to set track offsets read in file IO handle.",
                 function );

		goto on_error;
	}
#endif
	filename_length = narrow_string_length(
	                   filename );

	if( libbfio_file_set_name(
	     file_io_handle,
	     filename,
	     filename_length + 1,
	     error ) != 1 )
	{
                libcerror_error_set(
                 error,
                 LIBCERROR_ERROR_DOMAIN_RUNTIME,
                 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
                 "%s: unable to set filename in file IO handle.",
                 function );

		goto on_error;
	}
	if( libmdmp_file_open_file_io_handle(
	     file,
	     file_io_handle,
	     access_flags,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_OPEN_FAILED,
		 "%s: unable to open file: %s.",
		 function,
		 filename );

		goto on_error;
	}
	internal_file->file_io_handle_created_in_library = 1;

	return( 1 );

on_error:
	if( file_io_handle != NULL )
	{
		libbfio_handle_free(
		 &file_io_handle,
		 NULL );
	}
	return( -1 );
}

#if defined( HAVE_WIDE_CHARACTER_TYPE )

/* Opens a file
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_open_wide(
     libmdmp_file_t *file,
     const wchar_t *filename,
     int access_flags,
     libcerror_error_t **error )
{
	libbfio_handle_t *file_io_handle       = NULL;
	libmdmp_internal_file_t *internal_file = NULL;
	static char *function                  = "libmdmp_file_open_wide";
	size_t filename_length                 = 0;

	if( file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	internal_file = (libmdmp_internal_file_t *) file;

	if( filename == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid filename.",
		 function );

		return( -1 );
	}
	if( ( ( access_flags & LIBMDMP_ACCESS_FLAG_READ ) == 0 )
	 && ( ( access_flags & LIBMDMP_ACCESS_FLAG_WRITE ) == 0 ) )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,
		 "%s: unsupported access flags.",
		 function );

		return( -1 );
	}
	if( ( access_flags & LIBMDMP_ACCESS_FLAG_WRITE ) != 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,
		 "%s: write access currently not supported.",
		 function );

		return( -1 );
	}
	if( libbfio_file_initialize(
	     &file_io_handle,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create file IO handle.",
		 function );

		goto on_error;
	}
#if defined( HAVE_DEBUG_OUTPUT )
	if( libbfio_handle_set_track_offsets_read(
	     file_io_handle,
	     1,
	     error ) != 1 )
	{
                libcerror_error_set(
                 error,
                 LIBCERROR_ERROR_DOMAIN_RUNTIME,
                 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
                 "%s: unable to set track offsets read in file IO handle.",
                 function );

		goto on_error;
	}
#endif
	filename_length = wide_string_length(
	                   filename );

	if( libbfio_file_set_name_wide(
	     file_io_handle,
	     filename,
	     filename_length + 1,
	     error ) != 1 )
	{
                libcerror_error_set(
                 error,
                 LIBCERROR_ERROR_DOMAIN_RUNTIME,
                 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
                 "%s: unable to set filename in file IO handle.",
                 function );

		goto on_error;
	}
	if( libmdmp_file_open_file_io_handle(
	     file,
	     file_io_handle,
	     access_flags,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_OPEN_FAILED,
		 "%s: unable to open file: %ls.",
		 function,
		 filename );

		goto on_error;
	}
	internal_file->file_io_handle_created_in_library = 1;

	return( 1 );

on_error:
	if( file_io_handle != NULL )
	{
		libbfio_handle_free(
		 &file_io_handle,
		 NULL );
	}
	return( -1 );
}

#endif

/* Opens a file using a Basic File IO (bfio) handle
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_open_file_io_handle(
     libmdmp_file_t *file,
     libbfio_handle_t *file_io_handle,
     int access_flags,
     libcerror_error_t **error )
{
	libmdmp_internal_file_t *internal_file = NULL;
	static char *function                  = "libmdmp_file_open_file_io_handle";
	int bfio_access_flags                  = 0;
	int file_io_handle_is_open             = 0;

	if( file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	internal_file = (libmdmp_internal_file_t *) file;

	if( internal_file->file_io_handle != NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: invalid file - file IO handle already set.",
		 function );

		return( -1 );
	}
	if( file_io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file IO handle.",
		 function );

		return( -1 );
	}
	if( ( ( access_flags & LIBMDMP_ACCESS_FLAG_READ ) == 0 )
	 && ( ( access_flags & LIBMDMP_ACCESS_FLAG_WRITE ) == 0 ) )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,
		 "%s: unsupported access flags.",
		 function );

		return( -1 );
	}
	if( ( access_flags & LIBMDMP_ACCESS_FLAG_WRITE ) != 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,
		 "%s: write access currently not supported.",
		 function );

		return( -1 );
	}
	if( ( access_flags & LIBMDMP_ACCESS_FLAG_READ ) != 0 )
	{
		bfio_access_flags = LIBBFIO_ACCESS_FLAG_READ;
	}
	internal_file->file_io_handle = file_io_handle;

	file_io_handle_is_open = libbfio_handle_is_open(
	                          internal_file->file_io_handle,
	                          error );

	if( file_io_handle_is_open == -1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_OPEN_FAILED,
		 "%s: unable to determine if file IO handle is open.",
		 function );

		goto on_error;
	}
	else if( file_io_handle_is_open == 0 )
	{
		if( libbfio_handle_open(
		     internal_file->file_io_handle,
		     bfio_access_flags,
		     error ) != 1 )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_IO,
			 LIBCERROR_IO_ERROR_OPEN_FAILED,
			 "%s: unable to open file IO handle.",
			 function );

			goto on_error;
		}
		internal_file->file_io_handle_opened_in_library = 1;
	}
	if( libmdmp_file_open_read(
	     internal_file,
	     file_io_handle,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_READ_FAILED,
		 "%s: unable to read from file handle.",
		 function );

		goto on_error;
	}
	internal_file->file_io_handle = file_io_handle;

	return( 1 );

on_error:
	if( ( file_io_handle_is_open == 0 )
	 && ( internal_file->file_io_handle_opened_in_library != 0 ) )
	{
		libbfio_handle_close(
		 file_io_handle,
		 error );

		internal_file->file_io_handle_opened_in_library = 0;
	}
	internal_file->file_io_handle = NULL;

	return( -1 );
}

/* Closes a file
 * Returns 0 if successful or -1 on error
 */
int libmdmp_file_close(
     libmdmp_file_t *file,
     libcerror_error_t **error )
{
	libmdmp_internal_file_t *internal_file = NULL;
	static char *function                  = "libmdmp_file_close";
	int result                             = 0;

	if( file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	internal_file = (libmdmp_internal_file_t *) file;

	if( internal_file->file_io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid file - missing file IO handle.",
		 function );

		return( -1 );
	}
#if defined( HAVE_DEBUG_OUTPUT )
	if( libcnotify_verbose != 0 )
	{
		if( internal_file->file_io_handle_created_in_library != 0 )
		{
			if( libmdmp_debug_print_read_offsets(
			     internal_file->file_io_handle,
			     error ) != 1 )
			{
				libcerror_error_set(
				 error,
				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
				 LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,
				 "%s: unable to print the read offsets.",
				 function );

				result = -1;
			}
		}
	}
#endif
	if( internal_file->file_io_handle_opened_in_library != 0 )
	{
		if( libbfio_handle_close(
		     internal_file->file_io_handle,
		     error ) != 0 )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_IO,
			 LIBCERROR_IO_ERROR_CLOSE_FAILED,
			 "%s: unable to close file IO handle.",
			 function );

			result = -1;
		}
		internal_file->file_io_handle_opened_in_library = 0;
	}
	if( internal_file->file_io_handle_created_in_library != 0 )
	{
		if( libbfio_handle_free(
		     &( internal_file->file_io_handle ),
		     error ) != 1 )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
			 LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,
			 "%s: unable to free file IO handle.",
			 function );

			result = -1;
		}
		internal_file->file_io_handle_created_in_library = 0;
	}
	internal_file->file_io_handle = NULL;

	if( libmdmp_io_handle_clear(
	     internal_file->io_handle,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,
		 "%s: unable to clear IO handle.",
		 function );

		result = -1;
	}
	if( libmdmp_file_header_free(
	     &( internal_file->file_header ),
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,
		 "%s: unable to free file header.",
		 function );

		result = -1;
	}
	if( libcdata_array_resize(
	     internal_file->streams_array,
	     0,
	     (int (*)(intptr_t **, libcerror_error_t **)) &libmdmp_stream_descriptor_free,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_RESIZE_FAILED,
		 "%s: unable to resize streams array.",
		 function );

		result = -1;
	}
	return( result );
}

/* Opens a file for reading
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_open_read(
     libmdmp_internal_file_t *internal_file,
     libbfio_handle_t *file_io_handle,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_file_open_read";

	if( internal_file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	if( internal_file->io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid file - missing IO handle.",
		 function );

		return( -1 );
	}
	if( internal_file->file_header != NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: invalid file - file header value already set.",
		 function );

		return( -1 );
	}
	if( internal_file->io_handle->abort != 0 )
	{
		internal_file->io_handle->abort = 0;
	}
#if defined( HAVE_DEBUG_OUTPUT )
	if( libcnotify_verbose != 0 )
	{
		libcnotify_printf(
		 "Reading file header:\n" );
	}
#endif
	if( libmdmp_file_header_initialize(
	     &( internal_file->file_header ),
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create file header.",
		 function );

		goto on_error;
	}
	if( libmdmp_file_header_read_file_io_handle(
	     internal_file->file_header,
	     file_io_handle,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_READ_FAILED,
		 "%s: unable to read file header.",
		 function );

		goto on_error;
	}
	internal_file->io_handle->version = internal_file->file_header->version;

#if defined( HAVE_DEBUG_OUTPUT )
	if( libcnotify_verbose != 0 )
	{
		libcnotify_printf(
		 "Reading streams directory:\n" );
	}
#endif
	if( libmdmp_io_handle_read_streams_directory(
	     internal_file->io_handle,
	     file_io_handle,
	     internal_file->file_header->streams_directory_offset,
	     internal_file->file_header->number_of_streams,
	     internal_file->streams_array,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_READ_FAILED,
		 "%s: unable to read file header.",
		 function );

		goto on_error;
	}
/* TODO */
	return( 1 );

on_error:
	if( internal_file->file_header != NULL )
	{
		libmdmp_file_header_free(
		 &( internal_file->file_header ),
		 NULL );
	}
	return( -1 );
}

/* Retrieves the number of streams
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_get_number_of_streams(
     libmdmp_file_t *file,
     int *number_of_streams,
     libcerror_error_t **error )
{
	libmdmp_internal_file_t *internal_file = NULL;
	static char *function                  = "libmdmp_file_get_number_of_streams";

	if( file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	internal_file = (libmdmp_internal_file_t *) file;

	if( libcdata_array_get_number_of_entries(
	     internal_file->streams_array,
	     number_of_streams,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to retrieve number of streams.",
		 function );

		return( -1 );
	}
	return( 1 );
}

/* Retrieves a specific stream
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_get_stream(
     libmdmp_file_t *file,
     int stream_index,
     libmdmp_stream_t **stream,
     libcerror_error_t **error )
{
	libmdmp_internal_file_t *internal_file         = NULL;
	libmdmp_stream_descriptor_t *stream_descriptor = NULL;
	static char *function                          = "libmdmp_file_get_stream";

	if( file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	internal_file = (libmdmp_internal_file_t *) file;

	if( stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream.",
		 function );

		return( -1 );
	}
	if( *stream != NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: invalid stream value already set.",
		 function );

		return( -1 );
	}
	if( libcdata_array_get_entry_by_index(
	     internal_file->streams_array,
	     stream_index,
	     (intptr_t **) &stream_descriptor,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to retrieve stream descriptor: %d.",
		 function,
		 stream_index );

		return( -1 );
	}
	if( libmdmp_stream_initialize(
	     stream,
	     internal_file->io_handle,
	     internal_file->file_io_handle,
	     stream_descriptor,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create stream.",
		 function );

		return( -1 );
	}
	return( 1 );
}

/* Retrieves a specific stream by type
 * Returns 1 if successful, 0 if no such stream or -1 on error
 */
int libmdmp_file_get_stream_by_type(
     libmdmp_file_t *file,
     uint32_t stream_type,
     libmdmp_stream_t **stream,
     libcerror_error_t **error )
{
	libmdmp_internal_file_t *internal_file         = NULL;
	libmdmp_stream_descriptor_t *stream_descriptor = NULL;
	static char *function                          = "libmdmp_file_get_stream_by_type";
	int number_of_streams                          = 0;
	int stream_index                               = 0;

	if( file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	internal_file = (libmdmp_internal_file_t *) file;

	if( stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream.",
		 function );

		return( -1 );
	}
	if( *stream != NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: invalid stream value already set.",
		 function );

		return( -1 );
	}
	if( libcdata_array_get_number_of_entries(
	     internal_file->streams_array,
	     &number_of_streams,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to retrieve number of streams.",
		 function );

		return( -1 );
	}
	for( stream_index = 0;
	     stream_index < number_of_streams;
	     stream_index++ )
	{
		if( libcdata_array_get_entry_by_index(
		     internal_file->streams_array,
		     stream_index,
		     (intptr_t **) &stream_descriptor,
		     error ) != 1 )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
			 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
			 "%s: unable to retrieve stream descriptor: %d.",
			 function,
			 stream_index );

			return( -1 );
		}
		if( stream_descriptor == NULL )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
			 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
			 "%s: missing stream descriptor: %d.",
			 function,
			 stream_index );

			return( -1 );
		}
		if( stream_type == stream_descriptor->type )
		{
			if( libmdmp_stream_initialize(
			     stream,
			     internal_file->io_handle,
			     internal_file->file_io_handle,
			     stream_descriptor,
			     error ) != 1 )
			{
				libcerror_error_set(
				 error,
				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
				 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
				 "%s: unable to create stream.",
				 function );

				return( -1 );
			}
			return( 1 );
		}
	}
	return( 0 );
}


```

`libmdmp/libmdmp_file.h`:

```h
/*
 * File functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_INTERNAL_FILE_H )
#define _LIBMDMP_INTERNAL_FILE_H

#include <common.h>
#include <types.h>

#include "libmdmp_extern.h"
#include "libmdmp_file_header.h"
#include "libmdmp_io_handle.h"
#include "libmdmp_libbfio.h"
#include "libmdmp_libcdata.h"
#include "libmdmp_libcerror.h"
#include "libmdmp_types.h"

#if defined( __cplusplus )
extern "C" {
#endif

typedef struct libmdmp_internal_file libmdmp_internal_file_t;

struct libmdmp_internal_file
{
	/* The IO handle
	 */
	libmdmp_io_handle_t *io_handle;

	/* The file IO handle
	 */
	libbfio_handle_t *file_io_handle;

	/* Value to indicate if the file IO handle was created inside the library
	 */
	uint8_t file_io_handle_created_in_library;

	/* Value to indicate if the file IO handle was opened inside the library
	 */
	uint8_t file_io_handle_opened_in_library;

	/* The file header
	 */
	libmdmp_file_header_t *file_header;

	/* The streams array
	 */
	libcdata_array_t *streams_array;
};

LIBMDMP_EXTERN \
int libmdmp_file_initialize(
     libmdmp_file_t **file,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_file_free(
     libmdmp_file_t **file,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_file_signal_abort(
     libmdmp_file_t *file,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_file_open(
     libmdmp_file_t *file,
     const char *filename,
     int access_flags,
     libcerror_error_t **error );

#if defined( HAVE_WIDE_CHARACTER_TYPE )
LIBMDMP_EXTERN \
int libmdmp_file_open_wide(
     libmdmp_file_t *file,
     const wchar_t *filename,
     int access_flags,
     libcerror_error_t **error );
#endif

LIBMDMP_EXTERN \
int libmdmp_file_open_file_io_handle(
     libmdmp_file_t *file,
     libbfio_handle_t *file_io_handle,
     int access_flags,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_file_close(
     libmdmp_file_t *file,
     libcerror_error_t **error );

int libmdmp_file_open_read(
     libmdmp_internal_file_t *internal_file,
     libbfio_handle_t *file_io_handle,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_file_get_number_of_streams(
     libmdmp_file_t *file,
     int *number_of_streams,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_file_get_stream(
     libmdmp_file_t *file,
     int stream_index,
     libmdmp_stream_t **stream,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_file_get_stream_by_type(
     libmdmp_file_t *file,
     uint32_t stream_type,
     libmdmp_stream_t **stream,
     libcerror_error_t **error );

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_INTERNAL_FILE_H ) */


```

`libmdmp/libmdmp_file_header.c`:

```c
/*
 * File header functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <byte_stream.h>
#include <memory.h>
#include <types.h>

#include "libmdmp_debug.h"
#include "libmdmp_file_header.h"
#include "libmdmp_io_handle.h"
#include "libmdmp_libcerror.h"
#include "libmdmp_libcnotify.h"
#include "libmdmp_libfdatetime.h"

#include "mdmp_file_header.h"

/* Creates file header
 * Make sure the value file_header is referencing, is set to NULL
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_header_initialize(
     libmdmp_file_header_t **file_header,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_file_header_initialize";

	if( file_header == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file header.",
		 function );

		return( -1 );
	}
	if( *file_header != NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: invalid file header value already set.",
		 function );

		return( -1 );
	}
	*file_header = memory_allocate_structure(
	                libmdmp_file_header_t );

	if( *file_header == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,
		 "%s: unable to create file header.",
		 function );

		goto on_error;
	}
	if( memory_set(
	     *file_header,
	     0,
	     sizeof( libmdmp_file_header_t ) ) == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_SET_FAILED,
		 "%s: unable to clear file header.",
		 function );

		goto on_error;
	}
	return( 1 );

on_error:
	if( *file_header != NULL )
	{
		memory_free(
		 *file_header );

		*file_header = NULL;
	}
	return( -1 );
}

/* Frees file header
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_header_free(
     libmdmp_file_header_t **file_header,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_file_header_free";

	if( file_header == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file header.",
		 function );

		return( -1 );
	}
	if( *file_header != NULL )
	{
		memory_free(
		 *file_header );

		*file_header = NULL;
	}
	return( 1 );
}

/* Reads the file header data
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_header_read_data(
     libmdmp_file_header_t *file_header,
     const uint8_t *data,
     size_t data_size,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_file_header_read_data";

#if defined( HAVE_DEBUG_OUTPUT )
	uint32_t value_32bit  = 0;
	uint16_t value_16bit  = 0;
#endif

	if( file_header == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file header.",
		 function );

		return( -1 );
	}
	if( data == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid data.",
		 function );

		return( -1 );
	}
	if( ( data_size < sizeof( mdmp_file_header_t ) )
	 || ( data_size > (size_t) SSIZE_MAX ) )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
		 "%s: invalid data size value out of bounds.",
		 function );

		return( -1 );
	}
#if defined( HAVE_DEBUG_OUTPUT )
	if( libcnotify_verbose != 0 )
	{
		libcnotify_printf(
		 "%s: file header data:\n",
		 function );
		libcnotify_print_data(
		 data,
		 sizeof( mdmp_file_header_t ),
		 0 );
	}
#endif
	if( memory_compare(
	     ( (mdmp_file_header_t *) data )->signature,
	     mdmp_file_signature,
	     4 ) != 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_UNSUPPORTED_VALUE,
		 "%s: invalid signature.",
		 function );

		return( -1 );
	}
	byte_stream_copy_to_uint16_little_endian(
	 ( (mdmp_file_header_t *) data )->version,
	 file_header->version );

	byte_stream_copy_to_uint32_little_endian(
	 ( (mdmp_file_header_t *) data )->number_of_streams,
	 file_header->number_of_streams );

	byte_stream_copy_to_uint32_little_endian(
	 ( (mdmp_file_header_t *) data )->streams_directory_rva,
	 file_header->streams_directory_offset );

#if defined( HAVE_DEBUG_OUTPUT )
	if( libcnotify_verbose != 0 )
	{
		libcnotify_printf(
		 "%s: signature\t\t\t\t: %c%c%c%c\n",
		 function,
		 ( (mdmp_file_header_t *) data )->signature[ 0 ],
		 ( (mdmp_file_header_t *) data )->signature[ 1 ],
		 ( (mdmp_file_header_t *) data )->signature[ 2 ],
		 ( (mdmp_file_header_t *) data )->signature[ 3 ] );

		libcnotify_printf(
		 "%s: version\t\t\t\t: 0x%04" PRIx16 "\n",
		 function,
		 file_header->version );

		byte_stream_copy_to_uint16_little_endian(
		 ( (mdmp_file_header_t *) data )->implementation_version,
		 value_16bit );
		libcnotify_printf(
		 "%s: implementation version\t\t: 0x%04" PRIx16 "\n",
		 function,
		 value_16bit );

		libcnotify_printf(
		 "%s: number of streams\t\t\t: 0x%08" PRIx32 "\n",
		 function,
		 file_header->number_of_streams );

		libcnotify_printf(
		 "%s: streams directory RVA\t\t: 0x%08" PRIx32 "\n",
		 function,
		 file_header->streams_directory_offset );

		byte_stream_copy_to_uint32_little_endian(
		 ( (mdmp_file_header_t *) data )->checksum,
		 value_32bit );
		libcnotify_printf(
		 "%s: checksum\t\t\t\t: 0x%08" PRIx32 "\n",
		 function,
		 value_32bit );

/* TODO print date time value */
		byte_stream_copy_to_uint32_little_endian(
		 ( (mdmp_file_header_t *) data )->timestamp,
		 value_32bit );
		libcnotify_printf(
		 "%s: timestamp\t\t\t\t: 0x%08" PRIx32 "\n",
		 function,
		 value_32bit );

		byte_stream_copy_to_uint32_little_endian(
		 ( (mdmp_file_header_t *) data )->file_flags,
		 value_32bit );
		libcnotify_printf(
		 "%s: file flags\t\t\t\t: 0x%08" PRIx32 "\n",
		 function,
		 value_32bit );
		libmdmp_debug_print_file_flags(
		 value_32bit );
		libcnotify_printf(
		 "\n" );

		libcnotify_printf(
		 "\n" );
	}
#endif /* defined( HAVE_DEBUG_OUTPUT ) */

	return( 1 );
}

/* Reads the file header
 * Returns 1 if successful or -1 on error
 */
int libmdmp_file_header_read_file_io_handle(
     libmdmp_file_header_t *file_header,
     libbfio_handle_t *file_io_handle,
     libcerror_error_t **error )
{
	uint8_t file_header_data[ sizeof( mdmp_file_header_t ) ];

	static char *function = "libmdmp_file_header_read_file_io_handle";
	ssize_t read_count    = 0;

	if( file_header == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file header.",
		 function );

		return( -1 );
	}
#if defined( HAVE_DEBUG_OUTPUT )
	if( libcnotify_verbose != 0 )
	{
		libcnotify_printf(
		 "%s: reading file header at offset: 0 (0x00000000)\n",
		 function );
	}
#endif
	read_count = libbfio_handle_read_buffer_at_offset(
	              file_io_handle,
	              file_header_data,
	              sizeof( mdmp_file_header_t ),
	              0,
	              error );

	if( read_count != (ssize_t) sizeof( mdmp_file_header_t ) )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_READ_FAILED,
		 "%s: unable to read file header data at offset: 0 (0x00000000).",
		 function );

		return( -1 );
	}
	if( libmdmp_file_header_read_data(
	     file_header,
	     file_header_data,
	     sizeof( mdmp_file_header_t ),
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_READ_FAILED,
		 "%s: unable to read file header.",
		 function );

		return( -1 );
	}
	return( 1 );
}


```

`libmdmp/libmdmp_file_header.h`:

```h
/*
 * File header functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_FILE_HEADER_H )
#define _LIBMDMP_FILE_HEADER_H

#include <common.h>
#include <types.h>

#include "libmdmp_libbfio.h"
#include "libmdmp_libcerror.h"

#if defined( __cplusplus )
extern "C" {
#endif

typedef struct libmdmp_file_header libmdmp_file_header_t;

struct libmdmp_file_header
{
	/* The version
	 */
	uint16_t version;

	/* The number of streams
	 */
	uint32_t number_of_streams;

	/* The streams directory offset
	 */
	uint32_t streams_directory_offset;
};

int libmdmp_file_header_initialize(
     libmdmp_file_header_t **file_header,
     libcerror_error_t **error );

int libmdmp_file_header_free(
     libmdmp_file_header_t **file_header,
     libcerror_error_t **error );

int libmdmp_file_header_read_data(
     libmdmp_file_header_t *file_header,
     const uint8_t *data,
     size_t data_size,
     libcerror_error_t **error );

int libmdmp_file_header_read_file_io_handle(
     libmdmp_file_header_t *file_header,
     libbfio_handle_t *file_io_handle,
     libcerror_error_t **error );

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_FILE_HEADER_H ) */


```

`libmdmp/libmdmp_io_handle.c`:

```c
/*
 * Input/Output (IO) handle functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <byte_stream.h>
#include <memory.h>
#include <types.h>

#include "libmdmp_debug.h"
#include "libmdmp_definitions.h"
#include "libmdmp_io_handle.h"
#include "libmdmp_libbfio.h"
#include "libmdmp_libcerror.h"
#include "libmdmp_libcnotify.h"
#include "libmdmp_stream_descriptor.h"
#include "libmdmp_unused.h"

#include "mdmp_file_header.h"

const char *mdmp_file_signature = "MDMP";

const uint8_t empty_streams_directory_entry[ 12 ] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

/* Creates an IO handle
 * Make sure the value io_handle is referencing, is set to NULL
 * Returns 1 if successful or -1 on error
 */
int libmdmp_io_handle_initialize(
     libmdmp_io_handle_t **io_handle,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_io_handle_initialize";

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( *io_handle != NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: invalid IO handle value already set.",
		 function );

		return( -1 );
	}
	*io_handle = memory_allocate_structure(
	              libmdmp_io_handle_t );

	if( *io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,
		 "%s: unable to create IO handle.",
		 function );

		goto on_error;
	}
	if( memory_set(
	     *io_handle,
	     0,
	     sizeof( libmdmp_io_handle_t ) ) == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_SET_FAILED,
		 "%s: unable to clear file.",
		 function );

		goto on_error;
	}
	return( 1 );

on_error:
	if( *io_handle != NULL )
	{
		memory_free(
		 *io_handle );

		*io_handle = NULL;
	}
	return( -1 );
}

/* Frees a IO handle
 * Returns 1 if successful or -1 on error
 */
int libmdmp_io_handle_free(
     libmdmp_io_handle_t **io_handle,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_io_handle_free";

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( *io_handle != NULL )
	{
		memory_free(
		 *io_handle );

		*io_handle = NULL;
	}
	return( 1 );
}

/* Clears the IO handle
 * Returns 1 if successful or -1 on error
 */
int libmdmp_io_handle_clear(
     libmdmp_io_handle_t *io_handle,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_io_handle_clear";

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( memory_set(
	     io_handle,
	     0,
	     sizeof( libmdmp_io_handle_t ) ) == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_SET_FAILED,
		 "%s: unable to clear IO handle.",
		 function );

		return( -1 );
	}
	return( 1 );
}

/* Reads the streams directory
 * Returns 1 if successful or -1 on error
 */
int libmdmp_io_handle_read_streams_directory(
     libmdmp_io_handle_t *io_handle,
     libbfio_handle_t *file_io_handle,
     uint32_t streams_directory_offset,
     uint32_t number_of_streams,
     libcdata_array_t *streams_array,
     libcerror_error_t **error )
{
	libmdmp_stream_descriptor_t *stream_descriptor = NULL;
	uint8_t *streams_directory_data                = NULL;
	uint8_t *streams_directory_entry_data          = NULL;
	static char *function                          = "libmdmp_io_handle_read_streams_directory";
	size_t streams_directory_data_size             = 0;
	ssize_t read_count                             = 0;
	uint32_t stream_data_offset                    = 0;
	uint32_t stream_data_size                      = 0;
	uint32_t stream_index                          = 0;
	int entry_index                                = 0;
	int result                                     = 0;

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( ( number_of_streams == 0 )
	 || ( number_of_streams > (size_t) ( MEMORY_MAXIMUM_ALLOCATION_SIZE / sizeof( mdmp_streams_directory_entry_t ) ) ) )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,
		 "%s: invalid number of streams value out of bounds.",
		 function );

		goto on_error;
	}
	streams_directory_data_size = sizeof( mdmp_streams_directory_entry_t ) * number_of_streams;

	streams_directory_data = (uint8_t *) memory_allocate(
	                                      sizeof( uint8_t ) * streams_directory_data_size );

	if( streams_directory_data == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,
		 "%s: unable to create streams directory data.",
		 function );

		goto on_error;
	}
#if defined( HAVE_DEBUG_OUTPUT )
	if( libcnotify_verbose != 0 )
	{
		libcnotify_printf(
		 "%s: reading streams directory at offset: %" PRIu32 " (0x%08" PRIx32 ")\n",
		 function,
		 streams_directory_offset,
		 streams_directory_offset );
	}
#endif
	read_count = libbfio_handle_read_buffer_at_offset(
	              file_io_handle,
	              streams_directory_data,
	              streams_directory_data_size,
	              streams_directory_offset,
	              error );

	if( read_count != (ssize_t) streams_directory_data_size )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_READ_FAILED,
		 "%s: unable to read streams directory data at offset: %" PRIu32 " (0x%08" PRIx32 ").",
		 function,
		 streams_directory_offset,
		 streams_directory_offset );

		goto on_error;
	}
#if defined( HAVE_DEBUG_OUTPUT )
	if( libcnotify_verbose != 0 )
	{
		libcnotify_printf(
		 "%s: streams directory data:\n",
		 function );
		libcnotify_print_data(
		 streams_directory_data,
		 streams_directory_data_size,
		 0 );
	}
#endif
	streams_directory_entry_data = streams_directory_data;

	for( stream_index = 0;
	     stream_index < number_of_streams;
	     stream_index++ )
	{
		if( stream_descriptor == NULL )
		{
			if( libmdmp_stream_descriptor_initialize(
			     &stream_descriptor,
			     error ) != 1 )
			{
				libcerror_error_set(
				 error,
				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
				 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
				 "%s: unable to create stream descriptor.",
				 function );

				goto on_error;
			}
		}
		byte_stream_copy_to_uint32_little_endian(
		 ( (mdmp_streams_directory_entry_t *) streams_directory_entry_data )->stream_type,
		 stream_descriptor->type );

		byte_stream_copy_to_uint32_little_endian(
		 ( (mdmp_streams_directory_entry_t *) streams_directory_entry_data )->stream_data_size,
		 stream_data_size );

		byte_stream_copy_to_uint32_little_endian(
		 ( (mdmp_streams_directory_entry_t *) streams_directory_entry_data )->stream_data_rva,
		 stream_data_offset );

#if defined( HAVE_DEBUG_OUTPUT )
		if( libcnotify_verbose != 0 )
		{
			libcnotify_printf(
			 "%s: stream: %02" PRIu32 " type\t\t: %" PRIu32 " (%s)\n",
			 function,
			 stream_index,
			 stream_descriptor->type,
			 libmdmp_debug_get_stream_type(
			  stream_descriptor->type ) );

			libcnotify_printf(
			 "%s: stream: %02" PRIu32 " data size\t\t: %" PRIu32 "\n",
			 function,
			 stream_index,
			 stream_data_size );

			libcnotify_printf(
			 "%s: stream: %02" PRIu32 " RVA\t\t: 0x%08" PRIx32 "\n",
			 function,
			 stream_index,
			 stream_data_offset );
		}
#endif
		result = memory_compare(
		          streams_directory_entry_data,
		          empty_streams_directory_entry,
		          sizeof( mdmp_streams_directory_entry_t ) );

		streams_directory_entry_data += sizeof( mdmp_streams_directory_entry_t );

		if( result != 0 )
		{
			if( libmdmp_stream_descriptor_set_data_range(
			     stream_descriptor,
			     (off64_t) stream_data_offset,
			     (size64_t) stream_data_size,
			     error ) != 1 )
			{
				libcerror_error_set(
				 error,
				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
				 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
				 "%s: unable to set data range in stream descriptor.",
				 function );

				goto on_error;
			}
			if( libcdata_array_append_entry(
			     streams_array,
			     &entry_index,
			     (intptr_t *) stream_descriptor,
			     error ) != 1 )
			{
				libcerror_error_set(
				 error,
				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
				 LIBCERROR_RUNTIME_ERROR_APPEND_FAILED,
				 "%s: unable to append stream descriptor to sections array.",
				 function );

				goto on_error;
			}
			stream_descriptor = NULL;
		}
	}
	if( stream_descriptor != NULL )
	{
		if( libmdmp_stream_descriptor_free(
		     &stream_descriptor,
		     error ) != 1 )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
			 LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,
			 "%s: unable to free stream descriptor.",
			 function );

			goto on_error;
		}
	}
	memory_free(
	 streams_directory_data );

	return( 1 );

on_error:
	if( stream_descriptor != NULL )
	{
		libmdmp_stream_descriptor_free(
		 &stream_descriptor,
		 NULL );
	}
	if( streams_directory_data != NULL )
	{
		memory_free(
		 streams_directory_data );
	}
	return( -1 );
}

/* Reads the segment data into the buffer
 * Callback function for the section stream
 * Returns the number of bytes read or -1 on error
 */
ssize_t libmdmp_io_handle_read_segment_data(
         intptr_t *data_handle LIBMDMP_ATTRIBUTE_UNUSED,
         libbfio_handle_t *file_io_handle,
         int segment_index LIBMDMP_ATTRIBUTE_UNUSED,
         int segment_file_index LIBMDMP_ATTRIBUTE_UNUSED,
         uint8_t *segment_data,
         size_t segment_data_size,
         uint32_t segment_flags LIBMDMP_ATTRIBUTE_UNUSED,
         uint8_t read_flags LIBMDMP_ATTRIBUTE_UNUSED,
         libcerror_error_t **error )
{
	static char *function = "libmdmp_io_handle_read_segment_data";
	ssize_t read_count    = 0;

	LIBMDMP_UNREFERENCED_PARAMETER( data_handle )
	LIBMDMP_UNREFERENCED_PARAMETER( segment_index )
	LIBMDMP_UNREFERENCED_PARAMETER( segment_file_index )
	LIBMDMP_UNREFERENCED_PARAMETER( segment_flags )
	LIBMDMP_UNREFERENCED_PARAMETER( read_flags )

	read_count = libbfio_handle_read_buffer(
		      file_io_handle,
		      segment_data,
		      segment_data_size,
		      error );

	if( read_count != (ssize_t) segment_data_size )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_READ_FAILED,
		 "%s: unable to read segment data.",
		 function );

		return( -1 );
	}
	return( read_count );
}

/* Seeks a certain segment offset
 * Callback function for the section stream
 * Returns the offset or -1 on error
 */
off64_t libmdmp_io_handle_seek_segment_offset(
         intptr_t *data_handle LIBMDMP_ATTRIBUTE_UNUSED,
         libbfio_handle_t *file_io_handle,
         int segment_index LIBMDMP_ATTRIBUTE_UNUSED,
         int segment_file_index LIBMDMP_ATTRIBUTE_UNUSED,
         off64_t segment_offset,
         libcerror_error_t **error )
{
	static char *function = "libmdmp_io_handle_seek_segment_offset";

	LIBMDMP_UNREFERENCED_PARAMETER( data_handle )
	LIBMDMP_UNREFERENCED_PARAMETER( segment_index )
	LIBMDMP_UNREFERENCED_PARAMETER( segment_file_index )

	segment_offset = libbfio_handle_seek_offset(
	                  file_io_handle,
	                  segment_offset,
	                  SEEK_SET,
	                  error );

	if( segment_offset == -1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_READ_FAILED,
		 "%s: unable to seek segment offset.",
		 function );

		return( -1 );
	}
	return( segment_offset );
}


```

`libmdmp/libmdmp_io_handle.h`:

```h
/*
 * Input/Output (IO) handle functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_IO_HANDLE_H )
#define _LIBMDMP_IO_HANDLE_H

#include <common.h>
#include <types.h>

#include "libmdmp_libbfio.h"
#include "libmdmp_libcdata.h"
#include "libmdmp_libcerror.h"

#if defined( __cplusplus )
extern "C" {
#endif

extern const char *mdmp_file_signature;

typedef struct libmdmp_io_handle libmdmp_io_handle_t;

struct libmdmp_io_handle
{
	/* The version
	 */
	uint16_t version;

	/* Value to indicate if abort was signalled
	 */
	int abort;
};

int libmdmp_io_handle_initialize(
     libmdmp_io_handle_t **io_handle,
     libcerror_error_t **error );

int libmdmp_io_handle_free(
     libmdmp_io_handle_t **io_handle,
     libcerror_error_t **error );

int libmdmp_io_handle_clear(
     libmdmp_io_handle_t *io_handle,
     libcerror_error_t **error );

int libmdmp_io_handle_read_streams_directory(
     libmdmp_io_handle_t *io_handle,
     libbfio_handle_t *file_io_handle,
     uint32_t streams_directory_offset,
     uint32_t number_of_streams,
     libcdata_array_t *streams_array,
     libcerror_error_t **error );

ssize_t libmdmp_io_handle_read_segment_data(
         intptr_t *data_handle,
         libbfio_handle_t *file_io_handle,
         int segment_index,
         int segment_file_index,
         uint8_t *segment_data,
         size_t segment_data_size,
         uint32_t segment_flags,
         uint8_t read_flags,
         libcerror_error_t **error );

off64_t libmdmp_io_handle_seek_segment_offset(
         intptr_t *data_handle,
         libbfio_handle_t *file_io_handle,
         int segment_index,
         int segment_file_index,
         off64_t segment_offset,
         libcerror_error_t **error );

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_IO_HANDLE_H ) */


```

`libmdmp/libmdmp_libbfio.h`:

```h
/*
 * The libbfio header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_LIBBFIO_H )
#define _LIBMDMP_LIBBFIO_H

#include <common.h>

/* Define HAVE_LOCAL_LIBBFIO for local use of libbfio
 */
#if defined( HAVE_LOCAL_LIBBFIO )

#include <libbfio_definitions.h>
#include <libbfio_file.h>
#include <libbfio_file_pool.h>
#include <libbfio_file_range.h>
#include <libbfio_handle.h>
#include <libbfio_memory_range.h>
#include <libbfio_pool.h>
#include <libbfio_types.h>

#else

/* If libtool DLL support is enabled set LIBBFIO_DLL_IMPORT
 * before including libbfio.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBBFIO_DLL_IMPORT
#endif

#include <libbfio.h>

#if defined( HAVE_MULTI_THREAD_SUPPORT ) && !defined( LIBBFIO_HAVE_MULTI_THREAD_SUPPORT )
#error Multi-threading support requires libbfio with multi-threading support
#endif

#endif /* defined( HAVE_LOCAL_LIBBFIO ) */

#endif /* !defined( _LIBMDMP_LIBBFIO_H ) */


```

`libmdmp/libmdmp_libcdata.h`:

```h
/*
 * The libcdata header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_LIBCDATA_H )
#define _LIBMDMP_LIBCDATA_H

#include <common.h>

/* Define HAVE_LOCAL_LIBCDATA for local use of libcdata
 */
#if defined( HAVE_LOCAL_LIBCDATA )

#include <libcdata_array.h>
#include <libcdata_btree.h>
#include <libcdata_definitions.h>
#include <libcdata_list.h>
#include <libcdata_list_element.h>
#include <libcdata_range_list.h>
#include <libcdata_tree_node.h>
#include <libcdata_types.h>

#else

/* If libtool DLL support is enabled set LIBCDATA_DLL_IMPORT
 * before including libcdata.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBCDATA_DLL_IMPORT
#endif

#include <libcdata.h>

#endif /* defined( HAVE_LOCAL_LIBCDATA ) */

#endif /* !defined( _LIBMDMP_LIBCDATA_H ) */


```

`libmdmp/libmdmp_libcerror.h`:

```h
/*
 * The libcerror header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_LIBCERROR_H )
#define _LIBMDMP_LIBCERROR_H

#include <common.h>

/* Define HAVE_LOCAL_LIBCERROR for local use of libcerror
 */
#if defined( HAVE_LOCAL_LIBCERROR )

#include <libcerror_definitions.h>
#include <libcerror_error.h>
#include <libcerror_system.h>
#include <libcerror_types.h>

#else

/* If libtool DLL support is enabled set LIBCERROR_DLL_IMPORT
 * before including libcerror.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBCERROR_DLL_IMPORT
#endif

#include <libcerror.h>

#endif /* defined( HAVE_LOCAL_LIBCERROR ) */

#endif /* !defined( _LIBMDMP_LIBCERROR_H ) */


```

`libmdmp/libmdmp_libclocale.h`:

```h
/*
 * The libclocale header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_LIBCLOCALE_H )
#define _LIBMDMP_LIBCLOCALE_H

#include <common.h>

/* Define HAVE_LOCAL_LIBCLOCALE for local use of libclocale
 */
#if defined( HAVE_LOCAL_LIBCLOCALE )

#include <libclocale_codepage.h>
#include <libclocale_definitions.h>
#include <libclocale_locale.h>
#include <libclocale_support.h>

#else

/* If libtool DLL support is enabled set LIBCLOCALE_DLL_IMPORT
 * before including libclocale.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBCLOCALE_DLL_IMPORT
#endif

#include <libclocale.h>

#endif /* defined( HAVE_LOCAL_LIBCLOCALE ) */

#endif /* !defined( _LIBMDMP_LIBCLOCALE_H ) */


```

`libmdmp/libmdmp_libcnotify.h`:

```h
/*
 * The libcnotify header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_LIBCNOTIFY_H )
#define _LIBMDMP_LIBCNOTIFY_H

#include <common.h>

/* Define HAVE_LOCAL_LIBCNOTIFY for local use of libcnotify
 */
#if defined( HAVE_LOCAL_LIBCNOTIFY )

#include <libcnotify_definitions.h>
#include <libcnotify_print.h>
#include <libcnotify_stream.h>
#include <libcnotify_verbose.h>

#else

/* If libtool DLL support is enabled set LIBCNOTIFY_DLL_IMPORT
 * before including libcnotify.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBCNOTIFY_DLL_IMPORT
#endif

#include <libcnotify.h>

#endif /* defined( HAVE_LOCAL_LIBCNOTIFY ) */

#endif /* !defined( _LIBMDMP_LIBCNOTIFY_H ) */


```

`libmdmp/libmdmp_libfdata.h`:

```h
/*
 * The libfdata header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_LIBFDATA_H )
#define _LIBMDMP_LIBFDATA_H

#include <common.h>

/* Define HAVE_LOCAL_LIBFDATA for local use of libfdata
 */
#if defined( HAVE_LOCAL_LIBFDATA )

#include <libfdata_area.h>
#include <libfdata_definitions.h>
#include <libfdata_list.h>
#include <libfdata_list_element.h>
#include <libfdata_range_list.h>
#include <libfdata_stream.h>
#include <libfdata_types.h>
#include <libfdata_vector.h>

#else

/* If libtool DLL support is enabled set LIBFDATA_DLL_IMPORT
 * before including libfdata.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBFDATA_DLL_IMPORT
#endif

#include <libfdata.h>

#endif /* defined( HAVE_LOCAL_LIBFDATA ) */

#endif /* !defined( _LIBMDMP_LIBFDATA_H ) */


```

`libmdmp/libmdmp_libfdatetime.h`:

```h
/*
 * The libfdatetime header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_LIBFDATETIME_H )
#define _LIBMDMP_LIBFDATETIME_H

#include <common.h>

/* Define HAVE_LOCAL_LIBFDATETIME for local use of libfdatetime
 */
#if defined( HAVE_LOCAL_LIBFDATETIME )

#include <libfdatetime_date_time_values.h>
#include <libfdatetime_definitions.h>
#include <libfdatetime_fat_date_time.h>
#include <libfdatetime_filetime.h>
#include <libfdatetime_floatingtime.h>
#include <libfdatetime_hfs_time.h>
#include <libfdatetime_nsf_timedate.h>
#include <libfdatetime_posix_time.h>
#include <libfdatetime_systemtime.h>
#include <libfdatetime_types.h>

#else

/* If libtool DLL support is enabled set LIBFDATETIME_DLL_IMPORT
 * before including libfdatetime.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBFDATETIME_DLL_IMPORT
#endif

#include <libfdatetime.h>

#endif /* defined( HAVE_LOCAL_LIBFDATETIME ) */

#endif /* !defined( _LIBMDMP_LIBFDATETIME_H ) */


```

`libmdmp/libmdmp_libuna.h`:

```h
/*
 * The libuna header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_LIBUNA_H )
#define _LIBMDMP_LIBUNA_H

#include <common.h>

/* Define HAVE_LOCAL_LIBUNA for local use of libuna
 */
#if defined( HAVE_LOCAL_LIBUNA )

#include <libuna_base16_stream.h>
#include <libuna_base32_stream.h>
#include <libuna_base64_stream.h>
#include <libuna_byte_stream.h>
#include <libuna_unicode_character.h>
#include <libuna_url_stream.h>
#include <libuna_utf16_stream.h>
#include <libuna_utf16_string.h>
#include <libuna_utf32_stream.h>
#include <libuna_utf32_string.h>
#include <libuna_utf7_stream.h>
#include <libuna_utf8_stream.h>
#include <libuna_utf8_string.h>
#include <libuna_types.h>

#else

/* If libtool DLL support is enabled set LIBUNA_DLL_IMPORT
 * before including libuna.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBUNA_DLL_IMPORT
#endif

#include <libuna.h>

#endif /* defined( HAVE_LOCAL_LIBUNA ) */

#endif /* !defined( _LIBMDMP_LIBUNA_H ) */


```

`libmdmp/libmdmp_notify.c`:

```c
/*
 * Notification functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <types.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "libmdmp_libcerror.h"
#include "libmdmp_libcnotify.h"
#include "libmdmp_notify.h"

#if !defined( HAVE_LOCAL_LIBMDMP )

/* Sets the verbose notification
 */
void libmdmp_notify_set_verbose(
      int verbose )
{
	libcnotify_verbose_set(
	 verbose );
}

/* Sets the notification stream
 * Returns 1 if successful or -1 on error
 */
int libmdmp_notify_set_stream(
     FILE *stream,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_notify_set_stream";

	if( libcnotify_stream_set(
	     stream,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to set stream.",
		 function );

		return( -1 );
	}
	return( 1 );
}

/* Opens the notification stream using a filename
 * The stream is opened in append mode
 * Returns 1 if successful or -1 on error
 */
int libmdmp_notify_stream_open(
     const char *filename,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_notify_stream_open";

	if( libcnotify_stream_open(
	     filename,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_OPEN_FAILED,
		 "%s: unable to open stream.",
		 function );

		return( -1 );
	}
	return( 1 );
}

/* Closes the notification stream if opened using a filename
 * Returns 0 if successful or -1 on error
 */
int libmdmp_notify_stream_close(
     libcerror_error_t **error )
{
	static char *function = "libmdmp_notify_stream_close";

	if( libcnotify_stream_close(
	     error ) != 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_OPEN_FAILED,
		 "%s: unable to open stream.",
		 function );

		return( -1 );
	}
	return( 0 );
}

#endif /* !defined( HAVE_LOCAL_LIBMDMP ) */


```

`libmdmp/libmdmp_notify.h`:

```h
/*
 * Notification functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_NOTIFY_H )
#define _LIBMDMP_NOTIFY_H

#include <common.h>
#include <file_stream.h>
#include <types.h>

#include "libmdmp_extern.h"
#include "libmdmp_libcerror.h"

#if defined( __cplusplus )
extern "C" {
#endif

#if !defined( HAVE_LOCAL_LIBMDMP )

LIBMDMP_EXTERN \
void libmdmp_notify_set_verbose(
      int verbose );

LIBMDMP_EXTERN \
int libmdmp_notify_set_stream(
     FILE *stream,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_notify_stream_open(
     const char *filename,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_notify_stream_close(
     libcerror_error_t **error );

#endif /* !defined( HAVE_LOCAL_LIBMDMP ) */

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_NOTIFY_H ) */


```

`libmdmp/libmdmp_stream.c`:

```c
/*
 * Section functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <memory.h>
#include <types.h>

#include "libmdmp_definitions.h"
#include "libmdmp_io_handle.h"
#include "libmdmp_libbfio.h"
#include "libmdmp_libcerror.h"
#include "libmdmp_libfdata.h"
#include "libmdmp_libuna.h"
#include "libmdmp_stream.h"
#include "libmdmp_stream_io_handle.h"

/* Creates a stream
 * Make sure the value stream is referencing, is set to NULL
 * Returns 1 if successful or -1 on error
 */
int libmdmp_stream_initialize(
     libmdmp_stream_t **stream,
     libmdmp_io_handle_t *io_handle,
     libbfio_handle_t *file_io_handle,
     libmdmp_stream_descriptor_t *stream_descriptor,
     libcerror_error_t **error )
{
	libmdmp_internal_stream_t *internal_stream = NULL;
	static char *function                      = "libmdmp_stream_initialize";

	if( stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream.",
		 function );

		return( -1 );
	}
	if( *stream != NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: invalid stream value already set.",
		 function );

		return( -1 );
	}
	if( stream_descriptor == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream descriptor.",
		 function );

		return( -1 );
	}
	internal_stream = memory_allocate_structure(
	                   libmdmp_internal_stream_t );

	if( internal_stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create internal stream.",
		 function );

		goto on_error;
	}
	if( memory_set(
	     internal_stream,
	     0,
	     sizeof( libmdmp_internal_stream_t ) ) == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_SET_FAILED,
		 "%s: unable to clear internal stream.",
		 function );

		memory_free(
		 internal_stream );

		return( -1 );
	}
	internal_stream->file_io_handle    = file_io_handle;
	internal_stream->io_handle         = io_handle;
	internal_stream->stream_descriptor = stream_descriptor;

	*stream = (libmdmp_stream_t *) internal_stream;

	return( 1 );

on_error:
	if( internal_stream != NULL )
	{
		memory_free(
		 internal_stream );
	}
	return( -1 );
}

/* Frees a stream
 * Returns 1 if successful or -1 on error
 */
int libmdmp_stream_free(
     libmdmp_stream_t **stream,
     libcerror_error_t **error )
{
	libmdmp_internal_stream_t *internal_stream = NULL;
	static char *function                      = "libmdmp_stream_free";

	if( stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream.",
		 function );

		return( -1 );
	}
	if( *stream != NULL )
	{
		internal_stream = (libmdmp_internal_stream_t *) *stream;
		*stream         = NULL;

		/* The file_io_handle, io_handle and stream_descriptor references are freed elsewhere
		 */
		memory_free(
		 internal_stream );
	}
	return( 1 );
}

/* Retrieves the type
 * Returns 1 if successful or -1 on error
 */
int libmdmp_stream_get_type(
     libmdmp_stream_t *stream,
     uint32_t *type,
     libcerror_error_t **error )
{
	libmdmp_internal_stream_t *internal_stream = NULL;
	static char *function                      = "libmdmp_stream_get_type";

	if( stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream.",
		 function );

		return( -1 );
	}
	internal_stream = (libmdmp_internal_stream_t *) stream;

	if( internal_stream->stream_descriptor == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid internal stream - missing stream descriptor.",
		 function );

		return( -1 );
	}
	if( type == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid type.",
		 function );

		return( -1 );
	}
	*type = internal_stream->stream_descriptor->type;

	return( 1 );
}

/* Reads data at the current offset into a buffer
 * Returns the number of bytes read or -1 on error
 */
ssize_t libmdmp_stream_read_buffer(
         libmdmp_stream_t *stream,
         void *buffer,
         size_t buffer_size,
         libcerror_error_t **error )
{
	libmdmp_internal_stream_t *internal_stream = NULL;
	static char *function                      = "libmdmp_stream_read_buffer";
	ssize_t read_count                         = 0;

	if( stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream.",
		 function );

		return( -1 );
	}
	internal_stream = (libmdmp_internal_stream_t *) stream;

	if( internal_stream->stream_descriptor == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid stream - missing stream descriptor.",
		 function );

		return( -1 );
	}
	read_count = libfdata_stream_read_buffer(
	              internal_stream->stream_descriptor->data_stream,
	              (intptr_t *) internal_stream->file_io_handle,
	              buffer,
	              buffer_size,
	              0,
	              error );

	if( read_count == -1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_READ_FAILED,
		 "%s: unable to read buffer from stream data stream.",
		 function );

		return( -1 );
	}
	return( read_count );
}

/* Reads data at a specific offset into a buffer
 * Returns the number of bytes read or -1 on error
 */
ssize_t libmdmp_stream_read_buffer_at_offset(
         libmdmp_stream_t *stream,
         void *buffer,
         size_t buffer_size,
         off64_t offset,
         libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_read_buffer_at_offset";
	ssize_t read_count    = 0;

	if( libmdmp_stream_seek_offset(
	     stream,
	     offset,
	     SEEK_SET,
	     error ) == -1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_SEEK_FAILED,
		 "%s: unable to seek offset.",
		 function );

		return( -1 );
	}
	read_count = libmdmp_stream_read_buffer(
	              stream,
	              buffer,
	              buffer_size,
	              error );

	if( read_count < 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_READ_FAILED,
		 "%s: unable to read buffer.",
		 function );

		return( -1 );
	}
	return( read_count );
}

/* Seeks a certain offset of the data
 * Returns the offset if seek is successful or -1 on error
 */
off64_t libmdmp_stream_seek_offset(
         libmdmp_stream_t *stream,
         off64_t offset,
         int whence,
         libcerror_error_t **error )
{
	libmdmp_internal_stream_t *internal_stream = NULL;
	static char *function                      = "libmdmp_stream_seek_offset";

	if( stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream.",
		 function );

		return( -1 );
	}
	internal_stream = (libmdmp_internal_stream_t *) stream;

	if( internal_stream->stream_descriptor == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid stream - missing stream descriptor.",
		 function );

		return( -1 );
	}
	offset = libfdata_stream_seek_offset(
	          internal_stream->stream_descriptor->data_stream,
	          offset,
	          whence,
	          error );

	if( offset == -1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_SEEK_FAILED,
		 "%s: unable to seek in stream data stream.",
		 function );

		return( -1 );
	}
	return( offset );
}

/* Retrieves the (current) offset
 * Returns 1 if successful or -1 on error
 */
int libmdmp_stream_get_offset(
     libmdmp_stream_t *stream,
     off64_t *offset,
     libcerror_error_t **error )
{
	libmdmp_internal_stream_t *internal_stream = NULL;
	static char *function                      = "libmdmp_stream_get_offset";

	if( stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream.",
		 function );

		return( -1 );
	}
	internal_stream = (libmdmp_internal_stream_t *) stream;

	if( internal_stream->stream_descriptor == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid stream - missing stream descriptor.",
		 function );

		return( -1 );
	}
	if( libfdata_stream_get_offset(
	     internal_stream->stream_descriptor->data_stream,
	     offset,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to retrieve stream data stream offset.",
		 function );

		return( -1 );
	}
	return( 1 );
}

/* Retrieves the size
 * Returns 1 if successful or -1 on error
 */
int libmdmp_stream_get_size(
     libmdmp_stream_t *stream,
     size64_t *size,
     libcerror_error_t **error )
{
	libmdmp_internal_stream_t *internal_stream = NULL;
	static char *function                      = "libmdmp_stream_get_size";

	if( stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream.",
		 function );

		return( -1 );
	}
	internal_stream = (libmdmp_internal_stream_t *) stream;

	if( internal_stream->stream_descriptor == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid stream - missing stream descriptor.",
		 function );

		return( -1 );
	}
	if( libfdata_stream_get_size(
	     internal_stream->stream_descriptor->data_stream,
	     size,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to retrieve stream data stream size.",
		 function );

		return( -1 );
	}
	return( 1 );
}

/* Retrieves the start offset
 * Returns 1 if successful or -1 on error
 */
int libmdmp_stream_get_start_offset(
     libmdmp_stream_t *stream,
     off64_t *start_offset,
     libcerror_error_t **error )
{
	libmdmp_internal_stream_t *internal_stream = NULL;
	static char *function                      = "libmdmp_stream_get_start_offset";
	size64_t segment_size                      = 0;
	uint32_t segment_flags                     = 0;
	int segment_file_index                     = 0;

	if( stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream.",
		 function );

		return( -1 );
	}
	internal_stream = (libmdmp_internal_stream_t *) stream;

	if( internal_stream->stream_descriptor == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid internal stream - missing stream descriptor.",
		 function );

		return( -1 );
	}
	if( libfdata_stream_get_segment_by_index(
	     internal_stream->stream_descriptor->data_stream,
	     0,
	     &segment_file_index,
	     start_offset,
	     &segment_size,
	     &segment_flags,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to retrieve stream data stream segment: 0.",
		 function );

		return( -1 );
	}
	return( 1 );
}

/* Retrieves the stream data file IO handle
 * Returns 1 if successful -1 on error
 */
int libmdmp_stream_get_data_file_io_handle(
     libmdmp_stream_t *stream,
     libbfio_handle_t **file_io_handle,
     libcerror_error_t **error )
{
	libmdmp_stream_io_handle_t *io_handle = NULL;
	static char *function                 = "libmdmp_stream_get_data_file_io_handle";

	if( libmdmp_stream_io_handle_initialize(
	     &io_handle,
	     stream,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create stream file IO handle.",
		 function );

		goto on_error;
	}
	if( libbfio_handle_initialize(
	     file_io_handle,
	     (intptr_t *) io_handle,
	     (int (*)(intptr_t **, libcerror_error_t **)) libmdmp_stream_io_handle_free,
	     (int (*)(intptr_t **, intptr_t *, libcerror_error_t **)) libmdmp_stream_io_handle_clone,
	     (int (*)(intptr_t *, int flags, libcerror_error_t **)) libmdmp_stream_io_handle_open,
	     (int (*)(intptr_t *, libcerror_error_t **)) libmdmp_stream_io_handle_close,
	     (ssize_t (*)(intptr_t *, uint8_t *, size_t, libcerror_error_t **)) libmdmp_stream_io_handle_read,
	     (ssize_t (*)(intptr_t *, const uint8_t *, size_t, libcerror_error_t **)) libmdmp_stream_io_handle_write,
	     (off64_t (*)(intptr_t *, off64_t, int, libcerror_error_t **)) libmdmp_stream_io_handle_seek_offset,
	     (int (*)(intptr_t *, libcerror_error_t **)) libmdmp_stream_io_handle_exists,
	     (int (*)(intptr_t *, libcerror_error_t **)) libmdmp_stream_io_handle_is_open,
	     (int (*)(intptr_t *, size64_t *, libcerror_error_t **)) libmdmp_stream_io_handle_get_size,
	     LIBBFIO_FLAG_IO_HANDLE_MANAGED | LIBBFIO_FLAG_IO_HANDLE_CLONE_BY_FUNCTION,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create file IO handle.",
		 function );

		goto on_error;
	}
	return( 1 );

on_error:
	if( io_handle != NULL )
	{
		libmdmp_stream_io_handle_free(
		 &io_handle,
		 NULL );
	}
	return( -1 );
}


```

`libmdmp/libmdmp_stream.h`:

```h
/*
 * Section functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_INTERNAL_STREAM_H )
#define _LIBMDMP_INTERNAL_STREAM_H

#include <common.h>
#include <types.h>

#include "libmdmp_extern.h"
#include "libmdmp_io_handle.h"
#include "libmdmp_libbfio.h"
#include "libmdmp_libcerror.h"
#include "libmdmp_stream_descriptor.h"
#include "libmdmp_types.h"

#if defined( __cplusplus )
extern "C" {
#endif

typedef struct libmdmp_internal_stream libmdmp_internal_stream_t;

struct libmdmp_internal_stream
{
	/* The IO handle
	 */
	libmdmp_io_handle_t *io_handle;

	/* The file IO handle
	 */
	libbfio_handle_t *file_io_handle;

	/* The stream descriptor
	 */
	libmdmp_stream_descriptor_t *stream_descriptor;
};

int libmdmp_stream_initialize(
     libmdmp_stream_t **stream,
     libmdmp_io_handle_t *io_handle,
     libbfio_handle_t *file_io_handle,
     libmdmp_stream_descriptor_t *stream_descriptor,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_stream_free(
     libmdmp_stream_t **stream,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_stream_get_type(
     libmdmp_stream_t *stream,
     uint32_t *type,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
ssize_t libmdmp_stream_read_buffer(
         libmdmp_stream_t *stream,
         void *buffer,
         size_t buffer_size,
         libcerror_error_t **error );

LIBMDMP_EXTERN \
ssize_t libmdmp_stream_read_buffer_at_offset(
         libmdmp_stream_t *stream,
         void *buffer,
         size_t buffer_size,
         off64_t offset,
         libcerror_error_t **error );

LIBMDMP_EXTERN \
off64_t libmdmp_stream_seek_offset(
         libmdmp_stream_t *stream,
         off64_t offset,
         int whence,
         libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_stream_get_offset(
     libmdmp_stream_t *stream,
     off64_t *offset,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_stream_get_size(
     libmdmp_stream_t *stream,
     size64_t *size,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_stream_get_start_offset(
     libmdmp_stream_t *stream,
     off64_t *start_offset,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_stream_get_data_file_io_handle(
     libmdmp_stream_t *stream,
     libbfio_handle_t **file_io_handle,
     libcerror_error_t **error );

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_INTERNAL_STREAM_H ) */


```

`libmdmp/libmdmp_stream_descriptor.c`:

```c
/*
 * Section decriptor functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <memory.h>
#include <types.h>

#include "libmdmp_io_handle.h"
#include "libmdmp_libcerror.h"
#include "libmdmp_libfdata.h"
#include "libmdmp_stream_descriptor.h"

/* Creates a stream descriptor
 * Make sure the value stream_descriptor is referencing, is set to NULL
 * Returns 1 if successful or -1 on error
 */
int libmdmp_stream_descriptor_initialize(
     libmdmp_stream_descriptor_t **stream_descriptor,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_descriptor_initialize";

	if( stream_descriptor == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream descriptor.",
		 function );

		return( -1 );
	}
	if( *stream_descriptor != NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: invalid stream descriptor value already set.",
		 function );

		return( -1 );
	}
	*stream_descriptor = memory_allocate_structure(
	                      libmdmp_stream_descriptor_t );

	if( *stream_descriptor == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,
		 "%s: unable to create stream descriptor.",
		 function );

		goto on_error;
	}
	if( memory_set(
	     *stream_descriptor,
	     0,
	     sizeof( libmdmp_stream_descriptor_t ) ) == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_SET_FAILED,
		 "%s: unable to clear stream descriptor.",
		 function );

		memory_free(
		 *stream_descriptor );

		*stream_descriptor = NULL;

		return( -1 );
	}
	if( libfdata_stream_initialize(
	     &( ( *stream_descriptor )->data_stream ),
	     NULL,
	     NULL,
	     NULL,
	     NULL,
	     (ssize_t (*)(intptr_t *, intptr_t *, int, int, uint8_t *, size_t, uint32_t, uint8_t, libcerror_error_t **)) &libmdmp_io_handle_read_segment_data,
	     NULL,
	     (off64_t (*)(intptr_t *, intptr_t *, int, int, off64_t, libcerror_error_t **)) &libmdmp_io_handle_seek_segment_offset,
	     0,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create data stream.",
		 function );

		goto on_error;
	}
	if( libfdata_stream_resize(
	     ( *stream_descriptor )->data_stream,
	     1,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_RESIZE_FAILED,
		 "%s: unable to resize data stream.",
		 function );

		goto on_error;
	}
	return( 1 );

on_error:
	if( *stream_descriptor != NULL )
	{
		if( ( *stream_descriptor )->data_stream != NULL )
		{
			libfdata_stream_free(
			 &( ( *stream_descriptor )->data_stream ),
			 NULL );
		}
		memory_free(
		 *stream_descriptor );

		*stream_descriptor = NULL;
	}
	return( -1 );
}

/* Frees a stream descriptor
 * Returns 1 if successful or -1 on error
 */
int libmdmp_stream_descriptor_free(
     libmdmp_stream_descriptor_t **stream_descriptor,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_descriptor_free";
	int result            = 1;

	if( stream_descriptor == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream descriptor.",
		 function );

		return( -1 );
	}
	if( *stream_descriptor != NULL )
	{
		if( libfdata_stream_free(
		     &( ( *stream_descriptor )->data_stream ),
		     error ) != 1 )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
			 LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,
			 "%s: unable to free data stream.",
			 function );

			result = -1;
		}
		memory_free(
		 *stream_descriptor );

		*stream_descriptor = NULL;
	}
	return( result );
}

/* Sets the data range
 * Returns 1 if successful or -1 on error
 */
int libmdmp_stream_descriptor_set_data_range(
     libmdmp_stream_descriptor_t *stream_descriptor,
     off64_t data_offset,
     size64_t data_size,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_descriptor_set_data_range";

	if( stream_descriptor == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream descriptor.",
		 function );

		return( -1 );
	}
	if( libfdata_stream_set_segment_by_index(
	     stream_descriptor->data_stream,
	     0,
	     0,
	     data_offset,
	     data_size,
	     0,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to set segment in data stream.",
		 function );

		return( -1 );
	}
	return( 1 );
}


```

`libmdmp/libmdmp_stream_descriptor.h`:

```h
/*
 * Section descriptor functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_STREAM_DESCRIPTOR_H )
#define _LIBMDMP_STREAM_DESCRIPTOR_H

#include <common.h>
#include <types.h>

#include "libmdmp_libcerror.h"
#include "libmdmp_libfdata.h"

#if defined( __cplusplus )
extern "C" {
#endif

typedef struct libmdmp_stream_descriptor libmdmp_stream_descriptor_t;

struct libmdmp_stream_descriptor
{
	/* The type
	 */
	uint32_t type;

	/* The data stream
	 */
	libfdata_stream_t *data_stream;
};

int libmdmp_stream_descriptor_initialize(
     libmdmp_stream_descriptor_t **stream_descriptor,
     libcerror_error_t **error );

int libmdmp_stream_descriptor_free(
     libmdmp_stream_descriptor_t **stream_descriptor,
     libcerror_error_t **error );

int libmdmp_stream_descriptor_set_data_range(
     libmdmp_stream_descriptor_t *stream_descriptor,
     off64_t data_offset,
     size64_t data_size,
     libcerror_error_t **error );

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_STREAM_DESCRIPTOR_H ) */


```

`libmdmp/libmdmp_stream_io_handle.c`:

```c
/*
 * Section IO handle functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <memory.h>
#include <types.h>

#include "libmdmp_definitions.h"
#include "libmdmp_libbfio.h"
#include "libmdmp_libcerror.h"
#include "libmdmp_stream.h"
#include "libmdmp_stream_io_handle.h"
#include "libmdmp_types.h"

/* Creates a stream IO handle
 * Make sure the value io_handle is referencing, is set to NULL
 * Returns 1 if successful or -1 on error
 */
int libmdmp_stream_io_handle_initialize(
     libmdmp_stream_io_handle_t **io_handle,
     libmdmp_stream_t *stream,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_io_handle_initialize";

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( *io_handle != NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: invalid IO handle value already set.",
		 function );

		return( -1 );
	}
	if( stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid stream.",
		 function );

		return( -1 );
	}
	*io_handle = memory_allocate_structure(
	              libmdmp_stream_io_handle_t );

	if( *io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,
		 "%s: unable to create IO handle.",
		 function );

		goto on_error;
	}
	if( memory_set(
	     *io_handle,
	     0,
	     sizeof( libmdmp_stream_io_handle_t ) ) == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_SET_FAILED,
		 "%s: unable to clear IO handle.",
		 function );

		goto on_error;
	}
	( *io_handle )->stream = stream;

	return( 1 );

on_error:
	if( *io_handle != NULL )
	{
		memory_free(
		 *io_handle );

		*io_handle = NULL;
	}
	return( -1 );
}

/* Frees a stream IO handle
 * Returns 1 if succesful or -1 on error
 */
int libmdmp_stream_io_handle_free(
     libmdmp_stream_io_handle_t **io_handle,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_io_handle_free";

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( *io_handle != NULL )
	{
		/* The stream reference is freed elsewhere
		 */
		memory_free(
		 *io_handle );

		*io_handle = NULL;
	}
	return( 1 );
}

/* Clones (duplicates) the IO handle and its attributes
 * Returns 1 if succesful or -1 on error
 */
int libmdmp_stream_io_handle_clone(
     libmdmp_stream_io_handle_t **destination_io_handle,
     libmdmp_stream_io_handle_t *source_io_handle,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_io_handle_clone";

	if( destination_io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid destination IO handle.",
		 function );

		return( -1 );
	}
	if( *destination_io_handle != NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: destination IO handle already set.",
		 function );

		return( -1 );
	}
	if( source_io_handle == NULL )
	{
		*destination_io_handle = NULL;

		return( 1 );
	}
	if( libmdmp_stream_io_handle_initialize(
	     destination_io_handle,
	     source_io_handle->stream,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create IO handle.",
		 function );

		return( -1 );
	}
	( *destination_io_handle )->access_flags = source_io_handle->access_flags;

	return( 1 );
}

/* Opens the IO handle
 * Returns 1 if successful or -1 on error
 */
int libmdmp_stream_io_handle_open(
     libmdmp_stream_io_handle_t *io_handle,
     int flags,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_io_handle_open";

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( io_handle->stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid IO handle - missing stream.",
		 function );

		return( -1 );
	}
	if( io_handle->is_open != 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: IO handle already open.",
		 function );

		return( -1 );
	}
	if( ( flags & LIBBFIO_ACCESS_FLAG_READ ) == 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,
		 "%s: unsupported flags.",
		 function );

		return( -1 );
	}
	/* Currently only support for reading data
	 */
	if( ( flags & ~( LIBBFIO_ACCESS_FLAG_READ ) ) != 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,
		 "%s: unsupported flags.",
		 function );

		return( -1 );
	}
	io_handle->access_flags = flags;
	io_handle->is_open      = 1;

	return( 1 );
}

/* Closes the IO handle
 * Returns 0 if successful or -1 on error
 */
int libmdmp_stream_io_handle_close(
     libmdmp_stream_io_handle_t *io_handle,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_io_handle_close";

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( io_handle->stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid IO handle - missing stream.",
		 function );

		return( -1 );
	}
	if( io_handle->is_open == 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid IO handle - not open.",
		 function );

		return( -1 );
	}
	io_handle->is_open = 0;

	return( 0 );
}

/* Reads a buffer from the IO handle
 * Returns the number of bytes read if successful, or -1 on error
 */
ssize_t libmdmp_stream_io_handle_read(
         libmdmp_stream_io_handle_t *io_handle,
         uint8_t *buffer,
         size_t size,
         libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_io_handle_read";
	ssize_t read_count    = 0;

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( io_handle->stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid IO handle - missing stream.",
		 function );

		return( -1 );
	}
	if( io_handle->is_open == 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid IO handle - not open.",
		 function );

		return( -1 );
	}
	if( ( io_handle->access_flags & LIBBFIO_ACCESS_FLAG_READ ) == 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid IO handle - no read access.",
		 function );

		return( -1 );
	}
	read_count = libmdmp_stream_read_buffer(
	              io_handle->stream,
	              buffer,
	              size,
	              error );

	if( read_count <= -1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_READ_FAILED,
		 "%s: unable to read buffer from stream.",
		 function );

		return( -1 );
	}
	return( read_count );
}

/* Writes a buffer to the IO handle
 * Returns the number of bytes written if successful, or -1 on error
 */
ssize_t libmdmp_stream_io_handle_write(
         libmdmp_stream_io_handle_t *io_handle,
         const uint8_t *buffer,
         size_t size,
         libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_io_handle_write";

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( io_handle->stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid IO handle - missing stream.",
		 function );

		return( -1 );
	}
	if( io_handle->is_open == 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid IO handle - not open.",
		 function );

		return( -1 );
	}
	if( ( io_handle->access_flags & LIBBFIO_ACCESS_FLAG_WRITE ) == 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid IO handle - no write access.",
		 function );

		return( -1 );
	}
	if( buffer == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid buffer.",
		 function );

		return( -1 );
	}
	if( size > (size_t) SSIZE_MAX )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,
		 "%s: invalid size value exceeds maximum.",
		 function );

		return( -1 );
	}
	return( 0 );
}

/* Seeks a certain offset within the IO handle
 * Returns the offset if the seek is successful or -1 on error
 */
off64_t libmdmp_stream_io_handle_seek_offset(
         libmdmp_stream_io_handle_t *io_handle,
         off64_t offset,
         int whence,
         libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_io_handle_seek_offset";

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( io_handle->stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid IO handle - missing stream.",
		 function );

		return( -1 );
	}
	if( io_handle->is_open == 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid IO handle - not open.",
		 function );

		return( -1 );
	}
	offset = libmdmp_stream_seek_offset(
	          io_handle->stream,
	          offset,
	          whence,
	          error );

	if( offset == -1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_SEEK_FAILED,
		 "%s: unable to seek offset in stream.",
		 function );

		return( -1 );
	}
	return( offset );
}

/* Function to determine if the attached file exists
 * Returns 1 if the attached file exists, 0 if not or -1 on error
 */
int libmdmp_stream_io_handle_exists(
     libmdmp_stream_io_handle_t *io_handle,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_io_handle_exists";

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( io_handle->stream == NULL )
	{
		return( 0 );
	}
	return( 1 );
}

/* Check if the attached file is open
 * Returns 1 if open, 0 if not or -1 on error
 */
int libmdmp_stream_io_handle_is_open(
     libmdmp_stream_io_handle_t *io_handle,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_io_handle_is_open";

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( io_handle->stream == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,
		 "%s: invalid IO handle - missing stream.",
		 function );

		return( -1 );
	}
	if( io_handle->is_open == 0 )
	{
		return( 0 );
	}
	return( 1 );
}

/* Retrieves the attached file size
 * Returns 1 if successful or -1 on error
 */
int libmdmp_stream_io_handle_get_size(
     libmdmp_stream_io_handle_t *io_handle,
     size64_t *size,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_stream_io_handle_get_size";

	if( io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid IO handle.",
		 function );

		return( -1 );
	}
	if( libmdmp_stream_get_size(
	     io_handle->stream,
	     size,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to retrieve stream size.",
		 function );

		return( -1 );
	}
	return( 1 );
}


```

`libmdmp/libmdmp_stream_io_handle.h`:

```h
/*
 * Section IO handle functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_STREAM_IO_HANDLE_H )
#define _LIBMDMP_STREAM_IO_HANDLE_H

#include <common.h>
#include <types.h>

#include "libmdmp_libcerror.h"
#include "libmdmp_types.h"

#if defined( __cplusplus )
extern "C" {
#endif

typedef struct libmdmp_stream_io_handle libmdmp_stream_io_handle_t;

struct libmdmp_stream_io_handle
{
	/* The stream
	 */
	libmdmp_stream_t *stream;

	/* Value to indicate the IO handle is open
	 */
	uint8_t is_open;

	/* The current access flags
	 */
	int access_flags;
};

int libmdmp_stream_io_handle_initialize(
     libmdmp_stream_io_handle_t **io_handle,
     libmdmp_stream_t *stream,
     libcerror_error_t **error );

int libmdmp_stream_io_handle_free(
     libmdmp_stream_io_handle_t **io_handle,
     libcerror_error_t **error );

int libmdmp_stream_io_handle_clone(
     libmdmp_stream_io_handle_t **destination_io_handle,
     libmdmp_stream_io_handle_t *source_io_handle,
     libcerror_error_t **error );

int libmdmp_stream_io_handle_open(
     libmdmp_stream_io_handle_t *io_handle,
     int flags,
     libcerror_error_t **error );

int libmdmp_stream_io_handle_close(
     libmdmp_stream_io_handle_t *io_handle,
     libcerror_error_t **error );

ssize_t libmdmp_stream_io_handle_read(
         libmdmp_stream_io_handle_t *io_handle,
         uint8_t *buffer,
         size_t size,
         libcerror_error_t **error );

ssize_t libmdmp_stream_io_handle_write(
         libmdmp_stream_io_handle_t *io_handle,
         const uint8_t *buffer,
         size_t size,
         libcerror_error_t **error );

off64_t libmdmp_stream_io_handle_seek_offset(
         libmdmp_stream_io_handle_t *io_handle,
         off64_t offset,
         int whence,
         libcerror_error_t **error );

int libmdmp_stream_io_handle_exists(
     libmdmp_stream_io_handle_t *io_handle,
     libcerror_error_t **error );

int libmdmp_stream_io_handle_is_open(
     libmdmp_stream_io_handle_t *io_handle,
     libcerror_error_t **error );

int libmdmp_stream_io_handle_get_size(
     libmdmp_stream_io_handle_t *io_handle,
     size64_t *size,
     libcerror_error_t **error );

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_STREAM_IO_HANDLE_H ) */


```

`libmdmp/libmdmp_support.c`:

```c
/*
 * Support functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <memory.h>
#include <narrow_string.h>
#include <types.h>
#include <wide_string.h>

#include "libmdmp_codepage.h"
#include "libmdmp_definitions.h"
#include "libmdmp_io_handle.h"
#include "libmdmp_libbfio.h"
#include "libmdmp_libcerror.h"
#include "libmdmp_libclocale.h"
#include "libmdmp_support.h"

#if !defined( HAVE_LOCAL_LIBMDMP )

/* Returns the library version
 */
const char *libmdmp_get_version(
             void )
{
	return( (const char *) LIBMDMP_VERSION_STRING );
}

/* Returns the access flags for reading
 */
int libmdmp_get_access_flags_read(
     void )
{
	return( (int) LIBMDMP_ACCESS_FLAG_READ );
}

/* Retrieves the narrow system string codepage
 * A value of 0 represents no codepage, UTF-8 encoding is used instead
 * Returns 1 if successful or -1 on error
 */
int libmdmp_get_codepage(
     int *codepage,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_get_codepage";

	if( libclocale_codepage_get(
	     codepage,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to retrieve codepage.",
		 function );

		return( -1 );
	}
	return( 1 );
}

/* Sets the narrow system string codepage
 * A value of 0 represents no codepage, UTF-8 encoding is used instead
 * Returns 1 if successful or -1 on error
 */
int libmdmp_set_codepage(
     int codepage,
     libcerror_error_t **error )
{
	static char *function = "libmdmp_set_codepage";

	if( libclocale_codepage_set(
	     codepage,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to set codepage.",
		 function );

		return( -1 );
	}
	return( 1 );
}

#endif /* !defined( HAVE_LOCAL_LIBMDMP ) */

/* Determines if a file contains a MDMP file signature
 * Returns 1 if true, 0 if not or -1 on error
 */
int libmdmp_check_file_signature(
     const char *filename,
     libcerror_error_t **error )
{
	libbfio_handle_t *file_io_handle = NULL;
	static char *function            = "libmdmp_check_file_signature";
	size_t filename_length           = 0;
	int result                       = 0;

	if( filename == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid filename.",
		 function );

		return( -1 );
	}
	filename_length = narrow_string_length(
	                   filename );

	if( filename_length == 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid filename.",
		 function );

		goto on_error;
	}
	if( libbfio_file_initialize(
	     &file_io_handle,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create file IO handle.",
		 function );

		goto on_error;
	}
	if( libbfio_file_set_name(
	     file_io_handle,
	     filename,
	     filename_length,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to set filename in file IO handle.",
		 function );

		goto on_error;
	}
	result = libmdmp_check_file_signature_file_io_handle(
	          file_io_handle,
	          error );

	if( result == -1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to check file signature using a file handle.",
		 function );

		goto on_error;
	}
	if( libbfio_handle_free(
	     &file_io_handle,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to free file IO handle.",
		 function );

		goto on_error;
	}
	return( result );

on_error:
	if( file_io_handle != NULL )
	{
		libbfio_handle_free(
		 &file_io_handle,
		 NULL );
	}
	return( -1 );
}

#if defined( HAVE_WIDE_CHARACTER_TYPE )

/* Determines if a file contains a MDMP file signature
 * Returns 1 if true, 0 if not or -1 on error
 */
int libmdmp_check_file_signature_wide(
     const wchar_t *filename,
     libcerror_error_t **error )
{
	libbfio_handle_t *file_io_handle = NULL;
	static char *function            = "libmdmp_check_file_signature_wide";
	size_t filename_length           = 0;
	int result                       = 0;

	if( filename == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid filename.",
		 function );

		return( -1 );
	}
	filename_length = wide_string_length(
	                   filename );

	if( filename_length == 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid filename.",
		 function );

		goto on_error;
	}
	if( libbfio_file_initialize(
	     &file_io_handle,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create file IO handle.",
		 function );

		goto on_error;
	}
	if( libbfio_file_set_name_wide(
	     file_io_handle,
	     filename,
	     filename_length,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to set filename in file IO handle.",
		 function );

		goto on_error;
	}
	result = libmdmp_check_file_signature_file_io_handle(
	          file_io_handle,
	          error );

	if( result == -1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to check file signature using a file handle.",
		 function );

		goto on_error;
	}
	if( libbfio_handle_free(
	     &file_io_handle,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to free file IO handle.",
		 function );

		goto on_error;
	}
	return( result );

on_error:
	if( file_io_handle != NULL )
	{
		libbfio_handle_free(
		 &file_io_handle,
		 NULL );
	}
	return( -1 );
}

#endif /* defined( HAVE_WIDE_CHARACTER_TYPE ) */

/* Determines if a file contains a MDMP file signature using a Basic File IO (bfio) handle
 * Returns 1 if true, 0 if not or -1 on error
 */
int libmdmp_check_file_signature_file_io_handle(
     libbfio_handle_t *file_io_handle,
     libcerror_error_t **error )
{
	uint8_t signature[ 4 ];

	static char *function      = "libmdmp_check_file_signature_file_io_handle";
	ssize_t read_count         = 0;
	int file_io_handle_is_open = 0;

	if( file_io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file IO handle.",
		 function );

		return( -1 );
	}
	file_io_handle_is_open = libbfio_handle_is_open(
	                          file_io_handle,
	                          error );

	if( file_io_handle_is_open == -1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_OPEN_FAILED,
		 "%s: unable to open file.",
		 function );

		goto on_error;
	}
	else if( file_io_handle_is_open == 0 )
	{
		if( libbfio_handle_open(
		     file_io_handle,
		     LIBBFIO_OPEN_READ,
		     error ) != 1 )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_IO,
			 LIBCERROR_IO_ERROR_OPEN_FAILED,
			 "%s: unable to open file.",
			 function );

			goto on_error;
		}
	}
	read_count = libbfio_handle_read_buffer_at_offset(
	              file_io_handle,
	              signature,
	              4,
	              0,
	              error );

	if( read_count != 4 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_READ_FAILED,
		 "%s: unable to read signature at offset: 0 (0x00000000).",
		 function );

		goto on_error;
	}
	if( file_io_handle_is_open == 0 )
	{
		if( libbfio_handle_close(
		     file_io_handle,
		     error ) != 0 )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_IO,
			 LIBCERROR_IO_ERROR_CLOSE_FAILED,
			 "%s: unable to close file.",
			 function );

			goto on_error;
		}
	}
	if( memory_compare(
	     mdmp_file_signature,
	     signature,
	     4 ) == 0 )
	{
		return( 1 );
	}
	return( 0 );

on_error:
	if( file_io_handle_is_open == 0 )
	{
		libbfio_handle_close(
		 file_io_handle,
		 NULL );
	}
	return( -1 );
}


```

`libmdmp/libmdmp_support.h`:

```h
/*
 * Support functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_SUPPORT_H )
#define _LIBMDMP_SUPPORT_H

#include <common.h>
#include <types.h>

#include "libmdmp_extern.h"
#include "libmdmp_libbfio.h"
#include "libmdmp_libcerror.h"

#if defined( __cplusplus )
extern "C" {
#endif

#if !defined( HAVE_LOCAL_LIBMDMP )

LIBMDMP_EXTERN \
const char *libmdmp_get_version(
             void );

LIBMDMP_EXTERN \
int libmdmp_get_access_flags_read(
     void );

LIBMDMP_EXTERN \
int libmdmp_get_codepage(
     int *codepage,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_set_codepage(
     int codepage,
     libcerror_error_t **error );

#endif /* !defined( HAVE_LOCAL_LIBMDMP ) */

LIBMDMP_EXTERN \
int libmdmp_check_file_signature(
     const char *filename,
     libcerror_error_t **error );

#if defined( HAVE_WIDE_CHARACTER_TYPE )

LIBMDMP_EXTERN \
int libmdmp_check_file_signature_wide(
     const wchar_t *filename,
     libcerror_error_t **error );

#endif /* defined( HAVE_WIDE_CHARACTER_TYPE ) */

LIBMDMP_EXTERN \
int libmdmp_check_file_signature_file_io_handle(
     libbfio_handle_t *file_io_handle,
     libcerror_error_t **error );

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _LIBMDMP_SUPPORT_H ) */


```

`libmdmp/libmdmp_types.h`:

```h
/*
 * The internal type definitions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_INTERNAL_TYPES_H )
#define _LIBMDMP_INTERNAL_TYPES_H

#include <common.h>
#include <types.h>

/* Define HAVE_LOCAL_LIBMDMP for local use of libmdmp
 * The definitions in <libmdmp/types.h> are copied here
 * for local use of libmdmp
 */
#if defined( HAVE_LOCAL_LIBMDMP )

/* The following type definitions hide internal data structures
 */
#if defined( HAVE_DEBUG_OUTPUT ) && !defined( WINAPI )
typedef struct libmdmp_file {}		libmdmp_file_t;
typedef struct libmdmp_stream {}	libmdmp_stream_t;

#else
typedef intptr_t libmdmp_file_t;
typedef intptr_t libmdmp_stream_t;

#endif /* defined( HAVE_DEBUG_OUTPUT ) && !defined( WINAPI ) */

#endif /* defined( HAVE_LOCAL_LIBMDMP ) */

#endif /* !defined( _LIBMDMP_INTERNAL_TYPES_H ) */


```

`libmdmp/libmdmp_unused.h`:

```h
/*
 * Definitions to silence compiler warnings about unused function attributes/parameters.
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _LIBMDMP_UNUSED_H )
#define _LIBMDMP_UNUSED_H

#include <common.h>

#if !defined( LIBMDMP_ATTRIBUTE_UNUSED )
#if defined( __GNUC__ ) && __GNUC__ >= 3
#define LIBMDMP_ATTRIBUTE_UNUSED	__attribute__ ((__unused__))
#else
#define LIBMDMP_ATTRIBUTE_UNUSED
#endif
#endif

#if defined( _MSC_VER )
#define LIBMDMP_UNREFERENCED_PARAMETER( parameter ) \
	UNREFERENCED_PARAMETER( parameter );
#else
#define LIBMDMP_UNREFERENCED_PARAMETER( parameter ) \
	/* parameter */
#endif

#endif /* !defined( _LIBMDMP_UNUSED_H ) */


```

`libmdmp/mdmp_file_header.h`:

```h
/*
 * The file header definition of a Windows Minidump (MDMP) file
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMP_FILE_HEADER_H )
#define _MDMP_FILE_HEADER_H

#include <common.h>
#include <types.h>

#if defined( __cplusplus )
extern "C" {
#endif

typedef struct mdmp_file_header mdmp_file_header_t;

struct mdmp_file_header
{
	/* Signature
	 * Consists of 4 bytes
	 * "MDMP"
	 */
	uint8_t signature[ 4 ];

	/* The version
	 * Consists of 2 bytes
	 */
	uint8_t version[ 2 ];

	/* The implementation version
	 * Consists of 2 bytes
	 */
	uint8_t implementation_version[ 2 ];

	/* The number of streams
	 * Consists of 4 bytes
	 */
	uint8_t number_of_streams[ 4 ];

	/* The streams directory RVA
	 * Consists of 4 bytes
	 */
	uint8_t streams_directory_rva[ 4 ];

	/* The checksum
	 * Consists of 4 bytes
	 */
	uint8_t checksum[ 4 ];

	/* The timestamp
	 * Consists of 4 bytes
	 */
	uint8_t timestamp[ 4 ];

	/* The file flags
	 * Consists of 4 bytes
	 */
	uint8_t file_flags[ 4 ];
};

typedef struct mdmp_streams_directory_entry mdmp_streams_directory_entry_t;

struct mdmp_streams_directory_entry
{
	/* The stream type
	 * Consists of 4 bytes
	 */
	uint8_t stream_type[ 4 ];

	/* The stream data size
	 * Consists of 4 bytes
	 */
	uint8_t stream_data_size[ 4 ];

	/* The stream data RVA
	 * Consists of 4 bytes
	 */
	uint8_t stream_data_rva[ 4 ];
};

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _MDMP_FILE_HEADER_H ) */


```

`m4/common.m4`:

```m4
dnl Checks for common headers and functions
dnl
dnl Version: 20181117

dnl Function to test if a certain feature was disabled
AC_DEFUN([AX_COMMON_ARG_DISABLE],
[
  AC_ARG_ENABLE(
    [$1],
    [AS_HELP_STRING(
      [--disable-$1],
      [$3])],
    [ac_cv_enable_$2=$enableval],
    [ac_cv_enable_$2="yes"])dnl

    AC_CACHE_CHECK(
      [whether to disable $3],
      [ac_cv_enable_$2],
      [ac_cv_enable_$2="yes"])dnl
])

dnl Function to test if a certain feature was enabled
AC_DEFUN([AX_COMMON_ARG_ENABLE],
[
  AC_ARG_ENABLE(
    [$1],
    [AS_HELP_STRING(
      [--enable-$1],
      [$3 [default=$4]])],
    [ac_cv_enable_$2=$enableval],
    [ac_cv_enable_$2=$4])dnl

    AC_CACHE_CHECK(
      [whether to enable $3],
      [ac_cv_enable_$2],
      [ac_cv_enable_$2=$4])dnl
])

dnl Function to test if the location of a certain feature was provided
AC_DEFUN([AX_COMMON_ARG_WITH],
[
  AC_ARG_WITH(
    [$1],
    [AS_HELP_STRING(
      [--with-$1[[=$5]]],
      [$3 [default=$4]])],
    [ac_cv_with_$2=$withval],
    [ac_cv_with_$2=$4])dnl

    AC_CACHE_CHECK(
      [whether to use $3],
      [ac_cv_with_$2],
      [ac_cv_with_$2=$4])dnl
])

dnl Function to detect whether shared libary support should be disabled
AC_DEFUN([AX_COMMON_CHECK_DISABLE_SHARED_LIBS],
[
  AX_COMMON_ARG_DISABLE(
    [shared-libs],
    [shared_libs],
    [disable shared library support])
])

dnl Function to detect whether debug output should be enabled
AC_DEFUN([AX_COMMON_CHECK_ENABLE_DEBUG_OUTPUT],
[
  AX_COMMON_ARG_ENABLE(
    [debug-output],
    [debug_output],
    [enable debug output],
    [no])

  AS_IF(
    [test "x$ac_cv_enable_debug_output" != xno ],
    [AC_DEFINE(
      [HAVE_DEBUG_OUTPUT],
      [1],
      [Define to 1 if debug output should be used.])

    ac_cv_enable_debug_output=yes])
])

dnl Function to detect whether static executables support should be enabled
AC_DEFUN([AX_COMMON_CHECK_ENABLE_STATIC_EXECUTABLES],
[
  AX_COMMON_ARG_ENABLE(
    [static-executables],
    [static_executables],
    [build static executables (binaries)],
    [no])

  AS_IF(
    [test "x$ac_cv_enable_static_executables" != xno],
    [STATIC_LDFLAGS="-all-static";

    AC_SUBST(
      [STATIC_LDFLAGS])

    ac_cv_enable_static_executables=yes
    enable_shared=no])
])

dnl Function to detect whether verbose output should be enabled
AC_DEFUN([AX_COMMON_CHECK_ENABLE_VERBOSE_OUTPUT],
[
  AX_COMMON_ARG_ENABLE(
    [verbose-output],
    [verbose_output],
    [enable verbose output],
    [no])

  AS_IF(
    [test "x$ac_cv_enable_verbose_output" != xno ],
    [AC_DEFINE(
      [HAVE_VERBOSE_OUTPUT],
      [1],
      [Define to 1 if verbose output should be used.])

    ac_cv_enable_verbose_output=yes])
])

dnl Function to detect whether static executables support should be enabled
AC_DEFUN([AX_COMMON_CHECK_ENABLE_WIDE_CHARACTER_TYPE],
[
  AX_COMMON_ARG_ENABLE(
    [wide-character-type],
    [wide_character_type],
    [enable wide character type support],
    [no])
])

dnl Function to detect whether WINAPI support should be enabled
AC_DEFUN([AX_COMMON_CHECK_ENABLE_WINAPI],
[
  AX_COMMON_ARG_ENABLE(
    [winapi],
    [winapi],
    [enable WINAPI support for cross-compilation],
    [auto-detect])

  AS_IF(
    [test "x$ac_cv_enable_winapi" = xauto-detect],
    [ac_common_check_winapi_target_string="$target"

    AS_IF(
      [test "x$ac_common_check_winapi_target_string" = x],
      [ac_common_check_winapi_target_string="$host"])

    AS_CASE(
      [$ac_common_check_winapi_target_string],
      [*mingw*],[AC_MSG_NOTICE(
        [detected MinGW enabling WINAPI support for cross-compilation])
        ac_cv_enable_winapi=yes],
      [*msys*],[AC_MSG_NOTICE(
        [detected MSYS enabling WINAPI support for cross-compilation])
        ac_cv_enable_winapi=yes],
      [*],[ac_cv_enable_winapi=no])
  ])
])

dnl Function to detect whether printf conversion specifier "%jd" is available
AC_DEFUN([AX_COMMON_CHECK_FUNC_PRINTF_JD],
[
  AC_MSG_CHECKING(
    [whether printf supports the conversion specifier "%jd"])

  SAVE_CFLAGS="$CFLAGS"
  CFLAGS="$CFLAGS -Wall -Werror"
  AC_LANG_PUSH(C)

  dnl First try to see if compilation and linkage without a parameter succeeds
  AC_LINK_IFELSE(
    [AC_LANG_PROGRAM(
      [[#include <stdio.h>]],
      [[printf( "%jd" ); ]] )],
    [ac_cv_cv_have_printf_jd=no],
    [ac_cv_cv_have_printf_jd=yes])

  dnl Second try to see if compilation and linkage with a parameter succeeds
  AS_IF(
    [test "x$ac_cv_cv_have_printf_jd" = xyes],
    [AC_LINK_IFELSE(
      [AC_LANG_PROGRAM(
        [[#include <sys/types.h>
#include <stdio.h>]],
        [[printf( "%jd", (off_t) 10 ); ]] )],
      [ac_cv_cv_have_printf_jd=yes],
      [ac_cv_cv_have_printf_jd=no])
  ])

  dnl Third try to see if the program runs correctly
  AS_IF(
    [test "x$ac_cv_cv_have_printf_jd" = xyes],
    [AC_RUN_IFELSE(
      [AC_LANG_PROGRAM(
        [[#include <sys/types.h>
#include <stdio.h>]],
        [[char string[ 3 ];
if( snprintf( string, 3, "%jd", (off_t) 10 ) < 0 ) return( 1 );
if( ( string[ 0 ] != '1' ) || ( string[ 1 ] != '0' ) ) return( 1 ); ]] )],
      [ac_cv_cv_have_printf_jd=yes],
      [ac_cv_cv_have_printf_jd=no],
      [ac_cv_cv_have_printf_jd=undetermined])
  ])

  AC_LANG_POP(C)
  CFLAGS="$SAVE_CFLAGS"

  AS_IF(
    [test "x$ac_cv_cv_have_printf_jd" = xyes],
    [AC_MSG_RESULT(
      [yes])
    AC_DEFINE(
      [HAVE_PRINTF_JD],
      [1],
      [Define to 1 whether printf supports the conversion specifier "%jd".]) ],
    [AC_MSG_RESULT(
      [$ac_cv_cv_have_printf_jd])
  ])
])

dnl Function to detect whether printf conversion specifier "%zd" is available
AC_DEFUN([AX_COMMON_CHECK_FUNC_PRINTF_ZD],
[
  AC_MSG_CHECKING(
    [whether printf supports the conversion specifier "%zd"])

  SAVE_CFLAGS="$CFLAGS"
  CFLAGS="$CFLAGS -Wall -Werror"
  AC_LANG_PUSH(C)

  dnl First try to see if compilation and linkage without a parameter succeeds
  AC_LINK_IFELSE(
    [AC_LANG_PROGRAM(
      [[#include <stdio.h>]],
      [[printf( "%zd" ); ]] )],
    [ac_cv_cv_have_printf_zd=no],
    [ac_cv_cv_have_printf_zd=yes])

  dnl Second try to see if compilation and linkage with a parameter succeeds
  AS_IF(
    [test "x$ac_cv_cv_have_printf_zd" = xyes],
    [AC_LINK_IFELSE(
      [AC_LANG_PROGRAM(
        [[#include <sys/types.h>
#include <stdio.h>]],
        [[printf( "%zd", (size_t) 10 ); ]] )],
      [ac_cv_cv_have_printf_zd=yes],
      [ac_cv_cv_have_printf_zd=no])
  ])

  dnl Third try to see if the program runs correctly
  AS_IF(
    [test "x$ac_cv_cv_have_printf_zd" = xyes],
    [AC_RUN_IFELSE(
      [AC_LANG_PROGRAM(
        [[#include <sys/types.h>
#include <stdio.h>]],
        [[char string[ 3 ];
if( snprintf( string, 3, "%zd", (size_t) 10 ) < 0 ) return( 1 );
if( ( string[ 0 ] != '1' ) || ( string[ 1 ] != '0' ) ) return( 1 ); ]] )],
      [ac_cv_cv_have_printf_zd=yes],
      [ac_cv_cv_have_printf_zd=no],
      [ac_cv_cv_have_printf_zd=undetermined])
  ])

  AC_LANG_POP(C)
  CFLAGS="$SAVE_CFLAGS"

  AS_IF(
    [test "x$ac_cv_cv_have_printf_zd" = xyes],
    [AC_MSG_RESULT(
      [yes])
    AC_DEFINE(
      [HAVE_PRINTF_ZD],
      [1],
      [Define to 1 whether printf supports the conversion specifier "%zd".]) ],
    [AC_MSG_RESULT(
      [$ac_cv_cv_have_printf_zd])
  ])
])

dnl Function to detect if common dependencies are available
AC_DEFUN([AX_COMMON_CHECK_LOCAL],
[
  dnl Headers included in common/common.h
  AS_IF(
    [test "x$ac_cv_enable_winapi" = xyes],
    [AC_CHECK_HEADERS([windows.h])

    AS_IF(
      [test "x$ac_cv_header_windows_h" = xno],
      [AC_MSG_FAILURE(
        [Missing header: windows.h header is required to compile with winapi support],
        [1])
    ])
  ])

  AS_IF(
    [test "x$ac_cv_enable_winapi" = xno],
    [AC_CHECK_HEADERS([libintl.h])
  ])

  dnl Headers included in common/types.h
  AC_CHECK_HEADERS([limits.h])

  dnl Headers included in common/memory.h and common/narrow_string.h
  AC_CHECK_HEADERS([stdlib.h string.h])

  dnl Headers included in common/wide_string.h
  AC_CHECK_HEADERS([wchar.h wctype.h])

  dnl File stream functions used in common/file_stream.h
  AC_CHECK_FUNCS([fclose feof fgets fopen fread fseeko fseeko64 fwrite vfprintf])

  AS_IF(
    [test "x$ac_cv_func_fclose" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: fclose],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_feof" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: feof],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_fgets" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: fgets],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_fopen" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: fopen],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_fread" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: fread],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_fseeko" != xyes && test "x$ac_cv_func_fseeko64" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: fseeko and fseeko64],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_fwrite" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: fwrite],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_vfprintf" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: vfprintf],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_enable_wide_character_type" != xno],
    [AC_CHECK_FUNCS([fgetws])

    AS_IF(
      [test "x$ac_cv_func_fgetws" != xyes],
      [AC_MSG_FAILURE(
        [Missing function: fgetws],
        [1])
    ])
  ])

  dnl Memory functions used in common/memory.h
  AC_CHECK_FUNCS([free malloc memcmp memcpy memset realloc])

  AS_IF(
    [test "x$ac_cv_func_free" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: free],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_malloc" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: malloc],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_memcmp" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: memcmp],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_memcpy" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: memcpy],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_memset" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: memset],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_realloc" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: realloc],
      [1])
  ])

  dnl Narrow character string functions used in common/narrow_string.h
  AC_CHECK_FUNCS([memchr memrchr snprintf sscanf strcasecmp strchr strlen strncasecmp strncmp strncpy strnicmp strrchr strstr vsnprintf])

  AS_IF(
    [test "x$ac_cv_func_memchr" != xyes && test "x$ac_cv_func_strchr" != xyes],
    [AC_MSG_FAILURE(
      [Missing functions: memchr and strchr],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_memcmp" != xyes && test "x$ac_cv_func_strncmp" != xyes],
    [AC_MSG_FAILURE(
      [Missing functions: memcmp and strncmp],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_memcpy" != xyes && test "x$ac_cv_func_strncpy" != xyes],
    [AC_MSG_FAILURE(
      [Missing functions: memcpy and strncpy],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_memrchr" = xyes],
    [AC_CHECK_DECLS([memrchr])

    AS_IF(
      [test "x$ac_cv_decl_memrchr" != xyes],
      [ac_cv_func_memrchr=no])
  ])

  AS_IF(
    [test "x$ac_cv_func_memrchr" != xyes && test "x$ac_cv_func_strrchr" != xyes],
    [AC_MSG_FAILURE(
      [Missing functions: strrchr and memrchr],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_snprintf" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: snprintf],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_sscanf" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: sscanf],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_strlen" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: strlen],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_strcasecmp" != xyes && test "x$ac_cv_func_strncasecmp" != xyes && test "x$ac_cv_func_strnicmp" != xyes],
    [AC_MSG_FAILURE(
      [Missing functions: strncasecmp, strcasecmp and strnicmp],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_strstr" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: strstr],
      [1])
  ])

  AS_IF(
    [test "x$ac_cv_func_vsnprintf" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: vsnprintf],
      [1])
  ])

  dnl Wide character string functions used in common/wide_string.h
  AS_IF(
    [test "x$ac_cv_enable_wide_character_type" != xno],
    [AC_CHECK_FUNCS([swprintf towlower wcscasecmp wcschr wcslen wcsncasecmp wcsncmp wcsncpy wcsnicmp wcsrchr wcsstr wmemchr wmemcmp wmemcpy wmemrchr])

    AS_IF(
      [test "x$ac_cv_func_swprintf" != xyes],
      [AC_MSG_FAILURE(
        [Missing function: swprintf],
        [1])
    ])

    AS_IF(
      [test "x$ac_cv_func_wmemchr" != xyes && test "x$ac_cv_func_wcschr" != xyes],
      [AC_MSG_FAILURE(
        [Missing functions: wmemchr and wcschr],
        [1])
    ])

    AS_IF(
      [test "x$ac_cv_func_wmemcmp" != xyes && test "x$ac_cv_func_wcsncmp" != xyes],
      [AC_MSG_FAILURE(
        [Missing functions: wmemcmp and wcsncmp],
        [1])
    ])

    AS_IF(
      [test "x$ac_cv_func_wmemcpy" != xyes && test "x$ac_cv_func_wcsncpy" != xyes],
      [AC_MSG_FAILURE(
        [Missing functions: wmemcpy and wcsncpy],
        [1])
    ])

    AS_IF(
      [test "x$ac_cv_func_wmemrchr" != xyes && test "x$ac_cv_func_wcsrchr" != xyes],
      [AC_MSG_FAILURE(
        [Missing functions: wmemrchr and wcsrchr],
        [1])
    ])

    AS_IF(
      [test "x$ac_cv_func_wcslen" != xyes],
      [AC_MSG_FAILURE(
        [Missing function: wcslen],
        [1])
    ])

    AS_IF(
      [test "x$ac_cv_func_wcsncasecmp" != xyes && test "x$ac_cv_func_wcscasecmp" != xyes && test "x$ac_cv_func_wcsnicmp" != xyes && test "x$ac_cv_func_towlower" != xyes],
      [AC_MSG_FAILURE(
        [Missing functions: wcsncasecmp, wcscasecmp, wcsnicmp and towlower],
        [1])
    ])

    AS_IF(
      [test "x$ac_cv_func_wcsstr" != xyes],
      [AC_MSG_FAILURE(
        [Missing function: wcsstr],
        [1])
    ])
  ])

  dnl Check for printf conversion specifier support
  AX_COMMON_CHECK_FUNC_PRINTF_JD
  AX_COMMON_CHECK_FUNC_PRINTF_ZD
])


```

`m4/libbfio.m4`:

```m4
dnl Checks for libbfio required headers and functions
dnl
dnl Version: 20201125

dnl Function to detect if libbfio is available
dnl ac_libbfio_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBBFIO_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libbfio" = xno],
    [ac_cv_libbfio=no],
    [ac_cv_libbfio=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libbfio" != x && test "x$ac_cv_with_libbfio" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libbfio"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libbfio}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libbfio}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libbfio],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libbfio],
          [libbfio >= 20201125],
          [ac_cv_libbfio=yes],
          [ac_cv_libbfio=check])
        ])
      AS_IF(
        [test "x$ac_cv_libbfio" = xyes && test "x$ac_cv_enable_wide_character_type" != xno],
        [AC_CACHE_CHECK(
         [whether libbfio/features.h defines LIBBFIO_HAVE_WIDE_CHARACTER_TYPE as 1],
         [ac_cv_header_libbfio_features_h_have_wide_character_type],
         [AC_LANG_PUSH(C)
         AC_COMPILE_IFELSE(
           [AC_LANG_PROGRAM(
             [[#include <libbfio/features.h>]],
             [[#if !defined( LIBBFIO_HAVE_WIDE_CHARACTER_TYPE ) || ( LIBBFIO_HAVE_WIDE_CHARACTER_TYPE != 1 )
#error LIBBFIO_HAVE_WIDE_CHARACTER_TYPE not defined
#endif]] )],
           [ac_cv_header_libbfio_features_h_have_wide_character_type=yes],
           [ac_cv_header_libbfio_features_h_have_wide_character_type=no])
         AC_LANG_POP(C)],
         [ac_cv_header_libbfio_features_h_have_wide_character_type=no])

        AS_IF(
          [test "x$ac_cv_header_libbfio_features_h_have_wide_character_type" = xno],
          [ac_cv_libbfio=no])
        ])
      AS_IF(
        [test "x$ac_cv_libbfio" = xyes],
        [ac_cv_libbfio_CPPFLAGS="$pkg_cv_libbfio_CFLAGS"
        ac_cv_libbfio_LIBADD="$pkg_cv_libbfio_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libbfio" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libbfio.h])

      AS_IF(
        [test "x$ac_cv_header_libbfio_h" = xno],
        [ac_cv_libbfio=no],
        [dnl Check for the individual functions
        ac_cv_libbfio=yes

        AC_CHECK_LIB(
          bfio,
          libbfio_get_version,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])

        dnl Handle functions
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_free,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_open,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_close,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_exists,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_read_buffer,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_read_buffer_at_offset,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_write_buffer,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_write_buffer_at_offset,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_seek_offset,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])

        AC_CHECK_LIB(
          bfio,
          libbfio_handle_is_open,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_get_offset,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_get_size,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_set_track_offsets_read,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_get_number_of_offsets_read,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_handle_get_offset_read,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])

        dnl File functions
        AC_CHECK_LIB(
          bfio,
          libbfio_file_initialize,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_file_get_name_size,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_file_get_name,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_file_set_name,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])

        AS_IF(
          [test "x$ac_cv_enable_wide_character_type" != xno],
          [AC_CHECK_LIB(
            bfio,
            libbfio_file_get_name_size_wide,
            [ac_cv_libbfio_dummy=yes],
            [ac_cv_libbfio=no])
          AC_CHECK_LIB(
            bfio,
            libbfio_file_get_name_wide,
            [ac_cv_libbfio_dummy=yes],
            [ac_cv_libbfio=no])
          AC_CHECK_LIB(
            bfio,
            libbfio_file_set_name_wide,
            [ac_cv_libbfio_dummy=yes],
            [ac_cv_libbfio=no])
          ])

        dnl Pool functions
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_initialize,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_free,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_clone,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])

        AC_CHECK_LIB(
          bfio,
          libbfio_pool_get_number_of_handles,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_get_handle,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_set_handle,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_append_handle,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_remove_handle,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_get_maximum_number_of_open_handles,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_set_maximum_number_of_open_handles,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])

        AC_CHECK_LIB(
          bfio,
          libbfio_pool_open,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_reopen,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_close,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_close_all,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_read_buffer,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_read_buffer_at_offset,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_write_buffer,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_write_buffer_at_offset,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_seek_offset,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_get_offset,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])
        AC_CHECK_LIB(
          bfio,
          libbfio_pool_get_size,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])

        dnl File pool functions
        AC_CHECK_LIB(
          bfio,
          libbfio_file_pool_open,
          [ac_cv_libbfio_dummy=yes],
          [ac_cv_libbfio=no])

        AS_IF(
          [test "x$ac_cv_enable_wide_character_type" != xno],
          [AC_CHECK_LIB(
            bfio,
            libbfio_file_pool_open_wide,
            [ac_cv_libbfio_dummy=yes],
            [ac_cv_libbfio=no])
          ])

        ac_cv_libbfio_LIBADD="-lbfio"])
      ])
    AS_IF(
      [test "x$ac_cv_with_libbfio" != x && test "x$ac_cv_with_libbfio" != xauto-detect && test "x$ac_cv_libbfio" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libbfio in directory: $ac_cv_with_libbfio],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libbfio" = xyes],
    [AC_DEFINE(
      [HAVE_LIBBFIO],
      [1],
      [Define to 1 if you have the `bfio' library (-lbfio).])
    ])

  AS_IF(
    [test "x$ac_cv_libbfio" = xyes],
    [AC_SUBST(
      [HAVE_LIBBFIO],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBBFIO],
      [0])
    ])
  ])

dnl Function to detect if libbfio dependencies are available
AC_DEFUN([AX_LIBBFIO_CHECK_LOCAL],
  [dnl No additional checks.

  ac_cv_libbfio_CPPFLAGS="-I../libbfio";
  ac_cv_libbfio_LIBADD="../libbfio/libbfio.la";

  ac_cv_libbfio=local
  ])

dnl Function to detect how to enable libbfio
AC_DEFUN([AX_LIBBFIO_CHECK_ENABLE],
  [AX_COMMON_ARG_WITH(
    [libbfio],
    [libbfio],
    [search for libbfio in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  dnl Check for a shared library version
  AX_LIBBFIO_CHECK_LIB

  dnl Check if the dependencies for the local library version
  AS_IF(
    [test "x$ac_cv_libbfio" != xyes],
    [AX_LIBBFIO_CHECK_LOCAL

    AC_DEFINE(
      [HAVE_LOCAL_LIBBFIO],
      [1],
      [Define to 1 if the local version of libbfio is used.])
    AC_SUBST(
      [HAVE_LOCAL_LIBBFIO],
      [1])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBBFIO],
    [test "x$ac_cv_libbfio" = xlocal])
  AS_IF(
    [test "x$ac_cv_libbfio_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBBFIO_CPPFLAGS],
      [$ac_cv_libbfio_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libbfio_LIBADD" != "x"],
    [AC_SUBST(
      [LIBBFIO_LIBADD],
      [$ac_cv_libbfio_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libbfio" = xyes],
    [AC_SUBST(
      [ax_libbfio_pc_libs_private],
      [-lbfio])
    ])

  AS_IF(
    [test "x$ac_cv_libbfio" = xyes],
    [AC_SUBST(
      [ax_libbfio_spec_requires],
      [libbfio])
    AC_SUBST(
      [ax_libbfio_spec_build_requires],
      [libbfio-devel])
    ])
  ])


```

`m4/libcdata.m4`:

```m4
dnl Checks for libcdata required headers and functions
dnl
dnl Version: 20230108

dnl Function to detect if libcdata is available
dnl ac_libcdata_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBCDATA_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libcdata" = xno],
    [ac_cv_libcdata=no],
    [ac_cv_libcdata=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libcdata" != x && test "x$ac_cv_with_libcdata" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libcdata"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libcdata}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libcdata}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libcdata],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libcdata],
          [libcdata >= 20230108],
          [ac_cv_libcdata=yes],
          [ac_cv_libcdata=check])
        ])
      AS_IF(
        [test "x$ac_cv_libcdata" = xyes],
        [ac_cv_libcdata_CPPFLAGS="$pkg_cv_libcdata_CFLAGS"
        ac_cv_libcdata_LIBADD="$pkg_cv_libcdata_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libcdata" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libcdata.h])

      AS_IF(
        [test "x$ac_cv_header_libcdata_h" = xno],
        [ac_cv_libcdata=no],
        [dnl Check for the individual functions
        ac_cv_libcdata=yes

        AC_CHECK_LIB(
          cdata,
          libcdata_get_version,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])

        dnl Array functions
        AC_CHECK_LIB(
          cdata,
          libcdata_array_initialize,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_free,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_empty,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_clone,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_resize,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_reverse,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_get_number_of_entries,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_get_entry_by_index,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_get_entry_by_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_set_entry_by_index,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_prepend_entry,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_append_entry,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_insert_entry,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_array_remove_entry,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])

        dnl Balanced tree functions
        AC_CHECK_LIB(
          cdata,
          libcdata_btree_initialize,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_btree_free,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_btree_get_number_of_values,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_btree_get_value_by_index,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_btree_get_value_by_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_btree_insert_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_btree_replace_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_btree_remove_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])

        dnl List functions
        AC_CHECK_LIB(
          cdata,
          libcdata_list_initialize,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_free,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_empty,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_clone,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_get_number_of_elements,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_get_first_element,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_get_last_element,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_get_element_by_index,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_get_value_by_index,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_prepend_element,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_prepend_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_append_element,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_append_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_insert_element,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_insert_element_with_existing,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_insert_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_insert_value_with_existing,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_remove_element,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])

        dnl List element functions
        AC_CHECK_LIB(
          cdata,
          libcdata_list_element_initialize,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_element_free,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_element_get_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_element_set_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_element_get_previous_element,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_element_set_previous_element,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_element_get_next_element,
          [ac_cv_libcdata_dummy=yes],
        AC_CHECK_LIB(
          cdata,
          libcdata_list_element_set_next_element,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_element_get_elements,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_list_element_set_elements,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
          [ac_cv_libcdata=no])

        dnl Range list functions
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_initialize,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_free,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_empty,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_clone,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_get_number_of_elements,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_insert_range,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_insert_range_list,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_remove_range,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_get_range_by_index,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_get_range_at_offset,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_range_is_present,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_range_has_overlapping_range,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_range_list_get_spanning_range,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])

        dnl Tree node functions
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_initialize,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_free,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_empty,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_clone,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_get_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_set_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_get_parent_node,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_set_parent_node,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_get_previous_node,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_set_previous_node,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_get_next_node,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_set_next_node,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_get_nodes,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_set_nodes,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_append_node,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_append_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_insert_node,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_insert_value,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_replace_node,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_remove_node,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_get_number_of_sub_nodes,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_get_sub_node_by_index,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])
        AC_CHECK_LIB(
          cdata,
          libcdata_tree_node_get_leaf_node_list,
          [ac_cv_libcdata_dummy=yes],
          [ac_cv_libcdata=no])

        ac_cv_libcdata_LIBADD="-lcdata"])
      ])
    AS_IF(
      [test "x$ac_cv_with_libcdata" != x && test "x$ac_cv_with_libcdata" != xauto-detect && test "x$ac_cv_libcdata" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libcdata in directory: $ac_cv_with_libcdata],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libcdata" = xyes],
    [AC_DEFINE(
      [HAVE_LIBCDATA],
      [1],
      [Define to 1 if you have the `cdata' library (-lcdata).])
    ])

  AS_IF(
    [test "x$ac_cv_libcdata" = xyes],
    [AC_SUBST(
      [HAVE_LIBCDATA],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBCDATA],
      [0])
    ])
  ])

dnl Function to detect if libcdata dependencies are available
AC_DEFUN([AX_LIBCDATA_CHECK_LOCAL],
  [dnl No additional checks.

  ac_cv_libcdata_CPPFLAGS="-I../libcdata";
  ac_cv_libcdata_LIBADD="../libcdata/libcdata.la";

  ac_cv_libcdata=local
  ])

dnl Function to detect how to enable libcdata
AC_DEFUN([AX_LIBCDATA_CHECK_ENABLE],
  [AX_COMMON_ARG_WITH(
    [libcdata],
    [libcdata],
    [search for libcdata in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  dnl Check for a shared library version
  AX_LIBCDATA_CHECK_LIB

  dnl Check if the dependencies for the local library version
  AS_IF(
    [test "x$ac_cv_libcdata" != xyes],
    [AX_LIBCDATA_CHECK_LOCAL

    AC_DEFINE(
      [HAVE_LOCAL_LIBCDATA],
      [1],
      [Define to 1 if the local version of libcdata is used.])
    AC_SUBST(
      [HAVE_LOCAL_LIBCDATA],
      [1])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBCDATA],
    [test "x$ac_cv_libcdata" = xlocal])
  AS_IF(
    [test "x$ac_cv_libcdata_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBCDATA_CPPFLAGS],
      [$ac_cv_libcdata_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libcdata_LIBADD" != "x"],
    [AC_SUBST(
      [LIBCDATA_LIBADD],
      [$ac_cv_libcdata_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libcdata" = xyes],
    [AC_SUBST(
      [ax_libcdata_pc_libs_private],
      [-lcdata])
    ])

  AS_IF(
    [test "x$ac_cv_libcdata" = xyes],
    [AC_SUBST(
      [ax_libcdata_spec_requires],
      [libcdata])
    AC_SUBST(
      [ax_libcdata_spec_build_requires],
      [libcdata-devel])
    ])
  ])


```

`m4/libcerror.m4`:

```m4
dnl Checks for libcerror required headers and functions
dnl
dnl Version: 20190308

dnl Function to detect if libcerror is available
dnl ac_libcerror_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBCERROR_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libcerror" = xno],
    [ac_cv_libcerror=no],
    [ac_cv_libcerror=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libcerror" != x && test "x$ac_cv_with_libcerror" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libcerror"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libcerror}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libcerror}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libcerror],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libcerror],
          [libcerror >= 20120425],
          [ac_cv_libcerror=yes],
          [ac_cv_libcerror=check])
        ])
      AS_IF(
        [test "x$ac_cv_libcerror" = xyes],
        [ac_cv_libcerror_CPPFLAGS="$pkg_cv_libcerror_CFLAGS"
        ac_cv_libcerror_LIBADD="$pkg_cv_libcerror_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libcerror" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libcerror.h])

      AS_IF(
        [test "x$ac_cv_header_libcerror_h" = xno],
        [ac_cv_libcerror=no],
        [dnl Check for the individual functions
        ac_cv_libcerror=yes

        AC_CHECK_LIB(
          cerror,
          libcerror_get_version,
          [ac_cv_libcerror_dummy=yes],
          [ac_cv_libcerror=no])

        dnl Error functions
        AC_CHECK_LIB(
          cerror,
          libcerror_error_free,
          [ac_cv_libcerror_dummy=yes],
          [ac_cv_libcerror=no])
        AC_CHECK_LIB(
          cerror,
          libcerror_error_set,
          [ac_cv_libcerror_dummy=yes],
          [ac_cv_libcerror=no])
        AC_CHECK_LIB(
          cerror,
          libcerror_error_matches,
          [ac_cv_libcerror_dummy=yes],
          [ac_cv_libcerror=no])
        AC_CHECK_LIB(
          cerror,
          libcerror_error_fprint,
          [ac_cv_libcerror_dummy=yes],
          [ac_cv_libcerror=no])
        AC_CHECK_LIB(
          cerror,
          libcerror_error_sprint,
          [ac_cv_libcerror_dummy=yes],
          [ac_cv_libcerror=no])
        AC_CHECK_LIB(
          cerror,
          libcerror_error_backtrace_fprint,
          [ac_cv_libcerror_dummy=yes],
          [ac_cv_libcerror=no])
        AC_CHECK_LIB(
          cerror,
          libcerror_error_backtrace_sprint,
          [ac_cv_libcerror_dummy=yes],
          [ac_cv_libcerror=no])

        dnl System error functions
        AC_CHECK_LIB(
          cerror,
          libcerror_system_set_error,
          [ac_cv_libcerror_dummy=yes],
          [ac_cv_libcerror=no])

        ac_cv_libcerror_LIBADD="-lcerror"])
      ])
    AS_IF(
      [test "x$ac_cv_with_libcerror" != x && test "x$ac_cv_with_libcerror" != xauto-detect && test "x$ac_cv_libcerror" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libcerror in directory: $ac_cv_with_libcerror],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libcerror" = xyes],
    [AC_DEFINE(
      [HAVE_LIBCERROR],
      [1],
      [Define to 1 if you have the `cerror' library (-lcerror).])
    ])

  AS_IF(
    [test "x$ac_cv_libcerror" = xyes],
    [AC_SUBST(
      [HAVE_LIBCERROR],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBCERROR],
      [0])
    ])
  ])

dnl Function to detect if libcerror dependencies are available
AC_DEFUN([AX_LIBCERROR_CHECK_LOCAL],
  [dnl Headers included in libcerror/libcerror_error.c
  AC_CHECK_HEADERS([stdarg.h varargs.h])

  AS_IF(
    [test "x$ac_cv_header_stdarg_h" != xyes && test "x$ac_cv_header_varargs_h" != xyes],
    [AC_MSG_FAILURE(
      [Missing headers: stdarg.h and varargs.h],
      [1])
    ])

  dnl Wide character string functions used in libcerror/libcerror_error.c
  AS_IF(
    [test "x$ac_cv_enable_wide_character_type" != xno],
    [AC_CHECK_FUNCS([wcstombs])

    AS_IF(
      [test "x$ac_cv_func_wcstombs" != xyes],
      [AC_MSG_FAILURE(
        [Missing function: wcstombs],
        [1])
      ])
    ])

  dnl Check for error string functions used in libcerror/libcerror_system.c
  AC_FUNC_STRERROR_R()

  AS_IF(
    [test "x$ac_cv_have_decl_strerror_r" != xyes],
    [AC_CHECK_FUNCS([strerror])

    AS_IF(
      [test "x$ac_cv_func_strerror" != xyes],
      [AC_MSG_FAILURE(
        [Missing functions: strerror_r and strerror],
        [1])
      ])
    ])

  ac_cv_libcerror_CPPFLAGS="-I../libcerror";
  ac_cv_libcerror_LIBADD="../libcerror/libcerror.la";

  ac_cv_libcerror=local
  ])

dnl Function to detect how to enable libcerror
AC_DEFUN([AX_LIBCERROR_CHECK_ENABLE],
  [AX_COMMON_ARG_WITH(
    [libcerror],
    [libcerror],
    [search for libcerror in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  dnl Check for a shared library version
  AX_LIBCERROR_CHECK_LIB

  dnl Check if the dependencies for the local library version
  AS_IF(
    [test "x$ac_cv_libcerror" != xyes],
    [AX_LIBCERROR_CHECK_LOCAL

    AC_DEFINE(
      [HAVE_LOCAL_LIBCERROR],
      [1],
      [Define to 1 if the local version of libcerror is used.])
    AC_SUBST(
      [HAVE_LOCAL_LIBCERROR],
      [1])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBCERROR],
    [test "x$ac_cv_libcerror" = xlocal])
  AS_IF(
    [test "x$ac_cv_libcerror_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBCERROR_CPPFLAGS],
      [$ac_cv_libcerror_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libcerror_LIBADD" != "x"],
    [AC_SUBST(
      [LIBCERROR_LIBADD],
      [$ac_cv_libcerror_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libcerror" = xyes],
    [AC_SUBST(
      [ax_libcerror_pc_libs_private],
      [-lcerror])
    ])

  AS_IF(
    [test "x$ac_cv_libcerror" = xyes],
    [AC_SUBST(
      [ax_libcerror_spec_requires],
      [libcerror])
    AC_SUBST(
      [ax_libcerror_spec_build_requires],
      [libcerror-devel])
    ])
  ])


```

`m4/libcfile.m4`:

```m4
dnl Checks for libcfile required headers and functions
dnl
dnl Version: 20190308

dnl Function to detect if libcfile is available
dnl ac_libcfile_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBCFILE_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libcfile" = xno],
    [ac_cv_libcfile=no],
    [ac_cv_libcfile=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libcfile" != x && test "x$ac_cv_with_libcfile" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libcfile"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libcfile}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libcfile}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libcfile],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libcfile],
          [libcfile >= 20160409],
          [ac_cv_libcfile=yes],
          [ac_cv_libcfile=check])
        ])
      AS_IF(
        [test "x$ac_cv_libcfile" = xyes && test "x$ac_cv_enable_wide_character_type" != xno],
        [AC_CACHE_CHECK(
         [whether libcfile/features.h defines LIBCFILE_HAVE_WIDE_CHARACTER_TYPE as 1],
         [ac_cv_header_libcfile_features_h_have_wide_character_type],
         [AC_LANG_PUSH(C)
         AC_COMPILE_IFELSE(
           [AC_LANG_PROGRAM(
             [[#include <libcfile/features.h>]],
             [[#if !defined( LIBCFILE_HAVE_WIDE_CHARACTER_TYPE ) || ( LIBCFILE_HAVE_WIDE_CHARACTER_TYPE != 1 )
#error LIBCFILE_HAVE_WIDE_CHARACTER_TYPE not defined
#endif]] )],
           [ac_cv_header_libcfile_features_h_have_wide_character_type=yes],
           [ac_cv_header_libcfile_features_h_have_wide_character_type=no])
         AC_LANG_POP(C)],
         [ac_cv_header_libcfile_features_h_have_wide_character_type=no])

        AS_IF(
          [test "x$ac_cv_header_libcfile_features_h_have_wide_character_type" = xno],
          [ac_cv_libcfile=no])
        ])
      AS_IF(
        [test "x$ac_cv_libcfile" = xyes],
        [ac_cv_libcfile_CPPFLAGS="$pkg_cv_libcfile_CFLAGS"
        ac_cv_libcfile_LIBADD="$pkg_cv_libcfile_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libcfile" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libcfile.h])

      AS_IF(
        [test "x$ac_cv_header_libcfile_h" = xno],
        [ac_cv_libcfile=no],
        [dnl Check for the individual functions
        ac_cv_libcfile=yes

        AC_CHECK_LIB(
          cfile,
          libcfile_get_version,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])

        dnl File functions
        AC_CHECK_LIB(
          cfile,
          libcfile_file_initialize,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_free,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_open,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_open_with_error_code,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_close,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_read_buffer,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_read_buffer_with_error_code,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_write_buffer,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_write_buffer_with_error_code,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_seek_offset,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_resize,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_is_open,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_get_offset,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_get_size,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_is_device,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_io_control_read,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_io_control_read_with_error_code,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])

        AS_IF(
          [test "x$ac_cv_enable_wide_character_type" != xno],
          [AC_CHECK_LIB(
            cfile,
            libcfile_file_open_wide,
            [ac_cv_libcfile_dummy=yes],
            [ac_cv_libcfile=no])
          AC_CHECK_LIB(
            cfile,
            libcfile_file_open_wide_with_error_code,
            [ac_cv_libcfile_dummy=yes],
            [ac_cv_libcfile=no])
          ])

        dnl Support functions
        AC_CHECK_LIB(
          cfile,
          libcfile_file_exists,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])
        AC_CHECK_LIB(
          cfile,
          libcfile_file_remove,
          [ac_cv_libcfile_dummy=yes],
          [ac_cv_libcfile=no])

        AS_IF(
          [test "x$ac_cv_enable_wide_character_type" != xno],
          [AC_CHECK_LIB(
            cfile,
            libcfile_file_exists_wide,
            [ac_cv_libcfile_dummy=yes],
            [ac_cv_libcfile=no])
          AC_CHECK_LIB(
            cfile,
            libcfile_file_remove_wide,
            [ac_cv_libcfile_dummy=yes],
            [ac_cv_libcfile=no])
          ])

        ac_cv_libcfile_LIBADD="-lcfile"])
      ])
    AS_IF(
      [test "x$ac_cv_with_libcfile" != x && test "x$ac_cv_with_libcfile" != xauto-detect && test "x$ac_cv_libcfile" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libcfile in directory: $ac_cv_with_libcfile],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libcfile" = xyes],
    [AC_DEFINE(
      [HAVE_LIBCFILE],
      [1],
      [Define to 1 if you have the `cfile' library (-lcfile).])
    ])

  AS_IF(
    [test "x$ac_cv_libcfile" = xyes],
    [AC_SUBST(
      [HAVE_LIBCFILE],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBCFILE],
      [0])
    ])
  ])

dnl Function to detect if posix_fadvise is available
AC_DEFUN([AX_LIBCFILE_CHECK_FUNC_POSIX_FADVISE],
  [AC_CHECK_FUNCS([posix_fadvise])

  AS_IF(
    [test "x$ac_cv_func_posix_fadvise" = xyes],
    [AC_MSG_CHECKING(
        [whether posix_fadvise can be linked])

      SAVE_CFLAGS="$CFLAGS"
      CFLAGS="$CFLAGS -Wall -Werror"
      AC_LANG_PUSH(C)

      AC_LINK_IFELSE(
        [AC_LANG_PROGRAM(
          [[#include <fcntl.h>]],
          [[#if !defined( POSIX_FADV_SEQUENTIAL )
#define POSIX_FADV_SEQUENTIAL 2
#endif
posix_fadvise( 0, 0, 0, POSIX_FADV_SEQUENTIAL )]] )],
          [ac_cv_func_posix_fadvise=yes],
          [ac_cv_func_posix_fadvise=no])

      AC_LANG_POP(C)
      CFLAGS="$SAVE_CFLAGS"

      AS_IF(
        [test "x$ac_cv_func_posix_fadvise" = xyes],
        [AC_MSG_RESULT(
          [yes])
        AC_DEFINE(
          [HAVE_POSIX_FADVISE],
          [1],
          [Define to 1 if you have the posix_fadvise function.]) ],
        [AC_MSG_RESULT(
          [no]) ])
    ])
  ])

dnl Function to detect if libcfile dependencies are available
AC_DEFUN([AX_LIBCFILE_CHECK_LOCAL],
  [dnl Headers included in libcfile/libcfile_file.c and libcfile/libcfile_support.c
  AC_CHECK_HEADERS([errno.h stdio.h sys/stat.h])

  dnl Headers included in libcfile/libcfile_file.c
  AC_CHECK_HEADERS([cygwin/fs.h fcntl.h linux/fs.h sys/disk.h sys/disklabel.h sys/ioctl.h unistd.h])

  dnl File input/output functions used in libcfile/libcfile_file.c
  AC_CHECK_FUNCS([close fstat ftruncate ioctl lseek open read write])

  AS_IF(
    [test "x$ac_cv_func_close" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: close],
      [1])
    ])

  AX_LIBCFILE_CHECK_FUNC_POSIX_FADVISE

  AS_IF(
    [test "x$ac_cv_func_fstat" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: fstat],
      [1])
    ])

  AS_IF(
    [test "x$ac_cv_func_ftruncate" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: ftruncate],
      [1])
    ])

  AS_IF(
    [test x"$ac_cv_enable_winapi" = xno],
    [AS_IF(
      [test "x$ac_cv_func_ioctl" != xyes],
      [AC_MSG_FAILURE(
        [Missing function: ioctl],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_func_lseek" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: lseek],
      [1])
    ])

  AS_IF(
    [test "x$ac_cv_func_open" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: open],
      [1])
    ])

  AS_IF(
    [test "x$ac_cv_func_read" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: read],
      [1])
    ])

  AS_IF(
    [test "x$ac_cv_func_write" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: write],
      [1])
    ])

  dnl File input/output functions used in libcfile/libcfile_support.c
  AC_CHECK_FUNCS([stat unlink])

  AS_IF(
    [test "x$ac_cv_func_stat" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: stat],
      [1])
    ])

  AS_IF(
    [test "x$ac_cv_func_unlink" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: unlink],
      [1])
    ])

  ac_cv_libcfile_CPPFLAGS="-I../libcfile";
  ac_cv_libcfile_LIBADD="../libcfile/libcfile.la";

  ac_cv_libcfile=local
  ])

dnl Function to detect how to enable libcfile
AC_DEFUN([AX_LIBCFILE_CHECK_ENABLE],
  [AX_COMMON_ARG_WITH(
    [libcfile],
    [libcfile],
    [search for libcfile in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  dnl Check for a shared library version
  AX_LIBCFILE_CHECK_LIB

  dnl Check if the dependencies for the local library version
  AS_IF(
    [test "x$ac_cv_libcfile" != xyes],
    [AX_LIBCFILE_CHECK_LOCAL

    AC_DEFINE(
      [HAVE_LOCAL_LIBCFILE],
      [1],
      [Define to 1 if the local version of libcfile is used.])
    AC_SUBST(
      [HAVE_LOCAL_LIBCFILE],
      [1])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBCFILE],
    [test "x$ac_cv_libcfile" = xlocal])
  AS_IF(
    [test "x$ac_cv_libcfile_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBCFILE_CPPFLAGS],
      [$ac_cv_libcfile_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libcfile_LIBADD" != "x"],
    [AC_SUBST(
      [LIBCFILE_LIBADD],
      [$ac_cv_libcfile_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libcfile" = xyes],
    [AC_SUBST(
      [ax_libcfile_pc_libs_private],
      [-lcfile])
    ])

  AS_IF(
    [test "x$ac_cv_libcfile" = xyes],
    [AC_SUBST(
      [ax_libcfile_spec_requires],
      [libcfile])
    AC_SUBST(
      [ax_libcfile_spec_build_requires],
      [libcfile-devel])
    ])
  ])


```

`m4/libclocale.m4`:

```m4
dnl Checks for libclocale required headers and functions
dnl
dnl Version: 20190308

dnl Function to detect if libclocale is available
dnl ac_libclocale_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBCLOCALE_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libclocale" = xno],
    [ac_cv_libclocale=no],
    [ac_cv_libclocale=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libclocale" != x && test "x$ac_cv_with_libclocale" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libclocale"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libclocale}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libclocale}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libclocale],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libclocale],
          [libclocale >= 20120425],
          [ac_cv_libclocale=yes],
          [ac_cv_libclocale=check])
        ])
      AS_IF(
        [test "x$ac_cv_libclocale" = xyes && test "x$ac_cv_enable_wide_character_type" != xno],
        [AC_CACHE_CHECK(
          [whether libclocale/features.h defines LIBCLOCALE_HAVE_WIDE_CHARACTER_TYPE as 1],
          [ac_cv_header_libclocale_features_h_have_wide_character_type],
          [AC_LANG_PUSH(C)
          AC_COMPILE_IFELSE(
            [AC_LANG_PROGRAM(
              [[#include <libclocale/features.h>]],
              [[#if !defined( LIBCLOCALE_HAVE_WIDE_CHARACTER_TYPE ) || ( LIBCLOCALE_HAVE_WIDE_CHARACTER_TYPE != 1 )
#error LIBCLOCALE_HAVE_WIDE_CHARACTER_TYPE not defined
#endif]] )],
            [ac_cv_header_libclocale_features_h_have_wide_character_type=yes],
            [ac_cv_header_libclocale_features_h_have_wide_character_type=no])
          AC_LANG_POP(C)],
          [ac_cv_header_libclocale_features_h_have_wide_character_type=no])

        AS_IF(
          [test "x$ac_cv_header_libclocale_features_h_have_wide_character_type" = xno],
          [ac_cv_libclocale=no])
        ])
      AS_IF(
        [test "x$ac_cv_libclocale" = xyes],
        [ac_cv_libclocale_CPPFLAGS="$pkg_cv_libclocale_CFLAGS"
        ac_cv_libclocale_LIBADD="$pkg_cv_libclocale_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libclocale" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libclocale.h])

      AS_IF(
        [test "x$ac_cv_header_libclocale_h" = xno],
        [ac_cv_libclocale=no],
        [dnl Check for the individual functions
        ac_cv_libclocale=yes

        AC_CHECK_LIB(
          clocale,
          libclocale_get_version,
          [ac_cv_libclocale_dummy=yes],
          [ac_cv_libclocale=no])

        dnl Codepage functions
        AC_CHECK_LIB(
          clocale,
          libclocale_codepage,
          [ac_cv_libclocale_dummy=yes],
          [ac_cv_libclocale=no])
        AC_CHECK_LIB(
          clocale,
          libclocale_codepage_get,
          [ac_cv_libclocale_dummy=yes],
          [ac_cv_libclocale=no])
        AC_CHECK_LIB(
          clocale,
          libclocale_codepage_set,
          [ac_cv_libclocale_dummy=yes],
          [ac_cv_libclocale=no])
        AC_CHECK_LIB(
          clocale,
          libclocale_codepage_copy_from_string,
          [ac_cv_libclocale_dummy=yes],
          [ac_cv_libclocale=no])

        AS_IF(
          [test "x$ac_cv_enable_wide_character_type" != xno],
          [AC_CHECK_LIB(
            clocale,
            libclocale_codepage_copy_from_string_wide,
            [ac_cv_libclocale_dummy=yes],
            [ac_cv_libclocale=no])
          ])

        dnl Locale functions
        AC_CHECK_LIB(
          clocale,
          libclocale_locale_get_codepage,
          [ac_cv_libclocale_dummy=yes],
          [ac_cv_libclocale=no])
        AC_CHECK_LIB(
          clocale,
          libclocale_locale_get_decimal_point,
          [ac_cv_libclocale_dummy=yes],
          [ac_cv_libclocale=no])

        dnl Support functions
        AC_CHECK_LIB(
          clocale,
          libclocale_initialize,
          [ac_cv_libclocale_dummy=yes],
          [ac_cv_libclocale=no])

        ac_cv_libclocale_LIBADD="-lclocale"])
      ])
    AS_IF(
      [test "x$ac_cv_with_libclocale" != x && test "x$ac_cv_with_libclocale" != xauto-detect && test "x$ac_cv_libclocale" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libclocale in directory: $ac_cv_with_libclocale],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libclocale" = xyes],
    [AC_DEFINE(
      [HAVE_LIBCLOCALE],
      [1],
      [Define to 1 if you have the `clocale' library (-lclocale).])
    ])

  AS_IF(
    [test "x$ac_cv_libclocale" = xyes],
    [AC_SUBST(
      [HAVE_LIBCLOCALE],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBCLOCALE],
      [0])
    ])
  ])

dnl Function to detect whether nl_langinfo supports CODESET
AC_DEFUN([AX_LIBCLOCALE_CHECK_FUNC_LANGINFO_CODESET],
  [AC_CHECK_FUNCS([nl_langinfo])

  AS_IF(
    [test "x$ac_cv_func_nl_langinfo" = xyes],
    [AC_CACHE_CHECK(
      [for nl_langinfo CODESET support],
      [ac_cv_cv_langinfo_codeset],
      [AC_LANG_PUSH(C)
      AC_LINK_IFELSE(
        [AC_LANG_PROGRAM(
          [[#include <langinfo.h>]],
          [[char* charset = nl_langinfo( CODESET );]] )],
        [ac_cv_cv_langinfo_codeset=yes],
        [ac_cv_cv_langinfo_codeset=no])
      AC_LANG_POP(C) ]) ],
    [ac_cv_cv_langinfo_codeset=no])

  AS_IF(
    [test "x$ac_cv_cv_langinfo_codeset" = xyes],
    [AC_DEFINE(
      [HAVE_LANGINFO_CODESET],
      [1],
      [Define if nl_langinfo has CODESET support.])
    ])
  ])

dnl Function to detect if libclocale dependencies are available
AC_DEFUN([AX_LIBCLOCALE_CHECK_LOCAL],
  [dnl Headers included in libclocale/libclocale_locale.c
  AC_CHECK_HEADERS([langinfo.h locale.h])

  dnl Check for environment functions in libclocale/libclocale_locale.c
  AC_CHECK_FUNCS([getenv])

  AS_IF(
    [test "x$ac_cv_func_getenv" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: getenv],
      [1])
    ])

  dnl Check for localization functions in libclocale/libclocale_locale.c
  AS_IF(
    [test "x$ac_cv_enable_winapi" = xno],
    [AC_CHECK_FUNCS([localeconv])

    AS_IF(
      [test "x$ac_cv_func_localeconv" != xyes],
      [AC_MSG_FAILURE(
        [Missing function: localeconv],
        [1])
      ])
    ])

  AC_CHECK_FUNCS([setlocale])

  AS_IF(
    [test "x$ac_cv_func_setlocale" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: setlocale],
      [1])
    ])

  AX_LIBCLOCALE_CHECK_FUNC_LANGINFO_CODESET

  ac_cv_libclocale_CPPFLAGS="-I../libclocale";
  ac_cv_libclocale_LIBADD="../libclocale/libclocale.la";

  ac_cv_libclocale=local
  ])

dnl Function to detect how to enable libclocale
AC_DEFUN([AX_LIBCLOCALE_CHECK_ENABLE],
  [AX_COMMON_ARG_WITH(
    [libclocale],
    [libclocale],
    [search for libclocale in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  dnl Check for a shared library version
  AX_LIBCLOCALE_CHECK_LIB

  dnl Check if the dependencies for the local library version
  AS_IF(
    [test "x$ac_cv_libclocale" != xyes],
    [AX_LIBCLOCALE_CHECK_LOCAL

    AC_DEFINE(
      [HAVE_LOCAL_LIBCLOCALE],
      [1],
      [Define to 1 if the local version of libclocale is used.])
    AC_SUBST(
      [HAVE_LOCAL_LIBCLOCALE],
      [1])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBCLOCALE],
    [test "x$ac_cv_libclocale" = xlocal])
  AS_IF(
    [test "x$ac_cv_libclocale_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBCLOCALE_CPPFLAGS],
      [$ac_cv_libclocale_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libclocale_LIBADD" != "x"],
    [AC_SUBST(
      [LIBCLOCALE_LIBADD],
      [$ac_cv_libclocale_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libclocale" = xyes],
    [AC_SUBST(
      [ax_libclocale_pc_libs_private],
      [-lclocale])
    ])

  AS_IF(
    [test "x$ac_cv_libclocale" = xyes],
    [AC_SUBST(
      [ax_libclocale_spec_requires],
      [libclocale])
    AC_SUBST(
      [ax_libclocale_spec_build_requires],
      [libclocale-devel])
    ])
  ])


```

`m4/libcnotify.m4`:

```m4
dnl Checks for libcnotify required headers and functions
dnl
dnl Version: 20190308

dnl Function to detect if libcnotify is available
dnl ac_libcnotify_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBCNOTIFY_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libcnotify" = xno],
    [ac_cv_libcnotify=no],
    [ac_cv_libcnotify=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libcnotify" != x && test "x$ac_cv_with_libcnotify" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libcnotify"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libcnotify}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libcnotify}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libcnotify],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libcnotify],
          [libcnotify >= 20120425],
          [ac_cv_libcnotify=yes],
          [ac_cv_libcnotify=check])
        ])
      AS_IF(
        [test "x$ac_cv_libcnotify" = xyes],
        [ac_cv_libcnotify_CPPFLAGS="$pkg_cv_libcnotify_CFLAGS"
        ac_cv_libcnotify_LIBADD="$pkg_cv_libcnotify_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libcnotify" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libcnotify.h])

      AS_IF(
        [test "x$ac_cv_header_libcnotify_h" = xno],
        [ac_cv_libcnotify=no],
        [dnl Check for the individual functions
        ac_cv_libcnotify=yes

        AC_CHECK_LIB(
          cnotify,
          libcnotify_get_version,
          [ac_cv_libcnotify_dummy=yes],
          [ac_cv_libcnotify=no])

        dnl Print functions
        AC_CHECK_LIB(
          cnotify,
          libcnotify_printf,
          [ac_cv_libcnotify_dummy=yes],
          [ac_cv_libcnotify=no])
        AC_CHECK_LIB(
          cnotify,
          libcnotify_print_data,
          [ac_cv_libcnotify_dummy=yes],
          [ac_cv_libcnotify=no])
        AC_CHECK_LIB(
          cnotify,
          libcnotify_print_error_backtrace,
          [ac_cv_libcnotify_dummy=yes],
          [ac_cv_libcnotify=no])

        dnl Stream functions
        AC_CHECK_LIB(
          cnotify,
          libcnotify_stream_set,
          [ac_cv_libcnotify_dummy=yes],
          [ac_cv_libcnotify=no])
        AC_CHECK_LIB(
          cnotify,
          libcnotify_stream_open,
          [ac_cv_libcnotify_dummy=yes],
          [ac_cv_libcnotify=no])
        AC_CHECK_LIB(
          cnotify,
          libcnotify_stream_close,
          [ac_cv_libcnotify_dummy=yes],
          [ac_cv_libcnotify=no])

        dnl Verbose functions
        AC_CHECK_LIB(
          cnotify,
          libcnotify_verbose_set,
          [ac_cv_libcnotify_dummy=yes],
          [ac_cv_libcnotify=no])

        ac_cv_libcnotify_LIBADD="-lcnotify"])
      ])
    AS_IF(
      [test "x$ac_cv_with_libcnotify" != x && test "x$ac_cv_with_libcnotify" != xauto-detect && test "x$ac_cv_libcnotify" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libcnotify in directory: $ac_cv_with_libcnotify],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libcnotify" = xyes],
    [AC_DEFINE(
      [HAVE_LIBCNOTIFY],
      [1],
      [Define to 1 if you have the `cnotify' library (-lcnotify).])
    ])

  AS_IF(
    [test "x$ac_cv_libcnotify" = xyes],
    [AC_SUBST(
      [HAVE_LIBCNOTIFY],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBCNOTIFY],
      [0])
    ])
  ])

dnl Function to detect if libcnotify dependencies are available
AC_DEFUN([AX_LIBCNOTIFY_CHECK_LOCAL],
  [dnl Headers included in libcnotify/libcnotify_print.c
  AC_CHECK_HEADERS([stdarg.h varargs.h])

  AS_IF(
    [test "x$ac_cv_header_stdarg_h" != xyes && test "x$ac_cv_header_varargs_h" != xyes],
    [AC_MSG_FAILURE(
      [Missing headers: stdarg.h and varargs.h],
      [1])
    ])

  dnl Headers included in libcnotify/libcnotify_stream.c
  AC_CHECK_HEADERS([errno.h])

  ac_cv_libcnotify_CPPFLAGS="-I../libcnotify";
  ac_cv_libcnotify_LIBADD="../libcnotify/libcnotify.la";

  ac_cv_libcnotify=local
  ])

dnl Function to detect how to enable libcnotify
AC_DEFUN([AX_LIBCNOTIFY_CHECK_ENABLE],
  [AX_COMMON_ARG_WITH(
    [libcnotify],
    [libcnotify],
    [search for libcnotify in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  dnl Check for a shared library version
  AX_LIBCNOTIFY_CHECK_LIB

  dnl Check if the dependencies for the local library version
  AS_IF(
    [test "x$ac_cv_libcnotify" != xyes],
    [AX_LIBCNOTIFY_CHECK_LOCAL

    AC_DEFINE(
      [HAVE_LOCAL_LIBCNOTIFY],
      [1],
      [Define to 1 if the local version of libcnotify is used.])
    AC_SUBST(
      [HAVE_LOCAL_LIBCNOTIFY],
      [1])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBCNOTIFY],
    [test "x$ac_cv_libcnotify" = xlocal])
  AS_IF(
    [test "x$ac_cv_libcnotify_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBCNOTIFY_CPPFLAGS],
      [$ac_cv_libcnotify_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libcnotify_LIBADD" != "x"],
    [AC_SUBST(
      [LIBCNOTIFY_LIBADD],
      [$ac_cv_libcnotify_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libcnotify" = xyes],
    [AC_SUBST(
      [ax_libcnotify_pc_libs_private],
      [-lcnotify])
    ])

  AS_IF(
    [test "x$ac_cv_libcnotify" = xyes],
    [AC_SUBST(
      [ax_libcnotify_spec_requires],
      [libcnotify])
    AC_SUBST(
      [ax_libcnotify_spec_build_requires],
      [libcnotify-devel])
    ])
  ])


```

`m4/libcpath.m4`:

```m4
dnl Checks for libcpath required headers and functions
dnl
dnl Version: 20190308

dnl Function to detect if libcpath is available
dnl ac_libcpath_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBCPATH_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libcpath" = xno],
    [ac_cv_libcpath=no],
    [ac_cv_libcpath=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libcpath" != x && test "x$ac_cv_with_libcpath" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libcpath"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libcpath}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libcpath}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libcpath],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libcpath],
          [libcpath >= 20180716],
          [ac_cv_libcpath=yes],
          [ac_cv_libcpath=check])
        ])
      AS_IF(
        [test "x$ac_cv_libcpath" = xyes && test "x$ac_cv_enable_wide_character_type" != xno],
        [AC_CACHE_CHECK(
         [whether libcpath/features.h defines LIBCPATH_HAVE_WIDE_CHARACTER_TYPE as 1],
         [ac_cv_header_libcpath_features_h_have_wide_character_type],
         [AC_LANG_PUSH(C)
         AC_COMPILE_IFELSE(
           [AC_LANG_PROGRAM(
             [[#include <libcpath/features.h>]],
             [[#if !defined( LIBCPATH_HAVE_WIDE_CHARACTER_TYPE ) || ( LIBCPATH_HAVE_WIDE_CHARACTER_TYPE != 1 )
#error LIBCPATH_HAVE_WIDE_CHARACTER_TYPE not defined
#endif]] )],
           [ac_cv_header_libcpath_features_h_have_wide_character_type=yes],
           [ac_cv_header_libcpath_features_h_have_wide_character_type=no])
         AC_LANG_POP(C)],
         [ac_cv_header_libcpath_features_h_have_wide_character_type=no])

        AS_IF(
          [test "x$ac_cv_header_libcpath_features_h_have_wide_character_type" = xno],
          [ac_cv_libcpath=no])
        ])
      AS_IF(
        [test "x$ac_cv_libcpath" = xyes],
        [ac_cv_libcpath_CPPFLAGS="$pkg_cv_libcpath_CFLAGS"
        ac_cv_libcpath_LIBADD="$pkg_cv_libcpath_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libcpath" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libcpath.h])

      AS_IF(
        [test "x$ac_cv_header_libcpath_h" = xno],
        [ac_cv_libcpath=no],
        [dnl Check for the individual functions
        ac_cv_libcpath=yes

        AC_CHECK_LIB(
          cpath,
          libcpath_get_version,
          [ac_cv_libcpath_dummy=yes],
          [ac_cv_libcpath=no])

        dnl Path functions
        AC_CHECK_LIB(
          cpath,
          libcpath_path_change_directory,
          [ac_cv_libcpath_dummy=yes],
          [ac_cv_libcpath=no])
        AC_CHECK_LIB(
          cpath,
          libcpath_path_get_current_working_directory,
          [ac_cv_libcpath_dummy=yes],
          [ac_cv_libcpath=no])
        AC_CHECK_LIB(
          cpath,
          libcpath_path_get_full_path,
          [ac_cv_libcpath_dummy=yes],
          [ac_cv_libcpath=no])
        AC_CHECK_LIB(
          cpath,
          libcpath_path_get_sanitized_filename,
          [ac_cv_libcpath_dummy=yes],
          [ac_cv_libcpath=no])
        AC_CHECK_LIB(
          cpath,
          libcpath_path_get_sanitized_path,
          [ac_cv_libcpath_dummy=yes],
          [ac_cv_libcpath=no])
        AC_CHECK_LIB(
          cpath,
          libcpath_path_join,
          [ac_cv_libcpath_dummy=yes],
          [ac_cv_libcpath=no])
        AC_CHECK_LIB(
          cpath,
          libcpath_path_make_directory,
          [ac_cv_libcpath_dummy=yes],
          [ac_cv_libcpath=no])

        AS_IF(
          [test "x$ac_cv_enable_wide_character_type" != xno],
          [AC_CHECK_LIB(
            cpath,
            libcpath_path_change_directory_wide,
            [ac_cv_libcpath_dummy=yes],
            [ac_cv_libcpath=no])
          AC_CHECK_LIB(
            cpath,
            libcpath_path_get_current_working_directory_wide,
            [ac_cv_libcpath_dummy=yes],
            [ac_cv_libcpath=no])
          AC_CHECK_LIB(
            cpath,
            libcpath_path_get_full_path_wide,
            [ac_cv_libcpath_dummy=yes],
            [ac_cv_libcpath=no])
          AC_CHECK_LIB(
            cpath,
            libcpath_path_get_sanitized_filename_wide,
            [ac_cv_libcpath_dummy=yes],
            [ac_cv_libcpath=no])
          AC_CHECK_LIB(
            cpath,
            libcpath_path_get_sanitized_path_wide,
            [ac_cv_libcpath_dummy=yes],
            [ac_cv_libcpath=no])
          AC_CHECK_LIB(
            cpath,
            libcpath_path_join_wide,
            [ac_cv_libcpath_dummy=yes],
            [ac_cv_libcpath=no])
          AC_CHECK_LIB(
            cpath,
            libcpath_path_make_directory_wide,
            [ac_cv_libcpath_dummy=yes],
            [ac_cv_libcpath=no])
          ])

        ac_cv_libcpath_LIBADD="-lcpath"])
      ])
    AS_IF(
      [test "x$ac_cv_with_libcpath" != x && test "x$ac_cv_with_libcpath" != xauto-detect && test "x$ac_cv_libcpath" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libcpath in directory: $ac_cv_with_libcpath],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libcpath" = xyes],
    [AC_DEFINE(
      [HAVE_LIBCPATH],
      [1],
      [Define to 1 if you have the `cpath' library (-lcpath).])
    ])

  AS_IF(
    [test "x$ac_cv_libcpath" = xyes],
    [AC_SUBST(
      [HAVE_LIBCPATH],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBCPATH],
      [0])
    ])
  ])

dnl Function to detect if mkdir is available
dnl Also checks how to use mkdir
AC_DEFUN([AX_LIBCPATH_CHECK_FUNC_MKDIR],
  [AC_CHECK_FUNCS([mkdir])

  AS_IF(
    [test "x$ac_cv_func_mkdir" = xyes],
    [AC_MSG_CHECKING(
      [how to use mkdir])

    SAVE_CFLAGS="$CFLAGS"
    CFLAGS="$CFLAGS -Wall -Werror"
    AC_LANG_PUSH(C)

    AC_LINK_IFELSE(
      [AC_LANG_PROGRAM(
        [[#include <sys/stat.h>
#include <sys/types.h>]],
        [[mkdir( "", 0 )]] )],
        [AC_MSG_RESULT(
          [with additional mode argument])
        ac_cv_cv_mkdir_mode=yes],
        [ac_cv_cv_mkdir_mode=no])

    AS_IF(
      [test "x$ac_cv_cv_mkdir_mode" = xno],
      [AC_LINK_IFELSE(
        [AC_LANG_PROGRAM(
          [[#include <io.h>]],
          [[mkdir( "" )]] )],
        [AC_MSG_RESULT(
          [with single argument])
        ac_cv_cv_mkdir=yes],
        [ac_cv_cv_mkdir=no])
      ])

    AC_LANG_POP(C)
    CFLAGS="$SAVE_CFLAGS"

    AS_IF(
      [test "x$ac_cv_cv_mkdir_mode" = xno && test "x$ac_cv_cv_mkdir" = xno],
      [AC_MSG_WARN(
        [unknown])
      ac_cv_func_mkdir=no])

    AS_IF(
      [test "x$ac_cv_func_mkdir" = xyes],
      [AC_DEFINE(
        [HAVE_MKDIR],
        [1],
        [Define to 1 if you have the mkdir function.])
      ])

    AS_IF(
      [test "x$ac_cv_cv_mkdir_mode" = xyes],
      [AC_DEFINE(
        [HAVE_MKDIR_MODE],
        [1],
        [Define to 1 if you have the mkdir function with a second mode argument.])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_func_mkdir" = xno],
    [AC_MSG_FAILURE(
      [Missing function: mkdir],
      [1])
    ])
  ])

dnl Function to detect if libcpath dependencies are available
AC_DEFUN([AX_LIBCPATH_CHECK_LOCAL],
  [dnl Headers included in libcpath/libcpath_path.h
  AC_CHECK_HEADERS([errno.h sys/stat.h sys/syslimits.h])

  dnl Path functions used in libcpath/libcpath_path.h
  AC_CHECK_FUNCS([chdir getcwd])

  AS_IF(
    [test "x$ac_cv_func_chdir" != xyes],
    [AC_MSG_FAILURE(
      [Missing functions: chdir],
      [1])
    ])

  AS_IF(
    [test "x$ac_cv_func_getcwd" != xyes],
    [AC_MSG_FAILURE(
      [Missing functions: getcwd],
      [1])
    ])

  AX_LIBCPATH_CHECK_FUNC_MKDIR

  ac_cv_libcpath_CPPFLAGS="-I../libcpath";
  ac_cv_libcpath_LIBADD="../libcpath/libcpath.la";

  ac_cv_libcpath=local
  ])

dnl Function to detect how to enable libcpath
AC_DEFUN([AX_LIBCPATH_CHECK_ENABLE],
  [AX_COMMON_ARG_WITH(
    [libcpath],
    [libcpath],
    [search for libcpath in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  dnl Check for a shared library version
  AX_LIBCPATH_CHECK_LIB

  dnl Check if the dependencies for the local library version
  AS_IF(
    [test "x$ac_cv_libcpath" != xyes],
    [AX_LIBCPATH_CHECK_LOCAL

    AC_DEFINE(
      [HAVE_LOCAL_LIBCPATH],
      [1],
      [Define to 1 if the local version of libcpath is used.])
    AC_SUBST(
      [HAVE_LOCAL_LIBCPATH],
      [1])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBCPATH],
    [test "x$ac_cv_libcpath" = xlocal])
  AS_IF(
    [test "x$ac_cv_libcpath_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBCPATH_CPPFLAGS],
      [$ac_cv_libcpath_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libcpath_LIBADD" != "x"],
    [AC_SUBST(
      [LIBCPATH_LIBADD],
      [$ac_cv_libcpath_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libcpath" = xyes],
    [AC_SUBST(
      [ax_libcpath_pc_libs_private],
      [-lcpath])
    ])

  AS_IF(
    [test "x$ac_cv_libcpath" = xyes],
    [AC_SUBST(
      [ax_libcpath_spec_requires],
      [libcpath])
    AC_SUBST(
      [ax_libcpath_spec_build_requires],
      [libcpath-devel])
    ])
  ])


```

`m4/libcsplit.m4`:

```m4
dnl Checks for libcsplit required headers and functions
dnl
dnl Version: 20190308

dnl Function to detect if libcsplit is available
dnl ac_libcsplit_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBCSPLIT_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libcsplit" = xno],
    [ac_cv_libcsplit=no],
    [ac_cv_libcsplit=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libcsplit" != x && test "x$ac_cv_with_libcsplit" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libcsplit"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libcsplit}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libcsplit}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libcsplit],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libcsplit],
          [libcsplit >= 20120701],
          [ac_cv_libcsplit=yes],
          [ac_cv_libcsplit=check])
        ])
      AS_IF(
        [test "x$ac_cv_libcsplit" = xyes && test "x$ac_cv_enable_wide_character_type" != xno],
        [AC_CACHE_CHECK(
          [whether libcsplit/features.h defines LIBCSPLIT_HAVE_WIDE_CHARACTER_TYPE as 1],
          [ac_cv_header_libcsplit_features_h_have_wide_character_type],
          [AC_LANG_PUSH(C)
          AC_COMPILE_IFELSE(
            [AC_LANG_PROGRAM(
              [[#include <libcsplit/features.h>]],
              [[#if !defined( LIBCSPLIT_HAVE_WIDE_CHARACTER_TYPE ) || ( LIBCSPLIT_HAVE_WIDE_CHARACTER_TYPE != 1 )
#error LIBCSPLIT_HAVE_WIDE_CHARACTER_TYPE not defined
#endif]] )],
            [ac_cv_header_libcsplit_features_h_have_wide_character_type=yes],
            [ac_cv_header_libcsplit_features_h_have_wide_character_type=no])
          AC_LANG_POP(C)],
          [ac_cv_header_libcsplit_features_h_have_wide_character_type=no])

         AS_IF(
           [test "x$ac_cv_header_libcsplit_features_h_have_wide_character_type" = xno],
           [ac_cv_libcsplit=no])
        ])
      AS_IF(
        [test "x$ac_cv_libcsplit" = xyes],
        [ac_cv_libcsplit_CPPFLAGS="$pkg_cv_libcsplit_CFLAGS"
        ac_cv_libcsplit_LIBADD="$pkg_cv_libcsplit_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libcsplit" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libcsplit.h])

      AS_IF(
        [test "x$ac_cv_header_libcsplit_h" = xno],
        [ac_cv_libcsplit=no],
        [dnl Check for the individual functions
        ac_cv_libcsplit=yes

        AC_CHECK_LIB(
          csplit,
          libcsplit_get_version,
          [ac_cv_libcsplit_dummy=yes],
          [ac_cv_libcsplit=no])

        dnl Narrow string functions
        AC_CHECK_LIB(
          csplit,
          libcsplit_narrow_string_split,
          [ac_cv_libcsplit_dummy=yes],
          [ac_cv_libcsplit=no])

        dnl Narrow split string functions
        AC_CHECK_LIB(
          csplit,
          libcsplit_narrow_split_string_free,
          [ac_cv_libcsplit_dummy=yes],
          [ac_cv_libcsplit=no])
        AC_CHECK_LIB(
          csplit,
          libcsplit_narrow_split_string_get_string,
          [ac_cv_libcsplit_dummy=yes],
          [ac_cv_libcsplit=no])
        AC_CHECK_LIB(
          csplit,
          libcsplit_narrow_split_string_get_number_of_segments,
          [ac_cv_libcsplit_dummy=yes],
          [ac_cv_libcsplit=no])
        AC_CHECK_LIB(
          csplit,
          libcsplit_narrow_split_string_get_segment_by_index,
          [ac_cv_libcsplit_dummy=yes],
          [ac_cv_libcsplit=no])
        AC_CHECK_LIB(
          csplit,
          libcsplit_narrow_split_string_set_segment_by_index,
          [ac_cv_libcsplit_dummy=yes],
          [ac_cv_libcsplit=no])

        dnl Wide string functions
        AS_IF(
          [test "x$ac_cv_enable_wide_character_type" != xno],
          [AC_CHECK_LIB(
            csplit,
            libcsplit_wide_string_split,
            [ac_cv_libcsplit_dummy=yes],
            [ac_cv_libcsplit=no])

        dnl Wide split string functions
          AC_CHECK_LIB(
            csplit,
            libcsplit_wide_split_string_free,
            [ac_cv_libcsplit_dummy=yes],
            [ac_cv_libcsplit=no])
          AC_CHECK_LIB(
            csplit,
            libcsplit_wide_split_string_get_string,
            [ac_cv_libcsplit_dummy=yes],
            [ac_cv_libcsplit=no])
          AC_CHECK_LIB(
            csplit,
            libcsplit_wide_split_string_get_number_of_segments,
            [ac_cv_libcsplit_dummy=yes],
            [ac_cv_libcsplit=no])
          AC_CHECK_LIB(
            csplit,
            libcsplit_wide_split_string_get_segment_by_index,
            [ac_cv_libcsplit_dummy=yes],
            [ac_cv_libcsplit=no])
          AC_CHECK_LIB(
            csplit,
            libcsplit_wide_split_string_set_segment_by_index,
            [ac_cv_libcsplit_dummy=yes],
            [ac_cv_libcsplit=no])
          ])

        ac_cv_libcsplit_LIBADD="-lcsplit"])
      ])
    AS_IF(
      [test "x$ac_cv_with_libcsplit" != x && test "x$ac_cv_with_libcsplit" != xauto-detect && test "x$ac_cv_libcsplit" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libcsplit in directory: $ac_cv_with_libcsplit],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libcsplit" = xyes],
    [AC_DEFINE(
      [HAVE_LIBCSPLIT],
      [1],
      [Define to 1 if you have the `csplit' library (-lcsplit).])
    ])

  AS_IF(
    [test "x$ac_cv_libcsplit" = xyes],
    [AC_SUBST(
      [HAVE_LIBCSPLIT],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBCSPLIT],
      [0])
    ])
  ])

dnl Function to detect if libcsplit dependencies are available
AC_DEFUN([AX_LIBCSPLIT_CHECK_LOCAL],
  [dnl No additional checks.

  ac_cv_libcsplit_CPPFLAGS="-I../libcsplit";
  ac_cv_libcsplit_LIBADD="../libcsplit/libcsplit.la";

  ac_cv_libcsplit=local
  ])

dnl Function to detect how to enable libcsplit
AC_DEFUN([AX_LIBCSPLIT_CHECK_ENABLE],
  [AX_COMMON_ARG_WITH(
    [libcsplit],
    [libcsplit],
    [search for libcsplit in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  dnl Check for a shared library version
  AX_LIBCSPLIT_CHECK_LIB

  dnl Check if the dependencies for the local library version
  AS_IF(
    [test "x$ac_cv_libcsplit" != xyes],
    [AX_LIBCSPLIT_CHECK_LOCAL

    AC_DEFINE(
      [HAVE_LOCAL_LIBCSPLIT],
      [1],
      [Define to 1 if the local version of libcsplit is used.])
    AC_SUBST(
      [HAVE_LOCAL_LIBCSPLIT],
      [1])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBCSPLIT],
    [test "x$ac_cv_libcsplit" = xlocal])
  AS_IF(
    [test "x$ac_cv_libcsplit_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBCSPLIT_CPPFLAGS],
      [$ac_cv_libcsplit_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libcsplit_LIBADD" != "x"],
    [AC_SUBST(
      [LIBCSPLIT_LIBADD],
      [$ac_cv_libcsplit_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libcsplit" = xyes],
    [AC_SUBST(
      [ax_libcsplit_pc_libs_private],
      [-lcsplit])
    ])

  AS_IF(
    [test "x$ac_cv_libcsplit" = xyes],
    [AC_SUBST(
      [ax_libcsplit_spec_requires],
      [libcsplit])
    AC_SUBST(
      [ax_libcsplit_spec_build_requires],
      [libcsplit-devel])
    ])
  ])


```

`m4/libcthreads.m4`:

```m4
dnl Checks for libcthreads required headers and functions
dnl
dnl Version: 20190308

dnl Function to detect if libcthreads is available
dnl ac_libcthreads_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBCTHREADS_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libcthreads" = xno],
    [ac_cv_libcthreads=no],
    [ac_cv_libcthreads=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libcthreads" != x && test "x$ac_cv_with_libcthreads" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libcthreads"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libcthreads}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libcthreads}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libcthreads],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libcthreads],
          [libcthreads >= 20160404],
          [ac_cv_libcthreads=yes],
          [ac_cv_libcthreads=check])
        ])
      AS_IF(
        [test "x$ac_cv_libcthreads" = xyes],
        [ac_cv_libcthreads_CPPFLAGS="$pkg_cv_libcthreads_CFLAGS"
        ac_cv_libcthreads_LIBADD="$pkg_cv_libcthreads_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libcthreads" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libcthreads.h])

      AS_IF(
        [test "x$ac_cv_header_libcthreads_h" = xno],
        [ac_cv_libcthreads=no],
        [dnl Check for the individual functions
        ac_cv_libcthreads=yes

        AC_CHECK_LIB(
          cthreads,
          libcthreads_get_version,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])

        dnl Thread functions
        AC_CHECK_LIB(
          cthreads,
          libcthreads_thread_create,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_thread_join,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])

        dnl Thread attributes functions
        AC_CHECK_LIB(
          cthreads,
          libcthreads_thread_attributes_initialize,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_thread_attributes_free,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])

        dnl Condition functions
        AC_CHECK_LIB(
          cthreads,
          libcthreads_condition_initialize,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_condition_free,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_condition_broadcast,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_condition_signal,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_condition_wait,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])

        dnl Lock functions
        AC_CHECK_LIB(
          cthreads,
          libcthreads_lock_initialize,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_lock_free,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_lock_grab,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_lock_release,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])

        dnl Mutex functions
        AC_CHECK_LIB(
          cthreads,
          libcthreads_mutex_initialize,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_mutex_free,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_mutex_grab,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_mutex_try_grab,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_mutex_release,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])

        dnl Read/Write lock functions
        AC_CHECK_LIB(
          cthreads,
          libcthreads_read_write_lock_initialize,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_read_write_lock_free,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_read_write_lock_grab_for_read,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_read_write_lock_grab_for_write,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_read_write_lock_release_for_read,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_read_write_lock_release_for_write,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])

        dnl Queue functions
        AC_CHECK_LIB(
          cthreads,
          libcthreads_queue_initialize,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_queue_free,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_queue_type_pop,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_queue_pop,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_queue_try_push,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_queue_push,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_queue_push_sorted,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])

        dnl Thread pool functions
        AC_CHECK_LIB(
          cthreads,
          libcthreads_thread_pool_create,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_thread_pool_push,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_thread_pool_push_sorted,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])
        AC_CHECK_LIB(
          cthreads,
          libcthreads_thread_pool_join,
          [ac_cv_libcthreads_dummy=yes],
          [ac_cv_libcthreads=no])

        ac_cv_libcthreads_LIBADD="-lcthreads"])
      ])

    AS_IF(
      [test "x$ac_cv_with_libcthreads" != x && test "x$ac_cv_with_libcthreads" != xauto-detect && test "x$ac_cv_libcthreads" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libcthreads in directory: $ac_cv_with_libcthreads],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libcthreads" = xyes],
    [AC_DEFINE(
      [HAVE_LIBCTHREADS],
      [1],
      [Define to 1 if you have the `cthreads' library (-lcthreads).])
    ])

  AS_IF(
    [test "x$ac_cv_libcthreads" = xyes],
    [ac_cv_libcthreads_multi_threading=libcthreads],
    [ac_cv_libcthreads_multi_threading=no])

  AS_IF(
    [test "x$ac_cv_libcthreads" = xyes],
    [AC_SUBST(
      [HAVE_LIBCTHREADS],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBCTHREADS],
      [0])
    ])
  ])

dnl Function to detect if libcthreads dependencies are available
AC_DEFUN([AX_LIBCTHREADS_CHECK_LOCAL],
  [AS_IF(
    [test "x$ac_cv_enable_winapi" = xno],
    [dnl Check for enabling pthread support
    AX_PTHREAD_CHECK_ENABLE
      ac_cv_libcthreads_multi_threading=$ac_cv_pthread],
    [ac_cv_libcthreads_multi_threading="winapi"])

  AS_IF(
    [test "x$ac_cv_libcthreads_multi_threading" != xno],
    [ac_cv_libcthreads_CPPFLAGS="-I../libcthreads";
    ac_cv_libcthreads_LIBADD="../libcthreads/libcthreads.la";

    ac_cv_libcthreads=local],
    [ac_cv_libcthreads=no])
  ])

dnl Function to detect how to enable libcthreads
AC_DEFUN([AX_LIBCTHREADS_CHECK_ENABLE],
  [AX_COMMON_ARG_ENABLE(
    [multi-threading-support],
    [multi_threading_support],
    [enable multi-threading support],
    [yes])
  AX_COMMON_ARG_WITH(
    [libcthreads],
    [libcthreads],
    [search for libcthreads in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  AS_IF(
    [test "x$ac_cv_enable_multi_threading_support" = xno],
    [ac_cv_libcthreads="no"
    ac_cv_libcthreads_multi_threading="no"],
    [dnl Check for a shared library version
    AX_LIBCTHREADS_CHECK_LIB

    dnl Check if the dependencies for the local library version
    AS_IF(
      [test "x$ac_cv_libcthreads" != xyes],
      [AX_LIBCTHREADS_CHECK_LOCAL

      AC_DEFINE(
        [HAVE_LOCAL_LIBCTHREADS],
        [1],
        [Define to 1 if the local version of libcthreads is used.])
      AC_SUBST(
        [HAVE_LOCAL_LIBCTHREADS],
        [1])
      ])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBCTHREADS],
    [test "x$ac_cv_libcthreads" = xlocal])
  AS_IF(
    [test "x$ac_cv_libcthreads_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBCTHREADS_CPPFLAGS],
      [$ac_cv_libcthreads_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libcthreads_LIBADD" != "x"],
    [AC_SUBST(
      [LIBCTHREADS_LIBADD],
      [$ac_cv_libcthreads_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libcthreads" != xno],
    [AC_DEFINE(
      [HAVE_MULTI_THREAD_SUPPORT],
      [1],
      [Define to 1 if multi thread support should be used.])
    AC_SUBST(
      [HAVE_MULTI_THREAD_SUPPORT],
      [1]) ],
    [AC_SUBST(
      [HAVE_MULTI_THREAD_SUPPORT],
      [0])
    ])

  AS_IF(
    [test "x$ac_cv_libcthreads" = xyes],
    [AC_SUBST(
      [ax_libcthreads_pc_libs_private],
      [-lcthreads])
    ])

  AS_IF(
    [test "x$ac_cv_libcthreads" = xyes],
    [AC_SUBST(
      [ax_libcthreads_spec_requires],
      [libcthreads])
    AC_SUBST(
      [ax_libcthreads_spec_build_requires],
      [libcthreads-devel])
    ])
  ])


```

`m4/libfcache.m4`:

```m4
dnl Checks for libfcache required headers and functions
dnl
dnl Version: 20230115

dnl Function to detect if libfcache is available
dnl ac_libfcache_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBFCACHE_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libfcache" = xno],
    [ac_cv_libfcache=no],
    [ac_cv_libfcache=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libfcache" != x && test "x$ac_cv_with_libfcache" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libfcache"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libfcache}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libfcache}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libfcache],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libfcache],
          [libfcache >= 20191109],
          [ac_cv_libfcache=yes],
          [ac_cv_libfcache=check])
        ])
      AS_IF(
        [test "x$ac_cv_libfcache" = xyes],
        [ac_cv_libfcache_CPPFLAGS="$pkg_cv_libfcache_CFLAGS"
        ac_cv_libfcache_LIBADD="$pkg_cv_libfcache_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libfcache" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libfcache.h])

      AS_IF(
        [test "x$ac_cv_header_libfcache_h" = xno],
        [ac_cv_libfcache=no],
        [dnl Check for the individual functions
        ac_cv_libfcache=yes

        AC_CHECK_LIB(
          fcache,
          libfcache_get_version,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])

        dnl Cache functions
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_initialize,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_free,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_clone,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_clear,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_get_number_of_entries,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_get_number_of_cache_values,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_clear_value_by_index,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_get_value_by_identifier,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_get_value_by_index,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_set_value_by_identifier,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_set_value_by_index,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])

        dnl Cache value functions
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_value_free,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_value_clear,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_value_get_identifier,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_value_set_identifier,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_value_get_value,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])
        AC_CHECK_LIB(
          fcache,
          libfcache_cache_value_set_value,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])

        dnl Date time functions
        AC_CHECK_LIB(
          fcache,
          libfcache_date_time_get_timestamp,
          [ac_cv_libfcache_dummy=yes],
          [ac_cv_libfcache=no])

        ac_cv_libfcache_LIBADD="-lfcache"])
      ])
    AS_IF(
      [test "x$ac_cv_with_libfcache" != x && test "x$ac_cv_with_libfcache" != xauto-detect && test "x$ac_cv_libfcache" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libfcache in directory: $ac_cv_with_libfcache],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libfcache" = xyes],
    [AC_DEFINE(
      [HAVE_LIBFCACHE],
      [1],
      [Define to 1 if you have the `fcache' library (-lfcache).])
    ])

  AS_IF(
    [test "x$ac_cv_libfcache" = xyes],
    [AC_SUBST(
      [HAVE_LIBFCACHE],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBFCACHE],
      [0])
    ])
  ])

dnl Function to detect if libfcache dependencies are available
AC_DEFUN([AX_LIBFCACHE_CHECK_LOCAL],
  [dnl Types used in libfcache/libfcache_date_time.h
  AC_STRUCT_TM

  dnl Headers included in libfcache/libfcache_date_time.h
  AC_CHECK_HEADERS([sys/time.h])

  dnl Date and time functions used in libfcache/libfcache_date_time.h
  AC_CHECK_FUNCS([clock_gettime time])

  AS_IF(
    [test "x$ac_cv_func_time" != xyes],
    [AC_MSG_FAILURE(
      [Missing function: time],
      [1])
    ])

  ac_cv_libfcache_CPPFLAGS="-I../libfcache";
  ac_cv_libfcache_LIBADD="../libfcache/libfcache.la";

  ac_cv_libfcache=local
  ])

dnl Function to detect how to enable libfcache
AC_DEFUN([AX_LIBFCACHE_CHECK_ENABLE],
  [AX_COMMON_ARG_WITH(
    [libfcache],
    [libfcache],
    [search for libfcache in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  dnl Check for a shared library version
  AX_LIBFCACHE_CHECK_LIB

  dnl Check if the dependencies for the local library version
  AS_IF(
    [test "x$ac_cv_libfcache" != xyes],
    [AX_LIBFCACHE_CHECK_LOCAL

    AC_DEFINE(
      [HAVE_LOCAL_LIBFCACHE],
      [1],
      [Define to 1 if the local version of libfcache is used.])
    AC_SUBST(
      [HAVE_LOCAL_LIBFCACHE],
      [1])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBFCACHE],
    [test "x$ac_cv_libfcache" = xlocal])
  AS_IF(
    [test "x$ac_cv_libfcache_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBFCACHE_CPPFLAGS],
      [$ac_cv_libfcache_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libfcache_LIBADD" != "x"],
    [AC_SUBST(
      [LIBFCACHE_LIBADD],
      [$ac_cv_libfcache_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libfcache" = xyes],
    [AC_SUBST(
      [ax_libfcache_pc_libs_private],
      [-lfcache])
    ])

  AS_IF(
    [test "x$ac_cv_libfcache" = xyes],
    [AC_SUBST(
      [ax_libfcache_spec_requires],
      [libfcache])
    AC_SUBST(
      [ax_libfcache_spec_build_requires],
      [libfcache-devel])
    ])
  ])

```

`m4/libfdata.m4`:

```m4
dnl Functions for libfdata
dnl
dnl Version: 20230318

dnl Function to detect if libfdata is available
dnl ac_libfdata_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBFDATA_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libfdata" = xno],
    [ac_cv_libfdata=no],
    [ac_cv_libfdata=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libfdata" != x && test "x$ac_cv_with_libfdata" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libfdata"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libfdata}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libfdata}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libfdata],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libfdata],
          [libfdata >= 20201129],
          [ac_cv_libfdata=yes],
          [ac_cv_libfdata=check])
        ])
      AS_IF(
        [test "x$ac_cv_libfdata" = xyes],
        [ac_cv_libfdata_CPPFLAGS="$pkg_cv_libfdata_CFLAGS"
        ac_cv_libfdata_LIBADD="$pkg_cv_libfdata_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libfdata" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libfdata.h])

      AS_IF(
        [test "x$ac_cv_header_libfdata_h" = xno],
        [ac_cv_libfdata=no],
        [dnl Check for the individual functions
        ac_cv_libfdata=yes

        AC_CHECK_LIB(
          fdata,
          libfdata_get_version,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        dnl Area functions
        AC_CHECK_LIB(
          fdata,
          libfdata_area_initialize,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_free,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_clone,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_empty,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_resize,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_get_number_of_segments,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_get_segment_by_index,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_set_segment_by_index,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_prepend_segment,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_append_segment,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_get_element_data_size,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_get_element_value_at_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_set_element_value_at_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_area_get_size,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        dnl List functions
        AC_CHECK_LIB(
          fdata,
          libfdata_list_initialize,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_free,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_clone,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_empty,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_resize,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        AC_CHECK_LIB(
          fdata,
          libfdata_list_reverse,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_number_of_elements,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_list_element_by_index,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_element_by_index,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_set_element_by_index,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_prepend_element,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_append_element,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_append_list,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_is_element_set,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_element_mapped_range,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_mapped_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_set_mapped_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_mapped_size_by_index,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_set_mapped_size_by_index,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_element_by_index_with_mapped_size,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_set_element_by_index_with_mapped_size,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_append_element_with_mapped_size,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_element_index_at_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_list_element_at_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_element_at_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        AC_CHECK_LIB(
          fdata,
          libfdata_list_cache_element_value,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_element_value_by_index,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_element_value_at_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_set_element_value_by_index,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        AC_CHECK_LIB(
          fdata,
          libfdata_list_set_element_value_at_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_get_size,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        AC_CHECK_LIB(
          fdata,
          libfdata_list_element_get_mapped_size,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_element_set_mapped_size,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_element_get_element_value,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_element_set_element_value,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        dnl List element functions
        AC_CHECK_LIB(
          fdata,
          libfdata_list_element_get_mapped_size,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_element_set_mapped_size,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_element_get_element_value,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_list_element_set_element_value,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        dnl Range list functions
        dnl TODO: add functions

        dnl Stream functions
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_initialize,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_free,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_clone,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        AC_CHECK_LIB(
          fdata,
          libfdata_stream_empty,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_resize,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_reverse,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        AC_CHECK_LIB(
          fdata,
          libfdata_stream_get_number_of_segments,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_get_segment_by_index,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_set_segment_by_index,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_prepend_segment,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_append_segment,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_set_mapped_size,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        AC_CHECK_LIB(
          fdata,
          libfdata_stream_get_segment_mapped_range,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_get_segment_index_at_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_get_segment_at_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        AC_CHECK_LIB(
          fdata,
          libfdata_stream_read_buffer,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_read_buffer_at_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_write_buffer,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_seek_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_get_offset,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])
        AC_CHECK_LIB(
          fdata,
          libfdata_stream_get_size,
          [ac_cv_libfdata_dummy=yes],
          [ac_cv_libfdata=no])

        dnl Tree list functions
        dnl TODO: add functions

        dnl Vector list functions
        dnl TODO: add functions

        ac_cv_libfdata_LIBADD="-lfdata"])
      ])
    AS_IF(
      [test "x$ac_cv_with_libfdata" != x && test "x$ac_cv_with_libfdata" != xauto-detect && test "x$ac_cv_libfdata" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libfdata in directory: $ac_cv_with_libfdata],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libfdata" = xyes],
    [AC_DEFINE(
      [HAVE_LIBFDATA],
      [1],
      [Define to 1 if you have the `fdata' library (-lfdata).])
    ])

  AS_IF(
    [test "x$ac_cv_libfdata" = xyes],
    [AC_SUBST(
      [HAVE_LIBFDATA],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBFDATA],
      [0])
    ])
  ])

dnl Function to detect if libfdata dependencies are available
AC_DEFUN([AX_LIBFDATA_CHECK_LOCAL],
  [dnl No additional checks.

  ac_cv_libfdata_CPPFLAGS="-I../libfdata";
  ac_cv_libfdata_LIBADD="../libfdata/libfdata.la";

  ac_cv_libfdata=local
  ])

dnl Function to detect how to enable libfdata
AC_DEFUN([AX_LIBFDATA_CHECK_ENABLE],
  [AX_COMMON_ARG_WITH(
    [libfdata],
    [libfdata],
    [search for libfdata in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  dnl Check for a shared library version
  AX_LIBFDATA_CHECK_LIB

  dnl Check if the dependencies for the local library version
  AS_IF(
    [test "x$ac_cv_libfdata" != xyes],
    [AX_LIBFDATA_CHECK_LOCAL

    AC_DEFINE(
      [HAVE_LOCAL_LIBFDATA],
      [1],
      [Define to 1 if the local version of libfdata is used.])
    AC_SUBST(
      [HAVE_LOCAL_LIBFDATA],
      [1])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBFDATA],
    [test "x$ac_cv_libfdata" = xlocal])
  AS_IF(
    [test "x$ac_cv_libfdata_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBFDATA_CPPFLAGS],
      [$ac_cv_libfdata_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libfdata_LIBADD" != "x"],
    [AC_SUBST(
      [LIBFDATA_LIBADD],
      [$ac_cv_libfdata_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libfdata" = xyes],
    [AC_SUBST(
      [ax_libfdata_pc_libs_private],
      [-lfdata])
    ])

  AS_IF(
    [test "x$ac_cv_libfdata" = xyes],
    [AC_SUBST(
      [ax_libfdata_spec_requires],
      [libfdata])
    AC_SUBST(
      [ax_libfdata_spec_build_requires],
      [libfdata-devel])
    ])
  ])

```

`m4/libfdatetime.m4`:

```m4
dnl Checks for libfdatetime required headers and functions
dnl
dnl Version: 20190308

dnl Function to detect if libfdatetime is available
dnl ac_libfdatetime_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBFDATETIME_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libfdatetime" = xno],
    [ac_cv_libfdatetime=no],
    [ac_cv_libfdatetime=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libfdatetime" != x && test "x$ac_cv_with_libfdatetime" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libfdatetime"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libfdatetime}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libfdatetime}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libfdatetime],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libfdatetime],
          [libfdatetime >= 20180910],
          [ac_cv_libfdatetime=yes],
          [ac_cv_libfdatetime=check])
        ])
      AS_IF(
        [test "x$ac_cv_libfdatetime" = xyes],
        [ac_cv_libfdatetime_CPPFLAGS="$pkg_cv_libfdatetime_CFLAGS"
        ac_cv_libfdatetime_LIBADD="$pkg_cv_libfdatetime_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libfdatetime" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libfdatetime.h])

      AS_IF(
        [test "x$ac_cv_header_libfdatetime_h" = xno],
        [ac_cv_libfdatetime=no],
        [dnl Check for the individual functions
        ac_cv_libfdatetime=yes

        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_get_version,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])

        dnl FAT date time functions
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_fat_date_time_initialize,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_fat_date_time_free,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_fat_date_time_copy_from_byte_stream,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_fat_date_time_copy_from_32bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_fat_date_time_copy_to_32bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_fat_date_time_copy_to_utf8_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_fat_date_time_copy_to_utf8_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_fat_date_time_copy_to_utf16_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_fat_date_time_copy_to_utf16_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_fat_date_time_copy_to_utf32_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_fat_date_time_copy_to_utf32_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])

        dnl FILETIME functions
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_filetime_initialize,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_filetime_free,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_filetime_copy_from_byte_stream,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_filetime_copy_from_64bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_filetime_copy_to_64bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_filetime_copy_to_utf8_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_filetime_copy_to_utf8_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_filetime_copy_to_utf16_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_filetime_copy_to_utf16_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_filetime_copy_to_utf32_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_filetime_copy_to_utf32_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_filetime_add,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])

        dnl Floatingtime functions
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_floatingtime_initialize,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_floatingtime_free,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_floatingtime_copy_from_byte_stream,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_floatingtime_copy_from_64bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_floatingtime_copy_to_64bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_floatingtime_copy_to_utf8_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_floatingtime_copy_to_utf8_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_floatingtime_copy_to_utf16_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_floatingtime_copy_to_utf16_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_floatingtime_copy_to_utf32_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_floatingtime_copy_to_utf32_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])

        dnl HFS time functions
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_hfs_time_initialize,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_hfs_time_free,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_hfs_time_copy_from_byte_stream,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_hfs_time_copy_from_32bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_hfs_time_copy_to_32bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_hfs_time_copy_to_utf8_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_hfs_time_copy_to_utf8_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_hfs_time_copy_to_utf16_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_hfs_time_copy_to_utf16_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_hfs_time_copy_to_utf32_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_hfs_time_copy_to_utf32_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])

        dnl NSF timedate functions
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_nsf_timedate_initialize,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_nsf_timedate_free,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_nsf_timedate_copy_from_byte_stream,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_nsf_timedate_copy_from_64bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_nsf_timedate_copy_to_64bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_nsf_timedate_copy_to_utf8_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_nsf_timedate_copy_to_utf8_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_nsf_timedate_copy_to_utf16_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_nsf_timedate_copy_to_utf16_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_nsf_timedate_copy_to_utf32_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_nsf_timedate_copy_to_utf32_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])

        dnl POSIX time functions
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_initialize,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_free,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_copy_from_byte_stream,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_copy_from_32bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_copy_to_32bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_copy_from_64bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_copy_to_64bit,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_copy_to_utf8_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_copy_to_utf8_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_copy_to_utf16_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_copy_to_utf16_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_copy_to_utf32_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_posix_time_copy_to_utf32_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])

        dnl Systemtime functions
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_systemetime_initialize,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_systemetime_free,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_systemetime_copy_from_byte_stream,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_systemetime_copy_to_utf8_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_systemetime_copy_to_utf8_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_systemetime_copy_to_utf16_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_systemetime_copy_to_utf16_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_systemetime_copy_to_utf32_string,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])
        AC_CHECK_LIB(
          fdatetime,
          libfdatetime_systemetime_copy_to_utf32_string_with_index,
          [ac_cv_libfdatetime_dummy=yes],
          [ac_cv_libfdatetime=no])

        ac_cv_libfdatetime_LIBADD="-lfdatetime"])
      ])
    AS_IF(
      [test "x$ac_cv_with_libfdatetime" != x && test "x$ac_cv_with_libfdatetime" != xauto-detect && test "x$ac_cv_libfdatetime" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libfdatetime in directory: $ac_cv_with_libfdatetime],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libfdatetime" = xyes],
    [AC_DEFINE(
      [HAVE_LIBFDATETIME],
      [1],
      [Define to 1 if you have the `fdatetime' library (-lfdatetime).])
    ])

  AS_IF(
    [test "x$ac_cv_libfdatetime" = xyes],
    [AC_SUBST(
      [HAVE_LIBFDATETIME],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBFDATETIME],
      [0])
    ])
  ])

dnl Function to detect if libfdatetime dependencies are available
AC_DEFUN([AX_LIBFDATETIME_CHECK_LOCAL],
  [dnl No additional checks.

  ac_cv_libfdatetime_CPPFLAGS="-I../libfdatetime";
  ac_cv_libfdatetime_LIBADD="../libfdatetime/libfdatetime.la";

  ac_cv_libfdatetime=local
  ])

dnl Function to detect how to enable libfdatetime
AC_DEFUN([AX_LIBFDATETIME_CHECK_ENABLE],
  [AX_COMMON_ARG_WITH(
    [libfdatetime],
    [libfdatetime],
    [search for libfdatetime in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  AX_LIBFDATETIME_CHECK_LIB

  dnl Check if the dependencies for the local library version
  AS_IF(
    [test "x$ac_cv_libfdatetime" != xyes],
    [AX_LIBFDATETIME_CHECK_LOCAL

    AC_DEFINE(
      [HAVE_LOCAL_LIBFDATETIME],
      [1],
      [Define to 1 if the local version of libfdatetime is used.])
    AC_SUBST(
      [HAVE_LOCAL_LIBFDATETIME],
      [1])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBFDATETIME],
    [test "x$ac_cv_libfdatetime" = xlocal])
  AS_IF(
    [test "x$ac_cv_libfdatetime_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBFDATETIME_CPPFLAGS],
      [$ac_cv_libfdatetime_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libfdatetime_LIBADD" != "x"],
    [AC_SUBST(
      [LIBFDATETIME_LIBADD],
      [$ac_cv_libfdatetime_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libfdatetime" = xyes],
    [AC_SUBST(
      [ax_libfdatetime_pc_libs_private],
      [-lfdatetime])
    ])

  AS_IF(
    [test "x$ac_cv_libfdatetime" = xyes],
    [AC_SUBST(
      [ax_libfdatetime_spec_requires],
      [libfdatetime])
    AC_SUBST(
      [ax_libfdatetime_spec_build_requires],
      [libfdatetime-devel])
    ])
  ])


```

`m4/libuna.m4`:

```m4
dnl Checks for libuna or required headers and functions
dnl
dnl Version: 20230702

dnl Function to detect if a specific libuna definition is available.
AC_DEFUN([AX_LIBUNA_CHECK_DEFINITION],
  [AC_CACHE_CHECK(
    [if `$1' is defined],
    [$2],
    [AC_LANG_PUSH(C)
    AC_LINK_IFELSE(
      [AC_LANG_PROGRAM(
        [[#include <libuna.h>]],
        [[int test = $1;

return( 0 ); ]] )],
      [$2=yes],
      [$2=no])
    AC_LANG_POP(C)])
  ])

dnl Function to detect if libuna is available
dnl ac_libuna_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments
AC_DEFUN([AX_LIBUNA_CHECK_LIB],
  [AS_IF(
    [test "x$ac_cv_enable_shared_libs" = xno || test "x$ac_cv_with_libuna" = xno],
    [ac_cv_libuna=no],
    [ac_cv_libuna=check
    dnl Check if the directory provided as parameter exists
    AS_IF(
      [test "x$ac_cv_with_libuna" != x && test "x$ac_cv_with_libuna" != xauto-detect],
      [AS_IF(
        [test -d "$ac_cv_with_libuna"],
        [CFLAGS="$CFLAGS -I${ac_cv_with_libuna}/include"
        LDFLAGS="$LDFLAGS -L${ac_cv_with_libuna}/lib"],
        [AC_MSG_FAILURE(
          [no such directory: $ac_cv_with_libuna],
          [1])
        ])
      ],
      [dnl Check for a pkg-config file
      AS_IF(
        [test "x$cross_compiling" != "xyes" && test "x$PKGCONFIG" != "x"],
        [PKG_CHECK_MODULES(
          [libuna],
          [libuna >= 20230702],
          [ac_cv_libuna=yes],
          [ac_cv_libuna=check])
        ])
      AS_IF(
        [test "x$ac_cv_libuna" = xyes],
        [ac_cv_libuna_CPPFLAGS="$pkg_cv_libuna_CFLAGS"
        ac_cv_libuna_LIBADD="$pkg_cv_libuna_LIBS"])
      ])

    AS_IF(
      [test "x$ac_cv_libuna" = xcheck],
      [dnl Check for headers
      AC_CHECK_HEADERS([libuna.h])

      AS_IF(
        [test "x$ac_cv_header_libuna_h" = xno],
        [ac_cv_libuna=no],
        [dnl Check for the individual functions
        ac_cv_libuna=yes

        AC_CHECK_LIB(
          una,
          libuna_get_version,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        dnl Base16 stream functions
        AC_CHECK_LIB(
          una,
          libuna_base16_stream_size_to_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base16_stream_copy_to_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base16_stream_size_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base16_stream_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base16_stream_with_index_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        dnl Base32 stream functions
        AC_CHECK_LIB(
          una,
          libuna_base32_quintuplet_copy_from_base32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base32_quintuplet_copy_to_base32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base32_quintuplet_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base32_quintuplet_copy_to_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        AC_CHECK_LIB(
          una,
          libuna_base32_stream_size_to_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base32_stream_copy_to_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base32_stream_size_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base32_stream_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base32_stream_with_index_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        dnl Base64 stream functions
        AC_CHECK_LIB(
          una,
          libuna_base64_triplet_copy_from_base64_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base64_triplet_copy_to_base64_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base64_triplet_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base64_triplet_copy_to_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        AC_CHECK_LIB(
          una,
          libuna_base64_stream_size_to_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base64_stream_copy_to_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base64_stream_size_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base64_stream_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_base64_stream_with_index_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        dnl Byte stream functions
        AC_CHECK_LIB(
          una,
          libuna_byte_stream_size_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_byte_stream_copy_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_byte_stream_size_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_byte_stream_copy_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_byte_stream_size_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_byte_stream_copy_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        dnl Unicode character functions
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_size_to_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_to_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_size_to_ucs2,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_from_ucs2,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_to_ucs2,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_size_to_ucs4,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_from_ucs4,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_to_ucs4,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_from_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_to_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_size_to_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_to_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_size_to_utf8_rfc2279,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_from_utf8_rfc2279,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_to_utf8_rfc2279,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_size_to_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_to_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_from_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_to_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_to_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_from_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_unicode_character_copy_to_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        dnl UTF-8 stream functions
        AC_CHECK_LIB(
          una,
          libuna_utf8_stream_size_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_stream_copy_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_stream_size_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_stream_copy_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_stream_size_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_stream_copy_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        dnl UTF-16 stream functions
        AC_CHECK_LIB(
          una,
          libuna_utf16_stream_size_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_stream_copy_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_stream_size_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_stream_copy_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_stream_size_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_stream_copy_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        dnl UTF-32 stream functions
        AC_CHECK_LIB(
          una,
          libuna_utf32_stream_size_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_stream_copy_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_stream_size_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_stream_copy_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_stream_size_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_stream_copy_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        dnl UTF-8 string functions
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_size_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_with_index_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_compare_with_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_size_from_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_copy_from_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_with_index_copy_from_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_compare_with_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_size_from_utf8_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_copy_from_utf8_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_with_index_copy_from_utf8_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_compare_with_utf8_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_size_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_copy_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_with_index_copy_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_compare_with_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_size_from_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_copy_from_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_with_index_copy_from_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_compare_with_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_size_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_copy_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_with_index_copy_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_compare_with_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_size_from_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_copy_from_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_with_index_copy_from_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_compare_with_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_size_from_scsu_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_copy_from_scsu_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf8_string_with_index_copy_from_scsu_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        dnl UTF-16 string functions
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_size_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_with_index_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_compare_with_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_size_from_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_copy_from_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_with_index_copy_from_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_compare_with_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_size_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_copy_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_with_index_copy_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        dnl libuna_utf16_string_compare_with_utf8 is implemented by libuna_utf8_string_compare_with_utf16
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_size_from_utf8_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_copy_from_utf8_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_with_index_copy_from_utf8_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_compare_with_utf8_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_size_from_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_copy_from_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_with_index_copy_from_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_compare_with_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_size_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_copy_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_with_index_copy_from_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_compare_with_utf32,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_size_from_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_copy_from_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_with_index_copy_from_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_compare_with_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_size_from_scsu_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_copy_from_scsu_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf16_string_with_index_copy_from_scsu_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        dnl UTF-32 string functions
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_size_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_with_index_copy_from_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_compare_with_byte_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_size_from_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_copy_from_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_with_index_copy_from_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_compare_with_utf7_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_size_from_utf8_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_size_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_copy_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          libuna_utf32_string_with_index_copy_from_utf8,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        dnl libuna_utf32_string_compare_with_utf8 is implemented by libuna_utf8_string_compare_with_utf32
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_copy_from_utf8_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_with_index_copy_from_utf8_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_compare_with_utf8_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_size_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_copy_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_with_index_copy_from_utf16,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        dnl libuna_utf32_string_compare_with_utf16 is implemented by libuna_utf16_string_compare_with_utf32
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_size_from_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_copy_from_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_with_index_copy_from_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_compare_with_utf16_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_size_from_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_copy_from_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_with_index_copy_from_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_compare_with_utf32_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_size_from_scsu_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_copy_from_scsu_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])
        AC_CHECK_LIB(
          una,
          libuna_utf32_string_with_index_copy_from_scsu_stream,
          [ac_cv_libuna_dummy=yes],
          [ac_cv_libuna=no])

        dnl Check for definitions
        AX_LIBUNA_CHECK_DEFINITION(
          LIBUNA_COMPARE_LESS,
          [ac_cv_libuna_defines_compare_less])
        AS_IF(
          [test "x$ac_cv_libuna_defines_compare_less" != xyes],
          [ac_cv_libuna=no])

        AX_LIBUNA_CHECK_DEFINITION(
          LIBUNA_COMPARE_EQUAL,
          [ac_cv_libuna_defines_compare_equal])
        AS_IF(
          [test "x$ac_cv_libuna_defines_compare_less" != xyes],
          [ac_cv_libuna=no])

        AX_LIBUNA_CHECK_DEFINITION(
          LIBUNA_COMPARE_GREATER,
          [ac_cv_libuna_defines_compare_greater])
        AS_IF(
          [test "x$ac_cv_libuna_defines_compare_less" != xyes],
          [ac_cv_libuna=no])

        AX_LIBUNA_CHECK_DEFINITION(
          LIBUNA_UTF16_STREAM_ALLOW_UNPAIRED_SURROGATE,
          [ac_cv_libuna_defines_compare_greater])
        AS_IF(
          [test "x$ac_cv_libuna_defines_utf16_stream_allow_unpaired_surrogate" != xyes],
          [ac_cv_libuna=no])

        ac_cv_libuna_LIBADD="-luna"])
      ])
    AS_IF(
      [test "x$ac_cv_with_libuna" != x && test "x$ac_cv_with_libuna" != xauto-detect && test "x$ac_cv_libuna" != xyes],
      [AC_MSG_FAILURE(
        [unable to find supported libuna in directory: $ac_cv_with_libuna],
        [1])
      ])
    ])

  AS_IF(
    [test "x$ac_cv_libuna" = xyes],
    [AC_DEFINE(
      [HAVE_LIBUNA],
      [1],
      [Define to 1 if you have the `una' library (-luna).])
    ])

  AS_IF(
    [test "x$ac_cv_libuna" = xyes],
    [AC_SUBST(
      [HAVE_LIBUNA],
      [1]) ],
    [AC_SUBST(
      [HAVE_LIBUNA],
      [0])
    ])
  ])

dnl Function to detect if libuna dependencies are available
AC_DEFUN([AX_LIBUNA_CHECK_LOCAL],
  [dnl No additional checks.

  ac_cv_libuna_CPPFLAGS="-I../libuna";
  ac_cv_libuna_LIBADD="../libuna/libuna.la";

  ac_cv_libuna=local
  ])

dnl Function to detect how to enable libuna
AC_DEFUN([AX_LIBUNA_CHECK_ENABLE],
  [AX_COMMON_ARG_WITH(
    [libuna],
    [libuna],
    [search for libuna in includedir and libdir or in the specified DIR, or no if to use local version],
    [auto-detect],
    [DIR])

  dnl Check for a shared library version
  AX_LIBUNA_CHECK_LIB

  dnl Check if the dependencies for the local library version
  AS_IF(
    [test "x$ac_cv_libuna" != xyes],
    [AX_LIBUNA_CHECK_LOCAL

    AC_DEFINE(
      [HAVE_LOCAL_LIBUNA],
      [1],
      [Define to 1 if the local version of libuna is used.])
    AC_SUBST(
      [HAVE_LOCAL_LIBUNA],
      [1])
    ])

  AM_CONDITIONAL(
    [HAVE_LOCAL_LIBUNA],
    [test "x$ac_cv_libuna" = xlocal])
  AS_IF(
    [test "x$ac_cv_libuna_CPPFLAGS" != "x"],
    [AC_SUBST(
      [LIBUNA_CPPFLAGS],
      [$ac_cv_libuna_CPPFLAGS])
    ])
  AS_IF(
    [test "x$ac_cv_libuna_LIBADD" != "x"],
    [AC_SUBST(
      [LIBUNA_LIBADD],
      [$ac_cv_libuna_LIBADD])
    ])

  AS_IF(
    [test "x$ac_cv_libuna" = xyes],
    [AC_SUBST(
      [ax_libuna_pc_libs_private],
      [-luna])
    ])

  AS_IF(
    [test "x$ac_cv_libuna" = xyes],
    [AC_SUBST(
      [ax_libuna_spec_requires],
      [libuna])
    AC_SUBST(
      [ax_libuna_spec_build_requires],
      [libuna-devel])
    ])
  ])


```

`m4/pthread.m4`:

```m4
dnl Functions for pthread
dnl
dnl Version: 20130509

dnl Function to detect if pthread is available
AC_DEFUN([AX_PTHREAD_CHECK_LIB],
 [dnl Check if parameters were provided
 AS_IF(
  [test "x$ac_cv_with_pthread" != x && test "x$ac_cv_with_pthread" != xno && test "x$ac_cv_with_pthread" != xauto-detect],
  [AS_IF(
   [test -d "$ac_cv_with_pthread"],
   [CFLAGS="$CFLAGS -I${ac_cv_with_pthread}/include"
   LDFLAGS="$LDFLAGS -L${ac_cv_with_pthread}/lib"],
   [AC_MSG_WARN([no such directory: $ac_cv_with_pthread])
   ])
  ])

 AS_IF(
  [test "x$ac_cv_with_pthread" = xno],
  [ac_cv_pthread=no],
  [dnl Check for headers
  AC_CHECK_HEADERS([pthread.h])

  AS_IF(
   [test "x$ac_cv_header_pthread_h" = xno],
   [ac_cv_pthread=no],
   [dnl Check for the individual functions
   ac_cv_pthread=pthread

   dnl Thread functions
   AC_CHECK_LIB(
    pthread,
    pthread_create,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_exit,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_join,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])

   dnl Condition functions
   AC_CHECK_LIB(
    pthread,
    pthread_cond_init,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_cond_destroy,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_cond_broadcast,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_cond_signal,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_cond_wait,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])

   dnl Mutex functions
   AC_CHECK_LIB(
    pthread,
    pthread_mutex_init,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_mutex_destroy,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_mutex_lock,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_mutex_trylock,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_mutex_unlock,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])

   dnl Read/Write lock functions
   AC_CHECK_LIB(
    pthread,
    pthread_rwlock_init,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_rwlock_destroy,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_rwlock_rdlock,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_rwlock_wrlock,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])
   AC_CHECK_LIB(
    pthread,
    pthread_rwlock_unlock,
    [ac_pthread_dummy=yes],
    [ac_cv_pthread=no])

   ac_cv_pthread_LIBADD="-lpthread";
   ])
  ])

 AS_IF(
  [test "x$ac_cv_pthread" = xpthread],
  [AC_DEFINE(
   [HAVE_PTHREAD],
   [1],
   [Define to 1 if you have the 'pthread' library (-lpthread).])
  ])

 AS_IF(
  [test "x$ac_cv_pthread" != xno],
  [AC_SUBST(
   [HAVE_PTHREAD],
   [1]) ],
  [AC_SUBST(
   [HAVE_PTHREAD],
   [0])
  ])
 ])

dnl Function to detect how to enable pthread
AC_DEFUN([AX_PTHREAD_CHECK_ENABLE],
 [AX_COMMON_ARG_WITH(
  [pthread],
  [pthread],
  [search for pthread in includedir and libdir or in the specified DIR, or no if not to use pthread],
  [auto-detect],
  [DIR])

 dnl Check for a shared library version
 AX_PTHREAD_CHECK_LIB

 AS_IF(
  [test "x$ac_cv_pthread_CPPFLAGS" != "x"],
  [AC_SUBST(
   [PTHREAD_CPPFLAGS],
   [$ac_cv_pthread_CPPFLAGS])
  ])
 AS_IF(
  [test "x$ac_cv_pthread_LIBADD" != "x"],
  [AC_SUBST(
   [PTHREAD_LIBADD],
   [$ac_cv_pthread_LIBADD])
  ])

 AS_IF(
  [test "x$ac_cv_pthread" = xpthread],
  [AC_SUBST(
   [ax_pthread_pc_libs_private],
   [-lpthread])
  ])
 ])


```

`m4/tests.m4`:

```m4
dnl Functions for testing
dnl
dnl Version: 20200712

dnl Function to detect if tests dependencies are available
AC_DEFUN([AX_TESTS_CHECK_LOCAL],
  [AC_CHECK_HEADERS([dlfcn.h])

  AC_CHECK_FUNCS([fmemopen getopt mkstemp setenv tzset unlink])

  AC_CHECK_LIB(
    dl,
    dlsym)

  AS_IF(
    [test "x$lt_cv_prog_gnu_ld" = xyes && test "x$ac_cv_lib_dl_dlsym" = xyes],
    [AC_DEFINE(
      [HAVE_GNU_DL_DLSYM],
      [1],
      [Define to 1 if dlsym function is available in GNU dl.])
  ])
])

dnl Function to detect if OSS-Fuzz build environment is available
AC_DEFUN([AX_TESTS_CHECK_OSSFUZZ],
  [AM_CONDITIONAL(
    HAVE_LIB_FUZZING_ENGINE,
    [test "x${LIB_FUZZING_ENGINE}" != x])
  AC_SUBST(
    [LIB_FUZZING_ENGINE],
    ["${LIB_FUZZING_ENGINE}"])
])


```

`m4/types.m4`:

```m4
dnl Functions for type definitions
dnl
dnl Version: 20180727

dnl Function to detect if type definitions are available
AC_DEFUN([AX_TYPES_CHECK_LOCAL],
 [AS_IF(
  [test "x$ac_cv_enable_winapi" = xyes],
  [ac_cv_enable_wide_character_type=yes])

 AS_IF(
  [test "x$ac_cv_enable_wide_character_type" = xyes],
  [AC_DEFINE(
   [HAVE_WIDE_CHARACTER_TYPE],
   [1],
   [Define to 1 if wide character type should be used.])
  AC_SUBST(
   [HAVE_WIDE_CHARACTER_TYPE],
   [1]) ],
  [AC_SUBST(
   [HAVE_WIDE_CHARACTER_TYPE],
   [0])
  ])

 AC_CHECK_HEADERS([sys/types.h inttypes.h stdint.h wchar.h])

 AS_IF(
  [test "x$ac_cv_header_sys_types_h" = xyes],
  [AC_SUBST(
   [HAVE_SYS_TYPES_H],
   [1])],
  [AC_SUBST(
   [HAVE_SYS_TYPES_H],
   [0])
  ])

 AS_IF(
  [test "x$ac_cv_header_inttypes_h" = xyes],
  [AC_SUBST(
   [HAVE_INTTYPES_H],
   [1])],
  [AC_SUBST(
   [HAVE_INTTYPES_H],
   [0])
  ])

 AS_IF(
  [test "x$ac_cv_header_stdint_h" = xyes],
  [AC_SUBST(
   [HAVE_STDINT_H],
   [1])],
  [AC_SUBST(
   [HAVE_STDINT_H],
   [0])
  ])

 AS_IF(
  [test "x$ac_cv_header_wchar_h" = xyes],
  [AC_SUBST(
   [HAVE_WCHAR_H],
   [1]) ],
  [AC_SUBST(
   [HAVE_WCHAR_H],
   [0])
  ])

 AC_TYPE_MODE_T
 AC_TYPE_OFF_T
 AC_TYPE_SIZE_T

 AC_CHECK_TYPE(
  [size32_t],
  [AC_SUBST(
   [HAVE_SIZE32_T],
   [1])],
  [AC_SUBST(
   [HAVE_SIZE32_T],
   [0])
  ])

 AC_CHECK_TYPE(
  [ssize32_t],
  [AC_SUBST(
   [HAVE_SSIZE32_T],
   [1])],
  [AC_SUBST(
   [HAVE_SSIZE32_T],
   [0])
  ])

 AC_CHECK_TYPE(
  [size64_t],
  [AC_SUBST(
   [HAVE_SIZE64_T],
   [1])],
  [AC_SUBST(
   [HAVE_SIZE64_T],
   [0])
  ])

 AC_CHECK_TYPE(
  [ssize64_t],
  [AC_SUBST(
   [HAVE_SSIZE64_T],
   [1])],
  [AC_SUBST(
   [HAVE_SSIZE64_T],
   [0])
  ])

 AC_CHECK_TYPE(
  [off64_t],
  [AC_SUBST(
   [HAVE_OFF64_T],
   [1])],
  [AC_SUBST(
   [HAVE_OFF64_T],
   [0])
  ])

 AC_CHECK_TYPE([ssize_t])
 AC_CHECK_TYPE([u64])

 AC_CHECK_SIZEOF([int])
 AC_CHECK_SIZEOF([long])
 AC_CHECK_SIZEOF([off_t])
 AC_CHECK_SIZEOF([size_t])

 AS_IF(
  [test "x$ac_cv_header_wchar_h" = xyes],
  [AC_CHECK_SIZEOF([wchar_t])])
 ])


```

`manuals/Makefile.am`:

```am
man_MANS = \
	mdmpinfo.1 \
	libmdmp.3

EXTRA_DIST = \
	mdmpinfo.1 \
	libmdmp.3

MAINTAINERCLEANFILES = \
	Makefile.in

distclean: clean
	-rm -f Makefile


```

`manuals/libmdmp.3`:

```3
.Dd April 17, 2019
.Dt libmdmp 3
.Os libmdmp
.Sh NAME
.Nm libmdmp.h
.Nd Library to access the Windows Minidump (MDMP) format
.Sh SYNOPSIS
.In libmdmp.h
.Pp
Support functions
.Ft const char *
.Fn libmdmp_get_version "void"
.Ft int
.Fn libmdmp_get_access_flags_read "void"
.Ft int
.Fn libmdmp_get_codepage "int *codepage" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_set_codepage "int codepage" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_check_file_signature "const char *filename" "libmdmp_error_t **error"
.Pp
Available when compiled with wide character string support:
.Ft int
.Fn libmdmp_check_file_signature_wide "const wchar_t *filename" "libmdmp_error_t **error"
.Pp
Available when compiled with libbfio support:
.Ft int
.Fn libmdmp_check_file_signature_file_io_handle "libbfio_handle_t *file_io_handle" "libmdmp_error_t **error"
.Pp
Notify functions
.Ft void
.Fn libmdmp_notify_set_verbose "int verbose"
.Ft int
.Fn libmdmp_notify_set_stream "FILE *stream" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_notify_stream_open "const char *filename" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_notify_stream_close "libmdmp_error_t **error"
.Pp
Error functions
.Ft void
.Fn libmdmp_error_free "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_error_fprint "libmdmp_error_t *error" "FILE *stream"
.Ft int
.Fn libmdmp_error_sprint "libmdmp_error_t *error" "char *string" "size_t size"
.Ft int
.Fn libmdmp_error_backtrace_fprint "libmdmp_error_t *error" "FILE *stream"
.Ft int
.Fn libmdmp_error_backtrace_sprint "libmdmp_error_t *error" "char *string" "size_t size"
.Pp
File functions
.Ft int
.Fn libmdmp_file_initialize "libmdmp_file_t **file" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_file_free "libmdmp_file_t **file" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_file_signal_abort "libmdmp_file_t *file" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_file_open "libmdmp_file_t *file" "const char *filename" "int access_flags" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_file_close "libmdmp_file_t *file" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_file_get_number_of_streams "libmdmp_file_t *file" "int *number_of_streams" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_file_get_stream "libmdmp_file_t *file" "int stream_index" "libmdmp_stream_t **stream" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_file_get_stream_by_type "libmdmp_file_t *file" "uint32_t stream_type" "libmdmp_stream_t **stream" "libmdmp_error_t **error"
.Pp
Available when compiled with wide character string support:
.Ft int
.Fn libmdmp_file_open_wide "libmdmp_file_t *file" "const wchar_t *filename" "int access_flags" "libmdmp_error_t **error"
.Pp
Available when compiled with libbfio support:
.Ft int
.Fn libmdmp_file_open_file_io_handle "libmdmp_file_t *file" "libbfio_handle_t *file_io_handle" "int access_flags" "libmdmp_error_t **error"
.Pp
Stream functions
.Ft int
.Fn libmdmp_stream_free "libmdmp_stream_t **stream" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_stream_get_type "libmdmp_stream_t *stream" "uint32_t *type" "libmdmp_error_t **error"
.Ft ssize_t
.Fn libmdmp_stream_read_buffer "libmdmp_stream_t *stream" "void *buffer" "size_t buffer_size" "libmdmp_error_t **error"
.Ft ssize_t
.Fn libmdmp_stream_read_buffer_at_offset "libmdmp_stream_t *stream" "void *buffer" "size_t buffer_size" "off64_t offset" "libmdmp_error_t **error"
.Ft off64_t
.Fn libmdmp_stream_seek_offset "libmdmp_stream_t *stream" "off64_t offset" "int whence" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_stream_get_offset "libmdmp_stream_t *stream" "off64_t *offset" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_stream_get_size "libmdmp_stream_t *stream" "size64_t *size" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_stream_get_start_offset "libmdmp_stream_t *stream" "off64_t *start_offset" "libmdmp_error_t **error"
.Ft int
.Fn libmdmp_stream_get_virtual_address "libmdmp_stream_t *stream" "uint32_t *virtual_address" "libmdmp_error_t **error"
.Pp
Available when compiled with libbfio support:
.Ft int
.Fn libmdmp_stream_get_data_file_io_handle "libmdmp_stream_t *stream" "libbfio_handle_t **file_io_handle" "libmdmp_error_t **error"
.Sh DESCRIPTION
The
.Fn libmdmp_get_version
function is used to retrieve the library version.
.Sh RETURN VALUES
Most of the functions return NULL or \-1 on error, dependent on the return type.
For the actual return values see "libmdmp.h".
.Sh ENVIRONMENT
None
.Sh FILES
None
.Sh NOTES
libmdmp can be compiled with wide character support (wchar_t).
.sp
To compile libmdmp with wide character support use:
.Ar ./configure --enable-wide-character-type=yes
 or define:
.Ar _UNICODE
 or
.Ar UNICODE
 during compilation.
.sp
.Ar LIBMDMP_WIDE_CHARACTER_TYPE
 in libmdmp/features.h can be used to determine if libmdmp was compiled with wide character support.
.Sh BUGS
Please report bugs of any kind on the project issue tracker: https://github.com/libyal/libmdmp/issues
.Sh AUTHOR
These man pages are generated from "libmdmp.h".
.Sh COPYRIGHT
Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>.
.sp
This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
.Sh SEE ALSO
the libmdmp.h include file

```

`manuals/mdmpinfo.1`:

```1
.Dd April 17, 2019
.Dt mdmpinfo
.Os libmdmp
.Sh NAME
.Nm mdmpinfo
.Nd determines information about a Windows Minidump (MDMP) file
.Sh SYNOPSIS
.Nm mdmpinfo
.Op Fl ahvV
.Ar source
.Sh DESCRIPTION
.Nm mdmpinfo
is a utility to determine information about a Windows Minidump (MDMP) file
.Pp
.Nm mdmpinfo
is part of the
.Nm libmdmp
package.
.Nm libmdmp
is a library to access the Windows Minidump (MDMP) file format
.Pp
.Ar source
is the source file.
.Pp
The options are as follows:
.Bl -tag -width Ds
.It Fl a
shows allocation information
.It Fl h
shows this help
.It Fl v
verbose output to stderr
.It Fl V
print version
.El
.Sh ENVIRONMENT
None
.Sh FILES
None
.Sh EXAMPLES
.Bd -literal
# mdmpinfo WERC843.tmp.mdmp
mdmpinfo 20140402
.sp
Windows Minidump (MDMP) file information:
	...
.sp
.Ed
.Sh DIAGNOSTICS
Errors, verbose and debug output are printed to stderr when verbose output \-v is enabled.
Verbose and debug output are only printed when enabled at compilation.
.Sh BUGS
Please report bugs of any kind to <joachim.metz@gmail.com> or on the project website:
https://github.com/libyal/libmdmp/
.Sh AUTHOR
These man pages were written by Joachim Metz.
.Sh COPYRIGHT
Copyright 2014, Joachim Metz <joachim.metz@gmail.com>.
This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
.Sh SEE ALSO

```

`mdmptools/Makefile.am`:

```am
AM_CPPFLAGS = \
	-I$(top_srcdir)/include \
	-I$(top_srcdir)/common \
	@LIBCERROR_CPPFLAGS@ \
	@LIBCDATA_CPPFLAGS@ \
	@LIBCLOCALE_CPPFLAGS@ \
	@LIBCNOTIFY_CPPFLAGS@ \
	@LIBCSPLIT_CPPFLAGS@ \
	@LIBUNA_CPPFLAGS@ \
	@LIBCFILE_CPPFLAGS@ \
	@LIBCPATH_CPPFLAGS@ \
	@LIBBFIO_CPPFLAGS@ \
	@LIBFDATETIME_CPPFLAGS@ \
	@LIBMDMP_DLL_IMPORT@

AM_LDFLAGS = @STATIC_LDFLAGS@

bin_PROGRAMS = \
	mdmpinfo

mdmpinfo_SOURCES = \
	info_handle.c info_handle.h \
	mdmpinfo.c \
	mdmpinput.c mdmpinput.h \
	mdmptools_getopt.c mdmptools_getopt.h \
	mdmptools_i18n.h \
	mdmptools_libbfio.h \
	mdmptools_libcerror.h \
	mdmptools_libclocale.h \
	mdmptools_libcnotify.h \
	mdmptools_libmdmp.h \
	mdmptools_libuna.h \
	mdmptools_signal.c mdmptools_signal.h \
	mdmptools_output.c mdmptools_output.h \
	mdmptools_unused.h

mdmpinfo_LDADD = \
	@LIBCNOTIFY_LIBADD@ \
	@LIBCLOCALE_LIBADD@ \
	../libmdmp/libmdmp.la \
	@LIBCERROR_LIBADD@ \
	@LIBINTL@

MAINTAINERCLEANFILES = \
	Makefile.in

distclean: clean
	-rm -f Makefile

splint-local:
	@echo "Running splint on mdmpinfo ..."
	-splint -preproc -redef $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(mdmpinfo_SOURCES)


```

`mdmptools/info_handle.c`:

```c
/*
 * Info handle
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <memory.h>
#include <types.h>

#include "info_handle.h"
#include "mdmpinput.h"
#include "mdmptools_libcerror.h"
#include "mdmptools_libmdmp.h"

#define INFO_HANDLE_NOTIFY_STREAM	stdout

/* Returns a string with the stream type description
 */
const char *info_handle_get_stream_type(
             uint32_t stream_type )
{
	switch( stream_type )
	{
		case 0:
			return( "UnusedStream" );
		case 1:
			return( "ReservedStream0" );
		case 2:
			return( "ReservedStream1" );
		case 3:
			return( "ThreadListStream" );
		case 4:
			return( "ModuleListStream" );
		case 5:
			return( "MemoryListStream" );
		case 6:
			return( "ExceptionStream" );
		case 7:
			return( "SystemInfoStream" );
		case 8:
			return( "ThreadExListStream" );
		case 9:
			return( "Memory64ListStream" );
		case 10:
			return( "CommentStreamA" );
		case 11:
			return( "CommentStreamW" );
		case 12:
			return( "HandleDataStream" );
		case 13:
			return( "FunctionTableStream" );
		case 14:
			return( "UnloadedModuleListStream" );
		case 15:
			return( "MiscInfoStream" );
		case 16:
			return( "MemoryInfoListStream" );
		case 17:
			return( "ThreadInfoListStream" );
		case 18:
			return( "HandleOperationListStream" );

		default:
			break;
	}
	return( "UNKNOWN" );
}

/* Creates an info handle
 * Make sure the value info_handle is referencing, is set to NULL
 * Returns 1 if successful or -1 on error
 */
int info_handle_initialize(
     info_handle_t **info_handle,
     libcerror_error_t **error )
{
	static char *function = "info_handle_initialize";

	if( info_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid info handle.",
		 function );

		return( -1 );
	}
	if( *info_handle != NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,
		 "%s: invalid info handle value already set.",
		 function );

		return( -1 );
	}
	*info_handle = memory_allocate_structure(
	                info_handle_t );

	if( *info_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,
		 "%s: unable to create info handle.",
		 function );

		goto on_error;
	}
	if( memory_set(
	     *info_handle,
	     0,
	     sizeof( info_handle_t ) ) == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_SET_FAILED,
		 "%s: unable to clear info handle.",
		 function );

		goto on_error;
	}
	if( libmdmp_file_initialize(
	     &( ( *info_handle )->input_file ),
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to initialize input file.",
		 function );

		goto on_error;
	}
	( *info_handle )->notify_stream = INFO_HANDLE_NOTIFY_STREAM;

	return( 1 );

on_error:
	if( *info_handle != NULL )
	{
		memory_free(
		 *info_handle );

		*info_handle = NULL;
	}
	return( -1 );
}

/* Frees an info handle
 * Returns 1 if successful or -1 on error
 */
int info_handle_free(
     info_handle_t **info_handle,
     libcerror_error_t **error )
{
	static char *function = "info_handle_free";
	int result            = 1;

	if( info_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid info handle.",
		 function );

		return( -1 );
	}
	if( *info_handle != NULL )
	{
		if( ( *info_handle )->input_file != NULL )
		{
			if( libmdmp_file_free(
			     &( ( *info_handle )->input_file ),
			     error ) != 1 )
			{
				libcerror_error_set(
				 error,
				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
				 LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,
				 "%s: unable to free input file.",
				 function );

				result = -1;
			}
		}
		memory_free(
		 *info_handle );

		*info_handle = NULL;
	}
	return( result );
}

/* Signals the info handle to abort
 * Returns 1 if successful or -1 on error
 */
int info_handle_signal_abort(
     info_handle_t *info_handle,
     libcerror_error_t **error )
{
	static char *function = "info_handle_signal_abort";

	if( info_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid info handle.",
		 function );

		return( -1 );
	}
	info_handle->abort = 1;

	if( info_handle->input_file != NULL )
	{
		if( libmdmp_file_signal_abort(
		     info_handle->input_file,
		     error ) != 1 )
		{
			libcerror_error_set(
			 error,
			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
			 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
			 "%s: unable to signal input file to abort.",
			 function );

			return( -1 );
		}
	}
	return( 1 );
}

/* Sets the ascii codepage
 * Returns 1 if successful or -1 on error
 */
int info_handle_set_ascii_codepage(
     info_handle_t *info_handle,
     const system_character_t *string,
     libcerror_error_t **error )
{
	static char *function = "info_handle_set_ascii_codepage";
	int result            = 0;

	if( info_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid info handle.",
		 function );

		return( -1 );
	}
	result = mdmpinput_determine_ascii_codepage(
	          string,
	          &( info_handle->ascii_codepage ),
	          error );

	if( result == -1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to determine ASCII codepage.",
		 function );

		return( -1 );
	}
	return( result );
}

/* Opens the input
 * Returns 1 if successful or -1 on error
 */
int info_handle_open_input(
     info_handle_t *info_handle,
     const system_character_t *filename,
     libcerror_error_t **error )
{
	static char *function = "info_handle_open_input";

	if( info_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid info handle.",
		 function );

		return( -1 );
	}
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
	if( libmdmp_file_open_wide(
	     info_handle->input_file,
	     filename,
	     LIBMDMP_OPEN_READ,
	     error ) != 1 )
#else
	if( libmdmp_file_open(
	     info_handle->input_file,
	     filename,
	     LIBMDMP_OPEN_READ,
	     error ) != 1 )
#endif
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_OPEN_FAILED,
		 "%s: unable to open input file.",
		 function );

		return( -1 );
	}
	return( 1 );
}

/* Closes the input
 * Returns the 0 if succesful or -1 on error
 */
int info_handle_close_input(
     info_handle_t *info_handle,
     libcerror_error_t **error )
{
	static char *function = "info_handle_close_input";

	if( info_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid info handle.",
		 function );

		return( -1 );
	}
	if( libmdmp_file_close(
	     info_handle->input_file,
	     error ) != 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_CLOSE_FAILED,
		 "%s: unable to close input file.",
		 function );

		return( -1 );
	}
	return( 0 );
}

/* Prints the file information
 * Returns 1 if successful or -1 on error
 */
int info_handle_file_fprint(
     info_handle_t *info_handle,
     libcerror_error_t **error )
{
	libmdmp_stream_t *stream = NULL;
	static char *function    = "info_handle_file_fprint";
	off64_t start_offset     = 0;
	size64_t size            = 0;
	uint32_t stream_type     = 0;
	int number_of_streams    = 0;
	int stream_index         = 0;

	if( info_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid info handle.",
		 function );

		return( -1 );
	}
	if( libmdmp_file_get_number_of_streams(
	     info_handle->input_file,
	     &number_of_streams,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
		 "%s: unable to retrieve number of streams.",
		 function );

		goto on_error;
	}
	fprintf(
	 info_handle->notify_stream,
	 "Windows Minidump (MDMP) file information:\n" );

	fprintf(
	 info_handle->notify_stream,
	 "\tNumber of streams\t: %d\n",
	 number_of_streams );

	fprintf(
	 info_handle->notify_stream,
	 "\n" );

	if( number_of_streams > 0 )
	{
		for( stream_index = 0;
		     stream_index < number_of_streams;
		     stream_index++ )
		{
			fprintf(
			 info_handle->notify_stream,
			 "Stream: %d\n",
			 stream_index );

			if( libmdmp_file_get_stream(
			     info_handle->input_file,
			     stream_index,
			     &stream,
			     error ) != 1 )
			{
				libcerror_error_set(
				 error,
				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
				 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
				 "%s: unable to retrieve stream: %d.",
				 function,
				 stream_index );

				goto on_error;
			}
			if( libmdmp_stream_get_type(
			     stream,
			     &stream_type,
			     error ) != 1 )
			{
				libcerror_error_set(
				 error,
				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
				 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
				 "%s: unable to retrieve stream: %d type.",
				 function,
				 stream_index );

				goto on_error;
			}
			fprintf(
			 info_handle->notify_stream,
			 "\tType\t\t\t: %s (%" PRIu32 ")\n",
			 info_handle_get_stream_type(
			  stream_type ),
			 stream_type );

			if( libmdmp_stream_get_start_offset(
			     stream,
			     &start_offset,
			     error ) != 1 )
			{
				libcerror_error_set(
				 error,
				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
				 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
				 "%s: unable to retrieve stream: %d start offset.",
				 function,
				 stream_index );

				goto on_error;
			}
			fprintf(
			 info_handle->notify_stream,
			 "\tStart offset\t\t: 0x%08" PRIx64 "\n",
			 start_offset );

			if( libmdmp_stream_get_size(
			     stream,
			     &size,
			     error ) != 1 )
			{
				libcerror_error_set(
				 error,
				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
				 LIBCERROR_RUNTIME_ERROR_GET_FAILED,
				 "%s: unable to retrieve stream: %d size.",
				 function,
				 stream_index );

				goto on_error;
			}
			fprintf(
			 info_handle->notify_stream,
			 "\tSize\t\t\t: %" PRIu64 "\n",
			 size );

			if( libmdmp_stream_free(
			     &stream,
			     error ) != 1 )
			{
				libcerror_error_set(
				 error,
				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
				 LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,
				 "%s: unable to free stream.",
				 function );

				goto on_error;
			}
			fprintf(
			 info_handle->notify_stream,
			 "\n" );
		}
	}
	return( 1 );

on_error:
	if( stream != NULL )
	{
		libmdmp_stream_free(
		 &stream,
		 NULL );
	}
	return( -1 );
}


```

`mdmptools/info_handle.h`:

```h
/*
 * Info handle
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _INFO_HANDLE_H )
#define _INFO_HANDLE_H

#include <common.h>
#include <file_stream.h>
#include <types.h>

#include "mdmptools_libcerror.h"
#include "mdmptools_libmdmp.h"

#if defined( __cplusplus )
extern "C" {
#endif

typedef struct info_handle info_handle_t;

struct info_handle
{
	/* The libmdmp input file
	 */
	libmdmp_file_t *input_file;

	/* The ascii codepage
	 */
	int ascii_codepage;

	/* The notification output stream
	 */
	FILE *notify_stream;

	/* Value to indicate if abort was signalled
	 */
	int abort;
};

const char *info_handle_get_stream_type(
             uint32_t stream_type );

int info_handle_initialize(
     info_handle_t **info_handle,
     libcerror_error_t **error );

int info_handle_free(
     info_handle_t **info_handle,
     libcerror_error_t **error );

int info_handle_signal_abort(
     info_handle_t *info_handle,
     libcerror_error_t **error );

int info_handle_set_ascii_codepage(
     info_handle_t *info_handle,
     const system_character_t *string,
     libcerror_error_t **error );

int info_handle_open_input(
     info_handle_t *info_handle,
     const system_character_t *filename,
     libcerror_error_t **error );

int info_handle_close_input(
     info_handle_t *info_handle,
     libcerror_error_t **error );

int info_handle_file_fprint(
     info_handle_t *info_handle,
     libcerror_error_t **error );

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _INFO_HANDLE_H ) */


```

`mdmptools/mdmpinfo.c`:

```c
/*
 * Shows information obtained from a Windows Minidump (MDMP) file
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <memory.h>
#include <system_string.h>
#include <types.h>

#if defined( HAVE_UNISTD_H )
#include <unistd.h>
#endif

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "info_handle.h"
#include "mdmptools_getopt.h"
#include "mdmptools_libcerror.h"
#include "mdmptools_libclocale.h"
#include "mdmptools_libcnotify.h"
#include "mdmptools_libmdmp.h"
#include "mdmptools_output.h"
#include "mdmptools_signal.h"
#include "mdmptools_unused.h"

info_handle_t *mdmpinfo_info_handle = NULL;
int mdmpinfo_abort                  = 0;

/* Prints the executable usage information
 */
void usage_fprint(
      FILE *stream )
{
	if( stream == NULL )
	{
		return;
	}
	fprintf( stream, "Use mdmpinfo to determine information about a Windows\n"
	                 "Minidump (MDMP) file.\n\n" );

	fprintf( stream, "Usage: mdmpinfo [ -hvV ] source\n\n" );

	fprintf( stream, "\tsource: the source file\n\n" );

	fprintf( stream, "\t-h:     shows this help\n" );
	fprintf( stream, "\t-v:     verbose output to stderr\n" );
	fprintf( stream, "\t-V:     print version\n" );
}

/* Signal handler for mdmpinfo
 */
void mdmpinfo_signal_handler(
      mdmptools_signal_t signal MDMPTOOLS_ATTRIBUTE_UNUSED )
{
	libcerror_error_t *error = NULL;
	static char *function   = "mdmpinfo_signal_handler";

	MDMPTOOLS_UNREFERENCED_PARAMETER( signal )

	mdmpinfo_abort = 1;

	if( mdmpinfo_info_handle != NULL )
	{
		if( info_handle_signal_abort(
		     mdmpinfo_info_handle,
		     &error ) != 1 )
		{
			libcnotify_printf(
			 "%s: unable to signal info handle to abort.\n",
			 function );

			libcnotify_print_error_backtrace(
			 error );
			libcerror_error_free(
			 &error );
		}
	}
	/* Force stdin to close otherwise any function reading it will remain blocked
	 */
#if defined( WINAPI ) && !defined( __CYGWIN__ )
	if( _close(
	     0 ) != 0 )
#else
	if( close(
	     0 ) != 0 )
#endif
	{
		libcnotify_printf(
		 "%s: unable to close stdin.\n",
		 function );
	}
}

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain( int argc, wchar_t * const argv[] )
#else
int main( int argc, char * const argv[] )
#endif
{
	libcerror_error_t *error   = NULL;
	system_character_t *source = NULL;
	char *program              = "mdmpinfo";
	system_integer_t option    = 0;
	int verbose                = 0;

	libcnotify_stream_set(
	 stderr,
	 NULL );
	libcnotify_verbose_set(
	 1 );

	if( libclocale_initialize(
	     "mdmptools",
	     &error ) != 1 )
	{
		fprintf(
		 stderr,
		 "Unable to initialize locale values.\n" );

		goto on_error;
	}
	if( mdmptools_output_initialize(
	     _IONBF,
	     &error ) != 1 )
	{
		fprintf(
		 stderr,
		 "Unable to initialize output settings.\n" );

		goto on_error;
	}
	mdmptools_output_version_fprint(
	 stdout,
	 program );

	while( ( option = mdmptools_getopt(
	                   argc,
	                   argv,
	                   _SYSTEM_STRING( "hvV" ) ) ) != (system_integer_t) -1 )
	{
		switch( option )
		{
			case (system_integer_t) '?':
			default:
				fprintf(
				 stderr,
				 "Invalid argument: %" PRIs_SYSTEM "\n",
				 argv[ optind - 1 ] );

				usage_fprint(
				 stdout );

				return( EXIT_FAILURE );

			case (system_integer_t) 'h':
				usage_fprint(
				 stdout );

				return( EXIT_SUCCESS );

			case (system_integer_t) 'v':
				verbose = 1;

				break;

			case (system_integer_t) 'V':
				mdmptools_output_copyright_fprint(
				 stdout );

				return( EXIT_SUCCESS );
		}
	}
	if( optind == argc )
	{
		fprintf(
		 stderr,
		 "Missing source file.\n" );

		usage_fprint(
		 stdout );

		return( EXIT_FAILURE );
	}
	source = argv[ optind ];

	libcnotify_verbose_set(
	 verbose );
	libmdmp_notify_set_stream(
	 stderr,
	 NULL );
	libmdmp_notify_set_verbose(
	 verbose );

	if( info_handle_initialize(
	     &mdmpinfo_info_handle,
	     &error ) != 1 )
	{
		fprintf(
		 stderr,
		 "Unable to initialize info handle.\n" );

		goto on_error;
	}
	if( info_handle_open_input(
	     mdmpinfo_info_handle,
	     source,
	     &error ) != 1 )
	{
		fprintf(
		 stderr,
		 "Unable to open: %" PRIs_SYSTEM ".\n",
		 source );

		goto on_error;
	}
	if( info_handle_file_fprint(
	     mdmpinfo_info_handle,
	     &error ) != 1 )
	{
		fprintf(
		 stderr,
		 "Unable to print file information.\n" );

		goto on_error;
	}
	if( info_handle_close_input(
	     mdmpinfo_info_handle,
	     &error ) != 0 )
	{
		fprintf(
		 stderr,
		 "Unable to close info handle.\n" );

		goto on_error;
	}
	if( info_handle_free(
	     &mdmpinfo_info_handle,
	     &error ) != 1 )
	{
		fprintf(
		 stderr,
		 "Unable to free info handle.\n" );

		goto on_error;
	}
	return( EXIT_SUCCESS );

on_error:
	if( error != NULL )
	{
		libcnotify_print_error_backtrace(
		 error );
		libcerror_error_free(
		 &error );
	}
	if( mdmpinfo_info_handle != NULL )
	{
		info_handle_free(
		 &mdmpinfo_info_handle,
		 NULL );
	}
	return( EXIT_FAILURE );
}


```

`mdmptools/mdmpinput.c`:

```c
/*
 * Common input functions for the mdmptools
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <narrow_string.h>
#include <system_string.h>
#include <types.h>
#include <wide_string.h>

#include "mdmpinput.h"
#include "mdmptools_libcerror.h"
#include "mdmptools_libmdmp.h"

/* Determines the codepage from a string
 * Returns 1 if successful, 0 if unsupported value or -1 on error
 */
int mdmpinput_determine_ascii_codepage(
     const system_character_t *string,
     int *ascii_codepage,
     libcerror_error_t **error )
{
	static char *function = "mdmpinput_determine_ascii_codepage";
	size_t string_length  = 0;
	int result            = 0;

	if( string == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid string.",
		 function );

		return( -1 );
	}
	if( ascii_codepage == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid ASCII codepage.",
		 function );

		return( -1 );
	}
	string_length = system_string_length(
	                 string );

	if( string_length == 5 )
	{
		if( system_string_compare(
		     string,
		     _SYSTEM_STRING( "ascii" ),
		     5 ) == 0 )
		{
			*ascii_codepage = LIBMDMP_CODEPAGE_ASCII;
			result          = 1;
		}
	}
#if defined( HAVE_ISO_CODEPAGES )
	if( ( string_length == 10 )
	 || ( string_length == 11 ) )
	{
		if( system_string_compare(
		     string,
		     _SYSTEM_STRING( "iso" ),
		     3 ) == 0 )
		{
			if( ( string[ 3 ] != '-' )
			 && ( string[ 3 ] != '_' ) )
			{
			}
			else if( system_string_compare(
				  &( string[ 4 ] ),
				  _SYSTEM_STRING( "8859" ),
				  4 ) == 0 )
			{
				if( ( string[ 8 ] != '-' )
				 && ( string[ 8 ] != '_' ) )
				{
				}
				else if( string_length == 10 )
				{
					if( system_string_compare(
					     &( string[ 9 ] ),
					     _SYSTEM_STRING( "1" ),
					     1 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_1;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "2" ),
						  1 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_2;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "3" ),
						  1 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_3;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "4" ),
						  1 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_4;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "5" ),
						  1 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_5;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "6" ),
						  1 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_6;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "7" ),
						  1 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_7;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "8" ),
						  1 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_8;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "9" ),
						  1 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_9;
						result          = 1;
					}
				}
				else if( string_length == 11 )
				{
					if( system_string_compare(
					     &( string[ 9 ] ),
					     _SYSTEM_STRING( "10" ),
					     2 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_10;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "11" ),
						  2 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_11;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "13" ),
						  2 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_13;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "14" ),
						  2 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_14;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "15" ),
						  2 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_15;
						result          = 1;
					}
					else if( system_string_compare(
						  &( string[ 9 ] ),
						  _SYSTEM_STRING( "16" ),
						  2 ) == 0 )
					{
						*ascii_codepage = LIBMDMP_CODEPAGE_ISO_8859_16;
						result          = 1;
					}
				}
			}
		}
	}
#endif
	if( ( string_length == 11 )
	 || ( string_length == 12 ) )
	{
		if( system_string_compare(
		     string,
		     _SYSTEM_STRING( "windows" ),
		     7 ) == 0 )
		{
			if( ( string[ 7 ] != '-' )
			 && ( string[ 7 ] != '_' ) )
			{
			}
			else if( string_length == 11 )
			{
				if( system_string_compare(
				     &( string[ 8 ] ),
				     _SYSTEM_STRING( "874" ),
				     3 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_874;
					result          = 1;
				}
				else if( system_string_compare(
				          &( string[ 8 ] ),
				          _SYSTEM_STRING( "932" ),
				          3 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_932;
					result          = 1;
				}
				else if( system_string_compare(
				          &( string[ 8 ] ),
				          _SYSTEM_STRING( "936" ),
				          3 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_936;
					result          = 1;
				}
			}
			else if( string_length == 12 )
			{
				if( system_string_compare(
				     &( string[ 8 ] ),
				     _SYSTEM_STRING( "1250" ),
				     4 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_1250;
					result          = 1;
				}
				else if( system_string_compare(
					  &( string[ 8 ] ),
					  _SYSTEM_STRING( "1251" ),
					  4 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_1251;
					result          = 1;
				}
				else if( system_string_compare(
					  &( string[ 8 ] ),
					  _SYSTEM_STRING( "1252" ),
					  4 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_1252;
					result          = 1;
				}
				else if( system_string_compare(
					  &( string[ 8 ] ),
					  _SYSTEM_STRING( "1253" ),
					  4 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_1253;
					result          = 1;
				}
				else if( system_string_compare(
					  &( string[ 8 ] ),
					  _SYSTEM_STRING( "1253" ),
					  4 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_1253;
					result          = 1;
				}
				else if( system_string_compare(
					  &( string[ 8 ] ),
					  _SYSTEM_STRING( "1254" ),
					  4 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_1254;
					result          = 1;
				}
				else if( system_string_compare(
					  &( string[ 8 ] ),
					  _SYSTEM_STRING( "1255" ),
					  4 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_1255;
					result          = 1;
				}
				else if( system_string_compare(
					  &( string[ 8 ] ),
					  _SYSTEM_STRING( "1256" ),
					  4 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_1256;
					result          = 1;
				}
				else if( system_string_compare(
					  &( string[ 8 ] ),
					  _SYSTEM_STRING( "1257" ),
					  4 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_1257;
					result          = 1;
				}
				else if( system_string_compare(
					  &( string[ 8 ] ),
					  _SYSTEM_STRING( "1258" ),
					  4 ) == 0 )
				{
					*ascii_codepage = LIBMDMP_CODEPAGE_WINDOWS_1258;
					result          = 1;
				}
			}
		}
	}
	return( result );
}


```

`mdmptools/mdmpinput.h`:

```h
/*
 * Common input functions for the mdmptools
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMPINPUT_H )
#define _MDMPINPUT_H

#include <common.h>
#include <types.h>

#include "mdmptools_libcerror.h"

#if defined( __cplusplus )
extern "C" {
#endif

int mdmpinput_determine_ascii_codepage(
     const system_character_t *string,
     int *ascii_codepage,
     libcerror_error_t **error );

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _MDMPINPUT_H ) */


```

`mdmptools/mdmptools_getopt.c`:

```c
/*
 * GetOpt functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <narrow_string.h>
#include <system_string.h>
#include <types.h>
#include <wide_string.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmptools_getopt.h"
#include "mdmptools_libcnotify.h"

#if !defined( HAVE_GETOPT )

/* The option index
 * Start with argument 1 (argument 0 is the program name)
 */
int optind = 1;

/* The current option argument
 */
system_character_t *optarg = NULL;

/* Value to indicate the current option
 */
system_integer_t optopt = 0;

/* The next option in a group
 */
system_character_t *next_option = NULL;

/* Get the program options
 * Function for platforms that do not have the getopt function
 * Returns the option character processed, or -1 on error,
 * ? if the option was not in the options string, : if the option argument was missing
 */
system_integer_t mdmptools_getopt(
                  int argument_count,
                  system_character_t * const argument_values[],
                  const system_character_t *options_string )
{
	system_character_t *argument_value = NULL;
	system_character_t *option_value   = NULL;
	static char *function              = "mdmptools_getopt";
	size_t options_string_length       = 0;

	if( next_option != NULL )
	{
		argument_value = next_option;
		next_option    = NULL;
	}
	else if( optind >= argument_count )
	{
		return( (system_integer_t) -1 );
	}
	else
	{
		argument_value = argument_values[ optind ];

		/* Check if the argument value is not an empty string
		 */
		if( *argument_value == (system_character_t) '\0' )
		{
			return( (system_integer_t) -1 );
		}
		/* Check if the first character is a option marker '-'
		 */
		if( *argument_value != (system_character_t) '-' )
		{
			return( (system_integer_t) -1 );
		}
		argument_value++;

		/* Check if long options are provided '--'
		 */
		if( *argument_value == (system_character_t) '-' )
		{
			optind++;

			return( (system_integer_t) -1 );
		}
	}
	options_string_length = system_string_length(
	                         options_string );

	optopt       = *argument_value;
	option_value = system_string_search_character(
	                options_string,
	                optopt,
	                options_string_length );

	argument_value++;

	/* Check if an argument was specified or that the option was not found
	 * in the option string
	 */
	if( ( optopt == (system_integer_t) ':' )
	 || ( option_value == NULL ) )
	{
		if( *argument_value == (system_character_t) '\0' )
		{
			optind++;
		}
		if( ( *options_string != (system_character_t) ':' )
		 && ( optopt != (system_integer_t) '?' ) )
		{
			libcnotify_printf(
			 "%s: no such option: %" PRIc_SYSTEM ".\n",
			 function,
			 optopt );
		}
		return( (system_integer_t) '?' );
	}
	option_value++;

	/* Check if no option argument is required
	 */
	if( *option_value != (system_character_t) ':' )
	{
		optarg = NULL;

		if( *argument_value == (system_character_t) '\0' )
		{
			optind++;
		}
		else
		{
			/* Multiple options are grouped
			 */
			next_option = argument_value;
		}
	}
	/* Check if the argument is right after the option flag with no space in between
	 */
	else if( *argument_value != (system_character_t) '\0' )
	{
		optarg = argument_value;

		optind++;
	}
	else
	{
		optind++;

		/* Check if the argument was provided as the next argument value
		 */
		if( argument_count <= optind )
		{
			if( *option_value == ':' )
			{
				return( (system_integer_t) ':' );
			}
			libcnotify_printf(
			 "%s: option: %" PRIc_SYSTEM " requires an argument.\n",
			 function,
			 optopt );

			return( (system_integer_t) '?' );
		}
		optarg = argument_values[ optind ];

		optind++;
	}
	return( optopt );
}

#endif /* !defined( HAVE_GETOPT ) */


```

`mdmptools/mdmptools_getopt.h`:

```h
/*
 * GetOpt functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMPTOOLS_GETOPT_H )
#define _MDMPTOOLS_GETOPT_H

#include <common.h>
#include <types.h>

/* unistd.h is included here to export getopt, optarg, optind and optopt
 */
#if defined( HAVE_UNISTD_H )
#include <unistd.h>
#endif

#if defined( __cplusplus )
extern "C" {
#endif

#if defined( HAVE_GETOPT )
#define mdmptools_getopt( argument_count, argument_values, options_string ) \
	getopt( argument_count, argument_values, options_string )

#else

#if !defined( __CYGWIN__ )
extern int optind;
extern system_character_t *optarg;
extern system_integer_t optopt;

#else
int optind;
system_character_t *optarg;
system_integer_t optopt;

#endif /* !defined( __CYGWIN__ ) */

system_integer_t mdmptools_getopt(
                  int argument_count,
                  system_character_t * const argument_values[],
                  const system_character_t *options_string );

#endif /* defined( HAVE_GETOPT ) */

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _MDMPTOOLS_GETOPT_H ) */


```

`mdmptools/mdmptools_i18n.h`:

```h
/*
 * Internationalization (i18n) functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMPTOOLS_I18N_H )
#define _MDMPTOOLS_I18N_H

#include <common.h>

#if defined( HAVE_LIBINTL_H )
#include <libintl.h>
#endif

#if defined( __cplusplus )
extern "C" {
#endif

/* TODO for now do nothing i18n-like
#define	_( string ) \
	gettext( string )
*/

#define	_( string ) \
	string

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _MDMPTOOLS_I18N_H ) */


```

`mdmptools/mdmptools_libbfio.h`:

```h
/*
 * The libbfio header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMPTOOLS_LIBBFIO_H )
#define _MDMPTOOLS_LIBBFIO_H

#include <common.h>

/* Define HAVE_LOCAL_LIBBFIO for local use of libbfio
 */
#if defined( HAVE_LOCAL_LIBBFIO )

#include <libbfio_definitions.h>
#include <libbfio_file.h>
#include <libbfio_file_pool.h>
#include <libbfio_file_range.h>
#include <libbfio_handle.h>
#include <libbfio_memory_range.h>
#include <libbfio_pool.h>
#include <libbfio_types.h>

#else

/* If libtool DLL support is enabled set LIBBFIO_DLL_IMPORT
 * before including libbfio.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT ) && !defined( HAVE_STATIC_EXECUTABLES )
#define LIBBFIO_DLL_IMPORT
#endif

#include <libbfio.h>

#if defined( HAVE_MULTI_THREAD_SUPPORT ) && !defined( LIBBFIO_HAVE_MULTI_THREAD_SUPPORT )
#error Multi-threading support requires libbfio with multi-threading support
#endif

#endif /* defined( HAVE_LOCAL_LIBBFIO ) */

#endif /* !defined( _MDMPTOOLS_LIBBFIO_H ) */


```

`mdmptools/mdmptools_libcerror.h`:

```h
/*
 * The libcerror header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMPTOOLS_LIBCERROR_H )
#define _MDMPTOOLS_LIBCERROR_H

#include <common.h>

/* Define HAVE_LOCAL_LIBCERROR for local use of libcerror
 */
#if defined( HAVE_LOCAL_LIBCERROR )

#include <libcerror_definitions.h>
#include <libcerror_error.h>
#include <libcerror_system.h>
#include <libcerror_types.h>

#else

/* If libtool DLL support is enabled set LIBCERROR_DLL_IMPORT
 * before including libcerror.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT ) && !defined( HAVE_STATIC_EXECUTABLES )
#define LIBCERROR_DLL_IMPORT
#endif

#include <libcerror.h>

#endif /* defined( HAVE_LOCAL_LIBCERROR ) */

#endif /* !defined( _MDMPTOOLS_LIBCERROR_H ) */


```

`mdmptools/mdmptools_libclocale.h`:

```h
/*
 * The libclocale header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMPTOOLS_LIBCLOCALE_H )
#define _MDMPTOOLS_LIBCLOCALE_H

#include <common.h>

/* Define HAVE_LOCAL_LIBCLOCALE for local use of libclocale
 */
#if defined( HAVE_LOCAL_LIBCLOCALE )

#include <libclocale_codepage.h>
#include <libclocale_definitions.h>
#include <libclocale_locale.h>
#include <libclocale_support.h>

#else

/* If libtool DLL support is enabled set LIBCLOCALE_DLL_IMPORT
 * before including libclocale.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT ) && !defined( HAVE_STATIC_EXECUTABLES )
#define LIBCLOCALE_DLL_IMPORT
#endif

#include <libclocale.h>

#endif /* defined( HAVE_LOCAL_LIBCLOCALE ) */

#endif /* !defined( _MDMPTOOLS_LIBCLOCALE_H ) */


```

`mdmptools/mdmptools_libcnotify.h`:

```h
/*
 * The libcnotify header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMPTOOLS_LIBCNOTIFY_H )
#define _MDMPTOOLS_LIBCNOTIFY_H

#include <common.h>

/* Define HAVE_LOCAL_LIBCNOTIFY for local use of libcnotify
 */
#if defined( HAVE_LOCAL_LIBCNOTIFY )

#include <libcnotify_definitions.h>
#include <libcnotify_print.h>
#include <libcnotify_stream.h>
#include <libcnotify_verbose.h>

#else

/* If libtool DLL support is enabled set LIBCNOTIFY_DLL_IMPORT
 * before including libcnotify.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT ) && !defined( HAVE_STATIC_EXECUTABLES )
#define LIBCNOTIFY_DLL_IMPORT
#endif

#include <libcnotify.h>

#endif /* defined( HAVE_LOCAL_LIBCNOTIFY ) */

#endif /* !defined( _MDMPTOOLS_LIBCNOTIFY_H ) */


```

`mdmptools/mdmptools_libmdmp.h`:

```h
/*
 * The libmdmp header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMPTOOLS_LIBMDMP_H )
#define _MDMPTOOLS_LIBMDMP_H

#include <common.h>

#include <libmdmp.h>

#endif /* !defined( _MDMPTOOLS_LIBMDMP_H ) */


```

`mdmptools/mdmptools_libuna.h`:

```h
/*
 * The libuna header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMPTOOLS_LIBUNA_H )
#define _MDMPTOOLS_LIBUNA_H

#include <common.h>

/* Define HAVE_LOCAL_LIBUNA for local use of libuna
 */
#if defined( HAVE_LOCAL_LIBUNA )

#include <libuna_base16_stream.h>
#include <libuna_base32_stream.h>
#include <libuna_base64_stream.h>
#include <libuna_byte_stream.h>
#include <libuna_unicode_character.h>
#include <libuna_url_stream.h>
#include <libuna_utf16_stream.h>
#include <libuna_utf16_string.h>
#include <libuna_utf32_stream.h>
#include <libuna_utf32_string.h>
#include <libuna_utf7_stream.h>
#include <libuna_utf8_stream.h>
#include <libuna_utf8_string.h>
#include <libuna_types.h>

#else

/* If libtool DLL support is enabled set LIBUNA_DLL_IMPORT
 * before including libuna.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT ) && !defined( HAVE_STATIC_EXECUTABLES )
#define LIBUNA_DLL_IMPORT
#endif

#include <libuna.h>

#endif /* defined( HAVE_LOCAL_LIBUNA ) */

#endif /* !defined( _MDMPTOOLS_LIBUNA_H ) */


```

`mdmptools/mdmptools_output.c`:

```c
/*
 * Common output functions for the mdmptools
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <memory.h>
#include <types.h>

#include "mdmptools_i18n.h"
#include "mdmptools_libbfio.h"
#include "mdmptools_libmdmp.h"
#include "mdmptools_libuna.h"
#include "mdmptools_output.h"

/* Initializes output settings
 * Returns 1 if successful or -1 on error
 */
int mdmptools_output_initialize(
     int stdio_mode,
     libcerror_error_t **error )
{
	static char *function = "mdmptools_output_initialize";

	if( ( stdio_mode != _IOFBF )
	 && ( stdio_mode != _IOLBF )
	 && ( stdio_mode != _IONBF ) )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,
		 "%s: unsupported standard IO mode.",
		 function );

		return( -1 );
	}
#if !defined( __BORLANDC__ )
	if( setvbuf(
	     stdout,
	     NULL,
	     stdio_mode,
	     0 ) != 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to set IO mode of stdout.",
		 function );

		return( -1 );
	}
	if( setvbuf(
	     stderr,
	     NULL,
	     stdio_mode,
	     0 ) != 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to set IO mode of stderr.",
		 function );

		return( -1 );
	}
#endif /* !defined( __BORLANDC__ ) */

	return( 1 );
}

/* Prints the copyright information
 */
void mdmptools_output_copyright_fprint(
      FILE *stream )
{
	if( stream == NULL )
	{
		return;
	}
	/* TRANSLATORS: This is a proper name.
	 */
	fprintf(
	 stream,
	 _( "Copyright (C) 2014-2024, %s.\n" ),
	 _( "Joachim Metz" ) );

	fprintf(
	 stream,
	 _( "This is free software; see the source for copying conditions. There is NO\n"
	    "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n" ) );

	/* TRANSLATORS: The placeholder indicates the bug-reporting address
	 * for this package.  Please add _another line_ saying
	 * "Report translation bugs to <...>\n" with the address for translation
	 * bugs (typically your translation team's web or email address).
	 */
	fprintf(
	 stream,
	 _( "Report bugs to <%s>.\n" ),
	 PACKAGE_BUGREPORT );
}

/* Prints the version information
 */
void mdmptools_output_version_fprint(
      FILE *stream,
      const char *program )
{
	if( stream == NULL )
	{
		return;
	}
	if( program == NULL )
	{
		return;
	}
        fprintf(
	 stream,
	 "%s %s\n\n",
         program,
	 LIBMDMP_VERSION_STRING );
}

/* Prints the detailed version information
 */
void mdmptools_output_version_detailed_fprint(
      FILE *stream,
      const char *program )
{
	if( stream == NULL )
	{
		return;
	}
	if( program == NULL )
	{
		return;
	}
        fprintf(
	 stream,
	 "%s %s (libmdmp %s",
         program,
	 LIBMDMP_VERSION_STRING,
	 LIBMDMP_VERSION_STRING );

	fprintf(
	 stream,
	 ", libuna %s",
	 LIBUNA_VERSION_STRING );

	fprintf(
	 stream,
	 ", libbfio %s",
	 LIBBFIO_VERSION_STRING );

        fprintf(
	 stream,
	 ")\n\n" );
}


```

`mdmptools/mdmptools_output.h`:

```h
/*
 * Common output functions for the mdmptools
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMPTOOLS_OUTPUT_H )
#define _MDMPTOOLS_OUTPUT_H

#include <common.h>
#include <file_stream.h>
#include <types.h>

#include "mdmptools_libcerror.h"

#if defined( __cplusplus )
extern "C" {
#endif

int mdmptools_output_initialize(
     int stdio_mode,
     libcerror_error_t **error );

void mdmptools_output_copyright_fprint(
      FILE *stream );

void mdmptools_output_version_fprint(
      FILE *stream,
      const char *program );

void mdmptools_output_version_detailed_fprint(
      FILE *stream,
      const char *program );

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _MDMPTOOLS_OUTPUT_H ) */


```

`mdmptools/mdmptools_signal.c`:

```c
/*
 * Signal handling functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <types.h>

#if defined( HAVE_SIGNAL_H )
#include <signal.h>
#endif

#if defined( _MSC_VER )
#include <crtdbg.h>
#endif

#include "mdmptools_libcerror.h"
#include "mdmptools_signal.h"

#if defined( WINAPI )

void (*mdmptools_signal_signal_handler)( mdmptools_signal_t ) = NULL;

/* Signal handler for Ctrl+C or Ctrl+Break signals
 */
BOOL WINAPI mdmptools_signal_handler(
             mdmptools_signal_t signal )
{
	static char *function = "mdmptools_signal_handler";

	switch( signal )
	{
		/* use Ctrl+C or Ctrl+Break to simulate SERVICE_CONTROL_STOP in debug mode
		 */
		case CTRL_BREAK_EVENT:
		case CTRL_C_EVENT:
			if( mdmptools_signal_signal_handler != NULL )
			{
				mdmptools_signal_signal_handler(
				 signal );
			}
			return( TRUE );

		default:
			break;
	}
	return( FALSE );
}

#if defined( _MSC_VER )

/* Initialize memory usage and leakage debugging
 */
void mdmptools_signal_initialize_memory_debug(
      void )
{
	int flag = 0;

	/* Get the current state of the flag and store it in a temporary variable
	 */
	flag = _CrtSetDbgFlag(
	         _CRTDBG_REPORT_FLAG );

	/* Turn on client block identifiers and automatic leak detection
	 */
	flag |= ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );

	/* Set the new state for the flag
	 */
	_CrtSetDbgFlag(
	 flag );
}

#endif /* defined( _MSC_VER ) */

/* Attaches a signal handler for Ctrl+C or Ctrl+Break signals
 * Returns 1 if successful or -1 on error
 */
int mdmptools_signal_attach(
     void (*signal_handler)( mdmptools_signal_t ),
     libcerror_error_t **error )
{
	static char *function = "mdmptools_signal_attach";

	if( signal_handler == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid signal handler.",
		 function );

		return( -1 );
	}
	mdmptools_signal_signal_handler = signal_handler;

	if( SetConsoleCtrlHandler(
	     (PHANDLER_ROUTINE) mdmptools_signal_handler,
	     TRUE ) == 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to attach signal handler.",
		 function );

		return( -1 );
	}
	if( SetConsoleCtrlHandler(
	     NULL,
	     FALSE ) == 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to attach break signal.",
		 function );

		return( -1 );
	}
#if defined( _MSC_VER )
	mdmptools_signal_initialize_memory_debug();
#endif

	SetErrorMode(
	 SEM_FAILCRITICALERRORS );

#if defined( LOCALE_SUPPORT )
	/* Allow subsequent threads to have their own locale.
	 * If the application is single threaded this call has
	 * no practical effect.
	 */
	_configthreadlocale(
	  _ENABLE_PER_THREAD_LOCALE );

	/* Set the current thread locale to the user default
	 * ANSI code page.
	 */
	setlocale(
	 LC_ALL,
	 "" );

	/* Set the the code page used by multibyte functions
	 * to use the same code page as the previous call to setlocale.
	 */
	_setmbcp(
	  _MB_CP_LOCALE );

#endif /* defined( LOCALE_SUPPORT ) */

	return( 1 );
}

/* Detaches a signal handler for Ctrl+C or Ctrl+Break signals
 * Returns 1 if successful or -1 on error
 */
int mdmptools_signal_detach(
     libcerror_error_t **error )
{
	static char *function = "mdmptools_signal_detach";

	if( SetConsoleCtrlHandler(
	     (PHANDLER_ROUTINE) mdmptools_signal_handler,
	     FALSE ) == 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to detach signal handler.",
		 function );

		return( -1 );
	}
	mdmptools_signal_signal_handler = NULL;

	return( 1 );
}

#else

/* Attaches a signal handler for SIGINT
 * Returns 1 if successful or -1 on error
 */
int mdmptools_signal_attach(
     void (*signal_handler)( mdmptools_signal_t ),
     libcerror_error_t **error )
{
	static char *function = "mdmptools_signal_attach";

	if( signal_handler == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid signal handler.",
		 function );

		return( -1 );
	}
	if( signal(
	     SIGINT,
	     signal_handler ) == SIG_ERR )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to attach signal handler.",
		 function );

		return( -1 );
	}
	return( 1 );
}

/* Detaches a signal handler for SIGINT
 * Returns 1 if successful or -1 on error
 */
int mdmptools_signal_detach(
     libcerror_error_t **error )
{
	static char *function = "mdmptools_signal_detach";

	if( signal(
	     SIGINT,
	     SIG_DFL ) == SIG_ERR )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to detach signal handler.",
		 function );

		return( -1 );
	}
	return( 1 );
}

#endif /* defined( WINAPI ) */


```

`mdmptools/mdmptools_signal.h`:

```h
/*
 * Signal handling functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMPTOOLS_SIGNAL_H )
#define _MDMPTOOLS_SIGNAL_H

#include <common.h>
#include <types.h>

#include "mdmptools_libcerror.h"

#if defined( __cplusplus )
extern "C" {
#endif

#if !defined( HAVE_SIGNAL_H ) && !defined( WINAPI )
#error missing signal functions
#endif

#if defined( WINAPI )
typedef unsigned long mdmptools_signal_t;

#else
typedef int mdmptools_signal_t;

#endif /* defined( WINAPI ) */

#if defined( WINAPI )

BOOL WINAPI mdmptools_signal_handler(
             mdmptools_signal_t signal );

#if defined( _MSC_VER )

void mdmptools_signal_initialize_memory_debug(
      void );

#endif /* defined( _MSC_VER ) */

#endif /* defined( WINAPI ) */

int mdmptools_signal_attach(
     void (*signal_handler)( mdmptools_signal_t ),
     libcerror_error_t **error );

int mdmptools_signal_detach(
     libcerror_error_t **error );

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _MDMPTOOLS_SIGNAL_H ) */


```

`mdmptools/mdmptools_unused.h`:

```h
/*
 * Definitions to silence compiler warnings about unused function attributes/parameters.
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMPTOOLS_UNUSED_H )
#define _MDMPTOOLS_UNUSED_H

#include <common.h>

#if !defined( MDMPTOOLS_ATTRIBUTE_UNUSED )

#if defined( __GNUC__ ) && __GNUC__ >= 3
#define MDMPTOOLS_ATTRIBUTE_UNUSED	__attribute__ ((__unused__))

#else
#define MDMPTOOLS_ATTRIBUTE_UNUSED

#endif /* defined( __GNUC__ ) && __GNUC__ >= 3 */

#endif /* !defined( MDMPTOOLS_ATTRIBUTE_UNUSED ) */

#if defined( _MSC_VER )
#define MDMPTOOLS_UNREFERENCED_PARAMETER( parameter ) \
	UNREFERENCED_PARAMETER( parameter );

#else
#define MDMPTOOLS_UNREFERENCED_PARAMETER( parameter ) \
	/* parameter */

#endif /* defined( _MSC_VER ) */

#endif /* !defined( _MDMPTOOLS_UNUSED_H ) */


```

`msvscpp/Makefile.am`:

```am
MSVSCPP_FILES = \
	libbfio/libbfio.vcproj \
	libcdata/libcdata.vcproj \
	libcerror/libcerror.vcproj \
	libcfile/libcfile.vcproj \
	libclocale/libclocale.vcproj \
	libcnotify/libcnotify.vcproj \
	libcpath/libcpath.vcproj \
	libcsplit/libcsplit.vcproj \
	libcthreads/libcthreads.vcproj \
	libfcache/libfcache.vcproj \
	libfdata/libfdata.vcproj \
	libfdatetime/libfdatetime.vcproj \
	libmdmp/libmdmp.vcproj \
	libuna/libuna.vcproj \
	mdmp_test_error/mdmp_test_error.vcproj \
	mdmp_test_file/mdmp_test_file.vcproj \
	mdmp_test_io_handle/mdmp_test_io_handle.vcproj \
	mdmp_test_notify/mdmp_test_notify.vcproj \
	mdmp_test_stream/mdmp_test_stream.vcproj \
	mdmp_test_stream_descriptor/mdmp_test_stream_descriptor.vcproj \
	mdmp_test_stream_io_handle/mdmp_test_stream_io_handle.vcproj \
	mdmp_test_support/mdmp_test_support.vcproj \
	mdmp_test_tools_info_handle/mdmp_test_tools_info_handle.vcproj \
	mdmp_test_tools_output/mdmp_test_tools_output.vcproj \
	mdmp_test_tools_signal/mdmp_test_tools_signal.vcproj \
	mdmpinfo/mdmpinfo.vcproj \
	libmdmp.sln

EXTRA_DIST = \
	$(MSVSCPP_FILES)

MAINTAINERCLEANFILES = \
	Makefile.in

distclean: clean
	-rm -f Makefile


```

`msvscpp/libbfio/libbfio.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libbfio"
	ProjectGUID="{41CFAFBF-A1C8-4704-AFEF-31979E6452B9}"
	RootNamespace="libbfio"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libclocale;..\..\libcnotify;..\..\libcdata;..\..\libcsplit;..\..\libcfile;..\..\libcpath;..\..\libuna"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBBFIO"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libclocale;..\..\libcnotify;..\..\libcdata;..\..\libcsplit;..\..\libcfile;..\..\libcpath;..\..\libuna"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBBFIO"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libbfio\libbfio_error.c"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_file.c"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_file_io_handle.c"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_file_pool.c"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_file_range.c"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_file_range_io_handle.c"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_handle.c"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_memory_range.c"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_memory_range_io_handle.c"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_pool.c"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_support.c"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_system_string.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libbfio\libbfio_codepage.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_error.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_file.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_file_io_handle.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_file_pool.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_file_range.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_file_range_io_handle.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_handle.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_libcdata.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_libcfile.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_libclocale.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_libcpath.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_libcthreads.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_libuna.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_memory_range.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_memory_range_io_handle.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_pool.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_system_string.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_types.h"
				>
			</File>
			<File
				RelativePath="..\..\libbfio\libbfio_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libcdata/libcdata.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libcdata"
	ProjectGUID="{FC429AFB-0D66-43FF-9BA4-B858D5700D9A}"
	RootNamespace="libcdata"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libcdata\libcdata_array.c"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_btree.c"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_btree_node.c"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_btree_values_list.c"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_error.c"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_list.c"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_list_element.c"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_range_list.c"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_range_list_value.c"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_support.c"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_tree_node.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libcdata\libcdata_array.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_btree.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_btree_node.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_btree_values_list.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_error.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_libcthreads.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_list.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_list_element.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_range_list.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_range_list_value.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_tree_node.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_types.h"
				>
			</File>
			<File
				RelativePath="..\..\libcdata\libcdata_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libcerror/libcerror.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libcerror"
	ProjectGUID="{1274312A-186A-46D4-BE67-4F380D288512}"
	RootNamespace="libcerror"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libcerror\libcerror_error.c"
				>
			</File>
			<File
				RelativePath="..\..\libcerror\libcerror_support.c"
				>
			</File>
			<File
				RelativePath="..\..\libcerror\libcerror_system.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libcerror\libcerror_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libcerror\libcerror_error.h"
				>
			</File>
			<File
				RelativePath="..\..\libcerror\libcerror_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libcerror\libcerror_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libcerror\libcerror_system.h"
				>
			</File>
			<File
				RelativePath="..\..\libcerror\libcerror_types.h"
				>
			</File>
			<File
				RelativePath="..\..\libcerror\libcerror_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libcfile/libcfile.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libcfile"
	ProjectGUID="{2752F53E-7AF3-43AE-8968-AF4D60B8D8C9}"
	RootNamespace="libcfile"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libclocale;..\..\libcnotify;..\..\libuna"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libclocale;..\..\libcnotify;..\..\libuna"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libcfile\libcfile_error.c"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_file.c"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_notify.c"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_support.c"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_system_string.c"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_winapi.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libcfile\libcfile_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_error.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_file.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_libclocale.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_libcnotify.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_libuna.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_notify.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_system_string.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_types.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_unused.h"
				>
			</File>
			<File
				RelativePath="..\..\libcfile\libcfile_winapi.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libclocale/libclocale.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libclocale"
	ProjectGUID="{FA577F1F-7597-4C9D-AED7-D24836C515C6}"
	RootNamespace="libclocale"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCLOCALE"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCLOCALE"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libclocale\libclocale_codepage.c"
				>
			</File>
			<File
				RelativePath="..\..\libclocale\libclocale_locale.c"
				>
			</File>
			<File
				RelativePath="..\..\libclocale\libclocale_support.c"
				>
			</File>
			<File
				RelativePath="..\..\libclocale\libclocale_wide_string.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libclocale\libclocale_codepage.h"
				>
			</File>
			<File
				RelativePath="..\..\libclocale\libclocale_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libclocale\libclocale_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libclocale\libclocale_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libclocale\libclocale_locale.h"
				>
			</File>
			<File
				RelativePath="..\..\libclocale\libclocale_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libclocale\libclocale_unused.h"
				>
			</File>
			<File
				RelativePath="..\..\libclocale\libclocale_wide_string.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libcnotify/libcnotify.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libcnotify"
	ProjectGUID="{F6D3DAE9-D57C-49D3-B296-A987855776BC}"
	RootNamespace="libcnotify"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCNOTIFY"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCNOTIFY"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libcnotify\libcnotify_print.c"
				>
			</File>
			<File
				RelativePath="..\..\libcnotify\libcnotify_stream.c"
				>
			</File>
			<File
				RelativePath="..\..\libcnotify\libcnotify_support.c"
				>
			</File>
			<File
				RelativePath="..\..\libcnotify\libcnotify_verbose.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libcnotify\libcnotify_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libcnotify\libcnotify_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libcnotify\libcnotify_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libcnotify\libcnotify_print.h"
				>
			</File>
			<File
				RelativePath="..\..\libcnotify\libcnotify_stream.h"
				>
			</File>
			<File
				RelativePath="..\..\libcnotify\libcnotify_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libcnotify\libcnotify_unused.h"
				>
			</File>
			<File
				RelativePath="..\..\libcnotify\libcnotify_verbose.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libcpath/libcpath.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libcpath"
	ProjectGUID="{566815ED-947E-4124-9B30-0736849D0F55}"
	RootNamespace="libcpath"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libclocale;..\..\libcsplit;..\..\libuna"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCPATH"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libclocale;..\..\libcsplit;..\..\libuna"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCPATH"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libcpath\libcpath_error.c"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_path.c"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_support.c"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_system_string.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libcpath\libcpath_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_error.h"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_libclocale.h"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_libcsplit.h"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_libuna.h"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_path.h"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_system_string.h"
				>
			</File>
			<File
				RelativePath="..\..\libcpath\libcpath_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libcsplit/libcsplit.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libcsplit"
	ProjectGUID="{B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6}"
	RootNamespace="libcsplit"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCSPLIT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCSPLIT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libcsplit\libcsplit_error.c"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_narrow_split_string.c"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_narrow_string.c"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_support.c"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_wide_split_string.c"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_wide_string.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libcsplit\libcsplit_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_error.h"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_narrow_split_string.h"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_narrow_string.h"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_types.h"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_unused.h"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_wide_split_string.h"
				>
			</File>
			<File
				RelativePath="..\..\libcsplit\libcsplit_wide_string.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libcthreads/libcthreads.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libcthreads"
	ProjectGUID="{EA113D1A-FF4D-4F7D-94D2-AEC271000BF8}"
	RootNamespace="libcthreads"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libcthreads\libcthreads_condition.c"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_error.c"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_lock.c"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_mutex.c"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_queue.c"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_read_write_lock.c"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_repeating_thread.c"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_support.c"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_thread.c"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_thread_attributes.c"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_thread_pool.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libcthreads\libcthreads_condition.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_error.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_lock.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_mutex.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_queue.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_read_write_lock.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_repeating_thread.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_thread.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_thread_attributes.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_thread_pool.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_types.h"
				>
			</File>
			<File
				RelativePath="..\..\libcthreads\libcthreads_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libfcache/libfcache.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libfcache"
	ProjectGUID="{9CF433B9-FE55-4F1A-9EE2-2BC7F95038AD}"
	RootNamespace="libfcache"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBFCACHE"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBFCACHE"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libfcache\libfcache_cache.c"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_cache_value.c"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_date_time.c"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_error.c"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_support.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libfcache\libfcache_cache.h"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_cache_value.h"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_date_time.h"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_error.h"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_libcdata.h"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_types.h"
				>
			</File>
			<File
				RelativePath="..\..\libfcache\libfcache_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libfdata/libfdata.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libfdata"
	ProjectGUID="{18B55272-4470-4FC3-A3C3-2893A698D856}"
	RootNamespace="libfdata"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libcnotify;..\..\libfcache"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libcnotify;..\..\libfcache"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libfdata\libfdata_area.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_cache.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_error.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_list.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_list_element.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_mapped_range.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_notify.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_range.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_range_list.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_segments_array.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_stream.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_support.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_vector.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libfdata\libfdata_area.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_cache.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_error.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_libcdata.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_libcnotify.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_libfcache.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_list.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_list_element.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_mapped_range.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_notify.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_range.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_range_list.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_segments_array.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_stream.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_types.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_unused.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdata\libfdata_vector.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libfdatetime/libfdatetime.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libfdatetime"
	ProjectGUID="{25C60507-39C6-4564-912D-DA2E7482A00F}"
	RootNamespace="libfdatetime"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBFDATETIME"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBFDATETIME"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_date_time_values.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_error.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_fat_date_time.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_filetime.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_floatingtime.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_hfs_time.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_nsf_timedate.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_posix_time.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_support.c"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_systemtime.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_date_time_values.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_error.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_fat_date_time.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_filetime.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_floatingtime.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_hfs_time.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_nsf_timedate.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_posix_time.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_systemtime.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_types.h"
				>
			</File>
			<File
				RelativePath="..\..\libfdatetime\libfdatetime_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libmdmp.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 10.00
# Visual C++ Express 2008
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libfcache", "libfcache\libfcache.vcproj", "{9CF433B9-FE55-4F1A-9EE2-2BC7F95038AD}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
		{EA113D1A-FF4D-4F7D-94D2-AEC271000BF8} = {EA113D1A-FF4D-4F7D-94D2-AEC271000BF8}
		{FC429AFB-0D66-43FF-9BA4-B858D5700D9A} = {FC429AFB-0D66-43FF-9BA4-B858D5700D9A}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mdmp_test_error", "mdmp_test_error\mdmp_test_error.vcproj", "{6EA916F5-E93E-4077-A628-EDC1924B5279}"
	ProjectSection(ProjectDependencies) = postProject
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49} = {BCFEEA4E-D17E-4BEA-8603-F01071057C49}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mdmp_test_file", "mdmp_test_file\mdmp_test_file.vcproj", "{65194D06-29DF-41D2-AF01-8AB145918D47}"
	ProjectSection(ProjectDependencies) = postProject
		{41CFAFBF-A1C8-4704-AFEF-31979E6452B9} = {41CFAFBF-A1C8-4704-AFEF-31979E6452B9}
		{566815ED-947E-4124-9B30-0736849D0F55} = {566815ED-947E-4124-9B30-0736849D0F55}
		{2752F53E-7AF3-43AE-8968-AF4D60B8D8C9} = {2752F53E-7AF3-43AE-8968-AF4D60B8D8C9}
		{BC27FF34-C859-4A1A-95D6-FC89952E1910} = {BC27FF34-C859-4A1A-95D6-FC89952E1910}
		{B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6} = {B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6}
		{F6D3DAE9-D57C-49D3-B296-A987855776BC} = {F6D3DAE9-D57C-49D3-B296-A987855776BC}
		{FA577F1F-7597-4C9D-AED7-D24836C515C6} = {FA577F1F-7597-4C9D-AED7-D24836C515C6}
		{FC429AFB-0D66-43FF-9BA4-B858D5700D9A} = {FC429AFB-0D66-43FF-9BA4-B858D5700D9A}
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49} = {BCFEEA4E-D17E-4BEA-8603-F01071057C49}
		{EA113D1A-FF4D-4F7D-94D2-AEC271000BF8} = {EA113D1A-FF4D-4F7D-94D2-AEC271000BF8}
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mdmp_test_io_handle", "mdmp_test_io_handle\mdmp_test_io_handle.vcproj", "{086BD1AC-4D80-42EA-83AC-9CAB0FDDFF1A}"
	ProjectSection(ProjectDependencies) = postProject
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49} = {BCFEEA4E-D17E-4BEA-8603-F01071057C49}
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mdmp_test_notify", "mdmp_test_notify\mdmp_test_notify.vcproj", "{A2E6DFEE-063F-4DF6-BC29-3EC4C8B98425}"
	ProjectSection(ProjectDependencies) = postProject
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49} = {BCFEEA4E-D17E-4BEA-8603-F01071057C49}
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mdmp_test_stream", "mdmp_test_stream\mdmp_test_stream.vcproj", "{0E36842C-65B1-4872-9B79-279996E9F721}"
	ProjectSection(ProjectDependencies) = postProject
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49} = {BCFEEA4E-D17E-4BEA-8603-F01071057C49}
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mdmp_test_stream_descriptor", "mdmp_test_stream_descriptor\mdmp_test_stream_descriptor.vcproj", "{A7EE70BD-2867-4918-AFDF-04B6CCDD8129}"
	ProjectSection(ProjectDependencies) = postProject
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49} = {BCFEEA4E-D17E-4BEA-8603-F01071057C49}
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mdmp_test_stream_io_handle", "mdmp_test_stream_io_handle\mdmp_test_stream_io_handle.vcproj", "{954C3E4F-8040-4DB2-9B8B-6A8C0BBD60FD}"
	ProjectSection(ProjectDependencies) = postProject
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49} = {BCFEEA4E-D17E-4BEA-8603-F01071057C49}
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mdmp_test_support", "mdmp_test_support\mdmp_test_support.vcproj", "{3CA45598-DAFC-4112-BE58-4C810D84D997}"
	ProjectSection(ProjectDependencies) = postProject
		{41CFAFBF-A1C8-4704-AFEF-31979E6452B9} = {41CFAFBF-A1C8-4704-AFEF-31979E6452B9}
		{566815ED-947E-4124-9B30-0736849D0F55} = {566815ED-947E-4124-9B30-0736849D0F55}
		{2752F53E-7AF3-43AE-8968-AF4D60B8D8C9} = {2752F53E-7AF3-43AE-8968-AF4D60B8D8C9}
		{BC27FF34-C859-4A1A-95D6-FC89952E1910} = {BC27FF34-C859-4A1A-95D6-FC89952E1910}
		{B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6} = {B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6}
		{F6D3DAE9-D57C-49D3-B296-A987855776BC} = {F6D3DAE9-D57C-49D3-B296-A987855776BC}
		{FA577F1F-7597-4C9D-AED7-D24836C515C6} = {FA577F1F-7597-4C9D-AED7-D24836C515C6}
		{FC429AFB-0D66-43FF-9BA4-B858D5700D9A} = {FC429AFB-0D66-43FF-9BA4-B858D5700D9A}
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49} = {BCFEEA4E-D17E-4BEA-8603-F01071057C49}
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mdmp_test_tools_info_handle", "mdmp_test_tools_info_handle\mdmp_test_tools_info_handle.vcproj", "{AAF1F8D5-3C46-44A1-A17D-FE95DF8FB91B}"
	ProjectSection(ProjectDependencies) = postProject
		{FA577F1F-7597-4C9D-AED7-D24836C515C6} = {FA577F1F-7597-4C9D-AED7-D24836C515C6}
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49} = {BCFEEA4E-D17E-4BEA-8603-F01071057C49}
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mdmp_test_tools_output", "mdmp_test_tools_output\mdmp_test_tools_output.vcproj", "{8C1ABDB1-8488-475F-9953-74BA1F282B65}"
	ProjectSection(ProjectDependencies) = postProject
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49} = {BCFEEA4E-D17E-4BEA-8603-F01071057C49}
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mdmp_test_tools_signal", "mdmp_test_tools_signal\mdmp_test_tools_signal.vcproj", "{8C00EB06-77A7-4C36-B2B3-AA905136EA4A}"
	ProjectSection(ProjectDependencies) = postProject
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49} = {BCFEEA4E-D17E-4BEA-8603-F01071057C49}
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libclocale", "libclocale\libclocale.vcproj", "{FA577F1F-7597-4C9D-AED7-D24836C515C6}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libmdmp", "libmdmp\libmdmp.vcproj", "{BCFEEA4E-D17E-4BEA-8603-F01071057C49}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
		{EA113D1A-FF4D-4F7D-94D2-AEC271000BF8} = {EA113D1A-FF4D-4F7D-94D2-AEC271000BF8}
		{FC429AFB-0D66-43FF-9BA4-B858D5700D9A} = {FC429AFB-0D66-43FF-9BA4-B858D5700D9A}
		{FA577F1F-7597-4C9D-AED7-D24836C515C6} = {FA577F1F-7597-4C9D-AED7-D24836C515C6}
		{F6D3DAE9-D57C-49D3-B296-A987855776BC} = {F6D3DAE9-D57C-49D3-B296-A987855776BC}
		{B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6} = {B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6}
		{BC27FF34-C859-4A1A-95D6-FC89952E1910} = {BC27FF34-C859-4A1A-95D6-FC89952E1910}
		{2752F53E-7AF3-43AE-8968-AF4D60B8D8C9} = {2752F53E-7AF3-43AE-8968-AF4D60B8D8C9}
		{566815ED-947E-4124-9B30-0736849D0F55} = {566815ED-947E-4124-9B30-0736849D0F55}
		{41CFAFBF-A1C8-4704-AFEF-31979E6452B9} = {41CFAFBF-A1C8-4704-AFEF-31979E6452B9}
		{9CF433B9-FE55-4F1A-9EE2-2BC7F95038AD} = {9CF433B9-FE55-4F1A-9EE2-2BC7F95038AD}
		{18B55272-4470-4FC3-A3C3-2893A698D856} = {18B55272-4470-4FC3-A3C3-2893A698D856}
		{25C60507-39C6-4564-912D-DA2E7482A00F} = {25C60507-39C6-4564-912D-DA2E7482A00F}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libbfio", "libbfio\libbfio.vcproj", "{41CFAFBF-A1C8-4704-AFEF-31979E6452B9}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
		{EA113D1A-FF4D-4F7D-94D2-AEC271000BF8} = {EA113D1A-FF4D-4F7D-94D2-AEC271000BF8}
		{FA577F1F-7597-4C9D-AED7-D24836C515C6} = {FA577F1F-7597-4C9D-AED7-D24836C515C6}
		{F6D3DAE9-D57C-49D3-B296-A987855776BC} = {F6D3DAE9-D57C-49D3-B296-A987855776BC}
		{FC429AFB-0D66-43FF-9BA4-B858D5700D9A} = {FC429AFB-0D66-43FF-9BA4-B858D5700D9A}
		{B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6} = {B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6}
		{2752F53E-7AF3-43AE-8968-AF4D60B8D8C9} = {2752F53E-7AF3-43AE-8968-AF4D60B8D8C9}
		{566815ED-947E-4124-9B30-0736849D0F55} = {566815ED-947E-4124-9B30-0736849D0F55}
		{BC27FF34-C859-4A1A-95D6-FC89952E1910} = {BC27FF34-C859-4A1A-95D6-FC89952E1910}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libfdatetime", "libfdatetime\libfdatetime.vcproj", "{25C60507-39C6-4564-912D-DA2E7482A00F}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libcfile", "libcfile\libcfile.vcproj", "{2752F53E-7AF3-43AE-8968-AF4D60B8D8C9}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
		{FA577F1F-7597-4C9D-AED7-D24836C515C6} = {FA577F1F-7597-4C9D-AED7-D24836C515C6}
		{F6D3DAE9-D57C-49D3-B296-A987855776BC} = {F6D3DAE9-D57C-49D3-B296-A987855776BC}
		{BC27FF34-C859-4A1A-95D6-FC89952E1910} = {BC27FF34-C859-4A1A-95D6-FC89952E1910}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libcthreads", "libcthreads\libcthreads.vcproj", "{EA113D1A-FF4D-4F7D-94D2-AEC271000BF8}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libcpath", "libcpath\libcpath.vcproj", "{566815ED-947E-4124-9B30-0736849D0F55}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
		{FA577F1F-7597-4C9D-AED7-D24836C515C6} = {FA577F1F-7597-4C9D-AED7-D24836C515C6}
		{B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6} = {B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6}
		{BC27FF34-C859-4A1A-95D6-FC89952E1910} = {BC27FF34-C859-4A1A-95D6-FC89952E1910}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mdmpinfo", "mdmpinfo\mdmpinfo.vcproj", "{A7545354-5D50-49F6-A3D0-1F97F6228955}"
	ProjectSection(ProjectDependencies) = postProject
		{F6D3DAE9-D57C-49D3-B296-A987855776BC} = {F6D3DAE9-D57C-49D3-B296-A987855776BC}
		{FA577F1F-7597-4C9D-AED7-D24836C515C6} = {FA577F1F-7597-4C9D-AED7-D24836C515C6}
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49} = {BCFEEA4E-D17E-4BEA-8603-F01071057C49}
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libuna", "libuna\libuna.vcproj", "{BC27FF34-C859-4A1A-95D6-FC89952E1910}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libcerror", "libcerror\libcerror.vcproj", "{1274312A-186A-46D4-BE67-4F380D288512}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libcnotify", "libcnotify\libcnotify.vcproj", "{F6D3DAE9-D57C-49D3-B296-A987855776BC}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libfdata", "libfdata\libfdata.vcproj", "{18B55272-4470-4FC3-A3C3-2893A698D856}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
		{EA113D1A-FF4D-4F7D-94D2-AEC271000BF8} = {EA113D1A-FF4D-4F7D-94D2-AEC271000BF8}
		{FC429AFB-0D66-43FF-9BA4-B858D5700D9A} = {FC429AFB-0D66-43FF-9BA4-B858D5700D9A}
		{F6D3DAE9-D57C-49D3-B296-A987855776BC} = {F6D3DAE9-D57C-49D3-B296-A987855776BC}
		{9CF433B9-FE55-4F1A-9EE2-2BC7F95038AD} = {9CF433B9-FE55-4F1A-9EE2-2BC7F95038AD}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libcdata", "libcdata\libcdata.vcproj", "{FC429AFB-0D66-43FF-9BA4-B858D5700D9A}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
		{EA113D1A-FF4D-4F7D-94D2-AEC271000BF8} = {EA113D1A-FF4D-4F7D-94D2-AEC271000BF8}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libcsplit", "libcsplit\libcsplit.vcproj", "{B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6}"
	ProjectSection(ProjectDependencies) = postProject
		{1274312A-186A-46D4-BE67-4F380D288512} = {1274312A-186A-46D4-BE67-4F380D288512}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|Win32 = Release|Win32
		VSDebug|Win32 = VSDebug|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9CF433B9-FE55-4F1A-9EE2-2BC7F95038AD}.Release|Win32.ActiveCfg = Release|Win32
		{9CF433B9-FE55-4F1A-9EE2-2BC7F95038AD}.Release|Win32.Build.0 = Release|Win32
		{9CF433B9-FE55-4F1A-9EE2-2BC7F95038AD}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{9CF433B9-FE55-4F1A-9EE2-2BC7F95038AD}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{6EA916F5-E93E-4077-A628-EDC1924B5279}.Release|Win32.ActiveCfg = Release|Win32
		{6EA916F5-E93E-4077-A628-EDC1924B5279}.Release|Win32.Build.0 = Release|Win32
		{6EA916F5-E93E-4077-A628-EDC1924B5279}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{6EA916F5-E93E-4077-A628-EDC1924B5279}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{65194D06-29DF-41D2-AF01-8AB145918D47}.Release|Win32.ActiveCfg = Release|Win32
		{65194D06-29DF-41D2-AF01-8AB145918D47}.Release|Win32.Build.0 = Release|Win32
		{65194D06-29DF-41D2-AF01-8AB145918D47}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{65194D06-29DF-41D2-AF01-8AB145918D47}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{086BD1AC-4D80-42EA-83AC-9CAB0FDDFF1A}.Release|Win32.ActiveCfg = Release|Win32
		{086BD1AC-4D80-42EA-83AC-9CAB0FDDFF1A}.Release|Win32.Build.0 = Release|Win32
		{086BD1AC-4D80-42EA-83AC-9CAB0FDDFF1A}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{086BD1AC-4D80-42EA-83AC-9CAB0FDDFF1A}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{A2E6DFEE-063F-4DF6-BC29-3EC4C8B98425}.Release|Win32.ActiveCfg = Release|Win32
		{A2E6DFEE-063F-4DF6-BC29-3EC4C8B98425}.Release|Win32.Build.0 = Release|Win32
		{A2E6DFEE-063F-4DF6-BC29-3EC4C8B98425}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{A2E6DFEE-063F-4DF6-BC29-3EC4C8B98425}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{0E36842C-65B1-4872-9B79-279996E9F721}.Release|Win32.ActiveCfg = Release|Win32
		{0E36842C-65B1-4872-9B79-279996E9F721}.Release|Win32.Build.0 = Release|Win32
		{0E36842C-65B1-4872-9B79-279996E9F721}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{0E36842C-65B1-4872-9B79-279996E9F721}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{A7EE70BD-2867-4918-AFDF-04B6CCDD8129}.Release|Win32.ActiveCfg = Release|Win32
		{A7EE70BD-2867-4918-AFDF-04B6CCDD8129}.Release|Win32.Build.0 = Release|Win32
		{A7EE70BD-2867-4918-AFDF-04B6CCDD8129}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{A7EE70BD-2867-4918-AFDF-04B6CCDD8129}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{954C3E4F-8040-4DB2-9B8B-6A8C0BBD60FD}.Release|Win32.ActiveCfg = Release|Win32
		{954C3E4F-8040-4DB2-9B8B-6A8C0BBD60FD}.Release|Win32.Build.0 = Release|Win32
		{954C3E4F-8040-4DB2-9B8B-6A8C0BBD60FD}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{954C3E4F-8040-4DB2-9B8B-6A8C0BBD60FD}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{3CA45598-DAFC-4112-BE58-4C810D84D997}.Release|Win32.ActiveCfg = Release|Win32
		{3CA45598-DAFC-4112-BE58-4C810D84D997}.Release|Win32.Build.0 = Release|Win32
		{3CA45598-DAFC-4112-BE58-4C810D84D997}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{3CA45598-DAFC-4112-BE58-4C810D84D997}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{AAF1F8D5-3C46-44A1-A17D-FE95DF8FB91B}.Release|Win32.ActiveCfg = Release|Win32
		{AAF1F8D5-3C46-44A1-A17D-FE95DF8FB91B}.Release|Win32.Build.0 = Release|Win32
		{AAF1F8D5-3C46-44A1-A17D-FE95DF8FB91B}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{AAF1F8D5-3C46-44A1-A17D-FE95DF8FB91B}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{8C1ABDB1-8488-475F-9953-74BA1F282B65}.Release|Win32.ActiveCfg = Release|Win32
		{8C1ABDB1-8488-475F-9953-74BA1F282B65}.Release|Win32.Build.0 = Release|Win32
		{8C1ABDB1-8488-475F-9953-74BA1F282B65}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{8C1ABDB1-8488-475F-9953-74BA1F282B65}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{8C00EB06-77A7-4C36-B2B3-AA905136EA4A}.Release|Win32.ActiveCfg = Release|Win32
		{8C00EB06-77A7-4C36-B2B3-AA905136EA4A}.Release|Win32.Build.0 = Release|Win32
		{8C00EB06-77A7-4C36-B2B3-AA905136EA4A}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{8C00EB06-77A7-4C36-B2B3-AA905136EA4A}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{FA577F1F-7597-4C9D-AED7-D24836C515C6}.Release|Win32.ActiveCfg = Release|Win32
		{FA577F1F-7597-4C9D-AED7-D24836C515C6}.Release|Win32.Build.0 = Release|Win32
		{FA577F1F-7597-4C9D-AED7-D24836C515C6}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{FA577F1F-7597-4C9D-AED7-D24836C515C6}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49}.Release|Win32.ActiveCfg = Release|Win32
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49}.Release|Win32.Build.0 = Release|Win32
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{BCFEEA4E-D17E-4BEA-8603-F01071057C49}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{41CFAFBF-A1C8-4704-AFEF-31979E6452B9}.Release|Win32.ActiveCfg = Release|Win32
		{41CFAFBF-A1C8-4704-AFEF-31979E6452B9}.Release|Win32.Build.0 = Release|Win32
		{41CFAFBF-A1C8-4704-AFEF-31979E6452B9}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{41CFAFBF-A1C8-4704-AFEF-31979E6452B9}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{25C60507-39C6-4564-912D-DA2E7482A00F}.Release|Win32.ActiveCfg = Release|Win32
		{25C60507-39C6-4564-912D-DA2E7482A00F}.Release|Win32.Build.0 = Release|Win32
		{25C60507-39C6-4564-912D-DA2E7482A00F}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{25C60507-39C6-4564-912D-DA2E7482A00F}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{2752F53E-7AF3-43AE-8968-AF4D60B8D8C9}.Release|Win32.ActiveCfg = Release|Win32
		{2752F53E-7AF3-43AE-8968-AF4D60B8D8C9}.Release|Win32.Build.0 = Release|Win32
		{2752F53E-7AF3-43AE-8968-AF4D60B8D8C9}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{2752F53E-7AF3-43AE-8968-AF4D60B8D8C9}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{EA113D1A-FF4D-4F7D-94D2-AEC271000BF8}.Release|Win32.ActiveCfg = Release|Win32
		{EA113D1A-FF4D-4F7D-94D2-AEC271000BF8}.Release|Win32.Build.0 = Release|Win32
		{EA113D1A-FF4D-4F7D-94D2-AEC271000BF8}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{EA113D1A-FF4D-4F7D-94D2-AEC271000BF8}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{566815ED-947E-4124-9B30-0736849D0F55}.Release|Win32.ActiveCfg = Release|Win32
		{566815ED-947E-4124-9B30-0736849D0F55}.Release|Win32.Build.0 = Release|Win32
		{566815ED-947E-4124-9B30-0736849D0F55}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{566815ED-947E-4124-9B30-0736849D0F55}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{A7545354-5D50-49F6-A3D0-1F97F6228955}.Release|Win32.ActiveCfg = Release|Win32
		{A7545354-5D50-49F6-A3D0-1F97F6228955}.Release|Win32.Build.0 = Release|Win32
		{A7545354-5D50-49F6-A3D0-1F97F6228955}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{A7545354-5D50-49F6-A3D0-1F97F6228955}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{BC27FF34-C859-4A1A-95D6-FC89952E1910}.Release|Win32.ActiveCfg = Release|Win32
		{BC27FF34-C859-4A1A-95D6-FC89952E1910}.Release|Win32.Build.0 = Release|Win32
		{BC27FF34-C859-4A1A-95D6-FC89952E1910}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{BC27FF34-C859-4A1A-95D6-FC89952E1910}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{1274312A-186A-46D4-BE67-4F380D288512}.Release|Win32.ActiveCfg = Release|Win32
		{1274312A-186A-46D4-BE67-4F380D288512}.Release|Win32.Build.0 = Release|Win32
		{1274312A-186A-46D4-BE67-4F380D288512}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{1274312A-186A-46D4-BE67-4F380D288512}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{F6D3DAE9-D57C-49D3-B296-A987855776BC}.Release|Win32.ActiveCfg = Release|Win32
		{F6D3DAE9-D57C-49D3-B296-A987855776BC}.Release|Win32.Build.0 = Release|Win32
		{F6D3DAE9-D57C-49D3-B296-A987855776BC}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{F6D3DAE9-D57C-49D3-B296-A987855776BC}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{18B55272-4470-4FC3-A3C3-2893A698D856}.Release|Win32.ActiveCfg = Release|Win32
		{18B55272-4470-4FC3-A3C3-2893A698D856}.Release|Win32.Build.0 = Release|Win32
		{18B55272-4470-4FC3-A3C3-2893A698D856}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{18B55272-4470-4FC3-A3C3-2893A698D856}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{FC429AFB-0D66-43FF-9BA4-B858D5700D9A}.Release|Win32.ActiveCfg = Release|Win32
		{FC429AFB-0D66-43FF-9BA4-B858D5700D9A}.Release|Win32.Build.0 = Release|Win32
		{FC429AFB-0D66-43FF-9BA4-B858D5700D9A}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{FC429AFB-0D66-43FF-9BA4-B858D5700D9A}.VSDebug|Win32.Build.0 = VSDebug|Win32
		{B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6}.Release|Win32.ActiveCfg = Release|Win32
		{B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6}.Release|Win32.Build.0 = Release|Win32
		{B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6}.VSDebug|Win32.ActiveCfg = VSDebug|Win32
		{B8A4DFDC-BE63-473D-9FEA-7C8DF18B54D6}.VSDebug|Win32.Build.0 = VSDebug|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`msvscpp/libmdmp/libmdmp.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libmdmp"
	ProjectGUID="{BCFEEA4E-D17E-4BEA-8603-F01071057C49}"
	RootNamespace="libmdmp"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_EXPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\$(ProjectName).dll"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
				ImportLibrary="$(OutDir)\$(ProjectName).lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_EXPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\$(ProjectName).dll"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
				ImportLibrary="$(OutDir)\$(ProjectName).lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libmdmp\libmdmp.c"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_debug.c"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_error.c"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_file.c"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_file_header.c"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_io_handle.c"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_notify.c"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_stream.c"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_stream_descriptor.c"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_stream_io_handle.c"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_support.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libmdmp\libmdmp_codepage.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_debug.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_error.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_file.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_file_header.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_io_handle.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_libbfio.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_libcdata.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_libclocale.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_libcnotify.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_libfdata.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_libfdatetime.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_libuna.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_notify.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_stream.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_stream_descriptor.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_stream_io_handle.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_types.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\libmdmp_unused.h"
				>
			</File>
			<File
				RelativePath="..\..\libmdmp\mdmp_file_header.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
			<File
				RelativePath="..\..\libmdmp\libmdmp.rc"
				>
			</File>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/libuna/libuna.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="libuna"
	ProjectGUID="{BC27FF34-C859-4A1A-95D6-FC89952E1910}"
	RootNamespace="libuna"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBUNA"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror"
				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBUNA"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).lib"
				ModuleDefinitionFile=""
				IgnoreAllDefaultLibraries="false"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\libuna\libuna_base16_stream.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_base32_stream.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_base64_stream.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_byte_stream.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_10.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_13.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_14.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_15.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_16.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_2.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_3.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_4.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_5.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_6.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_7.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_8.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_9.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_koi8_r.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_koi8_u.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_arabic.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_celtic.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_centraleurroman.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_croatian.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_cyrillic.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_dingbats.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_farsi.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_gaelic.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_greek.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_icelandic.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_inuit.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_roman.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_romanian.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_russian.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_symbol.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_thai.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_turkish.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_ukrainian.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1250.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1251.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1252.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1253.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1254.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1255.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1256.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1257.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1258.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_874.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_932.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_936.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_949.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_950.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_error.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_scsu.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_support.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_unicode_character.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_url_stream.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf16_stream.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf16_string.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf32_stream.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf32_string.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf7_stream.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf8_stream.c"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf8_string.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\libuna\libuna_base16_stream.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_base32_stream.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_base64_stream.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_byte_stream.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_10.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_13.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_14.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_15.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_16.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_2.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_3.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_4.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_5.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_6.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_7.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_8.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_iso_8859_9.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_koi8_r.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_koi8_u.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_arabic.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_celtic.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_centraleurroman.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_croatian.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_cyrillic.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_dingbats.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_farsi.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_gaelic.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_greek.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_icelandic.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_inuit.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_roman.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_romanian.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_russian.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_symbol.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_thai.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_turkish.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_mac_ukrainian.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1250.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1251.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1252.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1253.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1254.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1255.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1256.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1257.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_1258.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_874.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_932.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_936.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_949.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_codepage_windows_950.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_definitions.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_error.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_extern.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_scsu.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_support.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_types.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_unicode_character.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_unused.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_url_stream.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf16_stream.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf16_string.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf32_stream.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf32_string.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf7_stream.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf8_stream.h"
				>
			</File>
			<File
				RelativePath="..\..\libuna\libuna_utf8_string.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/mdmp_test_error/mdmp_test_error.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="mdmp_test_error"
	ProjectGUID="{6EA916F5-E93E-4077-A628-EDC1924B5279}"
	RootNamespace="mdmp_test_error"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_error.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_libmdmp.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_macros.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/mdmp_test_file/mdmp_test_file.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="mdmp_test_file"
	ProjectGUID="{65194D06-29DF-41D2-AF01-8AB145918D47}"
	RootNamespace="mdmp_test_file"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_file.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_functions.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_getopt.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_functions.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_getopt.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libbfio.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libclocale.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libcnotify.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libmdmp.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libuna.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_macros.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/mdmp_test_io_handle/mdmp_test_io_handle.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="mdmp_test_io_handle"
	ProjectGUID="{086BD1AC-4D80-42EA-83AC-9CAB0FDDFF1A}"
	RootNamespace="mdmp_test_io_handle"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_io_handle.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libmdmp.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_macros.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/mdmp_test_notify/mdmp_test_notify.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="mdmp_test_notify"
	ProjectGUID="{A2E6DFEE-063F-4DF6-BC29-3EC4C8B98425}"
	RootNamespace="mdmp_test_notify"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_notify.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libmdmp.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_macros.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/mdmp_test_stream/mdmp_test_stream.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="mdmp_test_stream"
	ProjectGUID="{0E36842C-65B1-4872-9B79-279996E9F721}"
	RootNamespace="mdmp_test_stream"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_stream.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libmdmp.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_macros.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/mdmp_test_stream_descriptor/mdmp_test_stream_descriptor.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="mdmp_test_stream_descriptor"
	ProjectGUID="{A7EE70BD-2867-4918-AFDF-04B6CCDD8129}"
	RootNamespace="mdmp_test_stream_descriptor"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_stream_descriptor.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libmdmp.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_macros.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/mdmp_test_stream_io_handle/mdmp_test_stream_io_handle.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="mdmp_test_stream_io_handle"
	ProjectGUID="{954C3E4F-8040-4DB2-9B8B-6A8C0BBD60FD}"
	RootNamespace="mdmp_test_stream_io_handle"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_stream_io_handle.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libmdmp.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_macros.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/mdmp_test_support/mdmp_test_support.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="mdmp_test_support"
	ProjectGUID="{3CA45598-DAFC-4112-BE58-4C810D84D997}"
	RootNamespace="mdmp_test_support"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_functions.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_getopt.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_support.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\tests\mdmp_test_functions.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_getopt.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libbfio.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libclocale.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libcnotify.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libmdmp.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libuna.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_macros.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/mdmp_test_tools_info_handle/mdmp_test_tools_info_handle.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="mdmp_test_tools_info_handle"
	ProjectGUID="{AAF1F8D5-3C46-44A1-A17D-FE95DF8FB91B}"
	RootNamespace="mdmp_test_tools_info_handle"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\mdmptools\info_handle.c"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmpinput.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_tools_info_handle.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\mdmptools\info_handle.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmpinput.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_macros.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_memory.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/mdmp_test_tools_output/mdmp_test_tools_output.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="mdmp_test_tools_output"
	ProjectGUID="{8C1ABDB1-8488-475F-9953-74BA1F282B65}"
	RootNamespace="mdmp_test_tools_output"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\mdmptools\mdmptools_output.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_tools_output.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\mdmptools\mdmptools_output.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_macros.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/mdmp_test_tools_signal/mdmp_test_tools_signal.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="mdmp_test_tools_signal"
	ProjectGUID="{8C00EB06-77A7-4C36-B2B3-AA905136EA4A}"
	RootNamespace="mdmp_test_tools_signal"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcthreads;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfcache;..\..\libfdata;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCTHREADS;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFCACHE;HAVE_LOCAL_LIBFDATA;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\mdmptools\mdmptools_signal.c"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_tools_signal.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\mdmptools\mdmptools_signal.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_macros.h"
				>
			</File>
			<File
				RelativePath="..\..\tests\mdmp_test_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`msvscpp/mdmpinfo/mdmpinfo.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="mdmpinfo"
	ProjectGUID="{A7545354-5D50-49F6-A3D0-1F97F6228955}"
	RootNamespace="mdmpinfo"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				RuntimeLibrary="2"
				WarningLevel="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="2"
				DataExecutionPrevention="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="VSDebug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include;..\..\common;..\..\libcerror;..\..\libcdata;..\..\libclocale;..\..\libcnotify;..\..\libcsplit;..\..\libuna;..\..\libcfile;..\..\libcpath;..\..\libbfio;..\..\libfdatetime"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;HAVE_LOCAL_LIBCERROR;HAVE_LOCAL_LIBCDATA;HAVE_LOCAL_LIBCLOCALE;HAVE_LOCAL_LIBCNOTIFY;HAVE_LOCAL_LIBCSPLIT;HAVE_LOCAL_LIBUNA;HAVE_LOCAL_LIBCFILE;HAVE_LOCAL_LIBCPATH;HAVE_LOCAL_LIBBFIO;HAVE_LOCAL_LIBFDATETIME;LIBMDMP_DLL_IMPORT"
				BasicRuntimeChecks="3"
				SmallerTypeCheck="true"
				RuntimeLibrary="3"
				WarningLevel="4"
				DebugInformationFormat="3"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;$(OutDir)&quot;"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\mdmptools\info_handle.c"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmpinfo.c"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmpinput.c"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_getopt.c"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_output.c"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_signal.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\mdmptools\info_handle.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmpinput.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_getopt.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_i18n.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_libbfio.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_libcerror.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_libclocale.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_libcnotify.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_libmdmp.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_libuna.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_output.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_signal.h"
				>
			</File>
			<File
				RelativePath="..\..\mdmptools\mdmptools_unused.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`ossfuzz/Makefile.am`:

```am
if HAVE_LIB_FUZZING_ENGINE
AM_CPPFLAGS = \
	-I$(top_srcdir)/include \
	-I$(top_srcdir)/common \
	@LIBCERROR_CPPFLAGS@ \
	@LIBCDATA_CPPFLAGS@ \
	@LIBCLOCALE_CPPFLAGS@ \
	@LIBCNOTIFY_CPPFLAGS@ \
	@LIBUNA_CPPFLAGS@ \
	@LIBCFILE_CPPFLAGS@ \
	@LIBCPATH_CPPFLAGS@ \
	@LIBBFIO_CPPFLAGS@

bin_PROGRAMS = \
	file_fuzzer

file_fuzzer_SOURCES = \
	file_fuzzer.cc \
	ossfuzz_libbfio.h \
	ossfuzz_libmdmp.h

file_fuzzer_LDADD = \
	@LIB_FUZZING_ENGINE@ \
	@LIBBFIO_LIBADD@ \
	@LIBCPATH_LIBADD@ \
	@LIBCFILE_LIBADD@ \
	@LIBUNA_LIBADD@ \
	@LIBCDATA_LIBADD@ \
	../libmdmp/libmdmp.la \
	@LIBCNOTIFY_LIBADD@ \
	@LIBCLOCALE_LIBADD@ \
	@LIBCERROR_LIBADD@ \
	@LIBINTL@
endif

MAINTAINERCLEANFILES = \
	Makefile.in

distclean: clean
	-rm -f Makefile

splint-local:
	@echo "Running splint on file_fuzzer ..."
	-splint -preproc -redef $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(file_fuzzer_SOURCES)


```

`ossfuzz/file_fuzzer.cc`:

```cc
/*
 * OSS-Fuzz target for libmdmp file type
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <stddef.h>
#include <stdint.h>

/* Note that some of the OSS-Fuzz engines use C++
 */
extern "C" {

#include "ossfuzz_libbfio.h"
#include "ossfuzz_libmdmp.h"

#if !defined( LIBMDMP_HAVE_BFIO )

/* Opens a file using a Basic File IO (bfio) handle
 * Returns 1 if successful or -1 on error
 */
LIBMDMP_EXTERN \
int libmdmp_file_open_file_io_handle(
     libmdmp_file_t *file,
     libbfio_handle_t *file_io_handle,
     int access_flags,
     libmdmp_error_t **error );

#endif /* !defined( LIBMDMP_HAVE_BFIO ) */

int LLVMFuzzerTestOneInput(
     const uint8_t *data,
     size_t size )
{
	libbfio_handle_t *file_io_handle = NULL;
	libmdmp_file_t *file             = NULL;

	if( libbfio_memory_range_initialize(
	     &file_io_handle,
	     NULL ) != 1 )
	{
		return( 0 );
	}
	if( libbfio_memory_range_set(
	     file_io_handle,
	     (uint8_t *) data,
	     size,
	     NULL ) != 1 )
	{
		goto on_error_libbfio;
	}
	if( libmdmp_file_initialize(
	     &file,
	     NULL ) != 1 )
	{
		goto on_error_libbfio;
	}
	if( libmdmp_file_open_file_io_handle(
	     file,
	     file_io_handle,
	     LIBMDMP_OPEN_READ,
	     NULL ) != 1 )
	{
		goto on_error_libmdmp;
	}
	libmdmp_file_close(
	 file,
	 NULL );

on_error_libmdmp:
	libmdmp_file_free(
	 &file,
	 NULL );

on_error_libbfio:
	libbfio_handle_free(
	 &file_io_handle,
	 NULL );

	return( 0 );
}

} /* extern "C" */


```

`ossfuzz/ossfuzz_libbfio.h`:

```h
/*
 * The libbfio header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _OSSFUZZ_LIBBFIO_H )
#define _OSSFUZZ_LIBBFIO_H

#include <common.h>

/* Define HAVE_LOCAL_LIBBFIO for local use of libbfio
 */
#if defined( HAVE_LOCAL_LIBBFIO )

#include <libbfio_definitions.h>
#include <libbfio_file.h>
#include <libbfio_file_pool.h>
#include <libbfio_file_range.h>
#include <libbfio_handle.h>
#include <libbfio_memory_range.h>
#include <libbfio_pool.h>
#include <libbfio_types.h>

#else

/* If libtool DLL support is enabled set LIBBFIO_DLL_IMPORT
 * before including libbfio.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT ) && !defined( HAVE_STATIC_EXECUTABLES )
#define LIBBFIO_DLL_IMPORT
#endif

#include <libbfio.h>

#if defined( HAVE_MULTI_THREAD_SUPPORT ) && !defined( LIBBFIO_HAVE_MULTI_THREAD_SUPPORT )
#error Multi-threading support requires libbfio with multi-threading support
#endif

#endif /* defined( HAVE_LOCAL_LIBBFIO ) */

#endif /* !defined( _OSSFUZZ_LIBBFIO_H ) */


```

`ossfuzz/ossfuzz_libmdmp.h`:

```h
/*
 * The libmdmp header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _OSSFUZZ_LIBMDMP_H )
#define _OSSFUZZ_LIBMDMP_H

#include <common.h>

#include <libmdmp.h>

#endif /* !defined( _OSSFUZZ_LIBMDMP_H ) */


```

`po/ChangeLog`:

```
2016-11-08  gettextize  <bug-gnu-gettext@gnu.org>

```

`po/Makevars.in`:

```in
# Makefile variables for PO directory in any package using GNU gettext.

# Usually the message domain is the same as the package name.
DOMAIN = @PACKAGE@

# These two variables depend on the location of this directory.
subdir = po
top_builddir = ..

# These options get passed to xgettext.
XGETTEXT_OPTIONS = --keyword=_ --keyword=N_

# This is the copyright holder that gets inserted into the header of the
# $(DOMAIN).pot file.  Set this to the copyright holder of the surrounding
# package.  (Note that the msgstr strings, extracted from the package's
# sources, belong to the copyright holder of the package.)  Translators are
# expected to transfer the copyright for their translations to this person
# or entity, or to disclaim their copyright.  The empty string stands for
# the public domain; in this case the translators are expected to disclaim
# their copyright.
COPYRIGHT_HOLDER = Joachim Metz

# This is the email address or URL to which the translators shall report
# bugs in the untranslated strings:
# - Strings which are not entire sentences, see the maintainer guidelines
#   in the GNU gettext documentation, section 'Preparing Strings'.
# - Strings which use unclear terms or require additional context to be
#   understood.
# - Strings which make invalid assumptions about notation of date, time or
#   money.
# - Pluralisation problems.
# - Incorrect English spelling.
# - Incorrect formatting.
# It can be your email address, or a mailing list address where translators
# can write to without being subscribed, or the URL of a web page through
# which the translators can contact you.
MSGID_BUGS_ADDRESS = @PACKAGE_BUGREPORT@

# This is the list of locale categories, beyond LC_MESSAGES, for which the
# message catalogs shall be used.  It is usually empty.
EXTRA_LOCALE_CATEGORIES =

# Additional make targets.
sources splint:


```

`po/POTFILES.in`:

```in
# List of source files which contain translatable strings.

```

`runtests.ps1`:

```ps1
# Script that runs the tests
#
# Version: 20220103

$ExitSuccess = 0
$ExitFailure = 1
$ExitIgnore = 77

Set-Location -Path "tests"

$Result = ${ExitSuccess}

$Lines = Get-Content "Makefile.am"
$InTests = $FALSE

Foreach (${Line} in ${Lines})
{
	If (${InTests})
	{
		If (-Not ${Line})
		{
			${InTests} = $FALSE

			Continue
		}
		${Line} = ${Line}.TrimStart()

		If (${Line}.EndsWith(" \"))
		{
			${Line} = ${Line}.Substring(0, ${Line}.Length - 2)
		}
		If (-Not (${Line}.EndsWith(".sh")))
		{
			Continue
		}
		${Line} = ${Line}.Substring(0, ${Line}.Length - 3)
		${Line} = ".\${Line}.ps1"

		Try
		{
			Invoke-Expression ${Line}
		}
		Catch
		{
			$LastExitCode = ${ExitIgnore}
		}
		If (${LastExitCode} -eq ${ExitFailure})
		{
			$Result = ${ExitFailure}
			Write-Host "FAIL" -foreground Red -nonewline
		}
		ElseIf (${LastExitCode} -eq ${ExitIgnore})
		{
			Write-Host "SKIP" -foreground Cyan -nonewline
		}
		Else
		{
			Write-Host "PASS" -foreground Green -nonewline
		}
		Write-Host ": ${Line}"
	}
	ElseIf (${Line}.StartsWith("TESTS = "))
	{
		${InTests} = $TRUE
	}
}

Set-Location -Path ".."

Exit ${Result}

```

`runtests.sh`:

```sh
#!/usr/bin/env bash
# Script that runs the tests
#
# Version: 20231119

EXIT_SUCCESS=0;
EXIT_FAILURE=1;

run_configure_make()
{
	local CONFIGURE_OPTIONS=$@;

	./configure ${CONFIGURE_OPTIONS[@]};
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		echo "Running: './configure' failed";

		return ${RESULT};
	fi

	make clean > /dev/null;
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		echo "Running: 'make clean' failed";

		return ${RESULT};
	fi

	make > /dev/null;
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		echo "Running: 'make' failed";

		return ${RESULT};
	fi
	return ${EXIT_SUCCESS};
}

run_configure_make_check()
{
	run_configure_make $@;
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		return ${RESULT};
	fi

	make check CHECK_WITH_STDERR=1;
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		echo "Running: 'make check' failed";

		if test -f tests/test-suite.log;
		then
			cat tests/test-suite.log;
		fi

		return ${RESULT};
	fi
	return ${EXIT_SUCCESS};
}

run_configure_make_check_with_asan()
{
	local LDCONFIG=`which ldconfig 2> /dev/null`;

	if test -z ${LDCONFIG} || test ! -x ${LDCONFIG};
	then
		return ${EXIT_SUCCESS};
	fi
	local LIBASAN=`ldconfig -p | grep libasan | sed 's/^.* => //' | sort | tail -n 1`;

	if test -z ${LIBASAN} || test ! -f ${LIBASAN};
	then
		return ${EXIT_SUCCESS};
	fi

	# Using libasan is platform dependent.
	export CPPFLAGS="-DHAVE_ASAN";
	export CFLAGS="-fno-omit-frame-pointer -fsanitize=address -g";
	export LDFLAGS="-fsanitize=address -g";

	if test -z ${CC} || test ${CC} != "clang";
	then
		LDFLAGS="${LDFLAGS} -lasan";
	fi

	run_configure_make $@;
	RESULT=$?;

	export CPPFLAGS=;
	export CFLAGS=;
	export LDFLAGS=;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		return ${RESULT};
	fi

	make check CHECK_WITH_ASAN=1 CHECK_WITH_STDERR=1;
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		echo "Running: 'make check' failed";

		if test -f tests/test-suite.log;
		then
			cat tests/test-suite.log;
		fi

		return ${RESULT};
	fi
	return ${RESULT};
}

run_configure_make_check_with_coverage()
{
	# Disable optimization so we can hook malloc and realloc.
	export CPPFLAGS="-DOPTIMIZATION_DISABLED";
	export CFLAGS="--coverage -O0";
	export LDFLAGS="--coverage";

	# Disable creating a shared library so we can hook memset.
	run_configure_make_check $@;
	RESULT=$?;

	export CPPFLAGS=;
	export CFLAGS=;
	export LDFLAGS=;

	return ${RESULT};
}

run_configure_make_check_python()
{
	run_configure_make $@;
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		return ${RESULT};
	fi

	make check CHECK_WITH_STDERR=1 SKIP_LIBRARY_TESTS=1 SKIP_TOOLS_TESTS=1;
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		echo "Running: 'make check' failed";

		if test -f tests/test-suite.log;
		then
			cat tests/test-suite.log;
		fi

		return ${RESULT};
	fi
	return ${EXIT_SUCCESS};
}

run_setup_py_tests()
{
	# Skip this test when running Cygwin on AppVeyor.
	if test -n "${APPVEYOR}" && test ${TARGET} = "cygwin";
	then
		echo "Running: 'setup.py build' skipped";

		return ${EXIT_SUCCESS};
	fi
	PYTHON=$1;

	${PYTHON} setup.py build;
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		echo "Running: 'setup.py build' failed";

		return ${RESULT};
	fi
	return ${EXIT_SUCCESS};
}

PROJECT_NAME=`basename $PWD`;

CONFIGURE_HELP=`./configure --help`;

echo "${CONFIGURE_HELP}" | grep -- '--enable-wide-character-type' > /dev/null;

HAVE_ENABLE_WIDE_CHARACTER_TYPE=$?;

echo "${CONFIGURE_HELP}" | grep -- '--enable-verbose-output' > /dev/null;

HAVE_ENABLE_VERBOSE_OUTPUT=$?;

echo "${CONFIGURE_HELP}" | grep -- '--enable-debug-output' > /dev/null;

HAVE_ENABLE_DEBUG_OUTPUT=$?;

echo "${CONFIGURE_HELP}" | grep -- '--with-bzip2' > /dev/null;

HAVE_WITH_BZIP2=$?;

echo "${CONFIGURE_HELP}" | grep -- '--with-libfuse' > /dev/null;

HAVE_WITH_LIBFUSE=$?;

echo "${CONFIGURE_HELP}" | grep -- '--with-lzma' > /dev/null;

HAVE_WITH_LZMA=$?;

echo "${CONFIGURE_HELP}" | grep -- '--with-pthread' > /dev/null;

HAVE_WITH_PTHREAD=$?;

echo "${CONFIGURE_HELP}" | grep -- '--with-openssl' > /dev/null;

HAVE_WITH_OPENSSL=$?;

echo "${CONFIGURE_HELP}" | grep -- '--with-zlib' > /dev/null;

HAVE_WITH_ZLIB=$?;

echo "${CONFIGURE_HELP}" | grep -- '--enable-python' > /dev/null;

HAVE_ENABLE_PYTHON=$?;

echo "${CONFIGURE_HELP}" | grep -- '--enable-static-executables' > /dev/null;

HAVE_ENABLE_STATIC_EXECUTABLES=$?;

PYTHON_CONFIG="";

if test -x /usr/bin/whereis;
then
	PYTHON_CONFIG=`/usr/bin/whereis python-config | sed 's/^.*:[ ]*//' 2> /dev/null`;
fi

# Test "./configure && make && make check" without options.

run_configure_make_check;
RESULT=$?;

if test ${RESULT} -ne ${EXIT_SUCCESS};
then
	exit ${EXIT_FAILURE};
fi

if test ${HAVE_ENABLE_VERBOSE_OUTPUT} -eq 0 && test ${HAVE_ENABLE_DEBUG_OUTPUT} -eq 0;
then
	# Test "./configure && make && make check" with verbose and debug output.

	run_configure_make_check "--enable-verbose-output --enable-debug-output";
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		exit ${EXIT_FAILURE};
	fi
fi

if test ${HAVE_WITH_PTHREAD} -eq 0 && test ${PROJECT_NAME} != "libcthreads";
then
	# Test "./configure && make && make check" without multi-threading support.

	run_configure_make_check "--with-pthread=no";
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		exit ${EXIT_FAILURE};
	fi
fi

if test ${HAVE_WITH_ZLIB} -eq 0;
then
	# Test "./configure && make && make check" with fallback zlib implementation.

	run_configure_make_check "--with-zlib=no";
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		exit ${EXIT_FAILURE};
	fi
fi

if test ${HAVE_WITH_OPENSSL} -eq 0;
then
	# Test "./configure && make && make check" with fallback crypto implementation.

	run_configure_make_check "--with-openssl=no";
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		exit ${EXIT_FAILURE};
	fi

	# Test "./configure && make && make check" with OpenSSL non-EVP implementation.

	run_configure_make_check "--enable-openssl-evp-cipher=no --enable-openssl-evp-md=no";
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		exit ${EXIT_FAILURE};
	fi

	# Test "./configure && make && make check" with OpenSSL EVP implementation.

	run_configure_make_check "--enable-openssl-evp-cipher=yes --enable-openssl-evp-md=yes";
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		exit ${EXIT_FAILURE};
	fi
fi

if test ${HAVE_ENABLE_PYTHON} -eq 0 && test -n "${PYTHON_CONFIG}";
then
	run_configure_make_check_python "--enable-python";
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		exit ${EXIT_FAILURE};
	fi

	PYTHON=`which python 2> /dev/null`;

	if test -f "setup.py" && ! run_setup_py_tests ${PYTHON};
	then
		exit ${EXIT_FAILURE};
	fi
fi

if test ${HAVE_ENABLE_STATIC_EXECUTABLES} -eq 0;
then
	CONFIGURE_OPTIONS="--enable-static-executables --enable-multi-threading-support=no";

	if test ${HAVE_WITH_BZIP2} -eq 0;
	then
		CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-bzip2=no";
	fi
	if test ${HAVE_WITH_LIBFUSE} -eq 0;
	then
		CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-libfuse=no";
	fi
	if test ${HAVE_WITH_LZMA} -eq 0;
	then
		CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-lzma=no";
	fi
	if test ${HAVE_WITH_OPENSSL} -eq 0;
	then
		CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-openssl=no";
	fi
	if test ${HAVE_WITH_ZLIB} -eq 0;
	then
		CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-zlib=no";
	fi
	run_configure_make_check ${CONFIGURE_OPTIONS};
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		exit ${EXIT_FAILURE};
	fi
fi

# Run tests with asan.
CONFIGURE_OPTIONS="";

if test ${HAVE_ENABLE_WIDE_CHARACTER_TYPE} -eq 0;
then
	CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --enable-wide-character-type";
fi
if test ${HAVE_WITH_BZIP2} -eq 0;
then
	CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-bzip2=no";
fi
if test ${HAVE_WITH_LZMA} -eq 0;
then
	CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-lzma=no";
fi
if test ${HAVE_WITH_OPENSSL} -eq 0;
then
	CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-openssl=no";
fi
if test ${HAVE_WITH_ZLIB} -eq 0;
then
	CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-zlib=no";
fi
if test ${HAVE_ENABLE_PYTHON} -eq 0 && test -n "${PYTHON_CONFIG}";
then
	# Issue with running the python bindings with asan disabled for now.
	# CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --enable-python";
	CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS}";
fi

run_configure_make_check_with_asan ${CONFIGURE_OPTIONS};
RESULT=$?;

if test ${RESULT} -ne ${EXIT_SUCCESS};
then
	exit ${EXIT_FAILURE};
fi

# Run tests with coverage.
CONFIGURE_OPTIONS="--enable-shared=no";

if test ${HAVE_ENABLE_WIDE_CHARACTER_TYPE} -eq 0;
then
	CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --enable-wide-character-type";
fi
if test ${HAVE_WITH_BZIP2} -eq 0;
then
	CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-bzip2=no";
fi
if test ${HAVE_WITH_LZMA} -eq 0;
then
	CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-lzma=no";
fi
if test ${HAVE_WITH_OPENSSL} -eq 0;
then
	CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-openssl=no";
fi
if test ${HAVE_WITH_ZLIB} -eq 0;
then
	CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --with-zlib=no";
fi

run_configure_make_check_with_coverage ${CONFIGURE_OPTIONS};
RESULT=$?;

if test ${RESULT} -ne ${EXIT_SUCCESS};
then
	exit ${EXIT_FAILURE};
fi

exit ${EXIT_SUCCESS};


```

`synclibs.ps1`:

```ps1
# Script that synchronizes the local library dependencies
#
# Version: 20180125

Param (
	[switch]$UseHead = $false
)

$GitUrlPrefix = "https://github.com/libyal"
$LocalLibs = "libbfio libcdata libcerror libcfile libclocale libcnotify libcpath libcsplit libcthreads libfcache libfdata libfdatetime libuna"
$LocalLibs = ${LocalLibs} -split " "

$Git = "git"
$WinFlex = "..\win_flex_bison\win_flex.exe"
$WinBison = "..\win_flex_bison\win_bison.exe"

ForEach (${LocalLib} in ${LocalLibs})
{
	# Split will return an array of a single empty string when LocalLibs is empty.
	If (-Not (${LocalLib}))
	{
		Continue
	}
	$GitUrl = "${GitUrlPrefix}/${LocalLib}.git"

	# PowerShell will raise NativeCommandError if git writes to stdout or stderr
	# therefore 2>&1 is added and the output is stored in a variable.
	$Output = Invoke-Expression -Command "${Git} clone ${GitUrl} ${LocalLib}-${pid} 2>&1"

	Push-Location "${LocalLib}-${pid}"

	Try
	{
		$Output = Invoke-Expression -Command "${Git} fetch --quiet --all --tags --prune 2>&1"

		$LatestTag = Invoke-Expression -Command "${Git} describe --tags --abbrev=0 2>&1"

		If (${LatestTag} -and -not ${UseHead})
		{
			Write-Host "Synchronizing: ${LocalLib} from ${GitUrl} tag ${LatestTag}"

			$Output = Invoke-Expression -Command "${Git} checkout --quiet tags/${LatestTag} 2>&1"
		}
		Else
		{
			Write-Host "Synchronizing: ${LocalLib} from ${GitUrl} HEAD"
		}
	}
	Finally
	{
		Pop-Location
	}
	If (Test-Path ${LocalLib}-${pid})
	{
		$LocalLibVersion = Get-Content -Path ${LocalLib}-${pid}\configure.ac | select -skip 4 -first 1 | % { $_ -Replace " \[","" } | % { $_ -Replace "\],","" }

		If (Test-Path ${LocalLib})
		{
			Remove-Item -Path ${LocalLib} -Force -Recurse
		}
		New-Item -ItemType directory -Path ${LocalLib} -Force | Out-Null

		If (Test-Path ${LocalLib})
		{
			Copy-Item -Path ${LocalLib}-${pid}\${LocalLib}\*.[chly] -Destination ${LocalLib}\
			Get-Content -Path ${LocalLib}-${pid}\${LocalLib}\${LocalLib}_definitions.h.in | % { $_ -Replace "@VERSION@",${LocalLibVersion} } > ${LocalLib}\${LocalLib}_definitions.h
		}
		Remove-Item -Path ${LocalLib}-${pid} -Force -Recurse

		$NamePrefix = ""

		ForEach (${DirectoryElement} in Get-ChildItem -Path "${LocalLib}\*.l")
		{
			$OutputFile = ${DirectoryElement} -Replace ".l$",".c"

			$NamePrefix = Split-Path -path ${DirectoryElement} -leaf
			$NamePrefix = ${NamePrefix} -Replace "^${LocalLib}_",""
			$NamePrefix = ${NamePrefix} -Replace ".l$","_"

			# PowerShell will raise NativeCommandError if win_flex writes to stdout or stderr
			# therefore 2>&1 is added and the output is stored in a variable.
			$Output = Invoke-Expression -Command "& '${WinFlex}' -Cf ${DirectoryElement} 2>&1"
			Write-Host ${Output}

			# Moving manually sicne win_flex -o <filename> does not provide the expected behavior.
			Move-Item "lex.yy.c" ${OutputFile} -force
		}

		ForEach (${DirectoryElement} in Get-ChildItem -Path "${LocalLib}\*.y")
		{
			$OutputFile = ${DirectoryElement} -Replace ".y$",".c"

			# PowerShell will raise NativeCommandError if win_bison writes to stdout or stderr
			# therefore 2>&1 is added and the output is stored in a variable.
			$Output = Invoke-Expression -Command "& '${WinBison}' -d -v -l -p ${NamePrefix} -o ${OutputFile} ${DirectoryElement} 2>&1"
			Write-Host ${Output}
		}
	}
}


```

`synclibs.sh`:

```sh
#!/bin/sh
# Script that synchronizes the local library dependencies
#
# Version: 20231023

EXIT_SUCCESS=0;
EXIT_FAILURE=1;

GIT_URL_PREFIX="https://github.com/libyal";
LOCAL_LIBS="libbfio libcdata libcerror libcfile libclocale libcnotify libcpath libcsplit libcthreads libfcache libfdata libfdatetime libuna";

OLDIFS=$IFS;
IFS=" ";

for LOCAL_LIB in ${LOCAL_LIBS};
do
	GIT_URL="${GIT_URL_PREFIX}/${LOCAL_LIB}.git";

	git clone --quiet ${GIT_URL} ${LOCAL_LIB}-$$;

	if ! test -d ${LOCAL_LIB}-$$;
	then
		echo "Unable to git clone: ${GIT_URL}";

		IFS=$OLDIFS;

		exit ${EXIT_FAILURE};
	fi
	(cd ${LOCAL_LIB}-$$ && git fetch --quiet --all --tags --prune)

	LATEST_TAG=`cd ${LOCAL_LIB}-$$ && git describe --tags --abbrev=0`;

	if test -n ${LATEST_TAG} && test "$1" != "--use-head";
	then
		echo "Synchronizing: ${LOCAL_LIB} from ${GIT_URL} tag ${LATEST_TAG}";

		(cd ${LOCAL_LIB}-$$ && git checkout --quiet tags/${LATEST_TAG});
	else
		echo "Synchronizing: ${LOCAL_LIB} from ${GIT_URL} HEAD";
	fi

	rm -rf ${LOCAL_LIB};
	mkdir ${LOCAL_LIB};

	if ! test -d ${LOCAL_LIB};
	then
		echo "Missing directory: ${LOCAL_LIB}";

		IFS=$OLDIFS;

		exit ${EXIT_FAILURE};
	fi

	LOCAL_LIB_UPPER=`echo "${LOCAL_LIB}" | tr "[a-z]" "[A-Z]"`;
	# Note that sed on FreeBSD does not support \s hence that we use [[:space:]] instead.
	LOCAL_LIB_VERSION=`grep -A 2 AC_INIT ${LOCAL_LIB}-$$/configure.ac | tail -n 1 | sed 's/^[[:space:]]*\[\([0-9]*\)\],[[:space:]]*$/\1/'`;
	LOCAL_LIB_MAKEFILE_AM="${LOCAL_LIB}/Makefile.am";

	cp ${LOCAL_LIB}-$$/${LOCAL_LIB}/*.[chly] ${LOCAL_LIB};
	cp ${LOCAL_LIB}-$$/${LOCAL_LIB_MAKEFILE_AM} ${LOCAL_LIB_MAKEFILE_AM};

	# Make the necessary changes to libyal/Makefile.am

SED_SCRIPT="/AM_CPPFLAGS = / {
	i\\
if HAVE_LOCAL_${LOCAL_LIB_UPPER}
}

/lib_LTLIBRARIES = / {
	s/lib_LTLIBRARIES/noinst_LTLIBRARIES/
}

/${LOCAL_LIB}\.c/ {
	d
}

/${LOCAL_LIB}_la_LIBADD/ {
:loop1
	/${LOCAL_LIB}_la_LDFLAGS/ {
		N
		i\\
endif
		d
	}
	/${LOCAL_LIB}_la_LDFLAGS/ !{
		N
		b loop1
	}
}

/${LOCAL_LIB}_la_LDFLAGS/ {
	N
	i\\
endif
	d
}

/distclean: clean/ {
	n
	N
	d
}";
	echo "${SED_SCRIPT}" >> ${LOCAL_LIB}-$$.sed;
	sed -i'~' -f ${LOCAL_LIB}-$$.sed ${LOCAL_LIB_MAKEFILE_AM};
	rm -f ${LOCAL_LIB}-$$.sed;

	sed -i'~' "/AM_CPPFLAGS = /,/noinst_LTLIBRARIES = / { N; s/\\\\\\n.@${LOCAL_LIB_UPPER}_DLL_EXPORT@//; P; D; }" ${LOCAL_LIB_MAKEFILE_AM};
	sed -i'~' "/${LOCAL_LIB}_definitions.h.in/d" ${LOCAL_LIB_MAKEFILE_AM};
	sed -i'~' "/${LOCAL_LIB}\\.rc/d" ${LOCAL_LIB_MAKEFILE_AM};

	if test ${LOCAL_LIB} = "libfplist";
	then
		# TODO: make this more generic to strip the last \\
		sed -i'~' '/EXTRA_DIST = /,/^$/s/libfplist_xml_scanner.c \\/libfplist_xml_scanner.c/' ${LOCAL_LIB_MAKEFILE_AM};

	elif test ${LOCAL_LIB} = "libodraw";
	then
		# TODO: make this more generic to strip the last \\
		sed -i'~' '/EXTRA_DIST = /,/^$/s/libodraw_cue_scanner.c \\/libodraw_cue_scanner.c/' ${LOCAL_LIB_MAKEFILE_AM};

	else
		sed -i'~' '/EXTRA_DIST = /,/^$/d' ${LOCAL_LIB_MAKEFILE_AM};
	fi

SED_SCRIPT="/^$/ {
	x
	N
	/endif$/ {
		a\\

		D
	}
}";
	echo "${SED_SCRIPT}" >> ${LOCAL_LIB}-$$.sed;
	sed -i'~' -f ${LOCAL_LIB}-$$.sed ${LOCAL_LIB_MAKEFILE_AM};
	rm -f ${LOCAL_LIB}-$$.sed;

	# Make the necessary changes to libcfile/Makefile.am
	if test ${LOCAL_LIB} = "libcfile";
	then
		if ! test -f "m4/libuna.m4";
		then
			sed -i'~' 's?@LIBUNA_CPPFLAGS@?-I$(top_srcdir)/libuna?' ${LOCAL_LIB_MAKEFILE_AM};
		fi
	fi

	# Make the necessary changes to libfplist/Makefile.am
	if test ${LOCAL_LIB} = "libfplist";
	then
		if test -f "m4/libfdatetime.m4";
		then
			sed -i'~' '/@LIBFGUID_CPPFLAGS@/{h; s/FGUID/FDATETIME/; p; g;}' ${LOCAL_LIB_MAKEFILE_AM};
		fi
	fi

	# Make the necessary changes to libfvalue/Makefile.am
	if test ${LOCAL_LIB} = "libfvalue";
	then
		if ! test -f "m4/libfdatetime.m4";
		then
			sed -i'~' '/@LIBFDATETIME_CPPFLAGS@/d' ${LOCAL_LIB_MAKEFILE_AM};
		fi
		if ! test -f "m4/libfguid.m4";
		then
			sed -i'~' '/@LIBFGUID_CPPFLAGS@/d' ${LOCAL_LIB_MAKEFILE_AM};
		fi
		if ! test -f "m4/libfwnt.m4";
		then
			sed -i'~' '/@LIBFWNT_CPPFLAGS@/d' ${LOCAL_LIB_MAKEFILE_AM};
		fi
		if ! test -f "m4/libuna.m4";
		then
			sed -i'~' '/@LIBUNA_CPPFLAGS@/d' ${LOCAL_LIB_MAKEFILE_AM};
		fi
	fi

	# Make the necessary changes to libsmraw/Makefile.am
	if test ${LOCAL_LIB} = "libsmraw";
	then
		if test -f "m4/libfdatetime.m4";
		then
			sed -i'~' '/@LIBFVALUE_CPPFLAGS@/{h; s/FVALUE/FDATETIME/; p; g;}' ${LOCAL_LIB_MAKEFILE_AM};
		fi
		if test -f "m4/libfguid.m4";
		then
			sed -i'~' '/@LIBFVALUE_CPPFLAGS@/{h; s/FVALUE/FGUID/; p; g;}' ${LOCAL_LIB_MAKEFILE_AM};
		fi
	fi

	# Remove libyal/libyal.c
	rm -f ${LOCAL_LIB}/${LOCAL_LIB}.c;

	# Make the necessary changes to libyal/libyal_defitions.h
	cp ${LOCAL_LIB}-$$/${LOCAL_LIB}/${LOCAL_LIB}_definitions.h.in ${LOCAL_LIB}/${LOCAL_LIB}_definitions.h;
	sed -i'~' "s/@VERSION@/${LOCAL_LIB_VERSION}/" ${LOCAL_LIB}/${LOCAL_LIB}_definitions.h;

	rm -rf ${LOCAL_LIB}-$$;
done

IFS=$OLDIFS;

exit ${EXIT_SUCCESS};


```

`synctestdata.sh`:

```sh
#!/bin/sh
# Script that synchronizes the local test data
#
# Version: 20161009

TEST_SET="public";
TEST_INPUT_DIRECTORY="tests/input";
TEST_FILES="WER1090.tmp.mdmp";

mkdir -p "${TEST_INPUT_DIRECTORY}/${TEST_SET}";

for TEST_FILE in ${TEST_FILES};
do
	URL="https://github.com/log2timeline/plaso/blob/main/test_data/${TEST_FILE}?raw=true";

	curl -L -o "${TEST_INPUT_DIRECTORY}/${TEST_SET}/${TEST_FILE}" ${URL};
done


```

`tests/Makefile.am`:

```am
AUTOMAKE_OPTIONS = subdir-objects

AM_CPPFLAGS = \
	-I$(top_srcdir)/include \
	-I$(top_srcdir)/common \
	@LIBCERROR_CPPFLAGS@ \
	@LIBCTHREADS_CPPFLAGS@ \
	@LIBCDATA_CPPFLAGS@ \
	@LIBCLOCALE_CPPFLAGS@ \
	@LIBCNOTIFY_CPPFLAGS@ \
	@LIBCSPLIT_CPPFLAGS@ \
	@LIBUNA_CPPFLAGS@ \
	@LIBCFILE_CPPFLAGS@ \
	@LIBCPATH_CPPFLAGS@ \
	@LIBBFIO_CPPFLAGS@ \
	@LIBFCACHE_CPPFLAGS@ \
	@LIBFDATA_CPPFLAGS@ \
	@LIBFDATETIME_CPPFLAGS@ \
	@PTHREAD_CPPFLAGS@ \
	@LIBMDMP_DLL_IMPORT@

TESTS = \
	test_library.sh \
	test_tools.sh \
	test_mdmpinfo.sh

check_SCRIPTS = \
	test_library.sh \
	test_manpage.sh \
	test_mdmpinfo.sh \
	test_runner.sh \
	test_tools.sh

EXTRA_DIST = \
	$(check_SCRIPTS)

check_PROGRAMS = \
	mdmp_test_error \
	mdmp_test_file \
	mdmp_test_io_handle \
	mdmp_test_notify \
	mdmp_test_stream \
	mdmp_test_stream_descriptor \
	mdmp_test_stream_io_handle \
	mdmp_test_support \
	mdmp_test_tools_info_handle \
	mdmp_test_tools_output \
	mdmp_test_tools_signal

mdmp_test_error_SOURCES = \
	mdmp_test_error.c \
	mdmp_test_libmdmp.h \
	mdmp_test_macros.h \
	mdmp_test_unused.h

mdmp_test_error_LDADD = \
	../libmdmp/libmdmp.la

mdmp_test_file_SOURCES = \
	mdmp_test_file.c \
	mdmp_test_functions.c mdmp_test_functions.h \
	mdmp_test_getopt.c mdmp_test_getopt.h \
	mdmp_test_libbfio.h \
	mdmp_test_libcerror.h \
	mdmp_test_libclocale.h \
	mdmp_test_libcnotify.h \
	mdmp_test_libmdmp.h \
	mdmp_test_libuna.h \
	mdmp_test_macros.h \
	mdmp_test_memory.c mdmp_test_memory.h \
	mdmp_test_unused.h

mdmp_test_file_LDADD = \
	@LIBBFIO_LIBADD@ \
	@LIBCPATH_LIBADD@ \
	@LIBCFILE_LIBADD@ \
	@LIBUNA_LIBADD@ \
	@LIBCSPLIT_LIBADD@ \
	@LIBCNOTIFY_LIBADD@ \
	@LIBCLOCALE_LIBADD@ \
	@LIBCDATA_LIBADD@ \
	../libmdmp/libmdmp.la \
	@LIBCTHREADS_LIBADD@ \
	@LIBCERROR_LIBADD@ \
	@PTHREAD_LIBADD@

mdmp_test_io_handle_SOURCES = \
	mdmp_test_io_handle.c \
	mdmp_test_libcerror.h \
	mdmp_test_libmdmp.h \
	mdmp_test_macros.h \
	mdmp_test_memory.c mdmp_test_memory.h \
	mdmp_test_unused.h

mdmp_test_io_handle_LDADD = \
	../libmdmp/libmdmp.la \
	@LIBCERROR_LIBADD@

mdmp_test_notify_SOURCES = \
	mdmp_test_libcerror.h \
	mdmp_test_libmdmp.h \
	mdmp_test_macros.h \
	mdmp_test_notify.c \
	mdmp_test_unused.h

mdmp_test_notify_LDADD = \
	../libmdmp/libmdmp.la \
	@LIBCERROR_LIBADD@

mdmp_test_stream_SOURCES = \
	mdmp_test_libcerror.h \
	mdmp_test_libmdmp.h \
	mdmp_test_macros.h \
	mdmp_test_memory.c mdmp_test_memory.h \
	mdmp_test_stream.c \
	mdmp_test_unused.h

mdmp_test_stream_LDADD = \
	../libmdmp/libmdmp.la \
	@LIBCERROR_LIBADD@

mdmp_test_stream_descriptor_SOURCES = \
	mdmp_test_libcerror.h \
	mdmp_test_libmdmp.h \
	mdmp_test_macros.h \
	mdmp_test_memory.c mdmp_test_memory.h \
	mdmp_test_stream_descriptor.c \
	mdmp_test_unused.h

mdmp_test_stream_descriptor_LDADD = \
	../libmdmp/libmdmp.la \
	@LIBCERROR_LIBADD@

mdmp_test_stream_io_handle_SOURCES = \
	mdmp_test_libcerror.h \
	mdmp_test_libmdmp.h \
	mdmp_test_macros.h \
	mdmp_test_memory.c mdmp_test_memory.h \
	mdmp_test_stream_io_handle.c \
	mdmp_test_unused.h

mdmp_test_stream_io_handle_LDADD = \
	../libmdmp/libmdmp.la \
	@LIBCERROR_LIBADD@

mdmp_test_support_SOURCES = \
	mdmp_test_functions.c mdmp_test_functions.h \
	mdmp_test_getopt.c mdmp_test_getopt.h \
	mdmp_test_libbfio.h \
	mdmp_test_libcerror.h \
	mdmp_test_libclocale.h \
	mdmp_test_libcnotify.h \
	mdmp_test_libmdmp.h \
	mdmp_test_libuna.h \
	mdmp_test_macros.h \
	mdmp_test_memory.c mdmp_test_memory.h \
	mdmp_test_support.c \
	mdmp_test_unused.h

mdmp_test_support_LDADD = \
	@LIBBFIO_LIBADD@ \
	@LIBCPATH_LIBADD@ \
	@LIBCFILE_LIBADD@ \
	@LIBUNA_LIBADD@ \
	@LIBCSPLIT_LIBADD@ \
	@LIBCNOTIFY_LIBADD@ \
	@LIBCLOCALE_LIBADD@ \
	@LIBCDATA_LIBADD@ \
	../libmdmp/libmdmp.la \
	@LIBCERROR_LIBADD@

mdmp_test_tools_info_handle_SOURCES = \
	../mdmptools/info_handle.c ../mdmptools/info_handle.h \
	../mdmptools/mdmpinput.c ../mdmptools/mdmpinput.h \
	mdmp_test_libcerror.h \
	mdmp_test_macros.h \
	mdmp_test_memory.c mdmp_test_memory.h \
	mdmp_test_tools_info_handle.c \
	mdmp_test_unused.h

mdmp_test_tools_info_handle_LDADD = \
	@LIBCLOCALE_LIBADD@ \
	../libmdmp/libmdmp.la \
	@LIBCERROR_LIBADD@

mdmp_test_tools_output_SOURCES = \
	../mdmptools/mdmptools_output.c ../mdmptools/mdmptools_output.h \
	mdmp_test_libcerror.h \
	mdmp_test_macros.h \
	mdmp_test_tools_output.c \
	mdmp_test_unused.h

mdmp_test_tools_output_LDADD = \
	../libmdmp/libmdmp.la \
	@LIBCERROR_LIBADD@

mdmp_test_tools_signal_SOURCES = \
	../mdmptools/mdmptools_signal.c ../mdmptools/mdmptools_signal.h \
	mdmp_test_libcerror.h \
	mdmp_test_macros.h \
	mdmp_test_tools_signal.c \
	mdmp_test_unused.h

mdmp_test_tools_signal_LDADD = \
	../libmdmp/libmdmp.la \
	@LIBCERROR_LIBADD@

MAINTAINERCLEANFILES = \
	Makefile.in

distclean: clean
	-rm -f Makefile


```

`tests/build.sh`:

```sh
#!/bin/sh
# Script to build from source
#
# Version: 20201121

set -e

./synclibs.sh --use-head
./autogen.sh
./configure "$@"
make > /dev/null


```

`tests/lsan.suppressions`:

```suppressions
leak:/lib*/libpython*

```

`tests/mdmp_test_error.c`:

```c
/*
 * Library error functions test program
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <types.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_libmdmp.h"
#include "mdmp_test_macros.h"
#include "mdmp_test_unused.h"

/* Tests the libmdmp_error_free function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_error_free(
     void )
{
	/* Test invocation of function only
	 */
	libmdmp_error_free(
	 NULL );

	return( 1 );
}

/* Tests the libmdmp_error_fprint function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_error_fprint(
     void )
{
	/* Test invocation of function only
	 */
	libmdmp_error_fprint(
	 NULL,
	 NULL );

	return( 1 );
}

/* Tests the libmdmp_error_sprint function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_error_sprint(
     void )
{
	/* Test invocation of function only
	 */
	libmdmp_error_sprint(
	 NULL,
	 NULL,
	 0 );

	return( 1 );
}

/* Tests the libmdmp_error_backtrace_fprint function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_error_backtrace_fprint(
     void )
{
	/* Test invocation of function only
	 */
	libmdmp_error_backtrace_fprint(
	 NULL,
	 NULL );

	return( 1 );
}

/* Tests the libmdmp_error_backtrace_sprint function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_error_backtrace_sprint(
     void )
{
	/* Test invocation of function only
	 */
	libmdmp_error_backtrace_sprint(
	 NULL,
	 NULL,
	 0 );

	return( 1 );
}

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     wchar_t * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#else
int main(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     char * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#endif
{
	MDMP_TEST_UNREFERENCED_PARAMETER( argc )
	MDMP_TEST_UNREFERENCED_PARAMETER( argv )

	MDMP_TEST_RUN(
	 "libmdmp_error_free",
	 mdmp_test_error_free );

	MDMP_TEST_RUN(
	 "libmdmp_error_fprint",
	 mdmp_test_error_fprint );

	MDMP_TEST_RUN(
	 "libmdmp_error_sprint",
	 mdmp_test_error_sprint );

	MDMP_TEST_RUN(
	 "libmdmp_error_backtrace_fprint",
	 mdmp_test_error_backtrace_fprint );

	MDMP_TEST_RUN(
	 "libmdmp_error_backtrace_sprint",
	 mdmp_test_error_backtrace_sprint );

	return( EXIT_SUCCESS );

on_error:
	return( EXIT_FAILURE );
}


```

`tests/mdmp_test_file.c`:

```c
/*
 * Library file type test program
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <narrow_string.h>
#include <system_string.h>
#include <types.h>
#include <wide_string.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_functions.h"
#include "mdmp_test_getopt.h"
#include "mdmp_test_libbfio.h"
#include "mdmp_test_libcerror.h"
#include "mdmp_test_libmdmp.h"
#include "mdmp_test_macros.h"
#include "mdmp_test_memory.h"
#include "mdmp_test_unused.h"

#include "../libmdmp/libmdmp_file.h"

#if !defined( LIBMDMP_HAVE_BFIO )

LIBMDMP_EXTERN \
int libmdmp_check_file_signature_file_io_handle(
     libbfio_handle_t *file_io_handle,
     libcerror_error_t **error );

LIBMDMP_EXTERN \
int libmdmp_file_open_file_io_handle(
     libmdmp_file_t *file,
     libbfio_handle_t *file_io_handle,
     int access_flags,
     libmdmp_error_t **error );

#endif /* !defined( LIBMDMP_HAVE_BFIO ) */

#if defined( HAVE_WIDE_SYSTEM_CHARACTER ) && SIZEOF_WCHAR_T != 2 && SIZEOF_WCHAR_T != 4
#error Unsupported size of wchar_t
#endif

/* Define to make mdmp_test_file generate verbose output
#define MDMP_TEST_FILE_VERBOSE
 */

/* Creates and opens a source file
 * Returns 1 if successful or -1 on error
 */
int mdmp_test_file_open_source(
     libmdmp_file_t **file,
     libbfio_handle_t *file_io_handle,
     libcerror_error_t **error )
{
	static char *function = "mdmp_test_file_open_source";
	int result            = 0;

	if( file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	if( file_io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file IO handle.",
		 function );

		return( -1 );
	}
	if( libmdmp_file_initialize(
	     file,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to initialize file.",
		 function );

		goto on_error;
	}
	result = libmdmp_file_open_file_io_handle(
	          *file,
	          file_io_handle,
	          LIBMDMP_OPEN_READ,
	          error );

	if( result != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_OPEN_FAILED,
		 "%s: unable to open file.",
		 function );

		goto on_error;
	}
	return( 1 );

on_error:
	if( *file != NULL )
	{
		libmdmp_file_free(
		 file,
		 NULL );
	}
	return( -1 );
}

/* Closes and frees a source file
 * Returns 1 if successful or -1 on error
 */
int mdmp_test_file_close_source(
     libmdmp_file_t **file,
     libcerror_error_t **error )
{
	static char *function = "mdmp_test_file_close_source";
	int result            = 0;

	if( file == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file.",
		 function );

		return( -1 );
	}
	if( libmdmp_file_close(
	     *file,
	     error ) != 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_CLOSE_FAILED,
		 "%s: unable to close file.",
		 function );

		result = -1;
	}
	if( libmdmp_file_free(
	     file,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,
		 "%s: unable to free file.",
		 function );

		result = -1;
	}
	return( result );
}

/* Tests the libmdmp_file_initialize function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_file_initialize(
     void )
{
	libcerror_error_t *error        = NULL;
	libmdmp_file_t *file            = NULL;
	int result                      = 0;

#if defined( HAVE_MDMP_TEST_MEMORY )
	int number_of_malloc_fail_tests = 1;
	int number_of_memset_fail_tests = 1;
	int test_number                 = 0;
#endif

	/* Test regular cases
	 */
	result = libmdmp_file_initialize(
	          &file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "file",
	 file );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = libmdmp_file_free(
	          &file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "file",
	 file );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_file_initialize(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	file = (libmdmp_file_t *) 0x12345678UL;

	result = libmdmp_file_initialize(
	          &file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	file = NULL;

#if defined( HAVE_MDMP_TEST_MEMORY )

	for( test_number = 0;
	     test_number < number_of_malloc_fail_tests;
	     test_number++ )
	{
		/* Test libmdmp_file_initialize with malloc failing
		 */
		mdmp_test_malloc_attempts_before_fail = test_number;

		result = libmdmp_file_initialize(
		          &file,
		          &error );

		if( mdmp_test_malloc_attempts_before_fail != -1 )
		{
			mdmp_test_malloc_attempts_before_fail = -1;

			if( file != NULL )
			{
				libmdmp_file_free(
				 &file,
				 NULL );
			}
		}
		else
		{
			MDMP_TEST_ASSERT_EQUAL_INT(
			 "result",
			 result,
			 -1 );

			MDMP_TEST_ASSERT_IS_NULL(
			 "file",
			 file );

			MDMP_TEST_ASSERT_IS_NOT_NULL(
			 "error",
			 error );

			libcerror_error_free(
			 &error );
		}
	}
	for( test_number = 0;
	     test_number < number_of_memset_fail_tests;
	     test_number++ )
	{
		/* Test libmdmp_file_initialize with memset failing
		 */
		mdmp_test_memset_attempts_before_fail = test_number;

		result = libmdmp_file_initialize(
		          &file,
		          &error );

		if( mdmp_test_memset_attempts_before_fail != -1 )
		{
			mdmp_test_memset_attempts_before_fail = -1;

			if( file != NULL )
			{
				libmdmp_file_free(
				 &file,
				 NULL );
			}
		}
		else
		{
			MDMP_TEST_ASSERT_EQUAL_INT(
			 "result",
			 result,
			 -1 );

			MDMP_TEST_ASSERT_IS_NULL(
			 "file",
			 file );

			MDMP_TEST_ASSERT_IS_NOT_NULL(
			 "error",
			 error );

			libcerror_error_free(
			 &error );
		}
	}
#endif /* defined( HAVE_MDMP_TEST_MEMORY ) */

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	if( file != NULL )
	{
		libmdmp_file_free(
		 &file,
		 NULL );
	}
	return( 0 );
}

/* Tests the libmdmp_file_free function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_file_free(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test error cases
	 */
	result = libmdmp_file_free(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* Tests the libmdmp_file_open function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_file_open(
     const system_character_t *source )
{
	char narrow_source[ 256 ];

	libcerror_error_t *error = NULL;
	libmdmp_file_t *file     = NULL;
	int result               = 0;

	/* Initialize test
	 */
	result = mdmp_test_get_narrow_source(
	          source,
	          narrow_source,
	          256,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = libmdmp_file_initialize(
	          &file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "file",
	 file );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test open
	 */
	result = libmdmp_file_open(
	          file,
	          narrow_source,
	          LIBMDMP_OPEN_READ,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_file_open(
	          NULL,
	          narrow_source,
	          LIBMDMP_OPEN_READ,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	result = libmdmp_file_open(
	          file,
	          NULL,
	          LIBMDMP_OPEN_READ,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	result = libmdmp_file_open(
	          file,
	          narrow_source,
	          -1,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	/* Test open when already opened
	 */
	result = libmdmp_file_open(
	          file,
	          narrow_source,
	          LIBMDMP_OPEN_READ,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	/* Clean up
	 */
	result = libmdmp_file_free(
	          &file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "file",
	 file );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	if( file != NULL )
	{
		libmdmp_file_free(
		 &file,
		 NULL );
	}
	return( 0 );
}

#if defined( HAVE_WIDE_CHARACTER_TYPE )

/* Tests the libmdmp_file_open_wide function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_file_open_wide(
     const system_character_t *source )
{
	wchar_t wide_source[ 256 ];

	libcerror_error_t *error = NULL;
	libmdmp_file_t *file     = NULL;
	int result               = 0;

	/* Initialize test
	 */
	result = mdmp_test_get_wide_source(
	          source,
	          wide_source,
	          256,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = libmdmp_file_initialize(
	          &file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "file",
	 file );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test open
	 */
	result = libmdmp_file_open_wide(
	          file,
	          wide_source,
	          LIBMDMP_OPEN_READ,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_file_open_wide(
	          NULL,
	          wide_source,
	          LIBMDMP_OPEN_READ,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	result = libmdmp_file_open_wide(
	          file,
	          NULL,
	          LIBMDMP_OPEN_READ,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	result = libmdmp_file_open_wide(
	          file,
	          wide_source,
	          -1,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	/* Test open when already opened
	 */
	result = libmdmp_file_open_wide(
	          file,
	          wide_source,
	          LIBMDMP_OPEN_READ,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	/* Clean up
	 */
	result = libmdmp_file_free(
	          &file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "file",
	 file );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	if( file != NULL )
	{
		libmdmp_file_free(
		 &file,
		 NULL );
	}
	return( 0 );
}

#endif /* defined( HAVE_WIDE_CHARACTER_TYPE ) */

/* Tests the libmdmp_file_open_file_io_handle function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_file_open_file_io_handle(
     const system_character_t *source )
{
	libbfio_handle_t *file_io_handle = NULL;
	libcerror_error_t *error         = NULL;
	libmdmp_file_t *file             = NULL;
	size_t string_length             = 0;
	int result                       = 0;

	/* Initialize test
	 */
	result = libbfio_file_initialize(
	          &file_io_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

        MDMP_TEST_ASSERT_IS_NOT_NULL(
         "file_io_handle",
         file_io_handle );

        MDMP_TEST_ASSERT_IS_NULL(
         "error",
         error );

	string_length = system_string_length(
	                 source );

#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
	result = libbfio_file_set_name_wide(
	          file_io_handle,
	          source,
	          string_length,
	          &error );
#else
	result = libbfio_file_set_name(
	          file_io_handle,
	          source,
	          string_length,
	          &error );
#endif
	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

        MDMP_TEST_ASSERT_IS_NULL(
         "error",
         error );

	result = libmdmp_file_initialize(
	          &file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "file",
	 file );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test open
	 */
	result = libmdmp_file_open_file_io_handle(
	          file,
	          file_io_handle,
	          LIBMDMP_OPEN_READ,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_file_open_file_io_handle(
	          NULL,
	          file_io_handle,
	          LIBMDMP_OPEN_READ,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	result = libmdmp_file_open_file_io_handle(
	          file,
	          NULL,
	          LIBMDMP_OPEN_READ,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	result = libmdmp_file_open_file_io_handle(
	          file,
	          file_io_handle,
	          -1,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	/* Test open when already opened
	 */
	result = libmdmp_file_open_file_io_handle(
	          file,
	          file_io_handle,
	          LIBMDMP_OPEN_READ,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	/* Clean up
	 */
	result = libmdmp_file_free(
	          &file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "file",
	 file );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = libbfio_handle_free(
	          &file_io_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
         "file_io_handle",
         file_io_handle );

        MDMP_TEST_ASSERT_IS_NULL(
         "error",
         error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	if( file != NULL )
	{
		libmdmp_file_free(
		 &file,
		 NULL );
	}
	if( file_io_handle != NULL )
	{
		libbfio_handle_free(
		 &file_io_handle,
		 NULL );
	}
	return( 0 );
}

/* Tests the libmdmp_file_close function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_file_close(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test error cases
	 */
	result = libmdmp_file_close(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* Tests the libmdmp_file_open and libmdmp_file_close functions
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_file_open_close(
     const system_character_t *source )
{
	libcerror_error_t *error = NULL;
	libmdmp_file_t *file     = NULL;
	int result               = 0;

	/* Initialize test
	 */
	result = libmdmp_file_initialize(
	          &file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "file",
	 file );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test open and close
	 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
	result = libmdmp_file_open_wide(
	          file,
	          source,
	          LIBMDMP_OPEN_READ,
	          &error );
#else
	result = libmdmp_file_open(
	          file,
	          source,
	          LIBMDMP_OPEN_READ,
	          &error );
#endif

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = libmdmp_file_close(
	          file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 0 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test open and close a second time to validate clean up on close
	 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
	result = libmdmp_file_open_wide(
	          file,
	          source,
	          LIBMDMP_OPEN_READ,
	          &error );
#else
	result = libmdmp_file_open(
	          file,
	          source,
	          LIBMDMP_OPEN_READ,
	          &error );
#endif

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = libmdmp_file_close(
	          file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 0 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Clean up
	 */
	result = libmdmp_file_free(
	          &file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "file",
	 file );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	if( file != NULL )
	{
		libmdmp_file_free(
		 &file,
		 NULL );
	}
	return( 0 );
}

/* Tests the libmdmp_file_signal_abort function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_file_signal_abort(
     libmdmp_file_t *file )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test regular cases
	 */
	result = libmdmp_file_signal_abort(
	          file,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_file_signal_abort(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* Tests the libmdmp_file_get_number_of_streams function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_file_get_number_of_streams(
     libmdmp_file_t *file )
{
	libcerror_error_t *error     = NULL;
	int number_of_streams        = 0;
	int number_of_streams_is_set = 0;
	int result                   = 0;

	/* Test regular cases
	 */
	result = libmdmp_file_get_number_of_streams(
	          file,
	          &number_of_streams,
	          &error );

	MDMP_TEST_ASSERT_NOT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	number_of_streams_is_set = result;

	/* Test error cases
	 */
	result = libmdmp_file_get_number_of_streams(
	          NULL,
	          &number_of_streams,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	if( number_of_streams_is_set != 0 )
	{
		result = libmdmp_file_get_number_of_streams(
		          file,
		          NULL,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 -1 );

		MDMP_TEST_ASSERT_IS_NOT_NULL(
		 "error",
		 error );

		libcerror_error_free(
		 &error );
	}
	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* Tests the libmdmp_file_get_stream function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_file_get_stream(
     libmdmp_file_t *file )
{
	libcerror_error_t *error = NULL;
	libmdmp_stream_t *stream = 0;
	int result               = 0;

	/* Test regular cases
	 */
	result = libmdmp_file_get_stream(
	          file,
	          0,
	          &stream,
	          &error );

	MDMP_TEST_ASSERT_NOT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "stream",
	 stream );

	result = libmdmp_stream_free(
	          &stream,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_file_get_stream(
	          NULL,
	          0,
	          &stream,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "stream",
	 stream );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	result = libmdmp_file_get_stream(
	          file,
	          -1,
	          &stream,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "stream",
	 stream );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	result = libmdmp_file_get_stream(
	          file,
	          0,
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "stream",
	 stream );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain(
     int argc,
     wchar_t * const argv[] )
#else
int main(
     int argc,
     char * const argv[] )
#endif
{
	libbfio_handle_t *file_io_handle = NULL;
	libcerror_error_t *error         = NULL;
	libmdmp_file_t *file             = NULL;
	system_character_t *source       = NULL;
	system_integer_t option          = 0;
	size_t string_length             = 0;
	int result                       = 0;

	while( ( option = mdmp_test_getopt(
	                   argc,
	                   argv,
	                   _SYSTEM_STRING( "" ) ) ) != (system_integer_t) -1 )
	{
		switch( option )
		{
			case (system_integer_t) '?':
			default:
				fprintf(
				 stderr,
				 "Invalid argument: %" PRIs_SYSTEM ".\n",
				 argv[ optind - 1 ] );

				return( EXIT_FAILURE );
		}
	}
	if( optind < argc )
	{
		source = argv[ optind ];
	}
#if defined( HAVE_DEBUG_OUTPUT ) && defined( MDMP_TEST_FILE_VERBOSE )
	libmdmp_notify_set_verbose(
	 1 );
	libmdmp_notify_set_stream(
	 stderr,
	 NULL );
#endif

	MDMP_TEST_RUN(
	 "libmdmp_file_initialize",
	 mdmp_test_file_initialize );

	MDMP_TEST_RUN(
	 "libmdmp_file_free",
	 mdmp_test_file_free );

#if !defined( __BORLANDC__ ) || ( __BORLANDC__ >= 0x0560 )
	if( source != NULL )
	{
		result = libbfio_file_initialize(
		          &file_io_handle,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

	        MDMP_TEST_ASSERT_IS_NOT_NULL(
	         "file_io_handle",
	         file_io_handle );

	        MDMP_TEST_ASSERT_IS_NULL(
	         "error",
	         error );

		string_length = system_string_length(
		                 source );

#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
		result = libbfio_file_set_name_wide(
		          file_io_handle,
		          source,
		          string_length,
		          &error );
#else
		result = libbfio_file_set_name(
		          file_io_handle,
		          source,
		          string_length,
		          &error );
#endif
		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

	        MDMP_TEST_ASSERT_IS_NULL(
	         "error",
	         error );

		result = libmdmp_check_file_signature_file_io_handle(
		          file_io_handle,
		          &error );

		MDMP_TEST_ASSERT_NOT_EQUAL_INT(
		 "result",
		 result,
		 -1 );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );
	}
	if( result != 0 )
	{
		MDMP_TEST_RUN_WITH_ARGS(
		 "libmdmp_file_open",
		 mdmp_test_file_open,
		 source );

#if defined( HAVE_WIDE_CHARACTER_TYPE )

		MDMP_TEST_RUN_WITH_ARGS(
		 "libmdmp_file_open_wide",
		 mdmp_test_file_open_wide,
		 source );

#endif /* defined( HAVE_WIDE_CHARACTER_TYPE ) */

		MDMP_TEST_RUN_WITH_ARGS(
		 "libmdmp_file_open_file_io_handle",
		 mdmp_test_file_open_file_io_handle,
		 source );

		MDMP_TEST_RUN(
		 "libmdmp_file_close",
		 mdmp_test_file_close );

		MDMP_TEST_RUN_WITH_ARGS(
		 "libmdmp_file_open_close",
		 mdmp_test_file_open_close,
		 source );

		/* Initialize file for tests
		 */
		result = mdmp_test_file_open_source(
		          &file,
		          file_io_handle,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

		MDMP_TEST_ASSERT_IS_NOT_NULL(
		 "file",
		 file );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );

		MDMP_TEST_RUN_WITH_ARGS(
		 "libmdmp_file_signal_abort",
		 mdmp_test_file_signal_abort,
		 file );

#if defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT )

		/* TODO: add tests for libmdmp_file_open_read */

#endif /* defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) */

		MDMP_TEST_RUN_WITH_ARGS(
		 "libmdmp_file_get_number_of_streams",
		 mdmp_test_file_get_number_of_streams,
		 file );

		MDMP_TEST_RUN_WITH_ARGS(
		 "libmdmp_file_get_stream",
		 mdmp_test_file_get_stream,
		 file );

		/* TODO: add tests for libmdmp_file_get_stream_by_type */

		/* Clean up
		 */
		result = mdmp_test_file_close_source(
		          &file,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 0 );

		MDMP_TEST_ASSERT_IS_NULL(
		 "file",
		 file );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );
	}
	if( file_io_handle != NULL )
	{
		result = libbfio_handle_free(
		          &file_io_handle,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

		MDMP_TEST_ASSERT_IS_NULL(
	         "file_io_handle",
	         file_io_handle );

	        MDMP_TEST_ASSERT_IS_NULL(
	         "error",
	         error );
	}
#endif /* !defined( __BORLANDC__ ) || ( __BORLANDC__ >= 0x0560 ) */

	return( EXIT_SUCCESS );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	if( file != NULL )
	{
		libmdmp_file_free(
		 &file,
		 NULL );
	}
	if( file_io_handle != NULL )
	{
		libbfio_handle_free(
		 &file_io_handle,
		 NULL );
	}
	return( EXIT_FAILURE );
}


```

`tests/mdmp_test_file_header.c`:

```c
/*
 * Library file_header type test program
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <types.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_functions.h"
#include "mdmp_test_libbfio.h"
#include "mdmp_test_libcerror.h"
#include "mdmp_test_libmdmp.h"
#include "mdmp_test_macros.h"
#include "mdmp_test_memory.h"
#include "mdmp_test_unused.h"

#include "../libmdmp/libmdmp_file_header.h"

#if defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT )

/* Tests the libmdmp_file_header_initialize function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_file_header_initialize(
     void )
{
	libcerror_error_t *error           = NULL;
	libmdmp_file_header_t *file_header = NULL;
	int result                         = 0;

#if defined( HAVE_MDMP_TEST_MEMORY )
	int number_of_malloc_fail_tests    = 1;
	int number_of_memset_fail_tests    = 1;
	int test_number                    = 0;
#endif

	/* Test regular cases
	 */
	result = libmdmp_file_header_initialize(
	          &file_header,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "file_header",
	 file_header );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = libmdmp_file_header_free(
	          &file_header,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "file_header",
	 file_header );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_file_header_initialize(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	file_header = (libmdmp_file_header_t *) 0x12345678UL;

	result = libmdmp_file_header_initialize(
	          &file_header,
	          &error );

	file_header = NULL;

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

#if defined( HAVE_MDMP_TEST_MEMORY )

	for( test_number = 0;
	     test_number < number_of_malloc_fail_tests;
	     test_number++ )
	{
		/* Test libmdmp_file_header_initialize with malloc failing
		 */
		mdmp_test_malloc_attempts_before_fail = test_number;

		result = libmdmp_file_header_initialize(
		          &file_header,
		          &error );

		if( mdmp_test_malloc_attempts_before_fail != -1 )
		{
			mdmp_test_malloc_attempts_before_fail = -1;

			if( file_header != NULL )
			{
				libmdmp_file_header_free(
				 &file_header,
				 NULL );
			}
		}
		else
		{
			MDMP_TEST_ASSERT_EQUAL_INT(
			 "result",
			 result,
			 -1 );

			MDMP_TEST_ASSERT_IS_NULL(
			 "file_header",
			 file_header );

			MDMP_TEST_ASSERT_IS_NOT_NULL(
			 "error",
			 error );

			libcerror_error_free(
			 &error );
		}
	}
	for( test_number = 0;
	     test_number < number_of_memset_fail_tests;
	     test_number++ )
	{
		/* Test libmdmp_file_header_initialize with memset failing
		 */
		mdmp_test_memset_attempts_before_fail = test_number;

		result = libmdmp_file_header_initialize(
		          &file_header,
		          &error );

		if( mdmp_test_memset_attempts_before_fail != -1 )
		{
			mdmp_test_memset_attempts_before_fail = -1;

			if( file_header != NULL )
			{
				libmdmp_file_header_free(
				 &file_header,
				 NULL );
			}
		}
		else
		{
			MDMP_TEST_ASSERT_EQUAL_INT(
			 "result",
			 result,
			 -1 );

			MDMP_TEST_ASSERT_IS_NULL(
			 "file_header",
			 file_header );

			MDMP_TEST_ASSERT_IS_NOT_NULL(
			 "error",
			 error );

			libcerror_error_free(
			 &error );
		}
	}
#endif /* defined( HAVE_MDMP_TEST_MEMORY ) */

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	if( file_header != NULL )
	{
		libmdmp_file_header_free(
		 &file_header,
		 NULL );
	}
	return( 0 );
}

/* Tests the libmdmp_file_header_free function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_file_header_free(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test error cases
	 */
	result = libmdmp_file_header_free(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

#endif /* defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) */

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     wchar_t * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#else
int main(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     char * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#endif
{
	MDMP_TEST_UNREFERENCED_PARAMETER( argc )
	MDMP_TEST_UNREFERENCED_PARAMETER( argv )

#if defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT )

	MDMP_TEST_RUN(
	 "libmdmp_file_header_initialize",
	 mdmp_test_file_header_initialize );

	MDMP_TEST_RUN(
	 "libmdmp_file_header_free",
	 mdmp_test_file_header_free );

	/* TODO: add tests for libmdmp_file_header_read_data */

	/* TODO: add tests for libmdmp_file_header_read_file_io_handle */

#endif /* defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) */

	return( EXIT_SUCCESS );

on_error:
	return( EXIT_FAILURE );
}


```

`tests/mdmp_test_functions.c`:

```c
/*
 * Functions for testing
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <narrow_string.h>
#include <system_string.h>
#include <types.h>
#include <wide_string.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_libbfio.h"
#include "mdmp_test_libcerror.h"
#include "mdmp_test_libclocale.h"
#include "mdmp_test_libuna.h"

/* Retrieves source as a narrow string
 * Returns 1 if successful or -1 on error
 */
int mdmp_test_get_narrow_source(
     const system_character_t *source,
     char *narrow_string,
     size_t narrow_string_size,
     libcerror_error_t **error )
{
	static char *function     = "mdmp_test_get_narrow_source";
	size_t narrow_source_size = 0;
	size_t source_length      = 0;

#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
	int result                = 0;
#endif

	if( source == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid source.",
		 function );

		return( -1 );
	}
	if( narrow_string == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid narrow string.",
		 function );

		return( -1 );
	}
	if( narrow_string_size > (size_t) SSIZE_MAX )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,
		 "%s: invalid narrow string size value exceeds maximum.",
		 function );

		return( -1 );
	}
	source_length = system_string_length(
	                 source );

	if( source_length > (size_t) ( SSIZE_MAX - 1 ) )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
		 "%s: invalid source length value out of bounds.",
		 function );

		return( -1 );
	}
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
	if( libclocale_codepage == 0 )
	{
#if SIZEOF_WCHAR_T == 4
		result = libuna_utf8_string_size_from_utf32(
		          (libuna_utf32_character_t *) source,
		          source_length + 1,
		          &narrow_source_size,
		          error );
#elif SIZEOF_WCHAR_T == 2
		result = libuna_utf8_string_size_from_utf16(
		          (libuna_utf16_character_t *) source,
		          source_length + 1,
		          &narrow_source_size,
		          error );
#endif
	}
	else
	{
#if SIZEOF_WCHAR_T == 4
		result = libuna_byte_stream_size_from_utf32(
		          (libuna_utf32_character_t *) source,
		          source_length + 1,
		          libclocale_codepage,
		          &narrow_source_size,
		          error );
#elif SIZEOF_WCHAR_T == 2
		result = libuna_byte_stream_size_from_utf16(
		          (libuna_utf16_character_t *) source,
		          source_length + 1,
		          libclocale_codepage,
		          &narrow_source_size,
		          error );
#endif
	}
	if( result != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_CONVERSION,
		 LIBCERROR_CONVERSION_ERROR_GENERIC,
		 "%s: unable to determine narrow string size.",
		 function );

		return( -1 );
	}
#else
	narrow_source_size = source_length + 1;

#endif /* defined( HAVE_WIDE_SYSTEM_CHARACTER ) */

	if( narrow_string_size < narrow_source_size )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,
		 "%s: narrow string too small.",
		 function );

		return( -1 );
	}
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
	if( libclocale_codepage == 0 )
	{
#if SIZEOF_WCHAR_T == 4
		result = libuna_utf8_string_copy_from_utf32(
		          (libuna_utf8_character_t *) narrow_string,
		          narrow_string_size,
		          (libuna_utf32_character_t *) source,
		          source_length + 1,
		          error );
#elif SIZEOF_WCHAR_T == 2
		result = libuna_utf8_string_copy_from_utf16(
		          (libuna_utf8_character_t *) narrow_string,
		          narrow_string_size,
		          (libuna_utf16_character_t *) source,
		          source_length + 1,
		          error );
#endif
	}
	else
	{
#if SIZEOF_WCHAR_T == 4
		result = libuna_byte_stream_copy_from_utf32(
		          (uint8_t *) narrow_string,
		          narrow_string_size,
		          libclocale_codepage,
		          (libuna_utf32_character_t *) source,
		          source_length + 1,
		          error );
#elif SIZEOF_WCHAR_T == 2
		result = libuna_byte_stream_copy_from_utf16(
		          (uint8_t *) narrow_string,
		          narrow_string_size,
		          libclocale_codepage,
		          (libuna_utf16_character_t *) source,
		          source_length + 1,
		          error );
#endif
	}
	if( result != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_CONVERSION,
		 LIBCERROR_CONVERSION_ERROR_GENERIC,
		 "%s: unable to set narrow string.",
		 function );

		return( -1 );
	}
#else
	if( system_string_copy(
	     narrow_string,
	     source,
	     source_length ) == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_COPY_FAILED,
		 "%s: unable to set narrow string.",
		 function );

		return( -1 );
	}
	narrow_string[ source_length ] = 0;

#endif /* defined( HAVE_WIDE_SYSTEM_CHARACTER ) */

	return( 1 );
}

#if defined( HAVE_WIDE_CHARACTER_TYPE )

/* Retrieves source as a wide string
 * Returns 1 if successful or -1 on error
 */
int mdmp_test_get_wide_source(
     const system_character_t *source,
     wchar_t *wide_string,
     size_t wide_string_size,
     libcerror_error_t **error )
{
	static char *function   = "mdmp_test_get_wide_source";
	size_t wide_source_size = 0;
	size_t source_length    = 0;

#if !defined( HAVE_WIDE_SYSTEM_CHARACTER )
	int result              = 0;
#endif

	if( source == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid source.",
		 function );

		return( -1 );
	}
	if( wide_string == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid wide string.",
		 function );

		return( -1 );
	}
	if( wide_string_size > (size_t) SSIZE_MAX )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,
		 "%s: invalid wide string size value exceeds maximum.",
		 function );

		return( -1 );
	}
	source_length = system_string_length(
	                 source );

	if( source_length > (size_t) ( SSIZE_MAX - 1 ) )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
		 "%s: invalid source length value out of bounds.",
		 function );

		return( -1 );
	}
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
	wide_source_size = source_length + 1;
#else
	if( libclocale_codepage == 0 )
	{
#if SIZEOF_WCHAR_T == 4
		result = libuna_utf32_string_size_from_utf8(
		          (libuna_utf8_character_t *) source,
		          source_length + 1,
		          &wide_source_size,
		          error );
#elif SIZEOF_WCHAR_T == 2
		result = libuna_utf16_string_size_from_utf8(
		          (libuna_utf8_character_t *) source,
		          source_length + 1,
		          &wide_source_size,
		          error );
#endif
	}
	else
	{
#if SIZEOF_WCHAR_T == 4
		result = libuna_utf32_string_size_from_byte_stream(
		          (uint8_t *) source,
		          source_length + 1,
		          libclocale_codepage,
		          &wide_source_size,
		          error );
#elif SIZEOF_WCHAR_T == 2
		result = libuna_utf16_string_size_from_byte_stream(
		          (uint8_t *) source,
		          source_length + 1,
		          libclocale_codepage,
		          &wide_source_size,
		          error );
#endif
	}
	if( result != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_CONVERSION,
		 LIBCERROR_CONVERSION_ERROR_GENERIC,
		 "%s: unable to determine wide string size.",
		 function );

		return( -1 );
	}
#endif /* defined( HAVE_WIDE_SYSTEM_CHARACTER ) */

	if( wide_string_size < wide_source_size )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,
		 "%s: wide string too small.",
		 function );

		return( -1 );
	}
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
	if( system_string_copy(
	     wide_string,
	     source,
	     source_length ) == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_MEMORY,
		 LIBCERROR_MEMORY_ERROR_COPY_FAILED,
		 "%s: unable to set wide string.",
		 function );

		return( -1 );
	}
	wide_string[ source_length ] = 0;
#else
	if( libclocale_codepage == 0 )
	{
#if SIZEOF_WCHAR_T == 4
		result = libuna_utf32_string_copy_from_utf8(
		          (libuna_utf32_character_t *) wide_string,
		          wide_string_size,
		          (uint8_t *) source,
		          source_length + 1,
		          error );
#elif SIZEOF_WCHAR_T == 2
		result = libuna_utf16_string_copy_from_utf8(
		          (libuna_utf16_character_t *) wide_string,
		          wide_string_size,
		          (uint8_t *) source,
		          source_length + 1,
		          error );
#endif
	}
	else
	{
#if SIZEOF_WCHAR_T == 4
		result = libuna_utf32_string_copy_from_byte_stream(
		          (libuna_utf32_character_t *) wide_string,
		          wide_string_size,
		          (uint8_t *) source,
		          source_length + 1,
		          libclocale_codepage,
		          error );
#elif SIZEOF_WCHAR_T == 2
		result = libuna_utf16_string_copy_from_byte_stream(
		          (libuna_utf16_character_t *) wide_string,
		          wide_string_size,
		          (uint8_t *) source,
		          source_length + 1,
		          libclocale_codepage,
		          error );
#endif
	}
	if( result != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_CONVERSION,
		 LIBCERROR_CONVERSION_ERROR_GENERIC,
		 "%s: unable to set wide string.",
		 function );

		return( -1 );
	}

#endif /* defined( HAVE_WIDE_SYSTEM_CHARACTER ) */

	return( 1 );
}

#endif /* defined( HAVE_WIDE_CHARACTER_TYPE ) */

/* Creates a file IO handle for test data
 * Returns 1 if successful or -1 on error
 */
int mdmp_test_open_file_io_handle(
     libbfio_handle_t **file_io_handle,
     uint8_t *data,
     size_t data_size,
     libcerror_error_t **error )
{
	static char *function = "mdmp_test_open_file_io_handle";

	if( file_io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file IO handle.",
		 function );

		return( -1 );
	}
	if( libbfio_memory_range_initialize(
	     file_io_handle,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
		 "%s: unable to create file IO handle.",
		 function );

		goto on_error;
	}
	if( libbfio_memory_range_set(
	     *file_io_handle,
	     data,
	     data_size,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
		 "%s: unable to set memory range of file IO handle.",
		 function );

		goto on_error;
	}
	if( libbfio_handle_open(
	     *file_io_handle,
	     LIBBFIO_OPEN_READ,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_OPEN_FAILED,
		 "%s: unable to open file IO handle.",
		 function );

		goto on_error;
	}
	return( 1 );

on_error:
	if( *file_io_handle != NULL )
	{
		libbfio_handle_free(
		 file_io_handle,
		 NULL );
	}
	return( -1 );
}

/* Closes a file IO handle for test data
 * Returns 0 if successful or -1 on error
 */
int mdmp_test_close_file_io_handle(
     libbfio_handle_t **file_io_handle,
     libcerror_error_t **error )
{
	static char *function = "mdmp_test_close_file_io_handle";
	int result            = 0;

	if( file_io_handle == NULL )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
		 "%s: invalid file IO handle.",
		 function );

		return( -1 );
	}
	if( libbfio_handle_close(
	     *file_io_handle,
	     error ) != 0 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_IO,
		 LIBCERROR_IO_ERROR_CLOSE_FAILED,
		 "%s: unable to close file IO handle.",
		 function );

		result = -1;
	}
	if( libbfio_handle_free(
	     file_io_handle,
	     error ) != 1 )
	{
		libcerror_error_set(
		 error,
		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
		 LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,
		 "%s: unable to free file IO handle.",
		 function );

		result = -1;
	}
	return( result );
}


```

`tests/mdmp_test_functions.h`:

```h
/*
 * Functions for testing
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMP_TEST_FUNCTIONS_H )
#define _MDMP_TEST_FUNCTIONS_H

#include <common.h>
#include <types.h>

#include "mdmp_test_libbfio.h"
#include "mdmp_test_libcerror.h"

#if defined( __cplusplus )
extern "C" {
#endif

int mdmp_test_get_narrow_source(
     const system_character_t *source,
     char *narrow_string,
     size_t narrow_string_size,
     libcerror_error_t **error );

#if defined( HAVE_WIDE_CHARACTER_TYPE )

int mdmp_test_get_wide_source(
     const system_character_t *source,
     wchar_t *wide_string,
     size_t wide_string_size,
     libcerror_error_t **error );

#endif /* defined( HAVE_WIDE_CHARACTER_TYPE ) */

int mdmp_test_open_file_io_handle(
     libbfio_handle_t **file_io_handle,
     uint8_t *data,
     size_t data_size,
     libcerror_error_t **error );

int mdmp_test_close_file_io_handle(
     libbfio_handle_t **file_io_handle,
     libcerror_error_t **error );

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _MDMP_TEST_FUNCTIONS_H ) */


```

`tests/mdmp_test_getopt.c`:

```c
/*
 * GetOpt functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <narrow_string.h>
#include <system_string.h>
#include <types.h>
#include <wide_string.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_getopt.h"
#include "mdmp_test_libcnotify.h"

#if !defined( HAVE_GETOPT )

/* The option index
 * Start with argument 1 (argument 0 is the program name)
 */
int optind = 1;

/* The current option argument
 */
system_character_t *optarg = NULL;

/* Value to indicate the current option
 */
system_integer_t optopt = 0;

/* The next option in a group
 */
system_character_t *next_option = NULL;

/* Get the program options
 * Function for platforms that do not have the getopt function
 * Returns the option character processed, or -1 on error,
 * ? if the option was not in the options string, : if the option argument was missing
 */
system_integer_t mdmp_test_getopt(
                  int argument_count,
                  system_character_t * const argument_values[],
                  const system_character_t *options_string )
{
	system_character_t *argument_value = NULL;
	system_character_t *option_value   = NULL;
	static char *function              = "mdmp_test_getopt";
	size_t options_string_length       = 0;

	if( next_option != NULL )
	{
		argument_value = next_option;
		next_option    = NULL;
	}
	else if( optind >= argument_count )
	{
		return( (system_integer_t) -1 );
	}
	else
	{
		argument_value = argument_values[ optind ];

		/* Check if the argument value is not an empty string
		 */
		if( *argument_value == (system_character_t) '\0' )
		{
			return( (system_integer_t) -1 );
		}
		/* Check if the first character is a option marker '-'
		 */
		if( *argument_value != (system_character_t) '-' )
		{
			return( (system_integer_t) -1 );
		}
		argument_value++;

		/* Check if long options are provided '--'
		 */
		if( *argument_value == (system_character_t) '-' )
		{
			optind++;

			return( (system_integer_t) -1 );
		}
	}
	options_string_length = system_string_length(
	                         options_string );

	optopt       = *argument_value;
	option_value = system_string_search_character(
	                options_string,
	                optopt,
	                options_string_length );

	argument_value++;

	/* Check if an argument was specified or that the option was not found
	 * in the option string
	 */
	if( ( optopt == (system_integer_t) ':' )
	 || ( option_value == NULL ) )
	{
		if( *argument_value == (system_character_t) '\0' )
		{
			optind++;
		}
		if( ( *options_string != (system_character_t) ':' )
		 && ( optopt != (system_integer_t) '?' ) )
		{
			libcnotify_printf(
			 "%s: no such option: %" PRIc_SYSTEM ".\n",
			 function,
			 optopt );
		}
		return( (system_integer_t) '?' );
	}
	option_value++;

	/* Check if no option argument is required
	 */
	if( *option_value != (system_character_t) ':' )
	{
		optarg = NULL;

		if( *argument_value == (system_character_t) '\0' )
		{
			optind++;
		}
		else
		{
			/* Multiple options are grouped
			 */
			next_option = argument_value;
		}
	}
	/* Check if the argument is right after the option flag with no space in between
	 */
	else if( *argument_value != (system_character_t) '\0' )
	{
		optarg = argument_value;

		optind++;
	}
	else
	{
		optind++;

		/* Check if the argument was provided as the next argument value
		 */
		if( argument_count <= optind )
		{
			if( *option_value == ':' )
			{
				return( (system_integer_t) ':' );
			}
			libcnotify_printf(
			 "%s: option: %" PRIc_SYSTEM " requires an argument.\n",
			 function,
			 optopt );

			return( (system_integer_t) '?' );
		}
		optarg = argument_values[ optind ];

		optind++;
	}
	return( optopt );
}

#endif /* !defined( HAVE_GETOPT ) */


```

`tests/mdmp_test_getopt.h`:

```h
/*
 * GetOpt functions
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMP_TEST_GETOPT_H )
#define _MDMP_TEST_GETOPT_H

#include <common.h>
#include <types.h>

/* unistd.h is included here to export getopt, optarg, optind and optopt
 */
#if defined( HAVE_UNISTD_H )
#include <unistd.h>
#endif

#if defined( __cplusplus )
extern "C" {
#endif

#if defined( HAVE_GETOPT )
#define mdmp_test_getopt( argument_count, argument_values, options_string ) \
	getopt( argument_count, argument_values, options_string )

#else

#if !defined( __CYGWIN__ )
extern int optind;
extern system_character_t *optarg;
extern system_integer_t optopt;

#else
int optind;
system_character_t *optarg;
system_integer_t optopt;

#endif /* !defined( __CYGWIN__ ) */

system_integer_t mdmp_test_getopt(
                  int argument_count,
                  system_character_t * const argument_values[],
                  const system_character_t *options_string );

#endif /* defined( HAVE_GETOPT ) */

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _MDMP_TEST_GETOPT_H ) */


```

`tests/mdmp_test_io_handle.c`:

```c
/*
 * Library io_handle type test program
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <types.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_libcerror.h"
#include "mdmp_test_libmdmp.h"
#include "mdmp_test_macros.h"
#include "mdmp_test_memory.h"
#include "mdmp_test_unused.h"

#include "../libmdmp/libmdmp_io_handle.h"

#if defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT )

/* Tests the libmdmp_io_handle_initialize function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_io_handle_initialize(
     void )
{
	libcerror_error_t *error        = NULL;
	libmdmp_io_handle_t *io_handle  = NULL;
	int result                      = 0;

#if defined( HAVE_MDMP_TEST_MEMORY )
	int number_of_malloc_fail_tests = 1;
	int number_of_memset_fail_tests = 1;
	int test_number                 = 0;
#endif

	/* Test regular cases
	 */
	result = libmdmp_io_handle_initialize(
	          &io_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "io_handle",
	 io_handle );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = libmdmp_io_handle_free(
	          &io_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "io_handle",
	 io_handle );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_io_handle_initialize(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	io_handle = (libmdmp_io_handle_t *) 0x12345678UL;

	result = libmdmp_io_handle_initialize(
	          &io_handle,
	          &error );

	io_handle = NULL;

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

#if defined( HAVE_MDMP_TEST_MEMORY )

	for( test_number = 0;
	     test_number < number_of_malloc_fail_tests;
	     test_number++ )
	{
		/* Test libmdmp_io_handle_initialize with malloc failing
		 */
		mdmp_test_malloc_attempts_before_fail = test_number;

		result = libmdmp_io_handle_initialize(
		          &io_handle,
		          &error );

		if( mdmp_test_malloc_attempts_before_fail != -1 )
		{
			mdmp_test_malloc_attempts_before_fail = -1;

			if( io_handle != NULL )
			{
				libmdmp_io_handle_free(
				 &io_handle,
				 NULL );
			}
		}
		else
		{
			MDMP_TEST_ASSERT_EQUAL_INT(
			 "result",
			 result,
			 -1 );

			MDMP_TEST_ASSERT_IS_NULL(
			 "io_handle",
			 io_handle );

			MDMP_TEST_ASSERT_IS_NOT_NULL(
			 "error",
			 error );

			libcerror_error_free(
			 &error );
		}
	}
	for( test_number = 0;
	     test_number < number_of_memset_fail_tests;
	     test_number++ )
	{
		/* Test libmdmp_io_handle_initialize with memset failing
		 */
		mdmp_test_memset_attempts_before_fail = test_number;

		result = libmdmp_io_handle_initialize(
		          &io_handle,
		          &error );

		if( mdmp_test_memset_attempts_before_fail != -1 )
		{
			mdmp_test_memset_attempts_before_fail = -1;

			if( io_handle != NULL )
			{
				libmdmp_io_handle_free(
				 &io_handle,
				 NULL );
			}
		}
		else
		{
			MDMP_TEST_ASSERT_EQUAL_INT(
			 "result",
			 result,
			 -1 );

			MDMP_TEST_ASSERT_IS_NULL(
			 "io_handle",
			 io_handle );

			MDMP_TEST_ASSERT_IS_NOT_NULL(
			 "error",
			 error );

			libcerror_error_free(
			 &error );
		}
	}
#endif /* defined( HAVE_MDMP_TEST_MEMORY ) */

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	if( io_handle != NULL )
	{
		libmdmp_io_handle_free(
		 &io_handle,
		 NULL );
	}
	return( 0 );
}

/* Tests the libmdmp_io_handle_free function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_io_handle_free(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test error cases
	 */
	result = libmdmp_io_handle_free(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* Tests the libmdmp_io_handle_clear function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_io_handle_clear(
     void )
{
	libcerror_error_t *error       = NULL;
	libmdmp_io_handle_t *io_handle = NULL;
	int result                     = 0;

	/* Initialize test
	 */
	result = libmdmp_io_handle_initialize(
	          &io_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "io_handle",
	 io_handle );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test regular cases
	 */
	result = libmdmp_io_handle_clear(
	          io_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_io_handle_clear(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

#if defined( HAVE_MDMP_TEST_MEMORY )

	/* Test libmdmp_io_handle_clear with memset failing
	 */
	mdmp_test_memset_attempts_before_fail = 0;

	result = libmdmp_io_handle_clear(
	          io_handle,
	          &error );

	if( mdmp_test_memset_attempts_before_fail != -1 )
	{
		mdmp_test_memset_attempts_before_fail = -1;
	}
	else
	{
		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 -1 );

		MDMP_TEST_ASSERT_IS_NOT_NULL(
		 "error",
		 error );

		libcerror_error_free(
		 &error );
	}
#endif /* defined( HAVE_MDMP_TEST_MEMORY ) */

	/* Clean up
	 */
	result = libmdmp_io_handle_free(
	          &io_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "io_handle",
	 io_handle );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	if( io_handle != NULL )
	{
		libmdmp_io_handle_free(
		 &io_handle,
		 NULL );
	}
	return( 0 );
}

#endif /* defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) */

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     wchar_t * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#else
int main(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     char * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#endif
{
	MDMP_TEST_UNREFERENCED_PARAMETER( argc )
	MDMP_TEST_UNREFERENCED_PARAMETER( argv )

#if defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT )

	MDMP_TEST_RUN(
	 "libmdmp_io_handle_initialize",
	 mdmp_test_io_handle_initialize );

	MDMP_TEST_RUN(
	 "libmdmp_io_handle_free",
	 mdmp_test_io_handle_free );

	MDMP_TEST_RUN(
	 "libmdmp_io_handle_clear",
	 mdmp_test_io_handle_clear );

	/* TODO: add tests for libmdmp_io_handle_read_file_header */

	/* TODO: add tests for libmdmp_io_handle_read_streams_directory */

	/* TODO: add tests for libmdmp_io_handle_read_segment_data */

	/* TODO: add tests for libmdmp_io_handle_seek_segment_offset */

#endif /* defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) */

	return( EXIT_SUCCESS );

on_error:
	return( EXIT_FAILURE );
}


```

`tests/mdmp_test_libbfio.h`:

```h
/*
 * The libbfio header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMP_TEST_LIBBFIO_H )
#define _MDMP_TEST_LIBBFIO_H

#include <common.h>

/* Define HAVE_LOCAL_LIBBFIO for local use of libbfio
 */
#if defined( HAVE_LOCAL_LIBBFIO )

#include <libbfio_definitions.h>
#include <libbfio_file.h>
#include <libbfio_file_pool.h>
#include <libbfio_file_range.h>
#include <libbfio_handle.h>
#include <libbfio_memory_range.h>
#include <libbfio_pool.h>
#include <libbfio_types.h>

#else

/* If libtool DLL support is enabled set LIBBFIO_DLL_IMPORT
 * before including libbfio.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBBFIO_DLL_IMPORT
#endif

#include <libbfio.h>

#if defined( HAVE_MULTI_THREAD_SUPPORT ) && !defined( LIBBFIO_HAVE_MULTI_THREAD_SUPPORT )
#error Multi-threading support requires libbfio with multi-threading support
#endif

#endif /* defined( HAVE_LOCAL_LIBBFIO ) */

#endif /* !defined( _MDMP_TEST_LIBBFIO_H ) */


```

`tests/mdmp_test_libcerror.h`:

```h
/*
 * The libcerror header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMP_TEST_LIBCERROR_H )
#define _MDMP_TEST_LIBCERROR_H

#include <common.h>

/* Define HAVE_LOCAL_LIBCERROR for local use of libcerror
 */
#if defined( HAVE_LOCAL_LIBCERROR )

#include <libcerror_definitions.h>
#include <libcerror_error.h>
#include <libcerror_system.h>
#include <libcerror_types.h>

#else

/* If libtool DLL support is enabled set LIBCERROR_DLL_IMPORT
 * before including libcerror.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBCERROR_DLL_IMPORT
#endif

#include <libcerror.h>

#endif /* defined( HAVE_LOCAL_LIBCERROR ) */

#endif /* !defined( _MDMP_TEST_LIBCERROR_H ) */


```

`tests/mdmp_test_libclocale.h`:

```h
/*
 * The libclocale header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMP_TEST_LIBCLOCALE_H )
#define _MDMP_TEST_LIBCLOCALE_H

#include <common.h>

/* Define HAVE_LOCAL_LIBCLOCALE for local use of libclocale
 */
#if defined( HAVE_LOCAL_LIBCLOCALE )

#include <libclocale_codepage.h>
#include <libclocale_definitions.h>
#include <libclocale_locale.h>
#include <libclocale_support.h>

#else

/* If libtool DLL support is enabled set LIBCLOCALE_DLL_IMPORT
 * before including libclocale.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBCLOCALE_DLL_IMPORT
#endif

#include <libclocale.h>

#endif /* defined( HAVE_LOCAL_LIBCLOCALE ) */

#endif /* !defined( _MDMP_TEST_LIBCLOCALE_H ) */


```

`tests/mdmp_test_libcnotify.h`:

```h
/*
 * The libcnotify header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMP_TEST_LIBCNOTIFY_H )
#define _MDMP_TEST_LIBCNOTIFY_H

#include <common.h>

/* Define HAVE_LOCAL_LIBCNOTIFY for local use of libcnotify
 */
#if defined( HAVE_LOCAL_LIBCNOTIFY )

#include <libcnotify_definitions.h>
#include <libcnotify_print.h>
#include <libcnotify_stream.h>
#include <libcnotify_verbose.h>

#else

/* If libtool DLL support is enabled set LIBCNOTIFY_DLL_IMPORT
 * before including libcnotify.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBCNOTIFY_DLL_IMPORT
#endif

#include <libcnotify.h>

#endif /* defined( HAVE_LOCAL_LIBCNOTIFY ) */

#endif /* !defined( _MDMP_TEST_LIBCNOTIFY_H ) */


```

`tests/mdmp_test_libmdmp.h`:

```h
/*
 * The libmdmp header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMP_TEST_LIBMDMP_H )
#define _MDMP_TEST_LIBMDMP_H

#include <common.h>

#include <libmdmp.h>

#endif /* !defined( _MDMP_TEST_LIBMDMP_H ) */


```

`tests/mdmp_test_libuna.h`:

```h
/*
 * The libuna header wrapper
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMP_TEST_LIBUNA_H )
#define _MDMP_TEST_LIBUNA_H

#include <common.h>

/* Define HAVE_LOCAL_LIBUNA for local use of libuna
 */
#if defined( HAVE_LOCAL_LIBUNA )

#include <libuna_base16_stream.h>
#include <libuna_base32_stream.h>
#include <libuna_base64_stream.h>
#include <libuna_byte_stream.h>
#include <libuna_unicode_character.h>
#include <libuna_url_stream.h>
#include <libuna_utf16_stream.h>
#include <libuna_utf16_string.h>
#include <libuna_utf32_stream.h>
#include <libuna_utf32_string.h>
#include <libuna_utf7_stream.h>
#include <libuna_utf8_stream.h>
#include <libuna_utf8_string.h>
#include <libuna_types.h>

#else

/* If libtool DLL support is enabled set LIBUNA_DLL_IMPORT
 * before including libuna.h
 */
#if defined( _WIN32 ) && defined( DLL_IMPORT )
#define LIBUNA_DLL_IMPORT
#endif

#include <libuna.h>

#endif /* defined( HAVE_LOCAL_LIBUNA ) */

#endif /* !defined( _MDMP_TEST_LIBUNA_H ) */


```

`tests/mdmp_test_macros.h`:

```h
/*
 * Macros for testing
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMP_TEST_MACROS_H )
#define _MDMP_TEST_MACROS_H

#include <common.h>
#include <file_stream.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#define MDMP_TEST_ASSERT_EQUAL_INT( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%d) != %d\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_NOT_EQUAL_INT( name, value, expected_value ) \
	if( value == expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%d) == %d\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_GREATER_THAN_INT( name, value, expected_value ) \
	if( value <= expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%d) <= %d\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_LESS_THAN_INT( name, value, expected_value ) \
	if( value >= expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%d) >= %d\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_EQUAL_INTPTR( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (0x%08x" PRIjx ") != 0x%08x" PRIjx "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_NOT_EQUAL_INTPTR( name, value, expected_value ) \
	if( value == expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (0x%08x" PRIjx ") == 0x%08x" PRIjx "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_EQUAL_FLOAT( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%f) != %f\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_NOT_EQUAL_FLOAT( name, value, expected_value ) \
	if( value == expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%f) == %f\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_EQUAL_SIZE( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIzd ") != %" PRIzd "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_EQUAL_SSIZE( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIzd ") != %" PRIzd "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_NOT_EQUAL_SSIZE( name, value, expected_value ) \
	if( value == expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIzd ") == %" PRIzd "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_EQUAL_INT8( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIi8 ") != %" PRIi8 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_NOT_EQUAL_INT8( name, value, expected_value ) \
	if( value == expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIi8 ") == %" PRIi8 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_EQUAL_UINT8( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIi8 ") != %" PRIu8 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_LESS_THAN_UINT8( name, value, expected_value ) \
	if( value >= expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIi8 ") >= %" PRIu8 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_EQUAL_INT16( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIi16 ") != %" PRIi16 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_NOT_EQUAL_INT16( name, value, expected_value ) \
	if( value == expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIi16 ") == %" PRIi16 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_EQUAL_UINT16( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIi16 ") != %" PRIu16 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_LESS_THAN_UINT16( name, value, expected_value ) \
	if( value >= expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIi16 ") >= %" PRIu16 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_EQUAL_INT32( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIi32 ") != %" PRIi32 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_NOT_EQUAL_INT32( name, value, expected_value ) \
	if( value == expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIi32 ") == %" PRIi32 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_EQUAL_UINT32( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIu32 ") != %" PRIu32 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_LESS_THAN_UINT32( name, value, expected_value ) \
	if( value >= expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIu32 ") >= %" PRIu32 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_EQUAL_INT64( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIi64 ") != %" PRIi64 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_NOT_EQUAL_INT64( name, value, expected_value ) \
	if( value == expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIi64 ") == %" PRIi64 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_EQUAL_UINT64( name, value, expected_value ) \
	if( value != expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIu64 ") != %" PRIu64 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_LESS_THAN_UINT64( name, value, expected_value ) \
	if( value >= expected_value ) \
	{ \
		fprintf( stdout, "%s:%d %s (%" PRIu64 ") >= %" PRIu64 "\n", __FILE__, __LINE__, name, value, expected_value ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_IS_NOT_NULL( name, value ) \
	if( value == NULL ) \
	{ \
		fprintf( stdout, "%s:%d %s == NULL\n", __FILE__, __LINE__, name ); \
		goto on_error; \
	}

#define MDMP_TEST_ASSERT_IS_NULL( name, value ) \
	if( value != NULL ) \
	{ \
		fprintf( stdout, "%s:%d %s != NULL\n", __FILE__, __LINE__, name ); \
		goto on_error; \
	}

#define MDMP_TEST_RUN( name, function ) \
	if( function() != 1 ) \
	{ \
		fprintf( stdout, "Unable to run test: %s\n", name ); \
		goto on_error; \
	}

#if !defined( __BORLANDC__ ) || ( __BORLANDC__ >= 0x0560 )

#define MDMP_TEST_RUN_WITH_ARGS( name, function, ... ) \
	if( function( __VA_ARGS__ ) != 1 ) \
	{ \
		fprintf( stdout, "Unable to run test: %s\n", name ); \
		goto on_error; \
	}

#endif /* !defined( __BORLANDC__ ) || ( __BORLANDC__ >= 0x0560 ) */

#define MDMP_TEST_FPRINT_ERROR( error ) \
	libcerror_error_backtrace_fprint( error, stdout );

#endif /* !defined( _MDMP_TEST_MACROS_H ) */


```

`tests/mdmp_test_memory.c`:

```c
/*
 * Memory allocation functions for testing
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#if defined( HAVE_GNU_DL_DLSYM ) && defined( __GNUC__ )
#define __USE_GNU
#include <dlfcn.h>
#undef __USE_GNU
#endif

#include "mdmp_test_memory.h"

#if defined( HAVE_MDMP_TEST_MEMORY )

static void *(*mdmp_test_real_malloc)(size_t)                       = NULL;
static void *(*mdmp_test_real_memcpy)(void *, const void *, size_t) = NULL;
static void *(*mdmp_test_real_memset)(void *, int, size_t)          = NULL;
static void *(*mdmp_test_real_realloc)(void *, size_t)              = NULL;

int mdmp_test_malloc_attempts_before_fail                           = -1;
int mdmp_test_memcpy_attempts_before_fail                           = -1;
int mdmp_test_memset_attempts_before_fail                           = -1;
int mdmp_test_realloc_attempts_before_fail                          = -1;

/* Custom malloc for testing memory error cases
 * Note this function might fail if compiled with optimation
 * Returns a pointer to newly allocated data or NULL
 */
void *malloc(
       size_t size )
{
	void *ptr = NULL;

	if( mdmp_test_real_malloc == NULL )
	{
		mdmp_test_real_malloc = dlsym(
		                         RTLD_NEXT,
		                         "malloc" );
	}
	if( mdmp_test_malloc_attempts_before_fail == 0 )
	{
		mdmp_test_malloc_attempts_before_fail = -1;

		return( NULL );
	}
	else if( mdmp_test_malloc_attempts_before_fail > 0 )
	{
		mdmp_test_malloc_attempts_before_fail--;
	}
	ptr = mdmp_test_real_malloc(
	       size );

	return( ptr );
}

/* Custom memcpy for testing memory error cases
 * Note this function might fail if compiled with optimation and as a shared libary
 * Returns a pointer to newly allocated data or NULL
 */
void *memcpy(
       void *destination,
       const void *source,
       size_t size )
{
	if( mdmp_test_real_memcpy == NULL )
	{
		mdmp_test_real_memcpy = dlsym(
		                         RTLD_NEXT,
		                         "memcpy" );
	}
	if( mdmp_test_memcpy_attempts_before_fail == 0 )
	{
		mdmp_test_memcpy_attempts_before_fail = -1;

		return( NULL );
	}
	else if( mdmp_test_memcpy_attempts_before_fail > 0 )
	{
		mdmp_test_memcpy_attempts_before_fail--;
	}
	destination = mdmp_test_real_memcpy(
	               destination,
	               source,
	               size );

	return( destination );
}

/* Custom memset for testing memory error cases
 * Note this function might fail if compiled with optimation and as a shared libary
 * Returns a pointer to newly allocated data or NULL
 */
void *memset(
       void *ptr,
       int constant,
       size_t size )
{
	if( mdmp_test_real_memset == NULL )
	{
		mdmp_test_real_memset = dlsym(
		                         RTLD_NEXT,
		                         "memset" );
	}
	if( mdmp_test_memset_attempts_before_fail == 0 )
	{
		mdmp_test_memset_attempts_before_fail = -1;

		return( NULL );
	}
	else if( mdmp_test_memset_attempts_before_fail > 0 )
	{
		mdmp_test_memset_attempts_before_fail--;
	}
	ptr = mdmp_test_real_memset(
	       ptr,
	       constant,
	       size );

	return( ptr );
}

/* Custom realloc for testing memory error cases
 * Note this function might fail if compiled with optimation
 * Returns a pointer to reallocated data or NULL
 */
void *realloc(
       void *ptr,
       size_t size )
{
	if( mdmp_test_real_realloc == NULL )
	{
		mdmp_test_real_realloc = dlsym(
		                          RTLD_NEXT,
		                          "realloc" );
	}
	if( mdmp_test_realloc_attempts_before_fail == 0 )
	{
		mdmp_test_realloc_attempts_before_fail = -1;

		return( NULL );
	}
	else if( mdmp_test_realloc_attempts_before_fail > 0 )
	{
		mdmp_test_realloc_attempts_before_fail--;
	}
	ptr = mdmp_test_real_realloc(
	       ptr,
	       size );

	return( ptr );
}

#endif /* defined( HAVE_MDMP_TEST_MEMORY ) */


```

`tests/mdmp_test_memory.h`:

```h
/*
 * Memory allocation functions for testing
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMP_TEST_MEMORY_H )
#define _MDMP_TEST_MEMORY_H

#include <common.h>

#if defined( __cplusplus )
extern "C" {
#endif

#if defined( HAVE_GNU_DL_DLSYM ) && defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) && !defined( __arm__ ) && !defined( __clang__ ) && !defined( __CYGWIN__ ) && !defined( __hppa__ ) && !defined( __loongarch__ ) && !defined( __mips__ ) && !defined( __riscv ) && !defined( __sparc__ ) && !defined( HAVE_ASAN )
#define HAVE_MDMP_TEST_MEMORY		1
#endif

#if defined( HAVE_MDMP_TEST_MEMORY )

extern int mdmp_test_malloc_attempts_before_fail;

extern int mdmp_test_memcpy_attempts_before_fail;

extern int mdmp_test_memset_attempts_before_fail;

extern int mdmp_test_realloc_attempts_before_fail;

#endif /* defined( HAVE_MDMP_TEST_MEMORY ) */

#if defined( __cplusplus )
}
#endif

#endif /* !defined( _MDMP_TEST_MEMORY_H ) */


```

`tests/mdmp_test_notify.c`:

```c
/*
 * Library notification functions test program
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <types.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_libcerror.h"
#include "mdmp_test_libmdmp.h"
#include "mdmp_test_macros.h"
#include "mdmp_test_unused.h"

/* Tests the libmdmp_notify_set_verbose function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_notify_set_verbose(
     void )
{
	/* Test invocation of function only
	 */
	libmdmp_notify_set_verbose(
	 0 );

	return( 1 );
}

/* Tests the libmdmp_notify_set_stream function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_notify_set_stream(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test regular cases
	 */
	result = libmdmp_notify_set_stream(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
/* TODO test libcnotify_stream_set failure */

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* Tests the libmdmp_notify_stream_open function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_notify_stream_open(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test regular cases
	 */
	result = libmdmp_notify_stream_open(
	          "notify_stream.log",
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_notify_stream_open(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	/* Clean up
	 */
	result = libmdmp_notify_stream_close(
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 0 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* Tests the libmdmp_notify_stream_close function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_notify_stream_close(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test regular cases
	 */
	result = libmdmp_notify_stream_close(
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 0 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
/* TODO test libcnotify_stream_close failure */

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     wchar_t * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#else
int main(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     char * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#endif
{
	MDMP_TEST_UNREFERENCED_PARAMETER( argc )
	MDMP_TEST_UNREFERENCED_PARAMETER( argv )

	MDMP_TEST_RUN(
	 "libmdmp_notify_set_verbose",
	 mdmp_test_notify_set_verbose )

	MDMP_TEST_RUN(
	 "libmdmp_notify_set_stream",
	 mdmp_test_notify_set_stream )

	MDMP_TEST_RUN(
	 "libmdmp_notify_stream_open",
	 mdmp_test_notify_stream_open )

	MDMP_TEST_RUN(
	 "libmdmp_notify_stream_close",
	 mdmp_test_notify_stream_close )

	return( EXIT_SUCCESS );

on_error:
	return( EXIT_FAILURE );
}


```

`tests/mdmp_test_stream.c`:

```c
/*
 * Library stream type test program
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <types.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_libcerror.h"
#include "mdmp_test_libmdmp.h"
#include "mdmp_test_macros.h"
#include "mdmp_test_memory.h"
#include "mdmp_test_unused.h"

#include "../libmdmp/libmdmp_stream.h"

/* Tests the libmdmp_stream_free function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_stream_free(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test error cases
	 */
	result = libmdmp_stream_free(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

#if defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT )

#endif /* defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) */

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     wchar_t * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#else
int main(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     char * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#endif
{
	MDMP_TEST_UNREFERENCED_PARAMETER( argc )
	MDMP_TEST_UNREFERENCED_PARAMETER( argv )

#if defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT )

	/* TODO: add tests for libmdmp_stream_initialize */

#endif /* defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) */

	MDMP_TEST_RUN(
	 "libmdmp_stream_free",
	 mdmp_test_stream_free );

#if defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT )

	/* TODO: add tests for libmdmp_stream_get_type */

	/* TODO: add tests for libmdmp_stream_read_buffer */

	/* TODO: add tests for libmdmp_stream_read_buffer_at_offset */

	/* TODO: add tests for libmdmp_stream_seek_offset */

	/* TODO: add tests for libmdmp_stream_get_offset */

	/* TODO: add tests for libmdmp_stream_get_size */

	/* TODO: add tests for libmdmp_stream_get_start_offset */

	/* TODO: add tests for libmdmp_stream_get_data_file_io_handle */

#endif /* defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) */

	return( EXIT_SUCCESS );

on_error:
	return( EXIT_FAILURE );
}


```

`tests/mdmp_test_stream_descriptor.c`:

```c
/*
 * Library stream_descriptor type test program
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <types.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_libcerror.h"
#include "mdmp_test_libmdmp.h"
#include "mdmp_test_macros.h"
#include "mdmp_test_memory.h"
#include "mdmp_test_unused.h"

#include "../libmdmp/libmdmp_stream_descriptor.h"

#if defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT )

/* Tests the libmdmp_stream_descriptor_initialize function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_stream_descriptor_initialize(
     void )
{
	libcerror_error_t *error                       = NULL;
	libmdmp_stream_descriptor_t *stream_descriptor = NULL;
	int result                                     = 0;

#if defined( HAVE_MDMP_TEST_MEMORY )
	int number_of_malloc_fail_tests                = 1;
	int number_of_memset_fail_tests                = 1;
	int test_number                                = 0;
#endif

	/* Test regular cases
	 */
	result = libmdmp_stream_descriptor_initialize(
	          &stream_descriptor,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "stream_descriptor",
	 stream_descriptor );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = libmdmp_stream_descriptor_free(
	          &stream_descriptor,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "stream_descriptor",
	 stream_descriptor );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_stream_descriptor_initialize(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	stream_descriptor = (libmdmp_stream_descriptor_t *) 0x12345678UL;

	result = libmdmp_stream_descriptor_initialize(
	          &stream_descriptor,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	stream_descriptor = NULL;

#if defined( HAVE_MDMP_TEST_MEMORY )

	for( test_number = 0;
	     test_number < number_of_malloc_fail_tests;
	     test_number++ )
	{
		/* Test libmdmp_stream_descriptor_initialize with malloc failing
		 */
		mdmp_test_malloc_attempts_before_fail = test_number;

		result = libmdmp_stream_descriptor_initialize(
		          &stream_descriptor,
		          &error );

		if( mdmp_test_malloc_attempts_before_fail != -1 )
		{
			mdmp_test_malloc_attempts_before_fail = -1;

			if( stream_descriptor != NULL )
			{
				libmdmp_stream_descriptor_free(
				 &stream_descriptor,
				 NULL );
			}
		}
		else
		{
			MDMP_TEST_ASSERT_EQUAL_INT(
			 "result",
			 result,
			 -1 );

			MDMP_TEST_ASSERT_IS_NULL(
			 "stream_descriptor",
			 stream_descriptor );

			MDMP_TEST_ASSERT_IS_NOT_NULL(
			 "error",
			 error );

			libcerror_error_free(
			 &error );
		}
	}
	for( test_number = 0;
	     test_number < number_of_memset_fail_tests;
	     test_number++ )
	{
		/* Test libmdmp_stream_descriptor_initialize with memset failing
		 */
		mdmp_test_memset_attempts_before_fail = test_number;

		result = libmdmp_stream_descriptor_initialize(
		          &stream_descriptor,
		          &error );

		if( mdmp_test_memset_attempts_before_fail != -1 )
		{
			mdmp_test_memset_attempts_before_fail = -1;

			if( stream_descriptor != NULL )
			{
				libmdmp_stream_descriptor_free(
				 &stream_descriptor,
				 NULL );
			}
		}
		else
		{
			MDMP_TEST_ASSERT_EQUAL_INT(
			 "result",
			 result,
			 -1 );

			MDMP_TEST_ASSERT_IS_NULL(
			 "stream_descriptor",
			 stream_descriptor );

			MDMP_TEST_ASSERT_IS_NOT_NULL(
			 "error",
			 error );

			libcerror_error_free(
			 &error );
		}
	}
#endif /* defined( HAVE_MDMP_TEST_MEMORY ) */

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	if( stream_descriptor != NULL )
	{
		libmdmp_stream_descriptor_free(
		 &stream_descriptor,
		 NULL );
	}
	return( 0 );
}

/* Tests the libmdmp_stream_descriptor_free function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_stream_descriptor_free(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test error cases
	 */
	result = libmdmp_stream_descriptor_free(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

#endif /* defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) */

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     wchar_t * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#else
int main(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     char * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#endif
{
	MDMP_TEST_UNREFERENCED_PARAMETER( argc )
	MDMP_TEST_UNREFERENCED_PARAMETER( argv )

#if defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT )

	MDMP_TEST_RUN(
	 "libmdmp_stream_descriptor_initialize",
	 mdmp_test_stream_descriptor_initialize );

	MDMP_TEST_RUN(
	 "libmdmp_stream_descriptor_free",
	 mdmp_test_stream_descriptor_free );

	/* TODO: add tests for libmdmp_stream_descriptor_set_data_range */

#endif /* defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) */

	return( EXIT_SUCCESS );

on_error:
	return( EXIT_FAILURE );
}


```

`tests/mdmp_test_stream_io_handle.c`:

```c
/*
 * Library stream_io_handle type test program
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <types.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_libcerror.h"
#include "mdmp_test_libmdmp.h"
#include "mdmp_test_macros.h"
#include "mdmp_test_memory.h"
#include "mdmp_test_unused.h"

#include "../libmdmp/libmdmp_stream_io_handle.h"

#if defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT )

/* Tests the libmdmp_stream_io_handle_free function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_stream_io_handle_free(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test error cases
	 */
	result = libmdmp_stream_io_handle_free(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

#endif /* defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) */

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     wchar_t * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#else
int main(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     char * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#endif
{
	MDMP_TEST_UNREFERENCED_PARAMETER( argc )
	MDMP_TEST_UNREFERENCED_PARAMETER( argv )

#if defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT )

	/* TODO: add tests for libmdmp_stream_io_handle_initialize */

	MDMP_TEST_RUN(
	 "libmdmp_stream_io_handle_free",
	 mdmp_test_stream_io_handle_free );

	/* TODO: add tests for libmdmp_stream_io_handle_clone */

	/* TODO: add tests for libmdmp_stream_io_handle_read */

	/* TODO: add tests for libmdmp_stream_io_handle_write */

	/* TODO: add tests for libmdmp_stream_io_handle_seek_offset */

	/* TODO: add tests for libmdmp_stream_io_handle_exists */

	/* TODO: add tests for libmdmp_stream_io_handle_is_open */

	/* TODO: add tests for libmdmp_stream_io_handle_get_size */

#endif /* defined( __GNUC__ ) && !defined( LIBMDMP_DLL_IMPORT ) */

	return( EXIT_SUCCESS );

on_error:
	return( EXIT_FAILURE );
}


```

`tests/mdmp_test_support.c`:

```c
/*
 * Library support functions test program
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <narrow_string.h>
#include <system_string.h>
#include <types.h>
#include <wide_string.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_functions.h"
#include "mdmp_test_getopt.h"
#include "mdmp_test_libbfio.h"
#include "mdmp_test_libcerror.h"
#include "mdmp_test_libmdmp.h"
#include "mdmp_test_macros.h"
#include "mdmp_test_memory.h"
#include "mdmp_test_unused.h"

#if !defined( LIBMDMP_HAVE_BFIO )

LIBMDMP_EXTERN \
int libmdmp_check_file_signature_file_io_handle(
     libbfio_handle_t *file_io_handle,
     libcerror_error_t **error );

#endif /* !defined( LIBMDMP_HAVE_BFIO ) */

/* Tests the libmdmp_get_version function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_get_version(
     void )
{
	const char *version_string = NULL;
	int result                 = 0;

	version_string = libmdmp_get_version();

	result = narrow_string_compare(
	          version_string,
	          LIBMDMP_VERSION_STRING,
	          9 );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 0 );

	return( 1 );

on_error:
	return( 0 );
}

/* Tests the libmdmp_get_access_flags_read function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_get_access_flags_read(
     void )
{
	int access_flags = 0;

	access_flags = libmdmp_get_access_flags_read();

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "access_flags",
	 access_flags,
	 LIBMDMP_ACCESS_FLAG_READ );

	return( 1 );

on_error:
	return( 0 );
}

/* Tests the libmdmp_get_codepage function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_get_codepage(
     void )
{
	libcerror_error_t *error = NULL;
	int codepage             = 0;
	int result               = 0;

	result = libmdmp_get_codepage(
	          &codepage,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_get_codepage(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* Tests the libmdmp_set_codepage function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_set_codepage(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	result = libmdmp_set_codepage(
	          0,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = libmdmp_set_codepage(
	          -1,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* Tests the libmdmp_check_file_signature function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_check_file_signature(
     const system_character_t *source )
{
	char narrow_source[ 256 ];

	libcerror_error_t *error = NULL;
	int result               = 0;

	if( source != NULL )
	{
		/* Initialize test
		 */
		result = mdmp_test_get_narrow_source(
		          source,
		          narrow_source,
		          256,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );

		/* Test check file signature
		 */
		result = libmdmp_check_file_signature(
		          narrow_source,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );
	}
	/* Test error cases
	 */
	result = libmdmp_check_file_signature(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	result = libmdmp_check_file_signature(
	          "",
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	if( source != NULL )
	{
#if defined( HAVE_MDMP_TEST_MEMORY )

		/* Test libmdmp_check_file_signature with malloc failing in libbfio_file_initialize
		 */
		mdmp_test_malloc_attempts_before_fail = 0;

		result = libmdmp_check_file_signature(
		          narrow_source,
		          &error );

		if( mdmp_test_malloc_attempts_before_fail != -1 )
		{
			mdmp_test_malloc_attempts_before_fail = -1;
		}
		else
		{
			MDMP_TEST_ASSERT_EQUAL_INT(
			 "result",
			 result,
			 -1 );

			MDMP_TEST_ASSERT_IS_NOT_NULL(
			 "error",
			 error );

			libcerror_error_free(
			 &error );
		}
#endif /* defined( HAVE_MDMP_TEST_MEMORY ) */
	}
	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

#if defined( HAVE_WIDE_CHARACTER_TYPE )

/* Tests the libmdmp_check_file_signature_wide function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_check_file_signature_wide(
     const system_character_t *source )
{
	wchar_t wide_source[ 256 ];

	libcerror_error_t *error = NULL;
	int result               = 0;

	if( source != NULL )
	{
		/* Initialize test
		 */
		result = mdmp_test_get_wide_source(
		          source,
		          wide_source,
		          256,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );

		/* Test check file signature
		 */
		result = libmdmp_check_file_signature_wide(
		          wide_source,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );
	}
	/* Test error cases
	 */
	result = libmdmp_check_file_signature_wide(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	result = libmdmp_check_file_signature_wide(
	          L"",
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	if( source != NULL )
	{
#if defined( HAVE_MDMP_TEST_MEMORY )

		/* Test libmdmp_check_file_signature_wide with malloc failing in libbfio_file_initialize
		 */
		mdmp_test_malloc_attempts_before_fail = 0;

		result = libmdmp_check_file_signature_wide(
		          wide_source,
		          &error );

		if( mdmp_test_malloc_attempts_before_fail != -1 )
		{
			mdmp_test_malloc_attempts_before_fail = -1;
		}
		else
		{
			MDMP_TEST_ASSERT_EQUAL_INT(
			 "result",
			 result,
			 -1 );

			MDMP_TEST_ASSERT_IS_NOT_NULL(
			 "error",
			 error );

			libcerror_error_free(
			 &error );
		}
#endif /* defined( HAVE_MDMP_TEST_MEMORY ) */
	}
	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

#endif /* defined( HAVE_WIDE_CHARACTER_TYPE ) */

/* Tests the libmdmp_check_file_signature_file_io_handle function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_check_file_signature_file_io_handle(
     const system_character_t *source )
{
	uint8_t empty_block[ 8192 ];

	libbfio_handle_t *file_io_handle = NULL;
	libcerror_error_t *error         = NULL;
	void *memset_result              = NULL;
	size_t source_length             = 0;
	int result                       = 0;

	/* Initialize test
	 */
	memset_result = memory_set(
	                 empty_block,
	                 0,
	                 sizeof( uint8_t ) * 8192 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "memset_result",
	 memset_result );

	if( source != NULL )
	{
		/* Initialize test
		 */
		result = libbfio_file_initialize(
		          &file_io_handle,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

		MDMP_TEST_ASSERT_IS_NOT_NULL(
		 "file_io_handle",
		 file_io_handle );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );

		source_length = system_string_length(
		                 source );

#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
		result = libbfio_file_set_name_wide(
		          file_io_handle,
		          source,
		          source_length,
		          &error );
#else
		result = libbfio_file_set_name(
		          file_io_handle,
		          source,
		          source_length,
		          &error );
#endif
		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );

		result = libbfio_handle_open(
		          file_io_handle,
		          LIBBFIO_OPEN_READ,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );

		/* Test check file signature
		 */
		result = libmdmp_check_file_signature_file_io_handle(
		          file_io_handle,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );
	}
	/* Test error cases
	 */
	result = libmdmp_check_file_signature_file_io_handle(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	/* Clean up
	 */
	if( source != NULL )
	{
		result = libbfio_handle_close(
		          file_io_handle,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 0 );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );

		result = libbfio_handle_free(
		          &file_io_handle,
		          &error );

		MDMP_TEST_ASSERT_EQUAL_INT(
		 "result",
		 result,
		 1 );

		MDMP_TEST_ASSERT_IS_NULL(
		 "file_io_handle",
		 file_io_handle );

		MDMP_TEST_ASSERT_IS_NULL(
		 "error",
		 error );
	}
	/* Test check file signature with data too small
	 */
	result = mdmp_test_open_file_io_handle(
	          &file_io_handle,
	          empty_block,
	          sizeof( uint8_t ) * 1,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "file_io_handle",
	 file_io_handle );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = libmdmp_check_file_signature_file_io_handle(
	          file_io_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	result = mdmp_test_close_file_io_handle(
	          &file_io_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 0 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test check file signature with empty block
	 */
	result = mdmp_test_open_file_io_handle(
	          &file_io_handle,
	          empty_block,
	          sizeof( uint8_t ) * 8192,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "file_io_handle",
	 file_io_handle );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = libmdmp_check_file_signature_file_io_handle(
	          file_io_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 0 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = mdmp_test_close_file_io_handle(
	          &file_io_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 0 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	if( file_io_handle != NULL )
	{
		libbfio_handle_free(
		 &file_io_handle,
		 NULL );
	}
	return( 0 );
}

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain(
     int argc,
     wchar_t * const argv[] )
#else
int main(
     int argc,
     char * const argv[] )
#endif
{
	system_character_t *source = NULL;
	system_integer_t option    = 0;

	while( ( option = mdmp_test_getopt(
	                   argc,
	                   argv,
	                   _SYSTEM_STRING( "" ) ) ) != (system_integer_t) -1 )
	{
		switch( option )
		{
			case (system_integer_t) '?':
			default:
				fprintf(
				 stderr,
				 "Invalid argument: %" PRIs_SYSTEM ".\n",
				 argv[ optind - 1 ] );

				return( EXIT_FAILURE );
		}
	}
	if( optind < argc )
	{
		source = argv[ optind ];
	}
	MDMP_TEST_RUN(
	 "libmdmp_get_version",
	 mdmp_test_get_version );

	MDMP_TEST_RUN(
	 "libmdmp_get_access_flags_read",
	 mdmp_test_get_access_flags_read );

	MDMP_TEST_RUN(
	 "libmdmp_get_codepage",
	 mdmp_test_get_codepage );

	MDMP_TEST_RUN(
	 "libmdmp_set_codepage",
	 mdmp_test_set_codepage );

#if !defined( __BORLANDC__ ) || ( __BORLANDC__ >= 0x0560 )

	MDMP_TEST_RUN_WITH_ARGS(
	 "libmdmp_check_file_signature",
	 mdmp_test_check_file_signature,
	 source );

#if defined( HAVE_WIDE_CHARACTER_TYPE )

	MDMP_TEST_RUN_WITH_ARGS(
	 "libmdmp_check_file_signature_wide",
	 mdmp_test_check_file_signature_wide,
	 source );

#endif /* defined( HAVE_WIDE_CHARACTER_TYPE ) */

	MDMP_TEST_RUN_WITH_ARGS(
	 "libmdmp_check_file_signature_file_io_handle",
	 mdmp_test_check_file_signature_file_io_handle,
	 source );

#endif /* !defined( __BORLANDC__ ) || ( __BORLANDC__ >= 0x0560 ) */

	return( EXIT_SUCCESS );

on_error:
	return( EXIT_FAILURE );
}


```

`tests/mdmp_test_tools_info_handle.c`:

```c
/*
 * Tools info_handle type test program
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <memory.h>
#include <types.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_libcerror.h"
#include "mdmp_test_macros.h"
#include "mdmp_test_memory.h"
#include "mdmp_test_unused.h"

#include "../mdmptools/info_handle.h"

/* Tests the info_handle_initialize function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_tools_info_handle_initialize(
     void )
{
	info_handle_t *info_handle      = NULL;
	libcerror_error_t *error        = NULL;
	int result                      = 0;

#if defined( HAVE_MDMP_TEST_MEMORY )
	int number_of_malloc_fail_tests = 1;
	int number_of_memset_fail_tests = 1;
	int test_number                 = 0;
#endif

	/* Test regular cases
	 */
	result = info_handle_initialize(
	          &info_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "info_handle",
	 info_handle );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	result = info_handle_free(
	          &info_handle,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "info_handle",
	 info_handle );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = info_handle_initialize(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	info_handle = (info_handle_t *) 0x12345678UL;

	result = info_handle_initialize(
	          &info_handle,
	          &error );

	info_handle = NULL;

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

#if defined( HAVE_MDMP_TEST_MEMORY )

	for( test_number = 0;
	     test_number < number_of_malloc_fail_tests;
	     test_number++ )
	{
		/* Test info_handle_initialize with malloc failing
		 */
		mdmp_test_malloc_attempts_before_fail = test_number;

		result = info_handle_initialize(
		          &info_handle,
		          &error );

		if( mdmp_test_malloc_attempts_before_fail != -1 )
		{
			mdmp_test_malloc_attempts_before_fail = -1;

			if( info_handle != NULL )
			{
				info_handle_free(
				 &info_handle,
				 NULL );
			}
		}
		else
		{
			MDMP_TEST_ASSERT_EQUAL_INT(
			 "result",
			 result,
			 -1 );

			MDMP_TEST_ASSERT_IS_NULL(
			 "info_handle",
			 info_handle );

			MDMP_TEST_ASSERT_IS_NOT_NULL(
			 "error",
			 error );

			libcerror_error_free(
			 &error );
		}
	}
	for( test_number = 0;
	     test_number < number_of_memset_fail_tests;
	     test_number++ )
	{
		/* Test info_handle_initialize with memset failing
		 */
		mdmp_test_memset_attempts_before_fail = test_number;

		result = info_handle_initialize(
		          &info_handle,
		          &error );

		if( mdmp_test_memset_attempts_before_fail != -1 )
		{
			mdmp_test_memset_attempts_before_fail = -1;

			if( info_handle != NULL )
			{
				info_handle_free(
				 &info_handle,
				 NULL );
			}
		}
		else
		{
			MDMP_TEST_ASSERT_EQUAL_INT(
			 "result",
			 result,
			 -1 );

			MDMP_TEST_ASSERT_IS_NULL(
			 "info_handle",
			 info_handle );

			MDMP_TEST_ASSERT_IS_NOT_NULL(
			 "error",
			 error );

			libcerror_error_free(
			 &error );
		}
	}
#endif /* defined( HAVE_MDMP_TEST_MEMORY ) */

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	if( info_handle != NULL )
	{
		info_handle_free(
		 &info_handle,
		 NULL );
	}
	return( 0 );
}

/* Tests the info_handle_free function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_tools_info_handle_free(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test error cases
	 */
	result = info_handle_free(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     wchar_t * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#else
int main(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     char * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#endif
{
	MDMP_TEST_UNREFERENCED_PARAMETER( argc )
	MDMP_TEST_UNREFERENCED_PARAMETER( argv )

	MDMP_TEST_RUN(
	 "info_handle_initialize",
	 mdmp_test_tools_info_handle_initialize );

	MDMP_TEST_RUN(
	 "info_handle_free",
	 mdmp_test_tools_info_handle_free );

	return( EXIT_SUCCESS );

on_error:
	return( EXIT_FAILURE );
}


```

`tests/mdmp_test_tools_output.c`:

```c
/*
 * Tools output functions test program
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <types.h>

#include <stdio.h>

#if defined( HAVE_IO_H ) || defined( WINAPI )
#include <io.h>
#endif

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_libcerror.h"
#include "mdmp_test_macros.h"
#include "mdmp_test_unused.h"

#include "../mdmptools/mdmptools_output.h"

/* Tests the mdmptools_output_initialize function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_tools_output_initialize(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	result = mdmptools_output_initialize(
	          _IONBF,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     wchar_t * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#else
int main(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     char * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#endif
{
	MDMP_TEST_UNREFERENCED_PARAMETER( argc )
	MDMP_TEST_UNREFERENCED_PARAMETER( argv )

	MDMP_TEST_RUN(
	 "mdmptools_output_initialize",
	 mdmp_test_tools_output_initialize )

	/* TODO add tests for mdmptools_output_copyright_fprint */

	/* TODO add tests for mdmptools_output_version_fprint */

	/* TODO add tests for mdmptools_output_version_detailed_fprint */

	return( EXIT_SUCCESS );

on_error:
	return( EXIT_FAILURE );
}


```

`tests/mdmp_test_tools_signal.c`:

```c
/*
 * Tools signal functions test program
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <common.h>
#include <file_stream.h>
#include <types.h>

#if defined( HAVE_STDLIB_H ) || defined( WINAPI )
#include <stdlib.h>
#endif

#include "mdmp_test_libcerror.h"
#include "mdmp_test_macros.h"
#include "mdmp_test_unused.h"

#include "../mdmptools/mdmptools_signal.h"

void mdmp_test_tools_signal_handler_function(
      mdmptools_signal_t signal MDMP_TEST_ATTRIBUTE_UNUSED )
{
	MDMP_TEST_UNREFERENCED_PARAMETER( signal )
}

#if defined( WINAPI )

/* Tests the mdmptools_signal_handler function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_tools_signal_handler(
     void )
{
	BOOL result = 0;

	/* Test regular cases
	 */
	result = mdmptools_signal_handler(
	          CTRL_C_EVENT );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 (int) TRUE );

	result = mdmptools_signal_handler(
	          CTRL_LOGOFF_EVENT );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 (int) FALSE );

	return( 1 );

on_error:
	return( 0 );
}

#if defined( _MSC_VER )

	/* TODO add tests for mdmptools_signal_initialize_memory_debug */

#endif /* defined( _MSC_VER ) */

#endif /* defined( WINAPI ) */

/* Tests the mdmptools_signal_attach function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_tools_signal_attach(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test regular cases
	 */
	result = mdmptools_signal_attach(
	          mdmp_test_tools_signal_handler_function,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	/* Test error cases
	 */
	result = mdmptools_signal_attach(
	          NULL,
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 -1 );

	MDMP_TEST_ASSERT_IS_NOT_NULL(
	 "error",
	 error );

	libcerror_error_free(
	 &error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* Tests the mdmptools_signal_detach function
 * Returns 1 if successful or 0 if not
 */
int mdmp_test_tools_signal_detach(
     void )
{
	libcerror_error_t *error = NULL;
	int result               = 0;

	/* Test regular cases
	 */
	result = mdmptools_signal_detach(
	          &error );

	MDMP_TEST_ASSERT_EQUAL_INT(
	 "result",
	 result,
	 1 );

	MDMP_TEST_ASSERT_IS_NULL(
	 "error",
	 error );

	return( 1 );

on_error:
	if( error != NULL )
	{
		libcerror_error_free(
		 &error );
	}
	return( 0 );
}

/* The main program
 */
#if defined( HAVE_WIDE_SYSTEM_CHARACTER )
int wmain(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     wchar_t * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#else
int main(
     int argc MDMP_TEST_ATTRIBUTE_UNUSED,
     char * const argv[] MDMP_TEST_ATTRIBUTE_UNUSED )
#endif
{
	MDMP_TEST_UNREFERENCED_PARAMETER( argc )
	MDMP_TEST_UNREFERENCED_PARAMETER( argv )

#if defined( WINAPI )

	MDMP_TEST_RUN(
	 "mdmptools_signal_handler",
	 mdmp_test_tools_signal_handler )

#if defined( _MSC_VER )

	/* TODO add tests for mdmptools_signal_initialize_memory_debug */

#endif /* defined( _MSC_VER ) */

#endif /* defined( WINAPI ) */

	MDMP_TEST_RUN(
	 "mdmptools_signal_attach",
	 mdmp_test_tools_signal_attach )

	MDMP_TEST_RUN(
	 "mdmptools_signal_detach",
	 mdmp_test_tools_signal_detach )

	return( EXIT_SUCCESS );

on_error:
	return( EXIT_FAILURE );
}


```

`tests/mdmp_test_unused.h`:

```h
/*
 * Definitions to silence compiler warnings about unused function attributes/parameters.
 *
 * Copyright (C) 2014-2024, Joachim Metz <joachim.metz@gmail.com>
 *
 * Refer to AUTHORS for acknowledgements.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined( _MDMP_TEST_UNUSED_H )
#define _MDMP_TEST_UNUSED_H

#include <common.h>

#if !defined( MDMP_TEST_ATTRIBUTE_UNUSED )

#if defined( __GNUC__ ) && __GNUC__ >= 3
#define MDMP_TEST_ATTRIBUTE_UNUSED	__attribute__ ((__unused__))

#else
#define MDMP_TEST_ATTRIBUTE_UNUSED

#endif /* defined( __GNUC__ ) && __GNUC__ >= 3 */

#endif /* !defined( MDMP_TEST_ATTRIBUTE_UNUSED ) */

#if defined( _MSC_VER )
#define MDMP_TEST_UNREFERENCED_PARAMETER( parameter ) \
	UNREFERENCED_PARAMETER( parameter );

#else
#define MDMP_TEST_UNREFERENCED_PARAMETER( parameter ) \
	/* parameter */

#endif /* defined( _MSC_VER ) */

#endif /* !defined( _MDMP_TEST_UNUSED_H ) */


```

`tests/pkgbuild.sh`:

```sh
#!/bin/sh
# Script to build a MacOS pkg
#
# Version: 20201121

set -e

make install DESTDIR=${PWD}/osx-pkg
mkdir -p ${PWD}/osx-pkg/usr/share/doc/libmdmp
cp AUTHORS COPYING COPYING.LESSER NEWS README ${PWD}/osx-pkg/usr/share/doc/libmdmp

VERSION=`sed '5!d; s/^ \[//;s/\],$//' configure.ac`
pkgbuild --root osx-pkg --identifier com.github.libyal.libmdmp --version ${VERSION} --ownership recommended ../libmdmp-${VERSION}.pkg


```

`tests/runtests.sh`:

```sh
#!/bin/sh
# Script to run tests
#
# Version: 20201121

if test -f ${PWD}/libmdmp/.libs/libmdmp.1.dylib && test -f ./pymdmp/.libs/pymdmp.so;
then
	install_name_tool -change /usr/local/lib/libmdmp.1.dylib ${PWD}/libmdmp/.libs/libmdmp.1.dylib ./pymdmp/.libs/pymdmp.so;
fi

make check CHECK_WITH_STDERR=1;
RESULT=$?;

if test ${RESULT} -ne 0 && test -f tests/test-suite.log;
then
	cat tests/test-suite.log;
fi
exit ${RESULT};


```

`tests/syncsharedlibs.sh`:

```sh
#!/bin/sh
# Script that synchronizes the shared library dependencies
#
# Version: 20201121

EXIT_SUCCESS=0;
EXIT_FAILURE=1;

GIT_URL_PREFIX="https://github.com/libyal";
SHARED_LIBS="libcerror libcthreads libcdata libclocale libcnotify libcsplit libuna libcfile libcpath libbfio libfcache libfdata libfdatetime";

USE_HEAD="";

if test "$1" = "--use-head";
then
	USE_HEAD="--use-head";
fi

OLDIFS=$IFS;
IFS=" ";

for SHARED_LIB in ${SHARED_LIBS};
do
	GIT_URL="${GIT_URL_PREFIX}/${SHARED_LIB}.git";

	git clone --quiet ${GIT_URL} ${SHARED_LIB}-$$;

	if ! test -d ${SHARED_LIB}-$$;
	then
		echo "Unable to git clone: ${GIT_URL}";

		IFS=$OLDIFS;

		exit ${EXIT_FAILURE};
	fi
	(cd ${SHARED_LIB}-$$ && git fetch --quiet --all --tags --prune)

	LATEST_TAG=`cd ${SHARED_LIB}-$$ && git describe --tags --abbrev=0`;

	if test -n ${LATEST_TAG} && test -z ${USE_HEAD};
	then
		echo "Synchronizing: ${SHARED_LIB} from ${GIT_URL} tag ${LATEST_TAG}";

		(cd ${SHARED_LIB}-$$ && git checkout --quiet tags/${LATEST_TAG});
	else
		echo "Synchronizing: ${SHARED_LIB} from ${GIT_URL} HEAD";
	fi

	(cd ${SHARED_LIB}-$$ && ./synclibs.sh ${USE_HEAD} && ./autogen.sh);

	CONFIGURE_OPTIONS="";

	(cd ${SHARED_LIB}-$$ && ./configure --help | grep -- '--enable-wide-character-type' > /dev/null);

	if test $? -eq 0;
	then
		CONFIGURE_OPTIONS="${CONFIGURE_OPTIONS} --enable-wide-character-type";
	fi

	(cd ${SHARED_LIB}-$$ && ./configure --prefix=/usr ${CONFIGURE_OPTIONS} && make && sudo make install);

	rm -rf ${SHARED_LIB}-$$;
done

IFS=$OLDIFS;

exit ${EXIT_SUCCESS};


```

`tests/test_library.ps1`:

```ps1
# Tests library functions and types.
#
# Version: 20230410

$ExitSuccess = 0
$ExitFailure = 1
$ExitIgnore = 77

$LibraryTests = "error io_handle notify stream stream_descriptor stream_io_handle"
$LibraryTestsWithInput = "file support"
$OptionSets = ""

$InputGlob = "*"

Function GetTestExecutablesDirectory
{
	$TestExecutablesDirectory = ""

	ForEach (${VSDirectory} in ("msvscpp", "vs2008", "vs2010", "vs2012", "vs2013", "vs2015", "vs2017", "vs2019", "vs2022"))
	{
		ForEach (${VSConfiguration} in ("Release", "VSDebug"))
		{
			ForEach (${VSPlatform} in ("Win32", "x64"))
			{
				$TestExecutablesDirectory = "..\${VSDirectory}\${VSConfiguration}\${VSPlatform}"

				If (Test-Path ${TestExecutablesDirectory})
				{
					Return ${TestExecutablesDirectory}
				}
			}
			$TestExecutablesDirectory = "..\${VSDirectory}\${VSConfiguration}"

			If (Test-Path ${TestExecutablesDirectory})
			{
				Return ${TestExecutablesDirectory}
			}
		}
	}
	Return ${TestExecutablesDirectory}
}

Function ReadIgnoreList
{
	param( [string]$TestProfileDirectory )

	$IgnoreFile = "${TestProfileDirectory}\ignore"
	$IgnoreList = ""

	If (Test-Path -Path ${IgnoreFile} -PathType "Leaf")
	{
		$IgnoreList = Get-Content -Path ${IgnoreFile} | Where {$_ -notmatch '^#.*'}
	}
	Return $IgnoreList
}

Function RunTest
{
	param( [string]$TestType )

	$TestDescription = "Testing: ${TestName}"
	$TestExecutable = "${TestExecutablesDirectory}\mdmp_test_${TestName}.exe"

	If (-Not (Test-Path -Path ${TestExecutable} -PathType "Leaf"))
	{
		Write-Host "${TestDescription} (" -nonewline
		Write-Host "SKIP" -foreground Cyan -nonewline
		Write-Host ")"

		Return ${ExitIgnore}
	}
	$Output = Invoke-Expression ${TestExecutable}
	$Result = ${LastExitCode}

	If (${Result} -ne ${ExitSuccess})
	{
		Write-Host ${Output} -foreground Red
	}
	Write-Host "${TestDescription} (" -nonewline

	If (${Result} -ne ${ExitSuccess})
	{
		Write-Host "FAIL" -foreground Red -nonewline
	}
	Else
	{
		Write-Host "PASS" -foreground Green -nonewline
	}
	Write-Host ")"

	Return ${Result}
}

Function RunTestWithInput
{
	param( [string]$TestType )

	$TestDescription = "Testing: ${TestName}"
	$TestExecutable = "${TestExecutablesDirectory}\mdmp_test_${TestName}.exe"

	If (-Not (Test-Path -Path ${TestExecutable} -PathType "Leaf"))
	{
		Write-Host "${TestDescription} (" -nonewline
		Write-Host "SKIP" -foreground Cyan -nonewline
		Write-Host ")"

		Return ${ExitIgnore}
	}
	$TestProfileDirectory = "input\.libmdmp"

	If (-Not (Test-Path -Path ${TestProfileDirectory} -PathType "Container"))
	{
		New-Item -ItemType "directory" -Path ${TestProfileDirectory}
	}
	$IgnoreList = ReadIgnoreList ${TestProfileDirectory}

	$Result = ${ExitSuccess}

	ForEach ($TestSetInputDirectory in Get-ChildItem -Path "input" -Exclude ".*")
	{
		If (-Not (Test-Path -Path ${TestSetInputDirectory} -PathType "Container"))
		{
			Continue
		}
		If (${TestSetInputDirectory} -Contains ${IgnoreList})
		{
			Continue
		}
		$TestSetName = ${TestSetInputDirectory}.Name

		If (Test-Path -Path "${TestProfileDirectory}\${TestSetName}\files" -PathType "Leaf")
		{
			$InputFiles = Get-Content -Path "${TestProfileDirectory}\${TestSetName}\files" | Where {$_ -ne ""}
		}
		Else
		{
			$InputFiles = Get-ChildItem -Path ${TestSetInputDirectory} -Include ${InputGlob}
		}
		ForEach ($InputFile in ${InputFiles})
		{
			$TestedWithOptions = $False

			ForEach ($OptionSet in ${OptionSets} -split " ")
			{
				$InputFileName = ${InputFile}.Name
				$TestDataOptionFile = "${TestProfileDirectory}\${TestSetName}\${InputFileName}.${OptionSet}"

				If (-Not (Test-Path -Path "${TestDataOptionFile}" -PathType "Leaf"))
				{
					Continue
				}
				$InputOptions = Get-content -Path "${TestDataOptionFile}" -First 1

				$Output = Invoke-Expression "${TestExecutable} ${InputOptions} ${InputFile}"
				$Result = $LastExitCode

				If (${Result} -ne ${ExitSuccess})
				{
					Break
				}
				$TestedWithOptions = $True
			}
			If ((${Result} -eq ${ExitSuccess}) -And (-Not (${TestedWithOptions})))
			{
				$Output = Invoke-Expression "${TestExecutable} ${InputFile}"
				$Result = ${LastExitCode}
			}
			If (${Result} -ne ${ExitSuccess})
			{
				Break
			}
		}
		If (${Result} -ne ${ExitSuccess})
		{
			Break
		}
	}
	If (${Result} -ne ${ExitSuccess})
	{
		Write-Host ${Output} -foreground Red
	}
	Write-Host "${TestDescription} (" -nonewline

	If (${Result} -ne ${ExitSuccess})
	{
		Write-Host "FAIL" -foreground Red -nonewline
	}
	Else
	{
		Write-Host "PASS" -foreground Green -nonewline
	}
	Write-Host ")"

	Return ${Result}
}

$TestExecutablesDirectory = GetTestExecutablesDirectory

If (-Not (Test-Path ${TestExecutablesDirectory}))
{
	Write-Host "Missing test executables directory." -foreground Red

	Exit ${ExitFailure}
}

$Result = ${ExitIgnore}

Foreach (${TestName} in ${LibraryTests} -split " ")
{
	# Split will return an array of a single empty string when LibraryTests is empty.
	If (-Not (${TestName}))
	{
		Continue
	}
	$Result = RunTest ${TestName}

	If ((${Result} -ne ${ExitSuccess}) -And (${Result} -ne ${ExitIgnore}))
	{
		Break
	}
}

Foreach (${TestName} in ${LibraryTestsWithInput} -split " ")
{
	# Split will return an array of a single empty string when LibraryTestsWithInput is empty.
	If (-Not (${TestName}))
	{
		Continue
	}
	If (Test-Path -Path "input" -PathType "Container")
	{
		$Result = RunTestWithInput ${TestName}
	}
	Else
	{
		$Result = RunTest ${TestName}
	}
	If ((${Result} -ne ${ExitSuccess}) -And (${Result} -ne ${ExitIgnore}))
	{
		Break
	}
}

Exit ${Result}


```

`tests/test_library.sh`:

```sh
#!/usr/bin/env bash
# Tests library functions and types.
#
# Version: 20231007

EXIT_SUCCESS=0;
EXIT_FAILURE=1;
EXIT_IGNORE=77;

LIBRARY_TESTS="error io_handle notify stream stream_descriptor stream_io_handle";
LIBRARY_TESTS_WITH_INPUT="file support";
OPTION_SETS=();

INPUT_GLOB="*";

run_test()
{
	local TEST_NAME=$1;

	local TEST_DESCRIPTION="Testing: ${TEST_NAME}";
	local TEST_EXECUTABLE="./mdmp_test_${TEST_NAME}";

	if ! test -x "${TEST_EXECUTABLE}";
	then
		TEST_EXECUTABLE="${TEST_EXECUTABLE}.exe";
	fi

	# TODO: add support for TEST_PROFILE and OPTION_SETS?
	run_test_with_arguments "${TEST_DESCRIPTION}" "${TEST_EXECUTABLE}";
	local RESULT=$?;

	return ${RESULT};
}

run_test_with_input()
{
	local TEST_NAME=$1;

	local TEST_DESCRIPTION="Testing: ${TEST_NAME}";
	local TEST_EXECUTABLE="./mdmp_test_${TEST_NAME}";

	if ! test -x "${TEST_EXECUTABLE}";
	then
		TEST_EXECUTABLE="${TEST_EXECUTABLE}.exe";
	fi

	if ! test -d "input";
	then
		echo "Test input directory not found.";

		return ${EXIT_IGNORE};
	fi
	local RESULT=`ls input/* | tr ' ' '\n' | wc -l`;

	if test ${RESULT} -eq ${EXIT_SUCCESS};
	then
		echo "No files or directories found in the test input directory";

		return ${EXIT_IGNORE};
	fi

	local TEST_PROFILE_DIRECTORY=$(get_test_profile_directory "input" "libmdmp");

	local IGNORE_LIST=$(read_ignore_list "${TEST_PROFILE_DIRECTORY}");

	RESULT=${EXIT_SUCCESS};

	for TEST_SET_INPUT_DIRECTORY in input/*;
	do
		if ! test -d "${TEST_SET_INPUT_DIRECTORY}";
		then
			continue;
		fi
		if check_for_directory_in_ignore_list "${TEST_SET_INPUT_DIRECTORY}" "${IGNORE_LIST}";
		then
			continue;
		fi

		local TEST_SET_DIRECTORY=$(get_test_set_directory "${TEST_PROFILE_DIRECTORY}" "${TEST_SET_INPUT_DIRECTORY}");

		if test -f "${TEST_SET_DIRECTORY}/files";
		then
			IFS="" read -a INPUT_FILES <<< $(cat ${TEST_SET_DIRECTORY}/files | sed "s?^?${TEST_SET_INPUT_DIRECTORY}/?");
		else
			IFS="" read -a INPUT_FILES <<< $(ls -1d ${TEST_SET_INPUT_DIRECTORY}/${INPUT_GLOB});
		fi
		for INPUT_FILE in "${INPUT_FILES[@]}";
		do
			OPTION_INPUT_FILE="${INPUT_FILE}";

			if test "${OSTYPE}" = "msys";
			then
				# A test executable built with MinGW expects a Windows path.
				INPUT_FILE=`echo ${INPUT_FILE} | sed 's?/?\\\\?g'`;
			fi
			local TESTED_WITH_OPTIONS=0;

			for OPTION_SET in ${OPTION_SETS[@]};
			do
				local TEST_DATA_OPTION_FILE=$(get_test_data_option_file "${TEST_SET_DIRECTORY}" "${OPTION_INPUT_FILE}" "${OPTION_SET}");

				if test -f ${TEST_DATA_OPTION_FILE};
				then
					TESTED_WITH_OPTIONS=1;

					IFS=" " read -a OPTIONS <<< $(read_test_data_option_file "${TEST_SET_DIRECTORY}" "${INPUT_FILE}" "${OPTION_SET}");

					run_test_on_input_file "${TEST_SET_DIRECTORY}" "${TEST_DESCRIPTION}" "default" "${OPTION_SET}" "${TEST_EXECUTABLE}" "${INPUT_FILE}" "${OPTIONS[@]}";
					RESULT=$?;

					if test ${RESULT} -ne ${EXIT_SUCCESS};
					then
						break;
					fi
				fi
			done

			if test ${TESTED_WITH_OPTIONS} -eq 0;
			then
				run_test_on_input_file "${TEST_SET_DIRECTORY}" "${TEST_DESCRIPTION}" "default" "" "${TEST_EXECUTABLE}" "${INPUT_FILE}";
				RESULT=$?;
			fi

			if test ${RESULT} -ne ${EXIT_SUCCESS};
			then
				break;
			fi
		done

		if test ${RESULT} -ne ${EXIT_SUCCESS};
		then
			break;
		fi
	done

	return ${RESULT};
}

if test -n "${SKIP_LIBRARY_TESTS}";
then
	exit ${EXIT_IGNORE};
fi

TEST_RUNNER="tests/test_runner.sh";

if ! test -f "${TEST_RUNNER}";
then
	TEST_RUNNER="./test_runner.sh";
fi

if ! test -f "${TEST_RUNNER}";
then
	echo "Missing test runner: ${TEST_RUNNER}";

	exit ${EXIT_FAILURE};
fi

source ${TEST_RUNNER};

RESULT=${EXIT_IGNORE};

for TEST_NAME in ${LIBRARY_TESTS};
do
	run_test "${TEST_NAME}";
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		break;
	fi
done

if test ${RESULT} -ne ${EXIT_SUCCESS} && test ${RESULT} -ne ${EXIT_IGNORE};
then
	exit ${RESULT};
fi

for TEST_NAME in ${LIBRARY_TESTS_WITH_INPUT};
do
	if test -d "input";
	then
		run_test_with_input "${TEST_NAME}";
		RESULT=$?;
	else
		run_test "${TEST_NAME}";
		RESULT=$?;
	fi

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		break;
	fi
done

exit ${RESULT};


```

`tests/test_manpage.sh`:

```sh
#!/usr/bin/env bash
# Tests man pages.
#
# Version: 20230410

EXIT_SUCCESS=0;
EXIT_FAILURE=1;
EXIT_IGNORE=77;

run_test()
{
	local INPUT_FILE=$1;
	local RESULT=0

	TEST_NAME=`basename ${INPUT_FILE}`;
	echo -n "Testing man with input: ${TEST_NAME}";

	LC_ALL=en_US.UTF-8 MANROFFSEQ='' MANWIDTH=80 man --warnings -E UTF-8 -l -Tutf8 -Z ${INPUT_FILE} > /dev/null 2> ${TMPDIR}/${TEST_NAME}.warnings;
	RESULT=$?;

	# For now line break warnings are ignored.
	if test -f ${TMPDIR}/${TEST_NAME}.warnings;
	then
		sed "/can't break line/ d" -i ${TMPDIR}/${TEST_NAME}.warnings;
	fi
	if test -s ${TMPDIR}/${TEST_NAME}.warnings;
	then
		RESULT=${EXIT_FAILURE};
	fi
	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		echo " (FAIL)";
	else
		echo " (PASS)";
	fi
	if test -s ${TMPDIR}/${TEST_NAME}.warnings;
	then
		cat ${TMPDIR}/${TEST_NAME}.warnings;
	fi
	return ${RESULT};
}

if test "${OSTYPE}" = "msys";
then
	exit ${EXIT_IGNORE};
fi

TEST_RUNNER="tests/test_runner.sh";

if ! test -f "${TEST_RUNNER}";
then
	TEST_RUNNER="./test_runner.sh";
fi

if ! test -f "${TEST_RUNNER}";
then
	echo "Missing test runner: ${TEST_RUNNER}";

	exit ${EXIT_FAILURE};
fi

source ${TEST_RUNNER};

assert_availability_binary man;

RESULT=${EXIT_IGNORE};

TMPDIR="tmp$$";

rm -rf ${TMPDIR};
mkdir ${TMPDIR};

MANUALS_PATH="../manuals";

if ! test -d ${MANUALS_PATH};
then
	MANUALS_PATH="manuals";
fi

if ! test -d ${MANUALS_PATH};
then
	echo "Manuals directory not found.";

	exit ${EXIT_IGNORE};
fi

for INPUT_FILE in ${MANUALS_PATH}/*.[13];
do
	run_test "${INPUT_FILE}";
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		break;
	fi
done

rm -rf ${TMPDIR};

exit ${RESULT};


```

`tests/test_mdmpinfo.ps1`:

```ps1
# Info tool testing script
#
# Version: 20230410

$ExitSuccess = 0
$ExitFailure = 1
$ExitIgnore = 77

$Profiles = @("mdmpinfo")
$OptionsPerProfile = @("")
$OptionSets = ""

$InputGlob = "*"

Function GetTestExecutablesDirectory
{
	$TestExecutablesDirectory = ""

	ForEach (${VSDirectory} in ("msvscpp", "vs2008", "vs2010", "vs2012", "vs2013", "vs2015", "vs2017", "vs2019", "vs2022"))
	{
		ForEach (${VSConfiguration} in ("Release", "VSDebug"))
		{
			ForEach (${VSPlatform} in ("Win32", "x64"))
			{
				$TestExecutablesDirectory = "..\${VSDirectory}\${VSConfiguration}\${VSPlatform}"

				If (Test-Path ${TestExecutablesDirectory})
				{
					Return ${TestExecutablesDirectory}
				}
			}
			$TestExecutablesDirectory = "..\${VSDirectory}\${VSConfiguration}"

			If (Test-Path ${TestExecutablesDirectory})
			{
				Return ${TestExecutablesDirectory}
			}
		}
	}
	Return ${TestExecutablesDirectory}
}

Function ReadIgnoreList
{
	param( [string]$TestProfileDirectory )

	$IgnoreFile = "${TestProfileDirectory}\ignore"
	$IgnoreList = ""

	If (Test-Path -Path ${IgnoreFile} -PathType "Leaf")
	{
		$IgnoreList = Get-Content -Path ${IgnoreFile} | Where {$_ -notmatch '^#.*'}
	}
	Return $IgnoreList
}

$TestExecutablesDirectory = GetTestExecutablesDirectory

If (-Not (Test-Path ${TestExecutablesDirectory}))
{
	Write-Host "Missing test executables directory." -foreground Red

	Exit ${ExitFailure}
}

$TestExecutable = "${TestExecutablesDirectory}\mdmpinfo.exe"

If (-Not (Test-Path -Path "input"))
{
	Exit ${ExitIgnore}
}
$Result = ${ExitSuccess}

For ($ProfileIndex = 0; $ProfileIndex -le ($Profiles.length - 1); $ProfileIndex += 1)
{
	$TestProfile = $Profiles[$ProfileIndex]
	$Options = $OptionsPerProfile[$ProfileIndex]

	$TestProfileDirectory = "input\.${TestProfile}"

	If (-Not (Test-Path -Path ${TestProfileDirectory} -PathType "Container"))
	{
		New-Item -ItemType "directory" -Path ${TestProfileDirectory} | Out-Null
	}
	$IgnoreList = ReadIgnoreList ${TestProfileDirectory}

	# Note that the trailing backtick is needed.
	Get-ChildItem -Path "input" -Exclude ".*" | ForEach-Object `
	{
		$TestSetDirectory = $_

		If (-Not (Test-Path -Path ${TestSetDirectory} -PathType Container))
		{
			Continue
		}
		$TestSetName = ${TestSetDirectory}.Name

		If (${IgnoreList}.Contains(${TestSetName}))
		{
			Continue
		}
		If (-Not (Test-Path -Path "${TestProfileDirectory}\${TestSetName}" -PathType Container))
		{
			New-Item -Name "${TestProfileDirectory}\${TestSetName}" -ItemType "directory" | Out-Null
		}
		If (Test-Path -Path "${TestProfileDirectory}\${TestSetName}\files" -PathType Container)
		{
			$InputFiles = Get-content -Path "${TestProfileDirectory}\${TestSetName}\files"
		}
		Else
		{
			$InputFiles = Get-ChildItem -Path "${TestSetDirectory}\${InputGlob}"
		}
		ForEach ($InputFile in ${InputFiles})
		{
			$InputFileName = ${InputFile}.Name

			$TestedWithOptions = $False

			$TmpDir = "tmp${PID}"

			New-Item -Name ${TmpDir} -ItemType "directory" | Out-Null

			Push-Location ${TmpDir}

			Try
			{
				ForEach ($OptionSet in ${OptionSets} -split " ")
				{
					$TestDataOptionFile = "..\${TestProfileDirectory}\${TestSetName}\${InputFileName}.${OptionSet}"

					If (-Not (Test-Path -Path "${TestDataOptionFile}" -PathType "Leaf"))
					{
						Continue
					}
					$InputOptions = Get-content -Path "${TestDataOptionFile}" -First 1

					$TestLog = "${InputFileName}-${OptionSet}.log"

					Invoke-Expression "..\${TestExecutable} ${Options} ${InputOptions} ${InputFile} > ${TestLog}"
					$Result = $LastExitCode

					If (${Result} -ne ${ExitSuccess})
					{
						Break
					}
					$TestedWithOptions = $True
				}
				If ((${Result} -eq ${ExitSuccess}) -And (-Not (${TestedWithOptions})))
				{
					$TestLog = "${InputFileName}.log"

					Invoke-Expression "..\${TestExecutable} ${Options} ${InputFile} > ${TestLog}"
					$Result = $LastExitCode
				}
				If (${Result} -eq ${ExitSuccess})
				{
					# Strip header with version.
					(Get-Content ${TestLog} | Select-Object -Skip 2) | Set-Content ${TestLog}

					$StoredTestLog = "..\${TestProfileDirectory}\${TestSetName}\${TestLog}"

					If (Test-Path -Path ${StoredTestLog} -PathType "Leaf")
					{
						$Difference = Compare-Object -ReferenceObject (Get-Content -Path ${StoredTestLog}) -DifferenceObject (Get-Content -Path ${TestLog})

						If (${Difference})
						{
							$Result = ${ExitFailure}
						}
					}
					Else
					{
						Move-Item -Path ${TestLog} -Destination ${StoredTestLog}
					}
				}
			}
			Finally
			{
				Pop-Location

				Remove-Item ${TmpDir} -Force -Recurse
			}
		}
		If (${Result} -ne ${ExitSuccess})
		{
			Break
		}
	}
}

Exit ${Result}


```

`tests/test_mdmpinfo.sh`:

```sh
#!/usr/bin/env bash
# Info tool testing script
#
# Version: 20231005

EXIT_SUCCESS=0;
EXIT_FAILURE=1;
EXIT_IGNORE=77;

PROFILES=("mdmpinfo");
OPTIONS_PER_PROFILE=("");
OPTION_SETS=();

INPUT_GLOB="*";

if test -n "${SKIP_TOOLS_TESTS}" || test -n "${SKIP_TOOLS_END_TO_END_TESTS}";
then
	exit ${EXIT_IGNORE};
fi

TEST_EXECUTABLE="../mdmptools/mdmpinfo";

if ! test -x "${TEST_EXECUTABLE}";
then
	TEST_EXECUTABLE="../mdmptools/mdmpinfo.exe";
fi

if ! test -x "${TEST_EXECUTABLE}";
then
	echo "Missing test executable: ${TEST_EXECUTABLE}";

	exit ${EXIT_FAILURE};
fi

TEST_RUNNER="tests/test_runner.sh";

if ! test -f "${TEST_RUNNER}";
then
	TEST_RUNNER="./test_runner.sh";
fi

if ! test -f "${TEST_RUNNER}";
then
	echo "Missing test runner: ${TEST_RUNNER}";

	exit ${EXIT_FAILURE};
fi

source ${TEST_RUNNER};

if ! test -d "input";
then
	echo "Test input directory not found.";

	exit ${EXIT_IGNORE};
fi
RESULT=`ls input/* | tr ' ' '\n' | wc -l`;

if test ${RESULT} -eq ${EXIT_SUCCESS};
then
	echo "No files or directories found in the test input directory";

	exit ${EXIT_IGNORE};
fi

for PROFILE_INDEX in ${!PROFILES[*]};
do
	TEST_PROFILE=${PROFILES[${PROFILE_INDEX}]};

	TEST_PROFILE_DIRECTORY=$(get_test_profile_directory "input" "${TEST_PROFILE}");

	IGNORE_LIST=$(read_ignore_list "${TEST_PROFILE_DIRECTORY}");

	IFS=" " read -a PROFILE_OPTIONS <<< ${OPTIONS_PER_PROFILE[${PROFILE_INDEX}]};

	RESULT=${EXIT_SUCCESS};

	for TEST_SET_INPUT_DIRECTORY in input/*;
	do
		if ! test -d "${TEST_SET_INPUT_DIRECTORY}";
		then
			continue;
		fi
		TEST_SET=`basename ${TEST_SET_INPUT_DIRECTORY}`;

		if check_for_test_set_in_ignore_list "${TEST_SET}" "${IGNORE_LIST}";
		then
			continue;
		fi
		TEST_SET_DIRECTORY=$(get_test_set_directory "${TEST_PROFILE_DIRECTORY}" "${TEST_SET_INPUT_DIRECTORY}");

		RESULT=${EXIT_SUCCESS};

		if test -f "${TEST_SET_DIRECTORY}/files";
		then
			IFS="" read -a INPUT_FILES <<< $(cat ${TEST_SET_DIRECTORY}/files | sed "s?^?${TEST_SET_INPUT_DIRECTORY}/?");
		else
			IFS="" read -a INPUT_FILES <<< $(ls -1d ${TEST_SET_INPUT_DIRECTORY}/${INPUT_GLOB});
		fi
		for INPUT_FILE in "${INPUT_FILES[@]}";
		do
			TESTED_WITH_OPTIONS=0;

			for OPTION_SET in ${OPTION_SETS[@]};
			do
				TEST_DATA_OPTION_FILE=$(get_test_data_option_file "${TEST_SET_DIRECTORY}" "${INPUT_FILE}" "${OPTION_SET}");

				if test -f ${TEST_DATA_OPTION_FILE};
				then
					TESTED_WITH_OPTIONS=1;

					IFS=" " read -a OPTIONS <<< $(read_test_data_option_file "${TEST_SET_DIRECTORY}" "${INPUT_FILE}" "${OPTION_SET}");

					run_test_on_input_file "${TEST_SET_DIRECTORY}" "mdmpinfo" "with_stdout_reference" "${OPTION_SET}" "${TEST_EXECUTABLE}" "${INPUT_FILE}" "${PROFILE_OPTIONS[@]}" "${OPTIONS[@]}";
					RESULT=$?;

					if test ${RESULT} -ne ${EXIT_SUCCESS};
					then
						break;
					fi
				fi
			done

			if test ${TESTED_WITH_OPTIONS} -eq 0;
			then
				run_test_on_input_file "${TEST_SET_DIRECTORY}" "mdmpinfo" "with_stdout_reference" "" "${TEST_EXECUTABLE}" "${INPUT_FILE}" "${PROFILE_OPTIONS[@]}";
				RESULT=$?;
			fi

			if test ${RESULT} -ne ${EXIT_SUCCESS};
			then
				break;
			fi
		done

		# Ignore failures due to corrupted data.
		if test "${TEST_SET}" = "corrupted";
		then
			RESULT=${EXIT_SUCCESS};
		fi
		if test ${RESULT} -ne ${EXIT_SUCCESS};
		then
			break;
		fi
	done
done

exit ${RESULT};


```

`tests/test_runner.sh`:

```sh
#!/usr/bin/env bash
# Bash functions to run an executable for testing.
#
# Version: 20231013
#
# When CHECK_WITH_ASAN is set to a non-empty value the test executable
# is run with asan, otherwise it is run without.
#
# When CHECK_WITH_GDB is set to a non-empty value the test executable
# is run with gdb, otherwise it is run without.
#
# When CHECK_WITH_STDERR is set to a non-empty value the test executable
# is run with error output to stderr.
#
# When CHECK_WITH_VALGRIND is set to a non-empty value the test executable
# is run with valgrind, otherwise it is run without.
#
# PYTHON and PYTHON_VERSION are used to determine the Python interpreter.

EXIT_SUCCESS=0;
EXIT_FAILURE=1;
EXIT_IGNORE=77;

# Checks the availability of a binary and exits if not available.
#
# Arguments:
#   a string containing the name of the binary
#
assert_availability_binary()
{
	local BINARY=$1;

	which ${BINARY} > /dev/null 2>&1;
	if test $? -ne ${EXIT_SUCCESS};
	then
		echo "Missing binary: ${BINARY}";
		echo "";

		exit ${EXIT_FAILURE};
	fi
}

# Checks the availability of binaries and exits if not available.
#
# Globals:
#   CHECK_WITH_GDB
#   CHECK_WITH_VALGRIND
#
assert_availability_binaries()
{
	assert_availability_binary cat;
	assert_availability_binary cut;
	assert_availability_binary diff;
	assert_availability_binary file;
	assert_availability_binary gzip;
	assert_availability_binary ls;
	assert_availability_binary readlink;
	assert_availability_binary sed;
	assert_availability_binary tr;
	assert_availability_binary uname;
	assert_availability_binary wc;
	assert_availability_binary zcat;

	if test -n "${CHECK_WITH_GDB}";
	then
		assert_availability_binary gdb;

	elif test -n "${CHECK_WITH_VALGRIND}";
	then
		assert_availability_binary valgrind;
	fi
}

# Checks if the test set is in the ignore list.
#
# Arguments:
#   a string containing the test set
#   a string containing space separated ignore list
#
# Returns:
#   an integer containing the exit status to indicate the input directory
#   was found in the ignore list.
#
check_for_test_set_in_ignore_list()
{
	local TEST_SET=$1;
	local IGNORE_LIST=$2;

	local IFS=" ";

	for LIST_ELEMENT in ${IGNORE_LIST};
	do
		if test "${LIST_ELEMENT}" = "${TEST_SET}";
		then
			return ${EXIT_SUCCESS};
		fi
	done
	return ${EXIT_FAILURE};
}

# Checks if the input directory is in the ignore list.
#
# Arguments:
#   a string containing the path of the test input directory
#   a string containing space separated ignore list
#
# Returns:
#   an integer containing the exit status to indicate the input directory
#   was found in the ignore list.
#
check_for_directory_in_ignore_list()
{
	local INPUT_DIRECTORY=$1;
	local IGNORE_LIST=$2;

	local INPUT_BASENAME=`basename ${INPUT_DIRECTORY}`;

	local IFS=" ";

	for LIST_ELEMENT in ${IGNORE_LIST};
	do
		if test "${LIST_ELEMENT}" = "${INPUT_BASENAME}";
		then
			return ${EXIT_SUCCESS};
		fi
	done
	return ${EXIT_FAILURE};
}

# Searches for the binary variant of the executable in case the test executable
# refers to a libtool shell script.
#
# Arguments:
#   a string containing the path of the test executable
#
# Returns:
#   a string containing the path of the binary variant of the test executable
#
find_binary_executable()
{
	local TEST_EXECUTABLE=$1;

	TEST_EXECUTABLE=$( readlink_f "${TEST_EXECUTABLE}" );

	# Note that the behavior of `file -bi` is not helpful on Mac OS X.
	local EXECUTABLE_TYPE=`file -b ${TEST_EXECUTABLE}`;

	# Check if the test executable is a libtool shell script.
	# Linux: POSIX shell script, ASCII text executable, with very long lines
	# Mac OS X: POSIX shell script text executable
	echo "${EXECUTABLE_TYPE}" | grep "POSIX shell script" > /dev/null 2>&1;
	RESULT=$?;

	if test ${RESULT} -eq ${EXIT_SUCCESS};
	then
		local TEST_EXECUTABLE_BASENAME=`basename ${TEST_EXECUTABLE}`;
		local TEST_EXECUTABLE_DIRNAME=`dirname ${TEST_EXECUTABLE}`;

		TEST_EXECUTABLE="${TEST_EXECUTABLE_DIRNAME}/.libs/${TEST_EXECUTABLE_BASENAME}";

		if test -x ${TEST_EXECUTABLE};
		then
			# Note that the behavior of `file -bi` is not helpful on Mac OS X.
			EXECUTABLE_TYPE=`file -b ${TEST_EXECUTABLE}`;

			# Linux: ELF 64-bit LSB executable, x86-64, ...
			# Mac OS X: Mach-O 64-bit executable x86_64
			echo "${EXECUTABLE_TYPE}" | grep "executable" > /dev/null 2>&1;
			RESULT=$?;

			if test ${RESULT} -ne ${EXIT_SUCCESS};
			then
				echo "Invalid test executable: ${TEST_EXECUTABLE}";

				exit ${EXIT_FAILURE};
			fi
		fi
	fi
	echo ${TEST_EXECUTABLE};
}

# Searches for the path to the binary variant of the library.
#
# Arguments:
#   a string containing the path of the test executable
#
# Returns:
#   a string containing the path of the binary variant of the library.
#
find_binary_library_path()
{
	local TEST_EXECUTABLE=$1;
	local LIBRARY_NAME=`dirname ${TEST_EXECUTABLE}`;

	local NAME=`basename ${LIBRARY_NAME}`;

	if test ${NAME} = ".libs";
	then
		LIBRARY_NAME=`dirname ${LIBRARY_NAME}`;
		NAME=`basename ${LIBRARY_NAME}`;
	fi
	if test ${NAME} = "tests";
	then
		LIBRARY_NAME=`dirname ${LIBRARY_NAME}`;
		NAME=`basename ${LIBRARY_NAME}`;
	fi
	echo ${LIBRARY_NAME} | grep 'tools' > /dev/null 2>&1;

	if test $? -eq ${EXIT_SUCCESS};
	then
		LIBRARY_NAME=`basename ${LIBRARY_NAME} | sed 's/\(.*\)tools$/lib\1/'`;
	else
		LIBRARY_NAME=`basename ${LIBRARY_NAME} | sed 's/^py//' | sed 's/^\([^_]*\)_test_.*$/lib\1/'`;
	fi
	TEST_EXECUTABLE=`dirname ${TEST_EXECUTABLE}`;
	TEST_EXECUTABLE=`dirname ${TEST_EXECUTABLE}`;
	TEST_EXECUTABLE=`dirname ${TEST_EXECUTABLE}`;

	local LIBRARY_PATH="${TEST_EXECUTABLE}/${LIBRARY_NAME}/.libs";

	if ! test -d "${LIBRARY_PATH}";
	then
		LIBRARY_PATH="../${LIBRARY_NAME}/.libs";
	fi
	echo "${LIBRARY_PATH}";
}

# Searches for the path to the binary variant of the Python module
#
# Globals:
#   PYTHON_VERSION
#
# Arguments:
#   a string containing the path of the test executable
#
# Returns:
#   a string containing the path of the binary variant of the Python module
#
find_binary_python_module_path()
{
	local TEST_EXECUTABLE=$1;

	local PYTHON_MODULE_NAME=`basename ${TEST_EXECUTABLE} | sed 's/^py\(.*\)_test_.*$/py\1/'`;

	TEST_EXECUTABLE=`dirname ${TEST_EXECUTABLE}`;
	TEST_EXECUTABLE=`dirname ${TEST_EXECUTABLE}`;
	TEST_EXECUTABLE=`dirname ${TEST_EXECUTABLE}`;

	PYTHON_VERSION=`echo ${PYTHON_VERSION} | cut -c1`;

	local PYTHON_MODULE_PATH="${TEST_EXECUTABLE}/${PYTHON_MODULE_NAME}-python${PYTHON_VERSION}/.libs";

	if ! test -d "${PYTHON_MODULE_PATH}";
	then
		PYTHON_MODULE_PATH="../${PYTHON_MODULE_NAME}-python${PYTHON_VERSION}/.libs";
	fi
	if ! test -d "${PYTHON_MODULE_PATH}";
	then
		PYTHON_MODULE_PATH="${TEST_EXECUTABLE}/${PYTHON_MODULE_NAME}/.libs";
	fi
	if ! test -d "${PYTHON_MODULE_PATH}";
	then
		PYTHON_MODULE_PATH="../${PYTHON_MODULE_NAME}/.libs";
	fi
	echo "${PYTHON_MODULE_PATH}";
}

# Determines the test data option file.
#
# Arguments:
#   a string containing the path of the test set directory
#   a string containing the path of the test input file
#   a string containing the name of the test data option set
#
# Returns:
#   a string containing the test input files
#
get_test_data_option_file()
{
	local TEST_SET_DIRECTORY=$1;
	local INPUT_FILE=$2;
	local OPTION_SET=$3;

	local INPUT_NAME=`basename "${INPUT_FILE}"`;
	local TEST_DATA_OPTION_FILE="${TEST_SET_DIRECTORY}/${INPUT_NAME}.${OPTION_SET}";

	echo "${TEST_DATA_OPTION_FILE}";
}

# Determines the test profile directory.
# The directory is created if it does not exist.
#
# Arguments:
#   a string containing the path of the test input directory
#   a string containing the name of the test profile
#
# Returns:
#   a string containing the path of the test profile directory
#
get_test_profile_directory()
{
	local TEST_INPUT_DIRECTORY=$1;
	local TEST_PROFILE=$2;

	local TEST_PROFILE_DIRECTORY="${TEST_INPUT_DIRECTORY}/.${TEST_PROFILE}";

	if ! test -d "${TEST_PROFILE_DIRECTORY}";
	then
		mkdir "${TEST_PROFILE_DIRECTORY}";
	fi
	echo "${TEST_PROFILE_DIRECTORY}";
}

# Determines the test set directory.
# The directory is created if it does not exist.
#
# Arguments:
#   a string containing the path of the test profile directory
#   a string containing the path of the test set input directory
#
# Returns:
#   a string containing the path of the test set directory
#
get_test_set_directory()
{
	local TEST_PROFILE_DIRECTORY=$1;
	local TEST_SET_INPUT_DIRECTORY=$2;

	local TEST_SET=`basename ${TEST_SET_INPUT_DIRECTORY}`;
	local TEST_SET_DIRECTORY="${TEST_PROFILE_DIRECTORY}/${TEST_SET}";

	if ! test -d "${TEST_SET_DIRECTORY}";
	then
		mkdir "${TEST_SET_DIRECTORY}";
	fi
	echo "${TEST_SET_DIRECTORY}";
}

# Provides a cross-platform variant of "readlink -f"
#
# Arguments:
#   a string containing a path
#
# Returns:
#   a string containing the path with all symbolic links resolved
#
readlink_f() {
	local TARGET="$1"

	if test -f "${TARGET}";
	then
		while test -L "${TARGET}";
		do
			TARGET=`readlink "${TARGET}"`;
		done
	fi
	local BASENAME=`basename "${TARGET}"`;
	local DIRNAME=`dirname "${TARGET}"`;

	DIRNAME=`(cd "${DIRNAME}" && pwd -P)`;

	echo "${DIRNAME}/${BASENAME}";
}

# Reads the test profile ignore file if it exists.
#
# Arguments:
#   a string containing the path of the test profile directory
#
# Returns:
#   a string containing a space separated ignore list
#
read_ignore_list()
{
	local TEST_PROFILE_DIRECTORY=$1;
	local IGNORE_FILE="${TEST_PROFILE_DIRECTORY}/ignore";
	local IGNORE_LIST="";

	if test -f "${IGNORE_FILE}";
	then
		IGNORE_LIST=`cat ${IGNORE_FILE} | sed '/^#/d' | tr '\n' ' '`;
	fi
	echo ${IGNORE_LIST};
}

# Reads a test data option file.
#
# Arguments:
#   a string containing the path of the test set directory
#   a string containing the path of the test input file
#   a string containing the name of the test data option set
#
# Returns:
#   a string containing the test data specific options
#
read_test_data_option_file()
{
	local TEST_SET_DIRECTORY=$1;
	local INPUT_FILE=$2;
	local OPTION_SET=$3;

	local TEST_DATA_OPTION_FILE="${INPUT_FILE}.${OPTION_SET}";

	if ! test -f "${TEST_DATA_OPTION_FILE}";
	then
		TEST_DATA_OPTION_FILE=$(get_test_data_option_file "${TEST_SET_DIRECTORY}" "${INPUT_FILE}" "${OPTION_SET}");
	fi

	local OPTIONS_STRING=`head -n 1 "${TEST_DATA_OPTION_FILE}" | sed 's/[\r\n]*$//'`;

	if test "${OPTIONS_STRING}" = "# libyal test data options";
	then
		OPTIONS_STRING=`tail -n +2 "${TEST_DATA_OPTION_FILE}" | sed 's/^offset=/-o/;s/^password=/-p/;s/^recovery_password=/-r/;s/^startup_key=/-s/;s/virtual_address=/-v/' | tr '\n' ' '`;
	fi
	echo "${OPTIONS_STRING}";
}

# Runs the test with optional arguments.
#
# Globals:
#   CHECK_WITH_ASAN
#   CHECK_WITH_GDB
#   CHECK_WITH_STDERR
#   CHECK_WITH_VALGRIND
#   PYTHON_VERSION
#
# Arguments:
#   a string containing the test description
#   a string containing the path of the test executable
#   an array containing the arguments for the test executable
#
# Returns:
#   an integer containg the exit status of the test executable
#
run_test_with_arguments()
{
	local TEST_DESCRIPTION=$1;
	local TEST_EXECUTABLE=$2;
	shift 2;
	local ARGUMENTS=("$@");

	if ! test -f "${TEST_EXECUTABLE}";
	then
		echo "Missing test executable: ${TEST_EXECUTABLE}";
		echo "";

		return ${EXIT_FAILURE};
	fi
	local PLATFORM=`uname -s | sed 's/-.*$//'`;

	# Note that the behavior of `file -bi` is not helpful on Mac OS X.
	local EXECUTABLE_TYPE=`file -b ${TEST_EXECUTABLE}`;

	# Check if the test executable is a Python script.
	# Linux: Python script, ASCII text executable
	# Mac OS X: a python script text executable
	echo "${EXECUTABLE_TYPE}" | grep -i "python script" > /dev/null 2>&1;
	local IS_PYTHON_SCRIPT=$?;

	if test ${IS_PYTHON_SCRIPT} -eq 0 && test -z ${PYTHON};
	then
		local PYTHON=`which python${PYTHON_VERSION} 2> /dev/null`;

		if ! test -x ${PYTHON};
		then
			echo "Missing executable: ${PYTHON}";

			exit ${EXIT_FAILURE};
		fi
	fi
	local RESULT=0;

	if test -n "${CHECK_WITH_ASAN}";
	then
		local TEST_EXECUTABLE=$( find_binary_executable ${TEST_EXECUTABLE} );
		local LIBRARY_PATH=$( find_binary_library_path ${TEST_EXECUTABLE} );
		local PYTHON_MODULE_PATH=$( find_binary_python_module_path ${TEST_EXECUTABLE} );

		local LSAN_SUPPRESSIONS="lsan.suppressions";

		if ! test -f ${LSAN_SUPPRESSIONS};
		then
			LSAN_SUPPRESSIONS="../lsan.suppressions";
		fi
		if test "${PLATFORM}" = "Darwin";
		then
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				LSAN_OPTIONS=suppressions="${LSAN_SUPPRESSIONS}" DYLD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			else
				LSAN_OPTIONS=suppressions="${LSAN_SUPPRESSIONS}" DYLD_LIBRARY_PATH="${LIBRARY_PATH}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			fi
		else
			local CONFIG_LOG="../config.log";

			if ! test -f ${CONFIG_LOG};
			then
				CONFIG_LOG="../../config.log";
			fi
			local CC=`cat ${CONFIG_LOG} | grep -e "^CC=" | sed "s/CC='\\(.*\\)'/\1/"`;
			local LIBASAN="";

			if test -z ${CC} || test ${CC} != "clang";
			then
				local LDCONFIG=`which ldconfig 2> /dev/null`;

				if test -z ${LDCONFIG} || ! test -x ${LDCONFIG};
				then
					LDCONFIG="/sbin/ldconfig";
				fi
				if test -z ${LDCONFIG} || ! test -x ${LDCONFIG};
				then
					echo "Missing binary: ldconfig";
					echo "";

					exit ${EXIT_FAILURE};
				fi
				LIBASAN=`${LDCONFIG} -p | grep libasan | sed 's/^.* => //' | sort | tail -n 1`;

				if ! test -f ${LIBASAN};
				then
					echo "Missing library: ${BINARY}";
					echo "";

					exit ${EXIT_FAILURE};
				fi
			fi
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				LSAN_OPTIONS=suppressions="${LSAN_SUPPRESSIONS}" LD_PRELOAD="${LIBASAN}" LD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			else
				LSAN_OPTIONS=suppressions="${LSAN_SUPPRESSIONS}" LD_PRELOAD="${LIBASAN}" LD_LIBRARY_PATH="${LIBRARY_PATH}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			fi
		fi

	elif test -n "${CHECK_WITH_GDB}";
	then
		local TEST_EXECUTABLE=$( find_binary_executable ${TEST_EXECUTABLE} );
		local LIBRARY_PATH=$( find_binary_library_path ${TEST_EXECUTABLE} );
		local PYTHON_MODULE_PATH=$( find_binary_python_module_path ${TEST_EXECUTABLE} );

		if test "${PLATFORM}" = "Darwin";
		then
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				DYLD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" gdb -ex "set non-stop on" -ex "run" -ex "quit" --args "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			else
				DYLD_LIBRARY_PATH="${LIBRARY_PATH}" gdb -ex "set non-stop on" -ex "run" -ex "quit" --args "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			fi

		elif test "${PLATFORM}" = "CYGWIN_NT";
		then
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				PATH="${LIBRARY_PATH}:${PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" gdb -ex "set non-stop on" -ex "run" -ex "quit" --args "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			else
				PATH="${LIBRARY_PATH}:${PATH}" gdb -ex "set non-stop on" -ex "run" -ex "quit" --args "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			fi

		else
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				LD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" gdb -ex "set non-stop on" -ex "run" -ex "quit" --args "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			else
				LD_LIBRARY_PATH="${LIBRARY_PATH}" gdb -ex "set non-stop on" -ex "run" -ex "quit" --args "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			fi
		fi

	elif test -n "${CHECK_WITH_VALGRIND}";
	then
		local TEST_EXECUTABLE=$( find_binary_executable ${TEST_EXECUTABLE} );
		local LIBRARY_PATH=$( find_binary_library_path ${TEST_EXECUTABLE} );
		local PYTHON_MODULE_PATH=$( find_binary_python_module_path ${TEST_EXECUTABLE} );

		local VALGRIND_LOG="valgrind.log-$$";
		local VALGRIND_OPTIONS=("--tool=memcheck" "--leak-check=full" "--show-leak-kinds=definite,indirect,possible" "--track-origins=yes" "--log-file=${VALGRIND_LOG}");

		if test "${PLATFORM}" = "Darwin";
		then
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				DYLD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" valgrind ${VALGRIND_OPTIONS[@]} "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			else
				DYLD_LIBRARY_PATH="${LIBRARY_PATH}" valgrind ${VALGRIND_OPTIONS[@]} "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			fi

		elif test "${PLATFORM}" = "CYGWIN_NT";
		then
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				PATH="${LIBRARY_PATH}:${PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" valgrind ${VALGRIND_OPTIONS[@]} "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			else
				PATH="${LIBRARY_PATH}:${PATH}" valgrind ${VALGRIND_OPTIONS[@]} "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			fi

		else
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				LD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" valgrind ${VALGRIND_OPTIONS[@]} "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			else
				LD_LIBRARY_PATH="${LIBRARY_PATH}" valgrind ${VALGRIND_OPTIONS[@]} "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			fi
		fi
		if test ${RESULT} -eq ${EXIT_SUCCESS};
		then
			grep "All heap blocks were freed -- no leaks are possible" ${VALGRIND_LOG} > /dev/null 2>&1;

			if test $? -ne ${EXIT_SUCCESS};
			then
				# Ignore "still reachable"
				# Also see: http://valgrind.org/docs/manual/faq.html#faq.deflost

				grep "definitely lost: 0 bytes in 0 blocks" ${VALGRIND_LOG} > /dev/null 2>&1;
				RESULT_DIRECTLY_LOST=$?;

				grep "indirectly lost: 0 bytes in 0 blocks" ${VALGRIND_LOG} > /dev/null 2>&1;
				RESULT_INDIRECTLY_LOST=$?;

				grep "possibly lost: 0 bytes in 0 blocks" ${VALGRIND_LOG} > /dev/null 2>&1;
				RESULT_POSSIBLY_LOST=$?;

				grep "suppressed: 0 bytes in 0 blocks" ${VALGRIND_LOG} > /dev/null 2>&1;
				RESULT_SUPPRESSED=$?;

				if test ${RESULT_DIRECTLY_LOST} -ne ${EXIT_SUCCESS} || test ${RESULT_INDIRECTLY_LOST} -ne ${EXIT_SUCCESS} || test ${RESULT_POSSIBLY_LOST} -ne ${EXIT_SUCCESS} || test ${RESULT_SUPPRESSED} -ne ${EXIT_SUCCESS};
				then
					echo "Memory leakage detected.";
					cat ${VALGRIND_LOG};

					RESULT=${EXIT_FAILURE};
				fi
			fi
			# Detect valgrind warnings.
			local NUMBER_OF_LINES=`wc -l ${VALGRIND_LOG} | awk '{ print $1 }'`;

			if test ${NUMBER_OF_LINES} -ne 15 && test ${NUMBER_OF_LINES} -ne 22;
			then
				echo "Unsupported number of lines: ${NUMBER_OF_LINES}";
				cat ${VALGRIND_LOG};

				RESULT=${EXIT_FAILURE};
			fi
		fi
		rm -f ${VALGRIND_LOG};

	elif test ${IS_PYTHON_SCRIPT} -eq 0;
	then
		if ! test -f "${TEST_EXECUTABLE}";
		then
			echo "Invalid test Python script: ${TEST_EXECUTABLE}";
			echo "";

			return ${EXIT_FAILURE};
		fi
		local TEST_EXECUTABLE=$( find_binary_executable ${TEST_EXECUTABLE} );
		local LIBRARY_PATH=$( find_binary_library_path ${TEST_EXECUTABLE} );
		local PYTHON_MODULE_PATH=$( find_binary_python_module_path ${TEST_EXECUTABLE} );

		if test "${PLATFORM}" = "Darwin";
		then
			if test -n "${CHECK_WITH_STDERR}";
			then
				DYLD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			else
				DYLD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} 2> /dev/null;
				RESULT=$?;
			fi

		elif test "${PLATFORM}" = "CYGWIN_NT";
		then
			if test -n "${CHECK_WITH_STDERR}";
			then
				PATH="${LIBRARY_PATH}:${PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			else
				PATH="${LIBRARY_PATH}:${PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} 2> /dev/null;
				RESULT=$?;
			fi

		else
			if test -n "${CHECK_WITH_STDERR}";
			then
				LD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]};
				RESULT=$?;
			else
				LD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} 2> /dev/null;
				RESULT=$?;
			fi
		fi
	else
		if ! test -x "${TEST_EXECUTABLE}";
		then
			echo "Invalid test executable: ${TEST_EXECUTABLE}";
			echo "";

			return ${EXIT_FAILURE};
		fi

		if test -n "${CHECK_WITH_STDERR}";
		then
			${TEST_EXECUTABLE} ${ARGUMENTS[@]};
			RESULT=$?;
		else
			${TEST_EXECUTABLE} ${ARGUMENTS[@]} 2> /dev/null;
			RESULT=$?;
		fi
	fi
	if test -n "${TEST_DESCRIPTION}";
	then
		echo -n "${TEST_DESCRIPTION}";

		if test ${RESULT} -ne ${EXIT_SUCCESS};
		then
			echo " (FAIL)";
		else
			echo " (PASS)";
		fi
	fi
	return ${RESULT};
}

# Runs the test with an input file and optional arguments.
#
# Globals:
#   CHECK_WITH_ASAN
#   CHECK_WITH_GDB
#   CHECK_WITH_STDERR
#   CHECK_WITH_VALGRIND
#   PYTHON_VERSION
#
# Arguments:
#   a string containing the path of the test executable
#   a string containing the path of the test input file
#   an array containing the arguments for the test executable
#
# Returns:
#   an integer containg the exit status of the test executable
#
run_test_with_input_and_arguments()
{
	local TEST_EXECUTABLE=$1;
	local INPUT_FILE=$2;
	shift 2;
	local ARGUMENTS=("$@");

	if ! test -f "${TEST_EXECUTABLE}";
	then
		echo "Missing test executable: ${TEST_EXECUTABLE}";
		echo "";

		return ${EXIT_FAILURE};
	fi
	local PLATFORM=`uname -s | sed 's/-.*$//'`;

	# Note that the behavior of `file -bi` is not helpful on Mac OS X.
	local EXECUTABLE_TYPE=`file -b ${TEST_EXECUTABLE}`;

	# Check if the test executable is a Python script.
	# Linux: Python script, ASCII text executable
	# Mac OS X: a python script text executable
	echo "${EXECUTABLE_TYPE}" | grep -i "python script" > /dev/null 2>&1;
	local IS_PYTHON_SCRIPT=$?;

	if test ${IS_PYTHON_SCRIPT} -eq 0 && test -z ${PYTHON};
	then
		local PYTHON=`which python${PYTHON_VERSION} 2> /dev/null`;

		if ! test -x ${PYTHON};
		then
			echo "Missing executable: ${PYTHON}";

			exit ${EXIT_FAILURE};
		fi
	fi
	local RESULT=0;

	if test -n "${CHECK_WITH_ASAN}";
	then
		local TEST_EXECUTABLE=$( find_binary_executable ${TEST_EXECUTABLE} );
		local LIBRARY_PATH=$( find_binary_library_path ${TEST_EXECUTABLE} );
		local PYTHON_MODULE_PATH=$( find_binary_python_module_path ${TEST_EXECUTABLE} );

		local LSAN_SUPPRESSIONS="lsan.suppressions";

		if ! test -f ${LSAN_SUPPRESSIONS};
		then
			LSAN_SUPPRESSIONS="../lsan.suppressions";
		fi
		if test "${PLATFORM}" = "Darwin";
		then
			# TODO DYLD_INSERT_LIBRARIES=/Library/Developer/CommandLineTools/usr/lib/clang/8.1.0/lib/darwin/libclang_rt.asan_osx_dynamic.dylib
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				LSAN_OPTIONS=suppressions="${LSAN_SUPPRESSIONS}" DYLD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			else
				LSAN_OPTIONS=suppressions="${LSAN_SUPPRESSIONS}" DYLD_LIBRARY_PATH="${LIBRARY_PATH}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			fi
		else
			local CONFIG_LOG="../config.log";

			if ! test -f ${CONFIG_LOG};
			then
				CONFIG_LOG="../../config.log";
			fi
			local CC=`cat ${CONFIG_LOG} | grep -e "^CC=" | sed "s/CC='\\(.*\\)'/\1/"`;
			local LIBASAN="";

			if test -z ${CC} || test ${CC} != "clang";
			then
				local LDCONFIG=`which ldconfig 2> /dev/null`;

				if test -z ${LDCONFIG} || ! test -x ${LDCONFIG};
				then
					LDCONFIG="/sbin/ldconfig";
				fi
				if test -z ${LDCONFIG} || ! test -x ${LDCONFIG};
				then
					echo "Missing binary: ldconfig";
					echo "";

					exit ${EXIT_FAILURE};
				fi
				LIBASAN=`${LDCONFIG} -p | grep libasan | sed 's/^.* => //' | sort | tail -n 1`;

				if ! test -f ${LIBASAN};
				then
					echo "Missing library: ${BINARY}";
					echo "";

					exit ${EXIT_FAILURE};
				fi
			fi
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				LSAN_OPTIONS=suppressions="${LSAN_SUPPRESSIONS}" LD_PRELOAD="${LIBASAN}" LD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			else
				LSAN_OPTIONS=suppressions="${LSAN_SUPPRESSIONS}" LD_PRELOAD="${LIBASAN}" LD_LIBRARY_PATH="${LIBRARY_PATH}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			fi
		fi

	elif test -n "${CHECK_WITH_GDB}";
	then
		local TEST_EXECUTABLE=$( find_binary_executable ${TEST_EXECUTABLE} );
		local LIBRARY_PATH=$( find_binary_library_path ${TEST_EXECUTABLE} );
		local PYTHON_MODULE_PATH=$( find_binary_python_module_path ${TEST_EXECUTABLE} );

		if test "${PLATFORM}" = "Darwin";
		then
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				DYLD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" gdb -ex "set non-stop on" -ex "run" -ex "quit" --args "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			else
				DYLD_LIBRARY_PATH="${LIBRARY_PATH}" gdb -ex "set non-stop on" -ex "run" -ex "quit" --args "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			fi

		elif test "${PLATFORM}" = "CYGWIN_NT";
		then
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				PATH="${LIBRARY_PATH}:${PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" gdb -ex "set non-stop on" -ex "run" -ex "quit" --args "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			else
				PATH="${LIBRARY_PATH}:${PATH}" gdb -ex "set non-stop on" -ex "run" -ex "quit" --args "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			fi

		else
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				LD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" gdb -ex "set non-stop on" -ex "run" -ex "quit" --args "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			else
				LD_LIBRARY_PATH="${LIBRARY_PATH}" gdb -ex "set non-stop on" -ex "run" -ex "quit" --args "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			fi
		fi

	elif test -n "${CHECK_WITH_VALGRIND}";
	then
		local TEST_EXECUTABLE=$( find_binary_executable ${TEST_EXECUTABLE} );
		local LIBRARY_PATH=$( find_binary_library_path ${TEST_EXECUTABLE} );
		local PYTHON_MODULE_PATH=$( find_binary_python_module_path ${TEST_EXECUTABLE} );

		local VALGRIND_LOG="valgrind.log-$$";
		local VALGRIND_OPTIONS=("--tool=memcheck" "--leak-check=full" "--show-leak-kinds=definite,indirect,possible" "--track-origins=yes" "--log-file=${VALGRIND_LOG}");

		if test "${PLATFORM}" = "Darwin";
		then
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				DYLD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" valgrind ${VALGRIND_OPTIONS[@]} "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			else
				DYLD_LIBRARY_PATH="${LIBRARY_PATH}" valgrind ${VALGRIND_OPTIONS[@]} "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			fi

		elif test "${PLATFORM}" = "CYGWIN_NT";
		then
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				PATH="${LIBRARY_PATH}:${PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" valgrind ${VALGRIND_OPTIONS[@]} "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			else
				PATH="${LIBRARY_PATH}:${PATH}" valgrind ${VALGRIND_OPTIONS[@]} "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			fi

		else
			if test ${IS_PYTHON_SCRIPT} -eq 0;
			then
				LD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" valgrind ${VALGRIND_OPTIONS[@]} "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			else
				LD_LIBRARY_PATH="${LIBRARY_PATH}" valgrind ${VALGRIND_OPTIONS[@]} "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			fi
		fi
		if test ${RESULT} -eq ${EXIT_SUCCESS};
		then
			grep "All heap blocks were freed -- no leaks are possible" ${VALGRIND_LOG} > /dev/null 2>&1;

			if test $? -ne ${EXIT_SUCCESS};
			then
				# Ignore "still reachable"
				# Also see: http://valgrind.org/docs/manual/faq.html#faq.deflost

				grep "definitely lost: 0 bytes in 0 blocks" ${VALGRIND_LOG} > /dev/null 2>&1;
				RESULT_DIRECTLY_LOST=$?;

				grep "indirectly lost: 0 bytes in 0 blocks" ${VALGRIND_LOG} > /dev/null 2>&1;
				RESULT_INDIRECTLY_LOST=$?;

				grep "possibly lost: 0 bytes in 0 blocks" ${VALGRIND_LOG} > /dev/null 2>&1;
				RESULT_POSSIBLY_LOST=$?;

				grep "suppressed: 0 bytes in 0 blocks" ${VALGRIND_LOG} > /dev/null 2>&1;
				RESULT_SUPPRESSED=$?;

				if test ${RESULT_DIRECTLY_LOST} -ne ${EXIT_SUCCESS} || test ${RESULT_INDIRECTLY_LOST} -ne ${EXIT_SUCCESS} || test ${RESULT_POSSIBLY_LOST} -ne ${EXIT_SUCCESS} || test ${RESULT_SUPPRESSED} -ne ${EXIT_SUCCESS};
				then
					echo "Memory leakage detected.";
					cat ${VALGRIND_LOG};

					RESULT=${EXIT_FAILURE};
				fi
			fi
			# Detect valgrind warnings.
			local NUMBER_OF_LINES=`wc -l ${VALGRIND_LOG} | awk '{ print $1 }'`;

			if test ${NUMBER_OF_LINES} -ne 15 && test ${NUMBER_OF_LINES} -ne 22;
			then
				echo "Unsupported number of lines: ${NUMBER_OF_LINES}";
				cat ${VALGRIND_LOG};

				RESULT=${EXIT_FAILURE};
			fi
		fi
		rm -f ${VALGRIND_LOG};

	elif test ${IS_PYTHON_SCRIPT} -eq 0;
	then
		if ! test -f "${TEST_EXECUTABLE}";
		then
			echo "Invalid test Python script: ${TEST_EXECUTABLE}";
			echo "";

			return ${EXIT_FAILURE};
		fi
		local TEST_EXECUTABLE=$( find_binary_executable ${TEST_EXECUTABLE} );
		local LIBRARY_PATH=$( find_binary_library_path ${TEST_EXECUTABLE} );
		local PYTHON_MODULE_PATH=$( find_binary_python_module_path ${TEST_EXECUTABLE} );

		if test "${PLATFORM}" = "Darwin";
		then
			if test -n "${CHECK_WITH_STDERR}";
			then
				DYLD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			else
				DYLD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}" 2> /dev/null;
				RESULT=$?;
			fi

		elif test "${PLATFORM}" = "CYGWIN_NT";
		then
			if test -n "${CHECK_WITH_STDERR}";
			then
				PATH="${LIBRARY_PATH}:${PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			else
				PATH="${LIBRARY_PATH}:${PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}" 2> /dev/null;
				RESULT=$?;
			fi

		else
			if test -n "${CHECK_WITH_STDERR}";
			then
				LD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}";
				RESULT=$?;
			else
				LD_LIBRARY_PATH="${LIBRARY_PATH}" PYTHONPATH="${PYTHON_MODULE_PATH}" "${PYTHON}" "${TEST_EXECUTABLE}" ${ARGUMENTS[@]} "${INPUT_FILE}" 2> /dev/null;
				RESULT=$?;
			fi
		fi
	else
		if ! test -x "${TEST_EXECUTABLE}";
		then
			echo "Invalid test executable: ${TEST_EXECUTABLE}";
			echo "";

			return ${EXIT_FAILURE};
		fi

		if test -n "${CHECK_WITH_STDERR}";
		then
			${TEST_EXECUTABLE} ${ARGUMENTS[@]} "${INPUT_FILE}";
			RESULT=$?;
		else
			${TEST_EXECUTABLE} ${ARGUMENTS[@]} "${INPUT_FILE}" 2> /dev/null;
			RESULT=$?;
		fi
	fi
	return ${RESULT};
}

# Runs the test on the input file.
#
# Note that this function is not intended to be directly invoked
# from outside the test runner script.
#
# Arguments:
#   a string containing the path of the test set directory
#   a string containing the description of the test
#   a string containing the test mode
#   a string containing the name of the test data option set
#   a string containing the path of the test executable
#   a string containing the path of the test input file
#   an array containing the arguments for the test executable
#
# Returns:
#   an integer containg the exit status of the test executable
#
run_test_on_input_file()
{
	local TEST_SET_DIRECTORY=$1;
	local TEST_DESCRIPTION=$2;
	local TEST_MODE=$3;
	local OPTION_SET=$4;
	local TEST_EXECUTABLE=$5;
	local INPUT_FILE=$6;
	shift 6;
	local ARGUMENTS=("$@");

	local INPUT_NAME=`basename "${INPUT_FILE}"`;
	local TEST_OUTPUT="${INPUT_NAME}";

	if test -n "${OPTION_SET}";
	then
		TEST_OUTPUT="${INPUT_NAME}-${OPTION_SET}";
	fi

	local TMPDIR="tmp$$";
	local RESULT=0;

	rm -rf ${TMPDIR};
	mkdir ${TMPDIR};

	if test "${TEST_MODE}" = "with_callback";
	then
		test_callback "${TMPDIR}" "${TEST_SET_DIRECTORY}" "${TEST_OUTPUT}" "${TEST_EXECUTABLE}" "${TEST_INPUT}" ${ARGUMENTS[@]};
		RESULT=$?;

	elif test "${TEST_MODE}" = "with_stdout_reference";
	then
		TEST_EXECUTABLE=$( readlink_f "${TEST_EXECUTABLE}" );

		if ! test -x ${TEST_EXECUTABLE};
		then
			echo "Invalid test executable: ${TEST_EXECUTABLE}";
			echo "";

			return ${EXIT_FAILURE};
		fi
		local INPUT_FILE_FULL_PATH=$( readlink_f "${INPUT_FILE}" );
		local TEST_LOG="${TEST_OUTPUT}.log";

		(cd ${TMPDIR} && run_test_with_input_and_arguments "${TEST_EXECUTABLE}" "${INPUT_FILE_FULL_PATH}" ${ARGUMENTS[@]} > "${TEST_LOG}");
		RESULT=$?;

		# Compare output if test ran successfully.
		if test ${RESULT} -eq ${EXIT_SUCCESS};
		then
			local TEST_RESULTS="${TMPDIR}/${TEST_LOG}";
			local STORED_TEST_RESULTS="${TEST_SET_DIRECTORY}/${TEST_LOG}.gz";

			# Strip header with version.
			sed -i'~' '1,2d' "${TEST_RESULTS}";

			if test -f "${STORED_TEST_RESULTS}";
			then
				# Using zcat here since zdiff has issues on Mac OS X.
				# Note that zcat on Mac OS X requires the input from stdin.
				zcat < "${STORED_TEST_RESULTS}" | diff "${TEST_RESULTS}" -;
				RESULT=$?;
			else
				gzip "${TEST_RESULTS}";

				mv "${TEST_RESULTS}.gz" ${TEST_SET_DIRECTORY};
			fi
		fi

	else
		run_test_with_input_and_arguments "${TEST_EXECUTABLE}" "${INPUT_FILE}" ${ARGUMENTS[@]};
		RESULT=$?;
	fi

	rm -rf ${TMPDIR};

	if test -n "${TEST_DESCRIPTION}";
	then
		ARGUMENTS=`echo "${ARGUMENTS[*]}" | tr '\n' ' ' | sed 's/[ ]\$//'`;

		if test -z "${ARGUMENTS}";
		then
			echo -n "${TEST_DESCRIPTION} with input: ${INPUT_FILE}";
		else
			echo -n "${TEST_DESCRIPTION} with options: '${ARGUMENTS}' and input: ${INPUT_FILE}";
		fi

		if test ${RESULT} -ne ${EXIT_SUCCESS};
		then
			echo " (FAIL)";
		else
			echo " (PASS)";
		fi
	fi
	return ${RESULT};
}


```

`tests/test_tools.ps1`:

```ps1
# Tests tools functions and types.
#
# Version: 20230410

$ExitSuccess = 0
$ExitFailure = 1
$ExitIgnore = 77

$ToolsTests = "info_handle output signal"
$ToolsTestsWithInput = ""

$InputGlob = "*"

Function GetTestProfileDirectory
{
	param( [string]$TestInputDirectory, [string]$TestProfile )

	$TestProfileDirectory = "${TestInputDirectory}\.${TestProfile}"

	If (-Not (Test-Path -Path ${TestProfileDirectory} -PathType "Container"))
	{
		New-Item -ItemType "directory" -Path ${TestProfileDirectory}
	}
	Return ${TestProfileDirectory}
}

Function GetTestSetDirectory
{
	param( [string]$TestProfileDirectory, [string]$TestSetInputDirectory )

	$TestSetDirectory = "${TestProfileDirectory}\${TestSetInputDirectory.Basename}"

	If (-Not (Test-Path -Path ${TestSetDirectory} -PathType "Container"))
	{
		New-Item -ItemType "directory" -Path ${TestSetDirectory}
	}
	Return ${TestSetDirectory}
}

Function GetTestExecutablesDirectory
{
	$TestExecutablesDirectory = ""

	ForEach (${VSDirectory} in ("msvscpp", "vs2008", "vs2010", "vs2012", "vs2013", "vs2015", "vs2017", "vs2019", "vs2022"))
	{
		ForEach (${VSConfiguration} in ("Release", "VSDebug"))
		{
			ForEach (${VSPlatform} in ("Win32", "x64"))
			{
				$TestExecutablesDirectory = "..\${VSDirectory}\${VSConfiguration}\${VSPlatform}"

				If (Test-Path ${TestExecutablesDirectory})
				{
					Return ${TestExecutablesDirectory}
				}
			}
			$TestExecutablesDirectory = "..\${VSDirectory}\${VSConfiguration}"

			If (Test-Path ${TestExecutablesDirectory})
			{
				Return ${TestExecutablesDirectory}
			}
		}
	}
	Return ${TestExecutablesDirectory}
}

Function ReadIgnoreList
{
	param( [string]$TestProfileDirectory )

	$IgnoreFile = "${TestProfileDirectory}\ignore"
	$IgnoreList = ""

	If (Test-Path -Path ${IgnoreFile} -PathType "Leaf")
	{
		$IgnoreList = Get-Content -Path ${IgnoreFile} | Where {$_ -notmatch '^#.*'}
	}
	Return $IgnoreList
}

Function RunTest
{
	param( [string]$TestType )

	$TestDescription = "Testing: ${TestName}"
	$TestExecutable = "${TestExecutablesDirectory}\mdmp_test_tools_${TestName}.exe"

	$Output = Invoke-Expression ${TestExecutable}
	$Result = ${LastExitCode}

	If (${Result} -ne ${ExitSuccess})
	{
		Write-Host ${Output} -foreground Red
	}
	Write-Host "${TestDescription} " -nonewline

	If (${Result} -ne ${ExitSuccess})
	{
		Write-Host " (FAIL)"
	}
	Else
	{
		Write-Host " (PASS)"
	}
	Return ${Result}
}

Function RunTestWithInput
{
	param( [string]$TestType )

	$TestDescription = "Testing: ${TestName}"
	$TestExecutable = "${TestExecutablesDirectory}\mdmp_test_tools_${TestName}.exe"

	$TestProfileDirectory = GetTestProfileDirectory "input" "mdmptools"

	$IgnoreList = ReadIgnoreList ${TestProfileDirectory}

	$Result = ${ExitSuccess}

	ForEach ($TestSetInputDirectory in Get-ChildItem -Path "input" -Exclude ".*")
	{
		If (-Not (Test-Path -Path ${TestSetInputDirectory} -PathType "Container"))
		{
			Continue
		}
		If (${TestSetInputDirectory} -Contains ${IgnoreList})
		{
			Continue
		}
		$TestSetDirectory = GetTestSetDirectory ${TestProfileDirectory} ${TestSetInputDirectory}

		If (Test-Path -Path "${TestSetDirectory}\files" -PathType "Leaf")
		{
			$InputFiles = Get-Content -Path "${TestSetDirectory}\files" | Where {$_ -ne ""}
		}
		Else
		{
			$InputFiles = Get-ChildItem -Path ${TestSetInputDirectory} -Include ${InputGlob}
		}
		ForEach ($InputFile in ${InputFiles})
		{
			# TODO: add test option support
			$Output = Invoke-Expression ${TestExecutable}
			$Result = ${LastExitCode}

			If (${Result} -ne ${ExitSuccess})
			{
				Break
			}
		}
		If (${Result} -ne ${ExitSuccess})
		{
			Break
		}
	}
	If (${Result} -ne ${ExitSuccess})
	{
		Write-Host ${Output} -foreground Red
	}
	Write-Host "${TestDescription} " -nonewline

	If (${Result} -ne ${ExitSuccess})
	{
		Write-Host " (FAIL)"
	}
	Else
	{
		Write-Host " (PASS)"
	}
	Return ${Result}
}

$TestExecutablesDirectory = GetTestExecutablesDirectory

If (-Not (Test-Path ${TestExecutablesDirectory}))
{
	Write-Host "Missing test executables directory." -foreground Red

	Exit ${ExitFailure}
}

$Result = ${ExitIgnore}

Foreach (${TestName} in ${ToolsTests} -split " ")
{
	# Split will return an array of a single empty string when ToolsTests is empty.
	If (-Not (${TestName}))
	{
		Continue
	}
	$Result = RunTest ${TestName}

	If (${Result} -ne ${ExitSuccess})
	{
		Break
	}
}

Foreach (${TestName} in ${ToolsTestsWithInput} -split " ")
{
	# Split will return an array of a single empty string when ToolsTestsWithInput is empty.
	If (-Not (${TestName}))
	{
		Continue
	}
	If (Test-Path -Path "input" -PathType "Container")
	{
		$Result = RunTestWithInput ${TestName}
	}
	Else
	{
		$Result = RunTest ${TestName}
	}
	If (${Result} -ne ${ExitSuccess})
	{
		Break
	}
}

Exit ${Result}


```

`tests/test_tools.sh`:

```sh
#!/usr/bin/env bash
# Tests tools functions and types.
#
# Version: 20231007

EXIT_SUCCESS=0;
EXIT_FAILURE=1;
EXIT_IGNORE=77;

TOOLS_TESTS="info_handle output signal";
TOOLS_TESTS_WITH_INPUT="";
OPTION_SETS=();

INPUT_GLOB="*";

run_test()
{
	local TEST_NAME=$1;

	local TEST_DESCRIPTION="Testing: ${TEST_NAME}";
	local TEST_EXECUTABLE="./mdmp_test_tools_${TEST_NAME}";

	if ! test -x "${TEST_EXECUTABLE}";
	then
		TEST_EXECUTABLE="${TEST_EXECUTABLE}.exe";
	fi

	# TODO: add support for TEST_PROFILE and OPTION_SETS?
	run_test_with_arguments "${TEST_DESCRIPTION}" "${TEST_EXECUTABLE}";
	local RESULT=$?;

	return ${RESULT};
}

run_test_with_input()
{
	local TEST_NAME=$1;

	local TEST_DESCRIPTION="Testing: ${TEST_NAME}";
	local TEST_EXECUTABLE="./mdmp_test_tools_${TEST_NAME}";

	if ! test -x "${TEST_EXECUTABLE}";
	then
		TEST_EXECUTABLE="${TEST_EXECUTABLE}.exe";
	fi

	if ! test -d "input";
	then
		echo "Test input directory not found.";

		return ${EXIT_IGNORE};
	fi
	local RESULT=`ls input/* | tr ' ' '\n' | wc -l`;

	if test ${RESULT} -eq ${EXIT_SUCCESS};
	then
		echo "No files or directories found in the test input directory";

		return ${EXIT_IGNORE};
	fi

	local TEST_PROFILE_DIRECTORY=$(get_test_profile_directory "input" "mdmptools");

	local IGNORE_LIST=$(read_ignore_list "${TEST_PROFILE_DIRECTORY}");

	RESULT=${EXIT_SUCCESS};

	for TEST_SET_INPUT_DIRECTORY in input/*;
	do
		if ! test -d "${TEST_SET_INPUT_DIRECTORY}";
		then
			continue;
		fi
		if check_for_directory_in_ignore_list "${TEST_SET_INPUT_DIRECTORY}" "${IGNORE_LIST}";
		then
			continue;
		fi

		local TEST_SET_DIRECTORY=$(get_test_set_directory "${TEST_PROFILE_DIRECTORY}" "${TEST_SET_INPUT_DIRECTORY}");

		if test -f "${TEST_SET_DIRECTORY}/files";
		then
			IFS="" read -a INPUT_FILES <<< $(cat ${TEST_SET_DIRECTORY}/files | sed "s?^?${TEST_SET_INPUT_DIRECTORY}/?");
		else
			IFS="" read -a INPUT_FILES <<< $(ls -1d ${TEST_SET_INPUT_DIRECTORY}/${INPUT_GLOB});
		fi
		for INPUT_FILE in "${INPUT_FILES[@]}";
		do
			OPTION_INPUT_FILE="${INPUT_FILE}";

			if test "${OSTYPE}" = "msys";
			then
				# A test executable built with MinGW expects a Windows path.
				INPUT_FILE=`echo ${INPUT_FILE} | sed 's?/?\\\\?g'`;
			fi
			local TESTED_WITH_OPTIONS=0;

			for OPTION_SET in ${OPTION_SETS[@]};
			do
				local TEST_DATA_OPTION_FILE=$(get_test_data_option_file "${TEST_SET_DIRECTORY}" "${OPTION_INPUT_FILE}" "${OPTION_SET}");

				if test -f ${TEST_DATA_OPTION_FILE};
				then
					TESTED_WITH_OPTIONS=1;

					IFS=" " read -a OPTIONS <<< $(read_test_data_option_file "${TEST_SET_DIRECTORY}" "${INPUT_FILE}" "${OPTION_SET}");

					run_test_on_input_file "${TEST_SET_DIRECTORY}" "${TEST_DESCRIPTION}" "default" "${OPTION_SET}" "${TEST_EXECUTABLE}" "${INPUT_FILE}" "${OPTIONS[@]}";
					RESULT=$?;

					if test ${RESULT} -ne ${EXIT_SUCCESS};
					then
						break;
					fi
				fi
			done

			if test ${TESTED_WITH_OPTIONS} -eq 0;
			then
				run_test_on_input_file "${TEST_SET_DIRECTORY}" "${TEST_DESCRIPTION}" "default" "" "${TEST_EXECUTABLE}" "${INPUT_FILE}";
				RESULT=$?;
			fi

			if test ${RESULT} -ne ${EXIT_SUCCESS};
			then
				break;
			fi
		done

		if test ${RESULT} -ne ${EXIT_SUCCESS};
		then
			break;
		fi
	done

	return ${RESULT};
}

if test -n "${SKIP_TOOLS_TESTS}";
then
	exit ${EXIT_IGNORE};
fi

TEST_RUNNER="tests/test_runner.sh";

if ! test -f "${TEST_RUNNER}";
then
	TEST_RUNNER="./test_runner.sh";
fi

if ! test -f "${TEST_RUNNER}";
then
	echo "Missing test runner: ${TEST_RUNNER}";

	exit ${EXIT_FAILURE};
fi

source ${TEST_RUNNER};

RESULT=${EXIT_IGNORE};

for TEST_NAME in ${TOOLS_TESTS};
do
	run_test "${TEST_NAME}";
	RESULT=$?;

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		break;
	fi
done

if test ${RESULT} -ne ${EXIT_SUCCESS} && test ${RESULT} -ne ${EXIT_IGNORE};
then
	exit ${RESULT};
fi

for TEST_NAME in ${TOOLS_TESTS_WITH_INPUT};
do
	if test -d "input";
	then
		run_test_with_input "${TEST_NAME}";
		RESULT=$?;
	else
		run_test "${TEST_NAME}";
		RESULT=$?;
	fi

	if test ${RESULT} -ne ${EXIT_SUCCESS};
	then
		break;
	fi
done

exit ${RESULT};


```