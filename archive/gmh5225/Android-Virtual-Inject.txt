Project Path: arc_gmh5225_Android-Virtual-Inject_5s2jiya5

Source Tree:

```txt
arc_gmh5225_Android-Virtual-Inject_5s2jiya5
├── Bcore
│   ├── build.gradle.kts
│   ├── consumer-rules.pro
│   ├── proguard-rules.pro
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── aidl
│           │   ├── android
│           │   │   ├── accounts
│           │   │   │   ├── IAccountAuthenticator.aidl
│           │   │   │   ├── IAccountAuthenticatorResponse.aidl
│           │   │   │   └── IAccountManagerResponse.aidl
│           │   │   ├── app
│           │   │   │   ├── IActivityManager
│           │   │   │   │   └── ContentProviderHolder.aidl
│           │   │   │   ├── IServiceConnection.aidl
│           │   │   │   ├── IStopUserCallback.aidl
│           │   │   │   ├── IWallpaperManagerCallback.aidl
│           │   │   │   └── job
│           │   │   │       ├── IJobCallback.aidl
│           │   │   │       ├── IJobService.aidl
│           │   │   │       └── JobWorkItem.aidl
│           │   │   ├── content
│           │   │   │   ├── IIntentReceiver.aidl
│           │   │   │   ├── ISyncAdapter.aidl
│           │   │   │   ├── ISyncContext.aidl
│           │   │   │   ├── ISyncStatusObserver.aidl
│           │   │   │   ├── SyncStatusInfo.aidl
│           │   │   │   └── pm
│           │   │   │       ├── IPackageDataObserver.aidl
│           │   │   │       ├── IPackageDeleteObserver2.aidl
│           │   │   │       ├── IPackageInstallObserver.aidl
│           │   │   │       ├── IPackageInstallObserver2.aidl
│           │   │   │       ├── IPackageInstallerCallback.aidl
│           │   │   │       └── IPackageInstallerSession.aidl
│           │   │   ├── database
│           │   │   │   └── IContentObserver.aidl
│           │   │   ├── location
│           │   │   │   └── ILocationListener.aidl
│           │   │   ├── net
│           │   │   │   ├── IConnectivityManager.aidl
│           │   │   │   └── wifi
│           │   │   │       └── IWifiScanner.aidl
│           │   │   └── os
│           │   │       └── ISystemUpdateManager.aidl
│           │   └── com
│           │       ├── android
│           │       │   └── internal
│           │       │       └── widget
│           │       │           └── ILockSettings.aidl
│           │       └── vcore
│           │           ├── core
│           │           │   ├── IBActivityThread.aidl
│           │           │   ├── IEmpty.aidl
│           │           │   └── system
│           │           │       ├── accounts
│           │           │       │   └── IBAccountManagerService.aidl
│           │           │       ├── am
│           │           │       │   ├── IBActivityManagerService.aidl
│           │           │       │   └── IBJobManagerService.aidl
│           │           │       ├── device
│           │           │       │   └── IDeviceManagerService.aidl
│           │           │       ├── location
│           │           │       │   └── IBLocationManagerService.aidl
│           │           │       ├── notification
│           │           │       │   └── IBNotificationManagerService.aidl
│           │           │       ├── os
│           │           │       │   └── IBStorageManagerService.aidl
│           │           │       ├── pm
│           │           │       │   ├── BPackageSettings.aidl
│           │           │       │   ├── IBPackageInstallerService.aidl
│           │           │       │   ├── IBPackageManagerService.aidl
│           │           │       │   └── IBXposedManagerService.aidl
│           │           │       └── user
│           │           │           ├── BUserInfo.aidl
│           │           │           └── IBUserManagerService.aidl
│           │           └── entity
│           │               ├── AppConfig.aidl
│           │               ├── JobRecord.aidl
│           │               ├── UnbindRecord.aidl
│           │               ├── am
│           │               │   ├── PendingResultData.aidl
│           │               │   ├── ReceiverData.aidl
│           │               │   ├── RunningAppProcessInfo.aidl
│           │               │   └── RunningServiceInfo.aidl
│           │               ├── device
│           │               │   └── BDeviceConfig.aidl
│           │               ├── location
│           │               │   ├── BCell.aidl
│           │               │   ├── BLocation.aidl
│           │               │   └── BLocationConfig.aidl
│           │               └── pm
│           │                   ├── InstallOption.aidl
│           │                   ├── InstallResult.aidl
│           │                   ├── InstalledModule.aidl
│           │                   └── InstalledPackage.aidl
│           ├── cpp
│           │   ├── BoxCore.cpp
│           │   ├── BoxCore.h
│           │   ├── CMakeLists.txt
│           │   ├── Hook
│           │   │   ├── BaseHook.cpp
│           │   │   ├── BaseHook.h
│           │   │   ├── BinderHook.cpp
│           │   │   ├── BinderHook.h
│           │   │   ├── LinuxHook.cpp
│           │   │   ├── LinuxHook.h
│           │   │   ├── RuntimeHook.cpp
│           │   │   ├── RuntimeHook.h
│           │   │   ├── SystemPropertiesHook.cpp
│           │   │   ├── SystemPropertiesHook.h
│           │   │   ├── UnixFileSystemHook.cpp
│           │   │   ├── UnixFileSystemHook.h
│           │   │   ├── VMClassLoaderHook.cpp
│           │   │   └── VMClassLoaderHook.h
│           │   ├── IO.cpp
│           │   ├── IO.h
│           │   ├── JniHook
│           │   │   ├── ArtMethod.h
│           │   │   ├── JniHook.cpp
│           │   │   └── JniHook.h
│           │   └── Log.h
│           ├── java
│           │   ├── android
│           │   │   ├── app
│           │   │   │   ├── ActivityThread.java
│           │   │   │   └── ContentProviderHolder.java
│           │   │   ├── content
│           │   │   │   ├── IContentProvider.java
│           │   │   │   ├── SyncInfo.java
│           │   │   │   ├── SyncStatusInfo.java
│           │   │   │   └── pm
│           │   │   │       ├── ManifestDigest.java
│           │   │   │       ├── PackageParser.java
│           │   │   │       ├── PackageUserState.java
│           │   │   │       └── VerifierInfo.java
│           │   │   ├── location
│           │   │   │   └── LocationRequest.java
│           │   │   └── os
│           │   │       ├── ParcelableException.java
│           │   │       └── ServiceManager.java
│           │   ├── black
│           │   │   ├── Reflector.java
│           │   │   ├── android
│           │   │   │   ├── accounts
│           │   │   │   │   └── IAccountManager.java
│           │   │   │   ├── app
│           │   │   │   │   ├── Activity.java
│           │   │   │   │   ├── ActivityClient.java
│           │   │   │   │   ├── ActivityManagerNative.java
│           │   │   │   │   ├── ActivityManagerOreo.java
│           │   │   │   │   ├── ActivityTaskManager.java
│           │   │   │   │   ├── ActivityThread.java
│           │   │   │   │   ├── ActivityThreadNMR1.java
│           │   │   │   │   ├── ActivityThreadQ.java
│           │   │   │   │   ├── AppOpsManager.java
│           │   │   │   │   ├── ApplicationPackageManager.java
│           │   │   │   │   ├── ApplicationThreadNative.java
│           │   │   │   │   ├── ContextImpl.java
│           │   │   │   │   ├── ContextImplKitkat.java
│           │   │   │   │   ├── IActivityManager.java
│           │   │   │   │   ├── IActivityManagerL.java
│           │   │   │   │   ├── IActivityManagerN.java
│           │   │   │   │   ├── IActivityTaskManager.java
│           │   │   │   │   ├── IAlarmManager.java
│           │   │   │   │   ├── IApplicationThread.java
│           │   │   │   │   ├── ISearchManager.java
│           │   │   │   │   ├── IServiceConnectionO.java
│           │   │   │   │   ├── LoadedApk.java
│           │   │   │   │   ├── NotificationChannel.java
│           │   │   │   │   ├── NotificationChannelGroup.java
│           │   │   │   │   ├── NotificationManager.java
│           │   │   │   │   ├── NotificationO.java
│           │   │   │   │   ├── Service.java
│           │   │   │   │   ├── admin
│           │   │   │   │   │   └── IDevicePolicyManager.java
│           │   │   │   │   ├── job
│           │   │   │   │   │   ├── IJobScheduler.java
│           │   │   │   │   │   └── JobInfo.java
│           │   │   │   │   ├── servertransaction
│           │   │   │   │   │   ├── ClientTransaction.java
│           │   │   │   │   │   └── LaunchActivityItem.java
│           │   │   │   │   └── usage
│           │   │   │   │       └── IStorageStatsManager.java
│           │   │   │   ├── bluetooth
│           │   │   │   │   └── IBluetoothManager.java
│           │   │   │   ├── content
│           │   │   │   │   ├── AttributionSource.java
│           │   │   │   │   ├── AttributionSourceState.java
│           │   │   │   │   ├── BroadcastReceiver.java
│           │   │   │   │   ├── ContentProviderClient.java
│           │   │   │   │   ├── ContentProviderHolderOreo.java
│           │   │   │   │   ├── ContentProviderNative.java
│           │   │   │   │   ├── ContentResolver.java
│           │   │   │   │   ├── IContentService.java
│           │   │   │   │   ├── IIntentReceiver.java
│           │   │   │   │   ├── IRestrictionsManager.java
│           │   │   │   │   ├── pm
│           │   │   │   │   │   ├── ApplicationInfoL.java
│           │   │   │   │   │   ├── ApplicationInfoN.java
│           │   │   │   │   │   ├── ILauncherApps.java
│           │   │   │   │   │   ├── IShortcutService.java
│           │   │   │   │   │   ├── PackageParser.java
│           │   │   │   │   │   ├── PackageParserLollipop.java
│           │   │   │   │   │   ├── PackageParserLollipop22.java
│           │   │   │   │   │   ├── PackageParserMarshmallow.java
│           │   │   │   │   │   ├── PackageParserNougat.java
│           │   │   │   │   │   ├── PackageParserPie.java
│           │   │   │   │   │   ├── ParceledListSlice.java
│           │   │   │   │   │   ├── SigningInfo.java
│           │   │   │   │   │   └── UserInfo.java
│           │   │   │   │   └── res
│           │   │   │   │       └── AssetManager.java
│           │   │   │   ├── ddm
│           │   │   │   │   └── DdmHandleAppName.java
│           │   │   │   ├── graphics
│           │   │   │   │   └── Compatibility.java
│           │   │   │   ├── hardware
│           │   │   │   │   ├── display
│           │   │   │   │   │   └── DisplayManagerGlobal.java
│           │   │   │   │   └── location
│           │   │   │   │       └── IContextHubService.java
│           │   │   │   ├── location
│           │   │   │   │   ├── ILocationListener.java
│           │   │   │   │   ├── ILocationManager.java
│           │   │   │   │   ├── LocationManager.java
│           │   │   │   │   └── provider
│           │   │   │   │       └── ProviderProperties.java
│           │   │   │   ├── media
│           │   │   │   │   ├── IMediaRouterService.java
│           │   │   │   │   └── session
│           │   │   │   │       └── ISessionManager.java
│           │   │   │   ├── net
│           │   │   │   │   ├── IConnectivityManager.java
│           │   │   │   │   ├── IVpnManager.java
│           │   │   │   │   └── wifi
│           │   │   │   │       ├── IWifiManager.java
│           │   │   │   │       ├── WifiInfo.java
│           │   │   │   │       └── WifiSsid.java
│           │   │   │   ├── os
│           │   │   │   │   ├── Build.java
│           │   │   │   │   ├── Bundle.java
│           │   │   │   │   ├── Handler.java
│           │   │   │   │   ├── IDeviceIdentifiersPolicyService.java
│           │   │   │   │   ├── INetworkManagementService.java
│           │   │   │   │   ├── IPowerManager.java
│           │   │   │   │   ├── IUserManager.java
│           │   │   │   │   ├── IVibratorManagerService.java
│           │   │   │   │   ├── Process.java
│           │   │   │   │   ├── ServiceManager.java
│           │   │   │   │   ├── StrictMode.java
│           │   │   │   │   ├── SystemProperties.java
│           │   │   │   │   ├── UserHandle.java
│           │   │   │   │   ├── mount
│           │   │   │   │   │   └── IMountService.java
│           │   │   │   │   └── storage
│           │   │   │   │       ├── IStorageManager.java
│           │   │   │   │       ├── StorageManager.java
│           │   │   │   │       └── StorageVolume.java
│           │   │   │   ├── permission
│           │   │   │   │   └── IPermissionManager.java
│           │   │   │   ├── providers
│           │   │   │   │   └── Settings.java
│           │   │   │   ├── role
│           │   │   │   │   └── IRoleManager.java
│           │   │   │   ├── security
│           │   │   │   │   └── net
│           │   │   │   │       └── config
│           │   │   │   │           └── NetworkSecurityConfigProvider.java
│           │   │   │   ├── service
│           │   │   │   │   └── persistentdata
│           │   │   │   │       └── IPersistentDataBlockService.java
│           │   │   │   ├── telephony
│           │   │   │   │   └── TelephonyManager.java
│           │   │   │   ├── util
│           │   │   │   │   └── Singleton.java
│           │   │   │   └── view
│           │   │   │       ├── IAutoFillManager.java
│           │   │   │       ├── IGraphicsStats.java
│           │   │   │       ├── IWindowManager.java
│           │   │   │       ├── WindowManagerGlobal.java
│           │   │   │       └── accessibility
│           │   │   │           └── IAccessibilityManager.java
│           │   │   ├── com
│           │   │   │   └── android
│           │   │   │       └── internal
│           │   │   │           ├── R.java
│           │   │   │           ├── app
│           │   │   │           │   └── IAppOpsService.java
│           │   │   │           ├── appwidget
│           │   │   │           │   └── IAppWidgetService.java
│           │   │   │           ├── content
│           │   │   │           │   └── ReferrerIntent.java
│           │   │   │           ├── infra
│           │   │   │           │   └── AndroidFuture.java
│           │   │   │           ├── net
│           │   │   │           │   └── VpnConfig.java
│           │   │   │           ├── os
│           │   │   │           │   └── IVibratorService.java
│           │   │   │           └── telephony
│           │   │   │               ├── ISub.java
│           │   │   │               ├── ITelephony.java
│           │   │   │               └── ITelephonyRegistry.java
│           │   │   ├── dalvik
│           │   │   │   └── system
│           │   │   │       └── VMRuntime.java
│           │   │   ├── libcore
│           │   │   │   └── io
│           │   │   │       └── Libcore.java
│           │   │   └── oem
│           │   │       ├── flyme
│           │   │       │   └── IFlymePermissionService.java
│           │   │       └── vivo
│           │   │           ├── IPhysicalFlingManager.java
│           │   │           ├── IPopupCameraManager.java
│           │   │           ├── ISuperResolutionManager.java
│           │   │           ├── ISystemDefenceManager.java
│           │   │           └── IVivoPermissonService.java
│           │   └── com
│           │       └── vcore
│           │           ├── BlackBoxCore.java
│           │           ├── app
│           │           │   ├── BActivityThread.java
│           │           │   ├── LauncherActivity.java
│           │           │   ├── configuration
│           │           │   │   ├── AppLifecycleCallback.java
│           │           │   │   └── ClientConfiguration.java
│           │           │   └── dispatcher
│           │           │       ├── AppJobServiceDispatcher.java
│           │           │       └── AppServiceDispatcher.java
│           │           ├── core
│           │           │   ├── CrashHandler.java
│           │           │   ├── GmsCore.java
│           │           │   ├── IOCore.java
│           │           │   ├── NativeCore.java
│           │           │   ├── env
│           │           │   │   ├── AppSystemEnv.java
│           │           │   │   ├── BEnvironment.java
│           │           │   │   └── VirtualRuntime.java
│           │           │   └── system
│           │           │       ├── BProcessManagerService.java
│           │           │       ├── BlackBoxSystem.java
│           │           │       ├── DaemonService.java
│           │           │       ├── ISystemService.java
│           │           │       ├── ProcessRecord.java
│           │           │       ├── ServiceManager.java
│           │           │       ├── SystemCallProvider.java
│           │           │       ├── accounts
│           │           │       │   ├── BAccount.java
│           │           │       │   ├── BAccountManagerService.java
│           │           │       │   ├── BUserAccounts.java
│           │           │       │   ├── RegisteredServicesParser.java
│           │           │       │   └── TokenCache.java
│           │           │       ├── am
│           │           │       │   ├── ActiveServices.java
│           │           │       │   ├── ActivityRecord.kt
│           │           │       │   ├── ActivityStack.java
│           │           │       │   ├── BActivityManagerService.java
│           │           │       │   ├── BJobManagerService.java
│           │           │       │   ├── BroadcastManager.java
│           │           │       │   ├── PendingIntentRecord.java
│           │           │       │   ├── TaskRecord.java
│           │           │       │   └── UserSpace.java
│           │           │       ├── location
│           │           │       │   ├── BLocationManagerService.java
│           │           │       │   └── LocationRecord.java
│           │           │       ├── notification
│           │           │       │   ├── BNotificationManagerService.java
│           │           │       │   └── NotificationRecord.java
│           │           │       ├── os
│           │           │       │   └── BStorageManagerService.java
│           │           │       ├── pm
│           │           │       │   ├── BPackage.java
│           │           │       │   ├── BPackageInstallerService.java
│           │           │       │   ├── BPackageManagerService.java
│           │           │       │   ├── BPackageSettings.java
│           │           │       │   ├── BPackageUserState.java
│           │           │       │   ├── BXposedManagerService.java
│           │           │       │   ├── ComponentResolver.java
│           │           │       │   ├── FastImmutableArraySet.java
│           │           │       │   ├── IntentResolver.java
│           │           │       │   ├── PackageManagerCompat.java
│           │           │       │   ├── PackageMonitor.java
│           │           │       │   ├── Settings.java
│           │           │       │   ├── SharedUserSetting.java
│           │           │       │   └── installer
│           │           │       │       ├── CopyExecutor.java
│           │           │       │       ├── CreatePackageExecutor.java
│           │           │       │       ├── CreateUserExecutor.java
│           │           │       │       ├── Executor.java
│           │           │       │       ├── RemoveAppExecutor.java
│           │           │       │       └── RemoveUserExecutor.java
│           │           │       └── user
│           │           │           ├── BUserHandle.java
│           │           │           ├── BUserInfo.java
│           │           │           ├── BUserManagerService.java
│           │           │           └── BUserStatus.java
│           │           ├── entity
│           │           │   ├── AppConfig.java
│           │           │   ├── JobRecord.java
│           │           │   ├── ServiceRecord.java
│           │           │   ├── UnbindRecord.java
│           │           │   ├── am
│           │           │   │   ├── PendingResultData.java
│           │           │   │   ├── ReceiverData.java
│           │           │   │   ├── RunningAppProcessInfo.java
│           │           │   │   └── RunningServiceInfo.java
│           │           │   ├── device
│           │           │   │   └── BDeviceConfig.java
│           │           │   ├── location
│           │           │   │   ├── BCell.java
│           │           │   │   ├── BLocation.java
│           │           │   │   └── BLocationConfig.java
│           │           │   └── pm
│           │           │       ├── InstallOption.java
│           │           │       ├── InstallResult.java
│           │           │       ├── InstalledModule.java
│           │           │       ├── InstalledPackage.java
│           │           │       └── XposedConfig.java
│           │           ├── fake
│           │           │   ├── delegate
│           │           │   │   ├── AppInstrumentation.java
│           │           │   │   ├── BaseInstrumentationDelegate.java
│           │           │   │   ├── ContentProviderDelegate.java
│           │           │   │   ├── InnerReceiverDelegate.java
│           │           │   │   └── ServiceConnectionDelegate.java
│           │           │   ├── frameworks
│           │           │   │   ├── BAccountManager.java
│           │           │   │   ├── BActivityManager.java
│           │           │   │   ├── BJobManager.java
│           │           │   │   ├── BLocationManager.java
│           │           │   │   ├── BNotificationManager.java
│           │           │   │   ├── BPackageManager.java
│           │           │   │   ├── BStorageManager.java
│           │           │   │   ├── BUserManager.java
│           │           │   │   ├── BXposedManager.java
│           │           │   │   └── BlackManager.java
│           │           │   ├── hook
│           │           │   │   ├── BinderInvocationStub.java
│           │           │   │   ├── ClassInvocationStub.java
│           │           │   │   ├── HookManager.java
│           │           │   │   ├── IInjectHook.java
│           │           │   │   ├── MethodHook.java
│           │           │   │   ├── ProxyMethod.java
│           │           │   │   ├── ProxyMethods.java
│           │           │   │   └── ScanClass.java
│           │           │   ├── provider
│           │           │   │   ├── FileProvider.java
│           │           │   │   └── FileProviderHandler.java
│           │           │   └── service
│           │           │       ├── ActivityManagerCommonProxy.java
│           │           │       ├── BuildProxy.java
│           │           │       ├── HCallbackProxy.java
│           │           │       ├── IAccessibilityManagerProxy.java
│           │           │       ├── IAccountManagerProxy.java
│           │           │       ├── IActivityClientProxy.java
│           │           │       ├── IActivityManagerProxy.java
│           │           │       ├── IActivityTaskManagerProxy.java
│           │           │       ├── IAlarmManagerProxy.java
│           │           │       ├── IAppOpsManagerProxy.java
│           │           │       ├── IAppWidgetManagerProxy.java
│           │           │       ├── IAutofillManagerProxy.java
│           │           │       ├── IBluetoothManagerProxy.java
│           │           │       ├── IConnectivityManagerProxy.java
│           │           │       ├── IContextHubServiceProxy.java
│           │           │       ├── IDeviceIdentifiersPolicyProxy.java
│           │           │       ├── IDevicePolicyManagerProxy.java
│           │           │       ├── IDisplayManagerProxy.java
│           │           │       ├── IFingerprintManagerProxy.java
│           │           │       ├── IFlymePermissionServiceProxy.java
│           │           │       ├── IGraphicsStatsProxy.java
│           │           │       ├── IJobServiceProxy.java
│           │           │       ├── ILauncherAppsProxy.java
│           │           │       ├── ILocationManagerProxy.java
│           │           │       ├── IMediaRouterServiceProxy.java
│           │           │       ├── IMediaSessionManagerProxy.java
│           │           │       ├── INetworkManagementServiceProxy.java
│           │           │       ├── INotificationManagerProxy.java
│           │           │       ├── IPackageManagerProxy.java
│           │           │       ├── IPermissionManagerProxy.java
│           │           │       ├── IPersistentDataBlockServiceProxy.java
│           │           │       ├── IPhoneSubInfoProxy.java
│           │           │       ├── IPhysicalFlingManagerProxy.java
│           │           │       ├── IPopupCameraManagerProxy.java
│           │           │       ├── IPowerManagerProxy.java
│           │           │       ├── IRoleManagerProxy.java
│           │           │       ├── ISearchManagerProxy.java
│           │           │       ├── IShortcutManagerProxy.java
│           │           │       ├── IStorageManagerProxy.java
│           │           │       ├── IStorageStatsManagerProxy.java
│           │           │       ├── ISubProxy.java
│           │           │       ├── ISuperResolutionManagerProxy.java
│           │           │       ├── ISystemDefenceManagerProxy.java
│           │           │       ├── ISystemUpdateProxy.java
│           │           │       ├── ITelephonyManagerProxy.java
│           │           │       ├── ITelephonyRegistryProxy.java
│           │           │       ├── IUserManagerProxy.java
│           │           │       ├── IVibratorServiceProxy.java
│           │           │       ├── IVivoPermissionServiceProxy.java
│           │           │       ├── IVpnManagerProxy.java
│           │           │       ├── IWifiManagerProxy.java
│           │           │       ├── IWifiScannerProxy.java
│           │           │       ├── IWindowManagerProxy.java
│           │           │       ├── IWindowSessionProxy.java
│           │           │       ├── VpnCommonProxy.java
│           │           │       ├── base
│           │           │       │   ├── PkgMethodProxy.java
│           │           │       │   ├── UidMethodProxy.java
│           │           │       │   └── ValueMethodProxy.java
│           │           │       ├── context
│           │           │       │   ├── ContentServiceProxy.java
│           │           │       │   ├── LocationListenerProxy.java
│           │           │       │   ├── RestrictionsManagerProxy.java
│           │           │       │   └── providers
│           │           │       │       ├── BContentProvider.java
│           │           │       │       ├── ContentProviderStub.java
│           │           │       │       └── SystemProviderStub.java
│           │           │       └── libcore
│           │           │           └── OsProxy.java
│           │           ├── jnihook
│           │           │   ├── JniHook.java
│           │           │   └── MethodUtils.java
│           │           ├── proxy
│           │           │   ├── ProxyActivity.java
│           │           │   ├── ProxyBroadcastReceiver.java
│           │           │   ├── ProxyContentProvider.java
│           │           │   ├── ProxyJobService.java
│           │           │   ├── ProxyManifest.java
│           │           │   ├── ProxyPendingActivity.java
│           │           │   ├── ProxyService.java
│           │           │   ├── ProxyVpnService.java
│           │           │   ├── TransparentProxyActivity.java
│           │           │   └── record
│           │           │       ├── ProxyActivityRecord.java
│           │           │       ├── ProxyBroadcastRecord.java
│           │           │       ├── ProxyPendingRecord.java
│           │           │       └── ProxyServiceRecord.java
│           │           └── utils
│           │               ├── AbiUtils.java
│           │               ├── ArrayUtils.java
│           │               ├── CloseUtils.java
│           │               ├── ComponentUtils.java
│           │               ├── DrawableUtils.java
│           │               ├── FileUtils.java
│           │               ├── Md5Utils.java
│           │               ├── MethodParameterUtils.java
│           │               ├── NativeUtils.java
│           │               ├── ShellUtils.java
│           │               ├── Slog.java
│           │               ├── TrieTree.java
│           │               ├── compat
│           │               │   ├── AccountManagerCompat.java
│           │               │   ├── ActivityCompat.java
│           │               │   ├── ActivityManagerCompat.java
│           │               │   ├── ApplicationThreadCompat.java
│           │               │   ├── BuildCompat.java
│           │               │   ├── BundleCompat.java
│           │               │   ├── ContentProviderCompat.java
│           │               │   ├── ContextCompat.java
│           │               │   ├── PackageParserCompat.java
│           │               │   ├── ParceledListSliceCompat.java
│           │               │   ├── StrictModeCompat.java
│           │               │   ├── SystemPropertiesCompat.java
│           │               │   ├── TaskDescriptionCompat.java
│           │               │   └── XposedParserCompat.java
│           │               └── provider
│           │                   └── ProviderCall.java
│           └── res
│               ├── drawable
│               │   └── ic_launcher.png
│               ├── layout
│               │   └── activity_launcher.xml
│               ├── values
│               │   ├── strings.xml
│               │   └── styles.xml
│               └── xml
│                   └── filepath.xml
├── LICENSE
├── README.md
├── app
│   ├── build.gradle.kts
│   ├── proguard-rules.pro
│   └── src
│       ├── main
│       │   ├── AndroidManifest.xml
│       │   ├── java
│       │   │   └── com
│       │   │       └── reveny
│       │   │           └── virtualinject
│       │   │               ├── App.java
│       │   │               ├── Application.java
│       │   │               ├── MainActivity.java
│       │   │               ├── ui
│       │   │               │   ├── activity
│       │   │               │   │   ├── BaseActivity.java
│       │   │               │   │   └── MainActivity.java
│       │   │               │   ├── dialog
│       │   │               │   │   └── BlurBehindDialogBuilder.java
│       │   │               │   └── fragment
│       │   │               │       ├── BaseFragment.java
│       │   │               │       └── HomeFragment.java
│       │   │               └── util
│       │   │                   ├── NavUtil.java
│       │   │                   ├── ThemeUtil.java
│       │   │                   ├── Utility.java
│       │   │                   └── chrome
│       │   │                       ├── CustomTabsURLSpan.java
│       │   │                       └── LinkTransformationMethod.java
│       │   └── res
│       │       ├── drawable
│       │       │   ├── folder_open_outline.xml
│       │       │   ├── ic_launcher.xml
│       │       │   ├── ic_launcher_background.xml
│       │       │   ├── ic_launcher_foreground.xml
│       │       │   ├── iconsax_closecircle.xml
│       │       │   └── iconsax_tickcircle.xml
│       │       ├── layout
│       │       │   ├── activity_main.xml
│       │       │   ├── dialog_about.xml
│       │       │   ├── dialog_item.xml
│       │       │   ├── dialog_title.xml
│       │       │   └── fragment_home.xml
│       │       ├── menu
│       │       │   └── menu_home.xml
│       │       ├── mipmap-anydpi-v26
│       │       │   ├── ic_launcher.xml
│       │       │   └── ic_launcher_round.xml
│       │       ├── mipmap-hdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-mdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-xhdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-xxhdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-xxxhdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── values
│       │       │   ├── attrs.xml
│       │       │   ├── colors.xml
│       │       │   ├── colors_google.xml
│       │       │   ├── integer.xml
│       │       │   ├── strings.xml
│       │       │   ├── styles.xml
│       │       │   ├── themes.xml
│       │       │   ├── themes_custom.xml
│       │       │   └── themes_override.xml
│       │       ├── values-night
│       │       │   ├── colors.xml
│       │       │   ├── styles.xml
│       │       │   └── themes.xml
│       │       ├── values-sw600dp
│       │       │   └── integer.xml
│       │       ├── values-v28
│       │       │   └── themes.xml
│       │       ├── values-v30
│       │       │   └── themes.xml
│       │       └── xml
│       │           ├── backup_rules.xml
│       │           └── data_extraction_rules.xml
│       └── test
│           └── java
│               └── com
│                   └── reveny
│                       └── virtualinject
│                           └── ExampleUnitTest.java
├── build.gradle.kts
├── gradle
│   ├── libs.versions.toml
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── preview.jpg
└── settings.gradle.kts

```

`Bcore/build.gradle.kts`:

```kts
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.vcore"
    compileSdk = (rootProject.ext["compileSdk"] as Int)


    defaultConfig {
        minSdk = (rootProject.ext["minSdk"] as Int)
        consumerProguardFiles("consumer-rules.pro")
        vectorDrawables {
            useSupportLibrary = true
        }

        ndk.apply{
            abiFilters.add("armeabi-v7a")
            abiFilters.add("arm64-v8a")
        }
    }
    val cmake = rootProject.ext["cmakeVersion"] as String
    externalNativeBuild {
        cmake {
            path = file("src/main/cpp/CMakeLists.txt")
            version = cmake
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false  //not tested yet
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
        debug {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }
    buildFeatures{
        aidl = true
        prefab = true
        viewBinding = true
    }

    packagingOptions.apply {
        excludes.add("**/libshadowhook.so")
    }
}

// it make update dependency update easy
val ktxversion = rootProject.ext["ktx_version"] as String
val stdlib_version = rootProject.ext["stdlib_version"] as String
val hiddenapibypass = rootProject.ext["hiddenapibypass"] as String
val xcrashversion = rootProject.ext["xcrashversion"] as String
val shadowhook = rootProject.ext["shadowhook"] as String
val googlematerial = rootProject.ext["googlematerial"] as String

dependencies {
    implementation("androidx.appcompat:appcompat") {
        exclude(group = "com.android.support", module = "support-compat")
    }
    implementation("androidx.core:core-ktx:$ktxversion")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk7:$stdlib_version")
    implementation ("com.iqiyi.xcrash:xcrash-android-lib:$xcrashversion")
    implementation("com.google.android.material:material:$googlematerial")
    implementation ("org.lsposed.hiddenapibypass:hiddenapibypass:$hiddenapibypass")
    implementation("com.bytedance.android:shadowhook:$shadowhook")
    implementation ("top.canyie.pine:core:0.2.8")
    implementation ("top.canyie.pine:xposed:0.0.9")
}
```

`Bcore/consumer-rules.pro`:

```pro

-keep class com.vcore.** {*; }
-keep class black.** {*; }
-keep class android.** {*; }
-keep class com.android.** {*; }
```

`Bcore/proguard-rules.pro`:

```pro

-keep class com.vcore.** {*; }
-keep class black.** {*; }
-keep class android.** {*; }
-keep class com.android.** {*; }

```

`Bcore/src/main/AndroidManifest.xml`:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- unknown -->
    <uses-permission android:name="android.permission.WRITE_SOCIAL_STREAM" />
    <uses-permission android:name="android.permission.READ_SOCIAL_STREAM" />
    <uses-permission android:name="android.permission.READ_PROFILE" />
    <uses-permission android:name="android.permission.WRITE_PROFILE" />
    <uses-permission android:name="android.permission.READ_USER_DICTIONARY" />
    <uses-permission android:name="android.permission.WRITE_USER_DICTIONARY" />
    <uses-permission android:name="android.permission.USE_CREDENTIALS" />
    <uses-permission android:name="android.permission.AUTHENTICATE_ACCOUNTS" />

    <!-- samsung start -->
    <uses-permission android:name="com.samsung.svoice.sync.READ_DATABASE" />
    <uses-permission android:name="com.samsung.svoice.sync.ACCESS_SERVICE" />
    <uses-permission android:name="com.samsung.svoice.sync.WRITE_DATABASE" />
    <uses-permission android:name="com.sec.android.app.voicenote.Controller" />
    <uses-permission android:name="com.sec.android.permission.VOIP_INTERFACE" />
    <uses-permission android:name="com.sec.android.permission.LAUNCH_PERSONAL_PAGE_SERVICE" />
    <uses-permission android:name="com.samsung.android.providers.context.permission.WRITE_USE_APP_FEATURE_SURVEY" />
    <uses-permission android:name="com.samsung.android.providers.context.permission.READ_RECORD_AUDIO" />
    <uses-permission android:name="com.samsung.android.providers.context.permission.WRITE_RECORD_AUDIO" />
    <uses-permission android:name="com.sec.android.settings.permission.SOFT_RESET" />
    <uses-permission android:name="sec.android.permission.READ_MSG_PREF" />
    <uses-permission android:name="com.samsung.android.scloud.backup.lib.read" />
    <uses-permission android:name="com.samsung.android.scloud.backup.lib.write" />
    <!-- samsung end -->

    <!-- other app start -->
    <uses-permission android:name="com.android.alarm.permission.SET_ALARM" />
    <uses-permission android:name="com.android.voicemail.permission.ADD_VOICEMAIL" />
    <uses-permission android:name="com.android.voicemail.permission.READ_WRITE_ALL_VOICEMAIL" />
    <uses-permission android:name="com.huawei.authentication.HW_ACCESS_AUTH_SERVICE" />
    <!-- other app end -->

    <!-- google play store start -->
    <uses-permission android:name="com.android.vending.BILLING" />
    <uses-permission android:name="com.android.vending.CHECK_LICENSE" />
    <!-- google play store end -->

    <!-- google services framework start -->
    <uses-permission android:name="com.google.android.providers.talk.permission.READ_ONLY" />
    <uses-permission android:name="com.google.android.providers.talk.permission.WRITE_ONLY" />

    <uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" />
    <uses-permission android:name="com.google.android.gms.permission.ACTIVITY_RECOGNITION" />
    <uses-permission android:name="com.google.android.gms.permission.AD_ID_NOTIFICATION" />
    <uses-permission android:name="com.google.android.providers.gsf.permission.READ_GSERVICES" />
    <!-- google services framework end -->

    <!-- shortcut and badge start -->
    <uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT" />
    <uses-permission android:name="com.android.launcher.permission.UNINSTALL_SHORTCUT" />
    <uses-permission android:name="android.permission.READ_APP_BADGE" />

    <uses-permission android:name="com.google.android.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.oppo.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.oppo.launcher.permission.WRITE_SETTINGS" />
    <uses-permission android:name="me.everything.badger.permission.BADGE_COUNT_READ" />
    <uses-permission android:name="me.everything.badger.permission.BADGE_COUNT_WRITE" />
    <uses-permission android:name="com.android.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.sec.android.provider.badge.permission.READ" />
    <uses-permission android:name="com.sec.android.provider.badge.permission.WRITE" />
    <uses-permission android:name="com.htc.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.htc.launcher.permission.UPDATE_SHORTCUT" />
    <uses-permission android:name="com.sonyericsson.home.permission.BROADCAST_BADGE" />
    <uses-permission android:name="com.sonymobile.home.permission.PROVIDER_INSERT_BADGE" />
    <uses-permission android:name="com.anddoes.launcher.permission.UPDATE_COUNT" />
    <uses-permission android:name="com.majeur.launcher.permission.UPDATE_BADGE" />
    <uses-permission android:name="com.huawei.android.launcher.permission.CHANGE_BADGE" />
    <uses-permission android:name="com.huawei.android.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.huawei.android.launcher.permission.WRITE_SETTINGS" />
    <uses-permission android:name="com.android.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.android.launcher.permission.WRITE_SETTINGS" />
    <uses-permission android:name="com.android.launcher3.permission.READ_SETTINGS" />
    <uses-permission android:name="com.android.launcher2.permission.READ_SETTINGS" />
    <uses-permission android:name="com.teslacoilsw.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.actionlauncher.playstore.permission.READ_SETTINGS" />
    <uses-permission android:name="com.mx.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.anddoes.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.apusapps.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.tsf.shell.permission.READ_SETTINGS" />
    <uses-permission android:name="com.htc.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.lenovo.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.oppo.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.bbk.launcher2.permission.READ_SETTINGS" />
    <uses-permission android:name="com.s.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="cn.nubia.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.huawei.android.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="com.huawei.android.launcher.permission.CHANGE_BADGE" />
    <!-- shortcut and badge end -->
    <!-- 常用 -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.FLASHLIGHT" />
    <!-- 相机 -->
    <uses-permission android:name="android.permission.CAMERA" />

    <uses-feature android:name="android.hardware.camera" />
    <uses-feature
        android:name="android.hardware.camera.autofocus"
        android:required="false" />
    <!-- 位置服务 -->
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_LOCATION_EXTRA_COMMANDS" />
    <!-- 网络 -->
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_MULTICAST_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    <!-- sdcard -->
    <uses-permission
        android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"
        tools:ignore="ProtectedPermissions" />

    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <!-- 电量 -->
    <uses-permission
        android:name="android.permission.BATTERY_STATS"
        tools:ignore="ProtectedPermissions" />
    <!-- 身体传感器 -->
    <uses-permission android:name="android.permission.BODY_SENSORS" />
    <uses-permission android:name="android.permission.BROADCAST_STICKY" />
    <!-- 锁屏-->
    <uses-permission android:name="android.permission.DISABLE_KEYGUARD" />
    <!-- 允许应用程序展开或折叠状态栏 -->
    <uses-permission android:name="android.permission.EXPAND_STATUS_BAR" />
    <!-- 账号相关 -->
    <uses-permission android:name="android.permission.GET_ACCOUNTS" />
    <uses-permission android:name="android.permission.MANAGE_ACCOUNTS" />
    <!-- 通话状态 -->
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <!-- 修改当前配置-->
    <uses-permission
        android:name="android.permission.CHANGE_CONFIGURATION"
        tools:ignore="ProtectedPermissions" />
    <!-- 设置 -->
    <uses-permission
        android:name="android.permission.WRITE_SETTINGS"
        tools:ignore="ProtectedPermissions" />
    <!-- 最近任务/进程 -->
    <uses-permission android:name="android.permission.GET_TASKS" />
    <uses-permission android:name="android.permission.KILL_BACKGROUND_PROCESSES" />
    <uses-permission android:name="android.permission.REORDER_TASKS" />
    <uses-permission android:name="android.permission.PERSISTENT_ACTIVITY" />
    <!-- 录音 -->
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <!-- bluetooth -->
    <uses-permission android:name="android.permission.BLUETOOTH" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
    <!-- nfc -->
    <uses-permission android:name="android.permission.NFC" />
    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
    <!-- 震动 -->
    <uses-permission android:name="android.permission.VIBRATE" />
    <!-- 指纹 -->
    <uses-permission android:name="android.permission.USE_FINGERPRINT" />

    <!-- 下面自己按需保留 -->

    <!-- browser history start -->
    <uses-permission android:name="com.android.browser.permission.READ_HISTORY_BOOKMARKS" />
    <uses-permission android:name="com.android.browser.permission.WRITE_HISTORY_BOOKMARKS" />
    <!-- browser history end -->

    <!-- 清空应用缓存-->
    <uses-permission
        android:name="android.permission.CLEAR_APP_CACHE"
        tools:ignore="ProtectedPermissions" />

    <uses-permission android:name="android.permission.GET_PACKAGE_SIZE" />
    <!-- 同步设置 -->
    <uses-permission android:name="android.permission.WRITE_SYNC_SETTINGS" />
    <uses-permission android:name="android.permission.READ_SYNC_SETTINGS" />
    <uses-permission android:name="android.permission.READ_SYNC_STATS" />
    <!-- rss -->
    <uses-permission android:name="android.permission.SUBSCRIBED_FEEDS_READ" />
    <uses-permission android:name="android.permission.SUBSCRIBED_FEEDS_WRITE" />
    <!-- 日历 -->
    <uses-permission android:name="android.permission.WRITE_CALENDAR" />
    <uses-permission android:name="android.permission.READ_CALENDAR" />
    <!-- 通讯录 -->
    <uses-permission android:name="android.permission.READ_CONTACTS" />
    <uses-permission android:name="android.permission.WRITE_CONTACTS" />
    <!-- 系统日志 -->
    <uses-permission
        android:name="android.permission.READ_LOGS"
        tools:ignore="ProtectedPermissions" />
    <!-- 重启应用 -->
    <uses-permission android:name="android.permission.RESTART_PACKAGES" />
    <!-- 时间/时区 -->
    <uses-permission
        android:name="android.permission.SET_TIME"
        tools:ignore="ProtectedPermissions" />

    <uses-permission
        android:name="android.permission.SET_TIME_ZONE"
        tools:ignore="ProtectedPermissions" />
    <!-- 墙纸 -->
    <uses-permission android:name="android.permission.SET_WALLPAPER" />
    <uses-permission android:name="android.permission.SET_WALLPAPER_HINTS" />
    <!-- 红外线 -->
    <uses-permission android:name="android.permission.TRANSMIT_IR" />

    <!-- SIP服务 -->
    <uses-permission android:name="android.permission.USE_SIP" />
    <!-- 唤醒屏幕 -->
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <!-- float window -->
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    <uses-permission android:name="android.permission.SYSTEM_OVERLAY_WINDOW" />
    <!-- boot -->
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />

    <!-- system app start -->
    <uses-permission
        android:name="android.permission.GET_INTENT_SENDER_INTENT"
        tools:ignore="ProtectedPermissions" />

    <uses-permission
        android:name="android.permission.BIND_DIRECTORY_SEARCH"
        tools:ignore="ProtectedPermissions" />

    <uses-permission
        android:name="android.permission.UPDATE_APP_OPS_STATS"
        tools:ignore="ProtectedPermissions" />

    <uses-permission
        android:name="android.permission.INSTALL_PACKAGES"
        tools:ignore="ProtectedPermissions" />

    <uses-permission
        android:name="android.permission.DELETE_PACKAGES"
        tools:ignore="ProtectedPermissions" />

    <uses-permission
        android:name="android.permission.CLEAR_APP_USER_DATA"
        tools:ignore="ProtectedPermissions" />

    <uses-permission
        android:name="android.permission.WRITE_MEDIA_STORAGE"
        tools:ignore="ProtectedPermissions" />

    <uses-permission
        android:name="android.permission.ACCESS_CACHE_FILESYSTEM"
        tools:ignore="ProtectedPermissions" />

    <uses-permission
        android:name="android.permission.DEVICE_POWER"
        tools:ignore="ProtectedPermissions" />

    <!--<uses-permission-->
    <!--android:name="android.permission.WRITE_APN_SETTINGS"-->
    <!--tools:ignore="ProtectedPermissions" />-->

    <!-- xdja -->
    <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS" />
    <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS_FULL" />
    <!-- xdja -->

    <uses-permission
        android:name="android.permission.BIND_APPWIDGET"
        tools:ignore="ProtectedPermissions" />

    <uses-permission
        android:name="android.permission.ACCOUNT_MANAGER"
        tools:ignore="ProtectedPermissions" />

    <uses-permission
        android:name="android.permission.PACKAGE_USAGE_STATS"
        tools:ignore="ProtectedPermissions" />
    <!-- system app end -->

    <!-- not found -->
    <uses-permission android:name="android.permission.READ_INSTALL_SESSIONS" />
    <uses-permission android:name="android.permission.READ_OWNER_DATA" />
    <uses-permission android:name="android.permission.READ_CELL_BROADCASTS" />
    <uses-permission android:name="android.permission.WRITE_CLIPS" />
    <uses-permission android:name="android.permission.READ_CLIPS" />
    <uses-permission android:name="android.permission.GET_CLIPS" />
    <uses-permission android:name="android.permission.WRITE_OWNER_DATA" />
    <uses-permission android:name="android.permission.ACCESS_GPS" />
    <uses-permission android:name="android.permission.ACCESS_WIMAX_STATE" />
    <uses-permission android:name="android.permission.ACCESS_DOWNLOAD_MANAGER" />
    <uses-permission android:name="android.permission.CHANGE_WIMAX_STATE" />
    <uses-permission android:name="android.permission.DOWNLOAD_WITHOUT_NOTIFICATION" />

    <!-- xdja -->
    <uses-permission android:name="android.permission.CALL_PHONE" />
    <uses-permission android:name="android.permission.SEND_SMS" />
    <uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS" />
    <!-- 安全接入 -->
    <uses-permission android:name="android.permission.RECEIVE_MMS" />
    <uses-permission android:name="android.permission.RECEIVE_SMS" />
    <uses-permission android:name="android.permission.READ_SMS" />
    <uses-permission android:name="android.permission.WRITE_SMS" />
    <!-- xdja -->

    <!-- 通话记录 -->
    <uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS" />
    <!-- call phone -->
    <uses-permission android:name="android.permission.CALL_PHONE" />
    <uses-permission android:name="android.permission.READ_CALL_LOG" />
    <uses-permission android:name="android.permission.WRITE_CALL_LOG" />
    <uses-permission android:name="android.permission.BIND_VPN_SERVICE" />

    <uses-permission android:name="android.permission.READ_DEVICE_CONFIG" />

    <uses-permission android:name="android.provider.Telephony.SMS_RECEIVED" />

    <uses-permission
        android:name="android.permission.BROADCAST_WAP_PUSH"
        tools:ignore="ProtectedPermissions" />
    <uses-permission
        android:name="android.permission.BROADCAST_SMS"
        tools:ignore="ProtectedPermissions" />
    <uses-permission
        android:name="android.permission.SEND_RESPOND_VIA_MESSAGE"
        tools:ignore="ProtectedPermissions" />

    <uses-permission
        android:name="android.permission.GET_INTENT_SENDER_INTENT"
        tools:ignore="ProtectedPermissions" />

    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE" />
    <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES" />

    <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" />

    <uses-feature
        android:name="android.hardware.nfc"
        android:required="false" />

    <uses-permission android:name="android.hardware.usb.host" />
    <uses-permission
        android:name="android.permission.HARDWARE_TEST"
        tools:ignore="ProtectedPermissions" />

    <uses-permission android:name="android.permission.PACKAGE_USAGE_STATS" />

    <!-- android 11 -->
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES" />

    <uses-permission android:name="android.permission.HIDE_OVERLAY_WINDOWS" />

    <application>
        <provider
            android:name="com.vcore.core.system.SystemCallProvider"
            android:authorities="${applicationId}.blackbox.SystemCallProvider"
            android:exported="false"
            android:process="@string/black_box_service_name" />

        <!--file provider-->
        <provider
            android:name=".fake.provider.FileProvider"
            android:authorities="${applicationId}.blackbox.FileProvider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/filepath" />
        </provider>

        <receiver
            android:name=".proxy.ProxyBroadcastReceiver"
            android:enabled="true"
            android:exported="true"
            android:process="@string/black_box_service_name">
            <intent-filter>
                <action android:name="${applicationId}.stub_receiver" />
            </intent-filter>
        </receiver>

        <service
            android:name="com.vcore.core.system.DaemonService"
            android:exported="false"
            android:foregroundServiceType="specialUse"
            android:process="@string/black_box_service_name" />

        <service
            android:name="com.vcore.core.system.DaemonService$DaemonInnerService"
            android:exported="false"
            android:process="@string/black_box_service_name" />

        <activity
            android:name=".app.LauncherActivity"
            android:excludeFromRecents="true"
            android:theme="@style/LauncherTheme" />

        <service
            android:name="com.vcore.proxy.ProxyVpnService"
            android:enabled="true"
            android:exported="false"
            android:permission="android.permission.BIND_VPN_SERVICE">

            <intent-filter>
                <action android:name="android.net.VpnService" />
            </intent-filter>
            <meta-data
                android:name="android.net.VpnService.SUPPORTS_ALWAYS_ON"
                android:value="true" />
        </service>

        <activity
            android:name=".proxy.ProxyActivity$P0"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p0"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P1"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p1"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P2"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p2"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P3"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p3"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P4"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p4"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P5"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p5"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P6"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p6"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P7"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p7"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P8"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p8"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P9"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p9"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P10"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p10"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P11"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p11"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P12"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p12"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P13"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p13"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P14"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p14"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P15"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p15"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P16"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p16"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P17"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p17"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P18"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p18"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P19"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p19"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P20"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p20"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P21"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p21"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P22"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p22"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P23"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p23"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P24"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p24"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P25"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p25"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P26"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p26"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P27"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p27"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P28"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p28"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P29"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p29"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P30"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p30"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P31"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p31"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P32"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p32"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P33"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p33"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P34"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p34"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P35"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p35"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P36"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p36"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P37"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p37"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P38"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p38"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P39"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p39"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P40"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p40"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P41"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p41"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P42"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p42"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P43"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p43"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P44"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p44"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P45"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p45"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P46"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p46"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P47"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p47"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P48"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p48"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.ProxyActivity$P49"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p49"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@style/BTheme" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P0"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p0"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P1"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p1"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P2"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p2"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P3"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p3"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P4"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p4"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P5"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p5"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P6"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p6"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P7"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p7"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P8"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p8"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P9"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p9"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P10"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p10"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P11"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p11"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P12"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p12"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P13"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p13"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P14"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p14"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P15"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p15"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P16"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p16"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P17"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p17"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P18"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p18"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P19"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p19"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P20"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p20"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P21"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p21"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P22"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p22"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P23"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p23"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P24"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p24"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P25"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p25"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P26"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p26"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P27"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p27"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P28"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p28"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P29"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p29"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P30"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p30"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P31"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p31"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P32"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p32"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P33"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p33"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P34"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p34"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P35"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p35"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P36"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p36"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P37"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p37"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P38"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p38"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P39"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p39"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P40"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p40"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P41"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p41"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P42"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p42"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P43"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p43"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P44"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p44"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P45"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p45"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P46"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p46"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P47"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p47"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P48"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p48"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.TransparentProxyActivity$P49"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
            android:exported="true"
            android:process=":p49"
            android:supportsPictureInPicture="true"
            android:taskAffinity="com.vspace.task_affinity"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P0"
            android:exported="true"
            android:process=":p0"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P1"
            android:exported="true"
            android:process=":p1"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P2"
            android:exported="true"
            android:process=":p2"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P3"
            android:exported="true"
            android:process=":p3"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P4"
            android:exported="true"
            android:process=":p4"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P5"
            android:exported="true"
            android:process=":p5"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P6"
            android:exported="true"
            android:process=":p6"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P7"
            android:exported="true"
            android:process=":p7"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P8"
            android:exported="true"
            android:process=":p8"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P9"
            android:exported="true"
            android:process=":p9"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P10"
            android:exported="true"
            android:process=":p10"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P11"
            android:exported="true"
            android:process=":p11"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P12"
            android:exported="true"
            android:process=":p12"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P13"
            android:exported="true"
            android:process=":p13"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P14"
            android:exported="true"
            android:process=":p14"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P15"
            android:exported="true"
            android:process=":p15"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P16"
            android:exported="true"
            android:process=":p16"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P17"
            android:exported="true"
            android:process=":p17"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P18"
            android:exported="true"
            android:process=":p18"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P19"
            android:exported="true"
            android:process=":p19"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P20"
            android:exported="true"
            android:process=":p20"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P21"
            android:exported="true"
            android:process=":p21"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P22"
            android:exported="true"
            android:process=":p22"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P23"
            android:exported="true"
            android:process=":p23"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P24"
            android:exported="true"
            android:process=":p24"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P25"
            android:exported="true"
            android:process=":p25"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P26"
            android:exported="true"
            android:process=":p26"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P27"
            android:exported="true"
            android:process=":p27"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P28"
            android:exported="true"
            android:process=":p28"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P29"
            android:exported="true"
            android:process=":p29"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P30"
            android:exported="true"
            android:process=":p30"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P31"
            android:exported="true"
            android:process=":p31"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P32"
            android:exported="true"
            android:process=":p32"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P33"
            android:exported="true"
            android:process=":p33"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P34"
            android:exported="true"
            android:process=":p34"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P35"
            android:exported="true"
            android:process=":p35"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P36"
            android:exported="true"
            android:process=":p36"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P37"
            android:exported="true"
            android:process=":p37"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P38"
            android:exported="true"
            android:process=":p38"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P39"
            android:exported="true"
            android:process=":p39"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P40"
            android:exported="true"
            android:process=":p40"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P41"
            android:exported="true"
            android:process=":p41"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P42"
            android:exported="true"
            android:process=":p42"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P43"
            android:exported="true"
            android:process=":p43"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P44"
            android:exported="true"
            android:process=":p44"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P45"
            android:exported="true"
            android:process=":p45"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P46"
            android:exported="true"
            android:process=":p46"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P47"
            android:exported="true"
            android:process=":p47"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P48"
            android:exported="true"
            android:process=":p48"
            android:theme="@android:style/Theme.Translucent" />

        <activity
            android:name=".proxy.ProxyPendingActivity$P49"
            android:exported="true"
            android:process=":p48"
            android:theme="@android:style/Theme.Translucent" />

        <service
            android:name=".proxy.ProxyService$P0"
            android:exported="true"
            android:process=":p0" />

        <service
            android:name=".proxy.ProxyService$P1"
            android:exported="true"
            android:process=":p1" />

        <service
            android:name=".proxy.ProxyService$P2"
            android:exported="true"
            android:process=":p2" />

        <service
            android:name=".proxy.ProxyService$P3"
            android:exported="true"
            android:process=":p3" />

        <service
            android:name=".proxy.ProxyService$P4"
            android:exported="true"
            android:process=":p4" />

        <service
            android:name=".proxy.ProxyService$P5"
            android:exported="true"
            android:process=":p5" />

        <service
            android:name=".proxy.ProxyService$P6"
            android:exported="true"
            android:process=":p6" />

        <service
            android:name=".proxy.ProxyService$P7"
            android:exported="true"
            android:process=":p7" />

        <service
            android:name=".proxy.ProxyService$P8"
            android:exported="true"
            android:process=":p8" />

        <service
            android:name=".proxy.ProxyService$P9"
            android:exported="true"
            android:process=":p9" />

        <service
            android:name=".proxy.ProxyService$P10"
            android:exported="true"
            android:process=":p10" />

        <service
            android:name=".proxy.ProxyService$P11"
            android:exported="true"
            android:process=":p11" />

        <service
            android:name=".proxy.ProxyService$P12"
            android:exported="true"
            android:process=":p12" />

        <service
            android:name=".proxy.ProxyService$P13"
            android:exported="true"
            android:process=":p13" />

        <service
            android:name=".proxy.ProxyService$P14"
            android:exported="true"
            android:process=":p14" />

        <service
            android:name=".proxy.ProxyService$P15"
            android:exported="true"
            android:process=":p15" />

        <service
            android:name=".proxy.ProxyService$P16"
            android:exported="true"
            android:process=":p16" />

        <service
            android:name=".proxy.ProxyService$P17"
            android:exported="true"
            android:process=":p17" />

        <service
            android:name=".proxy.ProxyService$P18"
            android:exported="true"
            android:process=":p18" />

        <service
            android:name=".proxy.ProxyService$P19"
            android:exported="true"
            android:process=":p19" />

        <service
            android:name=".proxy.ProxyService$P20"
            android:exported="true"
            android:process=":p20" />

        <service
            android:name=".proxy.ProxyService$P21"
            android:exported="true"
            android:process=":p21" />

        <service
            android:name=".proxy.ProxyService$P22"
            android:exported="true"
            android:process=":p22" />

        <service
            android:name=".proxy.ProxyService$P23"
            android:exported="true"
            android:process=":p23" />

        <service
            android:name=".proxy.ProxyService$P24"
            android:exported="true"
            android:process=":p24" />

        <service
            android:name=".proxy.ProxyService$P25"
            android:exported="true"
            android:process=":p25" />

        <service
            android:name=".proxy.ProxyService$P26"
            android:exported="true"
            android:process=":p26" />

        <service
            android:name=".proxy.ProxyService$P27"
            android:exported="true"
            android:process=":p27" />

        <service
            android:name=".proxy.ProxyService$P28"
            android:exported="true"
            android:process=":p28" />

        <service
            android:name=".proxy.ProxyService$P29"
            android:exported="true"
            android:process=":p29" />

        <service
            android:name=".proxy.ProxyService$P30"
            android:exported="true"
            android:process=":p30" />

        <service
            android:name=".proxy.ProxyService$P31"
            android:exported="true"
            android:process=":p31" />

        <service
            android:name=".proxy.ProxyService$P32"
            android:exported="true"
            android:process=":p32" />

        <service
            android:name=".proxy.ProxyService$P33"
            android:exported="true"
            android:process=":p33" />

        <service
            android:name=".proxy.ProxyService$P34"
            android:exported="true"
            android:process=":p34" />

        <service
            android:name=".proxy.ProxyService$P35"
            android:exported="true"
            android:process=":p35" />

        <service
            android:name=".proxy.ProxyService$P36"
            android:exported="true"
            android:process=":p36" />

        <service
            android:name=".proxy.ProxyService$P37"
            android:exported="true"
            android:process=":p37" />

        <service
            android:name=".proxy.ProxyService$P38"
            android:exported="true"
            android:process=":p38" />

        <service
            android:name=".proxy.ProxyService$P39"
            android:exported="true"
            android:process=":p39" />

        <service
            android:name=".proxy.ProxyService$P40"
            android:exported="true"
            android:process=":p40" />

        <service
            android:name=".proxy.ProxyService$P41"
            android:exported="true"
            android:process=":p41" />

        <service
            android:name=".proxy.ProxyService$P42"
            android:exported="true"
            android:process=":p42" />

        <service
            android:name=".proxy.ProxyService$P43"
            android:exported="true"
            android:process=":p43" />

        <service
            android:name=".proxy.ProxyService$P44"
            android:exported="true"
            android:process=":p44" />

        <service
            android:name=".proxy.ProxyService$P45"
            android:exported="true"
            android:process=":p45" />

        <service
            android:name=".proxy.ProxyService$P46"
            android:exported="true"
            android:process=":p46" />

        <service
            android:name=".proxy.ProxyService$P47"
            android:exported="true"
            android:process=":p47" />

        <service
            android:name=".proxy.ProxyService$P48"
            android:exported="true"
            android:process=":p48" />

        <service
            android:name=".proxy.ProxyService$P49"
            android:exported="true"
            android:process=":p49" />

        <provider
            android:name=".proxy.ProxyContentProvider$P0"
            android:authorities="${applicationId}.proxy_content_provider_0"
            android:exported="true"
            android:process=":p0" />

        <provider
            android:name=".proxy.ProxyContentProvider$P1"
            android:authorities="${applicationId}.proxy_content_provider_1"
            android:exported="true"
            android:process=":p1" />

        <provider
            android:name=".proxy.ProxyContentProvider$P2"
            android:authorities="${applicationId}.proxy_content_provider_2"
            android:exported="true"
            android:process=":p2" />

        <provider
            android:name=".proxy.ProxyContentProvider$P3"
            android:authorities="${applicationId}.proxy_content_provider_3"
            android:exported="true"
            android:process=":p3" />

        <provider
            android:name=".proxy.ProxyContentProvider$P4"
            android:authorities="${applicationId}.proxy_content_provider_4"
            android:exported="true"
            android:process=":p4" />

        <provider
            android:name=".proxy.ProxyContentProvider$P5"
            android:authorities="${applicationId}.proxy_content_provider_5"
            android:exported="true"
            android:process=":p5" />

        <provider
            android:name=".proxy.ProxyContentProvider$P6"
            android:authorities="${applicationId}.proxy_content_provider_6"
            android:exported="true"
            android:process=":p6" />

        <provider
            android:name=".proxy.ProxyContentProvider$P7"
            android:authorities="${applicationId}.proxy_content_provider_7"
            android:exported="true"
            android:process=":p7" />

        <provider
            android:name=".proxy.ProxyContentProvider$P8"
            android:authorities="${applicationId}.proxy_content_provider_8"
            android:exported="true"
            android:process=":p8" />

        <provider
            android:name=".proxy.ProxyContentProvider$P9"
            android:authorities="${applicationId}.proxy_content_provider_9"
            android:exported="true"
            android:process=":p9" />

        <provider
            android:name=".proxy.ProxyContentProvider$P10"
            android:authorities="${applicationId}.proxy_content_provider_10"
            android:exported="true"
            android:process=":p10" />

        <provider
            android:name=".proxy.ProxyContentProvider$P11"
            android:authorities="${applicationId}.proxy_content_provider_11"
            android:exported="true"
            android:process=":p11" />

        <provider
            android:name=".proxy.ProxyContentProvider$P12"
            android:authorities="${applicationId}.proxy_content_provider_12"
            android:exported="true"
            android:process=":p12" />

        <provider
            android:name=".proxy.ProxyContentProvider$P13"
            android:authorities="${applicationId}.proxy_content_provider_13"
            android:exported="true"
            android:process=":p13" />

        <provider
            android:name=".proxy.ProxyContentProvider$P14"
            android:authorities="${applicationId}.proxy_content_provider_14"
            android:exported="true"
            android:process=":p14" />

        <provider
            android:name=".proxy.ProxyContentProvider$P15"
            android:authorities="${applicationId}.proxy_content_provider_15"
            android:exported="true"
            android:process=":p15" />

        <provider
            android:name=".proxy.ProxyContentProvider$P16"
            android:authorities="${applicationId}.proxy_content_provider_16"
            android:exported="true"
            android:process=":p16" />

        <provider
            android:name=".proxy.ProxyContentProvider$P17"
            android:authorities="${applicationId}.proxy_content_provider_17"
            android:exported="true"
            android:process=":p17" />

        <provider
            android:name=".proxy.ProxyContentProvider$P18"
            android:authorities="${applicationId}.proxy_content_provider_18"
            android:exported="true"
            android:process=":p18" />

        <provider
            android:name=".proxy.ProxyContentProvider$P19"
            android:authorities="${applicationId}.proxy_content_provider_19"
            android:exported="true"
            android:process=":p19" />

        <provider
            android:name=".proxy.ProxyContentProvider$P20"
            android:authorities="${applicationId}.proxy_content_provider_20"
            android:exported="true"
            android:process=":p20" />

        <provider
            android:name=".proxy.ProxyContentProvider$P21"
            android:authorities="${applicationId}.proxy_content_provider_21"
            android:exported="true"
            android:process=":p21" />

        <provider
            android:name=".proxy.ProxyContentProvider$P22"
            android:authorities="${applicationId}.proxy_content_provider_22"
            android:exported="true"
            android:process=":p22" />

        <provider
            android:name=".proxy.ProxyContentProvider$P23"
            android:authorities="${applicationId}.proxy_content_provider_23"
            android:exported="true"
            android:process=":p23" />

        <provider
            android:name=".proxy.ProxyContentProvider$P24"
            android:authorities="${applicationId}.proxy_content_provider_24"
            android:exported="true"
            android:process=":p24" />

        <provider
            android:name=".proxy.ProxyContentProvider$P25"
            android:authorities="${applicationId}.proxy_content_provider_25"
            android:exported="true"
            android:process=":p25" />

        <provider
            android:name=".proxy.ProxyContentProvider$P26"
            android:authorities="${applicationId}.proxy_content_provider_26"
            android:exported="true"
            android:process=":p26" />

        <provider
            android:name=".proxy.ProxyContentProvider$P27"
            android:authorities="${applicationId}.proxy_content_provider_27"
            android:exported="true"
            android:process=":p27" />

        <provider
            android:name=".proxy.ProxyContentProvider$P28"
            android:authorities="${applicationId}.proxy_content_provider_28"
            android:exported="true"
            android:process=":p28" />

        <provider
            android:name=".proxy.ProxyContentProvider$P29"
            android:authorities="${applicationId}.proxy_content_provider_29"
            android:exported="true"
            android:process=":p29" />

        <provider
            android:name=".proxy.ProxyContentProvider$P30"
            android:authorities="${applicationId}.proxy_content_provider_30"
            android:exported="true"
            android:process=":p30" />

        <provider
            android:name=".proxy.ProxyContentProvider$P31"
            android:authorities="${applicationId}.proxy_content_provider_31"
            android:exported="true"
            android:process=":p31" />

        <provider
            android:name=".proxy.ProxyContentProvider$P32"
            android:authorities="${applicationId}.proxy_content_provider_32"
            android:exported="true"
            android:process=":p32" />

        <provider
            android:name=".proxy.ProxyContentProvider$P33"
            android:authorities="${applicationId}.proxy_content_provider_33"
            android:exported="true"
            android:process=":p33" />

        <provider
            android:name=".proxy.ProxyContentProvider$P34"
            android:authorities="${applicationId}.proxy_content_provider_34"
            android:exported="true"
            android:process=":p34" />

        <provider
            android:name=".proxy.ProxyContentProvider$P35"
            android:authorities="${applicationId}.proxy_content_provider_35"
            android:exported="true"
            android:process=":p35" />

        <provider
            android:name=".proxy.ProxyContentProvider$P36"
            android:authorities="${applicationId}.proxy_content_provider_36"
            android:exported="true"
            android:process=":p36" />

        <provider
            android:name=".proxy.ProxyContentProvider$P37"
            android:authorities="${applicationId}.proxy_content_provider_37"
            android:exported="true"
            android:process=":p37" />

        <provider
            android:name=".proxy.ProxyContentProvider$P38"
            android:authorities="${applicationId}.proxy_content_provider_38"
            android:exported="true"
            android:process=":p38" />

        <provider
            android:name=".proxy.ProxyContentProvider$P39"
            android:authorities="${applicationId}.proxy_content_provider_39"
            android:exported="true"
            android:process=":p39" />

        <provider
            android:name=".proxy.ProxyContentProvider$P40"
            android:authorities="${applicationId}.proxy_content_provider_40"
            android:exported="true"
            android:process=":p40" />

        <provider
            android:name=".proxy.ProxyContentProvider$P41"
            android:authorities="${applicationId}.proxy_content_provider_41"
            android:exported="true"
            android:process=":p41" />

        <provider
            android:name=".proxy.ProxyContentProvider$P42"
            android:authorities="${applicationId}.proxy_content_provider_42"
            android:exported="true"
            android:process=":p42" />

        <provider
            android:name=".proxy.ProxyContentProvider$P43"
            android:authorities="${applicationId}.proxy_content_provider_43"
            android:exported="true"
            android:process=":p43" />

        <provider
            android:name=".proxy.ProxyContentProvider$P44"
            android:authorities="${applicationId}.proxy_content_provider_44"
            android:exported="true"
            android:process=":p44" />

        <provider
            android:name=".proxy.ProxyContentProvider$P45"
            android:authorities="${applicationId}.proxy_content_provider_45"
            android:exported="true"
            android:process=":p45" />

        <provider
            android:name=".proxy.ProxyContentProvider$P46"
            android:authorities="${applicationId}.proxy_content_provider_46"
            android:exported="true"
            android:process=":p46" />

        <provider
            android:name=".proxy.ProxyContentProvider$P47"
            android:authorities="${applicationId}.proxy_content_provider_47"
            android:exported="true"
            android:process=":p47" />

        <provider
            android:name=".proxy.ProxyContentProvider$P48"
            android:authorities="${applicationId}.proxy_content_provider_48"
            android:exported="true"
            android:process=":p48" />

        <provider
            android:name=".proxy.ProxyContentProvider$P49"
            android:authorities="${applicationId}.proxy_content_provider_49"
            android:exported="true"
            android:process=":p49" />

        <service
            android:name=".proxy.ProxyJobService$P0"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p0" />

        <service
            android:name=".proxy.ProxyJobService$P1"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p1" />

        <service
            android:name=".proxy.ProxyJobService$P2"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p2" />

        <service
            android:name=".proxy.ProxyJobService$P3"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p3" />

        <service
            android:name=".proxy.ProxyJobService$P4"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p4" />

        <service
            android:name=".proxy.ProxyJobService$P5"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p5" />

        <service
            android:name=".proxy.ProxyJobService$P6"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p6" />

        <service
            android:name=".proxy.ProxyJobService$P7"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p7" />

        <service
            android:name=".proxy.ProxyJobService$P8"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p8" />

        <service
            android:name=".proxy.ProxyJobService$P9"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p9" />

        <service
            android:name=".proxy.ProxyJobService$P10"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p10" />

        <service
            android:name=".proxy.ProxyJobService$P11"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p11" />

        <service
            android:name=".proxy.ProxyJobService$P12"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p12" />

        <service
            android:name=".proxy.ProxyJobService$P13"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p13" />

        <service
            android:name=".proxy.ProxyJobService$P14"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p14" />

        <service
            android:name=".proxy.ProxyJobService$P15"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p15" />

        <service
            android:name=".proxy.ProxyJobService$P16"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p16" />

        <service
            android:name=".proxy.ProxyJobService$P17"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p17" />

        <service
            android:name=".proxy.ProxyJobService$P18"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p18" />

        <service
            android:name=".proxy.ProxyJobService$P19"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p19" />

        <service
            android:name=".proxy.ProxyJobService$P20"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p20" />

        <service
            android:name=".proxy.ProxyJobService$P21"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p21" />

        <service
            android:name=".proxy.ProxyJobService$P22"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p22" />

        <service
            android:name=".proxy.ProxyJobService$P23"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p23" />

        <service
            android:name=".proxy.ProxyJobService$P24"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p24" />

        <service
            android:name=".proxy.ProxyJobService$P25"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p25" />

        <service
            android:name=".proxy.ProxyJobService$P26"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p26" />

        <service
            android:name=".proxy.ProxyJobService$P27"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p27" />

        <service
            android:name=".proxy.ProxyJobService$P28"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p28" />

        <service
            android:name=".proxy.ProxyJobService$P29"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p29" />

        <service
            android:name=".proxy.ProxyJobService$P30"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p30" />

        <service
            android:name=".proxy.ProxyJobService$P31"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p31" />

        <service
            android:name=".proxy.ProxyJobService$P32"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p32" />

        <service
            android:name=".proxy.ProxyJobService$P33"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p33" />

        <service
            android:name=".proxy.ProxyJobService$P34"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p34" />

        <service
            android:name=".proxy.ProxyJobService$P35"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p35" />

        <service
            android:name=".proxy.ProxyJobService$P36"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p36" />

        <service
            android:name=".proxy.ProxyJobService$P37"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p37" />

        <service
            android:name=".proxy.ProxyJobService$P38"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p38" />

        <service
            android:name=".proxy.ProxyJobService$P39"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p39" />

        <service
            android:name=".proxy.ProxyJobService$P40"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p40" />

        <service
            android:name=".proxy.ProxyJobService$P41"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p41" />

        <service
            android:name=".proxy.ProxyJobService$P42"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p42" />

        <service
            android:name=".proxy.ProxyJobService$P43"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p43" />

        <service
            android:name=".proxy.ProxyJobService$P44"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p44" />

        <service
            android:name=".proxy.ProxyJobService$P45"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p45" />

        <service
            android:name=".proxy.ProxyJobService$P46"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p46" />

        <service
            android:name=".proxy.ProxyJobService$P47"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p47" />

        <service
            android:name=".proxy.ProxyJobService$P48"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p48" />

        <service
            android:name=".proxy.ProxyJobService$P49"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:process=":p49" />
    </application>
</manifest>

```

`Bcore/src/main/aidl/android/accounts/IAccountAuthenticator.aidl`:

```aidl
package android.accounts;

import android.accounts.IAccountAuthenticatorResponse;
import android.accounts.Account;
import android.os.Bundle;

/**
 * Service that allows the interaction with an authentication server.
 * @hide
 */
interface IAccountAuthenticator {
    /**
     * prompts the user for account information and adds the result to the IAccountManager
     */
    void addAccount(in IAccountAuthenticatorResponse response, String accountType,
        String authTokenType, in String[] requiredFeatures, in Bundle options);

    /**
     * prompts the user for the credentials of the account
     */
    void confirmCredentials(in IAccountAuthenticatorResponse response, in Account account,
        in Bundle options);

    /**
     * gets the password by either prompting the user or querying the IAccountManager
     */
    void getAuthToken(in IAccountAuthenticatorResponse response, in Account account,
        String authTokenType, in Bundle options);

    /**
     * Gets the user-visible label of the given authtoken type.
     */
    void getAuthTokenLabel(in IAccountAuthenticatorResponse response, String authTokenType);

    /**
     * prompts the user for a new password and writes it to the IAccountManager
     */
    void updateCredentials(in IAccountAuthenticatorResponse response, in Account account,
        String authTokenType, in Bundle options);

    /**
     * launches an activity that lets the user edit and set the properties for an authenticator
     */
    void editProperties(in IAccountAuthenticatorResponse response, String accountType);

    /**
     * returns a Bundle where the boolean value BOOLEAN_RESULT_KEY is set if the account has the
     * specified features
     */
    void hasFeatures(in IAccountAuthenticatorResponse response, in Account account, 
        in String[] features);

    /**
     * Gets whether or not the account is allowed to be removed.
     */
    void getAccountRemovalAllowed(in IAccountAuthenticatorResponse response, in Account account);

    /**
     * Returns a Bundle containing the required credentials to copy the account across users.
     */
    void getAccountCredentialsForCloning(in IAccountAuthenticatorResponse response,
            in Account account);

    /**
     * Uses the Bundle containing credentials from another instance of the authenticator to create
     * a copy of the account on this user.
     */
    void addAccountFromCredentials(in IAccountAuthenticatorResponse response, in Account account,
            in Bundle accountCredentials);
}

```

`Bcore/src/main/aidl/android/accounts/IAccountAuthenticatorResponse.aidl`:

```aidl
package android.accounts;
import android.os.Bundle;

/**
 * The interface used to return responses from an {@link IAccountAuthenticator}
 */
interface IAccountAuthenticatorResponse {
    void onResult(in Bundle value);
    void onRequestContinued();
    void onError(int errorCode, String errorMessage);
}

```

`Bcore/src/main/aidl/android/accounts/IAccountManagerResponse.aidl`:

```aidl
package android.accounts;

import android.os.Bundle;

/**
 * The interface used to return responses for asynchronous calls to the {@link IAccountManager}
 */
interface IAccountManagerResponse {
    void onResult(in Bundle value);
    void onError(int errorCode, String errorMessage);
}

```

`Bcore/src/main/aidl/android/app/IActivityManager/ContentProviderHolder.aidl`:

```aidl
// ContentProviderHolder.aidl
package android.app.IActivityManager;

parcelable ContentProviderHolder;
```

`Bcore/src/main/aidl/android/app/IServiceConnection.aidl`:

```aidl
package android.app;

import android.content.ComponentName;

/** @hide */
interface IServiceConnection {
    void connected(in ComponentName name, IBinder service);
}

```

`Bcore/src/main/aidl/android/app/IStopUserCallback.aidl`:

```aidl
package android.app;

/**
 * Callback to find out when we have finished stopping a user.
 * {@hide}
 */
interface IStopUserCallback {
    void userStopped(int userId);
    void userStopAborted(int userId);
}

```

`Bcore/src/main/aidl/android/app/IWallpaperManagerCallback.aidl`:

```aidl
package android.app;

/** @hide */
interface IWallpaperManagerCallback {
    void onWallpaperChanged();
}

```

`Bcore/src/main/aidl/android/app/job/IJobCallback.aidl`:

```aidl
package android.app.job;

import android.app.job.JobWorkItem;

/**
 * The server side of the JobScheduler IPC protocols.  The app-side implementation
 * invokes on this interface to indicate completion of the (asynchronous) instructions
 * issued by the server.
 *
 * In all cases, the 'who' parameter is the caller's service binder, used to track
 * which Job Service instance is reporting.
 *
 */
interface IJobCallback {
    /**
    * Immediate callback to the system after sending a start signal, used to quickly detect ANR.
    *
    * @param jobId Unique integer used to identify this job.
    * @param ongoing True to indicate that the client is processing the job. False if the job is
    * complete
    */
    void acknowledgeStartMessage(int jobId, boolean ongoing);
    /**
    * Immediate callback to the system after sending a stop signal, used to quickly detect ANR.
    *
    * @param jobId Unique integer used to identify this job.
    * @param reschedule Whether or not to reschedule this job.
    */
    void acknowledgeStopMessage(int jobId, boolean reschedule);
    /*
    * Called to deqeue next work item for the job.
    */
    JobWorkItem dequeueWork(int jobId);
    /*
    * Called to report that job has completed processing a work item.
    */
    boolean completeWork(int jobId, int workId);
    /*
    * Tell the job manager that the client is done with its execution, so that it can go on to
    * the next one and stop attributing wakelock time to us etc.
    *
    * @param jobId Unique integer used to identify this job.
    * @param reschedule Whether or not to reschedule this job.
    */
    void jobFinished(int jobId, boolean reschedule);
}

```

`Bcore/src/main/aidl/android/app/job/IJobService.aidl`:

```aidl
package android.app.job;

import android.app.job.JobParameters;

/**
 * Interface that the framework uses to communicate with application code that implements a
 * JobService.  End user code does not implement this interface directly; instead, the app's
 * service implementation will extend android.app.job.JobService.
 */
interface IJobService {
    /** Begin execution of application's job. */
    void startJob(in JobParameters jobParams);
    /** Stop execution of application's job. */
    void stopJob(in JobParameters jobParams);
}

```

`Bcore/src/main/aidl/android/app/job/JobWorkItem.aidl`:

```aidl
// JobWorkItem.aidl
package android.app.job;

parcelable JobWorkItem;
```

`Bcore/src/main/aidl/android/content/IIntentReceiver.aidl`:

```aidl
package android.content;

import android.content.Intent;
import android.os.Bundle;

/**
 * System private API for dispatching intent broadcasts.  This is given to the
 * activity manager as part of registering for an intent broadcasts, and is
 * called when it receives intents.
 *
 */
interface IIntentReceiver {
    void performReceive(in Intent intent, int resultCode, String data,
            in Bundle extras, boolean ordered, boolean sticky, int sendingUser);
}

```

`Bcore/src/main/aidl/android/content/ISyncAdapter.aidl`:

```aidl
package android.content;

import android.accounts.Account;
import android.os.Bundle;
import android.content.ISyncContext;

/**
 * Interface used to control the sync activity on a SyncAdapter
 */
interface ISyncAdapter {
    /**
     * Initiate a sync for this account. SyncAdapter-specific parameters may
     * be specified in extras, which is guaranteed to not be null.
     *
     * @param syncContext the ISyncContext used to indicate the progress of the sync. When
     *   the sync is finished (successfully or not) ISyncContext.onFinished() must be called.
     * @param authority the authority that should be synced
     * @param account the account that should be synced
     * @param extras SyncAdapter-specific parameters
     */
    void startSync(ISyncContext syncContext, String authority,
      in Account account, in Bundle extras);

    /**
     * Cancel the most recently initiated sync. Due to race conditions, this may arrive
     * after the ISyncContext.onFinished() for that sync was called.
     * @param syncContext the ISyncContext that was passed to {@link #startSync}
     */
    void cancelSync(ISyncContext syncContext);

    /**
     * Initialize the SyncAdapter for this account and authority.
     *
     * @param account the account that should be synced
     * @param authority the authority that should be synced
     */
    void initialize(in Account account, String authority);
}

```

`Bcore/src/main/aidl/android/content/ISyncContext.aidl`:

```aidl
package android.content;

import android.content.SyncResult;

/**
 * Interface used by the SyncAdapter to indicate its progress.
 * @hide
 */
interface ISyncContext {
    /**
     * Call to indicate that the SyncAdapter is making progress. E.g., if this SyncAdapter
     * downloads or sends records to/from the server, this may be called after each record
     * is downloaded or uploaded.
     */
    void sendHeartbeat();

    /**
     * Signal that the corresponding sync session is completed.
     * @param result information about this sync session
     */
    void onFinished(in SyncResult result);
}

```

`Bcore/src/main/aidl/android/content/ISyncStatusObserver.aidl`:

```aidl
package android.content;

interface ISyncStatusObserver {
    void onStatusChanged(int which);
}

```

`Bcore/src/main/aidl/android/content/SyncStatusInfo.aidl`:

```aidl
package android.content;

parcelable SyncStatusInfo;
```

`Bcore/src/main/aidl/android/content/pm/IPackageDataObserver.aidl`:

```aidl
package android.content.pm;

/**
 * API for package data change related callbacks from the Package Manager.
 * Some usage scenarios include deletion of cache directory, generate
 * statistics related to code, data, cache usage(TODO)
 */
interface IPackageDataObserver {
    void onRemoveCompleted(in String packageName, boolean succeeded);
}

```

`Bcore/src/main/aidl/android/content/pm/IPackageDeleteObserver2.aidl`:

```aidl
package android.content.pm;

import android.content.Intent;

interface IPackageDeleteObserver2 {
    void onUserActionRequired(in Intent intent);
    void onPackageDeleted(String packageName, int returnCode, String msg);
}

```

`Bcore/src/main/aidl/android/content/pm/IPackageInstallObserver.aidl`:

```aidl
package android.content.pm;

/**
 * API for installation callbacks from the Package Manager.
 */
interface IPackageInstallObserver {
    void packageInstalled(in String packageName, int returnCode);
}

```

`Bcore/src/main/aidl/android/content/pm/IPackageInstallObserver2.aidl`:

```aidl
package android.content.pm;

import android.content.Intent;
import android.os.Bundle;

/**
 * API for installation callbacks from the Package Manager.  In certain result cases
 * additional information will be provided.
 */
interface IPackageInstallObserver2 {
    void onUserActionRequired(in Intent intent);

    /**
     * The install operation has completed.  {@code returnCode} holds a numeric code
     * indicating success or failure.  In certain cases the {@code extras} Bundle will
     * contain additional details:
     *
     * <p><table>
     * <tr>
     *   <td>INSTALL_FAILED_DUPLICATE_PERMISSION</td>
     *   <td>Two strings are provided in the extras bundle: EXTRA_EXISTING_PERMISSION
     *       is the name of the permission that the app is attempting to define, and
     *       EXTRA_EXISTING_PACKAGE is the package name of the app which has already
     *       defined the permission.</td>
     * </tr>
     * </table>
     */
    void onPackageInstalled(String basePackageName, int returnCode, String msg, in Bundle extras);
}

```

`Bcore/src/main/aidl/android/content/pm/IPackageInstallerCallback.aidl`:

```aidl
package android.content.pm;

interface IPackageInstallerCallback {
    void onSessionCreated(int sessionId);
    void onSessionBadgingChanged(int sessionId);
    void onSessionActiveChanged(int sessionId, boolean active);
    void onSessionProgressChanged(int sessionId, float progress);
    void onSessionFinished(int sessionId, boolean success);
}

```

`Bcore/src/main/aidl/android/content/pm/IPackageInstallerSession.aidl`:

```aidl
package android.content.pm;

import android.content.pm.IPackageInstallObserver2;
import android.content.IntentSender;
import android.os.ParcelFileDescriptor;

interface IPackageInstallerSession {
    void setClientProgress(float progress);
    void addClientProgress(float progress);

    String[] getNames();
    ParcelFileDescriptor openWrite(String name, long offsetBytes, long lengthBytes);
    ParcelFileDescriptor openRead(String name);

    void removeSplit(String splitName);

    void close();
    void commit(in IntentSender statusReceiver);
    void abandon();
}

```

`Bcore/src/main/aidl/android/database/IContentObserver.aidl`:

```aidl
package android.database;

import android.net.Uri;

interface IContentObserver {
    /**
     * This method is called when an update occurs to the cursor that is being
     * observed. selfUpdate is true if the update was caused by a call to
     * commit on the cursor that is being observed.
     */
    void onChange(boolean selfUpdate, in Uri uri, int userId);
}

```

`Bcore/src/main/aidl/android/location/ILocationListener.aidl`:

```aidl
// ILocationListener.aidl
package android.location;

import android.location.Location;
import android.os.Bundle;

interface ILocationListener {
    void onLocationChanged(in Location location);
    void onStatusChanged(String provider, int status, in Bundle extras);
    void onProviderEnabled(String provider);
    void onProviderDisabled(String provider);
}

```

`Bcore/src/main/aidl/android/net/IConnectivityManager.aidl`:

```aidl
package android.net;

import android.net.NetworkInfo;
import android.net.LinkProperties;

interface IConnectivityManager {
    NetworkInfo getActiveNetworkInfo();
    NetworkInfo getActiveNetworkInfoForUid(int uid, boolean ignoreBlocked);

    NetworkInfo getNetworkInfo(int networkType);
    NetworkInfo[] getAllNetworkInfo();
    boolean isActiveNetworkMetered();
    boolean requestRouteToHostAddress(int networkType, int address);
    LinkProperties getActiveLinkProperties();
    LinkProperties getLinkProperties(int networkType);
}

```

`Bcore/src/main/aidl/android/net/wifi/IWifiScanner.aidl`:

```aidl
package android.net.wifi;

import android.os.Messenger;
import android.os.Bundle;

interface IWifiScanner {
    Messenger getMessenger();
    Bundle getAvailableChannels(int band);
}

```

`Bcore/src/main/aidl/android/os/ISystemUpdateManager.aidl`:

```aidl
package android.os;

import android.os.Bundle;
import android.os.PersistableBundle;

interface ISystemUpdateManager {
    Bundle retrieveSystemUpdateInfo();
    void updateSystemUpdateInfo(in PersistableBundle data);
}

```

`Bcore/src/main/aidl/com/android/internal/widget/ILockSettings.aidl`:

```aidl
package com.android.internal.widget;

interface ILockSettings {
    void setRecoverySecretTypes(in int[] secretTypes);
    int[] getRecoverySecretTypes();
}

```

`Bcore/src/main/aidl/com/vcore/core/IBActivityThread.aidl`:

```aidl
// IBActivityThread.aidl
package com.vcore.core;

// Declare any non-default types here with import statements

import android.os.IBinder;
import android.content.ComponentName;
import android.content.Intent;
import java.util.List;
import android.content.pm.ResolveInfo;
import android.content.pm.ActivityInfo;
import com.vcore.entity.am.ReceiverData;

interface IBActivityThread {
    IBinder getActivityThread();
    void bindApplication();
    void restartJobService(String selfId);
    IBinder acquireContentProviderClient(in ProviderInfo providerInfo);

    IBinder peekService(in Intent intent);
    void stopService(in Intent componentName);

    void finishActivity(IBinder token);
    void handleNewIntent(IBinder token, in Intent intent);

    void scheduleReceiver(in ReceiverData data);
}

```

`Bcore/src/main/aidl/com/vcore/core/IEmpty.aidl`:

```aidl
// IBActivityThread.aidl
package com.vcore.core;

// Declare any non-default types here with import statements
interface IEmpty {

}

```

`Bcore/src/main/aidl/com/vcore/core/system/accounts/IBAccountManagerService.aidl`:

```aidl
package com.vcore.core.system.accounts;

import android.accounts.IAccountManagerResponse;
import android.accounts.Account;
import android.accounts.AuthenticatorDescription;
import android.content.IntentSender;
import android.os.Bundle;
import android.os.RemoteCallback;
import android.os.UserHandle;

import java.util.Map;

interface IBAccountManagerService {
    String getPassword(in Account account, int userId);
    String getUserData(in Account account, String key, int userId);
    AuthenticatorDescription[] getAuthenticatorTypes(int userId);
    Account[] getAccountsForPackage(String packageName, int uid, int userId);
    Account[] getAccountsByTypeForPackage(String type, String packageName, int userId);
    Account[] getAccountsAsUser(String accountType, int userId);
    void getAccountByTypeAndFeatures(in IAccountManagerResponse response, String accountType,
            in String[] features, int userId);
    void getAccountsByFeatures(in IAccountManagerResponse response, String accountType,
        in String[] features, int userId);
    boolean addAccountExplicitly(in Account account, String password, in Bundle extras, int userId);
    void removeAccountAsUser(in IAccountManagerResponse response, in Account account,
        boolean expectActivityLaunch, int userId);
    boolean removeAccountExplicitly(in Account account, int userId);
    void copyAccountToUser(in IAccountManagerResponse response, in Account account,
        int userFrom, int userTo);
    void invalidateAuthToken(String accountType, String authToken, int userId);
    String peekAuthToken(in Account account, String authTokenType, int userId);
    void setAuthToken(in Account account, String authTokenType, String authToken, int userId);
    void setPassword(in Account account, String password, int userId);
    void clearPassword(in Account account, int userId);
    void setUserData(in Account account, String key, String value, int userId);
    void updateAppPermission(in Account account, String authTokenType, int uid, boolean value);

    void getAuthToken(in IAccountManagerResponse response, in Account account,
        String authTokenType, boolean notifyOnAuthFailure, boolean expectActivityLaunch,
        in Bundle options, int userId);
    void addAccount(in IAccountManagerResponse response, String accountType,
            String authTokenType, in String[] requiredFeatures, boolean expectActivityLaunch,
            in Bundle options, int userId);
    void addAccountAsUser(in IAccountManagerResponse response, String accountType,
        String authTokenType, in String[] requiredFeatures, boolean expectActivityLaunch,
        in Bundle options, int userId);
    void updateCredentials(in IAccountManagerResponse response, in Account account,
        String authTokenType, boolean expectActivityLaunch, in Bundle options, int userId);
    void editProperties(in IAccountManagerResponse response, String accountType,
        boolean expectActivityLaunch, int userId);
    void confirmCredentialsAsUser(in IAccountManagerResponse response, in Account account,
        in Bundle options, boolean expectActivityLaunch, int userId);
    boolean accountAuthenticated(in Account account, int userId);
    void getAuthTokenLabel(in IAccountManagerResponse response, String accountType,
        String authTokenType, int userId);

    /* Returns Map<String, Integer> from package name to visibility with all values stored for given account */
    Map getPackagesAndVisibilityForAccount(in Account account, int userId);
    boolean addAccountExplicitlyWithVisibility(in Account account, String password, in Bundle extras,
            in Map visibility, int userId);
    boolean setAccountVisibility(in Account a, in String packageName, int newVisibility, int userId);
    int getAccountVisibility(in Account a, in String packageName, int userId);
    /* Type may be null returns Map <Account, Integer>*/
    Map getAccountsAndVisibilityForPackage(in String packageName, in String accountType, int userId);

    void registerAccountListener(in String[] accountTypes, String opPackageName, int userId);
    void unregisterAccountListener(in String[] accountTypes, String opPackageName, int userId);

    /* Check if the package in a user can access an account */
    // boolean hasAccountAccess(in Account account, String packageName, in UserHandle userHandle);
    /* Crate an intent to request account access for package and a given user id */
    // IntentSender createRequestAccountAccessIntentSenderAsUser(in Account account,
    // String packageName, in UserHandle userHandle);

    // void onAccountAccessed(String token);
}

```

`Bcore/src/main/aidl/com/vcore/core/system/am/IBActivityManagerService.aidl`:

```aidl
// IBActivityManagerService.aidl
package com.vcore.core.system.am;

import android.content.Intent;
import android.content.ComponentName;
import android.content.pm.ServiceInfo;
import android.content.pm.ProviderInfo;
import android.os.IBinder;
import java.lang.String;
import android.app.IServiceConnection;
import com.vcore.entity.AppConfig;
import  com.vcore.entity.UnbindRecord;
import android.os.Bundle;
import com.vcore.entity.am.RunningAppProcessInfo;
import com.vcore.entity.am.PendingResultData;
import com.vcore.entity.am.RunningServiceInfo;

// Declare any non-default types here with import statements
interface IBActivityManagerService {
    AppConfig initProcess(String packageName, String processName, int userId);
    void restartProcess(String packageName, String processName, int userId);

    void startActivity(in Intent intent, int userId);
    int startActivityAms(int userId, in Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags, in Bundle options);
    int startActivities(int userId, in Intent[] intent, in String[] resolvedType, IBinder resultTo, in Bundle options);

    ComponentName startService(in Intent intent, String resolvedType, boolean requireForeground, int userId);
    int stopService(in Intent intent,in String resolvedType, int userId);

    Intent bindService(in Intent service, in IBinder binder, String resolvedType, int userId);
    void unbindService(in IBinder binder, int userId);

    void stopServiceToken(in ComponentName className, in IBinder token, int userId);

    UnbindRecord onServiceUnbind(in Intent proxyIntent, int userId);
    void onServiceDestroy(in Intent proxyIntent, int userId);

    IBinder acquireContentProviderClient(in ProviderInfo providerInfo);
    Intent sendBroadcast(in Intent intent, String resolvedType, int userId);
    IBinder peekService(in Intent intent, String resolvedType, int userId);

    void onActivityCreated(int taskId, IBinder token, String activityToken);
    void onActivityResumed(IBinder token);
    void onActivityDestroyed(IBinder token);
    void onFinishActivity(IBinder token);

    RunningAppProcessInfo getRunningAppProcesses(String callerPackage, int userId);
    RunningServiceInfo getRunningServices(String callerPackage, int userId);

    void scheduleBroadcastReceiver(in Intent intent, in PendingResultData pendingResultData, int userId);
    void finishBroadcast(in PendingResultData data);

    String getCallingPackage(in IBinder token, int userId);
    ComponentName getCallingActivity(in IBinder token, int userId);

    void getIntentSender(in IBinder target, String packageName, int uid, int userId);
    String getPackageForIntentSender(in IBinder target, int userId);
    int getUidForIntentSender(in IBinder target, int userId);
}

```

`Bcore/src/main/aidl/com/vcore/core/system/am/IBJobManagerService.aidl`:

```aidl
// IBJobManagerService.aidl
package com.vcore.core.system.am;

import android.content.Intent;
import android.content.ComponentName;
import android.os.IBinder;
import java.lang.String;
import android.app.job.JobInfo;
import com.vcore.entity.JobRecord;

// Declare any non-default types here with import statements
interface IBJobManagerService {
    JobInfo schedule(in JobInfo info, int userId);
    JobRecord queryJobRecord(String processName, int jobId, int userId);
    void cancelAll(String processName, int userId);
    int cancel(String processName, int jobId, int userId);
}

```

`Bcore/src/main/aidl/com/vcore/core/system/device/IDeviceManagerService.aidl`:

```aidl
// IDeviceManagerService.aidl
package com.vcore.core.system.device;

// Declare any non-default types here with import statements
interface IDeviceManagerService {
    /**
     * Demonstrates some basic types that you can use as parameters
     * and return values in AIDL.
     */
    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
            double aDouble, String aString);
}
```

`Bcore/src/main/aidl/com/vcore/core/system/location/IBLocationManagerService.aidl`:

```aidl
// IFakeLocationManager.aidl
package com.vcore.core.system.location;

import com.vcore.entity.location.BLocation;
import com.vcore.entity.location.BCell;

import java.util.List;

interface IBLocationManagerService {
    int getPattern(int userId, String pkg);

    void setPattern(int userId, String pkg, int mode);

    void setCell(int userId, String pkg,in  BCell cell);

    void setAllCell(int userId, String pkg,in  List<BCell> cell);

    void setNeighboringCell(int userId, String pkg,in  List<BCell> cells);
    List<BCell> getNeighboringCell(int userId, String pkg);

    void setGlobalCell(in BCell cell);

    void setGlobalAllCell(in List<BCell> cell);

    void setGlobalNeighboringCell(in List<BCell> cell);

    List<BCell> getGlobalNeighboringCell();

    BCell getCell(int userId, String pkg);

    List<BCell> getAllCell(int userId, String pkg);

    void setLocation(int userId, String pkg,in  BLocation location);

    BLocation getLocation(int userId, String pkg);

    void setGlobalLocation(in BLocation location);

    BLocation getGlobalLocation();

    void requestLocationUpdates(in IBinder listener, String packageName, int userId);

    void removeUpdates(in IBinder listener);
}
```

`Bcore/src/main/aidl/com/vcore/core/system/notification/IBNotificationManagerService.aidl`:

```aidl
// IBNotificationManagerService.aidl
package com.vcore.core.system.notification;

// Declare any non-default types here with import statements
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationChannelGroup;

interface IBNotificationManagerService {
    NotificationChannel getNotificationChannel(String channelId, int userId);

    List<NotificationChannel> getNotificationChannels(String packageName, int userId);

    List<NotificationChannelGroup> getNotificationChannelGroups(String packageName, int userId);

    void createNotificationChannel(in NotificationChannel notificationChannel, int userId);

    void deleteNotificationChannel(String channelId, int userId);

    void createNotificationChannelGroup(in NotificationChannelGroup notificationChannelGroup, int userId);

    void deleteNotificationChannelGroup(String groupId, int userId);

    void enqueueNotificationWithTag(int id, String tag, in Notification notification, int userId);

    void cancelNotificationWithTag(int id, String tag, int userId);
}
```

`Bcore/src/main/aidl/com/vcore/core/system/os/IBStorageManagerService.aidl`:

```aidl
// IBStorageManagerService.aidl
package com.vcore.core.system.os;

import android.os.storage.StorageVolume;
import java.lang.String;
import android.net.Uri;

// Declare any non-default types here with import statements
interface IBStorageManagerService {
      StorageVolume[] getVolumeList(int uid, String packageName, int flags, int userId);
      Uri getUriForFile(String file);
}

```

`Bcore/src/main/aidl/com/vcore/core/system/pm/BPackageSettings.aidl`:

```aidl
// BPackageSettings.aidl
package com.vcore.core.system.pm;

// Declare any non-default types here with import statements
parcelable BPackageSettings;
```

`Bcore/src/main/aidl/com/vcore/core/system/pm/IBPackageInstallerService.aidl`:

```aidl
// IBPackageInstallerService.aidl
package com.vcore.core.system.pm;

import  com.vcore.core.system.pm.BPackageSettings;
import com.vcore.entity.pm.InstallOption;

// Declare any non-default types here with import statements
interface IBPackageInstallerService {
    int installPackageAsUser(in BPackageSettings ps, int userId);
    int uninstallPackageAsUser(in BPackageSettings ps, boolean removeApp, int userId);
    int clearPackage(in BPackageSettings ps, int userId);
    int updatePackage(in BPackageSettings ps);
}

```

`Bcore/src/main/aidl/com/vcore/core/system/pm/IBPackageManagerService.aidl`:

```aidl
// IBPackageManagerService.aidl
package com.vcore.core.system.pm;

// Declare any non-default types here with import statements
import android.content.pm.ApplicationInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.PackageInfo;
import android.content.pm.ServiceInfo;
import android.content.pm.ActivityInfo;
import android.content.pm.ProviderInfo;
import android.content.Intent;
import android.content.ComponentName;
import java.util.List;
import com.vcore.entity.pm.InstallResult;
import com.vcore.entity.pm.InstallOption;
import com.vcore.entity.pm.InstalledPackage;

interface IBPackageManagerService {
    int getUidByPid(int pid);

    ResolveInfo resolveService(in Intent intent, int flags, String resolvedType, int userId);
    ResolveInfo resolveActivity(in Intent intent, int flags, String resolvedType, int userId);
    ProviderInfo resolveContentProvider(String authority, int flag, int userId);
    ResolveInfo resolveIntent(in Intent intent, String resolvedType, int flags, int userId);

    ApplicationInfo getApplicationInfo(String packageName, int flags, int userId);
    PackageInfo getPackageInfo(String packageName, int flags, int userId);
    ServiceInfo getServiceInfo(in ComponentName component, int flags, int userId);
    ActivityInfo getReceiverInfo(in ComponentName componentName, int flags, int userId);
    ActivityInfo getActivityInfo(in ComponentName component, int flags, int userId);
    ProviderInfo getProviderInfo(in ComponentName component, int flags, int userId);
    List<ApplicationInfo> getInstalledApplications(int flags, int userId);
    List<PackageInfo> getInstalledPackages(int flags, int userId);

    List<ResolveInfo> queryIntentActivities(in Intent intent, int flags, String resolvedType, int userId);
    List<ResolveInfo> queryBroadcastReceivers(in Intent intent, int flags, String resolvedType, int userId);
    List<ResolveInfo> queryIntentServices(in Intent intent, int flags, int userId);
    List<ProviderInfo> queryContentProviders(String processName, int uid, int flags, int userId);

    InstallResult installPackageAsUser(String file, in InstallOption option, int userId);
    void uninstallPackageAsUser(String packageName, int userId);
    void uninstallPackage(String packageName);
    void clearPackage(String packageName, int userId);
    void stopPackage(String packageName, int userId);
    void deleteUser(int userId);

    boolean isInstalled(String packageName, int userId);
    List<InstalledPackage> getInstalledPackagesAsUser(int userId);
    String[] getPackagesForUid(int uid, int userId);
}

```

`Bcore/src/main/aidl/com/vcore/core/system/pm/IBXposedManagerService.aidl`:

```aidl
// IBXposedManagerService.aidl

package com.vcore.core.system.pm;

import java.util.List;
import com.vcore.entity.pm.InstalledModule;

interface IBXposedManagerService {
    boolean isXPEnable();
    void setXPEnable(boolean enable);
    boolean isModuleEnable(String packageName);
    void setModuleEnable(String packageName, boolean enable);
    List<InstalledModule> getInstalledModules();
}
```

`Bcore/src/main/aidl/com/vcore/core/system/user/BUserInfo.aidl`:

```aidl
// BUserInfo.aidl
package com.vcore.core.system.user;

// Declare any non-default types here with import statements
parcelable BUserInfo;

```

`Bcore/src/main/aidl/com/vcore/core/system/user/IBUserManagerService.aidl`:

```aidl
// IBUserManagerService.aidl
package com.vcore.core.system.user;

// Declare any non-default types here with import statements
import com.vcore.core.system.user.BUserInfo;
import java.util.List;

interface IBUserManagerService {
    BUserInfo getUserInfo(int userId);
    boolean exists(int userId);
    BUserInfo createUser(int userId);
    List<BUserInfo> getUsers();
    void deleteUser(int userId);
}

```

`Bcore/src/main/aidl/com/vcore/entity/AppConfig.aidl`:

```aidl
// AppConfig.aidl
package com.vcore.entity;

// Declare any non-default types here with import statements
parcelable AppConfig;
```

`Bcore/src/main/aidl/com/vcore/entity/JobRecord.aidl`:

```aidl
// JobRecord.aidl
package com.vcore.entity;

// Declare any non-default types here with import statements
parcelable JobRecord;
```

`Bcore/src/main/aidl/com/vcore/entity/UnbindRecord.aidl`:

```aidl
package com.vcore.entity;

parcelable UnbindRecord;
```

`Bcore/src/main/aidl/com/vcore/entity/am/PendingResultData.aidl`:

```aidl
package com.vcore.entity.am;

parcelable PendingResultData;
```

`Bcore/src/main/aidl/com/vcore/entity/am/ReceiverData.aidl`:

```aidl
package com.vcore.entity.am;

parcelable ReceiverData;
```

`Bcore/src/main/aidl/com/vcore/entity/am/RunningAppProcessInfo.aidl`:

```aidl
package com.vcore.entity.am;

parcelable RunningAppProcessInfo;
```

`Bcore/src/main/aidl/com/vcore/entity/am/RunningServiceInfo.aidl`:

```aidl
package com.vcore.entity.am;

parcelable RunningServiceInfo;
```

`Bcore/src/main/aidl/com/vcore/entity/device/BDeviceConfig.aidl`:

```aidl
// BDeviceConfig.aidl
package com.vcore.entity.device;

// Declare any non-default types here with import statements
parcelable BDeviceConfig;
```

`Bcore/src/main/aidl/com/vcore/entity/location/BCell.aidl`:

```aidl
package com.vcore.entity.location;

parcelable BCell;
```

`Bcore/src/main/aidl/com/vcore/entity/location/BLocation.aidl`:

```aidl
package com.vcore.entity.location;

// Declare any non-default types here with import statements
parcelable BLocation;
```

`Bcore/src/main/aidl/com/vcore/entity/location/BLocationConfig.aidl`:

```aidl
package com.vcore.entity.location;

parcelable BLocationConfig;
```

`Bcore/src/main/aidl/com/vcore/entity/pm/InstallOption.aidl`:

```aidl
package com.vcore.entity.pm;

parcelable InstallOption;
```

`Bcore/src/main/aidl/com/vcore/entity/pm/InstallResult.aidl`:

```aidl
package com.vcore.entity.pm;

parcelable InstallResult;
```

`Bcore/src/main/aidl/com/vcore/entity/pm/InstalledModule.aidl`:

```aidl
package com.vcore.entity.pm;

parcelable InstalledModule;
```

`Bcore/src/main/aidl/com/vcore/entity/pm/InstalledPackage.aidl`:

```aidl
package com.vcore.entity.pm;

parcelable InstalledPackage;
```

`Bcore/src/main/cpp/BoxCore.cpp`:

```cpp
#define CORE_CLASS "com/vcore/core/NativeCore"
#include "BoxCore.h"
#include "Log.h"
#include "IO.h"
#include <jni.h>
#include "JniHook/JniHook.h"
#include "Hook/VMClassLoaderHook.h"
#include "Hook/UnixFileSystemHook.h"
#include "Hook/LinuxHook.h"
#include "Hook/SystemPropertiesHook.h"
#include "Hook/BinderHook.h"
#include "Hook/RuntimeHook.h"

struct {
    JavaVM *vm;
    jclass NativeCoreClass;
    jmethodID getCallingUidId;
    jmethodID redirectPathString;
    jmethodID redirectPathFile;
    int api_level;
} VMEnv;

JNIEnv *getEnv() {
    JNIEnv *env;
    VMEnv.vm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_6);
    return env;
}

JNIEnv *ensureEnvCreated() {
    JNIEnv *env = getEnv();
    if (env == nullptr) {
        VMEnv.vm->AttachCurrentThread(&env, nullptr);
    }
    return env;
}

int BoxCore::getCallingUid(int orig) {
    JNIEnv *env = ensureEnvCreated();
    return env->CallStaticIntMethod(VMEnv.NativeCoreClass, VMEnv.getCallingUidId, orig);
}

jstring BoxCore::redirectPathString(JNIEnv *env, jstring path) {
    env = ensureEnvCreated();
    return (jstring) env->CallStaticObjectMethod(VMEnv.NativeCoreClass, VMEnv.redirectPathString, path);
}

jobject BoxCore::redirectPathFile(JNIEnv *env, jobject path) {
    env = ensureEnvCreated();
    return env->CallStaticObjectMethod(VMEnv.NativeCoreClass, VMEnv.redirectPathFile, path);
}

int BoxCore::getApiLevel() {
    return VMEnv.api_level;
}

JavaVM *BoxCore::getJavaVM() {
    return VMEnv.vm;
}

void nativeHook(JNIEnv *env) {
    BaseHook::init(env);
    UnixFileSystemHook::init(env);
    LinuxHook::init(env);
    VMClassLoaderHook::init(env);

    // SystemPropertiesHook会引起小米k40，安卓11上的抖音崩溃
   // SystemPropertiesHook::init(env);
    RuntimeHook::init(env);
    BinderHook::init(env);
}

void hideXposed(JNIEnv *env, jclass clazz) {
    ALOGD("Hiding Xposed!");
    VMClassLoaderHook::hideXposed();
}

void init(JNIEnv *env, jobject clazz, jint api_level) {
    ALOGD("NativeCore init.");
    VMEnv.api_level = api_level;
    VMEnv.NativeCoreClass = (jclass) env->NewGlobalRef(env->FindClass(CORE_CLASS));
    VMEnv.getCallingUidId = env->GetStaticMethodID(VMEnv.NativeCoreClass, "getCallingUid", "(I)I");
    VMEnv.redirectPathString = env->GetStaticMethodID(VMEnv.NativeCoreClass, "redirectPath", "(Ljava/lang/String;)Ljava/lang/String;");
    VMEnv.redirectPathFile = env->GetStaticMethodID(VMEnv.NativeCoreClass, "redirectPath", "(Ljava/io/File;)Ljava/io/File;");
    JniHook::InitJniHook(env, api_level);
}

// IO类添加重定向规则
void addIORule(JNIEnv *env, jclass clazz, jstring target_path, jstring relocate_path) {
    IO::addRule(env->GetStringUTFChars(target_path, JNI_FALSE),env->GetStringUTFChars(relocate_path, JNI_FALSE));
}

// IO类添加白名单规则
void addWhiteList(JNIEnv *env, jclass clazz, jstring path) {
    IO::addWhiteList(env->GetStringUTFChars(path, JNI_FALSE));
}

void enableIO(JNIEnv *env, jclass clazz) {
    nativeHook(env);
}

static JNINativeMethod gMethods[] = {
    {"hideXposed", "()V", (void *) hideXposed},
    {"addIORule", "(Ljava/lang/String;Ljava/lang/String;)V", (void *) addIORule},
    {"enableIO", "()V", (void *) enableIO},
    {"init", "(I)V", (void *) init},
    {"addWhiteList", "(Ljava/lang/String;)V", (void *) addWhiteList},
};

int registerNativeMethods(JNIEnv *env, const char *className,JNINativeMethod *gMethods, int numMethods) {
    jclass clazz;
    clazz = env->FindClass(className);
    if (clazz == nullptr) {
        return JNI_FALSE;
    }

    if (env->RegisterNatives(clazz, gMethods, numMethods) < 0) {
        return JNI_FALSE;
    }
    return JNI_TRUE;
}

int registerNatives(JNIEnv *env) {
    if (!registerNativeMethods(env, CORE_CLASS, gMethods, sizeof(gMethods) / sizeof(gMethods[0]))) {
        return JNI_FALSE;
    }
    return JNI_TRUE;
}

void registerMethod(JNIEnv *jenv) {
    registerNatives(jenv);
}

JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env;
    VMEnv.vm = vm;
    if (vm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_6) != JNI_OK) {
        return JNI_EVERSION;
    }
    registerMethod(env);
    return JNI_VERSION_1_6;
}

```

`Bcore/src/main/cpp/BoxCore.h`:

```h
#ifndef BLACKBOX_BOXCORE_H
#define BLACKBOX_BOXCORE_H

#include <jni.h>
#include <unistd.h>


class BoxCore {
public:
    static JavaVM *getJavaVM();
    static int getApiLevel();
    static int getCallingUid(int orig);
    static jstring redirectPathString(JNIEnv *env, jstring path);
    static jobject redirectPathFile(JNIEnv *env, jobject path);
    static void replaceFD(JNIEnv *env, jobject fd);
};


#endif // BLACKBOX_BOXCORE_H

```

`Bcore/src/main/cpp/CMakeLists.txt`:

```txt
# For more information about using CMake with Android Studio, read the
# documentation: https://d.android.com/studio/projects/add-native-code.html

# Sets the minimum version of CMake required to build the native library.

cmake_minimum_required(VERSION 3.4.1)
enable_language(ASM)
project(vcore)

# Creates and names a library, sets it as either STATIC
# or SHARED, and provides the relative paths to its source code.
# You can define multiple libraries, and CMake builds them for you.
# Gradle automatically packages shared libraries with your APK.
include_directories(JniHook)
include_directories(./)
aux_source_directory(./ SRC1)
aux_source_directory(Hook SRC2)
aux_source_directory(JniHook SRC3)
add_compile_options(-w)

add_library( # Sets the name of the library.
        vcore
        # Sets the library as a shared library.
        SHARED
        # Provides a relative path to your source file(s).
        BoxCore.cpp
        ${SRC1}
        ${SRC2}
        ${SRC3})

# Searches for a specified prebuilt library and stores the path as a
# variable. Because CMake includes system libraries in the search path by
# default, you only need to specify the name of the public NDK library
# you want to add. CMake verifies that the library exists before
# completing its build.

find_library( # Sets the name of the path variable.
        log-lib

        # Specifies the name of the NDK library that
        # you want CMake to locate.
        log)

# Specifies libraries CMake should link to your target library. You
# can link multiple libraries, such as libraries you define in this
# build script, prebuilt third-party libraries, or system libraries.
find_package(shadowhook REQUIRED CONFIG)
target_link_libraries( # Specifies the target library.
        vcore
        # Links the target library to the log library
        # included in the NDK.
        ${log-lib}
        z
        shadowhook::shadowhook)
```

`Bcore/src/main/cpp/Hook/BaseHook.cpp`:

```cpp
#include "BaseHook.h"

void BaseHook::init(JNIEnv *env) {

}

```

`Bcore/src/main/cpp/Hook/BaseHook.h`:

```h
#ifndef BLACKBOX_BASEHOOK_H
#define BLACKBOX_BASEHOOK_H

#include <jni.h>
#include <Log.h>

class BaseHook {
public:
    static void init(JNIEnv *env);
};

#endif // BLACKBOX_BASEHOOK_H

```

`Bcore/src/main/cpp/Hook/BinderHook.cpp`:

```cpp
#include "BinderHook.h"
#include <IO.h>
#include <BoxCore.h>
#include "UnixFileSystemHook.h"
#import "JniHook/JniHook.h"

HOOK_JNI(jint, getCallingUid, JNIEnv *env, jobject obj) {
    int orig = orig_getCallingUid(env, obj);
    return BoxCore::getCallingUid(orig);
}

void BinderHook::init(JNIEnv *env) {
    const char *clazz = "android/os/Binder";
    JniHook::HookJniFun(env, clazz, "getCallingUid", "()I", (void *) new_getCallingUid, (void **) (&orig_getCallingUid), true);
}

```

`Bcore/src/main/cpp/Hook/BinderHook.h`:

```h
#ifndef BLACKBOX_BINDERHOOK_H
#define BLACKBOX_BINDERHOOK_H

#include "BaseHook.h"

class BinderHook : public BaseHook{
public:
    static void init(JNIEnv *env);
};

#endif // BLACKBOX_BINDERHOOK_H

```

`Bcore/src/main/cpp/Hook/LinuxHook.cpp`:

```cpp
#include "LinuxHook.h"
#import "JniHook/JniHook.h"
#include "IO.h"

HOOK_JNI(jboolean, access, JNIEnv *env, jobject obj, jstring path, jint mode) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_access(env, obj, redirect, mode);
}

HOOK_JNI(void, chmod, JNIEnv *env, jobject obj, jstring path, jint mode) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_chmod(env, obj, redirect, mode);
}

HOOK_JNI(void, chown, JNIEnv *env, jobject obj, jstring path, jint mode, jint gid) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_chown(env, obj, redirect, mode, gid);
}

HOOK_JNI(void, execv, JNIEnv *env, jobject obj, jstring filename, jobjectArray argv) {
    jstring redirect = IO::redirectPath(env, filename);
    return orig_execv(env, obj, redirect, argv);
}

HOOK_JNI(void, execve, JNIEnv *env, jobject obj, jstring filename, jobjectArray argv, jobjectArray envp) {
    jstring redirect = IO::redirectPath(env, filename);
    return orig_execve(env, obj, redirect, argv, envp);
}

HOOK_JNI(jbyteArray, getxattr, JNIEnv *env, jobject obj, jstring path, jstring name) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_getxattr(env, obj, redirect, name);
}

HOOK_JNI(void, lchown, JNIEnv *env, jobject obj, jstring path, jint uid, jint gid) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_lchown(env, obj, redirect, uid, gid);
}

HOOK_JNI(void, link, JNIEnv *env, jobject obj, jstring oldPath, jstring newPath) {
    jstring redirectOldPath = IO::redirectPath(env, oldPath);
    jstring redirectNewPath = IO::redirectPath(env, newPath);
    return orig_link(env, obj, redirectOldPath, redirectNewPath);
}

HOOK_JNI(jobjectArray, listxattr, JNIEnv *env, jobject obj, jstring path) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_listxattr(env, obj, redirect);
}

HOOK_JNI(jobject, lstat, JNIEnv *env, jobject obj, jstring path) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_lstat(env, obj, redirect);
}

HOOK_JNI(void, mkdir, JNIEnv *env, jobject obj, jstring path, jint mode) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_mkdir(env, obj, redirect, mode);
}

HOOK_JNI(void, mkfifo, JNIEnv *env, jobject obj, jstring path, jint mode) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_mkfifo(env, obj, redirect, mode);
}

HOOK_JNI(jobject, open, JNIEnv *env, jobject obj, jstring path, jint flags, jint mode) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_open(env, obj, redirect, flags, mode);
}

HOOK_JNI(jstring, readlink, JNIEnv *env, jobject obj, jstring path) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_readlink(env, obj, redirect);
}

HOOK_JNI(jstring, realpath, JNIEnv *env, jobject obj, jstring path) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_realpath(env, obj, redirect);
}

HOOK_JNI(void, remove, JNIEnv *env, jobject obj, jstring path) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_remove(env, obj, redirect);
}

HOOK_JNI(void, removexattr, JNIEnv *env, jobject obj, jstring path, jstring name) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_removexattr(env, obj, redirect, name);
}

HOOK_JNI(void, rename, JNIEnv *env, jobject obj, jstring oldPath, jstring newPath) {
    jstring redirectOldPath = IO::redirectPath(env, oldPath);
    jstring redirectNewPath = IO::redirectPath(env, newPath);
    return orig_rename(env, obj, redirectOldPath, redirectNewPath);
}

HOOK_JNI(void, setxattr, JNIEnv *env, jobject obj, jstring path, jstring name, jbyteArray value, jint flags) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_setxattr(env, obj, redirect, name, value, flags);
}

HOOK_JNI(jobject, stat, JNIEnv *env, jobject obj, jstring path) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_stat(env, obj, redirect);
}

HOOK_JNI(jobject, statvfs, JNIEnv *env, jobject obj, jstring path) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_statvfs(env, obj, redirect);
}

HOOK_JNI(void, symlink, JNIEnv *env, jobject obj, jstring oldPath, jstring newPath) {
    jstring redirectOldPath = IO::redirectPath(env, oldPath);
    jstring redirectNewPath = IO::redirectPath(env, newPath);
    return orig_symlink(env, obj, redirectOldPath, redirectNewPath);
}

HOOK_JNI(void, unlink, JNIEnv *env, jobject obj, jstring pathname) {
    jstring redirect = IO::redirectPath(env, pathname);
    return orig_unlink(env, obj, redirect);
}

void LinuxHook::init(JNIEnv *env) {
    JniHook::HookJniFun(env, "libcore/io/Linux", "access", "(Ljava/lang/String;I)Z",
                        (void *) new_access, (void **) (&orig_access), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "chmod", "(Ljava/lang/String;I)V",
                        (void *) new_chmod, (void **) (&orig_chmod), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "chown", "(Ljava/lang/String;II)V",
                        (void *) new_chown, (void **) (&orig_chown), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "execv", "(Ljava/lang/String;[Ljava/lang/String;)V",
                        (void *) new_execv, (void **) (&orig_execv), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "execve", "(Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)V",
                        (void *) new_execve, (void **) (&orig_execve), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "getxattr", "(Ljava/lang/String;Ljava/lang/String;)[B",
                        (void *) new_getxattr, (void **) (&orig_getxattr), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "lchown", "(Ljava/lang/String;II)V",
                        (void *) new_lchown, (void **) (&orig_lchown), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "link", "(Ljava/lang/String;Ljava/lang/String;)V",
                        (void *) new_link, (void **) (&orig_link), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "listxattr", "(Ljava/lang/String;)[Ljava/lang/String;",
                        (void *) new_listxattr, (void **) (&orig_listxattr), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "lstat", "(Ljava/lang/String;)Landroid/system/StructStat;",
                        (void *) new_lstat, (void **) (&orig_lstat), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "mkdir", "(Ljava/lang/String;I)V",
                        (void *) new_mkdir, (void **) (&orig_mkdir), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "mkfifo", "(Ljava/lang/String;I)V",
                        (void *) new_mkfifo, (void **) (&orig_mkfifo), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "open", "(Ljava/lang/String;II)Ljava/io/FileDescriptor;",
                        (void *) new_open, (void **) (&orig_open), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "readlink", "(Ljava/lang/String;)Ljava/lang/String;",
                        (void *) new_readlink, (void **) (&orig_readlink), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "realpath", "(Ljava/lang/String;)Ljava/lang/String;",
                        (void *) new_realpath, (void **) (&orig_realpath), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "remove", "(Ljava/lang/String;)V",
                        (void *) new_remove, (void **) (&orig_remove), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "removexattr", "(Ljava/lang/String;Ljava/lang/String;)V",
                        (void *) new_removexattr, (void **) (&orig_removexattr), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "rename", "(Ljava/lang/String;Ljava/lang/String;)V",
                        (void *) new_rename, (void **) (&orig_rename), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "stat", "(Ljava/lang/String;)Landroid/system/StructStat;",
                        (void *) new_stat, (void **) (&orig_stat), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "statvfs", "(Ljava/lang/String;)Landroid/system/StructStatVfs;",
                        (void *) new_statvfs, (void **) (&orig_statvfs), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "symlink", "(Ljava/lang/String;Ljava/lang/String;)V",
                        (void *) new_symlink, (void **) (&orig_symlink), false);

    JniHook::HookJniFun(env, "libcore/io/Linux", "unlink", "(Ljava/lang/String;)V",
                        (void *) new_unlink, (void **) (&orig_unlink), false);
}

```

`Bcore/src/main/cpp/Hook/LinuxHook.h`:

```h
#ifndef BLACKBOX_LINUXHOOK_H
#define BLACKBOX_LINUXHOOK_H

#include "BaseHook.h"

class LinuxHook : public BaseHook {
public:
    static void init(JNIEnv *env);
};

#endif // BLACKBOX_LINUXHOOK_H

```

`Bcore/src/main/cpp/Hook/RuntimeHook.cpp`:

```cpp
#include "RuntimeHook.h"
#import "JniHook/JniHook.h"
#include "BoxCore.h"

HOOK_JNI(jstring, nativeLoad, JNIEnv *env, jobject obj, jstring name, jobject class_loader) {
    const char *nameC = env->GetStringUTFChars(name, JNI_FALSE);
    ALOGD("nativeLoad: %s", nameC);
    jstring result = orig_nativeLoad(env, obj, name, class_loader);
    env->ReleaseStringUTFChars(name, nameC);
    return result;
}

HOOK_JNI(jstring, nativeLoadNew, JNIEnv *env, jobject obj, jstring name, jobject class_loader,
         jobject caller) {
    const char *nameC = env->GetStringUTFChars(name, JNI_FALSE);
    ALOGD("nativeLoad: %s", nameC);
    jstring result = orig_nativeLoadNew(env, obj, name, class_loader, caller);
    env->ReleaseStringUTFChars(name, nameC);
    return result;
}

void RuntimeHook::init(JNIEnv *env) {
    const char *className = "java/lang/Runtime";
    if (BoxCore::getApiLevel() >= __ANDROID_API_Q__) {
        JniHook::HookJniFun(env, className, "nativeLoad","(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/Class;)Ljava/lang/String;",
                            (void *) new_nativeLoadNew, (void **) (&orig_nativeLoadNew), true);
    } else {
        JniHook::HookJniFun(env, className, "nativeLoad","(Ljava/lang/String;Ljava/lang/ClassLoader;)Ljava/lang/String;",
                            (void *) new_nativeLoad, (void **) (&orig_nativeLoad), true);
    }
}

```

`Bcore/src/main/cpp/Hook/RuntimeHook.h`:

```h
#ifndef BLACKBOX_RUNTIMEHOOK_H
#define BLACKBOX_RUNTIMEHOOK_H

#include "BaseHook.h"
#include <jni.h>

class RuntimeHook : public BaseHook {
public:
    static void init(JNIEnv *env);
};

#endif // BLACKBOX_RUNTIMEHOOK_H

```

`Bcore/src/main/cpp/Hook/SystemPropertiesHook.cpp`:

```cpp
#include <shadowhook.h>
#include "SystemPropertiesHook.h"
#include "IO.h"
#include "BoxCore.h"
#import "JniHook/JniHook.h"
#include "Log.h"

static std::map<std::string, std::string> prop_map;

HOOK_JNI(jstring, native_get, JNIEnv *env, jobject obj, jstring key, jstring def) {
    const char *key_str = env->GetStringUTFChars(key, JNI_FALSE);
    const char *def_str = env->GetStringUTFChars(def, JNI_FALSE);
    if (key == nullptr || def == nullptr) {
        return orig_native_get(env, obj, key, def);
    }

    auto ret = prop_map.find(key_str);
    if (ret != prop_map.end()) {
        const char *ret_value = ret->second.c_str();
        return env->NewStringUTF(ret_value);
    }

    env->ReleaseStringUTFChars(key, key_str);
    env->ReleaseStringUTFChars(key, def_str);
    return orig_native_get(env, obj, key, def);
}

HOOK_JNI(int, __system_property_get, const char *name, char *value) {
    if (name == nullptr || value == nullptr) {
        return orig___system_property_get(name, value);
    }

    ALOGD(name, value);
    auto ret = prop_map.find(name);
    if (ret != prop_map.end()) {
        const char *ret_value = ret->second.c_str();
        strcpy(value, ret_value);
        return strlen(ret_value);
    }
    return orig___system_property_get(name, value);
}

void SystemPropertiesHook::init(JNIEnv *env) {
    prop_map.insert(map<std::string, std::string>::value_type("ro.product.board", "umi"));
    prop_map.insert(map<std::string, std::string>::value_type("ro.product.brand", "Xiaomi"));
    prop_map.insert(map<std::string, std::string>::value_type("ro.product.device", "umi"));
    prop_map.insert(map<std::string, std::string>::value_type("ro.build.display.id","QKQ1.191117.002 test-keys"));
    prop_map.insert(map<std::string, std::string>::value_type("ro.build.host", "c5-miui-ota-bd074.bj"));
    prop_map.insert(map<std::string, std::string>::value_type("ro.build.id", "QKQ1.191117.002"));
    prop_map.insert(map<std::string, std::string>::value_type("ro.product.manufacturer", "Xiaomi"));
    prop_map.insert(map<std::string, std::string>::value_type("ro.product.model", "Mi 10"));
    prop_map.insert(map<std::string, std::string>::value_type("ro.product.name", "umi"));
    prop_map.insert(map<std::string, std::string>::value_type("ro.build.tags", "release-keys"));
    prop_map.insert(map<std::string, std::string>::value_type("ro.build.type", "user"));
    prop_map.insert(map<std::string, std::string>::value_type("ro.build.user", "builder"));
    JniHook::HookJniFun(env, "android/os/SystemProperties","native_get", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                        (void *) new_native_get, (void **) (&orig_native_get), true);
    shadowhook_hook_sym_name("libc.so", "__system_property_get",(void *)new___system_property_get,(void **) &orig___system_property_get);
}
```

`Bcore/src/main/cpp/Hook/SystemPropertiesHook.h`:

```h
#ifndef BLACKBOX_SYSTEMPROPERTIESHOOK_H
#define BLACKBOX_SYSTEMPROPERTIESHOOK_H

#include <map>
#include "BaseHook.h"
#include <string>

class SystemPropertiesHook : public BaseHook{
public:
    static void init(JNIEnv *env);
};

#endif // BLACKBOX_SYSTEMPROPERTIESHOOK_H

```

`Bcore/src/main/cpp/Hook/UnixFileSystemHook.cpp`:

```cpp
#include <IO.h>
#include "UnixFileSystemHook.h"
#import "JniHook/JniHook.h"
#include "BaseHook.h"

/*
 * Class:     java_io_UnixFileSystem
 * Method:    canonicalize0
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
HOOK_JNI(jstring, canonicalize0, JNIEnv *env, jobject obj, jstring path) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_canonicalize0(env, obj, redirect);
}

/*
 * Class:     java_io_UnixFileSystem
 * Method:    getLastModifiedTime0
 * Signature: (Ljava/io/File;)J
 */
HOOK_JNI(jlong, getLastModifiedTime0, JNIEnv *env, jobject obj, jobject path) {
    jobject redirect = IO::redirectPath(env, path);
    return orig_getLastModifiedTime0(env, obj, redirect);
}

/*
 * Class:     java_io_UnixFileSystem
 * Method:    setPermission0
 * Signature: (Ljava/io/File;IZZ)Z
 */
HOOK_JNI(jboolean, setPermission0, JNIEnv *env, jobject obj, jobject file, jint access,
         jboolean enable, jboolean owneronly) {
    jobject redirect = IO::redirectPath(env, file);
    return orig_setPermission0(env, obj, redirect, access, enable, owneronly);
}

/*
 * Class:     java_io_UnixFileSystem
 * Method:    createFileExclusively0
 * Signature: (Ljava/lang/String;)Z
 */
HOOK_JNI(jboolean, createFileExclusively0, JNIEnv *env, jobject obj, jstring path) {
    jstring redirect = IO::redirectPath(env, path);
    return orig_createFileExclusively0(env, obj, redirect);
}

/*
 * Class:     java_io_UnixFileSystem
 * Method:    list0
 * Signature: (Ljava/io/File;)[Ljava/lang/String;
 */
HOOK_JNI(jobjectArray, list0, JNIEnv *env, jobject obj, jobject file) {
    jobject redirect = IO::redirectPath(env, file);
    return orig_list0(env, obj, redirect);
}

/*
 * Class:     java_io_UnixFileSystem
 * Method:    createDirectory0
 * Signature: (Ljava/io/File;)Z
 */
HOOK_JNI(jboolean, createDirectory0, JNIEnv *env, jobject obj, jobject path) {
    jobject redirect = IO::redirectPath(env, path);
    return orig_createDirectory0(env, obj, redirect);
}

/*
 * Class:     java_io_UnixFileSystem
 * Method:    setLastModifiedTime0
 * Signature: (Ljava/io/File;J)Z
 */
HOOK_JNI(jboolean, setLastModifiedTime0, JNIEnv *env, jobject obj, jobject file, jobject time) {
    jobject redirect = IO::redirectPath(env, file);
    return orig_setLastModifiedTime0(env, obj, redirect, time);
}

/*
 * Class:     java_io_UnixFileSystem
 * Method:    setReadOnly0
 * Signature: (Ljava/io/File;)Z
 */
HOOK_JNI(jboolean, setReadOnly0, JNIEnv *env, jobject obj, jobject file) {
    jobject redirect = IO::redirectPath(env, file);
    return orig_setReadOnly0(env, obj, redirect);
}

/*
 * Class:     java_io_UnixFileSystem
 * Method:    getSpace0
 * Signature: (Ljava/io/File;I)J
 */
HOOK_JNI(jboolean, getSpace0, JNIEnv *env, jobject obj, jobject file, jint t) {
    jobject redirect = IO::redirectPath(env, file);
    return orig_getSpace0(env, obj, redirect, t);
}

void UnixFileSystemHook::init(JNIEnv *env) {
    const char *className = "java/io/UnixFileSystem";
    // JniHook::HookJniFun(env, className, "canonicalize0", "(Ljava/lang/String;)Ljava/lang/String;",(void *) new_canonicalize0, (void **) (&orig_canonicalize0), false);

    JniHook::HookJniFun(env, className, "getLastModifiedTime0", "(Ljava/io/File;)J",
                        (void *) new_getLastModifiedTime0, (void **) (&orig_getLastModifiedTime0), false);

    JniHook::HookJniFun(env, className, "setPermission0", "(Ljava/io/File;IZZ)Z",
                        (void *) new_setPermission0, (void **) (&orig_setPermission0), false);

    JniHook::HookJniFun(env, className, "createFileExclusively0", "(Ljava/lang/String;)Z",
                        (void *) new_createFileExclusively0, (void **) (&orig_createFileExclusively0), false);

    JniHook::HookJniFun(env, className, "list0", "(Ljava/io/File;)[Ljava/lang/String;",
                        (void *) new_list0, (void **) (&orig_list0), false);

    JniHook::HookJniFun(env, className, "createDirectory0", "(Ljava/io/File;)Z",
                        (void *) new_createDirectory0, (void **) (&orig_createDirectory0), false);

    JniHook::HookJniFun(env, className, "setLastModifiedTime0", "(Ljava/io/File;J)Z",
                        (void *) new_setLastModifiedTime0, (void **) (&orig_setLastModifiedTime0),false);

    JniHook::HookJniFun(env, className, "setReadOnly0", "(Ljava/io/File;)Z",
                        (void *) new_setReadOnly0, (void **) (&orig_setReadOnly0), false);

    JniHook::HookJniFun(env, className, "getSpace0", "(Ljava/io/File;I)J",
                        (void *) new_getSpace0, (void **) (&orig_getSpace0), false);
}

```

`Bcore/src/main/cpp/Hook/UnixFileSystemHook.h`:

```h
#ifndef BLACKBOX_UNIXFILESYSTEMHOOK_H
#define BLACKBOX_UNIXFILESYSTEMHOOK_H

#include "BaseHook.h"

class UnixFileSystemHook : public BaseHook {
public:
    static void init(JNIEnv *env);
};

#endif // BLACKBOX_UNIXFILESYSTEMHOOK_H

```

`Bcore/src/main/cpp/Hook/VMClassLoaderHook.cpp`:

```cpp
#include <cstring>
#include "VMClassLoaderHook.h"
#import "JniHook/JniHook.h"

static bool hideXposedClass = false;

HOOK_JNI(jobject, findLoadedClass, JNIEnv *env, jobject obj, jobject class_loader, jstring name) {
    const char * nameC = env->GetStringUTFChars(name, JNI_FALSE);
	// ALOGD("findLoadedClass: %s", nameC);
    if (hideXposedClass) {
        if (strstr(nameC, "de/robv/android/xposed/") ||
            strstr(nameC, "me/weishu/epic") ||
            strstr(nameC, "me/weishu/exposed") ||
            strstr(nameC, "de.robv.android") ||
            strstr(nameC, "me.weishu.epic") ||
            strstr(nameC, "me.weishu.exposed")) {
            env->ReleaseStringUTFChars(name, nameC);
            return nullptr;
        }
    }
    jobject result = orig_findLoadedClass(env, obj, class_loader, name);
    env->ReleaseStringUTFChars(name, nameC);
    return result;
}

void VMClassLoaderHook::init(JNIEnv *env) {
    const char *className = "java/lang/VMClassLoader";
    JniHook::HookJniFun(env, className, "findLoadedClass", "(Ljava/lang/ClassLoader;Ljava/lang/String;)Ljava/lang/Class;",
                        (void *) new_findLoadedClass, (void **) (&orig_findLoadedClass), true);
}

void VMClassLoaderHook::hideXposed() {
    hideXposedClass = true;
}

```

`Bcore/src/main/cpp/Hook/VMClassLoaderHook.h`:

```h
#ifndef BLACKBOX_VMCLASSLOADERHOOK_H
#define BLACKBOX_VMCLASSLOADERHOOK_H

#include "BaseHook.h"
#include <jni.h>

class VMClassLoaderHook : public BaseHook {
public:
    static void hideXposed();
    static void init(JNIEnv *env);
};

#endif // BLACKBOX_VMCLASSLOADERHOOK_H

```

`Bcore/src/main/cpp/IO.cpp`:

```cpp
//
// Created by Milk on 4/10/21.
//

#include <sys/mman.h>
#include <bits/sysconf.h>
#include "IO.h"
#include "Log.h"
#include "JniHook/JniHook.h"

list<IO::RelocateInfo> relocate_rule;
list<const char *> white_rule;

char *replace(const char *str, const char *src, const char *dst) {
    const char *pos = str;
    int count = 0;
    while ((pos = strstr(pos, src))) {
        count++;
        pos += strlen(src);
    }

    size_t result_len = strlen(str) + (strlen(dst) - strlen(src)) * count + 1;
    char *result = (char *) malloc(result_len);
    memset(result, 0, strlen(result));

    const char *left = str;
    const char *right;

    while ((right = strstr(left, src))) {
        strncat(result, left, right - left);
        strcat(result, dst);
        right += strlen(src);
        left = right;
    }
    strcat(result, left);
    return result;
}

//#ifdef __arm__ https://developer.android.com/games/optimize/64-bit?hl=zh-cn
HOOK_JNI(void *, openat, int fd, const char *pathname, int flags, int mode) {
    // 执行 stack 清理（不可省略），只需调用一次
    // SHADOWHOOK_STACK_SCOPE();
    list<const char *>::iterator white_iterator;
    for (white_iterator = white_rule.begin();
         white_iterator != white_rule.end(); ++white_iterator) {
        const char *info = *white_iterator;
        if (strstr(pathname, info)) {
            return orig_openat(fd, pathname, flags, mode);
        }
    }
    list<IO::RelocateInfo>::iterator iterator;
    for (iterator = relocate_rule.begin(); iterator != relocate_rule.end(); ++iterator) {
        IO::RelocateInfo info = *iterator;
        if (strstr(pathname, info.targetPath) && !strstr(pathname, "/blackbox/")) {
            log_print_debug("redirectPath %s  => %s", pathname, info.relocatePath);
            return orig_openat(fd, info.relocatePath, flags, mode);
        }
    }
    // 调用原函数
    return orig_openat(fd, pathname, flags, mode);
}

jstring IO::redirectPath(JNIEnv *env, jstring path) {
    return BoxCore::redirectPathString(env, path);
}

jobject IO::redirectPath(JNIEnv *env, jobject path) {
    return BoxCore::redirectPathFile(env, path);
}

void IO::addWhiteList(const char *path) {
    white_rule.push_back(path);
}

void IO::addRule(const char *targetPath, const char *relocatePath) {
    IO::RelocateInfo info{};
    info.targetPath = targetPath;
    info.relocatePath = relocatePath;
    relocate_rule.push_back(info);
}



```

`Bcore/src/main/cpp/IO.h`:

```h
#ifndef BLACKBOX_IO_H
#define BLACKBOX_IO_H

#if defined(__LP64__)
#define LINKER_PATH_L "/system/bin/linker64"
#define LINKER_PATH_Q "/apex/com.android.runtime/bin/linker64"
#define LIBC_PATH_L "/system/lib64/libc.so"
#define LIBC_PATH_Q "/apex/com.android.runtime/lib64/bionic/libc.so"
#else
#define LINKER_PATH_L "/system/bin/linker"
#define LINKER_PATH_Q "/apex/com.android.runtime/bin/linker"
#define LIBC_PATH_L "/system/lib/libc.so"
#define LIBC_PATH_Q "/apex/com.android.runtime/lib/bionic/libc.so"
#endif

#include <jni.h>

#include <list>
#include <iostream>
#include "BoxCore.h"

using namespace std;

class IO {
public:
    static void init(JNIEnv *env);

    struct RelocateInfo {
        const char *targetPath;
        const char *relocatePath;
    };

    static void addRule(const char *targetPath, const char *relocatePath);

    static void addWhiteList(const char *path);

    static jstring redirectPath(JNIEnv *env, jstring path);

    static jobject redirectPath(JNIEnv *env, jobject path);

    static void replaceFD(JNIEnv *env, jobject fd);

};

#endif // BLACKBOX_IO_H

```

`Bcore/src/main/cpp/JniHook/ArtMethod.h`:

```h
#include <stdio.h>

#ifndef ARTHOOK_ART_METHOD_H
#define ARTHOOK_ART_METHOD_H

#define __ANDROID_API_R__ 30
#define __ANDROID_API_Q__ 29
#define __ANDROID_API_P__ 28

static constexpr uint32_t kAccPublic =       0x0001;  // class, field, method, ic
static constexpr uint32_t kAccPrivate =      0x0002;  // field, method, ic
static constexpr uint32_t kAccProtected =    0x0004;  // field, method, ic
static constexpr uint32_t kAccStatic =       0x0008;  // field, method, ic
static constexpr uint32_t kAccFinal =        0x0010;  // class, field, method, ic
static constexpr uint32_t kAccSynchronized = 0x0020;  // method (only allowed on natives)
static constexpr uint32_t kAccSuper =        0x0020;  // class (not used in dex)
static constexpr uint32_t kAccVolatile =     0x0040;  // field
static constexpr uint32_t kAccBridge =       0x0040;  // method (1.5)
static constexpr uint32_t kAccTransient =    0x0080;  // field
static constexpr uint32_t kAccVarargs =      0x0080;  // method (1.5)
static constexpr uint32_t kAccNative =       0x0100;  // method
static constexpr uint32_t kAccInterface =    0x0200;  // class, ic
static constexpr uint32_t kAccAbstract =     0x0400;  // class, method, ic
static constexpr uint32_t kAccStrict =       0x0800;  // method
static constexpr uint32_t kAccSynthetic =    0x1000;  // class, field, method, ic
static constexpr uint32_t kAccAnnotation =   0x2000;  // class, ic (1.5)
static constexpr uint32_t kAccEnum =         0x4000;  // class, field, ic (1.5)

static constexpr uint32_t kAccPublicApi =             0x10000000;  // field, method
static constexpr uint32_t kAccCorePlatformApi =       0x20000000;  // field, method

// Native method flags are set when linking the methods based on the presence of the
// @dalvik.annotation.optimization.{Fast,Critical}Native annotations with build visibility.
// Reuse the values of kAccSkipAccessChecks and kAccMiranda which are not used for native methods.
static constexpr uint32_t kAccFastNative =            0x00080000;  // method (runtime; native only)
static constexpr uint32_t kAccCriticalNative =        0x00200000;  // method (runtime; native only)
#endif // ARTHOOK_ART_METHOD_H

```

`Bcore/src/main/cpp/JniHook/JniHook.cpp`:

```cpp
#include <jni.h>
#include <cstring>
#define JNIHOOKCLASS "com/vcore/jnihook/JniHook"
#define JNIMETHOOG_Utills "com/vcore/jnihook/MethodUtils"
#include "JniHook.h"
#include "Log.h"
#include "ArtMethod.h"



static struct {
    int api_level;
    unsigned int art_field_size;
    int art_field_flags_offset;

    unsigned int art_method_size;
    int art_method_flags_offset;
    int art_method_native_offset;

    int class_flags_offset;

    jclass method_utils_class;
    jmethodID get_method_desc_id;
    jmethodID get_method_declaring_class_id;
    jmethodID get_method_name_id;
} HookEnv;

static const char *GetMethodDesc(JNIEnv *env, jobject javaMethod) {
    auto desc = reinterpret_cast<jstring>(env->CallStaticObjectMethod(HookEnv.method_utils_class, HookEnv.get_method_desc_id, javaMethod));
    return env->GetStringUTFChars(desc, JNI_FALSE);
}

static const char *GetMethodDeclaringClass(JNIEnv *env, jobject javaMethod) {
    auto desc = reinterpret_cast<jstring>(env->CallStaticObjectMethod(HookEnv.method_utils_class, HookEnv.get_method_declaring_class_id, javaMethod));
    return env->GetStringUTFChars(desc, JNI_FALSE);
}

static const char *GetMethodName(JNIEnv *env, jobject javaMethod) {
    auto desc = reinterpret_cast<jstring>(env->CallStaticObjectMethod(HookEnv.method_utils_class, HookEnv.get_method_name_id, javaMethod));
    return env->GetStringUTFChars(desc, JNI_FALSE);
}

inline static uint32_t GetAccessFlags(const char *art_method) {
    return *reinterpret_cast<const uint32_t *>(art_method + HookEnv.art_method_flags_offset);
}

inline static bool SetAccessFlags(char *art_method, uint32_t flags) {
    *reinterpret_cast<uint32_t *>(art_method + HookEnv.art_method_flags_offset) = flags;
    return true;
}

inline static bool AddAccessFlag(char *art_method, uint32_t flag) {
    uint32_t old_flag = GetAccessFlags(art_method);
    uint32_t new_flag = old_flag | flag;
    return new_flag != old_flag && SetAccessFlags(art_method, new_flag);
}

inline static bool ClearAccessFlag(char *art_method, uint32_t flag) {
    uint32_t old_flag = GetAccessFlags(art_method);
    uint32_t new_flag = old_flag & ~flag;
    return new_flag != old_flag && SetAccessFlags(art_method, new_flag);
}

inline static bool HasAccessFlag(char *art_method) {
    uint32_t flags = GetAccessFlags(art_method);
    return (flags & 256) == 256;
}

inline static bool ClearFastNativeFlag(char *art_method) {
    // FastNative
    return HookEnv.api_level < __ANDROID_API_P__ && ClearAccessFlag(art_method, kAccFastNative);
}

static void *GetArtMethod(JNIEnv *env, jclass clazz, jmethodID methodId) {
    if (HookEnv.api_level >= __ANDROID_API_Q__) {
        jclass executable = env->FindClass("java/lang/reflect/Executable");
        jfieldID artId = env->GetFieldID(executable, "artMethod", "J");
        jobject method = env->ToReflectedMethod(clazz, methodId, true);
        return reinterpret_cast<void *>(env->GetLongField(method, artId));
    } else {
        return methodId;
    }
}

static void *GetFieldMethod(JNIEnv *env, jobject field) {
    if (HookEnv.api_level >= __ANDROID_API_Q__) {
        jclass fieldClass = env->FindClass("java/lang/reflect/Field");
        jmethodID getArtField = env->GetMethodID(fieldClass, "getArtField", "()J");
        return reinterpret_cast<void *>(env->CallLongMethod(field, getArtField));
    } else {
        return env->FromReflectedField(field);
    }
}

bool CheckFlags(void *artMethod) {
    char *method = static_cast<char *>(artMethod);
    if (!HasAccessFlag(method)) {
        ALOGE("not native method");
        return false;
    }
    ClearFastNativeFlag(method);
    return true;
}

void JniHook::HookJniFun(JNIEnv *env, jobject java_method, void *new_fun, void **orig_fun, bool is_static) {
    const char *class_name = GetMethodDeclaringClass(env, java_method);
    const char *method_name = GetMethodName(env, java_method);
    const char *sign = GetMethodDesc(env, java_method);
    HookJniFun(env, class_name, method_name, sign, new_fun, orig_fun, is_static);
}

void JniHook::HookJniFun(JNIEnv *env, const char *class_name, const char *method_name, const char *sign, void *new_fun, void **orig_fun, bool is_static) {
    if (HookEnv.art_method_native_offset == 0) {
        return;
    }

    jclass clazz = env->FindClass(class_name);
    if (!clazz) {
        ALOGD("findClass fail: %s %s", class_name, method_name);
        env->ExceptionClear();
        return;
    }

    jmethodID method;
    if (is_static) {
        method = env->GetStaticMethodID(clazz, method_name, sign);
    } else {
        method = env->GetMethodID(clazz, method_name, sign);
    }

    if (!method) {
        env->ExceptionClear();
        ALOGD("get method id fail: %s %s", class_name, method_name);
        return;
    }

    JNINativeMethod gMethods[] = {
        { method_name, sign, (void *) new_fun },
    };

    auto artMethod = reinterpret_cast<uintptr_t *>(GetArtMethod(env, clazz, method));
    // 不检查系统包
    if (!strncmp(class_name, "android.", 8) && !CheckFlags(artMethod)) {
        ALOGE("check flags error. class：%s, method：%s", class_name, method_name);
        return;
    }

    *orig_fun = reinterpret_cast<void *>(artMethod[HookEnv.art_method_native_offset]);
    if (env->RegisterNatives(clazz, gMethods, 1) < 0) {
        ALOGE("JNI hook error. class：%s, method：%s", class_name, method_name);
        return;
    }

    // FastNative
    if (HookEnv.api_level == __ANDROID_API_O__ || HookEnv.api_level == __ANDROID_API_O_MR1__) {
        AddAccessFlag((char *) artMethod, kAccFastNative);
    }
    ALOGD("Register class：%s, method：%s success!", class_name, method_name);
}

__attribute__((section (".mytext")))
JNICALL void native_offset(JNIEnv *env, jclass obj) { }

__attribute__((section (".mytext")))
JNICALL void native_offset2(JNIEnv *env, jclass obj) { }

__attribute__((section (".mytext")))  JNICALL void set_method_accessible(JNIEnv *env, jclass obj, jclass clazz, jobject method) {
    jmethodID methodId = env->FromReflectedMethod(method);
    char *art_method = static_cast<char *>(GetArtMethod(env, clazz, methodId));

    AddAccessFlag(art_method, kAccPublic);
    if (HookEnv.api_level >= __ANDROID_API_Q__) {
        AddAccessFlag(art_method, kAccPublicApi);
    }
}

__attribute__((section (".mytext")))  JNICALL void set_field_accessible(JNIEnv *env, jclass obj, jclass clazz, jobject field) {
    char *artField = static_cast<char *>(GetFieldMethod(env, field));
    AddAccessFlag(artField, kAccPublic);

    if (HookEnv.api_level >= __ANDROID_API_Q__) {
        AddAccessFlag(artField, kAccPublicApi);
    }
    ClearAccessFlag(artField, kAccFinal);
}

void registerNative(JNIEnv *env) {
    jclass clazz = env->FindClass(JNIHOOKCLASS);
    JNINativeMethod gMethods[] = {
        {"nativeOffset", "()V", (void *) native_offset},
        {"nativeOffset2", "()V", (void *) native_offset2},
    };

    if (env->RegisterNatives(clazz, gMethods, sizeof(gMethods) / sizeof(gMethods[0])) < 0) {
        ALOGE("JNI register error.");
    }
}

void JniHook::InitJniHook(JNIEnv *env, int api_level) {
    registerNative(env);
    HookEnv.api_level = api_level;

    jclass clazz = env->FindClass(JNIHOOKCLASS);
    jmethodID nativeOffsetId = env->GetStaticMethodID(clazz, "nativeOffset", "()V");
    jmethodID nativeOffset2Id = env->GetStaticMethodID(clazz, "nativeOffset2", "()V");

    jfieldID nativeOffsetFieldId = env->GetStaticFieldID(clazz, "NATIVE_OFFSET", "I");
    jfieldID nativeOffsetField2Id = env->GetStaticFieldID(clazz, "NATIVE_OFFSET_2", "I");

    void *nativeOffsetField = GetFieldMethod(env, env->ToReflectedField(clazz, nativeOffsetFieldId, true));
    void *nativeOffsetField2 = GetFieldMethod(env, env->ToReflectedField(clazz, nativeOffsetField2Id, true));
    HookEnv.art_field_size = (size_t) nativeOffsetField2 - (size_t) nativeOffsetField;

    void *nativeOffset = GetArtMethod(env, clazz, nativeOffsetId);
    void *nativeOffset2 = GetArtMethod(env, clazz, nativeOffset2Id);
    HookEnv.art_method_size = (size_t) nativeOffset2 - (size_t) nativeOffset;

    // calc native offset
    auto artMethod = reinterpret_cast<uintptr_t *>(nativeOffset);
    for (int i = 0; i < HookEnv.art_method_size; ++i) {
        if (reinterpret_cast<void *>(artMethod[i]) == native_offset) {
            HookEnv.art_method_native_offset = i;
            break;
        }
    }

    uint32_t flags = 0x0;
    flags = flags | kAccPublic;
    flags = flags | kAccStatic;
    flags = flags | kAccNative;
    flags = flags | kAccFinal;
    if (api_level >= __ANDROID_API_Q__) {
        flags = flags | kAccPublicApi;
    }

    char *start = reinterpret_cast<char *>(artMethod);
    for (int i = 1; i < HookEnv.art_method_size; ++i) {
        auto value = *(uint32_t *) (start + i * sizeof(uint32_t));
        if (value == flags) {
            HookEnv.art_method_flags_offset = i * sizeof(uint32_t);
            break;
        }
    }

    flags = 0x0;
    flags = flags | kAccPublic;
    flags = flags | kAccStatic;
    flags = flags | kAccFinal;
    if (api_level >= __ANDROID_API_Q__) {
        flags = flags | kAccPublicApi;
    }

    char *fieldStart = reinterpret_cast<char *>(nativeOffsetField);
    for (int i = 1; i < HookEnv.art_field_size; ++i) {
        auto value = *(int32_t *) (fieldStart + i * sizeof(int32_t));
        if (value == flags) {
            HookEnv.art_field_flags_offset = i * sizeof(int32_t);
            break;
        }
    }

    HookEnv.method_utils_class = env->FindClass(JNIMETHOOG_Utills);
    HookEnv.get_method_desc_id = env->GetStaticMethodID(HookEnv.method_utils_class, "getDesc", "(Ljava/lang/reflect/Method;)Ljava/lang/String;");
    HookEnv.get_method_declaring_class_id = env->GetStaticMethodID(HookEnv.method_utils_class, "getDeclaringClass", "(Ljava/lang/reflect/Method;)Ljava/lang/String;");
    HookEnv.get_method_name_id = env->GetStaticMethodID(HookEnv.method_utils_class, "getMethodName", "(Ljava/lang/reflect/Method;)Ljava/lang/String;");
}

```

`Bcore/src/main/cpp/JniHook/JniHook.h`:

```h
#ifndef BLACKBOX_JNIHOOK_H
#define BLACKBOX_JNIHOOK_H

#include "ArtMethod.h"

#define HOOK_JNI(ret, func, ...) \
  ret (*orig_##func)(__VA_ARGS__); \
  ret new_##func(__VA_ARGS__)

class JniHook {
public:
    static void InitJniHook(JNIEnv *env, int api_level);
    static void HookJniFun(JNIEnv *env, const char *class_name, const char *method_name, const char *sign, void *new_fun, void **orig_fun, bool is_static);
    static void HookJniFun(JNIEnv *env, jobject java_method, void *new_fun, void **orig_fun, bool is_static);
};

#endif // BLACKBOX_JNIHOOK_H

```

`Bcore/src/main/cpp/Log.h`:

```h
#include <android/log.h>

#define TAG "NativeCore"

#if 1
#define log_print_error(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__)
#define log_print_debug(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__)
#else
#define log_print_error(...)
#endif

#define ALOGE(...) log_print_error(__VA_ARGS__)
#define ALOGD(...) log_print_debug(__VA_ARGS__)

#ifndef SPEED_LOG_H
#define SPEED_LOG_H 1

#endif

```

`Bcore/src/main/java/android/app/ActivityThread.java`:

```java
package android.app;

import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.ProviderInfo;
import android.os.Handler;
import android.os.IBinder;
import android.util.ArrayMap;

import java.lang.ref.WeakReference;
import java.util.Map;
import java.util.Objects;

public class ActivityThread {
    public H mH = null;
    public AppBindData mBoundApplication;
    public Application mInitialApplication;
    public Instrumentation mInstrumentation;
    public Map<String, WeakReference<?>> mPackages;
    public Map<IBinder, ActivityClientRecord> mActivities;
    public ArrayMap<ProviderKey, Object> mProviderMap;

    static class H extends Handler { }

    public static ActivityThread currentActivityThread() {
        throw new RuntimeException();
    }

    public String getProcessName() {
        throw new RuntimeException();
    }

    public Handler getHandler() {
        throw new RuntimeException();
    }

    public ContentProviderHolder installProvider(Context context, ContentProviderHolder holder, ProviderInfo info, boolean noisy,
                                                 boolean noReleaseNeeded, boolean stable) {
        throw new RuntimeException();
    }

    static final class AppBindData { }

    public static final class ActivityClientRecord {
        public Activity activity;
        public IBinder token;
        public ActivityInfo activityInfo;
        public Intent intent;
    }

    public static final class ProviderKey {
        public final String authority;
        public final int userId;

        public ProviderKey(String authority, int userId) {
            this.authority = authority;
            this.userId = userId;
        }

        @Override
        public boolean equals(Object o) {
            if (o instanceof ProviderKey) {
                final ProviderKey other = (ProviderKey) o;
                return Objects.equals(authority, other.authority) && userId == other.userId;
            }
            return false;
        }

        @Override
        public int hashCode() {
            return ((authority != null) ? authority.hashCode() : 0) ^ userId;
        }
    }
}

```

`Bcore/src/main/java/android/app/ContentProviderHolder.java`:

```java
package android.app;

import android.content.IContentProvider;
import android.content.pm.ProviderInfo;
import android.os.IBinder;

public class ContentProviderHolder {
    public final ProviderInfo info = null;
    public IContentProvider provider;
    public IBinder connection;
}

```

`Bcore/src/main/java/android/content/IContentProvider.java`:

```java
package android.content;

import android.os.IInterface;

public interface IContentProvider extends IInterface { }
```

`Bcore/src/main/java/android/content/SyncInfo.java`:

```java
package android.content;

import android.accounts.Account;
import android.os.Parcel;
import android.os.Parcelable;

/**
 * Information about the sync operation that is currently underway.
 */
public class SyncInfo implements Parcelable {
    /**
     * Used when the caller receiving this object doesn't have permission to access the accounts
     * on device.
     * @See Manifest.permission.GET_ACCOUNTS
     */
    private static final Account REDACTED_ACCOUNT = new Account("*****", "*****");

    /** @hide */
    public final int authorityId;

    /**
     * The {@link Account} that is currently being synced.
     */
    public final Account account;

    /**
     * The authority of the provider that is currently being synced.
     */
    public final String authority;

    /**
     * The start time of the current sync operation in milliseconds since boot.
     * This is represented in elapsed real time.
     * See {@link android.os.SystemClock#elapsedRealtime()}.
     */
    public final long startTime;

    /**
     * Creates a SyncInfo object with an unusable Account. Used when the caller receiving this
     * object doesn't have access to the accounts on the device.
     * @See Manifest.permission.GET_ACCOUNTS
     * @hide
     */
    public static SyncInfo createAccountRedacted(
        int authorityId, String authority, long startTime) {
        throw new RuntimeException("Stub!");
    }

    /** @hide */
    public SyncInfo(int authorityId, Account account, String authority, long startTime) {
        throw new RuntimeException("Stub!");
    }

    /** @hide */
    public SyncInfo(SyncInfo other) {
        throw new RuntimeException("Stub!");
    }

    /** @hide */
    public int describeContents() {
        return 0;
    }

    /** @hide */
    public void writeToParcel(Parcel parcel, int flags) {
        parcel.writeInt(authorityId);
        parcel.writeParcelable(account, flags);
        parcel.writeString(authority);
        parcel.writeLong(startTime);
    }

    SyncInfo(Parcel parcel) {
        throw new RuntimeException("Stub!");
    }

    public static final Creator<SyncInfo> CREATOR = new Creator<SyncInfo>() {
        public SyncInfo createFromParcel(Parcel in) {
            return new SyncInfo(in);
        }

        public SyncInfo[] newArray(int size) {
            return new SyncInfo[size];
        }
    };
}

```

`Bcore/src/main/java/android/content/SyncStatusInfo.java`:

```java
package android.content;

import android.os.Parcel;
import android.os.Parcelable;
import android.util.Log;

import java.util.ArrayList;

public class SyncStatusInfo implements Parcelable {
    static final int VERSION = 2;

    public final int authorityId;
    public long totalElapsedTime;
    public int numSyncs;
    public int numSourcePoll;
    public int numSourceServer;
    public int numSourceLocal;
    public int numSourceUser;
    public int numSourcePeriodic;
    public long lastSuccessTime;
    public int lastSuccessSource;
    public long lastFailureTime;
    public int lastFailureSource;
    public String lastFailureMesg;
    public long initialFailureTime;
    public boolean pending;
    public boolean initialize;
    
    // Warning: It is up to the external caller to ensure there are
    // no race conditions when accessing this list
    private ArrayList<Long> periodicSyncTimes;

    private static final String TAG = "Sync";

    public SyncStatusInfo(int authorityId) {
        this.authorityId = authorityId;
    }

    public int describeContents() {
        return 0;
    }

    public void writeToParcel(Parcel parcel, int flags) {
        parcel.writeInt(VERSION);
        parcel.writeInt(authorityId);
        parcel.writeLong(totalElapsedTime);
        parcel.writeInt(numSyncs);
        parcel.writeInt(numSourcePoll);
        parcel.writeInt(numSourceServer);
        parcel.writeInt(numSourceLocal);
        parcel.writeInt(numSourceUser);
        parcel.writeLong(lastSuccessTime);
        parcel.writeInt(lastSuccessSource);
        parcel.writeLong(lastFailureTime);
        parcel.writeInt(lastFailureSource);
        parcel.writeString(lastFailureMesg);
        parcel.writeLong(initialFailureTime);
        parcel.writeInt(pending ? 1 : 0);
        parcel.writeInt(initialize ? 1 : 0);

        if (periodicSyncTimes != null) {
            parcel.writeInt(periodicSyncTimes.size());
            for (long periodicSyncTime : periodicSyncTimes) {
                parcel.writeLong(periodicSyncTime);
            }
        } else {
            parcel.writeInt(-1);
        }
    }

    public SyncStatusInfo(Parcel parcel) {
        int version = parcel.readInt();
        if (version != VERSION && version != 1) {
            Log.w("SyncStatusInfo", "Unknown version: " + version);
        }

        authorityId = parcel.readInt();
        totalElapsedTime = parcel.readLong();
        numSyncs = parcel.readInt();
        numSourcePoll = parcel.readInt();
        numSourceServer = parcel.readInt();
        numSourceLocal = parcel.readInt();
        numSourceUser = parcel.readInt();
        lastSuccessTime = parcel.readLong();
        lastSuccessSource = parcel.readInt();
        lastFailureTime = parcel.readLong();
        lastFailureSource = parcel.readInt();
        lastFailureMesg = parcel.readString();
        initialFailureTime = parcel.readLong();
        pending = parcel.readInt() != 0;
        initialize = parcel.readInt() != 0;

        if (version == 1) {
            periodicSyncTimes = null;
        } else {
            int N = parcel.readInt();
            if (N < 0) {
                periodicSyncTimes = null;
            } else {
                periodicSyncTimes = new ArrayList<>();
                for (int i = 0; i < N; i++) {
                    periodicSyncTimes.add(parcel.readLong());
                }
            }
        }
    }

    public SyncStatusInfo(SyncStatusInfo other) {
        authorityId = other.authorityId;
        totalElapsedTime = other.totalElapsedTime;
        numSyncs = other.numSyncs;
        numSourcePoll = other.numSourcePoll;
        numSourceServer = other.numSourceServer;
        numSourceLocal = other.numSourceLocal;
        numSourceUser = other.numSourceUser;
        numSourcePeriodic = other.numSourcePeriodic;
        lastSuccessTime = other.lastSuccessTime;
        lastSuccessSource = other.lastSuccessSource;
        lastFailureTime = other.lastFailureTime;
        lastFailureSource = other.lastFailureSource;
        lastFailureMesg = other.lastFailureMesg;
        initialFailureTime = other.initialFailureTime;
        pending = other.pending;
        initialize = other.initialize;

        if (other.periodicSyncTimes != null) {
            periodicSyncTimes = new ArrayList<>(other.periodicSyncTimes);
        }
    }

    public void setPeriodicSyncTime(int index, long when) {
        // The list is initialized lazily when scheduling occurs so we need to make sure
        // we initialize elements < index to zero (zero is ignore for scheduling purposes)
        ensurePeriodicSyncTimeSize(index);
        periodicSyncTimes.set(index, when);
    }

    public long getPeriodicSyncTime(int index) {
        if (periodicSyncTimes != null && index < periodicSyncTimes.size()) {
            return periodicSyncTimes.get(index);
        }
        return 0;
    }

    public void removePeriodicSyncTime(int index) {
        if (periodicSyncTimes != null && index < periodicSyncTimes.size()) {
            periodicSyncTimes.remove(index);
        }
    }

    public static final Creator<SyncStatusInfo> CREATOR = new Creator<SyncStatusInfo>() {
        public SyncStatusInfo createFromParcel(Parcel in) {
            return new SyncStatusInfo(in);
        }

        public SyncStatusInfo[] newArray(int size) {
            return new SyncStatusInfo[size];
        }
    };

    private void ensurePeriodicSyncTimeSize(int index) {
        if (periodicSyncTimes == null) {
            periodicSyncTimes = new ArrayList<>(0);
        }

        final int requiredSize = index + 1;
        if (periodicSyncTimes.size() < requiredSize) {
            for (int i = periodicSyncTimes.size(); i < requiredSize; i++) {
                periodicSyncTimes.add((long) 0);
            }
        }
    }
}

```

`Bcore/src/main/java/android/content/pm/ManifestDigest.java`:

```java
package android.content.pm;

import android.os.Parcel;
import android.os.Parcelable;

import java.util.jar.Attributes;

public class ManifestDigest implements Parcelable {
    ManifestDigest(final byte[] digest) {
        throw new RuntimeException("Stub!");
    }

    private ManifestDigest(final Parcel source) {
        throw new RuntimeException("Stub!");
    }

    static ManifestDigest fromAttributes(final Attributes attributes) {
        throw new RuntimeException("Stub!");
    }

    @Override
    public int describeContents() {
        throw new RuntimeException("Stub!");
    }

    @Override
    public boolean equals(Object o) {
        throw new RuntimeException("Stub!");
    }

    @Override
    public int hashCode() {
        throw new RuntimeException("Stub!");
    }

    @Override
    public String toString() {
        throw new RuntimeException("Stub!");
    }

    @Override
    public void writeToParcel(final Parcel dest, final int flags) {
        throw new RuntimeException("Stub!");
    }

    public static final Parcelable.Creator<ManifestDigest> CREATOR = new Parcelable.Creator<ManifestDigest>() {
        public ManifestDigest createFromParcel(Parcel source) {
            return new ManifestDigest(source);
        }

        public ManifestDigest[] newArray(int size) {
            return new ManifestDigest[size];
        }
    };
}

```

`Bcore/src/main/java/android/content/pm/PackageParser.java`:

```java
package android.content.pm;

import android.annotation.SuppressLint;
import android.content.ComponentName;
import android.content.IntentFilter;
import android.content.res.TypedArray;
import android.os.Bundle;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.DisplayMetrics;

import java.io.File;
import java.io.PrintWriter;
import java.security.PublicKey;
import java.security.cert.Certificate;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class PackageParser {
    public final static int PARSE_IS_SYSTEM = 1;
    public final static int PARSE_CHATTY = 1 << 1;
    public final static int PARSE_MUST_BE_APK = 1 << 2;
    public final static int PARSE_IGNORE_PROCESSES = 1 << 3;
    public final static int PARSE_FORWARD_LOCK = 1 << 4;
    public final static int PARSE_EXTERNAL_STORAGE = 1 << 5;
    public final static int PARSE_IS_SYSTEM_DIR = 1 << 6;
    public final static int PARSE_IS_PRIVILEGED = 1 << 7;
    public final static int PARSE_COLLECT_CERTIFICATES = 1 << 8;
    public final static int PARSE_TRUSTED_OVERLAY = 1 << 9;

    public static class NewPermissionInfo {
        public final String name;
        public final int sdkVersion;
        public final int fileVersion;

        public NewPermissionInfo(String name, int sdkVersion, int fileVersion) {
            throw new RuntimeException("Stub!");
        }
    }

    public static class SplitPermissionInfo {
        public final String rootPerm;
        public final String[] newPerms;
        public final int targetSdk;

        public SplitPermissionInfo(String rootPerm, String[] newPerms, int targetSdk) {
            throw new RuntimeException("Stub!");
        }
    }

    public static final PackageParser.NewPermissionInfo[] NEW_PERMISSIONS = new PackageParser.NewPermissionInfo[]{
            new PackageParser.NewPermissionInfo(android.Manifest.permission.WRITE_EXTERNAL_STORAGE, android.os.Build.VERSION_CODES.DONUT, 0),
            new PackageParser.NewPermissionInfo(android.Manifest.permission.READ_PHONE_STATE, android.os.Build.VERSION_CODES.DONUT, 0)
    };

    static class ParsePackageItemArgs {
        final Package owner;
        final String[] outError;
        final int nameRes;
        final int labelRes;
        final int iconRes;
        final int logoRes;
        final int bannerRes;

        String tag;
        TypedArray sa;

        ParsePackageItemArgs(final Package owner, final String[] outError, final int nameRes, final int labelRes, final int iconRes, final int logoRes, final int bannerRes) {
            throw new RuntimeException("Stub!");
        }
    }

    static class ParseComponentArgs extends ParsePackageItemArgs {
        final String[] sepProcesses;
        final int processRes;
        final int descriptionRes;
        final int enabledRes;
        int flags;

        ParseComponentArgs(final Package owner, final String[] outError, final int nameRes, final int labelRes, final int iconRes, final int logoRes, final int bannerRes, final String[] sepProcesses, final int processRes, final int descriptionRes, final int enabledRes) {
            super(owner, outError, nameRes, labelRes, iconRes, logoRes, bannerRes);
            throw new RuntimeException("Stub!");
        }
    }

    public static class PackageLite {
        public final String packageName;
        public final int versionCode;
        public final int installLocation;
        public final VerifierInfo[] verifiers;

        // Names of any split APKs, ordered by parsed splitName.
        public final String[] splitNames;

        /**
         * Path where this package was found on disk. For monolithic packages
         * this is path to single base APK file; for cluster packages this is
         * path to the cluster directory.
         */
        public final String codePath;

        // Path of base APK.
        public final String baseCodePath;
        // Paths of any split APKs, ordered by parsed splitName.
        public final String[] splitCodePaths;

        // Revision code of base APK.
        public final int baseRevisionCode;
        // Revision codes of any split APKs, ordered by parsed splitName.
        public final int[] splitRevisionCodes;

        public final boolean coreApp;
        public final boolean multiArch;
        public final boolean extractNativeLibs;

        public PackageLite(final String codePath, final ApkLite baseApk, final String[] splitNames, final String[] splitCodePaths, final int[] splitRevisionCodes) {
            throw new RuntimeException("Stub!");
        }

        public List<String> getAllCodePaths() {
            throw new RuntimeException("Stub!");
        }
    }

    public static class ApkLite {
        public final String codePath;
        public final String packageName;
        public final String splitName;
        public final int versionCode;
        public final int revisionCode;
        public final int installLocation;
        public final VerifierInfo[] verifiers;
        public final Signature[] signatures;
        public final boolean coreApp;
        public final boolean multiArch;
        public final boolean extractNativeLibs;

        public ApkLite(final String codePath, final String packageName, final String splitName, final int versionCode, final int revisionCode, final int installLocation, final List<VerifierInfo> verifiers, final Signature[] signatures, final boolean coreApp, final boolean multiArch, final boolean extractNativeLibs) {
            throw new RuntimeException("Stub!");
        }
    }

    /**
     * For SDK_INT 29+
     */
    public Callback mCallback;

    public interface Callback {
        boolean hasFeature(String feature);
    }

    public static final class CallbackImpl implements Callback {
        private final PackageManager mPm;

        public CallbackImpl(PackageManager pm) {
            mPm = pm;
        }

        @Override
        public boolean hasFeature(String feature) {
            return mPm.hasSystemFeature(feature);
        }
    }

    public void setCallback(Callback cb) {
        mCallback = cb;
    }

    /**
     * For Android 5.0+
     */
    public PackageParser() {
        throw new RuntimeException("Stub!");
    }

    public PackageParser(final String archiveSourcePath) {
        throw new RuntimeException("Stub!");
    }

    public void setSeparateProcesses(final String[] procs) {
        throw new RuntimeException("Stub!");
    }

    public void setOnlyCoreApps(final boolean onlyCoreApps) {
        throw new RuntimeException("Stub!");
    }

    public void setDisplayMetrics(final DisplayMetrics metrics) {
        throw new RuntimeException("Stub!");
    }

    public static boolean isApkFile(final File file) {
        throw new RuntimeException("Stub!");
    }

    public static PackageInfo generatePackageInfo(final PackageParser.Package p, final int[] gids, final int flags, final long firstInstallTime, final long lastUpdateTime, final Set<String> grantedPermissions, final PackageUserState state) {
        throw new RuntimeException("Stub!");
    }

    public static boolean isAvailable(final PackageUserState state) {
        throw new RuntimeException("Stub!");
    }

    public static PackageInfo generatePackageInfo(final PackageParser.Package p, final int[] gids, final int flags, final long firstInstallTime, final long lastUpdateTime, final Set<String> grantedPermissions, final PackageUserState state, final int userId) {
        throw new RuntimeException("Stub!");
    }

    /**
     * Parse only lightweight details about the package at the given location.
     * Automatically detects if the package is a monolithic style (single APK
     * file) or cluster style (directory of APKs).
     * <p>
     * This performs sanity checking on cluster style packages, such as
     * requiring identical package name and version codes, a single base APK,
     * and unique split names.
     *
     * @see PackageParser#parsePackage(File, int)
     */
    public static PackageLite parsePackageLite(final File packageFile, final int flags) throws PackageParserException {
        throw new RuntimeException("Stub!");
    }

    /**
     * Parse the package at the given location. Automatically detects if the
     * package is a monolithic style (single APK file) or cluster style
     * (directory of APKs).
     * <p>
     * This performs sanity checking on cluster style packages, such as
     * requiring identical package name and version codes, a single base APK,
     * and unique split names.
     * <p>
     * Note that this <em>does not</em> perform signature verification; that
     * must be done separately in {@link #collectCertificates(Package, int)}.
     *
     * @see #parsePackageLite(File, int)
     * @since Android 5.0+
     */
    public Package parsePackage(final File packageFile, final int flags) throws PackageParserException {
        throw new RuntimeException("Stub!");
    }

    /**
     * @param sourceFile
     * @param destCodePath
     * @param metrics
     * @param flags
     * @return
     * @since Android 2.3+
     */
    public Package parsePackage(final File sourceFile, final String destCodePath, final DisplayMetrics metrics, final int flags) {
        throw new RuntimeException("Stub!");
    }

    public void collectManifestDigest(final Package pkg) throws PackageParserException {
        throw new RuntimeException("Stub!");
    }

    public void collectCertificates(final Package pkg, final int flags) throws PackageParserException {
        throw new RuntimeException("Stub!");
    }

    /**
     * Utility method that retrieves lightweight details about a single APK
     * file, including package name, split name, and install location.
     *
     * @param apkFile path to a single APK
     * @param flags optional parse flags, such as
     *            {@link #PARSE_COLLECT_CERTIFICATES}
     */
    public static ApkLite parseApkLite(final File apkFile, final int flags) throws PackageParserException {
        throw new RuntimeException("Stub!");
    }

    /**
     * Representation of a full package parsed from APK files on disk. A package
     * consists of a single base APK, and zero or more split APKs.
     */
    public final static class Package {
        public String packageName;

        // Names of any split APKs, ordered by parsed splitName.
        public String[] splitNames;

        // TODO: Work towards making these paths invariant.
        public String volumeUuid;

        /**
         * Path where this package was found on disk. For monolithic packages
         * this is path to single base APK file; for cluster packages this is
         * path to the cluster directory.
         */
        public String codePath;

        // Path of base APK.
        public String baseCodePath;
        // Paths of any split APKs, ordered by parsed splitName.
        public String[] splitCodePaths;

        // Revision code of base APK.
        public int baseRevisionCode;
        // Revision codes of any split APKs, ordered by parsed splitName.
        public int[] splitRevisionCodes;

        // Flags of any split APKs; ordered by parsed splitName.
        public int[] splitFlags;

        /**
         * Private flags of any split APKs; ordered by parsed splitName.
         *
         * {@hide}
         */
        public int[] splitPrivateFlags;

        public boolean baseHardwareAccelerated;

        // For now we only support one application per package.
        public ApplicationInfo applicationInfo = new ApplicationInfo();

        public final ArrayList<Permission> permissions = new ArrayList<>(0);
        public final ArrayList<PermissionGroup> permissionGroups = new ArrayList<>(0);
        public final ArrayList<Activity> activities = new ArrayList<>(0);
        public final ArrayList<Activity> receivers = new ArrayList<>(0);
        public final ArrayList<Provider> providers = new ArrayList<>(0);
        public final ArrayList<Service> services = new ArrayList<>(0);
        public final ArrayList<Instrumentation> instrumentation = new ArrayList<>(0);

        public final ArrayList<String> requestedPermissions = new ArrayList<>();

        public ArrayList<String> protectedBroadcasts;

        public ArrayList<String> libraryNames = null;
        public ArrayList<String> usesLibraries = null;
        public ArrayList<String> usesOptionalLibraries = null;
        public String[] usesLibraryFiles = null;

        public ArrayList<ActivityIntentInfo> preferredActivityFilters = null;

        public ArrayList<String> mOriginalPackages = null;
        public String mRealPackage = null;
        public ArrayList<String> mAdoptPermissions = null;

        // We store the application meta-data independently to avoid multiple unwanted references
        public Bundle mAppMetaData = null;

        // The version code declared for this package.
        public int mVersionCode;

        // The version name declared for this package.
        public String mVersionName;

        // The shared user id that this package wants to use.
        public String mSharedUserId;

        // The shared user label that this package wants to use.
        public int mSharedUserLabel;

        // Signatures that were read from the package.
        public Signature[] mSignatures;
        public SigningDetails mSigningDetails;
        public Certificate[][] mCertificates;

        // For use by package manager service for quick lookup of
        // preferred up order.
        public int mPreferredOrder = 0;

        // For use by package manager to keep track of where it needs to do dexopt.
		// public final ArraySet<String> mDexOptPerformed = new ArraySet<>(4);

        // For use by package manager to keep track of when a package was last used.
        public long mLastPackageUsageTimeInMills;

        // User set enabled state.
        // public int mSetEnabled = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
		
        // Whether the package has been stopped.
        // public boolean mSetStopped = false;

        // Additional data supplied by callers.
        public Object mExtras;

        // Applications hardware preferences
        public ArrayList<ConfigurationInfo> configPreferences = null;

        // Applications requested features
        public ArrayList<FeatureInfo> reqFeatures = null;

        // Applications requested feature groups
        public ArrayList<FeatureGroupInfo> featureGroups = null;

        public int installLocation;

        public boolean coreApp;

        // An app that's required for all users and cannot be uninstalled for a user.
        public boolean mRequiredForAllUsers;

        // The restricted account authenticator type that is used by this application.
        public String mRestrictedAccountType;

        // The required account type without which this application will not function.
        public String mRequiredAccountType;

        /**
         * Digest suitable for comparing whether this package's manifest is the
         * same as another.
         */
        public ManifestDigest manifestDigest;

        public String mOverlayTarget;
        public int mOverlayPriority;
        public boolean mTrustedOverlay;

        /**
         * Data used to feed the KeySetManagerService
         */
        public ArraySet<PublicKey> mSigningKeys;
        public ArraySet<String> mUpgradeKeySets;
        public ArrayMap<String, ArraySet<PublicKey>> mKeySetMapping;

        /**
         * The install time abi override for this package, if any.
         *
         * TODO: This seems like a horrible place to put the abiOverride because
         * this isn't something the packageParser parsers. However, this fits in with
         * the rest of the PackageManager where package scanning randomly pushes
         * and prods fields out of {@code this.applicationInfo}.
         */
        public String cpuAbiOverride;

        public Package(String packageName) {
            throw new RuntimeException("Stub!");
        }

        public List<String> getAllCodePaths() {
            throw new RuntimeException("Stub!");
        }

        /**
         * Filtered set of {@link #getAllCodePaths()} that excludes
         * resource-only APKs.
         */
        public List<String> getAllCodePathsExcludingResourceOnly() {
            throw new RuntimeException("Stub!");
        }

        public void setPackageName(final String newName) {
            throw new RuntimeException("Stub!");
        }

        public boolean hasComponentClassName(final String name) {
            throw new RuntimeException("Stub!");
        }

        public boolean isForwardLocked() {
            throw new RuntimeException("Stub!");
        }

        public boolean isSystemApp() {
            throw new RuntimeException("Stub!");
        }

        public boolean isPrivilegedApp() {
            throw new RuntimeException("Stub!");
        }

        public boolean isUpdatedSystemApp() {
            throw new RuntimeException("Stub!");
        }

        public boolean canHaveOatDir() {
            throw new RuntimeException("Stub!");
        }

        @Override
        public String toString() {
            throw new RuntimeException("Stub!");
        }
    }

    public static class Component<II extends IntentInfo> {
        public final Package owner;
        public final ArrayList<II> intents;
        public final String className;
        public Bundle metaData;

        ComponentName componentName;
        String componentShortName;

        public Component(final Package owner) {
            throw new RuntimeException("Stub!");
        }

        public Component(final ParsePackageItemArgs args, final PackageItemInfo outInfo) {
            throw new RuntimeException("Stub!");
        }

        public Component(final ParseComponentArgs args, final ComponentInfo outInfo) {
            throw new RuntimeException("Stub!");
        }

        public Component(final Component<II> clone) {
            throw new RuntimeException("Stub!");
        }

        public ComponentName getComponentName() {
            throw new RuntimeException("Stub!");
        }

        public void appendComponentShortName(final StringBuilder sb) {
            throw new RuntimeException("Stub!");
        }

        public void printComponentShortName(final PrintWriter pw) {
            throw new RuntimeException("Stub!");
        }

        public void setPackageName(final String packageName) {
            throw new RuntimeException("Stub!");
        }
    }

    public final static class Permission extends Component<IntentInfo> {
        public final PermissionInfo info;
        public boolean tree;
        public PermissionGroup group;

        public Permission(final Package owner) {
            super(owner);
            throw new RuntimeException("Stub!");
        }

        public Permission(final Package owner, final PermissionInfo info) {
            super(owner);
            throw new RuntimeException("Stub!");
        }

        @Override
        public void setPackageName(final String packageName) {
            throw new RuntimeException("Stub!");
        }

        @Override
        public String toString() {
            throw new RuntimeException("Stub!");
        }
    }

    public final static class PermissionGroup extends Component<IntentInfo> {
        public final PermissionGroupInfo info;

        public PermissionGroup(final Package owner) {
            super(owner);
            throw new RuntimeException("Stub!");
        }

        public PermissionGroup(final Package owner, final PermissionGroupInfo info) {
            super(owner);
            throw new RuntimeException("Stub!");
        }

        @Override
        public void setPackageName(final String packageName) {
            throw new RuntimeException("Stub!");
        }

        @Override
        public String toString() {
            throw new RuntimeException("Stub!");
        }
    }

    public final static class Activity extends Component<ActivityIntentInfo> {
        public final ActivityInfo info;

        public Activity(final ParseComponentArgs args, final ActivityInfo info) {
            super(args, info);
            throw new RuntimeException("Stub!");
        }

        @Override
        public void setPackageName(final String packageName) {
            throw new RuntimeException("Stub!");
        }

        @Override
        public String toString() {
            throw new RuntimeException("Stub!");
        }
    }

    public final static class Service extends Component<ServiceIntentInfo> {
        public final ServiceInfo info;

        public Service(final ParseComponentArgs args, final ServiceInfo info) {
            super(args, info);
            throw new RuntimeException("Stub!");
        }

        @Override
        public void setPackageName(final String packageName) {
            throw new RuntimeException("Stub!");
        }

        @Override
        public String toString() {
            throw new RuntimeException("Stub!");
        }
    }

    public final static class Provider extends Component<ProviderIntentInfo> {
        public final ProviderInfo info;
        public boolean syncable;

        public Provider(final ParseComponentArgs args, final ProviderInfo info) {
            super(args, info);
            throw new RuntimeException("Stub!");
        }

        public Provider(final Provider existingProvider) {
            super(existingProvider);
            throw new RuntimeException("Stub!");
        }

        @Override
        public void setPackageName(final String packageName) {
            throw new RuntimeException("Stub!");
        }

        @Override
        public String toString() {
            throw new RuntimeException("Stub!");
        }
    }

    public final static class Instrumentation extends Component<IntentInfo> {
        public final InstrumentationInfo info;

        public Instrumentation(final ParsePackageItemArgs args, final InstrumentationInfo info) {
            super(args, info);
            throw new RuntimeException("Stub!");
        }

        @Override
        public void setPackageName(final String packageName) {
            throw new RuntimeException("Stub!");
        }

        @Override
        public String toString() {
            throw new RuntimeException("Stub!");
        }
    }

    @SuppressLint("ParcelCreator")
    public static class IntentInfo extends IntentFilter {
        public boolean hasDefault;
        public int labelRes;
        public CharSequence nonLocalizedLabel;
        public int icon;
        public int logo;
        public int banner;
        public int preferred;
    }

    @SuppressLint("ParcelCreator")
    public final static class ActivityIntentInfo extends IntentInfo {
        public final Activity activity;

        public ActivityIntentInfo(final Activity activity) {
            throw new RuntimeException("Stub!");
        }

        @Override
        public String toString() {
            throw new RuntimeException("Stub!");
        }
    }

    @SuppressLint("ParcelCreator")
    public final static class ServiceIntentInfo extends IntentInfo {
        public final Service service;

        public ServiceIntentInfo(final Service service) {
            throw new RuntimeException("Stub!");
        }

        @Override
        public String toString() {
            throw new RuntimeException("Stub!");
        }
    }

    @SuppressLint("ParcelCreator")
    public static final class ProviderIntentInfo extends IntentInfo {
        public final Provider provider;

        public ProviderIntentInfo(final Provider provider) {
            throw new RuntimeException("Stub!");
        }

        @Override
        public String toString() {
            throw new RuntimeException("Stub!");
        }
    }

    public static class PackageParserException extends Exception {
        public PackageParserException(int error, String detailMessage) {
            super(detailMessage);
            throw new RuntimeException("Stub!");
        }

        public PackageParserException(int error, String detailMessage, Throwable throwable) {
            super(detailMessage, throwable);
            throw new RuntimeException("Stub!");
        }
    }

    public static class SigningDetails {
        public static final SigningDetails UNKNOWN = null;
        public Signature[] signatures;
        public Signature[] pastSigningCertificates;
    }
}

```

`Bcore/src/main/java/android/content/pm/PackageUserState.java`:

```java
package android.content.pm;

import android.util.ArraySet;

public class PackageUserState {
    public boolean stopped;
    public boolean notLaunched;
    public boolean installed;
    public boolean hidden; // Is the app restricted by owner/admin
    public int enabled;
    public boolean blockUninstall;

    public String lastDisableAppCaller;

    public ArraySet<String> disabledComponents;
    public ArraySet<String> enabledComponents;

    public int domainVerificationStatus;
    public int appLinkGeneration;

    public PackageUserState() {
        throw new RuntimeException("Stub!");
    }

    public PackageUserState(final PackageUserState o) {
        throw new RuntimeException("Stub!");
    }
}

```

`Bcore/src/main/java/android/content/pm/VerifierInfo.java`:

```java
package android.content.pm;

import android.os.Parcel;
import android.os.Parcelable;

import java.security.PublicKey;

public class VerifierInfo implements Parcelable {
    public static final Parcelable.Creator<VerifierInfo> CREATOR = new Parcelable.Creator<VerifierInfo>() {
        public VerifierInfo createFromParcel(final Parcel source) {
            return new VerifierInfo(source);
        }

        public VerifierInfo[] newArray(final int size) {
            return new VerifierInfo[size];
        }
    };

    public VerifierInfo(final String packageName, final PublicKey publicKey) {
        throw new RuntimeException("Stub!");
    }

    private VerifierInfo(final Parcel source) {
        throw new RuntimeException("Stub!");
    }

    @Override
    public int describeContents() {
        throw new RuntimeException("Stub!");
    }

    @Override
    public void writeToParcel(final Parcel dest, final int flags) {
        throw new RuntimeException("Stub!");
    }
}

```

`Bcore/src/main/java/android/location/LocationRequest.java`:

```java
package android.location;

import android.os.Parcel;
import android.os.Parcelable;

public final class LocationRequest implements Parcelable {
    public static final Creator<LocationRequest> CREATOR = new Creator<LocationRequest>() {
        @Override
        public LocationRequest createFromParcel(Parcel in) {
            return null;
        }

        @Override
        public LocationRequest[] newArray(int size) {
            return null;
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) { }
}

```

`Bcore/src/main/java/android/os/ParcelableException.java`:

```java
package android.os;

import android.annotation.TargetApi;

import java.io.IOException;

/**
 * Wrapper class that offers to transport typical {@link Throwable} across a
 * {@link Binder} call. This class is typically used to transport exceptions
 * that cannot be modified to add {@link Parcelable} behavior, such as
 * {@link IOException}.
 * <ul>
 * <li>The wrapped throwable must be defined as system class (that is, it must
 * be in the same {@link ClassLoader} as {@link Parcelable}).
 * <li>The wrapped throwable must support the
 * {@link Throwable#Throwable(String)} constructor.
 * <li>The receiver side must catch any thrown {@link ParcelableException} and
 * call {@link #maybeRethrow(Class)} for all expected exception types.
 * </ul>
 */
@TargetApi(Build.VERSION_CODES.O)
public final class ParcelableException extends RuntimeException implements Parcelable {
    public ParcelableException(Throwable t) {
        super(t);
    }

    public <T extends Throwable> void maybeRethrow(Class<T> clazz) throws T {
        throw new RuntimeException("Stub!");
    }

    public static Throwable readFromParcel(Parcel in) {
        throw new RuntimeException("Stub!");
    }

    public static void writeToParcel(Parcel out, Throwable t) {
        throw new RuntimeException("Stub!");
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        throw new RuntimeException("Stub!");
    }

    public static final Creator<ParcelableException> CREATOR = new Creator<ParcelableException>() {
        @Override
        public ParcelableException createFromParcel(Parcel source) {
            return new ParcelableException(readFromParcel(source));
        }

        @Override
        public ParcelableException[] newArray(int size) {
            return new ParcelableException[size];
        }
    };
}

```

`Bcore/src/main/java/android/os/ServiceManager.java`:

```java
package android.os;

public class ServiceManager {
	public static IBinder getService(String name) {
		throw new UnsupportedOperationException("Stub!");
	}
}

```

`Bcore/src/main/java/black/Reflector.java`:

```java
package black;

import android.os.Build;
import android.util.Log;

import org.lsposed.hiddenapibypass.HiddenApiBypass;

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.util.List;

@SuppressWarnings({"WeakerAccess", "unchecked"})
public class Reflector {
    private static final String TAG = "Reflector";
    private final Class<?> mClazz;

    private Reflector(Class<?> clazz) {
        mClazz = clazz;
    }

    public Class<?> getClazz() {
        return mClazz;
    }

    public static Reflector on(String name) {
        return new Reflector(findClass(name));
    }

    public static <T> MethodWrapper<T> wrap(Method method) {
        return new MethodWrapper<>(method);
    }

    public static <T> StaticMethodWrapper<T> wrapStatic(Method method) {
        return new StaticMethodWrapper<>(method);
    }

    public <T> MethodWrapper<T> method(String name, Class<?>... parameterTypes) {
        return method(mClazz, name, parameterTypes);
    }

    public static <T> MethodWrapper<T> method(Class<?> clazz, String name, Class<?>... parameterTypes) {
        Method method = getMethod(clazz, name, parameterTypes);
        if ((parameterTypes == null || parameterTypes.length == 0) && method == null) {
            method = findMethodNoChecks(clazz, name);
        }
        return wrap(method);
    }

    public <T> StaticMethodWrapper<T> staticMethod(String name, Class<?>... parameterTypes) {
        return staticMethod(mClazz, name, parameterTypes);
    }

    public static <T> StaticMethodWrapper<T> staticMethod(Class<?> clazz, String name, Class<?>... parameterTypes) {
        Method method = getMethod(clazz, name, parameterTypes);
        if ((parameterTypes == null || parameterTypes.length == 0) && method == null) {
            method = findMethodNoChecks(clazz, name);
        }
        return wrapStatic(method);
    }

    public static <T> FieldWrapper<T> wrap(Field field) {
        return new FieldWrapper<>(field);
    }

    public <T> FieldWrapper<T> field(String name) {
        return field(mClazz, name);
    }

    public static <T> FieldWrapper<T> field(Class<?> clazz, String name) {
        return wrap(getField(clazz, name));
    }

    public static <T> ConstructorWrapper<T> wrap(Constructor<T> constructor) {
        return new ConstructorWrapper<>(constructor);
    }

    public <T> ConstructorWrapper<T> constructor(Class<?>... parameterTypes) {
        return wrap(getConstructor(mClazz, parameterTypes));
    }

    public static Class<?> findClass(String name) {
        try {
            return Class.forName(name);
        } catch (ClassNotFoundException e) {
            Log.e(TAG, e.getMessage());
        }
        return null;
    }

    public static Method getMethod(Class<?> clazz, String name, Class<?>... parameterTypes) {
        return findMethod(clazz, name, parameterTypes);
    }

    public static Method findMethod(Class<?> clazz, String name, Class<?>... parameterTypes) {
        checkForFindMethod(parameterTypes);
        return findMethodNoChecks(clazz, name, parameterTypes);
    }

    public static Method findMethodNoChecks(Class<?> clazz, String name, Class<?>... parameterTypes) {
        while (clazz != null) {
            try {
                Method method = clazz.getDeclaredMethod(name, parameterTypes);
                method.setAccessible(true);
                return method;
            } catch (NoSuchMethodException e) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                    try {
                        Method method = HiddenApiBypass.getDeclaredMethod(clazz, name, parameterTypes);
                        method.setAccessible(true);
                        return method;
                    } catch (Exception ignored) { }
                }
            }
            clazz = clazz.getSuperclass();
        }
        return null;
    }

    public static Method findMethodNoChecks(Class<?> clazz, String name) {
        try {
            Method[] methods = clazz.getDeclaredMethods();
            for (Method method : methods) {
                if (method.getName().equals(name)) {
                    method.setAccessible(true);
                    return method;
                }
            }
        } catch (Throwable e) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                List<Method> methods = HiddenApiBypass.getDeclaredMethods(clazz);
                for (Method method : methods) {
                    if (method.getName().equals(name)) {
                        method.setAccessible(true);
                        return method;
                    }
                }
            }
        }
        return null;
    }

    public static Field getField(Class<?> clazz, String name) {
        return findField(clazz, name);
    }

    public static Field findField(Class<?> clazz, String name) {
        return findFieldNoChecks(clazz, name);
    }

    public static Field findFieldNoChecks(Class<?> clazz, String name) {
        while (clazz != null) {
            try {
                Field field = clazz.getDeclaredField(name);
                field.setAccessible(true);
                return field;
            } catch (NoSuchFieldException e) {
                try {
                    return findInstanceField(clazz, name);
                } catch (NoSuchFieldException ex) {
                    try {
                        return findStaticField(clazz, name);
                    } catch (NoSuchFieldException ignored) { }
                }
            }
            clazz = clazz.getSuperclass();
        }
        return null;
    }

    public static <T> Constructor<T> getConstructor(Class<?> clazz, Class<?>... parameterTypes) {
        return findConstructor(clazz, parameterTypes);
    }

    public static <T> Constructor<T> findConstructor(Class<?> clazz, Class<?>... parameterTypes) {
        checkForFindConstructor(parameterTypes);
        return findConstructorNoChecks(clazz, parameterTypes);
    }

    public static <T> Constructor<T> findConstructorNoChecks(Class<?> clazz, Class<?>... parameterTypes) {
        try {
            Constructor<T> constructor = (Constructor<T>) clazz.getDeclaredConstructor(parameterTypes);
            constructor.setAccessible(true);
            return constructor;
        } catch (NoSuchMethodException e) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                try {
                    Constructor<T> constructor = (Constructor<T>) HiddenApiBypass.getDeclaredConstructor(clazz, parameterTypes);
                    constructor.setAccessible(true);
                    return constructor;
                } catch (Exception ignored) { }
            }
        }
        return null;
    }

    private static Field findInstanceField(Class<?> clazz, String name) throws NoSuchFieldException {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            List<Field> fields = HiddenApiBypass.getInstanceFields(clazz);
            for (Field field : fields) {
                if (field.getName().equals(name)) {
                    field.setAccessible(true);
                    return field;
                }
            }
        }
        throw new NoSuchFieldException();
    }

    private static Field findStaticField(Class<?> clazz, String name) throws NoSuchFieldException {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            List<Field> fields = HiddenApiBypass.getStaticFields(clazz);
            for (Field field : fields) {
                if (field.getName().equals(name)) {
                    field.setAccessible(true);
                    return field;
                }
            }
        }
        throw new NoSuchFieldException();
    }

    private static void checkForFindMethod(Class<?>... parameterTypes) {
        if (parameterTypes != null) {
            for (int i = 0; i < parameterTypes.length; i++) {
                if (parameterTypes[i] == null) {
                    throw new NullPointerException("parameterTypes[" + i + "] == null");
                }
            }
        }
    }

    private static void checkForFindConstructor(Class<?>... parameterTypes) {
        if (parameterTypes != null) {
            for (int i = 0; i < parameterTypes.length; i++) {
                if (parameterTypes[i] == null) {
                    throw new NullPointerException("parameterTypes[" + i + "] == null");
                }
            }
        }
    }

    public static class MemberWrapper<M extends AccessibleObject & Member> {
        M member;

        MemberWrapper(M member) {
            if (member == null) {
                return;
            }

            member.setAccessible(true);
            this.member = member;
        }
    }

    public static class MethodWrapper<T> extends MemberWrapper<Method> {
        MethodWrapper(Method method) {
            super(method);
        }

        public T call(Object instance, Object... args) {
            try {
                return (T) member.invoke(instance, args);
            } catch (Throwable e) {
                e.printStackTrace();
            }
            return null;
        }
    }

    public static class StaticMethodWrapper<T> extends MemberWrapper<Method> {
        StaticMethodWrapper(Method method) {
            super(method);
        }

        public T call(Object... args) {
            try {
                return (T) member.invoke(null, args);
            } catch (Throwable e) {
                e.printStackTrace();
            }
            return null;
        }

        public <R> R callWithClass(Object... args) {
            try {
                return (R) member.invoke(null, args);
            } catch (Throwable e) {
                e.printStackTrace();
            }
            return null;
        }
    }

    public static class FieldWrapper<T> extends MemberWrapper<Field> {
        FieldWrapper(Field field) {
            super(field);
        }

        public T get(Object instance) {
            try {
                return (T) member.get(instance);
            } catch (Throwable e) {
                e.printStackTrace();
            }
            return null;
        }

        public T get() {
            return get(null);
        }

        public void set(Object instance, Object value) {
            try {
                member.set(instance, value);
            } catch (Throwable e) {
                e.printStackTrace();
            }
        }

        public void set(Object value) {
            set(null, value);
        }
    }

    public static class ConstructorWrapper<T> extends MemberWrapper<Constructor<T>> {
        ConstructorWrapper(Constructor<T> constructor) {
            super(constructor);
        }

        public T newInstance(Object... args) {
            try {
                return member.newInstance(args);
            } catch (Throwable e) {
                e.printStackTrace();
            }
            return null;
        }
    }
}

```

`Bcore/src/main/java/black/android/accounts/IAccountManager.java`:

```java
package black.android.accounts;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IAccountManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.accounts.IAccountManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/app/Activity.java`:

```java
package black.android.app;

import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.os.IBinder;

import black.Reflector;

public class Activity {
    public static final Reflector REF = Reflector.on("android.app.Activity");

    public static Reflector.FieldWrapper<ActivityInfo> mActivityInfo = REF.field("mActivityInfo");
    public static Reflector.FieldWrapper<Boolean> mFinished = REF.field("mFinished");
    public static Reflector.FieldWrapper<android.app.Activity> mParent = REF.field("mParent");
    public static Reflector.FieldWrapper<Integer> mResultCode = REF.field("mResultCode");
    public static Reflector.FieldWrapper<Intent> mResultData = REF.field("mResultData");
    public static Reflector.FieldWrapper<IBinder> mToken = REF.field("mToken");
}

```

`Bcore/src/main/java/black/android/app/ActivityClient.java`:

```java
package black.android.app;

import android.os.IInterface;

import black.Reflector;

public class ActivityClient {
    public static final Reflector REF = Reflector.on("android.app.ActivityClient");

    public static Reflector.FieldWrapper<Object> INTERFACE_SINGLETON = REF.field("INTERFACE_SINGLETON");

    public static Reflector.StaticMethodWrapper<Object> getInstance = REF.staticMethod("getInstance");
    public static Reflector.StaticMethodWrapper<Object> getActivityClientController = REF.staticMethod("getActivityClientController");

    public static class ActivityClientControllerSingleton {
        public static final Reflector REF = Reflector.on("android.app.ActivityClient$ActivityClientControllerSingleton");

        public static Reflector.FieldWrapper<IInterface> mKnownInstance = REF.field("mKnownInstance");
    }
}

```

`Bcore/src/main/java/black/android/app/ActivityManagerNative.java`:

```java
package black.android.app;

import android.os.IInterface;

import black.Reflector;

public class ActivityManagerNative {
    public static final Reflector REF = Reflector.on("android.app.ActivityManagerNative");

    public static Reflector.FieldWrapper<Object> gDefault = REF.field("gDefault");

    public static Reflector.StaticMethodWrapper<IInterface> getDefault = REF.staticMethod("getDefault");
}

```

`Bcore/src/main/java/black/android/app/ActivityManagerOreo.java`:

```java
package black.android.app;

import black.Reflector;

public class ActivityManagerOreo {
    public static final Reflector REF = Reflector.on("android.app.ActivityManager");

    public static Reflector.FieldWrapper<Object> IActivityManagerSingleton = REF.field("IActivityManagerSingleton");
}

```

`Bcore/src/main/java/black/android/app/ActivityTaskManager.java`:

```java
package black.android.app;

import black.Reflector;

public class ActivityTaskManager {
    public static final Reflector REF = Reflector.on("android.app.ActivityTaskManager");

    public static Reflector.FieldWrapper<Object> IActivityTaskManagerSingleton = REF.field("IActivityTaskManagerSingleton");
}

```

`Bcore/src/main/java/black/android/app/ActivityThread.java`:

```java
package black.android.app;

import android.app.Activity;
import android.app.Application;
import android.app.ContentProviderHolder;
import android.app.Instrumentation;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.ProviderInfo;
import android.content.pm.ServiceInfo;
import android.os.Handler;
import android.os.IBinder;
import android.os.IInterface;

import java.util.List;
import java.util.Map;

import black.Reflector;

public class ActivityThread {
    public static final Reflector REF = Reflector.on("android.app.ActivityThread");

    public static Reflector.FieldWrapper<IInterface> sPackageManager = REF.field("sPackageManager");
    public static Reflector.FieldWrapper<IInterface> sPermissionManager = REF.field("sPermissionManager");
    public static Reflector.FieldWrapper<Map<IBinder, Object>> mActivities = REF.field("mActivities");
    public static Reflector.FieldWrapper<Object> mBoundApplication = REF.field("mBoundApplication");
    public static Reflector.FieldWrapper<Handler> mH = REF.field("mH");
    public static Reflector.FieldWrapper<Application> mInitialApplication = REF.field("mInitialApplication");
    public static Reflector.FieldWrapper<Instrumentation> mInstrumentation = REF.field("mInstrumentation");
    public static Reflector.FieldWrapper<Map<?, ?>> mProviderMap = REF.field("mProviderMap");

    public static Reflector.StaticMethodWrapper<Object> currentActivityThread = REF.staticMethod("currentActivityThread");

    public static Reflector.MethodWrapper<IBinder> getApplicationThread = REF.method("getApplicationThread");
    public static Reflector.MethodWrapper<Object> getSystemContext = REF.method("getSystemContext");
    public static Reflector.MethodWrapper<Object> getLaunchingActivity = REF.method("getLaunchingActivity", IBinder.class);
    public static Reflector.MethodWrapper<Void> performNewIntents = REF.method("performNewIntents", IBinder.class, List.class);
    public static Reflector.MethodWrapper<Void> installProvider = REF.method("installProvider", Context.class, ContentProviderHolder.class, ProviderInfo.class, boolean.class, boolean.class, boolean.class);

    public static class CreateServiceData {
        public static final Reflector REF = Reflector.on("android.app.ActivityThread$CreateServiceData");

        public static Reflector.FieldWrapper<ServiceInfo> info = REF.field("info");
    }

    public static class H {
        public static final Reflector REF = Reflector.on("android.app.ActivityThread$H");

        public static Reflector.FieldWrapper<Integer> CREATE_SERVICE = REF.field("CREATE_SERVICE");
        public static Reflector.FieldWrapper<Integer> EXECUTE_TRANSACTION = REF.field("EXECUTE_TRANSACTION");
        public static Reflector.FieldWrapper<Integer> LAUNCH_ACTIVITY = REF.field("LAUNCH_ACTIVITY");
    }

    public static class AppBindData {
        public static final Reflector REF = Reflector.on("android.app.ActivityThread$AppBindData");

        public static Reflector.FieldWrapper<ApplicationInfo> appInfo = REF.field("appInfo");
        public static Reflector.FieldWrapper<Object> info = REF.field("info");
        public static Reflector.FieldWrapper<ComponentName> instrumentationName = REF.field("instrumentationName");
        public static Reflector.FieldWrapper<String> processName = REF.field("processName");
        public static Reflector.FieldWrapper<List<ProviderInfo>> providers = REF.field("providers");
    }

    public static class ProviderClientRecordP {
        public static final Reflector REF = Reflector.on("android.app.ActivityThread$ProviderClientRecord");

        public static Reflector.FieldWrapper<String[]> mNames = REF.field("mNames");
        public static Reflector.FieldWrapper<IInterface> mProvider = REF.field("mProvider");
    }

    public static class ActivityClientRecord {
        public static final Reflector REF = Reflector.on("android.app.ActivityThread$ActivityClientRecord");

        public static Reflector.FieldWrapper<Activity> activity = REF.field("activity");
        public static Reflector.FieldWrapper<ActivityInfo> activityInfo = REF.field("activityInfo");
        public static Reflector.FieldWrapper<Intent> intent = REF.field("intent");
        public static Reflector.FieldWrapper<IBinder> token = REF.field("token");
        public static Reflector.FieldWrapper<Object> packageInfo = REF.field("packageInfo");
    }

    public static class AndroidOs {
        public static final Reflector REF = Reflector.on("android.app.ActivityThread$AndroidOs");
    }
}

```

`Bcore/src/main/java/black/android/app/ActivityThreadNMR1.java`:

```java
package black.android.app;

import android.os.IBinder;

import java.util.List;

import black.Reflector;

public class ActivityThreadNMR1 {
    public static final Reflector REF = Reflector.on("android.app.ActivityThread");

    public static Reflector.MethodWrapper<Void> performNewIntents = REF.method("performNewIntents", IBinder.class, List.class, boolean.class);
}

```

`Bcore/src/main/java/black/android/app/ActivityThreadQ.java`:

```java
package black.android.app;

import android.os.IBinder;

import java.util.List;

import black.Reflector;

public class ActivityThreadQ {
    public static final Reflector REF = Reflector.on("android.app.ActivityThread");

    public static Reflector.MethodWrapper<Void> handleNewIntent = REF.method("handleNewIntent", IBinder.class, List.class);
}

```

`Bcore/src/main/java/black/android/app/AppOpsManager.java`:

```java
package black.android.app;

import android.os.IInterface;

import black.Reflector;

public class AppOpsManager {
    public static final Reflector REF = Reflector.on("android.app.AppOpsManager");

    public static Reflector.FieldWrapper<IInterface> mService = REF.field("mService");
}

```

`Bcore/src/main/java/black/android/app/ApplicationPackageManager.java`:

```java
package black.android.app;

import android.os.IInterface;

import black.Reflector;

public class ApplicationPackageManager {
    public static final Reflector REF = Reflector.on("android.app.ApplicationPackageManager");

    public static Reflector.FieldWrapper<IInterface> mPM = REF.field("mPM");
    public static Reflector.FieldWrapper<Object> mPermissionManager = REF.field("mPermissionManager");
}

```

`Bcore/src/main/java/black/android/app/ApplicationThreadNative.java`:

```java
package black.android.app;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class ApplicationThreadNative {
    public static final Reflector REF = Reflector.on("android.app.ApplicationThreadNative");

    public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
}

```

`Bcore/src/main/java/black/android/app/ContextImpl.java`:

```java
package black.android.app;

import android.content.Context;
import android.content.pm.PackageManager;

import black.Reflector;

public class ContextImpl {
    public static final Reflector REF = Reflector.on("android.app.ContextImpl");

    public static Reflector.FieldWrapper<String> mBasePackageName = REF.field("mBasePackageName");
    public static Reflector.FieldWrapper<Object> mPackageInfo = REF.field("mPackageInfo");
    public static Reflector.FieldWrapper<PackageManager> mPackageManager = REF.field("mPackageManager");

    public static Reflector.MethodWrapper<Void> setOuterContext = REF.method("setOuterContext", Context.class);
    public static Reflector.MethodWrapper<Object> getAttributionSource = REF.method("getAttributionSource");
}

```

`Bcore/src/main/java/black/android/app/ContextImplKitkat.java`:

```java
package black.android.app;

import black.Reflector;

public class ContextImplKitkat {
    public static final Reflector REF = Reflector.on("android.app.ContextImpl");

    public static Reflector.FieldWrapper<String> mOpPackageName = REF.field("mOpPackageName");
}

```

`Bcore/src/main/java/black/android/app/IActivityManager.java`:

```java
package black.android.app;

import android.content.Intent;
import android.content.pm.ProviderInfo;
import android.os.Bundle;
import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IActivityManager {
    public static final Reflector REF = Reflector.on("android.app.IActivityManager");

    public static Reflector.MethodWrapper<Integer> getTaskForActivity = REF.method("getTaskForActivity", IBinder.class, boolean.class);
    public static Reflector.MethodWrapper<Void> setRequestedOrientation = REF.method("setRequestedOrientation", IBinder.class, int.class);
    public static Reflector.MethodWrapper<Integer> startActivity = REF.method("startActivity", Reflector.findClass("android.app.IApplicationThread"), String.class, Intent.class, String.class, IBinder.class, String.class, int.class, int.class, Reflector.findClass("android.app.ProfilerInfo"), Bundle.class);

    public static class ContentProviderHolder {
        public static final Reflector REF = Reflector.on("android.app.IActivityManager$ContentProviderHolder");

        public static Reflector.FieldWrapper<ProviderInfo> info = REF.field("info");
        public static Reflector.FieldWrapper<IInterface> provider = REF.field("provider");
    }
}

```

`Bcore/src/main/java/black/android/app/IActivityManagerL.java`:

```java
package black.android.app;

import android.content.Intent;
import android.os.IBinder;

import black.Reflector;

public class IActivityManagerL {
    public static final Reflector REF = Reflector.on("android.app.IActivityManager");

    public static Reflector.MethodWrapper<Boolean> finishActivity = REF.method("finishActivity", IBinder.class, int.class, Intent.class, boolean.class);
}

```

`Bcore/src/main/java/black/android/app/IActivityManagerN.java`:

```java
package black.android.app;

import android.content.Intent;
import android.os.IBinder;

import black.Reflector;

public class IActivityManagerN {
    public static final Reflector REF = Reflector.on("android.app.IActivityManager");

    public static Reflector.MethodWrapper<Boolean> finishActivity = REF.method("finishActivity", IBinder.class, int.class, Intent.class, int.class);
}

```

`Bcore/src/main/java/black/android/app/IActivityTaskManager.java`:

```java
package black.android.app;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IActivityTaskManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.app.IActivityTaskManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/app/IAlarmManager.java`:

```java
package black.android.app;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IAlarmManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.app.IAlarmManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/app/IApplicationThread.java`:

```java
package black.android.app;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IApplicationThread {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.app.IApplicationThread$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/app/ISearchManager.java`:

```java
package black.android.app;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 19:57
 **/
public class ISearchManager {
    public static final Reflector REF = Reflector.on("android.app.ISearchManager");

    public static class Stub {
        public static final Reflector REF = Reflector.on("android.app.ISearchManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/app/IServiceConnectionO.java`:

```java
package black.android.app;

import android.content.ComponentName;
import android.os.IBinder;

import black.Reflector;

public class IServiceConnectionO {
    public static final Reflector REF = Reflector.on("android.app.IServiceConnection");

    public static Reflector.MethodWrapper<Void> connected = REF.method("connected", ComponentName.class, IBinder.class, boolean.class);
}

```

`Bcore/src/main/java/black/android/app/LoadedApk.java`:

```java
package black.android.app;

import android.app.Application;
import android.app.Instrumentation;
//import android.content.IIntentReceiver;
import android.content.ServiceConnection;
import android.content.pm.ApplicationInfo;

import java.lang.ref.WeakReference;

import black.Reflector;
import black.android.content.IIntentReceiver;

public class LoadedApk {

    public static final Reflector REF = Reflector.on("android.app.LoadedApk");

    public static Reflector.FieldWrapper<ApplicationInfo> mApplicationInfo = REF.field("mApplicationInfo");
    public static Reflector.FieldWrapper<Boolean> mSecurityViolation = REF.field("mSecurityViolation");

    public static Reflector.MethodWrapper<ClassLoader> getClassLoader = REF.method("getClassLoader");
    public static Reflector.MethodWrapper<Application> makeApplication = REF.method("makeApplication", boolean.class, Instrumentation.class);

    public static class ServiceDispatcher {
        public static final Reflector REF = Reflector.on("android.app.LoadedApk$ServiceDispatcher");

        public static Reflector.FieldWrapper<ServiceConnection> mConnection = REF.field("mConnection");

        public static class InnerConnection {
            public static final Reflector REF = Reflector.on("android.app.LoadedApk$ServiceDispatcher$InnerConnection");

            public static Reflector.FieldWrapper<WeakReference<?>> mDispatcher = REF.field("mDispatcher");
        }
    }

    public static class ReceiverDispatcher {
        public static final Reflector REF = Reflector.on("android.app.LoadedApk$ReceiverDispatcher");

      public static Reflector.FieldWrapper<IIntentReceiver> mIIntentReceiver = REF.field("mIIntentReceiver");

        public static class InnerReceiver {
            public static final Reflector REF = Reflector.on("android.app.LoadedApk$ReceiverDispatcher$InnerReceiver");

            public static Reflector.FieldWrapper<WeakReference<?>> mDispatcher = REF.field("mDispatcher");
        }
    }
}

```

`Bcore/src/main/java/black/android/app/NotificationChannel.java`:

```java
package black.android.app;

import black.Reflector;

public class NotificationChannel {
    public static final Reflector REF = Reflector.on("android.app.NotificationChannel");

    public static Reflector.FieldWrapper<String> mId = REF.field("mId");
}

```

`Bcore/src/main/java/black/android/app/NotificationChannelGroup.java`:

```java
package black.android.app;

import java.util.List;

import black.Reflector;

public class NotificationChannelGroup {
    public static final Reflector REF = Reflector.on("android.app.NotificationChannelGroup");

    public static Reflector.FieldWrapper<List<android.app.NotificationChannel>> mChannels = REF.field("mChannels");
    public static Reflector.FieldWrapper<String> mId = REF.field("mId");
}

```

`Bcore/src/main/java/black/android/app/NotificationManager.java`:

```java
package black.android.app;

import android.os.IInterface;

import black.Reflector;

public class NotificationManager {
    public static final Reflector REF = Reflector.on("android.app.NotificationManager");

    public static Reflector.FieldWrapper<IInterface> sService = REF.field("sService");
    public static Reflector.StaticMethodWrapper<IInterface> getService = REF.staticMethod("getService");
}

```

`Bcore/src/main/java/black/android/app/NotificationO.java`:

```java
package black.android.app;

import black.Reflector;

public class NotificationO {
    public static final Reflector REF = Reflector.on("android.app.Notification");

    public static Reflector.FieldWrapper<String> mChannelId = REF.field("mChannelId");
    public static Reflector.FieldWrapper<String> mGroupKey = REF.field("mGroupKey");
}

```

`Bcore/src/main/java/black/android/app/Service.java`:

```java
package black.android.app;

import android.app.ActivityThread;
import android.app.Application;
import android.content.Context;
import android.os.IBinder;

import black.Reflector;

public class Service {
    public static final Reflector REF = Reflector.on("android.app.Service");

    public static Reflector.MethodWrapper<Void> attach = REF.method("attach", Context.class, ActivityThread.class, String.class, IBinder.class, Application.class, Object.class);
}

```

`Bcore/src/main/java/black/android/app/admin/IDevicePolicyManager.java`:

```java
package black.android.app.admin;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IDevicePolicyManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.app.admin.IDevicePolicyManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/app/job/IJobScheduler.java`:

```java
package black.android.app.job;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IJobScheduler {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.app.job.IJobScheduler$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/app/job/JobInfo.java`:

```java
package black.android.app.job;

import android.content.ComponentName;

import black.Reflector;

public class JobInfo {
    public static final Reflector REF = Reflector.on("android.app.job.JobInfo");

    public static Reflector.FieldWrapper<ComponentName> service = REF.field("service");
}

```

`Bcore/src/main/java/black/android/app/servertransaction/ClientTransaction.java`:

```java
package black.android.app.servertransaction;

import android.os.IBinder;

import java.util.List;

import black.Reflector;

public class ClientTransaction {
    public static final Reflector REF = Reflector.on("android.app.servertransaction.ClientTransaction");

    public static Reflector.FieldWrapper<List<Object>> mActivityCallbacks = REF.field("mActivityCallbacks");
    public static Reflector.FieldWrapper<IBinder> mActivityToken = REF.field("mActivityToken");
}

```

`Bcore/src/main/java/black/android/app/servertransaction/LaunchActivityItem.java`:

```java
package black.android.app.servertransaction;

import android.content.Intent;
import android.content.pm.ActivityInfo;

import black.Reflector;

public class LaunchActivityItem {
    public static final Reflector REF = Reflector.on("android.app.servertransaction.LaunchActivityItem");

    public static Reflector.FieldWrapper<ActivityInfo> mInfo = REF.field("mInfo");
    public static Reflector.FieldWrapper<Intent> mIntent = REF.field("mIntent");
}

```

`Bcore/src/main/java/black/android/app/usage/IStorageStatsManager.java`:

```java
package black.android.app.usage;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IStorageStatsManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.app.usage.IStorageStatsManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/bluetooth/IBluetoothManager.java`:

```java
package black.android.bluetooth;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IBluetoothManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.bluetooth.IBluetoothManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/content/AttributionSource.java`:

```java
package black.android.content;

import black.Reflector;

public class AttributionSource {
    public static final Reflector REF = Reflector.on("android.content.AttributionSource");

    public static Reflector.FieldWrapper<Object> mAttributionSourceState = REF.field("mAttributionSourceState");

    public static Reflector.MethodWrapper<Object> getNext = REF.method("getNext");
}

```

`Bcore/src/main/java/black/android/content/AttributionSourceState.java`:

```java
package black.android.content;

import black.Reflector;

public class AttributionSourceState {
    public static final Reflector REF = Reflector.on("android.content.AttributionSourceState");

    public static Reflector.FieldWrapper<String> packageName = REF.field("packageName");
    public static Reflector.FieldWrapper<Integer> uid = REF.field("uid");
}

```

`Bcore/src/main/java/black/android/content/BroadcastReceiver.java`:

```java
package black.android.content;

import android.os.Bundle;
import android.os.IBinder;

import black.Reflector;

public class BroadcastReceiver {
    public static final Reflector REF = Reflector.on("android.content.BroadcastReceiver");

    public static Reflector.MethodWrapper<android.content.BroadcastReceiver.PendingResult> getPendingResult = REF.method("getPendingResult");
    public static Reflector.MethodWrapper<Void> setPendingResult = REF.method("setPendingResult", Reflector.findClass("android.content.BroadcastReceiver$PendingResult"));

    public static class PendingResultM {
        public static final Reflector REF = Reflector.on("android.content.BroadcastReceiver$PendingResult");

        public static Reflector.ConstructorWrapper<android.content.BroadcastReceiver.PendingResult> _new = REF.constructor(int.class, String.class, Bundle.class, int.class, boolean.class, boolean.class, IBinder.class, int.class, int.class);

        public static Reflector.FieldWrapper<Boolean> mAbortBroadcast = REF.field("mAbortBroadcast");
        public static Reflector.FieldWrapper<Boolean> mFinished = REF.field("mFinished");
        public static Reflector.FieldWrapper<Integer> mFlags = REF.field("mFlags");
        public static Reflector.FieldWrapper<Boolean> mInitialStickyHint = REF.field("mInitialStickyHint");
        public static Reflector.FieldWrapper<Boolean> mOrderedHint = REF.field("mOrderedHint");
        public static Reflector.FieldWrapper<String> mResultData = REF.field("mResultData");
        public static Reflector.FieldWrapper<Bundle> mResultExtras = REF.field("mResultExtras");
        public static Reflector.FieldWrapper<Integer> mSendingUser = REF.field("mSendingUser");
        public static Reflector.FieldWrapper<IBinder> mToken = REF.field("mToken");
        public static Reflector.FieldWrapper<Integer> mType = REF.field("mType");
    }

    public static class PendingResult {
        public static final Reflector REF = Reflector.on("android.content.BroadcastReceiver$PendingResult");

        public static Reflector.ConstructorWrapper<android.content.BroadcastReceiver.PendingResult> _new = REF.constructor(int.class, String.class, Bundle.class, int.class, boolean.class, boolean.class, IBinder.class, int.class);

        public static Reflector.FieldWrapper<Boolean> mAbortBroadcast = REF.field("mAbortBroadcast");
        public static Reflector.FieldWrapper<Boolean> mFinished = REF.field("mFinished");
        public static Reflector.FieldWrapper<Boolean> mInitialStickyHint = REF.field("mInitialStickyHint");
        public static Reflector.FieldWrapper<Boolean> mOrderedHint = REF.field("mOrderedHint");
        public static Reflector.FieldWrapper<String> mResultData = REF.field("mResultData");
        public static Reflector.FieldWrapper<Bundle> mResultExtras = REF.field("mResultExtras");
        public static Reflector.FieldWrapper<Integer> mSendingUser = REF.field("mSendingUser");
        public static Reflector.FieldWrapper<IBinder> mToken = REF.field("mToken");
        public static Reflector.FieldWrapper<Integer> mType = REF.field("mType");
    }
}

```

`Bcore/src/main/java/black/android/content/ContentProviderClient.java`:

```java
package black.android.content;

import android.os.IInterface;

import black.Reflector;

public class ContentProviderClient {
    public static final Reflector REF = Reflector.on("android.content.ContentProviderClient");

    public static Reflector.FieldWrapper<IInterface> mContentProvider = REF.field("mContentProvider");
}

```

`Bcore/src/main/java/black/android/content/ContentProviderHolderOreo.java`:

```java
package black.android.content;

import android.os.IInterface;

import black.Reflector;

public class ContentProviderHolderOreo {
    public static final Reflector REF = Reflector.on("android.app.ContentProviderHolder");

    public static Reflector.FieldWrapper<IInterface> provider = REF.field("provider");
}

```

`Bcore/src/main/java/black/android/content/ContentProviderNative.java`:

```java
package black.android.content;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class ContentProviderNative {
    public static final Reflector REF = Reflector.on("android.content.ContentProviderNative");

    public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
}

```

`Bcore/src/main/java/black/android/content/ContentResolver.java`:

```java
package black.android.content;

import black.Reflector;

public class ContentResolver {
    public static final Reflector REF = Reflector.on("android.content.ContentResolver");

    public static Reflector.FieldWrapper<String> mPackageName = REF.field("mPackageName");
}

```

`Bcore/src/main/java/black/android/content/IContentService.java`:

```java
package black.android.content;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IContentService {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.content.IContentService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/content/IIntentReceiver.java`:

```java
package black.android.content;

import android.content.Intent;
import android.os.Bundle;

import black.Reflector;

public class IIntentReceiver {
    public static final Reflector REF = Reflector.on("android.content.IIntentReceiver");

    public static Reflector.MethodWrapper<Void> performReceive = REF.method("performReceive", Intent.class, int.class, String.class, Bundle.class, boolean.class, boolean.class, int.class);
}

```

`Bcore/src/main/java/black/android/content/IRestrictionsManager.java`:

```java
package black.android.content;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IRestrictionsManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.content.IRestrictionsManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/content/pm/ApplicationInfoL.java`:

```java
package black.android.content.pm;

import black.Reflector;

public class ApplicationInfoL {
    public static final Reflector REF = Reflector.on("android.content.pm.ApplicationInfo");

    public static Reflector.FieldWrapper<String> primaryCpuAbi = REF.field("primaryCpuAbi");
    public static Reflector.FieldWrapper<String> scanPublicSourceDir = REF.field("scanPublicSourceDir");
    public static Reflector.FieldWrapper<String> scanSourceDir = REF.field("scanSourceDir");
}

```

`Bcore/src/main/java/black/android/content/pm/ApplicationInfoN.java`:

```java
package black.android.content.pm;

import black.Reflector;

public class ApplicationInfoN {
    public static final Reflector REF = Reflector.on("android.content.pm.ApplicationInfo");

    public static Reflector.FieldWrapper<String> credentialEncryptedDataDir = REF.field("credentialEncryptedDataDir");
    public static Reflector.FieldWrapper<String> credentialProtectedDataDir = REF.field("credentialProtectedDataDir");
    public static Reflector.FieldWrapper<String> deviceProtectedDataDir = REF.field("deviceProtectedDataDir");
}

```

`Bcore/src/main/java/black/android/content/pm/ILauncherApps.java`:

```java
package black.android.content.pm;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class ILauncherApps {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.content.pm.ILauncherApps$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/content/pm/IShortcutService.java`:

```java
package black.android.content.pm;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IShortcutService {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.content.pm.IShortcutService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/content/pm/PackageParser.java`:

```java
package black.android.content.pm;

import android.content.pm.ApplicationInfo;
import android.content.pm.Signature;
import android.util.DisplayMetrics;

import java.io.File;

import black.Reflector;

public class PackageParser {
    public static final Reflector REF = Reflector.on("android.content.pm.PackageParser");

    public static Reflector.MethodWrapper<Void> collectCertificates = REF.method("collectCertificates", android.content.pm.PackageParser.Package.class, int.class);
    public static Reflector.MethodWrapper<android.content.pm.PackageParser.Package> parsePackage = REF.method("parsePackage", File.class, String.class, DisplayMetrics.class, int.class);

    public static class Package {
        public static final Reflector REF = Reflector.on("android.content.pm.PackageParser$Package");

        public static Reflector.FieldWrapper<ApplicationInfo> applicationInfo = REF.field("applicationInfo");
    }

    public static class SigningDetails {
        public static final Reflector REF = Reflector.on("android.content.pm.PackageParser$SigningDetails");

        public static Reflector.FieldWrapper<Signature[]> signatures = REF.field("signatures");
    }
}

```

`Bcore/src/main/java/black/android/content/pm/PackageParserLollipop.java`:

```java
package black.android.content.pm;

import android.content.pm.PackageParser;
import android.content.pm.PackageParser.Package;

import java.io.File;

import black.Reflector;

public class PackageParserLollipop {
    public static final Reflector REF = Reflector.on("android.content.pm.PackageParser");

    public static Reflector.ConstructorWrapper<PackageParser> _new = REF.constructor();

    public static Reflector.MethodWrapper<Void> collectCertificates = REF.method("collectCertificates", Package.class, int.class);
    public static Reflector.MethodWrapper<Package> parsePackage = REF.method("parsePackage", File.class, int.class);
}

```

`Bcore/src/main/java/black/android/content/pm/PackageParserLollipop22.java`:

```java
package black.android.content.pm;

import android.content.pm.PackageParser;
import android.content.pm.PackageParser.Package;

import java.io.File;

import black.Reflector;

public class PackageParserLollipop22 {
    public static final Reflector REF = Reflector.on("android.content.pm.PackageParser");

    public static Reflector.ConstructorWrapper<PackageParser> _new = REF.constructor();

    public static Reflector.MethodWrapper<Void> collectCertificates = REF.method("collectCertificates", Package.class, int.class);
    public static Reflector.MethodWrapper<Package> parsePackage = REF.method("parsePackage", File.class, int.class);
}

```

`Bcore/src/main/java/black/android/content/pm/PackageParserMarshmallow.java`:

```java
package black.android.content.pm;

import android.content.pm.PackageParser;
import android.content.pm.PackageParser.Package;

import java.io.File;

import black.Reflector;

public class PackageParserMarshmallow {
    public static final Reflector REF = Reflector.on("android.content.pm.PackageParser");

    public static Reflector.ConstructorWrapper<PackageParser> _new = REF.constructor();

    public static Reflector.MethodWrapper<Void> collectCertificates = REF.method("collectCertificates", Package.class, int.class);
    public static Reflector.MethodWrapper<Package> parsePackage = REF.method("parsePackage", File.class, int.class);
}

```

`Bcore/src/main/java/black/android/content/pm/PackageParserNougat.java`:

```java
package black.android.content.pm;

import android.content.pm.PackageParser;

import black.Reflector;

public class PackageParserNougat {
    public static final Reflector REF = Reflector.on("android.content.pm.PackageParser");

    public static Reflector.StaticMethodWrapper<Void> collectCertificates = REF.staticMethod("collectCertificates", PackageParser.Package.class, int.class);
}

```

`Bcore/src/main/java/black/android/content/pm/PackageParserPie.java`:

```java
package black.android.content.pm;

import android.content.pm.PackageParser;

import java.io.File;

import black.Reflector;

public class PackageParserPie {
    public static final Reflector REF = Reflector.on("android.content.pm.PackageParser");

    public static Reflector.ConstructorWrapper<PackageParser> _new = REF.constructor();

    public static Reflector.StaticMethodWrapper<Void> collectCertificates = REF.staticMethod("collectCertificates", PackageParser.Package.class, boolean.class);

    public static Reflector.MethodWrapper<PackageParser.Package> parsePackage = REF.method("parsePackage", File.class, int.class);
}

```

`Bcore/src/main/java/black/android/content/pm/ParceledListSlice.java`:

```java
package black.android.content.pm;

import java.util.List;

import black.Reflector;

public class ParceledListSlice {
    public static final Reflector REF = Reflector.on("android.content.pm.ParceledListSlice");

    public static Reflector.ConstructorWrapper<Object> _new0 = REF.constructor();
    public static Reflector.ConstructorWrapper<Object> _new1 = REF.constructor(List.class);

    public static Reflector.MethodWrapper<Boolean> append = REF.method("append", Object.class);
    public static Reflector.MethodWrapper<List<?>> getList = REF.method("getList");
    public static Reflector.MethodWrapper<Void> setLastSlice = REF.method("setLastSlice", boolean.class);
}

```

`Bcore/src/main/java/black/android/content/pm/SigningInfo.java`:

```java
package black.android.content.pm;

import android.content.pm.PackageParser.SigningDetails;

import black.Reflector;

public class SigningInfo {
    public static final Reflector REF = Reflector.on("android.content.pm.SigningInfo");

    public static Reflector.ConstructorWrapper<android.content.pm.SigningInfo> _new = REF.constructor(SigningDetails.class);
}

```

`Bcore/src/main/java/black/android/content/pm/UserInfo.java`:

```java
package black.android.content.pm;

import black.Reflector;

public class UserInfo {
    public static final Reflector REF = Reflector.on("android.content.pm.UserInfo");

    public static Reflector.ConstructorWrapper<Object> _new = REF.constructor(int.class, String.class, int.class);

    public static Reflector.FieldWrapper<Integer> FLAG_PRIMARY = REF.field("FLAG_PRIMARY");
}

```

`Bcore/src/main/java/black/android/content/res/AssetManager.java`:

```java
package black.android.content.res;

import black.Reflector;

public class AssetManager {
    public static final Reflector REF = Reflector.on("android.content.res.AssetManager");

    public static Reflector.ConstructorWrapper<android.content.res.AssetManager> _new = REF.constructor();

    public static Reflector.MethodWrapper<Integer> addAssetPath = REF.method("addAssetPath", String.class);
}

```

`Bcore/src/main/java/black/android/ddm/DdmHandleAppName.java`:

```java
package black.android.ddm;

import black.Reflector;

public class DdmHandleAppName {
    public static final Reflector REF = Reflector.on("android.ddm.DdmHandleAppName");

    public static Reflector.StaticMethodWrapper<Void> setAppName = REF.staticMethod("setAppName", String.class, int.class);
}

```

`Bcore/src/main/java/black/android/graphics/Compatibility.java`:

```java
package black.android.graphics;

import black.Reflector;

public class Compatibility {
    public static final Reflector REF = Reflector.on("android.graphics.Compatibility");

    public static Reflector.StaticMethodWrapper<Void> setTargetSdkVersion = REF.staticMethod("setTargetSdkVersion", int.class);
}

```

`Bcore/src/main/java/black/android/hardware/display/DisplayManagerGlobal.java`:

```java
package black.android.hardware.display;

import android.os.IInterface;

import black.Reflector;

public class DisplayManagerGlobal {
    public static final Reflector REF = Reflector.on("android.hardware.display.DisplayManagerGlobal");

    public static Reflector.FieldWrapper<IInterface> mDm = REF.field("mDm");

    public static Reflector.StaticMethodWrapper<Object> getInstance = REF.staticMethod("getInstance");
}

```

`Bcore/src/main/java/black/android/hardware/location/IContextHubService.java`:

```java
package black.android.hardware.location;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IContextHubService {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.hardware.location.IContextHubService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/location/ILocationListener.java`:

```java
package black.android.location;

import android.location.Location;
import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class ILocationListener {
    public static final Reflector REF = Reflector.on("android.location.ILocationListener");

    public static Reflector.MethodWrapper<Void> onLocationChanged = REF.method("onLocationChanged", Location.class);

    public static class Stub {
        public static final Reflector REF = Reflector.on("android.location.ILocationListener$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/location/ILocationManager.java`:

```java
package black.android.location;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class ILocationManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.location.ILocationManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/location/LocationManager.java`:

```java
package black.android.location;

import black.Reflector;

public class LocationManager {
    public static class GnssStatusListenerTransport {
        public static final Reflector REF = Reflector.on("android.location.LocationManager$GnssStatusListenerTransport");

        public static Reflector.MethodWrapper<Void> onGnssStarted = REF.method("onGnssStarted");
        public static Reflector.MethodWrapper<Void> onNmeaReceived = REF.method("onNmeaReceived", long.class, String.class);
    }

    public static class GpsStatusListenerTransport {
        public static final Reflector REF = Reflector.on("android.location.LocationManager$GpsStatusListenerTransport");

        public static Reflector.MethodWrapper<Void> onNmeaReceived = REF.method("onNmeaReceived", long.class, String.class);
    }

    public static class LocationListenerTransport {
        public static final Reflector REF = Reflector.on("android.location.LocationManager$LocationListenerTransport");

        public static Reflector.FieldWrapper<Object> mListener = REF.field("mListener");
    }
}

```

`Bcore/src/main/java/black/android/location/provider/ProviderProperties.java`:

```java
package black.android.location.provider;

import black.Reflector;

public class ProviderProperties {
    public static final Reflector REF = Reflector.on("android.location.provider.ProviderProperties");

    public static Reflector.FieldWrapper<Boolean> mHasNetworkRequirement = REF.field("mHasNetworkRequirement");
    public static Reflector.FieldWrapper<Boolean> mHasCellRequirement = REF.field("mHasCellRequirement");
}

```

`Bcore/src/main/java/black/android/media/IMediaRouterService.java`:

```java
package black.android.media;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IMediaRouterService {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.media.IMediaRouterService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/media/session/ISessionManager.java`:

```java
package black.android.media.session;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class ISessionManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.media.session.ISessionManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/net/IConnectivityManager.java`:

```java
package black.android.net;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IConnectivityManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.net.IConnectivityManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/net/IVpnManager.java`:

```java
package black.android.net;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IVpnManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.net.IVpnManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/net/wifi/IWifiManager.java`:

```java
package black.android.net.wifi;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IWifiManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.net.wifi.IWifiManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/net/wifi/WifiInfo.java`:

```java
package black.android.net.wifi;

import black.Reflector;

public class WifiInfo {
    public static final Reflector REF = Reflector.on("android.net.wifi.WifiInfo");

    public static Reflector.FieldWrapper<String> mBSSID = REF.field("mBSSID");
    public static Reflector.FieldWrapper<String> mMacAddress = REF.field("mMacAddress");
    public static Reflector.FieldWrapper<Object> mWifiSsid = REF.field("mWifiSsid");
}

```

`Bcore/src/main/java/black/android/net/wifi/WifiSsid.java`:

```java
package black.android.net.wifi;

import black.Reflector;

public class WifiSsid {
    public static final Reflector REF = Reflector.on("android.net.wifi.WifiSsid");

    public static Reflector.StaticMethodWrapper<Object> createFromAsciiEncoded = REF.staticMethod("createFromAsciiEncoded", String.class);
}

```

`Bcore/src/main/java/black/android/os/Build.java`:

```java
package black.android.os;

import black.Reflector;

public class Build {
    public static final Reflector REF = Reflector.on("android.os.Build");

    public static Reflector.FieldWrapper<String> BOARD = REF.field("BOARD");
    public static Reflector.FieldWrapper<String> BRAND = REF.field("BRAND");
    public static Reflector.FieldWrapper<String> DEVICE = REF.field("DEVICE");
    public static Reflector.FieldWrapper<String> DISPLAY = REF.field("DISPLAY");
    public static Reflector.FieldWrapper<String> HOST = REF.field("HOST");
    public static Reflector.FieldWrapper<String> ID = REF.field("ID");
    public static Reflector.FieldWrapper<String> MANUFACTURER = REF.field("MANUFACTURER");
    public static Reflector.FieldWrapper<String> MODEL = REF.field("MODEL");
    public static Reflector.FieldWrapper<String> PRODUCT = REF.field("PRODUCT");
    public static Reflector.FieldWrapper<String> TAGS = REF.field("TAGS");
    public static Reflector.FieldWrapper<String> TYPE = REF.field("TYPE");
    public static Reflector.FieldWrapper<String> USER = REF.field("USER");
}

```

`Bcore/src/main/java/black/android/os/Bundle.java`:

```java
package black.android.os;

import android.os.IBinder;

import black.Reflector;

public class Bundle {
    public static final Reflector REF = Reflector.on("android.os.Bundle");

    public static Reflector.MethodWrapper<IBinder> getIBinder = REF.method("getIBinder", String.class);
    public static Reflector.MethodWrapper<Void> putIBinder = REF.method("putIBinder", String.class, IBinder.class);
}

```

`Bcore/src/main/java/black/android/os/Handler.java`:

```java
package black.android.os;

import android.os.Handler.Callback;

import black.Reflector;

public class Handler {
    public static final Reflector REF = Reflector.on("android.os.Handler");

    public static Reflector.FieldWrapper<Callback> mCallback = REF.field("mCallback");
}

```

`Bcore/src/main/java/black/android/os/IDeviceIdentifiersPolicyService.java`:

```java
package black.android.os;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IDeviceIdentifiersPolicyService {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.os.IDeviceIdentifiersPolicyService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/os/INetworkManagementService.java`:

```java
package black.android.os;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class INetworkManagementService {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.os.INetworkManagementService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/os/IPowerManager.java`:

```java
package black.android.os;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IPowerManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.os.IPowerManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/os/IUserManager.java`:

```java
package black.android.os;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IUserManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.os.IUserManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/os/IVibratorManagerService.java`:

```java
package black.android.os;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IVibratorManagerService {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.os.IVibratorManagerService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/os/Process.java`:

```java
package black.android.os;

import black.Reflector;

public class Process {
    public static final Reflector REF = Reflector.on("android.os.Process");

    public static Reflector.StaticMethodWrapper<Void> setArgV0 = REF.staticMethod("setArgV0", String.class);
}

```

`Bcore/src/main/java/black/android/os/ServiceManager.java`:

```java
package black.android.os;

import android.os.IBinder;

import java.util.Map;

import black.Reflector;

public class ServiceManager {
    public static final Reflector REF = Reflector.on("android.os.ServiceManager");

    public static Reflector.FieldWrapper<Map<String, IBinder>> sCache = REF.field("sCache");

    public static Reflector.StaticMethodWrapper<IBinder> getService = REF.staticMethod("getService", String.class);
}

```

`Bcore/src/main/java/black/android/os/StrictMode.java`:

```java
package black.android.os;

import black.Reflector;

public class StrictMode {
    public static final Reflector REF = Reflector.on("android.os.StrictMode");

    public static Reflector.FieldWrapper<Integer> DETECT_VM_FILE_URI_EXPOSURE = REF.field("DETECT_VM_FILE_URI_EXPOSURE");
    public static Reflector.FieldWrapper<Integer> PENALTY_DEATH_ON_FILE_URI_EXPOSURE = REF.field("PENALTY_DEATH_ON_FILE_URI_EXPOSURE");
    public static Reflector.FieldWrapper<Integer> sVmPolicyMask = REF.field("sVmPolicyMask");

    public static Reflector.StaticMethodWrapper<Void> disableDeathOnFileUriExposure = REF.staticMethod("disableDeathOnFileUriExposure");
}

```

`Bcore/src/main/java/black/android/os/SystemProperties.java`:

```java
package black.android.os;

import black.Reflector;

public class SystemProperties {
    public static final Reflector REF = Reflector.on("android.os.SystemProperties");

    public static Reflector.StaticMethodWrapper<String> get0 = REF.staticMethod("get", String.class, String.class);
    public static Reflector.StaticMethodWrapper<String> get1 = REF.staticMethod("get", String.class);
    public static Reflector.StaticMethodWrapper<Integer> getInt = REF.staticMethod("getInt", String.class, int.class);
}

```

`Bcore/src/main/java/black/android/os/UserHandle.java`:

```java
package black.android.os;

import black.Reflector;

public class UserHandle {
    public static final Reflector REF = Reflector.on("android.os.UserHandle");

    public static Reflector.StaticMethodWrapper<Integer> myUserId = REF.staticMethod("myUserId");
}

```

`Bcore/src/main/java/black/android/os/mount/IMountService.java`:

```java
package black.android.os.mount;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IMountService {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.os.storage.IMountService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/os/storage/IStorageManager.java`:

```java
package black.android.os.storage;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IStorageManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.os.storage.IStorageManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/os/storage/StorageManager.java`:

```java
package black.android.os.storage;

import android.os.storage.StorageVolume;

import black.Reflector;

public class StorageManager {
    public static final Reflector REF = Reflector.on("android.os.storage.StorageManager");

    public static Reflector.StaticMethodWrapper<StorageVolume[]> getVolumeList = REF.staticMethod("getVolumeList", int.class, int.class);
}

```

`Bcore/src/main/java/black/android/os/storage/StorageVolume.java`:

```java
package black.android.os.storage;

import java.io.File;

import black.Reflector;

public class StorageVolume {
    public static final Reflector REF = Reflector.on("android.os.storage.StorageVolume");

    public static Reflector.FieldWrapper<File> mInternalPath = REF.field("mInternalPath");
    public static Reflector.FieldWrapper<File> mPath = REF.field("mPath");
}

```

`Bcore/src/main/java/black/android/permission/IPermissionManager.java`:

```java
package black.android.permission;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IPermissionManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.permission.IPermissionManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/providers/Settings.java`:

```java
package black.android.providers;

import android.os.IInterface;

import black.Reflector;

public class Settings {
    public static class System {
        public static final Reflector REF = Reflector.on("android.provider.Settings$System");

        public static Reflector.FieldWrapper<Object> sNameValueCache = REF.field("sNameValueCache");
    }

    public static class Secure {
        public static final Reflector REF = Reflector.on("android.provider.Settings$Secure");

        public static Reflector.FieldWrapper<Object> sNameValueCache = REF.field("sNameValueCache");
    }

    public static class ContentProviderHolder {
        public static final Reflector REF = Reflector.on("android.provider.Settings$ContentProviderHolder");

        public static Reflector.FieldWrapper<IInterface> mContentProvider = REF.field("mContentProvider");
    }

    public static class NameValueCacheOreo {
        public static final Reflector REF = Reflector.on("android.provider.Settings$NameValueCache");

        public static Reflector.FieldWrapper<Object> mProviderHolder = REF.field("mProviderHolder");
    }

    public static class NameValueCache {
        public static final Reflector REF = Reflector.on("android.provider.Settings$NameValueCache");

        public static Reflector.FieldWrapper<Object> mContentProvider = REF.field("mContentProvider");
    }

    public static class Global {
        public static final Reflector REF = Reflector.on("android.provider.Settings$Global");

        public static Reflector.FieldWrapper<Object> sNameValueCache = REF.field("sNameValueCache");
    }
}

```

`Bcore/src/main/java/black/android/role/IRoleManager.java`:

```java
package black.android.role;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 19:48
 **/
public class IRoleManager {
    public static final Reflector TYPE = Reflector.on("android.app.role.IRoleManager");

    public static class Stub {
        public static final Reflector TYPE = Reflector.on("android.app.role.IRoleManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = TYPE.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/security/net/config/NetworkSecurityConfigProvider.java`:

```java
package black.android.security.net.config;

import android.content.Context;

import black.Reflector;

public class NetworkSecurityConfigProvider {
    public static final Reflector REF = Reflector.on("android.security.net.config.NetworkSecurityConfigProvider");

    public static Reflector.StaticMethodWrapper<Void> install = REF.staticMethod("install", Context.class);
}

```

`Bcore/src/main/java/black/android/service/persistentdata/IPersistentDataBlockService.java`:

```java
package black.android.service.persistentdata;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IPersistentDataBlockService {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.service.persistentdata.IPersistentDataBlockService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/telephony/TelephonyManager.java`:

```java
package black.android.telephony;

import android.os.IInterface;

import black.Reflector;

public class TelephonyManager {
    public static final Reflector REF = Reflector.on("android.telephony.TelephonyManager");

    public static Reflector.StaticMethodWrapper<Object> getSubscriberInfoService = REF.staticMethod("getSubscriberInfoService");

    public static Reflector.FieldWrapper<Boolean> sServiceHandleCacheEnabled = REF.field("sServiceHandleCacheEnabled");
    public static Reflector.FieldWrapper<IInterface> sIPhoneSubInfo = REF.field("sIPhoneSubInfo");

    public static Reflector.MethodWrapper<IInterface> getSubscriberInfo = REF.method("getSubscriberInfo");
}

```

`Bcore/src/main/java/black/android/util/Singleton.java`:

```java
package black.android.util;

import black.Reflector;

public class Singleton {
    public static final Reflector REF = Reflector.on("android.util.Singleton");

    public static Reflector.FieldWrapper<Object> mInstance = REF.field("mInstance");

    public static Reflector.MethodWrapper<Object> get = REF.method("get");
}

```

`Bcore/src/main/java/black/android/view/IAutoFillManager.java`:

```java
package black.android.view;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IAutoFillManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.view.autofill.IAutoFillManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/view/IGraphicsStats.java`:

```java
package black.android.view;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IGraphicsStats {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.view.IGraphicsStats$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/view/IWindowManager.java`:

```java
package black.android.view;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IWindowManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.view.IWindowManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/android/view/WindowManagerGlobal.java`:

```java
package black.android.view;

import android.os.IInterface;

import black.Reflector;

public class WindowManagerGlobal {
    public static final Reflector REF = Reflector.on("android.view.WindowManagerGlobal");
    
    public static Reflector.FieldWrapper<IInterface> sWindowManagerService = REF.field("sWindowManagerService");
}

```

`Bcore/src/main/java/black/android/view/accessibility/IAccessibilityManager.java`:

```java
package black.android.view.accessibility;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IAccessibilityManager {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.view.accessibility.IAccessibilityManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/com/android/internal/R.java`:

```java
package black.com.android.internal;

import black.Reflector;

public class R {
    public static class styleable {
        public static final Reflector REF = Reflector.on("com.android.internal.R$styleable");

        public static Reflector.FieldWrapper<Integer[]> AccountAuthenticator = REF.field("AccountAuthenticator");
        public static Reflector.FieldWrapper<Integer> AccountAuthenticator_accountPreferences = REF.field("AccountAuthenticator_accountPreferences");
        public static Reflector.FieldWrapper<Integer> AccountAuthenticator_accountType = REF.field("AccountAuthenticator_accountType");
        public static Reflector.FieldWrapper<Integer> AccountAuthenticator_customTokens = REF.field("AccountAuthenticator_customTokens");
        public static Reflector.FieldWrapper<Integer> AccountAuthenticator_icon = REF.field("AccountAuthenticator_icon");
        public static Reflector.FieldWrapper<Integer> AccountAuthenticator_label = REF.field("AccountAuthenticator_label");
        public static Reflector.FieldWrapper<Integer> AccountAuthenticator_smallIcon = REF.field("AccountAuthenticator_smallIcon");
        public static Reflector.FieldWrapper<Integer[]> Window = REF.field("Window");
        public static Reflector.FieldWrapper<Integer> Window_windowFullscreen = REF.field("Window_windowFullscreen");
        public static Reflector.FieldWrapper<Integer> Window_windowIsTranslucent = REF.field("Window_windowIsTranslucent");
        public static Reflector.FieldWrapper<Integer> Window_windowShowWallpaper = REF.field("Window_windowShowWallpaper");
    }
}

```

`Bcore/src/main/java/black/com/android/internal/app/IAppOpsService.java`:

```java
package black.com.android.internal.app;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IAppOpsService {
    public static class Stub {
        public static final Reflector REF = Reflector.on("com.android.internal.app.IAppOpsService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/com/android/internal/appwidget/IAppWidgetService.java`:

```java
package black.com.android.internal.appwidget;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IAppWidgetService {
    public static class Stub {
        public static final Reflector REF = Reflector.on("com.android.internal.appwidget.IAppWidgetService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/com/android/internal/content/ReferrerIntent.java`:

```java
package black.com.android.internal.content;

import android.content.Intent;

import black.Reflector;

public class ReferrerIntent {
    public static final Reflector REF = Reflector.on("com.android.internal.content.ReferrerIntent");

    public static Reflector.ConstructorWrapper<Intent> _new = REF.constructor(Intent.class, String.class);
}

```

`Bcore/src/main/java/black/com/android/internal/infra/AndroidFuture.java`:

```java
package black.com.android.internal.infra;

import android.content.Context;

import black.Reflector;

/**
 * @author Findger
 * @function
 * @date :2023/10/13 18:56
 **/
public class AndroidFuture {
    public static final Reflector REF = Reflector.on("com.android.internal.infra.AndroidFuture");
    public static Reflector.MethodWrapper<Boolean> complete = REF.method("complete", Object.class);
    public static Reflector.ConstructorWrapper<Object> ctor = REF.constructor();
}

```

`Bcore/src/main/java/black/com/android/internal/net/VpnConfig.java`:

```java
package black.com.android.internal.net;

import java.util.List;

import black.Reflector;

public class VpnConfig {
    public static final Reflector REF = Reflector.on("com.android.internal.net.VpnConfig");

    public static Reflector.FieldWrapper<String> user = REF.field("user");
    public static Reflector.FieldWrapper<List<String>> disallowedApplications = REF.field("disallowedApplications");
    public static Reflector.FieldWrapper<List<String>> allowedApplications = REF.field("allowedApplications");
}

```

`Bcore/src/main/java/black/com/android/internal/os/IVibratorService.java`:

```java
package black.com.android.internal.os;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class IVibratorService {
    public static class Stub {
        public static final Reflector REF = Reflector.on("android.os.IVibratorService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/com/android/internal/telephony/ISub.java`:

```java
package black.com.android.internal.telephony;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class ISub {
    public static class Stub {
        public static final Reflector REF = Reflector.on("com.android.internal.telephony.ISub$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/com/android/internal/telephony/ITelephony.java`:

```java
package black.com.android.internal.telephony;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class ITelephony {
    public static class Stub {
        public static final Reflector REF = Reflector.on("com.android.internal.telephony.ITelephony$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/com/android/internal/telephony/ITelephonyRegistry.java`:

```java
package black.com.android.internal.telephony;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

public class ITelephonyRegistry {
    public static class Stub {
        public static final Reflector REF = Reflector.on("com.android.internal.telephony.ITelephonyRegistry$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = REF.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/dalvik/system/VMRuntime.java`:

```java
package black.dalvik.system;

import black.Reflector;

public class VMRuntime {
    public static final Reflector REF = Reflector.on("dalvik.system.VMRuntime");

    public static Reflector.StaticMethodWrapper<Object> getRuntime = REF.staticMethod("getRuntime");
    public static Reflector.MethodWrapper<Void> setTargetSdkVersion = REF.method("setTargetSdkVersion", int.class);
}

```

`Bcore/src/main/java/black/libcore/io/Libcore.java`:

```java
package black.libcore.io;

import black.Reflector;

public class Libcore {
    public static final Reflector REF = Reflector.on("libcore.io.Libcore");

    public static Reflector.FieldWrapper<Object> os = REF.field("os");
}

```

`Bcore/src/main/java/black/oem/flyme/IFlymePermissionService.java`:

```java
package black.oem.flyme;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

/**
 * @author Findger
 * @function
 * @date :2023/10/9 12:33
 **/
public class IFlymePermissionService {
    public static final Reflector TYPE = Reflector.on("meizu.security.IFlymePermissionService");

    public static class Stub {
        public static final Reflector TYPE = Reflector.on("meizu.security.IFlymePermissionService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = TYPE.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/oem/vivo/IPhysicalFlingManager.java`:

```java
package black.oem.vivo;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 20:12
 **/
public class IPhysicalFlingManager {
    public static final Reflector TYPE = Reflector.on("vivo.app.physicalfling.IPhysicalFlingManager");

    public static class Stub {
        public static final Reflector TYPE = Reflector.on("vivo.app.physicalfling.IPhysicalFlingManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = TYPE.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/oem/vivo/IPopupCameraManager.java`:

```java
package black.oem.vivo;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 20:21
 **/
public class IPopupCameraManager {
    public static final Reflector TYPE = Reflector.on("vivo.app.popupcamera.IPopupCameraManager");

    public static class Stub {
        public static final Reflector TYPE = Reflector.on("vivo.app.popupcamera.IPopupCameraManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = TYPE.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/oem/vivo/ISuperResolutionManager.java`:

```java
package black.oem.vivo;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 20:27
 **/
public class ISuperResolutionManager {
    public static final Reflector TYPE = Reflector.on("vivo.app.superresolution.ISuperResolutionManager");

    public static class Stub {
        public static final Reflector TYPE = Reflector.on("vivo.app.superresolution.ISuperResolutionManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = TYPE.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/oem/vivo/ISystemDefenceManager.java`:

```java
package black.oem.vivo;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 20:32
 **/
public class ISystemDefenceManager {
    public static final Reflector TYPE = Reflector.on("vivo.app.systemdefence.ISystemDefenceManager");

    public static class Stub {
        public static final Reflector TYPE = Reflector.on("vivo.app.systemdefence.ISystemDefenceManager$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = TYPE.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/black/oem/vivo/IVivoPermissonService.java`:

```java
package black.oem.vivo;

import android.os.IBinder;
import android.os.IInterface;

import black.Reflector;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 20:37
 **/
public class IVivoPermissonService {
    public static final Reflector TYPE = Reflector.on("vivo.app.security.IVivoPermissionService");

    public static class Stub {
        public static final Reflector TYPE = Reflector.on("vivo.app.security.IVivoPermissionService$Stub");
        public static Reflector.StaticMethodWrapper<IInterface> asInterface = TYPE.staticMethod("asInterface", IBinder.class);
    }
}

```

`Bcore/src/main/java/com/vcore/BlackBoxCore.java`:

```java
package com.vcore;

import android.annotation.SuppressLint;
import android.app.ActivityManager;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.graphics.Color;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.Process;
import android.util.Log;

import org.lsposed.hiddenapibypass.HiddenApiBypass;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import black.android.app.ActivityThread;
import black.android.os.UserHandle;
import com.vcore.app.LauncherActivity;
import com.vcore.app.configuration.AppLifecycleCallback;
import com.vcore.app.configuration.ClientConfiguration;
import com.vcore.core.GmsCore;
import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.DaemonService;
import com.vcore.core.system.ServiceManager;
import com.vcore.core.system.user.BUserHandle;
import com.vcore.core.system.user.BUserInfo;
import com.vcore.entity.pm.InstallOption;
import com.vcore.entity.pm.InstallResult;
import com.vcore.entity.pm.InstalledModule;
import com.vcore.fake.delegate.ContentProviderDelegate;
import com.vcore.fake.frameworks.BActivityManager;
import com.vcore.fake.frameworks.BJobManager;
import com.vcore.fake.frameworks.BPackageManager;
import com.vcore.fake.frameworks.BStorageManager;
import com.vcore.fake.frameworks.BUserManager;
import com.vcore.fake.frameworks.BXposedManager;
import com.vcore.fake.hook.HookManager;
import com.vcore.proxy.ProxyManifest;
import com.vcore.utils.FileUtils;
import com.vcore.utils.ShellUtils;
import com.vcore.utils.Slog;
import com.vcore.utils.compat.BuildCompat;
import com.vcore.utils.compat.BundleCompat;
import com.vcore.utils.compat.XposedParserCompat;
import com.vcore.utils.provider.ProviderCall;

@SuppressLint({"StaticFieldLeak", "NewApi"})
public class BlackBoxCore extends ClientConfiguration {
    public static final String TAG = "BlackBoxCore";

    private static final BlackBoxCore sBlackBoxCore = new BlackBoxCore();
    private static Context sContext;
    private ProcessType mProcessType;
    private final Map<String, IBinder> mServices = new HashMap<>();
    private Thread.UncaughtExceptionHandler mExceptionHandler;
    private ClientConfiguration mClientConfiguration;
    private final List<AppLifecycleCallback> mAppLifecycleCallbacks = new ArrayList<>();
    private final Handler mHandler = new Handler(Looper.getMainLooper());
    private final int mHostUid = Process.myUid();
    private final int mHostUserId = UserHandle.myUserId.call();

    public static BlackBoxCore get() {
        return sBlackBoxCore;
    }

    public Handler getHandler() {
        return mHandler;
    }

    public static PackageManager getPackageManager() {
        return sContext.getPackageManager();
    }

    public static String getHostPkg() {
        return get().getHostPackageName();
    }

    public static int getHostUid() {
        return get().mHostUid;
    }

    public static int getHostUserId() {
        return get().mHostUserId;
    }

    public static Context getContext() {
        return sContext;
    }

    public Thread.UncaughtExceptionHandler getExceptionHandler() {
        return mExceptionHandler;
    }

    public void setExceptionHandler(Thread.UncaughtExceptionHandler exceptionHandler) {
        mExceptionHandler = exceptionHandler;
    }

    public void doAttachBaseContext(Context context, ClientConfiguration clientConfiguration) {
        if (clientConfiguration == null) {
            throw new IllegalArgumentException("ClientConfiguration is null!");
        }

        if (BuildCompat.isPie()) {
            HiddenApiBypass.addHiddenApiExemptions("L");
        }

        sContext = context;
        mClientConfiguration = clientConfiguration;
        initNotificationManager();

        String processName = getProcessName(getContext());
        if (processName.equals(BlackBoxCore.getHostPkg())) {
            mProcessType = ProcessType.Main;
            startLogcat();
        } else if (processName.endsWith(getContext().getString(R.string.black_box_service_name))) {
            mProcessType = ProcessType.Server;
        } else {
            mProcessType = ProcessType.BAppClient;
        }

        if (BlackBoxCore.get().isBlackProcess()) {
            BEnvironment.load();
        }

        if (isServerProcess()) {
            if (clientConfiguration.isEnableDaemonService()) {
                Intent intent = new Intent();
                intent.setClass(getContext(), DaemonService.class);
                if (BuildCompat.isOreo()) {
                    getContext().startForegroundService(intent);
                } else {
                    getContext().startService(intent);
                }
            }
        }

        xcrash.XCrash.init(context);
        HookManager.get().init();
    }

    public void doCreate() {
        if (isBlackProcess()) {
            ContentProviderDelegate.init();
        }
        if (!isServerProcess()) {
            ServiceManager.initBlackManager();
        }
    }

    public static Object mainThread() {
        return ActivityThread.currentActivityThread.call();
    }

    public void startActivity(Intent intent, int userId) {
        if (mClientConfiguration.isEnableLauncherActivity()) {
            LauncherActivity.launch(intent, userId);
        } else {
            getBActivityManager().startActivity(intent, userId);
        }
    }

    public static BJobManager getBJobManager() {
        return BJobManager.get();
    }

    public static BPackageManager getBPackageManager() {
        return BPackageManager.get();
    }

    public static BActivityManager getBActivityManager() {
        return BActivityManager.get();
    }

    public static BStorageManager getBStorageManager() {
        return BStorageManager.get();
    }

    public boolean launchApk(String packageName, int userId) {
        Intent launchIntentForPackage = getBPackageManager().getLaunchIntentForPackage(packageName, userId);
        if (launchIntentForPackage == null) {
            return false;
        }

        startActivity(launchIntentForPackage, userId);
        return true;
    }

    public boolean isInstalled(String packageName, int userId) {
        return getBPackageManager().isInstalled(packageName, userId);
    }

    public void uninstallPackageAsUser(String packageName, int userId) {
        getBPackageManager().uninstallPackageAsUser(packageName, userId);
    }

    public void uninstallPackage(String packageName) {
        getBPackageManager().uninstallPackage(packageName);
    }

    public InstallResult installPackageAsUser(String packageName, int userId) {
        try {
            PackageInfo packageInfo = getPackageManager().getPackageInfo(packageName, 0);
            return getBPackageManager().installPackageAsUser(packageInfo.applicationInfo.sourceDir, InstallOption.installBySystem(), userId);
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
            return new InstallResult().installError(e.getMessage());
        }
    }

    public InstallResult installPackageAsUser(File apk, int userId) {
        return getBPackageManager().installPackageAsUser(apk.getAbsolutePath(), InstallOption.installByStorage(), userId);
    }

    public InstallResult installPackageAsUser(Uri apk, int userId) {
        return getBPackageManager().installPackageAsUser(apk.toString(), InstallOption.installByStorage().makeUriFile(), userId);
    }

    public InstallResult installXPModule(File apk) {
        return getBPackageManager().installPackageAsUser(apk.getAbsolutePath(), InstallOption.installByStorage().makeXposed(), BUserHandle.USER_XPOSED);
    }

    public InstallResult installXPModule(Uri apk) {
        return getBPackageManager().installPackageAsUser(apk.toString(), InstallOption.installByStorage()
                .makeXposed()
                .makeUriFile(), BUserHandle.USER_XPOSED);
    }

    public InstallResult installXPModule(String packageName) {
        try {
            PackageInfo packageInfo = getPackageManager().getPackageInfo(packageName, 0);
            String path = packageInfo.applicationInfo.sourceDir;
            return getBPackageManager().installPackageAsUser(path, InstallOption.installBySystem().makeXposed(), BUserHandle.USER_XPOSED);
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
            return new InstallResult().installError(e.getMessage());
        }
    }

    public void uninstallXPModule(String packageName) {
        uninstallPackage(packageName);
    }

    public boolean isXPEnable() {
        return BXposedManager.get().isXPEnable();
    }

    public void setXPEnable(boolean enable) {
        BXposedManager.get().setXPEnable(enable);
    }

    public boolean isXposedModule(File file) {
        return XposedParserCompat.isXPModule(file.getAbsolutePath());
    }

    public boolean isInstalledXposedModule(String packageName) {
        return isInstalled(packageName, BUserHandle.USER_XPOSED);
    }

    public boolean isModuleEnable(String packageName) {
        return BXposedManager.get().isModuleEnable(packageName);
    }

    public void setModuleEnable(String packageName, boolean enable) {
        BXposedManager.get().setModuleEnable(packageName, enable);
    }

    public List<InstalledModule> getInstalledXPModules() {
        return BXposedManager.get().getInstalledModules();
    }

    public List<ApplicationInfo> getInstalledApplications(int flags, int userId) {
        return getBPackageManager().getInstalledApplications(flags, userId);
    }

    public List<PackageInfo> getInstalledPackages(int flags, int userId) {
        return getBPackageManager().getInstalledPackages(flags, userId);
    }

    public void clearPackage(String packageName, int userId) {
        BPackageManager.get().clearPackage(packageName, userId);
    }

    public void stopPackage(String packageName, int userId) {
        BPackageManager.get().stopPackage(packageName, userId);
    }

    public List<BUserInfo> getUsers() {
        return BUserManager.get().getUsers();
    }

    public BUserInfo createUser(int userId) {
        return BUserManager.get().createUser(userId);
    }

    public void deleteUser(int userId) {
        BUserManager.get().deleteUser(userId);
    }

    public List<AppLifecycleCallback> getAppLifecycleCallbacks() {
        return mAppLifecycleCallbacks;
    }

    public void removeAppLifecycleCallback(AppLifecycleCallback appLifecycleCallback) {
        mAppLifecycleCallbacks.remove(appLifecycleCallback);
    }

    public void addAppLifecycleCallback(AppLifecycleCallback appLifecycleCallback) {
        mAppLifecycleCallbacks.add(appLifecycleCallback);
    }

    public boolean isSupportGms() {
        return GmsCore.isSupportGms();
    }

    public boolean isInstallGms(int userId) {
        return GmsCore.isInstalledGoogleService(userId);
    }

    public InstallResult installGms(int userId) {
        return GmsCore.installGApps(userId);
    }

    public boolean uninstallGms(int userId) {
        GmsCore.uninstallGApps(userId);
        return !GmsCore.isInstalledGoogleService(userId);
    }

    public IBinder getService(String name) {
        IBinder binder = mServices.get(name);
        if (binder != null && binder.isBinderAlive()) {
            return binder;
        }

        Bundle bundle = new Bundle();
        bundle.putString("_B_|_server_name_", name);
        Bundle vm = ProviderCall.callSafely(ProxyManifest.getBindProvider(), "VM", null, bundle);
        binder = BundleCompat.getBinder(vm, "_B_|_server_");

        Slog.d(TAG, "getService: " + name + ", " + binder);
        mServices.put(name, binder);
        return binder;
    }

    /**
     * Process type
     */
    private enum ProcessType {
        /**
         * Server process
         */
        Server,
        /**
         * Black app process
         */
        BAppClient,
        /**
         * Main process
         */
        Main,
    }

    public boolean isBlackProcess() {
        return mProcessType == ProcessType.BAppClient;
    }

    public boolean isMainProcess() {
        return mProcessType == ProcessType.Main;
    }

    public boolean isServerProcess() {
        return mProcessType == ProcessType.Server;
    }

    @Override
    public boolean isHideRoot() {
        return mClientConfiguration.isHideRoot();
    }

    @Override
    public boolean isHideXposed() {
        return mClientConfiguration.isHideXposed();
    }

    @Override
    public String getHostPackageName() {
        return mClientConfiguration.getHostPackageName();
    }

    @Override
    public boolean requestInstallPackage(File file, int userId) {
        return mClientConfiguration.requestInstallPackage(file, userId);
    }

    private void startLogcat() {
        new Thread(() -> {
            File file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS), getContext().getPackageName() + "_logcat.txt");
            FileUtils.deleteDir(file);
            ShellUtils.execCommand("logcat -c", false);
            ShellUtils.execCommand("logcat -f " + file.getAbsolutePath(), false);
        }).start();
    }

    private static String getProcessName(Context context) {
        int pid = Process.myPid();
        String processName = null;
        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        for (ActivityManager.RunningAppProcessInfo info : am.getRunningAppProcesses()) {
            if (info.pid == pid) {
                processName = info.processName;
                break;
            }
        }

        if (processName == null) {
            throw new RuntimeException("processName = null");
        }
        return processName;
    }

    public static boolean is64Bit() {
        if (BuildCompat.isM()) {
            return Process.is64Bit();
        } else {
            return Build.CPU_ABI.equals("arm64-v8a");
        }
    }

    private void initNotificationManager() {
        NotificationManager nm = (NotificationManager) BlackBoxCore.getContext().getSystemService(Context.NOTIFICATION_SERVICE);
        String CHANNEL_ONE_ID = BlackBoxCore.getContext().getPackageName() + ".blackbox_core";
        String CHANNEL_ONE_NAME = "blackbox_core";

        if (BuildCompat.isOreo()) {
            NotificationChannel notificationChannel = new NotificationChannel(CHANNEL_ONE_ID, CHANNEL_ONE_NAME, NotificationManager.IMPORTANCE_HIGH);
            notificationChannel.enableLights(true);
            notificationChannel.setLightColor(Color.RED);
            notificationChannel.setShowBadge(true);
            notificationChannel.setLockscreenVisibility(Notification.VISIBILITY_PUBLIC);
            nm.createNotificationChannel(notificationChannel);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/app/BActivityThread.java`:

```java
package com.vcore.app;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.Application;
import android.app.Instrumentation;
import android.app.Service;
import android.app.job.JobService;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentProviderClient;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ProviderInfo;
import android.content.pm.ServiceInfo;
import android.os.Binder;
import android.os.Build;
import android.os.ConditionVariable;
import android.os.Handler;
import android.os.IBinder;
import android.os.IInterface;
import android.os.Looper;
import android.os.RemoteException;
import android.os.StrictMode;
import android.util.Log;
import android.webkit.WebView;

import java.io.File;
import java.lang.reflect.Field;
import java.security.Security;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import black.android.app.ActivityManagerNative;
import black.android.app.ActivityThread;
import black.android.app.ActivityThreadNMR1;
import black.android.app.ActivityThreadQ;
import black.android.app.ContextImpl;
import black.android.app.LoadedApk;
import black.android.graphics.Compatibility;
import black.android.security.net.config.NetworkSecurityConfigProvider;
import black.com.android.internal.content.ReferrerIntent;
import black.dalvik.system.VMRuntime;

import com.vcore.BlackBoxCore;
import com.vcore.app.configuration.AppLifecycleCallback;
import com.vcore.app.dispatcher.AppServiceDispatcher;
import com.vcore.core.CrashHandler;
import com.vcore.core.IBActivityThread;
import com.vcore.core.IOCore;
import com.vcore.core.NativeCore;
import com.vcore.core.env.VirtualRuntime;
import com.vcore.core.system.user.BUserHandle;
import com.vcore.entity.AppConfig;
import com.vcore.entity.am.ReceiverData;
import com.vcore.fake.delegate.AppInstrumentation;
import com.vcore.fake.delegate.ContentProviderDelegate;
import com.vcore.fake.hook.HookManager;
import com.vcore.fake.service.HCallbackProxy;
import com.vcore.utils.Slog;
import com.vcore.utils.compat.ActivityManagerCompat;
import com.vcore.utils.compat.BuildCompat;
import com.vcore.utils.compat.ContextCompat;
import com.vcore.utils.compat.StrictModeCompat;

public class BActivityThread extends IBActivityThread.Stub {
    public static final String TAG = "BActivityThread";

    private AppBindData mBoundApplication;
    private Application mInitialApplication;
    private AppConfig mAppConfig;
    private final List<ProviderInfo> mProviders = new ArrayList<>();
    private final Handler mH = BlackBoxCore.get().getHandler();
    private static final Object mConfigLock = new Object();

    public static boolean isThreadInit() {
        return true;
    }

    private static final class SBActivityThreadHolder {
        static final BActivityThread sBActivityThread = new BActivityThread();
    }

    public static BActivityThread currentActivityThread() {
        return SBActivityThreadHolder.sBActivityThread;
    }

    public static AppConfig getAppConfig() {
        synchronized (mConfigLock) {
            return currentActivityThread().mAppConfig;
        }
    }

    public static List<ProviderInfo> getProviders() {
        return currentActivityThread().mProviders;
    }

    public static String getAppProcessName() {
        if (getAppConfig() != null) {
            return getAppConfig().processName;
        } else if (currentActivityThread().mBoundApplication != null) {
            return currentActivityThread().mBoundApplication.processName;
        }
        return null;
    }

    public static String getAppPackageName() {
        if (getAppConfig() != null) {
            return getAppConfig().packageName;
        } else if (currentActivityThread().mInitialApplication != null) {
            return currentActivityThread().mInitialApplication.getPackageName();
        }
        return null;
    }

    public static Application getApplication() {
        return currentActivityThread().mInitialApplication;
    }

    public static int getAppPid() {
        return getAppConfig() == null ? -1 : getAppConfig().bPID;
    }

    public static int getBUid() {
        return getAppConfig() == null ? BUserHandle.AID_APP_START : getAppConfig().bUID;
    }

    public static int getBAppId() {
        return BUserHandle.getAppId(getBUid());
    }

    public static int getCallingBUid() {
        return getAppConfig() == null ? BlackBoxCore.getHostUid() : getAppConfig().callingBUid;
    }

    public static int getUid() {
        return getAppConfig() == null ? -1 : getAppConfig().uid;
    }

    public static int getUserId() {
        return getAppConfig() == null ? 0 : getAppConfig().userId;
    }

    public void initProcess(AppConfig appConfig) {
        synchronized (mConfigLock) {
            if (this.mAppConfig != null && !this.mAppConfig.packageName.equals(appConfig.packageName)) {
                // 该进程已被attach
                throw new RuntimeException("Reject init process: " + appConfig.processName + ", this process is: " + this.mAppConfig.processName);
            }

            this.mAppConfig = appConfig;
            IBinder iBinder = asBinder();
            try {
                iBinder.linkToDeath(new DeathRecipient() {
                    @Override
                    public void binderDied() {
                        synchronized (mConfigLock) {
                            try {
                                iBinder.linkToDeath(this, 0);
                            } catch (RemoteException ignored) { }
                            mAppConfig = null;
                        }
                    }
                }, 0);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }
    }

    public boolean isInit() {
        return mBoundApplication != null;
    }

    public Service createService(ServiceInfo serviceInfo, IBinder token) {
        if (!BActivityThread.currentActivityThread().isInit()) {
            BActivityThread.currentActivityThread().bindApplication(serviceInfo.packageName, serviceInfo.processName);
        }

        ClassLoader classLoader = LoadedApk.getClassLoader.call(mBoundApplication.info);
        Service service;
        try {
            service = (Service) classLoader.loadClass(serviceInfo.name).newInstance();
        } catch (Exception e) {
            e.printStackTrace();
            Slog.e(TAG, "Unable to instantiate service " + serviceInfo.name + ": " + e);
            return null;
        }

        try {
            Context context = BlackBoxCore.getContext().createPackageContext(serviceInfo.packageName,
                    Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY);

            ContextImpl.setOuterContext.call(context, service);
            black.android.app.Service.attach.call(service, context, BlackBoxCore.mainThread(), serviceInfo.name, token, mInitialApplication,
                    ActivityManagerNative.getDefault.call());

            ContextCompat.fix(context);
            service.onCreate();
            return service;
        } catch (Exception e) {
            throw new RuntimeException("Unable to create service " + serviceInfo.name + ": " + e, e);
        }
    }

    public JobService createJobService(ServiceInfo serviceInfo) {
        if (!BActivityThread.currentActivityThread().isInit()) {
            BActivityThread.currentActivityThread().bindApplication(serviceInfo.packageName, serviceInfo.processName);
        }

        ClassLoader classLoader = LoadedApk.getClassLoader.call(mBoundApplication.info);
        JobService service;
        try {
            service = (JobService) classLoader.loadClass(serviceInfo.name).newInstance();
        } catch (Exception e) {
            e.printStackTrace();
            Slog.e(TAG, "Unable to create JobService " + serviceInfo.name + ": " + e);
            return null;
        }

        try {
            Context context = BlackBoxCore.getContext().createPackageContext(serviceInfo.packageName, Context.CONTEXT_INCLUDE_CODE |
                    Context.CONTEXT_IGNORE_SECURITY);

            ContextImpl.setOuterContext.call(context, service);
            black.android.app.Service.attach.call(service, context, BlackBoxCore.mainThread(), serviceInfo.name,
                    BActivityThread.currentActivityThread().getActivityThread(), mInitialApplication, ActivityManagerNative.getDefault.call());

            ContextCompat.fix(context);
            service.onCreate();
            service.onBind(null);
            return service;
        } catch (Exception e) {
            throw new RuntimeException(
                    "Unable to create JobService " + serviceInfo.name
                            + ": " + e, e);
        }
    }

    public void bindApplication(final String packageName, final String processName) {
        if (Looper.myLooper() != Looper.getMainLooper()) {
            final ConditionVariable conditionVariable = new ConditionVariable();

            BlackBoxCore.get().getHandler().post(() -> {
                handleBindApplication(packageName, processName);
                conditionVariable.open();
            });
            conditionVariable.block();
        } else {
            handleBindApplication(packageName, processName);
        }
    }

    @SuppressLint({"NewApi", "UnsafeDynamicallyLoadedCode", "SdCardPath"})
    public synchronized void handleBindApplication(String packageName, String processName) {
        if (isInit())
            return;
        try {
            CrashHandler.create();
        } catch (Throwable ignored) { }

        PackageInfo packageInfo = BlackBoxCore.getBPackageManager().getPackageInfo(packageName, PackageManager.GET_PROVIDERS, BActivityThread.getUserId());
        ApplicationInfo applicationInfo = packageInfo.applicationInfo;
        if (packageInfo.providers == null) {
            packageInfo.providers = new ProviderInfo[]{};
        }
        mProviders.addAll(Arrays.asList(packageInfo.providers));

        Object boundApplication = ActivityThread.mBoundApplication.get(BlackBoxCore.mainThread());
        Context packageContext = createPackageContext(applicationInfo);
        Object loadedApk = ContextImpl.mPackageInfo.get(packageContext);

        LoadedApk.mSecurityViolation.set(loadedApk, false);
        LoadedApk.mApplicationInfo.set(loadedApk, applicationInfo);

        int targetSdkVersion = applicationInfo.targetSdkVersion;
        if (targetSdkVersion < Build.VERSION_CODES.GINGERBREAD) {
            StrictMode.ThreadPolicy newPolicy = new StrictMode.ThreadPolicy.Builder(StrictMode.getThreadPolicy()).permitNetwork().build();
            StrictMode.setThreadPolicy(newPolicy);
        }

        if (BuildCompat.isN()) {
            if (targetSdkVersion < Build.VERSION_CODES.N) {
                StrictModeCompat.disableDeathOnFileUriExposure();
            }
        }

        if (BuildCompat.isPie()) {
            WebView.setDataDirectorySuffix(getUserId() + ":" + packageName + ":" + processName);
        }

        VirtualRuntime.setupRuntime(processName, applicationInfo);
        VMRuntime.setTargetSdkVersion.call(VMRuntime.getRuntime.call(), applicationInfo.targetSdkVersion);
        if (BuildCompat.isS()) {
            Compatibility.setTargetSdkVersion.call(applicationInfo.targetSdkVersion);
        }

        NativeCore.init(Build.VERSION.SDK_INT);
        assert packageContext != null;
        IOCore.get().enableRedirect(packageContext);

        AppBindData bindData = new AppBindData();
        bindData.appInfo = applicationInfo;
        bindData.processName = processName;
        bindData.info = loadedApk;
        bindData.providers = mProviders;

        ActivityThread.AppBindData.instrumentationName.set(boundApplication, new ComponentName(bindData.appInfo.packageName, Instrumentation.class.getName()));
        ActivityThread.AppBindData.appInfo.set(boundApplication, bindData.appInfo);
        ActivityThread.AppBindData.info.set(boundApplication, bindData.info);
        ActivityThread.AppBindData.processName.set(boundApplication, bindData.processName);
        ActivityThread.AppBindData.providers.set(boundApplication, bindData.providers);
        mBoundApplication = bindData;

        // SSL适配
        Security.removeProvider("AndroidNSSP");
        NetworkSecurityConfigProvider.install.call(packageContext);
        Application application;
        try {
            onBeforeCreateApplication(packageName, processName, packageContext);
            application = LoadedApk.makeApplication.call(loadedApk, false, null);

            mInitialApplication = application;
            ActivityThread.mInitialApplication.set(BlackBoxCore.mainThread(), mInitialApplication);
            ContextCompat.fix((Context) ActivityThread.getSystemContext.call(BlackBoxCore.mainThread()));
            ContextCompat.fix(mInitialApplication);
            installProviders(mInitialApplication, bindData.processName, bindData.providers);
            //fix wechat
            if (Build.VERSION.SDK_INT >= 24 && "com.tencent.mm:recovery".equals(processName)) {
                try {
                    Field field = application.getClassLoader().loadClass("com.tencent.recovery.Recovery").getField("context");
                    field.setAccessible(true);
                    if (field.get(null) != null) {
                        return;
                    }
                    field.set(null, application.getBaseContext());
                } catch (Throwable e) {
                    e.printStackTrace();
                }
            }
            onBeforeApplicationOnCreate(packageName, processName, application);
            AppInstrumentation.get().callApplicationOnCreate(application);
            onAfterApplicationOnCreate(packageName, processName, application);
            HookManager.get().checkEnv(HCallbackProxy.class);
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Unable to makeApplication", e);
        }
    }

    public static Context createPackageContext(ApplicationInfo info) {
        try {
            return BlackBoxCore.getContext().createPackageContext(info.packageName, Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private void installProviders(Context context, String processName, List<ProviderInfo> provider) {
        long origId = Binder.clearCallingIdentity();
        try {
            for (ProviderInfo providerInfo : provider) {
                try {
                    if (processName.equals(providerInfo.processName) || providerInfo.processName.equals(context.getPackageName()) || providerInfo.multiprocess) {
                        installProvider(BlackBoxCore.mainThread(), context, providerInfo, null);
                        Log.d(TAG, "providerInfo.authority: " + providerInfo.authority);
                    }
                } catch (Throwable ignored) { }
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
            ContentProviderDelegate.init();
        }
    }

    public Object getPackageInfo() {
        return mBoundApplication.info;
    }

    public static void installProvider(Object mainThread, Context context, ProviderInfo providerInfo, Object holder) {
        ActivityThread.installProvider.call(mainThread, context, holder, providerInfo, false, true, true);
    }

    /*public void loadXposed(Context context) {
        String vPackageName = getAppPackageName();
        String vProcessName = getAppProcessName();

        if (!TextUtils.isEmpty(vPackageName) && !TextUtils.isEmpty(vProcessName) && BXposedManager.get().isXPEnable()) {
            boolean isFirstApplication = vPackageName.equals(vProcessName);

            List<InstalledModule> installedModules = BXposedManager.get().getInstalledModules();
            for (InstalledModule installedModule : installedModules) {
                if (!installedModule.enable) {
                    continue;
                }

                try {
                    XposedInit.loadModule(installedModule.getApplication().sourceDir, context.getClassLoader());
                } catch (Throwable e) {
                    e.printStackTrace();
                }
            }

            try {
                XposedInit.onPackageLoad(vPackageName, vProcessName, context.getApplicationInfo(), isFirstApplication, context.getClassLoader());
            } catch (Throwable ignored) { }
        }
        if (BlackBoxCore.get().isHideXposed()) {
            NativeCore.hideXposed();
        }
    }
*/
    @Override
    public IBinder getActivityThread() {
        return ActivityThread.getApplicationThread.call(BlackBoxCore.mainThread());
    }

    @Override
    public void bindApplication() {
        if (!isInit()) {
            bindApplication(getAppPackageName(), getAppProcessName());
        }
    }

    @Override
    public void stopService(Intent intent) {
        AppServiceDispatcher.get().stopService(intent);
    }

    @Override
    public void restartJobService(String selfId) { }

    @Override
    public IBinder acquireContentProviderClient(ProviderInfo providerInfo) {
        if (!isInit()) {
            bindApplication(BActivityThread.getAppConfig().packageName, BActivityThread.getAppConfig().processName);
        }

        String[] split = providerInfo.authority.split(";");
        for (String auth : split) {
            ContentProviderClient contentProviderClient = BlackBoxCore.getContext().getContentResolver().acquireContentProviderClient(auth);
            IInterface iInterface = black.android.content.ContentProviderClient.mContentProvider.get(contentProviderClient);

            if (iInterface == null) {
                continue;
            }
            return iInterface.asBinder();
        }
        return null;
    }

    @Override
    public IBinder peekService(Intent intent) {
        return AppServiceDispatcher.get().peekService(intent);
    }

    @Override
    public void finishActivity(final IBinder token) {
        mH.post(() -> {
            Map<IBinder, Object> activities = ActivityThread.mActivities.get(BlackBoxCore.mainThread());
            if (activities.isEmpty()) {
                return;
            }

            Object clientRecord = activities.get(token);
            if (clientRecord == null) {
                return;
            }

            Activity activity = getActivityByToken(token);
            while (activity.getParent() != null) {
                activity = activity.getParent();
            }

            int resultCode = black.android.app.Activity.mResultCode.get(activity);
            Intent resultData = black.android.app.Activity.mResultData.get(activity);
            ActivityManagerCompat.finishActivity(token, resultCode, resultData);
            black.android.app.Activity.mFinished.set(activity, true);
        });
    }

    @Override
    public void handleNewIntent(final IBinder token, final Intent intent) {
        mH.post(() -> {
            Intent newIntent;
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) {
                newIntent = ReferrerIntent._new.newInstance(BlackBoxCore.getHostPkg());
            } else {
                newIntent = intent;
            }

            Object mainThread = BlackBoxCore.mainThread();
            if (ActivityThread.performNewIntents != null) {
                ActivityThread.performNewIntents.call(mainThread, token, Collections.singletonList(newIntent));
            } else if (ActivityThreadNMR1.performNewIntents != null) {
                ActivityThreadNMR1.performNewIntents.call(mainThread, token, Collections.singletonList(newIntent), true);
            } else if (ActivityThreadQ.handleNewIntent != null) {
                ActivityThreadQ.handleNewIntent.call(mainThread, token, Collections.singletonList(newIntent));
            }
        });
    }

    @Override
    public void scheduleReceiver(ReceiverData data) {
        if (!isInit()) {
            bindApplication();
        }
        mH.post(() -> {
            BroadcastReceiver mReceiver = null;
            Intent intent = data.intent;
            ActivityInfo activityInfo = data.activityInfo;
            BroadcastReceiver.PendingResult pendingResult = data.data.build();

            try {
                Context baseContext = mInitialApplication.getBaseContext();
                ClassLoader classLoader = baseContext.getClassLoader();
                intent.setExtrasClassLoader(classLoader);

                mReceiver = (BroadcastReceiver) classLoader.loadClass(activityInfo.name).newInstance();
                black.android.content.BroadcastReceiver.setPendingResult.call(mReceiver, pendingResult);
                mReceiver.onReceive(baseContext, intent);

                BroadcastReceiver.PendingResult finish = black.android.content.BroadcastReceiver.getPendingResult.call(mReceiver);
                if (finish != null) {
                    finish.finish();
                }
                BlackBoxCore.getBActivityManager().finishBroadcast(data.data);
            } catch (Throwable throwable) {
                throwable.printStackTrace();
                Slog.e(TAG, "Error receiving broadcast " + intent + " in " + mReceiver);
            }
        });
    }

    public static Activity getActivityByToken(IBinder token) {
        Map<IBinder, Object> iBinderObjectMap = ActivityThread.mActivities.get(BlackBoxCore.mainThread());
        return ActivityThread.ActivityClientRecord.activity.get(iBinderObjectMap.get(token));
    }

    private void onBeforeCreateApplication(String packageName, String processName, Context context) {
        for (AppLifecycleCallback appLifecycleCallback : BlackBoxCore.get().getAppLifecycleCallbacks()) {
            appLifecycleCallback.beforeCreateApplication(packageName, processName, context, BActivityThread.getUserId());
        }
    }

    private void onBeforeApplicationOnCreate(String packageName, String processName, Application application) {
        for (AppLifecycleCallback appLifecycleCallback : BlackBoxCore.get().getAppLifecycleCallbacks()) {
            appLifecycleCallback.beforeApplicationOnCreate(packageName, processName, application, BActivityThread.getUserId());
        }
    }

    private void onAfterApplicationOnCreate(String packageName, String processName, Application application) {
        for (AppLifecycleCallback appLifecycleCallback : BlackBoxCore.get().getAppLifecycleCallbacks()) {
            appLifecycleCallback.afterApplicationOnCreate(packageName, processName, application, BActivityThread.getUserId());
        }
    }

    public static class AppBindData {
        String processName;
        ApplicationInfo appInfo;
        List<ProviderInfo> providers;
        Object info;
    }
}

```

`Bcore/src/main/java/com/vcore/app/LauncherActivity.java`:

```java
package com.vcore.app;

import android.app.Activity;
import android.app.ActivityManager;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.text.TextUtils;

import androidx.annotation.Nullable;

import java.util.List;

import com.vcore.BlackBoxCore;
import com.vcore.R;
import com.vcore.core.system.user.BUserHandle;
import com.vcore.fake.frameworks.BActivityManager;
import com.vcore.utils.Slog;

public class LauncherActivity extends Activity {
    public static final String TAG = "SplashScreen";

    public static final String KEY_INTENT = "launch_intent";
    public static final String KEY_PKG = "launch_pkg";
    public static final String KEY_USER_ID = "launch_user_id";
    private boolean isRunning = false;
    private boolean UnRunning = false;

    public static void launch(Intent intent, int userId) {
        Intent splash = new Intent();
        splash.setClass(BlackBoxCore.getContext(), LauncherActivity.class);
        splash.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        splash.putExtra(LauncherActivity.KEY_INTENT, intent);
        splash.putExtra(LauncherActivity.KEY_PKG, intent.getPackage());
        splash.putExtra(LauncherActivity.KEY_USER_ID, userId);
        BlackBoxCore.getContext().startActivity(splash);
    }

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        //这里解决多进程问题
        super.onCreate(savedInstanceState);
        Intent intent = getIntent();
        if (intent == null) {
            finish();
            return;
        }

        Intent launchIntent = intent.getParcelableExtra(KEY_INTENT);
        String packageName = intent.getStringExtra(KEY_PKG);
        int userId = intent.getIntExtra(KEY_USER_ID, 0);

        PackageInfo packageInfo = BlackBoxCore.getBPackageManager().getPackageInfo(packageName, 0, userId);
        if (packageInfo == null) {
            Slog.e(TAG, packageName + " not installed!");
            finish();
            return;
        }
        Drawable drawable = packageInfo.applicationInfo.loadIcon(BlackBoxCore.getPackageManager());
        setContentView(R.layout.activity_launcher);

        findViewById(R.id.iv_icon)
                .setBackground(drawable);
        new Thread(() -> BlackBoxCore.getBActivityManager().startActivity(launchIntent, userId)).start();
    }

    @Override
    protected void onPause() {
        super.onPause();
        isRunning = true;
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (isRunning) {
            finish();
        }
    }
}

```

`Bcore/src/main/java/com/vcore/app/configuration/AppLifecycleCallback.java`:

```java
package com.vcore.app.configuration;

import android.app.Activity;
import android.app.Application;
import android.content.Context;
import android.os.Bundle;
import android.util.Log;

import de.robv.android.xposed.XC_MethodHook;
import de.robv.android.xposed.XposedHelpers;
import com.vcore.BlackBoxCore;

public class AppLifecycleCallback implements Application.ActivityLifecycleCallbacks {
    public void beforeCreateApplication(String packageName, String processName, Context context, int userId) { }

    public void beforeApplicationOnCreate(String packageName, String processName, Application application, int userId) {

    }

    public void afterApplicationOnCreate(String packageName, String processName, Application application, int userId) { }

    @Override
    public void onActivityCreated(Activity activity, Bundle savedInstanceState) { }

    @Override
    public void onActivityStarted(Activity activity) { }

    @Override
    public void onActivityResumed(Activity activity) { }

    @Override
    public void onActivityPaused(Activity activity) { }

    @Override
    public void onActivityStopped(Activity activity) { }

    @Override
    public void onActivitySaveInstanceState(Activity activity, Bundle outState) { }

    @Override
    public void onActivityDestroyed(Activity activity) { }
}

```

`Bcore/src/main/java/com/vcore/app/configuration/ClientConfiguration.java`:

```java
package com.vcore.app.configuration;

import java.io.File;

public abstract class ClientConfiguration {
    public boolean isHideRoot() {
        return false;
    }

    public boolean isHideXposed() {
        return false;
    }

    public abstract String getHostPackageName();

    public boolean isEnableDaemonService() {
        return true;
    }

    public boolean isEnableLauncherActivity() {
        return true;
    }

    /**
     * This method is called when an internal application requests to install a new application.
     *
     * @return Is it handled?
     */
    public boolean requestInstallPackage(File file, int userId) {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/app/dispatcher/AppJobServiceDispatcher.java`:

```java
package com.vcore.app.dispatcher;

import android.app.job.JobParameters;
import android.app.job.JobService;
import android.content.res.Configuration;

import java.util.HashMap;
import java.util.Map;

import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.entity.JobRecord;

public class AppJobServiceDispatcher {
    private static final AppJobServiceDispatcher sServiceDispatcher = new AppJobServiceDispatcher();
    private final Map<Integer, JobRecord> mJobRecords = new HashMap<>();

    public static AppJobServiceDispatcher get() {
        return sServiceDispatcher;
    }

    public boolean onStartJob(JobParameters params) {
        try {
            JobService jobService = getJobService(params.getJobId());
            if (jobService == null) {
                return false;
            }
            return jobService.onStartJob(params);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    public boolean onStopJob(JobParameters params) {
        JobService jobService = getJobService(params.getJobId());
        if (jobService == null) {
            return false;
        }

        boolean isStopJob = jobService.onStopJob(params);
        jobService.onDestroy();

        synchronized (mJobRecords) {
            mJobRecords.remove(params.getJobId());
        }
        return isStopJob;
    }

    public void onConfigurationChanged(Configuration newConfig) {
        for (JobRecord jobRecord : mJobRecords.values()) {
            if (jobRecord.mJobService != null) {
                jobRecord.mJobService.onConfigurationChanged(newConfig);
            }
        }
    }

    public void onDestroy() {
        for (JobRecord jobRecord : mJobRecords.values()) {
            if (jobRecord.mJobService != null) {
                jobRecord.mJobService.onDestroy();
            }
        }
    }

    public void onLowMemory() {
        for (JobRecord jobRecord : mJobRecords.values()) {
            if (jobRecord.mJobService != null) {
                jobRecord.mJobService.onLowMemory();
            }
        }
    }

    public void onTrimMemory(int level) {
        for (JobRecord jobRecord : mJobRecords.values()) {
            if (jobRecord.mJobService != null) {
                jobRecord.mJobService.onTrimMemory(level);
            }
        }
    }

    JobService getJobService(int jobId) {
        synchronized (mJobRecords) {
            JobRecord jobRecord = mJobRecords.get(jobId);
            if (jobRecord != null && jobRecord.mJobService != null) {
                return jobRecord.mJobService;
            }

            try {
                JobRecord record = BlackBoxCore.getBJobManager().queryJobRecord(BActivityThread.getAppProcessName(), jobId);
                if (record == null) {
                    return null;
                }

                record.mJobService = BActivityThread.currentActivityThread().createJobService(record.mServiceInfo);
                if (record.mJobService == null) {
                    return null;
                }

                mJobRecords.put(jobId, record);
                return record.mJobService;
            } catch (Throwable t) {
                t.printStackTrace();
            }
            return null;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/app/dispatcher/AppServiceDispatcher.java`:

```java
package com.vcore.app.dispatcher;

import android.app.Service;
import android.content.Intent;
import android.content.pm.ServiceInfo;
import android.content.res.Configuration;
import android.os.Handler;
import android.os.IBinder;

import java.util.HashMap;
import java.util.Map;

import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.entity.ServiceRecord;
import com.vcore.entity.UnbindRecord;
import com.vcore.proxy.record.ProxyServiceRecord;

public class AppServiceDispatcher {
    private static final AppServiceDispatcher sServiceDispatcher = new AppServiceDispatcher();
    private final Map<Intent.FilterComparison, ServiceRecord> mService = new HashMap<>();
    private final Handler mHandler = BlackBoxCore.get().getHandler();

    public static AppServiceDispatcher get() {
        return sServiceDispatcher;
    }

    public IBinder onBind(Intent proxyIntent) {
        ProxyServiceRecord serviceRecord = ProxyServiceRecord.create(proxyIntent);
        Intent intent = serviceRecord.mServiceIntent;
        ServiceInfo serviceInfo = serviceRecord.mServiceInfo;

        if (intent == null || serviceInfo == null) {
            return null;
        }

        Service service = getOrCreateService(serviceRecord);
        if (service == null) {
            return null;
        }
        intent.setExtrasClassLoader(service.getClassLoader());

        ServiceRecord record = findRecord(intent);
        record.incrementAndGetBindCount(intent);

        if (record.hasBinder(intent)) {
            if (record.isRebind()) {
                service.onRebind(intent);
                record.setRebind(false);
            }
            return record.getBinder(intent);
        }

        try {
            IBinder iBinder = service.onBind(intent);
            record.addBinder(intent, iBinder);
            return iBinder;
        } catch (Throwable e) {
            e.printStackTrace();
        }
        return null;
    }

    public void onStartCommand(Intent proxyIntent) {
        ProxyServiceRecord stubRecord = ProxyServiceRecord.create(proxyIntent);
        if (stubRecord.mServiceIntent == null || stubRecord.mServiceInfo == null) {
            return;
        }

        Service service = getOrCreateService(stubRecord);
        if (service == null) {
            return;
        }
        stubRecord.mServiceIntent.setExtrasClassLoader(service.getClassLoader());

        ServiceRecord record = findRecord(stubRecord.mServiceIntent);
        record.setStartId(stubRecord.mStartId);
    }

    public void onDestroy() {
        if (mService.size() > 0) {
            for (ServiceRecord record : mService.values()) {
                try {
                    record.getService().onDestroy();
                } catch (Throwable e) {
                    e.printStackTrace();
                }
            }
        }
        mService.clear();
    }

    public void onConfigurationChanged(Configuration newConfig) {
        if (mService.size() > 0) {
            for (ServiceRecord record : mService.values()) {
                try {
                    record.getService().onConfigurationChanged(newConfig);
                } catch (Throwable e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public void onLowMemory() {
        if (mService.size() > 0) {
            for (ServiceRecord record : mService.values()) {
                try {
                    record.getService().onLowMemory();
                } catch (Throwable e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public void onTrimMemory(int level) {
        if (mService.size() > 0) {
            for (ServiceRecord record : mService.values()) {
                try {
                    record.getService().onTrimMemory(level);
                } catch (Throwable e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public void onUnbind(Intent proxyIntent) {
        ProxyServiceRecord stubRecord = ProxyServiceRecord.create(proxyIntent);
        if (stubRecord.mServiceIntent == null || stubRecord.mServiceInfo == null) {
            return;
        }

        Intent intent = stubRecord.mServiceIntent;
        try {
            UnbindRecord unbindRecord = BlackBoxCore.getBActivityManager().onServiceUnbind(proxyIntent, BActivityThread.getUserId());
            if (unbindRecord == null) {
                return;
            }

            Service service = getOrCreateService(stubRecord);
            if (service == null) {
                return;
            }
            stubRecord.mServiceIntent.setExtrasClassLoader(service.getClassLoader());

            ServiceRecord record = findRecord(intent);
            boolean destroy = unbindRecord.getStartId() == 0;

            if (destroy || record.decreaseConnectionCount(intent)) {
                if (destroy) {
                    service.onDestroy();

                    BlackBoxCore.getBActivityManager().onServiceDestroy(proxyIntent, BActivityThread.getUserId());
                    mService.remove(new Intent.FilterComparison(intent));
                }
                record.setRebind(true);
            }
        } catch (Throwable e) {
            e.printStackTrace();
        }
    }

    public IBinder peekService(Intent intent) {
        ServiceRecord record = findRecord(intent);
        if (record == null) {
            return null;
        }
        return record.getBinder(intent);
    }

    public void stopService(Intent intent) {
        if (intent == null) {
            return;
        }

        ServiceRecord record = findRecord(intent);
        if (record == null) {
            return;
        }

        if (record.getService() != null) {
            boolean destroy = record.getStartId() > 0;
            try {
                if (destroy) {
                    mHandler.post(() -> record.getService().onDestroy());
                    BlackBoxCore.getBActivityManager().onServiceDestroy(intent, BActivityThread.getUserId());
                    mService.remove(new Intent.FilterComparison(intent));
                }
            } catch (Throwable e) {
                e.printStackTrace();
            }
        }
    }

    private ServiceRecord findRecord(Intent intent) {
        return mService.get(new Intent.FilterComparison(intent));
    }

    private Service getOrCreateService(ProxyServiceRecord proxyServiceRecord) {
        Intent intent = proxyServiceRecord.mServiceIntent;
        ServiceInfo serviceInfo = proxyServiceRecord.mServiceInfo;
        IBinder token = proxyServiceRecord.mToken;

        ServiceRecord record = findRecord(intent);
        if (record != null && record.getService() != null) {
            return record.getService();
        }

        Service service = BActivityThread.currentActivityThread().createService(serviceInfo, token);
        if (service == null) {
            return null;
        }

        record = new ServiceRecord();
        record.setService(service);
        mService.put(new Intent.FilterComparison(intent), record);
        return service;
    }
}

```

`Bcore/src/main/java/com/vcore/core/CrashHandler.java`:

```java
package com.vcore.core;

import androidx.annotation.NonNull;

import com.vcore.BlackBoxCore;

public class CrashHandler implements Thread.UncaughtExceptionHandler {
    private final Thread.UncaughtExceptionHandler mDefaultHandler;

    public static void create() {
        new CrashHandler();
    }

    public CrashHandler() {
        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();
        Thread.setDefaultUncaughtExceptionHandler(this);
    }

    @Override
    public void uncaughtException(@NonNull Thread t, @NonNull Throwable e) {
        if (BlackBoxCore.get().getExceptionHandler() != null) {
            BlackBoxCore.get().getExceptionHandler().uncaughtException(t, e);
        }
        mDefaultHandler.uncaughtException(t, e);
    }
}

```

`Bcore/src/main/java/com/vcore/core/GmsCore.java`:

```java
package com.vcore.core;

import android.content.pm.PackageManager;

import java.util.HashSet;
import java.util.Set;

import com.vcore.BlackBoxCore;
import com.vcore.entity.pm.InstallResult;

public class GmsCore {
    private static final HashSet<String> GOOGLE_APP = new HashSet<>();
    private static final HashSet<String> GOOGLE_SERVICE = new HashSet<>();
    public static final String GMS_PKG = "com.google.android.gms";
    public static final String GSF_PKG = "com.google.android.gsf";
    public static final String VENDING_PKG = "com.android.vending";

    static {
        GOOGLE_APP.add(VENDING_PKG);
        GOOGLE_APP.add("com.google.android.play.games");
        GOOGLE_APP.add("com.google.android.wearable.app");
        GOOGLE_APP.add("com.google.android.wearable.app.cn");

        // GMS must install at first
        GOOGLE_SERVICE.add(GMS_PKG);
        GOOGLE_SERVICE.add(GSF_PKG);
        GOOGLE_SERVICE.add("com.google.android.gsf.login");
        GOOGLE_SERVICE.add("com.google.android.backuptransport");
        GOOGLE_SERVICE.add("com.google.android.backup");
        GOOGLE_SERVICE.add("com.google.android.configupdater");
        GOOGLE_SERVICE.add("com.google.android.syncadapters.contacts");
        GOOGLE_SERVICE.add("com.google.android.feedback");
        GOOGLE_SERVICE.add("com.google.android.onetimeinitializer");
        GOOGLE_SERVICE.add("com.google.android.partnersetup");
        GOOGLE_SERVICE.add("com.google.android.setupwizard");
        GOOGLE_SERVICE.add("com.google.android.syncadapters.calendar");
    }

    public static boolean isGoogleAppOrService(String str) {
        return GOOGLE_APP.contains(str) || GOOGLE_SERVICE.contains(str);
    }

    private static InstallResult installPackages(Set<String> list, int userId) {
        BlackBoxCore blackBoxCore = BlackBoxCore.get();
        for (String packageName : list) {
            if (blackBoxCore.isInstalled(packageName, userId)) {
                continue;
            }

            try {
                BlackBoxCore.getContext().getPackageManager().getApplicationInfo(packageName, 0);
            } catch (PackageManager.NameNotFoundException ignored) {
                continue;
            }

            InstallResult installResult = blackBoxCore.installPackageAsUser(packageName, userId);
            if (!installResult.success) {
                return installResult;
            }
        }
        return new InstallResult();
    }

    private static void uninstallPackages(Set<String> list, int userId) {
        BlackBoxCore blackBoxCore = BlackBoxCore.get();
        for (String packageName : list) {
            blackBoxCore.uninstallPackageAsUser(packageName, userId);
        }
    }

    public static InstallResult installGApps(int userId) {
        Set<String> googleApps = new HashSet<>();

        googleApps.addAll(GOOGLE_SERVICE);
        googleApps.addAll(GOOGLE_APP);

        InstallResult installResult = installPackages(googleApps, userId);
        if (!installResult.success) {
            uninstallGApps(userId);
            return installResult;
        }
        return installResult;
    }

    public static void uninstallGApps(int userId) {
        uninstallPackages(GOOGLE_SERVICE, userId);
        uninstallPackages(GOOGLE_APP, userId);
    }

    public static void remove(String packageName) {
        GOOGLE_SERVICE.remove(packageName);
        GOOGLE_APP.remove(packageName);
    }

    public static boolean isSupportGms() {
        try {
            BlackBoxCore.getPackageManager().getPackageInfo(GMS_PKG, 0);
            return true;
        } catch (PackageManager.NameNotFoundException ignored) { }
        return false;
    }

    public static boolean isInstalledGoogleService(int userId) {
        return BlackBoxCore.get().isInstalled(GMS_PKG, userId);
    }
}
```

`Bcore/src/main/java/com/vcore/core/IOCore.java`:

```java
package com.vcore.core;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.Environment;
import android.os.Process;
import android.text.TextUtils;

import java.io.File;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.core.env.BEnvironment;
import com.vcore.utils.FileUtils;
import com.vcore.utils.TrieTree;

@SuppressLint("SdCardPath")
public class IOCore {
    public static final String TAG = "IOCore";

    private static final IOCore sIOCore = new IOCore();
    private static final TrieTree mTrieTree = new TrieTree();
    private static final TrieTree sBlackTree = new TrieTree();
    private final Map<String, String> mRedirectMap = new LinkedHashMap<>();

    public static IOCore get() {
        return sIOCore;
    }

    // 路径前缀匹配，重定向
    // /data/data/com.google/  ----->  /data/data/com.virtual/data/com.google/
    public void addRedirect(String origPath, String redirectPath) {
        if (TextUtils.isEmpty(origPath) || TextUtils.isEmpty(redirectPath) || mRedirectMap.get(origPath) != null) {
            return;
        }
        // Add the key to TrieTree
        mTrieTree.add(origPath);
        mRedirectMap.put(origPath, redirectPath);
        File redirectFile = new File(redirectPath);
        if (!redirectFile.exists()) {
            FileUtils.mkdirs(redirectPath);
        }
        NativeCore.addIORule(origPath, redirectPath);
    }

    public void addBlackRedirect(String path) {
        if (TextUtils.isEmpty(path)) {
            return;
        }
        sBlackTree.add(path);
        NativeCore.addWhiteList(path);
    }

    public String redirectPath(String path) {
        if (TextUtils.isEmpty(path)) {
            return path;
        }
        if (path.contains("/blackbox/")) {
            return path;
        }
        String search = sBlackTree.search(path);
        if (!TextUtils.isEmpty(search)) {
            return search;
        }

        // Search the key from TrieTree
        String key = mTrieTree.search(path);
        if (!TextUtils.isEmpty(key)) {
            path = path.replace(key, Objects.requireNonNull(mRedirectMap.get(key)));
        }
        return path;
    }

    public File redirectPath(File path) {
        if (path == null) {
            return null;
        }
        String pathStr = path.getAbsolutePath();
        return new File(redirectPath(pathStr));
    }

    public String redirectPath(String path, Map<String, String> rule) {
        if (TextUtils.isEmpty(path)) {
            return path;
        }
        // Search the key from TrieTree
        String key = mTrieTree.search(path);
        if (!TextUtils.isEmpty(key)) {
            path = path.replace(key, Objects.requireNonNull(rule.get(key)));
        }
        return path;
    }

    // 由于正常情况Application已完成重定向，以下重定向是怕代码写死。
    public void enableRedirect(Context context) {
        Map<String, String> rule = new LinkedHashMap<>();
        Set<String> blackRule = new HashSet<>();

        try {
            // 修改所有已安装的路径, 支持xposed module
            int systemUserId = BlackBoxCore.getHostUserId();
            List<ApplicationInfo> installedApplications = BlackBoxCore.getBPackageManager().getInstalledApplications(PackageManager.GET_META_DATA, BActivityThread.getUserId());
            for (ApplicationInfo packageInfo : installedApplications) {
                rule.put(String.format("/data/data/%s/lib", packageInfo.packageName), packageInfo.nativeLibraryDir);
                rule.put(String.format("/data/user/%d/%s/lib", systemUserId, packageInfo.packageName), packageInfo.nativeLibraryDir);

                rule.put(String.format("/data/data/%s", packageInfo.packageName), packageInfo.dataDir);
                rule.put(String.format("/data/user/%d/%s", systemUserId, packageInfo.packageName), packageInfo.dataDir);
            }

            if (BlackBoxCore.getContext().getExternalCacheDir() != null && context.getExternalCacheDir() != null) {
                File external = BEnvironment.getExternalUserDir(BActivityThread.getUserId());

                // sdcard
                rule.put("/sdcard", external.getAbsolutePath());
                rule.put(String.format("/storage/emulated/%d", systemUserId), external.getAbsolutePath());

                blackRule.add("/sdcard/Pictures");
                blackRule.add(String.format("/storage/emulated/%d/Pictures", systemUserId));
                blackRule.add(String.format("/storage/emulated/%d/%s", systemUserId, Environment.DIRECTORY_PODCASTS));
                blackRule.add(String.format("/storage/emulated/%d/%s", systemUserId, Environment.DIRECTORY_RINGTONES));
                blackRule.add(String.format("/storage/emulated/%d/%s", systemUserId, Environment.DIRECTORY_ALARMS));
                blackRule.add(String.format("/storage/emulated/%d/%s", systemUserId, Environment.DIRECTORY_NOTIFICATIONS));
                blackRule.add(String.format("/storage/emulated/%d/%s", systemUserId, Environment.DIRECTORY_PICTURES));
                blackRule.add(String.format("/storage/emulated/%d/%s", systemUserId, Environment.DIRECTORY_MOVIES));
                blackRule.add(String.format("/storage/emulated/%d/%s", systemUserId, Environment.DIRECTORY_DOWNLOADS));
                blackRule.add(String.format("/storage/emulated/%d/%s", systemUserId, Environment.DIRECTORY_DCIM));
                blackRule.add(String.format("/storage/emulated/%d/%s", systemUserId, Environment.DIRECTORY_MUSIC));
                blackRule.add(String.format("/sdcard/%s", Environment.DIRECTORY_PODCASTS));
                blackRule.add(String.format("/sdcard/%s", Environment.DIRECTORY_RINGTONES));
                blackRule.add(String.format("/sdcard/%s", Environment.DIRECTORY_ALARMS));
                blackRule.add(String.format("/sdcard/%s", Environment.DIRECTORY_NOTIFICATIONS));
                blackRule.add(String.format("/sdcard/%s", Environment.DIRECTORY_PICTURES));
                blackRule.add(String.format("/sdcard/%s", Environment.DIRECTORY_MOVIES));
                blackRule.add(String.format("/sdcard/%s", Environment.DIRECTORY_DOWNLOADS));
                blackRule.add(String.format("/sdcard/%s", Environment.DIRECTORY_DCIM));
                blackRule.add(String.format("/sdcard/%s", Environment.DIRECTORY_MUSIC));
            }

            if (BlackBoxCore.get().isHideRoot()) {
                hideRoot(rule);
            }
            proc(rule);
        } catch (Exception e) {
            e.printStackTrace();
        }
        for (String key : rule.keySet()) {
            get().addRedirect(key, rule.get(key));
        }
        for (String s : blackRule) {
            get().addBlackRedirect(s);
        }
        NativeCore.enableIO();
    }

    private void hideRoot(Map<String, String> rule) {
        rule.put("/system/app/Superuser.apk", "/system/app/Superuser.apk-fake");
        rule.put("/sbin/su", "/sbin/su-fake");
        rule.put("/system/bin/su", "/system/bin/su-fake");
        rule.put("/system/xbin/su", "/system/xbin/su-fake");
        rule.put("/data/local/xbin/su", "/data/local/xbin/su-fake");
        rule.put("/data/local/bin/su", "/data/local/bin/su-fake");
        rule.put("/system/sd/xbin/su", "/system/sd/xbin/su-fake");
        rule.put("/system/bin/failsafe/su", "/system/bin/failsafe/su-fake");
        rule.put("/data/local/su", "/data/local/su-fake");
        rule.put("/su/bin/su", "/su/bin/su-fake");
    }

    private void proc(Map<String, String> rule) {
        int appPid = BActivityThread.getAppPid();
        int pid = Process.myPid();
        String selfProc = "/proc/self/";
        String proc = "/proc/" + pid + "/";

        String cmdline = new File(BEnvironment.getProcDir(appPid), "cmdline").getAbsolutePath();
        rule.put(proc + "cmdline", cmdline);
        rule.put(selfProc + "cmdline", cmdline);
    }
}

```

`Bcore/src/main/java/com/vcore/core/NativeCore.java`:

```java
package com.vcore.core;

import android.annotation.SuppressLint;
import android.os.Binder;
import android.os.Process;
import android.util.Log;

import androidx.annotation.Keep;

import java.io.File;

import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;

@SuppressLint({"UnsafeDynamicallyLoadedCode", "SdCardPath"})
public class NativeCore {
    public static final String TAG = "NativeCore";
    private static boolean isInjected = false;

    static {
        System.loadLibrary("vcore");

        if (!isInjected) {
            Log.i(TAG, "Loading libinject.so from cache directory");
            if (new File("/data/data/com.reveny.virtualinject/cache/libinject.so").exists()) {
                Log.i(TAG, "Loading libinject.so from cache directory");
                System.load("/data/data/com.reveny.virtualinject/cache/libinject.so");
            } else {
                Log.e(TAG, "libinject.so not found in cache directory");
            }
        } else {
            Log.i(TAG, "libinject.so already loaded");
        }
    }

    public static native void init(int apiLevel);

    public static native void enableIO();

    public static native void addWhiteList(String path);

    public static native void addIORule(String targetPath, String relocatePath);

    private static native void nativeIORedirect(String origPath, String newPath);

    public static native void hideXposed();

    @Keep
    public static int getCallingUid(int origCallingUid) {
        // 系统uid
        if (origCallingUid > 0 && origCallingUid < Process.FIRST_APPLICATION_UID) {
            return origCallingUid;
        }
        // 非用户应用
        if (origCallingUid > Process.LAST_APPLICATION_UID) {
            return origCallingUid;
        }

        if (origCallingUid == BlackBoxCore.getHostUid()) {
            int callingPid = Binder.getCallingPid();
            int bUid = BlackBoxCore.getBPackageManager().getUidByPid(callingPid);
            if (bUid != -1) {
                return bUid;
            }
            return BActivityThread.getCallingBUid();
        }
        return origCallingUid;
    }

    @Keep
    public static String redirectPath(String path) {
        return IOCore.get().redirectPath(path);
    }

    @Keep
    public static File redirectPath(File path) {
        return IOCore.get().redirectPath(path);
    }
}

```

`Bcore/src/main/java/com/vcore/core/env/AppSystemEnv.java`:

```java
package com.vcore.core.env;

import android.content.ComponentName;
import android.os.Build;

import java.util.ArrayList;
import java.util.List;

import com.vcore.BlackBoxCore;

public class AppSystemEnv {
    private static final List<String> sSystemPackages = new ArrayList<>();
    private static final List<String> sSuPackages = new ArrayList<>();
    private static final List<String> sXposedPackages = new ArrayList<>();
    private static final List<String> sPreInstallPackages = new ArrayList<>();

    static {
        sSystemPackages.add("android");
        sSystemPackages.add("com.google.android.webview");
        sSystemPackages.add("com.google.android.webview.dev");
        sSystemPackages.add("com.google.android.webview.beta");
        sSystemPackages.add("com.google.android.webview.canary");
        sSystemPackages.add("com.android.webview");
        sSystemPackages.add("com.android.camera");
        sSystemPackages.add("com.android.talkback");
        sSystemPackages.add("com.miui.gallery");

        // Google Gboard
        sSystemPackages.add("com.google.android.inputmethod.latin");
        // sSystemPackages.add(BlackBoxCore.getHostPkg());

        // 华为
        sSystemPackages.add("com.huawei.webview");

        // MIUI
        sSystemPackages.add("com.miui.contentcatcher");
        sSystemPackages.add("com.miui.catcherpatch");

        // Oppo
        sSystemPackages.add("com.coloros.safecenter");

        // Su
        sSuPackages.add("com.noshufou.android.su");
        sSuPackages.add("com.noshufou.android.su.elite");
        sSuPackages.add("eu.chainfire.supersu");
        sSuPackages.add("com.koushikdutta.superuser");
        sSuPackages.add("com.thirdparty.superuser");
        sSuPackages.add("com.yellowes.su");

        sXposedPackages.add("de.robv.android.xposed.installer");
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N && Build.VERSION.SDK_INT < 29){
            //解决Android 9三星浏览器闪退问题
        }else{

        }
    }

    public static boolean isOpenPackage(String packageName) {
        return sSystemPackages.contains(packageName);
    }

    public static boolean isOpenPackage(ComponentName componentName) {
        return componentName != null && isOpenPackage(componentName.getPackageName());
    }

    public static boolean isBlackPackage(String packageName) {
        if (BlackBoxCore.get().isHideRoot() && sSuPackages.contains(packageName)) {
            return true;
        }
        return BlackBoxCore.get().isHideXposed() && sXposedPackages.contains(packageName);
    }

    public static List<String> getPreInstallPackages() {
        return sPreInstallPackages;
    }
}

```

`Bcore/src/main/java/com/vcore/core/env/BEnvironment.java`:

```java
package com.vcore.core.env;

import java.io.File;
import java.util.Locale;

import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.utils.FileUtils;

public class BEnvironment {
    private static final File sVirtualRoot = new File(BlackBoxCore.getContext().getCacheDir().getParent(), "blackbox");
    private static final File sExternalVirtualRoot = BlackBoxCore.getContext().getExternalFilesDir("blackbox");

    public static void load() {
        FileUtils.mkdirs(sVirtualRoot);
        FileUtils.mkdirs(sExternalVirtualRoot);
        FileUtils.mkdirs(getSystemDir());
        FileUtils.mkdirs(getCacheDir());
        FileUtils.mkdirs(getProcDir());
    }

    public static File getVirtualRoot() {
        return sVirtualRoot;
    }

    public static File getExternalVirtualRoot() {
        return sExternalVirtualRoot;
    }

    public static File getSystemDir() {
        return new File(sVirtualRoot, "system");
    }

    public static File getProcDir() {
        return new File(sVirtualRoot, "proc");
    }

    public static File getCacheDir() {
        return new File(sVirtualRoot, "cache");
    }

    public static File getUserInfoConf() {
        return new File(getSystemDir(), "user.conf");
    }

    public static File getAccountsConf() {
        return new File(getSystemDir(), "accounts.conf");
    }

    public static File getUidConf() {
        return new File(getSystemDir(), "uid.conf");
    }

    public static File getSharedUserConf() {
        return new File(getSystemDir(), "shared-user.conf");
    }

    public static File getXPModuleConf() {
        return new File(getSystemDir(), "xposed-module.conf");
    }

    public static File getFakeLocationConf() {
        return new File(getSystemDir(), "fake-location.conf");
    }

    public static File getFakeDeviceConf() {
        return new File(getSystemDir(), "fake-device.conf");
    }

    public static File getPackageConf(String packageName) {
        return new File(getAppDir(packageName), "package.conf");
    }

    public static File getExternalUserDir(int userId) {
        return new File(sExternalVirtualRoot, String.format(Locale.CHINA, "storage/emulated/%d/", userId));
    }

    public static File getUserDir(int userId) {
        return new File(sVirtualRoot, String.format(Locale.CHINA, "data/user/%d", userId));
    }

    public static File getDeDataDir(String packageName, int userId) {
        return new File(sVirtualRoot, String.format(Locale.CHINA, "data/user_de/%d/%s", userId, packageName));
    }

    public static File getExternalDataDir(String packageName, int userId) {
        return new File(getExternalUserDir(userId), String.format(Locale.CHINA, "Android/data/%s", packageName));
    }

    public static File getDataDir(String packageName, int userId) {
        return new File(sVirtualRoot, String.format(Locale.CHINA, "data/user/%d/%s", userId, packageName));
    }

    public static File getProcDir(int pid) {
        File file = new File(getProcDir(), String.format(Locale.CHINA, "%d", pid));
        FileUtils.mkdirs(file);
        return file;
    }

    public static File getExternalDataFilesDir(String packageName, int userId) {
        return new File(getExternalDataDir(packageName, userId), "files");
    }

    public static File getDataFilesDir(String packageName, int userId) {
        return new File(getDataDir(packageName, userId), "files");
    }

    public static File getExternalDataCacheDir(String packageName, int userId) {
        return new File(getExternalDataDir(packageName, userId), "cache");
    }

    public static File getDataCacheDir(String packageName, int userId) {
        return new File(getDataDir(packageName, userId), "cache");
    }

    public static File getDataLibDir(String packageName, int userId) {
        return new File(getDataDir(packageName, userId), "lib");
    }

    public static File getDataDatabasesDir(String packageName, int userId) {
        return new File(getDataDir(packageName, userId), "databases");
    }

    public static File getAppRootDir() {
        return getAppDir("");
    }

    public static File getAppDir(String packageName) {
        return new File(sVirtualRoot, "data/app/" + packageName);
    }

    public static File getBaseApkDir(String packageName) {
        return new File(sVirtualRoot, "data/app/" + packageName + "/base.apk");
    }

    public static File getAppLibDir(String packageName) {
        return new File(getAppDir(packageName), "lib");
    }

    public static File getXSharedPreferences(String packageName, String prefFileName) {
       return new File(BEnvironment.getDataDir(packageName, BActivityThread.getUserId()), "shared_prefs/" + prefFileName + ".xml");
    }
}

```

`Bcore/src/main/java/com/vcore/core/env/VirtualRuntime.java`:

```java
package com.vcore.core.env;

import android.content.pm.ApplicationInfo;

import black.android.ddm.DdmHandleAppName;
import black.android.os.Process;

public class VirtualRuntime {
    private static String sInitialPackageName;
    private static String sProcessName;

    public static String getProcessName() {
        return sProcessName;
    }

    public static String getInitialPackageName() {
        return sInitialPackageName;
    }

    public static void setupRuntime(String processName, ApplicationInfo appInfo) {
        if (sProcessName != null) {
            return;
        }

        sInitialPackageName = appInfo.packageName;
        sProcessName = processName;
        Process.setArgV0.call(processName);
        DdmHandleAppName.setAppName.call(processName, 0);
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/BProcessManagerService.java`:

```java
package com.vcore.core.system;

import android.app.ActivityManager;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.os.Binder;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Process;
import android.os.RemoteException;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.vcore.BlackBoxCore;

import com.vcore.core.IBActivityThread;
import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.notification.BNotificationManagerService;
import com.vcore.core.system.pm.BPackageManagerService;
import com.vcore.core.system.user.BUserHandle;
import com.vcore.entity.AppConfig;
import com.vcore.proxy.ProxyManifest;
import com.vcore.utils.FileUtils;
import com.vcore.utils.Slog;
import com.vcore.utils.compat.ApplicationThreadCompat;
import com.vcore.utils.compat.BundleCompat;
import com.vcore.utils.provider.ProviderCall;

public class BProcessManagerService implements ISystemService {
    public static final String TAG = "BProcessManager";

    public static final BProcessManagerService sBProcessManagerService = new BProcessManagerService();
    private final Map<Integer, Map<String, ProcessRecord>> mProcessMap = new HashMap<>();
    private final List<ProcessRecord> mPidsSelfLocked = new ArrayList<>();
    private final Object mProcessLock = new Object();

    public static BProcessManagerService get() {
        return sBProcessManagerService;
    }

    public ProcessRecord startProcessLocked(String packageName, String processName, int userId, int bPID, int callingPid) {
        ApplicationInfo info = BPackageManagerService.get().getApplicationInfo(packageName, 0, userId);
        if (info == null) {
            return null;
        }

        ProcessRecord app;
        int bUID = BUserHandle.getUid(userId, BPackageManagerService.get().getAppId(packageName));
        synchronized (mProcessLock) {
            Map<String, ProcessRecord> bProcess = mProcessMap.get(bUID);

            if (bProcess == null) {
                bProcess = new HashMap<>();
            }

            if (bPID == -1) {
                app = bProcess.get(processName);
                if (app != null) {
                    if (app.initLock != null) {
                        app.initLock.block();
                    }

                    if (app.bActivityThread != null) {
                        return app;
                    }
                }
                bPID = getUsingBPidL();
                Slog.d(TAG, "init bUid = " + bUID + ", bPid = " + bPID);
            }

            if (bPID == -1) {
                throw new RuntimeException("No processes available");
            }

            app = new ProcessRecord(info, processName);
            app.uid = Process.myUid();
            app.bPID = bPID;
            app.bUID = BPackageManagerService.get().getAppId(packageName);
            app.callingBUid = getBUidByPidOrPackageName(callingPid, packageName);
            app.userId = userId;

            bProcess.put(processName, app);
            mPidsSelfLocked.add(app);

            synchronized (mProcessMap) {
                mProcessMap.put(bUID, bProcess);
            }

            if (!initAppProcessL(app)) {
                bProcess.remove(processName);
                mPidsSelfLocked.remove(app);
                app = null;
            } else {
                app.pid = getPid(BlackBoxCore.getContext(), ProxyManifest.getProcessName(app.bPID));

                Slog.d(TAG, "init pid = " + app.pid);
            }
        }
        return app;
    }

    private void killProcess(final ProcessRecord app) {
        if (app.pid > 0) {
            Process.killProcess(app.pid);
        } else {
            try {
                ActivityManager manager = (ActivityManager) BlackBoxCore.getContext().getSystemService(Context.ACTIVITY_SERVICE);
                List<ActivityManager.RunningAppProcessInfo> runningAppProcesses = manager.getRunningAppProcesses();
                for (ActivityManager.RunningAppProcessInfo runningAppProcess : runningAppProcesses) {
                    int bPID = parseBPid(runningAppProcess.processName);
                    if (bPID != -1 && app.bPID == bPID) {
                        Slog.d(TAG, "force kill process: " + app.processName + ", pid: " + runningAppProcess.pid + ", bPID: " + bPID);
                        Process.killProcess(runningAppProcess.pid);
                    }
                }
            } catch (Throwable e) {
                e.printStackTrace();
            }
        }
    }

    private int getUsingBPidL() {
        ActivityManager manager = (ActivityManager) BlackBoxCore.getContext().getSystemService(Context.ACTIVITY_SERVICE);
        List<ActivityManager.RunningAppProcessInfo> runningAppProcesses = manager.getRunningAppProcesses();
        Set<Integer> usingPs = new HashSet<>();

        for (ActivityManager.RunningAppProcessInfo runningAppProcess : runningAppProcesses) {
            int i = parseBPid(runningAppProcess.processName);
            usingPs.add(i);
        }

        for (int i = 0; i < ProxyManifest.FREE_COUNT; i++) {
            if (usingPs.contains(i)) {
                continue;
            }
            return i;
        }
        return -1;
    }

    public void restartAppProcess(String packageName, String processName, int userId) {
        synchronized (mProcessLock) {
            int callingPid = Binder.getCallingPid();
            ProcessRecord app = findProcessByPid(callingPid);
            if (app != null) {
                killProcess(app);
            }

            String stubProcessName = getProcessName(BlackBoxCore.getContext(), callingPid);
            int bPID = parseBPid(stubProcessName);
            startProcessLocked(packageName, processName, userId, bPID, callingPid);
        }
    }

    private int parseBPid(String stubProcessName) {
        String prefix;
        if (stubProcessName == null) {
            return -1;
        } else {
            prefix = BlackBoxCore.getHostPkg() + ":p";
        }

        if (stubProcessName.startsWith(prefix)) {
            try {
                return Integer.parseInt(stubProcessName.substring(prefix.length()));
            } catch (NumberFormatException ignored) { }
        }
        return -1;
    }

    private boolean initAppProcessL(ProcessRecord record) {
        Slog.d(TAG, "initProcess: " + record.processName);
        AppConfig appConfig = record.getClientConfig();
        Bundle bundle = new Bundle();
        bundle.putParcelable(AppConfig.KEY, appConfig);
        Bundle init = ProviderCall.callSafely(record.getProviderAuthority(), "_Black_|_init_process_", null, bundle);

        IBinder appThread = BundleCompat.getBinder(init, "_Black_|_client_");
        if (appThread == null || !appThread.isBinderAlive()) {
            return false;
        }

        attachClientL(record, appThread);
        createProc(record);
        return true;
    }

    private void attachClientL(final ProcessRecord app, final IBinder appThread) {
        IBActivityThread activityThread = IBActivityThread.Stub.asInterface(appThread);
        if (activityThread == null) {
            killProcess(app);
            return;
        }

        try {
            appThread.linkToDeath(new IBinder.DeathRecipient() {
                @Override
                public void binderDied() {
                    Slog.d(TAG, "App Died: " + app.processName);
                    appThread.unlinkToDeath(this, 0);
                    onProcessDie(app);
                }
            }, 0);
        } catch (RemoteException e) {
            e.printStackTrace();
        }

        app.bActivityThread = activityThread;
        try {
            app.appThread = ApplicationThreadCompat.asInterface(activityThread.getActivityThread());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        app.initLock.open();
    }

    public void onProcessDie(ProcessRecord record) {
        synchronized (mProcessLock) {
            killProcess(record);
            Map<String, ProcessRecord> process = mProcessMap.get(record.bUID);
            if (process != null) {
                process.remove(record.processName);
                if (process.isEmpty()) {
                    mProcessMap.remove(record.bUID);
                }
            }

            mPidsSelfLocked.remove(record);
            removeProc(record);
            BNotificationManagerService.get().deletePackageNotification(record.getPackageName(), record.userId);
        }
    }

    public ProcessRecord findProcessRecord(String packageName, String processName, int userId) {
        synchronized (mProcessMap) {
            int appId = BPackageManagerService.get().getAppId(packageName);
            int bUID = BUserHandle.getUid(userId, appId);

            Map<String, ProcessRecord> processRecordMap = mProcessMap.get(bUID);
            if (processRecordMap == null) {
                return null;
            }
            return processRecordMap.get(processName);
        }
    }

    public void killAllByPackageName(String packageName) {
        synchronized (mProcessLock) {
            synchronized (mPidsSelfLocked) {
                List<ProcessRecord> tmp = new ArrayList<>(mPidsSelfLocked);
                int appId = BPackageManagerService.get().getAppId(packageName);
                for (ProcessRecord processRecord : mPidsSelfLocked) {
                    int appId1 = BUserHandle.getAppId(processRecord.bUID);
                    if (appId == appId1) {
                        mProcessMap.remove(processRecord.bUID);
                        killProcess(processRecord);
                        tmp.remove(processRecord);
                    }
                }
                mPidsSelfLocked.clear();
                mPidsSelfLocked.addAll(tmp);
            }
        }
    }

    public void killPackageAsUser(String packageName, int userId) {
        synchronized (mProcessLock) {
            int bUID = BUserHandle.getUid(userId, BPackageManagerService.get().getAppId(packageName));
            Map<String, ProcessRecord> process = mProcessMap.get(bUID);
            if (process == null) {
                return;
            }

            for (ProcessRecord value : process.values()) {
                killProcess(value);
                mPidsSelfLocked.remove(value);
            }
            mProcessMap.remove(bUID);
        }
    }

    public List<ProcessRecord> getPackageProcessAsUser(String packageName, int userId) {
        synchronized (mProcessMap) {
            int bUID = BUserHandle.getUid(userId, BPackageManagerService.get().getAppId(packageName));
            Map<String, ProcessRecord> process = mProcessMap.get(bUID);
            if (process == null) {
                return new ArrayList<>();
            }
            return new ArrayList<>(process.values());
        }
    }

    public int getBUidByPidOrPackageName(int pid, String packageName) {
        ProcessRecord callingProcess = findProcessByPid(pid);
        if (callingProcess == null) {
            return BPackageManagerService.get().getAppId(packageName);
        }
        return BUserHandle.getAppId(callingProcess.bUID);
    }

    public int getUserIdByCallingPid(int callingPid) {
        ProcessRecord callingProcess = findProcessByPid(callingPid);
        if (callingProcess == null) {
            return 0;
        }
        return callingProcess.userId;
    }

    public ProcessRecord findProcessByPid(int pid) {
        synchronized (mPidsSelfLocked) {
            for (ProcessRecord processRecord : mPidsSelfLocked) {
                if (processRecord.pid == pid) {
                    return processRecord;
                }
            }
            return null;
        }
    }

    private static String getProcessName(Context context, int pid) {
        String processName = null;
        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        for (ActivityManager.RunningAppProcessInfo info : am.getRunningAppProcesses()) {
            if (info.pid == pid) {
                processName = info.processName;
                break;
            }
        }
        if (processName == null) {
            throw new RuntimeException("processName = null");
        }
        return processName;
    }

    public static int getPid(Context context, String processName) {
        try {
            ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            List<ActivityManager.RunningAppProcessInfo> runningAppProcesses = manager.getRunningAppProcesses();
            for (ActivityManager.RunningAppProcessInfo runningAppProcess : runningAppProcesses) {
                if (runningAppProcess.processName.equals(processName)) {
                    return runningAppProcess.pid;
                }
            }
        } catch (Throwable e) {
            e.printStackTrace();
        }
        return -1;
    }

    private static void createProc(ProcessRecord record) {
        File cmdline = new File(BEnvironment.getProcDir(record.bPID), "cmdline");
        try {
            FileUtils.writeToFile(record.processName.getBytes(), cmdline);
        } catch (IOException ignored) { }
    }

    private static void removeProc(ProcessRecord record) {
        FileUtils.deleteDir(BEnvironment.getProcDir(record.bPID));
    }

    @Override
    public void systemReady() {
        FileUtils.deleteDir(BEnvironment.getProcDir());
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/BlackBoxSystem.java`:

```java
package com.vcore.core.system;

import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import com.vcore.BlackBoxCore;
import com.vcore.core.env.AppSystemEnv;
import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.accounts.BAccountManagerService;
import com.vcore.core.system.am.BActivityManagerService;
import com.vcore.core.system.am.BJobManagerService;
import com.vcore.core.system.location.BLocationManagerService;
import com.vcore.core.system.notification.BNotificationManagerService;
import com.vcore.core.system.os.BStorageManagerService;
import com.vcore.core.system.pm.BPackageInstallerService;
import com.vcore.core.system.pm.BPackageManagerService;
import com.vcore.core.system.pm.BXposedManagerService;
import com.vcore.core.system.user.BUserHandle;
import com.vcore.core.system.user.BUserManagerService;
import com.vcore.entity.pm.InstallOption;

public class BlackBoxSystem {
    private final List<ISystemService> mServices = new ArrayList<>();
    private final static AtomicBoolean isStartup = new AtomicBoolean(false);

    private static final class SBlackBoxSystemHolder {
        static final BlackBoxSystem sBlackBoxSystem = new BlackBoxSystem();
    }

    public static BlackBoxSystem getSystem() {
        return SBlackBoxSystemHolder.sBlackBoxSystem;
    }

    public void startup() {
        if (isStartup.getAndSet(true)) {
            return;
        }

        BEnvironment.load();
        mServices.add(BPackageManagerService.get());
        mServices.add(BUserManagerService.get());
        mServices.add(BActivityManagerService.get());
        mServices.add(BJobManagerService.get());
        mServices.add(BStorageManagerService.get());
        mServices.add(BPackageInstallerService.get());
        mServices.add(BXposedManagerService.get());
        mServices.add(BProcessManagerService.get());
        mServices.add(BAccountManagerService.get());
        mServices.add(BLocationManagerService.get());
        mServices.add(BNotificationManagerService.get());

        for (ISystemService service : mServices) {
            service.systemReady();
        }

        List<String> preInstallPackages = AppSystemEnv.getPreInstallPackages();
        for (String preInstallPackage : preInstallPackages) {
            try {
                if (!BPackageManagerService.get().isInstalled(preInstallPackage, BUserHandle.USER_ALL)) {
                    PackageInfo packageInfo = BlackBoxCore.getPackageManager().getPackageInfo(preInstallPackage, 0);
                    BPackageManagerService.get().installPackageAsUser(packageInfo.applicationInfo.sourceDir, InstallOption.installBySystem(), BUserHandle.USER_ALL);
                }
            } catch (PackageManager.NameNotFoundException ignored) { }
        }
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/DaemonService.java`:

```java
package com.vcore.core.system;

import android.app.NotificationManager;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.util.Log;

import androidx.core.app.NotificationCompat;

import com.vcore.BlackBoxCore;
import com.vcore.utils.compat.BuildCompat;

public class DaemonService extends Service {
    public static final String TAG = "DaemonService";
    private static final int NOTIFY_ID = BlackBoxCore.getHostPkg().hashCode();

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Intent innerIntent = new Intent(this, DaemonInnerService.class);
        startService(innerIntent);
        if (BuildCompat.isOreo()) {
            showNotification();
        }
        return START_STICKY;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy");
    }

    private void showNotification() {
        NotificationCompat.Builder builder = new NotificationCompat.Builder(getApplicationContext(), getPackageName() + ".blackbox_core")
                .setPriority(NotificationCompat.PRIORITY_MAX);
        startForeground(NOTIFY_ID, builder.build());
    }

    public static class DaemonInnerService extends Service {
        @Override
        public void onCreate() {
            Log.i(TAG, "DaemonInnerService -> onCreate");
            super.onCreate();
        }

        @Override
        public int onStartCommand(Intent intent, int flags, int startId) {
            Log.i(TAG, "DaemonInnerService -> onStartCommand");
            NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            nm.cancel(NOTIFY_ID);
            stopSelf();
            return super.onStartCommand(intent, flags, startId);
        }

        @Override
        public IBinder onBind(Intent intent) {
            return null;
        }

        @Override
        public void onDestroy() {
            Log.i(TAG, "DaemonInnerService -> onDestroy");
            super.onDestroy();
        }
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/ISystemService.java`:

```java
package com.vcore.core.system;

public interface ISystemService {
    void systemReady();
}

```

`Bcore/src/main/java/com/vcore/core/system/ProcessRecord.java`:

```java
package com.vcore.core.system;

import android.content.pm.ApplicationInfo;
import android.os.Binder;
import android.os.ConditionVariable;
import android.os.IInterface;

import java.util.Arrays;

import com.vcore.core.IBActivityThread;
import com.vcore.entity.AppConfig;
import com.vcore.proxy.ProxyManifest;

public class ProcessRecord extends Binder {
    public final ApplicationInfo info;
    final public String processName;
    public IBActivityThread bActivityThread;
    public IInterface appThread;
    public int uid;
    public int pid;
    public int bUID;
    public int bPID;
    public int callingBUid;
    public int userId;

    public final ConditionVariable initLock = new ConditionVariable();

    public ProcessRecord(ApplicationInfo info, String processName) {
        this.info = info;
        this.processName = processName;
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(new Object[]{processName, pid, bUID, bPID, uid, pid, userId});
    }

    public String getProviderAuthority() {
        return ProxyManifest.getProxyAuthorities(bPID);
    }

    public AppConfig getClientConfig() {
        AppConfig config = new AppConfig();
        config.packageName = info.packageName;
        config.processName = processName;
        config.bPID = bPID;
        config.bUID = bUID;
        config.uid = uid;
        config.callingBUid = callingBUid;
        config.userId = userId;
        config.token = this;
        return config;
    }

    public String getPackageName() {
        return info.packageName;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/ServiceManager.java`:

```java
package com.vcore.core.system;

import android.os.IBinder;

import java.util.HashMap;
import java.util.Map;

import com.vcore.BlackBoxCore;
import com.vcore.core.system.accounts.BAccountManagerService;
import com.vcore.core.system.am.BActivityManagerService;
import com.vcore.core.system.am.BJobManagerService;
import com.vcore.core.system.location.BLocationManagerService;
import com.vcore.core.system.notification.BNotificationManagerService;
import com.vcore.core.system.os.BStorageManagerService;
import com.vcore.core.system.pm.BPackageManagerService;
import com.vcore.core.system.pm.BXposedManagerService;
import com.vcore.core.system.user.BUserManagerService;

public class ServiceManager {
    public static final String ACTIVITY_MANAGER = "activity_manager";
    public static final String JOB_MANAGER = "job_manager";
    public static final String PACKAGE_MANAGER = "package_manager";
    public static final String STORAGE_MANAGER = "storage_manager";
    public static final String USER_MANAGER = "user_manager";
    public static final String XPOSED_MANAGER = "xposed_manager";
    public static final String ACCOUNT_MANAGER = "account_manager";
    public static final String LOCATION_MANAGER = "location_manager";
    public static final String NOTIFICATION_MANAGER = "notification_manager";

    private final Map<String, IBinder> mCaches = new HashMap<>();

    private static final class SServiceManagerHolder {
        static final ServiceManager sServiceManager = new ServiceManager();
    }

    public static ServiceManager get() {
        return SServiceManagerHolder.sServiceManager;
    }

    public static IBinder getService(String name) {
        return get().getServiceInternal(name);
    }

    private ServiceManager() {
        mCaches.put(ACTIVITY_MANAGER, BActivityManagerService.get());
        mCaches.put(JOB_MANAGER, BJobManagerService.get());
        mCaches.put(PACKAGE_MANAGER, BPackageManagerService.get());
        mCaches.put(STORAGE_MANAGER, BStorageManagerService.get());
        mCaches.put(USER_MANAGER, BUserManagerService.get());
        mCaches.put(XPOSED_MANAGER, BXposedManagerService.get());
        mCaches.put(ACCOUNT_MANAGER, BAccountManagerService.get());
        mCaches.put(LOCATION_MANAGER, BLocationManagerService.get());
        mCaches.put(NOTIFICATION_MANAGER, BNotificationManagerService.get());
    }

    public IBinder getServiceInternal(String name) {
        return mCaches.get(name);
    }

    public static void initBlackManager() {
        BlackBoxCore.get().getService(ACTIVITY_MANAGER);
        BlackBoxCore.get().getService(JOB_MANAGER);
        BlackBoxCore.get().getService(PACKAGE_MANAGER);
        BlackBoxCore.get().getService(STORAGE_MANAGER);
        BlackBoxCore.get().getService(USER_MANAGER);
        BlackBoxCore.get().getService(XPOSED_MANAGER);
        BlackBoxCore.get().getService(ACCOUNT_MANAGER);
        BlackBoxCore.get().getService(LOCATION_MANAGER);
        BlackBoxCore.get().getService(NOTIFICATION_MANAGER);
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/SystemCallProvider.java`:

```java
package com.vcore.core.system;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.vcore.utils.Slog;
import com.vcore.utils.compat.BundleCompat;

public class SystemCallProvider extends ContentProvider {
    public static final String TAG = "SystemCallProvider";

    @Override
    public boolean onCreate() {
        return initSystem();
    }

    private boolean initSystem() {
        BlackBoxSystem.getSystem().startup();
        return true;
    }

    @Nullable
    @Override
    public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) {
        Slog.d(TAG, "call: " + method + ", " + extras);
        if ("VM".equals(method)) {
            Bundle bundle = new Bundle();
            if (extras != null) {
                String name = extras.getString("_B_|_server_name_");
                BundleCompat.putBinder(bundle, "_B_|_server_", ServiceManager.getService(name));
            }
            return bundle;
        }
        return super.call(method, arg, extras);
    }

    @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {
        return null;
    }

    @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        return null;
    }

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
        return null;
    }

    @Override
    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {
        return 0;
    }

    @Override
    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {
        return 0;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/accounts/BAccount.java`:

```java
package com.vcore.core.system.accounts;

import android.accounts.Account;
import android.os.Parcel;
import android.os.Parcelable;

import java.util.HashMap;
import java.util.LinkedHashMap;

public class BAccount implements Parcelable {
    public Account account;
    public String password;
    public HashMap<String, String> accountUserData = new LinkedHashMap<>();
    public HashMap<String, Integer> visibility = new LinkedHashMap<>();
    public HashMap<String, String> authTokens = new LinkedHashMap<>();
    public long updateLastAuthenticatedTime;

    public boolean isMatch(Account account) {
        if (account == null) {
            return false;
        }
        return account.equals(this.account);
    }

    public void insertExtra(String key, String value) {
        this.accountUserData.put(key, value);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeParcelable(this.account, flags);
        dest.writeString(this.password);
        dest.writeSerializable(this.accountUserData);
        dest.writeSerializable(this.visibility);
        dest.writeSerializable(this.authTokens);
        dest.writeLong(this.updateLastAuthenticatedTime);
    }

    public BAccount() { }

    protected BAccount(Parcel in) {
        this.account = in.readParcelable(Account.class.getClassLoader());
        this.password = in.readString();
        this.accountUserData = (HashMap<String, String>) in.readSerializable();
        this.visibility = (HashMap<String, Integer>) in.readSerializable();
        this.authTokens = (HashMap<String, String>) in.readSerializable();
        this.updateLastAuthenticatedTime = in.readLong();
    }

    public static final Creator<BAccount> CREATOR = new Creator<BAccount>() {
        @Override
        public BAccount createFromParcel(Parcel source) {
            return new BAccount(source);
        }

        @Override
        public BAccount[] newArray(int size) {
            return new BAccount[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/core/system/accounts/BAccountManagerService.java`:

```java
package com.vcore.core.system.accounts;

import android.accounts.AbstractAccountAuthenticator;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.accounts.AuthenticatorDescription;
import android.accounts.IAccountAuthenticator;
import android.accounts.IAccountAuthenticatorResponse;
import android.accounts.IAccountManagerResponse;
import android.annotation.SuppressLint;
import android.content.ClipData;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.pm.ServiceInfo;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.content.res.XmlResourceParser;
import android.os.Binder;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.Parcel;
import android.os.Parcelable;
import android.os.RemoteException;
import android.os.SystemClock;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.util.Log;
import android.util.Xml;

import androidx.annotation.NonNull;
import androidx.core.util.AtomicFile;
import androidx.core.util.Preconditions;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import com.vcore.BlackBoxCore;
import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.BProcessManagerService;
import com.vcore.core.system.ISystemService;
import com.vcore.core.system.ProcessRecord;
import com.vcore.core.system.pm.BPackageManagerService;
import com.vcore.core.system.pm.PackageMonitor;
import com.vcore.core.system.user.BUserHandle;
import com.vcore.utils.ArrayUtils;
import com.vcore.utils.CloseUtils;
import com.vcore.utils.FileUtils;
import com.vcore.utils.Slog;
import com.vcore.utils.compat.AccountManagerCompat;


@SuppressLint("InlinedApi")
public class BAccountManagerService extends IBAccountManagerService.Stub implements ISystemService, PackageMonitor {
    private static final String TAG = "AccountManagerService";
    private static final BAccountManagerService sService = new BAccountManagerService();
    private static final Account[] EMPTY_ACCOUNT_ARRAY = new Account[]{};

    // Messages that can be sent on mHandler
    private static final int MESSAGE_TIMED_OUT = 3;

    private final BPackageManagerService mPms;
    private final Map<Integer, BUserAccounts> mUserAccountsMap = new HashMap<>();
    private final AuthenticatorCache mAuthenticatorCache = new AuthenticatorCache();

    private final LinkedList<TokenCache> mTokenCaches = new LinkedList<>();
    private final LinkedHashMap<String, Session> mSessions = new LinkedHashMap<>();
    private final Handler mHandler = new Handler(Looper.getMainLooper());

    private final Context mContext;

    public static BAccountManagerService get() {
        return sService;
    }

    public BAccountManagerService() {
        this.mContext = BlackBoxCore.getContext();
        this.mPms = BPackageManagerService.get();
    }

    @Override
    public void systemReady() {
        loadAccounts();
        loadAuthenticatorCache(null);
        mPms.addPackageMonitor(this);
    }

    @Override
    public void onPackageUninstalled(String packageName, boolean isRemove, int userId) {
        loadAuthenticatorCache(null);
    }

    @Override
    public void onPackageInstalled(String packageName, int userId) {
        loadAuthenticatorCache(packageName);
    }

    private void loadAccounts() {
        Parcel parcel = Parcel.obtain();
        InputStream is = null;
        try {
            File userInfoConf = BEnvironment.getAccountsConf();
            if (!userInfoConf.exists()) {
                return;
            }

            is = new FileInputStream(BEnvironment.getAccountsConf());
            byte[] bytes = FileUtils.toByteArray(is);
            parcel.unmarshall(bytes, 0, bytes.length);
            parcel.setDataPosition(0);

            HashMap<Integer, BUserAccounts> accountsMap = parcel.readHashMap(BUserAccounts.class.getClassLoader());
            if (accountsMap == null) {
                return;
            }

            synchronized (mUserAccountsMap) {
                mUserAccountsMap.clear();
                for (Integer key : accountsMap.keySet()) {
                    mUserAccountsMap.put(key, accountsMap.get(key));
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            parcel.recycle();
            CloseUtils.close(is);
        }
    }

    private void saveAllAccounts() {
        synchronized (mUserAccountsMap) {
            Parcel parcel = Parcel.obtain();
            AtomicFile atomicFile = new AtomicFile(BEnvironment.getAccountsConf());
            FileOutputStream fileOutputStream = null;

            try {
                parcel.writeMap(mUserAccountsMap);
                try {
                    fileOutputStream = atomicFile.startWrite();
                    FileUtils.writeParcelToOutput(parcel, fileOutputStream);
                    atomicFile.finishWrite(fileOutputStream);
                } catch (IOException e) {
                    e.printStackTrace();
                    atomicFile.failWrite(fileOutputStream);
                } finally {
                    CloseUtils.close(fileOutputStream);
                }
            } finally {
                parcel.recycle();
            }
        }
    }

    @Override
    public String getPassword(Account account, int userId) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, "getPassword: " + account + ", caller's uid " + Binder.getCallingUid() + ", pid " + Binder.getCallingPid());
        }

        if (account == null) {
            throw new IllegalArgumentException("account is null");
        }
        BUserAccounts accounts = getUserAccounts(userId);
        return readPasswordInternal(accounts, account);
    }

    @Override
    public String getUserData(Account account, String key, int userId) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            String msg = String.format("getUserData( account: %s, key: %s, callerUid: %s, pid: %s", account, key, Binder.getCallingUid(),
                    Binder.getCallingPid());
            Log.v(TAG, msg);
        }

        Objects.requireNonNull(account, "account cannot be null");
        Objects.requireNonNull(key, "key cannot be null");
        BUserAccounts accounts = getUserAccounts(userId);
        return readUserDataInternal(accounts, account, key);
    }

    @Override
    public AuthenticatorDescription[] getAuthenticatorTypes(int userId) {
        // Only allow the system process to read accounts of other users
        BUserAccounts userAccounts = getUserAccounts(userId);
        List<AuthenticatorDescription> authenticatorDescriptions = new ArrayList<>();
        synchronized (userAccounts.lock) {
            for (BAccount account : userAccounts.accounts) {
                AuthenticatorInfo authenticatorInfo = mAuthenticatorCache.authenticators.get(account.account.type);
                if (authenticatorInfo != null) {
                    authenticatorDescriptions.add(authenticatorInfo.desc);
                }
            }
        }
        return authenticatorDescriptions.toArray(new AuthenticatorDescription[]{});
    }

    @Override
    public Account[] getAccountsForPackage(String packageName, int uid, int userId) {
        // Only allow the system process to read accounts of other users
        BUserAccounts userAccounts = getUserAccounts(userId);
        List<Account> accounts = new ArrayList<>();
        synchronized (userAccounts.lock) {
            for (BAccount account : userAccounts.accounts) {
                Integer visibility = account.visibility.get(packageName);
                if (visibility != null && visibility == AccountManager.VISIBILITY_VISIBLE) {
                    accounts.add(account.account);
                }
            }
        }
        return accounts.toArray(new Account[]{});
    }

    @Override
    public Account[] getAccountsByTypeForPackage(String type, String packageName, int userId) {
        // Only allow the system process to read accounts of other users
        BUserAccounts userAccounts = getUserAccounts(userId);
        List<Account> accounts = new ArrayList<>();
        synchronized (userAccounts.lock) {
            for (BAccount account : userAccounts.accounts) {
                if (account.account.type.equals(type)) {
                    Integer visibility = account.visibility.get(packageName);
                    if (visibility != null && visibility == AccountManager.VISIBILITY_VISIBLE) {
                        accounts.add(account.account);
                    }
                }
            }
        }
        return accounts.toArray(new Account[]{});
    }

    @Override
    public Account[] getAccountsAsUser(String accountType, int userId) {
        BUserAccounts userAccounts = getUserAccounts(userId);
        List<Account> accounts = new ArrayList<>();
        synchronized (userAccounts.lock) {
            for (BAccount account : userAccounts.accounts) {
                if (account.account.type.equals(accountType)) {
                    accounts.add(account.account);
                }
            }
        }
        return accounts.toArray(new Account[]{});
    }

    @Override
    public void getAccountByTypeAndFeatures(IAccountManagerResponse response, String accountType, String[] features, int userId) {
        if (response == null) {
            throw new IllegalArgumentException("response is null");
        }

        if (accountType == null) {
            throw new IllegalArgumentException("accountType is null");
        }

        String opPackageName = getCallingPackageName();
        BUserAccounts userAccounts = getUserAccounts(userId);

        if (ArrayUtils.isEmpty(features)) {
            Account[] accountsWithManagedNotVisible = getAccountsFromCache(userAccounts, accountType, opPackageName,
                    true /* include managed not visible */);
            handleGetAccountsResult(response, accountsWithManagedNotVisible, opPackageName, userId);
            return;
        }

        IAccountManagerResponse retrieveAccountsResponse =
                new IAccountManagerResponse.Stub() {
                    @Override
                    public void onResult(Bundle value) {
                        Parcelable[] parcelables = value.getParcelableArray(AccountManager.KEY_ACCOUNTS);

                        Account[] accounts = new Account[parcelables.length];
                        for (int i = 0; i < parcelables.length; i++) {
                            accounts[i] = (Account) parcelables[i];
                        }
                        handleGetAccountsResult(response, accounts, opPackageName, userId);
                    }

                    @Override
                    public void onError(int errorCode, String errorMessage) {
                        // Will not be called in this case.
                    }
                };
        new GetAccountsByTypeAndFeatureSession(userAccounts, retrieveAccountsResponse, accountType, features, userId, opPackageName,
                true /* include managed not visible */)
                .bind();
    }

    @Override
    public void getAccountsByFeatures(IAccountManagerResponse response, String type, String[] features, int userId) {
        if (response == null) {
            throw new IllegalArgumentException("response is null");
        }

        if (type == null) {
            throw new IllegalArgumentException("accountType is null");
        }

        String opPackageName = getCallingPackageName();
        // Check visibleAccountTypes
        BUserAccounts userAccounts = getUserAccounts(userId);
        if (features == null || features.length == 0) {
            Account[] accounts = getAccountsFromCache(userAccounts, type, opPackageName, false);

            Bundle result = new Bundle();
            result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);

            onResult(response, result);
            return;
        }
        new GetAccountsByTypeAndFeatureSession(userAccounts, response, type, features, userId, opPackageName,
                false /* include managed not visible */)
                .bind();
    }

    @Override
    public boolean addAccountExplicitly(Account account, String password, Bundle extras, int userId) {
        return addAccountExplicitlyWithVisibility(account, password, extras, null, userId);
    }

    @Override
    public void removeAccountAsUser(IAccountManagerResponse response, Account account, boolean expectActivityLaunch, int userId) {
        Preconditions.checkArgument(account != null, "Account cannot be null");
        Preconditions.checkArgument(response != null, "Response cannot be null");
        // Only allow the system process to modify accounts of other users
        /*
         * Only the system, authenticator or profile owner should be allowed to remove accounts for
         * that authenticator.  This will let users remove accounts (via Settings in the system) but
         * not arbitrary applications (like competing authenticators).
         */
        BUserAccounts accounts = getUserAccounts(userId);
        new RemoveAccountSession(accounts, response, account, expectActivityLaunch)
                .bind();
    }

    @Override
    public boolean removeAccountExplicitly(Account account, int userId) {
        final int callingUid = Binder.getCallingUid();
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, "removeAccountExplicitly: " + account + ", caller's uid " + callingUid + ", pid " + Binder.getCallingPid());
        }

        if (account == null) {
            /*
             * Null accounts should result in returning false, as per
             * AccountManage.addAccountExplicitly(...) java doc.
             */
            Log.e(TAG, "account is null");
            return false;
        }
        BUserAccounts accounts = getUserAccounts(userId);
        return removeAccountInternal(accounts, account);
    }

    @Override
    public void copyAccountToUser(IAccountManagerResponse response, Account account, int userFrom, int userTo) {
        final BUserAccounts fromAccounts = getUserAccounts(userFrom);
        final BUserAccounts toAccounts = getUserAccounts(userTo);
        if (fromAccounts == null || toAccounts == null) {
            if (response != null) {
                Bundle result = new Bundle();
                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);
                try {
                    response.onResult(result);
                } catch (RemoteException e) {
                    Slog.w(TAG, "Failed to report error back to the client." + e);
                }
            }
            return;
        }

        Slog.d(TAG, "Copying account " + account.toString() + " from user " + userFrom + " to user " + userTo);
        new Session(fromAccounts, response, account.type, false, false /* stripAuthTokenFromResult */, account.name,
                false /* authDetailsRequired */) {
            @Override
            protected String toDebugString(long now) {
                return super.toDebugString(now) + ", getAccountCredentialsForClone" + ", " + account.type;
            }

            @Override
            public void run() throws RemoteException {
                mAuthenticator.getAccountCredentialsForCloning(this, account);
            }

            @Override
            public void onResult(Bundle result) {
                if (result != null && result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {
                    // Create a Session for the target user and pass in the bundle
                    completeCloningAccount(response, result, account, toAccounts, userFrom);
                }
                super.onResult(result);
            }
        }
        .bind();
    }

    @Override
    public void invalidateAuthToken(String accountType, String authToken, int userId) {
        BUserAccounts accounts = getUserAccounts(userId);
        synchronized (accounts.lock) {
            boolean changed = false;
            for (BAccount account : accounts.accounts) {
                if (account.account.type.equals(accountType)) {
                    account.accountUserData.values().remove(authToken);
                    changed = true;
                }
            }

            if (changed) {
                saveAllAccounts();
            }
        }

        synchronized (mTokenCaches) {
            Iterator<TokenCache> iterator = mTokenCaches.iterator();
            while (iterator.hasNext()) {
                TokenCache next = iterator.next();
                if (next.account.type.equals(accountType) && next.userId == userId && next.authToken.equals(authToken)) {
                    iterator.remove();
                }
            }
        }
    }

    @Override
    public String peekAuthToken(Account account, String authTokenType, int userId) {
        Objects.requireNonNull(account, "Account cannot be null");
        Objects.requireNonNull(authTokenType, "AuthTokenType cannot be null");

        BUserAccounts accounts = getUserAccounts(userId);
        if (accounts == null) {
            return null;
        }

        synchronized (accounts.lock) {
            return accounts.getAuthToken(account).get(authTokenType);
        }
    }

    @Override
    public void setAuthToken(Account account, String authTokenType, String authToken, int userId) {
        Objects.requireNonNull(account, "Account cannot be null");
        Objects.requireNonNull(authTokenType, "AuthTokenType cannot be null");

        BUserAccounts accounts = getUserAccounts(userId);
        if (accounts == null) {
            return;
        }

        synchronized (accounts.lock) {
            accounts.getAuthToken(account).put(authTokenType, authToken);
            saveAllAccounts();
        }
    }

    @Override
    public void setPassword(Account account, String password, int userId) {
        Objects.requireNonNull(account, "Account cannot be null");
        BUserAccounts accounts = getUserAccounts(userId);
        if (accounts == null) {
            return;
        }

        synchronized (accounts.lock) {
            BAccount bAccount = accounts.getAccount(account);
            bAccount.password = password;
            bAccount.authTokens.clear();
            saveAllAccounts();
        }

        synchronized (mTokenCaches) {
            Iterator<TokenCache> iterator = mTokenCaches.iterator();
            while (iterator.hasNext()) {
                TokenCache next = iterator.next();
                if (next.account.equals(account) && next.userId == userId) {
                    iterator.remove();
                }
            }
        }
    }

    @Override
    public void clearPassword(Account account, int userId) {
        setPassword(account, null, userId);
    }

    @Override
    public void setUserData(Account account, String key, String value, int userId) {
        if (key == null) {
            throw new IllegalArgumentException("key is null");
        }

        if (account == null) {
            throw new IllegalArgumentException("account is null");
        }

        BUserAccounts accounts = getUserAccounts(userId);
        if (accounts == null) {
            return;
        }

        synchronized (accounts.lock) {
            accounts.getAccountUserData(account).put(key, value);
            saveAllAccounts();
        }
    }

    @Override
    public void updateAppPermission(Account account, String authTokenType, int uid, boolean value) {
        // System
    }

    @Override
    public void getAuthToken(IAccountManagerResponse response, Account account, String authTokenType, boolean notifyOnAuthFailure, boolean expectActivityLaunch, Bundle loginOptions, int userId) {
        Preconditions.checkArgument(response != null, "response cannot be null");
        try {
            if (account == null) {
                Slog.w(TAG, "getAuthToken called with null account");
                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, "account is null");
                return;
            }

            if (authTokenType == null) {
                Slog.w(TAG, "getAuthToken called with null authTokenType");
                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, "authTokenType is null");
                return;
            }
        } catch (RemoteException e) {
            Slog.w(TAG, "Failed to report error back to the client." + e);
            return;
        }

        final BUserAccounts accounts = getUserAccounts(userId);
        AuthenticatorInfo authenticatorInfo = mAuthenticatorCache.authenticators.get(account.type);

        final boolean customTokens = authenticatorInfo != null && authenticatorInfo.desc.customTokens;

        // Get the calling package. We will use it for the purpose of caching.
        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);

        // Let authenticator know the identity of the caller
        loginOptions.putInt(AccountManager.KEY_CALLER_UID, Binder.getCallingUid());
        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());

        if (notifyOnAuthFailure) {
            loginOptions.putBoolean(AccountManagerCompat.KEY_NOTIFY_ON_FAILURE, true);
        }

        // if the caller has permission, do the peek. otherwise go the more expensive
        // route of starting a Session
        if (!customTokens) {
            String authToken = readAuthTokenInternal(accounts, account, authTokenType);
            if (authToken != null) {
                Bundle result = new Bundle();
                result.putString(AccountManager.KEY_AUTHTOKEN, authToken);
                result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);
                result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);

                onResult(response, result);
                return;
            }
        }

        if (customTokens) {
            /*
             * Look up tokens in the new cache only if the loginOptions don't have parameters
             * outside of those expected to be injected by the AccountManager, e.g.
             * ANDROID_PACKAGE_NAME.
             */
            String token = readCachedTokenInternal(accounts, account, authTokenType, callerPkg);
            if (token != null) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, "getAuthToken: cache hit ofr custom token authenticator.");
                }

                Bundle result = new Bundle();
                result.putString(AccountManager.KEY_AUTHTOKEN, token);
                result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);
                result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);

                onResult(response, result);
                return;
            }
        }
        new Session(accounts, response, account.type, expectActivityLaunch, false /* stripAuthTokenFromResult */,
                account.name, false /* authDetailsRequired */) {
            @Override
            protected String toDebugString(long now) {
                loginOptions.keySet();
                return super.toDebugString(now) + ", getAuthToken" + ", " + account + ", authTokenType " + authTokenType + ", loginOptions " + loginOptions
                        + ", notifyOnAuthFailure " + notifyOnAuthFailure;
            }

            @Override
            public void run() throws RemoteException {
                // If the caller doesn't have permission then create and return the
                // "grant permission" intent instead of the "getAuthToken" intent.
                mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);
            }

            @Override
            public void onResult(Bundle result) {
                if (result != null) {
                    String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);
                    if (authToken != null) {
                        String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);
                        String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);
                        if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {
                            onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "the type and name should not be empty");
                            return;
                        }

                        Account resultAccount = new Account(name, type);
                        if (!customTokens) {
                            saveAuthTokenToDatabase(mAccounts, resultAccount, authTokenType, authToken);
                        }

                        long expiryMillis = result.getLong(AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);
                        if (customTokens && expiryMillis > System.currentTimeMillis()) {
                            saveCachedToken(mAccounts, account, callerPkg, authTokenType, authToken, expiryMillis);
                        }
                    }
                }
                super.onResult(result);
            }
        }
        .bind();
    }

    @Override
    public void addAccount(IAccountManagerResponse response, String accountType, String authTokenType, String[] requiredFeatures, boolean expectActivityLaunch, Bundle optionsIn, int userId) {
        if (response == null) {
            throw new IllegalArgumentException("response is null");
        }

        if (accountType == null) {
            throw new IllegalArgumentException("accountType is null");
        }

        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;
        BUserAccounts accounts = getUserAccounts(userId);

        new Session(accounts, response, accountType, expectActivityLaunch,
                true /* stripAuthTokenFromResult */, null /* accountName */,
                false /* authDetailsRequired */, true /* updateLastAuthenticationTime */) {
            @Override
            public void run() throws RemoteException {
                mAuthenticator.addAccount(this, mAccountType, authTokenType, requiredFeatures, options);
            }

            @Override
            protected String toDebugString(long now) {
                return super.toDebugString(now) + ", addAccount" + ", accountType " + accountType + ", requiredFeatures "
                        + Arrays.toString(requiredFeatures);
            }
        }
        .bind();
    }

    @Override
    public void addAccountAsUser(IAccountManagerResponse response, String accountType, String authTokenType, String[] requiredFeatures, boolean expectActivityLaunch, Bundle options, int userId) {
        // Ignore
    }

    @Override
    public void updateCredentials(IAccountManagerResponse response, Account account, String authTokenType, boolean expectActivityLaunch, Bundle loginOptions, int userId) {
        if (response == null) {
            throw new IllegalArgumentException("response is null");
        }

        if (account == null) {
            throw new IllegalArgumentException("account is null");
        }

        BUserAccounts accounts = getUserAccounts(userId);
        new Session(accounts, response, account.type, expectActivityLaunch,
                true /* stripAuthTokenFromResult */, account.name,
                false /* authDetailsRequired */, true /* updateLastCredentialTime */) {
            @Override
            public void run() throws RemoteException {
                mAuthenticator.updateCredentials(this, account, authTokenType, loginOptions);
            }
            @Override
            protected String toDebugString(long now) {
                if (loginOptions != null) {
                    loginOptions.keySet();
                }
                return super.toDebugString(now) + ", updateCredentials" + ", " + account + ", authTokenType " + authTokenType
                        + ", loginOptions " + loginOptions;
            }
        }
        .bind();
    }

    @Override
    public void editProperties(IAccountManagerResponse response, String accountType, boolean expectActivityLaunch, int userId) {
        if (response == null) {
            throw new IllegalArgumentException("response is null");
        }

        if (accountType == null) {
            throw new IllegalArgumentException("accountType is null");
        }

        BUserAccounts accounts = getUserAccounts(userId);
        new Session(accounts, response, accountType, expectActivityLaunch,
                true /* stripAuthTokenFromResult */, null /* accountName */,
                false /* authDetailsRequired */) {
            @Override
            public void run() throws RemoteException {
                mAuthenticator.editProperties(this, mAccountType);
            }
            @Override
            protected String toDebugString(long now) {
                return super.toDebugString(now) + ", editProperties" + ", accountType " + accountType;
            }
        }
        .bind();
    }

    @Override
    public void confirmCredentialsAsUser(IAccountManagerResponse response, Account account, Bundle options, boolean expectActivityLaunch, int userId) {
        // Ignore
    }

    @Override
    public boolean accountAuthenticated(Account account, int userId) {
        Objects.requireNonNull(account, "account cannot be null");
        BUserAccounts userAccounts = getUserAccounts(userId);

        if (userAccounts == null) {
            return false;
        }
        return updateLastAuthenticatedTime(userAccounts, account);
    }

    @Override
    public void getAuthTokenLabel(IAccountManagerResponse response, String accountType, String authTokenType, int userId) {
        Preconditions.checkArgument(accountType != null, "accountType cannot be null");
        Preconditions.checkArgument(authTokenType != null, "authTokenType cannot be null");

        BUserAccounts accounts = getUserAccounts(userId);
        new Session(accounts, response, accountType, false /* expectActivityLaunch */,
                false /* stripAuthTokenFromResult */,  null /* accountName */,
                false /* authDetailsRequired */) {
            @Override
            protected String toDebugString(long now) {
                return super.toDebugString(now) + ", getAuthTokenLabel" + ", " + accountType + ", authTokenType " + authTokenType;
            }

            @Override
            public void run() throws RemoteException {
                mAuthenticator.getAuthTokenLabel(this, authTokenType);
            }

            @Override
            public void onResult(Bundle result) {
                if (result != null) {
                    String label = result.getString(AccountManager.KEY_AUTH_TOKEN_LABEL);

                    Bundle bundle = new Bundle();
                    bundle.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, label);
                    super.onResult(bundle);
                }
                super.onResult(null);
            }
        }
        .bind();
    }

    @Override
    public HashMap<?, ?> getPackagesAndVisibilityForAccount(Account account, int userId) {
        return new HashMap<>();
    }

    protected void saveCachedToken(BUserAccounts accounts, Account account, String callerPkg, String tokenType, String token, long expiryMillis) {
        if (account == null || tokenType == null || callerPkg == null) {
            return;
        }

        TokenCache cache = new TokenCache(accounts.userId, account, callerPkg, tokenType, token, expiryMillis);
        synchronized (mTokenCaches) {
            mTokenCaches.add(cache);
        }
    }

    protected void saveAuthTokenToDatabase(BUserAccounts accounts, Account account, String authTokenType, String authToken) {
        if (accounts == null) {
            return;
        }

        synchronized (accounts.lock) {
            accounts.getAuthToken(account).put(authTokenType, authToken);
            saveAllAccounts();
        }
    }

    protected String readCachedTokenInternal(BUserAccounts accounts, Account account, String tokenType, String callingPackage) {
        long nowTime = System.currentTimeMillis();
        synchronized (mTokenCaches) {
            Iterator<TokenCache> iterator = mTokenCaches.iterator();
            while (iterator.hasNext()) {
                TokenCache next = iterator.next();

                if (next.userId == accounts.userId && next.account.equals(account) && next.authTokenType.equals(tokenType) && next.packageName.equals(callingPackage)) {
                    if (next.expiryEpochMillis > nowTime) {
                        return next.authToken;
                    }
                    iterator.remove();
                }
            }
            return null;
        }
    }

    protected String readAuthTokenInternal(BUserAccounts accounts, Account account, String authTokenType) {
        if (accounts == null) {
            return null;
        }
        // If not cached yet - do slow path and sync with db if necessary
        synchronized (accounts.lock) {
            Map<String, String> authToken = accounts.getAuthToken(account);
            return authToken.get(authTokenType);
        }
    }

    private void completeCloningAccount(IAccountManagerResponse response, final Bundle accountCredentials, final Account account,
                                        final BUserAccounts targetUser, final int parentUserId) {
        new Session(targetUser, response, account.type, false,
                false /* stripAuthTokenFromResult */, account.name,
                false /* authDetailsRequired */) {
            @Override
            protected String toDebugString(long now) {
                return super.toDebugString(now) + ", getAccountCredentialsForClone" + ", " + account.type;
            }

            @Override
            public void run() throws RemoteException {
                // Confirm that the owner's account still exists before this step.
                for (Account acc : getAccounts(parentUserId, mContext.getPackageName())) {
                    if (acc.equals(account)) {
                        mAuthenticator.addAccountFromCredentials(this, account, accountCredentials);
                        break;
                    }
                }
            }

            @Override
            public void onResult(Bundle result) {
                // TODO: Anything to do if if succeded?
                // TODO: If it failed: Show error notification? Should we remove the shadow account to avoid retries?
                // TODO: What we do with the visibility?
                super.onResult(result);
            }

            @Override
            public void onError(int errorCode, String errorMessage) {
                super.onError(errorCode,  errorMessage);
                // TODO: Show error notification to user
                // TODO: Should we remove the shadow account so that it doesn't keep trying?
            }
        }
        .bind();
    }

    public Account[] getAccounts(int userId, String opPackageName) {
        BUserAccounts userAccounts = getUserAccounts(userId);
        return userAccounts.accounts.toArray(new Account[]{});
    }

    @Override
    public boolean addAccountExplicitlyWithVisibility(Account account, String password, Bundle extras, Map packageToVisibility, int userId) {
        /*
         * Child users are not allowed to add accounts. Only the accounts that are shared by the
         * parent profile can be added to child profile.
         *
         * TODO: Only allow accounts that were shared to be added by a limited user.
         */
        // Fails if the account already exists.
        BUserAccounts accounts = getUserAccounts(userId);
        return addAccountInternal(accounts, account, password, extras, (Map<String, Integer>) packageToVisibility);
    }

    @Override
    public boolean setAccountVisibility(Account account, String packageName, int newVisibility, int userId) {
        Objects.requireNonNull(account, "account cannot be null");
        Objects.requireNonNull(packageName, "packageName cannot be null");

        BUserAccounts userAccounts = getUserAccounts(userId);
        if (userAccounts == null) {
            return false;
        }
        return setAccountVisibility(account, packageName, newVisibility, userAccounts);
    }

    @Override
    public int getAccountVisibility(Account account, String packageName, int userId) {
        Objects.requireNonNull(account, "account cannot be null");
        Objects.requireNonNull(packageName, "packageName cannot be null");

        BUserAccounts accounts = getUserAccounts(userId);
        if (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)) {
            int visibility = getAccountVisibilityFromCache(account, packageName, accounts);

            if (AccountManager.VISIBILITY_UNDEFINED != visibility) {
                return visibility;
            } else {
                return AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;
            }
        }

        if (AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName)) {
            int visibility = getAccountVisibilityFromCache(account, packageName, accounts);
            if (AccountManager.VISIBILITY_UNDEFINED != visibility) {
                return visibility;
            } else {
                return AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;
            }
        }
        return resolveAccountVisibility(account, packageName, accounts);
    }

    @Override
    public Map getAccountsAndVisibilityForPackage(String packageName, String accountType, int userId) {
        Map<Account, Integer> hashMap = new HashMap<>();
        BUserAccounts userAccounts = getUserAccounts(userId);

        synchronized (userAccounts.lock) {
            for (BAccount account : userAccounts.accounts) {
                if (account.account.type.equals(accountType)) {
                    Integer integer = userAccounts.getVisibility(account.account).get(packageName);
                    if (integer != null) {
                        hashMap.put(account.account, integer);
                    }
                }
            }
        }
        return hashMap;
    }

    @Override
    public void registerAccountListener(String[] accountTypes, String opPackageName, int userId) throws RemoteException { }

    @Override
    public void unregisterAccountListener(String[] accountTypes, String opPackageName, int userId) { }

    private boolean addAccountInternal(BUserAccounts accounts, Account account, String password, Bundle extras, Map<String, Integer> packageToVisibility) {
        if (accounts == null) {
            accounts = new BUserAccounts();
        }

        synchronized (accounts.lock) {
            BAccount bAccount = accounts.getAccount(account);
            if (bAccount != null) {
                Slog.d(TAG, "skipping since insertExtra failed for key " + account);
                return false;
            }

            bAccount = accounts.addAccount(account);
            bAccount.password = password;
            if (extras != null) {
                for (String key : extras.keySet()) {
                    final String value = extras.getString(key);
                    bAccount.insertExtra(key, value);
                }
            }

            if (packageToVisibility != null) {
                for (Map.Entry<String, Integer> entry : packageToVisibility.entrySet()) {
                    setAccountVisibility(account, entry.getKey() /* package */, entry.getValue() /* visibility */, accounts);
                }
            }
        }

        saveAllAccounts();
        return true;
    }

    private boolean setAccountVisibility(Account account, String packageName, int newVisibility, BUserAccounts accounts) {
        synchronized (accounts.lock) {
            BAccount bAccount = accounts.getAccount(account);
            if (bAccount == null) {
                return false;
            }

            bAccount.visibility.put(packageName, newVisibility);
            return true;
        }
    }

    protected Account[] getAccountsFromCache(BUserAccounts userAccounts, String accountType, String callingPackage, boolean includeManagedNotVisible) {
        if (accountType != null) {
            Account[] accounts;
            synchronized (userAccounts.lock) {
                accounts = userAccounts.getAccountsByType(accountType);
            }

            if (accounts == null) {
                return EMPTY_ACCOUNT_ARRAY;
            }
            return filterAccounts(userAccounts, Arrays.copyOf(accounts, accounts.length), callingPackage, includeManagedNotVisible);
        } else {
            int totalLength = 0;
            Account[] accountsArray;

            synchronized (mUserAccountsMap) {
                for (BUserAccounts bUserAccounts : mUserAccountsMap.values()) {
                    totalLength += bUserAccounts.toAccounts().length;
                }

                if (totalLength == 0) {
                    return EMPTY_ACCOUNT_ARRAY;
                }

                accountsArray = new Account[totalLength];
                totalLength = 0;
                for (BUserAccounts bUserAccounts : mUserAccountsMap.values()) {
                    Account[] accountsOfType = bUserAccounts.toAccounts();

                    System.arraycopy(accountsOfType, 0, accountsArray, totalLength, accountsOfType.length);
                    totalLength += accountsOfType.length;
                }
            }
            return filterAccounts(userAccounts, accountsArray, callingPackage, includeManagedNotVisible);
        }
    }

    @NonNull
    private Account[] filterAccounts(BUserAccounts accounts, Account[] unfiltered, String callingPackage, boolean includeManagedNotVisible) {
        Map<Account, Integer> firstPass = new LinkedHashMap<>();
        for (Account account : unfiltered) {
            int visibility = resolveAccountVisibility(account, callingPackage, accounts);
            if ((visibility == AccountManager.VISIBILITY_VISIBLE || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)
                    || (includeManagedNotVisible && (visibility == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE))) {
                firstPass.put(account, visibility);
            }
        }
        return firstPass.keySet().toArray(new Account[]{});
    }

    /**
     * Method which handles default values for Account visibility.
     *
     * @param account     The account to check visibility.
     * @param packageName Package name to check visibility
     * @param accounts    UserAccount that currently hosts the account and application
     * @return Visibility value, the method never returns AccountManager.VISIBILITY_UNDEFINED
     */
    private Integer resolveAccountVisibility(Account account, @NonNull String packageName, BUserAccounts accounts) {
        if (accounts == null) {
            return AccountManager.VISIBILITY_NOT_VISIBLE;
        }

        BAccount bAccount = accounts.getAccount(account);
        if (bAccount == null) {
            return AccountManager.VISIBILITY_NOT_VISIBLE;
        }

        // Return stored value if it was set.
        int visibility = getAccountVisibilityFromCache(account, packageName, accounts);
        if (AccountManager.VISIBILITY_UNDEFINED != visibility) {
            return visibility;
        }
        return AccountManager.VISIBILITY_NOT_VISIBLE;
    }

    /**
     * Method returns visibility for given account and package name.
     *
     * @param account     The account to check visibility.
     * @param packageName Package name to check visibility.
     * @param accounts    UserAccount that currently hosts the account and application
     * @return Visibility value, AccountManager.VISIBILITY_UNDEFINED if no value was stored.
     */
    private int getAccountVisibilityFromCache(Account account, String packageName, BUserAccounts accounts) {
        synchronized (accounts.lock) {
            Map<String, Integer> accountVisibility = getPackagesAndVisibilityForAccountLocked(account, accounts);
            Integer visibility = accountVisibility.get(packageName);
            return visibility != null ? visibility : AccountManager.VISIBILITY_UNDEFINED;
        }
    }

    private @NonNull Map<String, Integer> getPackagesAndVisibilityForAccountLocked(Account account, BUserAccounts accounts) {
        return accounts.getVisibility(account);
    }

    private void handleGetAccountsResult(IAccountManagerResponse response, Account[] accounts, String callingPackage, int userId) {
        if (needToStartChooseAccountActivity(accounts, callingPackage, userId)) {
            return;
        }

        if (accounts.length == 1) {
            Bundle bundle = new Bundle();
            bundle.putString(AccountManager.KEY_ACCOUNT_NAME, accounts[0].name);
            bundle.putString(AccountManager.KEY_ACCOUNT_TYPE, accounts[0].type);

            onResult(response, bundle);
            return;
        }
        onResult(response, new Bundle());
    }

    private boolean needToStartChooseAccountActivity(Account[] accounts, String callingPackage, int userId) {
        if (accounts.length < 1) {
            return false;
        }

        if (accounts.length > 1) {
            return true;
        }

        Account account = accounts[0];
        BUserAccounts userAccounts = getUserAccounts(userId);
        int visibility = resolveAccountVisibility(account, callingPackage, userAccounts);
        return visibility == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;
    }

    private String readUserDataInternal(BUserAccounts accounts, Account account, String key) {
        if (accounts == null) {
            return null;
        }

        synchronized (accounts.lock) {
            Map<String, String> accountUserData = accounts.getAccountUserData(account);
            return accountUserData.get(key);
        }
    }

    public String readPasswordInternal(BUserAccounts accounts, Account account) {
        if (accounts == null) {
            return null;
        }

        synchronized (accounts.lock) {
            BAccount bAccount = accounts.getAccount(account);
            if (bAccount == null) {
                return null;
            }
            return bAccount.password;
        }
    }

    public BUserAccounts getUserAccounts(int userId) {
        synchronized (mUserAccountsMap) {
            BUserAccounts bUserAccounts = mUserAccountsMap.get(userId);
            if (bUserAccounts == null) {
                bUserAccounts = new BUserAccounts();
                mUserAccountsMap.put(userId, bUserAccounts);
            }
            return mUserAccountsMap.get(userId);
        }
    }

    private boolean isAccountPresentForCaller(String accountName, String accountType, int userId) {
        BUserAccounts userAccounts = getUserAccounts(userId);
        if (userAccounts != null) {
            BAccount account = userAccounts.getAccount(new Account(accountName, accountType));
            return account != null;
        }
        return false;
    }

    private boolean removeAccountInternal(BUserAccounts accounts, Account account) {
        synchronized (accounts.lock) {
            boolean del = accounts.delAccount(account);
            if (del) {
                saveAllAccounts();
            }
            return del;
        }
    }

    private class RemoveAccountSession extends Session {
        final Account mAccount;

        public RemoveAccountSession(BUserAccounts accounts, IAccountManagerResponse response, Account account, boolean expectActivityLaunch) {
            super(accounts, response, account.type, expectActivityLaunch, true /* stripAuthTokenFromResult */, account.name,
                    false /* authDetailsRequired */);
            this.mAccount = account;
        }

        @Override
        protected String toDebugString(long now) {
            return super.toDebugString(now) + ", removeAccount" + ", account " + mAccount;
        }

        @Override
        public void run() throws RemoteException {
            mAuthenticator.getAccountRemovalAllowed(this, mAccount);
        }

        @Override
        public void onResult(Bundle result) {
            if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT) && !result.containsKey(AccountManager.KEY_INTENT)) {
                final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);
                if (removalAllowed) {
                    removeAccountInternal(mAccounts, mAccount);
                }

                IAccountManagerResponse response = getResponseAndClose();
                if (response != null) {
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.v(TAG, getClass().getSimpleName() + " calling onResult() on response " + response);
                    }

                    try {
                        response.onResult(result);
                    } catch (RemoteException e) {
                        Slog.e(TAG, "Error calling onResult()", e);
                    }
                }
            }
            super.onResult(result);
        }
    }

    private class GetAccountsByTypeAndFeatureSession extends Session {
        private final String[] mFeatures;
        private volatile Account[] mAccountsOfType = null;
        private volatile ArrayList<Account> mAccountsWithFeatures = null;
        private volatile int mCurrentAccount = 0;
        private final String mPackageName;
        private final boolean mIncludeManagedNotVisible;

        public GetAccountsByTypeAndFeatureSession(BUserAccounts accounts, IAccountManagerResponse response, String type, String[] features, int userId,
                                                  String packageName, boolean includeManagedNotVisible) {
            super(accounts, response, type, false /* expectActivityLaunch */, true /* stripAuthTokenFromResult */,
                    null /* accountName */, false /* authDetailsRequired */);
            this.mFeatures = features;
            this.mPackageName = packageName;
            this.mIncludeManagedNotVisible = includeManagedNotVisible;
        }

        @Override
        public void run() throws RemoteException {
            mAccountsOfType = getAccountsFromCache(mAccounts, mAccountType, mPackageName, mIncludeManagedNotVisible);
            // Check whether each account matches the requested features.
            mAccountsWithFeatures = new ArrayList<>(mAccountsOfType.length);
            mCurrentAccount = 0;
            checkAccount();
        }

        public void checkAccount() {
            if (mCurrentAccount >= mAccountsOfType.length) {
                sendResult();
                return;
            }

            final IAccountAuthenticator accountAuthenticator = mAuthenticator;
            if (accountAuthenticator == null) {
                // It is possible that the authenticator has died, which is indicated by
                // mAuthenticator being set to null. If this happens then just abort.
                // There is no need to send back a result or error in this case since
                // that already happened when mAuthenticator was cleared.
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, "checkAccount: aborting session since we are no longer" + " connected to the authenticator, " + toDebugString());
                }
                return;
            }

            try {
                accountAuthenticator.hasFeatures(this, mAccountsOfType[mCurrentAccount], mFeatures);
            } catch (RemoteException e) {
                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, "remote exception");
            }
        }

        @Override
        public void onResult(Bundle result) {
            mNumResults++;
            if (result == null) {
                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "null bundle");
                return;
            }

            if (result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {
                mAccountsWithFeatures.add(mAccountsOfType[mCurrentAccount]);
            }

            mCurrentAccount++;
            checkAccount();
        }

        public void sendResult() {
            IAccountManagerResponse response = getResponseAndClose();
            if (response != null) {
                try {
                    Account[] accounts = new Account[mAccountsWithFeatures.size()];
                    for (int i = 0; i < accounts.length; i++) {
                        accounts[i] = mAccountsWithFeatures.get(i);
                    }

                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.v(TAG, getClass().getSimpleName() + " calling onResult() on response " + response);
                    }

                    Bundle result = new Bundle();
                    result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);
                    response.onResult(result);
                } catch (RemoteException e) {
                    // If the caller is dead then there is no one to care about remote exceptions.
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.v(TAG, "failure while notifying response", e);
                    }
                }
            }
        }

        @Override
        protected String toDebugString(long now) {
            return super.toDebugString(now) + ", getAccountsByTypeAndFeatures" + ", " + (mFeatures != null ? TextUtils.join(",", mFeatures) : null);
        }
    }

    private static final class AuthenticatorInfo {
        final AuthenticatorDescription desc;
        final ServiceInfo serviceInfo;

        AuthenticatorInfo(AuthenticatorDescription desc, ServiceInfo info) {
            this.desc = desc;
            this.serviceInfo = info;
        }
    }

    private static final class AuthenticatorCache {
        final Map<String, AuthenticatorInfo> authenticators = new HashMap<>();
    }

    private static AuthenticatorDescription parseAuthenticatorDescription(Resources resources, String packageName, AttributeSet attributeSet) {
        TypedArray array = resources.obtainAttributes(attributeSet, ArrayUtils.toInt(black.com.android.internal.R.styleable.AccountAuthenticator.get()));
        try {
            String accountType = array.getString(black.com.android.internal.R.styleable.AccountAuthenticator_accountType.get());
            int label = array.getResourceId(black.com.android.internal.R.styleable.AccountAuthenticator_label.get(), 0);
            int icon = array.getResourceId(black.com.android.internal.R.styleable.AccountAuthenticator_icon.get(), 0);
            int smallIcon = array.getResourceId(black.com.android.internal.R.styleable.AccountAuthenticator_smallIcon.get(), 0);
            int accountPreferences = array.getResourceId(black.com.android.internal.R.styleable.AccountAuthenticator_accountPreferences.get(), 0);
            boolean customTokens = array.getBoolean(black.com.android.internal.R.styleable.AccountAuthenticator_customTokens.get(), false);

            if (TextUtils.isEmpty(accountType)) {
                return null;
            }
            return new AuthenticatorDescription(accountType, packageName, label, icon, smallIcon, accountPreferences, customTokens);
        } finally {
            array.recycle();
        }
    }

    public void loadAuthenticatorCache(String packageName) {
        mAuthenticatorCache.authenticators.clear();
        Intent intent = new Intent(AccountManager.ACTION_AUTHENTICATOR_INTENT);
        if (packageName != null) {
            intent.setPackage(packageName);
        }

        generateServicesMap(mPms.queryIntentServices(intent, PackageManager.GET_META_DATA, BUserHandle.USER_ALL), mAuthenticatorCache.authenticators,
                new RegisteredServicesParser());
    }

    private void generateServicesMap(List<ResolveInfo> services, Map<String, AuthenticatorInfo> map, RegisteredServicesParser accountParser) {
        for (ResolveInfo info : services) {
            XmlResourceParser parser = accountParser.getParser(mContext, info.serviceInfo, AccountManager.AUTHENTICATOR_META_DATA_NAME);
            if (parser != null) {
                try {
                    AttributeSet attributeSet = Xml.asAttributeSet(parser);
                    if (AccountManager.AUTHENTICATOR_ATTRIBUTES_NAME.equals(parser.getName())) {
                        AuthenticatorDescription desc = parseAuthenticatorDescription(accountParser.getResources(mContext, info.serviceInfo.applicationInfo),
                                info.serviceInfo.packageName, attributeSet);
                        if (desc != null) {
                            map.put(desc.type, new AuthenticatorInfo(desc, info.serviceInfo));
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private abstract class Session extends IAccountAuthenticatorResponse.Stub implements IBinder.DeathRecipient, ServiceConnection {
        IAccountManagerResponse mResponse;
        final String mAccountType;
        final boolean mExpectActivityLaunch;
        final long mCreationTime;
        final String mAccountName;
        // Indicates if we need to add auth details (like last credential time)
        final boolean mAuthDetailsRequired;
        // If set, we need to update the last authenticated time. This is currently used on
        // successful confirming credentials.
        final boolean mUpdateLastAuthenticatedTime;

        public int mNumResults = 0;
        private int mNumRequestContinued = 0;
        private int mNumErrors = 0;

        IAccountAuthenticator mAuthenticator = null;

        private final boolean mStripAuthTokenFromResult;
        protected final BUserAccounts mAccounts;

        public Session(BUserAccounts accounts, IAccountManagerResponse response, String accountType, boolean expectActivityLaunch,
                       boolean stripAuthTokenFromResult, String accountName, boolean authDetailsRequired) {
            this(accounts, response, accountType, expectActivityLaunch, stripAuthTokenFromResult, accountName,
                    authDetailsRequired, false /* updateLastAuthenticatedTime */);
        }

        public Session(BUserAccounts accounts, IAccountManagerResponse response, String accountType, boolean expectActivityLaunch,
                       boolean stripAuthTokenFromResult, String accountName, boolean authDetailsRequired, boolean updateLastAuthenticatedTime) {
            super();
            if (accountType == null) {
                throw new IllegalArgumentException("accountType is null");
            }

            mAccounts = accounts;
            mStripAuthTokenFromResult = stripAuthTokenFromResult;
            mResponse = response;
            mAccountType = accountType;
            mExpectActivityLaunch = expectActivityLaunch;
            mCreationTime = SystemClock.elapsedRealtime();
            mAccountName = accountName;
            mAuthDetailsRequired = authDetailsRequired;
            mUpdateLastAuthenticatedTime = updateLastAuthenticatedTime;

            synchronized (mSessions) {
                mSessions.put(toString(), this);
            }

            if (response != null) {
                try {
                    response.asBinder().linkToDeath(this, 0 /* flags */);
                } catch (RemoteException e) {
                    mResponse = null;
                    binderDied();
                }
            }
        }

        IAccountManagerResponse getResponseAndClose() {
            if (mResponse == null) {
                // This session has already been closed.
                return null;
            }
            IAccountManagerResponse response = mResponse;
            close(); // This clears mResponse so we need to save the response before this call.
            return response;
        }

        /**
         * Checks Intents, supplied via KEY_INTENT, to make sure that they don't violate our
         * security policy.
         * <p>
         * In particular we want to make sure that the Authenticator doesn't try to trick users
         * into launching arbitrary intents on the device via by tricking to click authenticator
         * supplied entries in the system Settings app.
         */
        protected boolean checkKeyIntent(int authUid, Intent intent) {
            // Explicitly set an empty ClipData to ensure that we don't offer to
            // promote any Uris contained inside for granting purposes
            if (intent.getClipData() == null) {
                intent.setClipData(ClipData.newPlainText(null, null));
            }
            intent.setFlags(intent.getFlags() & ~(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION
                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION));
            long bid = Binder.clearCallingIdentity();
            try {
                ResolveInfo resolveInfo = mPms.resolveActivity(intent, 0, null, mAccounts.userId);
                return resolveInfo != null;
            } finally {
                Binder.restoreCallingIdentity(bid);
            }
        }

        private void close() {
            synchronized (mSessions) {
                if (mSessions.remove(toString()) == null) {
                    // The session was already closed, so bail out now.
                    return;
                }
            }
            if (mResponse != null) {
                // Stop listening for response deaths.
                mResponse.asBinder().unlinkToDeath(this, 0 /* flags */);

                // Clear this so that we don't accidentally send any further results.
                mResponse = null;
            }
            cancelTimeout();
            unbind();
        }

        @Override
        public void binderDied() {
            mResponse = null;
            close();
        }

        protected String toDebugString() {
            return toDebugString(SystemClock.elapsedRealtime());
        }

        protected String toDebugString(long now) {
            return "Session: expectLaunch " + mExpectActivityLaunch + ", connected " + (mAuthenticator != null)
                    + ", stats (" + mNumResults + "/" + mNumRequestContinued + "/" + mNumErrors + ")" + ", lifetime " + ((now - mCreationTime) / 1000.0);
        }

        void bind() {
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, "initiating bind to authenticator type " + mAccountType);
            }

            if (!bindToAuthenticator(mAccountType)) {
                Log.d(TAG, "bind attempt failed for " + toDebugString());
                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, "bind failure");
            }
        }

        private void unbind() {
            if (mAuthenticator != null) {
                mAuthenticator = null;
                mContext.unbindService(this);
            }
        }

        public void cancelTimeout() {
            mHandler.removeMessages(MESSAGE_TIMED_OUT, this);
        }

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            mAuthenticator = IAccountAuthenticator.Stub.asInterface(service);
            try {
                run();
            } catch (RemoteException e) {
                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, "remote exception");
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            mAuthenticator = null;
            IAccountManagerResponse response = getResponseAndClose();

            if (response != null) {
                try {
                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, "disconnected");
                } catch (RemoteException e) {
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.v(TAG, "Session.onServiceDisconnected: " + "caught RemoteException while responding", e);
                    }
                }
            }
        }

        public abstract void run() throws RemoteException;

        @Override
        public void onResult(Bundle result) {
            mNumResults++;
            Intent intent = null;

            if (result != null) {
                boolean isSuccessfulConfirmCreds = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);
                boolean isSuccessfulUpdateCredsOrAddAccount = result.containsKey(AccountManager.KEY_ACCOUNT_NAME)
                        && result.containsKey(AccountManager.KEY_ACCOUNT_TYPE);
                // We should only update lastAuthenticated time, if
                // mUpdateLastAuthenticatedTime is true and the confirmRequest
                // or updateRequest was successful.
                boolean needUpdate = mUpdateLastAuthenticatedTime && (isSuccessfulConfirmCreds || isSuccessfulUpdateCredsOrAddAccount);
                if (needUpdate || mAuthDetailsRequired) {
                    boolean accountPresent = isAccountPresentForCaller(mAccountName, mAccountType, mAccounts.userId);
                    if (needUpdate && accountPresent) {
                        updateLastAuthenticatedTime(mAccounts, new Account(mAccountName, mAccountType));
                    }

                    if (mAuthDetailsRequired) {
                        long lastAuthenticatedTime = -1;
                        if (accountPresent) {
                            lastAuthenticatedTime = mAccounts.findAccountLastAuthenticatedTime(new Account(mAccountName, mAccountType));
                        }

                        result.putLong(AccountManager.KEY_LAST_AUTHENTICATED_TIME, lastAuthenticatedTime);
                    }
                }
            }

            if (result != null && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {
                if (!checkKeyIntent(Binder.getCallingUid(), intent)) {
                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "invalid intent in bundle returned");
                    return;
                }
            }

            IAccountManagerResponse response;
            if (mExpectActivityLaunch && result != null && result.containsKey(AccountManager.KEY_INTENT)) {
                response = mResponse;
            } else {
                response = getResponseAndClose();
            }

            if (response != null) {
                try {
                    if (result == null) {
                        if (Log.isLoggable(TAG, Log.VERBOSE)) {
                            Log.v(TAG, getClass().getSimpleName() + " calling onError() on response " + response);
                        }

                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "null bundle returned");
                    } else {
                        if (mStripAuthTokenFromResult) {
                            result.remove(AccountManager.KEY_AUTHTOKEN);
                        }

                        if (Log.isLoggable(TAG, Log.VERBOSE)) {
                            Log.v(TAG, getClass().getSimpleName() + " calling onResult() on response " + response);
                        }

                        if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {
                            // All AccountManager error codes are greater than 0.
                            response.onError(result.getInt(AccountManager.KEY_ERROR_CODE), result.getString(AccountManager.KEY_ERROR_MESSAGE));
                        } else {
                            response.onResult(result);
                        }
                    }
                } catch (RemoteException e) {
                    // If the caller is dead then there is no one to care about remote exceptions.
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.v(TAG, "failure while notifying response", e);
                    }
                }
            }
        }

        @Override
        public void onRequestContinued() {
            mNumRequestContinued++;
        }

        @Override
        public void onError(int errorCode, String errorMessage) {
            mNumErrors++;
            IAccountManagerResponse response = getResponseAndClose();

            if (response != null) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + " calling onError() on response " + response);
                }

                try {
                    response.onError(errorCode, errorMessage);
                } catch (RemoteException e) {
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.v(TAG, "Session.onError: caught RemoteException while responding", e);
                    }
                }
            } else {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, "Session.onError: already closed");
                }
            }
        }

        /**
         * find the component name for the authenticator and initiate a bind
         * if no authenticator or the bind fails then return false, otherwise return true
         */
        private boolean bindToAuthenticator(String authenticatorType) {
            AuthenticatorInfo authenticatorInfo = mAuthenticatorCache.authenticators.get(authenticatorType);
            if (authenticatorInfo == null) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, "there is no authenticator for " + authenticatorType + ", bailing out");
                }
                return false;
            }

            Intent intent = new Intent();
            intent.setAction(AccountManager.ACTION_AUTHENTICATOR_INTENT);
			
            ComponentName componentName = new ComponentName(authenticatorInfo.serviceInfo.packageName, authenticatorInfo.serviceInfo.name);
            intent.setComponent(componentName);
            intent.putExtra("_B_|_UserId", mAccounts.userId);

            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, "performing bindService to " + componentName);
            }

            int flags = Context.BIND_AUTO_CREATE;
            if (!mContext.bindService(intent, this, flags)) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, "bindService to " + componentName + " failed");
                }
                return false;
            }
            return true;
        }
    }

    private void onResult(IAccountManagerResponse response, Bundle result) {
        if (result == null) {
            Log.e(TAG, "the result is unexpectedly null", new Exception());
        }

        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, getClass().getSimpleName() + " calling onResult() on response " + response);
        }

        try {
            response.onResult(result);
        } catch (RemoteException e) {
            // If the caller is dead then there is no one to care about remote exceptions.
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, "failure while notifying response", e);
            }
        }
    }

    private boolean updateLastAuthenticatedTime(BUserAccounts userAccounts, Account account) {
        userAccounts.updateLastAuthenticatedTime(account);
        return true;
    }

    private String getCallingPackageName() {
        int callingPid = Binder.getCallingPid();
        ProcessRecord processByPid = BProcessManagerService.get().findProcessByPid(callingPid);

        if (processByPid == null) {
            throw new IllegalArgumentException("ProcessRecord is null, PID: " + callingPid);
        }
        return processByPid.getPackageName();
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/accounts/BUserAccounts.java`:

```java
package com.vcore.core.system.accounts;

import android.accounts.Account;
import android.os.Parcel;
import android.os.Parcelable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BUserAccounts implements Parcelable {
    public final Object lock = new Object();

    public int userId;
    public List<BAccount> accounts = new ArrayList<>();

    public Account[] toAccounts() {
        List<Account> local = new ArrayList<>();
        for (BAccount account : accounts) {
            local.add(account.account);
        }
        return local.toArray(new Account[]{});
    }

    public BAccount addAccount(Account account) {
        BAccount bAccount = new BAccount();
        bAccount.account = account;
        accounts.add(bAccount);
        return bAccount;
    }

    public BAccount getAccount(Account account) {
        for (BAccount bAccount : accounts) {
            if (bAccount.isMatch(account)) {
                return bAccount;
            }
        }
        return null;
    }

    public boolean delAccount(Account account) {
        BAccount bAccount = getAccount(account);
        return accounts.remove(bAccount);
    }

    public Map<String, Integer> getVisibility(Account account) {
        BAccount bAccount = getAccount(account);
        if (bAccount == null) {
            return new HashMap<>();
        }
        return bAccount.visibility;
    }

    public Map<String, String> getAccountUserData(Account account) {
        BAccount bAccount = getAccount(account);
        if (bAccount == null) {
            return new HashMap<>();
        }
        return bAccount.accountUserData;
    }

    public Map<String, String> getAuthToken(Account account) {
        BAccount bAccount = getAccount(account);
        if (bAccount == null) {
            return new HashMap<>();
        }
        return bAccount.authTokens;
    }

    public Account[] getAccountsByType(String type) {
        List<Account> local = new ArrayList<>();
        for (BAccount account : accounts) {
            if (account.account.type.equals(type)) {
                local.add(account.account);
            }
        }
        return local.toArray(new Account[]{});
    }

    public void updateLastAuthenticatedTime(Account account) {
        BAccount bAccount = getAccount(account);
        if (bAccount != null) {
            bAccount.updateLastAuthenticatedTime = System.currentTimeMillis();
        }
    }

    public long findAccountLastAuthenticatedTime(Account account) {
        BAccount bAccount = getAccount(account);
        if (bAccount != null) {
            return bAccount.updateLastAuthenticatedTime;
        }
        return -1;
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(this.userId);
        dest.writeTypedList(this.accounts);
    }

    public BUserAccounts() { }

    protected BUserAccounts(Parcel in) {
        this.userId = in.readInt();
        this.accounts = in.createTypedArrayList(BAccount.CREATOR);
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/accounts/RegisteredServicesParser.java`:

```java
package com.vcore.core.system.accounts;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.ServiceInfo;
import android.content.res.Resources;
import android.content.res.XmlResourceParser;
import android.os.Bundle;

import com.vcore.core.system.pm.PackageManagerCompat;

public class RegisteredServicesParser {
    public XmlResourceParser getParser(Context context, ServiceInfo serviceInfo, String name) {
        Bundle meta = serviceInfo.metaData;
        if (meta != null) {
            int xmlId = meta.getInt(name);
            if (xmlId != 0) {
                try {
                    Resources resources = getResources(context, serviceInfo.applicationInfo);
                    if (resources == null) {
                        return null;
                    }
                    return resources.getXml(xmlId);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        return null;
    }

    public Resources getResources(Context context, ApplicationInfo appInfo) {
        return PackageManagerCompat.getResources(context, appInfo);
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/accounts/TokenCache.java`:

```java
package com.vcore.core.system.accounts;

import android.accounts.Account;

import java.util.Objects;

public class TokenCache {
    public final int userId;
    public final Account account;
    public final long expiryEpochMillis;
    public final String authToken;
    public final String authTokenType;
    public final String packageName;

    public TokenCache(int userId, Account account, String callerPkg, String tokenType, String token, long expiryMillis) {
        this.userId = userId;
        this.account = account;
        this.expiryEpochMillis = expiryMillis;
        this.authToken = token;
        this.authTokenType = tokenType;
        this.packageName = callerPkg;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }

        if (!(o instanceof TokenCache)) {
            return false;
        }
        TokenCache that = (TokenCache) o;
        return userId == that.userId && expiryEpochMillis == that.expiryEpochMillis && Objects.equals(account, that.account) &&
                Objects.equals(authToken, that.authToken) && Objects.equals(authTokenType, that.authTokenType) && Objects.equals(packageName, that.packageName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(userId, account, expiryEpochMillis, authToken, authTokenType, packageName);
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/am/ActiveServices.java`:

```java
package com.vcore.core.system.am;

import android.annotation.SuppressLint;
import android.app.ActivityManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ResolveInfo;
import android.content.pm.ServiceInfo;
import android.os.Binder;
import android.os.IBinder;
import android.os.RemoteException;
import android.util.Log;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;

import com.vcore.BlackBoxCore;
import com.vcore.core.IEmpty;
import com.vcore.core.system.BProcessManagerService;
import com.vcore.core.system.ProcessRecord;
import com.vcore.core.system.pm.BPackageManagerService;
import com.vcore.entity.UnbindRecord;
import com.vcore.entity.am.RunningServiceInfo;
import com.vcore.proxy.ProxyManifest;
import com.vcore.proxy.record.ProxyServiceRecord;

@SuppressLint("NewApi")
public class ActiveServices {
    public static final String TAG = "ActiveServices";
    private final Map<Intent.FilterComparison, RunningServiceRecord> mRunningServiceRecords = new HashMap<>();
    private final Map<IBinder, RunningServiceRecord> mRunningTokens = new HashMap<>();
    private final Map<IBinder, ConnectedServiceRecord> mConnectedServices = new HashMap<>();

    public void startService(Intent intent, String resolvedType, int userId) {
        ResolveInfo resolveInfo = resolveService(intent, resolvedType, userId);
        if (resolveInfo == null) {
            return;
        }

        ServiceInfo serviceInfo = resolveInfo.serviceInfo;
        ProcessRecord processRecord = BProcessManagerService.get().startProcessLocked(serviceInfo.packageName, serviceInfo.processName, userId, -1, Binder.getCallingPid());
        if (processRecord == null) {
            throw new RuntimeException("Unable to create " + serviceInfo.name);
        }

        RunningServiceRecord runningServiceRecord = getOrCreateRunningServiceRecord(intent);
        runningServiceRecord.mServiceInfo = serviceInfo;
        runningServiceRecord.getAndIncrementStartId();

        final Intent stubServiceIntent = createStubServiceIntent(intent, serviceInfo, processRecord, runningServiceRecord);
        new Thread(() -> {
            try {
                BlackBoxCore.getContext().startService(stubServiceIntent);
            } catch (Throwable e) {
                e.printStackTrace();
            }
        }).start();
    }

    public int stopService(Intent intent, String resolvedType, int userId) {
        synchronized (mRunningServiceRecords) {
            RunningServiceRecord runningServiceRecord = findRunningServiceRecord(intent);
            if (runningServiceRecord == null) {
                return 0;
            }

            if (runningServiceRecord.mBindCount.get() > 0) {
                Log.d(TAG, "There are also connections");
                return 0;
            }

            runningServiceRecord.mStartId.set(0);
            ResolveInfo resolveInfo = resolveService(intent, resolvedType, userId);
            if (resolveInfo == null) {
                return 0;
            }

            ServiceInfo serviceInfo = resolveInfo.serviceInfo;
            ProcessRecord processRecord = BProcessManagerService.get().startProcessLocked(serviceInfo.packageName, serviceInfo.processName, userId, -1, Binder.getCallingPid());
            if (processRecord == null) {
                return 0;
            }

            try {
                processRecord.bActivityThread.stopService(intent);
            } catch (RemoteException ignored) { }
        }
        return 0;
    }

    public Intent bindService(Intent intent, final IBinder binder, String resolvedType, int userId) {
        ResolveInfo resolveInfo = resolveService(intent, resolvedType, userId);
        if (resolveInfo == null) {
            return intent;
        }

        ServiceInfo serviceInfo = resolveInfo.serviceInfo;
        ProcessRecord processRecord = BProcessManagerService.get().startProcessLocked(serviceInfo.packageName, serviceInfo.processName,
                userId, -1, Binder.getCallingPid());
        if (processRecord == null) {
            throw new RuntimeException("Unable to create " + serviceInfo.name);
        }

        RunningServiceRecord runningServiceRecord;
        synchronized (mRunningServiceRecords) {
            runningServiceRecord = getOrCreateRunningServiceRecord(intent);
            runningServiceRecord.mServiceInfo = serviceInfo;

            if (binder != null) {
                ConnectedServiceRecord connectedService = mConnectedServices.get(binder);
                boolean isBound = false;
                if (connectedService != null) {
                    isBound = true;
                } else {
                    connectedService = new ConnectedServiceRecord();
                    try {
                        binder.linkToDeath(new IBinder.DeathRecipient() {
                            @Override
                            public void binderDied() {
                                binder.unlinkToDeath(this, 0);
                                mConnectedServices.remove(binder);
                            }
                        }, 0);
                    } catch (RemoteException e) {
                        e.printStackTrace();
                    }

                    connectedService.mIntent = intent;
                    mConnectedServices.put(binder, connectedService);
                }

                if (!isBound) {
                    runningServiceRecord.incrementBindCountAndGet();
                }
            }
        }
        return createStubServiceIntent(intent, serviceInfo, processRecord, runningServiceRecord);
    }

    public void unbindService(IBinder binder) {
        ConnectedServiceRecord connectedService = mConnectedServices.get(binder);
        if (connectedService == null) {
            return;
        }

        RunningServiceRecord runningServiceRecord = getOrCreateRunningServiceRecord(connectedService.mIntent);
        runningServiceRecord.mBindCount.decrementAndGet();
        mConnectedServices.remove(binder);
    }

    public void stopServiceToken(IBinder token, int userId) {
        RunningServiceRecord runningServiceByToken = findRunningServiceByToken(token);
        if (runningServiceByToken != null) {
            stopService(runningServiceByToken.mIntent, null, userId);
        }
    }

    public void onServiceDestroy(Intent proxyIntent) {
        if (proxyIntent == null) {
            return;
        }

        ProxyServiceRecord proxyServiceRecord = ProxyServiceRecord.create(proxyIntent);
        if (proxyServiceRecord.mServiceIntent != null) {
            proxyIntent = proxyServiceRecord.mServiceIntent;
        }

        RunningServiceRecord remove = mRunningServiceRecords.remove(new Intent.FilterComparison(proxyIntent));
        if (remove != null) {
            mRunningTokens.remove(remove);
        }
    }

    public UnbindRecord onServiceUnbind(Intent proxyIntent) {
        if (proxyIntent == null) {
            return null;
        }

        ProxyServiceRecord proxyServiceRecord = ProxyServiceRecord.create(proxyIntent);
        ComponentName component = proxyServiceRecord.mServiceIntent.getComponent();
        RunningServiceRecord runningServiceRecord = findRunningServiceRecord(proxyServiceRecord.mServiceIntent);
        if (runningServiceRecord == null) {
            return null;
        }

        UnbindRecord record = new UnbindRecord();
        record.setComponentName(component);
        record.setBindCount(runningServiceRecord.mBindCount.get());
        record.setStartId(runningServiceRecord.mStartId.get());
        return record;
    }

    private Intent createStubServiceIntent(Intent targetIntent, ServiceInfo serviceInfo, ProcessRecord processRecord, RunningServiceRecord runningServiceRecord) {
        Intent stub = new Intent();
        ComponentName stubComp = new ComponentName(BlackBoxCore.getHostPkg(), ProxyManifest.getProxyService(processRecord.bPID));
        stub.setComponent(stubComp);
        stub.setAction(UUID.randomUUID().toString());
        ProxyServiceRecord.saveStub(stub, targetIntent, serviceInfo, runningServiceRecord, processRecord.userId, runningServiceRecord.mStartId.get());
        return stub;
    }

    private RunningServiceRecord getOrCreateRunningServiceRecord(Intent intent) {
        RunningServiceRecord runningServiceRecord = findRunningServiceRecord(intent);
        if (runningServiceRecord == null) {
            runningServiceRecord = new RunningServiceRecord();
            runningServiceRecord.mIntent = intent;
            mRunningServiceRecords.put(new Intent.FilterComparison(intent), runningServiceRecord);
            mRunningTokens.put(runningServiceRecord, runningServiceRecord);
        }
        return runningServiceRecord;
    }

    private RunningServiceRecord findRunningServiceRecord(Intent intent) {
        return mRunningServiceRecords.get(new Intent.FilterComparison(intent));
    }

    private RunningServiceRecord findRunningServiceByToken(IBinder token) {
        return mRunningTokens.get(token);
    }

    public RunningServiceInfo getRunningServiceInfo(String callerPackage, int userId) {
        ActivityManager manager = (ActivityManager) BlackBoxCore.getContext().getSystemService(Context.ACTIVITY_SERVICE);
        List<ActivityManager.RunningServiceInfo> runningServices = manager.getRunningServices(Integer.MAX_VALUE);
        Map<Integer, ActivityManager.RunningServiceInfo> serviceInfoMap = new HashMap<>();
        for (ActivityManager.RunningServiceInfo runningService : runningServices) {
            serviceInfoMap.put(runningService.pid, runningService);
        }

        RunningServiceInfo info = new RunningServiceInfo();
        for (RunningServiceRecord value : mRunningServiceRecords.values()) {
            ServiceInfo serviceInfo = value.mServiceInfo;
            ProcessRecord processRecord = BProcessManagerService.get().findProcessRecord(callerPackage, serviceInfo.processName, userId);
            if (processRecord == null) {
                continue;
            }

            ActivityManager.RunningServiceInfo runningServiceInfo = serviceInfoMap.get(processRecord.pid);
            if (runningServiceInfo != null) {
                runningServiceInfo.process = processRecord.processName;
                runningServiceInfo.service = new ComponentName(serviceInfo.packageName, serviceInfo.name);
                info.mRunningServiceInfoList.add(runningServiceInfo);
            }
        }
        return info;
    }

    public IBinder peekService(Intent intent, String resolvedType, int userId) {
        ResolveInfo resolveInfo = resolveService(intent, resolvedType, userId);
        if (resolveInfo == null) {
            return null;
        }

        ProcessRecord processRecord = BProcessManagerService.get().findProcessRecord(resolveInfo.serviceInfo.packageName, resolveInfo.serviceInfo.processName,
                userId);
        if (processRecord == null) {
            return null;
        }

        try {
            return processRecord.bActivityThread.peekService(intent);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    private ResolveInfo resolveService(Intent intent, String resolvedType, int userId) {
        return BPackageManagerService.get().resolveService(intent, 0, resolvedType, userId);
    }

    public static class RunningServiceRecord extends IEmpty.Stub {
        private final AtomicInteger mStartId = new AtomicInteger(1);
        private final AtomicInteger mBindCount = new AtomicInteger(0);

        private ServiceInfo mServiceInfo;
        private Intent mIntent;

        public void getAndIncrementStartId() {
            mStartId.getAndIncrement();
        }

        public void incrementBindCountAndGet() {
            mBindCount.incrementAndGet();
        }
    }

    public static class ConnectedServiceRecord {
        private Intent mIntent;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/am/ActivityRecord.kt`:

```kt
package com.vcore.core.system.am

import android.content.ComponentName
import android.content.Intent
import android.content.pm.ActivityInfo
import android.os.Binder
import android.os.IBinder
import com.vcore.core.system.ProcessRecord
import java.util.UUID

class ActivityRecord : Binder() {
    @JvmField
    var task: TaskRecord? = null
    @JvmField
    var token: IBinder? = null
    @JvmField
    var resultTo: IBinder? = null
    @JvmField
    var info: ActivityInfo? = null
    @JvmField
    var component: ComponentName? = null
    @JvmField
    var intent: Intent? = null
    @JvmField
    var userId = 0
    @JvmField
    var finished = false
    @JvmField
    var processRecord: ProcessRecord? = null
    @JvmField
    var mBToken: String? = null

    companion object {
        @JvmStatic
        fun create(intent: Intent?, info: ActivityInfo, resultTo: IBinder?, userId: Int): ActivityRecord {
            val record = ActivityRecord()
            record.intent = intent
            record.info = info
            record.component = ComponentName(info.packageName, info.name)
            record.resultTo = resultTo
            record.userId = userId
            record.mBToken = UUID.randomUUID().toString()
            return record
        }
    }
}
```

`Bcore/src/main/java/com/vcore/core/system/am/ActivityStack.java`:

```java
package com.vcore.core.system.am;

import static android.content.pm.PackageManager.GET_ACTIVITIES;

import android.app.ActivityManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.ResolveInfo;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.os.Binder;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.IInterface;
import android.os.Looper;
import android.os.Message;
import android.os.RemoteException;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;

import black.android.app.ActivityManagerNative;
import black.android.app.IActivityManager;

import com.vcore.BlackBoxCore;
import com.vcore.core.system.BProcessManagerService;
import com.vcore.core.system.ProcessRecord;
import com.vcore.core.system.pm.BPackageManagerService;
import com.vcore.core.system.pm.PackageManagerCompat;
import com.vcore.proxy.ProxyActivity;
import com.vcore.proxy.ProxyManifest;
import com.vcore.proxy.record.ProxyActivityRecord;
import com.vcore.utils.ArrayUtils;
import com.vcore.utils.ComponentUtils;
import com.vcore.utils.Slog;
import com.vcore.utils.compat.ActivityManagerCompat;

public class ActivityStack {
    public static final String TAG = "ActivityStack";

    private final ActivityManager mAms;
    private final Map<Integer, TaskRecord> mTasks = new LinkedHashMap<>();
    private final Map<String, ActivityRecord> mLaunchingActivities = new HashMap<>();

    public static final int LAUNCH_TIME_OUT = 0;

    private final Handler mHandler = new Handler(Looper.getMainLooper()) {
        @Override
        public void handleMessage(Message msg) {
            if (msg.what == LAUNCH_TIME_OUT) {
                String token = (String) msg.obj;
                if (token != null) {
                    mLaunchingActivities.remove(token);
                }
            }
        }
    };

    public ActivityStack() {
        this.mAms = (ActivityManager) BlackBoxCore.getContext().getSystemService(Context.ACTIVITY_SERVICE);
    }

    public boolean containsFlag(Intent intent, int flag) {
        return (intent.getFlags() & flag) != 0;
    }

    public int startActivitiesLocked(int userId, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle options) {
        if (intents == null) {
            throw new NullPointerException("intents is null");
        }

        if (resolvedTypes == null) {
            throw new NullPointerException("resolvedTypes is null");
        }

        if (intents.length != resolvedTypes.length) {
            throw new IllegalArgumentException("intents are length different than resolvedTypes");
        }

        for (int i = 0; i < intents.length; i++) {
            startActivityLocked(userId, intents[i], resolvedTypes[i], resultTo, null, -1, 0, options);
        }
        return 0;
    }

    public int startActivityLocked(int userId, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags, Bundle options) {
        synchronized (mTasks) {
            synchronizeTasks();
        }

        ResolveInfo resolveInfo = BPackageManagerService.get().resolveActivity(intent, GET_ACTIVITIES, resolvedType, userId);
        if (resolveInfo == null || resolveInfo.activityInfo == null) {
            return 0;
        }

        Slog.d(TAG, "startActivityLocked : " + resolveInfo.activityInfo);
        ActivityInfo activityInfo = resolveInfo.activityInfo;

        ActivityRecord sourceRecord = findActivityRecordByToken(userId, resultTo);
        if (sourceRecord == null) {
            resultTo = null;
        }

        TaskRecord sourceTask = null;
        if (sourceRecord != null) {
            sourceTask = sourceRecord.task;
        }

        String taskAffinity = ComponentUtils.getTaskAffinity(activityInfo);

        int launchModeFlags = 0;
        boolean singleTop = containsFlag(intent, Intent.FLAG_ACTIVITY_SINGLE_TOP) || activityInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP;
        boolean newTask = containsFlag(intent, Intent.FLAG_ACTIVITY_NEW_TASK);
        boolean clearTop = containsFlag(intent, Intent.FLAG_ACTIVITY_CLEAR_TOP);
        boolean clearTask = containsFlag(intent, Intent.FLAG_ACTIVITY_CLEAR_TASK);

        TaskRecord taskRecord = null;
        switch (activityInfo.launchMode) {
            case ActivityInfo.LAUNCH_SINGLE_TOP:
            case ActivityInfo.LAUNCH_MULTIPLE:
            case ActivityInfo.LAUNCH_SINGLE_TASK:
                taskRecord = findTaskRecordByTaskAffinityLocked(userId, taskAffinity);
                if (taskRecord == null && !newTask) {
                    taskRecord = sourceTask;
                }
                break;
            case ActivityInfo.LAUNCH_SINGLE_INSTANCE:
                taskRecord = findTaskRecordByTaskAffinityLocked(userId, taskAffinity);
                break;
        }

        // 如果还没有task则新启动一个task
        if (taskRecord == null || taskRecord.needNewTask()) {
            return startActivityInNewTaskLocked(userId, intent, activityInfo, resultTo, launchModeFlags);
        }
        // 移至前台
        mAms.moveTaskToFront(taskRecord.id, 0);

        boolean notStartToFront = clearTop || singleTop || clearTask;
        boolean startTaskToFront = !notStartToFront && ComponentUtils.intentFilterEquals(taskRecord.rootIntent, intent)
                && taskRecord.rootIntent.getFlags() == intent.getFlags();
        if (startTaskToFront)
            return 0;

        ActivityRecord topActivityRecord = taskRecord.getTopActivityRecord();
        ActivityRecord targetActivityRecord = findActivityRecordByComponentName(userId, ComponentUtils.toComponentName(activityInfo));
        ActivityRecord newIntentRecord = null;

        if (clearTop) {
            if (targetActivityRecord != null) {
                // 目标栈上面所有activity出栈
                synchronized (Objects.requireNonNull(targetActivityRecord.task).activities) {
                    for (int i = targetActivityRecord.task.activities.size() - 1; i >= 0; i--) {
                        ActivityRecord next = targetActivityRecord.task.activities.get(i);
                        if (next != targetActivityRecord) {
                            next.finished = true;
                            Slog.d(TAG, "makerFinish: " + Objects.requireNonNull(next.component));
                        } else {
                            if (singleTop) {
                                newIntentRecord = targetActivityRecord;
                            } else {
                                // clearTop并且不是singleTop，目标也finish，重建。
                                targetActivityRecord.finished = true;
                            }
                            break;
                        }
                    }
                }
            }
        }

        if (singleTop && !clearTop) {
            if (ComponentUtils.intentFilterEquals(topActivityRecord.intent, intent)) {
                newIntentRecord = topActivityRecord;
            }
        }

        if (activityInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK && !clearTop) {
            if (ComponentUtils.intentFilterEquals(topActivityRecord.intent, intent)) {
                newIntentRecord = topActivityRecord;
            } else {
                ActivityRecord record = findActivityRecordByComponentName(userId, ComponentUtils.toComponentName(activityInfo));
                if (record != null) {
                    // 需要调用目标onNewIntent
                    newIntentRecord = record;
                    // 目标栈上面所有activity出栈
                    synchronized (taskRecord.activities) {
                        for (int i = taskRecord.activities.size() - 1; i >= 0; i--) {
                            ActivityRecord next = taskRecord.activities.get(i);
                            if (next != record) {
                                next.finished = true;
                            } else {
                                break;
                            }
                        }
                    }
                }
            }
        }

        if (activityInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
            newIntentRecord = topActivityRecord;
        }

        // clearTask finish All
        if (clearTask && newTask) {
            for (ActivityRecord activity : taskRecord.activities) {
                activity.finished = true;
            }
        }

        finishAllActivity(userId);

        if (newIntentRecord != null) {
            // 通知onNewIntent
            deliverNewIntentLocked(newIntentRecord, intent);
            return 0;
        }

        if (resultTo == null) {
            ActivityRecord top = taskRecord.getTopActivityRecord();
            if (top != null) {
                resultTo = top.token;
            }
        } else if (sourceTask != null) {
            ActivityRecord top = sourceTask.getTopActivityRecord();
            if (top != null) {
                resultTo = top.token;
            }
        }
        return startActivityInSourceTask(intent, resolvedType, resultTo, resultWho, requestCode, flags, options, userId, topActivityRecord, activityInfo,
                launchModeFlags);
    }

    private void deliverNewIntentLocked(ActivityRecord activityRecord, Intent intent) {
        try {
            Objects.requireNonNull(activityRecord.processRecord).bActivityThread.handleNewIntent(activityRecord.token, intent);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    private Intent startActivityProcess(int userId, Intent intent, ActivityInfo info, ActivityRecord record) {
        ProxyActivityRecord stubRecord = new ProxyActivityRecord(userId, info, intent, record.mBToken);
        ProcessRecord targetApp = BProcessManagerService.get().startProcessLocked(info.packageName, info.processName, userId, -1, Binder.getCallingPid());
        if (targetApp == null) {
            throw new RuntimeException("Unable to create process, name:" + info.name);
        }
        return getStartStubActivityIntentInner(intent, targetApp.bPID, stubRecord, info);
    }

    private int startActivityInNewTaskLocked(int userId, Intent intent, ActivityInfo activityInfo, IBinder resultTo, int launchMode) {
        ActivityRecord record = newActivityRecord(intent, activityInfo, resultTo, userId);
        Intent shadow = startActivityProcess(userId, intent, activityInfo, record);

        shadow.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
        shadow.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT);
        shadow.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        shadow.addFlags(launchMode);

        BlackBoxCore.getContext().startActivity(shadow);
        return 0;
    }

    private int startActivityInSourceTask(Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags, Bundle options,
                                          int userId, ActivityRecord sourceRecord, ActivityInfo activityInfo, int launchMode) {
        ActivityRecord selfRecord = newActivityRecord(intent, activityInfo, resultTo, userId);
        Intent shadow = startActivityProcess(userId, intent, activityInfo, selfRecord);
        shadow.setAction(UUID.randomUUID().toString());
        shadow.addFlags(launchMode);
        if (resultTo == null) {
            shadow.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        }
        return realStartActivityLocked(Objects.requireNonNull(sourceRecord.processRecord).appThread, shadow, resolvedType, resultTo, resultWho, requestCode, flags, options);
    }

    private int realStartActivityLocked(IInterface appThread, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags,
                                        Bundle options) {
        try {
            flags &= ~ActivityManagerCompat.START_FLAG_DEBUG;
            flags &= ~ActivityManagerCompat.START_FLAG_NATIVE_DEBUGGING;
            flags &= ~ActivityManagerCompat.START_FLAG_TRACK_ALLOCATION;

            IActivityManager.startActivity.call(ActivityManagerNative.getDefault.call(), appThread, BlackBoxCore.getHostPkg(), intent, resolvedType, resultTo, resultWho, requestCode, flags, null, options);
        } catch (Throwable e) {
            e.printStackTrace();
        }
        return 0;
    }

    private Intent getStartStubActivityIntentInner(Intent intent, int vPID, ProxyActivityRecord target, ActivityInfo activityInfo) {
        Intent shadow = new Intent();
        TypedArray typedArray = null;

        try {
            Resources resources = PackageManagerCompat.getResources(BlackBoxCore.getContext(), activityInfo.applicationInfo);
            int id;
            if (activityInfo.theme != 0) {
                id = activityInfo.theme;
            } else {
                id = activityInfo.applicationInfo.theme;
            }

            assert resources != null;
            typedArray = resources.newTheme().obtainStyledAttributes(id, ArrayUtils.toInt(black.com.android.internal.R.styleable.Window.get()));
            boolean windowIsTranslucent = typedArray.getBoolean(black.com.android.internal.R.styleable.Window_windowIsTranslucent.get(), false);
            if (windowIsTranslucent) {
                shadow.setComponent(new ComponentName(BlackBoxCore.getHostPkg(), ProxyManifest.TransparentProxyActivity(vPID)));
            } else {
                shadow.setComponent(new ComponentName(BlackBoxCore.getHostPkg(), ProxyManifest.getProxyActivity(vPID)));
            }

            Slog.d(TAG, activityInfo + ", windowIsTranslucent: " + windowIsTranslucent);
        } catch (Throwable e) {
            e.printStackTrace();
            shadow.setComponent(new ComponentName(BlackBoxCore.getHostPkg(), ProxyManifest.getProxyActivity(vPID)));
        } finally {
            if (typedArray != null) {
                typedArray.recycle();
            }
        }
        ProxyActivityRecord.saveStub(shadow, intent, target.mActivityInfo, target.mActivityToken, target.mUserId);
        return shadow;
    }

    private void finishAllActivity(int userId) {
        for (TaskRecord task : mTasks.values()) {
            for (ActivityRecord activity : task.activities) {
                if (activity.userId == userId) {
                    if (activity.finished) {
                        try {
                            assert activity.processRecord != null;
                            activity.processRecord.bActivityThread.finishActivity(activity.token);
                        } catch (RemoteException ignored) { }
                    }
                }
            }
        }
    }

    ActivityRecord newActivityRecord(Intent intent, ActivityInfo info, IBinder resultTo, int userId) {
        ActivityRecord targetRecord = ActivityRecord.create(intent, info, resultTo, userId);
        synchronized (mLaunchingActivities) {
            mLaunchingActivities.put(targetRecord.mBToken, targetRecord);
            Message obtain = Message.obtain(mHandler, LAUNCH_TIME_OUT, targetRecord.mBToken);
            mHandler.sendMessageDelayed(obtain, 15000);
        }
        return targetRecord;
    }

    private ActivityRecord findActivityRecordByComponentName(int userId, ComponentName componentName) {
        ActivityRecord record = null;
        for (TaskRecord next : mTasks.values()) {
            if (userId == next.userId) {
                for (ActivityRecord activity : next.activities) {
                    if (Objects.equals(activity.component, componentName)) {
                        record = activity;
                        break;
                    }
                }
            }
        }
        return record;
    }

    private ActivityRecord findActivityRecordByToken(int userId, IBinder token) {
        ActivityRecord record = null;
        if (token != null) {
            for (TaskRecord next : mTasks.values()) {
                if (userId == next.userId) {
                    for (ActivityRecord activity : next.activities) {
                        if (activity.token == token) {
                            record = activity;
                            break;
                        }
                    }
                }
            }
        }
        return record;
    }

    private TaskRecord findTaskRecordByTaskAffinityLocked(int userId, String taskAffinity) {
        synchronized (mTasks) {
            for (TaskRecord next : mTasks.values()) {
                if (userId == next.userId && next.taskAffinity.equals(taskAffinity)) {
                    return next;
                }
            }
            return null;
        }
    }

    public void onActivityCreated(ProcessRecord processRecord, int taskId, IBinder
            token, String activityToken) {
        ActivityRecord record = mLaunchingActivities.get(activityToken);
        if (record == null) {
            return;
        }

        synchronized (mLaunchingActivities) {
            mLaunchingActivities.remove(activityToken);
            mHandler.removeMessages(LAUNCH_TIME_OUT, activityToken);
        }

        synchronized (mTasks) {
            synchronizeTasks();
            TaskRecord taskRecord = mTasks.get(taskId);
            if (taskRecord == null) {
                taskRecord = new TaskRecord(taskId, record.userId, ComponentUtils.getTaskAffinity(Objects.requireNonNull(record.info)));
                taskRecord.rootIntent = record.intent;
                mTasks.put(taskId, taskRecord);
            }

            record.token = token;
            record.processRecord = processRecord;
            record.task = taskRecord;
            taskRecord.addTopActivity(record);
            Slog.d(TAG, "onActivityCreated : " + Objects.requireNonNull(record.component));
        }
    }

    // FIXME: Multiple activities belonged to same app.
    public void onActivityResumed(int userId, IBinder token) {
        synchronized (mTasks) {
            synchronizeTasks();
            ActivityRecord activityRecord = findActivityRecordByToken(userId, token);
            if (activityRecord == null) {
                return;
            }

            Slog.d(TAG, "onActivityResumed : " + Objects.requireNonNull(activityRecord.component));
            synchronized (Objects.requireNonNull(activityRecord.task).activities) {
                activityRecord.task.removeActivity(activityRecord);
                activityRecord.task.addTopActivity(activityRecord);
            }
        }
    }

    public void onActivityDestroyed(int userId, IBinder token) {
        synchronized (mTasks) {
            synchronizeTasks();
            ActivityRecord activityRecord = findActivityRecordByToken(userId, token);
            if (activityRecord == null) {
                return;
            }

            activityRecord.finished = true;
            Slog.d(TAG, "onActivityDestroyed : " + Objects.requireNonNull(activityRecord.component));
            synchronized (Objects.requireNonNull(activityRecord.task).activities) {
                activityRecord.task.removeActivity(activityRecord);
            }
        }
    }

    public void onFinishActivity(int userId, IBinder token) {
        synchronized (mTasks) {
            synchronizeTasks();
            ActivityRecord activityRecord = findActivityRecordByToken(userId, token);
            if (activityRecord == null) {
                return;
            }

            activityRecord.finished = true;
            Slog.d(TAG, "onFinishActivity : " + Objects.requireNonNull(activityRecord.component));
        }
    }

    public String getCallingPackage(IBinder token, int userId) {
        synchronized (mTasks) {
            synchronizeTasks();
            ActivityRecord activityRecordByToken = findActivityRecordByToken(userId, token);
            if (activityRecordByToken != null) {
                ActivityRecord resultTo = findActivityRecordByToken(userId, activityRecordByToken.resultTo);
                if (resultTo != null) {
                    return Objects.requireNonNull(resultTo.info).packageName;
                }
            }
            return BlackBoxCore.getHostPkg();
        }
    }

    public ComponentName getCallingActivity(IBinder token, int userId) {
        synchronized (mTasks) {
            synchronizeTasks();
            ActivityRecord activityRecordByToken = findActivityRecordByToken(userId, token);
            if (activityRecordByToken != null) {
                ActivityRecord resultTo = findActivityRecordByToken(userId, activityRecordByToken.resultTo);
                if (resultTo != null) {
                    return resultTo.component;
                }
            }
            return new ComponentName(BlackBoxCore.getHostPkg(), ProxyActivity.P0.class.getName());
        }
    }

    private void synchronizeTasks() {
        List<ActivityManager.RecentTaskInfo> recentTasks = mAms.getRecentTasks(100, 0);
        Map<Integer, TaskRecord> newTacks = new LinkedHashMap<>();

        for (int i = recentTasks.size() - 1; i >= 0; i--) {
            ActivityManager.RecentTaskInfo next = recentTasks.get(i);
            TaskRecord taskRecord = mTasks.get(next.id);
            if (taskRecord == null) {
                continue;
            }
            newTacks.put(next.id, taskRecord);
        }

        mTasks.clear();
        mTasks.putAll(newTacks);
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/am/BActivityManagerService.java`:

```java
package com.vcore.core.system.am;

import static android.content.pm.PackageManager.GET_META_DATA;

import android.app.ActivityManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.os.Binder;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.vcore.BlackBoxCore;
import com.vcore.core.system.BProcessManagerService;
import com.vcore.core.system.ISystemService;
import com.vcore.core.system.ProcessRecord;
import com.vcore.core.system.pm.BPackageManagerService;
import com.vcore.entity.AppConfig;
import com.vcore.entity.UnbindRecord;
import com.vcore.entity.am.PendingResultData;
import com.vcore.entity.am.ReceiverData;
import com.vcore.entity.am.RunningAppProcessInfo;
import com.vcore.entity.am.RunningServiceInfo;
import com.vcore.utils.Slog;

public class BActivityManagerService extends IBActivityManagerService.Stub implements ISystemService {
    public static final String TAG = "BActivityManagerService";
    private static final BActivityManagerService sService = new BActivityManagerService();
    private final Map<Integer, UserSpace> mUserSpace = new HashMap<>();
    private final BroadcastManager mBroadcastManager;

    public static BActivityManagerService get() {
        return sService;
    }

    public BActivityManagerService() {
        BPackageManagerService mPms = BPackageManagerService.get();
        this.mBroadcastManager = BroadcastManager.startSystem(mPms);
    }

    @Override
    public ComponentName startService(Intent intent, String resolvedType, boolean requireForeground, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mActiveServices) {
            userSpace.mActiveServices.startService(intent, resolvedType, userId);
        }
        return null;
    }

    @Override
    public IBinder acquireContentProviderClient(ProviderInfo providerInfo) {
        int callingPid = Binder.getCallingPid();
        ProcessRecord processRecord = BProcessManagerService.get().startProcessLocked(providerInfo.packageName, providerInfo.processName,
                BProcessManagerService.get().getUserIdByCallingPid(callingPid), -1, Binder.getCallingPid());
        if (processRecord == null) {
            throw new RuntimeException("Unable to create process " + providerInfo.name);
        }

        try {
            return processRecord.bActivityThread.acquireContentProviderClient(providerInfo);
        } catch (Throwable t) {
            t.printStackTrace();
            return null;
        }
    }

    @Override
    public Intent sendBroadcast(Intent intent, String resolvedType, int userId) {
        List<ResolveInfo> resolves = BPackageManagerService.get().queryBroadcastReceivers(intent, GET_META_DATA, resolvedType, userId);
        for (ResolveInfo resolve : resolves) {
            ProcessRecord processRecord = BProcessManagerService.get().findProcessRecord(resolve.activityInfo.packageName, resolve.activityInfo.processName, userId);
            if (processRecord == null) {
                continue;
            }

            try {
                processRecord.bActivityThread.bindApplication();
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }

        Intent shadow = new Intent();
        shadow.setPackage(BlackBoxCore.getHostPkg());
        shadow.setComponent(null);
        shadow.setAction(intent.getAction());
        return shadow;
    }

    @Override
    public IBinder peekService(Intent intent, String resolvedType, int userId) throws RemoteException {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mActiveServices) {
            return userSpace.mActiveServices.peekService(intent, resolvedType, userId);
        }
    }

    @Override
    public void onActivityCreated(int taskId, IBinder token, String activityToken) {
        int callingPid = Binder.getCallingPid();
        ProcessRecord process = BProcessManagerService.get().findProcessByPid(callingPid);
        if (process == null) {
            return;
        }

        // Crash by BinderProxy cast
        // ActivityRecord record = (ActivityRecord) activityRecord;
        UserSpace userSpace = getOrCreateSpaceLocked(process.userId);
        synchronized (userSpace.mStack) {
            userSpace.mStack.onActivityCreated(process, taskId, token, activityToken);
        }
    }

    @Override
    public void onActivityResumed(IBinder token) throws RemoteException {
        int callingPid = Binder.getCallingPid();
        ProcessRecord process = BProcessManagerService.get().findProcessByPid(callingPid);
        if (process == null) {
            return;
        }

        UserSpace userSpace = getOrCreateSpaceLocked(process.userId);
        synchronized (userSpace.mStack) {
            userSpace.mStack.onActivityResumed(process.userId, token);
        }
    }

    @Override
    public void onActivityDestroyed(IBinder token) throws RemoteException {
        int callingPid = Binder.getCallingPid();
        ProcessRecord process = BProcessManagerService.get().findProcessByPid(callingPid);
        if (process == null) {
            return;
        }

        UserSpace userSpace = getOrCreateSpaceLocked(process.userId);
        synchronized (userSpace.mStack) {
            userSpace.mStack.onActivityDestroyed(process.userId, token);
        }
    }

    @Override
    public void onFinishActivity(IBinder token) {
        int callingPid = Binder.getCallingPid();
        ProcessRecord process = BProcessManagerService.get().findProcessByPid(callingPid);
        if (process == null) {
            return;
        }

        UserSpace userSpace = getOrCreateSpaceLocked(process.userId);
        synchronized (userSpace.mStack) {
            userSpace.mStack.onFinishActivity(process.userId, token);
        }
    }

    @Override
    public RunningAppProcessInfo getRunningAppProcesses(String callerPackage, int userId) {
        ActivityManager manager = (ActivityManager) BlackBoxCore.getContext().getSystemService(Context.ACTIVITY_SERVICE);
        List<ActivityManager.RunningAppProcessInfo> runningAppProcesses = manager.getRunningAppProcesses();
        Map<Integer, ActivityManager.RunningAppProcessInfo> runningProcessMap = new HashMap<>();

        for (ActivityManager.RunningAppProcessInfo runningProcess : runningAppProcesses) {
            runningProcessMap.put(runningProcess.pid, runningProcess);
        }

        List<ProcessRecord> packageProcessAsUser = BProcessManagerService.get().getPackageProcessAsUser(callerPackage, userId);
        RunningAppProcessInfo appProcessInfo = new RunningAppProcessInfo();
        for (ProcessRecord processRecord : packageProcessAsUser) {
            ActivityManager.RunningAppProcessInfo runningAppProcessInfo = runningProcessMap.get(processRecord.pid);
            if (runningAppProcessInfo != null) {
                runningAppProcessInfo.processName = processRecord.processName;
                appProcessInfo.mAppProcessInfoList.add(runningAppProcessInfo);
            }
        }
        return appProcessInfo;
    }

    @Override
    public RunningServiceInfo getRunningServices(String callerPackage, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        return userSpace.mActiveServices.getRunningServiceInfo(callerPackage, userId);
    }

    @Override
    public void scheduleBroadcastReceiver(Intent intent, PendingResultData pendingResultData, int userId) throws RemoteException {
        List<ResolveInfo> resolves = BPackageManagerService.get().queryBroadcastReceivers(intent, GET_META_DATA, null, userId);
        if (resolves.isEmpty()) {
            pendingResultData.build().finish();
            Slog.d(TAG, "scheduleBroadcastReceiver empty");
            return;
        }

        mBroadcastManager.sendBroadcast(pendingResultData);
        for (ResolveInfo resolve : resolves) {
            ProcessRecord processRecord = BProcessManagerService.get().findProcessRecord(resolve.activityInfo.packageName, resolve.activityInfo.processName, userId);
            if (processRecord != null) {
                ReceiverData data = new ReceiverData();
                data.intent = intent;
                data.activityInfo = resolve.activityInfo;
                data.data = pendingResultData;
                processRecord.bActivityThread.scheduleReceiver(data);
            }
        }
    }

    @Override
    public void finishBroadcast(PendingResultData data) {
        mBroadcastManager.finishBroadcast(data);
    }

    @Override
    public String getCallingPackage(IBinder token, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mStack) {
            return userSpace.mStack.getCallingPackage(token, userId);
        }
    }

    @Override
    public ComponentName getCallingActivity(IBinder token, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mStack) {
            return userSpace.mStack.getCallingActivity(token, userId);
        }
    }

    @Override
    public void getIntentSender(IBinder target, String packageName, int uid, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mIntentSenderRecords) {
            PendingIntentRecord record = new PendingIntentRecord();
            record.uid = uid;
            record.packageName = packageName;
            userSpace.mIntentSenderRecords.put(target, record);
        }
    }

    @Override
    public String getPackageForIntentSender(IBinder target, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mIntentSenderRecords) {
            PendingIntentRecord record = userSpace.mIntentSenderRecords.get(target);
            if (record != null) {
                return record.packageName;
            }
        }
        return null;
    }

    @Override
    public int getUidForIntentSender(IBinder target, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mIntentSenderRecords) {
            PendingIntentRecord record = userSpace.mIntentSenderRecords.get(target);
            if (record != null) {
                return record.uid;
            }
        }
        return -1;
    }

    @Override
    public UnbindRecord onServiceUnbind(Intent proxyIntent, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mActiveServices) {
            return userSpace.mActiveServices.onServiceUnbind(proxyIntent);
        }
    }

    @Override
    public void onServiceDestroy(Intent proxyIntent, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mActiveServices) {
            userSpace.mActiveServices.onServiceDestroy(proxyIntent);
        }
    }

    @Override
    public int stopService(Intent intent, String resolvedType, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mActiveServices) {
            return userSpace.mActiveServices.stopService(intent, resolvedType, userId);
        }
    }

    @Override
    public Intent bindService(Intent service, IBinder binder, String resolvedType, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mActiveServices) {
            return userSpace.mActiveServices.bindService(service, binder, resolvedType, userId);
        }
    }

    @Override
    public void unbindService(IBinder binder, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mActiveServices) {
            userSpace.mActiveServices.unbindService(binder);
        }
    }

    @Override
    public void stopServiceToken(ComponentName className, IBinder token, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mActiveServices) {
            userSpace.mActiveServices.stopServiceToken(token, userId);
        }
    }

    @Override
    public AppConfig initProcess(String packageName, String processName, int userId) {
        ProcessRecord processRecord = BProcessManagerService.get().startProcessLocked(packageName, processName, userId, -1, Binder.getCallingPid());
        if (processRecord == null) {
            return null;
        }
        return processRecord.getClientConfig();
    }

    @Override
    public void restartProcess(String packageName, String processName, int userId) {
        BProcessManagerService.get().restartAppProcess(packageName, processName, userId);
    }

    @Override
    public void startActivity(Intent intent, int userId) {
        UserSpace userSpace = getOrCreateSpaceLocked(userId);
        synchronized (userSpace.mStack) {
            userSpace.mStack.startActivityLocked(userId, intent, null, null, null, -1, -1, null);
        }
    }

    @Override
    public int startActivityAms(int userId, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags, Bundle options) {
        UserSpace space = getOrCreateSpaceLocked(userId);
        synchronized (space.mStack) {
            return space.mStack.startActivityLocked(userId, intent, resolvedType, resultTo, resultWho, requestCode, flags, options);
        }
    }

    @Override
    public int startActivities(int userId, Intent[] intent, String[] resolvedType, IBinder resultTo, Bundle options) {
        UserSpace space = getOrCreateSpaceLocked(userId);
        synchronized (space.mStack) {
            return space.mStack.startActivitiesLocked(userId, intent, resolvedType, resultTo, options);
        }
    }

    private UserSpace getOrCreateSpaceLocked(int userId) {
        synchronized (mUserSpace) {
            UserSpace userSpace = mUserSpace.get(userId);
            if (userSpace != null) {
                return userSpace;
            }

            userSpace = new UserSpace();
            mUserSpace.put(userId, userSpace);
            return userSpace;
        }
    }

    @Override
    public void systemReady() {
        mBroadcastManager.startup();
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/am/BJobManagerService.java`:

```java
package com.vcore.core.system.am;

import android.app.job.JobInfo;
import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.pm.ServiceInfo;
import android.os.Binder;
import android.os.RemoteException;

import java.util.HashMap;
import java.util.Map;

import com.vcore.BlackBoxCore;
import com.vcore.core.system.BProcessManagerService;
import com.vcore.core.system.ISystemService;
import com.vcore.core.system.ProcessRecord;
import com.vcore.core.system.pm.BPackageManagerService;
import com.vcore.entity.JobRecord;
import com.vcore.proxy.ProxyManifest;



public class BJobManagerService extends IBJobManagerService.Stub implements ISystemService {
    private static final BJobManagerService sService = new BJobManagerService();

    private final Map<String, JobRecord> mJobRecords = new HashMap<>();

    public static BJobManagerService get() {
        return sService;
    }

    @Override
    public JobInfo schedule(JobInfo info, int userId) {
        ComponentName componentName = info.getService();
        Intent intent = new Intent();
        intent.setComponent(componentName);
        ResolveInfo resolveInfo = BPackageManagerService.get().resolveService(intent, PackageManager.GET_META_DATA, null, userId);
        if (resolveInfo == null) {
            return info;
        }

        ServiceInfo serviceInfo = resolveInfo.serviceInfo;
        ProcessRecord processRecord = BProcessManagerService.get().findProcessRecord(serviceInfo.packageName, serviceInfo.processName, userId);
        if (processRecord == null) {
            processRecord = BProcessManagerService.get().startProcessLocked(serviceInfo.packageName, serviceInfo.processName, userId,
                    -1, Binder.getCallingPid());
            if (processRecord == null) {
                throw new RuntimeException("Unable to create Process " + serviceInfo.processName);
            }
        }
        return scheduleJob(processRecord, info, serviceInfo);
    }

    @Override
    public JobRecord queryJobRecord(String processName, int jobId, int userId) {
        return mJobRecords.get(formatKey(processName, jobId));
    }

    public JobInfo scheduleJob(ProcessRecord processRecord, JobInfo info, ServiceInfo serviceInfo) {
        JobRecord jobRecord = new JobRecord();
        jobRecord.mJobInfo = info;
        jobRecord.mServiceInfo = serviceInfo;

        mJobRecords.put(formatKey(processRecord.processName, info.getId()), jobRecord);
        black.android.app.job.JobInfo.service.set(info, new ComponentName(BlackBoxCore.getHostPkg(), ProxyManifest.getProxyJobService(processRecord.bPID)));
        return info;
    }

    @Override
    public void cancelAll(String processName, int userId) { }

    @Override
    public int cancel(String processName, int jobId, int userId) throws RemoteException {
        return jobId;
    }

    private String formatKey(String processName, int jobId) {
        return processName + "_" + jobId;
    }

    @Override
    public void systemReady() { }
}

```

`Bcore/src/main/java/com/vcore/core/system/am/BroadcastManager.java`:

```java
package com.vcore.core.system.am;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.vcore.BlackBoxCore;
import com.vcore.core.system.pm.BPackage;
import com.vcore.core.system.pm.BPackageManagerService;
import com.vcore.core.system.pm.BPackageSettings;
import com.vcore.core.system.pm.PackageMonitor;
import com.vcore.entity.am.PendingResultData;
import com.vcore.proxy.ProxyBroadcastReceiver;
import com.vcore.utils.Slog;

public class BroadcastManager implements PackageMonitor {
    public static final String TAG = "BroadcastManager";
    public static final int TIMEOUT = 9000;
    public static final int MSG_TIME_OUT = 1;
    private static volatile BroadcastManager sBroadcastManager;

    private final BPackageManagerService mPms;
    private final Map<String, List<BroadcastReceiver>> mReceivers = new HashMap<>();
    private final Map<String, PendingResultData> mReceiversData = new HashMap<>();

    private final Handler mHandler = new Handler(Looper.getMainLooper()) {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            if (msg.what == MSG_TIME_OUT) {
                try {
                    PendingResultData data = (PendingResultData) msg.obj;
                    data.build().finish();
                    Slog.d(TAG, "Timeout Receiver: " + data);
                } catch (Throwable ignore) { }
            }
        }
    };

    public static BroadcastManager startSystem(BPackageManagerService pms) {
        if (sBroadcastManager == null) {
            synchronized (BroadcastManager.class) {
                if (sBroadcastManager == null) {
                    sBroadcastManager = new BroadcastManager(pms);
                }
            }
        }
        return sBroadcastManager;
    }

    public BroadcastManager(BPackageManagerService pms) {
        this.mPms = pms;
    }

    public void startup() {
        mPms.addPackageMonitor(this);
        List<BPackageSettings> bPackageSettings = mPms.getBPackageSettings();
        for (BPackageSettings bPackageSetting : bPackageSettings) {
            BPackage bPackage = bPackageSetting.pkg;
            registerPackage(bPackage);
        }
    }

    private void registerPackage(BPackage bPackage) {
        synchronized (mReceivers) {
            Slog.d(TAG, "register: " + bPackage.packageName + ", size: " + bPackage.receivers.size());
            for (BPackage.Activity receiver : bPackage.receivers) {
                List<BPackage.ActivityIntentInfo> intents = receiver.intents;
                for (BPackage.ActivityIntentInfo intent : intents) {
                    ProxyBroadcastReceiver proxyBroadcastReceiver = new ProxyBroadcastReceiver();
                    BlackBoxCore.getContext().registerReceiver(proxyBroadcastReceiver, intent.intentFilter, Context.RECEIVER_NOT_EXPORTED);
                    addReceiver(bPackage.packageName, proxyBroadcastReceiver);
                }
            }
        }
    }

    private void addReceiver(String packageName, BroadcastReceiver receiver) {
        List<BroadcastReceiver> broadcastReceivers = mReceivers.get(packageName);
        if (broadcastReceivers == null) {
            broadcastReceivers = new ArrayList<>();
            mReceivers.put(packageName, broadcastReceivers);
        }
        broadcastReceivers.add(receiver);
    }

    public void sendBroadcast(PendingResultData pendingResultData) {
        synchronized (mReceiversData) {
            mReceiversData.put(pendingResultData.mBToken, pendingResultData);
            Message obtain = Message.obtain(mHandler, MSG_TIME_OUT, pendingResultData);
            mHandler.sendMessageDelayed(obtain, TIMEOUT);
        }
    }

    public void finishBroadcast(PendingResultData data) {
        synchronized (mReceiversData) {
            mHandler.removeMessages(MSG_TIME_OUT, mReceiversData.get(data.mBToken));
        }
    }

    @Override
    public void onPackageUninstalled(String packageName, boolean removeApp, int userId) {
        if (removeApp) {
            synchronized (mReceivers) {
                List<BroadcastReceiver> broadcastReceivers = mReceivers.get(packageName);
                if (broadcastReceivers != null) {
                    Slog.d(TAG, "unregisterReceiver Package: " + packageName + ", size: " + broadcastReceivers.size());
                    for (BroadcastReceiver broadcastReceiver : broadcastReceivers) {
                        try {
                            BlackBoxCore.getContext().unregisterReceiver(broadcastReceiver);
                        } catch (Throwable ignored) { }
                    }
                }
                mReceivers.remove(packageName);
            }
        }
    }

    @Override
    public void onPackageInstalled(String packageName, int userId) {
        synchronized (mReceivers) {
            mReceivers.remove(packageName);
            BPackageSettings bPackageSetting = mPms.getBPackageSetting(packageName);
            if (bPackageSetting != null) {
                registerPackage(bPackageSetting.pkg);
            }
        }
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/am/PendingIntentRecord.java`:

```java
package com.vcore.core.system.am;

import java.util.Objects;

public class PendingIntentRecord {
    public int uid;
    public String packageName;

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }

        if (!(o instanceof PendingIntentRecord)) {
            return false;
        }

        PendingIntentRecord that = (PendingIntentRecord) o;
        return uid == that.uid && Objects.equals(packageName, that.packageName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(uid, packageName);
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/am/TaskRecord.java`:

```java
package com.vcore.core.system.am;

import android.content.Intent;

import java.util.LinkedList;
import java.util.List;




public class TaskRecord {
    public final int id;
    public final int userId;
    public final String taskAffinity;
    public Intent rootIntent;
    public final List<ActivityRecord> activities = new LinkedList<>();

    public TaskRecord(int id, int userId, String taskAffinity) {
        this.id = id;
        this.userId = userId;
        this.taskAffinity = taskAffinity;
    }

    public boolean needNewTask() {
        for (ActivityRecord activity : activities) {
            if (!activity.finished) {
                return false;
            }
        }
        return true;
    }

    public void addTopActivity(ActivityRecord record) {
        activities.add(record);
    }

    public void removeActivity(ActivityRecord record) {
        activities.remove(record);
    }

    public ActivityRecord getTopActivityRecord() {
        for (int i = activities.size() - 1; i >= 0; i--) {
            ActivityRecord activityRecord = activities.get(i);
            if (!activityRecord.finished) {
                return activityRecord;
            }
        }
        return null;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/am/UserSpace.java`:

```java
package com.vcore.core.system.am;

import android.os.IBinder;

import java.util.HashMap;
import java.util.Map;

public class UserSpace {
    // 单实例
    public final ActiveServices mActiveServices = new ActiveServices();
    // 单实例
    public final ActivityStack mStack = new ActivityStack();
    public final Map<IBinder, PendingIntentRecord> mIntentSenderRecords = new HashMap<>();
}

```

`Bcore/src/main/java/com/vcore/core/system/location/BLocationManagerService.java`:

```java
package com.vcore.core.system.location;

import android.os.IBinder;
import android.os.IInterface;
import android.os.Parcel;
import android.os.RemoteException;
import android.util.AtomicFile;
import android.util.SparseArray;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

import black.android.location.ILocationListener;
import com.vcore.BlackBoxCore;
import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.ISystemService;
import com.vcore.entity.location.BCell;
import com.vcore.entity.location.BLocation;
import com.vcore.entity.location.BLocationConfig;
import com.vcore.fake.frameworks.BLocationManager;
import com.vcore.utils.CloseUtils;
import com.vcore.utils.FileUtils;
import com.vcore.utils.Slog;

/**
 * Fake location
 * plan1: only GPS invocation is valid and other methods like addressed by cells are intercepted at all.
 * plan2: mock fake neighboring cells from LBS database and modify the result of GPS invocation.
 * plan3: cheat internal application at being given permission to access location information but get data from BB.
 * the final testing condition requires UI demo.
 * Created by BlackBoxing on 3/8/22.
 **/
public class BLocationManagerService extends IBLocationManagerService.Stub implements ISystemService {
    public static final String TAG = "BLocationManagerService";

    private static final BLocationManagerService sService = new BLocationManagerService();
    private final SparseArray<HashMap<String, BLocationConfig>> mLocationConfigs = new SparseArray<>();
    private final BLocationConfig mGlobalConfig = new BLocationConfig();
    private final Map<IBinder, LocationRecord> mLocationListeners = new HashMap<>();
    private final Executor mThreadPool = Executors.newCachedThreadPool();

    public static BLocationManagerService get() {
        return sService;
    }

    private BLocationConfig getOrCreateConfig(int userId, String pkg) {
        synchronized (mLocationConfigs) {
            HashMap<String, BLocationConfig> pkgs = mLocationConfigs.get(userId);
            if (pkgs == null) {
                pkgs = new HashMap<>();
                mLocationConfigs.put(userId, pkgs);
            }

            BLocationConfig config = pkgs.get(pkg);
            if (config == null) {
                config = new BLocationConfig();
                config.pattern = BLocationManager.CLOSE_MODE;
                pkgs.put(pkg, config);
            }
            return config;
        }
    }

    public int getPattern(int userId, String pkg) {
        synchronized (mLocationConfigs) {
            BLocationConfig config = getOrCreateConfig(userId, pkg);
            return config.pattern;
        }
    }

    @Override
    public void setPattern(int userId, String pkg, int pattern) {
        synchronized (mLocationConfigs) {
            getOrCreateConfig(userId, pkg).pattern = pattern;
            save();
        }
    }

    @Override
    public void setCell(int userId, String pkg, BCell cell) {
        synchronized (mLocationConfigs) {
            getOrCreateConfig(userId, pkg).cell = cell;
            save();
        }
    }

    @Override
    public void setAllCell(int userId, String pkg, List<BCell> cells) {
        synchronized (mLocationConfigs) {
            getOrCreateConfig(userId, pkg).allCell = cells;
            save();
        }
    }

    @Override
    public void setNeighboringCell(int userId, String pkg, List<BCell> cells) {
        synchronized (mLocationConfigs) {
            getOrCreateConfig(userId, pkg).allCell = cells;
            save();
        }
    }

    @Override
    public List<BCell> getNeighboringCell(int userId, String pkg) {
        synchronized (mLocationConfigs) {
            return getOrCreateConfig(userId, pkg).allCell;
        }
    }

    @Override
    public void setGlobalCell(BCell cell) {
        synchronized (mGlobalConfig) {
            mGlobalConfig.cell = cell;
            save();
        }
    }

    @Override
    public void setGlobalAllCell(List<BCell> cells) {
        synchronized (mGlobalConfig) {
            mGlobalConfig.allCell = cells;
            save();
        }
    }

    @Override
    public void setGlobalNeighboringCell(List<BCell> cells) {
        synchronized (mGlobalConfig) {
            mGlobalConfig.neighboringCellInfo = cells;
            save();
        }
    }

    @Override
    public List<BCell> getGlobalNeighboringCell() {
        synchronized (mGlobalConfig) {
            return mGlobalConfig.neighboringCellInfo;
        }
    }

    @Override
    public BCell getCell(int userId, String pkg) {
        BLocationConfig config = getOrCreateConfig(userId, pkg);
        switch (config.pattern) {
            case BLocationManager.OWN_MODE:
                return config.cell;
            case BLocationManager.GLOBAL_MODE:
                return mGlobalConfig.cell;
            case BLocationManager.CLOSE_MODE:
            default:
                return null;
        }
    }

    @Override
    public List<BCell> getAllCell(int userId, String pkg) {
        BLocationConfig config = getOrCreateConfig(userId, pkg);
        switch (config.pattern) {
            case BLocationManager.OWN_MODE:
                return config.allCell;
            case BLocationManager.GLOBAL_MODE:
                return mGlobalConfig.allCell;
            case BLocationManager.CLOSE_MODE:
            default:
                return null;
        }
    }

    @Override
    public void setLocation(int userId, String pkg, BLocation location) {
        synchronized (mLocationConfigs) {
            getOrCreateConfig(userId, pkg).location = location;
            save();
        }
    }

    @Override
    public BLocation getLocation(int userId, String pkg) {
        BLocationConfig config = getOrCreateConfig(userId, pkg);
        switch (config.pattern) {
            case BLocationManager.OWN_MODE:
                return config.location;
            case BLocationManager.GLOBAL_MODE:
                return mGlobalConfig.location;
            case BLocationManager.CLOSE_MODE:
            default:
                return null;
        }
    }

    @Override
    public void setGlobalLocation(BLocation location) {
        synchronized (mGlobalConfig) {
            mGlobalConfig.location = location;
            save();
        }
    }

    @Override
    public BLocation getGlobalLocation() {
        synchronized (mGlobalConfig) {
            return mGlobalConfig.location;
        }
    }

    @Override
    public void requestLocationUpdates(IBinder listener, String packageName, int userId) throws RemoteException {
        if (listener == null || !listener.pingBinder()) {
            return;
        }

        if (mLocationListeners.containsKey(listener)) {
            return;
        }

        listener.linkToDeath(new DeathRecipient() {
            @Override
            public void binderDied() {
                listener.unlinkToDeath(this, 0);
                mLocationListeners.remove(listener);
            }
        }, 0);
        LocationRecord record = new LocationRecord(packageName, userId);
        mLocationListeners.put(listener, record);
        addTask(listener);
    }

    @Override
    public void removeUpdates(IBinder listener) throws RemoteException {
        if (listener == null || !listener.pingBinder()) {
            return;
        }
        mLocationListeners.remove(listener);
    }

    private void addTask(IBinder locationListener) {
        mThreadPool.execute(() -> {
            BLocation lastLocation = null;
            long l = System.currentTimeMillis();

            while (locationListener.pingBinder()) {
                IInterface iInterface = ILocationListener.Stub.asInterface.call(locationListener);
                LocationRecord locationRecord = mLocationListeners.get(locationListener);
                if (locationRecord == null) {
                    continue;
                }

                BLocation location = getLocation(locationRecord.userId, locationRecord.packageName);
                if (location == null) {
                    continue;
                }

                if (location.equals(lastLocation) && (System.currentTimeMillis() - l) < 3000) {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException ignored) { }
                    continue;
                }

                lastLocation = location;
                l = System.currentTimeMillis();
                BlackBoxCore.get().getHandler().post(() -> ILocationListener.onLocationChanged.call(iInterface, location.convert2SystemLocation()));
            }
        });
    }

    public void save() {
        synchronized (mGlobalConfig) {
            synchronized (mLocationConfigs) {
                Parcel parcel = Parcel.obtain();
                AtomicFile atomicFile = new AtomicFile(BEnvironment.getFakeLocationConf());
                FileOutputStream fileOutputStream = null;

                try {
                    mGlobalConfig.writeToParcel(parcel, 0);
                    parcel.writeInt(mLocationConfigs.size());

                    for (int i = 0; i < mLocationConfigs.size(); i++) {
                        int tmpUserId = mLocationConfigs.keyAt(i);
                        HashMap<String, BLocationConfig> configArrayMap = mLocationConfigs.valueAt(i);
                        parcel.writeInt(tmpUserId);
                        parcel.writeMap(configArrayMap);
                    }

                    parcel.setDataPosition(0);
                    fileOutputStream = atomicFile.startWrite();
                    FileUtils.writeParcelToOutput(parcel, fileOutputStream);
                    atomicFile.finishWrite(fileOutputStream);
                } catch (Throwable e) {
                    e.printStackTrace();
                    atomicFile.failWrite(fileOutputStream);
                } finally {
                    parcel.recycle();
                    CloseUtils.close(fileOutputStream);
                }
            }
        }
    }

    public void loadConfig() {
        Parcel parcel = Parcel.obtain();
        InputStream is = null;

        try {
            File fakeLocationConf = BEnvironment.getFakeLocationConf();
            if (!fakeLocationConf.exists()) {
                return;
            }

            is = new FileInputStream(BEnvironment.getFakeLocationConf());
            byte[] bytes = FileUtils.toByteArray(is);
            parcel.unmarshall(bytes, 0, bytes.length);
            parcel.setDataPosition(0);

            synchronized (mGlobalConfig) {
                mGlobalConfig.refresh(parcel);
            }

            synchronized (mLocationConfigs) {
                mLocationConfigs.clear();

                int size = parcel.readInt();
                for (int i = 0; i < size; i++) {
                    int userId = parcel.readInt();
                    HashMap<String, BLocationConfig> configArrayMap = parcel.readHashMap(BLocationConfig.class.getClassLoader());
                    mLocationConfigs.put(userId, configArrayMap);
                    Slog.d(TAG, "load userId: " + userId + ", config: " + configArrayMap);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            Slog.d(TAG, "bad config");
            FileUtils.deleteDir(BEnvironment.getFakeLocationConf());
        } finally {
            parcel.recycle();
            CloseUtils.close(is);
        }
    }

    @Override
    public void systemReady() {
        loadConfig();
        for (IBinder iBinder : mLocationListeners.keySet()) {
            addTask(iBinder);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/location/LocationRecord.java`:

```java
package com.vcore.core.system.location;

public class LocationRecord {
    public final String packageName;
    public final int userId;

    public LocationRecord(String packageName, int userId) {
        this.packageName = packageName;
        this.userId = userId;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/notification/BNotificationManagerService.java`:

```java
package com.vcore.core.system.notification;

import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationChannelGroup;
import android.app.NotificationManager;
import android.content.Context;
import android.os.Binder;
import android.os.Build;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import black.android.app.NotificationO;
import com.vcore.BlackBoxCore;
import com.vcore.core.system.BProcessManagerService;
import com.vcore.core.system.ISystemService;
import com.vcore.core.system.ProcessRecord;
import com.vcore.utils.compat.BuildCompat;

public class BNotificationManagerService extends IBNotificationManagerService.Stub implements ISystemService {
    private final static BNotificationManagerService sService = new BNotificationManagerService();
    public static final String CHANNEL_BLACK = "@black-";
    public static final String GROUP_BLACK = "@black-group-";
    private final Map<String, NotificationRecord> mNotificationRecords = new HashMap<>();

    private final NotificationManager mRealNotificationManager = (NotificationManager) BlackBoxCore.getContext().getSystemService(Context.NOTIFICATION_SERVICE);

    public static BNotificationManagerService get() {
        return sService;
    }

    @Override
    public void systemReady() { }

    private NotificationRecord getNotificationRecord(String packageName, int userId) {
        String key = packageName + "-" + userId;
        synchronized (mNotificationRecords) {
            NotificationRecord notificationRecord = mNotificationRecords.get(key);
            if (notificationRecord == null) {
                notificationRecord = new NotificationRecord();
                mNotificationRecords.put(key, notificationRecord);
            }
            return notificationRecord;
        }
    }

    private void removeNotificationRecord(String packageName, int userId) {
        String key = packageName + "-" + userId;
        synchronized (mNotificationRecords) {
            mNotificationRecords.remove(key);
        }
    }

    @Override
    @TargetApi(Build.VERSION_CODES.O)
    public NotificationChannel getNotificationChannel(String channelId, int userId) {
        int callingPid = getCallingPid();
        ProcessRecord processByPid = BProcessManagerService.get().findProcessByPid(callingPid);
        if (processByPid == null) {
            return null;
        }

        NotificationRecord notificationRecord = getNotificationRecord(processByPid.getPackageName(), userId);
        synchronized (notificationRecord.mNotificationChannels) {
            return notificationRecord.mNotificationChannels.get(channelId);
        }
    }

    @Override
    public List<NotificationChannel> getNotificationChannels(String packageName, int userId) {
        NotificationRecord notificationRecord = getNotificationRecord(packageName, userId);
        synchronized (notificationRecord.mNotificationChannels) {
            return new ArrayList<>(notificationRecord.mNotificationChannels.values());
        }
    }

    @Override
    public List<NotificationChannelGroup> getNotificationChannelGroups(String packageName, int userId) {
        NotificationRecord notificationRecord = getNotificationRecord(packageName, userId);
        synchronized (notificationRecord.mNotificationChannelGroups) {
            return new ArrayList<>(notificationRecord.mNotificationChannelGroups.values());
        }
    }

    @Override
    @TargetApi(Build.VERSION_CODES.O)
    public void createNotificationChannel(NotificationChannel notificationChannel, int userId) {
        int callingPid = getCallingPid();
        ProcessRecord processByPid = BProcessManagerService.get().findProcessByPid(callingPid);
        if (processByPid == null) {
            return;
        }

        handleNotificationChannel(notificationChannel, userId);
        mRealNotificationManager.createNotificationChannel(notificationChannel);

        resetNotificationChannel(notificationChannel);
        NotificationRecord notificationRecord = getNotificationRecord(processByPid.getPackageName(), userId);
        synchronized (notificationRecord.mNotificationChannels) {
            notificationRecord.mNotificationChannels.put(notificationChannel.getId(), notificationChannel);
        }
    }

    @Override
    @TargetApi(Build.VERSION_CODES.O)
    public void deleteNotificationChannel(String channelId, int userId) {
        int callingPid = getCallingPid();
        ProcessRecord processByPid = BProcessManagerService.get().findProcessByPid(callingPid);
        if (processByPid == null) {
            return;
        }

        NotificationRecord notificationRecord = getNotificationRecord(processByPid.getPackageName(), userId);
        synchronized (notificationRecord.mNotificationChannels) {
            NotificationChannel remove = notificationRecord.mNotificationChannels.remove(channelId);
            if (remove != null) {
                String blackChannelId = getBlackChannelId(remove.getId(), userId);
                mRealNotificationManager.deleteNotificationChannel(blackChannelId);
            }
        }
    }

    @Override
    @TargetApi(Build.VERSION_CODES.O)
    public void createNotificationChannelGroup(NotificationChannelGroup notificationChannelGroup, int userId) {
        int callingPid = getCallingPid();
        ProcessRecord processByPid = BProcessManagerService.get().findProcessByPid(callingPid);
        if (processByPid == null) {
            return;
        }

        handleNotificationGroup(notificationChannelGroup, userId);
        mRealNotificationManager.createNotificationChannelGroup(notificationChannelGroup);

        resetNotificationGroup(notificationChannelGroup);
        NotificationRecord notificationRecord = getNotificationRecord(processByPid.getPackageName(), userId);
        synchronized (notificationRecord.mNotificationChannelGroups) {
            notificationRecord.mNotificationChannelGroups.put(notificationChannelGroup.getId(), notificationChannelGroup);
        }
    }

    @Override
    @TargetApi(Build.VERSION_CODES.O)
    public void deleteNotificationChannelGroup(String groupId, int userId) {
        int callingPid = getCallingPid();
        ProcessRecord processByPid = BProcessManagerService.get().findProcessByPid(callingPid);
        if (processByPid == null) {
            return;
        }

        NotificationRecord notificationRecord = getNotificationRecord(processByPid.getPackageName(), userId);
        synchronized (notificationRecord.mNotificationChannelGroups) {
            NotificationChannelGroup remove = notificationRecord.mNotificationChannelGroups.remove(groupId);
            if (remove != null) {
                String blackGroupId = getBlackGroupId(remove.getId(), userId);
                mRealNotificationManager.deleteNotificationChannelGroup(blackGroupId);
            }
        }
    }

    @Override
    public void enqueueNotificationWithTag(int id, String tag, Notification notification, int userId) {
        ProcessRecord processByPid = BProcessManagerService.get().findProcessByPid(Binder.getCallingPid());
        if (processByPid == null) {
            return;
        }

        int notificationId = getNotificationId(userId, id, processByPid.getPackageName());
        if (BuildCompat.isOreo()) {
            if (NotificationO.mChannelId != null) {
                String blackChannelId = getBlackChannelId(NotificationO.mChannelId.get(), userId);
                NotificationO.mChannelId.set(blackChannelId);
            }
			
            if (NotificationO.mGroupKey != null) {
                String blackGroupId = getBlackGroupId(NotificationO.mGroupKey.get(), userId);
                NotificationO.mGroupKey.set(blackGroupId);
            }
        }

        NotificationRecord notificationRecord = getNotificationRecord(processByPid.getPackageName(), userId);
        synchronized (notificationRecord.mIds) {
            notificationRecord.mIds.add(notificationId);
        }
        mRealNotificationManager.notify(notificationId, notification);
    }

    @Override
    public void cancelNotificationWithTag(int id, String tag, int userId) {
        ProcessRecord processByPid = BProcessManagerService.get().findProcessByPid(Binder.getCallingPid());
        if (processByPid == null) {
            return;
        }

        int notificationId = getNotificationId(userId, id, processByPid.getPackageName());
        mRealNotificationManager.cancel(notificationId);

        NotificationRecord notificationRecord = getNotificationRecord(processByPid.getPackageName(), userId);
        synchronized (notificationRecord.mIds) {
            notificationRecord.mIds.remove(notificationId);
        }
    }

    @TargetApi(Build.VERSION_CODES.O)
    private void handleNotificationChannel(NotificationChannel notificationChannel, int userId) {
        String channelId = black.android.app.NotificationChannel.mId.get(notificationChannel);
        String blackChannelId = getBlackChannelId(channelId, userId);

        black.android.app.NotificationChannel.mId.set(notificationChannel, blackChannelId);
        notificationChannel.setGroup(getBlackGroupId(notificationChannel.getGroup(), userId));
    }

    private void resetNotificationChannel(NotificationChannel notificationChannel) {
        String channelId = black.android.app.NotificationChannel.mId.get(notificationChannel);
        String realChannelId = getRealChannelId(channelId);
        black.android.app.NotificationChannel.mId.set(notificationChannel, realChannelId);
    }

    private void handleNotificationGroup(NotificationChannelGroup notificationChannelGroup, int userId) {
        String groupId = black.android.app.NotificationChannelGroup.mId.get(notificationChannelGroup);
        String blackGroupId = getBlackGroupId(groupId, userId);
        black.android.app.NotificationChannelGroup.mId.set(notificationChannelGroup, blackGroupId);

        List<NotificationChannel> notificationChannels = black.android.app.NotificationChannelGroup.mChannels.get(notificationChannelGroup);
        if (notificationChannels != null) {
            for (NotificationChannel notificationChannel : notificationChannels) {
                createNotificationChannel(notificationChannel, userId);
            }
        }
    }

    private void resetNotificationGroup(NotificationChannelGroup notificationChannelGroup) {
        String groupId = black.android.app.NotificationChannelGroup.mId.get(notificationChannelGroup);
        String realGroupId = getRealGroupId(groupId);
        black.android.app.NotificationChannelGroup.mId.set(notificationChannelGroup, realGroupId);

        List<NotificationChannel> notificationChannels = black.android.app.NotificationChannelGroup.mChannels.get(notificationChannelGroup);
        if (notificationChannels != null) {
            for (NotificationChannel notificationChannel : notificationChannels) {
                resetNotificationChannel(notificationChannel);
            }
        }
    }

    @SuppressLint("NewApi")
    public void deletePackageNotification(String packageName, int userId) {
        NotificationRecord notificationRecord = getNotificationRecord(packageName, userId);
        if (BuildCompat.isOreo()) {
            for (NotificationChannelGroup value : notificationRecord.mNotificationChannelGroups.values()) {
                String blackGroupId = getBlackGroupId(value.getId(), userId);
                mRealNotificationManager.deleteNotificationChannelGroup(blackGroupId);
            }

            for (NotificationChannel value : notificationRecord.mNotificationChannels.values()) {
                String blackChannelId = getBlackChannelId(value.getId(), userId);
                mRealNotificationManager.deleteNotificationChannel(blackChannelId);
            }
        }

        for (Integer id : notificationRecord.mIds) {
            mRealNotificationManager.cancel(id);
        }
        removeNotificationRecord(packageName, userId);
    }

    private String getBlackChannelId(String channelId, int userId) {
        if (channelId == null || channelId.contains(CHANNEL_BLACK)) {
            return channelId;
        }
        return channelId + CHANNEL_BLACK + userId;
    }

    private String getRealChannelId(String channelId) {
        if (channelId == null || !channelId.contains(CHANNEL_BLACK)) {
            return channelId;
        }
        return channelId.split(CHANNEL_BLACK)[0];
    }

    private String getBlackGroupId(String groupId, int userId) {
        if (groupId == null || groupId.contains(GROUP_BLACK)) {
            return groupId;
        }
        return groupId + GROUP_BLACK + userId;
    }

    private String getRealGroupId(String groupId) {
        if (groupId == null || !groupId.contains(GROUP_BLACK)) {
            return groupId;
        }
        return groupId.split(GROUP_BLACK)[0];
    }

    public static int getNotificationId(int userId, int notificationId, String packageName) {
        return (packageName + userId + notificationId).hashCode();
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/notification/NotificationRecord.java`:

```java
package com.vcore.core.system.notification;

import android.app.NotificationChannel;
import android.app.NotificationChannelGroup;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class NotificationRecord {
    public final Map<String, NotificationChannel> mNotificationChannels = new HashMap<>();
    public final Map<String, NotificationChannelGroup> mNotificationChannelGroups = new HashMap<>();
    public final Set<Integer> mIds = new HashSet<>();
}

```

`Bcore/src/main/java/com/vcore/core/system/os/BStorageManagerService.java`:

```java
package com.vcore.core.system.os;

import android.net.Uri;
import android.os.Process;
import android.os.storage.StorageVolume;

import java.io.File;

import black.android.os.storage.StorageManager;
import com.vcore.BlackBoxCore;
import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.ISystemService;
import com.vcore.core.system.user.BUserHandle;
import com.vcore.fake.provider.FileProvider;
import com.vcore.proxy.ProxyManifest;
import com.vcore.utils.compat.BuildCompat;

public class BStorageManagerService extends IBStorageManagerService.Stub implements ISystemService {
    private static final BStorageManagerService sService = new BStorageManagerService();

    public static BStorageManagerService get() {
        return sService;
    }

    public BStorageManagerService() { }

    @Override
    public StorageVolume[] getVolumeList(int uid, String packageName, int flags, int userId) {
        if (StorageManager.getVolumeList == null) {
            return null;
        }

        try {
            StorageVolume[] storageVolumes = StorageManager.getVolumeList.call(BUserHandle.getUserId(Process.myUid()), 0);
            if (storageVolumes == null) {
                return null;
            }

            for (StorageVolume storageVolume : storageVolumes) {
                black.android.os.storage.StorageVolume.mPath.set(storageVolume, BEnvironment.getExternalUserDir(userId));
                if (BuildCompat.isPie()) {
                    black.android.os.storage.StorageVolume.mInternalPath.set(storageVolume, BEnvironment.getExternalUserDir(userId));
                }
            }
            return storageVolumes;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public Uri getUriForFile(String file) {
        return FileProvider.getUriForFile(BlackBoxCore.getContext(), ProxyManifest.getProxyFileProvider(), new File(file));
    }

    @Override
    public void systemReady() { }
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/BPackage.java`:

```java
package com.vcore.core.system.pm;

import android.content.ComponentName;
import android.content.IntentFilter;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.ConfigurationInfo;
import android.content.pm.FeatureInfo;
import android.content.pm.InstrumentationInfo;
import android.content.pm.PackageParser;
import android.content.pm.PermissionGroupInfo;
import android.content.pm.PermissionInfo;
import android.content.pm.ProviderInfo;
import android.content.pm.ServiceInfo;
import android.content.pm.Signature;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;

import java.util.ArrayList;

import com.vcore.entity.pm.InstallOption;
import com.vcore.utils.compat.BuildCompat;

public class BPackage implements Parcelable {
    public final ArrayList<Activity> activities;
    public final ArrayList<Activity> receivers;
    public final ArrayList<Provider> providers;
    public final ArrayList<Service> services;
    public final ArrayList<Instrumentation> instrumentation;
    public final ArrayList<Permission> permissions;
    public final ArrayList<PermissionGroup> permissionGroups;
    public ArrayList<String> requestedPermissions = new ArrayList<>();
    public final Signature[] mSignatures;
    public SigningDetails mSigningDetails;
    public final Bundle mAppMetaData;
    public BPackageSettings mExtras;
    public final String packageName;
    public final int mPreferredOrder;
    public final String mSharedUserId;
    public final ArrayList<String> usesLibraries;
    public final ArrayList<String> usesOptionalLibraries;
    public final int mVersionCode;
    public ApplicationInfo applicationInfo;
    public final String mVersionName;
    public String baseCodePath;

    public final int mSharedUserLabel;
    public final ArrayList<ConfigurationInfo> configPreferences;
    public final ArrayList<FeatureInfo> reqFeatures;

    public InstallOption installOption;

    public BPackage(PackageParser.Package aPackage) {
        this.activities = new ArrayList<>(aPackage.activities.size());
        for (PackageParser.Activity activity : aPackage.activities) {
            Activity selfActivity = new Activity(activity);
            for (ActivityIntentInfo intent : selfActivity.intents) {
                intent.activity = selfActivity;
            }

            selfActivity.owner = this;
            this.activities.add(selfActivity);
        }

        this.receivers = new ArrayList<>(aPackage.receivers.size());
        for (PackageParser.Activity receiver : aPackage.receivers) {
            Activity selfReceiver = new Activity(receiver);
            for (ActivityIntentInfo intent : selfReceiver.intents) {
                intent.activity = selfReceiver;
            }

            selfReceiver.owner = this;
            this.receivers.add(selfReceiver);
        }

        this.providers = new ArrayList<>(aPackage.providers.size());
        for (PackageParser.Provider provider : aPackage.providers) {
            Provider selfProvider = new Provider(provider);
            for (ProviderIntentInfo intent : selfProvider.intents) {
                intent.provider = selfProvider;
            }

            selfProvider.owner = this;
            this.providers.add(selfProvider);
        }

        this.services = new ArrayList<>(aPackage.services.size());
        for (PackageParser.Service service : aPackage.services) {
            Service selfService = new Service(service);
            for (ServiceIntentInfo intent : selfService.intents) {
                intent.service = selfService;
            }

            selfService.owner = this;
            this.services.add(selfService);
        }

        this.instrumentation = new ArrayList<>(aPackage.instrumentation.size());
        for (PackageParser.Instrumentation instrumentation1 : aPackage.instrumentation) {
            Instrumentation selfInstrumentation = new Instrumentation(instrumentation1);
            selfInstrumentation.owner = this;
            this.instrumentation.add(selfInstrumentation);
        }

        this.permissions = new ArrayList<>(aPackage.permissions.size());
        for (PackageParser.Permission permission : aPackage.permissions) {
            Permission selfPermission = new Permission(permission);
            selfPermission.owner = this;
            this.permissions.add(selfPermission);
        }

        this.permissionGroups = new ArrayList<>(aPackage.permissionGroups.size());
        for (PackageParser.PermissionGroup permissionGroup : aPackage.permissionGroups) {
            PermissionGroup selfPermissionGroup = new PermissionGroup(permissionGroup);
            selfPermissionGroup.owner = this;
            this.permissionGroups.add(selfPermissionGroup);
        }

        this.requestedPermissions = aPackage.requestedPermissions;
        if (BuildCompat.isPie()) {
            this.mSigningDetails = new SigningDetails(aPackage.mSigningDetails);
            this.mSignatures = this.mSigningDetails.signatures;
        } else {
            this.mSignatures = aPackage.mSignatures;
        }

        this.mAppMetaData = aPackage.mAppMetaData;
        // this.mExtras = new BPackageSettings((PackageSetting) aPackage.mExtras);
        this.packageName = aPackage.packageName;
        this.mPreferredOrder = aPackage.mPreferredOrder;
        this.mSharedUserId = aPackage.mSharedUserId;
        this.usesLibraries = aPackage.usesLibraries;
        this.usesOptionalLibraries = aPackage.usesOptionalLibraries;
        this.mVersionCode = aPackage.mVersionCode;
        this.applicationInfo = aPackage.applicationInfo;
        this.mVersionName = aPackage.mVersionName;
        this.baseCodePath = aPackage.baseCodePath;
        this.mSharedUserLabel = aPackage.mSharedUserLabel;
        this.configPreferences = aPackage.configPreferences;
        this.reqFeatures = aPackage.reqFeatures;
    }

    protected BPackage(Parcel in) {
        int N = in.readInt();
        this.activities = new ArrayList<>(N);
        while (N-- > 0) {
            Activity activity = new Activity(in);
            for (ActivityIntentInfo intent : activity.intents) {
                intent.activity = activity;
            }

            activity.owner = this;
            this.activities.add(activity);
        }

        N = in.readInt();
        this.receivers = new ArrayList<>(N);
        while (N-- > 0) {
            Activity activity = new Activity(in);
            for (ActivityIntentInfo intent : activity.intents) {
                intent.activity = activity;
            }

            activity.owner = this;
            this.receivers.add(activity);
        }

        N = in.readInt();
        this.providers = new ArrayList<>(N);
        while (N-- > 0) {
            Provider provider = new Provider(in);
            for (ProviderIntentInfo intent : provider.intents) {
                intent.provider = provider;
            }

            provider.owner = this;
            this.providers.add(provider);
        }

        N = in.readInt();
        this.services = new ArrayList<>(N);
        while (N-- > 0) {
            Service service = new Service(in);
            for (ServiceIntentInfo intent : service.intents) {
                intent.service = service;
            }

            service.owner = this;
            this.services.add(service);
        }

        N = in.readInt();
        this.instrumentation = new ArrayList<>(N);
        while (N-- > 0) {
            Instrumentation instrumentation = new Instrumentation(in);
            instrumentation.owner = this;
            this.instrumentation.add(instrumentation);
        }

        N = in.readInt();
        this.permissions = new ArrayList<>(N);
        while (N-- > 0) {
            Permission permission = new Permission(in);
            permission.owner = this;
            this.permissions.add(permission);
        }

        N = in.readInt();
        this.permissionGroups = new ArrayList<>(N);
        while (N-- > 0) {
            PermissionGroup permissionGroup = new PermissionGroup(in);
            permissionGroup.owner = this;
            this.permissionGroups.add(permissionGroup);
        }

        in.readStringList(this.requestedPermissions);
        if (BuildCompat.isPie()) {
            this.mSigningDetails = in.readParcelable(SigningDetails.class.getClassLoader());
        }

        this.mSignatures = in.createTypedArray(Signature.CREATOR);
        this.mAppMetaData = in.readBundle(Bundle.class.getClassLoader());
        // this.mExtras = in.readParcelable(BPackageSettings.class.getClassLoader());
        this.packageName = in.readString();
        this.mPreferredOrder = in.readInt();
        this.mSharedUserId = in.readString();
        this.usesLibraries = in.createStringArrayList();
        this.usesOptionalLibraries = in.createStringArrayList();
        this.mVersionCode = in.readInt();
        this.applicationInfo = in.readParcelable(ApplicationInfo.class.getClassLoader());
        this.mVersionName = in.readString();
        this.baseCodePath = in.readString();
        this.mSharedUserLabel = in.readInt();
        this.configPreferences = in.createTypedArrayList(ConfigurationInfo.CREATOR);
        this.reqFeatures = in.createTypedArrayList(FeatureInfo.CREATOR);
        this.installOption = in.readParcelable(InstallOption.class.getClassLoader());
    }

    public final static class Activity extends Component<ActivityIntentInfo> {
        public final ActivityInfo info;

        public Activity(PackageParser.Activity activity) {
            super(activity);
            this.info = activity.info;

            if (activity.intents != null) {
                int size = activity.intents.size();
                this.intents = new ArrayList<>(size);

                for (PackageParser.ActivityIntentInfo intent : activity.intents) {
                    this.intents.add(new ActivityIntentInfo(intent));
                }
            }
        }

        public Activity(Parcel parcel) {
            super(parcel);
            this.info = parcel.readParcelable(ActivityInfo.class.getClassLoader());
            int N = parcel.readInt();
            this.intents = new ArrayList<>(N);

            while (N-- > 0) {
                IntentInfo intentInfo = parcel.readParcelable(BPackage.class.getClassLoader());
                this.intents.add(new ActivityIntentInfo(intentInfo));
            }
        }
    }

    public static final class Service extends Component<ServiceIntentInfo> {
        public final ServiceInfo info;

        public Service(PackageParser.Service service) {
            super(service);
            info = service.info;

            if (service.intents != null) {
                int size = service.intents.size();
                intents = new ArrayList<>(size);

                for (PackageParser.ServiceIntentInfo intent : service.intents) {
                    intents.add(new ServiceIntentInfo(intent));
                }
            }
        }

        public Service(Parcel parcel) {
            super(parcel);
            info = parcel.readParcelable(ServiceInfo.class.getClassLoader());
            int N = parcel.readInt();
            intents = new ArrayList<>(N);

            while (N-- > 0) {
                IntentInfo intentInfo = parcel.readParcelable(BPackage.class.getClassLoader());
                intents.add(new ServiceIntentInfo(intentInfo));
            }
        }
    }

    public static final class Provider extends Component<ProviderIntentInfo> {
        public final ProviderInfo info;

        public Provider(PackageParser.Provider provider) {
            super(provider);
            info = provider.info;

            if (provider.intents != null) {
                int size = provider.intents.size();
                intents = new ArrayList<>(size);

                for (PackageParser.ProviderIntentInfo intent : provider.intents) {
                    intents.add(new ProviderIntentInfo(intent));
                }
            }
        }

        public Provider(Parcel parcel) {
            super(parcel);
            info = parcel.readParcelable(ProviderInfo.class.getClassLoader());
            int N = parcel.readInt();
            intents = new ArrayList<>(N);

            while (N-- > 0) {
                IntentInfo intentInfo = parcel.readParcelable(BPackage.class.getClassLoader());
                intents.add(new ProviderIntentInfo(intentInfo));
            }
        }
    }

    public static final class Instrumentation extends Component<IntentInfo> {
        public final InstrumentationInfo info;

        public Instrumentation(PackageParser.Instrumentation instrumentation) {
            super(instrumentation);
            info = instrumentation.info;

            if (instrumentation.intents != null) {
                int size = instrumentation.intents.size();
                this.intents = new ArrayList<>(size);

                for (PackageParser.IntentInfo intent : instrumentation.intents) {
                    this.intents.add(new IntentInfo(intent));
                }
            }
        }

        public Instrumentation(Parcel parcel) {
            super(parcel);
            this.info = parcel.readParcelable(InstrumentationInfo.class.getClassLoader());
            int N = parcel.readInt();
            this.intents = new ArrayList<>(N);

            while (N-- > 0) {
                IntentInfo intentInfo = parcel.readParcelable(BPackage.class.getClassLoader());
                this.intents.add(intentInfo);
            }
        }
    }

    public static final class Permission extends Component<IntentInfo> {
        public final PermissionInfo info;

        public Permission(PackageParser.Permission permission) {
            super(permission);
            this.info = permission.info;

            if (permission.intents != null) {
                int size = permission.intents.size();
                this.intents = new ArrayList<>(size);

                for (PackageParser.IntentInfo intent : permission.intents) {
                    this.intents.add(new IntentInfo(intent));
                }
            }
        }

        public Permission(Parcel parcel) {
            super(parcel);
            this.info = parcel.readParcelable(Permission.class.getClassLoader());
            int N = parcel.readInt();
            this.intents = new ArrayList<>(N);

            while (N-- > 0) {
                IntentInfo intentInfo = parcel.readParcelable(BPackage.class.getClassLoader());
                this.intents.add(intentInfo);
            }
        }
    }

    public static final class PermissionGroup extends Component<IntentInfo> {
        public final PermissionGroupInfo info;

        public PermissionGroup(PackageParser.PermissionGroup group) {
            super(group);
            this.info = group.info;

            if (group.intents != null) {
                int size = group.intents.size();
                this.intents = new ArrayList<>(size);

                for (PackageParser.IntentInfo intent : group.intents) {
                    this.intents.add(new IntentInfo(intent));
                }
            }
        }

        public PermissionGroup(Parcel parcel) {
            super(parcel);
            this.info = parcel.readParcelable(PermissionGroup.class.getClassLoader());
            int N = parcel.readInt();
            this.intents = new ArrayList<>(N);

            while (N-- > 0) {
                IntentInfo intentInfo = parcel.readParcelable(BPackage.class.getClassLoader());
                this.intents.add(intentInfo);
            }
        }
    }

    public static class ActivityIntentInfo extends IntentInfo {
        public Activity activity;

        public ActivityIntentInfo(PackageParser.IntentInfo intentInfo) {
            super(intentInfo);
        }

        public ActivityIntentInfo(IntentInfo intentInfo) {
            super(intentInfo);
        }
    }

    public static class ServiceIntentInfo extends IntentInfo {
        public Service service;

        public ServiceIntentInfo(PackageParser.IntentInfo intentInfo) {
            super(intentInfo);
        }

        public ServiceIntentInfo(IntentInfo intentInfo) {
            super(intentInfo);
        }
    }

    public static class ProviderIntentInfo extends IntentInfo {
        public Provider provider;

        public ProviderIntentInfo(PackageParser.IntentInfo intentInfo) {
            super(intentInfo);
        }

        public ProviderIntentInfo(IntentInfo intentInfo) {
            super(intentInfo);
        }
    }

    public static final class SigningDetails implements Parcelable {
        public final Signature[] signatures;

        @Override
        public int describeContents() {
            return 0;
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            dest.writeTypedArray(this.signatures, flags);
        }

        public SigningDetails(PackageParser.SigningDetails signingDetails) {
            if (signingDetails.pastSigningCertificates == null) {
                this.signatures = signingDetails.signatures;
            } else {
                this.signatures = signingDetails.pastSigningCertificates;
            }
        }

        private SigningDetails(Parcel in) {
            this.signatures = in.createTypedArray(Signature.CREATOR);
        }

        public static final Creator<SigningDetails> CREATOR = new Creator<SigningDetails>() {
            @Override
            public SigningDetails createFromParcel(Parcel source) {
                return new SigningDetails(source);
            }

            @Override
            public SigningDetails[] newArray(int size) {
                return new SigningDetails[size];
            }
        };
    }

    public static class IntentInfo implements Parcelable {
        public final IntentFilter intentFilter;
        public final boolean hasDefault;
        public final int labelRes;
        public final String nonLocalizedLabel;
        public final int icon;
        public final int logo;
        public final int banner;

        public IntentInfo(PackageParser.IntentInfo intentInfo) {
            this.intentFilter = intentInfo;
            this.hasDefault = intentInfo.hasDefault;
            this.labelRes = intentInfo.labelRes;
            this.nonLocalizedLabel = intentInfo.nonLocalizedLabel == null ? null : intentInfo.nonLocalizedLabel.toString();
            this.icon = intentInfo.icon;
            this.logo = intentInfo.logo;
            this.banner = intentInfo.banner;
        }

        public IntentInfo(IntentInfo intentInfo) {
            this.intentFilter = intentInfo.intentFilter;
            this.hasDefault = intentInfo.hasDefault;
            this.labelRes = intentInfo.labelRes;
            this.nonLocalizedLabel = intentInfo.nonLocalizedLabel == null ? null : intentInfo.nonLocalizedLabel;
            this.icon = intentInfo.icon;
            this.logo = intentInfo.logo;
            this.banner = intentInfo.banner;
        }

        @Override
        public int describeContents() {
            return 0;
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            dest.writeParcelable(this.intentFilter, flags);
            dest.writeByte(this.hasDefault ? (byte) 1 : (byte) 0);
            dest.writeInt(this.labelRes);
            dest.writeString(this.nonLocalizedLabel);
            dest.writeInt(this.icon);
            dest.writeInt(this.logo);
            dest.writeInt(this.banner);
        }

        protected IntentInfo(Parcel in) {
            this.intentFilter = in.readParcelable(BPackage.class.getClassLoader());
            this.hasDefault = in.readByte() != 0;
            this.labelRes = in.readInt();
            this.nonLocalizedLabel = in.readString();
            this.icon = in.readInt();
            this.logo = in.readInt();
            this.banner = in.readInt();
        }

        public static final Creator<IntentInfo> CREATOR = new Creator<IntentInfo>() {
            @Override
            public IntentInfo createFromParcel(Parcel source) {
                return new IntentInfo(source);
            }

            @Override
            public IntentInfo[] newArray(int size) {
                return new IntentInfo[size];
            }
        };
    }

    public static class Component<II extends BPackage.IntentInfo> {
        public BPackage owner;
        public ArrayList<II> intents;
        public final String className;
        public final Bundle metaData;
        public ComponentName componentName;

        public Component(Parcel parcel) {
            this.className = parcel.readString();
            this.metaData = parcel.readBundle(Bundle.class.getClassLoader());
        }

        public Component(PackageParser.Component<?> component) {
            this.className = component.className;
            this.metaData = component.metaData;
        }

        public ComponentName getComponentName() {
            if (componentName != null) {
                return componentName;
            }
            if (className != null) {
                componentName = new ComponentName(owner.packageName, className);
            }
            return componentName;
        }
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        int size = this.activities.size();
        dest.writeInt(size);

        for (Activity activity : this.activities) {
            dest.writeString(activity.className);
            dest.writeBundle(activity.metaData);
            dest.writeParcelable(activity.info, flags);

            if (activity.intents != null) {
                int N = activity.intents.size();
                dest.writeInt(N);
                while (N-- > 0) {
                    dest.writeParcelable(activity.intents.get(N), flags);
                }
            } else {
                dest.writeInt(0);
            }
        }

        size = this.receivers.size();
        dest.writeInt(size);

        for (Activity receiver : this.receivers) {
            dest.writeString(receiver.className);
            dest.writeBundle(receiver.metaData);
            dest.writeParcelable(receiver.info, flags);

            if (receiver.intents != null) {
                int N = receiver.intents.size();
                dest.writeInt(N);
                while (N-- > 0) {
                    dest.writeParcelable(receiver.intents.get(N), flags);
                }
            } else {
                dest.writeInt(0);
            }
        }

        size = this.providers.size();
        dest.writeInt(size);

        for (Provider provider : this.providers) {
            dest.writeString(provider.className);
            dest.writeBundle(provider.metaData);
            dest.writeParcelable(provider.info, flags);

            if (provider.intents != null) {
                int N = provider.intents.size();
                dest.writeInt(N);
                while (N-- > 0) {
                    dest.writeParcelable(provider.intents.get(N), flags);
                }
            } else {
                dest.writeInt(0);
            }
        }

        size = this.services.size();
        dest.writeInt(size);

        for (Service service : this.services) {
            dest.writeString(service.className);
            dest.writeBundle(service.metaData);
            dest.writeParcelable(service.info, flags);

            if (service.intents != null) {
                int N = service.intents.size();
                dest.writeInt(N);
                while (N-- > 0) {
                    dest.writeParcelable(service.intents.get(N), flags);
                }
            } else {
                dest.writeInt(0);
            }
        }

        size = this.instrumentation.size();
        dest.writeInt(size);

        for (Instrumentation instrumentation : this.instrumentation) {
            dest.writeString(instrumentation.className);
            dest.writeBundle(instrumentation.metaData);
            dest.writeParcelable(instrumentation.info, flags);

            if (instrumentation.intents != null) {
                int N = instrumentation.intents.size();
                dest.writeInt(N);
                while (N-- > 0) {
                    dest.writeParcelable(instrumentation.intents.get(N), flags);
                }
            } else {
                dest.writeInt(0);
            }
        }

        size = this.permissions.size();
        dest.writeInt(size);

        for (Permission permission : this.permissions) {
            dest.writeString(permission.className);
            dest.writeBundle(permission.metaData);
            dest.writeParcelable(permission.info, flags);

            if (permission.intents != null) {
                int N = permission.intents.size();
                dest.writeInt(N);
                while (N-- > 0) {
                    dest.writeParcelable(permission.intents.get(N), flags);
                }
            } else {
                dest.writeInt(0);
            }
        }

        size = this.permissionGroups.size();
        dest.writeInt(size);

        for (PermissionGroup permissionGroup : this.permissionGroups) {
            dest.writeString(permissionGroup.className);
            dest.writeBundle(permissionGroup.metaData);
            dest.writeParcelable(permissionGroup.info, flags);

            if (permissionGroup.intents != null) {
                int N = permissionGroup.intents.size();
                dest.writeInt(N);
                while (N-- > 0) {
                    dest.writeParcelable(permissionGroup.intents.get(N), flags);
                }
            } else {
                dest.writeInt(0);
            }
        }

        dest.writeStringList(this.requestedPermissions);
        if (BuildCompat.isPie()) {
            dest.writeParcelable(this.mSigningDetails, flags);
        }

        dest.writeTypedArray(this.mSignatures, flags);
        dest.writeBundle(this.mAppMetaData);
        // dest.writeParcelable(this.mExtras, flags);
        dest.writeString(this.packageName);
        dest.writeInt(this.mPreferredOrder);
        dest.writeString(this.mSharedUserId);
        dest.writeStringList(this.usesLibraries);
        dest.writeStringList(this.usesOptionalLibraries);
        dest.writeInt(this.mVersionCode);
        dest.writeParcelable(this.applicationInfo, flags);
        dest.writeString(this.mVersionName);
        dest.writeString(this.baseCodePath);
        dest.writeInt(this.mSharedUserLabel);
        dest.writeTypedList(this.configPreferences);
        dest.writeTypedList(this.reqFeatures);
        dest.writeParcelable(this.installOption, flags);
    }

    public static final Parcelable.Creator<BPackage> CREATOR = new Parcelable.Creator<BPackage>() {
        @Override
        public BPackage createFromParcel(Parcel source) {
            return new BPackage(source);
        }

        @Override
        public BPackage[] newArray(int size) {
            return new BPackage[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/BPackageInstallerService.java`:

```java
package com.vcore.core.system.pm;

import java.util.ArrayList;
import java.util.List;

import com.vcore.core.system.ISystemService;
import com.vcore.core.system.pm.installer.CopyExecutor;
import com.vcore.core.system.pm.installer.CreatePackageExecutor;
import com.vcore.core.system.pm.installer.CreateUserExecutor;
import com.vcore.core.system.pm.installer.Executor;
import com.vcore.core.system.pm.installer.RemoveAppExecutor;
import com.vcore.core.system.pm.installer.RemoveUserExecutor;
import com.vcore.entity.pm.InstallOption;
import com.vcore.utils.Slog;



public class BPackageInstallerService extends IBPackageInstallerService.Stub implements ISystemService {
    private static final BPackageInstallerService sService = new BPackageInstallerService();

    public static BPackageInstallerService get() {
        return sService;
    }

    public static final String TAG = "BPackageInstallerService";

    @Override
    public int installPackageAsUser(BPackageSettings ps, int userId) {
        List<Executor> executors = new ArrayList<>();
        // 创建用户环境相关操作
        executors.add(new CreateUserExecutor());
        // 创建应用环境相关操作
        executors.add(new CreatePackageExecutor());
        // 拷贝应用相关文件
        executors.add(new CopyExecutor());
        InstallOption option = ps.installOption;
        for (Executor executor : executors) {
            int exec = executor.exec(ps, option, userId);
            Slog.d(TAG, "installPackageAsUser: " + executor.getClass().getSimpleName() + " exec: " + exec);
            if (exec != 0) {
                return exec;
            }
        }
        return 0;
    }

    @Override
    public int uninstallPackageAsUser(BPackageSettings ps, boolean removeApp, int userId) {
        List<Executor> executors = new ArrayList<>();
        if (removeApp) {
            // 移除App
            executors.add(new RemoveAppExecutor());
        }
        // 移除用户相关目录
        executors.add(new RemoveUserExecutor());
        InstallOption option = ps.installOption;
        for (Executor executor : executors) {
            int exec = executor.exec(ps, option, userId);
            Slog.d(TAG, "uninstallPackageAsUser: " + executor.getClass().getSimpleName() + " exec: " + exec);
            if (exec != 0) {
                return exec;
            }
        }
        return 0;
    }

    @Override
    public int clearPackage(BPackageSettings ps, int userId) {
        List<Executor> executors = new ArrayList<>();
        // 移除用户相关目录
        executors.add(new RemoveUserExecutor());
        // 创建用户环境相关操作
        executors.add(new CreateUserExecutor());
        InstallOption option = ps.installOption;
        for (Executor executor : executors) {
            int exec = executor.exec(ps, option, userId);
            Slog.d(TAG, "uninstallPackageAsUser: " + executor.getClass().getSimpleName() + " exec: " + exec);
            if (exec != 0) {
                return exec;
            }
        }
        return 0;
    }

    @Override
    public int updatePackage(BPackageSettings ps) {
        List<Executor> executors = new ArrayList<>();
        executors.add(new CreatePackageExecutor());
        executors.add(new CopyExecutor());
        InstallOption option = ps.installOption;
        for (Executor executor : executors) {
            int exec = executor.exec(ps, option, -1);
            if (exec != 0) {
                return exec;
            }
        }
        return 0;
    }

    @Override
    public void systemReady() { }
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/BPackageManagerService.java`:

```java
package com.vcore.core.system.pm;

import static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_UNAWARE;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageParser;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.ServiceInfo;
import android.net.Uri;
import android.os.Build;
import android.os.RemoteException;
import android.text.TextUtils;

import androidx.annotation.RequiresApi;

import java.io.File;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;

import com.vcore.BlackBoxCore;
import com.vcore.core.GmsCore;
import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.BProcessManagerService;
import com.vcore.core.system.ISystemService;
import com.vcore.core.system.ProcessRecord;
import com.vcore.core.system.user.BUserHandle;
import com.vcore.core.system.user.BUserInfo;
import com.vcore.core.system.user.BUserManagerService;
import com.vcore.entity.pm.InstallOption;
import com.vcore.entity.pm.InstallResult;
import com.vcore.entity.pm.InstalledPackage;
import com.vcore.utils.AbiUtils;
import com.vcore.utils.FileUtils;
import com.vcore.utils.Slog;
import com.vcore.utils.compat.PackageParserCompat;
import com.vcore.utils.compat.XposedParserCompat;



public class BPackageManagerService extends IBPackageManagerService.Stub implements ISystemService {
    public static final String TAG = "BPackageManagerService";
    public static final BPackageManagerService sService = new BPackageManagerService();
    private final Settings mSettings = new Settings();
    private final ComponentResolver mComponentResolver;
    private static final BUserManagerService sUserManager = BUserManagerService.get();
    private final List<PackageMonitor> mPackageMonitors = new ArrayList<>();

    final Map<String, BPackageSettings> mPackages = mSettings.mPackages;
    final Object mInstallLock = new Object();

    public static BPackageManagerService get() {
        return sService;
    }

    @RequiresApi(api = Build.VERSION_CODES.TIRAMISU)
    public BPackageManagerService() {
        mComponentResolver = new ComponentResolver();
        IntentFilter filter = new IntentFilter();
        filter.addAction("android.intent.action.PACKAGE_ADDED");
        filter.addAction("android.intent.action.PACKAGE_REMOVED");
        filter.addDataScheme("package");

        BroadcastReceiver mPackageChangedHandler = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                String action = intent.getAction();
                if (!TextUtils.isEmpty(action)) {
                    if ("android.intent.action.PACKAGE_ADDED".equals(action) || "android.intent.action.PACKAGE_REMOVED".equals(action)) {
                        mSettings.scanPackage();
                    }
                }
            }
        };
        BlackBoxCore.getContext().registerReceiver(mPackageChangedHandler, filter, Context.RECEIVER_NOT_EXPORTED);
    }

    @Override
    public ApplicationInfo getApplicationInfo(String packageName, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }

        if (Objects.equals(packageName, BlackBoxCore.getHostPkg())) {
            try {
                return BlackBoxCore.getPackageManager().getApplicationInfo(packageName, flags);
            } catch (PackageManager.NameNotFoundException e) {
                e.printStackTrace();
            }
            return null;
        }

        flags = updateFlags(flags);
        synchronized (mPackages) {
            // Normalize package name to handle renamed packages and static libs.
            BPackageSettings ps = mPackages.get(packageName);
            if (ps != null) {
                BPackage p = ps.pkg;
                return PackageManagerCompat.generateApplicationInfo(p, flags, ps.readUserState(userId), userId);
            }
        }
        return null;
    }

    @Override
    public ResolveInfo resolveService(Intent intent, int flags, String resolvedType, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }

        List<ResolveInfo> query = queryIntentServicesInternal(intent, resolvedType, flags, userId);
        if (query != null) {
            if (query.size() >= 1) {
                // If there is more than one service with the same priority,
                // just arbitrarily pick the first one.
                return query.get(0);
            }
        }
        return null;
    }

    private List<ResolveInfo> queryIntentServicesInternal(Intent intent, String resolvedType, int flags, int userId) {
        ComponentName comp = intent.getComponent();
        if (comp == null) {
            if (intent.getSelector() != null) {
                intent = intent.getSelector();
                comp = intent.getComponent();
            }
        }

        if (comp != null) {
            final List<ResolveInfo> list = new ArrayList<>(1);
            final ServiceInfo si = getServiceInfo(comp, flags, userId);
            if (si != null) {
                // When specifying an explicit component, we prevent the service from being
                // used when either 1) the service is in an instant application and the
                // caller is not the same instant application or 2) the calling package is
                // ephemeral and the activity is not visible to ephemeral applications.
                final ResolveInfo ri = new ResolveInfo();
                ri.serviceInfo = si;
                list.add(ri);
            }
            return list;
        }

        synchronized (mPackages) {
            String pkgName = intent.getPackage();
            if (pkgName != null) {
                BPackageSettings bPackageSettings = mPackages.get(pkgName);
                if (bPackageSettings != null) {
                    final BPackage pkg = bPackageSettings.pkg;
                    return mComponentResolver.queryServices(intent, resolvedType, flags, pkg.services, userId);
                }
            } else {
               return mComponentResolver.queryServices(intent, resolvedType, flags, userId);
            }
            return Collections.emptyList();
        }
    }

    @Override
    public ResolveInfo resolveActivity(Intent intent, int flags, String resolvedType, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }

        List<ResolveInfo> resolves = queryIntentActivities(intent, resolvedType, flags, userId);
        return chooseBestActivity(resolves);
    }

    @Override
    public ProviderInfo resolveContentProvider(String authority, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }

        return mComponentResolver.queryProvider(authority, flags, userId);
    }

    @Override
    public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }

        List<ResolveInfo> resolves = queryIntentActivities(intent, resolvedType, flags, userId);
        return chooseBestActivity(resolves);
    }

    private ResolveInfo chooseBestActivity(List<ResolveInfo> query) {
        if (query != null) {
            final int N = query.size();
            if (N == 1) {
                return query.get(0);
            } else if (N > 1) {
                // If there is more than one activity with the same priority,
                // then let the user decide between them.
                ResolveInfo r0 = query.get(0);
                ResolveInfo r1 = query.get(1);
                // If the first activity has a higher priority, or a different
                // default, then it is always desirable to pick it.
                if (r0.priority != r1.priority || r0.preferredOrder != r1.preferredOrder || r0.isDefault != r1.isDefault) {
                    return query.get(0);
                }
            }
        }
        return null;
    }

    private List<ResolveInfo> queryIntentActivities(Intent intent, String resolvedType, int flags, int userId) {
        ComponentName comp = intent.getComponent();
        if (comp == null) {
            if (intent.getSelector() != null) {
                intent = intent.getSelector();
                comp = intent.getComponent();
            }
        }

        if (comp != null) {
            final List<ResolveInfo> list = new ArrayList<>(1);
            final ActivityInfo ai = getActivity(comp, flags, userId);
            if (ai != null) {
                // When specifying an explicit component, we prevent the activity from being
                // used when either 1) the calling package is normal and the activity is within
                // an ephemeral application or 2) the calling package is ephemeral and the
                // activity is not visible to ephemeral applications.
                final ResolveInfo ri = new ResolveInfo();
                ri.activityInfo = ai;
                list.add(ri);
                return list;
            }
        }

        synchronized (mPackages) {
            return mComponentResolver.queryActivities(intent, resolvedType, flags, userId);
        }
    }

    @Override
    public List<ResolveInfo> queryIntentServices(Intent intent, int flags, int userId) {
        final String resolvedType = intent.resolveTypeIfNeeded(BlackBoxCore.getContext().getContentResolver());
        return this.queryIntentServicesInternal(intent, resolvedType, flags, userId);
    }

    private ActivityInfo getActivity(ComponentName component, int flags, int userId) {
        flags = updateFlags(flags);
        synchronized (mPackages) {
            BPackage.Activity a = mComponentResolver.getActivity(component);

            if (a != null) {
                BPackageSettings ps = mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                }
                return PackageManagerCompat.generateActivityInfo(a, flags, ps.readUserState(userId), userId);
            }
        }
        return null;
    }

    @Override
    public int getUidByPid(int pid) {
        ProcessRecord processByPid = BProcessManagerService.get().findProcessByPid(pid);
        if (processByPid != null) {
            return processByPid.bUID;
        }
        return -1;
    }

    @Override
    public PackageInfo getPackageInfo(String packageName, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }

        if (Objects.equals(packageName, BlackBoxCore.getHostPkg())) {
            try {
                return BlackBoxCore.getPackageManager().getPackageInfo(packageName, flags);
            } catch (PackageManager.NameNotFoundException e) {
                e.printStackTrace();
            }
            return null;
        }

        flags = updateFlags(flags);
        BPackageSettings ps;

        synchronized (mPackages) {
            // Normalize package name to handle renamed packages and static libs.
            ps = mPackages.get(packageName);
        }

        if (ps != null) {
            return PackageManagerCompat.generatePackageInfo(ps, flags, ps.readUserState(userId), userId);
        }
        return null;
    }

    @Override
    public ServiceInfo getServiceInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }

        synchronized (mPackages) {
            BPackage.Service s = mComponentResolver.getService(component);

            if (s != null) {
                BPackageSettings ps = mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                }
                return PackageManagerCompat.generateServiceInfo(s, flags, ps.readUserState(userId), userId);
            }
        }
        return null;
    }

    @Override
    public ActivityInfo getReceiverInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }

        synchronized (mPackages) {
            BPackage.Activity a = mComponentResolver.getReceiver(component);

            if (a != null) {
                BPackageSettings ps = mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                }
                return PackageManagerCompat.generateActivityInfo(a, flags, ps.readUserState(userId), userId);
            }
        }
        return null;
    }

    @Override
    public ActivityInfo getActivityInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }

        synchronized (mPackages) {
            BPackage.Activity a = mComponentResolver.getActivity(component);

            if (a != null) {
                BPackageSettings ps = mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                }
                return PackageManagerCompat.generateActivityInfo(a, flags, ps.readUserState(userId), userId);
            }
        }
        return null;
    }

    @Override
    public ProviderInfo getProviderInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) return null;
        synchronized (mPackages) {
            BPackage.Provider p = mComponentResolver.getProvider(component);

            if (p != null) {
                BPackageSettings ps = mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                }
                return PackageManagerCompat.generateProviderInfo(p, flags, ps.readUserState(userId), userId);
            }
        }
        return null;
    }

    @Override
    public List<ApplicationInfo> getInstalledApplications(int flags, int userId) {
        return getInstalledApplicationsListInternal(flags, userId);
    }

    @Override
    public List<PackageInfo> getInstalledPackages(int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }

        synchronized (mPackages) {
            ArrayList<PackageInfo> list;
            list = new ArrayList<>(mPackages.size());

            for (BPackageSettings ps : mPackages.values()) {
                PackageInfo pi = getPackageInfo(ps.pkg.packageName, flags, userId);
                if (pi != null) {
                    list.add(pi);
                }
            }
            return new ArrayList<>(list);
        }
    }

    private List<ApplicationInfo> getInstalledApplicationsListInternal(int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }

        synchronized (mPackages) {
            ArrayList<ApplicationInfo> list;
            list = new ArrayList<>(mPackages.size());
            Collection<BPackageSettings> packageSettings = mPackages.values();

            for (BPackageSettings ps : packageSettings) {
                if (GmsCore.isGoogleAppOrService(ps.pkg.packageName)) {
                    continue;
                }

                ApplicationInfo ai = PackageManagerCompat.generateApplicationInfo(ps.pkg, flags, ps.readUserState(userId), userId);
                if (ai != null) {
                    list.add(ai);
                }
            }
            return list;
        }
    }

    @Override
    public List<ResolveInfo> queryIntentActivities(Intent intent, int flags, String resolvedType, int userId) {
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }

        final String pkgName = intent.getPackage();
        ComponentName comp = intent.getComponent();
        if (comp == null) {
            if (intent.getSelector() != null) {
                intent = intent.getSelector();
                comp = intent.getComponent();
            }
        }

        if (comp != null) {
            final List<ResolveInfo> list = new ArrayList<>(1);
            final ActivityInfo ai = getActivityInfo(comp, flags, userId);
            if (ai != null) {
                // When specifying an explicit component, we prevent the activity from being
                // used when either 1) the calling package is normal and the activity is within
                // an ephemeral application or 2) the calling package is ephemeral and the
                // activity is not visible to ephemeral applications.
                final ResolveInfo ri = new ResolveInfo();
                ri.activityInfo = ai;
                list.add(ri);
            }
            return list;
        }

        List<ResolveInfo> result;
        synchronized (mPackages) {
            if (pkgName != null) {
                BPackageSettings bPackageSettings = mPackages.get(pkgName);
                result = null;
				
                if (bPackageSettings != null) {
                    final BPackage pkg = bPackageSettings.pkg;
                    result = mComponentResolver.queryActivities(intent, resolvedType, flags, pkg.activities, userId);
                }

                if (result == null || result.size() == 0) {
                    // the caller wants to resolve for a particular package; however, there
                    // were no installed results, so, try to find an ephemeral result
                    if (result == null) {
                        result = new ArrayList<>();
                    }
                }
                return result;
            }
        }
        return Collections.emptyList();
    }

    @Override
    public List<ResolveInfo> queryBroadcastReceivers(Intent intent, int flags, String resolvedType, int userId) {
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }

        ComponentName comp = intent.getComponent();
        if (comp == null) {
            if (intent.getSelector() != null) {
                intent = intent.getSelector();
                comp = intent.getComponent();
            }
        }

        if (comp != null) {
            final List<ResolveInfo> list = new ArrayList<>(1);
            final ActivityInfo ai = getReceiverInfo(comp, flags, userId);
            if (ai != null) {
                // When specifying an explicit component, we prevent the activity from being
                // used when either 1) the calling package is normal and the activity is within
                // an instant application or 2) the calling package is ephemeral and the
                // activity is not visible to instant applications.
                ResolveInfo ri = new ResolveInfo();
                ri.activityInfo = ai;
                list.add(ri);
            }
            return list;
        }

        synchronized (mPackages) {
            String pkgName = intent.getPackage();
            BPackageSettings bPackageSettings = mPackages.get(pkgName);
            if (bPackageSettings != null) {
                final BPackage pkg = bPackageSettings.pkg;
                return mComponentResolver.queryReceivers(intent, resolvedType, flags, pkg.receivers, userId);
            } else {
                return mComponentResolver.queryReceivers(intent, resolvedType, flags, userId);
            }
        }
    }

    @Override
    public List<ProviderInfo> queryContentProviders(String processName, int uid, int flags, int userId) throws RemoteException {
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }

        List<ProviderInfo> providers = new ArrayList<>();
        if (TextUtils.isEmpty(processName)) {
            return providers;
        }
        providers.addAll(mComponentResolver.queryProviders(processName, flags, userId));
        return providers;
    }

    @Override
    public InstallResult installPackageAsUser(String file, InstallOption option, int userId) {
        synchronized (mInstallLock) {
            return installPackageAsUserLocked(file, option, userId);
        }
    }

    @Override
    public void uninstallPackageAsUser(String packageName, int userId) throws RemoteException {
        synchronized (mInstallLock) {
            synchronized (mPackages) {
                BPackageSettings ps = mPackages.get(packageName);
                if (ps == null) {
                    return;
                }

                if (ps.installOption.isFlag(InstallOption.FLAG_XPOSED) && userId != BUserHandle.USER_XPOSED) {
                    return;
                }

                if (!isInstalled(packageName, userId)) {
                    return;
                }

                boolean removeApp = ps.getUserState().size() <= 1;
                BProcessManagerService.get().killPackageAsUser(packageName, userId);
                if (removeApp) {
                    mSettings.removePackage(packageName);
                    mComponentResolver.removeAllComponents(ps.pkg);
                } else {
                    ps.removeUser(userId);
                    ps.save();
                }
                onPackageUninstalled(packageName, removeApp, userId);
            }
        }
    }

    @Override
    public void uninstallPackage(String packageName) {
        synchronized (mInstallLock) {
            synchronized (mPackages) {
                BPackageSettings ps = mPackages.get(packageName);
                if (ps == null) {
                    return;
                }

                BProcessManagerService.get().killAllByPackageName(packageName);
                if (ps.installOption.isFlag(InstallOption.FLAG_XPOSED)) {
                    for (BUserInfo user : BUserManagerService.get().getAllUsers()) {
                        int i = BPackageInstallerService.get().uninstallPackageAsUser(ps, true, user.id);
                        if (i < 0) {
                            continue;
                        }
                        onPackageUninstalled(packageName, true, user.id);
                    }
                } else {
                    for (Integer userId : ps.getUserIds()) {
                        int i = BPackageInstallerService.get().uninstallPackageAsUser(ps, true, userId);
                        if (i < 0) {
                            continue;
                        }
                        onPackageUninstalled(packageName, true, userId);
                    }
                }

                mSettings.removePackage(packageName);
                mComponentResolver.removeAllComponents(ps.pkg);
            }
        }
    }

    @Override
    public void clearPackage(String packageName, int userId) {
        if (!isInstalled(packageName, userId)) {
            return;
        }
        BProcessManagerService.get().killPackageAsUser(packageName, userId);
    }

    @Override
    public void stopPackage(String packageName, int userId) {
        BProcessManagerService.get().killPackageAsUser(packageName, userId);
    }

    @Override
    public void deleteUser(int userId) throws RemoteException {
        synchronized (mPackages) {
            for (BPackageSettings ps : mPackages.values()) {
                uninstallPackageAsUser(ps.pkg.packageName, userId);
            }
        }
    }

    @Override
    public boolean isInstalled(String packageName, int userId) {
        if (!sUserManager.exists(userId)) {
            return false;
        }

        synchronized (mPackages) {
            BPackageSettings ps = mPackages.get(packageName);
            if (ps == null) {
                return false;
            }
            return ps.getInstalled(userId);
        }
    }

    @Override
    public List<InstalledPackage> getInstalledPackagesAsUser(int userId) {
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }

        synchronized (mPackages) {
            List<InstalledPackage> installedPackages = new ArrayList<>();
            for (BPackageSettings ps : mPackages.values()) {
                if (ps.getInstalled(userId) && !GmsCore.isGoogleAppOrService(ps.pkg.packageName)) {
                    InstalledPackage installedPackage = new InstalledPackage();
                    installedPackage.userId = userId;
                    installedPackage.packageName = ps.pkg.packageName;
                    installedPackages.add(installedPackage);
                }
            }
            return installedPackages;
        }
    }

    @Override
    public String[] getPackagesForUid(int uid, int userId) {
        if (!sUserManager.exists(userId)) {
            return new String[]{};
        }

        synchronized (mPackages) {
            List<String> packages = new ArrayList<>();
            for (BPackageSettings ps : mPackages.values()) {
                String packageName = ps.pkg.packageName;
                if (ps.getInstalled(userId) && getAppId(packageName) == uid) {
                    packages.add(packageName);
                }
            }

            if (packages.isEmpty()) {
                ProcessRecord processByPid = BProcessManagerService.get().findProcessByPid(getCallingPid());
                if (processByPid != null) {
                    packages.add(processByPid.getPackageName());
                }
            }
            return packages.toArray(new String[]{});
        }
    }

    private InstallResult installPackageAsUserLocked(String file, InstallOption option, int userId) {
        long l = System.currentTimeMillis();
        InstallResult result = new InstallResult();
        File apkFile = null;

        try {
            if (!sUserManager.exists(userId)) {
                sUserManager.createUser(userId);
            }

            if (option.isFlag(InstallOption.FLAG_URI_FILE)) {
                apkFile = new File(BEnvironment.getCacheDir(), UUID.randomUUID().toString() + ".apk");
                InputStream inputStream = BlackBoxCore.getContext().getContentResolver().openInputStream(Uri.parse(file));
                FileUtils.copyFile(inputStream, apkFile);
            } else {
                apkFile = new File(file);
            }

            if (option.isFlag(InstallOption.FLAG_XPOSED) && userId != BUserHandle.USER_XPOSED) {
                return new InstallResult().installError("Please install the XP module in XP module management");
            }
            if (option.isFlag(InstallOption.FLAG_XPOSED) && !XposedParserCompat.isXPModule(apkFile.getAbsolutePath())) {
                return new InstallResult().installError("Not a XP module");
            }

            PackageInfo packageArchiveInfo = BlackBoxCore.getPackageManager().getPackageArchiveInfo(apkFile.getAbsolutePath(), 0);
            if (packageArchiveInfo == null) {
                return result.installError("getPackageArchiveInfo error. Please check whether APK is normal.");
            }

            boolean support = AbiUtils.isSupport(apkFile);
            if (!support) {
                String msg = packageArchiveInfo.applicationInfo.loadLabel(BlackBoxCore.getPackageManager()) + "[" + packageArchiveInfo.packageName + "]";
                return result.installError(packageArchiveInfo.packageName,
                        msg + "\n" + (BlackBoxCore.is64Bit() ? "The box does not support 32-bit Application" : "The box does not support 64-bit Application"));
            }

            PackageParser.Package aPackage = parserApk(apkFile.getAbsolutePath());
            if (aPackage == null) {
                return result.installError("Parser apk error.");
            }

            result.packageName = aPackage.packageName;
            if (option.isFlag(InstallOption.FLAG_SYSTEM)) {
                aPackage.applicationInfo = BlackBoxCore.getPackageManager().getPackageInfo(aPackage.packageName, 0).applicationInfo;
            }
            BPackageSettings bPackageSettings = mSettings.getPackageLPw(aPackage.packageName, aPackage, option);

            BProcessManagerService.get().killPackageAsUser(aPackage.packageName, userId);
            int i = BPackageInstallerService.get().installPackageAsUser(bPackageSettings, userId);
            if (i < 0) {
                return result.installError("Install apk error.");
            }

            synchronized (mPackages) {
                bPackageSettings.setInstalled(true, userId);
                bPackageSettings.save();
            }

            mComponentResolver.removeAllComponents(bPackageSettings.pkg);
            mComponentResolver.addAllComponents(bPackageSettings.pkg);
            mSettings.scanPackage(aPackage.packageName);
            onPackageInstalled(bPackageSettings.pkg.packageName, userId);
            return result;
        } catch (Throwable t) {
            t.printStackTrace();
        } finally {
            if (apkFile != null && option.isFlag(InstallOption.FLAG_URI_FILE)) {
                FileUtils.deleteDir(apkFile);
            }
            Slog.d(TAG, "Install finish: " + (System.currentTimeMillis() - l) + "ms");
        }
        return result;
    }

    private PackageParser.Package parserApk(String file) {
        try {
            PackageParser parser = PackageParserCompat.createParser();
            PackageParser.Package aPackage = PackageParserCompat.parsePackage(parser, new File(file), 0);
            PackageParserCompat.collectCertificates(parser, aPackage, 0);
            return aPackage;
        } catch (Throwable t) {
            t.printStackTrace();
        }
        return null;
    }

    static String fixProcessName(String defProcessName, String processName) {
        if (processName == null) {
            return defProcessName;
        }
        return processName;
    }

    /**
     * Update given flags based on encryption status of current user.
     */
    private int updateFlags(int flags) {
        // Caller expressed no opinion, so match based on user state
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;
        }
        return flags;
    }

    public int getAppId(String packageName) {
        BPackageSettings bPackageSettings = mPackages.get(packageName);
        if (bPackageSettings != null) {
            return bPackageSettings.appId;
        }
        return -1;
    }

    public void addPackageMonitor(PackageMonitor monitor) {
        mPackageMonitors.add(monitor);
    }

    void onPackageUninstalled(String packageName, boolean isRemove, int userId) {
        for (PackageMonitor packageMonitor : mPackageMonitors) {
            packageMonitor.onPackageUninstalled(packageName, isRemove, userId);
        }
        Slog.d(TAG, "onPackageUninstalled: " + packageName + ", userId: " + userId);
    }

    void onPackageInstalled(String packageName, int userId) {
        for (PackageMonitor packageMonitor : mPackageMonitors) {
            packageMonitor.onPackageInstalled(packageName, userId);
        }
        Slog.d(TAG, "onPackageInstalled: " + packageName + ", userId: " + userId);
    }

    public BPackageSettings getBPackageSetting(String packageName) {
        return mPackages.get(packageName);
    }

    public List<BPackageSettings> getBPackageSettings() {
        return new ArrayList<>(mPackages.values());
    }

    @Override
    public void systemReady() {
        mSettings.scanPackage();
        for (BPackageSettings value : mPackages.values()) {
            mComponentResolver.removeAllComponents(value.pkg);
            mComponentResolver.addAllComponents(value.pkg);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/BPackageSettings.java`:

```java
package com.vcore.core.system.pm;

import android.os.Parcel;
import android.os.Parcelable;
import android.util.AtomicFile;

import java.io.FileOutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.user.BUserHandle;
import com.vcore.entity.pm.InstallOption;
import com.vcore.utils.CloseUtils;
import com.vcore.utils.FileUtils;

public class BPackageSettings implements Parcelable {
    public BPackage pkg;
    public int appId;
    public InstallOption installOption;
    public Map<Integer, BPackageUserState> userState = new HashMap<>();

    public BPackageSettings() { }

    public List<BPackageUserState> getUserState() {
        return new ArrayList<>(userState.values());
    }

    public List<Integer> getUserIds() {
        return new ArrayList<>(userState.keySet());
    }

    public void setInstalled(boolean inst, int userId) {
        modifyUserState(userId).installed = inst;
    }

    public boolean getInstalled(int userId) {
        return readUserState(userId).installed;
    }

    public void removeUser(int userId) {
        userState.remove(userId);
    }

    public BPackageUserState readUserState(int userId) {
        BPackageUserState state = userState.get(userId);
        if (state == null) {
            state = new BPackageUserState();
        }

        state = new BPackageUserState(state);
        // xp模块所有用户可见、如果开启的话
        if (installOption.isFlag(InstallOption.FLAG_XPOSED) &&
                BXposedManagerService.get().isModuleEnable(pkg.packageName) &&
                BXposedManagerService.get().isXPEnable()) {
            state.installed = true;
        }

        if (userId == BUserHandle.USER_ALL) {
            state.installed = true;
        }
        return state;
    }

    private BPackageUserState modifyUserState(int userId) {
        BPackageUserState state = userState.get(userId);
        if (state == null) {
            state = new BPackageUserState();
            userState.put(userId, state);
        }
        return state;
    }

    public void save() {
        synchronized (this) {
            Parcel parcel = Parcel.obtain();
            AtomicFile atomicFile = new AtomicFile(BEnvironment.getPackageConf(pkg.packageName));
            FileOutputStream fileOutputStream = null;

            try {
                writeToParcel(parcel, 0);
                parcel.setDataPosition(0);
                fileOutputStream = atomicFile.startWrite();

                FileUtils.writeParcelToOutput(parcel, fileOutputStream);
                atomicFile.finishWrite(fileOutputStream);
            } catch (Throwable e) {
                e.printStackTrace();
                atomicFile.failWrite(fileOutputStream);
            } finally {
                parcel.recycle();
                CloseUtils.close(fileOutputStream);
            }
        }
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeParcelable(this.pkg, flags);
        dest.writeInt(this.appId);
        dest.writeParcelable(this.installOption, flags);
        dest.writeInt(this.userState.size());

        for (Map.Entry<Integer, BPackageUserState> entry : this.userState.entrySet()) {
            dest.writeValue(entry.getKey());
            dest.writeParcelable(entry.getValue(), flags);
        }
    }

    protected BPackageSettings(Parcel in) {
        this.pkg = in.readParcelable(BPackage.class.getClassLoader());
        this.appId = in.readInt();
        this.installOption = in.readParcelable(InstallOption.class.getClassLoader());
        int userStateSize = in.readInt();
        this.userState = new HashMap<>(userStateSize);

        for (int i = 0; i < userStateSize; i++) {
            Integer key = (Integer) in.readValue(Integer.class.getClassLoader());
            BPackageUserState value = in.readParcelable(BPackageUserState.class.getClassLoader());
            this.userState.put(key, value);
        }
    }

    public static final Creator<BPackageSettings> CREATOR = new Creator<BPackageSettings>() {
        @Override
        public BPackageSettings createFromParcel(Parcel source) {
            return new BPackageSettings(source);
        }

        @Override
        public BPackageSettings[] newArray(int size) {
            return new BPackageSettings[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/BPackageUserState.java`:

```java
package com.vcore.core.system.pm;

import android.os.Parcel;
import android.os.Parcelable;

public class BPackageUserState implements Parcelable {
    public boolean installed;
    public final boolean stopped;
    public final boolean hidden;

    public BPackageUserState() {
        this.installed = false;
        this.stopped = true;
        this.hidden = false;
    }

    public static BPackageUserState create() {
        BPackageUserState state = new BPackageUserState();
        state.installed = true;
        return state;
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeByte(this.installed ? (byte) 1 : (byte) 0);
        dest.writeByte(this.stopped ? (byte) 1 : (byte) 0);
        dest.writeByte(this.hidden ? (byte) 1 : (byte) 0);
    }

    protected BPackageUserState(Parcel in) {
        this.installed = in.readByte() != 0;
        this.stopped = in.readByte() != 0;
        this.hidden = in.readByte() != 0;
    }

    public BPackageUserState(BPackageUserState state) {
        this.installed = state.installed;
        this.stopped = state.stopped;
        this.hidden = state.hidden;
    }

    public static final Parcelable.Creator<BPackageUserState> CREATOR = new Parcelable.Creator<BPackageUserState>() {
        @Override
        public BPackageUserState createFromParcel(Parcel source) {
            return new BPackageUserState(source);
        }

        @Override
        public BPackageUserState[] newArray(int size) {
            return new BPackageUserState[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/BXposedManagerService.java`:

```java
package com.vcore.core.system.pm;

import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.Parcel;

import androidx.core.util.AtomicFile;

import java.io.File;
import java.io.FileOutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.ISystemService;
import com.vcore.core.system.user.BUserHandle;
import com.vcore.entity.pm.InstalledModule;
import com.vcore.entity.pm.XposedConfig;
import com.vcore.utils.CloseUtils;
import com.vcore.utils.FileUtils;
import com.vcore.utils.compat.XposedParserCompat;

public class BXposedManagerService extends IBXposedManagerService.Stub implements ISystemService, PackageMonitor {
    private static final BXposedManagerService sService = new BXposedManagerService();

    private XposedConfig mXposedConfig;
    private final Object mLock = new Object();
    private BPackageManagerService mPms;
    private final Map<String, InstalledModule> mCacheModule = new HashMap<>();

    public static BXposedManagerService get() {
        return sService;
    }

    public BXposedManagerService() { }

    @Override
    public void systemReady() {
        loadModuleStateLr();
        mPms = BPackageManagerService.get();
        mPms.addPackageMonitor(this);
    }

    @Override
    public boolean isXPEnable() {
        synchronized (mLock) {
            return mXposedConfig.enable;
        }
    }

    @Override
    public void setXPEnable(boolean enable) {
        synchronized (mLock) {
            mXposedConfig.enable = enable;
            saveModuleStateLw();
        }
    }

    @Override
    public boolean isModuleEnable(String packageName) {
        synchronized (mLock) {
            Boolean enable = mXposedConfig.moduleState.get(packageName);
            return enable != null && enable;
        }
    }

    @Override
    public void setModuleEnable(String packageName, boolean enable) {
        synchronized (mLock) {
            if (!mPms.isInstalled(packageName, BUserHandle.USER_XPOSED)) {
                return;
            }
            mXposedConfig.moduleState.put(packageName, enable);
            saveModuleStateLw();
        }
    }

    @Override
    public List<InstalledModule> getInstalledModules() {
        List<ApplicationInfo> installedApplications = mPms.getInstalledApplications(PackageManager.GET_META_DATA, BUserHandle.USER_XPOSED);
        synchronized (mCacheModule) {
            for (ApplicationInfo installedApplication : installedApplications) {
                if (mCacheModule.containsKey(installedApplication.packageName)) {
                    continue;
                }

                InstalledModule installedModule = XposedParserCompat.parseModule(installedApplication);
                if (installedModule != null) {
                    mCacheModule.put(installedApplication.packageName, installedModule);
                }
            }

            ArrayList<InstalledModule> installedModules = new ArrayList<>(mCacheModule.values());
            for (InstalledModule installedModule : installedModules) {
                installedModule.enable = isModuleEnable(installedModule.packageName);
            }
            return installedModules;
        }
    }

    private void loadModuleStateLr() {
        File xpModuleConf = BEnvironment.getXPModuleConf();
        if (!xpModuleConf.exists()) {
            mXposedConfig = new XposedConfig();
            saveModuleStateLw();
            return;
        }

        Parcel parcel = null;
        try {
            parcel = FileUtils.readToParcel(xpModuleConf);
            mXposedConfig = new XposedConfig(parcel);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (parcel != null) {
                parcel.recycle();
            }
        }
    }

    private void saveModuleStateLw() {
        Parcel parcel = Parcel.obtain();
        AtomicFile atomicFile = new AtomicFile(BEnvironment.getXPModuleConf());
        FileOutputStream fileOutputStream = null;

        try {
            mXposedConfig.writeToParcel(parcel, 0);
            parcel.setDataPosition(0);
            fileOutputStream = atomicFile.startWrite();

            FileUtils.writeParcelToOutput(parcel, fileOutputStream);
            atomicFile.finishWrite(fileOutputStream);
        } catch (Exception ignored) {
            atomicFile.failWrite(fileOutputStream);
        } finally {
            parcel.recycle();
            CloseUtils.close(fileOutputStream);
        }
    }

    @Override
    public void onPackageUninstalled(String packageName, boolean removeApp, int userId) {
        if (userId != BUserHandle.USER_XPOSED && userId != BUserHandle.USER_ALL) {
            return;
        }

        synchronized (mCacheModule) {
            mCacheModule.remove(packageName);
        }

        synchronized (mLock) {
            mXposedConfig.moduleState.remove(packageName);
            saveModuleStateLw();
        }
    }

    @Override
    public void onPackageInstalled(String packageName, int userId) {
        if (userId != BUserHandle.USER_XPOSED && userId != BUserHandle.USER_ALL) {
            return;
        }

        synchronized (mCacheModule) {
            mCacheModule.remove(packageName);
        }

        synchronized (mLock) {
            mXposedConfig.moduleState.put(packageName, false);
            saveModuleStateLw();
        }
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/ComponentResolver.java`:

```java
package com.vcore.core.system.pm;

import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageManager;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.ServiceInfo;
import android.util.ArrayMap;

import java.util.ArrayList;
import java.util.List;

import com.vcore.utils.Slog;

public class ComponentResolver {
    public static final String TAG = "ComponentResolver";

    private final Object mLock = new Object();

    /**
     * All available activities, for your resolving pleasure.
     */
    private final ActivityIntentResolver mActivities = new ActivityIntentResolver();

    /**
     * All available providers, for your resolving pleasure.
     */
    private final ProviderIntentResolver mProviders = new ProviderIntentResolver();

    /**
     * All available receivers, for your resolving pleasure.
     */
    private final ActivityIntentResolver mReceivers = new ActivityIntentResolver();

    /**
     * All available services, for your resolving pleasure.
     */
    private final ServiceIntentResolver mServices = new ServiceIntentResolver();
    /**
     * Mapping from provider authority [first directory in content URI codePath) to provider.
     */
    private final ArrayMap<String, BPackage.Provider> mProvidersByAuthority = new ArrayMap<>();

    public ComponentResolver() { }

    void addAllComponents(BPackage pkg) {
        final ArrayList<BPackage.ActivityIntentInfo> newIntents = new ArrayList<>();
        synchronized (mLock) {
            addActivitiesLocked(pkg, newIntents);
            addServicesLocked(pkg);
            addProvidersLocked(pkg);
            addReceiversLocked(pkg);
        }
    }

    void removeAllComponents(BPackage pkg) {
        synchronized (mLock) {
            removeAllComponentsLocked(pkg);
        }
    }

    private void removeAllComponentsLocked(BPackage pkg) {
        int componentSize;
        int i;

        componentSize = pkg.activities.size();
        for (i = 0; i < componentSize; i++) {
            BPackage.Activity a = pkg.activities.get(i);
            mActivities.removeActivity(a);
        }

        componentSize = pkg.providers.size();
        for (i = 0; i < componentSize; i++) {
            BPackage.Provider p = pkg.providers.get(i);
            mProviders.removeProvider(p);
            if (p.info.authority == null) {
                // Another content provider with this authority existed when this app was
                // installed, so this authority is null. Ignore it as we don't have to
                // unregister the provider.
                continue;
            }

            String[] names = p.info.authority.split(";");
            for (String name : names) {
                if (mProvidersByAuthority.get(name) == p) {
                    mProvidersByAuthority.remove(name);
                }
            }
            mProvidersByAuthority.remove(p.info.authority);
        }

        componentSize = pkg.receivers.size();
        for (i = 0; i < componentSize; i++) {
            BPackage.Activity a = pkg.receivers.get(i);
            mReceivers.removeActivity(a);
        }

        componentSize = pkg.services.size();
        for (i = 0; i < componentSize; i++) {
            BPackage.Service s = pkg.services.get(i);
            mServices.removeService(s);
        }
    }

    private void addActivitiesLocked(BPackage pkg, List<BPackage.ActivityIntentInfo> newIntents) {
        final int activitiesSize = pkg.activities.size();
        for (int i = 0; i < activitiesSize; i++) {
            BPackage.Activity a = pkg.activities.get(i);
            a.info.processName = BPackageManagerService.fixProcessName(pkg.applicationInfo.processName, a.info.processName);
            mActivities.addActivity(a, "activity", newIntents);
        }
    }

    private void addProvidersLocked(BPackage pkg) {
        final int providersSize = pkg.providers.size();
        for (int i = 0; i < providersSize; i++) {
            BPackage.Provider p = pkg.providers.get(i);
            p.info.processName = BPackageManagerService.fixProcessName(pkg.applicationInfo.processName, p.info.processName);
            mProviders.addProvider(p);

            if (p.info.authority != null) {
                String[] names = p.info.authority.split(";");
                p.info.authority = null;
                for (String name : names) {
                    if (!mProvidersByAuthority.containsKey(name)) {
                        mProvidersByAuthority.put(name, p);
                        if (p.info.authority == null) {
                            p.info.authority = name;
                        } else {
                            p.info.authority = p.info.authority + ";" + name;
                        }
                    } else {
                        final BPackage.Provider other = mProvidersByAuthority.get(name);
                        final ComponentName component = (other != null && other.getComponentName() != null) ? other.getComponentName() : null;
                        final String packageName = component != null ? component.getPackageName() : "?";

                        Slog.w(TAG, "Skipping provider name " + name + " (in package " + pkg.applicationInfo.packageName + ")"
                                + ": name already used by " + packageName);
                    }
                }
            }
        }
    }

    private void addReceiversLocked(BPackage pkg) {
        final int receiversSize = pkg.receivers.size();
        for (int i = 0; i < receiversSize; i++) {
            BPackage.Activity a = pkg.receivers.get(i);
            a.info.processName = BPackageManagerService.fixProcessName(pkg.applicationInfo.processName, a.info.processName);
            mReceivers.addActivity(a, "receiver", null);
        }
    }

    private void addServicesLocked(BPackage pkg) {
        final int servicesSize = pkg.services.size();
        for (int i = 0; i < servicesSize; i++) {
            BPackage.Service s = pkg.services.get(i);
            s.info.processName = BPackageManagerService.fixProcessName(pkg.applicationInfo.processName, s.info.processName);
            mServices.addService(s);
        }
    }

    /**
     * Returns the given activity
     */
    BPackage.Activity getActivity(ComponentName component) {
        synchronized (mLock) {
            return mActivities.mActivities.get(component);
        }
    }

    /**
     * Returns the given provider
     */
    BPackage.Provider getProvider(ComponentName component) {
        synchronized (mLock) {
            return mProviders.mProviders.get(component);
        }
    }

    /**
     * Returns the given receiver
     */
    BPackage.Activity getReceiver(ComponentName component) {
        synchronized (mLock) {
            return mReceivers.mActivities.get(component);
        }
    }

    /**
     * Returns the given service
     */
    BPackage.Service getService(ComponentName component) {
        synchronized (mLock) {
            return mServices.mServices.get(component);
        }
    }

    List<ResolveInfo> queryActivities(Intent intent, String resolvedType, int flags, int userId) {
        synchronized (mLock) {
            return mActivities.queryIntent(intent, resolvedType, flags, userId);
        }
    }

    List<ResolveInfo> queryActivities(Intent intent, String resolvedType, int flags, List<BPackage.Activity> activities, int userId) {
        synchronized (mLock) {
            return mActivities.queryIntentForPackage(intent, resolvedType, flags, activities, userId);
        }
    }

    List<ProviderInfo> queryProviders(String processName, int flags, int userId) {
        List<ProviderInfo> providerList = new ArrayList<>();
        synchronized (mLock) {
            for (int i = mProviders.mProviders.size() - 1; i >= 0; --i) {
                final BPackage.Provider p = mProviders.mProviders.valueAt(i);
                final BPackageSettings ps = p.owner.mExtras;
                if (ps == null) {
                    continue;
                }

                if (p.info.authority == null) {
                    continue;
                }

                if (processName != null && (!p.info.processName.equals(processName))) {
                    continue;
                }
                // See PM.queryContentProviders()'s javadoc for why we have the metaData parameter.
                final ProviderInfo info = PackageManagerCompat.generateProviderInfo(p, flags, ps.readUserState(userId), userId);
                if (info == null) {
                    continue;
                }
                providerList.add(info);
            }
        }
        return providerList;
    }

    ProviderInfo queryProvider(String authority, int flags, int userId) {
        synchronized (mLock) {
            final BPackage.Provider p = mProvidersByAuthority.get(authority);
            if (p == null) {
                return null;
            }

            BPackageSettings ps = p.owner.mExtras;
            return PackageManagerCompat.generateProviderInfo(p, flags, ps.readUserState(userId), userId);
        }
    }

    List<ResolveInfo> queryReceivers(Intent intent, String resolvedType, int flags, int userId) {
        synchronized (mLock) {
            return mReceivers.queryIntent(intent, resolvedType, flags, userId);
        }
    }

    List<ResolveInfo> queryReceivers(Intent intent, String resolvedType, int flags, List<BPackage.Activity> receivers, int userId) {
        synchronized (mLock) {
            return mReceivers.queryIntentForPackage(intent, resolvedType, flags, receivers, userId);
        }
    }

    List<ResolveInfo> queryServices(Intent intent, String resolvedType, int flags, int userId) {
        synchronized (mLock) {
            return mServices.queryIntent(intent, resolvedType, flags, userId);
        }
    }

    List<ResolveInfo> queryServices(Intent intent, String resolvedType, int flags, List<BPackage.Service> services, int userId) {
        synchronized (mLock) {
            return mServices.queryIntentForPackage(intent, resolvedType, flags, services, userId);
        }
    }

    private static final class ServiceIntentResolver extends IntentResolver<BPackage.ServiceIntentInfo, ResolveInfo> {

        @Override
        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
            mFlags = defaultOnly ? PackageManager.MATCH_DEFAULT_ONLY : 0;
            return super.queryIntent(intent, resolvedType, defaultOnly, userId);
        }

        List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags, int userId) {
            mFlags = flags;
            return super.queryIntent(intent, resolvedType, (flags & PackageManager.MATCH_DEFAULT_ONLY) != 0, userId);
        }

        List<ResolveInfo> queryIntentForPackage(Intent intent, String resolvedType, int flags, List<BPackage.Service> packageServices, int userId) {
            if (packageServices == null) {
                return null;
            }

            mFlags = flags;
            final boolean defaultOnly = (flags & PackageManager.MATCH_DEFAULT_ONLY) != 0;
            final int servicesSize = packageServices.size();

            ArrayList<BPackage.ServiceIntentInfo[]> listCut = new ArrayList<>(servicesSize);
            ArrayList<BPackage.ServiceIntentInfo> intentFilters;

            for (int i = 0; i < servicesSize; ++i) {
                intentFilters = packageServices.get(i).intents;
                if (intentFilters != null && intentFilters.size() > 0) {
                    BPackage.ServiceIntentInfo[] array = new BPackage.ServiceIntentInfo[intentFilters.size()];
                    intentFilters.toArray(array);
                    listCut.add(array);
                }
            }
            return super.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);
        }

        void addService(BPackage.Service s) {
            mServices.put(s.getComponentName(), s);
            final int intentsSize = s.intents.size();
            int j;

            for (j = 0; j < intentsSize; j++) {
                BPackage.ServiceIntentInfo intent = s.intents.get(j);
                addFilter(intent);
            }
        }

        void removeService(BPackage.Service s) {
            mServices.remove(s.getComponentName());
            final int intentsSize = s.intents.size();
            int j;

            for (j = 0; j < intentsSize; j++) {
                BPackage.ServiceIntentInfo intent = s.intents.get(j);
                removeFilter(intent);
            }
        }

        @Override
        protected boolean isPackageForFilter(String packageName, BPackage.ServiceIntentInfo info) {
            return packageName.equals(info.service.owner.packageName);
        }

        @Override
        protected BPackage.ServiceIntentInfo[] newArray(int size) {
            return new BPackage.ServiceIntentInfo[size];
        }

        @Override
        protected ResolveInfo newResult(BPackage.ServiceIntentInfo filter, int match, int userId) {
            final BPackage.Service service = filter.service;
            BPackageSettings ps = service.owner.mExtras;
            if (ps == null) {
                return null;
            }

            ServiceInfo si = PackageManagerCompat.generateServiceInfo(service, mFlags, ps.readUserState(userId), userId);
            final ResolveInfo res = new ResolveInfo();
            res.serviceInfo = si;
            if ((mFlags & PackageManager.GET_RESOLVED_FILTER) != 0) {
                res.filter = filter.intentFilter;
            }

            res.priority = filter.intentFilter.getPriority();
            res.preferredOrder = service.owner.mPreferredOrder;
            res.match = match;
            res.isDefault = filter.hasDefault;
            res.labelRes = filter.labelRes;
            res.nonLocalizedLabel = filter.nonLocalizedLabel;
            res.icon = filter.icon;
            return res;
        }

        // Keys are String (activity class name), values are Activity.
        private final ArrayMap<ComponentName, BPackage.Service> mServices = new ArrayMap<>();
        private int mFlags;
    }


    private static final class ActivityIntentResolver extends IntentResolver<BPackage.ActivityIntentInfo, ResolveInfo> {

        @Override
        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
            mFlags = (defaultOnly ? PackageManager.MATCH_DEFAULT_ONLY : 0);
            return super.queryIntent(intent, resolvedType, defaultOnly, userId);
        }

        List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags, int userId) {
            mFlags = flags;
            return super.queryIntent(intent, resolvedType, (flags & PackageManager.MATCH_DEFAULT_ONLY) != 0, userId);
        }

        List<ResolveInfo> queryIntentForPackage(Intent intent, String resolvedType, int flags, List<BPackage.Activity> packageActivities, int userId) {
            if (packageActivities == null) {
                return null;
            }

            mFlags = flags;
            final boolean defaultOnly = (flags & PackageManager.MATCH_DEFAULT_ONLY) != 0;
            final int activitiesSize = packageActivities.size();

            ArrayList<BPackage.ActivityIntentInfo[]> listCut = new ArrayList<>(activitiesSize);
            ArrayList<BPackage.ActivityIntentInfo> intentFilters;

            for (int i = 0; i < activitiesSize; ++i) {
                intentFilters = packageActivities.get(i).intents;
                if (intentFilters != null && intentFilters.size() > 0) {
                    BPackage.ActivityIntentInfo[] array = new BPackage.ActivityIntentInfo[intentFilters.size()];
                    intentFilters.toArray(array);
                    listCut.add(array);
                }
            }
            return super.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);
        }

        private void addActivity(BPackage.Activity a, String type, List<BPackage.ActivityIntentInfo> newIntents) {
            mActivities.put(a.getComponentName(), a);
            final int intentsSize = a.intents.size();

            for (int j = 0; j < intentsSize; j++) {
                BPackage.ActivityIntentInfo intent = a.intents.get(j);
                if (newIntents != null && "activity".equals(type)) {
                    newIntents.add(intent);
                }
                addFilter(intent);
            }
        }

        private void removeActivity(BPackage.Activity a) {
            mActivities.remove(a.getComponentName());
            final int intentsSize = a.intents.size();

            for (int j = 0; j < intentsSize; j++) {
                BPackage.ActivityIntentInfo intent = a.intents.get(j);
                removeFilter(intent);
            }
        }

        @Override
        protected boolean isPackageForFilter(String packageName, BPackage.ActivityIntentInfo info) {
            return packageName.equals(info.activity.owner.packageName);
        }

        @Override
        protected BPackage.ActivityIntentInfo[] newArray(int size) {
            return new BPackage.ActivityIntentInfo[size];
        }

        @Override
        protected ResolveInfo newResult(BPackage.ActivityIntentInfo info, int match, int userId) {
            final BPackage.Activity activity = info.activity;
            BPackageSettings ps = activity.owner.mExtras;
            if (ps == null) {
                return null;
            }

            ActivityInfo ai = PackageManagerCompat.generateActivityInfo(activity, mFlags, ps.readUserState(userId), userId);
            final ResolveInfo res = new ResolveInfo();
            res.activityInfo = ai;
            if ((mFlags & PackageManager.GET_RESOLVED_FILTER) != 0) {
                res.filter = info.intentFilter;
            }

            res.priority = info.intentFilter.getPriority();
            res.preferredOrder = activity.owner.mPreferredOrder;
            res.match = match;
            res.isDefault = info.hasDefault;
            res.labelRes = info.labelRes;
            res.nonLocalizedLabel = info.nonLocalizedLabel;
            res.icon = info.icon;
            return res;
        }

        // Keys are String (activity class name), values are Activity.
        private final ArrayMap<ComponentName, BPackage.Activity> mActivities = new ArrayMap<>();
        private int mFlags;
    }

    private static final class ProviderIntentResolver
            extends IntentResolver<BPackage.ProviderIntentInfo, ResolveInfo> {
        @Override
        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
            mFlags = defaultOnly ? PackageManager.MATCH_DEFAULT_ONLY : 0;
            return super.queryIntent(intent, resolvedType, defaultOnly, userId);
        }

        void addProvider(BPackage.Provider p) {
            mProviders.put(p.getComponentName(), p);
            final int intentsSize = p.intents.size();
            int j;

            for (j = 0; j < intentsSize; j++) {
                BPackage.ProviderIntentInfo intent = p.intents.get(j);
                addFilter(intent);
            }
        }

        void removeProvider(BPackage.Provider p) {
            mProviders.remove(p.getComponentName());
            final int intentsSize = p.intents.size();
            int j;

            for (j = 0; j < intentsSize; j++) {
                BPackage.ProviderIntentInfo intent = p.intents.get(j);
                removeFilter(intent);
            }
        }

        @Override
        protected boolean allowFilterResult(BPackage.ProviderIntentInfo filter, List<ResolveInfo> dest) {
            ProviderInfo filterPi = filter.provider.info;
            for (int i = dest.size() - 1; i >= 0; i--) {
                ProviderInfo destPi = dest.get(i).providerInfo;
                if (destPi.name.equals(filterPi.name) && destPi.packageName.equals(filterPi.packageName)) {
                    return false;
                }
            }
            return true;
        }

        @Override
        protected BPackage.ProviderIntentInfo[] newArray(int size) {
            return new BPackage.ProviderIntentInfo[size];
        }

        @Override
        protected boolean isPackageForFilter(String packageName, BPackage.ProviderIntentInfo info) {
            return packageName.equals(info.provider.owner.packageName);
        }

        @Override
        protected ResolveInfo newResult(BPackage.ProviderIntentInfo filter, int match, int userId) {
            final BPackage.Provider provider = filter.provider;
            BPackageSettings ps = provider.owner.mExtras;
            if (ps == null) {
                return null;
            }

            ProviderInfo pi = PackageManagerCompat.generateProviderInfo(provider, mFlags, ps.readUserState(userId), userId);
            final ResolveInfo res = new ResolveInfo();
            res.providerInfo = pi;
            if ((mFlags & PackageManager.GET_RESOLVED_FILTER) != 0) {
                res.filter = filter.intentFilter;
            }

            res.priority = filter.intentFilter.getPriority();
            res.preferredOrder = provider.owner.mPreferredOrder;
            res.match = match;
            res.isDefault = filter.hasDefault;
            res.labelRes = filter.labelRes;
            res.nonLocalizedLabel = filter.nonLocalizedLabel;
            res.icon = filter.icon;
            return res;
        }

        private final ArrayMap<ComponentName, BPackage.Provider> mProviders = new ArrayMap<>();
        private int mFlags;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/FastImmutableArraySet.java`:

```java
package com.vcore.core.system.pm;

import androidx.annotation.NonNull;

import java.util.AbstractSet;
import java.util.Iterator;

/**
 * A fast immutable set wrapper for an array that is optimized for non-concurrent iteration.
 * The same iterator instance is reused each time to avoid creating lots of garbage.
 * Iterating over an array in this fashion is 2.5x faster than iterating over a {@link HashSet}
 * so it is worth copying the contents of the set to an array when iterating over it
 * hundreds of times.
 * @hide
 */
public final class FastImmutableArraySet<T> extends AbstractSet<T> {
    FastIterator<T> mIterator;
    final T[] mContents;

    public FastImmutableArraySet(T[] contents) {
        this.mContents = contents;
    }

    @NonNull
    @Override
    public Iterator<T> iterator() {
        FastIterator<T> it = mIterator;
        if (it == null) {
            it = new FastIterator<>(mContents);
            mIterator = it;
        } else {
            it.mIndex = 0;
        }
        return it;
    }

    @Override
    public int size() {
        return mContents.length;
    }

    private static final class FastIterator<T> implements Iterator<T> {
        private final T[] mContents;
        int mIndex;

        public FastIterator(T[] contents) {
            this.mContents = contents;
        }

        @Override
        public boolean hasNext() {
            return mIndex != mContents.length;
        }

        @Override
        public T next() {
            return mContents[mIndex++];
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/IntentResolver.java`:

```java
package com.vcore.core.system.pm;

import android.content.Intent;
import android.content.IntentFilter;
import android.net.Uri;
import android.util.ArrayMap;
import android.util.Log;
import android.util.LogPrinter;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import com.vcore.utils.Slog;

/**
 * {@hide}
 */
public abstract class IntentResolver<F extends BPackage.IntentInfo, R> {
    final private static String TAG = "IntentResolver";
    final private static boolean DEBUG = false;
    final private static boolean localLOGV = DEBUG;

    public void addFilter(F f) {
        if (localLOGV) {
            Slog.v(TAG, "Adding filter: " + f);
            f.intentFilter.dump(new LogPrinter(Log.VERBOSE, TAG), "      ");
            Slog.v(TAG, "    Building Lookup Maps:");
        }

        int numS = register_intent_filter(f, f.intentFilter.schemesIterator(), mSchemeToFilter, "      Scheme: ");
        int numT = register_mime_types(f);
        if (numS == 0 && numT == 0) {
            register_intent_filter(f, f.intentFilter.actionsIterator(), mActionToFilter, "      Action: ");
        }

        if (numT != 0) {
            register_intent_filter(f, f.intentFilter.actionsIterator(),
                    mTypedActionToFilter, "      TypedAction: ");
        }
    }

    public void removeFilter(F f) {
        removeFilterInternal(f);
    }

    void removeFilterInternal(F f) {
        if (localLOGV) {
            Slog.v(TAG, "Removing filter: " + f);
            f.intentFilter.dump(new LogPrinter(Log.VERBOSE, TAG), "      ");
            Slog.v(TAG, "    Cleaning Lookup Maps:");
        }

        int numS = unregister_intent_filter(f, f.intentFilter.schemesIterator(), mSchemeToFilter, "      Scheme: ");
        int numT = unregister_mime_types(f);
        if (numS == 0 && numT == 0) {
            unregister_intent_filter(f, f.intentFilter.actionsIterator(), mActionToFilter, "      Action: ");
        }

        if (numT != 0) {
            unregister_intent_filter(f, f.intentFilter.actionsIterator(), mTypedActionToFilter, "      TypedAction: ");
        }
    }

    public List<R> queryIntentFromList(Intent intent, String resolvedType, boolean defaultOnly, ArrayList<F[]> listCut, int userId) {
        ArrayList<R> resultList = new ArrayList<>();
        final boolean debug = localLOGV || ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);

        FastImmutableArraySet<String> categories = getFastIntentCategories(intent);
        final String scheme = intent.getScheme();
        int N = listCut.size();

        for (int i = 0; i < N; ++i) {
            buildResolveList(intent, categories, debug, defaultOnly, resolvedType, scheme, listCut.get(i), resultList, userId);
        }
        return resultList;
    }

    public List<R> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
        String scheme = intent.getScheme();
        ArrayList<R> finalList = new ArrayList<>();

        final boolean debug = localLOGV || ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);
        if (debug) {
            Slog.v(TAG, "Resolving type=" + resolvedType + " scheme=" + scheme + " defaultOnly=" + defaultOnly + " userId=" + userId + " of " + intent);
        }

        F[] firstTypeCut = null;
        F[] secondTypeCut = null;
        F[] thirdTypeCut = null;
        F[] schemeCut = null;

        // If the intent includes a MIME type, then we want to collect all of
        // the filters that match that MIME type.
        if (resolvedType != null) {
            int slashPos = resolvedType.indexOf('/');
            if (slashPos > 0) {
                final String baseType = resolvedType.substring(0, slashPos);
                if (!baseType.equals("*")) {
                    if (resolvedType.length() != slashPos + 2 || resolvedType.charAt(slashPos+1) != '*') {
                        // Not a wild card, so we can just look for all filters that
                        // completely match or wildcards whose base type matches.
                        firstTypeCut = mTypeToFilter.get(resolvedType);
                    } else {
                        // We can match anything with our base type.
                        firstTypeCut = mBaseTypeToFilter.get(baseType);
                    }

                    if (debug) {
                        Slog.v(TAG, "First type cut: " + Arrays.toString(firstTypeCut));
                    }

                    secondTypeCut = mWildTypeToFilter.get(baseType);
                    if (debug) {
                        Slog.v(TAG, "Second type cut: " + Arrays.toString(secondTypeCut));
                    }
                    // Any */* types always apply, but we only need to do this
                    // if the intent type was not already */*.
                    thirdTypeCut = mWildTypeToFilter.get("*");
                    if (debug) {
                        Slog.v(TAG, "Third type cut: " + Arrays.toString(thirdTypeCut));
                    }
                } else if (intent.getAction() != null) {
                    // The intent specified any type ({@literal *}/*).  This
                    // can be a whole heck of a lot of things, so as a first
                    // cut let's use the action instead.
                    firstTypeCut = mTypedActionToFilter.get(intent.getAction());
                    if (debug) {
                        Slog.v(TAG, "Typed Action list: " + Arrays.toString(firstTypeCut));
                    }
                }
            }
        }

        // If the intent includes a data URI, then we want to collect all of
        // the filters that match its scheme (we will further refine matches
        // on the authority and path by directly matching each resulting filter).
        if (scheme != null) {
            schemeCut = mSchemeToFilter.get(scheme);
            if (debug) {
                Slog.v(TAG, "Scheme list: " + Arrays.toString(schemeCut));
            }
        }

        // If the intent does not specify any data -- either a MIME type or
        // a URI -- then we will only be looking for matches against empty
        // data.
        if (resolvedType == null && scheme == null && intent.getAction() != null) {
            firstTypeCut = mActionToFilter.get(intent.getAction());
            if (debug) {
                Slog.v(TAG, "Action list: " + Arrays.toString(firstTypeCut));
            }
        }

        FastImmutableArraySet<String> categories = getFastIntentCategories(intent);
        if (firstTypeCut != null) {
            buildResolveList(intent, categories, debug, defaultOnly, resolvedType, scheme, firstTypeCut, finalList, userId);
        }

        if (secondTypeCut != null) {
            buildResolveList(intent, categories, debug, defaultOnly, resolvedType, scheme, secondTypeCut, finalList, userId);
        }

        if (thirdTypeCut != null) {
            buildResolveList(intent, categories, debug, defaultOnly, resolvedType, scheme, thirdTypeCut, finalList, userId);
        }

        if (schemeCut != null) {
            buildResolveList(intent, categories, debug, defaultOnly, resolvedType, scheme, schemeCut, finalList, userId);
        }

        if (debug) {
            Slog.v(TAG, "Final result list:");
            for (int i=0; i<finalList.size(); i++) {
                Slog.v(TAG, "  " + finalList.get(i));
            }
        }
        return finalList;
    }

    /**
     * Control whether the given filter is allowed to go into the result
     * list.  Mainly intended to prevent adding multiple filters for the
     * same target object.
     */
    protected boolean allowFilterResult(F filter, List<R> dest) {
        return true;
    }

    /**
     * Returns whether this filter is owned by this package. This must be
     * implemented to provide correct filtering of Intents that have
     * specified a package name they are to be delivered to.
     */
    protected abstract boolean isPackageForFilter(String packageName, F filter);

    protected abstract F[] newArray(int size);

    @SuppressWarnings("unchecked")
    protected R newResult(F filter, int match, int userId) {
        return (R)filter;
    }

    private void addFilter(ArrayMap<String, F[]> map, String name, F filter) {
        F[] array = map.get(name);
        if (array == null) {
            array = newArray(2);
            map.put(name,  array);
            array[0] = filter;
        } else {
            final int N = array.length;
            int i = N;
            while (i > 0 && array[i-1] == null) {
                i--;
            }

            if (i < N) {
                array[i] = filter;
            } else {
                F[] newArray = newArray((N*3)/2);
                System.arraycopy(array, 0, newArray, 0, N);
                newArray[N] = filter;
                map.put(name, newArray);
            }
        }
    }

    private int register_mime_types(F filter) {
        final Iterator<String> i = filter.intentFilter.typesIterator();
        if (i == null) {
            return 0;
        }

        int num = 0;
        while (i.hasNext()) {
            String name = i.next();
            num++;

            if (localLOGV) {
                Slog.v(TAG, "      Type: " + name);
            }

            String baseName = name;
            final int slashPos = name.indexOf('/');
            if (slashPos > 0) {
                baseName = name.substring(0, slashPos).intern();
            } else {
                name = name + "/*";
            }

            addFilter(mTypeToFilter, name, filter);
            if (slashPos > 0) {
                addFilter(mBaseTypeToFilter, baseName, filter);
            } else {
                addFilter(mWildTypeToFilter, baseName, filter);
            }
        }
        return num;
    }

    private int unregister_mime_types(F filter) {
        final Iterator<String> i = filter.intentFilter.typesIterator();
        if (i == null) {
            return 0;
        }

        int num = 0;
        while (i.hasNext()) {
            String name = i.next();
            num++;

            if (localLOGV) {
                Slog.v(TAG, "      Type: " + name);
            }

            String baseName = name;
            final int slashPos = name.indexOf('/');
            if (slashPos > 0) {
                baseName = name.substring(0, slashPos).intern();
            } else {
                name = name + "/*";
            }

            remove_all_objects(mTypeToFilter, name, filter);
            if (slashPos > 0) {
                remove_all_objects(mBaseTypeToFilter, baseName, filter);
            } else {
                remove_all_objects(mWildTypeToFilter, baseName, filter);
            }
        }
        return num;
    }

    private int register_intent_filter(F filter, Iterator<String> i, ArrayMap<String, F[]> dest, String prefix) {
        if (i == null) {
            return 0;
        }

        int num = 0;
        while (i.hasNext()) {
            String name = i.next();
            num++;

            if (localLOGV) {
                Slog.v(TAG, prefix + name);
            }
            addFilter(dest, name, filter);
        }
        return num;
    }

    private int unregister_intent_filter(F filter, Iterator<String> i, ArrayMap<String, F[]> dest, String prefix) {
        if (i == null) {
            return 0;
        }

        int num = 0;
        while (i.hasNext()) {
            String name = i.next();
            num++;

            if (localLOGV) {
                Slog.v(TAG, prefix + name);
            }
            remove_all_objects(dest, name, filter);
        }
        return num;
    }

    private void remove_all_objects(ArrayMap<String, F[]> map, String name, Object object) {
        F[] array = map.get(name);
        if (array != null) {
            int LAST = array.length-1;
            while (LAST >= 0 && array[LAST] == null) {
                LAST--;
            }

            for (int idx=LAST; idx>=0; idx--) {
                if (array[idx] == object) {
                    final int remain = LAST - idx;
                    if (remain > 0) {
                        System.arraycopy(array, idx+1, array, idx, remain);
                    }

                    array[LAST] = null;
                    LAST--;
                }
            }

            if (LAST < 0) {
                map.remove(name);
            } else if (LAST < (array.length/2)) {
                F[] newArray = newArray(LAST+2);
                System.arraycopy(array, 0, newArray, 0, LAST+1);
                map.put(name, newArray);
            }
        }
    }

    private static FastImmutableArraySet<String> getFastIntentCategories(Intent intent) {
        final Set<String> categories = intent.getCategories();
        if (categories == null) {
            return null;
        }
        return new FastImmutableArraySet<>(categories.toArray(new String[0]));
    }

    private void buildResolveList(Intent intent, FastImmutableArraySet<String> categories, boolean debug, boolean defaultOnly, String resolvedType, String scheme,
            F[] src, List<R> dest, int userId) {
        final String action = intent.getAction();
        final Uri data = intent.getData();
        final String packageName = intent.getPackage();

        final int N = src != null ? src.length : 0;
        boolean hasNonDefaults = false;
        int i;
        F filter;

        for (i = 0; i < N && (filter = src[i]) != null; i++) {
            int match;
            if (debug) {
                Slog.v(TAG, "Matching against filter " + filter);
            }

            // Is delivery being limited to filters owned by a particular package?
            if (packageName != null && !isPackageForFilter(packageName, filter)) {
                if (debug) {
                    Slog.v(TAG, "  Filter is not from package " + packageName + "; skipping");
                }
                continue;
            }

            // Do we already have this one?
            if (!allowFilterResult(filter, dest)) {
                if (debug) {
                    Slog.v(TAG, "  Filter's target already added");
                }
                continue;
            }

            match = filter.intentFilter.match(action, resolvedType, scheme, data, categories, TAG);
            if (match >= 0) {
                if (debug) {
                    Slog.v(TAG, "  Filter matched!  match=0x" + Integer.toHexString(match) + " hasDefault="
                            + filter.intentFilter.hasCategory(Intent.CATEGORY_DEFAULT));
                }

                if (!defaultOnly || filter.intentFilter.hasCategory(Intent.CATEGORY_DEFAULT)) {
                    final R oneResult = newResult(filter, match, userId);
                    if (debug) {
                        Slog.v(TAG, "    Created result: " + oneResult);
                    }

                    if (oneResult != null) {
                        dest.add(oneResult);
                    }
                } else {
                    hasNonDefaults = true;
                }
            } else {
                if (debug) {
                    String reason;
                    switch (match) {
                        case IntentFilter.NO_MATCH_ACTION: reason = "action"; break;
                        case IntentFilter.NO_MATCH_CATEGORY: reason = "category"; break;
                        case IntentFilter.NO_MATCH_DATA: reason = "data"; break;
                        case IntentFilter.NO_MATCH_TYPE: reason = "type"; break;
                        default: reason = "unknown reason"; break;
                    }
                    Slog.v(TAG, "  Filter did not match: " + reason);
                }
            }
        }

        if (debug && hasNonDefaults) {
            if (dest.size() == 0) {
                Slog.v(TAG, "resolveIntent failed: found match, but none with CATEGORY_DEFAULT");
            } else if (dest.size() > 1) {
                Slog.v(TAG, "resolveIntent: multiple matches, only some with CATEGORY_DEFAULT");
            }
        }
    }

    /**
     * All of the MIME types that have been registered, such as "image/jpeg",
     * "image/*", or "{@literal *}/*".
     */
    private final ArrayMap<String, F[]> mTypeToFilter = new ArrayMap<>();

    /**
     * The base names of all of all fully qualified MIME types that have been
     * registered, such as "image" or "*".  Wild card MIME types such as
     * "image/*" will not be here.
     */
    private final ArrayMap<String, F[]> mBaseTypeToFilter = new ArrayMap<>();

    /**
     * The base names of all of the MIME types with a sub-type wildcard that
     * have been registered.  For example, a filter with "image/*" will be
     * included here as "image" but one with "image/jpeg" will not be
     * included here.  This also includes the "*" for the "{@literal *}/*"
     * MIME type.
     */
    private final ArrayMap<String, F[]> mWildTypeToFilter = new ArrayMap<>();

    /**
     * All of the URI schemes (such as http) that have been registered.
     */
    private final ArrayMap<String, F[]> mSchemeToFilter = new ArrayMap<>();

    /**
     * All of the actions that have been registered, but only those that did
     * not specify data.
     */
    private final ArrayMap<String, F[]> mActionToFilter = new ArrayMap<>();

    /**
     * All of the actions that have been registered and specified a MIME type.
     */
    private final ArrayMap<String, F[]> mTypedActionToFilter = new ArrayMap<>();
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/PackageManagerCompat.java`:

```java
package com.vcore.core.system.pm;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.ConfigurationInfo;
import android.content.pm.FeatureInfo;
import android.content.pm.InstrumentationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PermissionInfo;
import android.content.pm.ProviderInfo;
import android.content.pm.ServiceInfo;
import android.content.res.AssetManager;
import android.content.res.Resources;
import android.os.Build;

import java.util.HashSet;
import java.util.Set;

import black.android.content.pm.ApplicationInfoL;
import black.android.content.pm.ApplicationInfoN;
import black.android.content.pm.SigningInfo;
import com.vcore.BlackBoxCore;
import com.vcore.core.env.AppSystemEnv;
import com.vcore.core.env.BEnvironment;
import com.vcore.entity.pm.InstallOption;
import com.vcore.utils.ArrayUtils;
import com.vcore.utils.FileUtils;
import com.vcore.utils.compat.BuildCompat;

@SuppressLint({"SdCardPath", "NewApi"})
public class PackageManagerCompat {
    public static PackageInfo generatePackageInfo(BPackageSettings ps, int flags, BPackageUserState state, int userId) {
        if (ps == null) {
            return null;
        }

        BPackage p = ps.pkg;
        if (p != null) {
            PackageInfo packageInfo = null;
            try {
                packageInfo = generatePackageInfo(p, flags, 0, 0, state, userId);
            } catch (Throwable ignored) { }
            return packageInfo;
        }
        return null;
    }

    public static PackageInfo generatePackageInfo(BPackage p, int flags, long firstInstallTime, long lastUpdateTime, BPackageUserState state, int userId) {
        if (checkUseInstalledOrHidden(state, p.applicationInfo)) {
            return null;
        }

        PackageInfo pi = new PackageInfo();
        pi.packageName = p.packageName;
        pi.versionCode = p.mVersionCode;
        pi.versionName = p.mVersionName;
        pi.sharedUserId = p.mSharedUserId;
        pi.sharedUserLabel = p.mSharedUserLabel;
        pi.applicationInfo = generateApplicationInfo(p, flags, state, userId);

        pi.firstInstallTime = firstInstallTime;
        pi.lastUpdateTime = lastUpdateTime;
        if (!p.requestedPermissions.isEmpty()) {
            String[] requestedPermissions = new String[p.requestedPermissions.size()];
            p.requestedPermissions.toArray(requestedPermissions);
            pi.requestedPermissions = requestedPermissions;
        }

        if ((flags & PackageManager.GET_GIDS) != 0) {
            pi.gids = new int[]{};
        }

        if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
            int N = p.configPreferences != null ? p.configPreferences.size() : 0;
            if (N > 0) {
                pi.configPreferences = new ConfigurationInfo[N];
                p.configPreferences.toArray(pi.configPreferences);
            }

            N = p.reqFeatures != null ? p.reqFeatures.size() : 0;
            if (N > 0) {
                pi.reqFeatures = new FeatureInfo[N];
                p.reqFeatures.toArray(pi.reqFeatures);
            }
        }

        if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
            pi.activities = null;
            final int N = p.activities.size();

            if (N > 0) {
                int num = 0;
                final ActivityInfo[] res = new ActivityInfo[N];
                for (int i = 0; i < N; i++) {
                    final BPackage.Activity a = p.activities.get(i);
                    res[num++] = generateActivityInfo(a, flags, state, userId);
                }

                pi.activities = ArrayUtils.trimToSize(res, num);
            }
        }

        if ((flags & PackageManager.GET_RECEIVERS) != 0) {
            pi.receivers = null;
            final int N = p.receivers.size();

            if (N > 0) {
                int num = 0;
                final ActivityInfo[] res = new ActivityInfo[N];
                for (int i = 0; i < N; i++) {
                    final BPackage.Activity a = p.receivers.get(i);
                    res[num++] = generateActivityInfo(a, flags, state, userId);
                }

                pi.receivers = ArrayUtils.trimToSize(res, num);
            }
        }

        if ((flags & PackageManager.GET_SERVICES) != 0) {
            pi.services = null;
            final int N = p.services.size();
            if (N > 0) {
                int num = 0;
                final ServiceInfo[] res = new ServiceInfo[N];
                for (int i = 0; i < N; i++) {
                    final BPackage.Service s = p.services.get(i);
                    res[num++] = generateServiceInfo(s, flags, state, userId);
                }

                pi.services = ArrayUtils.trimToSize(res, num);
            }
        }

        if ((flags & PackageManager.GET_PROVIDERS) != 0) {
            pi.providers = null;
            final int N = p.providers.size();

            if (N > 0) {
                int num = 0;
                final ProviderInfo[] res = new ProviderInfo[N];
                for (int i = 0; i < N; i++) {
                    final BPackage.Provider pr = p.providers.get(i);
                    ProviderInfo providerInfo = generateProviderInfo(pr, flags, state, userId);
                    if (providerInfo != null) {
                        res[num++] = providerInfo;
                    }
                }

                pi.providers = ArrayUtils.trimToSize(res, num);
            }
        }

        if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
            pi.instrumentation = null;
            int N = p.instrumentation.size();
            if (N > 0) {
                pi.instrumentation = new InstrumentationInfo[N];
                for (int i = 0; i < N; i++) {
                    pi.instrumentation[i] = generateInstrumentationInfo(p.instrumentation.get(i), flags);
                }
            }
        }

        if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
            pi.permissions = null;
            int N = p.permissions.size();
            if (N > 0) {
                pi.permissions = new PermissionInfo[N];
                for (int i = 0; i < N; i++) {
                    pi.permissions[i] = generatePermissionInfo(p.permissions.get(i), flags);
                }
            }

            pi.requestedPermissions = null;
            N = p.requestedPermissions.size();
            if (N > 0) {
                pi.requestedPermissions = new String[N];
                pi.requestedPermissionsFlags = new int[N];
                for (int i = 0; i < N; i++) {
                    final String perm = p.requestedPermissions.get(i);
                    pi.requestedPermissions[i] = perm;
                }
            }
        }

        PackageInfo base = null;
        try {
            base = BlackBoxCore.getPackageManager().getPackageInfo(p.packageName, flags);
        } catch (PackageManager.NameNotFoundException ignored) { }
        if (base != null) {
            if (base.splitNames != null) {
                pi.splitNames = base.splitNames;
            }
        }

        if ((flags & PackageManager.GET_SIGNATURES) != 0) {
            if (base == null) {
                pi.signatures = p.mSignatures;
            } else {
                pi.signatures = base.signatures;
            }
        }

        if (BuildCompat.isPie()) {
            if ((flags & PackageManager.GET_SIGNING_CERTIFICATES) != 0) {
                if (base == null) {
                    black.android.content.pm.PackageParser.SigningDetails.signatures.set(null, p.mSigningDetails.signatures);
                    pi.signingInfo = SigningInfo._new.newInstance();
                } else {
                    pi.signingInfo = base.signingInfo;
                }
            }
        }
        return pi;
    }

    public static ActivityInfo generateActivityInfo(BPackage.Activity a, int flags, BPackageUserState state, int userId) {
        if (checkUseInstalledOrHidden(state, a.info.applicationInfo)) {
            return null;
        }
        // Make shallow copies so we can store the metadata safely
        ActivityInfo ai = new ActivityInfo(a.info);
        ai.metaData = a.metaData;
        ai.processName = BPackageManagerService.fixProcessName(ai.packageName, ai.processName);
        ai.applicationInfo = generateApplicationInfo(a.owner, flags, state, userId);
        return ai;
    }

    public static ServiceInfo generateServiceInfo(BPackage.Service s, int flags, BPackageUserState state, int userId) {
        if (checkUseInstalledOrHidden(state, s.info.applicationInfo)) {
            return null;
        }
        // Make shallow copies so we can store the metadata safely
        ServiceInfo si = new ServiceInfo(s.info);
        si.metaData = s.metaData;
        si.processName = BPackageManagerService.fixProcessName(si.packageName, si.processName);
        si.applicationInfo = generateApplicationInfo(s.owner, flags, state, userId);
        return si;
    }

    public static ProviderInfo generateProviderInfo(BPackage.Provider p, int flags, BPackageUserState state, int userId) {
        if (checkUseInstalledOrHidden(state, p.info.applicationInfo)) {
            return null;
        }
        // Make shallow copies so we can store the metadata safely
        ProviderInfo pi = new ProviderInfo(p.info);
        if (pi.authority == null) {
            return null;
        }

        pi.metaData = p.metaData;
        pi.processName = BPackageManagerService.fixProcessName(pi.packageName, pi.processName);
        if ((flags & PackageManager.GET_URI_PERMISSION_PATTERNS) == 0) {
            pi.uriPermissionPatterns = null;
        }
        pi.applicationInfo = generateApplicationInfo(p.owner, flags, state, userId);
        return pi;
    }

    public static PermissionInfo generatePermissionInfo(BPackage.Permission p, int flags) {
        if (p == null) {
            return null;
        }

        if ((flags & PackageManager.GET_META_DATA) == 0) {
            return p.info;
        }
        PermissionInfo pi = new PermissionInfo(p.info);
        pi.metaData = p.metaData;
        return pi;
    }

    public static InstrumentationInfo generateInstrumentationInfo(BPackage.Instrumentation i, int flags) {
        if (i == null) {
            return null;
        }

        if ((flags & PackageManager.GET_META_DATA) == 0) {
            return i.info;
        }
        InstrumentationInfo ii = new InstrumentationInfo(i.info);
        ii.metaData = i.metaData;
        return ii;
    }

    public static ApplicationInfo generateApplicationInfo(BPackage p, int flags, BPackageUserState state, int userId) {
        if (checkUseInstalledOrHidden(state, p.applicationInfo)) {
            return null;
        }

        ApplicationInfo baseApplication;
        try {
            baseApplication = BlackBoxCore.getPackageManager().getApplicationInfo(BlackBoxCore.getHostPkg(), flags);
        } catch (Exception e) {
            return null;
        }

        String sourceDir = p.baseCodePath;
        if (p.applicationInfo == null) {
            p.applicationInfo = BlackBoxCore.getPackageManager().getPackageArchiveInfo(sourceDir, 0).applicationInfo;
        }

        ApplicationInfo ai = new ApplicationInfo(p.applicationInfo);
        if ((flags & PackageManager.GET_META_DATA) != 0) {
            ai.metaData = p.mAppMetaData;
        }

        ai.dataDir = BEnvironment.getDataDir(ai.packageName, userId).getAbsolutePath();
        if (!p.installOption.isFlag(InstallOption.FLAG_SYSTEM)) {
            ai.nativeLibraryDir = BEnvironment.getAppLibDir(ai.packageName).getAbsolutePath();
        }
        ai.processName = BPackageManagerService.fixProcessName(p.packageName, ai.packageName);
        ai.publicSourceDir = sourceDir;
        ai.sourceDir = sourceDir;
        ai.uid = p.mExtras.appId;

        if (BuildCompat.isL()) {
            ApplicationInfoL.primaryCpuAbi.set(ai, Build.CPU_ABI);
            ApplicationInfoL.scanPublicSourceDir.set(ai, ApplicationInfoL.scanPublicSourceDir.get(baseApplication));
            ApplicationInfoL.scanSourceDir.set(ai, ApplicationInfoL.scanSourceDir.get(baseApplication));
        }

        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.N) {
            ai.deviceProtectedDataDir = BEnvironment.getDeDataDir(p.packageName, userId).getAbsolutePath();

            if (ApplicationInfoN.deviceProtectedDataDir != null) {
                ApplicationInfoN.deviceProtectedDataDir.set(ai, ai.deviceProtectedDataDir);
            }

            if (ApplicationInfoN.credentialEncryptedDataDir != null) {
                ApplicationInfoN.credentialEncryptedDataDir.set(ai, ai.dataDir);
            }

            if (ApplicationInfoN.deviceProtectedDataDir != null) {
                ApplicationInfoN.deviceProtectedDataDir.set(ai, ai.deviceProtectedDataDir);
            }

            if (ApplicationInfoN.credentialProtectedDataDir != null) {
                ApplicationInfoN.credentialProtectedDataDir.set(ai, ai.dataDir);
            }
        }
        fixJar(ai);
        return ai;
    }

    private static boolean checkUseInstalledOrHidden(BPackageUserState state, ApplicationInfo appInfo) {
        if (AppSystemEnv.isBlackPackage(appInfo.packageName)) {
            return true;
        }
        // Returns false if the package is hidden system app until installed.
        return !state.installed || state.hidden;
    }

    private static void fixJar(ApplicationInfo info) {
        String APACHE_LEGACY_JAR = "/system/framework/org.apache.http.legacy.boot.jar";
        String APACHE_LEGACY_JAR_Q = "/system/framework/org.apache.http.legacy.jar";
        Set<String> sharedLibraryFileList = new HashSet<>();

        if (BuildCompat.isQ()) {
            if (!FileUtils.isExist(APACHE_LEGACY_JAR_Q)) {
                sharedLibraryFileList.add(APACHE_LEGACY_JAR);
            } else {
                sharedLibraryFileList.add(APACHE_LEGACY_JAR_Q);
            }
        } else {
            sharedLibraryFileList.add(APACHE_LEGACY_JAR);
        }
        info.sharedLibraryFiles = sharedLibraryFileList.toArray(new String[]{});
    }

    public static Resources getResources(Context context, ApplicationInfo appInfo) {
        BPackageSettings ps = BPackageManagerService.get().getBPackageSetting(appInfo.packageName);
        if (ps != null) {
            AssetManager assets = black.android.content.res.AssetManager._new.newInstance();
            black.android.content.res.AssetManager.addAssetPath.call(assets, ps.pkg.baseCodePath);

            Resources hostRes = context.getResources();
            return new Resources(assets, hostRes.getDisplayMetrics(), hostRes.getConfiguration());
        }
        return null;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/PackageMonitor.java`:

```java
package com.vcore.core.system.pm;

public interface PackageMonitor {
    void onPackageUninstalled(String packageName, boolean isRemove, int userId);

    void onPackageInstalled(String packageName, int userId);
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/Settings.java`:

```java
package com.vcore.core.system.pm;

import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageParser;
import android.os.Parcel;
import android.os.Process;
import android.util.ArrayMap;
import android.util.AtomicFile;

import java.io.File;
import java.io.FileOutputStream;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import com.vcore.BlackBoxCore;
import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.BProcessManagerService;
import com.vcore.core.system.user.BUserHandle;
import com.vcore.entity.pm.InstallOption;
import com.vcore.utils.FileUtils;
import com.vcore.utils.Slog;
import com.vcore.utils.compat.PackageParserCompat;

/*public*/ class Settings {
    public static final String TAG = "Settings";

    final ArrayMap<String, BPackageSettings> mPackages = new ArrayMap<>();
    private final Map<String, Integer> mAppIds = new HashMap<>();
    private final Map<String, SharedUserSetting> mSharedUsers = SharedUserSetting.sSharedUsers;
    private int mCurrUid = 0;

    public Settings() {
        synchronized (mPackages) {
            loadUidLP();
            SharedUserSetting.loadSharedUsers();
        }
    }

    BPackageSettings getPackageLPw(String name, PackageParser.Package aPackage, InstallOption installOption) {
        BPackageSettings pkgSettings;
        BPackageSettings origSettings = new BPackageSettings();
        origSettings.pkg = new BPackage(aPackage);
        origSettings.pkg.installOption = installOption;
        origSettings.installOption = installOption;
        origSettings.pkg.mExtras = origSettings;
        origSettings.pkg.applicationInfo = PackageManagerCompat.generateApplicationInfo(origSettings.pkg, 0, BPackageUserState.create(), 0);

        synchronized (mPackages) {
            pkgSettings = mPackages.get(name);
            if (pkgSettings != null) {
                origSettings.appId = pkgSettings.appId;
                origSettings.userState = pkgSettings.userState;
            } else {
                boolean b = registerAppIdLPw(origSettings);
                if (!b) {
                    throw new RuntimeException("registerAppIdLPw err.");
                }
            }
        }
        return origSettings;
    }

    boolean registerAppIdLPw(BPackageSettings p) {
        boolean createdNew;
        String sharedUserId = p.pkg.mSharedUserId;
        SharedUserSetting sharedUserSetting = null;

        if (sharedUserId != null) {
            sharedUserSetting = mSharedUsers.get(sharedUserId);
            if (sharedUserSetting == null) {
                sharedUserSetting = new SharedUserSetting(sharedUserId);
                sharedUserSetting.userId = acquireAndRegisterNewAppIdLPw(p);
                mSharedUsers.put(sharedUserId, sharedUserSetting);
            }
        }

        if (sharedUserSetting != null) {
            p.appId = sharedUserSetting.userId;
            Slog.d(TAG, p.pkg.packageName + " sharedUserId = " + sharedUserId + ", setAppId = " + p.appId);
        }

        if (p.appId == 0) {
            // Assign new user ID
            p.appId = acquireAndRegisterNewAppIdLPw(p);
        }
        createdNew = p.appId >= 0;
        saveUidLP();
        SharedUserSetting.saveSharedUsers();
        return createdNew;
    }

    private int acquireAndRegisterNewAppIdLPw(BPackageSettings obj) {
        // Let's be stupidly inefficient for now...
        Integer integer = mAppIds.get(obj.pkg.packageName);
        if (integer != null) {
            return integer;
        }

        if (mCurrUid >= Process.LAST_APPLICATION_UID) {
            return -1;
        }
        mCurrUid++;
        mAppIds.put(obj.pkg.packageName, mCurrUid);
        return Process.FIRST_APPLICATION_UID + mCurrUid;
    }

    private void saveUidLP() {
        Parcel parcel = Parcel.obtain();
        FileOutputStream fileOutputStream = null;
        AtomicFile atomicFile = new AtomicFile(BEnvironment.getUidConf());

        try {
            Set<String> pkgName = mPackages.keySet();
            for (String s : new HashSet<>(mAppIds.keySet())) {
                if (!pkgName.contains(s)) {
                    mAppIds.remove(s);
                }
            }
            parcel.writeInt(mCurrUid);
            parcel.writeMap(mAppIds);

            fileOutputStream = atomicFile.startWrite();
            FileUtils.writeParcelToOutput(parcel, fileOutputStream);
            atomicFile.finishWrite(fileOutputStream);
        } catch (Exception e) {
            e.printStackTrace();
            atomicFile.failWrite(fileOutputStream);
        } finally {
            parcel.recycle();
        }
    }

    private void loadUidLP() {
        Parcel parcel = Parcel.obtain();
        try {
            byte[] uidBytes = FileUtils.toByteArray(BEnvironment.getUidConf());
            parcel.unmarshall(uidBytes, 0, uidBytes.length);
            parcel.setDataPosition(0);

            mCurrUid = parcel.readInt();
            HashMap hashMap = parcel.readHashMap(HashMap.class.getClassLoader());
            synchronized (mAppIds) {
                mAppIds.clear();
                mAppIds.putAll(hashMap);
            }
        } catch (Exception e) {
			// e.printStackTrace();
        } finally {
            parcel.recycle();
        }
    }

    public void scanPackage() {
        synchronized (mPackages) {
            File appRootDir = BEnvironment.getAppRootDir();
            FileUtils.mkdirs(appRootDir);
            File[] apps = appRootDir.listFiles();

            if (apps != null) {
                for (File app : apps) {
                    if (!app.isDirectory()) {
                        continue;
                    }
                    scanPackage(app.getName());
                }
            }
        }
    }

    public void scanPackage(String packageName) {
        synchronized (mPackages) {
            updatePackageLP(BEnvironment.getAppDir(packageName));
        }
    }

    private void updatePackageLP(File app) {
        String packageName = app.getName();
        Parcel packageSettingsIn = Parcel.obtain();
        File packageConf = BEnvironment.getPackageConf(packageName);

        try {
            byte[] bPackageSettingsBytes = FileUtils.toByteArray(packageConf);

            packageSettingsIn.unmarshall(bPackageSettingsBytes, 0, bPackageSettingsBytes.length);
            packageSettingsIn.setDataPosition(0);

            BPackageSettings bPackageSettings = new BPackageSettings(packageSettingsIn);
            bPackageSettings.pkg.mExtras = bPackageSettings;
            if (bPackageSettings.installOption.isFlag(InstallOption.FLAG_SYSTEM)) {
                PackageInfo packageInfo = BlackBoxCore.getPackageManager().getPackageInfo(packageName, PackageManager.GET_META_DATA);
                String currPackageSourcePath = packageInfo.applicationInfo.sourceDir;
                if (!currPackageSourcePath.equals(bPackageSettings.pkg.baseCodePath)) {
                    BProcessManagerService.get().killAllByPackageName(bPackageSettings.pkg.packageName);
                    BPackageSettings newPkg = reInstallBySystem(packageInfo, bPackageSettings.installOption);
                    bPackageSettings.pkg = newPkg.pkg;
                }
            } else {
                bPackageSettings.pkg.applicationInfo = PackageManagerCompat.generateApplicationInfo(bPackageSettings.pkg, 0, BPackageUserState.create(), 0);
            }

            bPackageSettings.save();
            mPackages.put(bPackageSettings.pkg.packageName, bPackageSettings);
            Slog.d(TAG, "Loaded package: " + packageName);
        } catch (Throwable e) {
            e.printStackTrace();

            FileUtils.deleteDir(app);
            removePackage(packageName);
            BProcessManagerService.get().killAllByPackageName(packageName);
            BPackageManagerService.get().onPackageUninstalled(packageName, true, BUserHandle.USER_ALL);
            Slog.d(TAG, "Bad package: " + packageName);
        } finally {
            packageSettingsIn.recycle();
        }
    }

    private BPackageSettings reInstallBySystem(PackageInfo systemPackageInfo, InstallOption option) throws Exception {
        Slog.d(TAG, "reInstallBySystem: " + systemPackageInfo.packageName);
        PackageParser.Package aPackage = parserApk(systemPackageInfo.applicationInfo.sourceDir);
        if (aPackage == null) {
            throw new RuntimeException("parser apk error.");
        }

        aPackage.applicationInfo = BlackBoxCore.getPackageManager().getPackageInfo(aPackage.packageName, 0).applicationInfo;
        return getPackageLPw(aPackage.packageName, aPackage, option);
    }

    public void removePackage(String packageName) {
        mPackages.remove(packageName);
    }

    private PackageParser.Package parserApk(String file) {
        try {
            PackageParser parser = PackageParserCompat.createParser();
            PackageParser.Package aPackage = PackageParserCompat.parsePackage(parser, new File(file), 0);
            PackageParserCompat.collectCertificates(parser, aPackage, 0);
            return aPackage;
        } catch (Throwable t) {
            t.printStackTrace();
        }
        return null;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/SharedUserSetting.java`:

```java
package com.vcore.core.system.pm;

import android.os.Parcel;
import android.os.Parcelable;
import android.util.AtomicFile;

import java.io.FileOutputStream;
import java.util.HashMap;
import java.util.Map;

import com.vcore.core.env.BEnvironment;
import com.vcore.utils.FileUtils;

/**
 * Settings data for a particular shared user ID we know about.
 */
public final class SharedUserSetting implements Parcelable {
    public static final Map<String, SharedUserSetting> sSharedUsers = new HashMap<>();

    String name;
    int userId;

    // The lowest targetSdkVersion of all apps in the sharedUserSetting, used to assign seinfo so
    // that all apps within the sharedUser run in the same selinux context.
    int seInfoTargetSdkVersion;

    SharedUserSetting(String _name) {
        name = _name;
    }

    @Override
    public String toString() {
        return "SharedUserSetting{" + Integer.toHexString(System.identityHashCode(this)) + " " + name + "/" + userId + "}";
    }

    public static void saveSharedUsers() {
        Parcel parcel = Parcel.obtain();
        FileOutputStream fileOutputStream = null;
        AtomicFile atomicFile = new AtomicFile(BEnvironment.getSharedUserConf());

        try {
            parcel.writeMap(sSharedUsers);

            fileOutputStream = atomicFile.startWrite();
            FileUtils.writeParcelToOutput(parcel, fileOutputStream);
            atomicFile.finishWrite(fileOutputStream);
        } catch (Exception e) {
            e.printStackTrace();
            atomicFile.failWrite(fileOutputStream);
        } finally {
            parcel.recycle();
        }
    }

    public static void loadSharedUsers() {
        Parcel parcel = Parcel.obtain();

        try {
            byte[] sharedUsersBytes = FileUtils.toByteArray(BEnvironment.getSharedUserConf());
            parcel.unmarshall(sharedUsersBytes, 0, sharedUsersBytes.length);
            parcel.setDataPosition(0);

            HashMap hashMap = parcel.readHashMap(SharedUserSetting.class.getClassLoader());
            synchronized (sSharedUsers) {
                sSharedUsers.clear();
                sSharedUsers.putAll(hashMap);
            }
        } catch (Exception e) {
			// e.printStackTrace();
        } finally {
            parcel.recycle();
        }
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(this.name);
        dest.writeInt(this.userId);
        dest.writeInt(this.seInfoTargetSdkVersion);
    }

    public void readFromParcel(Parcel source) {
        this.name = source.readString();
        this.userId = source.readInt();
    }

    protected SharedUserSetting(Parcel in) {
        this.name = in.readString();
        this.userId = in.readInt();
    }

    public static final Parcelable.Creator<SharedUserSetting> CREATOR = new Parcelable.Creator<SharedUserSetting>() {
        @Override
        public SharedUserSetting createFromParcel(Parcel source) {
            return new SharedUserSetting(source);
        }

        @Override
        public SharedUserSetting[] newArray(int size) {
            return new SharedUserSetting[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/installer/CopyExecutor.java`:

```java
package com.vcore.core.system.pm.installer;

import java.io.File;
import java.io.IOException;

import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.pm.BPackageSettings;
import com.vcore.entity.pm.InstallOption;
import com.vcore.utils.FileUtils;
import com.vcore.utils.NativeUtils;

public class CopyExecutor implements Executor {

    @Override
    public int exec(BPackageSettings ps, InstallOption option, int userId) {
        try {
            if (!option.isFlag(InstallOption.FLAG_SYSTEM)) {
                NativeUtils.copyNativeLib(new File(ps.pkg.baseCodePath), BEnvironment.getAppLibDir(ps.pkg.packageName));
            }
        } catch (Exception e) {
            e.printStackTrace();
            return -1;
        }
        if (option.isFlag(InstallOption.FLAG_STORAGE)) {
            // 外部安装
            File origFile = new File(ps.pkg.baseCodePath);
            File newFile = BEnvironment.getBaseApkDir(ps.pkg.packageName);
            try {
                if (option.isFlag(InstallOption.FLAG_URI_FILE)) {
                    boolean b = FileUtils.renameTo(origFile, newFile);
                    if (!b) {
                        FileUtils.copyFile(origFile, newFile);
                    }
                } else {
                    FileUtils.copyFile(origFile, newFile);
                }
                ps.pkg.baseCodePath = newFile.getAbsolutePath();
            } catch (IOException e) {
                e.printStackTrace();
                return -1;
            }
        }
        return 0;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/installer/CreatePackageExecutor.java`:

```java
package com.vcore.core.system.pm.installer;

import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.pm.BPackageSettings;
import com.vcore.entity.pm.InstallOption;
import com.vcore.utils.FileUtils;

public class CreatePackageExecutor implements Executor {

    @Override
    public int exec(BPackageSettings ps, InstallOption option, int userId) {
        FileUtils.deleteDir(BEnvironment.getAppDir(ps.pkg.packageName));
        FileUtils.mkdirs(BEnvironment.getAppDir(ps.pkg.packageName));
        FileUtils.mkdirs(BEnvironment.getAppLibDir(ps.pkg.packageName));
        return 0;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/installer/CreateUserExecutor.java`:

```java
package com.vcore.core.system.pm.installer;

import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.pm.BPackageSettings;
import com.vcore.entity.pm.InstallOption;
import com.vcore.utils.FileUtils;

public class CreateUserExecutor implements Executor {

    @Override
    public int exec(BPackageSettings ps, InstallOption option, int userId) {
        String packageName = ps.pkg.packageName;
        FileUtils.deleteDir(BEnvironment.getDataLibDir(packageName, userId));

        FileUtils.mkdirs(BEnvironment.getDataDir(packageName, userId));
        FileUtils.mkdirs(BEnvironment.getDataCacheDir(packageName, userId));
        FileUtils.mkdirs(BEnvironment.getDataFilesDir(packageName, userId));
        FileUtils.mkdirs(BEnvironment.getDataDatabasesDir(packageName, userId));
        FileUtils.mkdirs(BEnvironment.getDeDataDir(packageName, userId));
        return 0;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/installer/Executor.java`:

```java
package com.vcore.core.system.pm.installer;

import com.vcore.core.system.pm.BPackageSettings;
import com.vcore.entity.pm.InstallOption;

public interface Executor {
    String TAG = "InstallExecutor";

    int exec(BPackageSettings ps, InstallOption option, int userId);
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/installer/RemoveAppExecutor.java`:

```java
package com.vcore.core.system.pm.installer;

import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.pm.BPackageSettings;
import com.vcore.entity.pm.InstallOption;
import com.vcore.utils.FileUtils;

public class RemoveAppExecutor implements Executor {
    @Override
    public int exec(BPackageSettings ps, InstallOption option, int userId) {
        FileUtils.deleteDir(BEnvironment.getAppDir(ps.pkg.packageName));
        return 0;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/pm/installer/RemoveUserExecutor.java`:

```java
package com.vcore.core.system.pm.installer;

import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.pm.BPackageSettings;
import com.vcore.entity.pm.InstallOption;
import com.vcore.utils.FileUtils;

public class RemoveUserExecutor implements Executor {

    @Override
    public int exec(BPackageSettings ps, InstallOption option, int userId) {
        String packageName = ps.pkg.packageName;
		
        FileUtils.deleteDir(BEnvironment.getDataDir(packageName, userId));
        FileUtils.deleteDir(BEnvironment.getDeDataDir(packageName, userId));
        FileUtils.deleteDir(BEnvironment.getExternalDataDir(packageName, userId));
        return 0;
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/user/BUserHandle.java`:

```java
package com.vcore.core.system.user;

import android.os.Parcel;
import android.os.Parcelable;
import android.os.Process;

import androidx.annotation.NonNull;

/**
 * Representation of a user on the device.
 */
public final class BUserHandle implements Parcelable {
    // NOTE: keep logic in sync with system/core/libcutils/multiuser.c

    /**
     * @hide Range of uids allocated for a user.
     */
    public static final int PER_USER_RANGE = 100000;

    /**
     * @hide A user id to indicate all users on the device
     */
    public static final int USER_ALL = -1;

    /**
     * @hide A user handle to indicate all users on the device
     */
    public static final BUserHandle ALL = new BUserHandle(USER_ALL);

    /**
     * @hide A user id to indicate the currently active user
     */
    public static final int USER_CURRENT = -2;

    /**
     * @hide A user handle to indicate the current user of the device
     */
    public static final BUserHandle CURRENT = new BUserHandle(USER_CURRENT);

    public static final int USER_XPOSED = -4;

    /**
     * @hide An undefined user id
     */
    public static final int USER_NULL = -10000;

    /**
     * @hide A user id constant to indicate the "owner" user of the device
     * @deprecated Consider using either {@link BUserHandle#USER_SYSTEM} constant or
     * check the target user's flag {@link }.
     */
    @Deprecated
    public static final int USER_OWNER = 0;

    /**
     * @hide A user handle to indicate the primary/owner user of the device
     * @deprecated Consider using either {@link BUserHandle#SYSTEM} constant or
     * check the target user's flag {@link }.
     */
    @Deprecated
    public static final BUserHandle OWNER = new BUserHandle(USER_OWNER);

    /**
     * @hide A user id constant to indicate the "system" user of the device
     */
    public static final int USER_SYSTEM = 0;

    /**
     * @hide A user handle to indicate the "system" user of the device
     */
    public static final BUserHandle SYSTEM = new BUserHandle(USER_SYSTEM);

    /**
     * @hide Enable multi-user related side effects. Set this to false if
     * there are problems with single user use-cases.
     */
    public static final boolean MU_ENABLED = true;

    /**
     * @hide
     */
    public static final int AID_APP_START = android.os.Process.FIRST_APPLICATION_UID;

    final int mHandle;

    /**
     * Whether a UID belongs to a system core component or not.
     *
     * @hide
     */
    public static boolean isCore(int uid) {
        if (uid >= 0) {
            final int appId = getAppId(uid);
            return appId < Process.FIRST_APPLICATION_UID;
        } else {
            return false;
        }
    }

    /**
     * Returns the user id for a given uid.
     *
     * @hide
     */
    public static int getUserId(int uid) {
        if (MU_ENABLED) {
            return uid / PER_USER_RANGE;
        } else {
            return BUserHandle.USER_SYSTEM;
        }
    }

    /**
     * @hide
     */
    public static BUserHandle of(int userId) {
        return userId == USER_SYSTEM ? SYSTEM : new BUserHandle(userId);
    }

    /**
     * Returns the uid that is composed from the userId and the appId.
     *
     * @hide
     */
    public static int getUid(int userId, int appId) {
        if (MU_ENABLED) {
            return userId * PER_USER_RANGE + (appId % PER_USER_RANGE);
        } else {
            return appId;
        }
    }

    /**
     * Returns the app id (or base uid) for a given uid, stripping out the user id from it.
     *
     * @hide
     */
    public static int getAppId(int uid) {
        return uid % PER_USER_RANGE;
    }

    /**
     * Returns true if this UserHandle refers to the owner user; false otherwise.
     *
     * @return true if this UserHandle refers to the owner user; false otherwise.
     * @hide
     * @deprecated please use {@link #isSystem()} or check for
     */
    @Deprecated
    public boolean isOwner() {
        return this.equals(OWNER);
    }

    /**
     * @return true if this UserHandle refers to the system user; false otherwise.
     * @hide
     */
    public boolean isSystem() {
        return this.equals(SYSTEM);
    }

    /**
     * @hide
     */
    public BUserHandle(int h) {
        this.mHandle = h;
    }

    @NonNull
    @Override
    public String toString() {
        return "UserHandle{" + mHandle + "}";
    }

    @Override
    public boolean equals(Object obj) {
        try {
            if (obj instanceof BUserHandle) {
                BUserHandle other = (BUserHandle) obj;
                return mHandle == other.mHandle;
            }
        } catch (ClassCastException ignored) { }
        return false;
    }

    @Override
    public int hashCode() {
        return mHandle;
    }

    public int describeContents() {
        return 0;
    }

    public void writeToParcel(Parcel out, int flags) {
        out.writeInt(mHandle);
    }

    /**
     * Write a UserHandle to a Parcel, handling null pointers.  Must be
     * read with {@link #readFromParcel(Parcel)}.
     *
     * @param h   The UserHandle to be written.
     * @param out The Parcel in which the UserHandle will be placed.
     * @see #readFromParcel(Parcel)
     */
    public static void writeToParcel(BUserHandle h, Parcel out) {
        if (h != null) {
            h.writeToParcel(out, 0);
        } else {
            out.writeInt(USER_NULL);
        }
    }

    public static final Parcelable.Creator<BUserHandle> CREATOR = new Creator<BUserHandle>() {
        public BUserHandle createFromParcel(Parcel in) {
            return new BUserHandle(in);
        }

        public BUserHandle[] newArray(int size) {
            return new BUserHandle[size];
        }
    };

    /**
     * Instantiate a new UserHandle from the data in a Parcel that was
     * previously written with {@link #writeToParcel(Parcel, int)}.  Note that you
     * must not use this with data written by
     * {@link #writeToParcel(BUserHandle, Parcel)} since it is not possible
     * to handle a null UserHandle here.
     *
     * @param in The Parcel containing the previously written UserHandle,
     *           positioned at the location in the buffer where it was written.
     */
    public BUserHandle(Parcel in) {
        this.mHandle = in.readInt();
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/user/BUserInfo.java`:

```java
package com.vcore.core.system.user;

import android.os.Parcel;
import android.os.Parcelable;

public class BUserInfo implements Parcelable {
    public int id;
    public BUserStatus status;
    public String name;
    public long createTime;

    BUserInfo() { }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(this.id);
        dest.writeInt(this.status == null ? -1 : this.status.ordinal());
        dest.writeString(this.name);
        dest.writeLong(this.createTime);
    }

    protected BUserInfo(Parcel in) {
        this.id = in.readInt();
        int tmpStatus = in.readInt();
        this.status = tmpStatus == -1 ? null : BUserStatus.values()[tmpStatus];
        this.name = in.readString();
        this.createTime = in.readLong();
    }

    public static final Creator<BUserInfo> CREATOR = new Creator<BUserInfo>() {

        @Override
        public BUserInfo createFromParcel(Parcel source) {
            return new BUserInfo(source);
        }

        @Override
        public BUserInfo[] newArray(int size) {
            return new BUserInfo[size];
        }
    };

    @Override
    public String toString() {
        return "BUserInfo{" + "id=" + id + ", status=" + status + ", name='" + name + '\'' + ", createTime=" + createTime + '}';
    }
}

```

`Bcore/src/main/java/com/vcore/core/system/user/BUserManagerService.java`:

```java
package com.vcore.core.system.user;

import android.os.Parcel;
import android.os.RemoteException;

import androidx.core.util.AtomicFile;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import com.vcore.core.env.BEnvironment;
import com.vcore.core.system.ISystemService;
import com.vcore.core.system.pm.BPackageManagerService;
import com.vcore.utils.CloseUtils;
import com.vcore.utils.FileUtils;


public class BUserManagerService extends IBUserManagerService.Stub implements ISystemService {
    private static final BUserManagerService sService = new BUserManagerService();
    public final HashMap<Integer, BUserInfo> mUsers = new HashMap<>();
    public final Object mUserLock = new Object();

    public static BUserManagerService get() {
        return sService;
    }

    @Override
    public void systemReady() {
        scanUserL();
    }

    @Override
    public BUserInfo getUserInfo(int userId) {
        synchronized (mUserLock) {
            return mUsers.get(userId);
        }
    }

    @Override
    public boolean exists(int userId) {
        synchronized (mUsers) {
            return mUsers.get(userId) != null;
        }
    }

    @Override
    public BUserInfo createUser(int userId) {
        synchronized (mUserLock) {
            if (exists(userId)) {
                return getUserInfo(userId);
            }
            return createUserLocked(userId);
        }
    }

    @Override
    public List<BUserInfo> getUsers() {
        synchronized (mUsers) {
            ArrayList<BUserInfo> bUsers = new ArrayList<>();
            for (BUserInfo value : mUsers.values()) {
                if (value.id >= 0) {
                    bUsers.add(value);
                }
            }
            return bUsers;
        }
    }

    public List<BUserInfo> getAllUsers() {
        synchronized (mUsers) {
            return new ArrayList<>(mUsers.values());
        }
    }

    @Override
    public void deleteUser(int userId) throws RemoteException {
        synchronized (mUserLock) {
            synchronized (mUsers) {
                BPackageManagerService.get().deleteUser(userId);

                mUsers.remove(userId);
                saveUserInfoLocked();
                FileUtils.deleteDir(BEnvironment.getUserDir(userId));
                FileUtils.deleteDir(BEnvironment.getExternalUserDir(userId));
            }
        }
    }

    private BUserInfo createUserLocked(int userId) {
        BUserInfo bUserInfo = new BUserInfo();
        bUserInfo.id = userId;
        bUserInfo.status = BUserStatus.ENABLE;
        mUsers.put(userId, bUserInfo);
        synchronized (mUsers) {
            saveUserInfoLocked();
        }
        return bUserInfo;
    }

    private void saveUserInfoLocked() {
        Parcel parcel = Parcel.obtain();
        AtomicFile atomicFile = new AtomicFile(BEnvironment.getUserInfoConf());
        FileOutputStream fileOutputStream = null;

        try {
            ArrayList<BUserInfo> bUsers = new ArrayList<>(mUsers.values());
            parcel.writeTypedList(bUsers);

            try {
                fileOutputStream = atomicFile.startWrite();
                FileUtils.writeParcelToOutput(parcel, fileOutputStream);
                atomicFile.finishWrite(fileOutputStream);
            } catch (IOException e) {
                e.printStackTrace();
                atomicFile.failWrite(fileOutputStream);
            } finally {
                CloseUtils.close(fileOutputStream);
            }
        } finally {
            parcel.recycle();
        }
    }

    private void scanUserL() {
        synchronized (mUserLock) {
            Parcel parcel = Parcel.obtain();
            InputStream is = null;

            try {
                File userInfoConf = BEnvironment.getUserInfoConf();
                if (!userInfoConf.exists()) {
                    return;
                }

                is = new FileInputStream(BEnvironment.getUserInfoConf());
                byte[] bytes = FileUtils.toByteArray(is);
                parcel.unmarshall(bytes, 0, bytes.length);
                parcel.setDataPosition(0);

                ArrayList<BUserInfo> loadUsers = parcel.createTypedArrayList(BUserInfo.CREATOR);
                if (loadUsers == null) {
                    return;
                }

                synchronized (mUsers) {
                    mUsers.clear();
                    for (BUserInfo loadUser : loadUsers) {
                        mUsers.put(loadUser.id, loadUser);
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                parcel.recycle();
                CloseUtils.close(is);
            }
        }
    }
}
```

`Bcore/src/main/java/com/vcore/core/system/user/BUserStatus.java`:

```java
package com.vcore.core.system.user;

public enum BUserStatus {
    ENABLE, DISABLE

}

```

`Bcore/src/main/java/com/vcore/entity/AppConfig.java`:

```java
package com.vcore.entity;

import android.os.IBinder;
import android.os.Parcel;
import android.os.Parcelable;

public class AppConfig implements Parcelable {
    public static final String KEY = "BlackBox_client_config";

    public String packageName;
    public String processName;
    public int bPID;
    public int bUID;
    public int uid;
    public int userId;
    public int callingBUid;
    public IBinder token;

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(this.packageName);
        dest.writeString(this.processName);
        dest.writeInt(this.bPID);
        dest.writeInt(this.bUID);
        dest.writeInt(this.uid);
        dest.writeInt(this.userId);
        dest.writeInt(this.callingBUid);
        dest.writeStrongBinder(token);
    }

    public AppConfig() { }

    protected AppConfig(Parcel in) {
        this.packageName = in.readString();
        this.processName = in.readString();
        this.bPID = in.readInt();
        this.bUID = in.readInt();
        this.uid = in.readInt();
        this.userId = in.readInt();
        this.callingBUid = in.readInt();
        this.token = in.readStrongBinder();
    }

    public static final Parcelable.Creator<AppConfig> CREATOR = new Parcelable.Creator<AppConfig>() {
        @Override
        public AppConfig createFromParcel(Parcel source) {
            return new AppConfig(source);
        }

        @Override
        public AppConfig[] newArray(int size) {
            return new AppConfig[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/entity/JobRecord.java`:

```java
package com.vcore.entity;

import android.app.job.JobInfo;
import android.app.job.JobService;
import android.content.pm.ServiceInfo;
import android.os.Parcel;
import android.os.Parcelable;

public class JobRecord implements Parcelable {
    public JobInfo mJobInfo;
    public ServiceInfo mServiceInfo;

    public JobService mJobService;

    public JobRecord() { }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeParcelable(this.mJobInfo, flags);
        dest.writeParcelable(this.mServiceInfo, flags);
    }

    protected JobRecord(Parcel in) {
        this.mJobInfo = in.readParcelable(JobInfo.class.getClassLoader());
        this.mServiceInfo = in.readParcelable(ServiceInfo.class.getClassLoader());
    }

    public static final Creator<JobRecord> CREATOR = new Creator<JobRecord>() {
        @Override
        public JobRecord createFromParcel(Parcel source) {
            return new JobRecord(source);
        }

        @Override
        public JobRecord[] newArray(int size) {
            return new JobRecord[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/entity/ServiceRecord.java`:

```java
package com.vcore.entity;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;
import android.os.RemoteException;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

public class ServiceRecord {
    private Service mService;
    private final Map<Intent.FilterComparison, BoundInfo> mBounds = new HashMap<>();
    private boolean rebind;
    private int mStartId;

    public static class BoundInfo {
        private IBinder mIBinder;
        private final AtomicInteger mBindCount = new AtomicInteger(0);

        public void incrementAndGetBindCount() {
            mBindCount.incrementAndGet();
        }

        public int decrementAndGetBindCount() {
            return mBindCount.decrementAndGet();
        }

        public IBinder getIBinder() {
            return mIBinder;
        }

        public void setIBinder(IBinder IBinder) {
            mIBinder = IBinder;
        }
    }

    public int getStartId() {
        return mStartId;
    }

    public void setStartId(int startId) {
        mStartId = startId;
    }

    public Service getService() {
        return mService;
    }

    public void setService(Service service) {
        mService = service;
    }

    public IBinder getBinder(Intent intent) {
        BoundInfo boundInfo = getOrCreateBoundInfo(intent);
        return boundInfo.getIBinder();
    }

    public boolean hasBinder(Intent intent) {
        BoundInfo boundInfo = getOrCreateBoundInfo(intent);
        return boundInfo.getIBinder() != null;
    }

    public void addBinder(Intent intent, final IBinder iBinder) {
        final Intent.FilterComparison filterComparison = new Intent.FilterComparison(intent);
        BoundInfo boundInfo = getOrCreateBoundInfo(intent);
        if (boundInfo == null) {
            boundInfo = new BoundInfo();
            mBounds.put(filterComparison, boundInfo);
        }

        boundInfo.setIBinder(iBinder);
        try {
            iBinder.linkToDeath(new IBinder.DeathRecipient() {
                @Override
                public void binderDied() {
                    iBinder.unlinkToDeath(this, 0);
                    mBounds.remove(filterComparison);
                }
            }, 0);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void incrementAndGetBindCount(Intent intent) {
        BoundInfo boundInfo = getOrCreateBoundInfo(intent);
        boundInfo.incrementAndGetBindCount();
    }

    public boolean decreaseConnectionCount(Intent intent) {
        Intent.FilterComparison filterComparison = new Intent.FilterComparison(intent);
        BoundInfo boundInfo = mBounds.get(filterComparison);
        if (boundInfo == null) {
            return true;
        }
        int i = boundInfo.decrementAndGetBindCount();
        return i <= 0;
    }

    public BoundInfo getOrCreateBoundInfo(Intent intent) {
        Intent.FilterComparison filterComparison = new Intent.FilterComparison(intent);
        BoundInfo boundInfo = mBounds.get(filterComparison);
        if (boundInfo == null) {
            boundInfo = new BoundInfo();
            mBounds.put(filterComparison, boundInfo);
        }
        return boundInfo;
    }

    public boolean isRebind() {
        return rebind;
    }

    public void setRebind(boolean rebind) {
        this.rebind = rebind;
    }
}

```

`Bcore/src/main/java/com/vcore/entity/UnbindRecord.java`:

```java
package com.vcore.entity;

import android.content.ComponentName;
import android.os.Parcel;
import android.os.Parcelable;

public class UnbindRecord implements Parcelable {
    private int mBindCount;
    private int mStartId;
    private ComponentName mComponentName;

    public int getStartId() {
        return mStartId;
    }

    public void setStartId(int startId) {
        mStartId = startId;
    }

    public void setBindCount(int bindCount) {
        mBindCount = bindCount;
    }

    public ComponentName getComponentName() {
        return mComponentName;
    }

    public void setComponentName(ComponentName componentName) {
        mComponentName = componentName;
    }

    public static Creator<UnbindRecord> getCREATOR() {
        return CREATOR;
    }

    public UnbindRecord() { }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(this.mBindCount);
        dest.writeInt(this.mStartId);
        dest.writeParcelable(this.mComponentName, flags);
    }

    protected UnbindRecord(Parcel in) {
        this.mBindCount = in.readInt();
        this.mStartId = in.readInt();
        this.mComponentName = in.readParcelable(ComponentName.class.getClassLoader());
    }

    public static final Creator<UnbindRecord> CREATOR = new Creator<UnbindRecord>() {
        @Override
        public UnbindRecord createFromParcel(Parcel source) {
            return new UnbindRecord(source);
        }

        @Override
        public UnbindRecord[] newArray(int size) {
            return new UnbindRecord[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/entity/am/PendingResultData.java`:

```java
package com.vcore.entity.am;

import android.content.BroadcastReceiver;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

import java.util.UUID;

import com.vcore.utils.compat.BuildCompat;

public class PendingResultData implements Parcelable {
    public final int mType;
    public final boolean mOrderedHint;
    public final boolean mInitialStickyHint;
    public final IBinder mToken;
    public final int mSendingUser;
    public int mFlags;
    public int mResultCode;
    public final String mResultData;
    public final Bundle mResultExtras;
    public final boolean mAbortBroadcast;
    public final boolean mFinished;
    public final String mBToken;

    public PendingResultData(BroadcastReceiver.PendingResult pendingResult) {
        this.mBToken = UUID.randomUUID().toString();
        if (BuildCompat.isM()) {
            this.mType = black.android.content.BroadcastReceiver.PendingResultM.mType.get(pendingResult);
            this.mOrderedHint = black.android.content.BroadcastReceiver.PendingResultM.mOrderedHint.get(pendingResult);
            this.mInitialStickyHint = black.android.content.BroadcastReceiver.PendingResultM.mInitialStickyHint.get(pendingResult);
            this.mToken = black.android.content.BroadcastReceiver.PendingResultM.mToken.get(pendingResult);
            this.mSendingUser = black.android.content.BroadcastReceiver.PendingResultM.mSendingUser.get(pendingResult);
            this.mFlags = black.android.content.BroadcastReceiver.PendingResultM.mFlags.get(pendingResult);
            this.mResultData = black.android.content.BroadcastReceiver.PendingResultM.mResultData.get(pendingResult);
            this.mResultExtras = black.android.content.BroadcastReceiver.PendingResultM.mResultExtras.get(pendingResult);
            this.mAbortBroadcast = black.android.content.BroadcastReceiver.PendingResultM.mAbortBroadcast.get(pendingResult);
            this.mFinished = black.android.content.BroadcastReceiver.PendingResultM.mFinished.get(pendingResult);
        } else {
            this.mType = black.android.content.BroadcastReceiver.PendingResult.mType.get(pendingResult);
            this.mOrderedHint = black.android.content.BroadcastReceiver.PendingResult.mOrderedHint.get(pendingResult);
            this.mInitialStickyHint = black.android.content.BroadcastReceiver.PendingResult.mInitialStickyHint.get(pendingResult);
            this.mToken = black.android.content.BroadcastReceiver.PendingResult.mToken.get(pendingResult);
            this.mSendingUser = black.android.content.BroadcastReceiver.PendingResult.mSendingUser.get(pendingResult);
            this.mResultData = black.android.content.BroadcastReceiver.PendingResult.mResultData.get(pendingResult);
            this.mResultExtras = black.android.content.BroadcastReceiver.PendingResult.mResultExtras.get(pendingResult);
            this.mAbortBroadcast = black.android.content.BroadcastReceiver.PendingResult.mAbortBroadcast.get(pendingResult);
            this.mFinished = black.android.content.BroadcastReceiver.PendingResult.mFinished.get(pendingResult);
        }
    }

    public BroadcastReceiver.PendingResult build() {
        if (BuildCompat.isM()) {
            return black.android.content.BroadcastReceiver.PendingResultM._new.newInstance(mResultCode, mResultData, mResultExtras, mType, mOrderedHint, mInitialStickyHint, mToken, mSendingUser, mFlags);
        }
        return black.android.content.BroadcastReceiver.PendingResult._new.newInstance(mResultCode, mResultData, mResultExtras, mType, mOrderedHint, mInitialStickyHint, mToken, mSendingUser);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(this.mType);
        dest.writeByte(this.mOrderedHint ? (byte) 1 : (byte) 0);
        dest.writeByte(this.mInitialStickyHint ? (byte) 1 : (byte) 0);
        dest.writeStrongBinder(this.mToken);
        dest.writeInt(this.mSendingUser);
        dest.writeInt(this.mFlags);
        dest.writeInt(this.mResultCode);
        dest.writeString(this.mResultData);
        dest.writeBundle(this.mResultExtras);
        dest.writeByte(this.mAbortBroadcast ? (byte) 1 : (byte) 0);
        dest.writeByte(this.mFinished ? (byte) 1 : (byte) 0);
        dest.writeString(this.mBToken);
    }

    protected PendingResultData(Parcel in) {
        this.mType = in.readInt();
        this.mOrderedHint = in.readByte() != 0;
        this.mInitialStickyHint = in.readByte() != 0;
        this.mToken = in.readStrongBinder();
        this.mSendingUser = in.readInt();
        this.mFlags = in.readInt();
        this.mResultCode = in.readInt();
        this.mResultData = in.readString();
        this.mResultExtras = in.readBundle();
        this.mAbortBroadcast = in.readByte() != 0;
        this.mFinished = in.readByte() != 0;
        this.mBToken = in.readString();
    }

    public static final Parcelable.Creator<PendingResultData> CREATOR = new Parcelable.Creator<PendingResultData>() {
        @Override
        public PendingResultData createFromParcel(Parcel source) {
            return new PendingResultData(source);
        }

        @Override
        public PendingResultData[] newArray(int size) {
            return new PendingResultData[size];
        }
    };

    @NonNull
    @Override
    public String toString() {
        return "PendingResultData{" + "mType=" + mType + ", mOrderedHint=" + mOrderedHint + ", mInitialStickyHint=" + mInitialStickyHint + ", mToken=" + mToken +
                ", mSendingUser=" + mSendingUser + ", mFlags=" + mFlags + ", mResultCode=" + mResultCode + ", mResultData='" + mResultData + '\'' +
                ", mResultExtras=" + mResultExtras + ", mAbortBroadcast=" + mAbortBroadcast + ", mFinished=" + mFinished + '}';
    }
}

```

`Bcore/src/main/java/com/vcore/entity/am/ReceiverData.java`:

```java
package com.vcore.entity.am;

import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.os.Parcel;
import android.os.Parcelable;

public class ReceiverData implements Parcelable {
    public Intent intent;
    public ActivityInfo activityInfo;
    public PendingResultData data;

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeParcelable(this.intent, flags);
        dest.writeParcelable(this.activityInfo, flags);
        dest.writeParcelable(this.data, flags);
    }

    public ReceiverData() { }

    protected ReceiverData(Parcel in) {
        this.intent = in.readParcelable(Intent.class.getClassLoader());
        this.activityInfo = in.readParcelable(ActivityInfo.class.getClassLoader());
        this.data = in.readParcelable(PendingResultData.class.getClassLoader());
    }

    public static final Parcelable.Creator<ReceiverData> CREATOR = new Parcelable.Creator<ReceiverData>() {
        @Override
        public ReceiverData createFromParcel(Parcel source) {
            return new ReceiverData(source);
        }

        @Override
        public ReceiverData[] newArray(int size) {
            return new ReceiverData[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/entity/am/RunningAppProcessInfo.java`:

```java
package com.vcore.entity.am;

import android.app.ActivityManager;
import android.os.Parcel;
import android.os.Parcelable;

import java.util.ArrayList;
import java.util.List;

public class RunningAppProcessInfo implements Parcelable {
    public final List<ActivityManager.RunningAppProcessInfo> mAppProcessInfoList;

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeTypedList(this.mAppProcessInfoList);
    }

    public RunningAppProcessInfo() {
        this.mAppProcessInfoList = new ArrayList<>();
    }

    protected RunningAppProcessInfo(Parcel in) {
        this.mAppProcessInfoList = in.createTypedArrayList(ActivityManager.RunningAppProcessInfo.CREATOR);
    }

    public static final Parcelable.Creator<RunningAppProcessInfo> CREATOR = new Parcelable.Creator<RunningAppProcessInfo>() {
        @Override
        public RunningAppProcessInfo createFromParcel(Parcel source) {
            return new RunningAppProcessInfo(source);
        }

        @Override
        public RunningAppProcessInfo[] newArray(int size) {
            return new RunningAppProcessInfo[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/entity/am/RunningServiceInfo.java`:

```java
package com.vcore.entity.am;

import android.app.ActivityManager;
import android.os.Parcel;
import android.os.Parcelable;

import java.util.ArrayList;
import java.util.List;

public class RunningServiceInfo implements Parcelable {
    public final List<ActivityManager.RunningServiceInfo> mRunningServiceInfoList;

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeTypedList(this.mRunningServiceInfoList);
    }

    public RunningServiceInfo() {
        this.mRunningServiceInfoList = new ArrayList<>();
    }

    protected RunningServiceInfo(Parcel in) {
        this.mRunningServiceInfoList = in.createTypedArrayList(ActivityManager.RunningServiceInfo.CREATOR);
    }

    public static final Parcelable.Creator<RunningServiceInfo> CREATOR = new Parcelable.Creator<RunningServiceInfo>() {
        @Override
        public RunningServiceInfo createFromParcel(Parcel source) {
            return new RunningServiceInfo(source);
        }

        @Override
        public RunningServiceInfo[] newArray(int size) {
            return new RunningServiceInfo[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/entity/device/BDeviceConfig.java`:

```java
package com.vcore.entity.device;

import android.os.Parcel;
import android.os.Parcelable;

public class BDeviceConfig implements Parcelable {
    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) { }
}

```

`Bcore/src/main/java/com/vcore/entity/location/BCell.java`:

```java
package com.vcore.entity.location;

import android.os.Parcel;
import android.os.Parcelable;

public class BCell implements Parcelable {
    /**
     * mnc : 1
     * lac : 41093
     * ci : 3865320
     * acc : 1177
     * location : {"lon":116.343278,"lat":39.531734}
     * reference blog: https://liuschen.top/2016/09/15/BLocation.html
     * MCC，Mobile Country Code，移动国家代码（中国的为460）；
     * MNC，Mobile Network Code，移动网络号码（00移动 01联通 11电信4G）；
     * LAC/TAC(1~65535)，Location Area Code，位置区域码；
     * CID/CI( 2G(1~65535), 3G/4G(1~268435455))，Cell Identity，基站编号；
     * TYPE: Cdma/Lte/Gsm/Wcdma
     */
    public int MCC;
    public int MNC;
    public int LAC;
    public int CID;
    public int TYPE;

    /**
     * GSM phone
     */
    public static final int PHONE_TYPE_GSM = 1;

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(this.MCC);
        dest.writeInt(this.MNC);
        dest.writeInt(this.LAC);
        dest.writeInt(this.CID);
        dest.writeInt(this.TYPE);
    }

    public BCell() { }
    public BCell(int MCC, int MNC, int LAC, int CID) {
        this.TYPE = PHONE_TYPE_GSM;
        this.MCC = MCC;
        this.CID = CID;
        this.MNC = MNC;
        this.LAC = LAC;
    }

    public BCell(Parcel in) {
        this.MCC = in.readInt();
        this.MNC = in.readInt();
        this.LAC = in.readInt();
        this.CID = in.readInt();
        this.TYPE = in.readInt();
    }

    public static final Parcelable.Creator<BCell> CREATOR = new Parcelable.Creator<BCell>() {
        @Override
        public BCell createFromParcel(Parcel source) {
            return new BCell(source);
        }

        @Override
        public BCell[] newArray(int size) {
            return new BCell[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/entity/location/BLocation.java`:

```java
package com.vcore.entity.location;

import android.location.Location;
import android.location.LocationManager;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

public class BLocation implements Parcelable {
    private double mLatitude = 0.0;
    private double mLongitude = 0.0;
    private double mAltitude = 0.0f;
    private float mSpeed = 0.0f;
    private float mBearing = 0.0f;
    private float mAccuracy = 0.0f;

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeDouble(this.mLatitude);
        dest.writeDouble(this.mLongitude);
        dest.writeDouble(this.mAltitude);
        dest.writeFloat(this.mSpeed);
        dest.writeFloat(this.mBearing);
        dest.writeFloat(this.mAccuracy);
    }

    public double getLatitude() {
        return mLatitude;
    }

    public double getLongitude() {
        return mLongitude;
    }

    public BLocation() { }

    public BLocation(double latitude, double mLongitude) {
        this.mLatitude = latitude;
        this.mLongitude = mLongitude;
    }

    public BLocation(Parcel in) {
        this.mLatitude = in.readDouble();
        this.mLongitude = in.readDouble();
        this.mAltitude = in.readDouble();
        this.mAccuracy = in.readFloat();
        this.mSpeed = in.readFloat();
        this.mBearing = in.readFloat();
    }

    public boolean isEmpty() {
        return mLatitude == 0 && mLongitude == 0;
    }

    public static final Parcelable.Creator<BLocation> CREATOR = new Parcelable.Creator<BLocation>() {
        @Override
        public BLocation createFromParcel(Parcel source) {
            return new BLocation(source);
        }

        @Override
        public BLocation[] newArray(int size) {
            return new BLocation[size];
        }
    };

    @NonNull
    @Override
    public String toString() {
        return "BLocation{" + "latitude: " + mLatitude + ", longitude: " + mLongitude + ", altitude: " + mAltitude + ", speed: " + mSpeed
                + ", bearing: " + mBearing + ", accuracy: " + mAccuracy + '}';
    }

    public Location convert2SystemLocation() {
        Location location = new Location(LocationManager.GPS_PROVIDER);
        location.setLatitude(mLatitude);
        location.setLongitude(mLongitude);
        location.setSpeed(mSpeed);
        location.setBearing(mBearing);
        location.setAccuracy(40f);
        location.setTime(System.currentTimeMillis());
        Bundle extraBundle = new Bundle();
        // GPS satellite number
        int satelliteCount = 10;
        extraBundle.putInt("satellites", satelliteCount);
        extraBundle.putInt("satellitesvalue", satelliteCount);
        location.setExtras(extraBundle);
        return location;
    }

    public static String getSouthEast(BLocation location) {
        if (location.mLongitude > 0.0d) {
            return "E";
        }
        return "W";
    }

    public static String getNorthWest(BLocation location) {
        if (location.mLatitude > 0.0d) {
            return "N";
        }
        return "S";
    }

    public static String getGPSLatitude(double v) {
        int du = (int) v;
        double fen = (v - (double) du) * 60.0d;

        return du + leftZeroPad((int) fen) + ":" + String.valueOf(fen).substring(2);
    }

    private static String leftZeroPad(int num) {
        return leftZeroPad(String.valueOf(num));
    }

    private static String leftZeroPad(String num) {
        StringBuilder sb = new StringBuilder(2);
        int i;

        if (num == null) {
            for (i = 0; i < 2; i++) {
                sb.append('0');
            }
        } else {
            for (i = 0; i < 2 - num.length(); i++) {
                sb.append('0');
            }
            sb.append(num);
        }
        return sb.toString();
    }

    public static String checkSum(String nema) {
        String checkStr = nema;
        if (nema.startsWith("$")) {
            checkStr = nema.substring(1);
        }

        int sum = 0;
        for (int i = 0; i < checkStr.length(); i++) {
            sum ^= (byte) checkStr.charAt(i);
        }
        return nema + "*" + String.format("%02X", sum).toLowerCase();
    }
}

```

`Bcore/src/main/java/com/vcore/entity/location/BLocationConfig.java`:

```java
package com.vcore.entity.location;

import android.os.Parcel;
import android.os.Parcelable;

import java.util.List;

public class BLocationConfig implements Parcelable {
    public int pattern;
    public BCell cell;
    public List<BCell> allCell;
    public List<BCell> neighboringCellInfo;
    public BLocation location;

    @Override
    public int describeContents() {
        return 0;
    }

    public BLocationConfig() { }

    public BLocationConfig(Parcel in) {
        refresh(in);
    }

    public void refresh(Parcel in) {
        this.pattern = in.readInt();
        this.cell = in.readParcelable(BCell.class.getClassLoader());
        this.allCell = in.createTypedArrayList(BCell.CREATOR);
        this.neighboringCellInfo = in.createTypedArrayList(BCell.CREATOR);
        this.location = in.readParcelable(BLocation.class.getClassLoader());
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(this.pattern);
        dest.writeParcelable(this.cell, flags);
        dest.writeTypedList(this.allCell);
        dest.writeTypedList(this.neighboringCellInfo);
        dest.writeParcelable(this.location, flags);
    }

    public static final Creator<BLocationConfig> CREATOR = new Creator<BLocationConfig>() {
        @Override
        public BLocationConfig createFromParcel(Parcel source) {
            return new BLocationConfig(source);
        }

        @Override
        public BLocationConfig[] newArray(int size) {
            return new BLocationConfig[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/entity/pm/InstallOption.java`:

```java
package com.vcore.entity.pm;

import android.os.Parcel;
import android.os.Parcelable;

public class InstallOption implements Parcelable {
    public static final int FLAG_SYSTEM = 1;
    public static final int FLAG_STORAGE = 1 << 1;
    public static final int FLAG_XPOSED = 1 << 2;
    public static final int FLAG_URI_FILE = 1 << 3;

    public int flags = 0;

    public static InstallOption installBySystem() {
        InstallOption installOption = new InstallOption();
        installOption.flags = installOption.flags | FLAG_SYSTEM;
        return installOption;
    }

    public static InstallOption installByStorage() {
        InstallOption installOption = new InstallOption();
        installOption.flags = installOption.flags | FLAG_STORAGE;
        return installOption;
    }

    public InstallOption makeXposed() {
        this.flags |= FLAG_XPOSED;
        return this;
    }

    public InstallOption makeUriFile() {
        this.flags |= FLAG_URI_FILE;
        return this;
    }

    public boolean isFlag(int flag) {
        return (flags & flag) != 0;
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(this.flags);
    }

    public InstallOption() { }

    protected InstallOption(Parcel in) {
        this.flags = in.readInt();
    }

    public static final Parcelable.Creator<InstallOption> CREATOR = new Parcelable.Creator<InstallOption>() {
        @Override
        public InstallOption createFromParcel(Parcel source) {
            return new InstallOption(source);
        }

        @Override
        public InstallOption[] newArray(int size) {
            return new InstallOption[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/entity/pm/InstallResult.java`:

```java
package com.vcore.entity.pm;

import android.os.Parcel;
import android.os.Parcelable;

import com.vcore.utils.Slog;

public class InstallResult implements Parcelable {
    public static final String TAG = "InstallResult";

    public boolean success = true;
    public String packageName;
    public String msg;

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeByte(this.success ? (byte) 1 : (byte) 0);
        dest.writeString(this.packageName);
        dest.writeString(this.msg);
    }

    public InstallResult() { }

    protected InstallResult(Parcel in) {
        this.success = in.readByte() != 0;
        this.packageName = in.readString();
        this.msg = in.readString();
    }

    public InstallResult installError(String packageName, String msg) {
        this.msg = msg;
        this.success = false;
        this.packageName = packageName;
        Slog.d(TAG, msg);
        return this;
    }

    public InstallResult installError(String msg) {
        this.msg = msg;
        this.success = false;
        Slog.d(TAG, msg);
        return this;
    }

    public static final Parcelable.Creator<InstallResult> CREATOR = new Parcelable.Creator<InstallResult>() {
        @Override
        public InstallResult createFromParcel(Parcel source) {
            return new InstallResult(source);
        }

        @Override
        public InstallResult[] newArray(int size) {
            return new InstallResult[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/entity/pm/InstalledModule.java`:

```java
package com.vcore.entity.pm;

import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Parcel;
import android.os.Parcelable;

import com.vcore.BlackBoxCore;
import com.vcore.core.system.user.BUserHandle;

public class InstalledModule implements Parcelable {
    public String packageName;
    public String name;
    public String desc;
    public String main;
    public boolean enable;

    public InstalledModule() { }

    public ApplicationInfo getApplication() {
        return BlackBoxCore.getBPackageManager().getApplicationInfo(packageName, PackageManager.GET_META_DATA, BUserHandle.USER_XPOSED);
    }

    public PackageInfo getPackageInfo() {
        return BlackBoxCore.getBPackageManager().getPackageInfo(packageName, PackageManager.GET_META_DATA, BUserHandle.USER_XPOSED);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(this.packageName);
        dest.writeString(this.name);
        dest.writeString(this.desc);
        dest.writeString(this.main);
        dest.writeByte(this.enable ? (byte) 1 : (byte) 0);
    }

    protected InstalledModule(Parcel in) {
        this.packageName = in.readString();
        this.name = in.readString();
        this.desc = in.readString();
        this.main = in.readString();
        this.enable = in.readByte() != 0;
    }

    public static final Creator<InstalledModule> CREATOR = new Creator<InstalledModule>() {
        @Override
        public InstalledModule createFromParcel(Parcel source) {
            return new InstalledModule(source);
        }

        @Override
        public InstalledModule[] newArray(int size) {
            return new InstalledModule[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/entity/pm/InstalledPackage.java`:

```java
package com.vcore.entity.pm;

import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Parcel;
import android.os.Parcelable;

import java.util.Objects;

import com.vcore.BlackBoxCore;

public class InstalledPackage implements Parcelable {
    public int userId;
    public String packageName;

    public ApplicationInfo getApplication() {
        return BlackBoxCore.getBPackageManager().getApplicationInfo(packageName, PackageManager.GET_META_DATA, userId);
    }

    public PackageInfo getPackageInfo() {
        return BlackBoxCore.getBPackageManager().getPackageInfo(packageName, PackageManager.GET_META_DATA, userId);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(this.userId);
        dest.writeString(this.packageName);
    }

    public InstalledPackage() { }

    public InstalledPackage(String packageName) {
        this.packageName = packageName;
    }

    protected InstalledPackage(Parcel in) {
        this.userId = in.readInt();
        this.packageName = in.readString();
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }

        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        InstalledPackage that = (InstalledPackage) o;
        return Objects.equals(packageName, that.packageName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(packageName);
    }

    public static final Parcelable.Creator<InstalledPackage> CREATOR = new Parcelable.Creator<InstalledPackage>() {
        @Override
        public InstalledPackage createFromParcel(Parcel source) {
            return new InstalledPackage(source);
        }

        @Override
        public InstalledPackage[] newArray(int size) {
            return new InstalledPackage[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/entity/pm/XposedConfig.java`:

```java
package com.vcore.entity.pm;

import android.os.Parcel;
import android.os.Parcelable;

import java.util.HashMap;
import java.util.Map;

public class XposedConfig implements Parcelable {
    public boolean enable;
    public Map<String, Boolean> moduleState = new HashMap<>();

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeByte(this.enable ? (byte) 1 : (byte) 0);
        dest.writeInt(this.moduleState.size());
        for (Map.Entry<String, Boolean> entry : this.moduleState.entrySet()) {
            dest.writeString(entry.getKey());
            dest.writeValue(entry.getValue());
        }
    }

    public XposedConfig() { }

    public XposedConfig(Parcel in) {
        this.enable = in.readByte() != 0;
        int mModuleStateSize = in.readInt();
        this.moduleState = new HashMap<>(mModuleStateSize);

        for (int i = 0; i < mModuleStateSize; i++) {
            String key = in.readString();
            Boolean value = (Boolean) in.readValue(Boolean.class.getClassLoader());
            this.moduleState.put(key, value);
        }
    }

    public static final Parcelable.Creator<XposedConfig> CREATOR = new Parcelable.Creator<XposedConfig>() {
        @Override
        public XposedConfig createFromParcel(Parcel source) {
            return new XposedConfig(source);
        }

        @Override
        public XposedConfig[] newArray(int size) {
            return new XposedConfig[size];
        }
    };
}

```

`Bcore/src/main/java/com/vcore/fake/delegate/AppInstrumentation.java`:

```java
package com.vcore.fake.delegate;

import android.app.Activity;
import android.app.Application;
import android.app.Instrumentation;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.graphics.Canvas;
import android.os.Bundle;
import android.os.PersistableBundle;
import android.util.Log;

import java.lang.reflect.Field;

import black.Reflector;
import black.android.app.ActivityThread;
import de.robv.android.xposed.XposedBridge;
import de.robv.android.xposed.XposedHelpers;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.fake.hook.HookManager;
import com.vcore.fake.hook.IInjectHook;
import com.vcore.fake.service.HCallbackProxy;
import com.vcore.fake.service.IActivityClientProxy;
import com.vcore.utils.compat.ActivityCompat;
import com.vcore.utils.compat.ActivityManagerCompat;
import com.vcore.utils.compat.BuildCompat;
import com.vcore.utils.compat.ContextCompat;

public final class AppInstrumentation extends BaseInstrumentationDelegate implements IInjectHook {
    private static final String TAG = AppInstrumentation.class.getSimpleName();

    private static final class SAppInstrumentationHolder {
        static final AppInstrumentation sAppInstrumentation = new AppInstrumentation();
    }

    public static AppInstrumentation get() {
        return SAppInstrumentationHolder.sAppInstrumentation;
    }

    public AppInstrumentation() { }

    @Override
    public void injectHook() {
        try {
            Instrumentation mInstrumentation = getCurrInstrumentation();
            if (mInstrumentation == this || checkInstrumentation(mInstrumentation)) {
                return;
            }
            mBaseInstrumentation = mInstrumentation;
            ActivityThread.mInstrumentation.set(BlackBoxCore.mainThread(), this);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Instrumentation getCurrInstrumentation() {
        Object currentActivityThread = BlackBoxCore.mainThread();
        return ActivityThread.mInstrumentation.get(currentActivityThread);
    }

    @Override
    public boolean isBadEnv() {
        return !checkInstrumentation(getCurrInstrumentation());
    }

    private boolean checkInstrumentation(Instrumentation instrumentation) {
        if (instrumentation instanceof AppInstrumentation) {
            return true;
        }

        Class<?> clazz = instrumentation.getClass();
        if (Instrumentation.class.equals(clazz)) {
            return false;
        }

        do {
            assert clazz != null;
            Field[] fields = clazz.getDeclaredFields();
            for (Field field : fields) {
                if (Instrumentation.class.isAssignableFrom(field.getType())) {
                    field.setAccessible(true);
                    try {
                        Object obj = field.get(instrumentation);
                        if ((obj instanceof AppInstrumentation)) {
                            return true;
                        }
                    } catch (Exception e) {
                        return false;
                    }
                }
            }
            clazz = clazz.getSuperclass();
        } while (!Instrumentation.class.equals(clazz));
        return false;
    }

    private void checkHCallback() {
        HookManager.get().checkEnv(HCallbackProxy.class);
    }

    private void checkActivity(Activity activity) {
        Log.d(TAG, "callActivityOnCreate: " + activity.getClass().getName());
        checkHCallback();
        HookManager.get().checkEnv(IActivityClientProxy.class);

        ActivityInfo info = black.android.app.Activity.mActivityInfo.get(activity);
        ContextCompat.fix(activity);
        ActivityCompat.fix(activity);
        if (info.theme != 0) {
            activity.getTheme().applyStyle(info.theme, true);
        }
        ActivityManagerCompat.setActivityOrientation(activity, info.screenOrientation);
    }

    @Override
    public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
        ContextCompat.fix(context);
        //BActivityThread.currentActivityThread().loadXposed(context);
        return super.newApplication(cl, className, context);
    }

    @Override
    public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) {
        checkActivity(activity);
        super.callActivityOnCreate(activity, icicle, persistentState);
    }

    @Override
    public void callActivityOnCreate(Activity activity, Bundle icicle) {
        checkActivity(activity);
        super.callActivityOnCreate(activity, icicle);
    }

    @Override
    public void callApplicationOnCreate(Application app) {
        checkHCallback();
        super.callApplicationOnCreate(app);
    }

    public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
        try {
            return super.newActivity(cl, className, intent);
        } catch (ClassNotFoundException e) {
            return mBaseInstrumentation.newActivity(cl, className, intent);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/delegate/BaseInstrumentationDelegate.java`:

```java
package com.vcore.fake.delegate;

import android.app.Activity;
import android.app.Application;
import android.app.Instrumentation;
import android.app.UiAutomation;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.ActivityInfo;
import android.os.Build;
import android.os.Bundle;
import android.os.IBinder;
import android.os.PersistableBundle;
import android.view.KeyEvent;
import android.view.MotionEvent;

import androidx.annotation.RequiresApi;

import com.vcore.BlackBoxCore;
import com.vcore.app.configuration.AppLifecycleCallback;

public class BaseInstrumentationDelegate extends Instrumentation {
    protected Instrumentation mBaseInstrumentation;

    @Override
    public void onCreate(Bundle arguments) {
        mBaseInstrumentation.onCreate(arguments);
    }

    @Override
    public void start() {
        mBaseInstrumentation.start();
    }

    @Override
    public void onStart() {
        mBaseInstrumentation.onStart();
    }

    @Override
    public boolean onException(Object obj, Throwable e) {
        return mBaseInstrumentation.onException(obj, e);
    }

    @Override
    public void sendStatus(int resultCode, Bundle results) {
        mBaseInstrumentation.sendStatus(resultCode, results);
    }

    @RequiresApi(api = Build.VERSION_CODES.O)
    @Override
    public void addResults(Bundle results) {
        mBaseInstrumentation.addResults(results);
    }

    @Override
    public void finish(int resultCode, Bundle results) {
        mBaseInstrumentation.finish(resultCode, results);
    }

    @Override
    public void setAutomaticPerformanceSnapshots() {
        mBaseInstrumentation.setAutomaticPerformanceSnapshots();
    }

    @Override
    public void startPerformanceSnapshot() {
        mBaseInstrumentation.startPerformanceSnapshot();
    }

    @Override
    public void endPerformanceSnapshot() {
        mBaseInstrumentation.endPerformanceSnapshot();
    }

    @Override
    public void onDestroy() {
        mBaseInstrumentation.onDestroy();
    }

    @Override
    public Context getContext() {
        return mBaseInstrumentation.getContext();
    }

    @Override
    public ComponentName getComponentName() {
        return mBaseInstrumentation.getComponentName();
    }

    @Override
    public Context getTargetContext() {
        return mBaseInstrumentation.getTargetContext();
    }

    @Override
    public boolean isProfiling() {
        return mBaseInstrumentation.isProfiling();
    }

    @Override
    public void startProfiling() {
        mBaseInstrumentation.startProfiling();
    }

    @Override
    public void stopProfiling() {
        mBaseInstrumentation.stopProfiling();
    }

    @Override
    public void setInTouchMode(boolean inTouch) {
        mBaseInstrumentation.setInTouchMode(inTouch);
    }

    @Override
    public void waitForIdle(Runnable recipient) {
        mBaseInstrumentation.waitForIdle(recipient);
    }

    @Override
    public void waitForIdleSync() {
        mBaseInstrumentation.waitForIdleSync();
    }

    @Override
    public void runOnMainSync(Runnable runner) {
        mBaseInstrumentation.runOnMainSync(runner);
    }

    @Override
    public Activity startActivitySync(Intent intent) {
        return mBaseInstrumentation.startActivitySync(intent);
    }

    @Override
    public void addMonitor(ActivityMonitor monitor) {
        mBaseInstrumentation.addMonitor(monitor);
    }

    @Override
    public ActivityMonitor addMonitor(IntentFilter filter, ActivityResult result, boolean block) {
        return mBaseInstrumentation.addMonitor(filter, result, block);
    }

    @Override
    public ActivityMonitor addMonitor(String cls, ActivityResult result, boolean block) {
        return mBaseInstrumentation.addMonitor(cls, result, block);
    }

    @Override
    public boolean checkMonitorHit(ActivityMonitor monitor, int minHits) {
        return mBaseInstrumentation.checkMonitorHit(monitor, minHits);
    }

    @Override
    public Activity waitForMonitor(ActivityMonitor monitor) {
        return mBaseInstrumentation.waitForMonitor(monitor);
    }

    @Override
    public Activity waitForMonitorWithTimeout(ActivityMonitor monitor, long timeOut) {
        return mBaseInstrumentation.waitForMonitorWithTimeout(monitor, timeOut);
    }

    @Override
    public void removeMonitor(ActivityMonitor monitor) {
        mBaseInstrumentation.removeMonitor(monitor);
    }

    @Override
    public boolean invokeMenuActionSync(Activity targetActivity, int id, int flag) {
        return mBaseInstrumentation.invokeMenuActionSync(targetActivity, id, flag);
    }

    @Override
    public boolean invokeContextMenuAction(Activity targetActivity, int id, int flag) {
        return mBaseInstrumentation.invokeContextMenuAction(targetActivity, id, flag);
    }

    @Override
    public void sendStringSync(String text) {
        mBaseInstrumentation.sendStringSync(text);
    }

    @Override
    public void sendKeySync(KeyEvent event) {
        mBaseInstrumentation.sendKeySync(event);
    }

    @Override
    public void sendKeyDownUpSync(int key) {
        mBaseInstrumentation.sendKeyDownUpSync(key);
    }

    @Override
    public void sendCharacterSync(int keyCode) {
        mBaseInstrumentation.sendCharacterSync(keyCode);
    }

    @Override
    public void sendPointerSync(MotionEvent event) {
        mBaseInstrumentation.sendPointerSync(event);
    }

    @Override
    public void sendTrackballEventSync(MotionEvent event) {
        mBaseInstrumentation.sendTrackballEventSync(event);
    }

    @Override
    public Application newApplication(ClassLoader cl, String className, Context context) throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        return mBaseInstrumentation.newApplication(cl, className, context);
    }

    @Override
    public void callApplicationOnCreate(Application app) {
        mBaseInstrumentation.callApplicationOnCreate(app);
    }

    @Override
    public Activity newActivity(Class<?> clazz, Context context, IBinder token, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, Object lastNonConfigurationInstance) throws IllegalAccessException, InstantiationException {
        return mBaseInstrumentation.newActivity(clazz, context, token, application, intent, info, title, parent, id, lastNonConfigurationInstance);
    }

    @Override
    public Activity newActivity(ClassLoader cl, String className, Intent intent) throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        return mBaseInstrumentation.newActivity(cl, className, intent);
    }

    @Override
    public void callActivityOnCreate(Activity activity, Bundle icicle) {
        mBaseInstrumentation.callActivityOnCreate(activity, icicle);
        for (AppLifecycleCallback appLifecycleCallback : BlackBoxCore.get().getAppLifecycleCallbacks()) {
            appLifecycleCallback.onActivityCreated(activity, icicle);
        }
    }

    @Override
    public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) {
        mBaseInstrumentation.callActivityOnCreate(activity, icicle, persistentState);
        for (AppLifecycleCallback appLifecycleCallback : BlackBoxCore.get().getAppLifecycleCallbacks()) {
            appLifecycleCallback.onActivityCreated(activity, icicle);
        }
    }

    @Override
    public void callActivityOnDestroy(Activity activity) {
        mBaseInstrumentation.callActivityOnDestroy(activity);
        for (AppLifecycleCallback appLifecycleCallback : BlackBoxCore.get().getAppLifecycleCallbacks()) {
            appLifecycleCallback.onActivityDestroyed(activity);
        }
    }

    @Override
    public void callActivityOnRestoreInstanceState(Activity activity, Bundle savedInstanceState) {
        mBaseInstrumentation.callActivityOnRestoreInstanceState(activity, savedInstanceState);
    }

    @Override
    public void callActivityOnRestoreInstanceState(Activity activity, Bundle savedInstanceState, PersistableBundle persistentState) {
        mBaseInstrumentation.callActivityOnRestoreInstanceState(activity, savedInstanceState, persistentState);
    }

    @Override
    public void callActivityOnPostCreate(Activity activity, Bundle icicle) {
        mBaseInstrumentation.callActivityOnPostCreate(activity, icicle);
    }

    @Override
    public void callActivityOnPostCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) {
        mBaseInstrumentation.callActivityOnPostCreate(activity, icicle, persistentState);
    }

    @Override
    public void callActivityOnNewIntent(Activity activity, Intent intent) {
        mBaseInstrumentation.callActivityOnNewIntent(activity, intent);
    }

    @Override
    public void callActivityOnStart(Activity activity) {
        mBaseInstrumentation.callActivityOnStart(activity);
        for (AppLifecycleCallback appLifecycleCallback : BlackBoxCore.get().getAppLifecycleCallbacks()) {
            appLifecycleCallback.onActivityStarted(activity);
        }
    }

    @Override
    public void callActivityOnRestart(Activity activity) {
        mBaseInstrumentation.callActivityOnRestart(activity);
    }

    @Override
    public void callActivityOnResume(Activity activity) {
        mBaseInstrumentation.callActivityOnResume(activity);
        for (AppLifecycleCallback appLifecycleCallback : BlackBoxCore.get().getAppLifecycleCallbacks()) {
            appLifecycleCallback.onActivityResumed(activity);
        }
    }

    @Override
    public void callActivityOnStop(Activity activity) {
        mBaseInstrumentation.callActivityOnStop(activity);
        for (AppLifecycleCallback appLifecycleCallback : BlackBoxCore.get().getAppLifecycleCallbacks()) {
            appLifecycleCallback.onActivityStopped(activity);
        }
    }

    @Override
    public void callActivityOnSaveInstanceState(Activity activity, Bundle outState) {
        mBaseInstrumentation.callActivityOnSaveInstanceState(activity, outState);
    }

    @Override
    public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) {
        mBaseInstrumentation.callActivityOnSaveInstanceState(activity, outState, outPersistentState);
        for (AppLifecycleCallback appLifecycleCallback : BlackBoxCore.get().getAppLifecycleCallbacks()) {
            appLifecycleCallback.onActivitySaveInstanceState(activity, outState);
        }
    }

    @Override
    public void callActivityOnPause(Activity activity) {
        mBaseInstrumentation.callActivityOnPause(activity);
        for (AppLifecycleCallback appLifecycleCallback : BlackBoxCore.get().getAppLifecycleCallbacks()) {
            appLifecycleCallback.onActivityPaused(activity);
        }
    }

    @Override
    public void callActivityOnUserLeaving(Activity activity) {
        mBaseInstrumentation.callActivityOnUserLeaving(activity);
    }

    @Override
    public void startAllocCounting() {
        mBaseInstrumentation.startAllocCounting();
    }

    @Override
    public void stopAllocCounting() {
        mBaseInstrumentation.stopAllocCounting();
    }

    @Override
    public Bundle getAllocCounts() {
        return mBaseInstrumentation.getAllocCounts();
    }

    @Override
    public Bundle getBinderCounts() {
        return mBaseInstrumentation.getBinderCounts();
    }

    @Override
    public UiAutomation getUiAutomation() {
        return mBaseInstrumentation.getUiAutomation();
    }
}

```

`Bcore/src/main/java/com/vcore/fake/delegate/ContentProviderDelegate.java`:

```java
package com.vcore.fake.delegate;

import android.net.Uri;
import android.os.Build;
import android.os.IInterface;
import android.util.ArrayMap;

import java.lang.reflect.Proxy;
import java.util.HashSet;
import java.util.Set;

import black.android.app.ActivityThread;
import black.android.app.IActivityManager;
import black.android.content.ContentProviderHolderOreo;
import black.android.providers.Settings;
import com.vcore.BlackBoxCore;
import com.vcore.fake.service.context.providers.ContentProviderStub;
import com.vcore.fake.service.context.providers.SystemProviderStub;
import com.vcore.utils.compat.BuildCompat;

public class ContentProviderDelegate {
    public static final String TAG = "ContentProviderDelegate";
    private static final Set<String> sInjected = new HashSet<>();

    public static void update(Object holder, String auth) {
        IInterface iInterface;
        if (BuildCompat.isOreo()) {
            iInterface = ContentProviderHolderOreo.provider.get(holder);
        } else {
            iInterface = IActivityManager.ContentProviderHolder.provider.get(holder);
        }

        if (iInterface instanceof Proxy) {
            return;
        }

        IInterface bContentProvider;
        switch (auth) {
            case "media":
            case "telephony":
            case "settings":
                bContentProvider = new SystemProviderStub().wrapper(iInterface, BlackBoxCore.getHostPkg());
                break;
            default:
                bContentProvider = new ContentProviderStub().wrapper(iInterface, BlackBoxCore.getHostPkg());
                break;
        }

        if (BuildCompat.isOreo()) {
            ContentProviderHolderOreo.provider.set(holder, bContentProvider);
        } else {
            IActivityManager.ContentProviderHolder.provider.set(holder, bContentProvider);
        }
    }

    public static void init() {
        clearSettingProvider();

        BlackBoxCore.getContext().getContentResolver().call(Uri.parse("content://settings"), "", null, null);
        Object activityThread = BlackBoxCore.mainThread();
        ArrayMap<Object, Object> map = (ArrayMap<Object, Object>) ActivityThread.mProviderMap.get(activityThread);

        for (Object value : map.values()) {
            String[] mNames = ActivityThread.ProviderClientRecordP.mNames.get(value);
            if (mNames == null || mNames.length <= 0) {
                continue;
            }

            String providerName = mNames[0];
            if (!sInjected.contains(providerName)) {
                sInjected.add(providerName);
                IInterface iInterface = ActivityThread.ProviderClientRecordP.mProvider.get(value);
                ActivityThread.ProviderClientRecordP.mProvider.set(value, new ContentProviderStub().wrapper(iInterface, BlackBoxCore.getHostPkg()));
                ActivityThread.ProviderClientRecordP.mNames.set(value, new String[]{providerName});
            }
        }
    }

    public static void clearSettingProvider() {
        Object cache;
        cache = Settings.System.sNameValueCache.get();
        if (cache != null) {
            clearContentProvider(cache);
        }

        cache = Settings.Secure.sNameValueCache.get();
        if (cache != null) {
            clearContentProvider(cache);
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
            cache = Settings.Global.sNameValueCache.get();
            if (cache != null) {
                clearContentProvider(cache);
            }
        }
    }

    private static void clearContentProvider(Object cache) {
        if (BuildCompat.isOreo()) {
            Object holder = Settings.NameValueCacheOreo.mProviderHolder.get(cache);
            if (holder != null) {
                Settings.ContentProviderHolder.mContentProvider.set(holder, null);
            }
        } else {
            Settings.NameValueCache.mContentProvider.set(cache, null);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/delegate/InnerReceiverDelegate.java`:

```java
package com.vcore.fake.delegate;

import android.content.IIntentReceiver;
import android.content.Intent;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;

import java.lang.ref.WeakReference;
import java.util.HashMap;
import java.util.Map;

import com.vcore.app.BActivityThread;
import com.vcore.proxy.record.ProxyBroadcastRecord;

public class InnerReceiverDelegate extends IIntentReceiver.Stub {
    public static final String TAG = "InnerReceiverDelegate";

    private static final Map<IBinder, InnerReceiverDelegate> sInnerReceiverDelegate = new HashMap<>();
    private final WeakReference<IIntentReceiver> mIntentReceiver;

    private InnerReceiverDelegate(IIntentReceiver iIntentReceiver) {
        this.mIntentReceiver = new WeakReference<>(iIntentReceiver);
    }

    public static IIntentReceiver createProxy(IIntentReceiver base) {
        if (base instanceof InnerReceiverDelegate) {
            return base;
        }
        final IBinder iBinder = base.asBinder();
        InnerReceiverDelegate delegate = sInnerReceiverDelegate.get(iBinder);
        if (delegate == null) {
            try {
                iBinder.linkToDeath(new DeathRecipient() {
                    @Override
                    public void binderDied() {
                        sInnerReceiverDelegate.remove(iBinder);
                        iBinder.unlinkToDeath(this, 0);
                    }
                }, 0);
            } catch (RemoteException e) {
                e.printStackTrace();
            }

            delegate = new InnerReceiverDelegate(base);
            sInnerReceiverDelegate.put(iBinder, delegate);
        }
        return delegate;
    }

    @Override
    public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
        intent.setExtrasClassLoader(BActivityThread.getApplication().getClassLoader());
        ProxyBroadcastRecord proxyBroadcastRecord = ProxyBroadcastRecord.create(intent);
        Intent perIntent;
        if (proxyBroadcastRecord.mIntent != null) {
            proxyBroadcastRecord.mIntent.setExtrasClassLoader(BActivityThread.getApplication().getClassLoader());
            perIntent = proxyBroadcastRecord.mIntent;
        } else {
            perIntent = intent;
        }

        IIntentReceiver iIntentReceiver = mIntentReceiver.get();
        if (iIntentReceiver != null) {
            black.android.content.IIntentReceiver.performReceive.call(iIntentReceiver, perIntent, resultCode, data, extras, ordered, sticky, sendingUser);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/delegate/ServiceConnectionDelegate.java`:

```java
package com.vcore.fake.delegate;

import android.app.IServiceConnection;
import android.content.ComponentName;
import android.content.Intent;
import android.os.IBinder;
import android.os.RemoteException;

import java.util.HashMap;
import java.util.Map;

import black.android.app.IServiceConnectionO;
import com.vcore.utils.compat.BuildCompat;

public class ServiceConnectionDelegate extends IServiceConnection.Stub {
    private static final Map<IBinder, ServiceConnectionDelegate> sServiceConnectDelegate = new HashMap<>();
    private final IServiceConnection mConn;
    private final ComponentName mComponentName;

    private ServiceConnectionDelegate(IServiceConnection mConn, ComponentName targetComponent) {
        this.mConn = mConn;
        this.mComponentName = targetComponent;
    }

    public static ServiceConnectionDelegate getDelegate(IBinder iBinder) {
        return sServiceConnectDelegate.get(iBinder);
    }

    public static IServiceConnection createProxy(IServiceConnection base, Intent intent) {
        final IBinder iBinder = base.asBinder();
        ServiceConnectionDelegate delegate = sServiceConnectDelegate.get(iBinder);
        if (delegate == null) {
            try {
                iBinder.linkToDeath(new IBinder.DeathRecipient() {
                    @Override
                    public void binderDied() {
                        sServiceConnectDelegate.remove(iBinder);
                        iBinder.unlinkToDeath(this, 0);
                    }
                }, 0);
            } catch (RemoteException e) {
                e.printStackTrace();
            }

            delegate = new ServiceConnectionDelegate(base, intent.getComponent());
            sServiceConnectDelegate.put(iBinder, delegate);
        }
        return delegate;
    }

    @Override
    public void connected(ComponentName name, IBinder service) throws RemoteException {
        connected(name, service, false);
    }

    public void connected(ComponentName name, IBinder service, boolean dead) throws RemoteException {
        if (BuildCompat.isOreo()) {
            IServiceConnectionO.connected.call(mConn, mComponentName, service, dead);
        } else {
            mConn.connected(name, service);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/frameworks/BAccountManager.java`:

```java
package com.vcore.fake.frameworks;

import android.accounts.Account;
import android.accounts.AuthenticatorDescription;
import android.accounts.IAccountManagerResponse;
import android.os.Bundle;
import android.os.RemoteException;

import java.util.Map;

import com.vcore.app.BActivityThread;
import com.vcore.core.system.ServiceManager;
import com.vcore.core.system.accounts.IBAccountManagerService;

public class BAccountManager extends BlackManager<IBAccountManagerService> {
    private static final BAccountManager sBAccountManager = new BAccountManager();

    public static BAccountManager get() {
        return sBAccountManager;
    }

    @Override
    protected String getServiceName() {
        return ServiceManager.ACCOUNT_MANAGER;
    }

    public String getPassword(Account account) {
        try {
            return getService().getPassword(account, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public String getUserData(Account account, String key) {
        try {
            return getService().getUserData(account, key, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public AuthenticatorDescription[] getAuthenticatorTypes() {
        try {
            return getService().getAuthenticatorTypes(BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public Account[] getAccountsForPackage(String packageName, int uid) {
        try {
            return getService().getAccountsForPackage(packageName, uid, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public Account[] getAccountsByTypeForPackage(String type, String packageName) {
        try {
            return getService().getAccountsByTypeForPackage(type, packageName, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public Account[] getAccountsAsUser(String type) {
        try {
            return getService().getAccountsAsUser(type, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void getAccountByTypeAndFeatures(IAccountManagerResponse response, String accountType,
                                            String[] features) {
        try {
            getService().getAccountByTypeAndFeatures(response, accountType, features, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }
    
    public void getAccountsByFeatures(IAccountManagerResponse response, String accountType, String[] features) {
        try {
            getService().getAccountsByFeatures(response, accountType, features, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public boolean addAccountExplicitly(Account account, String password, Bundle extras) {
        try {
            return getService().addAccountExplicitly(account, password, extras, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return false;
    }

    public void removeAccountAsUser(IAccountManagerResponse response, Account account, boolean expectActivityLaunch) {
        try {
            getService().removeAccountAsUser(response, account, expectActivityLaunch, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public boolean removeAccountExplicitly(Account account) {
        try {
            return getService().removeAccountExplicitly(account, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return false;
    }

    public void copyAccountToUser(IAccountManagerResponse response, Account account, int userFrom, int userTo) {
        try {
            getService().copyAccountToUser(response, account, userFrom, userTo);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void invalidateAuthToken(String accountType, String authToken) {
        try {
            getService().invalidateAuthToken(accountType, authToken, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public String peekAuthToken(Account account, String authTokenType) {
        try {
            return getService().peekAuthToken(account, authTokenType, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void setAuthToken(Account account, String authTokenType, String authToken) {
        try {
            getService().setAuthToken(account, authTokenType, authToken, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void setPassword(Account account, String password) {
        try {
            getService().setPassword(account, password, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void clearPassword(Account account) {
        try {
            getService().clearPassword(account, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void setUserData(Account account, String key, String value) {
        try {
            getService().setUserData(account, key, value, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void updateAppPermission(Account account, String authTokenType, int uid, boolean value) {
        try {
            getService().updateAppPermission(account, authTokenType, uid, value);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void getAuthToken(IAccountManagerResponse response, Account account, String authTokenType, boolean notifyOnAuthFailure, boolean expectActivityLaunch,
                             Bundle options) {
        try {
            getService().getAuthToken(response, account, authTokenType, notifyOnAuthFailure, expectActivityLaunch, options, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void addAccount(IAccountManagerResponse response, String accountType, String authTokenType, String[] requiredFeatures, boolean expectActivityLaunch,
                           Bundle options) {
        try {
            getService().addAccount(response, accountType, authTokenType, requiredFeatures, expectActivityLaunch, options, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void addAccountAsUser(IAccountManagerResponse response, String accountType, String authTokenType, String[] requiredFeatures,
                                 boolean expectActivityLaunch, Bundle options) {
        try {
            getService().addAccountAsUser(response, accountType, authTokenType, requiredFeatures, expectActivityLaunch, options, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void updateCredentials(IAccountManagerResponse response, Account account, String authTokenType, boolean expectActivityLaunch, Bundle options) {
        try {
            getService().updateCredentials(response, account, authTokenType, expectActivityLaunch, options, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void editProperties(IAccountManagerResponse response, String accountType, boolean expectActivityLaunch) {
        try {
            getService().editProperties(response, accountType, expectActivityLaunch, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void confirmCredentialsAsUser(IAccountManagerResponse response, Account account, Bundle options, boolean expectActivityLaunch) {
        try {
            getService().confirmCredentialsAsUser(response, account, options, expectActivityLaunch, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void accountAuthenticated(Account account) {
        try {
            getService().accountAuthenticated(account, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void getAuthTokenLabel(IAccountManagerResponse response, String accountType, String authTokenType) {
        try {
            getService().getAuthTokenLabel(response, accountType, authTokenType, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    /* Returns Map<String, Integer> from package name to visibility with all values stored for given account */
    public Map getPackagesAndVisibilityForAccount(Account account) {
        try {
            return getService().getPackagesAndVisibilityForAccount(account, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public boolean addAccountExplicitlyWithVisibility(Account account, String password, Bundle extras, Map visibility) {
        try {
            return getService().addAccountExplicitlyWithVisibility(account, password, extras, visibility, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return false;
    }

    public boolean setAccountVisibility(Account account, String packageName, int newVisibility) {
        try {
            return getService().setAccountVisibility(account, packageName, newVisibility, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return false;
    }

    public int getAccountVisibility(Account account, String packageName) {
        try {
            return getService().getAccountVisibility(account, packageName, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        // AccountManager.VISIBILITY_NOT_VISIBLE
        return 3;
    }

    /* Type may be null returns Map <Account, Integer>*/
    public Map getAccountsAndVisibilityForPackage(String packageName, String accountType) {
        try {
            return getService().getAccountsAndVisibilityForPackage(packageName, accountType, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void registerAccountListener(String[] accountTypes, String opPackageName) {
        try {
            getService().registerAccountListener(accountTypes, opPackageName, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void unregisterAccountListener(String[] accountTypes, String opPackageName) {
        try {
            getService().unregisterAccountListener(accountTypes, opPackageName, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/frameworks/BActivityManager.java`:

```java
package com.vcore.fake.frameworks;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.ProviderInfo;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;

import com.vcore.app.BActivityThread;
import com.vcore.core.system.ServiceManager;
import com.vcore.core.system.am.IBActivityManagerService;
import com.vcore.entity.AppConfig;
import com.vcore.entity.UnbindRecord;
import com.vcore.entity.am.PendingResultData;
import com.vcore.entity.am.RunningAppProcessInfo;
import com.vcore.entity.am.RunningServiceInfo;

public class BActivityManager extends BlackManager<IBActivityManagerService> {
    private static final BActivityManager sActivityManager = new BActivityManager();

    public static BActivityManager get() {
        return sActivityManager;
    }

    @Override
    protected String getServiceName() {
        return ServiceManager.ACTIVITY_MANAGER;
    }

    public AppConfig initProcess(String packageName, String processName, int userId) {
        try {
            return getService().initProcess(packageName, processName, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void restartProcess(String packageName, String processName, int userId) {
        try {
            getService().restartProcess(packageName, processName, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void startActivity(Intent intent, int userId) {
        try {
            getService().startActivity(intent, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void startActivityAms(int userId, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags, Bundle options) {
        try {
            getService().startActivityAms(userId, intent, resolvedType, resultTo, resultWho, requestCode, flags, options);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public int startActivities(int userId, Intent[] intent, String[] resolvedType, IBinder resultTo, Bundle options) {
        try {
            return getService().startActivities(userId, intent, resolvedType, resultTo, options);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return -1;
    }

    public ComponentName startService(Intent intent, String resolvedType, boolean requireForeground, int userId) {
        try {
            return getService().startService(intent, resolvedType, requireForeground, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public int stopService(Intent intent, String resolvedType, int userId) {
        try {
            return getService().stopService(intent, resolvedType, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return -1;
    }

    public Intent bindService(Intent service, IBinder binder, String resolvedType, int userId) {
        try {
            return getService().bindService(service, binder, resolvedType, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void unbindService(IBinder binder, int userId) {
        try {
            getService().unbindService(binder, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void stopServiceToken(ComponentName componentName, IBinder token, int userId) {
        try {
            getService().stopServiceToken(componentName, token, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public UnbindRecord onServiceUnbind(Intent proxyIntent, int userId) {
        try {
            return getService().onServiceUnbind(proxyIntent, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void onServiceDestroy(Intent proxyIntent, int userId) {
        try {
            getService().onServiceDestroy(proxyIntent, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public IBinder acquireContentProviderClient(ProviderInfo providerInfo) {
        try {
            return getService().acquireContentProviderClient(providerInfo);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public Intent sendBroadcast(Intent intent, String resolvedType, int userId) {
        try {
            return getService().sendBroadcast(intent, resolvedType, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public IBinder peekService(Intent intent, String resolvedType, int userId) {
        try {
            return getService().peekService(intent, resolvedType, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void onActivityCreated(int taskId, IBinder token, String activityToken) {
        try {
            getService().onActivityCreated(taskId, token, activityToken);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void onActivityResumed(IBinder token) {
        try {
            // Fix https://github.com/FBlackBox/BlackBox/issues/28
            if ("com.tencent.mm".equals(BActivityThread.getAppPackageName())) {
                Activity activityByToken = BActivityThread.getActivityByToken(token);
                if (activityByToken != null) {
                    activityByToken.getWindow().getDecorView().clearFocus();
                }
            }
        } catch (Throwable ignored) { }

        try {
            getService().onActivityResumed(token);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void onActivityDestroyed(IBinder token) {
        try {
            getService().onActivityDestroyed(token);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void onFinishActivity(IBinder token) {
        try {
            getService().onFinishActivity(token);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public RunningAppProcessInfo getRunningAppProcesses(String callerPackage, int userId) {
        try {
            return getService().getRunningAppProcesses(callerPackage, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public RunningServiceInfo getRunningServices(String callerPackage, int userId) {
        try {
            return getService().getRunningServices(callerPackage, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void scheduleBroadcastReceiver(Intent intent, PendingResultData pendingResultData, int userId) throws RemoteException {
        getService().scheduleBroadcastReceiver(intent, pendingResultData, userId);
    }

    public void finishBroadcast(PendingResultData data) {
        try {
            getService().finishBroadcast(data);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public String getCallingPackage(IBinder token, int userId) {
        try {
            return getService().getCallingPackage(token, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public ComponentName getCallingActivity(IBinder token, int userId) {
        try {
            return getService().getCallingActivity(token, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void getIntentSender(IBinder target, String packageName, int uid) {
        try {
            getService().getIntentSender(target, packageName, uid, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public String getPackageForIntentSender(IBinder target) {
        try {
            return getService().getPackageForIntentSender(target, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public int getUidForIntentSender(IBinder target) {
        try {
            return getService().getUidForIntentSender(target, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return -1;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/frameworks/BJobManager.java`:

```java
package com.vcore.fake.frameworks;

import android.app.job.JobInfo;
import android.os.RemoteException;

import com.vcore.app.BActivityThread;
import com.vcore.core.system.ServiceManager;
import com.vcore.core.system.am.IBJobManagerService;
import com.vcore.entity.JobRecord;

public class BJobManager extends BlackManager<IBJobManagerService> {
    private static final BJobManager sJobManager = new BJobManager();

    public static BJobManager get() {
        return sJobManager;
    }

    @Override
    protected String getServiceName() {
        return ServiceManager.JOB_MANAGER;
    }

    public JobInfo schedule(JobInfo info) {
        try {
            return getService().schedule(info, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public JobRecord queryJobRecord(String processName, int jobId) {
        try {
            return getService().queryJobRecord(processName, jobId, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void cancelAll(String processName) {
        try {
            getService().cancelAll(processName, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public int cancel(String processName, int jobId) {
        try {
            return getService().cancel(processName, jobId, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return -1;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/frameworks/BLocationManager.java`:

```java
package com.vcore.fake.frameworks;

import android.os.IBinder;
import android.os.RemoteException;

import java.util.ArrayList;
import java.util.List;

import com.vcore.app.BActivityThread;
import com.vcore.core.system.ServiceManager;
import com.vcore.core.system.location.IBLocationManagerService;
import com.vcore.entity.location.BCell;
import com.vcore.entity.location.BLocation;

public class BLocationManager extends BlackManager<IBLocationManagerService> {
    private static final BLocationManager sLocationManager = new BLocationManager();

    public static final int CLOSE_MODE = 0;
    public static final int GLOBAL_MODE = 1;
    public static final int OWN_MODE = 2;

    public static BLocationManager get() {
        return sLocationManager;
    }

    @Override
    protected String getServiceName() {
        return ServiceManager.LOCATION_MANAGER;
    }

    public static boolean isFakeLocationEnable() {
        return get().getPattern(BActivityThread.getUserId(), BActivityThread.getAppPackageName()) != CLOSE_MODE;
    }

    public static void disableFakeLocation(int userId,String pkg) {
        get().setPattern(userId, pkg, CLOSE_MODE);
    }

    public void setPattern(int userId, String pkg, int pattern) {
        try {
            getService().setPattern(userId, pkg, pattern);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public int getPattern(int userId, String pkg) {
        try {
            return getService().getPattern(userId, pkg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return CLOSE_MODE;
    }

    public List<BCell> getNeighboringCell(int userId, String pkg) {
        try {
            return getService().getNeighboringCell(userId, pkg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public BCell getCell(int userId, String pkg) {
        try {
            return getService().getCell(userId, pkg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public List<BCell> getAllCell(int userId, String pkg) {
        try {
            return getService().getAllCell(userId, pkg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return new ArrayList<>();
    }

    public void setLocation(int userId, String pkg, BLocation location) {
        try {
            getService().setLocation(userId, pkg, location);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public BLocation getLocation(int userId, String pkg) {
        try {
            return getService().getLocation(userId, pkg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void requestLocationUpdates(IBinder listener) {
        try {
            getService().requestLocationUpdates(listener, BActivityThread.getAppPackageName(), BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void removeUpdates(IBinder listener) {
        try {
            getService().removeUpdates(listener);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/frameworks/BNotificationManager.java`:

```java
package com.vcore.fake.frameworks;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationChannelGroup;
import android.os.RemoteException;

import java.util.ArrayList;
import java.util.List;

import com.vcore.app.BActivityThread;
import com.vcore.core.system.ServiceManager;
import com.vcore.core.system.notification.IBNotificationManagerService;

public class BNotificationManager extends BlackManager<IBNotificationManagerService> {
    private static final BNotificationManager sNotificationManager = new BNotificationManager();

    public static BNotificationManager get() {
        return sNotificationManager;
    }

    @Override
    protected String getServiceName() {
        return ServiceManager.NOTIFICATION_MANAGER;
    }

    public NotificationChannel getNotificationChannel(String channelId) {
        try {
            return getService().getNotificationChannel(channelId, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public List<NotificationChannelGroup> getNotificationChannelGroups(String packageName) {
        try {
            return getService().getNotificationChannelGroups(packageName, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void createNotificationChannel(NotificationChannel notificationChannel) {
        try {
            getService().createNotificationChannel(notificationChannel, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void deleteNotificationChannel(String channelId) {
        try {
            getService().deleteNotificationChannel(channelId, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void createNotificationChannelGroup(NotificationChannelGroup notificationChannelGroup) {
        try {
            getService().createNotificationChannelGroup(notificationChannelGroup, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void deleteNotificationChannelGroup(String groupId) {
        try {
            getService().deleteNotificationChannelGroup(groupId, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void enqueueNotificationWithTag(int id, String tag, Notification notification) {
        try {
            getService().enqueueNotificationWithTag(id, tag, notification, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void cancelNotificationWithTag(int id, String tag) {
        try {
            getService().cancelNotificationWithTag(id, tag, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public List<NotificationChannel> getNotificationChannels(String packageName) {
        try {
            return getService().getNotificationChannels(packageName, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return new ArrayList<>();
    }
}

```

`Bcore/src/main/java/com/vcore/fake/frameworks/BPackageManager.java`:

```java
package com.vcore.fake.frameworks;

import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.ServiceInfo;
import android.os.RemoteException;

import java.util.Collections;
import java.util.List;

import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.core.system.ServiceManager;
import com.vcore.core.system.pm.IBPackageManagerService;
import com.vcore.entity.pm.InstallOption;
import com.vcore.entity.pm.InstallResult;

public class BPackageManager extends BlackManager<IBPackageManagerService> {
    private static final BPackageManager sPackageManager = new BPackageManager();

    public static BPackageManager get() {
        return sPackageManager;
    }

    @Override
    protected String getServiceName() {
        return ServiceManager.PACKAGE_MANAGER;
    }

    public Intent getLaunchIntentForPackage(String packageName, int userId) {
        Intent intentToResolve = new Intent(Intent.ACTION_MAIN);
        intentToResolve.addCategory(Intent.CATEGORY_INFO);
        intentToResolve.setPackage(packageName);
        List<ResolveInfo> ris = queryIntentActivities(intentToResolve, 0,
                intentToResolve.resolveTypeIfNeeded(BlackBoxCore.getContext().getContentResolver()), userId);

        // Otherwise, try to find a main launcher activity.
        if (ris == null || ris.size() <= 0) {
            // Reuse the intent instance.
            intentToResolve.removeCategory(Intent.CATEGORY_INFO);
            intentToResolve.addCategory(Intent.CATEGORY_LAUNCHER);
            intentToResolve.setPackage(packageName);
            ris = queryIntentActivities(intentToResolve, 0, intentToResolve.resolveTypeIfNeeded(BlackBoxCore.getContext().getContentResolver()), userId);
        }

        if (ris == null || ris.size() <= 0) {
            return null;
        }

        Intent intent = new Intent(intentToResolve);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.setClassName(ris.get(0).activityInfo.packageName, ris.get(0).activityInfo.name);
        return intent;
    }

    public ResolveInfo resolveService(Intent intent, int flags, String resolvedType, int userId) {
        try {
            return getService().resolveService(intent, flags, resolvedType, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public ResolveInfo resolveActivity(Intent intent, int flags, String resolvedType, int userId) {
        try {
            return getService().resolveActivity(intent, flags, resolvedType, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public ProviderInfo resolveContentProvider(String authority, int flags, int userId) {
        try {
            return getService().resolveContentProvider(authority, flags, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) {
        try {
            return getService().resolveIntent(intent, resolvedType, flags, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public ApplicationInfo getApplicationInfo(String packageName, int flags, int userId) {
        try {
            return getService().getApplicationInfo(packageName, flags, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public int getUidByPid(int pid) {
        try {
            return getService().getUidByPid(pid);
        } catch (RemoteException e) {
            crash(e);
        }
        return -1;
    }

    public PackageInfo getPackageInfo(String packageName, int flags, int userId) {
        try {
            return getService().getPackageInfo(packageName, flags, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public ServiceInfo getServiceInfo(ComponentName component, int flags, int userId) {
        try {
            return getService().getServiceInfo(component, flags, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public ActivityInfo getReceiverInfo(ComponentName componentName, int flags, int userId) {
        try {
            return getService().getReceiverInfo(componentName, flags, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public ActivityInfo getActivityInfo(ComponentName component, int flags, int userId) {
        try {
            return getService().getActivityInfo(component, flags, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public ProviderInfo getProviderInfo(ComponentName component, int flags, int userId) {
        try {
            return getService().getProviderInfo(component, flags, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public List<ResolveInfo> queryIntentActivities(Intent intent, int flags, String resolvedType, int userId) {
        try {
            return getService().queryIntentActivities(intent, flags, resolvedType, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public List<ResolveInfo> queryBroadcastReceivers(Intent intent, int flags, String resolvedType, int userId) {
        try {
            return getService().queryBroadcastReceivers(intent, flags, resolvedType, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public List<ProviderInfo> queryContentProviders(String processName, int uid, int flags, int userId) {
        try {
            return getService().queryContentProviders(processName, uid, flags, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public InstallResult installPackageAsUser(String file, InstallOption option, int userId) {
        try {
            return getService().installPackageAsUser(file, option, userId);
        } catch (RemoteException e) {
            crash(e);
        }
        return null;
    }

    public List<ApplicationInfo> getInstalledApplications(int flags, int userId) {
        try {
            return getService().getInstalledApplications(flags, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return Collections.emptyList();
    }

    public List<PackageInfo> getInstalledPackages(int flags, int userId) {
        try {
            return getService().getInstalledPackages(flags, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return Collections.emptyList();
    }

    public void clearPackage(String packageName, int userId) {
        try {
            getService().clearPackage(packageName, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void stopPackage(String packageName, int userId) {
        try {
            getService().stopPackage(packageName, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void uninstallPackageAsUser(String packageName, int userId) {
        try {
            getService().uninstallPackageAsUser(packageName, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void uninstallPackage(String packageName) {
        try {
            getService().uninstallPackage(packageName);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public boolean isInstalled(String packageName, int userId) {
        try {
            return getService().isInstalled(packageName, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return false;
    }

    public String[] getPackagesForUid(int uid) {
        try {
            return getService().getPackagesForUid(uid, BActivityThread.getUserId());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return new String[]{};
    }

    private void crash(Throwable e) {
        e.printStackTrace();
    }
}

```

`Bcore/src/main/java/com/vcore/fake/frameworks/BStorageManager.java`:

```java
package com.vcore.fake.frameworks;

import android.net.Uri;
import android.os.RemoteException;
import android.os.storage.StorageVolume;

import com.vcore.core.system.ServiceManager;
import com.vcore.core.system.os.IBStorageManagerService;

public class BStorageManager extends BlackManager<IBStorageManagerService> {
    private static final BStorageManager sStorageManager = new BStorageManager();

    public static BStorageManager get() {
        return sStorageManager;
    }

    @Override
    protected String getServiceName() {
        return ServiceManager.STORAGE_MANAGER;
    }

    public StorageVolume[] getVolumeList(int uid, String packageName, int flags, int userId) {
        try {
            return getService().getVolumeList(uid, packageName, flags, userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return new StorageVolume[]{};
    }

    public Uri getUriForFile(String file) {
        try {
            return getService().getUriForFile(file);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/frameworks/BUserManager.java`:

```java
package com.vcore.fake.frameworks;

import android.os.RemoteException;

import java.util.Collections;
import java.util.List;

import com.vcore.core.system.ServiceManager;
import com.vcore.core.system.user.BUserInfo;
import com.vcore.core.system.user.IBUserManagerService;

public class BUserManager extends BlackManager<IBUserManagerService> {
    private static final BUserManager sUserManager = new BUserManager();

    public static BUserManager get() {
        return sUserManager;
    }

    @Override
    protected String getServiceName() {
        return ServiceManager.USER_MANAGER;
    }

    public BUserInfo createUser(int userId) {
        try {
            return getService().createUser(userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void deleteUser(int userId) {
        try {
            getService().deleteUser(userId);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public List<BUserInfo> getUsers() {
        try {
            return getService().getUsers();
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return Collections.emptyList();
    }
}

```

`Bcore/src/main/java/com/vcore/fake/frameworks/BXposedManager.java`:

```java
package com.vcore.fake.frameworks;

import android.os.RemoteException;

import java.util.Collections;
import java.util.List;

import com.vcore.core.system.ServiceManager;
import com.vcore.core.system.pm.IBXposedManagerService;
import com.vcore.entity.pm.InstalledModule;

public class BXposedManager extends BlackManager<IBXposedManagerService> {
    private static final BXposedManager sXposedManager = new BXposedManager();

    public static BXposedManager get() {
        return sXposedManager;
    }

    @Override
    protected String getServiceName() {
        return ServiceManager.XPOSED_MANAGER;
    }

    public boolean isXPEnable() {
        try {
            return getService().isXPEnable();
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return false;
    }

    public void setXPEnable(boolean enable) {
        try {
            getService().setXPEnable(enable);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public boolean isModuleEnable(String packageName) {
        try {
            return getService().isModuleEnable(packageName);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return false;
    }

    public void setModuleEnable(String packageName, boolean enable) {
        try {
            getService().setModuleEnable(packageName, enable);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public List<InstalledModule> getInstalledModules() {
        try {
            return getService().getInstalledModules();
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        return Collections.emptyList();
    }
}

```

`Bcore/src/main/java/com/vcore/fake/frameworks/BlackManager.java`:

```java
package com.vcore.fake.frameworks;

import android.os.IBinder;
import android.os.IInterface;

import java.lang.reflect.ParameterizedType;

import black.Reflector;
import com.vcore.BlackBoxCore;

public abstract class BlackManager<Service extends IInterface> {
    public static final String TAG = "BlackManager";

    private Service mService;

    protected abstract String getServiceName();

    public Service getService() {
        if (mService != null && mService.asBinder().pingBinder() && mService.asBinder().isBinderAlive()) {
            return mService;
        }
        try {
            // 通过反射调用T.Stub.asInterface
            mService = Reflector.on(getTClass().getName() + "$Stub").staticMethod("asInterface", IBinder.class)
                    .callWithClass(BlackBoxCore.get().getService(getServiceName()));
            mService.asBinder().linkToDeath(new IBinder.DeathRecipient() {
                @Override
                public void binderDied() {
                    mService.asBinder().unlinkToDeath(this, 0);
                    mService = null;
                }
            }, 0);
            return getService();
        } catch (Throwable e) {
            e.printStackTrace();
            return null;
        }
    }

    private Class<Service> getTClass() {
        return (Class<Service>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
    }
}
```

`Bcore/src/main/java/com/vcore/fake/hook/BinderInvocationStub.java`:

```java
package com.vcore.fake.hook;

import android.os.IBinder;
import android.os.IInterface;
import android.os.Parcel;
import android.os.RemoteException;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.FileDescriptor;
import java.util.Map;

import black.android.os.ServiceManager;

public abstract class BinderInvocationStub extends ClassInvocationStub implements IBinder {
    private final IBinder mBaseBinder;

    public BinderInvocationStub(IBinder baseBinder) {
        this.mBaseBinder = baseBinder;
    }

    @Override
    protected void onBindMethod() { }

    @Nullable
    @Override
    public String getInterfaceDescriptor() throws RemoteException {
        return mBaseBinder.getInterfaceDescriptor();
    }

    @Override
    public boolean pingBinder() {
        return mBaseBinder.pingBinder();
    }

    @Override
    public boolean isBinderAlive() {
        return mBaseBinder.isBinderAlive();
    }

    @Nullable
    @Override
    public IInterface queryLocalInterface(@NonNull String descriptor) {
        return (IInterface) getProxyInvocation();
    }

    @Override
    public void dump(@NonNull FileDescriptor fd, @Nullable String[] args) throws RemoteException {
        mBaseBinder.dump(fd, args);
    }

    @Override
    public void dumpAsync(@NonNull FileDescriptor fd, @Nullable String[] args) throws RemoteException {
        mBaseBinder.dumpAsync(fd, args);
    }

    @Override
    public boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException {
        return mBaseBinder.transact(code, data, reply, flags);
    }

    @Override
    public void linkToDeath(@NonNull DeathRecipient recipient, int flags) throws RemoteException {
        mBaseBinder.linkToDeath(recipient, flags);
    }

    @Override
    public boolean unlinkToDeath(@NonNull DeathRecipient recipient, int flags) {
        return mBaseBinder.unlinkToDeath(recipient, flags);
    }

    protected void replaceSystemService(String name) {
        Map<String, IBinder> services = ServiceManager.sCache.get();
        services.put(name, this);
    }
}

```

`Bcore/src/main/java/com/vcore/fake/hook/ClassInvocationStub.java`:

```java
package com.vcore.fake.hook;

import android.text.TextUtils;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

import com.vcore.utils.MethodParameterUtils;
import com.vcore.utils.Slog;

public abstract class ClassInvocationStub implements InvocationHandler, IInjectHook {
    public static final String TAG = ClassInvocationStub.class.getSimpleName();

    private final Map<String, MethodHook> mMethodHookMap = new HashMap<>();
    private Object mBase;
    private Object mProxyInvocation;
    private boolean onlyProxy;

    protected abstract Object getWho();

    protected abstract void inject(Object baseInvocation, Object proxyInvocation);

    protected void onBindMethod() { }

    public Object getProxyInvocation() {
        return mProxyInvocation;
    }

    protected void onlyProxy(boolean onlyStatus) {
        onlyProxy = onlyStatus;
    }

    @Override
    public void injectHook() {
        mBase = getWho();
        mProxyInvocation = Proxy.newProxyInstance(mBase.getClass().getClassLoader(), MethodParameterUtils.getAllInterface(mBase.getClass()), this);
        if (!onlyProxy) {
            inject(mBase, mProxyInvocation);
        }

        onBindMethod();
        Class<?>[] declaredClasses = this.getClass().getDeclaredClasses();
        for (Class<?> declaredClass : declaredClasses) {
            initAnnotation(declaredClass);
        }

        ScanClass scanClass = this.getClass().getAnnotation(ScanClass.class);
        if (scanClass != null) {
            for (Class<?> aClass : scanClass.value()) {
                for (Class<?> declaredClass : aClass.getDeclaredClasses()) {
                    initAnnotation(declaredClass);
                }
            }
        }
    }

    protected void initAnnotation(Class<?> clazz) {
        // Get proxy method annotation.
        ProxyMethod proxyMethod = clazz.getAnnotation(ProxyMethod.class);
        if (proxyMethod != null) {
            final String name = proxyMethod.value();
            if (!TextUtils.isEmpty(name)) {
                try {
                    addMethodHook(name, (MethodHook) clazz.newInstance());
                } catch (Throwable t) {
                    t.printStackTrace();
                }
            }
        }

        ProxyMethods proxyMethods = clazz.getAnnotation(ProxyMethods.class);
        if (proxyMethods != null) {
            String[] value = proxyMethods.value();
            for (String name : value) {
                try {
                    addMethodHook(name, (MethodHook) clazz.newInstance());
                } catch (Throwable t) {
                    t.printStackTrace();
                }
            }
        }
    }

    protected void addMethodHook(MethodHook methodHook) {
        mMethodHookMap.put(methodHook.getMethodName(), methodHook);
    }

    protected void addMethodHook(String name, MethodHook methodHook) {
        mMethodHookMap.put(name, methodHook);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        MethodHook methodHook = mMethodHookMap.get(method.getName());
        if (methodHook == null || !methodHook.isEnable()) {
            try {
                //Slog.e(TAG, mBase.getClass().getName() + ", " + method.getName());
                return method.invoke(mBase, args);
            } catch (Throwable e) {
                throw Objects.requireNonNull(e.getCause());
            }
        }

        Object result = methodHook.beforeHook(mBase, method, args);
        if (result != null) {
            return result;
        }

        result = methodHook.hook(mBase, method, args);
        result = methodHook.afterHook(result);
        return result;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/hook/HookManager.java`:

```java
package com.vcore.fake.hook;

import android.util.Log;

import java.util.HashMap;
import java.util.Map;

import black.oem.flyme.IFlymePermissionService;
import black.oem.vivo.IPhysicalFlingManager;
import black.oem.vivo.IPopupCameraManager;
import black.oem.vivo.ISuperResolutionManager;
import black.oem.vivo.ISystemDefenceManager;
import black.oem.vivo.IVivoPermissonService;
import com.vcore.BlackBoxCore;
import com.vcore.fake.delegate.AppInstrumentation;
import com.vcore.fake.service.BuildProxy;
import com.vcore.fake.service.HCallbackProxy;
import com.vcore.fake.service.IAccessibilityManagerProxy;
import com.vcore.fake.service.IAccountManagerProxy;
import com.vcore.fake.service.IActivityClientProxy;
import com.vcore.fake.service.IActivityManagerProxy;
import com.vcore.fake.service.IActivityTaskManagerProxy;
import com.vcore.fake.service.IAlarmManagerProxy;
import com.vcore.fake.service.IAppOpsManagerProxy;
import com.vcore.fake.service.IAppWidgetManagerProxy;
import com.vcore.fake.service.IAutofillManagerProxy;
import com.vcore.fake.service.IBluetoothManagerProxy;
import com.vcore.fake.service.IConnectivityManagerProxy;
import com.vcore.fake.service.IContextHubServiceProxy;
import com.vcore.fake.service.IDeviceIdentifiersPolicyProxy;
import com.vcore.fake.service.IDevicePolicyManagerProxy;
import com.vcore.fake.service.IDisplayManagerProxy;
import com.vcore.fake.service.IFingerprintManagerProxy;
import com.vcore.fake.service.IFlymePermissionServiceProxy;
import com.vcore.fake.service.IGraphicsStatsProxy;
import com.vcore.fake.service.IJobServiceProxy;
import com.vcore.fake.service.ILauncherAppsProxy;
import com.vcore.fake.service.ILocationManagerProxy;
import com.vcore.fake.service.IMediaRouterServiceProxy;
import com.vcore.fake.service.IMediaSessionManagerProxy;
import com.vcore.fake.service.INetworkManagementServiceProxy;
import com.vcore.fake.service.INotificationManagerProxy;
import com.vcore.fake.service.IPackageManagerProxy;
import com.vcore.fake.service.IPermissionManagerProxy;
import com.vcore.fake.service.IPersistentDataBlockServiceProxy;
import com.vcore.fake.service.IPhoneSubInfoProxy;
import com.vcore.fake.service.IPhysicalFlingManagerProxy;
import com.vcore.fake.service.IPopupCameraManagerProxy;
import com.vcore.fake.service.IPowerManagerProxy;
import com.vcore.fake.service.IRoleManagerProxy;
import com.vcore.fake.service.ISearchManagerProxy;
import com.vcore.fake.service.IShortcutManagerProxy;
import com.vcore.fake.service.IStorageManagerProxy;
import com.vcore.fake.service.IStorageStatsManagerProxy;
import com.vcore.fake.service.ISubProxy;
import com.vcore.fake.service.ISuperResolutionManagerProxy;
import com.vcore.fake.service.ISystemDefenceManagerProxy;
import com.vcore.fake.service.ISystemUpdateProxy;
import com.vcore.fake.service.ITelephonyManagerProxy;
import com.vcore.fake.service.ITelephonyRegistryProxy;
import com.vcore.fake.service.IUserManagerProxy;
import com.vcore.fake.service.IVibratorServiceProxy;
import com.vcore.fake.service.IVivoPermissionServiceProxy;
import com.vcore.fake.service.IVpnManagerProxy;
import com.vcore.fake.service.IWifiManagerProxy;
import com.vcore.fake.service.IWifiScannerProxy;
import com.vcore.fake.service.IWindowManagerProxy;
import com.vcore.fake.service.context.ContentServiceProxy;
import com.vcore.fake.service.context.RestrictionsManagerProxy;
import com.vcore.fake.service.libcore.OsProxy;
import com.vcore.utils.Slog;
import com.vcore.utils.compat.BuildCompat;

public class HookManager {
    public static final String TAG = "HookManager";

    private static final HookManager sHookManager = new HookManager();
    private final Map<Class<?>, IInjectHook> mInjectors = new HashMap<>();

    public static HookManager get() {
        return sHookManager;
    }

    public void init() {
        if (BlackBoxCore.get().isBlackProcess() || BlackBoxCore.get().isServerProcess()) {
            addInjector(new IDisplayManagerProxy());
            addInjector(new OsProxy());

            addInjector(new ILocationManagerProxy());
            // AM and PM hook
            addInjector(new IActivityManagerProxy());
            addInjector(new IPackageManagerProxy());
            addInjector(new ITelephonyManagerProxy());
            addInjector(new HCallbackProxy());

            /*
             * It takes time to test and enhance the compatibility of WifiManager
             * (only tested in Android 10).
             * commented by BlackBoxing at 2022/03/08
             * */
            addInjector(new IWifiManagerProxy());
            addInjector(new IWifiScannerProxy());
            addInjector(new IBluetoothManagerProxy());

            addInjector(new ISubProxy());
            addInjector(new IAppOpsManagerProxy());
            addInjector(new INotificationManagerProxy());
            addInjector(new IAlarmManagerProxy());
            addInjector(new IAppWidgetManagerProxy());
            addInjector(new ContentServiceProxy());
            addInjector(new IWindowManagerProxy());
            addInjector(new IUserManagerProxy());
            addInjector(new RestrictionsManagerProxy());
            addInjector(new IMediaSessionManagerProxy());
            addInjector(new IStorageManagerProxy());
            addInjector(new ILauncherAppsProxy());
            addInjector(new IJobServiceProxy());
            addInjector(new IAccessibilityManagerProxy());
            addInjector(new ITelephonyRegistryProxy());
            addInjector(new IDevicePolicyManagerProxy());
            addInjector(new IAccountManagerProxy());
            addInjector(new ISearchManagerProxy());
            addInjector(new IConnectivityManagerProxy());
            addInjector(new IPhoneSubInfoProxy());
            addInjector(new IMediaRouterServiceProxy());
            addInjector(new IPowerManagerProxy());
            addInjector(new IVibratorServiceProxy());
            addInjector(new IPersistentDataBlockServiceProxy());
            addInjector(AppInstrumentation.get());

            addInjector(new BuildProxy());
            // 12.0
            if (BuildCompat.isS()) {
                addInjector(new IActivityClientProxy(null));
                addInjector(new IVpnManagerProxy());
            }
            // 11.0
            if (BuildCompat.isR()) {
                addInjector(new IPermissionManagerProxy());
            }
            // 10.0
            if (BuildCompat.isQ()) {
                addInjector(new IDeviceIdentifiersPolicyProxy());
                addInjector(new IRoleManagerProxy());
                addInjector(new IActivityTaskManagerProxy());
            }
            // 9.0
            if (BuildCompat.isPie()) {
                addInjector(new ISystemUpdateProxy());
            }
            //fix flyme service
            if (IFlymePermissionService.TYPE != null) {
                addInjector(new IFlymePermissionServiceProxy());
            }
            // 8.0
            if (BuildCompat.isOreo()) {
                addInjector(new IAutofillManagerProxy());
                addInjector(new IStorageStatsManagerProxy());
            }
            // 7.0
            if (BuildCompat.isN()) {
                addInjector(new IContextHubServiceProxy());
                addInjector(new INetworkManagementServiceProxy());
                addInjector(new IShortcutManagerProxy());
            }
            // 6.0
            if (BuildCompat.isM()) {
                addInjector(new IFingerprintManagerProxy());
                addInjector(new IGraphicsStatsProxy());
            }
            // 5.0
            if (BuildCompat.isL()) {
                addInjector(new IJobServiceProxy());
            }
            if (IPhysicalFlingManager.TYPE != null) {
                addInjector(new IPhysicalFlingManagerProxy());
            }
            if (IPopupCameraManager.TYPE != null) {
                addInjector(new IPopupCameraManagerProxy());
            }
            if (ISuperResolutionManager.TYPE != null) {
                addInjector(new ISuperResolutionManagerProxy());
            }
            if (ISystemDefenceManager.TYPE != null) {
                addInjector(new ISystemDefenceManagerProxy());
            }
            if (IVivoPermissonService.TYPE != null) {
                addInjector(new IVivoPermissionServiceProxy());
            }
        }
        injectAll();
    }

    public void checkEnv(Class<?> clazz) {
        IInjectHook iInjectHook = mInjectors.get(clazz);
        if (iInjectHook != null && iInjectHook.isBadEnv()) {
            Log.d(TAG, "checkEnv: " + clazz.getSimpleName() + " is bad env");
            iInjectHook.injectHook();
        }
    }

    void addInjector(IInjectHook injectHook) {
        mInjectors.put(injectHook.getClass(), injectHook);
    }

    void injectAll() {
        for (IInjectHook value : mInjectors.values()) {
            try {
                Slog.d(TAG, "hook: " + value);
                value.injectHook();
            } catch (Exception e) {
                Slog.d(TAG, "hook error: " + value + " " + e.getMessage());
            }
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/hook/IInjectHook.java`:

```java
package com.vcore.fake.hook;

public interface IInjectHook {
    void injectHook();

    boolean isBadEnv();
}

```

`Bcore/src/main/java/com/vcore/fake/hook/MethodHook.java`:

```java
package com.vcore.fake.hook;

import java.lang.reflect.Method;

import com.vcore.BlackBoxCore;

public abstract class MethodHook {
    protected String getMethodName() {
        return null;
    }

    protected Object afterHook(Object result) {
        return result;
    }

    protected Object beforeHook(Object who, Method method, Object[] args) throws Throwable {
        return null;
    }

    protected abstract Object hook(Object who, Method method, Object[] args) throws Throwable;

    protected boolean isEnable() {
        return BlackBoxCore.get().isBlackProcess();
    }
}

```

`Bcore/src/main/java/com/vcore/fake/hook/ProxyMethod.java`:

```java
package com.vcore.fake.hook;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ProxyMethod {
    String value();
}

```

`Bcore/src/main/java/com/vcore/fake/hook/ProxyMethods.java`:

```java
package com.vcore.fake.hook;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ProxyMethods {
    String[] value() default {};
}

```

`Bcore/src/main/java/com/vcore/fake/hook/ScanClass.java`:

```java
package com.vcore.fake.hook;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ScanClass {
    Class<?>[] value() default {};
}
```

`Bcore/src/main/java/com/vcore/fake/provider/FileProvider.java`:

```java
package com.vcore.fake.provider;

import static org.xmlpull.v1.XmlPullParser.END_DOCUMENT;
import static org.xmlpull.v1.XmlPullParser.START_TAG;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ProviderInfo;
import android.content.res.XmlResourceParser;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.os.ParcelFileDescriptor;
import android.provider.OpenableColumns;
import android.text.TextUtils;
import android.webkit.MimeTypeMap;

import androidx.core.content.ContextCompat;

import org.xmlpull.v1.XmlPullParserException;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class FileProvider extends ContentProvider {
    private static final String[] COLUMNS = {
            OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE
    };

    private static final String META_DATA_FILE_PROVIDER_PATHS = "android.support.FILE_PROVIDER_PATHS";

    private static final String TAG_ROOT_PATH = "root-path";
    private static final String TAG_FILES_PATH = "files-path";
    private static final String TAG_CACHE_PATH = "cache-path";
    private static final String TAG_EXTERNAL = "external-path";
    private static final String TAG_EXTERNAL_FILES = "external-files-path";
    private static final String TAG_EXTERNAL_CACHE = "external-cache-path";
    private static final String TAG_EXTERNAL_MEDIA = "external-media-path";

    private static final String ATTR_NAME = "name";
    private static final String ATTR_PATH = "path";

    private static final File DEVICE_ROOT = new File("/");

    private static final HashMap<String, PathStrategy> sCache = new HashMap<>();

    private PathStrategy mStrategy;

    /**
     * The default FileProvider implementation does not need to be initialized. If you want to
     * override this method, you must provide your own subclass of 
     */
    @Override
    public boolean onCreate() {
        return true;
    }

    /**
     * After the FileProvider is instantiated, this method is called to provide the system with
     * information about the provider.
     *
     * @param context A {@link Context} for the current component.
     * @param info A {@link ProviderInfo} for the new provider.
     */
    @Override
    public void attachInfo(Context context, ProviderInfo info) {
        super.attachInfo(context, info);

        // Sanity check our security
        if (info.exported) {
            throw new SecurityException("Provider must not be exported");
        }
        if (!info.grantUriPermissions) {
            throw new SecurityException("Provider must grant uri permissions");
        }
        mStrategy = getPathStrategy(context, info.authority);
    }

    /**
     * Return a content URI for a given {@link File}. Specific temporary
     * permissions for the content URI can be set with
     * {@link Context#grantUriPermission(String, Uri, int)}, or added
     * to an {@link Intent} by calling {@link Intent#setData(Uri) setData()} and then
     * {@link Intent#setFlags(int) setFlags()}; in both cases, the applicable flags are
     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and
     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}. A FileProvider can only return a
     * <code>content</code> {@link Uri} for file paths defined in their <code>&lt;paths&gt;</code>
     * meta-data element. See the Class Overview for more information.
     *
     * @param context A {@link Context} for the current component.
     * @param authority The authority of a {@link FileProvider} defined in a
     *            {@code <provider>} element in your app's manifest.
     * @param file A {@link File} pointing to the filename for which you want a
     * <code>content</code> {@link Uri}.
     * @return A content URI for the file.
     * @throws IllegalArgumentException When the given {@link File} is outside
     * the paths supported by the provider.
     */
    public static Uri getUriForFile(Context context, String authority, File file) {
        final PathStrategy strategy = getPathStrategy(context, authority);
        return strategy.getUriForFile(file);
    }

    public static File getFileForUri(Context context, String authority, Uri uri) {
        final PathStrategy strategy = getPathStrategy(context, authority);
        return strategy.getFileForUri(uri);
    }

    /**
     * Use a content URI returned by
     * {@link #getUriForFile(Context, String, File) getUriForFile()} to get information about a file
     * managed by the 
     * FileProvider reports the column names defined in {@link android.provider.OpenableColumns}:
     * <ul>
     * <li>{@link android.provider.OpenableColumns#DISPLAY_NAME}</li>
     * <li>{@link android.provider.OpenableColumns#SIZE}</li>
     * </ul>
     * For more information, see
     * {@link ContentProvider#query(Uri, String[], String, String[], String)
     * ContentProvider.query()}.
     *
     * @param uri A content URI returned by {@link #getUriForFile}.
     * @param projection The list of columns to put into the {@link Cursor}. If null all columns are
     * included.
     * @param selection Selection criteria to apply. If null then all data that matches the content
     * URI is returned.
     * @param selectionArgs An array of {@link java.lang.String}, containing arguments to bind to
     * the <i>selection</i> parameter. The <i>query</i> method scans <i>selection</i> from left to
     * right and iterates through <i>selectionArgs</i>, replacing the current "?" character in
     * <i>selection</i> with the value at the current position in <i>selectionArgs</i>. The
     * values are bound to <i>selection</i> as {@link java.lang.String} values.
     * @param sortOrder A {@link java.lang.String} containing the column name(s) on which to sort
     * the resulting {@link Cursor}.
     * @return A {@link Cursor} containing the results of the query.
     *
     */
    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
        // ContentProvider has already checked granted permissions
        final File file = mStrategy.getFileForUri(uri);

        if (projection == null) {
            projection = COLUMNS;
        }

        String[] cols = new String[projection.length];
        Object[] values = new Object[projection.length];
        int i = 0;
        for (String col : projection) {
            if (OpenableColumns.DISPLAY_NAME.equals(col)) {
                cols[i] = OpenableColumns.DISPLAY_NAME;
                values[i++] = file.getName();
            } else if (OpenableColumns.SIZE.equals(col)) {
                cols[i] = OpenableColumns.SIZE;
                values[i++] = file.length();
            }
        }

        cols = copyOf(cols, i);
        values = copyOf(values, i);

        final MatrixCursor cursor = new MatrixCursor(cols, 1);
        cursor.addRow(values);
        return cursor;
    }

    /**
     * Returns the MIME type of a content URI returned by
     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
     *
     * @param uri A content URI returned by
     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
     * @return If the associated file has an extension, the MIME type associated with that
     * extension; otherwise <code>application/octet-stream</code>.
     */
    @Override
    public String getType(Uri uri) {
        // ContentProvider has already checked granted permissions
        final File file = mStrategy.getFileForUri(uri);

        final int lastDot = file.getName().lastIndexOf('.');
        if (lastDot >= 0) {
            final String extension = file.getName().substring(lastDot + 1);
            final String mime = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
            if (mime != null) {
                return mime;
            }
        }
        return "application/octet-stream";
    }

    /**
     * By default, this method throws an {@link java.lang.UnsupportedOperationException}. You must
     * subclass FileProvider if you want to provide different functionality.
     */
    @Override
    public Uri insert(Uri uri, ContentValues values) {
        throw new UnsupportedOperationException("No external inserts");
    }

    /**
     * By default, this method throws an {@link java.lang.UnsupportedOperationException}. You must
     * subclass FileProvider if you want to provide different functionality.
     */
    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        throw new UnsupportedOperationException("No external updates");
    }

    /**
     * Deletes the file associated with the specified content URI, as
     * returned by {@link #getUriForFile(Context, String, File) getUriForFile()}. Notice that this
     * method does <b>not</b> throw an {@link java.io.IOException}; you must check its return value.
     *
     * @param uri A content URI for a file, as returned by
     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
     * @param selection Ignored. Set to {@code null}.
     * @param selectionArgs Ignored. Set to {@code null}.
     * @return 1 if the delete succeeds; otherwise, 0.
     */
    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        // ContentProvider has already checked granted permissions
        final File file = mStrategy.getFileForUri(uri);
        return file.delete() ? 1 : 0;
    }

    /**
     * By default, FileProvider automatically returns the
     * {@link ParcelFileDescriptor} for a file associated with a <code>content://</code>
     * {@link Uri}. To get the {@link ParcelFileDescriptor}, call
     * {@link android.content.ContentResolver#openFileDescriptor(Uri, String)
     * ContentResolver.openFileDescriptor}.
     *
     * To override this method, you must provide your own subclass of 
     *
     * @param uri A content URI associated with a file, as returned by
     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
     * @param mode Access mode for the file. May be "r" for read-only access, "rw" for read and
     * write access, or "rwt" for read and write access that truncates any existing file.
     * @return A new {@link ParcelFileDescriptor} with which you can access the file.
     */
    @Override
    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
        // ContentProvider has already checked granted permissions
        final File file = mStrategy.getFileForUri(uri);
        final int fileMode = modeToMode(mode);
        return ParcelFileDescriptor.open(file, fileMode);
    }

    /**
     * Return {@link PathStrategy} for given authority, either by parsing or
     * returning from cache.
     */
    private static PathStrategy getPathStrategy(Context context, String authority) {
        PathStrategy strat;
        synchronized (sCache) {
            strat = sCache.get(authority);
            if (strat == null) {
                try {
                    strat = parsePathStrategy(context, authority);
                } catch (IOException | XmlPullParserException e) {
                    throw new IllegalArgumentException("Failed to parse " + META_DATA_FILE_PROVIDER_PATHS + " meta-data", e);
                }
                sCache.put(authority, strat);
            }
        }
        return strat;
    }

    /**
     * Parse and return {@link PathStrategy} for given authority as defined in
     * {@link #META_DATA_FILE_PROVIDER_PATHS} {@code <meta-data>}.
     *
     * @see #getPathStrategy(Context, String)
     */
    private static PathStrategy parsePathStrategy(Context context, String authority)
            throws IOException, XmlPullParserException {
        final SimplePathStrategy simplePathStrategy = new SimplePathStrategy(authority);

        final ProviderInfo info = context.getPackageManager()
                .resolveContentProvider(authority, PackageManager.GET_META_DATA);
        if (info == null) {
            throw new IllegalArgumentException("Couldn't find meta-data for provider with authority " + authority);
        }

        final XmlResourceParser in = info.loadXmlMetaData(context.getPackageManager(), META_DATA_FILE_PROVIDER_PATHS);
        if (in == null) {
            throw new IllegalArgumentException("Missing " + META_DATA_FILE_PROVIDER_PATHS + " meta-data");
        }

        int type;
        while ((type = in.next()) != END_DOCUMENT) {
            if (type == START_TAG) {
                final String tag = in.getName();

                final String name = in.getAttributeValue(null, ATTR_NAME);
                String path = in.getAttributeValue(null, ATTR_PATH);

                File target = null;
                if (TAG_ROOT_PATH.equals(tag)) {
                    target = DEVICE_ROOT;
                } else if (TAG_FILES_PATH.equals(tag)) {
                    target = context.getFilesDir();
                } else if (TAG_CACHE_PATH.equals(tag)) {
                    target = context.getCacheDir();
                } else if (TAG_EXTERNAL.equals(tag)) {
                    target = Environment.getExternalStorageDirectory();
                } else if (TAG_EXTERNAL_FILES.equals(tag)) {
                    File[] externalFilesDirs = ContextCompat.getExternalFilesDirs(context, null);
                    if (externalFilesDirs.length > 0) {
                        target = externalFilesDirs[0];
                    }
                } else if (TAG_EXTERNAL_CACHE.equals(tag)) {
                    File[] externalCacheDirs = ContextCompat.getExternalCacheDirs(context);
                    if (externalCacheDirs.length > 0) {
                        target = externalCacheDirs[0];
                    }
                } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP
                        && TAG_EXTERNAL_MEDIA.equals(tag)) {
                    File[] externalMediaDirs = context.getExternalMediaDirs();
                    if (externalMediaDirs.length > 0) {
                        target = externalMediaDirs[0];
                    }
                }

                if (target != null) {
                    simplePathStrategy.addRoot(name, buildPath(target, path));
                }
            }
        }
        return simplePathStrategy;
    }

    /**
     * Strategy for mapping between {@link File} and {@link Uri}.
     * <p>
     * Strategies must be symmetric so that mapping a {@link File} to a
     * {@link Uri} and then back to a {@link File} points at the original
     * target.
     * <p>
     * Strategies must remain consistent across app launches, and not rely on
     * dynamic state. This ensures that any generated {@link Uri} can still be
     * resolved if your process is killed and later restarted.
     *
     * @see SimplePathStrategy
     */
    interface PathStrategy {
        /**
         * Return a {@link Uri} that represents the given {@link File}.
         */
        Uri getUriForFile(File file);

        /**
         * Return a {@link File} that represents the given {@link Uri}.
         */
        File getFileForUri(Uri uri);
    }

    /**
     * Strategy that provides access to files living under a narrow whitelist of
     * filesystem roots. It will throw {@link SecurityException} if callers try
     * accessing files outside the configured roots.
     * <p>
     * For example, if configured with
     * {@code addRoot("myfiles", context.getFilesDir())}, then
     * {@code context.getFileStreamPath("foo.txt")} would map to
     * {@code content://myauthority/myfiles/foo.txt}.
     */
    static class SimplePathStrategy implements PathStrategy {
        private final String mAuthority;
        private final HashMap<String, File> mRoots = new HashMap<>();

        SimplePathStrategy(String authority) {
            mAuthority = authority;
        }

        /**
         * Add a mapping from a name to a filesystem root. The provider only offers
         * access to files that live under configured roots.
         */
        void addRoot(String name, File root) {
            if (TextUtils.isEmpty(name)) {
                throw new IllegalArgumentException("Name must not be empty");
            }

            try {
                // Resolve to canonical path to keep path checking fast
                root = root.getCanonicalFile();
            } catch (IOException e) {
                throw new IllegalArgumentException(
                        "Failed to resolve canonical path for " + root, e);
            }
            mRoots.put(name, root);
        }

        @Override
        public Uri getUriForFile(File file) {
            String path;
            try {
                path = file.getCanonicalPath();
            } catch (IOException e) {
                throw new IllegalArgumentException("Failed to resolve canonical path for " + file);
            }

            // Find the most-specific root path
            Map.Entry<String, File> mostSpecific = null;
            for (Map.Entry<String, File> root : mRoots.entrySet()) {
                final String rootPath = root.getValue().getPath();
                if (path.startsWith(rootPath) && (mostSpecific == null || rootPath.length() > mostSpecific.getValue().getPath().length())) {
                    mostSpecific = root;
                }
            }

            if (mostSpecific == null) {
                throw new IllegalArgumentException("Failed to find configured root that contains " + path);
            }

            // Start at first char of path under root
            final String rootPath = mostSpecific.getValue().getPath();
            if (rootPath.endsWith("/")) {
                path = path.substring(rootPath.length());
            } else {
                path = path.substring(rootPath.length() + 1);
            }

            // Encode the tag and path separately
            path = Uri.encode(mostSpecific.getKey()) + '/' + Uri.encode(path, "/");
            return new Uri.Builder().scheme("content")
                    .authority(mAuthority).encodedPath(path).build();
        }

        @Override
        public File getFileForUri(Uri uri) {
            String path = uri.getEncodedPath();

            final int splitIndex = path.indexOf('/', 1);
            final String tag = Uri.decode(path.substring(1, splitIndex));
            path = Uri.decode(path.substring(splitIndex + 1));

            final File root = mRoots.get(tag);
            if (root == null) {
                throw new IllegalArgumentException("Unable to find configured root for " + uri);
            }

            File file = new File(root, path);
            try {
                file = file.getCanonicalFile();
            } catch (IOException e) {
                throw new IllegalArgumentException("Failed to resolve canonical path for " + file);
            }

            if (!file.getPath().startsWith(root.getPath())) {
                throw new SecurityException("Resolved path jumped beyond configured root");
            }
            return file;
        }
    }

    /**
     * Copied from ContentResolver.java
     */
    private static int modeToMode(String mode) {
        int modeBits;
        if ("r".equals(mode)) {
            modeBits = ParcelFileDescriptor.MODE_READ_ONLY;
        } else if ("w".equals(mode) || "wt".equals(mode)) {
            modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY
                    | ParcelFileDescriptor.MODE_CREATE
                    | ParcelFileDescriptor.MODE_TRUNCATE;
        } else if ("wa".equals(mode)) {
            modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY
                    | ParcelFileDescriptor.MODE_CREATE
                    | ParcelFileDescriptor.MODE_APPEND;
        } else if ("rw".equals(mode)) {
            modeBits = ParcelFileDescriptor.MODE_READ_WRITE
                    | ParcelFileDescriptor.MODE_CREATE;
        } else if ("rwt".equals(mode)) {
            modeBits = ParcelFileDescriptor.MODE_READ_WRITE
                    | ParcelFileDescriptor.MODE_CREATE
                    | ParcelFileDescriptor.MODE_TRUNCATE;
        } else {
            throw new IllegalArgumentException("Invalid mode: " + mode);
        }
        return modeBits;
    }

    private static File buildPath(File base, String... segments) {
        File cur = base;
        for (String segment : segments) {
            if (segment != null) {
                cur = new File(cur, segment);
            }
        }
        return cur;
    }

    private static String[] copyOf(String[] original, int newLength) {
        final String[] result = new String[newLength];
        System.arraycopy(original, 0, result, 0, newLength);
        return result;
    }

    private static Object[] copyOf(Object[] original, int newLength) {
        final Object[] result = new Object[newLength];
        System.arraycopy(original, 0, result, 0, newLength);
        return result;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/provider/FileProviderHandler.java`:

```java
package com.vcore.fake.provider;

import android.content.Context;
import android.content.pm.ProviderInfo;
import android.net.Uri;

import java.io.File;
import java.util.List;

import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.utils.compat.BuildCompat;

public class FileProviderHandler {
    public static Uri convertFileUri(Context context, Uri uri) {
        if (BuildCompat.isN()) {
            File file = convertFile(context, uri);
            if (file == null) {
                return null;
            }
            return BlackBoxCore.getBStorageManager().getUriForFile(file.getAbsolutePath());
        }
        return uri;
    }

    public static File convertFile(Context context, Uri uri) {
        List<ProviderInfo> providers = BActivityThread.getProviders();
        for (ProviderInfo provider : providers) {
            try {
                File fileForUri = FileProvider.getFileForUri(context, provider.authority, uri);
                if (fileForUri != null && fileForUri.exists()) {
                    return fileForUri;
                }
            } catch (Exception ignored) { }
        }
        return null;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/ActivityManagerCommonProxy.java`:

```java
package com.vcore.fake.service;

import static android.content.pm.PackageManager.GET_META_DATA;

import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.ResolveInfo;
import android.net.Uri;
import android.os.Bundle;
import android.os.IBinder;

import java.io.File;
import java.lang.reflect.Method;

import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.fake.provider.FileProviderHandler;
import com.vcore.utils.ComponentUtils;
import com.vcore.utils.MethodParameterUtils;
import com.vcore.utils.Slog;
import com.vcore.utils.compat.BuildCompat;

public class ActivityManagerCommonProxy {
    public static final String TAG = "ActivityManagerCommonProxy";

    @ProxyMethod("startActivity")
    public static class StartActivity extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceFirstAppPkg(args);
            Intent intent = getIntent(args);

            Slog.d(TAG, "Hook in : " + intent);
            assert intent != null;
            if (intent.getParcelableExtra("_B_|_target_") != null) {
                return method.invoke(who, args);
            }

            if (ComponentUtils.isRequestInstall(intent)) {
                File file = FileProviderHandler.convertFile(BActivityThread.getApplication(), intent.getData());
                if (BlackBoxCore.get().requestInstallPackage(file, BActivityThread.getUserId())) {
                    return 0;
                }

                intent.setData(FileProviderHandler.convertFileUri(BActivityThread.getApplication(), intent.getData()));
                return method.invoke(who, args);
            }

            String dataString = intent.getDataString();
            if (dataString != null && dataString.equals("package:" + BActivityThread.getAppPackageName())) {
                intent.setData(Uri.parse("package:" + BlackBoxCore.getHostPkg()));
            }

            ResolveInfo resolveInfo = BlackBoxCore.getBPackageManager().resolveActivity(intent, GET_META_DATA, getResolvedType(args),
                    BActivityThread.getUserId());
            if (resolveInfo == null) {
                String origPackage = intent.getPackage();
                if (intent.getPackage() == null && intent.getComponent() == null) {
                    intent.setPackage(BActivityThread.getAppPackageName());
                } else {
                    origPackage = intent.getPackage();
                }

                resolveInfo = BlackBoxCore.getBPackageManager().resolveActivity(intent, GET_META_DATA, getResolvedType(args),
                        BActivityThread.getUserId());
                if (resolveInfo == null) {
                    intent.setPackage(origPackage);
                    return method.invoke(who, args);
                }
            }

            intent.setExtrasClassLoader(who.getClass().getClassLoader());
            intent.setComponent(new ComponentName(resolveInfo.activityInfo.packageName, resolveInfo.activityInfo.name));
            BlackBoxCore.getBActivityManager().startActivityAms(BActivityThread.getUserId(), getIntent(args),
                    getResolvedType(args), getResultTo(args), getResultWho(args),
                    getRequestCode(args), getFlags(args), getOptions(args));
            return 0;
        }

        private Intent getIntent(Object[] args) {
            int index;
            if (BuildCompat.isR()) {
                index = 3;
            } else {
                index = 2;
            }

            if (args[index] instanceof Intent) {
                return (Intent) args[index];
            }

            for (Object arg : args) {
                if (arg instanceof Intent) {
                    return (Intent) arg;
                }
            }
            return null;
        }

        private String getResolvedType(Object[] args) {
            int index;
            if (BuildCompat.isR()) {
                index = 4;
            } else {
                index = 3;
            }

            if (args[index] instanceof String) {
                return (String) args[index];
            }

            for (Object arg : args) {
                if (arg instanceof String) {
                    return (String) arg;
                }
            }
            return null;
        }

        private IBinder getResultTo(Object[] args) {
            int index;
            if (BuildCompat.isR()) {
                index = 5;
            } else {
                index = 4;
            }

            if (args[index] instanceof IBinder) {
                return (IBinder) args[index];
            }

            for (Object arg : args) {
                if (arg instanceof IBinder) {
                    return (IBinder) arg;
                }
            }
            return null;
        }

        private String getResultWho(Object[] args) {
            int index;
            if (BuildCompat.isR()) {
                index = 6;
            } else {
                index = 5;
            }

            if (args[index] instanceof String) {
                return (String) args[index];
            }

            for (Object arg : args) {
                if (arg instanceof String) {
                    return (String) arg;
                }
            }
            return null;
        }

        private int getRequestCode(Object[] args) {
            int index;
            if (BuildCompat.isR()) {
                index = 7;
            } else {
                index = 6;
            }

            if (args[index] instanceof Integer) {
                return (Integer) args[index];
            }

            for (Object arg : args) {
                if (arg instanceof Integer) {
                    return (Integer) arg;
                }
            }
            return 0;
        }

        private int getFlags(Object[] args) {
            int index;
            if (BuildCompat.isR()) {
                index = 8;
            } else {
                index = 7;
            }

            if (args[index] instanceof Integer) {
                return (Integer) args[index];
            }

            for (Object arg : args) {
                if (arg instanceof Integer) {
                    return (Integer) arg;
                }
            }
            return 0;
        }

        private Bundle getOptions(Object[] args) {
            int index;
            if (BuildCompat.isR()) {
                index = 9;
            } else {
                index = 8;
            }

            if (args[index] instanceof Bundle) {
                return (Bundle) args[index];
            }

            for (Object arg : args) {
                if (arg instanceof Bundle) {
                    return (Bundle) arg;
                }
            }
            return null;
        }
    }

    @ProxyMethod("startActivities")
    public static class StartActivities extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            int index = getIntents();
            Intent[] intents = (Intent[]) args[index++];
            String[] resolvedTypes = (String[]) args[index++];
            IBinder resultTo = (IBinder) args[index++];
            Bundle options = (Bundle) args[index];

            if (!ComponentUtils.isSelf(intents)) {
                return method.invoke(who, args);
            }

            for (Intent intent : intents) {
                intent.setExtrasClassLoader(who.getClass().getClassLoader());
            }
            return BlackBoxCore.getBActivityManager().startActivities(BActivityThread.getUserId(), intents, resolvedTypes, resultTo, options);
        }

        public int getIntents() {
            return 2;
        }
    }

    @ProxyMethod("activityResumed")
    public static class ActivityResumed extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BlackBoxCore.getBActivityManager().onActivityResumed((IBinder) args[0]);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("activityDestroyed")
    public static class ActivityDestroyed extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BlackBoxCore.getBActivityManager().onActivityDestroyed((IBinder) args[0]);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("finishActivity")
    public static class FinishActivity extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BlackBoxCore.getBActivityManager().onFinishActivity((IBinder) args[0]);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getAppTasks")
    public static class GetAppTasks extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceFirstAppPkg(args);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getCallingPackage")
    public static class GetCallingPackage extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BlackBoxCore.getBActivityManager().getCallingPackage((IBinder) args[0], BActivityThread.getUserId());
        }
    }

    @ProxyMethod("getCallingActivity")
    public static class GetCallingActivity extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BlackBoxCore.getBActivityManager().getCallingActivity((IBinder) args[0], BActivityThread.getUserId());
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/BuildProxy.java`:

```java
package com.vcore.fake.service;

import black.android.os.Build;
import com.vcore.fake.hook.ClassInvocationStub;

public class BuildProxy extends ClassInvocationStub {

    @Override
    protected Object getWho() {
        return Build.REF;
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        Build.BOARD.set("umi");
        Build.BRAND.set("Xiaomi");
        Build.DEVICE.set("umi");
        Build.DISPLAY.set("QKQ1.191117.002 test-keys");
        Build.HOST.set("c5-miui-ota-bd074.bj");
        Build.ID.set("QKQ1.191117.002");
        Build.MANUFACTURER.set("Xiaomi");
        Build.MODEL.set("Mi 10");
        Build.PRODUCT.set("umi");
        Build.TAGS.set("release-keys");
        Build.TYPE.set("user");
        Build.USER.set("builder");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/HCallbackProxy.java`:

```java
package com.vcore.fake.service;

import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.ServiceInfo;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;

import androidx.annotation.NonNull;

import java.lang.reflect.Proxy;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import black.android.app.ActivityClient;
import black.android.app.ActivityManagerNative;
import black.android.app.ActivityThread;
import black.android.app.IActivityManager;
import black.android.app.servertransaction.ClientTransaction;
import black.android.app.servertransaction.LaunchActivityItem;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.fake.hook.IInjectHook;
import com.vcore.proxy.ProxyManifest;
import com.vcore.proxy.record.ProxyActivityRecord;
import com.vcore.utils.Slog;
import com.vcore.utils.compat.BuildCompat;

public class HCallbackProxy implements IInjectHook, Handler.Callback {
    public static final String TAG = "HCallbackProxy";
    private Handler.Callback mOtherCallback;
    private final AtomicBoolean mBeing = new AtomicBoolean(false);

    private Handler.Callback getHCallback() {
        return black.android.os.Handler.mCallback.get(getH());
    }

    private Handler getH() {
        Object currentActivityThread = BlackBoxCore.mainThread();
        return ActivityThread.mH.get(currentActivityThread);
    }

    @Override
    public void injectHook() {
        mOtherCallback = getHCallback();
        if (mOtherCallback != null && (mOtherCallback == this || mOtherCallback.getClass().getName().equals(this.getClass().getName()))) {
            mOtherCallback = null;
        }
        black.android.os.Handler.mCallback.set(getH(), this);
    }

    @Override
    public boolean isBadEnv() {
        Handler.Callback hCallback = getHCallback();
        return hCallback != null && hCallback != this;
    }

    @Override
    public boolean handleMessage(@NonNull Message msg) {
        if (!mBeing.getAndSet(true)) {
            try {
                if (BuildCompat.isPie()) {
                    if (msg.what == ActivityThread.H.EXECUTE_TRANSACTION.get()) {
                        if (handleLaunchActivity(msg.obj)) {
                            getH().sendMessageAtFrontOfQueue(Message.obtain(msg));
                            return true;
                        }
                    }
                } else {
                    if (msg.what == ActivityThread.H.LAUNCH_ACTIVITY.get()) {
                        if (handleLaunchActivity(msg.obj)) {
                            getH().sendMessageAtFrontOfQueue(Message.obtain(msg));
                            return true;
                        }
                    }
                }

                if (msg.what == ActivityThread.H.CREATE_SERVICE.get()) {
                    return handleCreateService(msg.obj);
                }

                if (mOtherCallback != null) {
                    return mOtherCallback.handleMessage(msg);
                }
                return false;
            } finally {
                mBeing.set(false);
            }
        }
        return false;
    }

    private Object getLaunchActivityItem(Object clientTransaction) {
        List<Object> mActivityCallbacks = ClientTransaction.mActivityCallbacks.get(clientTransaction);

        for (Object obj : mActivityCallbacks) {
            if (LaunchActivityItem.REF.getClazz().getName().equals(obj.getClass().getCanonicalName())) {
                return obj;
            }
        }
        return null;
    }

    private boolean handleLaunchActivity(Object client) {
        Object r;
        if (BuildCompat.isPie()) {
            // ClientTransaction
            r = getLaunchActivityItem(client);
        } else {
            // ActivityClientRecord
            r = client;
        }

        if (r == null) {
            return false;
        }

        Intent intent;
        IBinder token;
        if (BuildCompat.isPie()) {
            intent = LaunchActivityItem.mIntent.get(r);
            token = ClientTransaction.mActivityToken.get(client);
        } else {
            intent = ActivityThread.ActivityClientRecord.intent.get(r);
            token = ActivityThread.ActivityClientRecord.token.get(r);
        }

        if (intent == null) {
            return false;
        }

        ProxyActivityRecord stubRecord = ProxyActivityRecord.create(intent);
        ActivityInfo activityInfo = stubRecord.mActivityInfo;
        if (activityInfo != null) {
            if (BActivityThread.getAppConfig() == null) {
                BlackBoxCore.getBActivityManager().restartProcess(activityInfo.packageName, activityInfo.processName, stubRecord.mUserId);

                Intent launchIntentForPackage = BlackBoxCore.getBPackageManager().getLaunchIntentForPackage(activityInfo.packageName, stubRecord.mUserId);
                intent.setExtrasClassLoader(this.getClass().getClassLoader());
                ProxyActivityRecord.saveStub(intent, launchIntentForPackage, stubRecord.mActivityInfo, stubRecord.mActivityToken, stubRecord.mUserId);
                if (BuildCompat.isPie()) {
                    LaunchActivityItem.mIntent.set(r, intent);
                    LaunchActivityItem.mInfo.set(r, activityInfo);
                } else {
                    ActivityThread.ActivityClientRecord.intent.set(r, intent);
                    ActivityThread.ActivityClientRecord.activityInfo.set(r, activityInfo);
                }
                return true;
            }

            if (!BActivityThread.currentActivityThread().isInit()) {
                BActivityThread.currentActivityThread().bindApplication(activityInfo.packageName, activityInfo.processName);
                return true;
            }

            int taskId = IActivityManager.getTaskForActivity.call(ActivityManagerNative.getDefault.call(), token, false);
            BlackBoxCore.getBActivityManager().onActivityCreated(taskId, token, stubRecord.mActivityToken);

            if (Build.VERSION.SDK_INT == Build.VERSION_CODES.S || (Build.VERSION.SDK_INT == Build.VERSION_CODES.R && Build.VERSION.PREVIEW_SDK_INT == 1)) {
                Object record = ActivityThread.getLaunchingActivity.call(BlackBoxCore.mainThread(), token);
                ActivityThread.ActivityClientRecord.intent.set(record, stubRecord.mTarget);
                ActivityThread.ActivityClientRecord.activityInfo.set(record, activityInfo);
                ActivityThread.ActivityClientRecord.packageInfo.set(record, BActivityThread.currentActivityThread().getPackageInfo());
                checkActivityClient();
            } else if (BuildCompat.isPie()) {
                LaunchActivityItem.mIntent.set(r, stubRecord.mTarget);
                LaunchActivityItem.mInfo.set(r, activityInfo);
            } else {
                ActivityThread.ActivityClientRecord.intent.set(r, stubRecord.mTarget);
                ActivityThread.ActivityClientRecord.activityInfo.set(r, activityInfo);
            }
        }
        return false;
    }

    private boolean handleCreateService(Object data) {
        if (BActivityThread.getAppConfig() != null) {
            String appPackageName = BActivityThread.getAppPackageName();
            assert appPackageName != null;

            ServiceInfo serviceInfo = ActivityThread.CreateServiceData.info.get(data);
            if (!serviceInfo.name.equals(ProxyManifest.getProxyService(BActivityThread.getAppPid()))
                    && !serviceInfo.name.equals(ProxyManifest.getProxyJobService(BActivityThread.getAppPid()))) {
                Slog.d(TAG, "handleCreateService: " + data);
                Intent intent = new Intent();
                intent.setComponent(new ComponentName(appPackageName, serviceInfo.name));
                BlackBoxCore.getBActivityManager().startService(intent, null, false, BActivityThread.getUserId());
                return true;
            }
        }
        return false;
    }

    private void checkActivityClient() {
        try {
            Object activityClientController = ActivityClient.getActivityClientController.call();
            if (!(activityClientController instanceof Proxy)) {
                IActivityClientProxy iActivityClientProxy = new IActivityClientProxy(activityClientController);
                iActivityClientProxy.onlyProxy(true);
                iActivityClientProxy.injectHook();

                Object instance = ActivityClient.getInstance.call();
                Object o = ActivityClient.INTERFACE_SINGLETON.get(instance);
                ActivityClient.ActivityClientControllerSingleton.mKnownInstance.set(o, iActivityClientProxy.getProxyInvocation());
            }
        } catch (Throwable t) {
            t.printStackTrace();
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IAccessibilityManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.content.pm.ApplicationInfo;

import java.lang.reflect.Method;

import black.android.os.ServiceManager;
import black.android.view.accessibility.IAccessibilityManager;
import com.vcore.BlackBoxCore;
import com.vcore.core.system.user.BUserHandle;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethods;

public class IAccessibilityManagerProxy extends BinderInvocationStub {
    public IAccessibilityManagerProxy() {
        super(ServiceManager.getService.call(Context.ACCESSIBILITY_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IAccessibilityManager.Stub.asInterface.call(ServiceManager.getService.call(Context.ACCESSIBILITY_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.ACCESSIBILITY_SERVICE);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @ProxyMethods({"interrupt", "sendAccessibilityEvent", "addClient", "removeClient", "getInstalledAccessibilityServiceList",
            "getEnabledAccessibilityServiceList", "addAccessibilityInteractionConnection", "getWindowToken", "setSystemAudioCaptioningEnabled",
            "isSystemAudioCaptioningUiEnabled", "setSystemAudioCaptioningUiEnabled"})
    public static class ReplaceUserId extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (args != null) {
                int index = args.length - 1;
                Object arg = args[index];

                if (arg instanceof Integer) {
                    ApplicationInfo applicationInfo = BlackBoxCore.getContext().getApplicationInfo();
                    args[index] = BUserHandle.getUserId(applicationInfo.uid);
                }
            }
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IAccountManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.accounts.Account;
import android.accounts.IAccountManagerResponse;
import android.content.Context;
import android.os.Bundle;

import java.lang.reflect.Method;
import java.util.Map;

import black.android.accounts.IAccountManager;
import black.android.os.ServiceManager;
import com.vcore.fake.frameworks.BAccountManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;

public class IAccountManagerProxy extends BinderInvocationStub {
    public static final String TAG = "IAccountManagerProxy";

    public IAccountManagerProxy() {
        super(ServiceManager.getService.call(Context.ACCOUNT_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IAccountManager.Stub.asInterface.call(ServiceManager.getService.call(Context.ACCOUNT_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.ACCOUNT_SERVICE);
    }



    @Override
    public boolean isBadEnv() {
        return false;
    }

    @ProxyMethod("getPassword")
    public static class GetPassword extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().getPassword((Account) args[0]);
        }
    }

    @ProxyMethod("getUserData")
    public static class GetUserData extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().getUserData((Account) args[0], (String) args[1]);
        }
    }

    @ProxyMethod("getAuthenticatorTypes")
    public static class GetAuthenticatorTypes extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().getAuthenticatorTypes();
        }
    }

    @ProxyMethod("getAccountsForPackage")
    public static class GetAccountsForPackage extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().getAccountsForPackage((String) args[0], (int) args[1]);
        }
    }

    @ProxyMethod("getAccountsByTypeForPackage")
    public static class GetAccountsByTypeForPackage extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().getAccountsByTypeForPackage((String) args[0], (String) args[1]);
        }
    }

    @ProxyMethod("getAccountByTypeAndFeatures")
    public static class GetAccountByTypeAndFeatures extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().getAccountByTypeAndFeatures((IAccountManagerResponse) args[0], (String) args[1], (String[]) args[2]);
            return 0;
        }
    }

    @ProxyMethod("getAccountsByFeatures")
    public static class GetAccountsByFeatures extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().getAccountsByFeatures((IAccountManagerResponse) args[0], (String) args[1], (String[]) args[2]);
            return 0;
        }
    }

    @ProxyMethod("getAccountsAsUser")
    public static class GetAccountsAsUser extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().getAccountsAsUser((String) args[0]);
        }
    }

    @ProxyMethod("addAccountExplicitly")
    public static class AddAccountExplicitly extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().addAccountExplicitly((Account) args[0], (String) args[1], (Bundle) args[2]);
        }
    }

    @ProxyMethod("removeAccountAsUser")
    public static class RemoveAccountAsUser extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().removeAccountAsUser((IAccountManagerResponse) args[0], (Account) args[1], (boolean) args[2]);
            return 0;
        }
    }

    @ProxyMethod("removeAccountExplicitly")
    public static class RemoveAccountExplicitly extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().removeAccountExplicitly((Account) args[0]);
        }
    }

    @ProxyMethod("copyAccountToUser")
    public static class CopyAccountToUser extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().copyAccountToUser((IAccountManagerResponse) args[0], (Account) args[1], (int) args[2], (int) args[3]);
            return 0;
        }
    }

    @ProxyMethod("invalidateAuthToken")
    public static class InvalidateAuthToken extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().invalidateAuthToken((String) args[0], (String) args[1]);
            return 0;
        }
    }

    @ProxyMethod("peekAuthToken")
    public static class PeekAuthToken extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().peekAuthToken((Account) args[0], (String) args[1]);
        }
    }

    @ProxyMethod("setAuthToken")
    public static class SetAuthToken extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().setAuthToken((Account) args[0], (String) args[1], (String) args[2]);
            return 0;
        }
    }

    @ProxyMethod("setPassword")
    public static class SetPassword extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().setPassword((Account) args[0], (String) args[1]);
            return 0;
        }
    }

    @ProxyMethod("clearPassword")
    public static class ClearPassword extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().clearPassword((Account) args[0]);
            return 0;
        }
    }

    @ProxyMethod("setUserData")
    public static class SetUserData extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().setUserData((Account) args[0], (String) args[1], (String) args[2]);
            return 0;
        }
    }

    @ProxyMethod("updateAppPermission")
    public static class UpdateAppPermission extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().updateAppPermission((Account) args[0], (String) args[1], (int) args[2], (boolean) args[3]);
            return 0;
        }
    }

    @ProxyMethod("getAuthToken")
    public static class GetAuthToken extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().getAuthToken((IAccountManagerResponse) args[0],
                    (Account) args[1],
                    (String) args[2],
                    (boolean) args[3],
                    (boolean) args[4],
                    (Bundle) args[5]);
            return 0;
        }
    }

    @ProxyMethod("addAccount")
    public static class AddAccount extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().addAccount((IAccountManagerResponse) args[0],
                    (String) args[1],
                    (String) args[2],
                    (String[]) args[3],
                    (boolean) args[4],
                    (Bundle) args[5]);
            return 0;
        }
    }

    @ProxyMethod("addAccountAsUser")
    public static class AddAccountAsUser extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().addAccountAsUser((IAccountManagerResponse) args[0],
                    (String) args[1],
                    (String) args[2],
                    (String[]) args[3],
                    (boolean) args[4],
                    (Bundle) args[5]);
            return 0;
        }
    }

    @ProxyMethod("updateCredentials")
    public static class UpdateCredentials extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().updateCredentials((IAccountManagerResponse) args[0],
                    (Account) args[1],
                    (String) args[2],
                    (boolean) args[3],
                    (Bundle) args[4]);
            return 0;
        }
    }

    @ProxyMethod("editProperties")
    public static class EditProperties extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().editProperties((IAccountManagerResponse) args[0],
                    (String) args[1],
                    (boolean) args[2]);
            return 0;
        }
    }

    @ProxyMethod("confirmCredentialsAsUser")
    public static class ConfirmCredentialsAsUser extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().confirmCredentialsAsUser((IAccountManagerResponse) args[0],
                    (Account) args[1],
                    (Bundle) args[2],
                    (boolean) args[3]);
            return 0;
        }
    }

    @ProxyMethod("accountAuthenticated")
    public static class AccountAuthenticated extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().accountAuthenticated((Account) args[0]);
            return 0;
        }
    }

    @ProxyMethod("getAuthTokenLabel")
    public static class GetAuthTokenLabel extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().getAuthTokenLabel((IAccountManagerResponse) args[0],
                    (String) args[1],
                    (String) args[2]);
            return 0;
        }
    }

    @ProxyMethod("getPackagesAndVisibilityForAccount")
    public static class GetPackagesAndVisibilityForAccount extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().getPackagesAndVisibilityForAccount((Account) args[0]);
        }
    }

    @ProxyMethod("addAccountExplicitlyWithVisibility")
    public static class AddAccountExplicitlyWithVisibility extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().addAccountExplicitlyWithVisibility((Account) args[0],
                    (String) args[1],
                    (Bundle) args[2],
                    (Map<?, ?>) args[3]
            );
        }
    }

    @ProxyMethod("setAccountVisibility")
    public static class SetAccountVisibility extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().setAccountVisibility((Account) args[0],
                    (String) args[1],
                    (int) args[2]
            );
        }
    }

    @ProxyMethod("getAccountVisibility")
    public static class GetAccountVisibility extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().getAccountVisibility((Account) args[0],
                    (String) args[1]
            );
        }
    }

    @ProxyMethod("getAccountsAndVisibilityForPackage")
    public static class GetAccountsAndVisibilityForPackage extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BAccountManager.get().getAccountsAndVisibilityForPackage((String) args[0],
                    (String) args[1]
            );
        }
    }

    @ProxyMethod("registerAccountListener")
    public static class RegisterAccountListener extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().registerAccountListener((String[]) args[0],
                    (String) args[1]
            );
            return 0;
        }
    }

    @ProxyMethod("unregisterAccountListener")
    public static class UnregisterAccountListener extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BAccountManager.get().unregisterAccountListener((String[]) args[0],
                    (String) args[1]
            );
            return 0;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IActivityClientProxy.java`:

```java
package com.vcore.fake.service;

import android.app.ActivityManager;
import android.os.IBinder;

import java.lang.reflect.Method;

import black.android.app.ActivityClient;
import black.android.util.Singleton;
import com.vcore.fake.frameworks.BActivityManager;
import com.vcore.fake.hook.ClassInvocationStub;
import com.vcore.fake.hook.HookManager;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.utils.compat.TaskDescriptionCompat;

public class IActivityClientProxy extends ClassInvocationStub {
    public static final String TAG = "IActivityClientProxy";
    private final Object who;

    public IActivityClientProxy(Object who) {
        this.who = who;
    }

    @Override
    protected Object getWho() {
        if (who != null) {
            return who;
        }

        Object instance = ActivityClient.getInstance.call();
        Object singleton = ActivityClient.INTERFACE_SINGLETON.get(instance);
        return Singleton.get.call(singleton);
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        Object instance = ActivityClient.getInstance.call();
        Object singleton = ActivityClient.INTERFACE_SINGLETON.get(instance);
        Singleton.mInstance.set(singleton, proxyInvocation);

    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    public void onlyProxy(boolean only) {
        super.onlyProxy(only);
    }

    @ProxyMethod("finishActivity")
    public static class FinishActivity extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            IBinder token = (IBinder) args[0];
            BActivityManager.get().onFinishActivity(token);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("activityResumed")
    public static class ActivityResumed extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            IBinder token = (IBinder) args[0];
            BActivityManager.get().onActivityResumed(token);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("activityDestroyed")
    public static class ActivityDestroyed extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            IBinder token = (IBinder) args[0];
            BActivityManager.get().onActivityDestroyed(token);
            return method.invoke(who, args);
        }
    }

    // for >= Android 12
    @ProxyMethod("setTaskDescription")
    public static class SetTaskDescription extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            ActivityManager.TaskDescription td = (ActivityManager.TaskDescription) args[1];
            args[1] = TaskDescriptionCompat.fix(td);
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IActivityManagerProxy.java`:

```java
package com.vcore.fake.service;

import static android.content.pm.PackageManager.GET_META_DATA;
import static android.content.pm.PackageManager.PERMISSION_GRANTED;

import android.Manifest;
import android.app.ActivityManager;
import android.app.IServiceConnection;
import android.app.Notification;
import android.content.ComponentName;
import android.content.IIntentReceiver;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.os.Build;
import android.os.IBinder;
import android.os.IInterface;
import android.util.Log;

import java.lang.ref.WeakReference;
import java.lang.reflect.Method;
import java.util.ArrayList;

import black.android.app.ActivityManagerNative;
import black.android.app.ActivityManagerOreo;
import black.android.app.IActivityManager;
import black.android.app.LoadedApk;
import black.android.content.ContentProviderNative;
import black.android.content.pm.UserInfo;
import black.android.util.Singleton;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.core.env.AppSystemEnv;
import com.vcore.core.system.DaemonService;
import com.vcore.entity.AppConfig;
import com.vcore.entity.am.RunningAppProcessInfo;
import com.vcore.entity.am.RunningServiceInfo;
import com.vcore.fake.delegate.ContentProviderDelegate;
import com.vcore.fake.delegate.InnerReceiverDelegate;
import com.vcore.fake.delegate.ServiceConnectionDelegate;
import com.vcore.fake.frameworks.BActivityManager;
import com.vcore.fake.frameworks.BPackageManager;
import com.vcore.fake.hook.ClassInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.fake.hook.ScanClass;
import com.vcore.fake.service.base.PkgMethodProxy;
import com.vcore.fake.service.context.providers.ContentProviderStub;
import com.vcore.proxy.ProxyManifest;
import com.vcore.proxy.record.ProxyBroadcastRecord;
import com.vcore.proxy.record.ProxyPendingRecord;
import com.vcore.utils.MethodParameterUtils;
import com.vcore.utils.Slog;
import com.vcore.utils.compat.ActivityManagerCompat;
import com.vcore.utils.compat.BuildCompat;
import com.vcore.utils.compat.ParceledListSliceCompat;
import com.vcore.utils.compat.TaskDescriptionCompat;

@ScanClass(ActivityManagerCommonProxy.class)
public class IActivityManagerProxy extends ClassInvocationStub {
    public static final String TAG = "IActivityManagerProxy";

    @Override
    protected Object getWho() {
        Object iActivityManager = null;
        if (BuildCompat.isOreo()) {
            iActivityManager = ActivityManagerOreo.IActivityManagerSingleton.get();
        } else if (BuildCompat.isL()) {
            iActivityManager = ActivityManagerNative.gDefault.get();
        }
        return Singleton.get.call(iActivityManager);
    }

    @Override
    protected void inject(Object base, Object proxy) {
        Object iActivityManager = null;
        if (BuildCompat.isOreo()) {
            iActivityManager = ActivityManagerOreo.IActivityManagerSingleton.get();
        } else if (BuildCompat.isL()) {
            iActivityManager = ActivityManagerNative.gDefault.get();
        }
        Singleton.mInstance.set(iActivityManager, proxy);
    }

    @Override
    public boolean isBadEnv() {
        return getProxyInvocation() != getWho();
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        addMethodHook(new PkgMethodProxy("getAppStartMode"));
        addMethodHook(new PkgMethodProxy("setAppLockedVerifying"));
        addMethodHook(new PkgMethodProxy("reportJunkFromApp"));
    }

    @ProxyMethod("getContentProvider")
    public static class GetContentProvider extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Exception {
            int authIndex = getAuthIndex();
            Object auth = args[authIndex];
            Object content;

            Slog.d(TAG, "Innovate getContentProvider: " + auth);
            if (auth instanceof String) {
                if (ProxyManifest.isProxy((String) auth)) {
                    Slog.d(TAG, "ProxyManifest.isProxy: " + auth);
                    return method.invoke(who, args);
                }

                if (BuildCompat.isQ()) {
                    args[1] = BlackBoxCore.getHostPkg();
                }

                if (auth.equals("settings") || auth.equals("media") || auth.equals("telephony")) {
                    content = method.invoke(who, args);
                    ContentProviderDelegate.update(content, (String) auth);
                    return content;
                } else {
                    Slog.d(TAG, "Hook getContentProvider: " + auth);
                    ProviderInfo providerInfo = BlackBoxCore.getBPackageManager().resolveContentProvider((String) auth, GET_META_DATA, BActivityThread.getUserId());

                    Slog.d(TAG, "Hook app: " + auth);
                    IBinder providerBinder = null;
                    if (BActivityThread.getAppPid() != -1 && providerInfo != null) {
                        AppConfig appConfig = BlackBoxCore.getBActivityManager().initProcess(providerInfo.packageName, providerInfo.processName, BActivityThread.getUserId());
                        if (appConfig.bPID != BActivityThread.getAppPid()) {
                            providerBinder = BlackBoxCore.getBActivityManager().acquireContentProviderClient(providerInfo);
                        }

                        args[authIndex] = ProxyManifest.getProxyAuthorities(appConfig.bPID);
                        args[getUserIndex()] = BlackBoxCore.getHostUserId();
                    }

                    if (providerBinder == null) {
                        return null;
                    }

                    content = method.invoke(who, args);
                    IActivityManager.ContentProviderHolder.info.set(content, providerInfo);
                    IActivityManager.ContentProviderHolder.provider.set(content, new ContentProviderStub().wrapper(ContentProviderNative.asInterface.call(providerBinder), BActivityThread.getAppPackageName()));
                }
                return content;
            }
            return method.invoke(who, args);
        }

        private int getAuthIndex() {
            // 10.0
            if (BuildCompat.isQ()) {
                return 2;
            } else {
                return 1;
            }
        }

        private int getUserIndex() {
            return getAuthIndex() + 1;
        }
    }

    @ProxyMethod("startService")
    public static class StartService extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Intent intent = (Intent) args[1];
            String resolvedType = (String) args[2];

            ResolveInfo resolveInfo = BlackBoxCore.getBPackageManager().resolveService(intent, 0, resolvedType, BActivityThread.getUserId());
            if (resolveInfo == null) {
                return method.invoke(who, args);
            }

            int requireForegroundIndex = getRequireForeground();
            boolean requireForeground = false;
            if (requireForegroundIndex != -1) {
                requireForeground = (boolean) args[requireForegroundIndex];
            }
            return BlackBoxCore.getBActivityManager().startService(intent, resolvedType, requireForeground, BActivityThread.getUserId());
        }

        public int getRequireForeground() {
            if (BuildCompat.isOreo()) {
                return 3;
            }
            return -1;
        }
    }

    @ProxyMethod("stopService")
    public static class StopService extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Intent intent = (Intent) args[1];
            String resolvedType = (String) args[2];
            return BlackBoxCore.getBActivityManager().stopService(intent, resolvedType, BActivityThread.getUserId());
        }
    }

    @ProxyMethod("stopServiceToken")
    public static class StopServiceToken extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            ComponentName componentName = (ComponentName) args[0];
            IBinder token = (IBinder) args[1];
            BlackBoxCore.getBActivityManager().stopServiceToken(componentName, token, BActivityThread.getUserId());
            return true;
        }
    }

    @ProxyMethod("bindService")
    public static class BindService extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Intent intent = (Intent) args[2];
            String resolvedType = (String) args[3];
            IServiceConnection connection = (IServiceConnection) args[4];
            int userId = intent.getIntExtra("_B_|_UserId", -1);
            userId = userId == -1 ? BActivityThread.getUserId() : userId;
            int callingPkgIdx = false ? 7 : (char) 6;
            if (Build.VERSION.SDK_INT >= 23 && args.length >= 8 && (args[callingPkgIdx] instanceof String)) {
                args[callingPkgIdx] = BlackBoxCore.getHostPkg();
            }
            long flags = getIntOrLongValue(args[5]);
            ResolveInfo resolveInfo = BlackBoxCore.getBPackageManager().resolveService(intent, 0, resolvedType, userId);
            if (resolveInfo != null || AppSystemEnv.isOpenPackage(intent.getComponent())) {
                if (BuildCompat.isU()){
                    args[5] = Long.valueOf(flags & 2147483647L);
                }else{
                    args[5] = Integer.valueOf((int) (flags & 2147483647L));
                }
                Intent proxyIntent = BlackBoxCore.getBActivityManager().bindService(intent, connection == null ? null : connection.asBinder(), resolvedType,
                        userId);
                if (connection != null) {
                    if (intent.getComponent() == null && resolveInfo != null) {
                        intent.setComponent(new ComponentName(resolveInfo.serviceInfo.packageName, resolveInfo.serviceInfo.name));
                    }

                    IServiceConnection proxy = ServiceConnectionDelegate.createProxy(connection, intent);
                    args[4] = proxy;

                    WeakReference<?> weakReference = LoadedApk.ServiceDispatcher.InnerConnection.mDispatcher.get(connection);
                    if (weakReference != null) {
                        LoadedApk.ServiceDispatcher.mConnection.set(weakReference.get(), proxy);
                    }
                }
                if (BuildCompat.isT()){
                    if (proxyIntent != null) {
                        args[2] = proxyIntent;
                        return method.invoke(who, args);
                    }
                }else{
                    return method.invoke(who, args);
                }
            }
            return method.invoke(who, args);
        }

        @Override
        protected boolean isEnable() {
            return BlackBoxCore.get().isBlackProcess() || BlackBoxCore.get().isServerProcess();
        }
    }

    public static long getIntOrLongValue(Object obj) {
        if (obj == null) {
            return 0L;
        }
        if (obj instanceof Integer) {
            return ((Integer) obj).longValue();
        }
        if (obj instanceof Long) {
            return ((Long) obj).longValue();
        }
        return -1L;
    }

    // 10.0
    @ProxyMethod("bindIsolatedService")
    public static class BindIsolatedService extends BindService {

        @Override
        protected Object beforeHook(Object who, Method method, Object[] args) throws Throwable {
            // instanceName
            args[6] = null;
            return super.beforeHook(who, method, args);
        }
    }

    @ProxyMethod("unbindService")
    public static class UnbindService extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            IServiceConnection iServiceConnection = (IServiceConnection) args[0];
            if (iServiceConnection == null) {
                return method.invoke(who, args);
            }

            BlackBoxCore.getBActivityManager().unbindService(iServiceConnection.asBinder(), BActivityThread.getUserId());
            ServiceConnectionDelegate delegate = ServiceConnectionDelegate.getDelegate(iServiceConnection.asBinder());
            if (delegate != null) {
                args[0] = delegate;
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getRunningAppProcesses")
    public static class GetRunningAppProcesses extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            RunningAppProcessInfo runningAppProcesses = BActivityManager.get().getRunningAppProcesses(BActivityThread.getAppPackageName(), BActivityThread.getUserId());
            if (runningAppProcesses == null) {
                return new ArrayList<>();
            }
            return runningAppProcesses.mAppProcessInfoList;
        }
    }

    @ProxyMethod("getServices")
    public static class GetServices extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            RunningServiceInfo runningServices = BActivityManager.get().getRunningServices(BActivityThread.getAppPackageName(), BActivityThread.getUserId());
            if (runningServices == null) {
                return new ArrayList<>();
            }
            return runningServices.mRunningServiceInfoList;
        }
    }

    @ProxyMethod("getIntentSender")
    public static class GetIntentSender extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            int type = (int) args[0];
            Intent[] intents = (Intent[]) args[getIntentsIndex(args)];
            MethodParameterUtils.replaceFirstAppPkg(args);

            for (int i = 0; i < intents.length; i++) {
                Intent intent = intents[i];
                if (type == ActivityManagerCompat.INTENT_SENDER_ACTIVITY) {
                    Intent shadow = new Intent();
                    shadow.setComponent(new ComponentName(BlackBoxCore.getHostPkg(), ProxyManifest.getProxyPendingActivity(BActivityThread.getAppPid())));

                    ProxyPendingRecord.saveStub(shadow, intent, BActivityThread.getUserId());
                    intents[i] = shadow;
                }
            }

            IInterface invoke = (IInterface) method.invoke(who, args);
            if (invoke != null) {
                String[] packagesForUid = BPackageManager.get().getPackagesForUid(BActivityThread.getCallingBUid());
                if (packagesForUid.length < 1) {
                    packagesForUid = new String[]{BlackBoxCore.getHostPkg()};
                }
                BlackBoxCore.getBActivityManager().getIntentSender(invoke.asBinder(), packagesForUid[0], BActivityThread.getCallingBUid());
            }
            return invoke;
        }

        private int getIntentsIndex(Object[] args) {
            for (int i = 0; i < args.length; i++) {
                if (args[i] instanceof Intent[]) {
                    return i;
                }
            }
            if (BuildCompat.isR()) {
                return 6;
            } else {
                return 5;
            }
        }
    }

    @ProxyMethod("getPackageForIntentSender")
    public static class GetPackageForIntentSender extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            IInterface invoke = (IInterface) args[0];
            return BlackBoxCore.getBActivityManager().getPackageForIntentSender(invoke.asBinder());
        }
    }

    @ProxyMethod("getUidForIntentSender")
    public static class getUidForIntentSender extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            IInterface invoke = (IInterface) args[0];
            return BlackBoxCore.getBActivityManager().getUidForIntentSender(invoke.asBinder());
        }
    }

    @ProxyMethod("broadcastIntent")
    public static class BroadcastIntent extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            int intentIndex = getIntentIndex(args);
            Intent intent = (Intent) args[intentIndex];
            String resolvedType = (String) args[intentIndex + 1];

            Intent proxyIntent = BlackBoxCore.getBActivityManager().sendBroadcast(intent, resolvedType, BActivityThread.getUserId());
            if (proxyIntent != null) {
                proxyIntent.setExtrasClassLoader(BActivityThread.getApplication().getClassLoader());

                ProxyBroadcastRecord.saveStub(proxyIntent, intent, BActivityThread.getUserId());
                args[intentIndex] = proxyIntent;
            }
            // ignore permission
            for (int i = 0; i < args.length; i++) {
                Object o = args[i];
                if (o instanceof String[]) {
                    args[i] = null;
                }
            }
            return method.invoke(who, args);
        }

        int getIntentIndex(Object[] args) {
            for (int i = 0; i < args.length; i++) {
                Object arg = args[i];
                if (arg instanceof Intent) {
                    return i;
                }
            }
            return 1;
        }
    }

    @ProxyMethod("peekService")
    public static class PeekService extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceLastAppPkg(args);
            Intent intent = (Intent) args[0];
            String resolvedType = (String) args[1];
            return BlackBoxCore.getBActivityManager().peekService(intent, resolvedType, BActivityThread.getUserId());
        }
    }

    // TODO
    @ProxyMethod("sendIntentSender")
    public static class SendIntentSender extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return 0;
        }
    }

    @ProxyMethod("registerReceiver")
    public static class RegisterReceiver extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceFirstAppPkg(args);
            int receiverIndex = getReceiverIndex();
            if (args[receiverIndex] != null) {
                IIntentReceiver intentReceiver = (IIntentReceiver) args[receiverIndex];
                IIntentReceiver proxy = InnerReceiverDelegate.createProxy(intentReceiver);

                WeakReference<?> weakReference = LoadedApk.ReceiverDispatcher.InnerReceiver.mDispatcher.get(intentReceiver);
                if (weakReference != null) {
                    LoadedApk.ReceiverDispatcher.mIIntentReceiver.set(weakReference.get(), proxy);
                }

                args[receiverIndex] = proxy;
            }
            // ignore permission
            if (args[getPermissionIndex()] != null) {
                args[getPermissionIndex()] = null;
            }
            return method.invoke(who, args);
        }

        public int getReceiverIndex() {
            if (BuildCompat.isS()) {
                return 4;
            } else if (BuildCompat.isR()) {
                return 3;
            }
            return 2;
        }

        public int getPermissionIndex() {
            if (BuildCompat.isS()) {
                return 6;
            } else if (BuildCompat.isR()) {
                return 5;
            }
            return 4;
        }
    }

    @ProxyMethod("grantUriPermission")
    public static class GrantUriPermission extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceLastUid(args);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("setServiceForeground")
    public static class SetServiceForeground extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Notification notification = (Notification) args[3];

            Intent intent = new Intent(BlackBoxCore.getContext(), DaemonService.class);
            if (notification != null) {
                if (BuildCompat.isOreo()) {
                    BlackBoxCore.getContext().startForegroundService(intent);
                } else {
                    BlackBoxCore.getContext().startService(intent);
                }
            } else {
                BlackBoxCore.getContext().stopService(intent);
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getHistoricalProcessExitReasons")
    public static class GetHistoricalProcessExitReasons extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return ParceledListSliceCompat.create(new ArrayList<>());
        }
    }

    @ProxyMethod("getCurrentUser")
    public static class GetCurrentUser extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return UserInfo._new.newInstance(BActivityThread.getUserId(), "BlackBox", UserInfo.FLAG_PRIMARY.get());
        }
    }

    @ProxyMethod("checkPermission")
    public static class CheckPermission extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceLastUid(args);
            String permission = (String) args[0];

            if (permission.equals(Manifest.permission.ACCOUNT_MANAGER) || permission.equals(Manifest.permission.SEND_SMS)) {
                return PackageManager.PERMISSION_GRANTED;
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("checkUriPermission")
    public static class CheckUriPermission extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return PERMISSION_GRANTED;
        }
    }

    // for < Android 10
    @ProxyMethod("setTaskDescription")
    public static class SetTaskDescription extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            ActivityManager.TaskDescription td = (ActivityManager.TaskDescription) args[1];
            args[1] = TaskDescriptionCompat.fix(td);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("overridePendingTransition")
    public static class OverridePendingTransition extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            String packageName = (String) args[1];
            if ("com.tencent.mm".equals(packageName)) {
                return null;
            }else{
                return method.invoke(who, args);
            }
        }
    }

    @ProxyMethod("setPackageAskScreenCompat")
    public static class SetPackageAskScreenCompat extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1) {
                if (args.length > 0 && args[0] instanceof String) {
                    args[0] = BlackBoxCore.getHostPkg();
                }
            }
            return method.invoke(who,args);
        }
    }

    @ProxyMethod("handleIncomingUser")
    public static class HandleIncomingUser extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (BlackBoxCore.get().isBlackProcess()){
                int lastIndex = args.length - 1;
                if (args[lastIndex] instanceof String) {
                    args[lastIndex] = BlackBoxCore.getHostPkg();
                }
                return method.invoke(who, args);
            }else{
                return method.invoke(who, args);
            }
        }
    }

    @ProxyMethod("getPersistedUriPermissions")
    public static class GetPersistedUriPermissions extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (BlackBoxCore.get().isBlackProcess()){
                MethodParameterUtils.replaceFirstAppPkg(args);
                return method.invoke(who, args);
            }else{
                return method.invoke(who, args);
            }
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IActivityTaskManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.app.ActivityManager;

import java.lang.reflect.Method;

import black.android.app.ActivityTaskManager;
import black.android.app.IActivityTaskManager;
import black.android.os.ServiceManager;
import black.android.util.Singleton;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.fake.hook.ScanClass;
import com.vcore.utils.compat.TaskDescriptionCompat;

@ScanClass(ActivityManagerCommonProxy.class)
public class IActivityTaskManagerProxy extends BinderInvocationStub {
    public static final String TAG = "ActivityTaskManager";

    public IActivityTaskManagerProxy() {
        super(ServiceManager.getService.call("activity_task"));
    }

    @Override
    protected Object getWho() {
        return IActivityTaskManager.Stub.asInterface.call(ServiceManager.getService.call("activity_task"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("activity_task");

        Object o = ActivityTaskManager.IActivityTaskManagerSingleton.get();
        Singleton.mInstance.set(o, IActivityTaskManager.Stub.asInterface.call(this));

    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new SetTaskDescription());
    }

    // for >= Android 10 && < Android 12
    @ProxyMethod("setTaskDescription")
    public static class SetTaskDescription extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            ActivityManager.TaskDescription td = (ActivityManager.TaskDescription) args[1];
            args[1] = TaskDescriptionCompat.fix(td);
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IAlarmManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.os.Build;
import android.os.WorkSource;

import java.lang.reflect.Method;

import black.android.app.IAlarmManager;
import black.android.os.ServiceManager;
import com.vcore.BlackBoxCore;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.fake.service.base.ValueMethodProxy;
import com.vcore.utils.ArrayUtils;

public class IAlarmManagerProxy extends BinderInvocationStub {
    public IAlarmManagerProxy() {
        super(ServiceManager.getService.call(Context.ALARM_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IAlarmManager.Stub.asInterface.call(ServiceManager.getService.call(Context.ALARM_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.ALARM_SERVICE);
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        //addMethodHook(new ValueMethodProxy("set", 0));
        addMethodHook(new ValueMethodProxy("setTimeZone",null));
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @ProxyMethod("set")
    public static class Set extends MethodHook {

        @Override
        protected String getMethodName() {
            return "set";
        }

        @Override
        protected Object beforeHook(Object who, Method method, Object[] args) throws Throwable {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N && args[0] instanceof String) {
                args[0] = BlackBoxCore.getHostPkg();
            }
            int index = ArrayUtils.indexOfFirst(args, WorkSource.class);
            if (index >= 0) {
                args[index] = null;
            }
            return true;
        }

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            try {
                return method.invoke(who, method, args);
            } catch (Throwable e) {
                e.printStackTrace();
            }
            return 0;
        }
    }

    @ProxyMethod("setTime")
    public static class SetTime extends MethodHook {

        @Override
        protected String getMethodName() {
            return "setTime";
        }

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                return false;
            }
            return null;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IAppOpsManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.app.AppOpsManager;
import android.content.Context;

import java.lang.reflect.Method;

import black.android.os.ServiceManager;
import black.com.android.internal.app.IAppOpsService;
import com.vcore.BlackBoxCore;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.utils.MethodParameterUtils;

public class IAppOpsManagerProxy extends BinderInvocationStub {
    public IAppOpsManagerProxy() {
        super(ServiceManager.getService.call(Context.APP_OPS_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IAppOpsService.Stub.asInterface.call(ServiceManager.getService.call(Context.APP_OPS_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        if (black.android.app.AppOpsManager.mService != null) {
            AppOpsManager appOpsManager = (AppOpsManager) BlackBoxCore.getContext().getSystemService(Context.APP_OPS_SERVICE);
            try {
                black.android.app.AppOpsManager.mService.set(appOpsManager, getProxyInvocation());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        replaceSystemService(Context.APP_OPS_SERVICE);

    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        MethodParameterUtils.replaceFirstAppPkg(args);
        MethodParameterUtils.replaceLastUid(args);
        return super.invoke(proxy, method, args);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }


    @ProxyMethod("noteProxyOperation")
    public static class NoteProxyOperation extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return AppOpsManager.MODE_ALLOWED;
        }
    }

    @ProxyMethod("checkPackage")
    public static class CheckPackage extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            // TODO
            return AppOpsManager.MODE_ALLOWED;
        }
    }

    @ProxyMethod("checkOperation")
    public static class CheckOperation extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceLastUid(args);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("noteOperation")
    public static class NoteOperation extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IAppWidgetManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;

import java.lang.reflect.Method;

import black.android.os.ServiceManager;
import black.com.android.internal.appwidget.IAppWidgetService;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.ValueMethodProxy;
import com.vcore.utils.MethodParameterUtils;

public class IAppWidgetManagerProxy extends BinderInvocationStub {
    public IAppWidgetManagerProxy() {
        super(ServiceManager.getService.call(Context.APPWIDGET_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IAppWidgetService.Stub.asInterface.call(ServiceManager.getService.call(Context.APPWIDGET_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.APPWIDGET_SERVICE);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        MethodParameterUtils.replaceAllAppPkg(args);
        return super.invoke(proxy, method, args);
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        addMethodHook(new ValueMethodProxy("startListening", new int[0]));
        addMethodHook(new ValueMethodProxy("stopListening", 0));
        addMethodHook(new ValueMethodProxy("allocateAppWidgetId", 0));
        addMethodHook(new ValueMethodProxy("deleteAppWidgetId", 0));
        addMethodHook(new ValueMethodProxy("deleteHost", 0));
        addMethodHook(new ValueMethodProxy("deleteAllHosts", 0));
        addMethodHook(new ValueMethodProxy("getAppWidgetViews", null));
        addMethodHook(new ValueMethodProxy("getAppWidgetIdsForHost", null));
        addMethodHook(new ValueMethodProxy("createAppWidgetConfigIntentSender", null));
        addMethodHook(new ValueMethodProxy("updateAppWidgetIds", 0));
        addMethodHook(new ValueMethodProxy("updateAppWidgetOptions", 0));
        addMethodHook(new ValueMethodProxy("getAppWidgetOptions", null));
        addMethodHook(new ValueMethodProxy("partiallyUpdateAppWidgetIds", 0));
        addMethodHook(new ValueMethodProxy("updateAppWidgetProvider", 0));
        addMethodHook(new ValueMethodProxy("notifyAppWidgetViewDataChanged", 0));
        addMethodHook(new ValueMethodProxy("getInstalledProvidersForProfile", null));
        addMethodHook(new ValueMethodProxy("getAppWidgetInfo", null));
        addMethodHook(new ValueMethodProxy("hasBindAppWidgetPermission", false));
        addMethodHook(new ValueMethodProxy("setBindAppWidgetPermission", 0));
        addMethodHook(new ValueMethodProxy("bindAppWidgetId", false));
        addMethodHook(new ValueMethodProxy("bindRemoteViewsService", 0));
        addMethodHook(new ValueMethodProxy("unbindRemoteViewsService", 0));
        addMethodHook(new ValueMethodProxy("getAppWidgetIds", new int[0]));
        addMethodHook(new ValueMethodProxy("isBoundWidgetPackage", false));
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IAutofillManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.ComponentName;

import java.lang.reflect.Method;

import black.android.os.ServiceManager;
import black.android.view.IAutoFillManager;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.proxy.ProxyManifest;

public class IAutofillManagerProxy extends BinderInvocationStub {
    public static final String TAG = "AutofillManagerStub";

    public IAutofillManagerProxy() {
        super(ServiceManager.getService.call("autofill"));
    }

    @Override
    protected Object getWho() {
        return IAutoFillManager.Stub.asInterface.call(ServiceManager.getService.call("autofill"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("autofill");

    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new StartSession());
    }

    @ProxyMethod("startSession")
    public static class StartSession extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (args != null) {
                for (int i = 0; i < args.length; i++) {
                    if (args[i] == null) {
                        continue;
                    }

                    if (args[i] instanceof ComponentName) {
                        args[i] = new ComponentName(BlackBoxCore.getHostPkg(), ProxyManifest.getProxyActivity(BActivityThread.getAppPid()));
                    }
                }
            }
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IBluetoothManagerProxy.java`:

```java
package com.vcore.fake.service;

import java.lang.reflect.Method;

import black.android.bluetooth.IBluetoothManager;
import black.android.os.ServiceManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;

public class IBluetoothManagerProxy extends BinderInvocationStub {
    public static final String TAG = "IBluetoothManagerProxy";

    public IBluetoothManagerProxy() {
        super(ServiceManager.getService.call("bluetooth_manager"));
    }

    @Override
    protected Object getWho() {
        return IBluetoothManager.Stub.asInterface.call(ServiceManager.getService.call("bluetooth_manager"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("bluetooth_manager");

    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new GetName());
    }

    @ProxyMethod("getName")
    public static class GetName extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return null;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IConnectivityManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;

import black.android.net.IConnectivityManager;
import black.android.os.ServiceManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.ValueMethodProxy;

public class IConnectivityManagerProxy extends BinderInvocationStub {
    public static final String TAG = "IConnectivityManagerProxy";

    public IConnectivityManagerProxy() {
        super(ServiceManager.getService.call(Context.CONNECTIVITY_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IConnectivityManager.Stub.asInterface.call(ServiceManager.getService.call(Context.CONNECTIVITY_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.CONNECTIVITY_SERVICE);
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        addMethodHook(new ValueMethodProxy("getAllNetworkInfo", null));
        addMethodHook(new ValueMethodProxy("getAllNetworks",null));
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IContextHubServiceProxy.java`:

```java
package com.vcore.fake.service;

import black.android.hardware.location.IContextHubService;
import black.android.os.ServiceManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.ValueMethodProxy;
import com.vcore.utils.compat.BuildCompat;

public class IContextHubServiceProxy extends BinderInvocationStub {
    public IContextHubServiceProxy() {
        super(ServiceManager.getService.call(getServiceName()));
    }

    private static String getServiceName() {
        return BuildCompat.isOreo() ? "contexthub" : "contexthub_service";
    }

    @Override
    protected Object getWho() {
        return IContextHubService.Stub.asInterface.call(ServiceManager.getService.call(getServiceName()));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(getServiceName());
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        addMethodHook(new ValueMethodProxy("registerCallback", 0));
        addMethodHook(new ValueMethodProxy("getContextHubInfo", null));
        addMethodHook(new ValueMethodProxy("getContextHubHandles",new int[]{}));
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IDeviceIdentifiersPolicyProxy.java`:

```java
package com.vcore.fake.service;

import java.lang.reflect.Method;

import black.android.os.IDeviceIdentifiersPolicyService;
import black.android.os.ServiceManager;
import com.vcore.BlackBoxCore;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.fake.service.base.PkgMethodProxy;
import com.vcore.utils.Md5Utils;

public class IDeviceIdentifiersPolicyProxy extends BinderInvocationStub {
    public IDeviceIdentifiersPolicyProxy() {
        super(ServiceManager.getService.call("device_identifiers"));
    }

    @Override
    protected Object getWho() {
        return IDeviceIdentifiersPolicyService.Stub.asInterface.call(ServiceManager.getService.call("device_identifiers"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("device_identifiers");

    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new PkgMethodProxy("getSerialForPackage"));
    }

    @ProxyMethod("getSerialForPackage")
    public static class GetSerialForPackage extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return Md5Utils.md5(BlackBoxCore.getHostPkg());
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IDevicePolicyManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.ComponentName;
import android.content.Context;

import java.lang.reflect.Method;

import black.android.app.admin.IDevicePolicyManager;
import black.android.os.ServiceManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.utils.MethodParameterUtils;

public class IDevicePolicyManagerProxy extends BinderInvocationStub {
    public IDevicePolicyManagerProxy() {
        super(ServiceManager.getService.call(Context.DEVICE_POLICY_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IDevicePolicyManager.Stub.asInterface.call(ServiceManager.getService.call(Context.DEVICE_POLICY_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.DEVICE_POLICY_SERVICE);

    }

    @Override
    public boolean isBadEnv() {
        return false;
    }


    @ProxyMethod("getStorageEncryptionStatus")
    public static class GetStorageEncryptionStatus extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceFirstAppPkg(args);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getDeviceOwnerComponent")
    public static class GetDeviceOwnerComponent extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return new ComponentName("", "");
        }
    }

    @ProxyMethod("getDeviceOwnerName")
    public static class GetDeviceOwnerName extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return "BlackBox";
        }
    }

    @ProxyMethod("getProfileOwnerName")
    public static class GetProfileOwnerName extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return "BlackBox";
        }
    }

    @ProxyMethod("isDeviceProvisioned")
    public static class IsDeviceProvisioned extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return true;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IDisplayManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.os.IInterface;

import java.lang.reflect.Method;

import black.android.hardware.display.DisplayManagerGlobal;
import com.vcore.fake.hook.ClassInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.utils.MethodParameterUtils;

public class IDisplayManagerProxy extends ClassInvocationStub {
    public IDisplayManagerProxy() { }

    @Override
    protected Object getWho() {
        return DisplayManagerGlobal.mDm.get(DisplayManagerGlobal.getInstance.call());
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        Object dmg = DisplayManagerGlobal.getInstance.call();
        DisplayManagerGlobal.mDm.set(dmg, getProxyInvocation());

    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new CreateVirtualDisplay());
    }

    @Override
    public boolean isBadEnv() {
        Object dmg = DisplayManagerGlobal.getInstance.call();
        IInterface mDm = DisplayManagerGlobal.mDm.get(dmg);
        return mDm != getProxyInvocation();
    }

    @ProxyMethod("createVirtualDisplay")
    public static class CreateVirtualDisplay extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceFirstAppPkg(args);
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IFingerprintManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;

import black.android.os.ServiceManager;
import black.android.view.IGraphicsStats;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.PkgMethodProxy;

public class IFingerprintManagerProxy extends BinderInvocationStub {
    public IFingerprintManagerProxy() {
        super(ServiceManager.getService.call(Context.FINGERPRINT_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IGraphicsStats.Stub.asInterface.call(ServiceManager.getService.call(Context.FINGERPRINT_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.FINGERPRINT_SERVICE);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        addMethodHook(new PkgMethodProxy("isHardwareDetected"));
        addMethodHook(new PkgMethodProxy("hasEnrolledFingerprints"));
        addMethodHook(new PkgMethodProxy("authenticate"));
        addMethodHook(new PkgMethodProxy("cancelAuthentication"));
        addMethodHook(new PkgMethodProxy("getEnrolledFingerprints"));
        addMethodHook(new PkgMethodProxy("getAuthenticatorId"));
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IFlymePermissionServiceProxy.java`:

```java
package com.vcore.fake.service;

import android.os.IBinder;

import black.android.os.ServiceManager;
import black.oem.flyme.IFlymePermissionService;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.PkgMethodProxy;

/**
 * @author Findger
 * @function
 * @date :2023/10/9 12:34
 **/
public class IFlymePermissionServiceProxy extends BinderInvocationStub {
    public IFlymePermissionServiceProxy() {
        super(ServiceManager.getService.call("flyme_permission"));
    }

    @Override
    protected Object getWho() {
        return IFlymePermissionService.Stub.TYPE;
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        addMethodHook(new PkgMethodProxy("noteIntentOperation"));
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IGraphicsStatsProxy.java`:

```java
package com.vcore.fake.service;

import java.lang.reflect.Method;

import black.android.os.ServiceManager;
import black.android.view.IGraphicsStats;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.utils.MethodParameterUtils;

public class IGraphicsStatsProxy extends BinderInvocationStub {
    public IGraphicsStatsProxy() {
        super(ServiceManager.getService.call("graphicsstats"));
    }

    @Override
    protected Object getWho() {
        return IGraphicsStats.Stub.asInterface.call(ServiceManager.getService.call("graphicsstats"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("graphicsstats");

    }

    @Override
    public boolean isBadEnv() {
        return false;
    }


    @ProxyMethod("requestBufferForProcess")
    public static class RequestBufferForProcess extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceFirstAppPkg(args);
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IJobServiceProxy.java`:

```java
package com.vcore.fake.service;

import android.app.job.JobInfo;
import android.content.Context;

import java.lang.reflect.Method;

import black.android.app.job.IJobScheduler;
import black.android.os.ServiceManager;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;

public class IJobServiceProxy extends BinderInvocationStub {
    public static final String TAG = "JobServiceStub";

    public IJobServiceProxy() {
        super(ServiceManager.getService.call(Context.JOB_SCHEDULER_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IJobScheduler.Stub.asInterface.call(ServiceManager.getService.call(Context.JOB_SCHEDULER_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.JOB_SCHEDULER_SERVICE);

    }


    @ProxyMethod("schedule")
    public static class Schedule extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            JobInfo jobInfo = (JobInfo) args[0];
            JobInfo proxyJobInfo = BlackBoxCore.getBJobManager()
                    .schedule(jobInfo);
            args[0] = proxyJobInfo;
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("cancel")
    public static class Cancel extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            args[0] = BlackBoxCore.getBJobManager()
                    .cancel(BActivityThread.getAppConfig().processName, (Integer) args[0]);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("cancelAll")
    public static class CancelAll extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BlackBoxCore.getBJobManager().cancelAll(BActivityThread.getAppConfig().processName);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("enqueue")
    public static class Enqueue extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            JobInfo jobInfo = (JobInfo) args[0];
            JobInfo proxyJobInfo = BlackBoxCore.getBJobManager()
                    .schedule(jobInfo);
            args[0] = proxyJobInfo;
            return method.invoke(who, args);
        }
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/ILauncherAppsProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;

import java.lang.reflect.Method;

import black.android.content.pm.ILauncherApps;
import black.android.os.ServiceManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.utils.MethodParameterUtils;

public class ILauncherAppsProxy extends BinderInvocationStub {
    public ILauncherAppsProxy() {
        super(ServiceManager.getService.call(Context.LAUNCHER_APPS_SERVICE));
    }

    @Override
    protected Object getWho() {
        return ILauncherApps.Stub.asInterface.call(ServiceManager.getService.call(Context.LAUNCHER_APPS_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.LAUNCHER_APPS_SERVICE);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        MethodParameterUtils.replaceFirstAppPkg(args);
        // TODO: shouldHideFromSuggestions
        return super.invoke(proxy, method, args);
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/ILocationManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.location.ILocationListener;
import android.location.LocationManager;
import android.os.IInterface;
import android.util.Log;

import java.lang.reflect.Method;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.Locale;
import java.util.Objects;

import black.android.location.ILocationManager;
import black.android.location.provider.ProviderProperties;
import black.android.os.ServiceManager;
import com.vcore.app.BActivityThread;
import com.vcore.entity.location.BLocation;
import com.vcore.fake.frameworks.BLocationManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.fake.service.context.LocationListenerProxy;
import com.vcore.utils.MethodParameterUtils;
import com.vcore.utils.compat.BuildCompat;

public class ILocationManagerProxy extends BinderInvocationStub {
    public static final String TAG = "ILocationManagerProxy";

    public ILocationManagerProxy() {
        super(ServiceManager.getService.call(Context.LOCATION_SERVICE));
    }

    @Override
    protected Object getWho() {
        return ILocationManager.Stub.asInterface.call(ServiceManager.getService.call(Context.LOCATION_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.LOCATION_SERVICE);

    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        MethodParameterUtils.replaceFirstAppPkg(args);
        return super.invoke(proxy, method, args);
    }


    @ProxyMethod("registerGnssStatusCallback")
    public static class RegisterGnssStatusCallback extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (BLocationManager.isFakeLocationEnable()) {
                Object transport = MethodParameterUtils.getFirstParam(args, black.android.location.LocationManager.GnssStatusListenerTransport.REF.getClazz());

                if (transport != null) {
                    black.android.location.LocationManager.GnssStatusListenerTransport.onGnssStarted.call(transport);
                    BLocation location = BLocationManager.get().getLocation(BActivityThread.getUserId(), BActivityThread.getAppPackageName());

                    if (location != null) {
                        try {
                            String date = new SimpleDateFormat("HHmmss:SS", Locale.US).format(new Date());
                            String latitude = BLocation.getGPSLatitude(location.getLatitude());
                            String longitude = BLocation.getGPSLatitude(location.getLongitude());
                            String latitudeNorthWest = BLocation.getNorthWest(location);
                            String longitudeSouthEast = BLocation.getSouthEast(location);
                            String $GPGGA = BLocation.checkSum(String.format("$GPGGA,%s,%s,%s,%s,%s,1,%s,692,.00,M,.00,M,,,", date, latitude, latitudeNorthWest, longitude, longitudeSouthEast, location.convert2SystemLocation().getExtras().getInt("satellites")));
                            String $GPRMC = BLocation.checkSum(String.format("$GPRMC,%s,A,%s,%s,%s,%s,0,0,260717,,,A,", date, latitude, latitudeNorthWest, longitude, longitudeSouthEast));

                            black.android.location.LocationManager.GnssStatusListenerTransport.onNmeaReceived.call(transport, System.currentTimeMillis(), "$GPGSV,1,1,04,12,05,159,36,15,41,087,15,19,38,262,30,31,56,146,19,*73");
                            if (BuildCompat.isN()) {
                                black.android.location.LocationManager.GpsStatusListenerTransport.onNmeaReceived.call(transport, System.currentTimeMillis(), "$GPGSV,1,1,04,12,05,159,36,15,41,087,15,19,38,262,30,31,56,146,19,*73");
                                black.android.location.LocationManager.GpsStatusListenerTransport.onNmeaReceived.call(transport, System.currentTimeMillis(), $GPGGA);
                                black.android.location.LocationManager.GpsStatusListenerTransport.onNmeaReceived.call(transport, System.currentTimeMillis(), "$GPVTG,0,T,0,M,0,N,0,K,A,*25");
                                black.android.location.LocationManager.GpsStatusListenerTransport.onNmeaReceived.call(transport, System.currentTimeMillis(), $GPRMC);
                                black.android.location.LocationManager.GpsStatusListenerTransport.onNmeaReceived.call(transport, System.currentTimeMillis(), "$GPGSA,A,2,12,15,19,31,,,,,,,,,604,712,986,*27");
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
                return true;
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("registerLocationListener")
    public static class RegisterLocationListener extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (BLocationManager.isFakeLocationEnable()) {
                Object listener = MethodParameterUtils.getFirstParamByInstance(args, ILocationListener.Stub.class);
                if (listener != null) {
                    try {
                        black.android.location.LocationManager.LocationListenerTransport.mListener.set(listener,
                                new LocationListenerProxy().wrapper(black.android.location.LocationManager.LocationListenerTransport.mListener.get()));
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getLastLocation")
    public static class GetLastLocation extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Log.d(TAG, "GetLastLocation");
            if (BLocationManager.isFakeLocationEnable()) {
                return BLocationManager.get().getLocation(BActivityThread.getUserId(), BActivityThread.getAppPackageName()).convert2SystemLocation();
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getLastKnownLocation")
    public static class GetLastKnownLocation extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Log.d(TAG, "GetLastKnownLocation");
            if (BLocationManager.isFakeLocationEnable()) {
                return BLocationManager.get().getLocation(BActivityThread.getUserId(), BActivityThread.getAppPackageName()).convert2SystemLocation();
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getCurrentLocation")
    public static class GetCurrentLocation extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Log.d(TAG, "GetCurrentLocation");
            if (BLocationManager.isFakeLocationEnable()) {
                return BLocationManager.get().getLocation(BActivityThread.getUserId(), BActivityThread.getAppPackageName()).convert2SystemLocation();
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("requestLocationUpdates")
    public static class RequestLocationUpdates extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (BLocationManager.isFakeLocationEnable()) {
                Log.d(TAG, "isFakeLocationEnable RequestLocationUpdates");

                if (args[1] instanceof IInterface) {
                    IInterface listener = (IInterface) args[1];
                    BLocationManager.get().requestLocationUpdates(listener.asBinder());
                    return 0;
                }
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("removeUpdates")
    public static class RemoveUpdates extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (args[0] instanceof IInterface) {
                IInterface listener = (IInterface) args[0];
                BLocationManager.get().removeUpdates(listener.asBinder());
                return 0;
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getProviderProperties")
    public static class GetProviderProperties extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Object providerProperties = method.invoke(who, args);
            if (BLocationManager.isFakeLocationEnable()) {
                ProviderProperties.mHasNetworkRequirement.set(providerProperties, false);

                if (BLocationManager.get().getCell(BActivityThread.getUserId(), BActivityThread.getAppPackageName()) == null) {
                    ProviderProperties.mHasCellRequirement.set(providerProperties, false);
                }
            }
            return providerProperties;
        }
    }

    @ProxyMethod("removeGpsStatusListener")
    public static class RemoveGpsStatusListener extends MethodHook {
        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceLastAppPkg(args);
            if (BLocationManager.isFakeLocationEnable()) {
                return 0;
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getBestProvider")
    public static class GetBestProvider extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (BLocationManager.isFakeLocationEnable()) {
                return LocationManager.GPS_PROVIDER;
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getAllProviders")
    public static class GetAllProviders extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return Arrays.asList(LocationManager.GPS_PROVIDER, LocationManager.NETWORK_PROVIDER);
        }
    }

    @ProxyMethod("isProviderEnabledForUser")
    public static class isProviderEnabledForUser extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            String provider = (String) args[0];
            return Objects.equals(provider, LocationManager.GPS_PROVIDER);
        }
    }

    @ProxyMethod("setExtraLocationControllerPackageEnabled")
    public static class setExtraLocationControllerPackageEnabled extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return 0;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IMediaRouterServiceProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;

import java.lang.reflect.Method;

import black.android.media.IMediaRouterService;
import black.android.os.ServiceManager;
import com.vcore.core.system.accounts.RegisteredServicesParser;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.utils.MethodParameterUtils;

public class IMediaRouterServiceProxy extends BinderInvocationStub {
    public IMediaRouterServiceProxy() {
        super(ServiceManager.getService.call(Context.MEDIA_ROUTER_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IMediaRouterService.Stub.asInterface.call(ServiceManager.getService.call(Context.MEDIA_ROUTER_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.MEDIA_ROUTER_SERVICE);

    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        MethodParameterUtils.replaceFirstAppPkg(args);
        return super.invoke(proxy, method, args);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @ProxyMethod("registerClientAsUser")
    public static class registerClientAsUser extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("registerRouter2")
    public static class registerRouter2 extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IMediaSessionManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;

import java.lang.reflect.Method;

import black.android.media.session.ISessionManager;
import black.android.os.ServiceManager;
import com.vcore.BlackBoxCore;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;

public class IMediaSessionManagerProxy extends BinderInvocationStub {
    public IMediaSessionManagerProxy() {
        super(ServiceManager.getService.call(Context.MEDIA_SESSION_SERVICE));
    }

    @Override
    protected Object getWho() {
        return ISessionManager.Stub.asInterface.call(ServiceManager.getService.call(Context.MEDIA_SESSION_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.MEDIA_SESSION_SERVICE);

    }

    @Override
    public boolean isBadEnv() {
        return false;
    }


    @ProxyMethod("createSession")
    public static class CreateSession extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (args != null && args.length > 0 && args[0] instanceof String) {
                args[0] = BlackBoxCore.getHostPkg();
            }
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/INetworkManagementServiceProxy.java`:

```java
package com.vcore.fake.service;

import java.lang.reflect.Method;

import black.android.os.INetworkManagementService;
import black.android.os.ServiceManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.fake.service.base.UidMethodProxy;
import com.vcore.utils.MethodParameterUtils;

public class INetworkManagementServiceProxy extends BinderInvocationStub {

    public INetworkManagementServiceProxy() {
        super(ServiceManager.getService.call("network_management"));
    }

    @Override
    protected Object getWho() {
        return INetworkManagementService.Stub.asInterface.call(ServiceManager.getService.call("network_management"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("network_management");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        addMethodHook(new UidMethodProxy("setUidCleartextNetworkPolicy", 0));
        addMethodHook(new UidMethodProxy("setUidMeteredNetworkBlacklist", 0));
        addMethodHook(new UidMethodProxy("setUidMeteredNetworkWhitelist", 0));
    }

    @ProxyMethod("getNetworkStatsUidDetail")
    public static class GetNetworkStatsUidDetail extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceFirstUid(args);
            MethodParameterUtils.replaceFirstAppPkg(args);
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/INotificationManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationChannelGroup;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.IBinder;

import androidx.annotation.RequiresApi;

import java.lang.reflect.Method;
import java.util.List;

import black.android.app.NotificationManager;
import black.android.content.pm.ParceledListSlice;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.fake.frameworks.BActivityManager;
import com.vcore.fake.frameworks.BNotificationManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.utils.MethodParameterUtils;
import com.vcore.utils.compat.BuildCompat;
import com.vcore.utils.compat.ParceledListSliceCompat;

public class INotificationManagerProxy extends BinderInvocationStub {
    public static final String TAG = "INotificationManagerProxy";

    public INotificationManagerProxy() {
        super(NotificationManager.getService.call().asBinder());
    }

    @Override
    protected Object getWho() {
        return NotificationManager.getService.call();
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        NotificationManager.sService.set(getProxyInvocation());
        replaceSystemService(Context.NOTIFICATION_SERVICE);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        MethodParameterUtils.replaceAllAppPkg(args);
        return super.invoke(proxy, method, args);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }


    @ProxyMethod("getNotificationChannel")
    public static class GetNotificationChannel extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return BNotificationManager.get().getNotificationChannel((String) args[args.length - 1]);
        }
    }

    @ProxyMethod("getNotificationChannels")
    public static class GetNotificationChannels extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            List<NotificationChannel> notificationChannels = BNotificationManager.get().getNotificationChannels(BActivityThread.getAppPackageName());
            return ParceledListSliceCompat.create(notificationChannels);
        }
    }

    @ProxyMethod("cancelNotificationWithTag")
    public static class CancelNotificationWithTag extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            String tag = (String) args[getTagIndex()];
            int id = (int) args[getIdIndex()];

            BNotificationManager.get().cancelNotificationWithTag(id, tag);
            return 0;
        }

        public int getTagIndex() {
            if (BuildCompat.isR()) {
                return 2;
            }
            return 1;
        }

        public int getIdIndex() {
            return getTagIndex() + 1;
        }
    }


    @ProxyMethod("enqueueNotificationWithTag")
    public static class EnqueueNotificationWithTag extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            String tag = (String) args[getTagIndex()];
            int id = (int) args[getIdIndex()];

            Notification notification = MethodParameterUtils.getFirstParam(args, Notification.class);
            BNotificationManager.get().enqueueNotificationWithTag(id, tag, notification);
            return 0;
        }

        public int getTagIndex() {
            return 2;
        }

        public int getIdIndex() {
            return getTagIndex() + 1;
        }
    }

    @ProxyMethod("createNotificationChannels")
    @RequiresApi(api = Build.VERSION_CODES.O)
    public static class CreateNotificationChannels extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            List<?> list = ParceledListSlice.getList.call(args[1]);
            if (list == null) {
                return 0;
            }

            for (Object o : list) {
                BNotificationManager.get().createNotificationChannel((NotificationChannel) o);
            }
            return 0;
        }
    }

    @ProxyMethod("deleteNotificationChannel")
    public static class DeleteNotificationChannel extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BNotificationManager.get().deleteNotificationChannel((String) args[1]);
            return 0;
        }
    }

    @ProxyMethod("createNotificationChannelGroups")
    @RequiresApi(api = Build.VERSION_CODES.O)
    public static class CreateNotificationChannelGroups extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            List<?> list = ParceledListSlice.getList.call(args[1]);
            for (Object o : list) {
                BNotificationManager.get().createNotificationChannelGroup((NotificationChannelGroup) o);
            }
            return 0;
        }
    }

    @ProxyMethod("deleteNotificationChannelGroup")
    public static class DeleteNotificationChannelGroup extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            BNotificationManager.get().deleteNotificationChannelGroup((String) args[1]);
            return 0;
        }
    }

    @ProxyMethod("getNotificationChannelGroups")
    public static class GetNotificationChannelGroups extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            List<NotificationChannelGroup> notificationChannelGroups = BNotificationManager.get().getNotificationChannelGroups(BActivityThread.getAppPackageName());
            return ParceledListSliceCompat.create(notificationChannelGroups);
        }
    }

    @ProxyMethod("removeEdgeNotification")
    public static class RemoveEdgeNotification extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (BuildCompat.isSamsung()){
                MethodParameterUtils.replaceFirstAppPkg(args);
                return method.invoke(who,args);
            }
            return null;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IPackageManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.ServiceInfo;
import android.content.pm.VersionedPackage;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import black.android.app.ActivityThread;
import black.android.app.ApplicationPackageManager;
import black.android.app.ContextImpl;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.core.env.AppSystemEnv;
import com.vcore.core.system.pm.BPackageManagerService;
import com.vcore.core.system.pm.BPackageSettings;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.fake.service.base.PkgMethodProxy;
import com.vcore.utils.MethodParameterUtils;
import com.vcore.utils.Slog;
import com.vcore.utils.compat.BuildCompat;
import com.vcore.utils.compat.ParceledListSliceCompat;

public class IPackageManagerProxy extends BinderInvocationStub {
    public static final String TAG = "PackageManagerProxy";

    public IPackageManagerProxy() {
        super(ActivityThread.sPackageManager.get().asBinder());
    }

    @Override
    protected Object getWho() {
        return ActivityThread.sPackageManager.get();
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        ActivityThread.sPackageManager.set(proxyInvocation);
        replaceSystemService("package");

        Object systemContext = ActivityThread.getSystemContext.call(BlackBoxCore.mainThread());
        PackageManager packageManager = ContextImpl.mPackageManager.get(systemContext);
        if (packageManager != null) {
            try {
                ApplicationPackageManager.mPM.set(packageManager, proxyInvocation);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        addMethodHook(new PkgMethodProxy("getPackageUid"));
        addMethodHook(new PkgMethodProxy("canRequestPackageInstalls"));
        if (BuildCompat.isOreo()) {
            addMethodHook("getPackageInfoVersioned", new MethodHook() {
                @Override
                protected Object hook(Object who, Method method, Object[] args) throws Throwable {
                    VersionedPackage versionedPackage = (VersionedPackage) args[0];
                    String packageName = versionedPackage.getPackageName();
                    PackageInfo packageInfo;

                    if (BuildCompat.isT()) {
                        long flags = (long) args[1];
                        packageInfo = BlackBoxCore.getBPackageManager().getPackageInfo(packageName, Math.toIntExact(flags), BActivityThread.getUserId());
                    } else {
                        int flags = (int) args[1];
                        packageInfo = BlackBoxCore.getBPackageManager().getPackageInfo(packageName, flags, BActivityThread.getUserId());
                    }

                    if (packageInfo != null) {
                        return packageInfo;
                    }

                    if (AppSystemEnv.isOpenPackage(packageName)) {
                        return method.invoke(who, args);
                    }
                    return null;
                }
            });
        }
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @ProxyMethod("resolveIntent")
    public static class ResolveIntent extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Intent intent = (Intent) args[0];
            String resolvedType = (String) args[1];
            ResolveInfo resolveInfo;

            if (BuildCompat.isT()) {
                long flags = (long) args[2];
                resolveInfo = BlackBoxCore.getBPackageManager().resolveIntent(intent, resolvedType, Math.toIntExact(flags), BActivityThread.getUserId());
            } else {
                int flags = (int) args[2];
                resolveInfo = BlackBoxCore.getBPackageManager().resolveIntent(intent, resolvedType, flags, BActivityThread.getUserId());
            }

            if (resolveInfo != null) {
                return resolveInfo;
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("resolveService")
    public static class ResolveService extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Intent intent = (Intent) args[0];
            String resolvedType = (String) args[1];
            ResolveInfo resolveInfo;

            if (BuildCompat.isT()) {
                long flags = (long) args[2];
                resolveInfo = BlackBoxCore.getBPackageManager().resolveService(intent, Math.toIntExact(flags), resolvedType, BActivityThread.getUserId());
            } else {
                int flags = (int) args[2];
                resolveInfo = BlackBoxCore.getBPackageManager().resolveService(intent, flags, resolvedType, BActivityThread.getUserId());
            }

            if (resolveInfo != null) {
                return resolveInfo;
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getPackageInfo")
    public static class GetPackageInfo extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            String packageName = (String) args[0];
            PackageInfo packageInfo;

            if (BuildCompat.isT()) {
                long flags = (long) args[1];
                packageInfo = BlackBoxCore.getBPackageManager().getPackageInfo(packageName, Math.toIntExact(flags), BActivityThread.getUserId());
            } else {
                int flags = (int) args[1];
                packageInfo = BlackBoxCore.getBPackageManager().getPackageInfo(packageName, flags, BActivityThread.getUserId());
            }

            if (packageInfo != null) {
                return packageInfo;
            }

            if (AppSystemEnv.isOpenPackage(packageName)) {
                return method.invoke(who, args);
            }
            return null;
        }
    }

    @ProxyMethod("getProviderInfo")
    public static class GetProviderInfo extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            ComponentName componentName = (ComponentName) args[0];
            ProviderInfo providerInfo;

            if (BuildCompat.isT()) {
                long flags = (long) args[1];
                providerInfo = BlackBoxCore.getBPackageManager().getProviderInfo(componentName, Math.toIntExact(flags), BActivityThread.getUserId());
            } else {
                int flags = (int) args[1];
                providerInfo = BlackBoxCore.getBPackageManager().getProviderInfo(componentName, flags, BActivityThread.getUserId());
            }

            if (providerInfo != null) {
                return providerInfo;
            }

            if (AppSystemEnv.isOpenPackage(componentName)) {
                return method.invoke(who, args);
            }
            return null;
        }
    }

    @ProxyMethod("getReceiverInfo")
    public static class GetReceiverInfo extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            ComponentName componentName = (ComponentName) args[0];
            ActivityInfo receiverInfo;

            if (BuildCompat.isT()) {
                long flags = (long) args[1];
                receiverInfo = BlackBoxCore.getBPackageManager().getReceiverInfo(componentName, Math.toIntExact(flags), BActivityThread.getUserId());
            } else {
                int flags = (int) args[1];
                receiverInfo = BlackBoxCore.getBPackageManager().getReceiverInfo(componentName, flags, BActivityThread.getUserId());
            }

            if (receiverInfo != null) {
                return receiverInfo;
            }

            if (AppSystemEnv.isOpenPackage(componentName)) {
                return method.invoke(who, args);
            }
            return null;
        }
    }

    @ProxyMethod("getActivityInfo")
    public static class GetActivityInfo extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            ComponentName componentName = (ComponentName) args[0];
            ActivityInfo activityInfo;

            if (BuildCompat.isT()) {
                long flags = (long) args[1];
                activityInfo = BlackBoxCore.getBPackageManager().getActivityInfo(componentName, Math.toIntExact(flags), BActivityThread.getUserId());
            } else {
                int flags = (int) args[1];
                activityInfo = BlackBoxCore.getBPackageManager().getActivityInfo(componentName, Math.toIntExact(flags), BActivityThread.getUserId());
            }

            if (activityInfo != null) {
                return activityInfo;
            }

            if (AppSystemEnv.isOpenPackage(componentName)) {
                return method.invoke(who, args);
            }
            return null;
        }
    }

    @ProxyMethod("getServiceInfo")
    public static class GetServiceInfo extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            ComponentName componentName = (ComponentName) args[0];
            ServiceInfo serviceInfo;

            if (BuildCompat.isT()) {
                long flags = (long) args[1];
                serviceInfo = BlackBoxCore.getBPackageManager().getServiceInfo(componentName, Math.toIntExact(flags), BActivityThread.getUserId());
            } else {
                int flags = (int) args[1];
                serviceInfo = BlackBoxCore.getBPackageManager().getServiceInfo(componentName, flags, BActivityThread.getUserId());
            }

            if (serviceInfo != null) {
                return serviceInfo;
            }

            if (AppSystemEnv.isOpenPackage(componentName)) {
                return method.invoke(who, args);
            }
            return null;
        }
    }

    @ProxyMethod("getInstalledApplications")
    public static class GetInstalledApplications extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            List<ApplicationInfo> installedApplications;

            if (BuildCompat.isT()) {
                long flags = (long) args[0];
                installedApplications = BlackBoxCore.getBPackageManager().getInstalledApplications(Math.toIntExact(flags), BActivityThread.getUserId());
            } else {
                int flags = (int) args[0];
                installedApplications = BlackBoxCore.getBPackageManager().getInstalledApplications(flags, BActivityThread.getUserId());
            }
            return ParceledListSliceCompat.create(installedApplications);
        }
    }

    @ProxyMethod("queryIntentActivities")
    public static class QueryIntentActivities extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Intent intent = (Intent) args[0];
            String resolvedType = (String) args[1];
            List<ResolveInfo> intentActivities;

            if (BuildCompat.isT()) {
                long flags = (long) args[2];
                intentActivities = BlackBoxCore.getBPackageManager().queryIntentActivities(intent, Math.toIntExact(flags), resolvedType, BActivityThread.getUserId());
            } else {
                int flags = (int) args[2];
                intentActivities = BlackBoxCore.getBPackageManager().queryIntentActivities(intent, flags, resolvedType, BActivityThread.getUserId());
            }
            return ParceledListSliceCompat.create(intentActivities);
        }
    }

    @ProxyMethod("getInstalledPackages")
    public static class GetInstalledPackages extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            List<PackageInfo> installedPackages;

            if (BuildCompat.isT()) {
                long flags = (long) args[0];
                installedPackages = BlackBoxCore.getBPackageManager().getInstalledPackages(Math.toIntExact(flags), BActivityThread.getUserId());
            } else {
                int flags = (int) args[0];
                installedPackages = BlackBoxCore.getBPackageManager().getInstalledPackages(flags, BActivityThread.getUserId());
            }
            return ParceledListSliceCompat.create(installedPackages);
        }
    }

    @ProxyMethod("getApplicationInfo")
    public static class GetApplicationInfo extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            String packageName = (String) args[0];
            ApplicationInfo applicationInfo;

            if (BuildCompat.isT()) {
                long flags = (long) args[1];
                applicationInfo = BlackBoxCore.getBPackageManager().getApplicationInfo(packageName, Math.toIntExact(flags), BActivityThread.getUserId());
            } else {
                int flags = (int) args[1];
                applicationInfo = BlackBoxCore.getBPackageManager().getApplicationInfo(packageName, flags, BActivityThread.getUserId());
            }

            if (applicationInfo != null) {
                return applicationInfo;
            }

            if (AppSystemEnv.isOpenPackage(packageName)) {
                return method.invoke(who, args);
            }
            return null;
        }
    }

    @ProxyMethod("queryContentProviders")
    public static class QueryContentProviders extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            List<ProviderInfo> providers;

            if (BuildCompat.isT()) {
                long flags = (long) args[2];

                providers = BlackBoxCore.getBPackageManager()
                        .queryContentProviders(BActivityThread.getAppProcessName(), BActivityThread.getBUid(), Math.toIntExact(flags), BActivityThread.getUserId());
            } else {
                int flags = (int) args[2];

                providers = BlackBoxCore.getBPackageManager()
                        .queryContentProviders(BActivityThread.getAppProcessName(), BActivityThread.getBUid(), flags, BActivityThread.getUserId());
            }
            return ParceledListSliceCompat.create(providers);
        }
    }

    @ProxyMethod("queryIntentReceivers")
    public static class QueryBroadcastReceivers extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Intent intent = MethodParameterUtils.getFirstParam(args, Intent.class);
            String type = MethodParameterUtils.getFirstParam(args, String.class);
            List<ResolveInfo> resolves;

            if (BuildCompat.isT()) {
                Long flags = MethodParameterUtils.getFirstParam(args, Long.class);
                resolves = BlackBoxCore.getBPackageManager().queryBroadcastReceivers(intent, Math.toIntExact(flags), type, BActivityThread.getUserId());
            } else {
                Integer flags = MethodParameterUtils.getFirstParam(args, Integer.class);
                resolves = BlackBoxCore.getBPackageManager().queryBroadcastReceivers(intent, flags, type, BActivityThread.getUserId());
            }

            Slog.d(TAG, "queryIntentReceivers: " + resolves);

            // http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/android/app/ApplicationPackageManager.java#872
            if (BuildCompat.isN()) {
                return ParceledListSliceCompat.create(resolves);
            }

            // http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/app/ApplicationPackageManager.java#699
            return resolves;
        }
    }

    @ProxyMethod("resolveContentProvider")
    public static class ResolveContentProvider extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            String authority = (String) args[0];
            ProviderInfo providerInfo;

            if (BuildCompat.isT()) {
                long flags = (long) args[1];
                providerInfo = BlackBoxCore.getBPackageManager().resolveContentProvider(authority, Math.toIntExact(flags), BActivityThread.getUserId());
            } else {
                int flags = (int) args[1];
                providerInfo = BlackBoxCore.getBPackageManager().resolveContentProvider(authority, flags, BActivityThread.getUserId());
            }

            if (providerInfo == null) {
                return method.invoke(who, args);
            }
            return providerInfo;
        }
    }

    @ProxyMethod("getPackagesForUid")
    public static class GetPackagesForUid extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            int uid = (Integer) args[0];
            if (uid == BlackBoxCore.getHostUid()) {
                args[0] = BActivityThread.getBUid();
                uid = (int) args[0];
            }

            String[] packagesForUid = BlackBoxCore.getBPackageManager().getPackagesForUid(uid);
            Slog.d(TAG, args[0] + " , " + BActivityThread.getAppProcessName() + " getPackagesForUid: " + Arrays.toString(packagesForUid));
            return packagesForUid;
        }
    }

    @ProxyMethod("getInstallerPackageName")
    public static class GetInstallerPackageName extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return "com.android.vending";
        }
    }

    @ProxyMethod("getSharedLibraries")
    public static class GetSharedLibraries extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            String packageName = (String) args[0];
            BPackageSettings packageSettings = BPackageManagerService.get().getBPackageSetting(packageName);
            if (packageSettings != null) {
                ArrayList<String> packageLibraries = new ArrayList<>();
                if (packageSettings.pkg.usesLibraries != null) {
                    packageLibraries.addAll(packageSettings.pkg.usesLibraries);
                }

                if (packageSettings.pkg.usesOptionalLibraries != null) {
                    packageLibraries.addAll(packageSettings.pkg.usesOptionalLibraries);
                }
                return ParceledListSliceCompat.create(packageLibraries);
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getComponentEnabledSetting")
    public static class GetComponentEnabledSetting extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IPermissionManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.pm.PackageManager;
import android.os.Build;

import java.lang.reflect.Method;

import black.android.app.ActivityThread;
import black.android.app.ApplicationPackageManager;
import black.android.app.ContextImpl;
import black.android.os.ServiceManager;
import black.android.permission.IPermissionManager;
import com.vcore.BlackBoxCore;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.service.base.PkgMethodProxy;
import com.vcore.fake.service.base.UidMethodProxy;
import com.vcore.utils.MethodParameterUtils;
import com.vcore.utils.compat.BuildCompat;

public class IPermissionManagerProxy extends BinderInvocationStub {
    public static final String TAG = "IPermissionManagerProxy";

    public IPermissionManagerProxy() {
        super(ServiceManager.getService.call("permissionmgr"));
    }

    @Override
    protected Object getWho() {
        return IPermissionManager.Stub.asInterface.call(ServiceManager.getService.call("permissionmgr"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("permissionmgr");
        ActivityThread.sPermissionManager.set(proxyInvocation);

        Object systemContext = ActivityThread.getSystemContext.call(BlackBoxCore.mainThread());
        PackageManager packageManager = ContextImpl.mPackageManager.get(systemContext);
        if (packageManager != null) {
            try {
                ApplicationPackageManager.mPermissionManager.set(packageManager, proxyInvocation);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        addMethodHook(new PkgMethodProxy("getPermissionInfo"));
        addMethodHook(new PkgMethodProxy("getPermissionFlags"));
        addMethodHook(new PkgMethodProxy("updatePermissionFlags"));
        addMethodHook(new PkgMethodProxy("grantRuntimePermission"));
        addMethodHook(new PkgMethodProxy("revokeRuntimePermission"));
        addMethodHook(new PkgMethodProxy("shouldShowRequestPermissionRationale"));
        addMethodHook(new PkgMethodProxy("isPermissionRevokedByPolicy"));
        addMethodHook(new PkgMethodProxy("startOneTimePermissionSession"));
        addMethodHook(new PkgMethodProxy("stopOneTimePermissionSession"));
        addMethodHook(new PkgMethodProxy("setAutoRevokeExempted"));
        addMethodHook(new PkgMethodProxy("isAutoRevokeExempted"));

        if (BuildCompat.isT()) {
            addMethodHook(new PkgMethodProxy("getAllowlistedRestrictedPermissions"));
            addMethodHook(new PkgMethodProxy("addAllowlistedRestrictedPermission"));
            addMethodHook(new PkgMethodProxy("removeAllowlistedRestrictedPermission"));
        } else if (Build.VERSION.SDK_INT == Build.VERSION_CODES.S) {
            addMethodHook(new PkgMethodProxy("revokePostNotificationPermissionWithoutKillForTest"));
        } else {
            addMethodHook(new PkgMethodProxy("checkPermission"));
            addMethodHook(new UidMethodProxy("checkUidPermission", 1));
            addMethodHook(new PkgMethodProxy("getWhitelistedRestrictedPermissions"));
            addMethodHook(new PkgMethodProxy("addWhitelistedRestrictedPermission"));
            addMethodHook(new PkgMethodProxy("removeWhitelistedRestrictedPermission"));
            addMethodHook(new PkgMethodProxy("setDefaultBrowser"));
            addMethodHook(new PkgMethodProxy("grantDefaultPermissionsToActiveLuiApp"));
            addMethodHook("checkDeviceIdentifierAccess", new MethodHook() {
                @Override
                protected Object hook(Object who, Method method, Object[] args) throws Throwable {
                    MethodParameterUtils.replaceFirstAppPkg(args);
                    MethodParameterUtils.replaceLastUid(args);
                    return method.invoke(who, args);
                }
            });
        }
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IPersistentDataBlockServiceProxy.java`:

```java
package com.vcore.fake.service;

import black.android.os.ServiceManager;
import black.android.service.persistentdata.IPersistentDataBlockService;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.ValueMethodProxy;

public class IPersistentDataBlockServiceProxy extends BinderInvocationStub {

    public IPersistentDataBlockServiceProxy() {
        super(ServiceManager.getService.call("persistent_data_block"));
    }

    @Override
    protected Object getWho() {
        return IPersistentDataBlockService.Stub.asInterface.call(ServiceManager.getService.call("persistent_data_block"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("persistent_data_block");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        addMethodHook(new ValueMethodProxy("write", -1));
        addMethodHook(new ValueMethodProxy("read", new byte[0]));
        addMethodHook(new ValueMethodProxy("wipe", null));
        addMethodHook(new ValueMethodProxy("getDataBlockSize", 0));
        addMethodHook(new ValueMethodProxy("getMaximumDataBlockSize", 0));
        addMethodHook(new ValueMethodProxy("setOemUnlockEnabled", 0));
        addMethodHook(new ValueMethodProxy("getOemUnlockEnabled", false));
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IPhoneSubInfoProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.util.Log;

import java.lang.reflect.Method;

import black.android.os.ServiceManager;
import black.android.telephony.TelephonyManager;
import com.vcore.BlackBoxCore;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.fake.service.base.PkgMethodProxy;
import com.vcore.utils.Md5Utils;
import com.vcore.utils.MethodParameterUtils;
import com.vcore.utils.compat.BuildCompat;

public class IPhoneSubInfoProxy extends BinderInvocationStub {
    public static final String TAG = "IPhoneSubInfoProxy";

    public IPhoneSubInfoProxy() {
        super(ServiceManager.getService.call("iphonesubinfo"));
    }

    @Override
    protected Object getWho() {
        if (BuildCompat.isR()) {
            return TelephonyManager.sIPhoneSubInfo.get();
        }
        android.telephony.TelephonyManager telephonyManager = (android.telephony.TelephonyManager) BlackBoxCore.getContext().getSystemService(Context.TELEPHONY_SERVICE);
        return TelephonyManager.getSubscriberInfo.call(telephonyManager);
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        if (BuildCompat.isR()) {
            TelephonyManager.sIPhoneSubInfo.set(proxyInvocation);
        }
        replaceSystemService("iphonesubinfo");
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Log.e(TAG, "Test");
        MethodParameterUtils.replaceLastAppPkg(args);
        return super.invoke(proxy, method, args);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new PkgMethodProxy("getNaiForSubscriber"));
        addMethodHook(new PkgMethodProxy("getDeviceSvn"));
        addMethodHook(new PkgMethodProxy("getDeviceSvnUsingSubId"));
        addMethodHook(new PkgMethodProxy("getGroupIdLevel1"));
        addMethodHook(new PkgMethodProxy("getGroupIdLevel1ForSubscriber"));
        addMethodHook(new PkgMethodProxy("getLine1AlphaTag"));
        addMethodHook(new PkgMethodProxy("getLine1AlphaTagForSubscriber"));
        addMethodHook(new PkgMethodProxy("getMsisdn"));
        addMethodHook(new PkgMethodProxy("getMsisdnForSubscriber"));
        addMethodHook(new PkgMethodProxy("getVoiceMailNumber"));
        addMethodHook(new PkgMethodProxy("getVoiceMailNumberForSubscriber"));
        addMethodHook(new PkgMethodProxy("getVoiceMailAlphaTag"));
        addMethodHook(new PkgMethodProxy("getVoiceMailAlphaTagForSubscriber"));
        addMethodHook(new PkgMethodProxy("getLine1Number"));
    }

    @ProxyMethod("getSubscriberId")
    private static class GetSubscriberId extends MethodHook{

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            try {
                if (BuildCompat.isQ()) {
                    return "unknown";
                }
                return method.invoke(who, method, args);
            } catch (Throwable th) {
                return "unknown";
            }
        }
    }


    @ProxyMethod("getLine1NumberForSubscriber")
    public static class GetLine1NumberForSubscriber extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return null;
        }
    }

    @ProxyMethod("getSubscriberIdForSubscriber")
    public static class GetSubscriberIdForSubscriber extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return Md5Utils.md5(BlackBoxCore.getHostPkg());
        }
    }

    @ProxyMethod("getIccSerialNumber")
    public static class GetIccSerialNumber extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return "89860221919704198154";
        }
    }

    @ProxyMethod("getIccSerialNumberForSubscriber")
    public static class GetIccSerialNumberForSubscriber extends GetIccSerialNumber { }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IPhysicalFlingManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.os.IBinder;

import black.android.os.ServiceManager;
import black.oem.vivo.IPhysicalFlingManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.PkgMethodProxy;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 20:11
 **/
public class IPhysicalFlingManagerProxy extends BinderInvocationStub {
    public IPhysicalFlingManagerProxy() {
        super(ServiceManager.getService.call("physical_fling_service"));
    }

    @Override
    protected Object getWho() {
        return IPhysicalFlingManager.Stub.asInterface.call(ServiceManager.getService.call("physical_fling_service"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("physical_fling_service");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new PkgMethodProxy("isSupportPhysicalFling"));
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IPopupCameraManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;

import black.android.os.ServiceManager;
import black.oem.vivo.IPopupCameraManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.PkgMethodProxy;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 20:19
 **/
public class IPopupCameraManagerProxy extends BinderInvocationStub {

    public IPopupCameraManagerProxy() {
        super(ServiceManager.getService.call("popup_camera_service"));
    }

    @Override
    protected Object getWho() {
        return IPopupCameraManager.Stub.asInterface.call(ServiceManager.getService.call("popup_camera_service"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("popup_camera_service");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new PkgMethodProxy("notifyCameraStatus"));
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IPowerManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;

import black.android.os.IPowerManager;
import black.android.os.ServiceManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.ValueMethodProxy;

public class IPowerManagerProxy extends BinderInvocationStub {
    public IPowerManagerProxy() {
        super(ServiceManager.getService.call(Context.POWER_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IPowerManager.Stub.asInterface.call(ServiceManager.getService.call(Context.POWER_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.POWER_SERVICE);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        addMethodHook(new ValueMethodProxy("acquireWakeLock", 0));
        addMethodHook(new ValueMethodProxy("acquireWakeLockWithUid", 0));
        addMethodHook(new ValueMethodProxy("releaseWakeLock", 0));
        addMethodHook(new ValueMethodProxy("updateWakeLockWorkSource", 0));
        addMethodHook(new ValueMethodProxy("isWakeLockLevelSupported", true));
        addMethodHook(new ValueMethodProxy("reboot", null));
        addMethodHook(new ValueMethodProxy("rebootSafeMode", null));
        addMethodHook(new ValueMethodProxy("shutdown", null));
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IRoleManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.os.IBinder;

import black.android.os.IPowerManager;
import black.android.os.ServiceManager;
import black.android.role.IRoleManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.PkgMethodProxy;
import com.vcore.fake.service.base.ValueMethodProxy;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 19:45
 **/
public class IRoleManagerProxy extends BinderInvocationStub {

    public IRoleManagerProxy() {
        super(ServiceManager.getService.call(Context.ROLE_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IRoleManager.Stub.asInterface.call(ServiceManager.getService.call(Context.ROLE_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.ROLE_SERVICE);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new PkgMethodProxy("isRoleHeld"));
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/ISearchManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.ComponentName;
import android.content.Context;
import android.content.pm.ActivityInfo;
import android.os.IBinder;

import java.lang.reflect.Method;

import black.android.app.ISearchManager;
import black.android.os.ServiceManager;
import black.android.role.IRoleManager;
import com.vcore.BlackBoxCore;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.service.base.PkgMethodProxy;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 19:56
 **/
public class ISearchManagerProxy extends BinderInvocationStub {

    public ISearchManagerProxy() {
        super(ServiceManager.getService.call(Context.SEARCH_SERVICE));
    }

    @Override
    protected Object getWho() {
        return ISearchManager.Stub.asInterface.call(ServiceManager.getService.call(Context.SEARCH_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("search");
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new PkgMethodProxy("launchLegacyAssist"));
    }

    private static class GetSearchableInfo extends MethodHook{

        @Override
        protected String getMethodName() {
            return "getSearchableInfo";
        }

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            ComponentName component = (ComponentName) args[0];
            if (component != null) {
                ActivityInfo activityInfo = BlackBoxCore.getPackageManager().getActivityInfo(component, 0);
                if (activityInfo != null) {
                    return null;
                }
            }
            return method.invoke(who,args);
        }
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IShortcutManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.content.Intent;
import android.content.pm.ShortcutInfo;
import android.os.Build;

import androidx.annotation.RequiresApi;

import java.lang.reflect.Method;
import java.util.ArrayList;

import black.android.content.pm.IShortcutService;
import black.android.os.ServiceManager;
import black.com.android.internal.infra.AndroidFuture;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.fake.service.base.PkgMethodProxy;
import com.vcore.utils.MethodParameterUtils;
import com.vcore.utils.compat.ParceledListSliceCompat;

public class IShortcutManagerProxy extends BinderInvocationStub {
    public IShortcutManagerProxy() {
        super(ServiceManager.getService.call(Context.SHORTCUT_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IShortcutService.Stub.asInterface.call(ServiceManager.getService.call(Context.SHORTCUT_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.SHORTCUT_SERVICE);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        MethodParameterUtils.replaceAllAppPkg(args);
        return super.invoke(proxy, method, args);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        addMethodHook(new PkgMethodProxy("getShortcuts")); //修复WhatsApp启动黑屏问题
        addMethodHook(new PkgMethodProxy("disableShortcuts"));
        addMethodHook(new PkgMethodProxy("enableShortcuts"));
        addMethodHook(new PkgMethodProxy("getRemainingCallCount"));
        addMethodHook(new PkgMethodProxy("getRateLimitResetTime"));
        addMethodHook(new PkgMethodProxy("getIconMaxDimensions"));
        addMethodHook(new PkgMethodProxy("getMaxShortcutCountPerActivity"));
        addMethodHook(new PkgMethodProxy("reportShortcutUsed"));
        addMethodHook(new PkgMethodProxy("onApplicationActive"));
        addMethodHook(new PkgMethodProxy("hasShortcutHostPermission"));
        addMethodHook(new PkgMethodProxy("removeAllDynamicShortcuts"));
        addMethodHook(new PkgMethodProxy("removeDynamicShortcuts"));
        addMethodHook(new PkgMethodProxy("removeLongLivedShortcuts"));
        addMethodHook(new WrapperShortcutInfo("pushDynamicShortcut", 1,  null));
        addMethodHook(new WrapperShortcutInfo("requestPinShortcut", 1,  false));
        addMethodHook(new WrapperShortcutInfo("addDynamicShortcuts", 1,  false));
        addMethodHook(new WrapperShortcutInfo("setDynamicShortcuts", 1,  false));
        addMethodHook(new PkgMethodProxy("getManifestShortcuts") {

            @Override
            protected Object hook(Object who, Method method, Object[] args) {
                return ParceledListSliceCompat.create(new ArrayList<ShortcutInfo>());
            }
        });
    }

    static class WrapperShortcutInfo extends MethodHook{
        private int infoIndex;
        private Object defValue;
        private String MethodName;

        public WrapperShortcutInfo(String name,int infoIndex, Object defValue) {
            this.infoIndex = infoIndex;
            this.defValue = defValue;
            this.MethodName = name;
        }


        @Override
        protected String getMethodName() {
            return MethodName;
        }

        private Object wrapperResult(Method method,Object result) {
            if (!method.toString().contains("AndroidFuture")) {
                return result;
            }
            Object ret = AndroidFuture.ctor.newInstance();
            AndroidFuture.complete.call(ret, result);
            return ret;
        }

        @RequiresApi(api = Build.VERSION_CODES.N_MR1)
        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return wrapperResult(method,defValue);
        }
    }


    @ProxyMethod("requestPinShortcut")
    public static class RequestPinShortcut extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return true;
        }
    }

    @ProxyMethod("setDynamicShortcuts")
    public static class SetDynamicShortcuts extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return true;
        }
    }

    @ProxyMethod("createShortcutResultIntent")
    public static class CreateShortcutResultIntent extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return new Intent();
        }
    }

    @ProxyMethod("getMaxShortcutCountPerActivity")
    public static class GetMaxShortcutCountPerActivity extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return 0;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IStorageManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.os.IInterface;
import android.os.storage.StorageVolume;

import java.lang.reflect.Method;

import black.android.os.ServiceManager;
import black.android.os.mount.IMountService;
import black.android.os.storage.IStorageManager;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.utils.compat.BuildCompat;

public class IStorageManagerProxy extends BinderInvocationStub {
    public IStorageManagerProxy() {
        super(ServiceManager.getService.call("mount"));
    }

    @Override
    protected Object getWho() {
        IInterface mount;
        if (BuildCompat.isOreo()) {
            mount = IStorageManager.Stub.asInterface.call(ServiceManager.getService.call("mount"));
        } else {
            mount = IMountService.Stub.asInterface.call(ServiceManager.getService.call("mount"));
        }
        return mount;
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("mount");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @ProxyMethod("getVolumeList")
    public static class GetVolumeList extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (args == null) {
                StorageVolume[] volumeList = BlackBoxCore.getBStorageManager().getVolumeList(BActivityThread.getBUid(), null, 0, BActivityThread.getUserId());
                if (volumeList == null) {
                    return method.invoke(who, args);
                }
                return volumeList;
            }

            try {
                int uid = (int) args[0];
                String packageName = (String) args[1];
                int flags = (int) args[2];

                StorageVolume[] volumeList = BlackBoxCore.getBStorageManager().getVolumeList(uid, packageName, flags, BActivityThread.getUserId());
                if (volumeList == null) {
                    return method.invoke(who, args);
                }
                return volumeList;
            } catch (Throwable t) {
                return method.invoke(who, args);
            }
        }
    }

    @ProxyMethod("mkdirs")
    public static class MkDirs extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return 0;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IStorageStatsManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;

import java.lang.reflect.Method;

import black.android.app.usage.IStorageStatsManager;
import black.android.os.ServiceManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.utils.MethodParameterUtils;

public class IStorageStatsManagerProxy extends BinderInvocationStub {
    public IStorageStatsManagerProxy() {
        super(ServiceManager.getService.call(Context.STORAGE_STATS_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IStorageStatsManager.Stub.asInterface.call(ServiceManager.getService.call(Context.STORAGE_STATS_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.STORAGE_STATS_SERVICE);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        MethodParameterUtils.replaceFirstAppPkg(args);
        MethodParameterUtils.replaceLastUid(args);
        return super.invoke(proxy, method, args);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/ISubProxy.java`:

```java
package com.vcore.fake.service;

import black.android.os.ServiceManager;
import black.com.android.internal.telephony.ISub;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.ValueMethodProxy;

public class ISubProxy extends BinderInvocationStub {
    public static final String TAG = "ISubProxy";

    public ISubProxy() {
        super(ServiceManager.getService.call("isub"));
    }

    @Override
    protected Object getWho() {
        return ISub.Stub.asInterface.call(ServiceManager.getService.call("isub"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("isub");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        super.onBindMethod();
        addMethodHook(new ValueMethodProxy("getAllSubInfoList", null));
        addMethodHook(new ValueMethodProxy("getAllSubInfoCount", -1));
        addMethodHook(new ValueMethodProxy("getActiveSubscriptionInfo", null));
        addMethodHook(new ValueMethodProxy("getActiveSubscriptionInfoForIccId", null));
        addMethodHook(new ValueMethodProxy("getActiveSubscriptionInfoForSimSlotIndex", null));
        addMethodHook(new ValueMethodProxy("getActiveSubscriptionInfoList", null));
        addMethodHook(new ValueMethodProxy("getActiveSubInfoCount", -1));
        addMethodHook(new ValueMethodProxy("getActiveSubInfoCountMax", -1));
        addMethodHook(new ValueMethodProxy("getAvailableSubscriptionInfoList", null));
        addMethodHook(new ValueMethodProxy("getAccessibleSubscriptionInfoList", null));
        addMethodHook(new ValueMethodProxy("addSubInfoRecord", -1));
        addMethodHook(new ValueMethodProxy("addSubInfo", -1));
        addMethodHook(new ValueMethodProxy("removeSubInfo", -1));
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/ISuperResolutionManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.os.IBinder;

import black.android.os.ServiceManager;
import black.oem.vivo.ISuperResolutionManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.PkgMethodProxy;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 20:26
 **/
public class ISuperResolutionManagerProxy extends BinderInvocationStub {

    public ISuperResolutionManagerProxy() {
        super(ServiceManager.getService.call("SuperResolutionManager"));
    }

    @Override
    protected Object getWho() {
        return ISuperResolutionManager.Stub.asInterface.call(ServiceManager.getService.call("SuperResolutionManager"));
    }



    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("SuperResolutionManager");
    }


    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new PkgMethodProxy("registerPackageSettingStateChangeListener"));
        addMethodHook(new PkgMethodProxy("unRegisterPackageSettingStateChangeListener"));
        addMethodHook(new PkgMethodProxy("registerSuperResolutionStateChange"));
        addMethodHook(new PkgMethodProxy("unRegisterSuperResolutionStateChange"));
        addMethodHook(new PkgMethodProxy("getPackageSettingState"));
        addMethodHook(new PkgMethodProxy("putPackageSettingState"));
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/ISystemDefenceManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.os.IBinder;

import black.android.os.ServiceManager;
import black.oem.vivo.ISystemDefenceManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.PkgMethodProxy;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 20:30
 **/
public class ISystemDefenceManagerProxy extends BinderInvocationStub {
    public ISystemDefenceManagerProxy() {
        super(ServiceManager.getService.call("system_defence_service"));
    }

    @Override
    protected Object getWho() {
        return ISystemDefenceManager.Stub.asInterface.call(ServiceManager.getService.call("system_defence_service"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("system_defence_service");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new PkgMethodProxy("checkTransitionTimoutErrorDefence"));
        addMethodHook(new PkgMethodProxy("checkSkipKilledByRemoveTask"));
        addMethodHook(new PkgMethodProxy("checkSmallIconNULLPackage"));
        addMethodHook(new PkgMethodProxy("checkDelayUpdate"));
        addMethodHook(new PkgMethodProxy("onSetActivityResumed"));
        addMethodHook(new PkgMethodProxy("checkReinstallPacakge"));
        addMethodHook(new PkgMethodProxy("reportFgCrashData"));
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/ISystemUpdateProxy.java`:

```java
package com.vcore.fake.service;

import black.android.os.ServiceManager;
import black.android.view.IAutoFillManager;
import com.vcore.fake.hook.BinderInvocationStub;

public class ISystemUpdateProxy extends BinderInvocationStub {
    public ISystemUpdateProxy() {
        super(ServiceManager.getService.call("system_update"));
    }

    @Override
    protected Object getWho() {
        return IAutoFillManager.Stub.asInterface.call(ServiceManager.getService.call("system_update"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("system_update");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/ITelephonyManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.util.Log;

import java.lang.reflect.Method;

import black.android.os.ServiceManager;
import black.com.android.internal.telephony.ITelephony;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.entity.location.BCell;
import com.vcore.fake.frameworks.BLocationManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.utils.Md5Utils;

public class ITelephonyManagerProxy extends BinderInvocationStub {
    public static final String TAG = "ITelephonyManagerProxy";

    public ITelephonyManagerProxy() {
        super(ServiceManager.getService.call(Context.TELEPHONY_SERVICE));
    }

    @Override
    protected Object getWho() {
        return ITelephony.Stub.asInterface.call(ServiceManager.getService.call(Context.TELEPHONY_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.TELEPHONY_SERVICE);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }


    @ProxyMethod("getDeviceId")
    public static class GetDeviceId extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return Md5Utils.md5(BlackBoxCore.getHostPkg());
        }
    }

    @ProxyMethod("getImeiForSlot")
    public static class GetImeiForSlot extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return Md5Utils.md5(BlackBoxCore.getHostPkg());
        }
    }

    @ProxyMethod("getMeidForSlot")
    public static class GetMeidForSlot extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return Md5Utils.md5(BlackBoxCore.getHostPkg());
        }
    }

    @ProxyMethod("isUserDataEnabled")
    public static class IsUserDataEnabled extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return true;
        }
    }

    @ProxyMethod("getLine1NumberForDisplay")
    public static class GetLine1NumberForDisplay extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return null;
        }
    }

    @ProxyMethod("getSubscriberId")
    public static class GetSubscriberId extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return Md5Utils.md5(BlackBoxCore.getHostPkg());
        }
    }

    @ProxyMethod("getDeviceIdWithFeature")
    public static class GetDeviceIdWithFeature extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return Md5Utils.md5(BlackBoxCore.getHostPkg());
        }
    }

    @ProxyMethod("getCellLocation")
    public static class GetCellLocation extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Log.d(TAG, "getCellLocation");
            if (BLocationManager.isFakeLocationEnable()) {
                BCell cell = BLocationManager.get().getCell(BActivityThread.getUserId(), BActivityThread.getAppPackageName());
                if (cell != null) {
                    // TODO: Transfer BCell to CdmaCellLocation/GsmCellLocation
                    return null;
                }
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getAllCellInfo")
    public static class GetAllCellInfo extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Log.d(TAG, "GetAllCellInfo");
            if (BLocationManager.isFakeLocationEnable()) {
                // TODO: Transfer BCell to CdmaCellLocation/GsmCellLocation
                return BLocationManager.get().getAllCell(BActivityThread.getUserId(), BActivityThread.getAppPackageName());
            }

            try {
                return method.invoke(who, args);
            } catch (Throwable e) {
                return null;
            }
        }
    }

    @ProxyMethod("getNetworkOperator")
    public static class GetNetworkOperator extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Log.d(TAG, "getNetworkOperator");
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getNetworkTypeForSubscriber")
    public static class GetNetworkTypeForSubscriber extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            try {
                return method.invoke(who, args);
            } catch (Throwable e) {
                return 0;
            }
        }
    }

    @ProxyMethod("getNeighboringCellInfo")
    public static class GetNeighboringCellInfo extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Log.d(TAG, "getNeighboringCellInfo");
            if (BLocationManager.isFakeLocationEnable()) {
                // TODO: Transfer BCell to CdmaCellLocation/GsmCellLocation
                return BLocationManager.get().getNeighboringCell(BActivityThread.getUserId(), BActivityThread.getAppPackageName());
            }
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/ITelephonyRegistryProxy.java`:

```java
package com.vcore.fake.service;

import java.lang.reflect.Method;

import black.android.os.ServiceManager;
import black.com.android.internal.telephony.ITelephonyRegistry;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.utils.MethodParameterUtils;

public class ITelephonyRegistryProxy extends BinderInvocationStub {
    public ITelephonyRegistryProxy() {
        super(ServiceManager.getService.call("telephony.registry"));
    }

    @Override
    protected Object getWho() {
        return ITelephonyRegistry.Stub.asInterface.call(ServiceManager.getService.call("telephony.registry"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("telephony.registry");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @ProxyMethod("listenForSubscriber")
    public static class ListenForSubscriber extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceFirstAppPkg(args);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("listen")
    public static class Listen extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceFirstAppPkg(args);
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IUserManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;

import java.lang.reflect.Method;
import java.util.ArrayList;

import black.android.content.pm.UserInfo;
import black.android.os.IUserManager;
import black.android.os.ServiceManager;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.fake.service.base.PkgMethodProxy;
import com.vcore.fake.service.base.ValueMethodProxy;

public class IUserManagerProxy extends BinderInvocationStub {
    public IUserManagerProxy() {
        super(ServiceManager.getService.call(Context.USER_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IUserManager.Stub.asInterface.call(ServiceManager.getService.call(Context.USER_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.USER_SERVICE);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new ValueMethodProxy("getProfileParent",null));
        addMethodHook(new ValueMethodProxy("getUserIcon",null));
        addMethodHook(new ValueMethodProxy("getDefaultGuestRestrictions",null));
        addMethodHook(new ValueMethodProxy("setDefaultGuestRestrictions",null));
        addMethodHook(new ValueMethodProxy("removeRestrictions",null));
        addMethodHook(new ValueMethodProxy("createUser",null));
        addMethodHook(new ValueMethodProxy("createProfileForUser",null));
    }

    @ProxyMethod("getApplicationRestrictions")
    public static class GetApplicationRestrictions extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            args[0] = BlackBoxCore.getHostPkg();
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("getProfileParent")
    public static class GetProfileParent extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return UserInfo._new.newInstance(BActivityThread.getUserId(), "BlackBox", UserInfo.FLAG_PRIMARY);
        }
    }

    @ProxyMethod("getUsers")
    public static class GetUsers extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return new ArrayList<>();
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IVibratorServiceProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.os.IBinder;

import java.lang.reflect.Method;

import black.android.os.IVibratorManagerService;
import black.android.os.ServiceManager;
import black.com.android.internal.os.IVibratorService;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.utils.MethodParameterUtils;
import com.vcore.utils.compat.BuildCompat;

public class IVibratorServiceProxy extends BinderInvocationStub {
    private static final String NAME;

    static {
        if (BuildCompat.isS()) {
            NAME = "vibrator_manager";
        } else {
            NAME = Context.VIBRATOR_SERVICE;
        }
    }

    public IVibratorServiceProxy() {
        super(ServiceManager.getService.call(NAME));
    }

    @Override
    protected Object getWho() {
        IBinder service = ServiceManager.getService.call(NAME);
        if (BuildCompat.isS()) {
            return IVibratorManagerService.Stub.asInterface.call(service);
        }
        return IVibratorService.Stub.asInterface.call(service);
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(NAME);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        MethodParameterUtils.replaceFirstUid(args);
        MethodParameterUtils.replaceFirstAppPkg(args);
        return super.invoke(proxy, method, args);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IVivoPermissionServiceProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.os.IBinder;

import black.android.os.ServiceManager;
import black.oem.vivo.IVivoPermissonService;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.service.base.PkgMethodProxy;

/**
 * @author Findger
 * @function
 * @date :2023/10/8 20:36
 **/
public class IVivoPermissionServiceProxy extends BinderInvocationStub {
    public IVivoPermissionServiceProxy() {
        super(ServiceManager.getService.call("vivo_permission_service"));
    }

    @Override
    protected Object getWho() {
        return IVivoPermissonService.Stub.asInterface.call(ServiceManager.getService.call("vivo_permission_service"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("vivo_permission_service");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new PkgMethodProxy("checkPermission"));
        addMethodHook(new PkgMethodProxy("getAppPermission"));
        addMethodHook(new PkgMethodProxy("setAppPermission"));
        addMethodHook(new PkgMethodProxy("setWhiteListApp"));
        addMethodHook(new PkgMethodProxy("setBlackListApp"));
        addMethodHook(new PkgMethodProxy("noteStartActivityProcess"));
        addMethodHook(new PkgMethodProxy("isBuildInThirdPartApp"));
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IVpnManagerProxy.java`:

```java
package com.vcore.fake.service;

import black.android.net.IVpnManager;
import black.android.os.ServiceManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.ScanClass;

@ScanClass(VpnCommonProxy.class)
public class IVpnManagerProxy extends BinderInvocationStub {
    public static final String TAG = "IVpnManagerProxy";

    public IVpnManagerProxy() {
        super(ServiceManager.getService.call("vpn_management"));
    }

    @Override
    protected Object getWho() {
        return IVpnManager.Stub.asInterface.call(ServiceManager.getService.call("vpn_management"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("vpn_management");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IWifiManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiInfo;
import android.util.Log;

import java.lang.reflect.Method;
import java.util.ArrayList;

import black.android.net.wifi.IWifiManager;
import black.android.net.wifi.WifiSsid;
import black.android.os.ServiceManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;

public class IWifiManagerProxy extends BinderInvocationStub {
    public static final String TAG = "IWifiManagerProxy";

    public IWifiManagerProxy() {
        super(ServiceManager.getService.call(Context.WIFI_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IWifiManager.Stub.asInterface.call(ServiceManager.getService.call(Context.WIFI_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.WIFI_SERVICE);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @Override
    protected void onBindMethod() {
        addMethodHook(new GetConnectionInfo());
        addMethodHook(new GetScanResults());
    }

    @ProxyMethod("getConnectionInfo")
    public static class GetConnectionInfo extends MethodHook {
        /*
         * It doesn't have public method to set BSSID and SSID fields in WifiInfo class,
         * So the reflection framework invocation appeared.
         * commented by BlackBoxing at 2022/03/08
         */
        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            WifiInfo wifiInfo = (WifiInfo) method.invoke(who, args);
            black.android.net.wifi.WifiInfo.mBSSID.set(wifiInfo, "ac:62:5a:82:65:c4");
            black.android.net.wifi.WifiInfo.mMacAddress.set(wifiInfo, "ac:62:5a:82:65:c4");
            black.android.net.wifi.WifiInfo.mWifiSsid.set(wifiInfo, WifiSsid.createFromAsciiEncoded.call("BlackBox_Wifi"));
            return wifiInfo;
        }
    }

    @ProxyMethod("getScanResults")
    public static class GetScanResults extends MethodHook {
        /*
         * It doesn't have public method to set BSSID and SSID fields in WifiInfo class,
         * So the reflection framework invocation appeared.
         * commented by BlackBoxing at 2022/03/08
         */
        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Log.d(TAG, "GetScanResults");
            return new ArrayList<ScanResult>();
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IWifiScannerProxy.java`:

```java
package com.vcore.fake.service;

import black.android.net.wifi.IWifiManager;
import black.android.os.ServiceManager;
import com.vcore.fake.hook.BinderInvocationStub;

public class IWifiScannerProxy extends BinderInvocationStub {
    public IWifiScannerProxy() {
        super(ServiceManager.getService.call("wifiscanner"));
    }

    @Override
    protected Object getWho() {
        return IWifiManager.Stub.asInterface.call(ServiceManager.getService.call("wifiscanner"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("wifiscanner");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IWindowManagerProxy.java`:

```java
package com.vcore.fake.service;

import android.content.Context;
import android.os.IInterface;

import java.lang.reflect.Method;
import java.util.Objects;

import black.android.os.ServiceManager;
import black.android.view.IWindowManager;
import black.android.view.WindowManagerGlobal;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;

public class IWindowManagerProxy extends BinderInvocationStub {
    public static final String TAG = "WindowManagerStub";

    public IWindowManagerProxy() {
        super(ServiceManager.getService.call(Context.WINDOW_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IWindowManager.Stub.asInterface.call(ServiceManager.getService.call(Context.WINDOW_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.WINDOW_SERVICE);
        WindowManagerGlobal.sWindowManagerService.set(null);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }


    @ProxyMethod("openSession")
    public static class OpenSession extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            IInterface session = (IInterface) method.invoke(who, args);
            IWindowSessionProxy IWindowSessionProxy = new IWindowSessionProxy(Objects.requireNonNull(session));
            IWindowSessionProxy.injectHook();
            return IWindowSessionProxy.getProxyInvocation();
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/IWindowSessionProxy.java`:

```java
package com.vcore.fake.service;

import android.os.IInterface;
import android.view.WindowManager;

import java.lang.reflect.Method;

import com.vcore.BlackBoxCore;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;

public class IWindowSessionProxy extends BinderInvocationStub {
    public static final String TAG = "WindowSessionStub";
    private final IInterface mSession;

    public IWindowSessionProxy(IInterface session) {
        super(session.asBinder());
        this.mSession = session;
    }

    @Override
    protected Object getWho() {
        return mSession;
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) { }

    @Override
    public boolean isBadEnv() {
        return false;
    }


    @ProxyMethod("addToDisplay")
    public static class AddToDisplay extends MethodHook {
        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            for (Object arg : args) {
                if (arg == null) {
                    continue;
                }

                if (arg instanceof WindowManager.LayoutParams) {
                    ((WindowManager.LayoutParams) arg).packageName = BlackBoxCore.getHostPkg();
                }
            }
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("addToDisplayAsUser")
    public static class AddToDisplayAsUser extends AddToDisplay { }
}

```

`Bcore/src/main/java/com/vcore/fake/service/VpnCommonProxy.java`:

```java
package com.vcore.fake.service;

import java.lang.reflect.Method;
import java.util.List;

import black.com.android.internal.net.VpnConfig;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.proxy.ProxyVpnService;
import com.vcore.utils.MethodParameterUtils;

public class VpnCommonProxy {
    @ProxyMethod("setVpnPackageAuthorization")
    public static class SetVpnPackageAuthorization extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceFirstAppPkg(args);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("prepareVpn")
    public static class PrepareVpn extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            MethodParameterUtils.replaceFirstAppPkg(args);
            return method.invoke(who, args);
        }
    }

    @ProxyMethod("establishVpn")
    public static class EstablishVpn extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            VpnConfig.user.set(args[0], ProxyVpnService.class.getName());

            handlePackage(VpnConfig.allowedApplications.get());
            handlePackage(VpnConfig.disallowedApplications.get());
            return method.invoke(who, args);
        }

        private void handlePackage(List<String> applications) {
            if (applications == null) {
                return;
            }

            if (applications.contains(BActivityThread.getAppPackageName())) {
                applications.add(BlackBoxCore.getHostPkg());
            }
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/base/PkgMethodProxy.java`:

```java
package com.vcore.fake.service.base;

import java.lang.reflect.Method;

import com.vcore.fake.hook.MethodHook;
import com.vcore.utils.MethodParameterUtils;

public class PkgMethodProxy extends MethodHook {
	final String mName;

	public PkgMethodProxy(String name) {
		this.mName = name;
	}

	@Override
	protected String getMethodName() {
		return mName;
	}

	@Override
	protected Object hook(Object who, Method method, Object[] args) throws Throwable {
		MethodParameterUtils.replaceFirstAppPkg(args);
		return method.invoke(who, args);
	}
}

```

`Bcore/src/main/java/com/vcore/fake/service/base/UidMethodProxy.java`:

```java
package com.vcore.fake.service.base;

import java.lang.reflect.Method;

import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.fake.hook.MethodHook;

public class UidMethodProxy extends MethodHook {
    private final int index;
    private final String name;

    public UidMethodProxy(String name, int index) {
        this.index = index;
        this.name = name;
    }

    @Override
    protected String getMethodName() {
        return name;
    }

    @Override
    protected Object hook(Object who, Method method, Object[] args) throws Throwable {
        int uid = (int) args[index];
        if (uid == BActivityThread.getBUid()) {
            args[index] = BlackBoxCore.getHostUid();
        }
        return method.invoke(who, args);
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/base/ValueMethodProxy.java`:

```java
package com.vcore.fake.service.base;

import java.lang.reflect.Method;

import com.vcore.fake.hook.MethodHook;

public class ValueMethodProxy extends MethodHook {
	final Object mValue;
	final String mName;

	public ValueMethodProxy(String name, Object value) {
		this.mValue = value;
		this.mName = name;
	}

	@Override
	protected String getMethodName() {
		return mName;
	}

	@Override
	protected Object hook(Object who, Method method, Object[] args) throws Throwable {
		return mValue;
	}
}

```

`Bcore/src/main/java/com/vcore/fake/service/context/ContentServiceProxy.java`:

```java
package com.vcore.fake.service.context;

import java.lang.reflect.Method;

import black.android.content.IContentService;
import black.android.os.ServiceManager;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;

public class ContentServiceProxy extends BinderInvocationStub {
    public ContentServiceProxy() {
        super(ServiceManager.getService.call("content"));
    }

    @Override
    protected Object getWho() {
        return IContentService.Stub.asInterface.call(ServiceManager.getService.call("content"));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService("content");
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @ProxyMethod("registerContentObserver")
    public static class RegisterContentObserver extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return 0;
        }
    }

    @ProxyMethod("notifyChange")
    public static class NotifyChange extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            return 0;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/context/LocationListenerProxy.java`:

```java
package com.vcore.fake.service.context;

import android.location.Location;

import java.lang.reflect.Method;
import java.util.List;

import com.vcore.app.BActivityThread;
import com.vcore.fake.frameworks.BLocationManager;
import com.vcore.fake.hook.ClassInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;

public class LocationListenerProxy extends ClassInvocationStub {
    public static final String TAG = "LocationListenerProxy";
    private Object mBase;

    public Object wrapper(final Object locationListenerProxy) {
        mBase = locationListenerProxy;
        injectHook();
        return getProxyInvocation();
    }

    @Override
    protected Object getWho() {
        return mBase;
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) { }

    @ProxyMethod("onLocationChanged")
    public static class OnLocationChanged extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            if (args[0] instanceof List) {
                List<Location> locations = (List<Location>) args[0];
                locations.clear();
                locations.add(BLocationManager.get().getLocation(BActivityThread.getUserId(), BActivityThread.getAppPackageName()).convert2SystemLocation());
                args[0] = locations;
            } else if (args[0] instanceof Location) {
                args[0] = BLocationManager.get().getLocation(BActivityThread.getUserId(), BActivityThread.getAppPackageName()).convert2SystemLocation();
            }
            return method.invoke(who, args);
        }
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/context/RestrictionsManagerProxy.java`:

```java
package com.vcore.fake.service.context;

import android.content.Context;

import java.lang.reflect.Method;

import black.android.content.IRestrictionsManager;
import black.android.os.ServiceManager;
import com.vcore.BlackBoxCore;
import com.vcore.fake.hook.BinderInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;

public class RestrictionsManagerProxy extends BinderInvocationStub {
    public RestrictionsManagerProxy() {
        super(ServiceManager.getService.call(Context.RESTRICTIONS_SERVICE));
    }

    @Override
    protected Object getWho() {
        return IRestrictionsManager.Stub.asInterface.call(ServiceManager.getService.call(Context.RESTRICTIONS_SERVICE));
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        replaceSystemService(Context.RESTRICTIONS_SERVICE);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }

    @ProxyMethod("getApplicationRestrictions")
    public static class GetApplicationRestrictions extends MethodHook {
        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            args[0] = BlackBoxCore.getHostPkg();
            return method.invoke(who, args);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/context/providers/BContentProvider.java`:

```java
package com.vcore.fake.service.context.providers;

import android.os.IInterface;

public interface BContentProvider {
    IInterface wrapper(final IInterface contentProviderProxy, final String appPkg);
}

```

`Bcore/src/main/java/com/vcore/fake/service/context/providers/ContentProviderStub.java`:

```java
package com.vcore.fake.service.context.providers;

import android.os.Build;
import android.os.Bundle;
import android.os.IInterface;

import java.lang.reflect.Method;

import black.android.content.AttributionSource;
import com.vcore.app.BActivityThread;
import com.vcore.fake.hook.ClassInvocationStub;
import com.vcore.utils.compat.ContextCompat;

public class ContentProviderStub extends ClassInvocationStub implements BContentProvider {
    public static final String TAG = "ContentProviderStub";
    private IInterface mBase;
    private String mAppPkg;

    public IInterface wrapper(final IInterface contentProviderProxy, final String appPkg) {
        mBase = contentProviderProxy;
        mAppPkg = appPkg;

        injectHook();
        return (IInterface) getProxyInvocation();
    }

    private Bundle wrapBundle(String name, String value) {
        Bundle bundle = new Bundle();
        if (Build.VERSION.SDK_INT >= 24) {
            bundle.putString("name", name);
            bundle.putString("value", value);
        } else {
            bundle.putString(name, value);
        }
        return bundle;
    }

    @Override
    protected Object getWho() {
        return mBase;
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) { }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if ("asBinder".equals(method.getName())) {
            return method.invoke(mBase, args);
        }
        if (args != null && args.length > 0) {
            Object arg = args[0];
            if (arg instanceof String) {
                args[0] = mAppPkg;
                if ("android_id".equals(arg)) {
                    return wrapBundle("android_id", "");
                }
            } else if (arg.getClass().getName().equals(AttributionSource.REF.getClazz().getName())) {
                ContextCompat.fixAttributionSourceState(arg, BActivityThread.getBUid());
            }
        }
        return method.invoke(mBase, args);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/context/providers/SystemProviderStub.java`:

```java
package com.vcore.fake.service.context.providers;

import android.os.IInterface;

import java.lang.reflect.Method;

import black.android.content.AttributionSource;
import com.vcore.BlackBoxCore;
import com.vcore.fake.hook.ClassInvocationStub;
import com.vcore.utils.compat.ContextCompat;

public class SystemProviderStub extends ClassInvocationStub implements BContentProvider {
    public static final String TAG = "SystemProviderStub";
    private IInterface mBase;
    private String mAppPkg;

    @Override
    public IInterface wrapper(IInterface contentProviderProxy, String appPkg) {
        mBase = contentProviderProxy;
        mAppPkg = appPkg;

        injectHook();
        return (IInterface) getProxyInvocation();
    }


    @Override
    protected Object getWho() {
        return mBase;
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) { }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if ("asBinder".equals(method.getName())) {
            return method.invoke(mBase, args);
        }

        if (args != null && args.length > 0) {
            Object arg = args[0];
            if (arg instanceof String) {
                args[0] = mAppPkg;
            } else if (arg.getClass().getName().equals(AttributionSource.REF.getClazz().getName())) {
                ContextCompat.fixAttributionSourceState(arg, BlackBoxCore.getHostUid());
            }
        }
        return method.invoke(mBase, args);
    }

    @Override
    public boolean isBadEnv() {
        return false;
    }
}

```

`Bcore/src/main/java/com/vcore/fake/service/libcore/OsProxy.java`:

```java
package com.vcore.fake.service.libcore;

import android.os.Process;

import java.lang.reflect.Method;
import java.util.Objects;

import black.Reflector;
import black.libcore.io.Libcore;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.fake.hook.ClassInvocationStub;
import com.vcore.fake.hook.MethodHook;
import com.vcore.fake.hook.ProxyMethod;
import com.vcore.fake.hook.ProxyMethods;

public class OsProxy extends ClassInvocationStub {
    public static final String TAG = "OsProxy";
    private final Object mBase;

    public OsProxy() {
        this.mBase = Libcore.os.get();
    }

    @Override
    protected Object getWho() {
        return mBase;
    }

    @Override
    protected void inject(Object baseInvocation, Object proxyInvocation) {
        Libcore.os.set(proxyInvocation);
    }

    @Override
    public boolean isBadEnv() {
        return Libcore.os.get() != getProxyInvocation();
    }

    @ProxyMethod("getuid")
    public static class GetUID extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            int callUid = (int) method.invoke(who, args);
            return getFakeUid(callUid);
        }
    }

    @ProxyMethods({"lstat", "stat"})
    public static class Stat extends MethodHook {

        @Override
        protected Object hook(Object who, Method method, Object[] args) throws Throwable {
            Object invoke;
            try {
                invoke = method.invoke(who, args);
            } catch (Throwable e) {
                throw Objects.requireNonNull(e.getCause());
            }

            Reflector.on("android.system.StructStat")
                    .field("st_uid").set(invoke, getFakeUid(-1));
            return invoke;
        }
    }

    private static int getFakeUid(int callUid) {
        if (callUid > 0 && callUid <= Process.FIRST_APPLICATION_UID) {
            return callUid;
        }

        if (BActivityThread.isThreadInit() && BActivityThread.currentActivityThread().isInit()) {
            return BActivityThread.getBAppId();
        }
        return BlackBoxCore.getHostUid();
    }
}

```

`Bcore/src/main/java/com/vcore/jnihook/JniHook.java`:

```java
package com.vcore.jnihook;

public final class JniHook {
    public static final int NATIVE_OFFSET = 0;

    public static final int NATIVE_OFFSET_2 = 0;

    public static native void nativeOffset();

    public static native void nativeOffset2();
}

```

`Bcore/src/main/java/com/vcore/jnihook/MethodUtils.java`:

```java
package com.vcore.jnihook;

import androidx.annotation.Keep;

import java.lang.reflect.Method;
import java.util.Objects;

@Keep
public class MethodUtils {
    // native call
    public static String getDeclaringClass(final Method method) {
        return method.getDeclaringClass().getName().replace(".", "/");
    }

    // native call
    public static String getMethodName(final Method method) {
        return method.getName();
    }

    // native call
    public static String getDesc(final Method method) {
        final StringBuilder buf = new StringBuilder();
        buf.append("(");

        final Class<?>[] types = method.getParameterTypes();
        for (Class<?> type : types) {
            buf.append(getDesc(type));
        }

        buf.append(")");
        buf.append(getDesc(method.getReturnType()));
        return buf.toString();
    }

    private static String getDesc(final Class<?> returnType) {
        if (returnType.isPrimitive()) {
            return getPrimitiveLetter(returnType);
        }

        if (returnType.isArray()) {
            return "[" + getDesc(Objects.requireNonNull(returnType.getComponentType()));
        }
        return "L" + getType(returnType) + ";";
    }

    private static String getType(final Class<?> parameterType) {
        if (parameterType.isArray()) {
            return "[" + getDesc(Objects.requireNonNull(parameterType.getComponentType()));
        }

        if (!parameterType.isPrimitive()) {
            final String clsName = parameterType.getName();
            return clsName.replaceAll("\\.", "/");
        }
        return getPrimitiveLetter(parameterType);
    }

    private static String getPrimitiveLetter(final Class<?> type) {
        if (Integer.TYPE.equals(type)) {
            return "I";
        }

        if (Void.TYPE.equals(type)) {
            return "V";
        }

        if (Boolean.TYPE.equals(type)) {
            return "Z";
        }

        if (Character.TYPE.equals(type)) {
            return "C";
        }

        if (Byte.TYPE.equals(type)) {
            return "B";
        }

        if (Short.TYPE.equals(type)) {
            return "S";
        }

        if (Float.TYPE.equals(type)) {
            return "F";
        }

        if (Long.TYPE.equals(type)) {
            return "J";
        }

        if (Double.TYPE.equals(type)) {
            return "D";
        }
        throw new IllegalStateException("Type: " + type.getCanonicalName() + " is not a primitive type");
    }
}

```

`Bcore/src/main/java/com/vcore/proxy/ProxyActivity.java`:

```java
package com.vcore.proxy;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;

import androidx.annotation.Nullable;

import com.vcore.app.BActivityThread;
import com.vcore.fake.hook.HookManager;
import com.vcore.fake.service.HCallbackProxy;
import com.vcore.proxy.record.ProxyActivityRecord;

public class ProxyActivity extends Activity {
    public static final String TAG = "ProxyActivity";

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d(TAG, "onCreate");
        finish();

        HookManager.get().checkEnv(HCallbackProxy.class);
        ProxyActivityRecord record = ProxyActivityRecord.create(getIntent());
        if (record.mTarget != null) {
            record.mTarget.setExtrasClassLoader(BActivityThread.getApplication().getClassLoader());
            startActivity(record.mTarget);
        }
    }

    public static class P0 extends ProxyActivity { }

    public static class P1 extends ProxyActivity { }

    public static class P2 extends ProxyActivity { }

    public static class P3 extends ProxyActivity { }

    public static class P4 extends ProxyActivity { }

    public static class P5 extends ProxyActivity { }

    public static class P6 extends ProxyActivity { }

    public static class P7 extends ProxyActivity { }

    public static class P8 extends ProxyActivity { }

    public static class P9 extends ProxyActivity { }

    public static class P10 extends ProxyActivity { }

    public static class P11 extends ProxyActivity { }

    public static class P12 extends ProxyActivity { }

    public static class P13 extends ProxyActivity { }

    public static class P14 extends ProxyActivity { }

    public static class P15 extends ProxyActivity { }

    public static class P16 extends ProxyActivity { }

    public static class P17 extends ProxyActivity { }

    public static class P18 extends ProxyActivity { }

    public static class P19 extends ProxyActivity { }

    public static class P20 extends ProxyActivity { }

    public static class P21 extends ProxyActivity { }

    public static class P22 extends ProxyActivity { }

    public static class P23 extends ProxyActivity { }

    public static class P24 extends ProxyActivity { }

    public static class P25 extends ProxyActivity { }

    public static class P26 extends ProxyActivity { }

    public static class P27 extends ProxyActivity { }

    public static class P28 extends ProxyActivity { }

    public static class P29 extends ProxyActivity { }

    public static class P30 extends ProxyActivity { }

    public static class P31 extends ProxyActivity { }

    public static class P32 extends ProxyActivity { }

    public static class P33 extends ProxyActivity { }

    public static class P34 extends ProxyActivity { }

    public static class P35 extends ProxyActivity { }

    public static class P36 extends ProxyActivity { }

    public static class P37 extends ProxyActivity { }

    public static class P38 extends ProxyActivity { }

    public static class P39 extends ProxyActivity { }

    public static class P40 extends ProxyActivity { }

    public static class P41 extends ProxyActivity { }

    public static class P42 extends ProxyActivity { }

    public static class P43 extends ProxyActivity { }

    public static class P44 extends ProxyActivity { }

    public static class P45 extends ProxyActivity { }

    public static class P46 extends ProxyActivity { }

    public static class P47 extends ProxyActivity { }

    public static class P48 extends ProxyActivity { }

    public static class P49 extends ProxyActivity { }
}

```

`Bcore/src/main/java/com/vcore/proxy/ProxyBroadcastReceiver.java`:

```java
package com.vcore.proxy;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.RemoteException;

import com.vcore.BlackBoxCore;
import com.vcore.entity.am.PendingResultData;
import com.vcore.proxy.record.ProxyBroadcastRecord;

public class ProxyBroadcastReceiver extends BroadcastReceiver {
    public static final String TAG = "ProxyBroadcastReceiver";

    @Override
    public void onReceive(Context context, Intent intent) {
        intent.setExtrasClassLoader(context.getClassLoader());
        ProxyBroadcastRecord record = ProxyBroadcastRecord.create(intent);
        if (record.mIntent == null) {
            return;
        }

        PendingResult pendingResult = goAsync();
        try {
            BlackBoxCore.getBActivityManager().scheduleBroadcastReceiver(record.mIntent, new PendingResultData(pendingResult), record.mUserId);
        } catch (RemoteException e) {
            pendingResult.finish();
        }
    }
}
```

`Bcore/src/main/java/com/vcore/proxy/ProxyContentProvider.java`:

```java
package com.vcore.proxy;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.vcore.app.BActivityThread;
import com.vcore.entity.AppConfig;
import com.vcore.utils.compat.BundleCompat;

public class ProxyContentProvider extends ContentProvider {
    public static final String TAG = "ProxyContentProvider";

    @Override
    public boolean onCreate() {
        return false;
    }

    @Nullable
    @Override
    public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) {
        if (method.equals("_Black_|_init_process_")) {
            assert extras != null;
            extras.setClassLoader(AppConfig.class.getClassLoader());
            AppConfig appConfig = extras.getParcelable(AppConfig.KEY);
            BActivityThread.currentActivityThread().initProcess(appConfig);

            Bundle bundle = new Bundle();
            BundleCompat.putBinder(bundle, "_Black_|_client_", BActivityThread.currentActivityThread());
            return bundle;
        }
        return super.call(method, arg, extras);
    }

    @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {
        Log.d(TAG, uri.toString());
        return null;
    }

    @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        Log.d(TAG, uri.toString());
        return null;
    }

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
        Log.d(TAG, uri.toString());
        return null;
    }

    @Override
    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {
        Log.d(TAG, uri.toString());
        return 0;
    }

    @Override
    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {
        Log.d(TAG, uri.toString());
        return 0;
    }

    public static class P0 extends ProxyContentProvider { }

    public static class P1 extends ProxyContentProvider { }

    public static class P2 extends ProxyContentProvider { }

    public static class P3 extends ProxyContentProvider { }

    public static class P4 extends ProxyContentProvider { }

    public static class P5 extends ProxyContentProvider { }

    public static class P6 extends ProxyContentProvider { }

    public static class P7 extends ProxyContentProvider { }

    public static class P8 extends ProxyContentProvider { }

    public static class P9 extends ProxyContentProvider { }

    public static class P10 extends ProxyContentProvider { }

    public static class P11 extends ProxyContentProvider { }

    public static class P12 extends ProxyContentProvider { }

    public static class P13 extends ProxyContentProvider { }

    public static class P14 extends ProxyContentProvider { }

    public static class P15 extends ProxyContentProvider { }

    public static class P16 extends ProxyContentProvider { }

    public static class P17 extends ProxyContentProvider { }

    public static class P18 extends ProxyContentProvider { }

    public static class P19 extends ProxyContentProvider { }

    public static class P20 extends ProxyContentProvider { }

    public static class P21 extends ProxyContentProvider { }

    public static class P22 extends ProxyContentProvider { }

    public static class P23 extends ProxyContentProvider { }

    public static class P24 extends ProxyContentProvider { }

    public static class P25 extends ProxyContentProvider { }

    public static class P26 extends ProxyContentProvider { }

    public static class P27 extends ProxyContentProvider { }

    public static class P28 extends ProxyContentProvider { }

    public static class P29 extends ProxyContentProvider { }

    public static class P30 extends ProxyContentProvider { }

    public static class P31 extends ProxyContentProvider { }

    public static class P32 extends ProxyContentProvider { }

    public static class P33 extends ProxyContentProvider { }

    public static class P34 extends ProxyContentProvider { }

    public static class P35 extends ProxyContentProvider { }

    public static class P36 extends ProxyContentProvider { }

    public static class P37 extends ProxyContentProvider { }

    public static class P38 extends ProxyContentProvider { }

    public static class P39 extends ProxyContentProvider { }

    public static class P40 extends ProxyContentProvider { }

    public static class P41 extends ProxyContentProvider { }

    public static class P42 extends ProxyContentProvider { }

    public static class P43 extends ProxyContentProvider { }

    public static class P44 extends ProxyContentProvider { }

    public static class P45 extends ProxyContentProvider { }

    public static class P46 extends ProxyContentProvider { }

    public static class P47 extends ProxyContentProvider { }

    public static class P48 extends ProxyContentProvider { }

    public static class P49 extends ProxyContentProvider { }
}

```

`Bcore/src/main/java/com/vcore/proxy/ProxyJobService.java`:

```java
package com.vcore.proxy;

import android.app.job.JobParameters;
import android.app.job.JobService;
import android.content.Intent;
import android.content.res.Configuration;

import com.vcore.app.dispatcher.AppJobServiceDispatcher;

public class ProxyJobService extends JobService {
    public static final String TAG = "StubJobService";

    @Override
    public boolean onStartJob(JobParameters params) {
        return AppJobServiceDispatcher.get().onStartJob(params);
    }

    @Override
    public boolean onStopJob(JobParameters params) {
        return AppJobServiceDispatcher.get().onStopJob(params);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return START_NOT_STICKY;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        AppJobServiceDispatcher.get().onDestroy();
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        AppJobServiceDispatcher.get().onConfigurationChanged(newConfig);
    }

    @Override
    public void onLowMemory() {
        super.onLowMemory();
        AppJobServiceDispatcher.get().onLowMemory();
    }

    @Override
    public void onTrimMemory(int level) {
        super.onTrimMemory(level);
        AppJobServiceDispatcher.get().onTrimMemory(level);
    }

    public static class P0 extends ProxyJobService { }

    public static class P1 extends ProxyJobService { }

    public static class P2 extends ProxyJobService { }

    public static class P3 extends ProxyJobService { }

    public static class P4 extends ProxyJobService { }

    public static class P5 extends ProxyJobService { }

    public static class P6 extends ProxyJobService { }

    public static class P7 extends ProxyJobService { }

    public static class P8 extends ProxyJobService { }

    public static class P9 extends ProxyJobService { }

    public static class P10 extends ProxyJobService { }

    public static class P11 extends ProxyJobService { }

    public static class P12 extends ProxyJobService { }

    public static class P13 extends ProxyJobService { }

    public static class P14 extends ProxyJobService { }

    public static class P15 extends ProxyJobService { }

    public static class P16 extends ProxyJobService { }

    public static class P17 extends ProxyJobService { }

    public static class P18 extends ProxyJobService { }

    public static class P19 extends ProxyJobService { }

    public static class P20 extends ProxyJobService { }

    public static class P21 extends ProxyJobService { }

    public static class P22 extends ProxyJobService { }

    public static class P23 extends ProxyJobService { }

    public static class P24 extends ProxyJobService { }

    public static class P25 extends ProxyJobService { }

    public static class P26 extends ProxyJobService { }

    public static class P27 extends ProxyJobService { }

    public static class P28 extends ProxyJobService { }

    public static class P29 extends ProxyJobService { }

    public static class P30 extends ProxyJobService { }

    public static class P31 extends ProxyJobService { }

    public static class P32 extends ProxyJobService { }

    public static class P33 extends ProxyJobService { }

    public static class P34 extends ProxyJobService { }

    public static class P35 extends ProxyJobService { }

    public static class P36 extends ProxyJobService { }

    public static class P37 extends ProxyJobService { }

    public static class P38 extends ProxyJobService { }

    public static class P39 extends ProxyJobService { }

    public static class P40 extends ProxyJobService { }

    public static class P41 extends ProxyJobService { }

    public static class P42 extends ProxyJobService { }

    public static class P43 extends ProxyJobService { }

    public static class P44 extends ProxyJobService { }

    public static class P45 extends ProxyJobService { }

    public static class P46 extends ProxyJobService { }

    public static class P47 extends ProxyJobService { }

    public static class P48 extends ProxyJobService { }

    public static class P49 extends ProxyJobService { }
}

```

`Bcore/src/main/java/com/vcore/proxy/ProxyManifest.java`:

```java
package com.vcore.proxy;

import java.util.Locale;

import com.vcore.BlackBoxCore;

public class ProxyManifest {
    public static final int FREE_COUNT = 50;

    public static boolean isProxy(String msg) {
        return getBindProvider().equals(msg) || msg.contains("proxy_content_provider_");
    }

    public static String getBindProvider() {
        return BlackBoxCore.getHostPkg() + ".blackbox.SystemCallProvider";
    }

    public static String getProxyAuthorities(int index) {
        return String.format(Locale.CHINA, "%s.proxy_content_provider_%d", BlackBoxCore.getHostPkg(), index);
    }

    public static String getProxyPendingActivity(int index) {
        return String.format(Locale.CHINA, "com.vcore.proxy.ProxyPendingActivity$P%d", index);
    }

    public static String getProxyActivity(int index) {
        return String.format(Locale.CHINA, "com.vcore.proxy.ProxyActivity$P%d", index);
    }

    public static String TransparentProxyActivity(int index) {
        return String.format(Locale.CHINA, "com.vcore.proxy.TransparentProxyActivity$P%d", index);
    }

    public static String getProxyService(int index) {
        return String.format(Locale.CHINA, "com.vcore.proxy.ProxyService$P%d", index);
    }

    public static String getProxyJobService(int index) {
        return String.format(Locale.CHINA, "com.vcore.proxy.ProxyJobService$P%d", index);
    }

    public static String getProxyFileProvider() {
        return BlackBoxCore.getHostPkg() + ".blackbox.FileProvider";
    }

    public static String getProcessName(int bPid) {
        return BlackBoxCore.getHostPkg() + ":p" + bPid;
    }
}

```

`Bcore/src/main/java/com/vcore/proxy/ProxyPendingActivity.java`:

```java
package com.vcore.proxy;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;

import androidx.annotation.Nullable;

import com.vcore.app.BActivityThread;
import com.vcore.proxy.record.ProxyPendingRecord;
import com.vcore.utils.Slog;

public class ProxyPendingActivity extends Activity {
    public static final String TAG = "ProxyPendingActivity";

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        finish();

        ProxyPendingRecord pendingActivityRecord = ProxyPendingRecord.create(getIntent());
        Slog.d(TAG, "ProxyPendingActivity: " + pendingActivityRecord);
        if (pendingActivityRecord.mTarget == null) {
            return;
        }

        pendingActivityRecord.mTarget.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        pendingActivityRecord.mTarget.setExtrasClassLoader(BActivityThread.getApplication().getClassLoader());
        startActivity(pendingActivityRecord.mTarget);
    }

    public static class P0 extends ProxyPendingActivity { }

    public static class P1 extends ProxyPendingActivity { }

    public static class P2 extends ProxyPendingActivity { }

    public static class P3 extends ProxyPendingActivity { }

    public static class P4 extends ProxyPendingActivity { }

    public static class P5 extends ProxyPendingActivity { }

    public static class P6 extends ProxyPendingActivity { }

    public static class P7 extends ProxyPendingActivity { }

    public static class P8 extends ProxyPendingActivity { }

    public static class P9 extends ProxyPendingActivity { }

    public static class P10 extends ProxyPendingActivity { }

    public static class P11 extends ProxyPendingActivity { }

    public static class P12 extends ProxyPendingActivity { }

    public static class P13 extends ProxyPendingActivity { }

    public static class P14 extends ProxyPendingActivity { }

    public static class P15 extends ProxyPendingActivity { }

    public static class P16 extends ProxyPendingActivity { }

    public static class P17 extends ProxyPendingActivity { }

    public static class P18 extends ProxyPendingActivity { }

    public static class P19 extends ProxyPendingActivity { }

    public static class P20 extends ProxyPendingActivity { }

    public static class P21 extends ProxyPendingActivity { }

    public static class P22 extends ProxyPendingActivity { }

    public static class P23 extends ProxyPendingActivity { }

    public static class P24 extends ProxyPendingActivity { }

    public static class P25 extends ProxyPendingActivity { }

    public static class P26 extends ProxyPendingActivity { }

    public static class P27 extends ProxyPendingActivity { }

    public static class P28 extends ProxyPendingActivity { }

    public static class P29 extends ProxyPendingActivity { }

    public static class P30 extends ProxyPendingActivity { }

    public static class P31 extends ProxyPendingActivity { }

    public static class P32 extends ProxyPendingActivity { }

    public static class P33 extends ProxyPendingActivity { }

    public static class P34 extends ProxyPendingActivity { }

    public static class P35 extends ProxyPendingActivity { }

    public static class P36 extends ProxyPendingActivity { }

    public static class P37 extends ProxyPendingActivity { }

    public static class P38 extends ProxyPendingActivity { }

    public static class P39 extends ProxyPendingActivity { }

    public static class P40 extends ProxyPendingActivity { }

    public static class P41 extends ProxyPendingActivity { }

    public static class P42 extends ProxyPendingActivity { }

    public static class P43 extends ProxyPendingActivity { }

    public static class P44 extends ProxyPendingActivity { }

    public static class P45 extends ProxyPendingActivity { }

    public static class P46 extends ProxyPendingActivity { }

    public static class P47 extends ProxyPendingActivity { }

    public static class P48 extends ProxyPendingActivity { }

    public static class P49 extends ProxyPendingActivity { }
}

```

`Bcore/src/main/java/com/vcore/proxy/ProxyService.java`:

```java
package com.vcore.proxy;

import android.app.Service;
import android.content.Intent;
import android.content.res.Configuration;
import android.os.IBinder;

import androidx.annotation.Nullable;

import com.vcore.app.dispatcher.AppServiceDispatcher;

public class ProxyService extends Service {
    public static final String TAG = "StubService";

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return AppServiceDispatcher.get().onBind(intent);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        AppServiceDispatcher.get().onStartCommand(intent);
        return START_NOT_STICKY;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        AppServiceDispatcher.get().onDestroy();
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        AppServiceDispatcher.get().onConfigurationChanged(newConfig);
    }

    @Override
    public void onLowMemory() {
        super.onLowMemory();
        AppServiceDispatcher.get().onLowMemory();
    }

    @Override
    public void onTrimMemory(int level) {
        super.onTrimMemory(level);
        AppServiceDispatcher.get().onTrimMemory(level);
    }

    @Override
    public boolean onUnbind(Intent intent) {
        AppServiceDispatcher.get().onUnbind(intent);
        return false;
    }

    public static class P0 extends ProxyService { }

    public static class P1 extends ProxyService { }

    public static class P2 extends ProxyService { }

    public static class P3 extends ProxyService { }

    public static class P4 extends ProxyService { }

    public static class P5 extends ProxyService { }

    public static class P6 extends ProxyService { }

    public static class P7 extends ProxyService { }

    public static class P8 extends ProxyService { }

    public static class P9 extends ProxyService { }

    public static class P10 extends ProxyService { }

    public static class P11 extends ProxyService { }

    public static class P12 extends ProxyService { }

    public static class P13 extends ProxyService { }

    public static class P14 extends ProxyService { }

    public static class P15 extends ProxyService { }

    public static class P16 extends ProxyService { }

    public static class P17 extends ProxyService { }

    public static class P18 extends ProxyService { }

    public static class P19 extends ProxyService { }

    public static class P20 extends ProxyService { }

    public static class P21 extends ProxyService { }

    public static class P22 extends ProxyService { }

    public static class P23 extends ProxyService { }

    public static class P24 extends ProxyService { }

    public static class P25 extends ProxyService { }

    public static class P26 extends ProxyService { }

    public static class P27 extends ProxyService { }

    public static class P28 extends ProxyService { }

    public static class P29 extends ProxyService { }

    public static class P30 extends ProxyService { }

    public static class P31 extends ProxyService { }

    public static class P32 extends ProxyService { }

    public static class P33 extends ProxyService { }

    public static class P34 extends ProxyService { }

    public static class P35 extends ProxyService { }

    public static class P36 extends ProxyService { }

    public static class P37 extends ProxyService { }

    public static class P38 extends ProxyService { }

    public static class P39 extends ProxyService { }

    public static class P40 extends ProxyService { }

    public static class P41 extends ProxyService { }

    public static class P42 extends ProxyService { }

    public static class P43 extends ProxyService { }

    public static class P44 extends ProxyService { }

    public static class P45 extends ProxyService { }

    public static class P46 extends ProxyService { }

    public static class P47 extends ProxyService { }

    public static class P48 extends ProxyService { }

    public static class P49 extends ProxyService { }
}

```

`Bcore/src/main/java/com/vcore/proxy/ProxyVpnService.java`:

```java
package com.vcore.proxy;

import android.net.VpnService;

public class ProxyVpnService extends VpnService { }

```

`Bcore/src/main/java/com/vcore/proxy/TransparentProxyActivity.java`:

```java
package com.vcore.proxy;

public class TransparentProxyActivity extends ProxyActivity {
    public static class P0 extends TransparentProxyActivity { }

    public static class P1 extends TransparentProxyActivity { }

    public static class P2 extends TransparentProxyActivity { }

    public static class P3 extends TransparentProxyActivity { }

    public static class P4 extends TransparentProxyActivity { }

    public static class P5 extends TransparentProxyActivity { }

    public static class P6 extends TransparentProxyActivity { }

    public static class P7 extends TransparentProxyActivity { }

    public static class P8 extends TransparentProxyActivity { }

    public static class P9 extends TransparentProxyActivity { }

    public static class P10 extends TransparentProxyActivity { }

    public static class P11 extends TransparentProxyActivity { }

    public static class P12 extends TransparentProxyActivity { }

    public static class P13 extends TransparentProxyActivity { }

    public static class P14 extends TransparentProxyActivity { }

    public static class P15 extends TransparentProxyActivity { }

    public static class P16 extends TransparentProxyActivity { }

    public static class P17 extends TransparentProxyActivity { }

    public static class P18 extends TransparentProxyActivity { }

    public static class P19 extends TransparentProxyActivity { }

    public static class P20 extends TransparentProxyActivity { }

    public static class P21 extends TransparentProxyActivity { }

    public static class P22 extends TransparentProxyActivity { }

    public static class P23 extends TransparentProxyActivity { }

    public static class P24 extends TransparentProxyActivity { }

    public static class P25 extends TransparentProxyActivity { }

    public static class P26 extends TransparentProxyActivity { }

    public static class P27 extends TransparentProxyActivity { }

    public static class P28 extends TransparentProxyActivity { }

    public static class P29 extends TransparentProxyActivity { }

    public static class P30 extends TransparentProxyActivity { }

    public static class P31 extends TransparentProxyActivity { }

    public static class P32 extends TransparentProxyActivity { }

    public static class P33 extends TransparentProxyActivity { }

    public static class P34 extends TransparentProxyActivity { }

    public static class P35 extends TransparentProxyActivity { }

    public static class P36 extends TransparentProxyActivity { }

    public static class P37 extends TransparentProxyActivity { }

    public static class P38 extends TransparentProxyActivity { }

    public static class P39 extends TransparentProxyActivity { }

    public static class P40 extends TransparentProxyActivity { }

    public static class P41 extends TransparentProxyActivity { }

    public static class P42 extends TransparentProxyActivity { }

    public static class P43 extends TransparentProxyActivity { }

    public static class P44 extends TransparentProxyActivity { }

    public static class P45 extends TransparentProxyActivity { }

    public static class P46 extends TransparentProxyActivity { }

    public static class P47 extends TransparentProxyActivity { }

    public static class P48 extends TransparentProxyActivity { }

    public static class P49 extends TransparentProxyActivity { }
}

```

`Bcore/src/main/java/com/vcore/proxy/record/ProxyActivityRecord.java`:

```java
package com.vcore.proxy.record;

import android.content.Intent;
import android.content.pm.ActivityInfo;

public class ProxyActivityRecord {
    public final int mUserId;
    public final ActivityInfo mActivityInfo;
    public final Intent mTarget;
    public final String mActivityToken;

    public ProxyActivityRecord(int userId, ActivityInfo activityInfo, Intent target, String activityToken) {
        this.mUserId = userId;
        this.mActivityInfo = activityInfo;
        this.mTarget = target;
        this.mActivityToken = activityToken;
    }

    public static void saveStub(Intent shadow, Intent target, ActivityInfo activityInfo, String activityToken, int userId) {
        shadow.putExtra("_B_|_user_id_", userId);
        shadow.putExtra("_B_|_activity_info_", activityInfo);
        shadow.putExtra("_B_|_target_", target);
        shadow.putExtra("_B_|_activity_token_v_", activityToken);
    }

    public static ProxyActivityRecord create(Intent intent) {
        int userId = intent.getIntExtra("_B_|_user_id_", 0);
        ActivityInfo activityInfo = intent.getParcelableExtra("_B_|_activity_info_");

        Intent target = intent.getParcelableExtra("_B_|_target_");
        String activityToken = intent.getStringExtra("_B_|_activity_token_v_");
        return new ProxyActivityRecord(userId, activityInfo, target, activityToken);
    }
}

```

`Bcore/src/main/java/com/vcore/proxy/record/ProxyBroadcastRecord.java`:

```java
package com.vcore.proxy.record;

import android.content.Intent;

import androidx.annotation.NonNull;

public class ProxyBroadcastRecord {
    public final Intent mIntent;
    public final int mUserId;

    public ProxyBroadcastRecord(Intent intent, int userId) {
        this.mIntent = intent;
        this.mUserId = userId;
    }

    public static void saveStub(Intent shadow, Intent target, int userId) {
        shadow.putExtra("_B_|_target_", target);
        shadow.putExtra("_B_|_user_id_", userId);
    }

    public static ProxyBroadcastRecord create(Intent intent) {
        Intent target = intent.getParcelableExtra("_B_|_target_");
        int userId = intent.getIntExtra("_B_|_user_id_", 0);
        return new ProxyBroadcastRecord(target, userId);
    }

    @NonNull
    @Override
    public String toString() {
        return "ProxyBroadcastRecord{" + "mIntent=" + mIntent + ", mUserId=" + mUserId + '}';
    }
}

```

`Bcore/src/main/java/com/vcore/proxy/record/ProxyPendingRecord.java`:

```java
package com.vcore.proxy.record;

import android.content.Intent;

import androidx.annotation.NonNull;

public class ProxyPendingRecord {
    public final int mUserId;
    public final Intent mTarget;

    public ProxyPendingRecord(Intent target, int userId) {
        this.mUserId = userId;
        this.mTarget = target;
    }

    public static void saveStub(Intent shadow, Intent target, int userId) {
        shadow.putExtra("_B_|_P_user_id_", userId);
        shadow.putExtra("_B_|_P_target_", target);
    }

    public static ProxyPendingRecord create(Intent intent) {
        int userId = intent.getIntExtra("_B_|_P_user_id_", 0);
        Intent target = intent.getParcelableExtra("_B_|_P_target_");
        return new ProxyPendingRecord(target, userId);
    }

    @NonNull
    @Override
    public String toString() {
        return "ProxyPendingActivityRecord{" + "mUserId=" + mUserId + ", mTarget=" + mTarget + '}';
    }
}

```

`Bcore/src/main/java/com/vcore/proxy/record/ProxyServiceRecord.java`:

```java
package com.vcore.proxy.record;

import android.content.Intent;
import android.content.pm.ServiceInfo;
import android.os.IBinder;

import com.vcore.utils.compat.BundleCompat;

public class ProxyServiceRecord {
    public final Intent mServiceIntent;
    public final ServiceInfo mServiceInfo;
    public final IBinder mToken;
    public final int mUserId;
    public final int mStartId;

    public ProxyServiceRecord(Intent serviceIntent, ServiceInfo serviceInfo, IBinder token, int userId, int startId) {
        this.mServiceIntent = serviceIntent;
        this.mServiceInfo = serviceInfo;
        this.mUserId = userId;
        this.mStartId = startId;
        this.mToken = token;
    }

    public static void saveStub(Intent shadow, Intent target, ServiceInfo serviceInfo, IBinder token, int userId, int startId) {
        shadow.putExtra("_B_|_target_", target);
        shadow.putExtra("_B_|_service_info_", serviceInfo);
        shadow.putExtra("_B_|_user_id_", userId);
        shadow.putExtra("_B_|_start_id_", startId);
        BundleCompat.putBinder(shadow, "_B_|_token_", token);
    }

    public static ProxyServiceRecord create(Intent intent) {
        Intent target = intent.getParcelableExtra("_B_|_target_");
        ServiceInfo serviceInfo = intent.getParcelableExtra("_B_|_service_info_");

        int userId = intent.getIntExtra("_B_|_user_id_", 0);
        int startId = intent.getIntExtra("_B_|_start_id_", 0);

        IBinder token = BundleCompat.getBinder(intent, "_B_|_token_");
        return new ProxyServiceRecord(target, serviceInfo, token, userId, startId);
    }
}

```

`Bcore/src/main/java/com/vcore/utils/AbiUtils.java`:

```java
package com.vcore.utils;

import java.io.File;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import com.vcore.BlackBoxCore;

public class AbiUtils {
    private final Set<String> mLibs = new HashSet<>();
    private static final Map<File, AbiUtils> sAbiUtilsMap = new HashMap<>();

    public static boolean isSupport(File apkFile) {
        AbiUtils abiUtils = sAbiUtilsMap.get(apkFile);
        if (abiUtils == null) {
            abiUtils = new AbiUtils(apkFile);
            sAbiUtilsMap.put(apkFile, abiUtils);
        }

        if (abiUtils.isEmptyAib()) {
            return true;
        }

        if (BlackBoxCore.is64Bit()) {
            return abiUtils.is64Bit();
        } else {
            return abiUtils.is32Bit();
        }
    }

    public AbiUtils(File apkFile) {
        ZipFile zipFile = null;
        try {
            zipFile = new ZipFile(apkFile);
            Enumeration<? extends ZipEntry> entries = zipFile.entries();

            while (entries.hasMoreElements()) {
                ZipEntry zipEntry = entries.nextElement();
                String name = zipEntry.getName();

                if (name.startsWith("lib/arm64-v8a")) {
                    mLibs.add("arm64-v8a");
                } else if (name.startsWith("lib/armeabi")) {
                    mLibs.add("armeabi");
                } else if (name.startsWith("lib/armeabi-v7a")) {
                    mLibs.add("armeabi-v7a");
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            CloseUtils.close(zipFile);
        }
    }

    public boolean is64Bit() {
        return mLibs.contains("arm64-v8a");
    }

    public boolean is32Bit() {
        return mLibs.contains("armeabi") || mLibs.contains("armeabi-v7a");
    }

    public boolean isEmptyAib() {
        return mLibs.isEmpty();
    }
}

```

`Bcore/src/main/java/com/vcore/utils/ArrayUtils.java`:

```java
package com.vcore.utils;

import java.util.Arrays;

public class ArrayUtils {
	public static<T> T[] trimToSize(T[] array, int size) {
		if (array == null || size == 0) {
			return null;
		} else if (array.length == size) {
			return array;
		}
		return Arrays.copyOf(array, size);
	}

	public static int indexOfFirst(Object[] array, Class<?> type) {
		if (!isEmpty(array)) {
			int N = -1;
			for (Object one : array) {
				N++;
				if (one != null && type == one.getClass()) {
					return N;
				}
			}
		}
		return -1;
	}

	public static int indexOfObject(Object[] array, Class<?> type, int sequence) {
		if (array == null) {
			return -1;
		}

		while (sequence < array.length) {
			if (type.isInstance(array[sequence])) {
				return sequence;
			}
			sequence++;
		}
		return -1;
	}

	public static int indexOfLast(Object[] array, Class<?> type) {
		if (!isEmpty(array)) {
			for (int N = array.length; N > 0; N--) {
				Object one = array[N - 1];
				if (one != null && one.getClass() == type) {
					return N - 1;
				}
			}
		}
		return -1;
	}

	public static int[] toInt(Integer[] array) {
		int[] newArray = new int[array.length];

		for (int i = 0; i < array.length; i++) {
			newArray[i] = array[i];
		}
		return newArray;
	}

	public static <T> boolean isEmpty(T[] array) {
		return array == null || array.length == 0;
	}
}

```

`Bcore/src/main/java/com/vcore/utils/CloseUtils.java`:

```java
package com.vcore.utils;

import java.io.Closeable;
import java.io.IOException;

public class CloseUtils {
    public static void close(Closeable... closeables) {
        if (closeables == null) {
            return;
        }

        for (Closeable closeable : closeables) {
            if (closeable != null) {
                try {
                    closeable.close();
                } catch (IOException ignored) { }
            }
        }
    }
}

```

`Bcore/src/main/java/com/vcore/utils/ComponentUtils.java`:

```java
package com.vcore.utils;

import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;

import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.ComponentInfo;

import java.util.Objects;

import com.vcore.app.BActivityThread;

public class ComponentUtils {
    public static boolean isRequestInstall(Intent intent) {
        return "application/vnd.android.package-archive".equals(intent.getType());
    }

    public static boolean isSelf(Intent intent) {
        ComponentName component = intent.getComponent();
        if (component == null || BActivityThread.getAppPackageName() == null) {
            return false;
        }
        return component.getPackageName().equals(BActivityThread.getAppPackageName());
    }

    public static boolean isSelf(Intent[] intent) {
        for (Intent intent1 : intent) {
            if (!isSelf(intent1)) {
                return false;
            }
        }
        return true;
    }

    public static String getTaskAffinity(ActivityInfo info) {
        if (info.launchMode == LAUNCH_SINGLE_INSTANCE) {
            return "-SingleInstance-" + info.packageName + "/" + info.name;
        } else if (info.taskAffinity == null && info.applicationInfo.taskAffinity == null) {
            return info.packageName;
        } else if (info.taskAffinity != null) {
            return info.taskAffinity;
        }
        return info.applicationInfo.taskAffinity;
    }

    public static boolean intentFilterEquals(Intent a, Intent b) {
        if (a != null && b != null) {
            if (!Objects.equals(a.getAction(), b.getAction())) {
                return false;
            }

            if (!Objects.equals(a.getData(), b.getData())) {
                return false;
            }

            if (!Objects.equals(a.getType(), b.getType())) {
                return false;
            }

            Object pkgA = a.getPackage();
            if (pkgA == null && a.getComponent() != null) {
                pkgA = a.getComponent().getPackageName();
            }

            String pkgB = b.getPackage();
            if (pkgB == null && b.getComponent() != null) {
                pkgB = b.getComponent().getPackageName();
            }

            if (!Objects.equals(pkgA, pkgB)) {
                return false;
            }

            if (!Objects.equals(a.getComponent(), b.getComponent())) {
                return false;
            }
            return Objects.equals(a.getCategories(), b.getCategories());
        }
        return true;
    }

    public static String getProcessName(ComponentInfo componentInfo) {
        String processName = componentInfo.processName;
        if (processName == null) {
            processName = componentInfo.packageName;
            componentInfo.processName = processName;
        }
        return processName;
    }

    public static ComponentName toComponentName(ComponentInfo componentInfo) {
        return new ComponentName(componentInfo.packageName, componentInfo.name);
    }
}

```

`Bcore/src/main/java/com/vcore/utils/DrawableUtils.java`:

```java
package com.vcore.utils;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.PixelFormat;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;

public class DrawableUtils {
    public static Bitmap drawableToBitmap(Drawable drawable, int width, int height) {
        if (drawable == null) {
            return null;
        }

        if (drawable instanceof BitmapDrawable) {
            return ((BitmapDrawable) drawable).getBitmap();
        }

        Bitmap.Config config = drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
        Bitmap bitmap = Bitmap.createBitmap(width, height, config);

        Canvas canvas = new Canvas(bitmap);
        drawable.setBounds(0, 0, width, height);
        drawable.draw(canvas);
        return bitmap;
    }
}

```

`Bcore/src/main/java/com/vcore/utils/FileUtils.java`:

```java
package com.vcore.utils;

import android.os.Parcel;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;

public class FileUtils {
    public static int count(File file) {
        if (!file.exists()) {
            return -1;
        }

        if (file.isFile()) {
            return 1;
        }

        if (file.isDirectory()) {
            String[] fs = file.list();
            return fs == null ? 0 : fs.length;
        }
        return 0;
    }

    public static boolean renameTo(File origFile, File newFile) {
        return origFile.renameTo(newFile);
    }

    public static Parcel readToParcel(File file) throws IOException {
        Parcel in = Parcel.obtain();
        byte[] bytes = toByteArray(file);

        in.unmarshall(bytes, 0, bytes.length);
        in.setDataPosition(0);
        return in;
    }

    public static boolean isSymlink(File file) throws IOException {
        if (file == null) {
            throw new NullPointerException("File must not be null");
        }

        File canon;
        if (file.getParent() == null) {
            canon = file;
        } else {
            File canonDir = file.getParentFile().getCanonicalFile();
            canon = new File(canonDir, file.getName());
        }
        return !canon.getCanonicalFile().equals(canon.getAbsoluteFile());
    }

    public static void writeParcelToOutput(Parcel p, FileOutputStream fos) throws IOException {
        fos.write(p.marshall());
    }

    public static byte[] toByteArray(File file) throws IOException {
        FileInputStream fileInputStream = new FileInputStream(file);
        try {
            return toByteArray(fileInputStream);
        } finally {
            closeQuietly(fileInputStream);
        }
    }

    public static byte[] toByteArray(InputStream inStream) throws IOException {
        ByteArrayOutputStream swapStream = new ByteArrayOutputStream();
        byte[] buff = new byte[100];
        int rc;
        while ((rc = inStream.read(buff, 0, 100)) > 0) {
            swapStream.write(buff, 0, rc);
        }
        return swapStream.toByteArray();
    }

    public static int deleteDir(File dir) {
        int count = 0;
        if (dir.isDirectory()) {
            boolean link = false;
            try {
                link = isSymlink(dir);
            } catch (Exception ignored) { }

            if (!link) {
                String[] children = dir.list();
                for (String file : children) {
                    count += deleteDir(new File(dir, file));
                }
            }
        }

        if (dir.delete()) {
            count++;
        }
        return count;
    }

    public static int deleteDir(String dir) {
        return deleteDir(new File(dir));
    }

    public static void writeToFile(byte[] data, File target) throws IOException {
        try (ReadableByteChannel src = Channels.newChannel(new ByteArrayInputStream(data));
             FileOutputStream fo = new FileOutputStream(target);
             FileChannel out = fo.getChannel()) {
            out.transferFrom(src, 0, data.length);
        }
    }

    public static void copyFile(InputStream inputStream, File target) {
        FileOutputStream outputStream = null;
        try {
            outputStream = new FileOutputStream(target);
            byte[] data = new byte[4096];
            int len;
            while ((len = inputStream.read(data)) != -1) {
                outputStream.write(data, 0, len);
            }
            outputStream.flush();
        } catch (Throwable e) {
            // Ignore
        } finally {
            closeQuietly(inputStream);
            closeQuietly(outputStream);
        }
    }

    public static void copyFile(File source, File target) throws IOException {
        FileInputStream inputStream = null;
        FileOutputStream outputStream = null;
        try {
            inputStream = new FileInputStream(source);
            outputStream = new FileOutputStream(target);
            FileChannel iChannel = inputStream.getChannel();
            FileChannel oChannel = outputStream.getChannel();

            ByteBuffer buffer = ByteBuffer.allocate(1024);
            while (true) {
                buffer.clear();
                int r = iChannel.read(buffer);
                if (r == -1) {
                    break;
                }

                buffer.limit(buffer.position());
                buffer.position(0);
                oChannel.write(buffer);
            }
        } finally {
            closeQuietly(inputStream);
            closeQuietly(outputStream);
        }
    }

    public static void closeQuietly(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (Exception ignored) { }
        }
    }

    public static void mkdirs(File path) {
        if (!path.exists()) {
            path.mkdirs();
        }
    }

    public static void mkdirs(String path) {
        mkdirs(new File(path));
    }

    public static boolean isExist(String path) {
        return new File(path).exists();
    }
}

```

`Bcore/src/main/java/com/vcore/utils/Md5Utils.java`:

```java
package com.vcore.utils;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;

public class Md5Utils {
    private static final char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    public static String md5(String input) {
        if (input == null) {
            return null;
        }

        try {
            MessageDigest messageDigest = MessageDigest.getInstance("MD5");
            byte[] inputByteArray = input.getBytes(StandardCharsets.UTF_8);
            messageDigest.update(inputByteArray);

            byte[] resultByteArray = messageDigest.digest();
            return byteArrayToHex(resultByteArray);
        } catch (Exception e) {
            return null;
        }
    }

    private static String byteArrayToHex(byte[] byteArray) {
        char[] resultCharArray = new char[byteArray.length * 2];
        int index = 0;

        for (byte b : byteArray) {
            resultCharArray[index++] = hexDigits[b >>> 4 & 0xf];
            resultCharArray[index++] = hexDigits[b & 0xf];
        }
        return new String(resultCharArray);
    }
}

```

`Bcore/src/main/java/com/vcore/utils/MethodParameterUtils.java`:

```java
package com.vcore.utils;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Objects;

import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;

public class MethodParameterUtils {
    public static <T> T getFirstParam(Object[] args, Class<T> tClass) {
        if (args == null) {
            return null;
        }

        int index = ArrayUtils.indexOfFirst(args, tClass);
        if (index != -1) {
            return (T) args[index];
        }
        return null;
    }

    public static <T> T getFirstParamByInstance(Object[] args, Class<T> tClass) {
        if (args == null) {
            return null;
        }

        int index = ArrayUtils.indexOfObject(args, tClass, 0);
        if (index != -1) {
            return (T) args[index];
        }
        return null;
    }

    public static String replaceFirstAppPkg(Object[] args) {
        if (args == null) {
            return null;
        }

        for (int i = 0; i < args.length; i++) {
            if (args[i] instanceof String) {
                String value = (String) args[i];
                if (BlackBoxCore.get().isInstalled(value, BActivityThread.getUserId())) {
                    args[i] = BlackBoxCore.getHostPkg();
                    return value;
                }
            }
        }
        return null;
    }

    public static void replaceAllAppPkg(Object[] args) {
        if (args == null) {
            return;
        }

        for (int i = 0; i < args.length; i++) {
            if (args[i] == null) {
                continue;
            }

            if (args[i] instanceof String) {
                String value = (String) args[i];
                if (BlackBoxCore.get().isInstalled(value, BActivityThread.getUserId())) {
                    args[i] = BlackBoxCore.getHostPkg();
                }
            }
        }
    }

    public static void replaceFirstUid(Object[] args) {
        if (args == null) {
            return;
        }

        for (int i = 0; i < args.length; i++) {
            if (args[i] instanceof Integer) {
                int uid = (int) args[i];
                if (uid == BActivityThread.getBUid()) {
                    args[i] = BlackBoxCore.getHostUid();
                }
            }
        }
    }

    public static void replaceLastUid(Object[] args) {
        int index = ArrayUtils.indexOfLast(args, Integer.class);
        if (index != -1) {
            int uid = (int) args[index];
            if (uid == BActivityThread.getBUid()) {
                args[index] = BlackBoxCore.getHostUid();
            }
        }
    }

    public static void replaceLastAppPkg(Object[] args) {
        int index = ArrayUtils.indexOfLast(args, String.class);
        if (index != -1) {
            String pkg = (String) args[index];
            if (BlackBoxCore.get().isInstalled(pkg, BActivityThread.getUserId())) {
                args[index] = BlackBoxCore.getHostPkg();
            }
        }
    }

    public static Class<?>[] getAllInterface(Class<?> clazz) {
        HashSet<Class<?>> classes = new HashSet<>();
        getAllInterfaces(clazz, classes);

        Class<?>[] result = new Class[classes.size()];
        classes.toArray(result);
        return result;
    }

    public static void getAllInterfaces(Class<?> clazz, HashSet<Class<?>> interfaceCollection) {
        Class<?>[] classes = clazz.getInterfaces();
        if (classes.length != 0) {
            interfaceCollection.addAll(Arrays.asList(classes));
        }

        if (clazz.getSuperclass() != Object.class) {
            getAllInterfaces(Objects.requireNonNull(clazz.getSuperclass()), interfaceCollection);
        }
    }
}

```

`Bcore/src/main/java/com/vcore/utils/NativeUtils.java`:

```java
package com.vcore.utils;

import android.os.Build;
import android.util.Log;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class NativeUtils {
    public static final String TAG = "NativeUtils";

    public static void copyNativeLib(File apk, File nativeLibDir) throws Exception {
        long startTime = System.currentTimeMillis();
        if (!nativeLibDir.exists()) {
            nativeLibDir.mkdirs();
        }

        try (ZipFile zipfile = new ZipFile(apk.getAbsolutePath())) {
            if (findAndCopyNativeLib(zipfile, Build.CPU_ABI, nativeLibDir)) {
                return;
            }

            findAndCopyNativeLib(zipfile, "armeabi", nativeLibDir);
        } finally {
            Log.d(TAG, "Done! +" + (System.currentTimeMillis() - startTime) + "ms");
        }
    }

    private static boolean findAndCopyNativeLib(ZipFile zipfile, String cpuArch, File nativeLibDir) throws Exception {
        Log.d(TAG, "Try to copy plugin's cup arch: " + cpuArch);
        boolean findLib = false;
        boolean findSo = false;
        byte[] buffer = null;

        String libPrefix = "lib/" + cpuArch + "/";
        ZipEntry entry;
        Enumeration<?> e = zipfile.entries();

        while (e.hasMoreElements()) {
            entry = (ZipEntry) e.nextElement();
            String entryName = entry.getName();
            if (!findLib && !entryName.startsWith("lib/")) {
                continue;
            }

            findLib = true;
            if (!entryName.endsWith(".so") || !entryName.startsWith(libPrefix)) {
                continue;
            }

            if (buffer == null) {
                findSo = true;
                Log.d(TAG, "Found plugin's cup arch dir: " + cpuArch);
                buffer = new byte[8192];
            }

            String libName = entryName.substring(entryName.lastIndexOf('/') + 1);
            Log.d(TAG, "verify so " + libName);

            File libFile = new File(nativeLibDir, libName);
            if (libFile.exists() && libFile.length() == entry.getSize()) {
                Log.d(TAG, libName + " skip copy");
                continue;
            }

            FileOutputStream fos = new FileOutputStream(libFile);
            Log.d(TAG, "copy so " + entry.getName() + " of " + cpuArch);
            copySo(buffer, zipfile.getInputStream(entry), fos);
        }

        if (!findLib) {
            Log.d(TAG, "Fast skip all!");
            return true;
        }
        return findSo;
    }

    private static void copySo(byte[] buffer, InputStream input, OutputStream output) throws IOException {
        BufferedInputStream bufferedInput = new BufferedInputStream(input);
        BufferedOutputStream bufferedOutput = new BufferedOutputStream(output);
        int count;

        while ((count = bufferedInput.read(buffer)) > 0) {
            bufferedOutput.write(buffer, 0, count);
        }

        bufferedOutput.flush();
        bufferedOutput.close();
        output.close();
        bufferedInput.close();
        input.close();
    }
}

```

`Bcore/src/main/java/com/vcore/utils/ShellUtils.java`:

```java
package com.vcore.utils;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;

public class ShellUtils {
    public static final String COMMAND_SU = "su";
    public static final String COMMAND_SH = "sh";
    public static final String COMMAND_EXIT = "exit\n";
    public static final String COMMAND_LINE_END = "\n";

    private ShellUtils() {
        throw new AssertionError();
    }

    /**
     * Execute shell command, default return result msg
     *
     * @param command command
     * @param isRoot  whether need to run with root
     * @see ShellUtils#execCommand(String[], boolean, boolean)
     */
    public static void execCommand(String command, boolean isRoot) {
        execCommand(new String[]{command}, isRoot, true);
    }

    /**
     * Execute shell commands
     *
     * @param commands        command array
     * @param isRoot          whether need to run with root
     * @param isNeedResultMsg whether need result msg
     * @return <ul>
     * <li>if isNeedResultMsg is false, {@link CommandResult#successMsg} is null and
     * <li>if {@link CommandResult#result} is -1, there maybe some exception.</li>
     * </ul>
     */
    public static CommandResult execCommand(String[] commands, boolean isRoot, boolean isNeedResultMsg) {
        int result = -1;
        if (commands == null || commands.length == 0) {
            return new CommandResult(result, null);
        }

        Process process = null;
        BufferedReader successResult = null;
        StringBuilder successMsg = null;
        DataOutputStream os = null;

        try {
            process = Runtime.getRuntime().exec(isRoot ? COMMAND_SU : COMMAND_SH);
            os = new DataOutputStream(process.getOutputStream());

            for (String command : commands) {
                if (command == null) {
                    continue;
                }

                os.write(command.getBytes());
                os.writeBytes(COMMAND_LINE_END);
                os.flush();
            }

            os.writeBytes(COMMAND_EXIT);
            os.flush();

            result = process.waitFor();
            if (isNeedResultMsg) {
                successMsg = new StringBuilder();
                successResult = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String s;

                while ((s = successResult.readLine()) != null) {
                    successMsg.append(s).append("\n");
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (os != null) {
                    os.close();
                }

                if (successResult != null) {
                    successResult.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            if (process != null) {
                process.destroy();
            }
        }
        return new CommandResult(result, successMsg == null ? null : successMsg.toString());
    }

    /**
     * Result of command
     * <ul>
     * <li>{@link CommandResult#result} means result of command, 0 means normal, else means error, same to execute in
     * linux shell</li>
     * <li>{@link CommandResult#successMsg} means success message of command result</li>
     * </ul>
     *
     * @author <a href="http://www.trinea.cn" target="_blank">Trinea</a> 2013-5-16
     */
    public static class CommandResult {
        /**
         * result of command
         **/
        public final int result;
        /**
         * success message of command result
         **/
        public final String successMsg;

        public CommandResult(int result, String successMsg) {
            this.result = result;
            this.successMsg = successMsg;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/utils/Slog.java`:

```java
package com.vcore.utils;

import android.util.Log;

/**
 * @hide
 */
public final class Slog {
    private Slog() { }

    public static void v(String tag, String msg) {
        println(Log.VERBOSE, tag, msg);
    }

    public static void v(String tag, String msg, Throwable tr) {
        println(Log.VERBOSE, tag, msg + '\n' + Log.getStackTraceString(tr));
    }

    public static void d(String tag, String msg) {
        println(Log.DEBUG, tag, msg);
    }

    public static void d(String tag, String msg, Throwable tr) {
        println(Log.DEBUG, tag, msg + '\n' + Log.getStackTraceString(tr));
    }

    public static void i(String tag, String msg) {
        println(Log.INFO, tag, msg);
    }

    public static void i(String tag, String msg, Throwable tr) {
        println(Log.INFO, tag, msg + '\n' + Log.getStackTraceString(tr));
    }

    public static void w(String tag, String msg) {
        println(Log.WARN, tag, msg);
    }

    public static void w(String tag, String msg, Throwable tr) {
        println(Log.WARN, tag, msg + '\n' + Log.getStackTraceString(tr));
    }

    public static void w(String tag, Throwable tr) {
        println(Log.WARN, tag, Log.getStackTraceString(tr));
    }
    
    public static void e(String tag, String msg) {
        println(Log.ERROR, tag, msg);
    }

    public static void e(String tag, String msg, Throwable tr) {
        println(Log.ERROR, tag, msg + '\n' + Log.getStackTraceString(tr));
    }

    public static void println(int priority, String tag, String msg) {
        Log.println(priority, tag, msg);
    }
}


```

`Bcore/src/main/java/com/vcore/utils/TrieTree.java`:

```java
package com.vcore.utils;

import java.util.LinkedList;
import java.util.List;
import java.util.Objects;

public class TrieTree {
    private final TrieNode root = new TrieNode();

    private static class TrieNode {
        char content;
        String word;
        boolean isEnd = false;
        final List<TrieNode> children = new LinkedList<>();

        public TrieNode() { }

        public TrieNode(char content, String word) {
            this.content = content;
            this.word = word;
        }

        @Override
        public boolean equals(Object object) {
            if (object instanceof TrieNode) {
                return ((TrieNode) object).content == content;
            }
            return false;
        }

        public TrieNode nextNode(char content) {
            for (TrieNode childNode : children) {
                if (childNode.content == content) {
                    return childNode;
                }
            }
            return null;
        }
    }

    public void add(String word) {
        TrieNode current = root;
        StringBuilder wordBuilder = new StringBuilder();

        for (int index = 0; index < word.length(); ++index) {
            char content = word.charAt(index);
            wordBuilder.append(content);

            TrieNode node = new TrieNode(content, wordBuilder.toString());
            if (Objects.requireNonNull(current).children.contains(node)) {
                current = current.nextNode(content);
            } else {
                current.children.add(node);
                current = node;
            }

            if (index == (word.length() - 1)) {
                Objects.requireNonNull(current).isEnd = true;
            }
        }
    }

    public String search(String word) {
        TrieNode current = root;
        for (int index = 0; index < word.length(); ++index) {
            char content = word.charAt(index);

            TrieNode node = new TrieNode(content, null);
            if (current.children.contains(node)) {
                current = current.nextNode(content);
            } else {
                return null;
            }

            if (Objects.requireNonNull(current).isEnd) {
                return current.word;
            }
        }
        return null;
    }
}

```

`Bcore/src/main/java/com/vcore/utils/compat/AccountManagerCompat.java`:

```java
package com.vcore.utils.compat;

public class AccountManagerCompat {
    /**
     * Boolean, if set and 'customTokens' the authenticator is responsible for
     * notifications.
     */
    public static final String KEY_NOTIFY_ON_FAILURE = "notifyOnAuthFailure";
}

```

`Bcore/src/main/java/com/vcore/utils/compat/ActivityCompat.java`:

```java
package com.vcore.utils.compat;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.WallpaperManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.content.res.TypedArray;
import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.view.WindowManager;

import com.vcore.app.BActivityThread;
import com.vcore.utils.ArrayUtils;
import com.vcore.utils.DrawableUtils;

public class ActivityCompat {
    public static void fix(Activity activity) {
        Context baseContext = activity.getBaseContext();
        try {
            TypedArray typedArray = activity.obtainStyledAttributes(ArrayUtils.toInt(black.com.android.internal.R.styleable.Window.get()));
            if (typedArray != null) {
                boolean isShowWallpaper = typedArray.getBoolean(black.com.android.internal.R.styleable.Window_windowShowWallpaper.get(), false);
                if (isShowWallpaper) {
                    activity.getWindow().setBackgroundDrawable(WallpaperManager.getInstance(activity).getDrawable());
                }

                boolean isFullscreen = typedArray.getBoolean(black.com.android.internal.R.styleable.Window_windowFullscreen.get(), false);
                if (isFullscreen) {
                    activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
                }
                typedArray.recycle();
            }
        } catch (Throwable e) {
            e.printStackTrace();
        }

        if (BuildCompat.isL()) {
            Intent intent = activity.getIntent();
            ApplicationInfo applicationInfo = baseContext.getApplicationInfo();
            PackageManager packageManager = activity.getPackageManager();

            if (intent != null && activity.isTaskRoot()) {
                try {
                    String taskDescriptionLabel = TaskDescriptionCompat.getTaskDescriptionLabel(BActivityThread.getUserId(), applicationInfo.loadLabel(packageManager));

                    Bitmap icon = null;
                    Drawable activityIcon = getActivityIcon(activity);
                    if (activityIcon != null) {
                        ActivityManager activityManager = (ActivityManager) baseContext.getSystemService(Context.ACTIVITY_SERVICE);

                        int iconSize = activityManager.getLauncherLargeIconSize();
                        icon = DrawableUtils.drawableToBitmap(activityIcon, iconSize, iconSize);
                    }
                    activity.setTaskDescription(new ActivityManager.TaskDescription(taskDescriptionLabel, icon));
                } catch (Throwable e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private static Drawable getActivityIcon(Activity activity) {
        PackageManager packageManager = activity.getPackageManager();
        try {
            Drawable icon = packageManager.getActivityIcon(activity.getComponentName());
            if (icon != null) {
                return icon;
            }
        } catch (PackageManager.NameNotFoundException ignore) { }

        ApplicationInfo applicationInfo = activity.getApplicationInfo();
        return applicationInfo.loadIcon(packageManager);
    }
}
```

`Bcore/src/main/java/com/vcore/utils/compat/ActivityManagerCompat.java`:

```java
package com.vcore.utils.compat;

import android.app.Activity;
import android.content.Intent;
import android.os.IBinder;

import black.android.app.ActivityManagerNative;
import black.android.app.IActivityManager;
import black.android.app.IActivityManagerL;
import black.android.app.IActivityManagerN;

public class ActivityManagerCompat {
	/**
	 * Type for IActivityManager.getIntentSender: this PendingIntent is
	 * for a startActivity operation.
	 */
	public static final int INTENT_SENDER_ACTIVITY = 2;

	public static final int START_FLAG_DEBUG = 1<<1;
	public static final int START_FLAG_TRACK_ALLOCATION = 1<<2;
	public static final int START_FLAG_NATIVE_DEBUGGING = 1<<3;

	public static void finishActivity(IBinder token, int code, Intent data) {
		if (BuildCompat.isN()) {
			IActivityManagerN.finishActivity.call(ActivityManagerNative.getDefault.call(), token, code, data, 0);
		} else if (BuildCompat.isL()) {
			IActivityManagerL.finishActivity.call(ActivityManagerNative.getDefault.call(), token, code, data, false);
		}
	}

    public static void setActivityOrientation(Activity activity, int orientation) {
        try {
            activity.setRequestedOrientation(orientation);
        } catch (Throwable e) {
            e.printStackTrace();
            // Samsung is WindowManager.setRequestedOrientation
            Activity parent = black.android.app.Activity.mParent.get(activity);
            while (true) {
				Activity tmp = black.android.app.Activity.mParent.get(parent);
				if (tmp != null) {
					parent = tmp;
				} else {
					break;
				}
			}

            IBinder token = black.android.app.Activity.mToken.get(parent);
            try {
				IActivityManager.setRequestedOrientation.call(ActivityManagerNative.getDefault.call(), token, orientation);
            } catch (Throwable ex) {
                ex.printStackTrace();
            }
        }
    }
}

```

`Bcore/src/main/java/com/vcore/utils/compat/ApplicationThreadCompat.java`:

```java
package com.vcore.utils.compat;

import android.os.IBinder;
import android.os.IInterface;

import black.android.app.ApplicationThreadNative;
import black.android.app.IApplicationThread;

public class ApplicationThreadCompat {
    public static IInterface asInterface(IBinder binder) {
        if (BuildCompat.isOreo()) {
            return IApplicationThread.Stub.asInterface.call(binder);
        }
        return ApplicationThreadNative.asInterface.call(binder);
    }
}

```

`Bcore/src/main/java/com/vcore/utils/compat/BuildCompat.java`:

```java
package com.vcore.utils.compat;

import android.os.Build;

public class BuildCompat {

    // 14
    public static boolean isU() {
        return Build.VERSION.SDK_INT >= 34 || (Build.VERSION.SDK_INT >= 33 && Build.VERSION.PREVIEW_SDK_INT == 1);
    }

    // 13
    public static boolean isT() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S && Build.VERSION.PREVIEW_SDK_INT == 1);
    }

    // 12
    public static boolean isS() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.S || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R && Build.VERSION.PREVIEW_SDK_INT == 1);
    }

    // 11
    public static boolean isR() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.R || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && Build.VERSION.PREVIEW_SDK_INT == 1);
    }

    // 10
    public static boolean isQ() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P && Build.VERSION.PREVIEW_SDK_INT == 1);
    }

    // 9
    public static boolean isPie() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.P || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && Build.VERSION.PREVIEW_SDK_INT == 1);
    }

    // 8
    public static boolean isOreo() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.O || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N && Build.VERSION.PREVIEW_SDK_INT == 1);
    }

    // 7
    public static boolean isN() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.N || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && Build.VERSION.PREVIEW_SDK_INT == 1);
    }

    // 6
    public static boolean isM() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.M;
    }

    // 5
    public static boolean isL() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP;
    }

    public static boolean isSamsung() {
        return "samsung".equalsIgnoreCase(Build.BRAND) || "samsung".equalsIgnoreCase(Build.MANUFACTURER);
    }

    public static boolean isEMUI() {
        if (Build.DISPLAY.toUpperCase().startsWith("EMUI")) {
            return true;
        }

        String property = SystemPropertiesCompat.get("ro.build.version.emui");
        return property != null && property.contains("EmotionUI");
    }

    public static boolean isMIUI() {
        return SystemPropertiesCompat.getInt("ro.miui.ui.version.code", 0) > 0;
    }

    public static boolean isFlyme() {
        return Build.DISPLAY.toLowerCase().contains("flyme");
    }

    public static boolean isColorOS() {
        return SystemPropertiesCompat.isExist("ro.build.version.opporom") || SystemPropertiesCompat.isExist("ro.rom.different.version");
    }

    public static boolean is360UI() {
        String property = SystemPropertiesCompat.get("ro.build.uiversion");
        return property != null && property.toUpperCase().contains("360UI");
    }

    public static boolean isLetv() {
        return Build.MANUFACTURER.equalsIgnoreCase("Letv");
    }

    public static boolean isVivo() {
        return SystemPropertiesCompat.isExist("ro.vivo.os.build.display.id");
    }

    private static ROMType sRomType;
    public static ROMType getROMType() {
        if (sRomType == null) {
            if (isEMUI()) {
                sRomType = ROMType.EMUI;
            } else if (isMIUI()) {
                sRomType = ROMType.MIUI;
            } else if (isFlyme()) {
                sRomType = ROMType.FLYME;
            } else if (isColorOS()) {
                sRomType = ROMType.COLOR_OS;
            } else if (is360UI()) {
                sRomType = ROMType._360;
            } else if (isLetv()) {
                sRomType = ROMType.LETV;
            } else if (isVivo()) {
                sRomType = ROMType.VIVO;
            } else if (isSamsung()) {
                sRomType = ROMType.SAMSUNG;
            } else {
                sRomType = ROMType.OTHER;
            }
        }
        return sRomType;
    }

    public enum ROMType {
        EMUI,
        MIUI,
        FLYME,
        COLOR_OS,
        LETV,
        VIVO,
        _360,
        SAMSUNG,
        OTHER
    }
}
```

`Bcore/src/main/java/com/vcore/utils/compat/BundleCompat.java`:

```java
package com.vcore.utils.compat;

import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.os.IBinder;

public class BundleCompat {
    public static IBinder getBinder(Bundle bundle, String key) {
        if (Build.VERSION.SDK_INT >= 18) {
            return bundle.getBinder(key);
        }
        return black.android.os.Bundle.getIBinder.call(bundle, key);
    }

    public static void putBinder(Bundle bundle, String key, IBinder value) {
        if (Build.VERSION.SDK_INT >= 18) {
            bundle.putBinder(key, value);
        }
        black.android.os.Bundle.putIBinder.call(bundle, key, value);
    }

    public static void putBinder(Intent intent, String key, IBinder value) {
        Bundle bundle = new Bundle();
        putBinder(bundle, "binder", value);
        intent.putExtra(key, bundle);
    }

    public static IBinder getBinder(Intent intent, String key) {
        Bundle bundle = intent.getBundleExtra(key);
        if (bundle != null) {
            return getBinder(bundle, "binder");
        }
        return null;
    }
}

```

`Bcore/src/main/java/com/vcore/utils/compat/ContentProviderCompat.java`:

```java
package com.vcore.utils.compat;

import android.content.ContentProviderClient;
import android.content.Context;
import android.net.Uri;
import android.os.Build;
import android.os.Build.VERSION;
import android.os.Bundle;
import android.os.RemoteException;
import android.os.SystemClock;

public class ContentProviderCompat {
    public static Bundle call(Context context, Uri uri, String method, String arg, Bundle extras, int retryCount) throws IllegalAccessException {
        if (VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
            return context.getContentResolver().call(uri, method, arg, extras);
        }

        ContentProviderClient client = acquireContentProviderClientRetry(context, uri, retryCount);
        try {
            if (client == null) {
                throw new IllegalAccessException();
            }
            return client.call(method, arg, extras);
        } catch (RemoteException e) {
            throw new IllegalAccessException(e.getMessage());
        } finally {
            releaseQuietly(client);
        }
    }

    private static ContentProviderClient acquireContentProviderClient(Context context, Uri uri) {
        try {
            if (VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
                return context.getContentResolver().acquireUnstableContentProviderClient(uri);
            }
            return context.getContentResolver().acquireContentProviderClient(uri);
        } catch (SecurityException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static ContentProviderClient acquireContentProviderClientRetry(Context context, Uri uri, int retryCount) {
        ContentProviderClient client = acquireContentProviderClient(context, uri);
        if (client == null) {
            int retry = 0;
            while (retry < retryCount && client == null) {
                SystemClock.sleep(400);
                retry++;
                client = acquireContentProviderClient(context, uri);
            }
        }
        return client;
    }

    private static void releaseQuietly(ContentProviderClient client) {
        if (client != null) {
            try {
                if (VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                    client.close();
                } else {
                    client.release();
                }
            } catch (Exception ignored) { }
        }
    }
}

```

`Bcore/src/main/java/com/vcore/utils/compat/ContextCompat.java`:

```java
package com.vcore.utils.compat;

import android.content.Context;
import android.content.ContextWrapper;

import black.android.app.ContextImpl;
import black.android.app.ContextImplKitkat;
import black.android.content.AttributionSource;
import black.android.content.AttributionSourceState;
import black.android.content.ContentResolver;
import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;

public class ContextCompat {
    public static final String TAG = "ContextCompat";

    public static void fixAttributionSourceState(Object obj, int uid) {
        Object mAttributionSourceState;
        if (obj != null && AttributionSource.mAttributionSourceState != null) {
            mAttributionSourceState = AttributionSource.mAttributionSourceState.get(obj);

            AttributionSourceState.packageName.set(mAttributionSourceState, BlackBoxCore.getHostPkg());
            AttributionSourceState.uid.set(mAttributionSourceState, uid);
            fixAttributionSourceState(AttributionSource.getNext.call(obj), uid);
        }
    }

    public static void fix(Context context) {
        try {
            int deep = 0;
            while (context instanceof ContextWrapper) {
                context = ((ContextWrapper) context).getBaseContext();
                deep++;
                if (deep >= 10) {
                    return;
                }
            }

            ContextImpl.mPackageManager.set(context, null);
            try {
                context.getPackageManager();
            } catch (Throwable e) {
                e.printStackTrace();
            }

            ContextImpl.mBasePackageName.set(context, BlackBoxCore.getHostPkg());
            ContextImplKitkat.mOpPackageName.set(context, BlackBoxCore.getHostPkg());
            ContentResolver.mPackageName.set(context.getContentResolver(), BlackBoxCore.getHostPkg());

            if (BuildCompat.isS()) {
                fixAttributionSourceState(ContextImpl.getAttributionSource.call(context), BActivityThread.getBUid());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

`Bcore/src/main/java/com/vcore/utils/compat/PackageParserCompat.java`:

```java
package com.vcore.utils.compat;

import static android.os.Build.VERSION_CODES.LOLLIPOP;
import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
import static android.os.Build.VERSION_CODES.M;
import static android.os.Build.VERSION_CODES.N;

import android.content.pm.PackageParser;
import android.content.pm.PackageParser.Package;
import android.os.Build;
import android.util.DisplayMetrics;

import java.io.File;

import black.android.content.pm.PackageParserLollipop;
import black.android.content.pm.PackageParserLollipop22;
import black.android.content.pm.PackageParserMarshmallow;
import black.android.content.pm.PackageParserNougat;
import black.android.content.pm.PackageParserPie;
import com.vcore.BlackBoxCore;

public class PackageParserCompat {
    private static final int API_LEVEL = Build.VERSION.SDK_INT;

    public static PackageParser createParser() {
        if (BuildCompat.isQ()) {
            PackageParser packageParser = PackageParserPie._new.newInstance();
            packageParser.setCallback(new PackageParser.CallbackImpl(BlackBoxCore.getPackageManager()));
            return packageParser;
        } else if (API_LEVEL >= 28) {
            return PackageParserPie._new.newInstance();
        } else if (API_LEVEL >= M) {
            return PackageParserMarshmallow._new.newInstance();
        } else if (API_LEVEL >= LOLLIPOP_MR1) {
            return PackageParserLollipop22._new.newInstance();
        } else if (API_LEVEL >= LOLLIPOP) {
            return PackageParserLollipop._new.newInstance();
        }
        return null;
    }

    public static Package parsePackage(PackageParser parser, File packageFile, int flags) {
        if (BuildCompat.isPie()) {
            return PackageParserPie.parsePackage.call(parser, packageFile, flags);
        } else if (API_LEVEL >= M) {
            return PackageParserMarshmallow.parsePackage.call(parser, packageFile, flags);
        } else if (API_LEVEL >= LOLLIPOP_MR1) {
            return PackageParserLollipop22.parsePackage.call(parser, packageFile, flags);
        } else if (API_LEVEL >= LOLLIPOP) {
            return PackageParserLollipop.parsePackage.call(parser, packageFile, flags);
        }
        return black.android.content.pm.PackageParser.parsePackage.call(parser, packageFile, null, new DisplayMetrics(), flags);
    }

    public static void collectCertificates(PackageParser parser, Package p, int flags) {
        if (BuildCompat.isPie()) {
            PackageParserPie.collectCertificates.call(p, true);
        } else if (API_LEVEL >= N) {
            PackageParserNougat.collectCertificates.call(p, flags);
        } else if (API_LEVEL >= M) {
            PackageParserMarshmallow.collectCertificates.call(parser, p, flags);
        } else if (API_LEVEL >= LOLLIPOP_MR1) {
            PackageParserLollipop22.collectCertificates.call(parser, p, flags);
        } else if (API_LEVEL >= LOLLIPOP) {
            PackageParserLollipop.collectCertificates.call(parser, p, flags);
        }
        black.android.content.pm.PackageParser.collectCertificates.call(parser, p, flags);
    }
}

```

`Bcore/src/main/java/com/vcore/utils/compat/ParceledListSliceCompat.java`:

```java
package com.vcore.utils.compat;

import java.util.List;

import black.android.content.pm.ParceledListSlice;

public class ParceledListSliceCompat {
	public static Object create(List<?> list) {
		Object slice = ParceledListSlice._new1.newInstance(list);
		if (slice != null) {
			return slice;
		} else {
			slice = ParceledListSlice._new0.newInstance();
		}

		for (Object item : list) {
			ParceledListSlice.append.call(slice, item);
		}
		ParceledListSlice.setLastSlice.call(slice, true);
		return slice;
	}
}

```

`Bcore/src/main/java/com/vcore/utils/compat/StrictModeCompat.java`:

```java
package com.vcore.utils.compat;

import black.android.os.StrictMode;

public class StrictModeCompat {
    public static final int DETECT_VM_FILE_URI_EXPOSURE = StrictMode.DETECT_VM_FILE_URI_EXPOSURE.get() == null ?
            (0x20 << 8) : StrictMode.DETECT_VM_FILE_URI_EXPOSURE.get();

    public static final int PENALTY_DEATH_ON_FILE_URI_EXPOSURE = StrictMode.PENALTY_DEATH_ON_FILE_URI_EXPOSURE.get() == null ?
            (0x04 << 24) : StrictMode.PENALTY_DEATH_ON_FILE_URI_EXPOSURE.get();

    public static void disableDeathOnFileUriExposure() {
        try {
            StrictMode.disableDeathOnFileUriExposure.call();
        } catch (Throwable e) {
            try {
                int sVmPolicyMask = StrictMode.sVmPolicyMask.get();
                sVmPolicyMask &= ~(DETECT_VM_FILE_URI_EXPOSURE | PENALTY_DEATH_ON_FILE_URI_EXPOSURE);
                StrictMode.sVmPolicyMask.set(sVmPolicyMask);
            } catch (Throwable e2) {
                e2.printStackTrace();
            }
        }
    }
}

```

`Bcore/src/main/java/com/vcore/utils/compat/SystemPropertiesCompat.java`:

```java
package com.vcore.utils.compat;

import android.text.TextUtils;

import black.android.os.SystemProperties;

public class SystemPropertiesCompat {
    public static String get(String key, String def) {
        try {
            return SystemProperties.get0.call(key, def);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return def;
    }

    public static String get(String key) {
        try {
            return SystemProperties.get1.call(key);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static int getInt(String key, int def) {
        try {
            return SystemProperties.getInt.call(key, def);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return def;
    }

    public static boolean isExist(String key) {
        return !TextUtils.isEmpty(get(key));
    }
}

```

`Bcore/src/main/java/com/vcore/utils/compat/TaskDescriptionCompat.java`:

```java
package com.vcore.utils.compat;

import android.app.ActivityManager;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;

import java.util.Locale;

import com.vcore.BlackBoxCore;
import com.vcore.app.BActivityThread;
import com.vcore.utils.DrawableUtils;

public class TaskDescriptionCompat {
    public static ActivityManager.TaskDescription fix(ActivityManager.TaskDescription td) {
        String label = td.getLabel();
        Bitmap icon = td.getIcon();

        if (label != null && icon != null) {
            return td;
        }

        label = getTaskDescriptionLabel(BActivityThread.getUserId(), getApplicationLabel());
        Drawable drawable = getApplicationIcon();
        if (drawable == null) {
            return td;
        }

        ActivityManager am = (ActivityManager) BlackBoxCore.getContext().getSystemService(Context.ACTIVITY_SERVICE);
        int iconSize = am.getLauncherLargeIconSize();

        icon = DrawableUtils.drawableToBitmap(drawable, iconSize, iconSize);
        td = new ActivityManager.TaskDescription(label, icon, td.getPrimaryColor());
        return td;
    }

    public static String getTaskDescriptionLabel(int userId, CharSequence label) {
        return String.format(Locale.CHINA, "[B%d]%s", userId, label);
    }

    private static CharSequence getApplicationLabel() {
        try {
            PackageManager pm = BlackBoxCore.getPackageManager();
            return pm.getApplicationLabel(pm.getApplicationInfo(BActivityThread.getAppPackageName(), 0));
        } catch (PackageManager.NameNotFoundException ignore) {
            return null;
        }
    }

    private static Drawable getApplicationIcon() {
        try {
            return BlackBoxCore.getPackageManager().getApplicationIcon(BActivityThread.getAppPackageName());
        } catch (PackageManager.NameNotFoundException ignore) {
            return null;
        }
    }
}

```

`Bcore/src/main/java/com/vcore/utils/compat/XposedParserCompat.java`:

```java
package com.vcore.utils.compat;

import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import com.vcore.BlackBoxCore;
import com.vcore.entity.pm.InstalledModule;
import com.vcore.utils.CloseUtils;

public class XposedParserCompat {
    public static InstalledModule parseModule(ApplicationInfo applicationInfo) {
        try {
            PackageManager packageManager = BlackBoxCore.getPackageManager();
            InstalledModule module = new InstalledModule();
            module.packageName = applicationInfo.packageName;
            module.enable = false;
            module.desc = applicationInfo.metaData.getString("xposeddescription");
            module.name = applicationInfo.loadLabel(packageManager).toString();
            module.main = readMain(applicationInfo.sourceDir);
            return module;
        } catch (RuntimeException e) {
            return null;
        }
    }

    public static boolean isXPModule(String file) {
        try {
            String s = readMain(file);
            return s != null;
        } catch (Throwable ignored) {
            return false;
        }
    }

    private static String readMain(String apk) {
        ZipFile zipFile = null;
        try {
            zipFile = new ZipFile(new File(apk));
            ZipEntry entry = zipFile.getEntry("assets/xposed_init");
            if (entry == null) {
                throw new RuntimeException();
            }
            return getInputStreamContent(zipFile.getInputStream(entry)).trim();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            CloseUtils.close(zipFile);
        }
        return null;
    }

    private static String getInputStreamContent(InputStream stream) {
        BufferedReader reader = null;
        StringBuilder builder = new StringBuilder();
        try {
            reader = new BufferedReader(new InputStreamReader(stream));

            String line;
            while ((line = reader.readLine()) != null) {
                if (line.startsWith("#")) {
                    continue;
                }
                builder.append(line).append("\n");
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            CloseUtils.close(reader);
        }
        return builder.toString();
    }
}

```

`Bcore/src/main/java/com/vcore/utils/provider/ProviderCall.java`:

```java
package com.vcore.utils.provider;

import android.content.Context;
import android.net.Uri;
import android.os.Bundle;

import com.vcore.BlackBoxCore;
import com.vcore.utils.compat.ContentProviderCompat;

public class ProviderCall {
    public static Bundle callSafely(String authority, String methodName, String arg, Bundle bundle) {
        try {
            return call(authority, BlackBoxCore.getContext(), methodName, arg, bundle, 5);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static Bundle call(String authority, Context context, String method, String arg, Bundle bundle, int retryCount) throws IllegalAccessException {
        Uri uri = Uri.parse("content://" + authority);
        return ContentProviderCompat.call(context, uri, method, arg, bundle, retryCount);
    }
}

```

`Bcore/src/main/res/layout/activity_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical">

    <ImageView
        android:id="@+id/iv_icon"
        android:layout_width="60dp"
        android:layout_height="60dp" />
</LinearLayout>
```

`Bcore/src/main/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="black_box_service_name">:black</string>
</resources>
```

`Bcore/src/main/res/values/styles.xml`:

```xml
<resources>
    <style name="BTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">@android:color/transparent</item>
        <item name="android:windowDisablePreview">true</item>
    </style>

    <style name="LauncherTheme" parent="Theme.AppCompat.Light.NoActionBar" />
</resources>
```

`Bcore/src/main/res/xml/filepath.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<paths>
    <!--Context.getFilesDir() 位于/data/data/安装目录-->
    <files-path name="internalPath" path="." />
    <!--Context.getCacheDir()-->
    <cache-path name="cachePath" path="." />
    <!--Environment.getExternalStorageDirectory()-->
    <external-path name="externalPath" path="." />
    <!--Context.getExternalFilesDir(null)-->
    <external-files-path name="externalFPath" path="." />
</paths>
```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# Android-Virtual-Inject
An Android Injector aimed to inject through Virtual Space without root permissions.

## What Makes This Project Different from Others?
- **Android 14 support**: Provides compatibility with the latest version of Android.
- **Clean and modular code**: Easy to understand, maintain, and extend.
- **Fully open source**: No proprietary modules are used.
- **Easy to use UI**: The UI is simple and easy to use.

## Features
- [x] Non-root injection
- [x] Android 14 support
- [ ] Support for x86 and x86_64 

## Usage
1. Launch the Injector app.
2. Select a target app or game.
3. Browse for a target shared library to inject.
4. Click "Install" to install the app in the virtual environment.
5. Click "Inject," and the app should launch.

## Credits
NewBlackbox by ALEX5402: [GitHub](https://github.com/ALEX5402/NewBlackbox) <br />

## Contributions
Contributions are welcome to help improve this project! If you’re interested in adding features or enhancing functionality, feel free to submit a pull request or open an issue to discuss your ideas.

## Limitations
The injector is not compatible with games protected by anti-cheat mechanisms.

## Contact
For any questions, collaboration requests, or updates, feel free to reach out via:
- **Telegram Channel**: [Join Channel](https://t.me/reveny1) <br>
- **Telegram Contact**: [Contact Me](https://t.me/revenyy) <br>
- **Website**: [My Website](https://reveny.me) <br>
- **Email**: [contact@reveny.me](mailto:contact@reveny.me) <br>

## Support Me
If you'd like to support me, you can do so on [Patreon](https://www.patreon.com/c/Reveny)

## License
This project is licensed under the GPLv3 License. See the [LICENSE](LICENSE) file for details.

## Preview
<img src="https://github.com/reveny/Android-Virtual-Inject/blob/main/preview.jpg" width="350">

```

`app/build.gradle.kts`:

```kts
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("dev.rikka.tools.materialthemebuilder")
}

android {
    namespace = "com.reveny.virtualinject"
    compileSdk = 35

    defaultConfig {
        applicationId = "com.reveny.virtualinject"
        minSdk = 26
        targetSdk = 35
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }

    buildFeatures {
        buildConfig = true
        viewBinding = true
    }

    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }

    buildFeatures {
        aidl = true
        prefab = true
        viewBinding = true
        buildConfig = true
    }

    ndkVersion = (rootProject.ext["ndkVersion"] as String)
}

materialThemeBuilder {
    themes {
        for ((name, color) in listOf(
            "Sakura" to "FF9CA8",
        )) {
            create("Material$name") {
                lightThemeFormat = "ThemeOverlay.Light.%s"
                darkThemeFormat = "ThemeOverlay.Dark.%s"
                primaryColor = "#$color"
            }
        }
    }
    generatePalette = true
}

dependencies {
    implementation(project(":Bcore"))

    implementation(libs.bundles.androidx)
    implementation(libs.bundles.rikkax)
}

configurations.all {
    exclude("org.jetbrains", "annotations")
    exclude("androidx.appcompat", "appcompat")
}
```

`app/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
```

`app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES" tools:ignore="QueryAllPackagesPermission" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" tools:ignore="ScopedStorage" />

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:name="com.reveny.virtualinject.App"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"
        tools:targetApi="31">
        <activity
            android:name="com.reveny.virtualinject.ui.activity.MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

`app/src/main/java/com/reveny/virtualinject/App.java`:

```java
package com.reveny.virtualinject;

import android.app.Application;
import android.content.Context;
import android.content.SharedPreferences;

import androidx.preference.PreferenceManager;

import com.vcore.BlackBoxCore;
import com.vcore.app.configuration.ClientConfiguration;

public class App extends Application {
    private static App instance = null;
    private SharedPreferences pref;
    public static SharedPreferences getPreferences() {
        return instance.pref;
    }

    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        try {
            BlackBoxCore.get().doAttachBaseContext(base, new ClientConfiguration() {
                @Override
                public String getHostPackageName() {
                    return base.getPackageName();
                }
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onCreate() {
        super.onCreate();
        instance = this;
        pref = PreferenceManager.getDefaultSharedPreferences(this);
        BlackBoxCore.get().doCreate();
    }
}
```

`app/src/main/java/com/reveny/virtualinject/Application.java`:

```java
package com.reveny.virtualinject;

import android.content.Context;

import com.vcore.BlackBoxCore;
import com.vcore.app.configuration.ClientConfiguration;

public class Application extends android.app.Application {
    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        try {
            BlackBoxCore.get().doAttachBaseContext(base, new ClientConfiguration() {
                @Override
                public String getHostPackageName() {
                    return base.getPackageName();
                }
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onCreate() {
        super.onCreate();
        BlackBoxCore.get().doCreate();
    }
}

```

`app/src/main/java/com/reveny/virtualinject/MainActivity.java`:

```java
package com.reveny.virtualinject;

import android.os.Bundle;
import android.util.Log;

import androidx.activity.EdgeToEdge;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;

import com.vcore.BlackBoxCore;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        EdgeToEdge.enable(this);
        setContentView(R.layout.activity_main);
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.fragment_main), (v, insets) -> {
            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);
            return insets;
        });

        // Use package name to install provided that application has been install on device
        BlackBoxCore.get().installPackageAsUser("com.pixel.gun3d", 0);

        boolean isInstalled = BlackBoxCore.get().isInstalled("com.pixel.gun3d", 0);
        Log.i("VirtualInjectLog", "isInstalled: " + isInstalled);

        if (isInstalled) {
            // BlackBoxCore.get().launchApk("com.pixel.gun3d", 0);
        }
    }
}
```

`app/src/main/java/com/reveny/virtualinject/ui/activity/BaseActivity.java`:

```java
package com.reveny.virtualinject.ui.activity;

import android.app.ActivityManager;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.drawable.BitmapDrawable;
import android.os.Bundle;
import android.view.Window;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;


import com.reveny.virtualinject.util.ThemeUtil;

import rikka.material.app.MaterialActivity;

public class BaseActivity extends MaterialActivity {

    private static Bitmap icon = null;

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    }
    @Override
    protected void onStart() {
        super.onStart();
        for (var task : getSystemService(ActivityManager.class).getAppTasks()) {
            task.setExcludeFromRecents(false);
        }
        if (icon == null) {
            var drawable = getApplicationInfo().loadIcon(getPackageManager());
            if (drawable instanceof BitmapDrawable) {
                icon = ((BitmapDrawable) drawable).getBitmap();
            } else {
                icon = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
                final Canvas canvas = new Canvas(icon);
                drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
                drawable.draw(canvas);
            }
        }
        setTaskDescription(new ActivityManager.TaskDescription(getTitle().toString(), icon));
    }
    @Override
    public void onApplyUserThemeResource(@NonNull Resources.Theme theme, boolean isDecorView) {
        if (!ThemeUtil.isSystemAccent()) {
            theme.applyStyle(ThemeUtil.getColorThemeStyleRes(), true);
        }
    }

    @Override
    public void onApplyTranslucentSystemBars() {
        super.onApplyTranslucentSystemBars();
        Window window = getWindow();
        window.setStatusBarColor(Color.TRANSPARENT);
        window.setNavigationBarColor(Color.TRANSPARENT);
    }
}
```

`app/src/main/java/com/reveny/virtualinject/ui/activity/MainActivity.java`:

```java
package com.reveny.virtualinject.ui.activity;

import android.os.Bundle;

import com.reveny.virtualinject.R;
import com.reveny.virtualinject.databinding.ActivityMainBinding;
import com.reveny.virtualinject.ui.fragment.HomeFragment;

public class MainActivity extends BaseActivity {

    @Override
    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        ActivityMainBinding binding = ActivityMainBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());

        getSupportFragmentManager().beginTransaction().replace(R.id.container, new HomeFragment()).commit();
    }

}
```

`app/src/main/java/com/reveny/virtualinject/ui/dialog/BlurBehindDialogBuilder.java`:

```java
package com.reveny.virtualinject.ui.dialog;

import android.animation.ValueAnimator;
import android.annotation.SuppressLint;
import android.content.Context;
import android.os.Build;
import android.view.SurfaceControl;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.view.animation.DecelerateInterpolator;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;

import com.google.android.material.dialog.MaterialAlertDialogBuilder;

import java.lang.reflect.Method;

public class BlurBehindDialogBuilder extends MaterialAlertDialogBuilder {
    private static final boolean supportBlur = getSystemProperty("ro.surface_flinger.supports_background_blur", false) && !getSystemProperty("persist.sys.sf.disable_blurs", false);

    public BlurBehindDialogBuilder(@NonNull Context context) {
        super(context);
    }

    @NonNull
    @Override
    public AlertDialog create() {
        AlertDialog dialog = super.create();
        dialog.setOnShowListener(d -> setBackgroundBlurRadius(dialog));
        return dialog;
    }

    private void setBackgroundBlurRadius(AlertDialog dialog) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            Window window = dialog.getWindow();
            if (Build.VERSION.SDK_INT >= 31) {
                assert window != null;
                window.addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
                window.getAttributes().setBlurBehindRadius(53); //android.R.styleable.Window_windowBlurBehindRadius
                window.addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);
            } else if (supportBlur) {
                assert window != null;
                View view = window.getDecorView();
                ValueAnimator animator = ValueAnimator.ofInt(1, 153);
                animator.setInterpolator(new DecelerateInterpolator());
                try {
                    Object viewRootImpl = view.getClass().getMethod("getViewRootImpl").invoke(view);
                    if (viewRootImpl == null) {
                        return;
                    }
                    SurfaceControl surfaceControl = (SurfaceControl) viewRootImpl.getClass().getMethod("getSurfaceControl").invoke(viewRootImpl);

                    @SuppressLint("BlockedPrivateApi") Method setBackgroundBlurRadius = SurfaceControl.Transaction.class.getDeclaredMethod("setBackgroundBlurRadius", SurfaceControl.class, int.class);
                    animator.addUpdateListener(animation -> {
                        try {
                            SurfaceControl.Transaction transaction = new SurfaceControl.Transaction();
                            setBackgroundBlurRadius.invoke(transaction, surfaceControl, animation.getAnimatedValue());
                            transaction.apply();
                        } catch (Throwable ignored) {

                        }
                    });
                } catch (Throwable ignored) {

                }
                view.addOnAttachStateChangeListener(new View.OnAttachStateChangeListener() {
                    @Override
                    public void onViewAttachedToWindow(@NonNull View v) {
                    }

                    @Override
                    public void onViewDetachedFromWindow(@NonNull View v) {
                        animator.cancel();
                    }
                });
                animator.start();
            }
        }
    }

    public static boolean getSystemProperty(String key, boolean defaultValue) {
        boolean value = defaultValue;
        try {
            @SuppressLint("PrivateApi") Class<?> c = Class.forName("android.os.SystemProperties");
            Method get = c.getMethod("getBoolean", String.class, boolean.class);
            value = (boolean) get.invoke(c, key, defaultValue);
        } catch (Exception ignored) {

        }
        return value;
    }
}

```

`app/src/main/java/com/reveny/virtualinject/ui/fragment/BaseFragment.java`:

```java
package com.reveny.virtualinject.ui.fragment;

import android.view.View;

import androidx.appcompat.widget.Toolbar;
import androidx.fragment.app.Fragment;

public class BaseFragment extends Fragment {

    public void setupToolbar(Toolbar toolbar, View tipsView, int title, int menu) {
        setupToolbar(toolbar, tipsView, getString(title), menu, null);
    }

    public void setupToolbar(Toolbar toolbar, View tipsView, String title, int menu, View.OnClickListener navigationOnClickListener) {
        toolbar.setTitle(title);
        toolbar.setTooltipText(title);
        if (tipsView != null) tipsView.setTooltipText(title);
        if (menu != -1) {
            toolbar.inflateMenu(menu);
            toolbar.setOnMenuItemClickListener(this::onOptionsItemSelected);
            onPrepareOptionsMenu(toolbar.getMenu());
        }
    }

}

```

`app/src/main/java/com/reveny/virtualinject/ui/fragment/HomeFragment.java`:

```java
package com.reveny.virtualinject.ui.fragment;

import android.app.Activity;
import android.app.Dialog;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.text.method.LinkMovementMethod;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.Toast;
import android.content.Intent;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatDelegate;
import androidx.core.text.HtmlCompat;
import androidx.fragment.app.DialogFragment;

import com.reveny.virtualinject.BuildConfig;
import com.reveny.virtualinject.R;
import com.reveny.virtualinject.databinding.DialogAboutBinding;
import com.reveny.virtualinject.databinding.FragmentHomeBinding;
import com.reveny.virtualinject.ui.dialog.BlurBehindDialogBuilder;
import com.reveny.virtualinject.util.Utility;
import com.reveny.virtualinject.util.chrome.LinkTransformationMethod;
import com.vcore.BlackBoxCore;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.Objects;

import rikka.material.app.LocaleDelegate;

public class HomeFragment extends BaseFragment {
    private static final String TAG = "VirtualInjectLog";

    private String selectedApp;
    private String libraryPath;

    private FragmentHomeBinding binding;

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    }

    @Override
    public void onPrepareOptionsMenu(Menu menu) {
        menu.findItem(R.id.about).setOnMenuItemClickListener(item -> {
            showAbout();
            return true;
        });
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);

        if (requestCode != 1 || resultCode != Activity.RESULT_OK) {
            return;
        }

        if (data == null || data.getData() == null) {
            Toast.makeText(getActivity(), "File selection failed", Toast.LENGTH_SHORT).show();
            return;
        }

        Uri fileUri = data.getData();

        if (fileUri != null && fileUri.getPath() != null && fileUri.getPath().endsWith(".so")) {
            libraryPath = Objects.requireNonNull(fileUri.getPath()).replace("/document/primary:", Environment.getExternalStorageDirectory().getPath() + "/");
            Toast.makeText(getActivity(), "File Selected: " + libraryPath, Toast.LENGTH_LONG).show();

            // Define destination file in cache directory
            File dest = new File(requireContext().getCacheDir(), "libinject.so");

            try (InputStream inputStream = requireContext().getContentResolver().openInputStream(fileUri);
                 OutputStream outputStream = new FileOutputStream(dest)) {

                // Copy the file content from InputStream to OutputStream
                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    outputStream.write(buffer, 0, bytesRead);
                }

                Log.i(TAG, "Copied library file to: " + dest.getAbsolutePath());
                binding.libPath.setText(libraryPath);

            } catch (IOException e) {
                Log.e(TAG, "Failed to copy library file", e);
                Toast.makeText(getActivity(), "Failed to copy library file", Toast.LENGTH_SHORT).show();
                e.printStackTrace();
            }
        } else {
            Toast.makeText(getActivity(), "Invalid file type selected. Please select a .so or .dex file.", Toast.LENGTH_SHORT).show();
        }
    }

    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        binding = FragmentHomeBinding.inflate(inflater, container, false);
        setupToolbar(binding.toolbar, null, R.string.app_name, R.menu.menu_home);
        binding.toolbar.setNavigationIcon(null);
        binding.toolbar.setOnClickListener(null);
        binding.appBar.setLiftable(true);
        binding.nestedScrollView.getBorderViewDelegate().setBorderVisibilityChangedListener((top, oldTop, bottom, oldBottom) -> binding.appBar.setLifted(!top));
        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM);

        setupApplist();

        binding.libPathChoose.setEndIconOnClickListener(v -> {
            Intent chooseFile = new Intent(Intent.ACTION_GET_CONTENT);
            chooseFile.setType("*/*");

            // For .so
            chooseFile.putExtra(Intent.EXTRA_MIME_TYPES, new String[]{"application/octet-stream"});
            chooseFile = Intent.createChooser(chooseFile, "Choose a .so file");
            startActivityForResult(chooseFile, 1);
        });

        binding.installButton.setOnClickListener(v -> {
            if (selectedApp != null) {
                Log.i(TAG, "Installing: " + selectedApp);
                BlackBoxCore.get().installPackageAsUser(selectedApp, 0);

                boolean isInstalled = BlackBoxCore.get().isInstalled(selectedApp, 0);
                Log.i(TAG, "isInstalled: " + isInstalled);
                if (!isInstalled) {
                    Toast.makeText(requireContext(), "Failed to install", Toast.LENGTH_SHORT).show();
                }

                Toast.makeText(requireContext(), "Installed", Toast.LENGTH_SHORT).show();
            } else {
                Toast.makeText(requireContext(), "Please select an app", Toast.LENGTH_SHORT).show();
            }
        });

        binding.launchButton.setOnClickListener(v -> {
            if (selectedApp != null && libraryPath != null) {
                boolean isInstalled = BlackBoxCore.get().isInstalled(selectedApp, 0);
                if (!isInstalled) {
                    Toast.makeText(requireContext(), "Please install the app first", Toast.LENGTH_SHORT).show();
                    return;
                }
                Log.i(TAG, "Launching: " + selectedApp);
                BlackBoxCore.get().launchApk(selectedApp, 0);
            } else {
                Toast.makeText(requireContext(), "Please select a valid app and library path", Toast.LENGTH_SHORT).show();
            }
        });

        return binding.getRoot();
    }

    private void setupApplist() {
        ArrayAdapter<String> adapter = new ArrayAdapter<>(
            requireContext(),
            android.R.layout.simple_dropdown_item_1line,
            Utility.getInstalledApps(requireContext())
        );
        binding.appSelectorText.setAdapter(adapter);

        binding.appSelectorText.setOnItemClickListener((parent, view, position, id) -> {
            String selected = (String) parent.getItemAtPosition(position);
            selectedApp = selected;
            Log.i(TAG, "Selected: " + selected);
        });
    }

    public static class AboutDialog extends DialogFragment {
        @NonNull
        @Override
        public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) {
            DialogAboutBinding binding = DialogAboutBinding.inflate(getLayoutInflater(), null, false);
            setupAboutDialog(binding);
            return new BlurBehindDialogBuilder(requireContext()).setView(binding.getRoot()).create();
        }

        private void setupAboutDialog(DialogAboutBinding binding) {
            binding.designAboutTitle.setText(R.string.app_name);
            binding.designAboutInfo.setMovementMethod(LinkMovementMethod.getInstance());
            binding.designAboutInfo.setTransformationMethod(new LinkTransformationMethod(requireActivity()));
            binding.designAboutInfo.setText(HtmlCompat.fromHtml(getString(
                    R.string.about_view_source_code,
                    "<b><a href=\"https://t.me/revenyy\">Telegram</a></b>",
                    "<b><a href=\"https://github.com/reveny/\">Reveny</a></b>"), HtmlCompat.FROM_HTML_MODE_LEGACY));
            binding.designAboutVersion.setText(String.format(LocaleDelegate.getDefaultLocale(), "%s (%d)", BuildConfig.VERSION_NAME, BuildConfig.VERSION_CODE));
        }
    }


    private void showAbout() {
        // Showing the About Dialog
        new AboutDialog().show(getChildFragmentManager(), "about");
    }


    @Override
    public void onDestroyView() {
        super.onDestroyView();
        binding = null;
    }
}
```

`app/src/main/java/com/reveny/virtualinject/util/NavUtil.java`:

```java
package com.reveny.virtualinject.util;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.net.Uri;
import android.widget.Toast;

import androidx.browser.customtabs.CustomTabColorSchemeParams;
import androidx.browser.customtabs.CustomTabsIntent;

import rikka.core.util.ResourceUtils;

public final class NavUtil {

    public static void startURL(Activity activity, Uri uri) {
        CustomTabsIntent.Builder customTabsIntent = new CustomTabsIntent.Builder();

        customTabsIntent.setShowTitle(true);

        CustomTabColorSchemeParams params = new CustomTabColorSchemeParams.Builder()
                .setToolbarColor(ResourceUtils.resolveColor(activity.getTheme(), android.R.attr.colorBackground))
                .setNavigationBarColor(ResourceUtils.resolveColor(activity.getTheme(), android.R.attr.navigationBarColor))
                .setNavigationBarDividerColor(0)
                .build();
        customTabsIntent.setDefaultColorSchemeParams(params);

        boolean night = ResourceUtils.isNightMode(activity.getResources().getConfiguration());
        customTabsIntent.setColorScheme(night ? CustomTabsIntent.COLOR_SCHEME_DARK : CustomTabsIntent.COLOR_SCHEME_LIGHT);

        try {
            customTabsIntent.build().launchUrl(activity, uri);
        } catch (ActivityNotFoundException ignored) {
            Toast.makeText(activity, uri.toString(), Toast.LENGTH_SHORT).show();
        }
    }

    public static void startURL(Activity activity, String url) {
        startURL(activity, Uri.parse(url));
    }
}
```

`app/src/main/java/com/reveny/virtualinject/util/ThemeUtil.java`:

```java
package com.reveny.virtualinject.util;

import android.content.SharedPreferences;

import androidx.annotation.StyleRes;

import com.google.android.material.color.DynamicColors;
import com.reveny.virtualinject.App;
import com.reveny.virtualinject.R;

import java.util.HashMap;
import java.util.Map;

public class ThemeUtil {
    private static final Map<String, Integer> colorThemeMap = new HashMap<>();
    private static final SharedPreferences preferences = App.getPreferences();

    static {
        colorThemeMap.put("MATERIAL_INDIGO", R.style.ThemeOverlay_MaterialSakura);
    }
    public static boolean isSystemAccent() {
        return DynamicColors.isDynamicColorAvailable() && preferences.getBoolean("follow_system_accent", true);
    }
    public static String getColorTheme() {
        return isSystemAccent() ? "SYSTEM" : preferences.getString("theme_color", "COLOR_SAKURA");
    }
    @StyleRes
    public static int getColorThemeStyleRes() {
        return colorThemeMap.getOrDefault(getColorTheme(), R.style.ThemeOverlay_MaterialSakura);
    }
}
```

`app/src/main/java/com/reveny/virtualinject/util/Utility.java`:

```java
package com.reveny.virtualinject.util;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;

import java.util.ArrayList;
import java.util.List;

public class Utility {
    public static List<String> getInstalledApps(Context context) {
        List<ApplicationInfo> packages = context.getPackageManager().getInstalledApplications(PackageManager.GET_META_DATA);
        List<String> ret = new ArrayList<>();

        for (ApplicationInfo appInfo : packages) {
            // Check if the application is not a system app and not the current app
            if ((appInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0 && !appInfo.packageName.equals(context.getPackageName())) {
                ret.add(appInfo.packageName);
            }
        }

        return ret;
    }
}

```

`app/src/main/java/com/reveny/virtualinject/util/chrome/CustomTabsURLSpan.java`:

```java
package com.reveny.virtualinject.util.chrome;

import android.app.Activity;
import android.text.style.URLSpan;
import android.view.View;

import com.reveny.virtualinject.util.NavUtil;


public class CustomTabsURLSpan extends URLSpan {

    private final Activity activity;

    public CustomTabsURLSpan(Activity activity, String url) {
        super(url);
        this.activity = activity;
    }

    @Override
    public void onClick(View widget) {
        String url = getURL();
        NavUtil.startURL(activity, url);
    }
}

```

`app/src/main/java/com/reveny/virtualinject/util/chrome/LinkTransformationMethod.java`:

```java
package com.reveny.virtualinject.util.chrome;

import android.app.Activity;
import android.graphics.Rect;
import android.text.Spannable;
import android.text.Spanned;
import android.text.method.TransformationMethod;
import android.text.style.URLSpan;
import android.view.View;
import android.widget.TextView;

public class LinkTransformationMethod implements TransformationMethod {

    private final Activity activity;

    public LinkTransformationMethod(Activity activity) {
        this.activity = activity;
    }

    @Override
    public CharSequence getTransformation(CharSequence source, View view) {
        if (view instanceof TextView) {
            TextView textView = (TextView) view;
            if (textView.getText() == null || !(textView.getText() instanceof Spannable)) {
                return source;
            }
            Spannable text = (Spannable) textView.getText();
            URLSpan[] spans = text.getSpans(0, textView.length(), URLSpan.class);
            for (int i = spans.length - 1; i >= 0; i--) {
                URLSpan oldSpan = spans[i];
                int start = text.getSpanStart(oldSpan);
                int end = text.getSpanEnd(oldSpan);
                String url = oldSpan.getURL();
                text.removeSpan(oldSpan);
                text.setSpan(new CustomTabsURLSpan(activity, url), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
            return text;
        }
        return source;
    }

    @Override
    public void onFocusChanged(View view, CharSequence sourceText, boolean focused, int direction, Rect previouslyFocusedRect) {
    }
}

```

`app/src/main/res/drawable/folder_open_outline.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
  <path
      android:pathData="M18.291,22.75H5.711C2.311,22.75 2.131,20.88 1.981,19.37L1.581,14.36C1.491,13.39 1.771,12.42 2.391,11.64C3.131,10.74 4.181,10.25 5.311,10.25H18.691C19.801,10.25 20.851,10.74 21.561,11.59L21.731,11.82C22.271,12.56 22.511,13.46 22.421,14.37L22.021,19.36C21.871,20.88 21.691,22.75 18.291,22.75ZM5.311,11.75C4.641,11.75 4.001,12.05 3.581,12.57L3.511,12.64C3.191,13.05 3.021,13.63 3.081,14.23L3.481,19.24C3.621,20.7 3.681,21.25 5.711,21.25H18.291C20.331,21.25 20.381,20.7 20.521,19.23L20.921,14.22C20.981,13.63 20.811,13.04 20.421,12.58L20.321,12.46C19.871,11.99 19.301,11.75 18.681,11.75H5.311Z"
      android:fillColor="@android:color/white"/>
  <path
      android:pathData="M20.5,12.22C20.09,12.22 19.75,11.88 19.75,11.47V9.68C19.75,6.7 19.23,6.18 16.25,6.18H13.7C12.57,6.18 12.18,5.78 11.75,5.21L10.46,3.5C10.02,2.92 9.92,2.78 9.02,2.78H7.75C4.77,2.78 4.25,3.3 4.25,6.28V11.43C4.25,11.84 3.91,12.18 3.5,12.18C3.09,12.18 2.75,11.84 2.75,11.43V6.28C2.75,2.45 3.92,1.28 7.75,1.28H9.03C10.57,1.28 11.05,1.78 11.67,2.6L12.95,4.3C13.22,4.66 13.24,4.68 13.71,4.68H16.26C20.09,4.68 21.26,5.85 21.26,9.68V11.47C21.25,11.88 20.91,12.22 20.5,12.22Z"
      android:fillColor="@android:color/white"/>
  <path
      android:pathData="M14.57,17.75H9.43C9.02,17.75 8.68,17.41 8.68,17C8.68,16.59 9.02,16.25 9.43,16.25H14.57C14.98,16.25 15.32,16.59 15.32,17C15.32,17.41 14.99,17.75 14.57,17.75Z"
      android:fillColor="@android:color/white"/>
</vector>

```

`app/src/main/res/drawable/ic_launcher.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:autoMirrored="true"
    android:tint="?attr/colorControlNormal"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,2C6.49,2 2,6.49 2,12C2,17.51 6.49,22 12,22C17.51,22 22,17.51 22,12C22,6.49 17.51,2 12,2ZM15.36,14.3C15.65,14.59 15.65,15.07 15.36,15.36C15.21,15.51 15.02,15.58 14.83,15.58C14.64,15.58 14.45,15.51 14.3,15.36L12,13.06L9.7,15.36C9.55,15.51 9.36,15.58 9.17,15.58C8.98,15.58 8.79,15.51 8.64,15.36C8.35,15.07 8.35,14.59 8.64,14.3L10.94,12L8.64,9.7C8.35,9.41 8.35,8.93 8.64,8.64C8.93,8.35 9.41,8.35 9.7,8.64L12,10.94L14.3,8.64C14.59,8.35 15.07,8.35 15.36,8.64C15.65,8.93 15.65,9.41 15.36,9.7L13.06,12L15.36,14.3Z" />
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,22.631C11.33,22.631 10.65,22.481 10.12,22.171L4.62,19.001C2.38,17.491 2.24,17.261 2.24,14.891V9.111C2.24,6.741 2.37,6.511 4.57,5.021L10.11,1.821C11.16,1.211 12.81,1.211 13.86,1.821L19.38,5.001C21.62,6.511 21.76,6.741 21.76,9.111V14.881C21.76,17.251 21.63,17.481 19.43,18.971L13.89,22.171C13.35,22.481 12.67,22.631 12,22.631ZM12,2.871C11.58,2.871 11.17,2.951 10.88,3.121L5.38,6.301C3.75,7.401 3.75,7.401 3.75,9.111V14.881C3.75,16.591 3.75,16.591 5.42,17.721L10.88,20.871C11.47,21.211 12.54,21.211 13.13,20.871L18.63,17.691C20.25,16.591 20.25,16.591 20.25,14.881V9.111C20.25,7.401 20.25,7.401 18.58,6.271L13.12,3.121C12.83,2.951 12.42,2.871 12,2.871Z" />
</vector>

```

`app/src/main/res/drawable/ic_launcher_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#3DDC84"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
</vector>

```

`app/src/main/res/drawable/ic_launcher_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>
```

`app/src/main/res/drawable/iconsax_closecircle.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:autoMirrored="true"
    android:viewportWidth="24"
    android:viewportHeight="24">

    <path
        android:fillColor="@color/material_red_600"
        android:pathData="M12,2C6.49,2 2,6.49 2,12C2,17.51 6.49,22 12,22C17.51,22 22,17.51 22,12C22,6.49 17.51,2 12,2ZM15.36,14.3C15.65,14.59 15.65,15.07 15.36,15.36C15.21,15.51 15.02,15.58 14.83,15.58C14.64,15.58 14.45,15.51 14.3,15.36L12,13.06L9.7,15.36C9.55,15.51 9.36,15.58 9.17,15.58C8.98,15.58 8.79,15.51 8.64,15.36C8.35,15.07 8.35,14.59 8.64,14.3L10.94,12L8.64,9.7C8.35,9.41 8.35,8.93 8.64,8.64C8.93,8.35 9.41,8.35 9.7,8.64L12,10.94L14.3,8.64C14.59,8.35 15.07,8.35 15.36,8.64C15.65,8.93 15.65,9.41 15.36,9.7L13.06,12L15.36,14.3Z" />

</vector>

```

`app/src/main/res/drawable/iconsax_tickcircle.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:autoMirrored="true"
    android:viewportWidth="24"
    android:viewportHeight="24">

    <path
        android:fillColor="@color/material_green_600"
        android:pathData="M12,2C6.49,2 2,6.49 2,12C2,17.51 6.49,22 12,22C17.51,22 22,17.51 22,12C22,6.49 17.51,2 12,2ZM16.78,9.7L11.11,15.37C10.97,15.51 10.78,15.59 10.58,15.59C10.38,15.59 10.19,15.51 10.05,15.37L7.22,12.54C6.93,12.25 6.93,11.77 7.22,11.48C7.51,11.19 7.99,11.19 8.28,11.48L10.58,13.78L15.72,8.64C16.01,8.35 16.49,8.35 16.78,8.64C17.07,8.93 17.07,9.4 16.78,9.7Z" />

</vector>

```

`app/src/main/res/layout/activity_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:tools="http://schemas.android.com/tools"
    tools:shrinkMode="strict"
    app:edgeToEdge="true">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/container"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <androidx.fragment.app.FragmentContainerView
            android:id="@+id/fragment_main"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:background="?android:colorBackground"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"/>

    </androidx.constraintlayout.widget.ConstraintLayout>
</androidx.coordinatorlayout.widget.CoordinatorLayout>

```

`app/src/main/res/layout/dialog_about.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:orientation="horizontal"
    tools:shrinkMode="strict"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="24dp">

    <ImageView
        android:id="@+id/design_about_icon"
        android:layout_width="48dp"
        android:layout_height="48dp"
        app:srcCompat="@drawable/ic_launcher"
        tools:ignore="ContentDescription" />

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="16dp">

        <com.google.android.material.textview.MaterialTextView
            android:id="@+id/design_about_title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="18sp"
            android:textAppearance="@android:style/TextAppearance.Material.Body1" />

        <com.google.android.material.textview.MaterialTextView
            android:id="@+id/design_about_version"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="14sp" />

        <com.google.android.material.textview.MaterialTextView
            android:id="@+id/design_about_info"
            android:layout_marginTop="24dp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="14sp"
            android:textColor="?android:textColorSecondary" />

    </LinearLayout>

</LinearLayout>

```

`app/src/main/res/layout/dialog_item.xml`:

```xml
<com.google.android.material.textview.MaterialTextView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/item"
    style="@style/TextAppearance.MaterialComponents.Body2"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:shrinkMode="strict"
    android:gravity="center_vertical|start"
    android:minHeight="?attr/listPreferredItemHeight"
    android:paddingStart="?attr/listPreferredItemPaddingStart"
    android:paddingEnd="?attr/listPreferredItemPaddingEnd"
    android:textAlignment="viewStart" />

```

`app/src/main/res/layout/dialog_title.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.textview.MaterialTextView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/title"
    tools:shrinkMode="strict"
    style="@style/MaterialAlertDialog.Material3.Title.Text.CenterStacked"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingTop="?attr/dialogPreferredPadding"
    android:paddingBottom="?attr/dialogPreferredPadding" />

```

`app/src/main/res/layout/fragment_home.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/fragment_container"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:consumeSystemWindowsInsets="@integer/internal_fragment_insets"
    app:edgeToEdge="true"
    app:fitsSystemWindowsInsets="@integer/internal_fragment_insets"
    tools:shrinkMode="strict">

    <com.google.android.material.appbar.AppBarLayout
        android:id="@+id/app_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:fitsSystemWindows="false"
        app:fitsSystemWindowsInsets="@integer/internal_fragment_top_insets">

        <com.google.android.material.appbar.CollapsingToolbarLayout
            android:id="@+id/toolbar_layout"
            style="?collapsingToolbarLayoutLargeStyle"
            android:layout_width="match_parent"
            android:layout_height="?collapsingToolbarLayoutMediumSize"
            android:fitsSystemWindows="false"
            app:titleCollapseMode="fade">

            <com.google.android.material.appbar.MaterialToolbar
                android:id="@+id/toolbar"
                android:layout_width="match_parent"
                android:layout_height="?actionBarSize"
                android:elevation="0dp"
                app:layout_collapseMode="pin"
                tools:ignore="PrivateResource" />
        </com.google.android.material.appbar.CollapsingToolbarLayout>


    </com.google.android.material.appbar.AppBarLayout>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:fitsSystemWindowsInsets="@integer/internal_fragment_bottom_insets"
        app:layout_behavior="@string/appbar_scrolling_view_behavior"
        tools:ignore="MissingPrefix">

        <rikka.widget.borderview.BorderNestedScrollView
            android:id="@+id/nestedScrollView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:scrollbars="none"
            app:borderBottomVisibility="never"
            app:borderTopDrawable="@null"
            app:borderTopVisibility="whenTop" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:animateLayoutChanges="true"
            android:orientation="vertical"
            android:paddingHorizontal="@dimen/m3_appbar_expanded_title_margin_horizontal"
            android:paddingVertical="?dialogPreferredPadding"
            tools:context=".ui.activity.MainActivity">

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/app_selector"
                style="@style/Widget.Material3.TextInputLayout.OutlinedBox.ExposedDropdownMenu"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="12dp"
                android:hint="Select Target Package">

                <AutoCompleteTextView
                    android:id="@+id/app_selector_text"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="none"
                    tools:ignore="LabelFor" />
            </com.google.android.material.textfield.TextInputLayout>

            <LinearLayout
                android:id="@+id/lib_path_holder"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="24dp">

                <com.google.android.material.textfield.TextInputLayout
                    android:id="@+id/libPathChoose"
                    style="@style/Widget.Material3.TextInputLayout.OutlinedBox"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="0.7"
                    android:hint="Library Path: "
                    app:endIconDrawable="@drawable/folder_open_outline"
                    app:endIconMode="custom">

                    <com.google.android.material.textfield.TextInputEditText
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:id="@+id/lib_path"
                        android:inputType="text" />

                </com.google.android.material.textfield.TextInputLayout>

            </LinearLayout>

        </LinearLayout>

    </FrameLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom"
        android:layout_marginBottom="16dp"
        android:orientation="horizontal"
        android:padding="16dp">

        <com.google.android.material.button.MaterialButton
            android:layout_width="0dp"
            android:id="@+id/install_button"
            android:layout_height="wrap_content"
            android:layout_marginEnd="8dp"
            android:layout_weight="1"
            android:text="Install" />

        <com.google.android.material.button.MaterialButton
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:id="@+id/launch_button"
            android:layout_marginStart="8dp"
            style="@style/Widget.Material3.Button.OutlinedButton"
            android:layout_weight="1"
            android:text="Launch" />

    </LinearLayout>

</androidx.coordinatorlayout.widget.CoordinatorLayout>

```

`app/src/main/res/menu/menu_home.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item
        android:id="@+id/about"
        android:showAsAction="never"
        android:title="@string/About" />
</menu>

```

`app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`app/src/main/res/values-night/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="home_secondary_outline_ambient_shadow_color">@color/material_grey_700</color>
    <color name="home_secondary_outline_spot_shadow_color">@color/material_grey_600</color>

    <color name="primary_text_material_inverse">@color/abc_primary_text_material_light</color>
    <color name="secondary_text_material_inverse">@color/abc_secondary_text_material_light</color>

    <color name="primary_text_material">@color/abc_primary_text_material_dark</color>
    <color name="secondary_text_material">@color/abc_secondary_text_material_dark</color>
</resources>

```

`app/src/main/res/values-night/styles.xml`:

```xml
<resources>

    <style name="AppTheme" parent="Theme" />
    <style name="ThemeOverlay.MaterialSakura" parent="ThemeOverlay.Dark.MaterialSakura"/>
</resources>
```

`app/src/main/res/values-night/themes.xml`:

```xml
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Base.Theme.VirtualInject" parent="Theme.Material3.DayNight.NoActionBar">
        <!-- Customize your dark theme here. -->
        <!-- <item name="colorPrimary">@color/my_dark_primary</item> -->
    </style>
</resources>
```

`app/src/main/res/values-sw600dp/integer.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer name="internal_fragment_bottom_insets">0x50</integer> <!-- bottom -->
</resources>


```

`app/src/main/res/values-v28/themes.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.Light" parent="Base.AppTheme.Light">
        <item name="android:windowLayoutInDisplayCutoutMode">shortEdges</item>
    </style>

    <style name="Theme" parent="Base.AppTheme">
        <item name="android:windowLayoutInDisplayCutoutMode">shortEdges</item>
    </style>

</resources>

```

`app/src/main/res/values-v30/themes.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.Light" parent="Base.AppTheme.Light">
        <item name="android:windowLayoutInDisplayCutoutMode">always</item>
    </style>

    <style name="Theme" parent="Base.AppTheme">
        <item name="android:windowLayoutInDisplayCutoutMode">always</item>
    </style>

</resources>

```

`app/src/main/res/values/attrs.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <attr name="colorNormal" format="color" />
    <attr name="colorInstall" format="color" />


    <declare-styleable name="SubtitleCollapsingToolbarLayout">
        <!-- Specifies extra space on the start, top, end and bottom sides of the the expanded title text.
             Margin values should be positive,
             subtitle will also be affected. -->
        <attr name="expandedTitleMargin" />
        <!-- Specifies extra space on the start side of the the expanded title text. Margin values should be positive,
             subtitle will also be affected. -->
        <attr name="expandedTitleMarginStart" />
        <!-- Specifies extra space on the top side of the the expanded title text. Margin values should be positive,
             subtitle will also be affected. -->
        <attr name="expandedTitleMarginTop" />
        <!-- Specifies extra space on the end side of the the expanded title text. Margin values should be positive,
             subtitle will also be affected. -->
        <attr name="expandedTitleMarginEnd" />
        <!-- Specifies extra space on the bottom side of the the expanded title text. Margin values should be positive,
             subtitle will also be affected. -->
        <attr name="expandedTitleMarginBottom" />

        <!-- The text appearance of the CollapsingToolbarLayout's title when it is fully 'expanded' -->
        <attr name="expandedTitleTextAppearance" />
        <!-- The text appearance of the CollapsingToolbarLayout's subtitle when it is fully 'expanded' -->
        <attr name="expandedSubtitleTextAppearance" format="reference" />
        <!-- The text appearance of the CollapsingToolbarLayouts title when it is fully 'collapsed' -->
        <attr name="collapsedTitleTextAppearance" />
        <!-- The text appearance of the CollapsingToolbarLayouts subtitle when it is fully 'collapsed' -->
        <attr name="collapsedSubtitleTextAppearance" format="reference" />

        <!-- The drawable to use as a scrim on top of the CollapsingToolbarLayouts
             content when it has been scrolled sufficiently off screen. -->
        <attr name="contentScrim" />
        <!-- The drawable to use as a scrim for the status bar content when the
             CollapsingToolbarLayout has been scrolled sufficiently off screen.
             Only works on Lollipop with the correct setup. -->
        <attr name="statusBarScrim" />
        <!-- The id of the primary Toolbar child that you wish to use for the purpose of collapsing.
             This Toolbar descendant view does not need to be a direct child of the layout.
             If you do not set this, the first direct Toolbar child found will be used. -->
        <attr name="toolbarId" />
        <!-- Specifies the amount of visible height in pixels used to define when to trigger a
             scrim visibility change. -->
        <attr name="scrimVisibleHeightTrigger" />
        <!-- Specifies the duration used for scrim visibility animations. -->
        <attr name="scrimAnimationDuration" />

        <!-- Specifies how the title should be positioned when collapsed,
             subtitle will also be affected. -->
        <attr name="collapsedTitleGravity" />
        <!-- Specifies how the title should be positioned when expanded,
             subtitle will also be affected. -->
        <attr name="expandedTitleGravity" />

        <!-- Whether the CollapsingToolbarLayout should draw its own shrinking/growing title. -->
        <attr name="titleEnabled" />
        <!-- The title to show when titleEnabled is set to true. -->
        <attr name="title" />
        <!-- The subtitle to show when titleEnabled is set to true. -->
        <attr name="subtitle" />
    </declare-styleable>

</resources>

```

`app/src/main/res/values/colors.xml`:

```xml
<resources>
    <color name="home_secondary_outline_ambient_shadow_color">@color/material_grey_500</color>
    <color name="home_secondary_outline_spot_shadow_color">@color/material_grey_300</color>

    <color name="primary_text_material_inverse">@color/abc_primary_text_material_dark</color>
    <color name="secondary_text_material_inverse">@color/abc_secondary_text_material_dark</color>

    <color name="primary_text_material">@color/abc_primary_text_material_light</color>
    <color name="secondary_text_material">@color/abc_secondary_text_material_light</color>
</resources>
```

`app/src/main/res/values/colors_google.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="google_blue_600">#1A73E8</color>
    <color name="google_blue_300">#8AB4F8</color>
</resources>

```

`app/src/main/res/values/integer.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer name="internal_fragment_insets">0x00800007</integer>
    <integer name="internal_fragment_top_insets">0x30</integer>
    <integer name="internal_fragment_bottom_insets">0</integer>
</resources>

```

`app/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="app_name">Virtual Inject</string>
    <string name="about_view_source_code"><![CDATA[<br>Join our %1$s channel<br/><br>Copyright © %2$s<br/>]]></string>
    <string name="About">About</string>
</resources>
```

`app/src/main/res/values/styles.xml`:

```xml
<resources>

    <style name="AppTheme" parent="Theme.Light" />

    <!-- SubtitleCollapsingToolbarLayout styles -->
    <style name="Widget.Design.SubtitleCollapsingToolbar" parent="Widget.Design.CollapsingToolbar" />

    <style name="TextAppearance.Design.SubtitleCollapsingToolbar.ExpandedTitle" parent="TextAppearance.Design.CollapsingToolbar.Expanded" />

    <style name="TextAppearance.Design.SubtitleCollapsingToolbar.ExpandedSubtitle" parent="TextAppearance.AppCompat.Title">
        <item name="android:textColor">?android:attr/textColorSecondary</item>
    </style>

    <style name="language_menu_style" parent="ThemeOverlay.Preference.SimpleMenuPreference.PopupMenu">
        <item name="android:textAlignment">textStart</item>
    </style>
    <style name="Widget.Button.TextButton.Dialog.FullWidth" parent="Widget.Material3.Button.TextButton.Dialog.Flush">
        <item name="android:layout_width">0dp</item>
        <item name="android:layout_weight">1</item>
        <item name="android:maxWidth">@null</item>
    </style>
    <style name="ThemeOverlay.MaterialAlertDialog.Centered.FullWidthButtons" parent="ThemeOverlay.Material3.MaterialAlertDialog.Centered">
        <!-- Mark spacer as gone when showing full width buttons -->
        <item name="materialAlertDialogButtonSpacerVisibility">2</item>
        <item name="buttonBarPositiveButtonStyle">@style/Widget.Button.TextButton.Dialog.FullWidth</item>
        <item name="buttonBarNegativeButtonStyle">@style/Widget.Button.TextButton.Dialog.FullWidth</item>
        <item name="buttonBarNeutralButtonStyle">@style/Widget.Button.TextButton.Dialog.FullWidth</item>
    </style>
    <style name="ThemeOverlay.MaterialAlertDialog.FullWidthButtons" parent="ThemeOverlay.Material3.MaterialAlertDialog">
        <!-- Mark spacer as gone when showing full width buttons -->
        <item name="materialAlertDialogButtonSpacerVisibility">2</item>
        <item name="buttonBarPositiveButtonStyle">@style/Widget.Button.TextButton.Dialog.FullWidth</item>
        <item name="buttonBarNegativeButtonStyle">@style/Widget.Button.TextButton.Dialog.FullWidth</item>
        <item name="buttonBarNeutralButtonStyle">@style/Widget.Button.TextButton.Dialog.FullWidth</item>
    </style>
</resources>

```

`app/src/main/res/values/themes.xml`:

```xml
<resources>

    <style name="Base.AppTheme.Light" parent="Theme.Material3.DynamicColors.Light.Rikka">
        <item name="android:windowLightStatusBar">true</item>
        <item name="colorPrimaryVariant">@color/primary_dark_light_light_status_bar</item>

        <item name="android:statusBarColor">?android:colorBackground</item>
        <item name="android:windowActionBar">false</item>
        <item name="android:windowNoTitle">true</item>
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>

        <!-- Preference title -->
        <item name="android:textAppearanceListItem">?textAppearanceSubtitle1</item>
        <!-- Preference category title -->
        <item name="android:colorAccent">?colorPrimary</item>
        <!-- Preference switch -->
        <item name="android:colorControlActivated">?colorPrimary</item>
    </style>

    <style name="Theme.Light" parent="Base.AppTheme.Light" />

    <style name="Base.AppTheme" parent="Theme.Material3.DynamicColors.Dark.Rikka">
        <item name="android:windowActionBar">false</item>
        <item name="android:windowNoTitle">true</item>
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>

        <!-- Preference title -->
        <item name="android:textAppearanceListItem">?textAppearanceSubtitle1</item>
        <!-- Preference category title -->
        <item name="android:colorAccent">?colorPrimary</item>
        <!-- Preference switch -->
        <item name="android:colorControlActivated">?colorPrimary</item>
    </style>

    <style name="Theme" parent="Base.AppTheme" />
    <style name="Label">
        <item name="android:textAlignment">viewStart</item>
        <item name="android:textAppearance">@style/TextAppearance.MaterialComponents.Body1</item>
        <item name="android:textColor">?android:attr/textColorSecondary</item>
    </style>

</resources>

```

`app/src/main/res/values/themes_custom.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><resources>
    <style name="ThemeOverlay.MaterialSakura" parent="ThemeOverlay.Light.MaterialSakura"/>
</resources>

```

`app/src/main/res/values/themes_override.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools" tools:ignore="PrivateResource,UnusedResources">

    <!-- Add android:colorControlNormal -->
    <style name="Base.ThemeOverlay.AppCompat.ActionBar" tools:override="true">
        <item name="android:colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="searchViewStyle">@style/Widget.AppCompat.SearchView.ActionBar</item>
    </style>

    <style name="Base.ThemeOverlay.AppCompat.Dark.ActionBar" tools:override="true">
        <item name="android:colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="searchViewStyle">@style/Widget.AppCompat.SearchView.ActionBar</item>
    </style>

    <style name="Widget.MaterialComponents.CompoundButton.CheckBox" parent="Widget.AppCompat.CompoundButton.CheckBox" tools:override="true">
        <item name="enforceMaterialTheme">true</item>
        <item name="useMaterialThemeColors">true</item>
    </style>

    <style name="Widget.MaterialComponents.CompoundButton.RadioButton" parent="Widget.AppCompat.CompoundButton.RadioButton" tools:override="true">
        <item name="enforceMaterialTheme">true</item>
        <item name="useMaterialThemeColors">true</item>
    </style>

    <style name="ThemeOverlay.Material.Dialog.ColorPicker" parent="@style/ThemeOverlay.Material3.MaterialAlertDialog.Centered" tools:override="true" />

    <!-- Base themes -->
    <style name="Base.Light" parent="Theme.Material3.Light" tools:override="true">
        <item name="android:statusBarColor">?android:colorBackground</item>
        <item name="android:ambientShadowAlpha">@dimen/ambient_shadow_alpha</item>
        <item name="android:spotShadowAlpha">@dimen/spot_shadow_alpha</item>

        <item name="colorPrimary">@color/primary_light</item>
        <item name="colorPrimaryVariant">@color/primary_dark_light</item>
        <item name="swipeRefreshLayoutProgressSpinnerBackgroundColor">?cardBackground</item>

        <item name="colorAlert">@color/material_red_A200</item>
        <item name="colorSafe">@color/material_green_600</item>
        <item name="colorWarning">@color/material_orange_700</item>
        <item name="colorInactive" tools:ignore="PrivateResource">@color/material_grey_600</item>

        <item name="navigationBarDividerColor">@android:color/transparent</item>
    </style>

    <style name="Base" parent="Theme.Material3.Dark" tools:override="true">
        <item name="android:statusBarColor">?android:colorBackground</item>
        <item name="android:ambientShadowAlpha">@dimen/ambient_shadow_alpha</item>
        <item name="android:spotShadowAlpha">@dimen/spot_shadow_alpha</item>

        <item name="colorPrimary">@color/primary_dark</item>
        <item name="colorPrimaryVariant">@color/primary_dark_dark</item>
        <item name="swipeRefreshLayoutProgressSpinnerBackgroundColor">?cardBackground</item>

        <item name="colorAlert">@color/material_red_A100</item>
        <item name="colorSafe">@color/material_green_A100</item>
        <item name="colorWarning">@color/material_orange_A100</item>

        <item name="navigationBarDividerColor">@android:color/transparent</item>
    </style>
</resources>

```

`app/src/main/res/xml/backup_rules.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older that API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>
```

`app/src/main/res/xml/data_extraction_rules.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>
```

`app/src/test/java/com/reveny/virtualinject/ExampleUnitTest.java`:

```java
package com.reveny.virtualinject;

import org.junit.Test;

import static org.junit.Assert.*;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() {
        assertEquals(4, 2 + 2);
    }
}
```

`build.gradle.kts`:

```kts
ext.apply {
    set("compileSdk", 35)
    set("targetSdk", 35)
    set("minSdk", 26)
    set("ndkVersion", "27.0.12077973")
    set("cmakeVersion", "3.22.1")
    set("ktx_version", "1.12.0")
    set("stdlib_version", "1.8.22")
    set("hiddenapibypass", "4.3")
    set("xcrashversion", "3.0.0")
    set("shadowhook", "1.0.8")
    set("googlematerial", "1.11.0")
}

buildscript {
    dependencies {
        classpath(libs.gradle)
    }
}

plugins {
    id("com.android.application") version "8.3.2" apply false
    id("org.jetbrains.kotlin.android") version "2.0.0" apply false
    id("com.android.library") version "8.3.2" apply false
    id("dev.rikka.tools.materialthemebuilder") version "1.4.1" apply false
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}
```

`gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. For more details, visit
# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
android.enableJetifier=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true
```

`gradle/libs.versions.toml`:

```toml
[versions]
agp = "8.6.1"
gradle = "8.3.2"

[plugins]
agp-app = { id = "com.android.application", version.ref = "agp" }
agp-lib = { id = "com.android.library", version.ref = "agp" }
materialthemebuilder = { id = "dev.rikka.tools.materialthemebuilder", version = "1.4.1" }

[libraries]

gradle = { module = "com.android.tools.build:gradle", version.ref = "gradle" }
rikkax-appcompat = { module = "dev.rikka.rikkax.appcompat:appcompat", version = "1.6.1" }
rikkax-core = { module = "dev.rikka.rikkax.core:core", version = "1.4.1" }
rikkax-insets = { module = "dev.rikka.rikkax.insets:insets", version = "1.3.0" }
rikkax-layoutinflater = { module = "dev.rikka.rikkax.layoutinflater:layoutinflater", version = "1.3.0" }
rikkax-material = { module = "dev.rikka.rikkax.material:material", version = "2.7.0" }
rikkax-preference = { module = "dev.rikka.rikkax.material:material-preference", version = "2.0.0" }
rikkax-recyclerview = { module = "dev.rikka.rikkax.recyclerview:recyclerview-ktx", version = "1.3.2" }
rikkax-widget-borderview = { module = "dev.rikka.rikkax.widget:borderview", version = "1.1.0" }
rikkax-widget-mainswitchbar = { module = "dev.rikka.rikkax.widget:mainswitchbar", version = "1.1.0" }

androidx-activity = { module = "androidx.activity:activity", version = "1.9.3" }
androidx-browser = { module = "androidx.browser:browser", version = "1.8.0" }
androidx-constraintlayout = { module = "androidx.constraintlayout:constraintlayout", version = "2.2.0" }
androidx-core = { module = "androidx.core:core", version = "1.15.0" }
androidx-fragment = { module = "androidx.fragment:fragment", version = "1.8.5" }
androidx-preference = { module = "androidx.preference:preference", version = "1.2.1" }
androidx-recyclerview = { module = "androidx.recyclerview:recyclerview", version = "1.3.2" }
androidx-swiperefreshlayout = { module = "androidx.swiperefreshlayout:swiperefreshlayout", version = "1.2.0-alpha01" }

material = { module = "com.google.android.material:material", version = "1.12.0" }

[bundles]
androidx = [ "androidx-activity", "androidx-browser", "androidx-constraintlayout", "androidx-core", "androidx-fragment", "androidx-preference", "androidx-recyclerview", "androidx-swiperefreshlayout" ]
rikkax = ["rikkax-appcompat", "rikkax-core", "rikkax-insets", "rikkax-layoutinflater", "rikkax-material", "rikkax-preference", "rikkax-recyclerview", "rikkax-widget-borderview", "rikkax-widget-mainswitchbar", "material"]

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
#Sat Nov 02 20:21:20 CET 2024
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.9-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`settings.gradle.kts`:

```kts
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode = RepositoriesMode.FAIL_ON_PROJECT_REPOS
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "Virtual Inject"
include(":app")
include(":Bcore")
```