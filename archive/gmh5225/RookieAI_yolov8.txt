Project Path: arc_gmh5225_RookieAI_yolov8_eu7rq260

Source Tree:

```txt
arc_gmh5225_RookieAI_yolov8_eu7rq260
├── Announcement.md
├── CHANGELOG.md
├── CODE_OF_CONDUCT.md
├── DLLs
│   ├── LGmouseControl
│   │   ├── Ghub64.dll
│   │   ├── Ghub86.dll
│   │   ├── MouseControl.dll
│   │   ├── ghub_device.dll
│   │   ├── lghub_installer - 2020.1.31550.0.exe.7z
│   │   ├── lghub_installer - 2021.3.5164.0 - 2021.3.9205.exe.7z
│   │   ├── lghub_installer - 2021.9.7463.0 - 2021.11.1775.exe
│   │   ├── lghub_installer - 2021.9.7463.0 - 2021.11.1775.exe.7z
│   │   └── logitech.driver.dll
│   ├── python_pyd
│   │   ├── kmNet.cp310-win_amd64.pyd
│   │   ├── kmNet.cp311-win_amd64.pyd
│   │   ├── kmNet.cp312-win_amd64.pyd
│   │   └── kmNet.cp313-win_amd64.pyd
│   └── x64_msdk.dll
├── LICENSE
├── Model
│   ├── YOLOV10SwarzoneLOCK420.engine
│   └── YOLOv8s_apex_teammate_enemy.pt
├── Module
│   ├── announcement.py
│   ├── config.py
│   ├── const.py
│   ├── control.py
│   ├── draw_screen.py
│   ├── jump_detection.py
│   ├── keyboard.py
│   └── logger.py
├── Parameter_explanation.md
├── README.md
├── RookieAI.py
├── Tools
│   ├── PT_to_TRT.py
│   ├── cuDNN_download_V9.3_12.6.bat
│   └── launcher.py
├── UI
│   ├── RookieAiWindow.ui
│   └── ico
│       ├── PlayVideo.png
│       ├── RedLine.png
│       ├── StopVideo.png
│       ├── back.png
│       ├── back_turn.png
│       ├── body_photo.png
│       ├── checkmark-transparent.gif
│       ├── checkmark-transparent_84FPS.png
│       ├── close-modified.png
│       ├── close.png
│       ├── error.png
│       ├── gear-modified.png
│       ├── gear.png
│       ├── loading.png
│       ├── plus_Sign.png
│       ├── restartr-modified.png
│       ├── retart.png
│       ├── ultralytics-botAvatarSrcUrl-1729379860806.png
│       ├── waiting.png
│       ├── warningtriangle_87535-modified.png
│       └── warningtriangle_87535.png
├── Utils
│   ├── exception.py
│   └── revision.py
├── __version__
├── customLib
│   ├── animated_status
│   │   ├── __init__.py
│   │   ├── animated_status_test_ui.py
│   │   └── animated_status_test_ui.ui
│   └── automatic_trigger_set_dialog
│       ├── __init__.py
│       ├── automaticEmergencyStop_set.ui
│       └── automaticTrigger_set.ui
├── images
│   ├── V3.0.png
│   └── V3.png
├── pyproject.toml
└── yolov8n.pt

```

`Announcement.md`:

```md
### $[2024/12/29 1:30:00]$

**V3.0.0.12**  版本预告

更新内容：

1. 新增可分别调整X轴Y轴瞄准速度。
2. 修复读取配置文件问题，并上传标准配置文件。

```

`CHANGELOG.md`:

```md
# Changelog
## [2025-03-02] - New Updates
- [`30658a3`](30658a34e4c1dcda46c061470e229a420ea96d84) 移动公告更新地址
- [`e6236df`](e6236df8164950d12557424d33acb4eb9ea20e82) 默认关闭跳变抑制 #105

## [2025-02-21] - New Updates
- [`4fadb11`](4fadb11eace3fb00b8f991bb3bf2874a042f7b87) Merge branch 'main' into dev
- [`b9f5629`](b9f5629ba39a38db955c64666fee28a6d3405bc1) 修复资源路径

## [2025-01-24] - New Updates
- [`3e17c5f`](3e17c5fe097406941d27e1b207f754ac7cb9853c) 优化日志记录
- [`e962099`](e962099d1a1ed42b5a6992d5a0e428c9e9281b51) 优化日志记录器
- [`2eb70e8`](2eb70e8b93df007d09b5434ed684be4a18f1969f) 删除无用方法

## [2025-01-22] - New Updates
- [`7a183a8`](7a183a893cb08d9057764a297ec986a51ca4fd92) refactor(RookieAI): 将日志级别从 info 改为 debug
- [`08c5d4c`](08c5d4c2d58fefca105ed35c0ecc7995a8892088) feat(Module): 重构 logger 模块并添加新的移动模式
- [`2fbfe41`](2fbfe41e107c271f42f074aaa8f5818421a81008) 自动扳机UI配置文件
- [`7a9d598`](7a9d5986455eb165a7cd5151a67d8bc7135a845d) build(dependencies): 更新项目依赖管理和安装流程
- [`3e4e9d2`](3e4e9d2d662ac681234d067fe4988f62f66a7f02) 修复公告获取

## [2025-01-18] - New Updates
- [`974e145`](974e14584992a1dd320bb2f12c87acfa8c3f07ac) 优化配置读取，避免命名空间污染
- [`0ff8085`](0ff80855eb12ba3f78641b2d39732533588459cf) 3.0.0.14(Beta) 新增自动扳机 完善跳变抑制

## [2025-01-16] - New Updates
- [`9c8af8f`](9c8af8f3f62d3f3eab66b06f5735d8f5ba8e72c7) Merge pull request #86 from Passer1072/create-pr/update_version
- [`a906b2c`](a906b2c1593704cd13a6f6f75b2d7c0c0b2b3086) resolve #89

## [2025-01-15] - New Updates
- [`e36427f`](e36427f1a8b5a266619a6de94873324037d71a93) strip and sync
- [`b156662`](b156662696960ec7f748d5b83b6ecd1d3f65a384) Merge branch 'main' into dev
- [`922846a`](922846a493d5067f1551df6481d9e16dbed3f970) Merge pull request #84 from Passer1072/create-pr/update_version
- [`9f16aaf`](9f16aaf0765a033de70937500635fa819d47bd41) 更新参数解释文档，移除未使用的配置
- [`a7f3ed6`](a7f3ed61b42135116a820ad423c1e9a389294be3) 鼠标移动方式支持选择`Logitech`和`mouse`

## [2025-01-07] - New Updates
- [`d5308bb`](d5308bb03879f3bb71a1174008233761bc3f269e) 格式化文档

## [2025-01-06] - New Updates
- [`2dc4edb`](2dc4edbf0f951bb474281c0b49494791ac8c41a3) 更新 README.md
- [`06f7c78`](06f7c788b12ae9a546f0b64ee4f6cc09fc9592d4) 修复公告获取&删除无用文件
- [`2390042`](239004288097d253b9417b9e7c7cd350207fc1b7) Merge pull request #83 from Passer1072/create-pr/update_version
- [`27506ce`](27506ce95d7eec744f67aa7cbaa1c4e596ca1fae) 修复action ci时区
- [`4b25c48`](4b25c48e2a60e4a99e4457a7f0ad1056218201d5) 优化错误捕捉，重命名部分函数
- [`81e1fdc`](81e1fdc4dc0573524eaa0db3ca7acc49561b805c) Merge pull request #82 from Passer1072/create-pr/update_version
- [`c4ce1af`](c4ce1af6b6a43da915c6cece13fe628a1c1183b7) 添加功能：跳变抑制

## [2025-01-05] - New Updates
- [`06f0f2f`](06f0f2fec9fb039a0b30caad705dbe1906d47b6c) feat(config): 添加默认配置并调整日志级别&&删除冗余代码
- [`e98652a`](e98652a7e2c5ba2fb1a8e26838b01f631f31cf4a) 公告使用多线程获取

## [2024-12-30] - New Updates
- [`6a04f62`](6a04f62c4525cd7327632afeed2f562b93bc1d76) Update README.md
- [`6249d78`](6249d78671391b0dcda882939d73a95ff18fdacf) Update README.md
- [`4972ebf`](4972ebf93d62055f8cc74e5b4834e4800cb7d328) Merge branch 'dev' of https://github.com/Passer1072/RookieAI_yolov8 into dev
- [`927fe3a`](927fe3a5288f421227b5770e2f89aecf541072ae) Merge branch 'dev' of https://github.com/Passer1072/RookieAI_yolov8 into dev
- [`0271cbd`](0271cbd68d1342a7310b95fa53bd4f24a6ba5b48) Update README.md

## [2024-12-29] - New Updates
- [`dee40b7`](dee40b7a6dddcea832147f83a6ff67ba40f86e39) 上传适配3.0.0.12的UI界面
- [`0b8bf63`](0b8bf6330e023807539ef0f9f8dc2682e8ca1645) 设置action为正确的时区

## [2024-12-28] - New Updates
- [`a31c545`](a31c545c3b9108494f34a30eed1d7877faa47c5d) 配置文件标准参考文件
- [`0776305`](0776305169159ca1498c622c4fd13111d56750fd) Update Announcement.md
- [`bdd7131`](bdd7131586fc68e8e873b3ea39f630e8a7f0611c) 功能更新: 可分别调整X轴Y轴移动速度
- [`c662aeb`](c662aebbd64723823bab8afd82bc093a27d3d1b2) refactor(RookieAI): 调整渲染超时时间，优化代码格式和结构

## [2024-12-27] - New Updates
- [`0f2b6d2`](0f2b6d22db2b94fddeb846d90e86d0ec92fa29a4) chore: 更新 .gitignore 文件,上传pyd
- [`b950a91`](b950a9117bb9c1348373c63cb16c054035f8ad80) refactor(control): 重构鼠标控制函数并优化鼠标模式参数传递
- [`b2cc8a9`](b2cc8a9a1ec5c1925b144b585df6f988f660ca76) refactor(RookieAI): 重构鼠标控制逻辑并移除未使用的 DLL 文件

## [2024-12-24] - New Updates
- [`95e1420`](95e1420bf7f176949330564bf93c2cebd055630b) Merge pull request #78 from Passer1072/create-pr/update_version

## [2024-12-23] - New Updates
- [`a5ae43a`](a5ae43a4dd181633f483610cb69611bfbb85252b) Merge branch 'dev' of https://github.com/Passer1072/RookieAI_yolov8 into dev
- [`32fd597`](32fd597010fff92c3935fc6e8ee6ae8db363eb37) 修改文件夹
- [`6126ab9`](6126ab9d6a06f253041f2be47d0e0ca0c0e1daf1) 功能添加

## [2024-12-20] - New Updates
- [`5716fea`](5716fea574737df21de1ae72cf859deadb6a0b8d) Merge branch 'dev' of github.com:Passer1072/RookieAI_yolov8 into dev
- [`7340c7f`](7340c7f450e9a98cb97ce6987c2414fa329bb622) refactor(Module): 移除配置文件中的默认值设置,初始化公告和渠道
- [`9176ef6`](9176ef66f229ef93002e9aef8ed57a2a73dce619) refactor(mouse): 修复路径问题

## [2024-12-01] - New Updates
- [`689b808`](689b8089ed90088d12ca78af881ac83d4418ce99) Merge pull request #80 from NovaShen555/dev

## [2024-11-29] - New Updates
- [`2d32c16`](2d32c16cb534bd5b3b11b7e81ace30d959c6c6fe) Merge branch 'dev' of github.com:Passer1072/RookieAI_yolov8 into dev
- [`30f79f6`](30f79f648d25951f1ad2dbd804ec1bbda1c89241) refactor(module): 重构配置文件保存路径并简化导入
- [`83b20ea`](83b20ea8760b04c87414d2139bc22c8add85e15c) Merge pull request #73 from Passer1072/create-pr/update_version
- [`b5a7ce6`](b5a7ce64f19603f1a0ac1963e787bf1f5bfaa59f) refactor(RookieAI): 重构代码并添加新功能
- Merge branch 'dev' of https://github.com/Passer1072/RookieAI_yolov8 into dev [`be7f202`](be7f2027c145aa4c04a75d1968a4551ee835409e)
- 整理 [`2e11232`](2e11232c422e56a523570d7ef5cef86cdf42dddf)

## [2024-11-26] - New Updates
- 补上传自定义动画库 [`3bbcd39`](3bbcd399701782ddcd3b75d4200c9c06b0094f45)

## [2024-11-25] - New Updates
- 瞄准逻辑优化 [`1661dd6`](1661dd66395b7c371fc072b7d005c21e422d2675)

## [2024-11-15] - New Updates
- ci: 更新版本解析正则表达式 [`f97b7fd`](f97b7fd25d13cee995a397f89ecb8d41e987b762)
- Merge pull request #72 from Passer1072/create-pr/update_version [`8a5421c`](8a5421cb3e9553aaad95c112d384c3054ac32f4a)
- 更新公告内容，增加对YOLO 11模型的支持说明，删除之前的日志文件和UI管理器，添加新的启动器脚本，并引入异步操作以优化效果，更新相关信息和方法以支持最新需求。 [`4d32681`](4d32681ca6b47fa17b222a4cb12d30f28df431ab)
- 更新 CHANGELOG 和版本更新工作流程，修正日期格式检查，优化条件判断逻辑，添加对拉取请求的写权限，调整步骤名称以提高清晰度。 [`941f3be`](941f3be7adba7e462432bc3c5f62b712a45d18b1)
- 更新 CHANGELOG 和版本更新工作流程，修正 DATE 格式检查，优化条件判断逻辑，添加对拉取请求的写权限，调整步骤名称以提高清晰度。 [`afa3967`](afa39671e14f83b4f47005f296ee5c2c48b13245)
- ci: 添加自动更新版本的 GitHub Actions 工作流 [`962dfc7`](962dfc7)
- 合并ui文件 [`f58534d`](f58534d)
- Create RookieAiWindow.ui [`3f52164`](3f52164)
- 优化V3版本模块调用 [`d3cd1c8`](d3cd1c8)
- 补传 [`8915777`](8915777)
- V3.0.0.5 [`17d67db`](17d67db)

## [2024-11-13] - New Updates
- 移除未使用的资源文件 [`346cab1`](346cab1)
- 更新文档 [`20816e3`](20816e3)

## [2024-11-09] - New Updates
- Merge branch 'dev' of https://github.com/Passer1072/RookieAI_yolov8.git [`57f8e8a`](57f8e8a)
- 分离常量，移除无用代码 [`e5197d5`](e5197d5)
- 整理开发文档 `7669530`

## [2024-11-01] - New Updates
- ci: 优化 CHANGELOG.md 更新流程，提高了脚本的可读性和维护性，同时减少了出错的可能性 `09ba22a`
- ci: 优化 CHANGELOG.md 自动更新流程 `e4e315f`
- refactor(RookieAI_YOLOv8): 初步分离主程序并添加日志功能 `0a134e7`

## [2024-09-14] - Version V2.5.7
- 尝试在AMD GPU上使用兼容模式运行

## [2024-09-06] - Version V2.5.6.1 (beta)
- 新增一些热键
- 新增热键：左Ctrl、右Ctrl、左Shift、右Shift、左Alt、右Alt

## [2024-08-26] - Version V2.5.6 (beta)
- 增加对于onnx模型的支持
- 新增全目标识别，支持编号为0-9的所有目标识别
- 新增onnx模型支持，配合工具快速部署onnx环境
- 移除“像素预测”，一并移除相关可调选项
- 注意：需要下载cuDNN以支持onnx模型

## [2024-08-19] - Version V2.5.5 (beta)
- 添加目标移动方向识别，预测瞄准位置
- 新增目标预判功能，手动预测开发中
- 新增鼠标平滑功能，优化鼠标移动
- 注意：鼠标平滑与目标预判不可同时开启

## [2024-08-16] - Version V2.5.3 (beta)
- 优化倍率预测，添加自瞄平滑功能
- 新增鼠标移动平滑处理
- 移除新分段瞄准模式，感觉没用
- 优化分段瞄准逻辑，使瞄准更加平滑自然

## [2024-07-15] - Update
- 版本：V2.4.4.2(beta)/V2.5.0(beta)
- 概要：V2.4.4.2(beta)版更新‘忽略颜色’功能/V2.5.0(beta)版重构代码，移除部分无用内容
- 新增：
  - V2.4.4.2(beta)忽略颜色功能，有助于单标签模型区分敌我。
  - V2.5.0(beta)添加自动开火，目标距离判断正在测试。
- 移除：
  - V2.5.0(beta)移除随机特征码。
- 优化：
  - V2.5.0(beta)，[@molanp](https://github.com/molanp)对V2.4.3版本的代码进行优化。
- Python要求：>=3.10。
- 新增文件：
  - V2.5.0(beta)。
- 感谢：
  - [@molanp](https://github.com/molanp)：重构并优化V2.4.3版本代码。
  - [@CougarP](https://github.com/Cougarp)：对于颜色忽略功能的支持。

## [2024-07-08] - Update
- 版本：V2.4.3
- 概要：V2.4.3正式版，添加辅助压枪功能
- 新增：
  - 辅助压枪，参数可通过对应参数设置页面调整。
  - 可在settings.json中将"deactivate_dxcam"设置为true禁用dxcam模块加载。
- 优化：
  - 通过匿名API来请求更新公告，速度更快更稳定，每小时60次请求限制。
- 注意：
  - 配置文件(settings.json)发生变更，注意替换。
- 感谢：
  - [@molanp](https://github.com/molanp)：提供使用API请求更新公告的办法，使请求与加载速度更快更稳定！

## [2024-07-03] - Update
- 版本：V2.4.2
- 概要：修复V2.4.1正式版的BUG。
- 修复：
  - 死循环，意外弹窗，参数重置等恶性BUG。

## [2024-07-02] - V2.4.1
- 添加并完善更多功能的GUI页面。
- 新增随机特征码。
- 新增随机窗口名。
- 新增鼠标移动库选择：
  - win32
  - mouse
  - 飞易来U盘
  - 罗技移动（需下载旧版GHUB）
- 新增x轴瞄准偏移。
- 新增随机瞄准偏移参数配置GUI，支持设置随机瞄准区间及切换位置速度。
- 优化控制台输出，不再刷屏。
- 修复Dxcam截图方式黑屏的BUG。
- 注意：配置文件(settings.json)发生变更，需替换。
- 新增文件：
  - 罗技移动DLL（MouseControl.dll）
  - 罗技GHUB及相关文件（LGmouseControl文件夹）。
- 感谢[@loy0516](https://github.com/loy0516)和[@CougarP](https://github.com/Cougarp)。

## [2024-06-21] - V2.4.1 (test)
- 提高软件稳定性安全性，绕过反作弊检测。
- 新增随机特征码、随机窗口名、随机瞄准偏移。
- 注意：测试版GUI不完善，新功能需在配置文件内修改。

## [2024-06-04] - V2.3.3 (test)
- 新增微调水平瞄准偏移功能（测试）。
- 注意：配置文件发生变更，需替换。

## [2024-05-30] - V2.3.2
- 新增对TRT模型的兼容。

## [2024-05-12] - V2.3.1
- 新增分段瞄准四项参数的GUI模块。
- 优化部分代码，指定使用显卡推理。

## [2024-04-27] - V2.3 (test)
- 新增更快的截图方式（基于DXcam的优化版本bettercam）。
- 推出分段瞄准功能（测试版）。
- 注意：测试版GUI不完善，新功能需在配置文件内开启。

## [2024-04-22] - Update
- 新增：联网检测版本功能（依赖于Github的README.md，可能需要科学上网才能加载）。
- 提示：过时版本号为红色，最新版本号为绿色，点击版本号可快速跳转至Github界面。
- 注意：加载时间可能变长，加载时间不稳定，加载页面会出现无响应问题，等待几秒钟即可，问题已在调查。
- 未来计划：自动扳机，平滑鼠标。

## [2024-04-21] - Update
- 修复：修复了报错NameError的问题，现在可以稳定加载了。

## [2024-04-20] - Release V2.2
- 重新精简/分类各项设置页面。
- 新增：
  - 推理延迟修正设置（预测）：倍率预测、像素预测。
  - 可选择单个识别目标（需模型支持，并根据你的模型手动修改代码中的目标列表名字）。
  - 软件内可开关的测试画面，方便调试设置。
  - 一键重启软件按钮（用于更换模型后的快速重启以及报错后快速重启）。
  - 加入更新公告栏（依赖于Github的README.md，可能需要科学上网才能加载）。
- 优化：默认隐藏外部"frame_"调试窗口（可前往settings.json开启）以优化推理速度。
- 注意：
  - "V2.2"版本的配置文件（settings.json）已更改，需要替换。
  - Github库已整理，历史版本与对应可使用的配置文件已整理到historic_version文件夹。
- 已知问题：可能会报错NameError，当前可以通过重启软件解决，并在属性中勾选“管理员启动”与“注册此程序以重新启动”可能会好一些。

## [2024-04-08] - Release
- 推出全新GUI版本，使用customtkinter库进行美化，界面更直观、简洁。
- 新增启动画面。
- 版本号现在起从V1.0开始计算（前面都当测试吧）。
- 注意："newGUI"版本需要两个新的图片文件，注意替换。

## [2024-04-02] - Update
- 改进：独立出侧键触发开关，适用于任何按键触发方式，方便开关。
- 优化：整理触发判定代码，更统一易懂。
- 注意：配置文件内容已更改，新增了侧键保存参数，注意替换。

## [2024-04-01] - Update
- 改进自瞄偏差，现改为计算目标中心点到上边框的距离乘以用户设置倍数的方式，使远近距离偏移量都能在合适位置。
- 优化代码量，去除未启用功能代码，加入更多批注方便阅读。
- 移除：暂时移除压枪功能，考虑独立出来。
- 未来计划：支持其他格式文件，例如ONNX。

## [2024-03-19] - Update
- 新增：自定义压枪功能。
- 新增：新增侧键鼠标下侧键触发，贴脸腰射好用。
- 测试：支持最新YOLOv9, YOLOv5, YOLOv8。

## [2024-02-27] - Update
- 新增：自定义微调自瞄位置。
- 新增：可手动选择模型文件。
- 改进：半透明UI界面。

## [2024-02-04] - Fix
- 修复：文件无法手动选择，进程冲突导致的参数调整面板失效。
- 新建：创建更新日志，记录每次的更新内容。

## [2024-02-25] - Initiation
- 立项：基于yolov8的FPS游戏自瞄软件。
- 更新：实现基本的自瞄功能等。

## [2024-01-28] - Release
- 初次创建基于yolov8实现本地视频预处理项目。

```

`CODE_OF_CONDUCT.md`:

```md
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
csy108729@gmail.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 PASSER

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Module/announcement.py`:

```py
import threading
import Utils.revision as revision


def get_and_set(ui):
    ui.window.announcement.setMarkdown(
        revision.get_online_announcement())

    # 设置渠道类型
    ui.window.channelLabel.setText(revision.get_channel())

    # 设置当前版本号
    ui.window.versionLabel.setText(revision.get_local_version())

    # 设置当前版本日期
    ui.window.versionDateLabel.setText(
        revision.get_local_date())

    # 设置最新版版本号
    if revision.is_official_version():
        _version = revision.get_release_version_with_date()
    else:
        _version = revision.get_dev_version_with_date()
    _version = f"{_version[0]}({_version[1]})"
    ui.window.latestVersionLabel.setText(_version)


def get_announcement(ui):

    thread = threading.Thread(target=get_and_set, args=(ui,))
    thread.start()
    # 等待线程完成
    thread.join()

```

`Module/config.py`:

```py
import os
from pathlib import Path
import sys
from typing import Any
import json

Root = Path(os.path.realpath(sys.argv[0])).parent


class Config:
    default = {
        "log_level": "info",
        "aim_range": 150,
        "aimBot": True,
        "confidence": 0.3,
        "aim_speed_x": 6.7,
        "aim_speed_y": 8.3,
        "model_file": "yolov8n.pt",
        "mouse_Side_Button_Witch": True,
        "ProcessMode": "single_process",
        "window_always_on_top": False,
        "target_class": "0",
        "lockKey": "VK_RBUTTON",
        "triggerType": "按下",
        "offset_centery": 0.75,
        "offset_centerx": 0.0,
        "screen_pixels_for_360_degrees": 6550,
        "screen_height_pixels": 3220,
        "near_speed_multiplier": 2.5,
        "slow_zone_radius": 0,
        "mouseMoveMode": "win32",
        "lockSpeed": 5.5,
        "jump_suppression_switch": False,
        "jump_suppression_fluctuation_range": 18
    }
    content = None

    @classmethod
    def read(cls) -> dict:
        try:
            os.makedirs(Root / "Data", exist_ok=True)
            with open(Root / "Data" / "settings.json", "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            return cls.default

    @classmethod
    def get(cls, key: str, default: Any = None) -> Any:
        """
        获取配置项的值，如果不存在则返回默认值。

        :param key: 配置项的键
        :param default: 默认值
        :return: 返回配置项的值，类型可能是 int, str, list, float 或 bool
        """
        if cls.content is None:
            cls.content = cls.read()  # 读取配置文件
        if default is not None:
            return cls.content.get(key, default)
        return cls.content.get(key, cls.default.get(key))

    @classmethod
    def update(cls, key: str, value: Any) -> None:
        if cls.content is None:
            cls.content = cls.read()
        cls.content[key] = value
        cls.save()

    @classmethod
    def delete(cls, key: str) -> None:
        if cls.content is None:
            cls.content = cls.read()
        if key in cls.content:
            del cls.content[key]
            cls.save()

    @classmethod
    def save(cls) -> None:
        if cls.content is None:
            cls.content = cls.read()
        with open(Root / "Data" / "settings.json", "w", encoding="utf8") as f:
            f.write(json.dumps(cls.content, ensure_ascii=False, indent=4))

```

`Module/const.py`:

```py
method_mode = {
    "按下": "press",
    "切换": "toggle",
    "shift+按下": "shift+press"
}

```

`Module/control.py`:

```py
import mouse
import os
import importlib.machinery
import importlib.util
import sys
import ctypes
import win32api
import win32con
import platform
import random
import time
from Module.config import Root
from Module.logger import logger

#############################################################
# Pyd files list in                                               #
# https://github.com/kvmaibox/kmboxnet/tree/main/python_pyd #
#############################################################
def path_import(module_name):
    """
        导入模块
    :param file:
    :return:
    """
    logger.debug("******************* 开始动态加载模块 *************************")
    
    # 获取当前Python版本和平台
    py_version = f"cp{sys.version_info.major}{sys.version_info.minor}"
    platform_tag = f"{platform.system().lower()}_{platform.architecture()[0]}"
    file_name = f"{module_name}.{py_version}-{platform_tag}.pyd"
    file_path = Root / "DLLs"/ "python_pyd" / file_name
        
    loader_details = (
        importlib.machinery.ExtensionFileLoader,
        importlib.machinery.EXTENSION_SUFFIXES
    )
    tools_finder = importlib.machinery.FileFinder(
        os.path.dirname(file_path), loader_details)
    logger.debug("FileFinder: ", tools_finder)
    
    toolbox_specs = tools_finder.find_spec(module_name)
    logger.debug("find_spec: ", toolbox_specs)

    if toolbox_specs is None or toolbox_specs.loader is None:
        raise ImportError(f"无法找到或加载模块: {module_name} ({file_name})")

    toolbox = importlib.util.module_from_spec(toolbox_specs)
    logger.debug("module: ", toolbox)
    toolbox_specs.loader.exec_module(toolbox)
    logger.info("导入成功 path_import(): ", toolbox)
    logger.debug("检查sys中是否包含了此模块: ", toolbox in sys.modules)
    logger.debug("******************* 动态加载模块完成 *************************\n")
    return toolbox

msdk_dll = ctypes.windll.LoadLibrary(f"{Root}/DLLs/x64_msdk.dll")
msdk_dll.M_Open_VidPid.restype = ctypes.c_uint64  # 声明M_Open函数的返回类型为无符号整数
msdk_hdl = msdk_dll.M_Open_VidPid(0x1532, 0x98)  # 打开端口代码

LG_driver = ctypes.CDLL(f"{Root}/DLLs/LGmouseControl/MouseControl.dll")

kmNet = path_import("kmNet")

def emergencStop_valorant(last_state_w, last_state_a, last_state_s, last_state_d):
    # 获取当前按键状态
    state_w = bool(win32api.GetAsyncKeyState(0x57) & 0x8000)  # W键
    state_a = bool(win32api.GetAsyncKeyState(0x41) & 0x8000)  # A键
    state_s = bool(win32api.GetAsyncKeyState(0x53) & 0x8000)  # S键
    state_d = bool(win32api.GetAsyncKeyState(0x44) & 0x8000)  # D键

    stop = False


    # 检测按键是否从按下变为松开
    if not state_w and last_state_w:  # 如果按键W被松开
        logger.debug("W键弹起")
        kmNet.keydown(22)  #保持键盘s键按下
        time.sleep(0.03)
        kmNet.keyup(22)  # 键盘s键松开
        logger.debug("S键点击")
        stop = True
    if not state_a and last_state_a:  # 如果按键A被松开
        logger.debug("A键弹起")
        kmNet.keydown(7)   #保持键盘d键按下
        time.sleep(0.03)
        kmNet.keyup(7)   # 键盘d键松开
        logger.debug("D键点击")
        stop = True
    if not state_s and last_state_s:  # 如果按键S被松开
        logger.debug("S键弹起")
        kmNet.keydown(26)  #保持键盘w键按下
        time.sleep(0.03)
        kmNet.keyup(26)  # 键盘w键松开
        logger.debug("W键点击")
        stop = True
    if not state_d and last_state_d:  # 如果按键D被松开
        logger.debug("D键弹起")
        kmNet.keydown(4)  #保持键盘a键按下
        time.sleep(0.03)
        kmNet.keyup(4)  # 键盘a键松开
        logger.debug("A键点击")
        stop = True

    if stop:
        time.sleep(0.003)  # 添加一个小的延时，避免CPU占用过高

    # 返回更新后的按键状态
    return state_w, state_a, state_s, state_d


def monitor(mode):
    state = None
    match mode:
        case 'KmBoxNet':
            state = bool(kmNet.isdown_right())
        case "win32":
            state = bool(win32api.GetAsyncKeyState(0x02) & 0x8000)
    return state


def click(mode):
    match mode:
        case "飞易来USB":
            msdk_dll.M_KeyDown2(ctypes.c_uint64(msdk_hdl), 1)
            time.sleep(random.uniform(0.12, 0.17))
            msdk_dll.M_KeyDown2(ctypes.c_uint64(msdk_hdl), 2)
            time.sleep(random.uniform(0.12, 0.17))
        case "win32":
            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
            time.sleep(random.uniform(0.12, 0.17))
            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
            time.sleep(random.uniform(0.12, 0.17))
        case "mouse":
            mouse.click("left")
            time.sleep(random.uniform(0.12, 0.17))
        case "Logitech":
            LG_driver.click_Left_down()
            time.sleep(random.uniform(0.12, 0.17))
            LG_driver.click_Left_up()
            time.sleep(random.uniform(0.12, 0.17))
        case 'KmBoxNet':
            kmNet.left(1)
            time.sleep(random.uniform(0.12, 0.17))
            kmNet.left(0)
            time.sleep(random.uniform(0.12, 0.17))


def move(mode, centerx, centery):
    match mode:
        case "飞易来USB":
            msdk_dll.M_MoveR2(ctypes.c_uint64(msdk_hdl), int(centerx), int(centery))
        case "win32":
            win32api.mouse_event(
                win32con.MOUSEEVENTF_MOVE, int(centerx), int(centery), 0, 0
            )
        case "mouse":
            mouse.move(int(centerx), int(centery), False)
        case "Logitech":
            LG_driver.move_R(int(centerx), int(centery))
        case 'KmBoxNet':
            kmNet.enc_move(int(centerx), int(centery))




##############################################################
# Why is there no press and release method for kmNet?
# Please see:
# https://github.com/kvmaibox/kmboxnet/issues/14
##############################################################
def press(mode, key):
    match mode:
        case "飞易来USB":
            msdk_dll.M_KeyDown2(ctypes.c_uint64(msdk_hdl), key)
        case "win32":
            win32api.keybd_event(key, 0, 0, 0)
        case "mouse":
            mouse.press(key)
        case "Logitech":
            LG_driver.press_key(key)


def release(mode, key):
    match mode:
        case "飞易来USB":
            msdk_hdl.M_KeyUp2(ctypes.c_uint64(msdk_hdl), key)
        case "win32":
            win32api.keybd_event(key, 0, win32con.KEYEVENTF_KEYUP, 0)
        case "mouse":
            mouse.release(key)
        case "Logitech":
            LG_driver.release_key(key)

```

`Module/draw_screen.py`:

```py
import ctypes
from ctypes import wintypes
import math

# 定义Windows API结构和函数
user32 = ctypes.WinDLL("user32", use_last_error=True)
gdi32 = ctypes.WinDLL("gdi32", use_last_error=True)

# 定义需要的Windows API
EnumWindows = user32.EnumWindows
EnumWindowsProc = ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.HWND, wintypes.LPARAM)
GetWindowDC = user32.GetWindowDC
ReleaseDC = user32.ReleaseDC
MoveToEx = gdi32.MoveToEx
LineTo = gdi32.LineTo
CreatePen = gdi32.CreatePen
SelectObject = gdi32.SelectObject
DeleteObject = gdi32.DeleteObject
GetWindowRect = user32.GetWindowRect
Ellipse = gdi32.Ellipse
Rectangle = gdi32.Rectangle

# 设置函数参数类型和返回值类型
GetWindowRect.argtypes = [wintypes.HWND, ctypes.POINTER(wintypes.RECT)]
GetWindowRect.restype = wintypes.BOOL
MoveToEx.argtypes = [
    wintypes.HDC,
    ctypes.c_int,
    ctypes.c_int,
    ctypes.POINTER(wintypes.POINT),
]
MoveToEx.restype = wintypes.BOOL
LineTo.argtypes = [wintypes.HDC, ctypes.c_int, ctypes.c_int]
LineTo.restype = wintypes.BOOL
CreatePen.argtypes = [wintypes.UINT, wintypes.UINT, wintypes.COLORREF]
CreatePen.restype = wintypes.HGDIOBJ
SelectObject.argtypes = [wintypes.HDC, wintypes.HGDIOBJ]
SelectObject.restype = wintypes.HGDIOBJ
DeleteObject.argtypes = [wintypes.HGDIOBJ]
DeleteObject.restype = wintypes.BOOL
Ellipse.argtypes = [
    wintypes.HDC,
    ctypes.c_int,
    ctypes.c_int,
    ctypes.c_int,
    ctypes.c_int,
]
Ellipse.restype = wintypes.BOOL
Rectangle.argtypes = [
    wintypes.HDC,
    ctypes.c_int,
    ctypes.c_int,
    ctypes.c_int,
    ctypes.c_int,
]
Rectangle.restype = wintypes.BOOL

# 定义颜色和线条样式
PS_SOLID = 0x00000000
COLOR_BLUE = 0x000000FF
COLOR_RED = 0x00FF0000
COLOR_GREEN = 0x0000FF00
COLOR_YELLOW = 0x00FFFF00
COLOR_WHITE = 0x00FFFFFF


# 枚举窗口的回调函数
def callback(hwnd, lParam):
    rect = wintypes.RECT()
    GetWindowRect(hwnd, ctypes.byref(rect))
    if rect.left == 0 and rect.top == 0:
        ctypes.cast(lParam, ctypes.POINTER(wintypes.HWND)).contents.value = hwnd
        return False
    return True


# 获取桌面窗口句柄
def get_desktop_window():
    hwnd = wintypes.HWND()
    EnumWindows(EnumWindowsProc(callback), ctypes.byref(hwnd))
    return hwnd


# 创建一个笔
def create_pen(color, width):
    return CreatePen(PS_SOLID, width, color)


# 绘制矩形
def draw_rectangle(hdc, x1, y1, x2, y2, color, width):
    pen = create_pen(color, width)
    old_pen = SelectObject(hdc, pen)
    Rectangle(hdc, x1, y1, x2, y2)
    SelectObject(hdc, old_pen)
    DeleteObject(pen)


# 绘制圆形
def draw_circle(hdc, center_x, center_y, radius, color, width):
    pen = create_pen(color, width)
    old_pen = SelectObject(hdc, pen)
    left = center_x - radius
    top = center_y - radius
    right = center_x + radius
    bottom = center_y + radius
    Ellipse(hdc, left, top, right, bottom)
    SelectObject(hdc, old_pen)
    DeleteObject(pen)


# 绘制直线
def draw_line(hdc, x1, y1, x2, y2, color, width):
    pen = create_pen(color, width)
    old_pen = SelectObject(hdc, pen)
    MoveToEx(hdc, x1, y1, None)
    LineTo(hdc, x2, y2)
    SelectObject(hdc, old_pen)
    DeleteObject(pen)


# 绘制文本
# 绘制文本
def draw_text(hdc, text, x, y, color, font_size=16):
    """
    在指定位置和颜色下绘制文本。

    **参数**:
    
    - hdc: 设备上下文句柄。
    - text: 要绘制的文本内容。
    - x: 文本的起始x坐标。
    - y: 文本的起始y坐标。
    - color: 文本颜色(COLORREF)(Windows API颜色值)
    - font_size: 字体大小，默认为16点。
    """
    hfont = gdi32.CreateFontA(
        -font_size, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, b"Arial"
    )
    old_font = SelectObject(hdc, hfont)

    old_color = gdi32.SetTextColor(hdc, color)

    gdi32.TextOutA(hdc, x, y, text.encode("utf-8"), len(text))

    gdi32.SetTextColor(hdc, old_color)
    SelectObject(hdc, old_font)
    gdi32.DeleteObject(hfont)


# 主函数，用于绘制检测结果
def draw_detections(detections, frame_center, aim_range):
    desktop_hwnd = get_desktop_window()
    desktop_dc = GetWindowDC(desktop_hwnd)

    # 绘制一个淡蓝色的细圆（瞄准范围）
    circle_color = COLOR_WHITE  # 淡蓝色
    draw_circle(
        desktop_dc, frame_center[0], frame_center[1], aim_range, circle_color, 1
    )

    for detection in detections:
        x1, y1, x2, y2 = detection
        box_center = ((x1 + x2) // 2, (y1 + y2) // 2)

        # 默认所有框使用黄色连接线
        box_color = COLOR_YELLOW  # 黄色边框
        line_color = COLOR_YELLOW  # 黄色连接线

        # 绘制矩形框
        draw_rectangle(desktop_dc, x1, y1, x2, y2, box_color, 2)
        # 绘制中心点
        draw_circle(desktop_dc, box_center[0], box_center[1], 5, COLOR_RED, -1)
        # 绘制连接线条
        draw_line(
            desktop_dc,
            box_center[0],
            box_center[1],
            frame_center[0],
            frame_center[1],
            line_color,
            2,
        )

        # 计算距离
        distance = math.sqrt(
            (box_center[0] - frame_center[0]) ** 2
            + (box_center[1] - frame_center[1]) ** 2
        )
        # 绘制距离文本
        distance_text = f"{distance:.1f}px"
        draw_text(desktop_dc, distance_text, x1, y1 - 10, COLOR_BLUE, 16)

    # 如果有最近的 Box，再绘制其绿色框和红色连接线（覆盖上一步绘制）
    if detections:
        closest_box = detections[0]
        x1, y1, x2, y2 = closest_box
        box_center = ((x1 + x2) // 2, (y1 + y2) // 2)
        closest_distance = math.sqrt(
            (box_center[0] - frame_center[0]) ** 2
            + (box_center[1] - frame_center[1]) ** 2
        )

        # 只有当距离小于 aim_range 时，才绘制绿色框和红色连接线
        if closest_distance < aim_range:
            # 绘制最近的框的绿色边框
            draw_rectangle(desktop_dc, x1, y1, x2, y2, COLOR_GREEN, 3)
            # 绘制中心点
            draw_circle(desktop_dc, box_center[0], box_center[1], 5, COLOR_GREEN, -1)
            # 绘制红色连接线
            draw_line(
                desktop_dc,
                box_center[0],
                box_center[1],
                frame_center[0],
                frame_center[1],
                COLOR_RED,
                3,
            )

    # 释放设备上下文句柄
    release_dc(desktop_hwnd, desktop_dc)


def release_dc(desktop_hwnd, desktop_dc):
    """释放设备上下文句柄"""
    ReleaseDC(desktop_hwnd, desktop_dc)

```

`Module/jump_detection.py`:

```py
# jump_detection.py

def check_target_switching(offset_distance, last_offset_distance, jump_detection_switch, fluctuation_range, target_switching):
    """
    判断是否发生目标切换

    参数:
    - offset_distance: 当前的目标偏移距离
    - last_offset_distance: 上一次的目标偏移距离
    - jump_detection_switch: 跳变检测开关，是否启用跳变检测
    - jump_suppression_fluctuation_range: 允许的波动范围（单位：像素）
    - target_switching: 记录状态。（鼠标按下时持续性禁止移动，直到松开）

    返回:
    - target_switching: 是否发生了目标切换 (True or False)
    """

    if last_offset_distance is not None and not target_switching:
        # 如果启用跳变检测
        if jump_detection_switch:
            # 判断是否有不规律的跳变，判断 offset_distance 是否突然增大
            if offset_distance > last_offset_distance + fluctuation_range:
                target_switching = True  # 判断为目标切换
                logger.debug("目标切换")
            else:
                target_switching = False  # 认为是正常的规律移动
                logger.debug("正常移动")
        else:
            # 如果不启用跳变检测，则认为是正常移动
            target_switching = False
            logger.debug("正常移动")

    return target_switching

```

`Module/keyboard.py`:

```py
import tkinter as tk
import threading
import queue
from pynput import keyboard, mouse


class KeyCaptureApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Key Capture")
        self.label = tk.Label(
            root, text="Press any key...", font=('Helvetica', 16))
        self.label.pack(pady=20)

        # 设置焦点以便立即接收键盘事件
        self.root.focus_set()
        self.listener = None
        self.event_result = None

        # 绑定关闭事件以确保正确清理资源
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)

    def start_listening(self):
        self.listener = keyboard.Listener(on_press=self.on_press)
        self.listener.start()
        self.mouse_listener = mouse.Listener(on_click=self.on_mouse_click)
        self.mouse_listener.start()

    def on_press(self, key):
        if key == keyboard.Key.esc:
            self.on_close()
        if isinstance(key, keyboard.KeyCode):
            self.event_result = hex(
                key.vk) if key.vk is not None else 'UNKNOWN'
        else:
            self.event_result = hex(key.value.vk)
        self.on_close()

    def on_mouse_click(self, x, y, button, pressed):
        mouse_vk_map = {
            mouse.Button.left: 0x01,   # VK_LBUTTON
            mouse.Button.right: 0x02,  # VK_RBUTTON
            mouse.Button.middle: 0x04,  # VK_MBUTTON
            mouse.Button.x1: 0x05,     # VK_XBUTTON1
            mouse.Button.x2: 0x06      # VK_XBUTTON2
        }
        if vk_code := mouse_vk_map.get(button):
            self.event_result = hex(vk_code)
        else:
            self.event_result = 'UNKNOWN'
        self.on_close()

    def on_close(self):
        if self.listener is not None:
            self.listener.stop()
        if self.mouse_listener is not None:
            self.mouse_listener.stop()
        self.root.quit()  # 使用 quit 而不是 destroy 以便返回结果

    def capture_event(self):
        self.start_listening()
        self.root.mainloop()
        return self.event_result


def get_keyboard_event(text="UNKNOWN"):
    result_queue = queue.Queue()

    def capture_key():
        key = KeyCaptureApp(tk.Tk()).capture_event()
        result_queue.put(key)

    thread = threading.Thread(target=capture_key)
    thread.start()
    # 等待线程完成
    thread.join()

    # 获取结果
    key = 'UNKNOWN' if result_queue.empty() else result_queue.get()

    return text if key is None or key == 'UNKNOWN' else key


keys_maps_vk = {
    "VK_LBUTTON": 0x01,
    "VK_RBUTTON": 0x02,
    "VK_CANCEL": 0x03,
    "VK_MBUTTON": 0x04,
    "VK_XBUTTON1": 0x05,
    "VK_XBUTTON2": 0x06,
    "VK_BACK": 0x08,
    "VK_TAB": 0x09,
    "VK_CLEAR": 0x0C,
    "VK_RETURN": 0x0D,
    "VK_SHIFT": 0x10,
    "VK_CONTROL": 0x11,
    "VK_MENU": 0x12,
    "VK_PAUSE": 0x13,
    "VK_CAPITAL": 0x14,
    "VK_KANA": 0x15,
    "VK_HANGUL": 0x15,
    "VK_IME_ON": 0x16,
    "VK_JUNJA": 0x17,
    "VK_FINAL": 0x18,
    "VK_HANJA": 0x19,
    "VK_KANJI": 0x19,
    "VK_IME_OFF": 0x1A,
    "VK_ESCAPE": 0x1B,
    "VK_CONVERT": 0x1C,
    "VK_NONCONVERT": 0x1D,
    "VK_ACCEPT": 0x1E,
    "VK_MODECHANGE": 0x1F,
    "VK_SPACE": 0x20,
    "VK_PRIOR": 0x21,
    "VK_NEXT": 0x22,
    "VK_END": 0x23,
    "VK_HOME": 0x24,
    "VK_LEFT": 0x25,
    "VK_UP": 0x26,
    "VK_RIGHT": 0x27,
    "VK_DOWN": 0x28,
    "VK_SELECT": 0x29,
    "VK_PRINT": 0x2A,
    "VK_EXECUTE": 0x2B,
    "VK_SNAPSHOT": 0x2C,
    "VK_INSERT": 0x2D,
    "VK_DELETE": 0x2E,
    "VK_HELP": 0x2F,
    "VK_0": 0x30,
    "VK_1": 0x31,
    "VK_2": 0x32,
    "VK_3": 0x33,
    "VK_4": 0x34,
    "VK_5": 0x35,
    "VK_6": 0x36,
    "VK_7": 0x37,
    "VK_8": 0x38,
    "VK_9": 0x39,
    "VK_A": 0x41,
    "VK_B": 0x42,
    "VK_C": 0x43,
    "VK_D": 0x44,
    "VK_E": 0x45,
    "VK_F": 0x46,
    "VK_G": 0x47,
    "VK_H": 0x48,
    "VK_I": 0x49,
    "VK_J": 0x4A,
    "VK_K": 0x4B,
    "VK_L": 0x4C,
    "VK_M": 0x4D,
    "VK_N": 0x4E,
    "VK_O": 0x4F,
    "VK_P": 0x50,
    "VK_Q": 0x51,
    "VK_R": 0x52,
    "VK_S": 0x53,
    "VK_T": 0x54,
    "VK_U": 0x55,
    "VK_V": 0x56,
    "VK_W": 0x57,
    "VK_X": 0x58,
    "VK_Y": 0x59,
    "VK_Z": 0x5A,
    "VK_LWIN": 0x5B,
    "VK_RWIN": 0x5C,
    "VK_APPS": 0x5D,
    "VK_SLEEP": 0x5F,
    "VK_NUMPAD0": 0x60,
    "VK_NUMPAD1": 0x61,
    "VK_NUMPAD2": 0x62,
    "VK_NUMPAD3": 0x63,
    "VK_NUMPAD4": 0x64,
    "VK_NUMPAD5": 0x65,
    "VK_NUMPAD6": 0x66,
    "VK_NUMPAD7": 0x67,
    "VK_NUMPAD8": 0x68,
    "VK_NUMPAD9": 0x69,
    "VK_MULTIPLY": 0x6A,
    "VK_ADD": 0x6B,
    "VK_SEPARATOR": 0x6C,
    "VK_SUBTRACT": 0x6D,
    "VK_DECIMAL": 0x6E,
    "VK_DIVIDE": 0x6F,
    "VK_F1": 0x70,
    "VK_F2": 0x71,
    "VK_F3": 0x72,
    "VK_F4": 0x73,
    "VK_F5": 0x74,
    "VK_F6": 0x75,
    "VK_F7": 0x76,
    "VK_F8": 0x77,
    "VK_F9": 0x78,
    "VK_F10": 0x79,
    "VK_F11": 0x7A,
    "VK_F12": 0x7B,
    "VK_F13": 0x7C,
    "VK_F14": 0x7D,
    "VK_F15": 0x7E,
    "VK_F16": 0x7F,
    "VK_F17": 0x80,
    "VK_F18": 0x81,
    "VK_F19": 0x82,
    "VK_F20": 0x83,
    "VK_F21": 0x84,
    "VK_F22": 0x85,
    "VK_F23": 0x86,
    "VK_F24": 0x87,
    "VK_NUMLOCK": 0x90,
    "VK_SCROLL": 0x91,
    "VK_LSHIFT": 0xA0,
    "VK_RSHIFT": 0xA1,
    "VK_LCONTROL": 0xA2,
    "VK_RCONTROL": 0xA3,
    "VK_LMENU": 0xA4,
    "VK_RMENU": 0xA5,
    "VK_BROWSER_BACK": 0xA6,
    "VK_BROWSER_FORWARD": 0xA7,
    "VK_BROWSER_REFRESH": 0xA8,
    "VK_BROWSER_STOP": 0xA9,
    "VK_BROWSER_SEARCH": 0xAA,
    "VK_BROWSER_FAVORITES": 0xAB,
    "VK_BROWSER_HOME": 0xAC,
    "VK_VOLUME_MUTE": 0xAD,
    "VK_VOLUME_DOWN": 0xAE,
    "VK_VOLUME_UP": 0xAF,
    "VK_MEDIA_NEXT_TRACK": 0xB0,
    "VK_MEDIA_PREV_TRACK": 0xB1,
    "VK_MEDIA_STOP": 0xB2,
    "VK_MEDIA_PLAY_PAUSE": 0xB3,
    "VK_LAUNCH_MAIL": 0xB4,
    "VK_LAUNCH_MEDIA_SELECT": 0xB5,
    "VK_LAUNCH_APP1": 0xB6,
    "VK_LAUNCH_APP2": 0xB7,
    "VK_OEM_1": 0xBA,
    "VK_OEM_PLUS": 0xBB,
    "VK_OEM_COMMA": 0xBC,
    "VK_OEM_MINUS": 0xBD,
    "VK_OEM_PERIOD": 0xBE,
    "VK_OEM_2": 0xBF,
    "VK_OEM_3": 0xC0,
    "VK_OEM_4": 0xDB,
    "VK_OEM_5": 0xDC,
    "VK_OEM_6": 0xDD,
    "VK_OEM_7": 0xDE,
    "VK_OEM_8": 0xDF,
    "VK_OEM_102": 0xE2,
    "VK_PROCESSKEY": 0xE5,
    "VK_PACKET": 0xE7,
    "VK_ATTN": 0xF6,
    "VK_CRSEL": 0xF7,
    "VK_EXSEL": 0xF8,
    "VK_EREOF": 0xF9,
    "VK_PLAY": 0xFA,
    "VK_ZOOM": 0xFB,
    "VK_PA1": 0xFD,
    "VK_OEM_CLEAR": 0xFE
}


def get_key_name_vk(hex):
    return dict(
        zip(keys_maps_vk.values(),
            keys_maps_vk.keys())
    ).get(int(hex, 16), "UNKNOWN")


def get_key_code_vk(key_name):
    return keys_maps_vk.get(key_name, "UNKNOWN")

```

`Module/logger.py`:

```py
import os
import logging
import threading
import datetime
from logging import DEBUG, INFO, WARNING, ERROR, CRITICAL  # noqa: F401
from io import StringIO
from colorama import init, Fore, Style
from Module.config import Root, Config

# 自定义 TRACE 和 SUCCESS 级别的日志
TRACE_LOG_LEVEL = 5
SUCCESS_LOG_LEVEL = 25
logging.addLevelName(TRACE_LOG_LEVEL, "TRACE")
logging.addLevelName(SUCCESS_LOG_LEVEL, "SUCCESS")

def trace(self, message, *args, **kws):
    if self.isEnabledFor(TRACE_LOG_LEVEL):
        self._log(TRACE_LOG_LEVEL, message, args, **kws)

def success(self, message, *args, **kws):
    if self.isEnabledFor(SUCCESS_LOG_LEVEL):
        self._log(SUCCESS_LOG_LEVEL, message, args, **kws)

logging.Logger.trace = trace
logging.Logger.success = success

def get_log_level() -> int:
    """根据日志名称获取日志级别"""
    maps = {
        "TRACE": TRACE_LOG_LEVEL,
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "SUCCESS": SUCCESS_LOG_LEVEL,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL,
    }
    return maps.get(Config.get("LOG_LEVEL", "INFO").upper(), logging.INFO)

class CustomFormatter(logging.Formatter):
    def format(self, record):
        color = self._get_color(record.levelname)
        record.color = color
        return super().format(record)

    def _get_color(self, level_name):
        """根据日志级别返回相应的颜色"""
        colors = {
            "TRACE": Fore.LIGHTCYAN_EX,
            "DEBUG": Fore.BLUE,
            "INFO": Fore.WHITE,
            "SUCCESS": Fore.GREEN,
            "WARNING": Fore.YELLOW,
            "ERROR": Fore.RED,
            "CRITICAL": Fore.RED + Style.BRIGHT,
        }
        return colors.get(level_name, Fore.WHITE)

class logger:

    init(autoreset=True)

    console_log_level_int = TRACE_LOG_LEVEL
    file_log_level_int = INFO
    log_file_prefix = Root / "logs"
    os.makedirs(log_file_prefix, exist_ok=True)
    logger = logging.getLogger("RookieAI")
    logger.setLevel(get_log_level())

    console_handler = logging.StreamHandler()
    console_handler.setLevel(console_log_level_int)

    colored_formatter = CustomFormatter(
        f"{Fore.GREEN}{Style.BRIGHT}%(asctime)s{Style.RESET_ALL} "
        f"%(color)s[%(levelname)s]{Style.RESET_ALL} "
        f"{Fore.WHITE}%(message)s{Style.RESET_ALL}",
        datefmt="%Y-%m-%d %H:%M:%S",
    )
    console_handler.setFormatter(colored_formatter)
    logger.addHandler(console_handler)

    file_handler = None
    current_log_date = None
    lock = threading.Lock()

    log_stream = StringIO()

    @classmethod
    def _ensure_log_file_created(cls):
        """确保日志文件在首次记录日志时创建，或在新的一天开始时创建新文件。"""
        today = datetime.datetime.now().date()
        if cls.file_handler is None or today != cls.current_log_date:
            with cls.lock:
                if cls.file_handler is not None and today != cls.current_log_date:
                    cls.logger.removeHandler(cls.file_handler)
                    cls.file_handler.close()

                cls.current_log_date = today
                cls.log_file = os.path.join(cls.log_file_prefix, f"{today}.log")
                cls.file_handler = logging.FileHandler(cls.log_file, encoding="utf-8")
                cls.file_handler.setLevel(cls.file_log_level_int)
                cls.file_handler.setFormatter(
                    logging.Formatter(
                        "%(asctime)s [%(levelname)s] %(message)s",
                        datefmt="%Y-%m-%d %H:%M:%S",
                    )
                )
                cls.logger.addHandler(cls.file_handler)

    @classmethod
    def _format_message(cls, *args):
        return " ".join(str(arg) for arg in args)

    @classmethod
    def trace(cls, *args) -> None:
        cls._ensure_log_file_created()
        with cls.lock:
            cls.logger.trace(cls._format_message(*args))

    @classmethod
    def debug(cls, *args) -> None:
        cls._ensure_log_file_created()
        with cls.lock:
            cls.logger.debug(cls._format_message(*args))

    @classmethod
    def info(cls, *args) -> None:
        cls._ensure_log_file_created()
        with cls.lock:
            cls.logger.info(cls._format_message(*args))

    @classmethod
    def success(cls, *args) -> None:
        cls._ensure_log_file_created()
        with cls.lock:
            cls.logger.success(cls._format_message(*args))

    @classmethod
    def warning(cls, *args) -> None:
        cls._ensure_log_file_created()
        with cls.lock:
            cls.logger.warning(cls._format_message(*args))

    @classmethod
    def warn(cls, *args) -> None:
        cls.warning(*args)

    @classmethod
    def error(cls, *args) -> None:
        cls._ensure_log_file_created()
        with cls.lock:
            cls.logger.error(cls._format_message(*args))

    @classmethod
    def critical(cls, *args) -> None:
        cls._ensure_log_file_created()
        with cls.lock:
            cls.logger.critical(cls._format_message(*args))

    @classmethod
    def fatal(cls, *args) -> None:
        cls.critical(*args)

    @classmethod
    def _generate_log_output(cls):
        """生成器函数，用于生成日志输出。"""
        while True:
            if log_content := cls.log_stream.getvalue():
                cls.log_stream.seek(0)
                cls.log_stream.truncate(0)  # 清空日志缓冲区
                yield log_content
            else:
                yield ""

```

`Parameter_explanation.md`:

```md
| 参数名称 | 类型 | 范围 | 解释 | 默认值 |
|:---:|:---:|:---:|:---:|:---:|
| **log_level** | `str` | - | 控制台输出的日志等级 | `info`|
| **aim_range** | `int` | ∞ | 自瞄范围 | `150`|
| **aimBot** | `bool` | - | 自瞄启用状态 | `True` |
| **confidence** | `float` | [0, 1] | 模型识别的置信度 | `0.3` |
| **aim_speed_x** | `float` | ∞ | X轴基础瞄准速度 | `6.7` |
| **aim_speed_y** | `float` | ∞ | Y轴基础瞄准速度 | `8.3`|
| **model_file**v| `str` | - | 模型文件路径 | - |
| **mouse_Side_Button_Witch** | `bool` | - | 侧键自瞄开关状态 | `True` |
| **ProcessMode** | `str` | [`single_process`, `multi_process`] | 推理进程模式 | `multi_process` |
| **window_always_on_top** | `bool` | - | 应用窗口是否置顶 | `False` |
| **target_class** | `str` | ∞ | 所使用模型中需要检测的类别 | `0` |
| **lockKey** | `str` | - | 自瞄热键 | `VK_RBUTTON` |
| **triggerType** | `str` | - | 自瞄触发方式 | `按下` |
| **offset_centery** | `float` | ∞ | Y轴瞄准偏移 | `0.75` |
| **offset_centerx** | `float` | ∞ | X轴瞄准偏移 | `0.0` |
| **screen_pixels_for_360_degrees** | `int` | ∞ | 游戏内X轴360度视角像素 | `6550` |
| **screen_height_pixels** | `int` | ∞ | 游戏内Y轴180度视角像素 | `3220` |
| **near_speed_multiplier** | `float` | ∞ | 近点瞄准速度倍率 | `2.5` |
| **slow_zone_radius** | `int` | ∞ | 瞄准减速区域 | `0` |
| **mouseMoveMode** | `str` | - | 鼠标移动方式 | `win32` |
| **lockSpeed** | `float` | ∞ | 自瞄速度 | `5.5` |
| **jump_suppression_switch** | `bool` | - | 跳变抑制开关(防止突然切换目标) | `False` |
| **jump_suppression_fluctuation_range** | `float` | ∞ | 跳变抑制阈值 | `18` |

```

`README.md`:

```md
# RookieAI_yolov8_V3

> [!IMPORTANT]
> 使用前请先阅读[参数解释文档](Parameter_explanation.md)

加入**Discord**获取最新消息！
[![Static Badge](https://img.shields.io/badge/Discord-Join_Discord-36C9BB?logo=discord&logoSize=auto&label=%20)
](https://discord.gg/vtgbfy2afb)

> [!NOTE]
> 前言：为什么不提供直接打包成型的软件？
>
> 每个程序都有独立的特征码，如果大家都使用同一个程序，一旦其中一个人被BAN其他人会被联BAN。所以鼓励大家自行修改部分代码并自行打包即可避免此类情况发生。

## 版本要求

| Version | Python |
|---------|--------|
| `2.4.3或更早`   | 3.7+   |
| `2.4.4.2+`   | 3.10+   |

## 使用方法

1. 使用以下代码获取本代码需要的库与Pytorch库

**✨ 超高速无痛下载 ✨**
   

```shell
poetry install
poetry run pip install torch torchvision torchaudio -f https://mirror.sjtu.edu.cn/pytorch-wheels/torch_stable.html --no-index
```

**海外用户请使用以下命令**

```shell
poetry install
poetry run pip install torch torchvision torchaudio -f https://download.pytorch.org/whl/torch_stable.html --no-index
```

2. 你还需要一个自己的模型（目前支持.pt/.engine/.onnx模型），如果没有可暂时使用ultralytics官方模型

3. **当未找到模型时会自动下载YOLOv8n模型**，你也可以⬇️

访问[YOLOv8GitHub界面](https://docs.ultralytics.com/)获取更多官方yolov8模型以快速开始

访问[ultralytics官网](https://docs.ultralytics.com/)查看官方网站帮助文档

4. 运行

在脚本所在目录打开终端，键入以下内容并回车
```shell
poetry run python RookieAI.py
```

## 关于模型文件

建议自行训练

学习资料：
[Bilibili](https://search.bilibili.com/all?keyword=%E5%A6%82%E4%BD%95%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B&from_source=webtop_search&spm_id_from=333.1007&search_source=5) or [YouTube](https://www.youtube.com/results?search_query=how+to+train+yolov8+model)

V3.0预告

![V3.0](images/V3.png)

3.0版本注重使用多线程进行优化，理论上可以提升截图效率与推理效率，但是可能会导致延迟问题。当然也提供原始的单进程推理模式可供选择。

该版本从底层代码到UI界面进行了完全重构，多线程也可以带来更多使用上的优化，例如可随意调整鼠标移动的频率，不再受到推理帧数的限制等。目前测试主系统空载YOLO使用YOLO11n模型推理的帧数从55提升到了80，有明显提升。配合独立的鼠标移动进程，理论上可以带来不错的使用体验。


对电脑配置的要求也会有一定程度的降低。代码目前处于早期开发阶段，未集成Aimbot等基础功能，开发进度与源代码请稍后关注对应文档。

**推荐使用Atlas游戏系统配合boosterX性能优化软件获得更好体验**

[AtlasOS](https://atlasos.net/)对 Windows 进行修改，专为游戏玩家设计。具有更高的游戏帧率和更低的延迟。同时在此系统上使用RookieAI可更高效的利用GPU资源得到更高的推理帧率。

[boosterX](https://boosterx.org/en/)是一款系统优化软件，优化Windows，降低延迟、提高 FPS。在AtlasOS系统上使用可进一步进行优化。

配置单：
截图模式:mss  截图高/宽:320  显卡:RTX4080M  模型:YOLOv8s_TheFinals_teammate_enemy_04.engine

原版windows空载运行RookieAI2.4.3 对比 AtlasOS 空载运行RookieAI2.4.3：

### ✅✅✅注意✅✅✅

此项目最初目的为Apex的Aimbot，未考虑其他游戏，可能会出现因反作弊禁止WIN32移动方式而无法使用的情况！

已知游戏：**VALORANT**

面对日益增多的配置文件参数，我新建了参数解释文档，里面介绍了配置文件内所有参数的信息，前往[参数解释文档](Parameter_explanation.md)查看。

❗V3支持KmBoxNet，VALORANT确认可用
 
**🎉🎉🎉非常感谢由RicardoJoaquim提供的英文特别版本🎉🎉🎉**

## Star History

[![Star History Chart](https://api.star-history.com/svg?repos=Passer1072/RookieAI_yolov8)](https://star-history.com/#Passer1072/RookieAI_yolov8)

### 更新日志：

[已迁移](CHANGELOG.md)

___
Current latest version: ###

```

`RookieAI.py`:

```py
import contextlib
import math
import multiprocessing
import os
import queue
import subprocess
import sys
import time
import cv2
import mss
import numpy as np
import pyautogui
import win32api
import win32con
from math import sqrt
from ultralytics import YOLO
from PyQt6 import QtWidgets, uic
from PyQt6.QtCore import QTimer, Qt, QPropertyAnimation, QPoint, QEasingCurve, QParallelAnimationGroup, QRect, QSize
from PyQt6.QtGui import QIcon, QImage, QPixmap, QBitmap, QPainter
from PyQt6.QtWidgets import QGraphicsOpacityEffect, QFileDialog, QMessageBox, QSizePolicy
from multiprocessing import Pipe, Process, Queue, shared_memory, Event
from customLib.animated_status import AnimatedStatus  # 导入 带动画的状态提示浮窗 库
from customLib.automatic_trigger_set_dialog import AutomaticTriggerSetDialog  # 导入自定义设置窗口类
from Module.const import method_mode
from Module.config import Config, Root
from Module.control import kmNet
from Module.logger import logger
import Module.control as control
import Module.keyboard as keyboard
import Module.jump_detection as jump_detection
import Module.announcement

# 初始化配置文件
Config.save()

def communication_Process(pipe, videoSignal_queue, videoSignal_stop_queue, floating_information_signal_queue,
                          information_output_queue):
    """
    总通信进程
    pipe_parent
    """
    global video_running

    logger.debug("启动 communication_Process 监听信号...")
    while True:
        if pipe.poll():
            try:
                message = pipe.recv()
                if isinstance(message, tuple):  # 处理消息类型
                    cmd, cmd_01 = message
                    logger.debug(f"收到信号: {cmd}")
                    logger.debug(f"信号内容: {cmd_01}")

                    information_output_queue.put(
                        ("log_output_main", message))  # 显示调试信息

                    # 手动触发异常测试
                    if cmd == "trigger_error":
                        logger.info("手动触发异常测试")
                        raise ValueError("[INFO]手动触发的错误")

                    if cmd == "start_video":
                        logger.info("启动视频命令")
                        video_running = True
                        videoSignal_queue.put(("start_video", cmd_01))

                    elif cmd == "stop_video":
                        logger.info("停止视频命令")
                        video_running = False
                        videoSignal_stop_queue.put(("stop_video", cmd_01))

                    elif cmd == "loading_complete":
                        logger.info("软件初始化完毕")
                        floating_information_signal_queue.put(
                            ("loading_complete", cmd_01))

                    elif cmd == "loading_error":
                        logger.error("一般错误，软件初始化失败")
                        floating_information_signal_queue.put(
                            ("error_log", cmd_01))

                    elif cmd == "red_error":
                        logger.fatal("致命错误，无法加载模型")
                        floating_information_signal_queue.put(
                            ("red_error_log", cmd_01))

            except (BrokenPipeError, EOFError) as e:
                logger.error(f"管道通信错误: {e}")
                information_output_queue.put(
                    ("error_log", f"管道通信错误: {e}"))  # 捕获并记录错误信息
            except Exception as e:
                logger.error(f"发生错误: {e}")
                information_output_queue.put(("error_log", f"未知错误: {e}"))


def start_capture_process_multie(shm_name, frame_shape, frame_dtype, frame_available_event,
                                 videoSignal_queue, videoSignal_stop_queue, pipe, information_output_queue,
                                 ProcessMode):
    """
    （多进程）
    子进程视频信号获取逻辑 \n
    接收内容:\n
    1.start_video \n
    2.stop_video
    """

    # 连接到共享内存
    existing_shm = shared_memory.SharedMemory(name=shm_name)
    shared_frame = np.ndarray(
        frame_shape, dtype=frame_dtype, buffer=existing_shm.buf)

    logger.debug("视频信号获取进程已启动。")
    while True:
        try:
            message = videoSignal_queue.get(timeout=1)
            command, information = message
            logger.debug(f"接收到命令: {command}, 内容: {information}")
            information_output_queue.put(
                ("video_signal_acquisition_log", message))  # 调试信息输出

            if command == "start_video":
                logger.debug("进程模式选择")
                logger.info("进程模式：", ProcessMode)
                open_screen_video(
                    shared_frame, frame_available_event, videoSignal_stop_queue)
            if command == "change_model":
                logger.info("正在重新加载模型")
                model_file = information
                model = YOLO(model_file)
                logger.info(f"模型 {model_file} 加载完毕")
        except queue.Empty:
            pass
        except Exception as e:
            logger.error(f"获取视频信号时发生错误: {e}")
            information_output_queue.put(("error_log", f"获取视频信号时发生错误: {e}"))


def start_capture_process_single(videoSignal_queue, videoSignal_stop_queue, information_output_queue,
                                 processedVideo_queue, YoloSignal_queue, pipe_parent, model_file,
                                 box_shm_name, box_data_event, box_lock, accessibilityProcessSignal_queue):
    """
    （单进程）子进程视频信号获取逻辑
    接收内容:
    1.start_video
    2.stop_video
    """
    logger.debug("视频信号获取进程已启动。")

    def initialization_Yolo(model_file, information_output_queue):
        """初始化 YOLO 并进行一次模拟推理"""
        try:
            # 检查模型文件是否存在
            if not os.path.exists(model_file):
                logger.warn(f"模型文件 '{model_file}' 未找到，尝试使用默认模型 'yolov8n.pt'。")
                information_output_queue.put(
                    ("log_output_main", f"模型文件 '{model_file}' 未找到，使用默认模型 yolov8n.pt'。"))
                model_file = "yolov8n.pt"
                log_message = f"[ERROR]一般错误，模型文件 '{model_file}' 未找到，使用默认模型 'yolov8n.pt'。"
                # 选定文件未能找到，黄色报错
                pipe_parent.send(("loading_error", log_message))
                if not os.path.exists(model_file):
                    logger.fatal(f"致命错误，默认模型文件 '{model_file}' 也未找到。请确保模型文件存在。")
                    log_message = f"[ERROR]致命错误，默认模型文件 '{model_file}' 也未找到。请确保模型文件存在。"
                    # 默认文件也未找到，红色报错
                    pipe_parent.send(("red_error", log_message))
                    raise FileNotFoundError(
                        f"默认模型文件 '{model_file}' 也未找到。请确保模型文件存在。")

            model = YOLO(model_file)  # 加载 YOLO 模型
            logger.info(f"YOLO 模型 '{model_file}' 已加载。")
            # 创建一张临时图像（纯色或随机噪声）用于预热
            temp_img = np.zeros((320, 320, 3), dtype=np.uint8)  # 修改为640x640
            temp_img_path = "temp_init_image.jpg"
            cv2.imwrite(temp_img_path, temp_img)
            # 执行一次模拟推理
            model.predict(temp_img_path, conf=0.5)
            logger.debug("YOLO 模型已预热完成。")
            os.remove(temp_img_path)  # 删除临时图像
            return model
        except Exception as e:
            logger.error(f"YOLO 初始化失败: {e}")
            information_output_queue.put(("error_log", f"YOLO 初始化失败: {e}"))
            return None

    model = initialization_Yolo(
        model_file, information_output_queue)  # 初始化YOLO
    pipe_parent.send(("loading_complete", True))  # 初始化加载完成标志

    with contextlib.suppress(KeyboardInterrupt):
        while True:
            """开始监听视频开关信号"""
            try:
                message = videoSignal_queue.get(timeout=1)
                command, information = message
                logger.debug(f"接收到命令: {command}, 内容: {information}")
                information_output_queue.put(
                    ("video_signal_acquisition_log", message))  # 调试信息输出
                if command == 'start_video':
                    logger.debug("启动视频捕获和YOLO处理")
                    # 调用集成了共享内存写入的屏幕捕获和YOLO处理函数
                    screen_capture_and_yolo_processing(
                        processedVideo_queue, videoSignal_stop_queue, YoloSignal_queue,
                        pipe_parent, information_output_queue, model,
                        box_shm_name, box_data_event, box_lock, accessibilityProcessSignal_queue
                    )
                if command == 'change_model':  # 重新加载模型
                    logger.info("正在重新加载模型")
                    model_file = information
                    model = YOLO(model_file)
                    logger.info(f"模型 {model_file} 加载完毕")
            except queue.Empty:
                pass
            except Exception as e:
                logger.error(f"获取视频信号时发生错误: {e}")
                information_output_queue.put(
                    ("error_log", f"获取视频信号时发生错误: {e}"))


def open_screen_video(shared_frame, frame_available_event, videoSignal_stop_queue):
    """（多进程）打开屏幕捕获并显示视频帧，限制截图速率为100 FPS"""
    # 清空 videoSignal_stop_queue 队列
    while not videoSignal_stop_queue.empty():
        try:
            videoSignal_stop_queue.get_nowait()
        except Exception:
            break
    with mss.mss() as sct:
        _extracted_from_open_screen_video_11(
            videoSignal_stop_queue, sct, shared_frame, frame_available_event
        )


# TODO Rename this here and in `open_screen_video`
def _extracted_from_open_screen_video_11(videoSignal_stop_queue, sct, shared_frame, frame_available_event):
    # 获取屏幕分辨率
    screen_width, screen_height = pyautogui.size()
    logger.info("屏幕分辨率:", screen_width, screen_height)

    # 计算中心区域 320x320 的截取范围
    capture_width, capture_height = 320, 320
    left = (screen_width - capture_width) // 2
    top = (screen_height - capture_height) // 2
    capture_area = {
        "top": top,
        "left": left,
        "width": capture_width,
        "height": capture_height
    }

    # 初始化 'frame' 以避免引用前未赋值
    frame = np.zeros((capture_height, capture_width, 3), dtype=np.uint8)

    frame_interval = 0.05

    while True:
        frame_start_time = time.time()  # 记录帧开始时间

        # 检查是否收到停止信号
        if not videoSignal_stop_queue.empty():
            command, _ = videoSignal_stop_queue.get()
            logger.debug(f"videoSignal_stop_queue（多进程） 队列接收信息 {command}")
            if command == 'stop_video':
                logger.debug("停止屏幕捕获")
                break  # 退出循环

        # 获取指定区域的截图
        img = sct.grab(capture_area)

        # 使用 numpy.frombuffer 直接转换为数组，避免数据拷贝
        frame = np.frombuffer(img.rgb, dtype=np.uint8)
        frame = frame.reshape((img.height, img.width, 3))

        # 转换颜色空间，从 BGRA 到 RGB
        frame = cv2.cvtColor(frame, cv2.COLOR_BGRA2RGB)

        # 将视频帧放入共享内存
        np.copyto(shared_frame, frame)
        frame_available_event.set()

        # 计算已用时间
        frame_end_time = time.time()
        elapsed_time = frame_end_time - frame_start_time

        # 计算剩余时间
        remaining_time = frame_interval - elapsed_time
        if remaining_time > 0:
            time.sleep(remaining_time)
        else:
            # 如果处理时间超过了帧间隔，可能需要记录或优化
            logger.warn(
                f"视频帧处理时间 {elapsed_time:.4f} 秒超过目标间隔 {frame_interval:.4f} 秒")


def screen_capture_and_yolo_processing(processedVideo_queue, videoSignal_stop_queue, YoloSignal_queue, pipe_parent,
                                       information_output_queue, model,
                                       box_shm_name, box_data_event, box_lock, accessibilityProcessSignal_queue):
    """
    （单进程）整合屏幕捕获和 YOLO 推理。

    参数:
    - processedVideo_queue: 处理后的视频队列
    - videoSignal_stop_queue: 视频停止信号队列
    - YoloSignal_queue: YOLO 控制队列
    - pipe_parent: 管道父端
    - information_output_queue: 调试信息输出队列
    - model: YOLO 模型实例
    - box_shm_name: Box 坐标共享内存名称
    - box_data_event: 用于通知 Box 数据可用的 Event
    - box_lock: 用于同步访问共享内存的 Lock
    """
    global unique_id_counter

    yolo_enabled = False
    yolo_confidence = 0.5  # 初始化 YOLO 置信度
    unique_id_counter = 0

    # 清空 videoSignal_stop_queue 队列
    while not videoSignal_stop_queue.empty():
        try:
            videoSignal_stop_queue.get_nowait()
        except Exception:
            break

    with mss.mss(backend='directx') as sct:
        # 获取屏幕分辨率
        screen_width, screen_height = pyautogui.size()
        logger.info("屏幕分辨率:", screen_width, screen_height)
        # 计算中心区域 320x320 的截取范围
        capture_width, capture_height = 320, 320
        left = (screen_width - capture_width) // 2
        top = (screen_height - capture_height) // 2
        capture_area = {
            "top": top,
            "left": left,
            "width": capture_width,
            "height": capture_height
        }
        while True:
            try:
                # 检查是否收到停止信号
                if not videoSignal_stop_queue.empty():
                    command, _ = videoSignal_stop_queue.get()
                    logger.debug(f"videoSignal_stop_queue（单进程） 队列接收信息 {command}")
                    if command == 'stop_video':
                        logger.debug("停止屏幕捕获")
                        break
                    if command == 'change_model':
                        logger.debug("重新加载模型")
                        break
                # 检查 YOLO 的开启或停止信号
                if not YoloSignal_queue.empty():
                    command_data = YoloSignal_queue.get()
                    if isinstance(command_data, tuple):
                        cmd, cmd_01 = command_data
                        information_output_queue.put(
                            ("video_processing_log", command_data))
                        if cmd == 'YOLO_start':
                            yolo_enabled = True
                        elif cmd == 'YOLO_stop':
                            yolo_enabled = False
                        elif cmd == "change_conf":  # 更改置信度
                            logger.debug(f"更改置信度: {cmd_01}")
                            yolo_confidence = cmd_01
                        elif cmd == "change_class":
                            logger.debug(f"更改检测类别为: {cmd_01}")
                            target_class = cmd_01  # 更新目标类别
                        elif cmd == "aim_range_change":
                            aim_range = cmd_01
                            logger.debug(f"瞄准范围更改_02: {aim_range}")
                # 获取屏幕帧
                img = sct.grab(capture_area)
                # 转换为 numpy 数组
                frame = np.frombuffer(img.rgb, dtype=np.uint8).reshape(
                    (img.height, img.width, 3))
                # 转换颜色空间从 BGRA 到 RGB
                frame = cv2.cvtColor(frame, cv2.COLOR_BGRA2RGB)
                # 如果启用了 YOLO，执行推理并写入共享内存
                if yolo_enabled and model is not None:
                    processed_frame = YOLO_process_frame(
                        model, frame, accessibilityProcessSignal_queue, yolo_confidence,
                        target_class=target_class,  # 使用更新后的目标类别
                        box_shm_name=box_shm_name,
                        box_data_event=box_data_event,
                        box_lock=box_lock,
                        aim_range=aim_range,
                    )
                else:
                    processed_frame = frame
                # 将处理后的帧放入队列中
                processedVideo_queue.put(processed_frame)
            except Exception as e:
                logger.warn(f"捕获或处理时出错: {e}")
                information_output_queue.put(("error_log", f"捕获或处理时出错: {e}"))
                break


def video_processing(shm_name, frame_shape, frame_dtype, frame_available_event,
                     processedVideo_queue, YoloSignal_queue, pipe_parent, information_output_queue, model_file,
                     box_shm_name, box_data_event, box_lock, accessibilityProcessSignal_queue):
    """
    （多进程）对视频进行处理，支持 YOLO 推理。

    参数:
    - shm_name: 视频帧共享内存名称
    - frame_shape: 视频帧形状
    - frame_dtype: 视频帧数据类型
    - frame_available_event: 用于通知新帧可用的 Event
    - processedVideo_queue: 处理后的视频队列
    - YoloSignal_queue: YOLO 控制队列
    - pipe_parent: 管道父端
    - information_output_queue: 调试信息输出队列
    - model_file: YOLO 模型文件路径
    - box_shm_name: Box 坐标共享内存名称
    - box_data_event: 用于通知 Box 数据可用的 Event
    - box_lock: 用于同步访问共享内存的 Lock
    """
    global unique_id_counter

    yolo_enabled = False
    model = None
    frame = None
    yolo_confidence = 0.5
    target_class = "ALL"  # 初始化目标类别
    unique_id_counter = 0
    aim_range = 20  # 瞄准范围默认值

    # 连接到共享内存
    existing_shm = shared_memory.SharedMemory(name=shm_name)
    shared_frame = np.ndarray(
        frame_shape, dtype=frame_dtype, buffer=existing_shm.buf)

    try:
        # 初始化 YOLO
        # 检查模型文件是否存在，如果不存在则使用默认模型
        if not os.path.exists(model_file):
            logger.warn(f"模型文件 '{model_file}' 未找到，尝试使用默认模型 'yolov8n.pt'")
            information_output_queue.put(
                ("log_output_main", f"模型文件 '{model_file}' 未找到，使用默认模型 'yolov8n.pt'。"))
            log_message = f"[ERROR]一般错误，模型文件 '{model_file}' 未找到，使用默认模型 'yolov8n.pt'。"
            pipe_parent.send(("loading_error", log_message))  # 选定文件未能找到，黄色报错
            model_file = "yolov8n.pt"
            if not os.path.exists(model_file):
                logger.fatal(f"致命错误，默认模型文件 '{model_file}' 也未找到。请确保模型文件存在。")
                log_message = f"[ERROR]致命错误，默认模型文件 '{model_file}' 也未找到。请确保模型文件存在。"
                pipe_parent.send(("red_error", log_message))  # 默认文件也未找到，红色报错
                raise FileNotFoundError(
                    f"默认模型文件 '{model_file}' 也未找到。请确保模型文件存在。")
        model = YOLO(model_file)
        logger.debug("YOLO 模型已加载。")

        # 进行一次模拟推理以预热模型
        temp_img = np.zeros((320, 320, 3), dtype=np.uint8)
        model.predict(temp_img, conf=0.5)
        logger.debug("YOLO 模型已预热完成。")

        pipe_parent.send(("loading_complete", True))  # 软件初始化加载完毕标志

        while True:
            # 检查 YoloSignal_queue 中的信号
            if not YoloSignal_queue.empty():
                command_data = YoloSignal_queue.get()
                if isinstance(command_data, tuple):
                    cmd, cmd_01 = command_data
                    logger.debug(
                        f"video_processing(YoloSignal_queue) 收到命令: {cmd}, 信息: {cmd_01}")
                    information_output_queue.put(
                        ("video_processing_log", command_data))  # 显示调试信息
                    if cmd == 'YOLO_start':
                        yolo_enabled = True
                    elif cmd == 'YOLO_stop':
                        yolo_enabled = False
                    elif cmd == 'change_model':
                        logger.debug("video_processing进程 模型已重新加载")
                        model = YOLO(cmd_01)
                    elif cmd == "change_conf":
                        logger.debug("更改置信度")
                        yolo_confidence = cmd_01
                    elif cmd == "change_class":
                        logger.debug(f"更改检测类别为: {cmd_01}")
                        target_class = cmd_01  # 更新目标类别
                    elif cmd == "aim_range_change":
                        aim_range = cmd_01
                        logger.debug(f"瞄准范围更改_01: {aim_range}")

            # 等待新帧
            frame_available_event.wait()
            frame = shared_frame.copy()
            frame_available_event.clear()

            if yolo_enabled and model is not None:
                # 执行 YOLO 推理并写入共享内存
                processed_frame = YOLO_process_frame(
                    model, frame, yolo_confidence,
                    target_class=target_class,  # 使用更新后的目标类别
                    box_shm_name=box_shm_name,
                    box_data_event=box_data_event,
                    box_lock=box_lock,
                    aim_range=aim_range,
                )
            else:
                processed_frame = frame

            # 将处理后的帧放入队列
            processedVideo_queue.put(processed_frame)
    except Exception as e:
        logger.error(f"视频处理发生错误: {e}")
        information_output_queue.put(("error_log", f"视频处理发生错误: {e}"))
    finally:
        existing_shm.close()


def YOLO_process_frame(
    model,
    frame,
    accessibilityProcessSignal_queue,
    yolo_confidence=0.1,
    target_class="ALL",
    box_shm_name=None,
    box_data_event=None,
    box_lock=None,
    aim_range=100
):
    """
    对帧进行 YOLO 推理，返回带有标注的图像，并将最近的 Box 坐标、距离和唯一ID写入共享内存。
    """
    global unique_id_counter  # 声明使用全局变量
    try:
        # 确定 YOLO 推理中要使用的类别
        if target_class == "ALL":
            classes = None  # 允许检测所有类别
        else:
            try:
                classes = [int(target_class)]  # 只检测指定的类别
            except ValueError:
                classes = None  # 如果转换失败，则检测所有类别

        # 执行 YOLO 推理
        results = model.predict(
            frame,
            save=False,
            device="cuda:0",
            verbose=False,
            save_txt=False,
            half=True,
            conf=yolo_confidence,
            classes=classes  # 指定类别
        )

        # 获取检测结果
        boxes = results[0].boxes.xyxy  # 获取所有 Box 的 xyxy 坐标
        distances = []  # 用于存储每个 Box 到帧中心的距离
        frame = results[0].plot()  # 绘制检测框信息

        # 计算帧中心点
        frame_height, frame_width = frame.shape[:2]
        frame_center = (frame_width / 2, frame_height / 2)

        # 计算每个 Box 的距离
        for box in boxes:
            x1, y1, x2, y2 = box.cpu().numpy()  # 获取每个 Box 的坐标
            box_center = ((x1 + x2) / 2, (y1 + y2) / 2)  # 计算每个 Box 的中心点
            distance = sqrt((box_center[0] - frame_center[0]) ** 2 + (box_center[1] - frame_center[1]) ** 2)  # 计算距离
            distances.append(distance)  # 将距离加入到 distances 列表中

        # 找到距离最近的 Box
        if distances:
            min_distance_idx = np.argmin(distances)  # 找到最小距离的索引
            closest_box = boxes[min_distance_idx].cpu().numpy()
            closest_distance = distances[min_distance_idx]
            new_trigger_conditions = True
        else:
            closest_box = None
            closest_distance = None
            new_trigger_conditions = False

        # 初始化 last_put_data
        if not hasattr(YOLO_process_frame, "last_put_data"):
            YOLO_process_frame.last_put_data = None

        # 发送 Trigger_conditions 到队列，避免重复数据
        if new_trigger_conditions != YOLO_process_frame.last_put_data:
            try:
                accessibilityProcessSignal_queue.put(
                    ("Trigger_conditions", False), timeout=0.1
                )
                YOLO_process_frame.last_put_data = new_trigger_conditions
                logger.debug(f"放入队列的数据: ('Trigger_conditions', {new_trigger_conditions})")
            except multiprocessing.queues.Full:
                logger.warning("accessibilityProcessSignal_queue 已满，无法放入数据")

        # 将最近的 Box 坐标、距离和唯一ID写入共享内存
        if box_shm_name and box_data_event and box_lock:
            # 连接到共享内存
            box_shm = shared_memory.SharedMemory(name=box_shm_name)
            # 修改共享内存结构，加入unique_id
            box_array = np.ndarray(
                (1, 6), dtype=np.float32, buffer=box_shm.buf
            )
            with box_lock:
                box_array.fill(0)  # 清空之前的数据
                if closest_box is not None:
                    x1, y1, x2, y2 = closest_box
                    unique_id_counter += 1  # 递增唯一ID
                    unique_id = unique_id_counter
                    box_array[0, :4] = [x1, y1, x2, y2]  # 存储最近的 Box 坐标
                    box_array[0, 4] = closest_distance  # 存储距离
                    box_array[0, 5] = unique_id  # 存储唯一ID
            # 发送 Box 数据可用信号
            box_data_event.set()
            box_shm.close()

        # 绘制一个淡蓝色的细圆（瞄准范围）
        circle_color = (173, 216, 230)  # 淡蓝色
        cv2.circle(frame, (int(frame_center[0]), int(frame_center[1])), aim_range, circle_color, 1)

        # 绘制所有 Box
        for i, box in enumerate(boxes):
            x1, y1, x2, y2 = box.cpu().numpy()
            box_center = (int((x1 + x2) / 2), int((y1 + y2) / 2))
            # 默认所有框使用黄色连接线
            box_color = (255, 255, 0)  # 黄色边框
            line_color = (255, 255, 0)  # 黄色连接线
            # 绘制矩形框
            cv2.rectangle(frame, (int(x1), int(y1)), (int(x2), int(y2)), box_color, 2)
            # 绘制中心点
            cv2.circle(frame, box_center, 5, (0, 0, 255), -1)
            # 绘制连接线条
            cv2.line(frame, box_center, (int(frame_center[0]), int(frame_center[1])), line_color, 2)
            # 计算距离
            distance = sqrt((box_center[0] - frame_center[0]) ** 2 + (box_center[1] - frame_center[1]) ** 2)
            # 绘制距离文本
            distance_text = f"{distance:.1f}px"
            cv2.putText(frame, distance_text, (int(x1), int(y1) - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)

        # 如果有最近的 Box，再绘制其绿色框和红色连接线（覆盖上一步绘制）
        if closest_box is not None:
            # 获取最近的 Box 的坐标和中心
            x1, y1, x2, y2 = closest_box
            box_center = (int((x1 + x2) / 2), int((y1 + y2) / 2))
            # 只有当距离小于 aim_range 时，才绘制绿色框和红色连接线
            if closest_distance < aim_range:
                # 绘制最近的框的绿色边框
                cv2.rectangle(frame, (int(x1), int(y1)), (int(x2), int(y2)), (0, 255, 0), 3)
                # 绘制中心点
                cv2.circle(frame, box_center, 5, (0, 255, 0), -1)
                # 绘制红色连接线
                cv2.line(frame, box_center, (int(frame_center[0]), int(frame_center[1])), (255, 0, 0), 3)

        # 返回带有检测结果的图像
        return frame  # 返回绘制后的图像是 BGR 格式

    except Exception as e:
        logger.error(f"YOLO 推理失败: {e}")
        return frame  # 如果 YOLO 推理失败，返回原始帧


def mouse_move_prosses(box_shm_name, box_lock, mouseMoveProssesSignal_queue, accessibilityProcessSignal_queue,
                       aim_speed_x=0.2, aim_speed_y=0.0, aim_range=100, offset_centerx=0, offset_centery=0.3,
                       lockKey=0x02, aimbot_switch=True, mouse_Side_Button_Witch=True,
                       screen_pixels_for_360_degrees=1800,
                       screen_height_pixels=900, near_speed_multiplier=2, slow_zone_radius=10, mouseMoveMode='win32'):
    """
    鼠标移动进程，读取最近的 Box 数据并执行鼠标移动。

    参数:
    - box_shm_name: Box 坐标共享内存的名称
    - box_lock: 用于同步访问共享内存的 Lock
    - aim_speed_x: X轴基础瞄准速度
    - aim_speed_y: Y轴基础瞄准速度
    - aim_range: 瞄准范围
    - threshold: 距离阈值
    - fast_decay_rate: 当 distance < threshold 时的衰减率
    - slow_decay_rate: 当 distance >= threshold 时的衰减率
    - offset_centerx: X 轴瞄准偏移量
    - offset_centery: Y 轴瞄准偏移量
    - lockKey: 锁定键代码
    - aimbot_switch: 自瞄开关
    - mouse_Side_Button_Witch: 是否开启鼠标侧键瞄准
    """

    IP = "192.168.2.188"
    PORT = "1244"
    MAC = "84FF7019"
    connectKmBox = False

    logger.debug("测试KmBoxNet连通性...")
    response = subprocess.run(
        ["ping", IP], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output = response.stdout.decode('gbk', errors='ignore')
    logger.debug(output)

    # 根据 returncode 判断是否连通
    if response.returncode == 0:
        logger.info("KmBoxNet IP连通成功")
    else:
        logger.error("KmBoxNet IP连通测试失败")

    # 连接到 Box 共享内存
    box_shm = shared_memory.SharedMemory(name=box_shm_name)
    box_array = np.ndarray((1, 6), dtype=np.float32, buffer=box_shm.buf)

    # 获取截图中心坐标
    screenshot_center_x = 320 // 2
    screenshot_center_y = 320 // 2

    # 初始化变量
    last_unique_id = 0    # 上次读取的数据的唯一ID

    # 触发方式 按下/切换 press/toggle
    trigger_mode = 'press'
    trigger_toggle_state = False  # 切换触发模式下的运行状态
    prev_lockKey_pressed = False  # 上一次循环时触发键的状态

    # 初始化目标切换状态
    target_switching = False
    last_offset_distance = None  # 上次的偏移后目标距离
    fluctuation_range = 10  # 波动范围，单位：像素
    jump_detection_switch = False  # 跳变检测开关

    # 初始化自动扳机
    automatic_trigger_range_scale_factor = 0.1

    # 初始化 last_put_data 变量
    last_put_data = None

    try:
        while True:
            '''信号检查部分'''
            if not mouseMoveProssesSignal_queue.empty():
                command_data = mouseMoveProssesSignal_queue.get()
                logger.debug(f"mouseMoveProssesSignal_queue 队列收到信号: {command_data}")
                if isinstance(command_data, tuple):
                    cmd, cmd_01 = command_data
                    if cmd == "aimbot_switch_change":
                        aimbot_switch = cmd_01
                        logger.debug(f"自瞄状态更改: {aimbot_switch}")
                    elif cmd == "aim_speed_x_change":
                        aim_speed_x = cmd_01
                        logger.debug(f"X轴瞄准速度更改: {aim_speed_x}")
                    elif cmd == "aim_speed_y_change":
                        aim_speed_y = cmd_01
                        logger.debug(f"Y轴瞄准速度更改: {aim_speed_y}")
                    elif cmd == "aim_range_change":
                        aim_range = cmd_01
                        logger.debug(f"瞄准范围更改: {aim_range}")
                    elif cmd == "offset_centerx_change":
                        offset_centerx = cmd_01
                        logger.debug(f"瞄准偏移X更改: {offset_centerx}")
                    elif cmd == "offset_centery_change":
                        offset_centery = cmd_01
                        logger.debug(f"瞄准偏移Y更改: {offset_centery}")
                    elif cmd == "triggerMethod_change":
                        triggerMethod = cmd_01
                        logger.debug(f"瞄准热键触发方式更改: {triggerMethod}")
                    elif cmd == "lock_key_change":
                        lockKey = cmd_01
                        logger.debug(f"瞄准热键更改: {lockKey}")
                    elif cmd == "mouse_Side_Button_Witch_change":
                        mouse_Side_Button_Witch = cmd_01
                        logger.debug(f"侧键瞄准开关更改: {mouse_Side_Button_Witch}")
                    elif cmd == "trigger_mode_change":
                        trigger_mode = cmd_01  # 'press' 或 'toggle'
                        logger.debug(f"触发模式已更改为: {trigger_mode}")
                    elif cmd == "screen_pixels_for_360_degrees":
                        screen_pixels_for_360_degrees = cmd_01
                        logger.debug(f"游戏内X像素设置为: {screen_pixels_for_360_degrees}")
                    elif cmd == "screen_height_pixels":
                        screen_height_pixels = cmd_01
                        logger.debug(f"游戏内Y像素设置为: {screen_height_pixels}")
                    elif cmd == "near_speed_multiplier":
                        near_speed_multiplier = cmd_01
                        logger.debug(f"近点瞄准速度倍率设置为: {near_speed_multiplier}")
                    elif cmd == "slow_zone_radius":
                        slow_zone_radius = cmd_01
                        logger.debug(f"减速区域设置为: {slow_zone_radius}")
                    elif cmd == "mouseMoveMode":
                        mouseMoveMode = cmd_01
                        logger.debug(f"设置鼠标移动模式为: {mouseMoveMode}")
                    elif cmd == "automatic_trigger_range_switching":
                        automatic_trigger_range_scale_factor = cmd_01
                        logger.debug(f"自动扳机范围比例设置为: {automatic_trigger_range_scale_factor}")
                    elif cmd == "jump_detection_switch":
                        jump_detection_switch = cmd_01
                        logger.debug(f"跳变检测设置为: {jump_detection_switch}")
                    elif cmd == "jump_suppression_fluctuation_range":
                        fluctuation_range = cmd_01
                        logger.debug(f"跳变误差设置为: {fluctuation_range}")

            if mouseMoveMode == "KmBoxNet" and not connectKmBox:
                '''连接KmBox'''
                logger.info("尝试连接KmBox")
                kmNet.init(IP, PORT, MAC)  # 连接盒子
                kmNet.enc_move(100, 100)  # 测试移动
                connectKmBox = True
                logger.info("KmBox连接成功")

            pixels_per_degree_x = screen_pixels_for_360_degrees / 360  # 每度需要的像素数度
            pixels_per_degree_y = screen_height_pixels / 180  # 每度像素数

            '''鼠标移动处理部分'''
            # 获取最新的 Box 数据
            with box_lock:
                boxes = box_array.copy()

            # 获取最近的 Box（第一项）
            closest_box = boxes[0]
            x1, y1, x2, y2, distance, unique_id = closest_box

            # 检查是否有新数据
            if unique_id != last_unique_id:
                # 有新数据
                last_unique_id = int(unique_id)
                if not np.all(closest_box[:5] == 0):
                    # 计算Box的中心点
                    center_x = (x1 + x2) / 2
                    center_y = (y1 + y2) / 2

                    # 将 Box 中心点坐标从左上角坐标系转为以截图中心为原点的坐标系
                    center_x_relative_to_center = center_x - screenshot_center_x
                    center_y_relative_to_center = center_y - screenshot_center_y

                    # 计算中心点到上边框的垂直距离
                    vertical_distance = center_y - y1
                    # logger.debug(f"中心点到上边框的垂直距离: {vertical_distance}")

                    # 计算左边框到右边框的距离
                    horizontal_distance = x2 - x1
                    # logger.debug(f"左边框到右边框的水平距离: {horizontal_distance}")

                    # 计算目标相对于截图中心的偏移
                    delta_x = horizontal_distance * offset_centerx
                    delta_y = -vertical_distance * offset_centery
                    offset_target_x = center_x_relative_to_center + delta_x  # 偏移后目标点X
                    offset_target_y = center_y_relative_to_center + delta_y  # 偏移后目标点Y

                    # 计算偏移后的距离
                    offset_distance = math.sqrt(
                        offset_target_x ** 2 + offset_target_y ** 2)

                    # 自动扳机范围计算
                    box_horizontal_length = x2 - x1  # Box 的横向长度
                    automatic_trigger_range = (box_horizontal_length * automatic_trigger_range_scale_factor) / 2  # 半径为横向长度 * 缩放因子的一半

                    # 将像素偏移转换为角度偏移
                    angle_offset_x = offset_target_x / pixels_per_degree_x  # 度
                    angle_offset_y = offset_target_y / pixels_per_degree_y  # 度

                    # 基础 aim_speed 和最大 aim_speed
                    base_aim_speed_x = aim_speed_x  # x轴的基础速度
                    base_aim_speed_y = aim_speed_y  # y轴的基础速度
                    max_aim_speed_x = near_speed_multiplier * base_aim_speed_x  # 最大X速度
                    max_aim_speed_y = near_speed_multiplier * base_aim_speed_y  # 最大Y速度

                    # 动态调整 aim_speed
                    if offset_distance < slow_zone_radius:
                        # 偏移距离越小，aim_speed 越接近 base_aim_speed
                        last_aim_speed_x = base_aim_speed_x + (max_aim_speed_x - base_aim_speed_x) * (
                                    offset_distance / slow_zone_radius)
                        last_aim_speed_y = base_aim_speed_y + (max_aim_speed_y - base_aim_speed_y) * (
                                    offset_distance / slow_zone_radius)
                    elif offset_distance < aim_range:
                        # 使用偏移后的距离动态调整 aim_speed
                        last_aim_speed_x = base_aim_speed_x + (max_aim_speed_x - base_aim_speed_x) * (
                                    1 - offset_distance / aim_range)
                        last_aim_speed_y = base_aim_speed_y + (max_aim_speed_y - base_aim_speed_y) * (
                                    1 - offset_distance / aim_range)
                    else:
                        # 超过瞄准范围时，保持基础 aim_speed
                        last_aim_speed_x = base_aim_speed_x
                        last_aim_speed_y = base_aim_speed_y

                    # 保留小数点后两位
                    last_aim_speed_x = round(last_aim_speed_x, 2)
                    last_aim_speed_y = round(last_aim_speed_y, 2)

                    move_x = angle_offset_x * last_aim_speed_x * 2
                    move_y = angle_offset_y * last_aim_speed_y * 2

                    # 判断目标是否在瞄准范围内
                    target_is_within_range = distance < aim_range

                    if isinstance(lockKey, str) and lockKey.startswith("0x"):
                        lockKey = int(lockKey, 16)  # 转换为十六进制整数

                    # 检查锁定键、鼠标侧键和 Shift 键是否按下
                    lockKey_pressed = bool(win32api.GetKeyState(lockKey) & 0x8000)
                    xbutton2_pressed = bool(win32api.GetKeyState(0x05) & 0x8000)  # 鼠标侧键
                    shift_pressed = bool(win32api.GetKeyState(win32con.VK_SHIFT) & 0x8000)  # Shift 键

                    if trigger_mode == 'press':
                        # 按下模式：只需检测按键是否被按下
                        should_move = aimbot_switch and target_is_within_range and (
                            lockKey_pressed or (
                                mouse_Side_Button_Witch and xbutton2_pressed)
                        )
                    elif trigger_mode == 'shift+press':
                        # Shift + 按下模式：需要同时按下 Shift 和锁定键
                        should_move = aimbot_switch and target_is_within_range and (
                            shift_pressed and lockKey_pressed
                        )

                    elif trigger_mode == 'toggle':
                        # 检测按键从未按下变为按下的瞬间
                        if lockKey_pressed and not prev_lockKey_pressed:
                            trigger_toggle_state = not trigger_toggle_state  # 切换运行状态
                            # logger.debug(f"切换触发状态已更改为: {trigger_toggle_state}")
                        # 更新上一次的按键状态
                        prev_lockKey_pressed = lockKey_pressed
                        # 切换模式：运行状态由 `trigger_toggle_state` 控制
                        should_move = aimbot_switch and target_is_within_range and trigger_toggle_state

                    # 独立的触发逻辑：当仅按下 xbutton2_pressed，mouse_Side_Button_Witch 为 True，同时目标在瞄准范围内
                    if mouse_Side_Button_Witch and xbutton2_pressed and target_is_within_range:
                        should_move = True

                    # 自动扳机：如果目标进入自动扳机范围，则满足触发条件
                    Trigger_conditions = offset_distance <= int(automatic_trigger_range)
                    new_data = ("Trigger_conditions", Trigger_conditions)
                    if new_data != last_put_data:
                        try:
                            accessibilityProcessSignal_queue.put(new_data, timeout=0.1)
                            last_put_data = new_data
                            logger.debug(f"放入队列的数据: {new_data}")
                        except multiprocessing.queues.Full:
                            logger.warning("accessibilityProcessSignal_queue 已满，无法放入数据")

                    # 判断是否发生目标切换：通过move_x_int和move_y_int的数值变化规律
                    if should_move:
                        move_x_int = round(move_x / 2)
                        move_y_int = round(move_y / 2)

                        if last_offset_distance is not None:
                            # 调用跳变检测函数
                            target_switching = jump_detection.check_target_switching(offset_distance, last_offset_distance,
                                                                                     jump_detection_switch, fluctuation_range, target_switching)

                        # 保存当前的 offset_distance 用于下一次比较
                        last_offset_distance = int(offset_distance)

                        # 目标切换时，拒绝执行移动
                        if not target_switching and (move_x_int != 0 or move_y_int != 0):
                            control.move(mouseMoveMode, move_x_int, move_y_int)
                    else:
                        # 当 should_move 为 False 时，重置last_offset_distance为 None,重置规律移动状态
                        # logger.debug("重置规律移动状态")
                        last_offset_distance = None
                        target_switching = False
    except KeyboardInterrupt:
        pass
    finally:
        box_shm.close()


def accessibility_process(accessibilityProcessSignal_queue, mouseMoveMode='win32', click_mode="连点",
                          automatic_trigger_switch=False, Trigger_conditions=False, Effective_mode="按下自瞄生效",
                          mouse_isdown=False, BoxConnect=False, emergenc_stop_switch=False, stop=False):  # 辅助功能进程
    # 按键状态记录
    last_state_w = False
    last_state_a = False
    last_state_s = False
    last_state_d = False


    while True:
        '''信号检查部分'''
        if not accessibilityProcessSignal_queue.empty():
            command_data = accessibilityProcessSignal_queue.get()
            logger.debug(f"accessibilityProcessSignal_queue 队列收到信号: {command_data}")
            if isinstance(command_data, tuple):
                cmd, cmd_01 = command_data
                if cmd == "click_mode":  # 点击模式：“连点” “单点” “长按”
                    click_mode = cmd_01
                    logger.debug(f"点击模式切换为: {click_mode}")
                elif cmd == "automatic_trigger_switch":
                    automatic_trigger_switch = cmd_01
                    logger.debug(f"自动扳机开关切换为: {automatic_trigger_switch}")
                elif cmd == "Trigger_conditions":
                    Trigger_conditions = cmd_01
                    logger.debug(f"扳机条件是否满足: {Trigger_conditions}")
                elif cmd == "mouseMoveMode":
                    mouseMoveMode = cmd_01
                    logger.debug(f"鼠标点击模块为: {mouseMoveMode}")
                elif cmd == "Effective_mode":
                    Effective_mode = cmd_01
                    logger.debug(f"生效模式为: {Effective_mode}")
                elif cmd == "emergenc_stop_switch":
                    emergenc_stop_switch = cmd_01

        if mouseMoveMode == "KmBoxNet" and not BoxConnect:
            IP = "192.168.2.188"
            PORT = "1244"
            MAC = "84FF7019"
            kmNet.init(IP, PORT, MAC)  # 连接盒子
            kmNet.enc_move(100, 100)  # 测试移动
            kmNet.monitor(8888)  # 开启物理键鼠监控功能。使用端口号8888接收物理键鼠数据
            BoxConnect = True

        if Effective_mode == "持续生效":
            mouse_isdown = True
        elif Effective_mode == "按下自瞄生效":
            mouse_isdown = control.monitor(mouseMoveMode)

        if automatic_trigger_switch and Trigger_conditions and mouse_isdown:  # 自动扳机
            if click_mode == "连点":
                control.click(mouseMoveMode)
                # logger.debug(mouseMoveMode)
            elif click_mode == "单击":
                # TODO
                pass
            elif click_mode == "长按":
                # TODO
                pass
        else:
            pass

        if emergenc_stop_switch:  # 急停
            # 调用 monitor_release，接收返回的状态
            last_state_w, last_state_a, last_state_s, last_state_d = control.emergencStop_valorant(
                last_state_w, last_state_a, last_state_s, last_state_d
            )


class RookieAiAPP:  # 主进程 (UI进程)
    """
    RookieAiAPP
    主进程中 初始化UI 进程。
    """

    def __init__(self):
        """初始化 UI"""
        self.information_output_queue = None
        self.floating_information_signal_queue = None
        self.video_queue = None
        self.processedVideo_queue = None
        self.YoloSignal_queue = None
        self.videoSignal_queue = None
        self.videoSignal_stop_queue = None
        self.pipe_child = None
        self.pipe_parent = None

        # 创建 QApplication 实例
        self.app = QtWidgets.QApplication(sys.argv)

        # 加载主窗口 UI 文件
        self.window = uic.loadUi(Root / "UI" / 'RookieAiWindow.ui')  # 请确保 Root 已正确定义
        self.window.setWindowTitle("YOLO识别系统")  # 设置窗口标题
        self.window.setWindowIcon(QIcon(str(Root / "ico" / "ultralytics-botAvatarSrcUrl-1729379860806.png")))  # 设置窗口图标
        self.window.setFixedSize(1290, 585)  # 固定窗口大小（可选）

        self.automaticTriggerSetDialog = AutomaticTriggerSetDialog(self.window)
        self.automaticTriggerSetDialog.setModal(True)  # 设置为模态窗口

        # 连接控制组件
        self.window.OpVideoButton.clicked.connect(
            self.toggle_video_button)  # 连接按钮点击信号到打开视频信号的槽

        # 连接 OpYoloButton 的点击信号到 toggle_YOLO_button 方法
        self.window.OpYoloButton.clicked.connect(self.toggle_YOLO_button)

        # 连接settingsButton按钮，显示设置按钮
        self.window.settingsYoloButton.clicked.connect(self.show_settings)
        self.window.closeYoloSettingsButton.clicked.connect(self.hide_settings)

        # 连接保存按钮
        self.window.saveButton.clicked.connect(self.save_settings)

        # 连接窗口置顶复选框状态改变信号
        self.window.topWindowCheckBox.stateChanged.connect(
            self.update_window_on_top_state)

        # 连接 解锁窗口大小 复选框状态改变信号
        self.window.unlockWindowSizeCheckBox.stateChanged.connect(
            self.update_unlock_window_size)

        # 连接 跳变抑制 复选框改变信号
        self.window.jumpSuppressionCheckBox.stateChanged.connect(self.update_jum_suppression_state)

        # 连接 自动扳机 复选框改变信号
        self.window.automatic_trigger_switchCheckBox.stateChanged.connect(self.update_automatic_trigger_state)

        # 连接 resetSizeButton 的点击信号到槽函数
        self.window.resetSizeButton.clicked.connect(self.reset_window_size)

        # 连接模型选择按钮
        self.window.chooseModelButton.clicked.connect(self.choose_model)

        # 连接重启按钮
        self.window.RestartButton.clicked.connect(self.restart_application)

        # 连接 重新加载模型 按钮 change_yolo_model
        self.window.reloadModelButton.clicked.connect(self.change_yolo_model)

        # 连接 automatic_trigger_switchToolButton 的点击信号到显示设置窗口的槽函数
        self.window.automatic_trigger_switchToolButton.clicked.connect(self.show_automatic_trigger_set_dialog)

        # 连接 自动扳机配置buttonClicked 信号
        self.automaticTriggerSetDialog.buttonGroup.buttonClicked.connect(self.on_button_clicked)

        # 连接 detectionTargetComboBox 的信号到槽函数
        self.window.detectionTargetComboBox.currentTextChanged.connect(
            self.on_detection_target_changed)

        # 连接 aimBotCheckBox 的状态变化信号
        self.window.aimBotCheckBox.stateChanged.connect(
            self.on_aimBotCheckBox_state_changed)

        # 连接 sideButtonCheckBox 的状态变化信号
        self.window.sideButtonCheckBox.stateChanged.connect(
            self.on_sideButtonCheckBox_state_changed)

        # 连接 mobileModeQComboBox 的信号槽函数(鼠标移动模式)
        self.window.mobileModeQComboBox.currentIndexChanged.connect(
            self.on_mobileMode_changed)

        # 连接 触发方式选择 conboBox
        self.window.triggerMethodComboBox.currentTextChanged.connect(
            self.on_trigger_method_changed)

        # 连接 热键选择 HotkeyPushButton
        self.window.HotkeyPushButton.clicked.connect(
            lambda: self.on_trigger_hotkey_changed(self.window.HotkeyPushButton.text()))

        self.window.announcement.setReadOnly(True)
        # 设置公告内容
        logger.debug("正在获取公告信息...")
        Module.announcement.get_announcement(self)

        '''参数框架切换 代码'''
        # 初始化动画列表和当前框架索引
        self.animations = []
        self.animation_group = QParallelAnimationGroup()
        self.current_frame_index = 1  # 初始显示中间的框架（索引为1）
        # 定义框架列表和索引映射
        self.frames = [
            self.window.advancedSettingsFrame,  # 索引0
            self.window.basicSettingsFrame,  # 索引1
            self.window.softwareInformationFrame  # 索引2
        ]
        # 设置每个框架的初始位置
        for i, frame in enumerate(self.frames):
            frame.move((i - self.current_frame_index)
                       * frame.width(), frame.y())
        # 连接按钮点击事件，并传递对应的目标框架索引
        self.window.advancedSettingsPushButton.clicked.connect(
            lambda: self.move_to_frame(0))
        self.window.basicSettingsPushButton.clicked.connect(
            lambda: self.move_to_frame(1))
        self.window.softwareInformationPushButton.clicked.connect(
            lambda: self.move_to_frame(2))
        # 连接动画组的 finished 信号
        self.animation_group.finished.connect(self.on_animation_finished)

        '''参数选项文字 动画'''
        # 连接按钮点击事件
        self.window.basicSettingsPushButton.clicked.connect(
            lambda: self.on_item_button_clicked("basic"))
        self.window.advancedSettingsPushButton.clicked.connect(
            lambda: self.on_item_button_clicked("advanced"))
        self.window.softwareInformationPushButton.clicked.connect(
            lambda: self.on_item_button_clicked("software"))
        # 保存按钮的默认 y 坐标
        self.button_default_y = 20  # 按钮的默认 y 坐标
        self.button_selected_y = 15  # 被选中按钮的 y 坐标（上移 5 像素）
        # 保存当前选中的按钮类型
        self.current_selected = None
        # 初始化动画列表
        self.item_animations = []
        # 初始化红线位置（假设初始选中 basicSettingsPushButton）
        self.on_item_button_clicked("basic")

        # 设置 YOLO置信度 滑动条
        self.window.confSlider.setMinimum(0)
        self.window.confSlider.setMaximum(100)

        # 连接滑动条信号
        self.window.confSlider.sliderPressed.connect(self.on_slider_pressed)
        self.window.confSlider.sliderMoved.connect(self.on_slider_moved)
        self.window.confSlider.sliderReleased.connect(self.on_slider_released)
        self.window.confSlider.valueChanged.connect(
            self.on_slider_value_changed)

        # 初始化滑动条发送定时器
        self.slider_update_timer = QTimer()
        self.slider_update_timer.setInterval(200)  # 设置200ms的间隔
        self.slider_update_timer.timeout.connect(self.send_update)

        # 初始化滑动条状态变量
        self.is_slider_pressed = False

        # 设置 lockspeedX 滑动条
        self.window.lockSpeedXHorizontalSlider.setMaximum(100)
        self.window.lockSpeedXHorizontalSlider.setMinimum(0)

        # 连接滑动条信号(lockspeedX)
        self.window.lockSpeedXHorizontalSlider.sliderPressed.connect(
            self.on_lockSpeedX_slider_pressed)
        self.window.lockSpeedXHorizontalSlider.sliderMoved.connect(
            self.on_lockSpeedX_slider_moved)
        self.window.lockSpeedXHorizontalSlider.sliderReleased.connect(
            self.on_lockSpeedX_slider_released)
        self.window.lockSpeedXHorizontalSlider.valueChanged.connect(
            self.on_lockSpeedX_slider_value_changed)

        # 初始化滑动条发送定时器(lockspeedX)
        self.slider_update_timer_lockSpeedX = QTimer()
        self.slider_update_timer_lockSpeedX.setInterval(200)  # 设置200ms的间隔
        self.slider_update_timer_lockSpeedX.timeout.connect(
            self.send_lockSpeedX_update)

        # 初始化滑动条状态变量(lockspeedX)
        self.is_slider_pressed_lockSpeedX = False

        # 设置 lockspeedY 滑动条
        self.window.lockSpeedYHorizontalSlider.setMaximum(100)
        self.window.lockSpeedYHorizontalSlider.setMinimum(0)

        # 连接滑动条信号(lockspeedY)
        self.window.lockSpeedYHorizontalSlider.sliderPressed.connect(
            self.on_lockSpeedY_slider_pressed)
        self.window.lockSpeedYHorizontalSlider.sliderMoved.connect(
            self.on_lockSpeedY_slider_moved)
        self.window.lockSpeedYHorizontalSlider.sliderReleased.connect(
            self.on_lockSpeedY_slider_released)
        self.window.lockSpeedYHorizontalSlider.valueChanged.connect(
            self.on_lockSpeedY_slider_value_changed)

        # 初始化滑动条发送定时器(lockspeedY)
        self.slider_update_timer_lockSpeedY = QTimer()
        self.slider_update_timer_lockSpeedY.setInterval(200)  # 设置200ms的间隔
        self.slider_update_timer_lockSpeedY.timeout.connect(
            self.send_lockSpeedY_update)

        # 初始化滑动条状态变量(lockspeedY)
        self.is_slider_pressed_lockSpeedY = False

        # 设置 jumpSuppression 滑动条
        self.window.jumpSuppressionVerticalSlider.setMaximum(50)
        self.window.jumpSuppressionVerticalSlider.setMinimum(0)

        # 连接滑动条信号(jumpSuppression)
        self.window.jumpSuppressionVerticalSlider.sliderPressed.connect(
            self.on_jumpSuppression_slider_pressed)
        self.window.jumpSuppressionVerticalSlider.sliderMoved.connect(
            self.on_jumpSuppression_slider_moved)
        self.window.jumpSuppressionVerticalSlider.sliderReleased.connect(
            self.on_jumpSuppression_slider_released)
        self.window.jumpSuppressionVerticalSlider.valueChanged.connect(
            self.on_jumpSuppression_slider_value_changed)

        # 初始化滑动条发送定时器(jumpSuppression)
        self.slider_update_timer_jumpSuppression = QTimer()
        self.slider_update_timer_jumpSuppression.setInterval(200)  # 设置200ms的间隔
        self.slider_update_timer_jumpSuppression.timeout.connect(
            self.send_jumpSuppression_update)

        # 初始化滑动条状态变量(jumpSuppression)
        self.is_slider_pressed_jumpSuppression = False

        # 初始化 aimRange 滑动条(aim_range)
        self.window.aimRangeHorizontalSlider.setMinimum(0)  # 滑块的实际范围是 0 到 280
        self.window.aimRangeHorizontalSlider.setMaximum(280)

        # 连接滑动条信号(aim_range)
        self.window.aimRangeHorizontalSlider.sliderPressed.connect(
            self.on_aimRange_slider_pressed)
        self.window.aimRangeHorizontalSlider.sliderMoved.connect(
            self.on_aimRange_slider_moved)
        self.window.aimRangeHorizontalSlider.sliderReleased.connect(
            self.on_aimRange_slider_released)
        self.window.aimRangeHorizontalSlider.valueChanged.connect(
            self.on_aimRange_slider_value_changed)

        # 初始化滑动条发送定时器(aim_range)
        self.aimRange_slider_update_timer = QTimer()
        self.aimRange_slider_update_timer.setInterval(200)  # 设置 200ms 的间隔
        self.aimRange_slider_update_timer.timeout.connect(
            self.send_aimRange_update)

        # 初始化滑动条状态变量(aim_range)
        self.is_aimRange_slider_pressed = False

        # 初始化 offset_centery 的定时器和标志位（offset_centery）
        self.offset_centery_slider_update_timer = QTimer()
        self.offset_centery_slider_update_timer.setInterval(200)  # 设置定时器间隔为200ms
        self.offset_centery_slider_update_timer.timeout.connect(self.send_offset_centery_update)
        self.is_offset_centery_slider_pressed = False  # 标志位，表示滑动条是否被按下
        # 初始化 offset_centery 值
        self.offset_centery = 0.0  # 根据需要设置初始值

        # 设置 offset_centeryVerticalSlider 滑动条（offset_centery）
        self.window.offset_centeryVerticalSlider.setMinimum(0)
        self.window.offset_centeryVerticalSlider.setMaximum(100)
        self.window.offset_centeryVerticalSlider.setSingleStep(1)
        self.window.offset_centeryVerticalSlider.setValue(
            int(self.offset_centery * 100))  # 初始化滑动条位置

        # 连接滑动条信号（offset_centery）
        self.window.offset_centeryVerticalSlider.sliderPressed.connect(
            self.on_offset_centery_slider_pressed)
        self.window.offset_centeryVerticalSlider.sliderMoved.connect(
            self.on_offset_centery_slider_moved)
        self.window.offset_centeryVerticalSlider.sliderReleased.connect(
            self.on_offset_centery_slider_released)
        self.window.offset_centeryVerticalSlider.valueChanged.connect(
            self.on_offset_centery_slider_value_changed)

        # 初始化 offset_centerx 的定时器和标志位（offset_centerx）
        self.offset_centerx_slider_update_timer = QTimer()
        self.offset_centerx_slider_update_timer.setInterval(200)  # 设置定时器间隔为200ms
        self.offset_centerx_slider_update_timer.timeout.connect(self.send_offset_centerx_update)
        self.is_offset_centerx_slider_pressed = False  # 标志位，表示滑动条是否被按下
        # 初始化 offset_centerx 值
        self.offset_centerx = 0.0  # 根据需要设置初始值

        # 设置 offset_centerxVerticalSlider 滑动条（offset_centerx）
        self.window.offset_centerxVerticalSlider.setMinimum(0)
        self.window.offset_centerxVerticalSlider.setMaximum(100)
        self.window.offset_centerxVerticalSlider.setSingleStep(1)
        self.window.offset_centerxVerticalSlider.setValue(
            int(self.offset_centerx * 100))  # 初始化滑动条位置

        # 连接滑动条信号（offset_centerx）
        self.window.offset_centerxVerticalSlider.sliderPressed.connect(
            self.on_offset_centerx_slider_pressed)
        self.window.offset_centerxVerticalSlider.sliderMoved.connect(
            self.on_offset_centerx_slider_moved)
        self.window.offset_centerxVerticalSlider.sliderReleased.connect(
            self.on_offset_centerx_slider_released)
        self.window.offset_centerxVerticalSlider.valueChanged.connect(
            self.on_offset_centerx_slider_value_changed)

        # 初始化 aimRange 滑动条(autoTiggerRangeSlider)
        self.automaticTriggerSetDialog.autoTiggerRangeSlider.setMinimum(0)  # 滑块的实际范围是 0 到 280
        self.automaticTriggerSetDialog.autoTiggerRangeSlider.setMaximum(1)

        # 连接滑动条信号(autoTiggerRangeSlider)
        self.automaticTriggerSetDialog.autoTiggerRangeSlider.sliderPressed.connect(
            self.on_autoTiggerRangeSlider_pressed)
        self.automaticTriggerSetDialog.autoTiggerRangeSlider.sliderMoved.connect(
            self.on_autoTiggerRangeSlider_moved)
        self.automaticTriggerSetDialog.autoTiggerRangeSlider.sliderReleased.connect(
            self.on_autoTiggerRangeSlider_released)
        self.automaticTriggerSetDialog.autoTiggerRangeSlider.valueChanged.connect(
            self.on_autoTiggerRangeSlider_value_changed)

        # 初始化滑动条发送定时器(autoTiggerRangeSlider)
        self.autoTiggerRangeSlider_update_timer = QTimer()
        self.autoTiggerRangeSlider_update_timer.setInterval(200)  # 设置定时器间隔为200ms
        self.autoTiggerRangeSlider_update_timer.timeout.connect(self.send_autoTiggerRangeSlider_update)

        # 初始化滑动条状态变量(autoTiggerRangeSlider)
        self.is_autoTiggerRangeSlider_slider_pressed = False  # 标志位，表示滑动条是否被按下
        # 初始化 autoTiggerRangeSlider 值
        self.autoTiggerRange = 0.5  # 根据需要设置初始值

        # 设置 autoTiggerRangeSlider 滑动条（autoTiggerRangeSlider）
        self.automaticTriggerSetDialog.autoTiggerRangeSlider.setMinimum(0)
        self.automaticTriggerSetDialog.autoTiggerRangeSlider.setMaximum(100)
        self.automaticTriggerSetDialog.autoTiggerRangeSlider.setSingleStep(1)
        self.automaticTriggerSetDialog.autoTiggerRangeSlider.setValue(
            int(self.autoTiggerRange * 100))  # 初始化滑动条位置


        # 初始化遮罩透明度效果
        self.window.overlay_opacity = QGraphicsOpacityEffect(
            self.window.overlay)
        self.window.overlay.setGraphicsEffect(self.window.overlay_opacity)
        self.window.overlay_animation = QPropertyAnimation(
            self.window.overlay_opacity, b"opacity")

        # 初始隐藏设置面板，并将其移动到屏幕左侧外
        self.window.settingsPanel.hide()
        self.window.settingsPanel.move(-self.window.settingsPanel.width(),
                                       self.window.settingsPanel.y())
        self.window.overlay.hide()
        self.window.overlay.setGeometry(
            0, 0, self.window.width(), self.window.height())

        # 初始化 AnimatedStatus，将 TestUI 实例作为窗口参数传递，指定Widget和Label名称
        self.window.status_widget = AnimatedStatus(window=self.window,
                                                   widget_name="statusDisplayWidget",
                                                   label_name="statusDisplayLabel")

        # 初始化视频状态
        self.is_video_running = False
        self.update_button_text()

        # 初始化 视频显示画面更新 定时器
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_video_frame)  # 每次超时调用更新函数
        self.timer.start(5)  # 约每30毫秒更新一次

        # 初始化 帧 计数
        self.fps = 0
        self.frame_count = 0
        self.start_time = time.time()
        self.fps_update_interval = 0.5  # 设置FPS更新间隔（秒）

        # 初始化 YOLO 处理状态
        self.is_yolo_running = False

        # 初始化视频状态
        self.video_running = False

        # 创建并应用遮罩到 show_video
        self.apply_rounded_mask_to_show_video()

    def show_automatic_trigger_set_dialog(self):
        """显示自动扳机设置窗口（模态）"""
        self.automaticTriggerSetDialog.exec()

    def hide_automatic_trigger_set_window(self):
        """隐藏自动扳机设置窗口"""
        self.automaticTriggerSetDialog.hide()

    def on_button_clicked(self, button):
        # 获取被点击的按钮文本并打印
        Effective_mode = button.text()
        logger.debug(f"选中的按钮文本是: {Effective_mode}")
        self.accessibilityProcessSignal_queue.put(("Effective_mode", Effective_mode))

    def on_mobileMode_changed(self, selected_mobileMode):
        """
        鼠标移动方式库选择
        当 mobileModeQComboBox 改变时调用。
        :param selected_mobileMode: 鼠标移动模式(0 = win32, 1 = 飞易来, 2 = KmBoxNet)
        """
        # 对照字典
        mobile_mode_dict = {
            0: "win32",
            1: "飞易来",
            2: "KmBoxNet",
            3: "Logitech",
            4: "mouse"
        }

        # 根据 selected_mobileMode 获取对应的鼠标移动方式
        selected_mode_name = mobile_mode_dict.get(selected_mobileMode, "未知模式")
        logger.debug(f"选择的鼠标移动方式: {selected_mode_name}")

        # 发送鼠标移动方式切换的信号
        self.mouseMoveProssesSignal_queue.put(("mouseMoveMode", selected_mode_name))
        self.accessibilityProcessSignal_queue.put(("mouseMoveMode", selected_mode_name))

    def on_trigger_method_changed(self, selected_method):
        """
        当 triggerMethodComboBox 的选中值发生变化时调用
        """
        # 选项到触发模式的映射
        method_to_mode = method_mode

        # 获取对应的触发模式
        trigger_mode = method_to_mode.get(
            selected_method, "press")  # 默认值为 "press"

        # 向队列发送触发模式更新信号
        self.mouseMoveProssesSignal_queue.put(
            ("trigger_mode_change", trigger_mode))
        logger.debug(f"触发模式切换为: {trigger_mode}")

    def on_trigger_hotkey_changed(self, text):
        """当 LableButton 被点击时调用"""

        # 获取键代码
        lockKey = keyboard.get_keyboard_event(text)
        lockKey_name = keyboard.get_key_name_vk(lockKey)
        if lockKey != "UNKNOWN":
            # 更新鼠标相关的按键
            self.lockKey = lockKey
            self.window.HotkeyPushButton.setText(lockKey_name)
            # 发送信息到 mouseMoveProssesSignal_queue
            self.mouseMoveProssesSignal_queue.put(("lock_key_change", lockKey))
            logger.debug(f"触发按键已更改为: {lockKey_name} (代码: {lockKey})")

    def on_sideButtonCheckBox_state_changed(self, state):
        # 判断复选框是否被选中
        is_checked = (state == 2)  # 检查是否是 PartiallyChecked 或 Checked
        if state == 0:
            is_checked = False  # 如果是 Unchecked，则为 False
        elif state == 1:
            is_checked = True  # 如果是 Checked，则为 True

        # 发送信号到 mouseMoveProssesSignal_queue
        self.mouseMoveProssesSignal_queue.put(
            ("mouse_Side_Button_Witch_change", is_checked))
        logger.debug(f"sideButtonCheckBox 状态变化: {is_checked}")

    def on_aimBotCheckBox_state_changed(self, state):
        """处理 aimBotCheckBox 状态变化的槽函数。"""
        # 判断复选框是否被选中
        is_checked = (state == 2)  # 检查是否是 PartiallyChecked 或 Checked
        if state == 0:
            is_checked = False  # 如果是 Unchecked，则为 False
        elif state == 1:
            is_checked = True  # 如果是 Checked，则为 True

        # 发送信号到 mouseMoveProssesSignal_queue
        self.mouseMoveProssesSignal_queue.put(
            ("aimbot_switch_change", is_checked))
        logger.debug(f"aimBotCheckBox 状态变化: {is_checked}")

    def on_detection_target_changed(self, selected_class):
        """
        当 detectionTargetComboBox 的选项改变时调用。

        参数:
        - selected_class: 选中的类别 (0, 1, 2, 或 "ALL")
        """
        logger.debug(f"选择的检测类别: {selected_class}")
        self.information_output_queue.put(
            ("UI_process_log", f"选择的检测类别: {selected_class}"))

        # 发送类别更改信号到 YOLO 处理进程
        self.YoloSignal_queue.put(("change_class", selected_class))

    """瞄准偏移X滑动条"""

    def on_offset_centerx_slider_value_changed(self, value):
        """当滑动条的值改变时调用"""
        value = 1 - (value / 50.0)  # 将滑动条值从 0-100 映射到 1 到 -1
        self.window.offset_centerxNumber.display(f"{value:.2f}")  # 更新显示，保留两位小数
        self.offset_centerx = value  # 更新 offset_centerx 值
        # 如果定时器未启动，启动定时器
        if not self.offset_centerx_slider_update_timer.isActive():
            self.offset_centerx_slider_update_timer.start()

    def on_offset_centerx_slider_pressed(self):
        """当用户开始拖动滑动条时调用"""
        self.is_offset_centerx_slider_pressed = True
        self.offset_centerx_slider_update_timer.start()  # 开始定时器

    def on_offset_centerx_slider_moved(self, value):
        """当滑动条被拖动时调用"""
        value = 1 - (value / 50.0)  # 将滑动条值从 0-100 映射到 1 到 -1
        self.window.offset_centerxNumber.display(f"{value:.2f}")  # 实时更新显示
        self.offset_centerx = value  # 更新 offset_centerx 值

    def on_offset_centerx_slider_released(self):
        """当用户释放滑动条时调用"""
        self.is_offset_centerx_slider_pressed = False
        # 定时器将在发送最后一次值后停止

    def send_offset_centerx_update(self):
        """每200ms发送一次最新的 offset_centerx 值"""
        self.mouseMoveProssesSignal_queue.put(
            ("offset_centerx_change", self.offset_centerx))
        logger.debug(f"定时发送 offset_centerx 更新信号: {self.offset_centerx}")
        if not self.is_offset_centerx_slider_pressed:
            # 用户已停止拖动滑动条，停止定时器
            self.offset_centerx_slider_update_timer.stop()

    """瞄准偏移Y滑动条"""

    def on_offset_centery_slider_value_changed(self, value):
        """当滑动条的值改变时调用"""
        value = value / 100.0  # 将值转换为 0 到 1 的浮点数
        self.window.offset_centeryNumber.display(f"{value:.2f}")  # 更新显示，保留两位小数
        self.offset_centery = value  # 更新 offset_centery 值

        # 如果定时器未启动，启动定时器
        if not self.offset_centery_slider_update_timer.isActive():
            self.offset_centery_slider_update_timer.start()

    def on_offset_centery_slider_pressed(self):
        """当用户开始拖动滑动条时调用"""
        self.is_offset_centery_slider_pressed = True
        self.offset_centery_slider_update_timer.start()  # 开始定时器

    def on_offset_centery_slider_moved(self, value):
        """当滑动条被拖动时调用"""
        value = value / 100.0
        self.window.offset_centeryNumber.display(f"{value:.2f}")  # 实时更新显示
        self.offset_centery = value  # 更新 offset_centery 值

    def on_offset_centery_slider_released(self):
        """当用户释放滑动条时调用"""
        self.is_offset_centery_slider_pressed = False
        # 定时器将在发送最后一次值后停止

    def send_offset_centery_update(self):
        """每200ms发送一次最新的 offset_centery 值"""
        self.mouseMoveProssesSignal_queue.put(
            ("offset_centery_change", self.offset_centery))
        logger.debug(f"定时发送 offset_centery 更新信号: {self.offset_centery}")
        if not self.is_offset_centery_slider_pressed:
            # 用户已停止拖动滑动条，停止定时器
            self.offset_centery_slider_update_timer.stop()

    """自动扳机范围比例"""
    def on_autoTiggerRangeSlider_value_changed(self, value):
        """当 autoTiggerRang 滑动条的值改变时调用"""
        value = value / 100
        self.automaticTriggerSetDialog.autoTiggerRangeNumber.display(f"{value:.2f}")
        self.autoTiggerRange = value  # 更新 aimRange 值
        # 如果定时器未启动，启动定时器
        if not self.autoTiggerRangeSlider_update_timer.isActive():
            self.autoTiggerRangeSlider_update_timer.start()

    def on_autoTiggerRangeSlider_pressed(self):
        """当用户开始拖动 autoTiggerRang 滑动条时调用"""
        self.is_autoTiggerRangeSlider_slider_pressed = True
        self.autoTiggerRangeSlider_update_timer.start()  # 开始定时器

    def on_autoTiggerRangeSlider_moved(self, value):
        """当 autoTiggerRang 滑动条被拖动时调用"""
        value = value / 100.0
        self.automaticTriggerSetDialog.autoTiggerRangeNumber.display(f"{value:.2f}")  # 实时更新显示
        self.autoTiggerRange = value  # 更新 offset_centery 值

    def on_autoTiggerRangeSlider_released(self):
        """当用户释放 autoTiggerRang 滑动条时调用"""
        self.is_autoTiggerRangeSlider_slider_pressed = False
        # 定时器将在发送最后一次值后停止

    def send_autoTiggerRangeSlider_update(self):
        """每 200ms 发送一次最新的 autoTiggerRang 值"""
        self.mouseMoveProssesSignal_queue.put(
            ("automatic_trigger_range_switching", self.autoTiggerRange))
        self.YoloSignal_queue.put(("autoTiggerRange_change", self.autoTiggerRange))
        logger.debug(f"定时发送 autoTiggerRange 更新信号: {self.autoTiggerRange}")
        if not self.is_autoTiggerRangeSlider_slider_pressed:
            # 用户已停止拖动滑动条，停止定时器
            self.autoTiggerRangeSlider_update_timer.stop()

    '''瞄准范围 滑动条'''

    def on_aimRange_slider_value_changed(self, value):
        """当 aimRange 滑动条的值改变时调用"""
        # 将滑块的值映射到 20-300 范围
        mapped_value = value
        self.window.aimRangeLcdNumber.display(mapped_value)
        self.aim_range = mapped_value  # 更新 aimRange 值
        # 如果定时器未启动，启动定时器
        if not self.aimRange_slider_update_timer.isActive():
            self.aimRange_slider_update_timer.start()

    def on_aimRange_slider_pressed(self):
        """当用户开始拖动 aimRange 滑动条时调用"""
        self.is_aimRange_slider_pressed = True
        self.aimRange_slider_update_timer.start()  # 开始定时器

    def on_aimRange_slider_moved(self, value):
        """当 aimRange 滑动条被拖动时调用"""
        # 将滑块的值映射到 20-300 范围
        mapped_value = 20 + value
        self.window.aimRangeLcdNumber.display(mapped_value)
        self.aim_range = mapped_value  # 更新 aimRange 值

    def on_aimRange_slider_released(self):
        """当用户释放 aimRange 滑动条时调用"""
        self.is_aimRange_slider_pressed = False
        # 定时器将在发送最后一次值后停止

    def send_aimRange_update(self):
        """每 200ms 发送一次最新的 aimRange 值"""
        self.mouseMoveProssesSignal_queue.put(
            ("aim_range_change", self.aim_range))
        self.YoloSignal_queue.put(("aim_range_change", self.aim_range))
        logger.debug(f"定时发送 aimRange 更新信号: {self.aim_range}")
        if not self.is_aimRange_slider_pressed:
            # 用户已停止拖动滑动条，停止定时器
            self.aimRange_slider_update_timer.stop()

    '''lockSpeed_x 滑动条'''

    def on_lockSpeedX_slider_value_changed(self, value):
        """当 lockSpeed_x 滑动条的值改变时调用"""
        value = value / 10  # 将值缩放到 [0, 10] 范围
        self.window.lockSpeedXLcdNumber.display(
            f"{value:.1f}")  # 在 LCD 上显示一位小数的值
        self.lock_speed_x = value  # 更新锁定速度
        # 如果定时器未启动，启动定时器
        if not self.slider_update_timer_lockSpeedX.isActive():
            self.slider_update_timer_lockSpeedX.start()

    def on_lockSpeedX_slider_pressed(self):
        """当用户开始拖动 lockSpeed_x 滑动条时调用"""
        self.is_slider_pressed_lockSpeedX = True
        self.slider_update_timer_lockSpeedX.start()  # 开始定时器

    def on_lockSpeedX_slider_moved(self, value):
        """当 lockSpeed 滑动条被拖动时调用"""
        value = value / 10  # 将值缩放到 [0, 10] 范围
        self.window.lockSpeedXLcdNumber.display(
            f"滑动条的值: {value:.1f}")  # 在 LCD 上显示实时的值
        self.lock_speed_x = value  # 更新锁定速度

    def on_lockSpeedX_slider_released(self):
        """当用户释放 lockSpeed 滑动条时调用"""
        self.is_slider_pressed_lockSpeedX = False
        # 定时器将在发送最后一次值后停止
        self.send_lockSpeedX_update()

    def send_lockSpeedX_update(self):
        """每200ms发送一次最新的 lockSpeed 值"""
        self.mouseMoveProssesSignal_queue.put(
            ("aim_speed_x_change", self.lock_speed_x))  # 发送锁定速度到队列
        logger.debug(f"定时发送锁定速度更新信号: {self.lock_speed_x}")
        if not self.is_slider_pressed_lockSpeedX:
            # 用户已停止拖动滑动条，停止定时器
            self.slider_update_timer_lockSpeedX.stop()

    '''lockSpeed_y 滑动条'''

    def on_lockSpeedY_slider_value_changed(self, value):
        """当 lockSpeed_y 滑动条的值改变时调用"""
        value = value / 10  # 将值缩放到 [0, 10] 范围
        self.window.lockSpeedYLcdNumber.display(
            f"{value:.1f}")  # 在 LCD 上显示一位小数的值
        self.lock_speed_y = value  # 更新锁定速度
        # 如果定时器未启动，启动定时器
        if not self.slider_update_timer_lockSpeedY.isActive():
            self.slider_update_timer_lockSpeedY.start()

    def on_lockSpeedY_slider_pressed(self):
        """当用户开始拖动 lockSpeed_y 滑动条时调用"""
        self.is_slider_pressed_lockSpeedY = True
        self.slider_update_timer_lockSpeedY.start()  # 开始定时器

    def on_lockSpeedY_slider_moved(self, value):
        """当 lockSpeed 滑动条被拖动时调用"""
        value = value / 10  # 将值缩放到 [0, 10] 范围
        self.window.lockSpeedYLcdNumber.display(
            f"滑动条的值: {value:.1f}")  # 在 LCD 上显示实时的值
        self.lock_speed_y = value  # 更新锁定速度

    def on_lockSpeedY_slider_released(self):
        """当用户释放 lockSpeed 滑动条时调用"""
        self.is_slider_pressed_lockSpeedY = False
        # 定时器将在发送最后一次值后停止
        self.send_lockSpeedY_update()

    def send_lockSpeedY_update(self):
        """每200ms发送一次最新的 lockSpeed 值"""
        self.mouseMoveProssesSignal_queue.put(
            ("aim_speed_y_change", self.lock_speed_y))  # 发送锁定速度到队列
        logger.debug(f"定时发送锁定速度更新信号: {self.lock_speed_y}")
        if not self.is_slider_pressed_lockSpeedY:
            # 用户已停止拖动滑动条，停止定时器
            self.slider_update_timer_lockSpeedY.stop()

    '''jumpSuppression 滑动条'''

    def on_jumpSuppression_slider_value_changed(self, value):
        """当 jumpSuppression 滑动条的值改变时调用"""
        self.window.jumpSuppressionNumber.display(
            f"{value}")  # 在 LCD 上显示一位小数的值
        self.jump_suppression_fluctuation_range = value  # 更新锁定速度
        # 如果定时器未启动，启动定时器
        if not self.slider_update_timer_jumpSuppression.isActive():
            self.slider_update_timer_jumpSuppression.start()

    def on_jumpSuppression_slider_pressed(self):
        """当用户开始拖动 jumpSuppression 滑动条时调用"""
        self.is_slider_pressed_jumpSuppression = True
        self.slider_update_timer_jumpSuppression.start()  # 开始定时器

    def on_jumpSuppression_slider_moved(self, value):
        """当 jumpSuppression 滑动条被拖动时调用"""
        self.window.jumpSuppressionNumber.display(
            f"滑动条的值: {value}")  # 在 LCD 上显示实时的值
        self.jump_suppression_fluctuation_range = value  # 更新锁定速度

    def on_jumpSuppression_slider_released(self):
        """当用户释放 jumpSuppression 滑动条时调用"""
        self.is_slider_pressed_jumpSuppression = False
        # 定时器将在发送最后一次值后停止
        self.send_jumpSuppression_update()

    def send_jumpSuppression_update(self):
        """每200ms发送一次最新的 jumpSuppression 值"""
        self.mouseMoveProssesSignal_queue.put(
            ("jump_suppression_fluctuation_range", self.jump_suppression_fluctuation_range))  # 发送锁定速度到队列
        logger.debug(f"定时发送跳变误差更新信号: {self.jump_suppression_fluctuation_range}")
        if not self.is_slider_pressed_jumpSuppression:
            # 用户已停止拖动滑动条，停止定时器
            self.slider_update_timer_jumpSuppression.stop()

    '''置信度滑动条'''

    def on_slider_value_changed(self, value):
        """当滑动条的值改变时调用"""
        value = value / 100
        self.window.confNumber.display(f"{value:.2f}")
        self.yolo_confidence = value  # 更新置信度值

        # 如果定时器未启动，启动定时器
        if not self.slider_update_timer.isActive():
            self.slider_update_timer.start()

    def on_slider_pressed(self):
        """当用户开始拖动滑动条时调用"""
        self.is_slider_pressed = True
        self.slider_update_timer.start()  # 开始定时器

    def on_slider_moved(self, value):
        """当滑动条被拖动时调用"""
        value = value / 100
        self.window.confNumber.display(f"滑动条的值: {value:.2f}")
        self.yolo_confidence = value  # 更新置信度值

    def on_slider_released(self):
        """当用户释放滑动条时调用"""
        self.is_slider_pressed = False
        # 定时器将在发送最后一次值后停止

    def send_update(self):
        """每200ms发送一次最新的置信度值"""
        self.YoloSignal_queue.put(("change_conf", self.yolo_confidence))
        logger.debug(f"定时发送 YOLO 置信度更新信号: {self.yolo_confidence}")

        if not self.is_slider_pressed:
            # 用户已停止拖动滑动条，停止定时器
            self.slider_update_timer.stop()

    def restart_application(self):
        """重启当前应用程序。"""
        # 显示警告对话框
        reply = QMessageBox.warning(
            self.window,
            "确认重启",
            "软件即将重启，未保存的参数将丢失，是否继续？",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        if reply == QMessageBox.StandardButton.Yes:
            # 用户选择了“是”，执行重启
            # 首先，清理资源并停止子进程
            self.clean_up()
            # 使用 os.execl 重启应用程序
            python = sys.executable
            os.execl(python, python, *sys.argv)

    def clean_up(self):
        """终止子进程并清理资源。"""
        # 终止进程
        if hasattr(self, 'process_signal_processing'):
            self.process_signal_processing.terminate()
            self.process_signal_processing.join()
        if hasattr(self, 'process_video_signal'):
            self.process_video_signal.terminate()
            self.process_video_signal.join()
        if hasattr(self, 'process_videoprocessing'):
            self.process_videoprocessing.terminate()
            self.process_videoprocessing.join()
        # 关闭共享内存
        if hasattr(self, 'shm_video'):
            self.shm_video.close()
            self.shm_video.unlink()
        # 关闭应用程序
        self.app.quit()

    def req_config(self):
        """单进程推理模式 手动请求推理参数(补丁)"""
        # 获取当前 detectionTargetComboBox 的选项
        current_target_class = self.window.detectionTargetComboBox.currentText()
        self.YoloSignal_queue.put(
            ("change_class", current_target_class))  # 检测目标
        self.YoloSignal_queue.put(("change_conf", self.yolo_confidence))  # 置信度
        self.YoloSignal_queue.put(("aim_range_change", self.aim_range))  # 瞄准范围

    def load_settings(self):
        """加载配置文件 settings.json"""
        try:
            self._extracted_from_load_settings_4()
        except Exception as e:
            logger.warn("配置文件读取失败:", e)
            self.information_output_queue.put(
                ("UI_process_log", f"配置文件读取失败: {e}"))
            self.ProcessMode = "single_process"  # 设置默认值

    # TODO Rename this here and in `load_settings`
    def _extracted_from_load_settings_4(self):
        logger.info("配置文件读取成功")
        self.information_output_queue.put(("UI_process_log", "配置文件读取成功"))

        '''读取参数'''
        # 获取 "ProcessMode" 的状态
        self.ProcessMode = Config.get("ProcessMode", "single_process")
        logger.debug("ProcessMode状态:", self.ProcessMode)
        self.allow_network = Config.get("allow_network", False)
        logger.debug("是否允许联网:", self.allow_network)
        self.information_output_queue.put(
            ("UI_process_log", f"ProcessMode状态: {self.ProcessMode}"))
        # 获取 "window_always_on_top" 的状态
        self.window_always_on_top = Config.get(
            "window_always_on_top", False)
        logger.debug("窗口置顶状态:", self.window_always_on_top)
        # 获取 "model_file" 模型文件的路径
        self.model_file = Config.get("model_file", "yolov8n.pt")
        logger.debug(f"读取模型文件路径: {self.model_file}")
        # 获取 YOLO 置信度设置
        yolo_confidence = Config.get('confidence', 0.5)  # 默认值为0.5
        self.yolo_confidence = yolo_confidence
        self.window.confSlider.setValue(
            int(yolo_confidence * 100))  # 将置信度转换为滑动条值
        logger.debug(f"读取保存的YOLO置信度: {yolo_confidence}")
        # 获取 瞄准速度x
        aim_speed_x = Config.get('aim_speed_x', 0.5)
        self.aim_speed_x = aim_speed_x
        self.window.lockSpeedXHorizontalSlider.setValue(int(aim_speed_x * 10))
        logger.debug(f"读取保存的瞄准速度X: {aim_speed_x}")
        # 获取 瞄准速度y
        aim_speed_y = Config.get('aim_speed_y', 0.5)
        self.aim_speed_y = aim_speed_y
        self.window.lockSpeedYHorizontalSlider.setValue(int(aim_speed_y * 10))
        logger.debug(f"读取保存的瞄准速度Y: {aim_speed_y}")
        # 获取 瞄准范围
        aim_range = Config.get('aim_range', 100)
        self.aim_range = aim_range
        self.window.aimRangeHorizontalSlider.setValue(int(aim_range))
        logger.debug(f"读取保存的瞄准范围: {aim_range}")
        # 获取 Aimbot 开启状态
        aimbot_switch = Config.get("aimBot", False)
        self.window.aimBotCheckBox.setChecked(aimbot_switch)
        self.mouseMoveProssesSignal_queue.put(
            ("aimbot_switch_change", aimbot_switch))
        logger.debug(f"读取自瞄状态: {aimbot_switch}")
        # 获取 侧键瞄准 开启状态
        mouse_Side_Button_Witch = Config.get(
            "mouse_Side_Button_Witch", False)
        self.window.sideButtonCheckBox.setChecked(mouse_Side_Button_Witch)
        self.mouseMoveProssesSignal_queue.put(
            ("mouse_Side_Button_Witch_change", mouse_Side_Button_Witch))
        logger.debug(f"读取侧键瞄准开启状态: {mouse_Side_Button_Witch}")
        # 获取 detectionTargetComboBox 的值
        target_class = Config.get('target_class', "ALL")
        logger.debug(f"读取保存的检测类别: {target_class}")
        self.window.detectionTargetComboBox.setCurrentText(target_class)
        self.YoloSignal_queue.put(("change_class", target_class))
        # 获取 Y轴偏移 值
        offset_centery = Config.get('offset_centery', 0.3)
        logger.debug(f"读取保存的Y轴偏移: {offset_centery}")
        self.offset_centery = offset_centery
        self.window.offset_centeryVerticalSlider.setValue(
            int(offset_centery * 100))
        # 获取 Y轴偏移 值
        offset_centerx = Config.get('offset_centerx', 0)
        logger.debug(f"读取保存的X轴偏移: {offset_centerx}")
        self.offset_centerx = offset_centerx
        # 映射公式：slider_value = (1 - offset_centerx) * 50
        slider_value = int((1 - offset_centerx) * 50)
        self.window.offset_centerxVerticalSlider.setValue(slider_value)
        # 获取 触发热键代码 值
        lockKey = Config.get('lockKey', "VK_LBUTTON")
        logger.debug(f"读取保存的触发热键: {lockKey}")
        self.window.HotkeyPushButton.setText(lockKey)
        key_code = keyboard.get_key_code_vk(lockKey)
        logger.debug(f"加载触发热键代码: {key_code}")
        self.mouseMoveProssesSignal_queue.put(("lock_key_change", key_code))
        # 获取 触发方式
        triggerType = (Config.get('triggerType', "press"))
        logger.debug(f"读取保存的触发方式: {triggerType}")
        self.window.triggerMethodComboBox.setCurrentText(triggerType)
        # 获取 游戏内X轴360度视角像素
        screen_pixels_for_360_degrees = Config.get(
            'screen_pixels_for_360_degrees', 1800)
        logger.debug(f"读取游戏内一周像素: {screen_pixels_for_360_degrees}")
        self.mouseMoveProssesSignal_queue.put(
            ("screen_pixels_for_360_degrees", screen_pixels_for_360_degrees))
        # 获取 游戏内Y轴180度视角像素
        screen_height_pixels = Config.get('screen_height_pixels', 900)
        logger.debug(f"读取游戏内一周像素: {screen_height_pixels}")
        self.mouseMoveProssesSignal_queue.put(
            ("screen_height_pixels", screen_height_pixels))
        # 获取 近点瞄准速率倍率
        near_speed_multiplier = Config.get('near_speed_multiplier', 2)
        logger.debug(f"读取近点瞄准速率倍率: {near_speed_multiplier}")
        self.mouseMoveProssesSignal_queue.put(
            ("near_speed_multiplier", near_speed_multiplier))
        # 获取 瞄准减速区域
        slow_zone_radius = Config.get("slow_zone_radius", 10)
        logger.debug(f"读取瞄准减速区域: {slow_zone_radius}")
        self.mouseMoveProssesSignal_queue.put(
            ("slow_zone_radius", slow_zone_radius))
        # 获取 跳变抑制开关
        jump_suppression_switch = Config.get("jump_suppression_switch", False)
        logger.debug(f"跳变抑制开关: {jump_suppression_switch}")
        self.window.jumpSuppressionCheckBox.setChecked(jump_suppression_switch)
        self.mouseMoveProssesSignal_queue.put(("jump_detection_switch", jump_suppression_switch))
        # 获取 跳变抑制误差
        jump_suppression_fluctuation_range = Config.get("jump_suppression_fluctuation_range", 10)
        logger.debug(f"跳变抑制误差: {jump_suppression_fluctuation_range}")
        self.window.jumpSuppressionVerticalSlider.setValue(jump_suppression_fluctuation_range)
        self.mouseMoveProssesSignal_queue.put(
            ("jump_suppression_fluctuation_range", jump_suppression_fluctuation_range))

    def save_settings(self):
        """保存当前设置到 settings.json 文件"""
        '''获取值'''
        # 获取当前 ProcessModeComboBox 的选项
        current_process_mode = self.choose_process_model_comboBox()
        # 获取当前 topWindowCheckBox 的状态
        current_window_on_top = self.window.topWindowCheckBox.isChecked()
        # 获取当前 jumpSuppressionCheckBox 的状态
        jump_suppression_switch = self.window.jumpSuppressionCheckBox.isChecked()
        # 获取当前 detectionTargetComboBox 的选项
        current_target_class = self.window.detectionTargetComboBox.currentText()
        # 获取当前 aimBotCheckBox 的选项
        aimbot_switch = self.window.aimBotCheckBox.isChecked()
        # 获取当前 sideButtonCheckBox 的选项
        mouse_Side_Button_Witch = self.window.sideButtonCheckBox.isChecked()
        # 获取当前 HotkeyName PushButton 的文字
        lockKey = self.window.HotkeyPushButton.text()
        # 获取当前 triggerMethodComboBox 的选项
        triggerType = self.window.triggerMethodComboBox.currentText()

        '''保存参数'''
        # 更新 settings 字典
        # 推理模式
        Config.update("ProcessMode", current_process_mode)
        # 窗口置顶状态
        Config.update("window_always_on_top", current_window_on_top)
        # 自瞄开启状态
        Config.update("aimBot", aimbot_switch)
        # 侧键瞄准开启状态
        Config.update("mouse_Side_Button_Witch", mouse_Side_Button_Witch)
        # 模型文件路径
        Config.update("model_file", self.model_file)
        # 置信度
        Config.update("confidence", self.yolo_confidence)
        # 锁定速度x
        Config.update("aim_speed_x", self.lock_speed_x)
        # 锁定速度y
        Config.update("aim_speed_y", self.lock_speed_y)
        # 瞄准范围
        Config.update("aim_range", self.aim_range)
        # 目标代码
        Config.update("target_class", current_target_class)
        # Y轴瞄准偏移
        Config.update("offset_centery", self.offset_centery)
        # X轴瞄准偏移
        Config.update("offset_centerx", self.offset_centerx)
        # 触发热键
        Config.update("lockKey", lockKey)
        # 触发方式
        Config.update("triggerType", triggerType)
        # 跳变抑制开关
        Config.update("jump_suppression_switch", jump_suppression_switch)
        # 跳变抑制误差
        Config.update("jump_suppression_fluctuation_range", self.jump_suppression_fluctuation_range)

        # 将 settings 保存到文件
        try:
            Config.save()
            logger.info("配置文件保存成功")
            self.information_output_queue.put(("UI_process_log", "配置文件保存成功"))
            self.window.status_widget.display_message("配置已保存", bg_color="#55ff00", text_color="black",
                                                      auto_hide=3000)
        except Exception as e:
            logger.error("配置文件保存失败:", e)
            self.information_output_queue.put(
                ("UI_process_log", f"配置文件保存失败: {e}"))
            self.window.status_widget.display_message("配置保存失败", bg_color="Red", text_color="white",
                                                      auto_hide=3000)

    def init_ui_from_settings(self):
        """根据配置文件初始化界面"""
        # 设置 ProcessModeComboBox 的当前选项
        if (
                self.ProcessMode == "single_process"
                or self.ProcessMode != "multi_process"
        ):
            self.window.ProcessModeComboBox.setCurrentText("单进程模式")
        else:
            self.window.ProcessModeComboBox.setCurrentText("多进程模式")
        # 设置 topWindowCheckBox 的状态
        self.window.topWindowCheckBox.setChecked(self.window_always_on_top)
        # 根据设置，更新窗口置顶状态
        self.update_window_on_top_state()

    def update_window_on_top_state(self):
        """根据复选框状态更新窗口的置顶状态"""
        if self.window.topWindowCheckBox.isChecked():
            self.window.setWindowFlag(Qt.WindowType.WindowStaysOnTopHint, True)
        else:
            self.window.setWindowFlag(
                Qt.WindowType.WindowStaysOnTopHint, False)
        self.window.show()  # 需要调用 show() 以应用窗口标志的更改

    def update_unlock_window_size(self):
        """根据复选框状态更新窗口大小锁定的状态"""
        if self.window.unlockWindowSizeCheckBox.isChecked():
            # 解锁窗口大小：允许调整
            self.window.setFixedSize(QSize())  # 移除固定大小限制
            self.window.setSizePolicy(
                QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
            self.window.setMinimumSize(300, 400)  # 设置合理的最小尺寸，视具体需求调整
            self.window.setMaximumSize(QSize(16777215, 16777215))  # 设置最大的尺寸限制
        else:
            # 锁定窗口大小：设置固定大小为当前尺寸
            self.window.setFixedSize(self.window.size())
            self.window.setSizePolicy(
                QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)

    def update_jum_suppression_state(self):
        """跳变抑制开关"""
        if self.window.jumpSuppressionCheckBox.isChecked():
            self.mouseMoveProssesSignal_queue.put(("jump_detection_switch", True))
        else:
            self.mouseMoveProssesSignal_queue.put(("jump_detection_switch", False))

    def update_automatic_trigger_state(self):
        """自动扳机开关"""
        if self.window.automatic_trigger_switchCheckBox.isChecked():
            self.accessibilityProcessSignal_queue.put(("automatic_trigger_switch", True))
        else:
            self.accessibilityProcessSignal_queue.put(("automatic_trigger_switch", False))

    def reset_window_size(self):
        """重置窗口大小为 (1290, 585)"""
        target_size = QSize(1290, 585)

        if self.window.unlockWindowSizeCheckBox.isChecked():
            # 如果窗口大小已解锁，直接调整窗口大小
            self.window.resize(target_size)
        else:
            # 如果窗口大小已锁定，设置固定大小为目标大小
            self.window.setFixedSize(target_size)

        # 如果需要在重置大小后更新大小策略，可以在这里进行
        if self.window.unlockWindowSizeCheckBox.isChecked():
            self.window.setSizePolicy(
                QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        else:
            self.window.setSizePolicy(
                QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)

    def choose_process_model_comboBox(self):
        """选择进程模式"""
        ProcessMode = self.window.ProcessModeComboBox.currentText()  # 获取当前选项文本
        return "multi_process" if ProcessMode == "多进程模式" else "single_process"

    def apply_rounded_mask_to_show_video(self):
        """对 show_video 应用带圆角的遮罩"""
        radius = 20  # 设置圆角半径
        width = self.window.show_video.width()
        height = self.window.show_video.height()

        # 创建带圆角的遮罩
        mask = QBitmap(width, height)
        mask.fill(Qt.GlobalColor.color0)  # 使用 GlobalColor 中的 color0
        painter = QPainter(mask)
        # 使用 RenderHint.Antialiasing
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        painter.setBrush(Qt.GlobalColor.color1)  # 使用 GlobalColor 中的 color1
        painter.drawRoundedRect(0, 0, width, height, radius, radius)
        painter.end()

        # 将遮罩应用到 show_video
        self.window.show_video.setMask(mask)

    def update_button_text(self):
        """更新按钮文本"""
        if self.is_video_running:
            self.window.OpVideoButton.setText("关闭视频预览")
        else:
            self.window.OpVideoButton.setText("打开视频预览")

    def update_video_frame(self):
        """更新视频帧到QLabel"""
        frame = None  # 初始化 frame 为 None
        if not self.processedVideo_queue.empty():
            # 清空队列，只保留最新的帧
            while not self.processedVideo_queue.empty():
                frame = self.processedVideo_queue.get()

        # 如果 frame 为空，直接返回以跳过更新
        if frame is None:
            # logger.debug("未接收到视频帧，跳过更新")
            return

        # 更新 FPS 计数
        self.frame_count += 1
        current_time = time.time()
        elapsed_time = current_time - self.start_time
        # 每 fps_update_interval 秒更新一次 FPS
        if elapsed_time >= self.fps_update_interval:
            self.fps = self.frame_count / elapsed_time  # 计算当前 FPS
            self.frame_count = 0
            self.start_time = current_time

        # 将 BGR 转换为 RGB 格式
        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        # 将帧转换为 QImage
        height, width, channel = frame.shape
        bytes_per_line = 3 * width
        q_img = QImage(frame.data, width, height,
                       bytes_per_line, QImage.Format.Format_RGB888)
        # 绘制 FPS
        cv2.putText(frame, f'FPS: {self.fps:.1f}', (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 0, 0), 2, cv2.LINE_AA)
        # 更新 QLabel，保持等比填充
        pixmap = QPixmap.fromImage(q_img)
        pixmap = pixmap.scaled(self.window.show_video.size(), aspectRatioMode=Qt.AspectRatioMode.KeepAspectRatio,
                               transformMode=Qt.TransformationMode.SmoothTransformation)

        self.window.show_video.setPixmap(pixmap)

    def toggle_YOLO_button(self):
        """切换 YOLO 处理状态并更新按钮文本"""
        if self.is_yolo_running:
            self._extracted_from_toggle_YOLO_button_5(
                'YOLO_stop', "开启 YOLO", False, "YOLO 处理已停止。"
            )
        else:
            # 开启 YOLO 处理
            self.req_config()  # 手动请求数据
            self._extracted_from_toggle_YOLO_button_5(
                'YOLO_start', "关闭 YOLO", True, "YOLO 处理已启动。"
            )

    # TODO Rename this here and in `toggle_YOLO_button`
    def _extracted_from_toggle_YOLO_button_5(self, arg0, arg1, arg2, arg3):
        # 停止 YOLO 处理
        self.YoloSignal_queue.put((arg0, None))
        self.window.OpYoloButton.setText(arg1)
        self.is_yolo_running = arg2
        logger.debug(arg3)

    def toggle_video_button(self):
        """切换视频状态并更新按钮文本"""
        # video_source = self.choose_process_model_comboBox()  # 通过选择器获取进程模式
        video_source = "screen"  # 视频源

        if self.is_video_running:
            logger.debug("关闭视频源:", video_source)
            self.window.OpVideoButton.setText("关闭视频显示中...")  # 更新按钮文本
            self.pipe_parent.send(('stop_video', video_source))  # 发送停止视频信号
            self.window.status_widget.display_message("预览已关闭", bg_color="Yellow", text_color="black",
                                                      auto_hide=1500)
            # 启动清理定时器
            if not hasattr(self, 'clear_timer'):
                self.clear_timer = QTimer()
                self.clear_timer.timeout.connect(self.clear_video_display)
            self.clear_timer.start(100)  # 每100毫秒清理一次
            self.is_video_running = False  # 更新状态
        else:
            logger.debug("启动视频源:", video_source)
            self.window.OpVideoButton.setText("打开视频显示中...")  # 更新按钮文本
            self.pipe_parent.send(("start_video", video_source))  # 发送启动视频信号
            self.window.status_widget.display_message("预览已开启", bg_color="#55ff00", text_color="black",
                                                      auto_hide=1500)
            # 停止清理定时器
            if hasattr(self, 'clear_timer'):
                self.clear_timer.stop()
                del self.clear_timer  # 删除定时器
            self.is_video_running = True  # 更新状态

        self.update_button_text()  # 更新按钮文本

    def hide_settings(self):
        """隐藏设置面板"""

        # 获取当前设置面板的位置
        start_pos = self.window.settingsPanel.pos()
        # 计算结束位置，使面板移出屏幕（左侧）
        end_pos = QPoint(-self.window.settingsPanel.width(), start_pos.y())

        # 创建一个属性动画，控制设置面板的位置
        self.window.animation = QPropertyAnimation(
            self.window.settingsPanel, b"pos")
        self.window.animation.setDuration(500)  # 动画持续时间为 500 毫秒
        self.window.animation.setStartValue(start_pos)  # 动画开始位置
        self.window.animation.setEndValue(end_pos)  # 动画结束位置
        self.window.animation.setEasingCurve(
            QEasingCurve.Type.InQuad)  # 设置动画效果为缓入

        # 启动面板位置动画
        self.window.animation.start()

        # 设置遮罩动画属性
        self.window.overlay_animation.setDuration(500)  # 遮罩动画持续时间为 500 毫秒
        self.window.overlay_animation.setStartValue(1)  # 遮罩的初始透明度
        self.window.overlay_animation.setEndValue(0)  # 遮罩的结束透明度（完全透明）
        self.window.overlay_animation.setEasingCurve(
            QEasingCurve.Type.InQuad)  # 设置动画效果为缓入

        # 启动遮罩透明度动画
        self.window.overlay_animation.start()

        # 在面板隐藏动画完成后，隐藏面板并使主窗口可用
        self.window.animation.finished.connect(self.window.settingsPanel.hide)
        self.window.animation.finished.connect(lambda: (
            self.window.settingsPanel.hide(),
            self.window.overlay.hide(),  # 隐藏遮罩
            self.window.setEnabled(True)  # 使主窗口重新可用
        ))

    def show_settings(self):
        """显示设置面板和半透明遮罩"""

        # 显示遮罩组件
        self.window.overlay.show()

        # 设置遮罩动画属性
        self.window.overlay_animation.setDuration(500)  # 遮罩动画持续时间为 500 毫秒
        self.window.overlay_animation.setStartValue(0)  # 遮罩的初始透明度（完全透明）
        self.window.overlay_animation.setEndValue(1)  # 遮罩的结束透明度（完全不透明）
        self.window.overlay_animation.setEasingCurve(
            QEasingCurve.Type.OutQuad)  # 设置动画效果为缓出

        # 启动遮罩透明度动画
        self.window.overlay_animation.start()

        # 设置允许鼠标事件通过遮罩
        self.window.overlay.setAttribute(
            Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        self.window.settingsPanel.setAttribute(
            Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)

        # 显示设置面板
        self.window.settingsPanel.show()

        # 获取当前设置面板的位置
        start_pos = self.window.settingsPanel.pos()
        # 计算结束位置，使面板从左侧进入屏幕
        end_pos = QPoint(0, start_pos.y())

        # 创建一个属性动画，控制设置面板的位置
        self.window.animation = QPropertyAnimation(
            self.window.settingsPanel, b"pos")
        self.window.animation.setDuration(500)  # 动画持续时间为 500 毫秒
        self.window.animation.setStartValue(start_pos)  # 动画开始位置
        self.window.animation.setEndValue(end_pos)  # 动画结束位置
        self.window.animation.setEasingCurve(
            QEasingCurve.Type.OutQuad)  # 设置动画效果为缓出

        # 启动面板位置动画
        self.window.animation.start()

    def disable_buttons(self):
        """禁用按钮，防止在动画进行时重复点击"""
        self.window.advancedSettingsPushButton.setEnabled(False)
        self.window.basicSettingsPushButton.setEnabled(False)
        self.window.softwareInformationPushButton.setEnabled(False)

    def enable_buttons(self):
        """启用按钮"""
        self.window.advancedSettingsPushButton.setEnabled(True)
        self.window.basicSettingsPushButton.setEnabled(True)
        self.window.softwareInformationPushButton.setEnabled(True)

    def on_animation_finished(self):
        """动画结束后的处理"""
        # 启用按钮
        self.enable_buttons()

    def move_to_frame(self, target_index):
        """根据目标框架索引移动框架，实现页面切换动画。"""
        if self.current_frame_index == target_index:
            return  # 如果点击的是当前显示的框架，则不执行

        duration = 500  # 动画持续时间，单位为毫秒
        frame_width = self.frames[0].width()  # 假设所有框架宽度相同

        # 禁用按钮，防止在动画过程中重复点击
        self.disable_buttons()

        # 如果有正在进行的动画，先停止并清理
        if hasattr(self, 'animation_group') and self.animation_group.state() == QParallelAnimationGroup.State.Running:
            self.animation_group.stop()

        # 创建新的动画组
        self.animation_group = QParallelAnimationGroup()

        # 计算偏移量（当前索引 - 目标索引） * 框架宽度
        offset = (self.current_frame_index - target_index) * frame_width

        # 为每个框架创建动画
        for frame in self.frames:
            start_pos = frame.pos()
            end_pos = QPoint(start_pos.x() + offset, start_pos.y())

            # 创建动画
            animation = QPropertyAnimation(frame, b"pos")
            animation.setDuration(duration)
            animation.setStartValue(start_pos)
            animation.setEndValue(end_pos)
            animation.setEasingCurve(QEasingCurve.Type.OutQuad)

            # 将动画添加到动画组
            self.animation_group.addAnimation(animation)

        # 连接动画组的 finished 信号
        self.animation_group.finished.connect(self.on_animation_finished)

        # 启动动画组
        self.animation_group.start()

        # 更新当前框架索引
        self.current_frame_index = target_index

    def on_item_button_clicked(self, button_type):
        """当 itemFrame 中的按钮被点击时调用"""

        # 清除之前的动画引用
        self.item_animations.clear()

        # 获取按钮和红线控件
        basic_button = self.window.basicSettingsPushButton
        advanced_button = self.window.advancedSettingsPushButton
        software_button = self.window.softwareInformationPushButton
        red_line = self.window.redLine

        # 创建一个字典，方便根据类型获取按钮
        buttons = {
            "basic": basic_button,
            "advanced": advanced_button,
            "software": software_button
        }

        # 获取目标按钮
        target_button = buttons.get(button_type)

        # 如果目标按钮与当前选中的按钮相同，则不执行任何操作
        if self.current_selected == button_type:
            return

        # 更新当前选中的按钮类型
        self.current_selected = button_type

        # 按钮列表
        all_buttons = [basic_button, advanced_button, software_button]

        # 动画持续时间
        duration = 200  # 可以根据需要调整

        # 移动红线到目标按钮下方
        red_line_animation = QPropertyAnimation(red_line, b"geometry")
        red_line_animation.setDuration(duration)
        red_line_animation.setStartValue(red_line.geometry())
        target_red_line_geometry = QRect(
            target_button.x(), red_line.y(), target_button.width(), red_line.height())
        self._extracted_from_on_item_button_clicked_59(
            red_line_animation, target_red_line_geometry
        )
        # 移动按钮位置
        for button in all_buttons:
            button_animation = QPropertyAnimation(button, b"geometry")
            button_animation.setDuration(duration)
            button_animation.setStartValue(button.geometry())

            if button == target_button:
                # 被选中的按钮上移 5 像素
                target_geometry = QRect(
                    button.x(), self.button_selected_y, button.width(), button.height())
            else:
                # 其他按钮回到默认 y 位置
                target_geometry = QRect(
                    button.x(), self.button_default_y, button.width(), button.height())

            self._extracted_from_on_item_button_clicked_59(
                button_animation, target_geometry
            )

    # TODO Rename this here and in `on_item_button_clicked`
    def _extracted_from_on_item_button_clicked_59(self, arg0, arg1):
        arg0.setEndValue(arg1)
        arg0.setEasingCurve(QEasingCurve.Type.OutQuad)
        arg0.start()
        self.item_animations.append(arg0)

    def clear_video_display(self):
        """清空视频显示窗口直到清空干净"""
        if self.window.show_video.pixmap():
            self.window.show_video.setPixmap(QPixmap())  # 清空显示窗口
        else:
            self.clear_timer.stop()  # 停止定时器

    def change_yolo_model(self):
        """重新加载模型"""
        logger.debug("重新加载模型")
        # 检查模型文件路径是否为空
        if not getattr(self, 'model_file', None):  # 如果 model_file 属性不存在或为空
            log_msg = "未选择模型文件，无法重新加载模型。"
            self.window.status_widget.display_message(
                log_msg, bg_color="Red", text_color="black", auto_hide=6000)
            return  # 退出方法，不执行后续操作

        # 如果此时 视频预览 在开启状态，则进行关闭。
        if self.is_video_running:
            self.toggle_video_button()
        # 如果此时 YOLO推理 在开启状态，则进行关闭。
        if self.is_yolo_running:
            self.toggle_YOLO_button()

        if self.ProcessMode == "multi_process":
            # 发送更改模型信号 与 模型路径(多进程)
            self.YoloSignal_queue.put(("change_model", self.model_file))
            self.information_output_queue.put(
                ("UI_process_log", "向 YoloSignal_queue 发送 change_model"))
        else:
            # 发送更改模型信号 与 模型路径(单进程)
            self.videoSignal_queue.put(("change_model", self.model_file))
            self.information_output_queue.put(
                ("UI_process_log", "向 videoSignal_queue 发送 change_model"))

        # 显示模型已重新加载的消息
        self.window.status_widget.display_message("模型已重新加载", bg_color="#55ff00", text_color="black",
                                                  auto_hide=1500)

    def choose_model(self):
        """弹出文件选择窗口，让用户选择模型文件"""
        model_file, _ = QFileDialog.getOpenFileName(
            self.window,  # 父窗口
            "选择模型文件",  # 对话框标题
            "",  # 默认打开的路径
            "模型文件 (*.pt *.engine *.onnx);;所有文件 (*.*)"  # 文件过滤器
        )
        if model_file:  # 如果用户选择了文件
            self.file_name = os.path.basename(model_file)  # 只提取文件名和后缀
            self.window.modelFileLabel.setText(self.file_name)  # 更新UI中的标签文本
            self.model_file = model_file  # 保存模型文件路径到类属性
            logger.debug(f"选择的模型文件: {self.file_name}")

    def show(self):
        """显示窗口"""
        self.window.show()

        self.show_loading_animation()  # 显示加载信息悬浮窗

        self.show_log_output()  # 开启 调试信息 输出监听

        # 更新 modelFileLabel 显示的模型名称
        file_name = os.path.basename(self.model_file)  # 只提取文件名和后缀
        self.window.modelFileLabel.setText(file_name)  # 更新UI中的标签文本

        # 发送最新 置信度
        self.YoloSignal_queue.put(("change_conf", self.yolo_confidence))

        self.information_output_queue.put(("UI_process_log", "UI主进程 初始化完毕"))

        sys.exit(self.app.exec())

    def show_loading_animation(self):
        # 提示加载信息框
        self.window.status_widget.show_status_widget(
            "加载中...", bg_color="Yellow", text_color="black")

        # 创建定时器，用来周期性地检查队列
        # 将 self.window 作为 QTimer 的父对象
        self.timer_check_queue = QTimer(self.window)
        self.timer_check_queue.timeout.connect(
            self.check_floating_information_signal_queue)
        self.timer_check_queue.start(500)  # 每100毫秒检查一次队列

    def check_floating_information_signal_queue(self):
        """检查 floating_information_signal_queue 是否有加载完毕的信号"""
        if not self.floating_information_signal_queue.empty():
            message = self.floating_information_signal_queue.get_nowait()  # 非阻塞地获取消息
            if message[0] == "loading_complete" and message[1] is True:
                logger.info("软件初始化完毕，停止检查队列")
                # 停止定时器检查队列
                # self.timer_check_queue.stop()
                # 更新UI或执行其他操作
                self.window.status_widget.display_message("加载完毕", bg_color="#55ff00", text_color="black",
                                                          auto_hide=3000)
            elif message[0] == "error_log":
                self.window.status_widget.display_message(message[1], bg_color="Yellow", text_color="black",
                                                          auto_hide=3000)
            elif message[0] == "red_error_log":
                self.window.status_widget.show_status_widget(
                    message[1], bg_color="Red", text_color="black")

    def show_log_output(self):
        """调试信息输出 计时循环"""
        logger.debug("调试信息输出 监听信号...")
        self.timer_check_information_output_queue = QTimer(self.window)
        self.timer_check_information_output_queue.timeout.connect(
            self.log_output)
        self.timer_check_information_output_queue.start(100)

    def log_output(self):
        """调试信息输出"""
        if self.information_output_queue.empty():
            return
        message = self.information_output_queue.get_nowait()
        logger.debug("information_output_queue 队列接收信息:", message)

        if message[0] == "UI_process_log":  # UI主进程 调试信息输出
            log_msg = message[1]

            if not isinstance(log_msg, str):
                log_msg = str(log_msg)

            self.window.log_output_00.append(f"[INFO]UI主进程 日志: {log_msg}")
            self.window.log_output_00.ensureCursorVisible()

        if message[0] == "log_output_main":  # 主通信进程 调试信息输出
            log_msg = message[1]  # 提取信息段

            # 确保 log_msg 是字符串类型
            if not isinstance(log_msg, str):
                log_msg = str(log_msg)  # 如果不是字符串类型，则转换为字符串

            self.window.log_output_01.append(
                f"[INFO]通信进程 收到信号: {log_msg}")  # 添加新的日志信息
            self.window.log_output_01.ensureCursorVisible()  # 确保光标可见

        if message[0] == "video_processing_log":  # 视频处理进程 调试信息输出
            log_msg = message[1]

            if not isinstance(log_msg, str):
                log_msg = str(log_msg)

            self.window.log_output_02.append(
                f"[INFO]视频处理进程 收到信号: {log_msg}")
            self.window.log_output_02.ensureCursorVisible()

        if message[0] == "video_signal_acquisition_log":  # 视频信号接收进程 调试信息输出
            log_msg = message[1]
            operate, signal_source = log_msg

            if not isinstance(log_msg, str):
                log_msg = str(log_msg)

            self.window.log_output_03.append(
                f"[INFO]动作: {operate}  信号源: {signal_source}")
            self.window.log_output_03.ensureCursorVisible()

        if message[0] == "error_log":  # 报错信息提示
            log_msg = message[1]

            if not isinstance(log_msg, str):
                log_msg = str(log_msg)

            self.window.status_widget.display_message(
                log_msg, bg_color="Red", text_color="black", auto_hide=6000)

    def main(self):
        """程序启动初始化"""
        '''创建管道与队列'''
        # 创建总管道，总信号传输，
        parent_conn, child_conn = Pipe()  # 总传输管道
        VideoSignal_queue = Queue()  # 视频状态信号队列
        videoSignal_stop_queue = Queue()  # 视频状态信号队列（停止）
        video_queue = Queue(maxsize=1)  # 源视频画面传输队列
        processedVideo_queue = Queue(maxsize=1)  # 处理后的视频画面传输队列
        YoloSignal_queue = Queue()  # YOLO控制管道
        floating_information_signal_queue = Queue()  # 悬浮信息窗通信队列
        information_output_queue = Queue()  # 调试信息输出独立额
        mouseMoveProssesSignal_queue = Queue()  # 鼠标移动进程通信队列
        accessibilityProcessSignal_queue = Queue(maxsize=1)  # 辅助功能进程通信队列

        # 保存父进程中的管道与队列引用
        self.pipe_parent = parent_conn  # 控制信号的管道(父)
        self.pipe_child = child_conn  # 控制信号的管道(子)
        self.videoSignal_queue = VideoSignal_queue  # 视频信号队列
        self.videoSignal_stop_queue = videoSignal_stop_queue  # 视频状态信号队列（停止）
        self.video_queue = video_queue  # 视频传输队列
        self.processedVideo_queue = processedVideo_queue  # 处理后的视频画面传输队列
        self.YoloSignal_queue = YoloSignal_queue  # YOLO控制队列
        self.floating_information_signal_queue = floating_information_signal_queue  # 悬浮信息窗通信队列
        self.information_output_queue = information_output_queue  # 调试信息输出队列
        self.mouseMoveProssesSignal_queue = mouseMoveProssesSignal_queue  # 鼠标移动进程通信队列
        self.accessibilityProcessSignal_queue = accessibilityProcessSignal_queue  # 辅助功能进程通信队列

        self.information_output_queue.put(("UI_process_log", "管道创建完毕"))

        self.load_settings()  # 加载配置文件
        self.init_ui_from_settings()  # 根据加载的配置文件设置界面初始状态

        '''创建共享内存，用于 Box 坐标传输'''
        box_shape = (1, 6)  # 修改为1行，每行6字段 (x1, y1, x2, y2, distance, unique_id)
        box_dtype = np.float32
        box_size = int(np.prod(box_shape) * np.dtype(box_dtype).itemsize)
        box_shm = shared_memory.SharedMemory(create=True, size=box_size)
        box_array = np.ndarray(box_shape, dtype=box_dtype, buffer=box_shm.buf)
        box_array.fill(0)  # 初始化为0

        '''创建共享内存，用于 video_queue'''
        frame_shape = (320, 320, 3)  # 根据您的实际帧尺寸
        frame_dtype = np.uint8  # 假设帧的数据类型为 uint8
        frame_size = int(np.prod(frame_shape) * np.dtype(frame_dtype).itemsize)
        shm_video = shared_memory.SharedMemory(create=True, size=frame_size)
        shm_video_name = shm_video.name  # 共享内存名称，用于在子进程中访问

        '''创建同步原语'''
        # 用于 Box 坐标同步
        box_data_event = Event()  # 用于通知Box数据可用
        box_lock = multiprocessing.Lock()  # 用于同步访问Box共享内存

        # 用于视频帧同步
        frame_available_event = Event()

        # 保存共享内存和事件的引用
        information_output_queue.put(
            ("UI_process_log", f"共享内存已创建，名称为 {shm_video_name}"))
        information_output_queue.put(
            ("UI_process_log", f"Box共享内存已创建，名称为 {box_shm.name}"))

        '''创建进程'''
        # 1.进程通信进程
        process_signal_processing = Process(target=communication_Process,
                                            args=(self.pipe_child, self.videoSignal_queue, self.videoSignal_stop_queue,
                                                  self.floating_information_signal_queue,
                                                  self.information_output_queue,))
        self._extracted_from_main_65(
            process_signal_processing, "process_signal_processing 进程创建完毕"
        )
        # 2.视频信号获取进程
        if self.ProcessMode == "multi_process":  # 多进程模式
            target_function = start_capture_process_multie
            args = (
                shm_video_name, frame_shape, frame_dtype,
                frame_available_event, self.videoSignal_queue,
                self.videoSignal_stop_queue, self.pipe_parent,
                self.information_output_queue, self.ProcessMode
            )
        elif self.ProcessMode == "single_process":  # 单进程模式
            target_function = start_capture_process_single
            args = (
                self.videoSignal_queue, self.videoSignal_stop_queue,
                self.information_output_queue,
                self.processedVideo_queue, self.YoloSignal_queue, self.pipe_parent, self.model_file,
                box_shm.name, box_data_event, box_lock, self.accessibilityProcessSignal_queue
            )
        else:
            raise ValueError(f"未知的 ProcessMode: {self.ProcessMode}")
        # 创建并启动进程
        process_video_signal = Process(target=target_function, args=args)
        self._extracted_from_main_65(process_video_signal, "process_video_signal 进程创建完毕")

        # 3.视频处理进程(仅在多进程时启动)
        if self.ProcessMode == "multi_process":
            process_videoprocessing = Process(target=video_processing,
                                              args=(shm_video_name, frame_shape, frame_dtype,
                                                    frame_available_event, processedVideo_queue,
                                                    YoloSignal_queue, parent_conn,
                                                    information_output_queue, self.model_file,
                                                    box_shm.name, box_data_event, box_lock,
                                                    accessibilityProcessSignal_queue))
            process_videoprocessing.daemon = True
            process_videoprocessing.start()
            information_output_queue.put(
                ("UI_process_log", "process_videoprocessing 进程创建完毕"))

        # 4.鼠标移动进程
        process_mouse_move = Process(target=mouse_move_prosses,
                                     args=(box_shm.name, box_lock, self.mouseMoveProssesSignal_queue,
                                           self.accessibilityProcessSignal_queue))
        self._extracted_from_main_65(process_mouse_move, "process_mouse_move 进程创建完毕")

        # 5.辅助功能进程
        process_accessibility = Process(target=accessibility_process, args=(self.accessibilityProcessSignal_queue,))
        self._extracted_from_main_65(process_accessibility, "process_accessibility 进程创建完毕")

        # 启动进程后，保存引用
        self.process_signal_processing = process_signal_processing
        self.process_video_signal = process_video_signal
        self.process_mouse_move = process_mouse_move

        '''显示软件页面'''
        self.show()  # 初始化完毕 显示 UI窗口

    # TODO Rename this here and in `main`
    def _extracted_from_main_65(self, arg0, arg1):
        arg0.daemon = True
        arg0.start()
        self.information_output_queue.put(("UI_process_log", arg1))


if __name__ == '__main__':
    multiprocessing.freeze_support()
    app = RookieAiAPP()
    app.main()

```

`Tools/PT_to_TRT.py`:

```py
"""
本脚本使用ultralytics官方的YOLOv8 pt模型转换为TRT模型方案
修改原"yolov8n.pt"部分为需要转换的pt模型文件绝对路径，随后运行代码自动进行转换。
"""

from ultralytics import YOLO

# Load a model
model = YOLO("yolov8n.pt")  # load a custom trained model

# Export the model
model.export(format="engine", workspace=8.0, half=True)

```

`Tools/cuDNN_download_V9.3_12.6.bat`:

```bat
::该脚本由 @Passer1072 提供，如有问题请联系作者。

@echo off

:: Check if running as administrator
net session >nul 2>&1
if %errorLevel% NEQ 0 (
    echo [ERROR] Please run as administrator
    pause
    exit /B
)

set CUDA_VERSION=11.8
set CUDNN_VERSION=12.6
set CUDNN_URL=https://mqz0sa.ph.files.1drv.com/y4m7PpXEdYxNetKZbn4_pUslQ6agOXncF16GLDNKgRzvtOhjT0OsgXwAbwgNtGiKaQ3RyZWWx14A910BwWWDRLsGqxsArWT0Zcd-yUEzitrDzLxIyEHH1joDIUXQGFBE4qnYAWF6L8B7vtLvOll1TgAm7CD1SPyfoq7VtiEMbm_ubKEnyKnETDSv-e-qjzmUBBWx6F-4TX7z-a7kg67xlRAdw
set CUDNN_EXE=%TEMP%\cudnn_installer.exe

echo Downloading cuDNN installer with progress bar...

powershell -Command "& { $ProgressPreference = 'Continue'; $webclient = New-Object System.Net.WebClient; $webclient.Headers.Add('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3');$webclient.DownloadFile('%CUDNN_URL%', '%CUDNN_EXE%'); Write-Host 'Download complete.'; }"

echo Running cuDNN installer...
start /wait %CUDNN_EXE%

echo cuDNN installation complete. Copying cuDNN files...
xcopy /s /y "%SystemDrive%\Program Files\NVIDIA\CUDNN\v9.3\bin\%CUDNN_VERSION%\*" "%SystemDrive%\Program Files\NVIDIA\CUDNN\v9.3\bin\"

echo Cleaning up downloaded installer...
del %CUDNN_EXE%

echo All tasks completed.
pause


```

`Tools/launcher.py`:

```py
import sys
import asyncio
from PySide6.QtCore import QCoreApplication, QMetaObject, QRect, QSize, Qt
from PySide6.QtWidgets import (
    QApplication,
    QCheckBox,
    QMainWindow,
    QProgressBar,
    QPushButton,
    QTextBrowser,
    QWidget,
)


class LauncherAPP(object):
    def setupUi(self, MainWindow):
        if not MainWindow.objectName():
            MainWindow.setObjectName("MainWindow")
        MainWindow.resize(382, 283)
        MainWindow.setMaximumSize(QSize(382, 283))
        self.centralwidget = QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.checkBox = QCheckBox(self.centralwidget)
        self.checkBox.setObjectName("checkBox")
        self.checkBox.setGeometry(QRect(296, 10, 86, 19))
        self.checkBox.setChecked(True)
        self.textBrowser = QTextBrowser(self.centralwidget)
        self.textBrowser.setObjectName("textBrowser")
        self.textBrowser.setGeometry(QRect(0, 74, 382, 208))
        self.textBrowser.setMinimumSize(QSize(0, 200))
        self.progressBar = QProgressBar(self.centralwidget)
        self.progressBar.setObjectName("progressBar")
        self.progressBar.setGeometry(QRect(0, 46, 382, 22))
        self.progressBar.setMaximum(100)
        self.progressBar.setValue(0)
        self.progressBar.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.pushButton = QPushButton(self.centralwidget)
        self.pushButton.setObjectName("pushButton")
        self.pushButton.setGeometry(QRect(0, 0, 100, 40))
        self.pushButton.setMinimumSize(QSize(100, 40))
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)

        QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        MainWindow.setWindowTitle(
            QCoreApplication.translate("MainWindow", "MainWindow", None)
        )
        self.checkBox.setText(
            QCoreApplication.translate(
                "MainWindow", "\u4f7f\u7528\u955c\u50cf\u6e90", None
            )
        )
        self.pushButton.setText(
            QCoreApplication.translate("MainWindow", "\u4e00\u952e\u5b89\u88c5", None)
        )


class InstallationError(Exception):
    pass


async def install_requirements(launcher_app):
    import asyncio

    if launcher_app.checkBox.isChecked():
        process = await asyncio.create_subprocess_exec(
            "pip",
            "install",
            "-r",
            "requirements.txt",
            "-i",
            "https://pypi.doubanio.com/simple/",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
    else:
        process = await asyncio.create_subprocess_exec(
            "pip",
            "install",
            "-r",
            "requirements.txt",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )

    stdout, stderr = await process.communicate()

    if process.returncode != 0:
        error_message = stderr.decode().strip() if stderr else "未知错误"
        raise InstallationError(f"(code: {process.returncode})\n\t{error_message}")


async def start_app(launcher_app):
    import subprocess

    subprocess.Popen(["python", "RookieAI.py"])


async def install_torch(launcher_app):
    import asyncio

    if launcher_app.checkBox.isChecked():
        process = await asyncio.create_subprocess_exec(
            "pip",
            "install",
            "torch",
            "torchvision",
            "torchaudio",
            "-f",
            "https://mirror.sjtu.edu.cn/pytorch-wheels/torch_stable.html",
            "--no-index",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
    else:
        process = await asyncio.create_subprocess_exec(
            "pip",
            "install",
            "torch",
            "torchvision",
            "torchaudio",
            "-f",
            "https://download.pytorch.org/whl/torch_stable.html",
            "--no-index",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )

    stdout, stderr = await process.communicate()

    if process.returncode != 0:
        error_message = stderr.decode().strip() if stderr else "未知错误"
        raise InstallationError(f"(code: {process.returncode})\n\t{error_message}")


def update_progress(launcher_app, step_increment):
    launcher_app.progressBar.setValue(
        min(launcher_app.progressBar.value() + step_increment, 100)
    )


async def exec_install_async(launcher_app):
    launcher_app.textBrowser.clear()
    launcher_app.textBrowser.append(f"RookieAI v{VERSION} 安装程序\n")
    launcher_app.progressBar.setValue(0)
    launcher_app.pushButton.setEnabled(False)
    launcher_app.textBrowser.append("开始执行安装操作...\n")

    total_steps = 100
    increment_fast = 40  # 快速增加的步长
    increment_slow = 40  # 慢速增加的步长

    try:
        launcher_app.textBrowser.append("正在安装requirements.txt\n")
        await install_requirements(launcher_app)
        update_progress(launcher_app, increment_fast)
        launcher_app.textBrowser.append("安装requirements.txt完成\n")

        launcher_app.textBrowser.append("正在安装torch torchvision torchaudio\n")
        await install_torch(launcher_app)
        update_progress(launcher_app, increment_slow)
        launcher_app.textBrowser.append("安装torch torchvision torchaudio完成。\n")

        launcher_app.textBrowser.append("依赖已全部安装，准备启动主程序\n")
        launcher_app.progressBar.setValue(total_steps)
        await start_app(launcher_app)

    except Exception as e:
        launcher_app.textBrowser.append(f"安装过程中发生错误: {e}\n")
    finally:
        launcher_app.progressBar.setValue(0)
        launcher_app.pushButton.setEnabled(True)


def exec_install(launcher_app):
    asyncio.run(exec_install_async(launcher_app))


VERSION = "0.1.0"

if __name__ == "__main__":
    app = QApplication(sys.argv)
    main_window = QMainWindow()
    launcher_app = LauncherAPP()
    launcher_app.setupUi(main_window)
    launcher_app.pushButton.clicked.connect(lambda: exec_install(launcher_app))
    main_window.show()
    sys.exit(app.exec())

```

`UI/RookieAiWindow.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="enabled">
   <bool>true</bool>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1693</width>
    <height>615</height>
   </rect>
  </property>
  <property name="cursor">
   <cursorShape>ArrowCursor</cursorShape>
  </property>
  <property name="acceptDrops">
   <bool>false</bool>
  </property>
  <property name="windowTitle">
   <string>MainWindow</string>
  </property>
  <property name="whatsThis">
   <string>简化窗口</string>
  </property>
  <property name="styleSheet">
   <string notr="true"/>
  </property>
  <property name="animated">
   <bool>false</bool>
  </property>
  <widget class="QWidget" name="centralwidget">
   <property name="sizePolicy">
    <sizepolicy hsizetype="Ignored" vsizetype="Ignored">
     <horstretch>0</horstretch>
     <verstretch>0</verstretch>
    </sizepolicy>
   </property>
   <widget class="QLabel" name="show_video">
    <property name="geometry">
     <rect>
      <x>10</x>
      <y>10</y>
      <width>511</width>
      <height>511</height>
     </rect>
    </property>
    <property name="font">
     <font>
      <family>Microsoft YaHei</family>
     </font>
    </property>
    <property name="cursor">
     <cursorShape>ArrowCursor</cursorShape>
    </property>
    <property name="styleSheet">
     <string notr="true">

QFrame {
	background-color: rgb(63, 63, 63);
    border-radius: 20px;
    /* overflow: hidden;  确保内容不会溢出圆角边界 */
}</string>
    </property>
    <property name="frameShape">
     <enum>QFrame::Shape::Box</enum>
    </property>
    <property name="frameShadow">
     <enum>QFrame::Shadow::Raised</enum>
    </property>
    <property name="lineWidth">
     <number>3</number>
    </property>
    <property name="text">
     <string>预览已关闭</string>
    </property>
    <property name="alignment">
     <set>Qt::AlignmentFlag::AlignCenter</set>
    </property>
   </widget>
   <widget class="QPushButton" name="OpVideoButton">
    <property name="geometry">
     <rect>
      <x>540</x>
      <y>530</y>
      <width>141</width>
      <height>51</height>
     </rect>
    </property>
    <property name="font">
     <font>
      <family>Microsoft YaHei</family>
      <pointsize>12</pointsize>
     </font>
    </property>
    <property name="cursor">
     <cursorShape>PointingHandCursor</cursorShape>
    </property>
    <property name="text">
     <string>打开视频预览</string>
    </property>
   </widget>
   <widget class="QPushButton" name="OpYoloButton">
    <property name="geometry">
     <rect>
      <x>690</x>
      <y>530</y>
      <width>141</width>
      <height>51</height>
     </rect>
    </property>
    <property name="font">
     <font>
      <family>Microsoft YaHei</family>
      <pointsize>12</pointsize>
     </font>
    </property>
    <property name="cursor">
     <cursorShape>PointingHandCursor</cursorShape>
    </property>
    <property name="text">
     <string>开启 YOLO</string>
    </property>
   </widget>
   <widget class="QPushButton" name="settingsYoloButton">
    <property name="geometry">
     <rect>
      <x>840</x>
      <y>530</y>
      <width>51</width>
      <height>51</height>
     </rect>
    </property>
    <property name="cursor">
     <cursorShape>PointingHandCursor</cursorShape>
    </property>
    <property name="whatsThis">
     <string>设置面板</string>
    </property>
    <property name="text">
     <string/>
    </property>
    <property name="icon">
     <iconset>
      <normaloff>ico/gear-modified.png</normaloff>ico/gear-modified.png</iconset>
    </property>
    <property name="iconSize">
     <size>
      <width>32</width>
      <height>32</height>
     </size>
    </property>
    <property name="autoRepeatDelay">
     <number>300</number>
    </property>
   </widget>
   <widget class="QWidget" name="settingsPanel" native="true">
    <property name="geometry">
     <rect>
      <x>1320</x>
      <y>0</y>
      <width>381</width>
      <height>621</height>
     </rect>
    </property>
    <property name="font">
     <font>
      <family>Microsoft YaHei</family>
      <pointsize>12</pointsize>
     </font>
    </property>
    <property name="contextMenuPolicy">
     <enum>Qt::ContextMenuPolicy::NoContextMenu</enum>
    </property>
    <property name="styleSheet">
     <string notr="true">background-color: rgb(70, 70, 70);</string>
    </property>
    <widget class="QLabel" name="label">
     <property name="geometry">
      <rect>
       <x>100</x>
       <y>30</y>
       <width>171</width>
       <height>31</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>微软雅黑</family>
       <pointsize>18</pointsize>
      </font>
     </property>
     <property name="text">
      <string>模型设置面板</string>
     </property>
     <property name="alignment">
      <set>Qt::AlignmentFlag::AlignCenter</set>
     </property>
    </widget>
    <widget class="QLabel" name="label_7">
     <property name="geometry">
      <rect>
       <x>10</x>
       <y>320</y>
       <width>101</width>
       <height>21</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
       <pointsize>12</pointsize>
      </font>
     </property>
     <property name="text">
      <string>YOLO置信度:</string>
     </property>
    </widget>
    <widget class="QSlider" name="confSlider">
     <property name="geometry">
      <rect>
       <x>120</x>
       <y>320</y>
       <width>160</width>
       <height>18</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei UI</family>
       <pointsize>12</pointsize>
      </font>
     </property>
     <property name="maximum">
      <number>100</number>
     </property>
     <property name="orientation">
      <enum>Qt::Orientation::Horizontal</enum>
     </property>
    </widget>
    <widget class="QLCDNumber" name="confNumber">
     <property name="geometry">
      <rect>
       <x>290</x>
       <y>320</y>
       <width>61</width>
       <height>23</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei UI</family>
       <pointsize>12</pointsize>
      </font>
     </property>
     <property name="styleSheet">
      <string notr="true"/>
     </property>
     <property name="frameShape">
      <enum>QFrame::Shape::Box</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Shadow::Plain</enum>
     </property>
     <property name="lineWidth">
      <number>1</number>
     </property>
     <property name="digitCount">
      <number>5</number>
     </property>
     <property name="segmentStyle">
      <enum>QLCDNumber::SegmentStyle::Flat</enum>
     </property>
    </widget>
    <widget class="QPushButton" name="closeYoloSettingsButton">
     <property name="geometry">
      <rect>
       <x>320</x>
       <y>10</y>
       <width>41</width>
       <height>41</height>
      </rect>
     </property>
     <property name="cursor">
      <cursorShape>PointingHandCursor</cursorShape>
     </property>
     <property name="styleSheet">
      <string notr="true">background-color: rgb(0, 0, 0);</string>
     </property>
     <property name="text">
      <string/>
     </property>
     <property name="icon">
      <iconset>
       <normaloff>ico/close-modified.png</normaloff>ico/close-modified.png</iconset>
     </property>
     <property name="iconSize">
      <size>
       <width>28</width>
       <height>28</height>
      </size>
     </property>
    </widget>
    <widget class="QLabel" name="label_9">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="geometry">
      <rect>
       <x>10</x>
       <y>360</y>
       <width>91</width>
       <height>31</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
       <pointsize>12</pointsize>
      </font>
     </property>
     <property name="text">
      <string>YOLO锁帧:</string>
     </property>
    </widget>
    <widget class="QSpinBox" name="yoloFpsSetSpinBox">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="geometry">
      <rect>
       <x>120</x>
       <y>360</y>
       <width>101</width>
       <height>31</height>
      </rect>
     </property>
     <property name="alignment">
      <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
     </property>
    </widget>
    <widget class="QLabel" name="label_10">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="geometry">
      <rect>
       <x>230</x>
       <y>365</y>
       <width>31</width>
       <height>21</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei UI</family>
       <pointsize>12</pointsize>
      </font>
     </property>
     <property name="text">
      <string>FPS</string>
     </property>
    </widget>
    <widget class="QPushButton" name="RestartButton">
     <property name="geometry">
      <rect>
       <x>60</x>
       <y>540</y>
       <width>111</width>
       <height>41</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei UI</family>
       <pointsize>14</pointsize>
      </font>
     </property>
     <property name="text">
      <string>RESTART</string>
     </property>
    </widget>
    <widget class="QPushButton" name="saveButton">
     <property name="geometry">
      <rect>
       <x>210</x>
       <y>540</y>
       <width>111</width>
       <height>41</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei UI</family>
       <pointsize>14</pointsize>
      </font>
     </property>
     <property name="text">
      <string>SAVE</string>
     </property>
    </widget>
    <widget class="QLabel" name="label_11">
     <property name="geometry">
      <rect>
       <x>10</x>
       <y>280</y>
       <width>101</width>
       <height>21</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
       <pointsize>12</pointsize>
      </font>
     </property>
     <property name="text">
      <string>YOLO模型:</string>
     </property>
    </widget>
    <widget class="QLabel" name="modelFileLabel">
     <property name="geometry">
      <rect>
       <x>120</x>
       <y>280</y>
       <width>161</width>
       <height>21</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Cascadia Mono</family>
       <pointsize>9</pointsize>
      </font>
     </property>
     <property name="frameShape">
      <enum>QFrame::Shape::Box</enum>
     </property>
     <property name="text">
      <string>暂未选择文件</string>
     </property>
    </widget>
    <widget class="QPushButton" name="chooseModelButton">
     <property name="geometry">
      <rect>
       <x>290</x>
       <y>275</y>
       <width>61</width>
       <height>31</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
       <pointsize>10</pointsize>
      </font>
     </property>
     <property name="text">
      <string>选择</string>
     </property>
    </widget>
    <widget class="QLabel" name="label_17">
     <property name="geometry">
      <rect>
       <x>0</x>
       <y>230</y>
       <width>371</width>
       <height>31</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>微软雅黑</family>
       <pointsize>9</pointsize>
      </font>
     </property>
     <property name="text">
      <string>———————————YOLO设置———————————</string>
     </property>
     <property name="alignment">
      <set>Qt::AlignmentFlag::AlignCenter</set>
     </property>
    </widget>
    <widget class="QLabel" name="label_18">
     <property name="geometry">
      <rect>
       <x>10</x>
       <y>400</y>
       <width>101</width>
       <height>31</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
       <pointsize>12</pointsize>
      </font>
     </property>
     <property name="text">
      <string>推理进程模式:</string>
     </property>
    </widget>
    <widget class="QComboBox" name="ProcessModeComboBox">
     <property name="geometry">
      <rect>
       <x>120</x>
       <y>401</y>
       <width>111</width>
       <height>31</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
       <pointsize>12</pointsize>
      </font>
     </property>
     <item>
      <property name="text">
       <string>单进程模式</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>多进程模式</string>
      </property>
     </item>
    </widget>
    <widget class="QLabel" name="label_19">
     <property name="geometry">
      <rect>
       <x>0</x>
       <y>70</y>
       <width>371</width>
       <height>31</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>微软雅黑</family>
       <pointsize>9</pointsize>
      </font>
     </property>
     <property name="text">
      <string>———————————软件设置———————————</string>
     </property>
     <property name="alignment">
      <set>Qt::AlignmentFlag::AlignCenter</set>
     </property>
    </widget>
    <widget class="QCheckBox" name="topWindowCheckBox">
     <property name="geometry">
      <rect>
       <x>15</x>
       <y>110</y>
       <width>91</width>
       <height>21</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
       <pointsize>12</pointsize>
      </font>
     </property>
     <property name="text">
      <string>窗口置顶</string>
     </property>
    </widget>
    <widget class="QLabel" name="label_8">
     <property name="geometry">
      <rect>
       <x>240</x>
       <y>407</y>
       <width>21</width>
       <height>21</height>
      </rect>
     </property>
     <property name="sizePolicy">
      <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="toolTip">
      <string>保存后重启生效</string>
     </property>
     <property name="text">
      <string/>
     </property>
     <property name="pixmap">
      <pixmap>ico/warningtriangle_87535-modified.png</pixmap>
     </property>
     <property name="scaledContents">
      <bool>true</bool>
     </property>
    </widget>
    <widget class="QPushButton" name="reloadModelButton">
     <property name="geometry">
      <rect>
       <x>350</x>
       <y>275</y>
       <width>31</width>
       <height>31</height>
      </rect>
     </property>
     <property name="toolTip">
      <string>立即重新加载模型</string>
     </property>
     <property name="text">
      <string/>
     </property>
     <property name="icon">
      <iconset>
       <normaloff>ico/restartr-modified.png</normaloff>ico/restartr-modified.png</iconset>
     </property>
    </widget>
    <widget class="QCheckBox" name="topWindowCheckBox_2">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="geometry">
      <rect>
       <x>130</x>
       <y>110</y>
       <width>101</width>
       <height>21</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
       <pointsize>12</pointsize>
      </font>
     </property>
     <property name="text">
      <string>随机窗口名</string>
     </property>
    </widget>
    <widget class="QCheckBox" name="checkBox_2">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="geometry">
      <rect>
       <x>290</x>
       <y>370</y>
       <width>78</width>
       <height>19</height>
      </rect>
     </property>
     <property name="text">
      <string>无上限</string>
     </property>
    </widget>
    <widget class="QCheckBox" name="unlockWindowSizeCheckBox">
     <property name="enabled">
      <bool>true</bool>
     </property>
     <property name="geometry">
      <rect>
       <x>15</x>
       <y>150</y>
       <width>121</width>
       <height>21</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
       <pointsize>12</pointsize>
      </font>
     </property>
     <property name="text">
      <string>解锁窗口大小</string>
     </property>
    </widget>
    <widget class="QLabel" name="label_28">
     <property name="geometry">
      <rect>
       <x>170</x>
       <y>150</y>
       <width>21</width>
       <height>21</height>
      </rect>
     </property>
     <property name="sizePolicy">
      <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="toolTip">
      <string>开发人员选项</string>
     </property>
     <property name="text">
      <string/>
     </property>
     <property name="pixmap">
      <pixmap>ico/warningtriangle_87535-modified.png</pixmap>
     </property>
     <property name="scaledContents">
      <bool>true</bool>
     </property>
    </widget>
    <widget class="QPushButton" name="resetSizeButton">
     <property name="geometry">
      <rect>
       <x>135</x>
       <y>145</y>
       <width>31</width>
       <height>31</height>
      </rect>
     </property>
     <property name="toolTip">
      <string>重置窗口大小</string>
     </property>
     <property name="text">
      <string/>
     </property>
     <property name="icon">
      <iconset>
       <normaloff>ico/restartr-modified.png</normaloff>ico/restartr-modified.png</iconset>
     </property>
    </widget>
   </widget>
   <widget class="QWidget" name="overlay" native="true">
    <property name="geometry">
     <rect>
      <x>1670</x>
      <y>630</y>
      <width>971</width>
      <height>611</height>
     </rect>
    </property>
    <property name="styleSheet">
     <string notr="true">background-color: rgba(56, 56, 56, 180);</string>
    </property>
   </widget>
   <widget class="QWidget" name="closeMessageWidget" native="true">
    <property name="geometry">
     <rect>
      <x>1280</x>
      <y>630</y>
      <width>241</width>
      <height>171</height>
     </rect>
    </property>
    <property name="styleSheet">
     <string notr="true">background-color: rgb(45, 45, 45);</string>
    </property>
    <widget class="QLabel" name="label_5">
     <property name="geometry">
      <rect>
       <x>70</x>
       <y>70</y>
       <width>111</width>
       <height>31</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <pointsize>12</pointsize>
      </font>
     </property>
     <property name="text">
      <string>软件关闭中...</string>
     </property>
     <property name="alignment">
      <set>Qt::AlignmentFlag::AlignCenter</set>
     </property>
    </widget>
   </widget>
   <widget class="QWidget" name="widget" native="true">
    <property name="geometry">
     <rect>
      <x>1530</x>
      <y>630</y>
      <width>131</width>
      <height>41</height>
     </rect>
    </property>
    <property name="styleSheet">
     <string notr="true">background-color: rgb(255, 0, 0);</string>
    </property>
    <widget class="QLabel" name="floatingMessageLabel">
     <property name="geometry">
      <rect>
       <x>40</x>
       <y>10</y>
       <width>51</width>
       <height>21</height>
      </rect>
     </property>
     <property name="text">
      <string>ERROR</string>
     </property>
     <property name="alignment">
      <set>Qt::AlignmentFlag::AlignCenter</set>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
    </widget>
   </widget>
   <widget class="QWidget" name="statusDisplayWidget" native="true">
    <property name="geometry">
     <rect>
      <x>1050</x>
      <y>630</y>
      <width>211</width>
      <height>41</height>
     </rect>
    </property>
    <property name="styleSheet">
     <string notr="true">background-color: rgb(255, 255, 255);
border-radius: 20px;      /* 圆形效果，半径设为 QLabel 宽高的一半 */</string>
    </property>
    <widget class="QLabel" name="statusDisplayLabel">
     <property name="geometry">
      <rect>
       <x>10</x>
       <y>5</y>
       <width>191</width>
       <height>31</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>微软雅黑</family>
       <pointsize>12</pointsize>
      </font>
     </property>
     <property name="styleSheet">
      <string notr="true">color: rgb(0, 0, 0);</string>
     </property>
     <property name="text">
      <string>None</string>
     </property>
     <property name="alignment">
      <set>Qt::AlignmentFlag::AlignCenter</set>
     </property>
    </widget>
   </widget>
   <widget class="QWidget" name="settingWidget" native="true">
    <property name="geometry">
     <rect>
      <x>530</x>
      <y>10</y>
      <width>371</width>
      <height>511</height>
     </rect>
    </property>
    <property name="styleSheet">
     <string notr="true">
    border-radius: 20px;
    background-color: rgb(70, 70, 70);


</string>
    </property>
    <widget class="QFrame" name="itemFrame">
     <property name="geometry">
      <rect>
       <x>0</x>
       <y>0</y>
       <width>371</width>
       <height>71</height>
      </rect>
     </property>
     <property name="styleSheet">
      <string notr="true">background-color: rgba(0, 0, 0, 0);
border-color: rgba(0, 0, 0, 0);</string>
     </property>
     <property name="frameShape">
      <enum>QFrame::Shape::Box</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Shadow::Raised</enum>
     </property>
     <property name="lineWidth">
      <number>0</number>
     </property>
     <widget class="QPushButton" name="pushButton_3">
      <property name="geometry">
       <rect>
        <x>10</x>
        <y>0</y>
        <width>31</width>
        <height>51</height>
       </rect>
      </property>
      <property name="cursor">
       <cursorShape>PointingHandCursor</cursorShape>
      </property>
      <property name="styleSheet">
       <string notr="true">
    border-radius: 20px;
background-color: rgba(0, 0, 0, 0);


</string>
      </property>
      <property name="text">
       <string/>
      </property>
      <property name="icon">
       <iconset>
        <normaloff>ico/back_turn.png</normaloff>ico/back_turn.png</iconset>
      </property>
      <property name="iconSize">
       <size>
        <width>28</width>
        <height>28</height>
       </size>
      </property>
     </widget>
     <widget class="QPushButton" name="pushButton_4">
      <property name="geometry">
       <rect>
        <x>330</x>
        <y>0</y>
        <width>31</width>
        <height>51</height>
       </rect>
      </property>
      <property name="cursor">
       <cursorShape>PointingHandCursor</cursorShape>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgba(0, 0, 0, 0);
    border-radius: 20px;
</string>
      </property>
      <property name="text">
       <string/>
      </property>
      <property name="icon">
       <iconset>
        <normaloff>ico/back.png</normaloff>ico/back.png</iconset>
      </property>
      <property name="iconSize">
       <size>
        <width>28</width>
        <height>28</height>
       </size>
      </property>
     </widget>
     <widget class="QPushButton" name="basicSettingsPushButton">
      <property name="geometry">
       <rect>
        <x>150</x>
        <y>15</y>
        <width>75</width>
        <height>23</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="text">
       <string>基础设置</string>
      </property>
     </widget>
     <widget class="QPushButton" name="softwareInformationPushButton">
      <property name="geometry">
       <rect>
        <x>240</x>
        <y>20</y>
        <width>75</width>
        <height>23</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="text">
       <string>软件信息</string>
      </property>
     </widget>
     <widget class="QPushButton" name="advancedSettingsPushButton">
      <property name="geometry">
       <rect>
        <x>60</x>
        <y>20</y>
        <width>75</width>
        <height>23</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="text">
       <string>高级设置</string>
      </property>
     </widget>
     <widget class="QLabel" name="redLine">
      <property name="geometry">
       <rect>
        <x>150</x>
        <y>40</y>
        <width>75</width>
        <height>3</height>
       </rect>
      </property>
      <property name="text">
       <string/>
      </property>
      <property name="pixmap">
       <pixmap>ico/RedLine.png</pixmap>
      </property>
      <property name="scaledContents">
       <bool>true</bool>
      </property>
     </widget>
    </widget>
   </widget>
   <widget class="QWidget" name="settingWidget_2" native="true">
    <property name="geometry">
     <rect>
      <x>910</x>
      <y>10</y>
      <width>371</width>
      <height>511</height>
     </rect>
    </property>
    <property name="styleSheet">
     <string notr="true">
    border-radius: 20px;
    background-color: rgb(70, 70, 70);


</string>
    </property>
   </widget>
   <widget class="QFrame" name="frame_3">
    <property name="enabled">
     <bool>true</bool>
    </property>
    <property name="geometry">
     <rect>
      <x>910</x>
      <y>10</y>
      <width>371</width>
      <height>561</height>
     </rect>
    </property>
    <property name="styleSheet">
     <string notr="true"/>
    </property>
    <property name="frameShape">
     <enum>QFrame::Shape::NoFrame</enum>
    </property>
    <property name="frameShadow">
     <enum>QFrame::Shadow::Plain</enum>
    </property>
    <widget class="QLabel" name="label_15">
     <property name="geometry">
      <rect>
       <x>20</x>
       <y>20</y>
       <width>91</width>
       <height>16</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
      </font>
     </property>
     <property name="text">
      <string>进程0: UI主进程</string>
     </property>
    </widget>
    <widget class="QTextEdit" name="log_output_03">
     <property name="geometry">
      <rect>
       <x>20</x>
       <y>400</y>
       <width>331</width>
       <height>91</height>
      </rect>
     </property>
     <property name="styleSheet">
      <string notr="true"/>
     </property>
    </widget>
    <widget class="QTextEdit" name="log_output_02">
     <property name="geometry">
      <rect>
       <x>20</x>
       <y>280</y>
       <width>331</width>
       <height>91</height>
      </rect>
     </property>
     <property name="styleSheet">
      <string notr="true"/>
     </property>
    </widget>
    <widget class="QLabel" name="label_13">
     <property name="geometry">
      <rect>
       <x>20</x>
       <y>260</y>
       <width>91</width>
       <height>16</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
      </font>
     </property>
     <property name="text">
      <string>进程2: 视频处理</string>
     </property>
    </widget>
    <widget class="QTextEdit" name="log_output_00">
     <property name="geometry">
      <rect>
       <x>20</x>
       <y>40</y>
       <width>331</width>
       <height>91</height>
      </rect>
     </property>
     <property name="styleSheet">
      <string notr="true"/>
     </property>
    </widget>
    <widget class="QLabel" name="label_12">
     <property name="geometry">
      <rect>
       <x>20</x>
       <y>140</y>
       <width>81</width>
       <height>16</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
      </font>
     </property>
     <property name="text">
      <string>进程1: 主通信</string>
     </property>
    </widget>
    <widget class="QLabel" name="label_14">
     <property name="geometry">
      <rect>
       <x>20</x>
       <y>380</y>
       <width>111</width>
       <height>16</height>
      </rect>
     </property>
     <property name="font">
      <font>
       <family>Microsoft YaHei</family>
      </font>
     </property>
     <property name="text">
      <string>进程3: 视频信号获取</string>
     </property>
    </widget>
    <widget class="QTextEdit" name="log_output_01">
     <property name="geometry">
      <rect>
       <x>20</x>
       <y>160</y>
       <width>331</width>
       <height>91</height>
      </rect>
     </property>
     <property name="styleSheet">
      <string notr="true"/>
     </property>
    </widget>
   </widget>
   <widget class="QFrame" name="parameteComponentFrame">
    <property name="geometry">
     <rect>
      <x>530</x>
      <y>60</y>
      <width>371</width>
      <height>471</height>
     </rect>
    </property>
    <property name="styleSheet">
     <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
    </property>
    <property name="frameShape">
     <enum>QFrame::Shape::NoFrame</enum>
    </property>
    <property name="frameShadow">
     <enum>QFrame::Shadow::Raised</enum>
    </property>
    <widget class="QFrame" name="advancedSettingsFrame">
     <property name="geometry">
      <rect>
       <x>0</x>
       <y>0</y>
       <width>371</width>
       <height>461</height>
      </rect>
     </property>
     <property name="styleSheet">
      <string notr="true">background-color: rgba(0, 0, 0, 0);
border-color: rgba(0, 0, 0, 0);</string>
     </property>
     <property name="frameShape">
      <enum>QFrame::Shape::Box</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Shadow::Raised</enum>
     </property>
     <property name="lineWidth">
      <number>0</number>
     </property>
     <widget class="QComboBox" name="detectionTargetComboBox">
      <property name="geometry">
       <rect>
        <x>100</x>
        <y>10</y>
        <width>111</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>10</pointsize>
        <bold>false</bold>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgb(44, 44, 44);</string>
      </property>
      <item>
       <property name="text">
        <string>0</string>
       </property>
      </item>
      <item>
       <property name="text">
        <string>1</string>
       </property>
      </item>
      <item>
       <property name="text">
        <string>2</string>
       </property>
      </item>
      <item>
       <property name="text">
        <string>3</string>
       </property>
      </item>
      <item>
       <property name="text">
        <string>4</string>
       </property>
      </item>
      <item>
       <property name="text">
        <string>5</string>
       </property>
      </item>
      <item>
       <property name="text">
        <string>ALL</string>
       </property>
      </item>
     </widget>
     <widget class="QLabel" name="detectionTargetLabel">
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>10</y>
        <width>71</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
      </property>
      <property name="text">
       <string>检测目标:</string>
      </property>
      <property name="alignment">
       <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
      </property>
     </widget>
     <widget class="QCheckBox" name="auxiliaryPressureGunCheckBox_4">
      <property name="enabled">
       <bool>true</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>310</y>
        <width>91</width>
        <height>20</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="text">
       <string>自动急停</string>
      </property>
     </widget>
     <widget class="QCheckBox" name="automatic_trigger_switchCheckBox">
      <property name="enabled">
       <bool>true</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>340</y>
        <width>91</width>
        <height>20</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="text">
       <string>自动扳机</string>
      </property>
     </widget>
     <widget class="QToolButton" name="auxiliaryPressureGunToolButton_4">
      <property name="enabled">
       <bool>true</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>120</x>
        <y>310</y>
        <width>21</width>
        <height>21</height>
       </rect>
      </property>
      <property name="text">
       <string>...</string>
      </property>
     </widget>
     <widget class="QToolButton" name="automatic_trigger_switchToolButton">
      <property name="enabled">
       <bool>true</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>120</x>
        <y>340</y>
        <width>21</width>
        <height>21</height>
       </rect>
      </property>
      <property name="text">
       <string>...</string>
      </property>
     </widget>
     <widget class="QLabel" name="label_26">
      <property name="geometry">
       <rect>
        <x>220</x>
        <y>15</y>
        <width>21</width>
        <height>21</height>
       </rect>
      </property>
      <property name="sizePolicy">
       <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
        <horstretch>0</horstretch>
        <verstretch>0</verstretch>
       </sizepolicy>
      </property>
      <property name="toolTip">
       <string>根据模型进行调整</string>
      </property>
      <property name="text">
       <string/>
      </property>
      <property name="pixmap">
       <pixmap>ico/warningtriangle_87535-modified.png</pixmap>
      </property>
      <property name="scaledContents">
       <bool>true</bool>
      </property>
     </widget>
     <widget class="QLabel" name="aimingRangeLabel_3">
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>50</y>
        <width>81</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
      </property>
      <property name="text">
       <string>瞄准偏移X:</string>
      </property>
      <property name="alignment">
       <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
      </property>
     </widget>
     <widget class="QLCDNumber" name="offset_centerxNumber">
      <property name="geometry">
       <rect>
        <x>295</x>
        <y>55</y>
        <width>64</width>
        <height>23</height>
       </rect>
      </property>
      <property name="frameShape">
       <enum>QFrame::Shape::Box</enum>
      </property>
      <property name="frameShadow">
       <enum>QFrame::Shadow::Plain</enum>
      </property>
      <property name="segmentStyle">
       <enum>QLCDNumber::SegmentStyle::Flat</enum>
      </property>
     </widget>
     <widget class="QSlider" name="offset_centerxVerticalSlider">
      <property name="geometry">
       <rect>
        <x>130</x>
        <y>57</y>
        <width>161</width>
        <height>20</height>
       </rect>
      </property>
      <property name="orientation">
       <enum>Qt::Orientation::Horizontal</enum>
      </property>
     </widget>
     <widget class="QLabel" name="aimingRangeLabel_4">
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>140</y>
        <width>81</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
      </property>
      <property name="text">
       <string>瞄准偏移Y:</string>
      </property>
      <property name="alignment">
       <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
      </property>
     </widget>
     <widget class="QSlider" name="offset_centeryVerticalSlider">
      <property name="geometry">
       <rect>
        <x>110</x>
        <y>79</y>
        <width>20</width>
        <height>181</height>
       </rect>
      </property>
      <property name="orientation">
       <enum>Qt::Orientation::Vertical</enum>
      </property>
     </widget>
     <widget class="QLCDNumber" name="offset_centeryNumber">
      <property name="geometry">
       <rect>
        <x>295</x>
        <y>160</y>
        <width>64</width>
        <height>23</height>
       </rect>
      </property>
      <property name="frameShape">
       <enum>QFrame::Shape::Box</enum>
      </property>
      <property name="frameShadow">
       <enum>QFrame::Shadow::Plain</enum>
      </property>
      <property name="segmentStyle">
       <enum>QLCDNumber::SegmentStyle::Flat</enum>
      </property>
     </widget>
     <widget class="QLabel" name="label_27">
      <property name="geometry">
       <rect>
        <x>145</x>
        <y>80</y>
        <width>131</width>
        <height>181</height>
       </rect>
      </property>
      <property name="text">
       <string/>
      </property>
      <property name="pixmap">
       <pixmap>ico/body_photo.png</pixmap>
      </property>
      <property name="scaledContents">
       <bool>true</bool>
      </property>
     </widget>
     <widget class="QLabel" name="detectionTargetLabel_2">
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>270</y>
        <width>71</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
      </property>
      <property name="text">
       <string>移动方式:</string>
      </property>
      <property name="alignment">
       <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
      </property>
     </widget>
     <widget class="QComboBox" name="mobileModeQComboBox">
      <property name="geometry">
       <rect>
        <x>100</x>
        <y>270</y>
        <width>111</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>10</pointsize>
        <bold>false</bold>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgb(44, 44, 44);</string>
      </property>
      <item>
       <property name="text">
        <string>win32</string>
       </property>
      </item>
      <item>
       <property name="text">
        <string>飞易来</string>
       </property>
      </item>
      <item>
       <property name="text">
        <string>KmBoxNet</string>
       </property>
      </item>
      <item>
       <property name="text">
        <string>Logitech</string>
       </property>
      </item>
      <item>
       <property name="text">
        <string>mouse</string>
       </property>
      </item>
     </widget>
     <widget class="QCheckBox" name="jumpSuppressionCheckBox">
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>370</y>
        <width>91</width>
        <height>20</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="toolTip">
       <string>演戏，目标死亡后防止瞄准转移</string>
      </property>
      <property name="text">
       <string>跳变抑制</string>
      </property>
     </widget>
     <widget class="QLCDNumber" name="jumpSuppressionNumber">
      <property name="geometry">
       <rect>
        <x>295</x>
        <y>370</y>
        <width>64</width>
        <height>23</height>
       </rect>
      </property>
      <property name="frameShape">
       <enum>QFrame::Shape::Box</enum>
      </property>
      <property name="frameShadow">
       <enum>QFrame::Shadow::Plain</enum>
      </property>
      <property name="segmentStyle">
       <enum>QLCDNumber::SegmentStyle::Flat</enum>
      </property>
     </widget>
     <widget class="QSlider" name="jumpSuppressionVerticalSlider">
      <property name="geometry">
       <rect>
        <x>110</x>
        <y>370</y>
        <width>181</width>
        <height>20</height>
       </rect>
      </property>
      <property name="orientation">
       <enum>Qt::Orientation::Horizontal</enum>
      </property>
     </widget>
     <widget class="QCheckBox" name="smoothAimingCheckBox_5">
      <property name="enabled">
       <bool>false</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>400</y>
        <width>91</width>
        <height>20</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="text">
       <string>鼠标连点</string>
      </property>
     </widget>
     <widget class="QToolButton" name="smoothAimingToolButton_5">
      <property name="enabled">
       <bool>false</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>120</x>
        <y>400</y>
        <width>21</width>
        <height>21</height>
       </rect>
      </property>
      <property name="text">
       <string>...</string>
      </property>
     </widget>
    </widget>
    <widget class="QFrame" name="softwareInformationFrame">
     <property name="geometry">
      <rect>
       <x>840</x>
       <y>0</y>
       <width>371</width>
       <height>461</height>
      </rect>
     </property>
     <property name="styleSheet">
      <string notr="true">background-color: rgba(0, 0, 0, 0);
border-color: rgba(0, 0, 0, 0);</string>
     </property>
     <property name="frameShape">
      <enum>QFrame::Shape::Box</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Shadow::Raised</enum>
     </property>
     <property name="lineWidth">
      <number>0</number>
     </property>
     <widget class="QLabel" name="label_2">
      <property name="geometry">
       <rect>
        <x>135</x>
        <y>10</y>
        <width>101</width>
        <height>41</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>18</pointsize>
       </font>
      </property>
      <property name="text">
       <string>公告</string>
      </property>
      <property name="alignment">
       <set>Qt::AlignmentFlag::AlignCenter</set>
      </property>
     </widget>
     <widget class="QTextEdit" name="announcement">
      <property name="geometry">
       <rect>
        <x>30</x>
        <y>60</y>
        <width>311</width>
        <height>181</height>
       </rect>
      </property>
      <property name="markdown">
       <string>在这里显示公告！！！

</string>
      </property>
     </widget>
     <widget class="QLabel" name="label_3">
      <property name="geometry">
       <rect>
        <x>30</x>
        <y>260</y>
        <width>41</width>
        <height>21</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="text">
       <string>渠道：</string>
      </property>
     </widget>
     <widget class="QLabel" name="label_4">
      <property name="geometry">
       <rect>
        <x>30</x>
        <y>300</y>
        <width>91</width>
        <height>21</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="text">
       <string>当前版本：</string>
      </property>
     </widget>
     <widget class="QLabel" name="label_6">
      <property name="geometry">
       <rect>
        <x>30</x>
        <y>340</y>
        <width>71</width>
        <height>21</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="text">
       <string>构建时间：</string>
      </property>
     </widget>
     <widget class="QLabel" name="label_16">
      <property name="geometry">
       <rect>
        <x>30</x>
        <y>430</y>
        <width>41</width>
        <height>21</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="text">
       <string>作者：</string>
      </property>
     </widget>
     <widget class="QLabel" name="label_20">
      <property name="geometry">
       <rect>
        <x>70</x>
        <y>430</y>
        <width>61</width>
        <height>21</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Bauhaus 93</family>
        <pointsize>14</pointsize>
       </font>
      </property>
      <property name="text">
       <string>PASSER</string>
      </property>
     </widget>
     <widget class="QLabel" name="channelLabel">
      <property name="geometry">
       <rect>
        <x>80</x>
        <y>260</y>
        <width>181</width>
        <height>21</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="text">
       <string>内部预览版/预览版/正式版</string>
      </property>
     </widget>
     <widget class="QLabel" name="versionLabel">
      <property name="geometry">
       <rect>
        <x>110</x>
        <y>300</y>
        <width>300</width>
        <height>21</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="text">
       <string>NowVersion</string>
      </property>
     </widget>
     <widget class="QLabel" name="versionDateLabel">
      <property name="geometry">
       <rect>
        <x>110</x>
        <y>340</y>
        <width>200</width>
        <height>21</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="text">
       <string>VERSION_DATE</string>
      </property>
     </widget>
     <widget class="QLabel" name="label_24">
      <property name="geometry">
       <rect>
        <x>30</x>
        <y>320</y>
        <width>71</width>
        <height>21</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="text">
       <string>最新版本：</string>
      </property>
     </widget>
     <widget class="QLabel" name="latestVersionLabel">
      <property name="geometry">
       <rect>
        <x>110</x>
        <y>320</y>
        <width>650</width>
        <height>21</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>11</pointsize>
       </font>
      </property>
      <property name="text">
       <string>LatestVersion</string>
      </property>
     </widget>
    </widget>
    <widget class="QFrame" name="basicSettingsFrame">
     <property name="geometry">
      <rect>
       <x>450</x>
       <y>0</y>
       <width>371</width>
       <height>461</height>
      </rect>
     </property>
     <property name="styleSheet">
      <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
     </property>
     <property name="frameShape">
      <enum>QFrame::Shape::Box</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Shadow::Raised</enum>
     </property>
     <property name="lineWidth">
      <number>0</number>
     </property>
     <widget class="QComboBox" name="triggerMethodComboBox">
      <property name="geometry">
       <rect>
        <x>100</x>
        <y>50</y>
        <width>111</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>10</pointsize>
        <bold>false</bold>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgb(44, 44, 44);</string>
      </property>
      <item>
       <property name="text">
        <string>按下</string>
       </property>
      </item>
      <item>
       <property name="text">
        <string>切换</string>
       </property>
      </item>
      <item>
       <property name="text">
        <string>shift+按下</string>
       </property>
      </item>
     </widget>
     <widget class="QCheckBox" name="aimBotCheckBox">
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>10</y>
        <width>101</width>
        <height>21</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Arial Rounded MT</family>
        <pointsize>12</pointsize>
        <bold>true</bold>
       </font>
      </property>
      <property name="whatsThis">
       <string>自瞄开关</string>
      </property>
      <property name="text">
       <string>Aimbot</string>
      </property>
      <property name="iconSize">
       <size>
        <width>24</width>
        <height>24</height>
       </size>
      </property>
      <property name="autoRepeatDelay">
       <number>310</number>
      </property>
     </widget>
     <widget class="QLabel" name="triggerMethodLabel">
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>50</y>
        <width>91</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
      </property>
      <property name="text">
       <string>触发方式:</string>
      </property>
      <property name="alignment">
       <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
      </property>
     </widget>
     <widget class="QCheckBox" name="sideButtonCheckBox">
      <property name="geometry">
       <rect>
        <x>180</x>
        <y>10</y>
        <width>171</width>
        <height>20</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="text">
       <string>鼠标侧键瞄准开关</string>
      </property>
     </widget>
     <widget class="QLabel" name="triggerHotkeyLabel">
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>90</y>
        <width>200</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
      </property>
      <property name="text">
       <string>触发热键:</string>
      </property>
      <property name="alignment">
       <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
      </property>
     </widget>
     <widget class="QPushButton" name="HotkeyPushButton">
      <property name="geometry">
       <rect>
        <x>100</x>
        <y>90</y>
        <width>111</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>10</pointsize>
        <bold>false</bold>
       </font>
      </property>
      <property name="text">
       <string>HotKeyName</string>
      </property>
     </widget>
     <widget class="QCheckBox" name="auxiliaryPressureGunCheckBox">
      <property name="enabled">
       <bool>false</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>140</y>
        <width>91</width>
        <height>20</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="text">
       <string>辅助压枪</string>
      </property>
     </widget>
     <widget class="QCheckBox" name="smoothAimingCheckBox">
      <property name="enabled">
       <bool>false</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>180</y>
        <width>91</width>
        <height>20</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="text">
       <string>平滑瞄准</string>
      </property>
     </widget>
     <widget class="QToolButton" name="auxiliaryPressureGunToolButton">
      <property name="geometry">
       <rect>
        <x>120</x>
        <y>140</y>
        <width>21</width>
        <height>21</height>
       </rect>
      </property>
      <property name="text">
       <string>...</string>
      </property>
     </widget>
     <widget class="QToolButton" name="smoothAimingToolButton">
      <property name="geometry">
       <rect>
        <x>120</x>
        <y>180</y>
        <width>21</width>
        <height>21</height>
       </rect>
      </property>
      <property name="text">
       <string>...</string>
      </property>
     </widget>
     <widget class="QToolButton" name="automaticTriggerToolButton">
      <property name="geometry">
       <rect>
        <x>120</x>
        <y>220</y>
        <width>21</width>
        <height>21</height>
       </rect>
      </property>
      <property name="text">
       <string>...</string>
      </property>
     </widget>
     <widget class="QCheckBox" name="automaticTriggerCheckBox">
      <property name="enabled">
       <bool>false</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>20</x>
        <y>220</y>
        <width>91</width>
        <height>20</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="text">
       <string>自动扳机</string>
      </property>
     </widget>
     <widget class="QLabel" name="lockSpeedXLabel">
      <property name="geometry">
       <rect>
        <x>15</x>
        <y>245</y>
        <width>81</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
      </property>
      <property name="text">
       <string>瞄准速度X:</string>
      </property>
      <property name="alignment">
       <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
      </property>
     </widget>
     <widget class="QLabel" name="aimingRangeLabel">
      <property name="geometry">
       <rect>
        <x>15</x>
        <y>305</y>
        <width>71</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
      </property>
      <property name="text">
       <string>瞄准范围:</string>
      </property>
      <property name="alignment">
       <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
      </property>
     </widget>
     <widget class="QSlider" name="lockSpeedXHorizontalSlider">
      <property name="geometry">
       <rect>
        <x>95</x>
        <y>252</y>
        <width>191</width>
        <height>18</height>
       </rect>
      </property>
      <property name="orientation">
       <enum>Qt::Orientation::Horizontal</enum>
      </property>
     </widget>
     <widget class="QSlider" name="aimRangeHorizontalSlider">
      <property name="geometry">
       <rect>
        <x>95</x>
        <y>312</y>
        <width>191</width>
        <height>18</height>
       </rect>
      </property>
      <property name="orientation">
       <enum>Qt::Orientation::Horizontal</enum>
      </property>
     </widget>
     <widget class="QLCDNumber" name="lockSpeedXLcdNumber">
      <property name="geometry">
       <rect>
        <x>290</x>
        <y>250</y>
        <width>64</width>
        <height>23</height>
       </rect>
      </property>
      <property name="frameShape">
       <enum>QFrame::Shape::Box</enum>
      </property>
      <property name="frameShadow">
       <enum>QFrame::Shadow::Plain</enum>
      </property>
      <property name="segmentStyle">
       <enum>QLCDNumber::SegmentStyle::Flat</enum>
      </property>
     </widget>
     <widget class="QLCDNumber" name="aimRangeLcdNumber">
      <property name="geometry">
       <rect>
        <x>290</x>
        <y>310</y>
        <width>64</width>
        <height>23</height>
       </rect>
      </property>
      <property name="frameShape">
       <enum>QFrame::Shape::Box</enum>
      </property>
      <property name="frameShadow">
       <enum>QFrame::Shadow::Plain</enum>
      </property>
      <property name="segmentStyle">
       <enum>QLCDNumber::SegmentStyle::Flat</enum>
      </property>
     </widget>
     <widget class="QSlider" name="aimRangeHorizontalSlider_2">
      <property name="enabled">
       <bool>false</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>95</x>
        <y>342</y>
        <width>191</width>
        <height>18</height>
       </rect>
      </property>
      <property name="orientation">
       <enum>Qt::Orientation::Horizontal</enum>
      </property>
     </widget>
     <widget class="QLCDNumber" name="aimRangeLcdNumber_2">
      <property name="enabled">
       <bool>false</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>290</x>
        <y>340</y>
        <width>64</width>
        <height>23</height>
       </rect>
      </property>
      <property name="frameShape">
       <enum>QFrame::Shape::Box</enum>
      </property>
      <property name="frameShadow">
       <enum>QFrame::Shadow::Plain</enum>
      </property>
      <property name="segmentStyle">
       <enum>QLCDNumber::SegmentStyle::Flat</enum>
      </property>
     </widget>
     <widget class="QLabel" name="aimingRangeLabel_2">
      <property name="enabled">
       <bool>false</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>15</x>
        <y>335</y>
        <width>71</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
      </property>
      <property name="text">
       <string>移速补偿:</string>
      </property>
      <property name="alignment">
       <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
      </property>
     </widget>
     <widget class="QLCDNumber" name="aimRangeLcdNumber_3">
      <property name="enabled">
       <bool>false</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>290</x>
        <y>370</y>
        <width>64</width>
        <height>23</height>
       </rect>
      </property>
      <property name="frameShape">
       <enum>QFrame::Shape::Box</enum>
      </property>
      <property name="frameShadow">
       <enum>QFrame::Shadow::Plain</enum>
      </property>
      <property name="segmentStyle">
       <enum>QLCDNumber::SegmentStyle::Flat</enum>
      </property>
     </widget>
     <widget class="QSlider" name="aimRangeHorizontalSlider_3">
      <property name="enabled">
       <bool>false</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>95</x>
        <y>372</y>
        <width>191</width>
        <height>18</height>
       </rect>
      </property>
      <property name="orientation">
       <enum>Qt::Orientation::Horizontal</enum>
      </property>
     </widget>
     <widget class="QLabel" name="aimingRangeLabel_5">
      <property name="enabled">
       <bool>false</bool>
      </property>
      <property name="geometry">
       <rect>
        <x>15</x>
        <y>365</y>
        <width>71</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
      </property>
      <property name="text">
       <string>减速区域:</string>
      </property>
      <property name="alignment">
       <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
      </property>
     </widget>
     <widget class="QSlider" name="lockSpeedYHorizontalSlider">
      <property name="geometry">
       <rect>
        <x>95</x>
        <y>280</y>
        <width>191</width>
        <height>18</height>
       </rect>
      </property>
      <property name="orientation">
       <enum>Qt::Orientation::Horizontal</enum>
      </property>
     </widget>
     <widget class="QLCDNumber" name="lockSpeedYLcdNumber">
      <property name="geometry">
       <rect>
        <x>290</x>
        <y>280</y>
        <width>64</width>
        <height>23</height>
       </rect>
      </property>
      <property name="frameShape">
       <enum>QFrame::Shape::Box</enum>
      </property>
      <property name="frameShadow">
       <enum>QFrame::Shadow::Plain</enum>
      </property>
      <property name="segmentStyle">
       <enum>QLCDNumber::SegmentStyle::Flat</enum>
      </property>
     </widget>
     <widget class="QLabel" name="lockSpeedYLabel">
      <property name="geometry">
       <rect>
        <x>15</x>
        <y>275</y>
        <width>81</width>
        <height>31</height>
       </rect>
      </property>
      <property name="font">
       <font>
        <family>Microsoft YaHei</family>
        <pointsize>12</pointsize>
       </font>
      </property>
      <property name="styleSheet">
       <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
      </property>
      <property name="text">
       <string>瞄准速度Y:</string>
      </property>
      <property name="alignment">
       <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
      </property>
     </widget>
    </widget>
   </widget>
   <zorder>settingWidget_2</zorder>
   <zorder>settingWidget</zorder>
   <zorder>show_video</zorder>
   <zorder>OpVideoButton</zorder>
   <zorder>OpYoloButton</zorder>
   <zorder>settingsYoloButton</zorder>
   <zorder>closeMessageWidget</zorder>
   <zorder>widget</zorder>
   <zorder>frame_3</zorder>
   <zorder>statusDisplayWidget</zorder>
   <zorder>parameteComponentFrame</zorder>
   <zorder>overlay</zorder>
   <zorder>settingsPanel</zorder>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`Utils/exception.py`:

```py
import traceback
import sys


def handle_exception(e):
    error_type = type(e).__name__
    error_message = str(e)[:3000]  # 限制错误消息的最大长度
    if trace_info := traceback.extract_tb(sys.exc_info()[2]):
        error_traceback = trace_info[-1]
        return f"ERROR:\nType: {error_type}\nMessage: {error_message}\nLine: {error_traceback.lineno}\nFile: {error_traceback.filename}\nFunction: {error_traceback.name}"
    else:
        return f"ERROR:\nType: {error_type}\nMessage: {error_message}\nTraceback: Not available"

```

`Utils/revision.py`:

```py
import base64
import re
import requests
from Module.config import Root

session = requests.Session()


def get_release_version_with_date() -> tuple[str, str]:
    """
    获取最新的发布版本及其发布日期

    该函数通过GitHub API获取指定仓库的最新发布信息，并返回版本号和发布日期

    Returns:
        tuple: 包含版本号（tag_name）和发布日期（published_at）的元组
    """
    url = "https://api.github.com/repos/Passer1072/RookieAI_yolov8/releases/latest"
    try:
        response = session.get(url)
        response.raise_for_status()
        data = response.json()
    except requests.exceptions.RequestException:
        return "N/A", "N/A"
    return data["tag_name"], data["published_at"]


def get_dev_version_with_date() -> tuple[str, str | None]:
    """
    获取指定GitHub仓库中dev分支的版本号和最近修改日期。

    Returns:
        tuple: 包含版本号和发布日期（如果可用）的元组
    """
    owner = "Passer1072"
    repo = "RookieAI_yolov8"
    branch = "dev"
    file_path = "__version__"
    _version = "v0.0.0"
    _date = "1970-01-01 00:00:00"
    contents_url = f"https://api.github.com/repos/{owner}/{repo}/contents/{file_path}?ref={branch}"
    try:
        response = session.get(contents_url)
        response.raise_for_status()
        data = response.json()
    except requests.exceptions.RequestException:
        return "N/A", "N/A"
    content = base64.b64decode(
        data.get("content", b"")).decode("utf-8").split("\n")
    Line1 = content[0].strip() if len(content) > 0 else ""
    if Line1.startswith("__version__:"):
        _version = Line1.split(":", 1)[1].strip()
    Line2 = content[1].strip() if len(content) > 1 else ""
    if Line2.startswith("__version_date__:"):
        _date = Line2.split(":", 1)[1].strip()

    return _version, _date


def get_online_announcement(
    parse_announcement2json: bool = False,
) -> dict[str, str] | str:
    """
    获取在线公告。

    通过GitHub API获取指定仓库中的公告文件内容。
    公告文件是Markdown格式，需要使用base64解码后转换为字符串。

    备注：QT提供支持Markdown语法的WebView组件，建议直接渲染markdown格式的公告内容到WebView。

    Returns:
        str: 公告内容字符串
    """
    owner = "Passer1072"
    repo = "RookieAI_yolov8"
    branch = "announcement"
    file_path = "README.md"

    contents_url = f"https://api.github.com/repos/{owner}/{repo}/contents/{file_path}?ref={branch}"
    try:
        response = session.get(contents_url)
        response.raise_for_status()
        data = response.json()
    except requests.exceptions.RequestException:
        return "无法连接GitHub服务器，请检查网络连接。"
    announcement = base64.b64decode(
        data.get("content", b"")).decode("utf-8")
    if parse_announcement2json:
        published_at_match = re.search(
            r"\$\[(\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2})\]\$", announcement
        )
        if not published_at_match:
            raise ValueError("无法找到发布时间")

        # 提取发布时间
        published_at = published_at_match[1]

        # 去掉发布时间标记，提取内容
        content = re.sub(
            r"\$\[\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2}\]\$", "", announcement
        ).strip()

        return {"published_at": published_at, "content": content}
    return announcement


def get_local_version() -> str:
    """获取当前版本

    返回:
        str: 当前版本号
    """
    _version = "v0.0.0"
    version_file_path = Root / "__version__"
    with version_file_path.open(encoding="utf8") as version_file:
        first_line = version_file.readline().strip()
        if first_line.startswith("__version__:"):
            _version = first_line.split(":", 1)[1].strip()
    return _version


def get_local_date() -> str:
    """获取当前版本日期

    返回:
        str: 当前版本号日期
    """
    _date = "1970-01-01 00:00:00"
    version_file_path = Root / "__version__"
    with version_file_path.open(encoding="utf8") as version_file:
        first_line = version_file.readline().strip()
        if first_line.startswith("__version_date__:"):
            _date = first_line.split(":", 1)[1].strip()
    return _date


def is_dev_version() -> bool:
    """判断当前是否为开发版本
    返回:
        bool: 是否为开发版本
    """
    _version = get_local_version()
    return bool(re.search(r"-[0-9a-fA-F]{7}$", _version))


def is_internal_version() -> bool:
    """判断当前是否为内部开发版本
    返回:
        bool: 是否为内部版本
    """
    _version = get_local_version()
    return bool(re.search(r"-[0-9a-fA-F]{7}$", _version) and re.search(r"IV", _version))


def is_official_version() -> bool:
    """判断当前是否为正式版本
    返回:
        bool: 是否为正式版本
    """
    _version = get_local_version()
    return not bool(re.search(r"-[0-9a-fA-F]{7}$", _version))


def get_channel() -> str:
    """获取当前渠道
    返回:
        str: 当前渠道
    """
    if is_dev_version():
        return "预览版"
    elif is_internal_version():
        return "内部预览版"
    else:
        return "正式版"

```

`__version__`:

```
__version__: v3.0.0.14
__version_date__: 2025-01-18 22:18:57

```

`customLib/animated_status/__init__.py`:

```py
from PyQt6.QtCore import QPropertyAnimation, QEasingCurve, QPoint, Qt, QTimer
from PyQt6.QtWidgets import QGraphicsOpacityEffect, QVBoxLayout

class AnimatedStatus:
    def __init__(self, window, widget_name: str, label_name: str):
        """
        初始化 AnimatedStatus，并允许用户指定自定义的 Widget 和 Label 名称。

        :param window: 父窗口
        :param widget_name: 自定义的状态提示浮窗 Widget 名称
        :param label_name: 自定义的状态提示文本 Label 名称
        """
        self.window = window
        self.status_widget = getattr(window, widget_name)
        self.status_label = getattr(window, label_name)

        # 初始化布局并将自定义的 Label 居中放置在自定义的 Widget 中
        layout = QVBoxLayout(self.status_widget)
        layout.addWidget(self.status_label)
        layout.setContentsMargins(0, 0, 0, 0)  # 移除边距
        layout.setAlignment(self.status_label, Qt.AlignmentFlag.AlignCenter)  # 居中对齐

        # 初始化QTimer，用于自动隐藏
        self.hide_timer = QTimer()
        self.hide_timer.setSingleShot(True)  # 只触发一次
        self.hide_timer.timeout.connect(self.hide_status_widget)

    def display_message(self, message, bg_color="lightblue", text_color="black", font_size=14,
                        padding=(5, 10, 5, 10), auto_hide=3000):
        """
        快捷显示带动画的状态提示消息，并在指定时间后自动隐藏。

        :param message: 显示的消息文本
        :param bg_color: 背景颜色，默认浅蓝
        :param text_color: 文本颜色，默认黑色
        :param font_size: 文本字体大小，默认14
        :param padding: 文本内边距（上、右、下、左），默认为(5, 10, 5, 10)
        :param auto_hide: 自动隐藏的倒计时时长（毫秒），默认3000毫秒
        """
        # 调用show_status_widget并自动设置auto_hide
        self.show_status_widget(message, bg_color, text_color, font_size, padding, auto_hide)

    def show_status_widget(self, message, bg_color, text_color, font_size=14, padding=(5, 10, 5, 10), auto_hide=None):
        """
        显示状态提示浮窗的动画效果（位置移动和淡入效果）

        :param message: 显示的消息文本
        :param bg_color: 背景颜色
        :param text_color: 文本颜色
        :param font_size: 文本字体大小，默认14
        :param padding: 文本内边距（上、右、下、左），默认为(5, 10, 5, 10)
        :param auto_hide: 自动隐藏的倒计时时长（毫秒），默认不自动隐藏
        """
        # 设置消息提示浮窗的文本
        self.status_label.setText(message)
        # 设置背景颜色和文本颜色，同时保留圆角效果
        self.status_widget.setStyleSheet(
            f"background-color: {bg_color}; border-radius: 20px;"
        )

        # 设置文本颜色、字体大小、内边距
        top, right, bottom, left = padding
        self.status_label.setStyleSheet(
            f"color: {text_color}; font-size: {font_size}px; "
            f"padding: {top}px {right}px {bottom}px {left}px;"
        )

        # 获取文本的宽度
        font_metrics = self.status_label.fontMetrics()
        text_width = font_metrics.horizontalAdvance(message)

        # 设置 status_label 的固定宽度，确保最小宽度为 130
        label_width = max(text_width + 20, 130)
        self.status_label.setFixedWidth(label_width)

        # 设置 status_widget 的固定宽度，确保最小宽度为 210
        widget_width = max(text_width + 35, 210)
        self.status_widget.setFixedWidth(widget_width)

        # 获取窗口的几何信息
        window_geometry = self.window.geometry()
        widget_width = self.status_widget.width()

        # 创建位置动画，控制 status_widget 的位置
        self.status_display_widget_animation = QPropertyAnimation(self.status_widget, b"pos")

        # 设置起始位置（窗口上边框外部 50 像素）
        start_position = QPoint(
            (window_geometry.width() - widget_width) // 2,  # 水平居中
            -50  # 位于窗口上方 50 像素
        )
        # 设置结束位置（向下移动 80 像素）
        end_position = QPoint(
            (window_geometry.width() - widget_width) // 2,
            start_position.y() + 80
        )

        # 设置位置动画的起始值和结束值
        self.status_display_widget_animation.setStartValue(start_position)
        self.status_display_widget_animation.setEndValue(end_position)
        self.status_display_widget_animation.setDuration(500)  # 动画持续时间为 0.5 秒
        self.status_display_widget_animation.setEasingCurve(QEasingCurve.Type.OutQuad)

        # 创建透明度动画，控制淡入效果
        self.status_display_widget_opacity = QGraphicsOpacityEffect(self.status_widget)
        self.status_widget.setGraphicsEffect(self.status_display_widget_opacity)

        self.opacity_animation = QPropertyAnimation(self.status_display_widget_opacity, b"opacity")
        self.opacity_animation.setStartValue(0.0)  # 起始透明度为 0（完全透明）
        self.opacity_animation.setEndValue(1.0)  # 结束透明度为 1（完全不透明）
        self.opacity_animation.setDuration(500)  # 动画持续时间为 0.5 秒

        # 显示组件（初始为不可见状态，确保淡入效果生效）
        self.status_widget.show()

        # 启动动画
        self.status_display_widget_animation.start()
        self.opacity_animation.start()

        # 设置自动隐藏倒计时
        if auto_hide:
            self.hide_timer.start(auto_hide)

    def hide_status_widget(self):
        """用于隐藏 status_widget 的动画效果（位置移动和淡出效果）"""

        # 获取窗口的几何信息
        window_geometry = self.window.geometry()
        widget_width = self.status_widget.width()

        # 创建位置动画，控制 status_widget 的位置
        self.status_display_widget_animation = QPropertyAnimation(self.status_widget, b"pos")

        # 设置起始位置（当前显示位置）
        start_position = QPoint(
            (window_geometry.width() - widget_width) // 2,
            30  # 与 show_status_widget 的结束位置相同
        )

        # 设置结束位置（移动到窗口上方不可见位置）
        end_position = QPoint(
            (window_geometry.width() - widget_width) // 2,
            start_position.y() - 50  # 向上移动 80 像素
        )

        # 设置位置动画的起始值和结束值
        self.status_display_widget_animation.setStartValue(start_position)
        self.status_display_widget_animation.setEndValue(end_position)
        self.status_display_widget_animation.setDuration(500)  # 动画持续时间为 0.5 秒
        self.status_display_widget_animation.setEasingCurve(QEasingCurve.Type.InQuad)

        # 创建透明度动画，控制淡出效果
        self.status_display_widget_opacity = QGraphicsOpacityEffect(self.status_widget)
        self.status_widget.setGraphicsEffect(self.status_display_widget_opacity)

        self.opacity_animation = QPropertyAnimation(self.status_display_widget_opacity, b"opacity")
        self.opacity_animation.setStartValue(1.0)  # 起始透明度为 1（完全不透明）
        self.opacity_animation.setEndValue(0.0)  # 结束透明度为 0（完全透明）
        self.opacity_animation.setDuration(450)  # 动画持续时间为 0.5 秒

        # 启动动画
        self.status_display_widget_animation.start()
        self.opacity_animation.start()

        # 动画结束后隐藏组件并清空文本
        def on_animation_finished():
            self.status_widget.hide()
            self.status_label.setText("")  # 清空 status_label 的文本

        # 将动画结束信号连接到清理函数
        self.status_display_widget_animation.finished.connect(on_animation_finished)

```

`customLib/animated_status/animated_status_test_ui.py`:

```py
"""
带动画的 状态提示浮窗 库使用示例
"""

import sys
from PyQt6 import QtWidgets, uic
from customLib.animated_status import AnimatedStatus  # 导入 带动画的状态提示浮窗 库


class TestUI(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        uic.loadUi('animated_status_test_ui.ui', self)  # 加载 UI 文件

        # 初始化 AnimatedStatus，将 TestUI 实例作为窗口参数传递，指定Widget和Label名称
        self.status_widget = AnimatedStatus(window=self,
                                            widget_name="statusDisplayWidget",
                                            label_name="statusDisplayLabel")

        # 设置按钮事件
        self.showButton.clicked.connect(self.show_status_message)
        self.hideButton.clicked.connect(self.hide_status_message)
        self.quickCall.clicked.connect(self.quick_call_display_message)  # 连接quickCall按钮

    def show_status_message(self):
        """显示带动画效果的状态提示"""
        self.status_widget.show_status_widget("显示中的提示信息", bg_color="Yellow", text_color="black")

    def hide_status_message(self):
        """隐藏带动画效果的状态提示"""
        self.status_widget.hide_status_widget()

    def quick_call_display_message(self):
        """使用 display_message 快捷方法显示提示信息并自动隐藏"""
        self.status_widget.display_message("快捷调用成功！", bg_color="green", text_color="white", auto_hide=2000)


if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    window = TestUI()
    window.show()
    sys.exit(app.exec())

```

`customLib/animated_status/animated_status_test_ui.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>640</width>
    <height>480</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>MainWindow</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <widget class="QWidget" name="statusDisplayWidget" native="true">
    <property name="geometry">
     <rect>
      <x>240</x>
      <y>70</y>
      <width>171</width>
      <height>41</height>
     </rect>
    </property>
    <property name="styleSheet">
     <string notr="true">background-color: rgb(44, 44, 44);</string>
    </property>
    <widget class="QLabel" name="statusDisplayLabel">
     <property name="geometry">
      <rect>
       <x>40</x>
       <y>5</y>
       <width>91</width>
       <height>31</height>
      </rect>
     </property>
     <property name="text">
      <string>测试</string>
     </property>
     <property name="alignment">
      <set>Qt::AlignmentFlag::AlignCenter</set>
     </property>
    </widget>
   </widget>
   <widget class="QPushButton" name="showButton">
    <property name="geometry">
     <rect>
      <x>70</x>
      <y>410</y>
      <width>141</width>
      <height>51</height>
     </rect>
    </property>
    <property name="text">
     <string>显示</string>
    </property>
   </widget>
   <widget class="QPushButton" name="hideButton">
    <property name="geometry">
     <rect>
      <x>270</x>
      <y>410</y>
      <width>141</width>
      <height>51</height>
     </rect>
    </property>
    <property name="text">
     <string>隐藏</string>
    </property>
   </widget>
   <widget class="QPushButton" name="quickCall">
    <property name="geometry">
     <rect>
      <x>460</x>
      <y>410</y>
      <width>141</width>
      <height>51</height>
     </rect>
    </property>
    <property name="text">
     <string>快捷调用</string>
    </property>
   </widget>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`customLib/automatic_trigger_set_dialog/__init__.py`:

```py
# automatic_trigger_set_dialog.py

import sys
from PyQt6 import QtWidgets, uic
from PyQt6.QtWidgets import QDialog
from PyQt6.QtGui import QIcon
from pathlib import Path

Root = Path(__file__).parent


class AutomaticTriggerSetDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.autoTiggerRangeNumber = None
        self.autoTiggerRangeSlider = None
        self.buttonGroup = None
        uic.loadUi(Root / 'automaticTrigger_set.ui', self)
        self.setWindowTitle("自动扳机设置")
        self.setWindowIcon(QIcon(str(Root / "ico" / "ultralytics-botAvatarSrcUrl-1729379860806.png")))
        self.setFixedSize(400, 300)  # 根据需要设置窗口大小

    def closeEvent(self, event):
        """重写关闭事件，只隐藏窗口而不关闭"""
        event.ignore()
        self.hide()

```

`customLib/automatic_trigger_set_dialog/automaticEmergencyStop_set.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>406</width>
    <height>219</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <widget class="QLabel" name="label">
   <property name="geometry">
    <rect>
     <x>150</x>
     <y>0</y>
     <width>101</width>
     <height>31</height>
    </rect>
   </property>
   <property name="font">
    <font>
     <family>Microsoft YaHei</family>
     <pointsize>12</pointsize>
    </font>
   </property>
   <property name="text">
    <string>自动急停配置</string>
   </property>
   <property name="alignment">
    <set>Qt::AlignmentFlag::AlignCenter</set>
   </property>
  </widget>
  <widget class="QRadioButton" name="radioButton_3">
   <property name="geometry">
    <rect>
     <x>30</x>
     <y>40</y>
     <width>131</width>
     <height>21</height>
    </rect>
   </property>
   <property name="font">
    <font>
     <family>Microsoft YaHei</family>
     <pointsize>12</pointsize>
    </font>
   </property>
   <property name="text">
    <string>按下自瞄生效</string>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <attribute name="buttonGroup">
    <string notr="true">buttonGroup</string>
   </attribute>
  </widget>
  <widget class="QLabel" name="triggerPositionLabel">
   <property name="geometry">
    <rect>
     <x>30</x>
     <y>80</y>
     <width>71</width>
     <height>31</height>
    </rect>
   </property>
   <property name="font">
    <font>
     <family>Microsoft YaHei</family>
     <pointsize>12</pointsize>
    </font>
   </property>
   <property name="styleSheet">
    <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
   </property>
   <property name="text">
    <string>适用游戏：</string>
   </property>
   <property name="alignment">
    <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
   </property>
  </widget>
  <widget class="QComboBox" name="triggerPositioncomboBox_2">
   <property name="geometry">
    <rect>
     <x>110</x>
     <y>80</y>
     <width>131</width>
     <height>31</height>
    </rect>
   </property>
   <property name="font">
    <font>
     <family>Microsoft YaHei</family>
     <pointsize>10</pointsize>
    </font>
   </property>
   <item>
    <property name="text">
     <string>VALORANT</string>
    </property>
   </item>
   <item>
    <property name="text">
     <string>自定义（未启用）</string>
    </property>
   </item>
  </widget>
 </widget>
 <resources/>
 <connections/>
 <buttongroups>
  <buttongroup name="buttonGroup"/>
 </buttongroups>
</ui>

```

`customLib/automatic_trigger_set_dialog/automaticTrigger_set.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>371</width>
    <height>218</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <widget class="QSlider" name="autoTiggerRangeSlider">
   <property name="geometry">
    <rect>
     <x>100</x>
     <y>165</y>
     <width>181</width>
     <height>20</height>
    </rect>
   </property>
   <property name="orientation">
    <enum>Qt::Orientation::Horizontal</enum>
   </property>
  </widget>
  <widget class="QRadioButton" name="radioButton">
   <property name="geometry">
    <rect>
     <x>30</x>
     <y>40</y>
     <width>101</width>
     <height>21</height>
    </rect>
   </property>
   <property name="tabletTracking">
    <bool>false</bool>
   </property>
   <property name="acceptDrops">
    <bool>false</bool>
   </property>
   <property name="styleSheet">
    <string notr="true">font: 12pt &quot;Microsoft YaHei&quot;;</string>
   </property>
   <property name="text">
    <string>持续生效</string>
   </property>
   <property name="checked">
    <bool>false</bool>
   </property>
   <attribute name="buttonGroup">
    <string notr="true">buttonGroup</string>
   </attribute>
  </widget>
  <widget class="QLCDNumber" name="autoTiggerRangeNumber">
   <property name="geometry">
    <rect>
     <x>285</x>
     <y>165</y>
     <width>64</width>
     <height>23</height>
    </rect>
   </property>
   <property name="frameShape">
    <enum>QFrame::Shape::Box</enum>
   </property>
   <property name="frameShadow">
    <enum>QFrame::Shadow::Plain</enum>
   </property>
   <property name="segmentStyle">
    <enum>QLCDNumber::SegmentStyle::Flat</enum>
   </property>
  </widget>
  <widget class="QLabel" name="triggerFormLabel">
   <property name="geometry">
    <rect>
     <x>20</x>
     <y>120</y>
     <width>71</width>
     <height>31</height>
    </rect>
   </property>
   <property name="font">
    <font>
     <family>Microsoft YaHei</family>
     <pointsize>12</pointsize>
    </font>
   </property>
   <property name="styleSheet">
    <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
   </property>
   <property name="text">
    <string>触发形式:</string>
   </property>
   <property name="alignment">
    <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
   </property>
  </widget>
  <widget class="QLabel" name="label">
   <property name="geometry">
    <rect>
     <x>130</x>
     <y>0</y>
     <width>101</width>
     <height>31</height>
    </rect>
   </property>
   <property name="font">
    <font>
     <family>Microsoft YaHei</family>
     <pointsize>12</pointsize>
    </font>
   </property>
   <property name="text">
    <string>自动扳机配置</string>
   </property>
   <property name="alignment">
    <set>Qt::AlignmentFlag::AlignCenter</set>
   </property>
  </widget>
  <widget class="QComboBox" name="triggerFormcomboBox">
   <property name="geometry">
    <rect>
     <x>100</x>
     <y>120</y>
     <width>131</width>
     <height>31</height>
    </rect>
   </property>
   <property name="font">
    <font>
     <family>Microsoft YaHei</family>
     <pointsize>10</pointsize>
    </font>
   </property>
   <item>
    <property name="text">
     <string>连点</string>
    </property>
   </item>
   <item>
    <property name="text">
     <string>单点（未开发）</string>
    </property>
   </item>
   <item>
    <property name="text">
     <string>长按（未开发）</string>
    </property>
   </item>
  </widget>
  <widget class="QRadioButton" name="radioButton_2">
   <property name="geometry">
    <rect>
     <x>170</x>
     <y>40</y>
     <width>131</width>
     <height>21</height>
    </rect>
   </property>
   <property name="font">
    <font>
     <family>Microsoft YaHei</family>
     <pointsize>12</pointsize>
    </font>
   </property>
   <property name="text">
    <string>按下自瞄生效</string>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <attribute name="buttonGroup">
    <string notr="true">buttonGroup</string>
   </attribute>
  </widget>
  <widget class="QLabel" name="aimingRangeLabel_5">
   <property name="geometry">
    <rect>
     <x>20</x>
     <y>160</y>
     <width>71</width>
     <height>31</height>
    </rect>
   </property>
   <property name="font">
    <font>
     <family>Microsoft YaHei</family>
     <pointsize>12</pointsize>
    </font>
   </property>
   <property name="styleSheet">
    <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
   </property>
   <property name="text">
    <string>范围比例:</string>
   </property>
   <property name="alignment">
    <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
   </property>
  </widget>
  <widget class="QLabel" name="triggerPositionLabel">
   <property name="geometry">
    <rect>
     <x>20</x>
     <y>80</y>
     <width>71</width>
     <height>31</height>
    </rect>
   </property>
   <property name="font">
    <font>
     <family>Microsoft YaHei</family>
     <pointsize>12</pointsize>
    </font>
   </property>
   <property name="styleSheet">
    <string notr="true">background-color: rgba(0, 0, 0, 0);</string>
   </property>
   <property name="text">
    <string>触发位置:</string>
   </property>
   <property name="alignment">
    <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
   </property>
  </widget>
  <widget class="QComboBox" name="triggerPositioncomboBox">
   <property name="geometry">
    <rect>
     <x>100</x>
     <y>80</y>
     <width>131</width>
     <height>31</height>
    </rect>
   </property>
   <property name="font">
    <font>
     <family>Microsoft YaHei</family>
     <pointsize>10</pointsize>
    </font>
   </property>
   <item>
    <property name="text">
     <string>使用瞄准位置</string>
    </property>
   </item>
   <item>
    <property name="text">
     <string>自定义（未启用）</string>
    </property>
   </item>
  </widget>
 </widget>
 <resources/>
 <connections/>
 <buttongroups>
  <buttongroup name="buttonGroup"/>
 </buttongroups>
</ui>

```

`pyproject.toml`:

```toml
[project]
name = "rookieai"
version = "0.1.0"
description = ""
authors = [
    {name = "Your Name",email = "you@example.com"}
]
license = {text = "MIT"}
readme = "README.md"
requires-python = ">=3.10"
dependencies = [
    "opencv-python (>=4.11.0.86,<5.0.0.0)",
    "numpy (>=1.23.0,<3.0.0)",
    "pyautogui (>=0.9.54,<0.10.0)",
    "pywin32 (>=308,<309)",
    "mss (==6.1.0)",
    "ultralytics (>=8.3.65,<9.0.0)",
    "pillow (>=11.1.0,<12.0.0)",
    "chardet (>=5.2.0,<6.0.0)",
    "dxcam (>=0.0.5,<0.0.6)",
    "requests (>=2.32.3,<3.0.0)",
    "mouse (>=0.7.1,<0.8.0)",
    "psutil (>=6.1.1,<7.0.0)",
    "pyqt6 (>=6.8.0,<7.0.0)",
    "pynput (>=1.7.7,<2.0.0)"
]


[build-system]
requires = ["poetry-core>=2.0.0,<3.0.0"]
build-backend = "poetry.core.masonry.api"

[[tool.poetry.source]]
name = "ali"
url = "https://mirrors.aliyun.com/pypi/simple/"
priority = "primary"


```