Project Path: arc_gmh5225_Swift-String-Obfuscator_ftn2z4ug

Source Tree:

```txt
arc_gmh5225_Swift-String-Obfuscator_ftn2z4ug
├── Makefile
├── Package.resolved
├── Package.swift
├── README.md
├── Sources
│   ├── SwiftStringObfuscatorCore
│   │   ├── Extensions.swift
│   │   ├── ObfuscateStringsRewritter.swift
│   │   └── StringObfuscator.swift
│   └── swift_string_obfuscator
│       └── main.swift
├── Tests
│   ├── LinuxMain.swift
│   └── SwiftStringObfuscatorTests
│       ├── SwiftStringObfuscatorTests.swift
│       └── XCTestManifests.swift
└── github
    ├── decompiled_string.png
    ├── string_in_app.png
    └── string_obfuscated.png

```

`Makefile`:

```
INSTALL_PATH = /usr/local/bin/swift_string_obfuscator

build:
	swift package update
	swift build -c release

install: build
	cp -f .build/release/swift_string_obfuscator $(INSTALL_PATH)

clean:
	rm -rf .build

uninstall:
	rm -f $(INSTALL_PATH)

xcode:
	swift package generate-xcodeproj
	xed .
```

`Package.resolved`:

```resolved
{
  "object": {
    "pins": [
      {
        "package": "swift-argument-parser",
        "repositoryURL": "https://github.com/apple/swift-argument-parser",
        "state": {
          "branch": null,
          "revision": "92646c0cdbaca076c8d3d0207891785b3379cbff",
          "version": "0.3.1"
        }
      },
      {
        "package": "SwiftSyntax",
        "repositoryURL": "https://github.com/apple/swift-syntax.git",
        "state": {
          "branch": null,
          "revision": "844574d683f53d0737a9c6d706c3ef31ed2955eb",
          "version": "0.50300.0"
        }
      }
    ]
  },
  "version": 1
}

```

`Package.swift`:

```swift
// swift-tools-version:5.3
import PackageDescription

let package = Package(
    name: "SwiftStringObfuscator",
    platforms: [
        .macOS(.v10_13),
    ],
    products: [
        .executable(name: "swift_string_obfuscator", targets: ["swift_string_obfuscator"]),
    ],
    dependencies: [
        .package(name: "SwiftSyntax", url: "https://github.com/apple/swift-syntax.git", .exact("0.50300.0")),
        .package(url: "https://github.com/apple/swift-argument-parser", from: "0.3.0"),
    ],
    targets: [
        .target(
            name: "swift_string_obfuscator",
            dependencies: [
                "SwiftStringObfuscatorCore",
                .product(name: "ArgumentParser", package: "swift-argument-parser"),
            ]
        ),
        .target(
            name: "SwiftStringObfuscatorCore",
            dependencies: ["SwiftSyntax"]
        ),
        .testTarget(
            name: "SwiftStringObfuscatorTests",
            dependencies: ["SwiftStringObfuscatorCore"]),
    ]
)

```

`README.md`:

```md
# Swift String Obfuscator

Are You storing more or less sensitive strings like API keys directly in the application code? For exaple like this:

![String stored in app](/github/string_in_app.png)


Do You know that's relatively easy for anyone to disassemble the application and get these strings?

![decompiled_string](/github/decompiled_string.png)



This utility convert strings annotated with a comment `//:obfuscate` into byte arrays and make them more complicated to find in disassembled code. It's not a bulletproof solution but it's better than leaving them readable at first sight.

![string_obfuscated](/github/string_obfuscated.png)



# Installation

Clone the repo and run `make install`.



# Usage

1. Install the `swift_string_obfuscator` utility

2. Annotate sensitive strings with a comment `\\:obfuscate`

3. Create a new Run Script Phase and run `swift_string_obfuscator` for files with sensitive strings. Source and target file could be the same. 

   Another possible solution is to use two files. One file, excluded from the build, with plain strings and second, with obfuscated strings included in the build.

   ```bash
   swift_string_obfuscator -s ${PROJECT_DIR}/SampleApp/API.swift -t ${PROJECT_DIR}/SampleApp/API.swift
   
   ```



## Sample

Input with plain strings.

```swift
    //:obfuscate
    let apiKey = "something-secret"

    //:obfuscate
    let apiKey2="something-secret-without-spaces"

    //:obfuscate
    //useless line, only for test purposes

    let nonObfuscated: String = "non-obfuscated-string"

    struct XStruct {
        let x: Int
        
        //:obfuscate
        let apiKey3 = "key-in-struct"
        
        //:obfuscate
        var param: String {
            return "key-in-computed-property"
        }
        
        //:obfuscate
        var dynamic2: String { "key-in-computed-property-2" }
    }

    class Y {
        //:obfuscate
        static let keyInClass: String = "api-key-in-class"

        func apiFuncParam(_ key: String) { return }
    }

    func test() {
        let testClass = Y()
        //:obfuscate
        testClass.apiFuncParam("api_key_func_param")
    }
```



Obfuscated output:

```swift
    //:obfuscate
    let apiKey = String(bytes: [115,111,109,101,116,104,105,110,103,45,115,101,99,114,101,116], encoding: .utf8)

    //:obfuscate
    let apiKey2=String(bytes: [115,111,109,101,116,104,105,110,103,45,115,101,99,114,101,116,45,119,105,116,104,111,117,116,45,115,112,97,99,101,115], encoding: .utf8)

    //:obfuscate
    //useless line, only for test purposes

    let nonObfuscated: String = "non-obfuscated-string"

    struct XStruct {
        let x: Int
        
        //:obfuscate
        let apiKey3 = String(bytes: [107,101,121,45,105,110,45,115,116,114,117,99,116], encoding: .utf8)
        
        //:obfuscate
        var param: String {
            return String(bytes: [107,101,121,45,105,110,45,99,111,109,112,117,116,101,100,45,112,114,111,112,101,114,116,121], encoding: .utf8)
        }
        
        //:obfuscate
        var dynamic2: String { String(bytes: [107,101,121,45,105,110,45,99,111,109,112,117,116,101,100,45,112,114,111,112,101,114,116,121,45,50], encoding: .utf8)}
    }

    class Y {
        //:obfuscate
        static let keyInClass: String = String(bytes: [97,112,105,45,107,101,121,45,105,110,45,99,108,97,115,115], encoding: .utf8)

        func apiFuncParam(_ key: String) { return }
    }

    func test() {
        let testClass = Y()
        //:obfuscate
        testClass.apiFuncParam(String(bytes: [97,112,105,95,107,101,121,95,102,117,110,99,95,112,97,114,97,109], encoding: .utf8))
    }
```


```

`Sources/SwiftStringObfuscatorCore/Extensions.swift`:

```swift
//
//  Extensions.swift
//  string_obfuscator
//
//  Created by Lukas Gergel on 27.12.2020.
//

import Foundation

extension String {
    var data: Data { .init(utf8) }
    var bytes: [UInt8] { .init(utf8) }
}

```

`Sources/SwiftStringObfuscatorCore/ObfuscateStringsRewritter.swift`:

```swift
//
//  ObfuscateStringsRewritter.swift
//  string_obfuscator
//
//  Created by Lukas Gergel on 01.01.2021.
//

import Foundation
import SwiftSyntax

enum State {
    case reading
    case command
}

class ObfuscateStringsRewritter: SyntaxRewriter {
    var state: State = .reading
    
    func integerLiteralElement(_ int: Int, addComma: Bool = true) -> ArrayElementSyntax {
        let literal = SyntaxFactory.makeIntegerLiteral("\(int)")
        return SyntaxFactory.makeArrayElement(
            expression: ExprSyntax(SyntaxFactory.makeIntegerLiteralExpr(digits: literal)),
            trailingComma: addComma ? SyntaxFactory.makeCommaToken() : nil)
    }

    override open func visit(_ node: StringLiteralExprSyntax) -> ExprSyntax {
        defer {
            state = .reading
        }
        guard case .command = state else { return super.visit(node) }
        let origValue = "\(node.segments)"
        let bytes = origValue.bytes.enumerated().map { (i, element) -> ArrayElementSyntax in
            integerLiteralElement(Int(element), addComma: i < origValue.bytes.count - 1)
        }
        let arrayElementList = SyntaxFactory.makeArrayElementList(bytes)

        let bytesArg = SyntaxFactory.makeTupleExprElement(
            label: SyntaxFactory.makeIdentifier("bytes"),
            colon: SyntaxFactory.makeColonToken(leadingTrivia: .zero, trailingTrivia: .spaces(1)),
            expression: ExprSyntax(SyntaxFactory.makeArrayExpr(
                leftSquare: SyntaxFactory.makeLeftSquareBracketToken(),
                elements: arrayElementList,
                rightSquare: SyntaxFactory.makeRightSquareBracketToken())),
            trailingComma: SyntaxFactory.makeCommaToken()
        )

        let encodingArg = SyntaxFactory.makeTupleExprElement(
            label: SyntaxFactory.makeIdentifier("encoding"),
            colon: SyntaxFactory.makeColonToken(leadingTrivia: .zero, trailingTrivia: .spaces(1)),
            expression: ExprSyntax(SyntaxFactory.makeIdentifierExpr(identifier: SyntaxFactory.makeIdentifier(".utf8"),
                                                                    declNameArguments: nil)),
            trailingComma: nil
        ).withLeadingTrivia(.spaces(1))

        let newCall =
            SyntaxFactory.makeFunctionCallExpr(
                calledExpression: ExprSyntax(
                    SyntaxFactory.makeIdentifierExpr(
                        identifier: SyntaxFactory.makeIdentifier("String"),
                        declNameArguments: nil
                    )
                ),
                leftParen: SyntaxFactory.makeLeftParenToken(),
                argumentList: SyntaxFactory.makeTupleExprElementList([bytesArg, encodingArg]),
                rightParen: SyntaxFactory.makeRightParenToken(),
                trailingClosure: nil,
                additionalTrailingClosures: nil
            )
        return super.visit(newCall)
    }

    override func visit(_ token: TokenSyntax) -> Syntax {
        let withoutSpaces = token.leadingTrivia.filter { if case .spaces = $0 { return false }; return true }
        guard withoutSpaces.count > 1 else { return super.visit(token) }
        let lastNewLine = withoutSpaces.last
        let commandLine = withoutSpaces[withoutSpaces.count-2]
        
        if state == .reading, case .newlines(1) = lastNewLine, case .lineComment("//:obfuscate") = commandLine {
            state = .command
        }
        return super.visit(token)
    }
}

struct FileHandlerOutputStream: TextOutputStream {
    private let fileHandle: FileHandle
    let encoding: String.Encoding

    init(_ fileHandle: FileHandle, encoding: String.Encoding = .utf8) {
        self.fileHandle = fileHandle
        self.encoding = encoding
    }

    mutating func write(_ string: String) {
        if let data = string.data(using: encoding) {
            fileHandle.write(data)
        }
    }
}

```

`Sources/SwiftStringObfuscatorCore/StringObfuscator.swift`:

```swift
//
//  StringObfuscator.swift
//
//
//  Created by Lukas Gergel on 02.01.2021.
//

import Foundation
import SwiftSyntax

public class StringObfuscator {
    public static func getObfuscatedContent(for sourceFile: URL) throws -> String {
        let sourceFile = try SyntaxParser.parse(sourceFile)
        var output = ""
        let obfuscated = ObfuscateStringsRewritter().visit(sourceFile)
        obfuscated.write(to: &output)
        return output
    }
    
    public static func obfuscateContent(sourceFile: URL, targetFile: URL) throws {
        let sourceFile = try SyntaxParser.parse(sourceFile)
        let fileHandle = try FileHandle(forWritingTo: targetFile)
        var output = FileHandlerOutputStream(fileHandle)
        let obfuscated = ObfuscateStringsRewritter().visit(sourceFile)
        obfuscated.write(to: &output)
    }
}

```

`Sources/swift_string_obfuscator/main.swift`:

```swift
//
//  main.swift
//  string_obfuscator
//
//  Created by Lukas Gergel on 27.12.2020.
//

import ArgumentParser
import Foundation
import SwiftStringObfuscatorCore

struct SwiftStringObfuscator: ParsableCommand {
    static let configuration = CommandConfiguration(
        abstract: "A Swift command-line tool to convert string api-keys to byte arrays.")

    @Option(name: .shortAndLong, help: "Source file name.")
    var sourceFile: String
    
    @Option(name: .shortAndLong, help: "Target file name.")
    var targetFile: String

    mutating func run() throws {
        let inUrl = URL(fileURLWithPath: sourceFile)
        let outUrl = URL(fileURLWithPath: targetFile)
        try! StringObfuscator.obfuscateContent(sourceFile: inUrl, targetFile: outUrl)
    }
}

SwiftStringObfuscator.main()

```

`Tests/LinuxMain.swift`:

```swift
import XCTest

import string_obfuscatorTests

var tests = [XCTestCaseEntry]()
tests += string_obfuscatorTests.allTests()
XCTMain(tests)

```

`Tests/SwiftStringObfuscatorTests/SwiftStringObfuscatorTests.swift`:

```swift
import XCTest
@testable import SwiftStringObfuscatorCore
import SwiftSyntax

final class SwiftStringObfuscatorTests: XCTestCase {
    
    let sampleFileURL = urlTempString("""
    //:obfuscate
    let apiKey = "something-secret"

    //:obfuscate
    let apiKey2="something-secret-without-spaces"

    //:obfuscate
    //useless line, only for test purposes

    let nonObfuscated: String = "non-obfuscated-string"

    struct XStruct {
        let x: Int
        
        //:obfuscate
        let apiKey3 = "key-in-struct"
        
        //:obfuscate
        var param: String {
            return "key-in-computed-property"
        }
        
        //:obfuscate
        var dynamic2: String { "key-in-computed-property-2" }
    }

    class Y {
        //:obfuscate
        static let keyInClass: String = "api-key-in-class"

        func apiFuncParam(_ key: String) { return }
    }

    func test() {
        let testClass = Y()
        //:obfuscate
        testClass.apiFuncParam("api_key_func_param")
    }
    """)
    
    let sampleObfuscatedOutput = """
    //:obfuscate
    let apiKey = String(bytes: [115,111,109,101,116,104,105,110,103,45,115,101,99,114,101,116], encoding: .utf8)

    //:obfuscate
    let apiKey2=String(bytes: [115,111,109,101,116,104,105,110,103,45,115,101,99,114,101,116,45,119,105,116,104,111,117,116,45,115,112,97,99,101,115], encoding: .utf8)

    //:obfuscate
    //useless line, only for test purposes

    let nonObfuscated: String = "non-obfuscated-string"

    struct XStruct {
        let x: Int
        
        //:obfuscate
        let apiKey3 = String(bytes: [107,101,121,45,105,110,45,115,116,114,117,99,116], encoding: .utf8)
        
        //:obfuscate
        var param: String {
            return String(bytes: [107,101,121,45,105,110,45,99,111,109,112,117,116,101,100,45,112,114,111,112,101,114,116,121], encoding: .utf8)
        }
        
        //:obfuscate
        var dynamic2: String { String(bytes: [107,101,121,45,105,110,45,99,111,109,112,117,116,101,100,45,112,114,111,112,101,114,116,121,45,50], encoding: .utf8)}
    }

    class Y {
        //:obfuscate
        static let keyInClass: String = String(bytes: [97,112,105,45,107,101,121,45,105,110,45,99,108,97,115,115], encoding: .utf8)

        func apiFuncParam(_ key: String) { return }
    }

    func test() {
        let testClass = Y()
        //:obfuscate
        testClass.apiFuncParam(String(bytes: [97,112,105,95,107,101,121,95,102,117,110,99,95,112,97,114,97,109], encoding: .utf8))
    }
    """
    
    func testObfuscator() throws {
        let obfuscated = try? StringObfuscator.getObfuscatedContent(for: sampleFileURL)
        XCTAssertEqual(obfuscated, sampleObfuscatedOutput)
    }

    static var allTests = [("testObfuscator", testObfuscator)]
    
    static func urlTempString(_ str: String) -> URL {
        let directory = NSTemporaryDirectory()
        let fileName = NSUUID().uuidString
        let fullURL = NSURL.fileURL(withPathComponents: [directory, fileName])!
        
        try! str.write(to: fullURL, atomically: true, encoding: .utf8)
        
        return fullURL
    }
}

```

`Tests/SwiftStringObfuscatorTests/XCTestManifests.swift`:

```swift
import XCTest

#if !canImport(ObjectiveC)
public func allTests() -> [XCTestCaseEntry] {
    return [
        testCase(string_obfuscatorTests.allTests),
    ]
}
#endif

```