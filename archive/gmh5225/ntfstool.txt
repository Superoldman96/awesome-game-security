Project Path: arc_gmh5225_ntfstool_4xuyw3j3

Source Tree:

```txt
arc_gmh5225_ntfstool_4xuyw3j3
├── Docs
│   ├── ADS
│   │   └── Alternate Data Streams - Out of the shadows and into the light.pdf
│   ├── Bitlocker
│   │   ├── AES-CBC + Elephant diffuser - A Disk Encryption Algorithm for Windows Vista.pdf
│   │   ├── BitCracker - BitLocker meets GPUs.pdf
│   │   ├── BitLocker Drive Encryption (BDE) format specification.pdf
│   │   ├── Forensic Decryption of FAT BitLocker Volumes.pdf
│   │   ├── SSTIC2011-Article-bitlocker-bordes.pdf
│   │   ├── Windows 7 BitLocker™ Drive Encryption Security Policy.pdf
│   │   ├── nvbit_bitlocker_presentation.pdf
│   │   └── nvbit_bitlocker_white_paper.pdf
│   ├── Forensics
│   │   ├── NTFS Log Tracker.pdf
│   │   └── UsnJrnl Parsing for File System History.pdf
│   └── NTFS
│       ├── NTFS_internals.pdf
│       ├── ntfs_cheat_sheets.pdf
│       └── ntfsdoc.pdf
├── LICENSE
├── NTFS.sln
├── NTFS.vcxproj
├── README.md
├── SECURITY.md
├── Sources
│   ├── Bitlocker
│   │   ├── bek.cpp
│   │   ├── bek.h
│   │   ├── bitlocker.cpp
│   │   ├── bitlocker.h
│   │   ├── decryption.cpp
│   │   ├── decryption.h
│   │   ├── fve.h
│   │   ├── password.cpp
│   │   ├── password.h
│   │   ├── recovery.cpp
│   │   └── recovery.h
│   ├── Commands
│   │   ├── command_bitdecrypt.cpp
│   │   ├── command_bitlocker.cpp
│   │   ├── command_btree.cpp
│   │   ├── command_efs_backup.cpp
│   │   ├── command_efs_certificate.cpp
│   │   ├── command_efs_decrypt.cpp
│   │   ├── command_efs_key.cpp
│   │   ├── command_efs_masterkey.cpp
│   │   ├── command_extract.cpp
│   │   ├── command_fve.cpp
│   │   ├── command_gpt.cpp
│   │   ├── command_help.cpp
│   │   ├── command_image.cpp
│   │   ├── command_info.cpp
│   │   ├── command_logfile.cpp
│   │   ├── command_mbr.cpp
│   │   ├── command_mft.cpp
│   │   ├── command_reparse.cpp
│   │   ├── command_shadow.cpp
│   │   ├── command_shell.cpp
│   │   ├── command_smart.cpp
│   │   ├── command_streams.cpp
│   │   ├── command_undelete.cpp
│   │   ├── command_usn.cpp
│   │   ├── command_vbr.cpp
│   │   ├── commands.cpp
│   │   └── commands.h
│   ├── Compression
│   │   ├── lznt1.cpp
│   │   ├── lznt1.h
│   │   ├── lzx.cpp
│   │   ├── lzx.h
│   │   ├── ntdll_defs.h
│   │   ├── xpress.cpp
│   │   └── xpress.h
│   ├── Drive
│   │   ├── disk.cpp
│   │   ├── disk.h
│   │   ├── mbr_gpt.h
│   │   ├── reader.cpp
│   │   ├── reader.h
│   │   ├── smart.h
│   │   ├── vbr.h
│   │   ├── virtual_disk.cpp
│   │   ├── virtual_disk.h
│   │   ├── volume.cpp
│   │   └── volume.h
│   ├── EFS
│   │   ├── certificate_file.cpp
│   │   ├── certificate_file.h
│   │   ├── export_flags.h
│   │   ├── export_flags_enc.cpp
│   │   ├── export_flags_enc.h
│   │   ├── fek.h
│   │   ├── key_file.cpp
│   │   ├── key_file.h
│   │   ├── masterkey_file.cpp
│   │   ├── masterkey_file.h
│   │   ├── pkcs12_archive.cpp
│   │   ├── pkcs12_archive.h
│   │   ├── private_key.cpp
│   │   ├── private_key.h
│   │   ├── private_key_enc.cpp
│   │   ├── private_key_enc.h
│   │   ├── public_key.cpp
│   │   └── public_key.h
│   ├── NTFS
│   │   ├── ntfs.h
│   │   ├── ntfs_explorer.cpp
│   │   ├── ntfs_explorer.h
│   │   ├── ntfs_index_entry.cpp
│   │   ├── ntfs_index_entry.h
│   │   ├── ntfs_mft.cpp
│   │   ├── ntfs_mft.h
│   │   ├── ntfs_mft_record.cpp
│   │   ├── ntfs_mft_record.h
│   │   ├── ntfs_reader.cpp
│   │   └── ntfs_reader.h
│   ├── Utils
│   │   ├── btree.cpp
│   │   ├── btree.h
│   │   ├── buffer.h
│   │   ├── constant_names.cpp
│   │   ├── constant_names.h
│   │   ├── crash_handler.cpp
│   │   ├── crash_handler.h
│   │   ├── index_details.cpp
│   │   ├── index_details.h
│   │   ├── progress_bar.h
│   │   ├── table.cpp
│   │   ├── table.h
│   │   ├── utils.cpp
│   │   └── utils.h
│   ├── main.cpp
│   ├── options.cpp
│   └── options.h
└── vcpkg.json

```

`LICENSE`:

```
MIT License

Copyright (c) 2019 thewhiteninja

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`NTFS.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28803.156
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ntfstool", "NTFS.vcxproj", "{ED7F20A1-18AD-40D1-9CAE-5D613616F2F7}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{ED7F20A1-18AD-40D1-9CAE-5D613616F2F7}.Debug|x64.ActiveCfg = Debug|x64
		{ED7F20A1-18AD-40D1-9CAE-5D613616F2F7}.Debug|x64.Build.0 = Debug|x64
		{ED7F20A1-18AD-40D1-9CAE-5D613616F2F7}.Debug|x86.ActiveCfg = Debug|Win32
		{ED7F20A1-18AD-40D1-9CAE-5D613616F2F7}.Debug|x86.Build.0 = Debug|Win32
		{ED7F20A1-18AD-40D1-9CAE-5D613616F2F7}.Release|x64.ActiveCfg = Release|x64
		{ED7F20A1-18AD-40D1-9CAE-5D613616F2F7}.Release|x64.Build.0 = Release|x64
		{ED7F20A1-18AD-40D1-9CAE-5D613616F2F7}.Release|x86.ActiveCfg = Release|Win32
		{ED7F20A1-18AD-40D1-9CAE-5D613616F2F7}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F578E55A-EB10-4D4A-9F4E-C74DCB58DE73}
	EndGlobalSection
EndGlobal

```

`NTFS.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Sources\Bitlocker\bek.h" />
    <ClInclude Include="Sources\Bitlocker\bitlocker.h" />
    <ClInclude Include="Sources\Bitlocker\decryption.h" />
    <ClInclude Include="Sources\Bitlocker\fve.h" />
    <ClInclude Include="Sources\Bitlocker\password.h" />
    <ClInclude Include="Sources\Bitlocker\recovery.h" />
    <ClInclude Include="Sources\Commands\commands.h" />
    <ClInclude Include="Sources\Compression\lznt1.h" />
    <ClInclude Include="Sources\Compression\ntdll_defs.h" />
    <ClInclude Include="Sources\Compression\lzx.h" />
    <ClInclude Include="Sources\Compression\xpress.h" />
    <ClInclude Include="Sources\Drive\disk.h" />
    <ClInclude Include="Sources\Drive\mbr_gpt.h" />
    <ClInclude Include="Sources\Drive\reader.h" />
    <ClInclude Include="Sources\Drive\smart.h" />
    <ClInclude Include="Sources\Drive\vbr.h" />
    <ClInclude Include="Sources\Drive\virtual_disk.h" />
    <ClInclude Include="Sources\Drive\volume.h" />
    <ClInclude Include="Sources\EFS\certificate_file.h" />
    <ClInclude Include="Sources\EFS\export_flags.h" />
    <ClInclude Include="Sources\EFS\export_flags_enc.h" />
    <ClInclude Include="Sources\EFS\fek.h" />
    <ClInclude Include="Sources\EFS\key_file.h" />
    <ClInclude Include="Sources\EFS\masterkey_file.h" />
    <ClInclude Include="Sources\EFS\pkcs12_archive.h" />
    <ClInclude Include="Sources\EFS\private_key.h" />
    <ClInclude Include="Sources\EFS\private_key_enc.h" />
    <ClInclude Include="Sources\EFS\public_key.h" />
    <ClInclude Include="Sources\NTFS\ntfs.h" />
    <ClInclude Include="Sources\NTFS\ntfs_explorer.h" />
    <ClInclude Include="Sources\NTFS\ntfs_index_entry.h" />
    <ClInclude Include="Sources\NTFS\ntfs_mft.h" />
    <ClInclude Include="Sources\NTFS\ntfs_mft_record.h" />
    <ClInclude Include="Sources\NTFS\ntfs_reader.h" />
    <ClInclude Include="Sources\options.h" />
    <ClInclude Include="Sources\Utils\buffer.h" />
    <ClInclude Include="Sources\Utils\constant_names.h" />
    <ClInclude Include="Sources\Utils\crash_handler.h" />
    <ClInclude Include="Sources\Utils\index_details.h" />
    <ClInclude Include="Sources\Utils\progress_bar.h" />
    <ClInclude Include="Sources\Utils\table.h" />
    <ClInclude Include="Sources\Utils\btree.h" />
    <ClInclude Include="Sources\Utils\utils.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Sources\Bitlocker\bek.cpp" />
    <ClCompile Include="Sources\Bitlocker\bitlocker.cpp" />
    <ClCompile Include="Sources\Bitlocker\decryption.cpp" />
    <ClCompile Include="Sources\Bitlocker\password.cpp" />
    <ClCompile Include="Sources\Bitlocker\recovery.cpp" />
    <ClCompile Include="Sources\Commands\commands.cpp" />
    <ClCompile Include="Sources\Commands\command_bitdecrypt.cpp" />
    <ClCompile Include="Sources\Commands\command_bitlocker.cpp" />
    <ClCompile Include="Sources\Commands\command_btree.cpp" />
    <ClCompile Include="Sources\Commands\command_efs_backup.cpp" />
    <ClCompile Include="Sources\Commands\command_efs_certificate.cpp" />
    <ClCompile Include="Sources\Commands\command_efs_decrypt.cpp" />
    <ClCompile Include="Sources\Commands\command_efs_key.cpp" />
    <ClCompile Include="Sources\Commands\command_efs_masterkey.cpp" />
    <ClCompile Include="Sources\Commands\command_extract.cpp" />
    <ClCompile Include="Sources\Commands\command_image.cpp" />
    <ClCompile Include="Sources\Commands\command_logfile.cpp" />
    <ClCompile Include="Sources\Commands\command_reparse.cpp" />
    <ClCompile Include="Sources\Commands\command_shadow.cpp" />
    <ClCompile Include="Sources\Commands\command_shell.cpp" />
    <ClCompile Include="Sources\Commands\command_fve.cpp" />
    <ClCompile Include="Sources\Commands\command_mft.cpp" />
    <ClCompile Include="Sources\Commands\command_smart.cpp" />
    <ClCompile Include="Sources\Commands\command_streams.cpp" />
    <ClCompile Include="Sources\Commands\command_undelete.cpp" />
    <ClCompile Include="Sources\Commands\command_usn.cpp" />
    <ClCompile Include="Sources\Commands\command_vbr.cpp" />
    <ClCompile Include="Sources\Commands\command_gpt.cpp" />
    <ClCompile Include="Sources\Commands\command_help.cpp" />
    <ClCompile Include="Sources\Commands\command_info.cpp" />
    <ClCompile Include="Sources\Commands\command_mbr.cpp" />
    <ClCompile Include="Sources\Compression\lznt1.cpp" />
    <ClCompile Include="Sources\Compression\lzx.cpp" />
    <ClCompile Include="Sources\Compression\xpress.cpp" />
    <ClCompile Include="Sources\Drive\disk.cpp" />
    <ClCompile Include="Sources\Drive\reader.cpp" />
    <ClCompile Include="Sources\Drive\virtual_disk.cpp" />
    <ClCompile Include="Sources\Drive\volume.cpp" />
    <ClCompile Include="Sources\EFS\certificate_file.cpp" />
    <ClCompile Include="Sources\EFS\export_flags_enc.cpp" />
    <ClCompile Include="Sources\EFS\key_file.cpp" />
    <ClCompile Include="Sources\EFS\masterkey_file.cpp" />
    <ClCompile Include="Sources\EFS\pkcs12_archive.cpp" />
    <ClCompile Include="Sources\EFS\private_key.cpp" />
    <ClCompile Include="Sources\EFS\private_key_enc.cpp" />
    <ClCompile Include="Sources\EFS\public_key.cpp" />
    <ClCompile Include="Sources\main.cpp" />
    <ClCompile Include="Sources\NTFS\ntfs_explorer.cpp" />
    <ClCompile Include="Sources\NTFS\ntfs_index_entry.cpp" />
    <ClCompile Include="Sources\NTFS\ntfs_mft.cpp" />
    <ClCompile Include="Sources\NTFS\ntfs_mft_record.cpp" />
    <ClCompile Include="Sources\NTFS\ntfs_reader.cpp" />
    <ClCompile Include="Sources\options.cpp" />
    <ClCompile Include="Sources\Utils\constant_names.cpp" />
    <ClCompile Include="Sources\Utils\crash_handler.cpp" />
    <ClCompile Include="Sources\Utils\index_details.cpp" />
    <ClCompile Include="Sources\Utils\table.cpp" />
    <ClCompile Include="Sources\Utils\btree.cpp" />
    <ClCompile Include="Sources\Utils\utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="LICENSE" />
    <None Include="README.md" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{ED7F20A1-18AD-40D1-9CAE-5D613616F2F7}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>ntfstool</ProjectName>
    <VcpkgTriplet Condition="'$(Platform)'=='Win32'">
    </VcpkgTriplet>
    <VcpkgTriplet Condition="'$(Platform)'=='x64'">
    </VcpkgTriplet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <EnableASAN>
    </EnableASAN>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <EnableASAN>false</EnableASAN>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <EnableASAN>
    </EnableASAN>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <EnableASAN>false</EnableASAN>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>
    </LinkIncremental>
    <OutDir>$(SolutionDir)Builds\$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(SolutionDir)Builds\$(Configuration)\Temp\</IntDir>
    <SourcePath>$(VC_SourcePath);</SourcePath>
    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86);$(NETFXKitsDir)Lib\um\x86</LibraryPath>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <EnableClangTidyCodeAnalysis>false</EnableClangTidyCodeAnalysis>
    <EnableMicrosoftCodeAnalysis>true</EnableMicrosoftCodeAnalysis>
    <TargetName>$(ProjectName).$(PlatformTarget)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>
    </LinkIncremental>
    <OutDir>$(SolutionDir)Builds\$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(SolutionDir)Builds\$(Configuration)\Temp\</IntDir>
    <EnableClangTidyCodeAnalysis>false</EnableClangTidyCodeAnalysis>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
    <TargetName>$(ProjectName).$(PlatformTarget)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)Builds\$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(SolutionDir)Builds\$(Configuration)\Temp\</IntDir>
    <SourcePath>Sources</SourcePath>
    <LinkIncremental />
    <EnableClangTidyCodeAnalysis>false</EnableClangTidyCodeAnalysis>
    <EnableMicrosoftCodeAnalysis>true</EnableMicrosoftCodeAnalysis>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <TargetName>$(ProjectName).$(PlatformTarget)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)Builds\$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(SolutionDir)Builds\$(Configuration)\Temp\</IntDir>
    <SourcePath>Sources</SourcePath>
    <LinkIncremental>
    </LinkIncremental>
    <EnableClangTidyCodeAnalysis>false</EnableClangTidyCodeAnalysis>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
    <TargetName>$(ProjectName).$(PlatformTarget)</TargetName>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>Sources;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <FavorSizeOrSpeed />
      <MinimalRebuild>false</MinimalRebuild>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalOptions>/await %(AdditionalOptions)</AdditionalOptions>
      <EnablePREfast>false</EnablePREfast>
      <DisableSpecificWarnings>26812</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
      <IgnoreAllDefaultLibraries>
      </IgnoreAllDefaultLibraries>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_SILENCE_CLANG_COROUTINE_MESSAGE;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <AdditionalIncludeDirectories>Sources;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <Optimization>MinSpace</Optimization>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <FavorSizeOrSpeed />
      <AdditionalOptions>/await %(AdditionalOptions)</AdditionalOptions>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MinimalRebuild>false</MinimalRebuild>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
      <IgnoreAllDefaultLibraries>
      </IgnoreAllDefaultLibraries>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <SubSystem>Console</SubSystem>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>Sources;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <WarningLevel>Level3</WarningLevel>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalOptions>/await %(AdditionalOptions)</AdditionalOptions>
      <MinimalRebuild>false</MinimalRebuild>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <AdditionalIncludeDirectories>Sources;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PreprocessorDefinitions>_CONSOLE;_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS;</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <AdditionalOptions>/await %(AdditionalOptions)</AdditionalOptions>
      <Optimization>MinSpace</Optimization>
      <MinimalRebuild>false</MinimalRebuild>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`README.md`:

```md
# ntfstool

[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE.MIT)
[![Language: C++](https://img.shields.io/badge/Language-C%2B%2B-brightgreen.svg?tyle=flat-square)](#)
[![x64](https://img.shields.io/badge/Windows-64_bit-0078d7.svg)](#)
[![x86](https://img.shields.io/badge/Windows-32_bit-0078d7.svg)](#)
[![v1.5](https://img.shields.io/badge/Version-1.5-ff5733.svg)](#)
[![Build](https://ci.appveyor.com/api/projects/status/a3cn5dpdv146tdji?svg=true)](https://ci.appveyor.com/project/thewhiteninja/ntfstool)

<img align="right" width="100" height="100" src="https://cdn-icons-png.flaticon.com/512/3850/3850133.png">

<br />

NTFSTool is a forensic tool focused on [NTFS][10] volumes.
It supports reading partition info (mbr, partition table, vbr) but also information on master file table, bitlocker encrypted volume, EFS encrypted files and more.

Download the latest binaries on [AppVeyor](https://ci.appveyor.com/project/thewhiteninja/ntfstool).

See below for some [examples](#examples) of the features!


## Features

### Forensics

NTFSTool displays the complete structure of master boot record, volume boot record, partition table and [MFT][8] file record.
It is also possible to dump any file (even $mft or [SAM][9]) or parse [USN journals][6], [LogFile][7] including streams from Alternate Data Stream ([ADS][5]).
The undelete command will search for any file record marked as "not in use" and allow you to retrieve the file (or part of the file if it was already rewritten).
It support input from image file, live disk or virtual like [VeraCrypt][11] and [TrueCrypt][12], but you can also use tools like [OSFMount][3] to mount your disk image.
Sparse and compressed files (lznt1, xpress) are also supported. 

[3]: https://www.osforensics.com/tools/mount-disk-images.html
[5]: https://www.sans.org/white-papers/1503/
[6]: https://docs.microsoft.com/en-gb/windows/win32/fileio/change-journal-records
[7]: https://dfir.ru/2019/02/16/how-the-logfile-works/
[8]: https://en.wikipedia.org/wiki/NTFS#Master_File_Table
[9]: https://en.wikipedia.org/wiki/Security_Account_Manager
[10]: https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc781134(v=ws.10)?redirectedfrom=MSDN
[11]: https://www.veracrypt.fr/en/Home.html
[12]: http://truecrypt.sourceforge.net/

### Bitlocker support

For bitlocked partition, it can display FVE records, check a password and key (bek, password, recovery key), extract VMK and FVEK.
There is no bruteforce feature because GPU-based cracking is better (see [Bitcracker][1] and [Hashcat][2]) but you can get the hash for these tools.

[1]: https://arxiv.org/pdf/1901.01337
[2]: https://hashcat.net/hashcat/

### EFS support

Masterkeys, private keys and certificates can be listed, displayed and decrypted using needed inputs (SID, password).
Certificates with private keys can be exported using the backup command.

Reinmport the backup on another machine to be able to read your encrypted file again!
Or you can use the `efs.decrypt` command to decrypt a file using the backed-up key.

More information on [Mimikatz Wiki][4] 

[4]: https://github.com/gentilkiwi/mimikatz/wiki/howto-~-decrypt-EFS-files#installing-the-pfx

### Shell

There is a limited shell with few commands (exit, cd, ls, cat, pwd, cp, quit, rec).

Command `rec` shows the MFT record details.

## Help & Examples

Help command displays description and examples for each command.

Options can be entered as decimal or hex number with "0x" prefix (ex: inode).

    ntfstool help [command]
    
| Command | Description |
| --- | --- |
| [info](#info) | Display information for all disks and volumes |
| [mbr](#mbr) | Display MBR structure, code and partitions for a disk |
| [gpt](#gpt) | Display GPT structure, code  and partitions for a disk |
| [vbr](#vbr)  | Display VBR structure and code for a specidifed volume (ntfs, fat32, fat1x, bitlocker supported) |
| [extract](#extract)  | Extract a file from a volume. |
| [image](#image)  | Create an image file of a disk or volume. |
| [mft.record](#mft-record)  | Display FILE record details for a specified MFT inode. Almost all attribute types supported |
| [mft.btree](#mft-btree)  | Display VCN content and Btree index for an inode |
| [bitlocker](#bitlocker)  | Display detailed information and hash ($bitlocker$) for all VMK. It is possible to test a password or recovery key. If it is correct, the decrypted VMK and FVEK is displayed. |
| [bitdecrypt](#bitdecrypt)  | Decrypt a volume to a file using password, recovery key or bek. |
| [efs.backup](#efs-backup)  | Export EFS keys in PKCS12 (pfx) format. |
| [efs.decrypt](#efs-decrypt)  | Decrypt EFS encrypted file using keys in PKCS12 (pfx) format. |
| [efs.certificate](#efs-certificate)  | List, display and export system certificates (SystemCertificates/My/Certificates). |
| [efs.key](#efs-key)  | List, display, decrypt and export private keys (Crypto/RSA). |
| [efs.masterkey](#efs-masterkey)  | List, display and decrypt masterkeys (Protect). |
| [fve](#fve)  | Display information for the specified FVE block (0, 1, 2) |
| [reparse](#reparse)  | Parse and display reparse points from \$Extend\$Reparse. |
| [logfile](#logfile)  | Dump $LogFile file in specified format: csv, json, raw. |
| [usn](#usn)  | Dump $UsnJrnl file  in specified format: csv, json, raw. |
| [shadow](#shadow)  | List volume shadow snapshots from selected disk and volume. |
| [streams](#streams)   | Display Alternate Data Streams |
| [undelete](#undelete)  | Search and extract deleted files for a volume. |
| [shell](#shell-1)   | Start a mini Unix-like shell |
| [smart](#smart)  | Display S.M.A.R.T data |


## Limitations

- Some unsupported cases. WIP.
- No documentation :no_mouth:.

Feel free to open an issue or ask for a new feature!

## Build
    
- Install [Visual Studio 2022](https://visualstudio.microsoft.com/fr/vs/)
    
- Install vcpkg (for required third-party libs) as described here: [vcpkg#getting-started](https://github.com/microsoft/vcpkg#getting-started)

	```
	git clone https://github.com/microsoft/vcpkg
	.\vcpkg\bootstrap-vcpkg.bat
	```

- Integrate it to your VisualStudio env:

	```
	vcpkg integrate install
	```

At build time, VisualStudio will detect the `vcpkg.json` file and install required packages automatically.

Current third-party libs:
- [openssl](https://www.openssl.org/): OpenSSL is an open source project that provides a robust, commercial-grade, and full-featured toolkit for the Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols.
- [nlohmann-json](https://github.com/nlohmann/json): JSON for Modern C++
- [distorm](https://github.com/gdabah/distorm): Powerful Disassembler Library For x86/AMD64
- [cppcoro](https://github.com/lewissbaker/cppcoro): A library of C++ coroutine abstractions for the coroutines TS.


## Examples

### Info
<table>
<tr><td>info</td></tr>
<tr><td>

    +-------------------------------------------------------------------------------------+
    | Id | Model                     | Type      | Partition | Size                       |
    +-------------------------------------------------------------------------------------+
    | 0  | Samsung SSD 850 EVO 500GB | Fixed SSD | GPT       | 500107862016 (465.76 GiBs) |
    | 1  | ST2000DM001-1ER164        | Fixed HDD | GPT       | 2000398934016 (1.82 TiB)   |
    | 2  | 15EADS External           | Fixed HDD | MBR       | 1500301910016 (1.36 TiB)   |
    | 3  | osfdisk                   | Fixed HDD | MBR       | 536870912 (512.00 MiBs)    |
    +-------------------------------------------------------------------------------------+
</td></tr>
<tr><td>info disk=3</td></tr>
<tr><td>

    Model       : osfdisk
    Version     : 1
    Serial      :
    Media Type  : Fixed HDD
    Size        : 536870912 (512.00 MiBs)
    Geometry    : 512 bytes * 63 sectors * 255 tracks * 65 cylinders
    Volume      : MBR

    +--------------------------------------------------------------------------------------------------+
    | Id | Boot | Label     | Mounted | Filesystem | Offset           | Size                           |
    +--------------------------------------------------------------------------------------------------+
    | 1  | No   | NTFSDRIVE | F:\     | Bitlocker  | 0000000000000200 | 000000001ffffe00 (512.00 MiBs) |
    +--------------------------------------------------------------------------------------------------+   
</td></tr>
<tr><td>info disk=3 volume=1</td></tr>
<tr><td>

    Serial Number  : 0000aa60-00002eae
    Filesystem     : Bitlocker
    Bootable       : False
    Type           : Fixed
    Label          : NTFSDRIVE
    Offset         : 512 (512.00 bytes)
    Size           : 536870400 (512.00 MiBs)
    Free           : 519442432 (495.38 MiBs)
    Mounted        : True (F:\)
    Bitlocker      : True (Unlocked)
</td></tr>
</table>


### MBR
<table>
<tr><td>mbr disk=2</td></tr>
<tr><td>

    Disk signature  : e4589462
    Reserved bytes  : 0000
    
    Partition table :
    +---------------------------------------------------------------------------------------------------+
    | Id | Boot | Flags     | Filesystem   | First sector | Last sector | Offset | Sectors  | Size      |
    +---------------------------------------------------------------------------------------------------+
    | 1  | No   | Principal | NTFS / exFAT | 0 2 3        | 255 254 255 | 128    | 16771072 | 8.00 GiBs |
    +---------------------------------------------------------------------------------------------------+
    
    MBR signature  : 55aa
    
    Strings:
        [63] : Invalid partition table
        [7b] : Error loading operating system
        [9a] : Missing operating system
    
    Disassemble Bootstrap Code [y/N] ? y
    
        0000 : 33c0           : xor ax, ax
        0002 : 8ed0           : mov ss, ax
        0004 : bc007c         : mov sp, 0x7c00
        0007 : 8ec0           : mov es, ax
        0009 : 8ed8           : mov ds, ax
        000b : be007c         : mov si, 0x7c00
        000e : bf0006         : mov di, 0x600
        0011 : b90002         : mov cx, 0x200
	... 
</td></tr>
</table>


### GPT
<table>
<tr><td>gpt disk=1</td></tr>
<tr><td>

    Signature        : EFI PART
    Revision         : 1.0
    Header Size      : 92
    Header CRC32     : cc72e4d3
    Reserved         : 00000000
    Current LBA      : 1
    Backup LBA       : 3907029167
    First Usable LBA : 34
    Last Usable LBA  : 3907029134
    GUID             : {a21d6495-cd58-4b8d-b968-dc337adcf6ac}
    Entry LBA        : 2
    Entries Num      : 128
    Entries Size     : 128
    Partitions CRC32 : 0c9a0a25

    Partition table  : 2 entries
    +------------------------------------------------------------------------------------------------------------------------+
    | Id | Name                         | GUID                                   | First sector | Last sector | Flags        |
    +------------------------------------------------------------------------------------------------------------------------+
    | 1  | Microsoft reserved partition | {da0ac4a1-a78c-4053-bab5-36c70a71fe63} | 34           | 262177      | 000000000000 |
    | 2  | Basic data partition         | {4b4ea4b3-64a1-4c6d-bd4b-1c2b0e4e706f} | 264192       | 3907028991  | 000000000000 |
    +------------------------------------------------------------------------------------------------------------------------+
</td></tr>
</table>



### VBR
<table>
<tr><td>vbr disk=3 volume=1</td></tr>
<tr><td>

    Structure :
        Jump             : eb5890 (jmp 0x7c5a)
        OEM id           : -FVE-FS-
        BytePerSector    : 512
        SectorPerCluster : 8
        Reserved Sectors : 0
        Number of FATs   : 0
        Root Max Entries : 0
        Total Sectors    : 0
        Media Type       : f8
        SectorPerFat     : 8160
        SectorPerTrack   : 63
        Head Count       : 255
        FS Offset        : 1
        Total Sectors    : 0
        FAT Flags        : 0000
        FAT Version      : 0000
        Root Cluster     : 0
        FS Info Sector   : 1
        Backup BootSector: 6
        Reserved         : 00000000
        Reserved         : 00000000
        Reserved         : 00000000
        Drive Number     : 80
        Reserved         : 00
        Ext. Boot Sign   : 29
        Serial Number    : 00000000
        Volume Name      : NO NAME
        FileSystem Type  : FAT32
        Volume GUID      : {4967d63b-2e29-4ad8-8399-f6a339e3d001}
        FVE Block 1      : 0000000002100000
        FVE Block 2      : 00000000059e4000
        FVE Block 3      : 00000000092c8000
        End marker       : 55aa

    Strings:
        [00] : Remove disks or other media. 
        [1f] : Disk error 
        [2c] : Press any key to restart

    Disassemble Bootstrap Code [y/N] ? y

        7c5a : eb58           : jmp 0x7cb4
        7c5c : 90             : nop
        7c5d : 2d4656         : sub ax, 0x5646
        7c60 : 45             : inc bp
        7c61 : 2d4653         : sub ax, 0x5346
        7c64 : 2d0002         : sub ax, 0x200
        ...
</td></tr>
</table>


### Extract
<table>
<tr><td>extract disk=0 volume=4 inode=0 output=d:\mymft</td></tr>
<tr><td>

    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [-] Record Num  : 0 (00000000h)
    [-] Destination : d:\mymft
    [+] File extracted (5123541 bytes written)
</td></tr>
<tr><td>extract disk=3 volume=1 from=\bob.txt output=d:\bob.txt</td></tr>
<tr><td>

    [+] Opening \\?\Volume{00023d5d-0000-0000-0002-000000000000}\
    [-] Record Num  : 47 (0000002fh)
    [-] Destination : d:\bob.txt
    [+] File extracted (42 bytes written)
</td></tr>
<tr><td>extract disk=0 volume=4 --system output=d:\system</td></tr>
<tr><td>

    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [-] Record Num  : 623636 (00098414h)
    [-] Destination : d:\system
    [+] File extracted (19398656 bytes written)
</td></tr>
</table>

### Image
<table>
<tr><td>image disk=2 volume=2 output=d:\imagevol.raw</td></tr>
<tr><td>

    [+] Opening \\?\Volume{f095dd1d-f302-4d17-bf68-7cc8c1de3965}\
    [-] Size     : 33520128 (31.97 MiBs)
    [-] BlockSize: 4096
    [+] Copying  : [################################] 100% 0s
    [+] Done
</td></tr>
<tr><td>image disk=2 output=d:\image.raw</td></tr>
<tr><td>
    
    [+] Opening \\.\PhysicalDrive2
    [-] Size     : 67108864 (64.00 MiBs)
    [-] BlockSize: 4096
    [+] Copying  : [################################] 100% 0s
    [+] Done
</td></tr>
</table>


### MFT-record
<table>
<tr><td>mft.record disk=2 volume=1 inode=5 (root folder)</td></tr>
<tr><td>
  
    Signature         : FILE
    Update Offset     : 48
    Update Number     : 3
    $LogFile LSN      : 274035114
    Sequence Number   : 5
    Hardlink Count    : 1
    Attribute Offset  : 56
    Flags             : In_use | Directory
    Real Size         : 704
    Allocated Size    : 1024
    Base File Record  : 0
    Next Attribute ID : 56
    MFT Record Index  : 5
    Update Seq Number : 4461
    Update Seq Array  : 00000000

    Attributes:
    -----------

    +------------------------------------------------------------------------------------------------------------------+
    | Id | Type                   | Non-resident | Length | Overview                                                   |
    +------------------------------------------------------------------------------------------------------------------+
    | 1  | $STANDARD_INFORMATION  | False        | 72     | File Created Time       : 2009-12-02 02:03:31              |
    |    |                        |              |        | Last File Write Time    : 2020-02-24 19:42:23              |
    |    |                        |              |        | FileRecord Changed Time : 2020-02-24 19:42:23              |
    |    |                        |              |        | Last Access Time        : 2020-02-24 19:42:23              |
    |    |                        |              |        | Permissions             :                                  |
    |    |                        |              |        |   read_only     : 0                                        |
    |    |                        |              |        |   hidden        : 1                                        |
    |    |                        |              |        |   system        : 1                                        |
    |    |                        |              |        |   device        : 0                                        |
    |    |                        |              |        |   normal        : 0                                        |
    |    |                        |              |        |   temporary     : 0                                        |
    |    |                        |              |        |   sparse        : 0                                        |
    |    |                        |              |        |   reparse_point : 0                                        |
    |    |                        |              |        |   compressed    : 0                                        |
    |    |                        |              |        |   offline       : 0                                        |
    |    |                        |              |        |   not_indexed   : 1                                        |
    |    |                        |              |        |   encrypted     : 0                                        |
    |    |                        |              |        | Max Number of Versions  : 0                                |
    |    |                        |              |        | Version Number          : 0                                |
    +------------------------------------------------------------------------------------------------------------------+
    | 2  | $FILE_NAME             | False        | 68     | Parent Dir Record Index : 5                                |
    |    |                        |              |        | Parent Dir Sequence Num : 5                                |
    |    |                        |              |        | File Created Time       : 2009-12-02 02:03:31              |
    |    |                        |              |        | Last File Write Time    : 2011-12-24 03:13:12              |
    |    |                        |              |        | FileRecord Changed Time : 2011-12-24 03:13:12              |
    |    |                        |              |        | Last Access Time        : 1970-01-01 00:59:59              |
    |    |                        |              |        | Allocated Size          : 0                                |
    |    |                        |              |        | Real Size               : 0                                |
    |    |                        |              |        | ------                                                     |
    |    |                        |              |        | Name                    : .                                |
    +------------------------------------------------------------------------------------------------------------------+
    | 3  | $OBJECT_ID             | False        | 16     | Object Unique ID        : {cce8fec5-9a29-11df-be68-0017f29 |
    |    |                        |              |        |                           8268d}                           |
    +------------------------------------------------------------------------------------------------------------------+
    | 4  | $INDEX_ROOT            | False        | 152    | Attribute Type          : 00000030h                        |
    |    |                        |              |        | Collation Rule          : 1                                |
    |    |                        |              |        | Index Alloc Entry Size  : 4096                             |
    |    |                        |              |        | Cluster/Index Record    : 1                                |
    |    |                        |              |        | -----                                                      |
    |    |                        |              |        | First Entry Offset      : 16                               |
    |    |                        |              |        | Index Entries Size      : 136                              |
    |    |                        |              |        | Index Entries Allocated : 136                              |
    |    |                        |              |        | Flags                   : Large Index                      |
    +------------------------------------------------------------------------------------------------------------------+
    | 5  | $INDEX_ALLOCATION      | True         | 12288  | Index                                                      |
    |    |                        |              |        |        0000000000000004 : $AttrDef                         |
    |    |                        |              |        |        0000000000000008 : $BadClus                         |
    |    |                        |              |        |        0000000000000006 : $Bitmap                          |
    |    |                        |              |        |        0000000000000007 : $Boot                            |
    |    |                        |              |        |        000000000000000b : $Extend                          |
    |    |                        |              |        |        0000000000000002 : $LogFile                         |
    |    |                        |              |        |        0000000000000000 : $MFT                             |
    |    |                        |              |        |        0000000000000001 : $MFTMirr                         |
    |    |                        |              |        |        000000000000002d : $RECYCLE.BIN                     |
    |    |                        |              |        |        0000000000000009 : $Secure                          |
    |    |                        |              |        |        000000000000000a : $UpCase                          |
    |    |                        |              |        |        0000000000000003 : $Volume                          |
    |    |                        |              |        |        0000000000000005 : .                                |
    |    |                        |              |        |        000000000000240c : Dir1                             |
    |    |                        |              |        |        0000000000000218 : Dir2                             |
    |    |                        |              |        |        000000000000212a : Dir3                             |
    |    |                        |              |        |        0000000000000024 : Dir4                             |
    |    |                        |              |        |        0000000000000def : RECYCLER                         |
    |    |                        |              |        |        000000000000001b : System Volume Information        |
    |    |                        |              |        |        000000000000001b : SYSTEM~1                         |
    +------------------------------------------------------------------------------------------------------------------+
    | 6  | $BITMAP                | False        | 8      | Index Node Used         : 2                                |
    +------------------------------------------------------------------------------------------------------------------+
</td></tr>
</table>

### MFT-btree
<table>
<tr><td>mft.btree disk=0 volume=1 inode=5 (root folder)</td></tr>
<tr><td>

    Attributes:
    -----------
    
    +-------------------------------------------------------------------------------------------+
    | Id | Type              | Non-resident | Length | Overview                                 |
    +-------------------------------------------------------------------------------------------+
    | 1  | $INDEX_ROOT       | False        | 56     | Attribute Type          : Filename       |
    |    |                   |              |        | Collation Rule          : 1              |
    |    |                   |              |        | Index Alloc Entry Size  : 4096           |
    |    |                   |              |        | Cluster/Index Record    : 1              |
    |    |                   |              |        | -----                                    |
    |    |                   |              |        | First Entry Offset      : 16             |
    |    |                   |              |        | Index Entries Size      : 40             |
    |    |                   |              |        | Index Entries Allocated : 40             |
    |    |                   |              |        | Flags                   : Large Index    |
    +-------------------------------------------------------------------------------------------+
    | 2  | $INDEX_ALLOCATION | True         | 20480  | First VCN               : 0x000000000000 |
    |    |                   |              |        | Last VCN                : 0x000000000004 |
    +-------------------------------------------------------------------------------------------+
    
    $INDEX_ALLOCATION entries:
    --------------------------
    
    +--------------------------------------------------------------------------------------------+
    | VCN           | Raw address   | Size          | Entries                                    |
    +--------------------------------------------------------------------------------------------+
    | 000000000000h | 000000024000h | 000000001000h | 000000000004: $AttrDef                     |
    |               |               |               | 000000000008: $BadClus                     |
    |               |               |               | 000000000006: $Bitmap                      |
    						...
    |               |               |               | 000000000009: $Secure                      |
    |               |               |               | 00000000000a: $UpCase                      |
    |               |               |               | 000000000003: $Volume                      |
    +--------------------------------------------------------------------------------------------+
    | 000000000001h | 000000025000h | 000000001000h | 000000000098: randomfile - Copie (5).accdb |
    |               |               |               | 000000000097: randomfile - Copie (5).bat   |
    |               |               |               | 000000000095: randomfile - Copie (5).psd   |
    |               |               |               | 000000000096: randomfile - Copie (5).txt   |
    |               |               |               | 00000000009b: randomfile - Copie (6).accdb |
    						...
    |               |               |               | 000000000083: randomfile.accdb             |
    |               |               |               | 000000000082: randomfile.bat               |
    |               |               |               | 000000000084: randomfile.psd               |
    |               |               |               | 000000000081: randomfile.txt               |
    |               |               |               | 000000000024: System Volume Information    |
    +--------------------------------------------------------------------------------------------+
    | 000000000002h | 0000007d6000h | 000000001000h |                                            |
    +--------------------------------------------------------------------------------------------+
    | 000000000003h | 0000007d7000h | 000000001000h | 000000000005: .                            |
    |               |               |               | 000000000092: randomfile - Copie (4).txt   |
    +--------------------------------------------------------------------------------------------+
    | 000000000004h | 0000007d8000h | 000000001000h | 000000000027: random folder                |
    |               |               |               | 00000000008c: randomfile - Copie (2).accdb |
    |               |               |               | 00000000008b: randomfile - Copie (2).bat   |
    |               |               |               | 000000000089: randomfile - Copie (2).psd   |
    						...
    |               |               |               | 00000000008e: randomfile - Copie (3).txt   |
    |               |               |               | 000000000094: randomfile - Copie (4).accdb |
    |               |               |               | 000000000093: randomfile - Copie (4).bat   |
    |               |               |               | 000000000091: randomfile - Copie (4).psd   |
    +--------------------------------------------------------------------------------------------+
    
    B-tree index:
    -------------
    
    Root
    |- 000000000000:
    |---- VCN: 3
    	 |- 000000000005: .
    	 |---- VCN: 0
    		  |- 000000000004: $AttrDef
    		  |- 000000000008: $BadClus
    		  |- 000000000006: $Bitmap
    		  ....
    		  |- 000000000009: $Secure
    		  |- 00000000000a: $UpCase
    		  |- 000000000003: $Volume
    	 |- 000000000092: randomfile - Copie (4).txt
    	 |---- VCN: 4
    		  |- 000000000027: random folder
    		  |- 00000000008c: randomfile - Copie (2).accdb
    		  |- 00000000008b: randomfile - Copie (2).bat
    		  |- 000000000089: randomfile - Copie (2).psd
    		  ....
    		  |- 000000000094: randomfile - Copie (4).accdb
    		  |- 000000000093: randomfile - Copie (4).bat
    		  |- 000000000091: randomfile - Copie (4).psd
    	 |- 000000000000 (*)
    	 |---- VCN: 1
    		  |- 000000000098: randomfile - Copie (5).accdb
    		  |- 000000000097: randomfile - Copie (5).bat
    		  |- 000000000095: randomfile - Copie (5).psd
    		  ....
    		  |- 000000000084: randomfile.psd
    		  |- 000000000081: randomfile.txt
    		  |- 000000000024: System Volume Information
</td></tr>
</table>


### Bitlocker
<table>
<tr><td>bitlocker disk=3 volume=1</td></tr>
<tr><td>

    FVE Version    : 2
    State          : ENCRYPTED
    Size           : 536870400 (512.00 MiBs)
    Encrypted Size : 536870400 (512.00 MiBs)
    Algorithm      : AES-XTS-128
    Timestamp      : 2020-02-26 16:39:17

    Volume Master Keys:
    -------------------

    +--------------------------------------------------------------------------------------------------------------------+
    | Id | Type              | GUID                                   | Details                                          |
    +--------------------------------------------------------------------------------------------------------------------+
    | 1  | Password          | {2dd368f3-37d7-414f-94e6-3c5b86fadd50} | Nonce         : 01d5ecbb00f7155000000003         |
    |    |                   |                                        | MAC           : daea96439babc5d1e7f20c8860ff1ee9 |
    |    |                   |                                        | Encrypted Key : b76281568419ec3bee89d1eddccf3169 |
    |    |                   |                                        |                 59c466b6b392f40f0875e58168d868d7 |
    |    |                   |                                        |                 0788bd366bec117b11a9fd6e         |
    |    |                   |                                        |                                                  |
    |    |                   |                                        | JtR Hash      : $bitlocker$1$16$daea96439babc5d1 |
    |    |                   |                                        |                 e7f20c8860ff1ee9$1048576$12$5015 |
    |    |                   |                                        |                 f700bbecd50103000000$60$175ec23c |
    |    |                   |                                        |                 d799e2bde9d24bf3697919feb7628156 |
    |    |                   |                                        |                 8419ec3bee89d1eddccf316959c466b6 |
    |    |                   |                                        |                 b392f40f0875e58168d868d70788bd36 |
    |    |                   |                                        |                 6bec117b11a9fd6e                 |
    +--------------------------------------------------------------------------------------------------------------------+
    | 2  | Recovery Password | {19b4a3e2-94b3-452f-a614-6212faeb1b9d} | Nonce         : 01d5ecbb00f7155000000006         |
    |    |                   |                                        | MAC           : b9963d29e1bad1f42e60c3bfb6e3bef5 |
    |    |                   |                                        | Encrypted Key : 97a43d40c695c6d190eba3956ac7c7b1 |
    |    |                   |                                        |                 f5fdbbc7f9a61a77c914fa347479c7ac |
    |    |                   |                                        |                 6124ff46865e805367f7bef1         |
    |    |                   |                                        |                                                  |
    |    |                   |                                        | JtR Hash      : $bitlocker$1$16$b9963d29e1bad1f4 |
    |    |                   |                                        |                 2e60c3bfb6e3bef5$1048576$12$5015 |
    |    |                   |                                        |                 f700bbecd50106000000$60$3a06a06f |
    |    |                   |                                        |                 db044d850ecd6faf5cf2aec997a43d40 |
    |    |                   |                                        |                 c695c6d190eba3956ac7c7b1f5fdbbc7 |
    |    |                   |                                        |                 f9a61a77c914fa347479c7ac6124ff46 |
    |    |                   |                                        |                 865e805367f7bef1                 |
    +--------------------------------------------------------------------------------------------------------------------+
</td></tr>
<tr><td>bitlocker disk=3 volume=1 password=badpassword</td></tr>
<tr><td>

    FVE Version    : 2
    State          : ENCRYPTED
    Size           : 536870400 (512.00 MiBs)
    Encrypted Size : 536870400 (512.00 MiBs)
    Algorithm      : AES-XTS-128
    Timestamp      : 2020-02-26 16:39:17

    Tested Password:
    ----------------

    +--------------------------------------------------------------------------------+
    | Id | Type     | GUID                                   | Password    | Result  |
    +--------------------------------------------------------------------------------+
    | 1  | Password | {2dd368f3-37d7-414f-94e6-3c5b86fadd50} | badpassword | Invalid |
    +--------------------------------------------------------------------------------+
</td></tr>
<tr><td>bitlocker disk=3 volume=1 password=123456789</td></tr>
<tr><td>

    FVE Version    : 2
    State          : ENCRYPTED
    Size           : 536870400 (512.00 MiBs)
    Encrypted Size : 536870400 (512.00 MiBs)
    Algorithm      : AES-XTS-128
    Timestamp      : 2020-02-26 16:39:17

    Tested Password:
    ----------------

    +--------------------------------------------------------------------------------------------------------------+
    | Id | Type     | GUID                                   | Password  | Result                                  |
    +--------------------------------------------------------------------------------------------------------------+
    | 1  | Password | {2dd368f3-37d7-414f-94e6-3c5b86fadd50} | 123456789 | Valid                                   |
    |    |          |                                        |           |                                         |
    |    |          |                                        |           | VMK  : 751bf363db63ba6f1b36fb2ecd5ff1d8 |
    |    |          |                                        |           |        f5eab77e8754a848f2743978c7615f9f |
    |    |          |                                        |           | FVEK : 35b8197e6d74d8521f49698d5f556589 |
    |    |          |                                        |           |        2cf286ae5323c65631965c905a9d7da4 |
    +--------------------------------------------------------------------------------------------------------------+
</td></tr>
</table>


### Bitdecrypt
<table>
<tr><td>bitdecrypt disk=3 volume=1 output=decrypted.img fvek=35b8197e6d74d8521f49698d5f5565892cf286ae5323c65631965c905a9d7da4</td></tr>
<tr><td>
  
    [+] Opening \\?\Volume{09a02598-0000-0000-0002-000000000000}\
    [+] Reading Bitlocker VBR
    [-]   Volume State   : ENCRYPTED
    [-]   Size           : 536870400 (512.00 MiBs)
    [-]   Encrypted Size : 536870400 (512.00 MiBs)
    [-]   Algorithm      : AES-XTS-128
    [+] Decrypting sectors
    [-]   Processed data size : 512.00 MiBs (100%)
    [+] Duration : 7535ms
    [+] Closing Volume
</td></tr>
</table>


### EFS-backup
<table>
<tr><td>efs.backup disk=0 volume=4 password=123456</td></tr>
<tr><td>
    
    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [+] Listing user directories
        8 directories found
    [+] Searching for certificates
        - 8BB98DE9ED4DBDD09AA1FF467ED71F0F28ACF61B
    [+] Finding corresponding private keys
        - 5f2870d8a6f1ef6487be2e1aee746fb5_bbc401c6-854a-4d12-9b65-8d52ca66cb6a
    [+] Finding corresponding masterkeys
        - 9ac19509-54d3-48bc-8c67-4cfb01d73498
    [+] Exporting 1 certificates and keys (pass: backup)
        - ef456e5b-43e4-4eda-a80b-e234611306d4 : Ok
          Exported to 8BB98DE9ED4DBDD09AA1FF467ED71F0F28ACF61B.pfx
</td></tr>
</table>


### EFS-decrypt
<table>
<tr><td>efs.decrypt efs.decrypt disk=0 volume=4 from=c:\cat.png pfx=z:\my_backup.pfx password=backup output=c:\socute.png</td></tr>
<tr><td>

    [+] Loading PKCS12 input file
    [-] KeyID : 86598de9ed5dbdd00aa2ff467ed71f1f28acf61b
    [-] Reading record: 13525
    [+] Parsing $EFS streams
    [-] 1 data decryption field(s) found
    [+] Decrypting FEK
    [-] FEK
        +----------------------------------------------------------------------------------+
        | Property      | Value                                                            |
        +----------------------------------------------------------------------------------+
        | Entropy       | 32                                                               |
        | Algorithm     | CALG_AES_256                                                     |
        | Key (256bits) | 5BBBB8A7F9DD9B9FFFDE9E62370254979F32A9CFFDDB74212A0C1AEECCD75B4A |
        +----------------------------------------------------------------------------------+
    [+] Decrypting file
    [-] Decrypted file written to c:\socute.png (1.94 MiB)
</td></tr>
</table>

### EFS-certificate
<table>
<tr><td>efs.certificate disk=0 volume=4</td></tr>
<tr><td>

    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [+] Listing user directories
        8 directories found
    [+] Searching for certificates
        8 certificate(s) found
    [+] Certificates
        +-----------------------------------------------------------------------------------------------------------------------------------+
        | Id | User  | File                                                | Certificate                                                    |
        +-----------------------------------------------------------------------------------------------------------------------------------+
        |  0 | Bobby | Name     : 02728B6DF5573C5955A4DFF22319441C889C367B | Friendly Name : APNS certificate Direct                        |
        |    |       | Record   : 00000001d2d5h                            |                                                                |
        |    |       | Size     : 850.00 bytes                             |                                                                |
        |    |       |                                                     |                                                                |
        |    |       | Creation : 2019-05-11 15:59:29                      |                                                                |
        +-----------------------------------------------------------------------------------------------------------------------------------+
        |  1 | Bobby | Name     : 14BB7663C51C77FF5CAD89B4DC34495864338C67 | Friendly Name : APNS certificate                               |
        |    |       | Record   : 00000000b5a4h                            |                                                                |
        |    |       | Size     : 824.00 bytes                             |                                                                |
        |    |       |                                                     |                                                                |
        |    |       | Creation : 2021-03-03 18:02:33                      |                                                                |
        +-----------------------------------------------------------------------------------------------------------------------------------+
        |  2 | Bobby | Name     : 564481148D4DBDD09AA1FF467ED71F0F28ACF61B | Container     : ef456e5b-36e4-4eda-a80b-e234611306d4           |
        |    |       | Record   : 00000000ab23h                            | Provider      : Microsoft Enhanced Cryptographic Provider v1.0 |
        |    |       | Size     : 1.15 KiB                                 | Type          : PROV_RSA_FULL                                  |
        |    |       |                                                     | KeySpec       : AT_KEYEXCHANGE                                 |
        |    |       | Creation : 2020-08-17 13:20:03                      |                                                                |
        +-----------------------------------------------------------------------------------------------------------------------------------+
                                                                ..........
</td></tr>
<tr><td>efs.certificate disk=0 volume=4 inode=0xb5a4</td></tr>
<tr><td>
	
    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [+] Reading certificate file record: 46500
    [+] Certificate
        +--------------------------------------------------------------------------------------------------------------------------+
        | Id | Property                            | Value                                                                         |
        +--------------------------------------------------------------------------------------------------------------------------+
        |  0 | File                                | Creation : 2021-03-03 18:02:33                                                |
        |    |                                     | Size     : 824.00 bytes                                                       |
        +--------------------------------------------------------------------------------------------------------------------------+
        |  1 | SHA1_HASH_PROP_ID                   | 14A67663C51C66FF5CAD89B4DC34495864338C67                                      |
        +--------------------------------------------------------------------------------------------------------------------------+
        |  2 | FRIENDLY_NAME_PROP_ID               | APNS certificate                                                              |
        +--------------------------------------------------------------------------------------------------------------------------+
        |  3 | KEY_IDENTIFIER_PROP_ID              | 82B87AE4F2251242252A2644D98169F34F909CA8                                      |
        +--------------------------------------------------------------------------------------------------------------------------+
        |  4 | SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID | DB532C4794A15E5D0392C7C605FCBCA8                                              |
        +--------------------------------------------------------------------------------------------------------------------------+
        |  5 | CERTIFICATE_FILE                    | Data:                                                                         |
        |    |                                     |     Version: 3 (0x2)                                                          |
        |    |                                     |     Serial Number:                                                            |
        |    |                                     |         01:20:cb:ab:28:8a:97:ee:99:cc                                         |
        |    |                                     |     Signature Algorithm: sha1WithRSAEncryption                                |
        |    |                                     |     Issuer: C=US, O=Apple Inc., OU=Apple iPhone, CN=Apple iPhone Device CA    |
        |    |                                     |     Validity                                                                  |
        |    |                                     |         Not Before: Mar  3 15:57:33 2021 GMT                                  |
        |    |                                     |         Not After : Mar  3 16:02:33 2022 GMT                                  |
        |    |                                     |     Subject: CN=1A6032AA-91A2-4B1D-B6AF-5509FC173686                          |
        |    |                                     |     Subject Public Key Info:                                                  |
        |    |                                     |         Public Key Algorithm: rsaEncryption                                   |
        |    |                                     |             RSA Public-Key: (1024 bit)                                        |
        |    |                                     |             Modulus:                                                          |
        |    |                                     |                 00:a2:75:db:69:8d:c9:b3:fd:96:4d:28:b9:43:94:                 |
        |    |                                     |                 db:7d:73:53:88:c9:79:e9:fa:de:e4:12:14:2c:de:                 |
                                                          ...
        |    |                                     |                 a7:6b:d0:01:9e:dc:66:27:ef:2e:20:7e:e5:2a:42:                 |
        |    |                                     |                 9e:6f:85:9c:b6:8f:be:d3:05                                    |
        |    |                                     |             Exponent: 65537 (0x10001)                                         |
        |    |                                     |     X509v3 extensions:                                                        |
        |    |                                     |         X509v3 Authority Key Identifier:                                      |
        |    |                                     |             keyid:B2:FE:21:23:44:86:95:6A:79:D5:81:26:8E:73:10:D8:A7:4C:8E:74 |
        |    |                                     |         X509v3 Subject Key Identifier:                                        |
        |    |                                     |             82:B8:7A:E4:F2:25:12:42:25:2A:26:44:D9:81:69:F3:4F:90:9C:A8       |
        |    |                                     |         X509v3 Basic Constraints: critical                                    |
        |    |                                     |             CA:FALSE                                                          |
        |    |                                     |         X509v3 Key Usage: critical                                            |
        |    |                                     |             Digital Signature, Key Encipherment                               |
        |    |                                     |         X509v3 Extended Key Usage: critical                                   |
        |    |                                     |             TLS Web Server Authentication, TLS Web Client Authentication      |
        |    |                                     |         1.2.840.113635.100.6.10.6:                                            |
        |    |                                     |             ..                                                                |
        |    |                                     | Signature Algorithm: sha1WithRSAEncryption                                    |
        |    |                                     |      28:54:6c:d9:4e:97:f5:dd:1f:79:4a:6a:74:42:ad:6e:a1:11:                   |
                                                     ...
        |    |                                     |      27:58:3b:d5:1e:c3:71:af:6b:bd:fe:5d:ad:4d:bd:82:fa:53:                   |
        |    |                                     |      ff:0c                                                                    |
        +--------------------------------------------------------------------------------------------------------------------------+
</td></tr>
<tr><td>efs.certificate disk=0 volume=4 inode=0xb5a4 output=mycert</td></tr>
<tr><td>
    
    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [+] Reading certificate file record: 46500
    [+] Certificate exported to mycert.pem
</td></tr>
</table>

### EFS-key
<table>
<tr><td>efs.key disk=0 volume=4</td></tr>
<tr><td>
	
	[+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}
	[+] Listing user directories: 
	    8 directories found
	[+] Searching for keys
	    9713 key(s) found
	[+] Keys
	+------------------------------------------------------------------------------------------------------------------+
	| Id | User  | Keyfile                              | Name                                   | Creation Date       |
	+------------------------------------------------------------------------------------------------------------------+
	|  0 | User1 | Name   : 0004f7ed30db...017ee8d52ca6 | {15676EB3-D258-410F-85CB-9AB29E642CB3} | 2021-05-19 14:10:15 |
	|    |       | Record : 0000000246c5h               |                                        |                     |
	|    |       | Size   : 4.00 KiBs                   |                                        |                     |
	+------------------------------------------------------------------------------------------------------------------+
	|  1 | User1 | Name   : 0016875547ba...f7a9606b4177 | {BA4B66DC-8C1D-4FDF-A1EF-78B64411D1AD} | 2020-02-03 19:37:39 |
	|    |       | Record : 000000019f19h               |                                        |                     |
	|    |       | Size   : 4.00 KiBs                   |                                        |                     |
	+------------------------------------------------------------------------------------------------------------------+
	|  2 | User1 | Name   : 002a02ec680e...9a0a8d52ca67 | {3A3E1CF2-5AC2-4717-8006-D7C0F2936435} | 2019-06-26 15:50:50 |
                                                           ..........
</td></tr>
<tr><td>efs.key disk=0 volume=4 inode=742107</td></tr>
<tr><td>

	[+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
	[+] Reading key file record: 742107
	[+] Key
	+------------------------------------------------------------------------------------------------------------------+
	| Id | Property             | Value                                                                                |
	+------------------------------------------------------------------------------------------------------------------+
	|  0 | File                 | Creation : 2021-09-23 22:16:43                                                       |
	|    |                      | Size     : 4.00 KiBs                                                                 |
	+------------------------------------------------------------------------------------------------------------------+
	|  1 | Version              | 0                                                                                    |
	+------------------------------------------------------------------------------------------------------------------+
	|  2 | Name                 | ef456e5b-43e4-4eda-a80b-e234611306d4                                                 |
	+------------------------------------------------------------------------------------------------------------------+
	|  3 | Flags                | 00000000h                                                                            |
	+------------------------------------------------------------------------------------------------------------------+
	|  4 | PublicKey            | Magic       : 31415352h (RSA1)                                                       |
	|    |                      | Size        : 2048                                                                   |
	|    |                      | Exponent    : 65537                                                                  |
	|    |                      |                                                                                      |
	|    |                      | Permissions : CRYPT_ENCRYPT                                                          |
	|    |                      |               CRYPT_DECRYPT                                                          |
	|    |                      |               CRYPT_EXPORT                                                           |
	|    |                      |               CRYPT_READ                                                             |
                                                            ...
	|    |                      |                                                                                      |
	|    |                      | Modulus     : 96883F07FF78DA8354D037A94F897BD7                                       |
							    ...
	|    |                      |               FA77A3D04DD10D044761E65355B335B5                                       |
	+------------------------------------------------------------------------------------------------------------------+
	|  5 | Encrypted PrivateKey | Version           : 1                                                                |
	|    |                      | Provider GUID     : {df9d8cd0-1501-11d1-8c7a-00c04fc297eb}                           |
	|    |                      | MasterKey Version : 1                                                                |
	|    |                      | MasterKey GUID    : {9ac19509-54d3-48bc-8c67-4cfb01d73498}                           |
	|    |                      |                                                                                      |
	|    |                      | Description       : Clé privée CryptoAPI                                             |
	|    |                      | Flags             : 00000000h                                                        |
	|    |                      |                                                                                      |
	|    |                      | Encryption Alg    : CALG_AES_256                                                     |
	|    |                      | Hash Alg          : CALG_SHA_512                                                     |
	|    |                      |                                                                                      |
	|    |                      | Salt              : ABABD5324CCE0254BC726C3BF5A777D38BC4D75CACC2360EF3276EB4DC42FF6A |
	|    |                      |                                                                                      |
	|    |                      | HMAC              : -                                                                |
	|    |                      | HMAC2             : D24F0B0AF684AE986F1328EAAFC01DA346D2BADE2B84CBE3C94CCB338D449EA6 |
	|    |                      |                                                                                      |
	|    |                      | Encrypted Data    : D7DAD9229C91DBC9608852A4411527D7                                 |
	|    |                      |                     58DB27E19596DD118F2D70F68CC7913C                                 |
							    ...
	|    |                      |                     7870F6C68DA1B9139BF6E39725F4E72E                                 |
	|    |                      |                     4EC435C947F127CA3E333CB5E2F43978                                 |
	|    |                      |                                                                                      |
	|    |                      | Signature Data    : 6077C027E6714A81C2710C5D334758F9AD463117DA4CBA8D0D05B5845A662E8F |
	|    |                      |                     5E38DCCAB05DA5DD6C8328F5CF925F378F229790D30A2BCC91D5E3370AE50FED |
	+------------------------------------------------------------------------------------------------------------------+
	|  6 | Hash                 | 0000000000000000000000000000000000000000                                             |
	+------------------------------------------------------------------------------------------------------------------+
	|  7 | ExportFlag           | Version           : 1                                                                |
	|    |                      | Provider GUID     : {df9d8cd0-1501-11d1-8c7a-00c04fc297eb}                           |
	|    |                      | MasterKey Version : 1                                                                |
	|    |                      | MasterKey GUID    : {9ac19509-54d3-48bc-8c67-4cfb01d73498}                           |
	|    |                      |                                                                                      |
	|    |                      | Description       : Export Flag                                                      |
	|    |                      | Flags             : 00000000h                                                        |
	|    |                      |                                                                                      |
	|    |                      | Encryption Alg    : CALG_AES_256                                                     |
	|    |                      | Hash Alg          : CALG_SHA_512                                                     |
	|    |                      |                                                                                      |
	|    |                      | Salt              : 772935C3582F625367716CE87D9626A524F15B9B7FF07166BB2C704B1223CB06 |
	|    |                      |                                                                                      |
	|    |                      | HMAC              : -                                                                |
	|    |                      | HMAC2             : 3BCA74ED2C83767F06D9FF907817FE85FBA65FDB72A94E9D8F2C7CF1D8E7DCA2 |
	|    |                      |                                                                                      |
	|    |                      | Encrypted Data    : 875A6429226F11DFD3690D43BE633287                                 |
	|    |                      |                                                                                      |
	|    |                      | Signature Data    : FD97F69A214C37D0DA968B5AA18EE7C80D475F72F650C8DCAE887C97E850DCD6 |
	|    |                      |                     9FA17D397A2375E362DE6F17193E3D084C06B0DCDB38E6C746150C1056145178 |
	+------------------------------------------------------------------------------------------------------------------+
</td></tr>
<tr><td> efs.key disk=0 volume=4 inode=742107 masterkey=34fac126105ce30...178c5bff4979eb</td></tr>
<tr><td>
	
    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [+] Reading key file record: 742107
    [-] Key
	    Encryption Algorithm : CALG_AES_256
	    Hash Algorithm       : CALG_SHA_512
	    Salt                 : ABABD5324CCE0254BC726C33F5A777D38BC4D75CACC2360EF3276EB4DC42FF6A
    [+] Decrypting key
    [+] Key successfully decrypted
    [+] Export flags         : 00000001 (ALLOW_EXPORT_FLAG)
    [+] Clear key (2048bits) :
	    +----------------------------------------------------------+
	    | Id | Property         | Value                            |
	    +----------------------------------------------------------+
	    |  0 | Magic            | RSA2                             |
	    +----------------------------------------------------------+
	    |  1 | Bitsize          | 2048                             |
	    +----------------------------------------------------------+
	    |  2 | Exponent         | 65537                            |
	    +----------------------------------------------------------+
	    |  3 | Modulus          | 96883F07FF78DA8354D037A94F897BD7 |
                                      ...
	    |    |                  | FA77A3D04DD10D044761E65355B335B5 |
	    +----------------------------------------------------------+
	    |  4 | Prime1           | C02F585644ED6326FF82368B0AD9ECD4 |
                                      ...
	    |    |                  | 65F7DE6D173FEBEF95BE491FB222E07B |
	    +----------------------------------------------------------+
	    |  5 | Prime2           | C884376BBC50C2A14C495894FBF980DE |
                                      ...
	    |    |                  | 6759E812B6385B9151EBED8DCD65238F |
	    +----------------------------------------------------------+
	    |  6 | Exponent1        | 0E33B17876918051427271EB667AE238 |
                                      ...
	    |    |                  | 69349EF83ACE9B75D20004D155CDA3FF |
	    +----------------------------------------------------------+
	    |  7 | Exponent2        | 5BF265077E1EFA60C47E8DA423B751A4 |
                                      ...
	    |    |                  | E7008F2EA5684A74E4BFEEFAAB48C979 |
	    +----------------------------------------------------------+
	    |  8 | Coefficient      | 7D68AA3844F096959C23BD59E4BE3147 |
                                      ...
	    |    |                  | 592ABC1BEDEBA6F5B4BDE3D0F9BEF7C5 |
	    +----------------------------------------------------------+
	    |  9 | Private Exponent | 2462A061AD85A7C3B0DF7764CC5DDDFA |
	    |    |                  | 40D83B3FBF0D9D016C419E6B6744AD73 |
                                      ...
	    |    |                  | 47685BDEB0FABDC21AF5CABBA13D138D |
	    |    |                  | F39FC063F1F20323E3220229E29FA42D |
	    +----------------------------------------------------------+
</td></tr>
<tr><td> efs.key disk=0 volume=4 inode=742107 masterkey=34...eb output=mykey</td></tr>
<tr><td>
	
    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [+] Reading key file record: 742107
    [-] Key
        Encryption Algorithm : CALG_AES_256
        Hash Algorithm       : CALG_SHA_512
        Salt                 : ABABD5324CCE0254BC726C33F5A777D38BC4D75CACC2360EF3276EB4DC42FF6A
    [+] Decrypting key
    [+] Key successfully decrypted
    [+] Public key exported to mykey.pub.pem.	    
    [+] Private key exported to mykey.priv.pem.	    
</td></tr>
</table>

### EFS-masterkey
<table>
<tr><td>efs.masterkey disk=0 volume=4</td></tr>
<tr><td>
	
    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [+] Listing user directories
        8 directories found
    [+] Searching for keys
        19 key(s), 2 preferred file(s) found
    [+] MasterKeys
        +--------------------------------------------------------------------------------------------------------------------------------------------------+
        | Id | User           | Keyfile                                       | Key(s)                                               | Creation Date       |
        +--------------------------------------------------------------------------------------------------------------------------------------------------+
        |  0 | DefaultAppPool | Name   : e4ed144f-6522-4471-8893-a6e29e175ba6 | MasterKey                                            | 2021-08-17 14:54:41 |
        |    |                | Record : 000000031848h                        |     Version : 2                                      |                     |
        |    |                | Size   : 468.00 bytes                         |     Algo    : CALG_SHA_512 - CALG_AES_256            |                     |
        |    |                |                                               |     Salt    : FA737C82899CC3F61A3B332B15FDC241       |                     |
        |    |                |                                               |     Rounds  : 8000                                   |                     |
        |    |                |                                               | BackupKey                                            |                     |
        |    |                |                                               |     Version : 2                                      |                     |
        |    |                |                                               |     Algo    : CALG_SHA_512 - CALG_AES_256            |                     |
        |    |                |                                               |     Salt    : DF0651C903763132BC3043BF144A7DDD       |                     |
        |    |                |                                               |     Rounds  : 8000                                   |                     |
        |    |                |                                               | CredHist                                             |                     |
        |    |                |                                               |     Version : 3                                      |                     |
        |    |                |                                               |     GUID    : {00000000-0000-0000-0000-000000000000} |                     |
        +--------------------------------------------------------------------------------------------------------------------------------------------------+
        |  1 | DefaultAppPool | Name   : Preferred                            | Preferred                                            | 2021-08-17 14:54:41 |
        |    |                | Record : 00000003184ah                        |     GUID    : {e4ed144f-6522-4471-8893-a6e29e175ba6} |                     |
        |    |                | Size   : 24.00 bytes                          |     Renew   : 2021-11-15 12:54:41                    |                     |
        +--------------------------------------------------------------------------------------------------------------------------------------------------+
        |  2 | Bob            | Name   : 26bd8b3d-e87f-4df3-a1af-18f434788090 | MasterKey                                            | 2021-03-05 01:16:42 |
        |    |                | Record : 000000004f4ah                        |     Version : 2                                      |                     |
        |    |                | Size   : 468.00 bytes                         |     Algo    : CALG_SHA_512 - CALG_AES_256            |                     |
        |    |                |                                               |     Salt    : 39B575D1816DE8224B9E11C38E35EB34       |                     |
        |    |                |                                               |     Rounds  : 8000                                   |                     |
        |    |                |                                               | BackupKey                                            |                     |
                                                                ..........
</td></tr>
<tr><td>efs.masterkey disk=0 volume=4 inode=0x80544</td></tr>
<tr><td>
	
    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [+] Reading masterkey file record: 525636
    [+] MasterKey
        +--------------------------------------------------------------------+
        | Id | Property  | Value                                             |
        +--------------------------------------------------------------------+
        |  0 | File      | Creation : 2020-07-06 05:56:06                    |
        |    |           | Size     : 468.00 bytes                           |
        +--------------------------------------------------------------------+
        |  1 | Version   | 2                                                 |
        +--------------------------------------------------------------------+
        |  2 | GUID      | 9ac19509-54d3-48bc-8c67-4cfb01d73498              |
        +--------------------------------------------------------------------+
        |  3 | Policy    | 00000005h                                         |
        +--------------------------------------------------------------------+
        |  4 | MasterKey | Version  : 2                                      |
        |    |           | Salt     : 3ED4CDBCC4073D6724A512061D0597E1       |
        |    |           | Rounds   : 8000                                   |
        |    |           | Hash Alg : CALG_SHA_512                           |
        |    |           | Enc Alg  : CALG_AES_256                           |
        |    |           | Enc Key  : 3610946FE1A7B9099D0AFA7658325014       |
        |    |           |            296D1F0E5BA93249858BE3ACCC8FD7A8       |
        |    |           |            F62DB6808833FC303095C6588BDE3826       |
        |    |           |            80ABF391222CD77661BCCB637DDAC490       |
        |    |           |            B5FC02C854EF45490EE10851EF524DE2       |
        |    |           |            85DD508F905216D528D3DC3336830FF9       |
        |    |           |            690472730A03D64CF892E06B9AA35692       |
        |    |           |            AB7679E908D487119030B73CB87E6F9F       |
        |    |           |            731F65609CB8ACA972BCC9042B27B9B4       |
        +--------------------------------------------------------------------+
        |  5 | BackupKey | Version  : 2                                      |
        |    |           | Salt     : B60E21F9578D02A97964D7B10151BE69       |
        |    |           | Rounds   : 8000                                   |
        |    |           | Hash Alg : CALG_SHA_512                           |
        |    |           | Enc Alg  : CALG_AES_256                           |
        |    |           | Enc Key  : CD5D3684873D6A1D66520FB1642779E1       |
        |    |           |            D78A649F02DDFE7C069F9B5F8FF9F005       |
        |    |           |            7DC01E0A6AA9A815C8887BC1BF5B88E6       |
        |    |           |            E797DC5F4A3A0535B3217BADC7FAD38E       |
        |    |           |            798C1846423C8631DE472D790B308B2D       |
        |    |           |            F15340B87FCD55A98DAEE92196235CF9       |
        |    |           |            B328FAF475C05A911DF19C99D54D5A3C       |
        +--------------------------------------------------------------------+
        |  6 | CredHist  | Version  : 3                                      |
        |    |           | GUID     : {20e0b482-797f-429e-b4a0-30020731ef0a} |
        +--------------------------------------------------------------------+
</td></tr>
<tr><td> efs.masterkey disk=0 volume=4 inode=0x80544 sid="S-1-5-21-1521398...3175218-1001" password="ntfst00l"</td></tr>
<tr><td>
	
    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [+] Reading masterkey file record: 525636
    [-] Masterkey
        Encryption Algorithm : CALG_AES_256
        Hash Algorithm       : CALG_SHA_512
        Rounds               : 8000
        Salt                 : 3ED4CDBCC4073D6724A512061D0597E1
    [+] Decrypting masterkey
    [+] Clear masterkey (256bits):
        34FAC126105CE302421A0FC7E3933FEC5639AA6BFF95000E6DA83AE67522EAB6
        0AF58A27D834883B65611878B258AAAECD8983E3718E00F276178C5BFF4979EB
</td></tr>
</table>


### FVE
<table>
<tr><td>fve disk=3 volume=1 fve_block=2</td></tr>
<tr><td>
  
    Signature             : -FVE-FS-
    Size                  : 57
    Version               : 2
    Current State         : ENCRYPTED (4)
    Next State            : ENCRYPTED (4)
    Encrypted Size        : 536870400 (512.00 MiBs)
    Convert Size          : 0
    Backup Sectors        : 16
    FVE Block 1           : 0000000002100000
    FVE Block 2           : 00000000059e4000
    FVE Block 3           : 00000000092c8000
    Backup Sectors Offset : 0000000002110000

    FVE Metadata Header
    -------------------

    Size                  : 840
    Version               : 1
    Header Size           : 48
    Copy Size             : 840
    Volume GUID           : {70a57ea3-9b98-4034-8b6a-645f731e2d1e}
    Next Counter          : 10
    Algorithm             : AES-XTS-128 (8004)
    Timestamp             : 2020-02-26 16:39:17

    FVE Metadata Entries (5)
    ------------------------

    +----------------------------------------------------------------------------------------------------------------+
    | Id | Version | Size | Entry Type          | Value Type      | Value                                            |
    +----------------------------------------------------------------------------------------------------------------+
    | 1  | 1       | 72   | Drive Label         | Unicode         | String        : TWN NTFSDRIVE 26/02/2020         |
    +----------------------------------------------------------------------------------------------------------------+
    | 2  | 1       | 224  | VMK                 | VMK             | Key ID        : {2dd368f3-37d7-414f-94e6-3c5b86f |
    |    |         |      |                     |                 |                 add50}                           |
    |    |         |      |                     |                 | Last Change   : 2020-02-26 16:40:00              |
    |    |         |      |                     |                 | Protection    : Password                         |
    |    |         |      |                     |                 |                                                  |
    |    |         |      |                     |                 | Property #1 - Stretch Key - 108                  |
    |    |         |      |                     |                 | --------                                         |
    |    |         |      |                     |                 | Encryption    : STRETCH KEY                      |
    |    |         |      |                     |                 | MAC           : daea96439babc5d1e7f20c8860ff1ee9 |
    |    |         |      |                     |                 |                                                  |
    |    |         |      |                     |                 | Property #1.1 - AES-CCM - 80                     |
    |    |         |      |                     |                 | --------                                         |
    |    |         |      |                     |                 | Nonce as Hex  : 01d5ecbb00f71550                 |
    |    |         |      |                     |                 | Nonce as Time : 2020-02-26 16:39:59              |
    |    |         |      |                     |                 | Nonce Counter : 00000002                         |
    |    |         |      |                     |                 | MAC           : 1dfebdc79a966e72ca806d6a83d8c7ba |
    |    |         |      |                     |                 | Key           : eb51a188df981b54f51698c76d76a8bb |
    |    |         |      |                     |                 |                 d22afbbe27603ea6afc34c077726262e |
    |    |         |      |                     |                 |                 5ba07482053d3c36fdecf80f         |
    |    |         |      |                     |                 |                                                  |
    |    |         |      |                     |                 | Property #2 - AES-CCM - 80                       |
    |    |         |      |                     |                 | --------                                         |
    |    |         |      |                     |                 | Nonce as Hex  : 01d5ecbb00f71550                 |
    |    |         |      |                     |                 | Nonce as Time : 2020-02-26 16:39:59              |
    |    |         |      |                     |                 | Nonce Counter : 00000003                         |
    |    |         |      |                     |                 | MAC           : 175ec23cd799e2bde9d24bf3697919fe |
    |    |         |      |                     |                 | Key           : b76281568419ec3bee89d1eddccf3169 |
    |    |         |      |                     |                 |                 59c466b6b392f40f0875e58168d868d7 |
    |    |         |      |                     |                 |                 0788bd366bec117b11a9fd6e         |
    +----------------------------------------------------------------------------------------------------------------+
    | 3  | 1       | 316  | VMK                 | VMK             | Key ID        : {19b4a3e2-94b3-452f-a614-6212fae |
    |    |         |      |                     |                 |                 b1b9d}                           |
    |    |         |      |                     |                 | Last Change   : 2020-02-26 16:40:07              |
    |    |         |      |                     |                 | Protection    : Recovery Password                |
    |    |         |      |                     |                 |                                                  |
    |    |         |      |                     |                 | Property #1 - Stretch Key - 172                  |
    |    |         |      |                     |                 | --------                                         |
    |    |         |      |                     |                 | Encryption    : STRETCH KEY                      |
    |    |         |      |                     |                 | MAC           : b9963d29e1bad1f42e60c3bfb6e3bef5 |
    |    |         |      |                     |                 |                                                  |
    |    |         |      |                     |                 | Property #1.1 - AES-CCM - 64                     |
    |    |         |      |                     |                 | --------                                         |
    |    |         |      |                     |                 | Nonce as Hex  : 01d5ecbb00f71550                 |
    |    |         |      |                     |                 | Nonce as Time : 2020-02-26 16:39:59              |
    |    |         |      |                     |                 | Nonce Counter : 00000004                         |
    |    |         |      |                     |                 | MAC           : 8064d679c7d8d1fa8ae548b0844882c7 |
    |    |         |      |                     |                 | Key           : 18d21021d40e3dc99d38c8dd84faed10 |
    |    |         |      |                     |                 |                 370c32095f4f63261ad8ec40         |
    |    |         |      |                     |                 |                                                  |
    |    |         |      |                     |                 | Property #1.2 - AES-CCM - 80                     |
    |    |         |      |                     |                 | --------                                         |
    |    |         |      |                     |                 | Nonce as Hex  : 01d5ecbb00f71550                 |
    |    |         |      |                     |                 | Nonce as Time : 2020-02-26 16:39:59              |
    |    |         |      |                     |                 | Nonce Counter : 00000005                         |
    |    |         |      |                     |                 | MAC           : 3d40f2b5fc0091b894b438763fcdf4cd |
    |    |         |      |                     |                 | Key           : a0af0aeda32d977d26ac76f9fc429668 |
    |    |         |      |                     |                 |                 955d2a6a49fe4e2323751924e47e6c39 |
    |    |         |      |                     |                 |                 8c22f7fcd2d4272003cb7a4e         |
    |    |         |      |                     |                 |                                                  |
    |    |         |      |                     |                 | Property #2 - AES-CCM - 80                       |
    |    |         |      |                     |                 | --------                                         |
    |    |         |      |                     |                 | Nonce as Hex  : 01d5ecbb00f71550                 |
    |    |         |      |                     |                 | Nonce as Time : 2020-02-26 16:39:59              |
    |    |         |      |                     |                 | Nonce Counter : 00000006                         |
    |    |         |      |                     |                 | MAC           : 3a06a06fdb044d850ecd6faf5cf2aec9 |
    |    |         |      |                     |                 | Key           : 97a43d40c695c6d190eba3956ac7c7b1 |
    |    |         |      |                     |                 |                 f5fdbbc7f9a61a77c914fa347479c7ac |
    |    |         |      |                     |                 |                 6124ff46865e805367f7bef1         |
    |    |         |      |                     |                 |                                                  |
    |    |         |      |                     |                 | Property #3 - Unknown (00000015)                 |
    |    |         |      |                     |                 |  - 28                                            |
    |    |         |      |                     |                 | --------                                         |
    |    |         |      |                     |                 | Unknown Value Type (21)                          |
    +----------------------------------------------------------------------------------------------------------------+
    | 4  | 1       | 80   | FKEV                | AES-CCM         | Nonce as Hex  : 01d5ecbb00f71550                 |
    |    |         |      |                     |                 | Nonce as Time : 2020-02-26 16:39:59              |
    |    |         |      |                     |                 | Nonce Counter : 00000008                         |
    |    |         |      |                     |                 | MAC           : 2ff7d7f79920e3509fb8d20cb15b62c8 |
    |    |         |      |                     |                 | Key           : 097169b9a5c41420ed2353a4a4210763 |
    |    |         |      |                     |                 |                 a8833d1a4a88c6f7c0c45ec7c0959f25 |
    |    |         |      |                     |                 |                 2c8eac3f306e9fd1e693784a         |
    +----------------------------------------------------------------------------------------------------------------+
    | 5  | 1       | 100  | Volume Header Block | Offset and Size | Offset        : 0000000002110000                 |
    |    |         |      |                     |                 | Size          : 0000000000002000                 |
    +----------------------------------------------------------------------------------------------------------------+
</td></tr>
</table>


### reparse
<table>
<tr><td>reparse disk=0 volume=4</td></tr>
<tr><td>

    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [+] Reading $Extend\$Reparse
    [+] 104 entries found
    +----------------------------------------------------------------------------------------------------------------+
    | Id  | MFT Index | Filename                    | Type                        | Target/Data                      |
    +----------------------------------------------------------------------------------------------------------------+
    | 0   | 00000eb3  | debian.exe                  | AppExecLink                 | TheDebianProject.DebianGNULinux_ |
    |     |           |                             |                             | 76v4gfsz19hv4                    |
    |     |           |                             |                             |                                  |
    |     |           |                             |                             | TheDebianProject.DebianGNULinux_ |
    |     |           |                             |                             | 76v4gfsz19hv4!debian             |
    |     |           |                             |                             |                                  |
    |     |           |                             |                             | C:\Program Files\WindowsApps\The |
    |     |           |                             |                             | DebianProject.DebianGNULinux_1.2 |
    |     |           |                             |                             | .0.0_x64__76v4gfsz19hv4\debian.e |
    |     |           |                             |                             | xe                               |
    +----------------------------------------------------------------------------------------------------------------+
    ...
    +----------------------------------------------------------------------------------------------------------------+
    | 13  | 000007f9  | BaseLayer                   | Mount Point                 | \??\Volume{629458e4-0000-0000-00 |
    |     |           |                             |                             | 00-010000000000}\                |
    +----------------------------------------------------------------------------------------------------------------+
    | 14  | 00013e24  | Watchdog                    | Mount Point                 | \??\C:\Program Files\NVIDIA Corp |
    |     |           |                             |                             | oration\NvContainer\Watchdog     |
    +----------------------------------------------------------------------------------------------------------------+
    ...
    +----------------------------------------------------------------------------------------------------------------+
    | 102 | 00035861  | C2R64.dll                   | Symbolic Link               | \??\C:\Program Files\Common File |
    |     |           |                             |                             | s\Microsoft Shared\ClickToRun\C2 |
    |     |           |                             |                             | R64.dll                          |
    +----------------------------------------------------------------------------------------------------------------+
    | 103 | 000986b0  | All Users                   | Symbolic Link               | \??\C:\ProgramData               |
    +----------------------------------------------------------------------------------------------------------------+
</td></tr>
</table>


### logfile
<table>
<tr><td>logfile disk=4 volume=1 output=logfile.csv format=csv</td></tr>
<tr><td>

    [+] Opening \\?\Volume{00000001-0000-0000-0000-000000000000}\
    [+] Reading $LogFile record
    [-]     $LogFile size : 4.14 MiBs
    [+] Parsing $LogFile Restart Pages
    [-]     Newest Restart Page LSN : 5274485
    [-]     Volume marked as cleanly unmounted
    [-]     Client found : [1] NTFS
    [+] Parsing $LogFile Record Pages
    [-]     $LogFile Record Page Count: 86
    [+] Parsing $LogFile Records: 601
    [+] Closing volume
</td></tr>
<tr><td>Sample of logfile.csv</td></tr>
<tr><td><pre>    LSN,ClientPreviousLSN,UndoNextLSN,ClientID,RecordType,TransactionID,RedoOperation,UndoOperation,MFTClusterIndex,TargetVCN,TargetLCN
    5269000,5268967,5268967,0,1,24,SetNewAttributeSizes,SetNewAttributeSizes,2,10,43700
    5269019,5269000,5269000,0,1,24,UpdateNonresidentValue,Noop,0,0,37594
    5269044,5269019,5269019,0,1,24,SetNewAttributeSizes,SetNewAttributeSizes,2,10,43700
    5269063,5269044,5269044,0,1,24,SetNewAttributeSizes,SetNewAttributeSizes,2,10,43700
    5269082,5269063,5269063,0,1,24,UpdateNonresidentValue,Noop,0,0,37594
    5269103,5269082,5269082,0,1,24,SetNewAttributeSizes,SetNewAttributeSizes,2,10,43700
    5269122,5269103,0,0,1,24,ForgetTransaction,CompensationLogRecord,0,0,18446744073709551615
    5269133,0,0,0,1,24,UpdateResidentValue,UpdateResidentValue,2,13,43703</pre>
</td></tr>
</table>


### usn
<table>
<tr><td>usn disk=4 volume=1 output=usn.csv format=csv</td></tr>
<tr><td>
  
    [+] Opening \\?\Volume{00000001-0000-0000-0000-000000000000}\
    [+] Finding $Extend\$UsnJrnl record
    [+] Found in file record : 41
    [+] Data stream $J size : 2.66 KiBs
    [+] Reading $J
    [+] Processing entry : 32
    [+] Closing volume
</td></tr>
<tr><td>Sample of usn.csv</td></tr>
<tr><td><pre>MajorVersion,MinorVersion,FileReferenceNumber,FileReferenceSequenceNumber,ParentFileReferenceNumber,ParentFileReferenceSequenceNumber,Usn,Timestamp,Reason,SourceInfo,SecurityId,FileAttributes,Filename
2,0,53,4,5,5,0,2020-02-26 21:43:36,FILE_CREATE,0,0,DIRECTORY,Nouveau dossier
2,0,53,4,5,5,96,2020-02-26 21:43:36,FILE_CREATE+CLOSE,0,0,DIRECTORY,Nouveau dossier
2,0,53,4,5,5,192,2020-02-26 21:43:38,RENAME_OLD_NAME,0,0,DIRECTORY,Nouveau dossier
2,0,53,4,5,5,288,2020-02-26 21:43:38,RENAME_NEW_NAME,0,0,DIRECTORY,test
2,0,53,4,5,5,360,2020-02-26 21:43:38,RENAME_NEW_NAME+CLOSE,0,0,DIRECTORY,test
2,0,53,4,5,5,432,2020-02-26 21:43:39,OBJECT_ID_CHANGE,0,0,DIRECTORY,test
2,0,53,4,5,5,504,2020-02-26 21:43:39,OBJECT_ID_CHANGE+CLOSE,0,0,DIRECTORY,test
2,0,54,2,53,4,576,2020-02-26 21:43:41,FILE_CREATE,0,0,ARCHIVE,Nouveau document texte.txt</pre>
</td></tr>
</table>



### shadow
<table>
<tr><td>shadow disk=0 volume=4</td></tr>
<tr><td>
  
    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [+] VSS header found at 0x1e00

    +---------------------------------------------------------------------------------------------------------------+
    | SetID/ID                               | Count | Date                | Details                                |
    +---------------------------------------------------------------------------------------------------------------+
    | {857c9ac4-ee4f-4bc6-b822-59e935a7120f} | 1     | 2020-09-21 00:15:38 | Service Machine    : WORK-PC10         |
    |                                        |       |                     | Originating Machine: WORK-PC10         |
    | {3d102db1-8de2-4e7d-8ba5-e0dd4f67740d} |       |                     | State              : Created           |
    |                                        |       |                     | Flags              : 0x0042000d        |
    |                                        |       |                     |                    - Persistent        |
    |                                        |       |                     |                    - Client Accessible |
    |                                        |       |                     |                    - No Auto Release   |
    |                                        |       |                     |                    - Differential      |
    |                                        |       |                     |                    - Auto Recover      |
    +---------------------------------------------------------------------------------------------------------------+
    | {83bc8af4-8802-4466-ae38-717f6474616a} | 1     | 2020-09-22 06:10:00 | Service Machine    : WORK-PC10         |
    |                                        |       |                     | Originating Machine: WORK-PC10         |
    | {e668c329-66a2-4ebd-beef-3c6bca81cbf7} |       |                     | State              : Created           |
    |                                        |       |                     | Flags              : 0x0042000d        |
    |                                        |       |                     |                    - Persistent        |
    |                                        |       |                     |                    - Client Accessible |
    |                                        |       |                     |                    - No Auto Release   |
    |                                        |       |                     |                    - Differential      |
    |                                        |       |                     |                    - Auto Recover      |
    +---------------------------------------------------------------------------------------------------------------+
</td></tr>
</table>

### streams
<table>
<tr><td>streams disk=0 volume=4 from=c:\test.pdf</td></tr>
<tr><td>
  
    [+] Opening \\?\Volume{ee732b26-571c-4516-b8fd-32282aa8e66b}\
    [-] Source      : c:\test.pdf
    [-] Record Num  : 13525 (000034d5h)
    [+] Alternate data stream(s):
        +-----------------------------+
        | Id | Name            | Size |
        +-----------------------------+
        |  0 | Zone.Identifier |   27 |
        +-----------------------------+
</td></tr>
</table>

### undelete
<table>
<tr><td>undelete disk=4 volume=1</td></tr>
<tr><td>

    [+] Opening \\?\Volume{00000001-0000-0000-0000-000000000000}\
    [+] Reading $MFT record
    [+] $MFT size : 256.00 KiBs (~256 records)
    [+] Reading $BITMAP record
    [+] $BITMAP size : 16.00 KiBs
    [+] Searching deleted files
    [+] Processed data size : 262144 (100%)
    [+] Duration : 7ms

    Deleted Files Found
    -------------------

    +---------------------------------------------------------------------------------------------------------------+
    | Id | MFT Index | Flag | Filename                          | Size        | Deletion Date       | % Recoverable |
    +---------------------------------------------------------------------------------------------------------------+
    | 0  | 00000029  |      | .\$RECYCLE.BIN\[...]\$RAV85W4.jpg | 5.10 KiBs   | 2020-02-26 21:29:03 | 100.00        |
    +---------------------------------------------------------------------------------------------------------------+
    | 1  | 00000035  |      | .\$RECYCLE.BIN\[...]\$IAV85W4.jpg | 58.00 bytes | 2020-02-26 21:29:03 | 100.00        |
    +---------------------------------------------------------------------------------------------------------------+

</td></tr>
<tr><td>undelete disk=4 volume=1 inode=41 output=restored_kitten.jpg</td></tr>
<tr><td>

    [+] Opening \\?\Volume{00000001-0000-0000-0000-000000000000}\
    [+] Reading file record : 41
    [+] Extracting $RAV85W4.jpg to restored_kitten.jpg
    [+] 5219 bytes written
</td></tr>
</table>


### shell
<table>
<tr><td>shell disk=4 volume=1</td></tr>
<tr><td>

    disk4:volume1:> ls

    Inode | Type | Name                      | Size      | Creation Date       | Attributes
    ---------------------------------------------------------------------------------------
        4 |      | $AttrDef                  |      2560 | 2020-02-26 16:35:29 | Hi Sy
        8 |      | $BadClus                  |         0 | 2020-02-26 16:35:29 | Hi Sy
          | ADS  |   $Bad                    | 536866816 |                     |
        6 |      | $Bitmap                   |     16384 | 2020-02-26 16:35:29 | Hi Sy
        7 |      | $Boot                     |      8192 | 2020-02-26 16:35:29 | Hi Sy
       11 | DIR  | $Extend                   |           | 2020-02-26 16:35:29 | Hi Sy
        2 |      | $LogFile                  |   4341760 | 2020-02-26 16:35:29 | Hi Sy
        0 |      | $MFT                      |    262144 | 2020-02-26 16:35:29 | Hi Sy
        1 |      | $MFTMirr                  |      4096 | 2020-02-26 16:35:29 | Hi Sy
       50 | DIR  | $RECYCLE.BIN              |           | 2020-02-26 16:40:34 | Hi Sy
        9 |      | $Secure                   |         0 | 2020-02-26 16:35:29 | Hi Sy
          | ADS  |   $SDS                    |    264200 |                     |
       10 |      | $UpCase                   |    131072 | 2020-02-26 16:35:29 | Hi Sy
          | ADS  |   $Info                   |        32 |                     |
        3 |      | $Volume                   |         0 | 2020-02-26 16:35:29 | Hi Sy
        5 | DIR  | .                         |           | 2020-02-26 16:35:29 | Hi Sy
    85010 |      | 7z1900-x64.exe            |   1447178 | 2020-07-29 17:19:49 | Ar
          | ADS  |   Zone.Identifier         |       123 |                     | 
       42 |      | hello.txt                 |         5 | 2020-02-26 21:27:33 | Ar
       39 |      | kitten1.jpg               |     23486 | 2020-02-26 16:37:23 | Ar
          | ADS  |   Zone.Identifier         |       154 |                     |
       40 |      | kitten2.jpg               |     79678 | 2020-02-26 16:37:55 | Ar
          | ADS  |   Zone.Identifier         |       303 |                     |
       41 |      | kitten3.jpg               |      5219 | 2020-02-26 16:38:16 | Ar
          | ADS  |   Zone.Identifier         |       262 |                     |
       36 | DIR  | System Volume Information |           | 2020-02-26 16:35:29 | Hi Sy

    disk4:volume1:> pwd
    \
    disk4:volume1:> cat hello.txt
    Hey !
    disk4:volume1:> cat 7z1900-x64.exe:Zone.Identifier
    [ZoneTransfer]
    ZoneId=3
    ReferrerUrl=https://www.7-zip.org/download.html
    HostUrl=https://www.7-zip.org/a/7z1900-x64.exe

    disk4:volume1:> cp kitten3.jpg z:\custestkitten.jpg
    1 file copied
    disk4:volume1:> exit
    
</td></tr>
</table>


### smart
<table>
<tr><td>smart disk=1</td></tr>
<tr><td>

    Version          : 1 revision 1
    Type             : SATA/IDE Master on primary channel
    Capabilities     : ATA, ATAPI, S.M.A.R.T

    Status           : Passed

    -- Device ID
    +---------------------------------------------------------------------------------------------------+
    | Property                                               | Value                                    |
    +---------------------------------------------------------------------------------------------------+
    | General Configuration                                  | 0040h                                    |
    | Number of Cylinders                                    | 16383                                    |
    | Reserved                                               | c837h                                    |
    | Number Of Heads                                        | 16                                       |
    | Bytes Per Track                                        | 0                                        |
    | Bytes Per Sector                                       | 0                                        |
    | Sectors Per Track                                      | 63                                       |
    | Vendor Unique                                          |                                          |
    | Seria Number                                           | S2RBNX0H606448W                          |
    | Buffer Type                                            | 0                                        |
    | Buffer Size                                            | 0                                        |
    | ECC Size                                               | 0                                        |
    | Firmware Revision                                      | EMT02B6Q                                 |
    | Model Number                                           | Samsung SSD 850 EVO 500GB                |
    | Maximum Number of Sectors On R/W                       | 32769                                    |
    | Double Word IO                                         | 16385                                    |
    | Capabilities                                           | Reserved                 : 0000h         |
    |                                                        | DMA Support              : True          |
    |                                                        | LBA Support              : True          |
    |                                                        | DisIORDY                 : True          |
    |                                                        | IORDY                    : True          |
    |                                                        | Requires ATA soft start  : False         |
    |                                                        | Overlap Operation support: True          |
    |                                                        | Command Queue Support    : False         |
    |                                                        | Interleaved DMA Support  : False         |
    | Reserved1                                              | 4000h                                    |
    | PIO Timing                                             | 512                                      |
    | DMA Timing                                             | 512                                      |
    | Field Validity                                         | CHS Number               : True          |
    |                                                        | Cycle Number             : True          |
    |                                                        | Ultra DMA                : True          |
    | Current numbers of cylinders                           | 16383                                    |
    | Current numbers of heads                               | 16                                       |
    | Current numbers of sectors per track                   | 63                                       |
    | Multiple Sector Setting                                | 16514064                                 |
    | Total Number of Sectors Addressable (LBA)              | 268435455                                |
    | Singleword DMA Transfer Support                        | 0                                        |
    | Multiword DMA Transfer Support                         | Mode 0 (4.17Mb/s)                        |
    |                                                        | Mode 1 (13.3Mb/s)                        |
    |                                                        | Mode 2 (16.7Mb/s)                        |
    | Advanced PIO Modes                                     | 0003h                                    |
    | Minimum Multiword DMA Transfer Cycle Time per Word     | 120                                      |
    | Recommended Multiword DMA Transfer Cycle Time per Word | 120                                      |
    | Minimum PIO Transfer Cycle Time (No Flow Control)      | 120                                      |
    | Minimum PIO Transfer Cycle Time (Flow Control)         | 120                                      |
    | ATA Support                                            | ATA-2                                    |
    |                                                        | ATA-3                                    |
    |                                                        | ATA-4                                    |
    |                                                        | ATA/ATAPI-5                              |
    |                                                        | ATA/ATAPI-6                              |
    |                                                        | ATA/ATAPI-7                              |
    |                                                        | ATA/ATAPI-8                              |
    |                                                        | ATA/ATAPI-9                              |
    | Ultra DMA Transfer Support                             | Mode 0 (16.7MB/s)                        |
    |                                                        | Mode 1 (25.0MB/s)                        |
    |                                                        | Mode 2 (33.3MB/s)                        |
    |                                                        | Mode 3 (44.4MB/s)                        |
    |                                                        | Mode 4 (66.7MB/s)                        |
    |                                                        | Mode 5 (100.0MB/s) (selected)            |
    |                                                        | Mode 6 (133.0MB/s)                       |
    +---------------------------------------------------------------------------------------------------+

    -- Attributes
    +-------------------------------------------------------------------------------------------------------------------+
    | Index | Name                                         | Flags | Raw           | Value | Worst | Threshold | Status |
    +-------------------------------------------------------------------------------------------------------------------+
    |   05h | Reallocated Sector Count                     | 0033h | 000000000000h |   100 |   100 |        10 |     Ok |
    |   09h | Power-On Hours Count                         | 0032h | 000000008d54h |    92 |    92 |         0 |     Ok |
    |   0ch | Power Cycle Count                            | 0032h | 0000000000f5h |    99 |    99 |         0 |     Ok |
    |   b1h | Wear Range Delta                             | 0013h | 00000000005eh |    95 |    95 |         0 |     Ok |
    |   b3h | Used Reserved Block Count (Total)            | 0013h | 000000000000h |   100 |   100 |        10 |     Ok |
    |   b5h | Program Fail Count Total                     | 0032h | 000000000000h |   100 |   100 |        10 |     Ok |
    |   b6h | Erase Fail Count                             | 0032h | 000000000000h |   100 |   100 |        10 |     Ok |
    |   b7h | Sata Down Shift Error Count                  | 0013h | 000000000000h |   100 |   100 |        10 |     Ok |
    |   bbh | Reported Uncorrectable Errors                | 0032h | 000000000000h |   100 |   100 |         0 |     Ok |
    |   beh | Temperature Difference From 100              | 0032h | 000000000020h |    68 |    50 |         0 |     Ok |
    |   c3h | Hardware Ecc Recovered                       | 001ah | 000000000000h |   200 |   200 |         0 |     Ok |
    |   c7h | Udma Crc Error Rate                          | 003eh | 000000000000h |   100 |   100 |         0 |     Ok |
    |   ebh | Good Block Count And System Free Block Count | 0012h | 000000000071h |    99 |    99 |         0 |     Ok |
    |   f1h | Lifetime Writes From Host Gib                | 0032h | 00154bf298c9h |    99 |    99 |         0 |     Ok |
    +-------------------------------------------------------------------------------------------------------------------+
 
</td></tr>
</table>

```

`SECURITY.md`:

```md
# Security Policy

## Supported Versions

| Version | Supported          |
| ------- | ------------------ |
| latest  | :white_check_mark: |

## Reporting a Vulnerability

I appreciate your efforts to responsibly disclose your findings, and will make every effort to acknowledge your contributions.

To report a security issue ... open an issue :smiley:.

And after the initial check of the issue, I will keep you informed of the progress towards a fix and full announcement, and may ask for additional information or guidance.

Report security bugs in third-party modules to the person or team maintaining the module.

```

`Sources/Bitlocker/bek.cpp`:

```cpp
#include "Bitlocker/bek.h"

#include "Utils/buffer.h"
#include "Utils/utils.h"

#include "Bitlocker/bitlocker.h"

bool test_bitlocker_bek(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_vmk, ULONG32 enc_size, PBYTE salt, std::string bek_file)
{
	std::shared_ptr<Buffer<PBYTE>> bek = read_bek_file(utils::strings::from_string(bek_file));
	if (bek != nullptr)
	{
		unsigned char vmk_buffer[256] = { 0 };
		unsigned char nonce[12] = { 0 };
		*((PULONG64)nonce) = nonce_time;
		*((PULONG32)(nonce + 8)) = nonce_ctr;

		bitlocker_decrypt_data(enc_vmk, enc_size, bek->data(), mac_val, nonce, vmk_buffer);
		return bitlocker_mac_check(vmk_buffer, bek->data(), nonce, vmk_buffer + 16, enc_size);
	}
	return false;
}

void get_vmk_from_bek(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_vmk, ULONG32 enc_size, PBYTE salt, std::string bekfile, PBYTE vmk)
{
	std::shared_ptr<Buffer<PBYTE>> bek = read_bek_file(utils::strings::from_string(bekfile));
	if (bek != nullptr)
	{
		unsigned char nonce[12] = { 0 };
		*((PULONG64)nonce) = nonce_time;
		*((PULONG32)(nonce + 8)) = nonce_ctr;

		bitlocker_decrypt_data(enc_vmk, enc_size, bek->data(), mac_val, nonce, vmk);
	}
}

std::shared_ptr<Buffer<PBYTE>> read_bek_file(std::wstring filename)
{
	std::shared_ptr<Buffer<PBYTE>> key = nullptr;

	std::shared_ptr<Buffer<PBYTE>> bekfile = Buffer<PBYTE>::from_file(filename);
	PEXTERNAL_KEY_FILE pbek = (PEXTERNAL_KEY_FILE)bekfile->data();
	PFVE_ENTRY entry = POINTER_ADD(PFVE_ENTRY, bekfile->data(), pbek->metadata_header_size);
	if (entry->entry_type == FVE_METADATA_ENTRY_TYPE_STARTUP_KEY && entry->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_EXTERNAL_KEY)
	{
		PFVE_ENTRY_EXTERNAL_KEY pext = (PFVE_ENTRY_EXTERNAL_KEY)entry->data;
		key = std::make_shared<Buffer<PBYTE>>(32);
		memcpy(key->data(), pext->key + 0xc, 32);
	}

	return key;
}
```

`Sources/Bitlocker/bek.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>

#include <string>
#include <memory>

#include "Utils/buffer.h"

std::shared_ptr<Buffer<PBYTE>> read_bek_file(std::wstring filename);

bool test_bitlocker_bek(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_vmk, ULONG32 enc_size, PBYTE salt, std::string bek_file);

void get_vmk_from_bek(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_vmk, ULONG32 enc_size, PBYTE salt, std::string bekfile, PBYTE vmk);
```

`Sources/Bitlocker/bitlocker.cpp`:

```cpp
#include "Bitlocker/bitlocker.h"

void bitlocker_derive_key(unsigned char* password_hash, unsigned char* password_salt, unsigned int iterations, unsigned char* key)
{
	FVE_KEY_DATA fkd = { 0 };
	SHA256_CTX ctx = { 0 };
	uint64_t ic = 0;

	memset(&fkd, 0, sizeof(FVE_KEY_DATA));
	memcpy(fkd.initial_sha256_hash, password_hash, 32);
	memcpy(fkd.salt, password_salt, 16);

	for (ic = 0; ic < iterations; ic++) {
		SHA256_Init(&ctx);
		fkd.iteration_count = ic;
		SHA256_Update(&ctx, &fkd, sizeof(FVE_KEY_DATA));
		SHA256_Final(fkd.last_sha256_hash, &ctx);
	}

	memcpy(key, fkd.last_sha256_hash, 32);
}

void bitlocker_decrypt_data(PBYTE encrypted_data, ULONG32 encrypted_data_size, PBYTE key, PBYTE mac, PBYTE nonce, PBYTE decrypted_data)
{
	uint8_t block_data[16];
	uint8_t iv[16];
	size_t data_offset = 0;
	AES_KEY ctx;

	AES_set_encrypt_key(key, 256, &ctx);

	memset(iv, 0, 16);
	memcpy(&(iv[1]), nonce, 12);
	iv[0] = 2;

	memcpy(decrypted_data, mac, 16);
	memcpy(decrypted_data + 16, encrypted_data, encrypted_data_size);
	encrypted_data_size += 16;

	while ((data_offset + 16) < encrypted_data_size)
	{
		AES_ecb_encrypt(iv, block_data, &ctx, AES_ENCRYPT);
		for (size_t block_index = 0; block_index < 16; block_index++)
		{
			decrypted_data[data_offset++] ^= block_data[block_index];
		}
		iv[15] += 1;
	}
	if (data_offset < encrypted_data_size)
	{
		AES_ecb_encrypt(iv, block_data, &ctx, AES_ENCRYPT);
		size_t left = encrypted_data_size - data_offset;

		for (size_t block_index = 0; block_index < left; block_index++)
		{
			decrypted_data[data_offset++] ^= block_data[block_index];
		}
	}
}

bool bitlocker_mac_check(PBYTE clear_mac, PBYTE key, PBYTE nonce, PBYTE data, ULONG32 data_size)
{
	unsigned char iv[16] = { 0 };
	iv[0] = 0x3a;
	memcpy(iv + 1, nonce, 12);
	*(((PUSHORT)iv) + 7) = _byteswap_ushort((USHORT)(data_size & 0xffff));

	AES_KEY ctx;
	AES_set_encrypt_key(key, 256, &ctx);
	AES_ecb_encrypt(iv, iv, &ctx, AES_ENCRYPT);

	while (data_size > 16)
	{
		utils::crypto::xor_buffer(iv, 16, data, 16);
		AES_ecb_encrypt(iv, iv, &ctx, AES_ENCRYPT);
		data += 16;
		data_size -= 16;
	}
	if (data_size > 0)
	{
		utils::crypto::xor_buffer(iv, data_size, data, data_size);
		AES_ecb_encrypt(iv, iv, &ctx, AES_ENCRYPT);
	}

	return memcmp(clear_mac, iv, 16) == 0;
}

void get_fvek_from_vmk(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_fvek, ULONG32 enc_size, PBYTE vmk, PBYTE fvek)
{
	unsigned char nonce[12] = { 0 };
	*((PULONG64)nonce) = nonce_time;
	*((PULONG32)(nonce + 8)) = nonce_ctr;

	bitlocker_decrypt_data(enc_fvek, enc_size, vmk, mac_val, nonce, fvek);
}
```

`Sources/Bitlocker/bitlocker.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>

#include <memory>
#include <string>

#include "openssl/sha.h"
#include "openssl/aes.h"

#include "Utils/buffer.h"
#include "Utils/utils.h"

#include "Bitlocker/fve.h"

#pragma pack(push, 1)

typedef struct _FVE_BLOCK_HEADER
{
	CHAR		signature[8];
	WORD		size;
	WORD		version;
	WORD		curr_state;
	WORD		next_state;
	DWORD64		encrypted_volume_size;
	DWORD convert_size;
	DWORD nb_sectors;
	DWORD64		block_header_offsets[3];
	DWORD64		backup_sector_offset;
} FVE_BLOCK_HEADER, * PFVE_BLOCK_HEADER;

typedef struct _FVE_HEADER
{
	DWORD		size;
	DWORD		version;
	DWORD		header_size;
	DWORD		copy_size;
	GUID		volume_guid;
	DWORD		next_counter;
	WORD		algorithm;
	WORD		algorithm_unused;
	FILETIME	timestamp;
} FVE_HEADER, * PFVE_HEADER;

typedef struct _FVE_ENTRY
{
	WORD		size;
	WORD		entry_type;
	WORD		value_type;
	WORD		version;
	CHAR		data[1];
} FVE_ENTRY, * PFVE_ENTRY;

typedef struct _FVE_ENTRY_KEY
{
	DWORD		encryption_method;
	BYTE		key[1];
} FVE_ENTRY_KEY, * PFVE_ENTRY_KEY;

typedef struct _FVE_ENTRY_UNICODE
{
	WCHAR string[1];
} FVE_ENTRY_UNICODE, * PFVE_ENTRY_UNICODE;

typedef struct _FVE_ENTRY_STRETCH_KEY
{
	ULONG32		encryption_method;
	BYTE		salt[16];
	BYTE		subentries[1];
} FVE_ENTRY_STRETCH_KEY, * PFVE_ENTRY_STRETCH_KEY;

typedef struct _FVE_ENTRY_USE_KEY
{
	ULONG32		encryption_method;
	BYTE		subentries[1];
} FVE_ENTRY_USE_KEY, * PFVE_ENTRY_USE_KEY;

typedef struct _FVE_ENTRY_AES_CCM
{
	FILETIME	nonce_time;
	ULONG32		nonce_counter;
	BYTE		mac[16];
	BYTE		key[1];
} FVE_ENTRY_AES_CCM, * PFVE_ENTRY_AES_CCM;

typedef struct _FVE_ENTRY_VMK
{
	GUID		key_id;
	FILETIME	last_change;
	WORD		unknown;
	WORD		protection_type;
	BYTE		subentries[1];
} FVE_ENTRY_VMK, * PFVE_ENTRY_VMK;

typedef struct _FVE_ENTRY_EXTERNAL_KEY
{
	GUID		key_id;
	FILETIME	last_change;
	BYTE		key[1];
} FVE_ENTRY_EXTERNAL_KEY, * PFVE_ENTRY_EXTERNAL_KEY;

typedef struct _FVE_ENTRY_OFFSET_SIZE
{
	DWORD64		offset;
	DWORD64		size;
	BYTE		data[1];
} FVE_ENTRY_OFFSET_SIZE, * PFVE_ENTRY_OFFSET_SIZE;

typedef struct _FVE_KEY_DATA
{
	BYTE last_sha256_hash[32];
	BYTE initial_sha256_hash[32];
	BYTE salt[16];
	ULONG64 iteration_count;
} FVE_KEY_DATA, * PFVE_KEY_DATA;

typedef struct _FVE_VMK
{
	BYTE		mac[16];
	DWORD		size;
	DWORD		version;
	DWORD		algorithm;
	BYTE		vmk[1];
} FVE_VMK, * PFVE_VMK;

typedef struct _FVE_FVEK
{
	BYTE		mac[16];
	DWORD		size;
	DWORD		version;
	DWORD		algorithm;
	BYTE		fvek[1];
} FVE_FVEK, * PFVE_FVEK;

typedef struct
{
	DWORD		metadata_size;
	DWORD		version;
	DWORD		metadata_header_size;
	DWORD		metadata_size_backup;
	GUID		key_id;
	DWORD		next_nonce;
	DWORD		encryption_method;
	FILETIME	creation;
	BYTE		entries[1];
} EXTERNAL_KEY_FILE, * PEXTERNAL_KEY_FILE;

#pragma pack(pop)

void bitlocker_derive_key(unsigned char* password_hash, unsigned char* password_salt, unsigned int iterations, unsigned char* key);

void bitlocker_decrypt_data(PBYTE encrypted_data, ULONG32 encrypted_data_size, PBYTE key, PBYTE mac, PBYTE nonce, PBYTE decrypted_data);

bool bitlocker_mac_check(PBYTE clear_mac, PBYTE key, PBYTE nonce, PBYTE data, ULONG32 data_size);

void get_fvek_from_vmk(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_fvek, ULONG32 enc_size, PBYTE vmk, PBYTE fvek);
```

`Sources/Bitlocker/decryption.cpp`:

```cpp
#include "Bitlocker/decryption.h"

#include "Utils/utils.h"

#pragma comment(lib, "gdi32")
#pragma comment(lib, "crypt32")

void diffuser_a_decrypt(uint8_t* sector, uint16_t sector_size, uint32_t* buffer)
{
	int Acycles = 5;
	uint16_t Ra[] = { 9, 0, 13, 0 };
	uint16_t int_size = sector_size >> 2;

	while (Acycles--)
	{
		for (int i = 0; i < int_size; ++i)
		{
			*(buffer + i) = *(buffer + i) + (*(buffer + ((i - 2 + int_size) % int_size)) ^ ROTATE_LEFT(*(buffer + ((i - 5 + int_size) % int_size)), Ra[i % 4]));
		}
	}
}

void diffuser_b_decrypt(uint8_t* sector, uint16_t sector_size, uint32_t* buffer)
{
	int Bcycles = 3;
	uint16_t Rb[] = { 0, 10, 0, 25 };
	uint16_t int_size = sector_size / 4;

	while (Bcycles--)
	{
		for (int i = 0; i < int_size; ++i)
		{
			*(buffer + i) = *(buffer + i) + (*(buffer + ((i + 2) % int_size)) ^ ROTATE_LEFT(*(buffer + ((i + 5) % int_size)), Rb[i % 4]));
		}
	}
}

void decrypt_sector_aes_128(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted)
{
	int len = 0;
	unsigned char null_iv[16] = { 0 };
	union {
		unsigned char data[16] = { 0 };
		DWORD64 sector;
	} iv;
	iv.sector = sector_offset;
	EVP_EncryptInit(pctx, EVP_aes_128_ecb(), key, null_iv);
	EVP_EncryptUpdate(pctx, iv.data, &len, iv.data, 16);
	EVP_CIPHER_CTX_cleanup(pctx);

	EVP_DecryptInit(pctx, EVP_aes_128_cbc(), key, iv.data);
	EVP_DecryptUpdate(pctx, decrypted, &len, sector, sector_size);
	EVP_CIPHER_CTX_cleanup(pctx);
}

void decrypt_sector_aes_128_diffuser(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted)
{
	int len = 0;
	unsigned char null_iv[16] = { 0 };
	union {
		unsigned char data[16] = { 0 };
		DWORD64 sector;
	} iv;
	iv.sector = sector_offset;

	uint8_t sector_key[32] = { 0 };

	EVP_EncryptInit(pctx, EVP_aes_128_ecb(), key + 0x20, null_iv);
	EVP_EncryptUpdate(pctx, sector_key, &len, iv.data, 16);
	iv.data[15] = 0x80;
	EVP_EncryptUpdate(pctx, sector_key + 16, &len, iv.data, 16);
	EVP_CIPHER_CTX_cleanup(pctx);

	decrypt_sector_aes_128(pctx, sector, key, sector_offset, sector_size, decrypted);

	diffuser_b_decrypt(decrypted, sector_size & 0xffff, (uint32_t*)decrypted);
	diffuser_a_decrypt(decrypted, sector_size & 0xffff, (uint32_t*)decrypted);

	utils::crypto::xor_buffer(decrypted, sector_size, sector_key, 32);
}

void decrypt_sector_aes_256(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted)
{
	int len = 0;
	unsigned char null_iv[16] = { 0 };
	union {
		unsigned char data[16] = { 0 };
		DWORD64 sector;
	} iv;
	iv.sector = sector_offset;
	EVP_EncryptInit(pctx, EVP_aes_256_ecb(), key, null_iv);
	EVP_EncryptUpdate(pctx, iv.data, &len, iv.data, 16);
	EVP_CIPHER_CTX_cleanup(pctx);

	EVP_DecryptInit(pctx, EVP_aes_256_cbc(), key, iv.data);
	EVP_DecryptUpdate(pctx, decrypted, &len, sector, sector_size);
	EVP_CIPHER_CTX_cleanup(pctx);
}

void decrypt_sector_aes_256_diffuser(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted)
{
	int len = 0;
	unsigned char null_iv[16] = { 0 };
	union {
		unsigned char data[16] = { 0 };
		DWORD64 sector;
	} iv;
	iv.sector = sector_offset;

	uint8_t sector_key[32] = { 0 };

	EVP_EncryptInit(pctx, EVP_aes_256_ecb(), key + 0x20, null_iv);
	EVP_EncryptUpdate(pctx, sector_key, &len, iv.data, 16);
	iv.data[15] = 0x80;
	EVP_EncryptUpdate(pctx, sector_key + 16, &len, iv.data, 16);
	EVP_CIPHER_CTX_cleanup(pctx);

	decrypt_sector_aes_256(pctx, sector, key, sector_offset, sector_size, decrypted);

	diffuser_b_decrypt(decrypted, sector_size & 0xffff, (uint32_t*)decrypted);
	diffuser_a_decrypt(decrypted, sector_size & 0xffff, (uint32_t*)decrypted);

	utils::crypto::xor_buffer(decrypted, sector_size, sector_key, 32);
}

void decrypt_sector_xts_256(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted)
{
	int len = 0;
	union {
		unsigned char data[16] = { 0 };
		DWORD64 sector;
	} iv;
	iv.sector = sector_offset / sector_size;
	EVP_DecryptInit(pctx, EVP_aes_256_xts(), key, iv.data);
	EVP_DecryptUpdate(pctx, decrypted, &len, sector, sector_size);
	EVP_CIPHER_CTX_cleanup(pctx);
}

void decrypt_sector_xts_128(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted)
{
	int len = 0;
	union {
		unsigned char data[16] = { 0 };
		DWORD64 sector;
	} iv;
	iv.sector = sector_offset / sector_size;
	EVP_DecryptInit(pctx, EVP_aes_128_xts(), key, iv.data);
	EVP_DecryptUpdate(pctx, decrypted, &len, sector, sector_size);
	EVP_CIPHER_CTX_cleanup(pctx);
}
```

`Sources/Bitlocker/decryption.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>

#include <openssl/aes.h>
#include <openssl/evp.h>

#define ROTATE_LEFT(a,n)  (((a) << (n)) | ((a) >> ((sizeof(a) * 8)-(n))))

typedef void (*decrypt_fn)(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted);

void diffuser_a_decrypt(uint8_t* sector, uint16_t sector_size, uint32_t* buffer);

void diffuser_b_decrypt(uint8_t* sector, uint16_t sector_size, uint32_t* buffer);

void decrypt_sector_aes_128(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted);

void decrypt_sector_aes_128_diffuser(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted);

void decrypt_sector_aes_256(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted);

void decrypt_sector_aes_256_diffuser(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted);

void decrypt_sector_xts_256(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted);

void decrypt_sector_xts_128(EVP_CIPHER_CTX* pctx, PBYTE sector, PBYTE key, DWORD64 sector_offset, DWORD sector_size, PBYTE decrypted);
```

`Sources/Bitlocker/fve.h`:

```h
#pragma once

#define FVE_METADATA_ENTRY_VALUE_TYPE_ERASED				0x0000
#define FVE_METADATA_ENTRY_VALUE_TYPE_KEY					0x0001
#define FVE_METADATA_ENTRY_VALUE_TYPE_UNICODE_STRING		0x0002
#define FVE_METADATA_ENTRY_VALUE_TYPE_STRETCH_KEY			0x0003
#define FVE_METADATA_ENTRY_VALUE_TYPE_USE_KEY				0x0004
#define FVE_METADATA_ENTRY_VALUE_TYPE_AES_CCM_ENCRYPTED_KEY 0x0005
#define FVE_METADATA_ENTRY_VALUE_TYPE_TPM_ENCODED_KEY		0x0006
#define FVE_METADATA_ENTRY_VALUE_TYPE_VALIDATION			0x0007
#define FVE_METADATA_ENTRY_VALUE_TYPE_VOLUME_MASTER_KEY		0x0008
#define FVE_METADATA_ENTRY_VALUE_TYPE_EXTERNAL_KEY			0x0009
#define FVE_METADATA_ENTRY_VALUE_TYPE_UPDATE				0x000a
#define FVE_METADATA_ENTRY_VALUE_TYPE_ERROR					0x000b
#define FVE_METADATA_ENTRY_VALUE_TYPE_ASYMMETRIC_ENCRYPTION	0x000c
#define FVE_METADATA_ENTRY_VALUE_TYPE_EXPORTED_KEY			0x000d
#define FVE_METADATA_ENTRY_VALUE_TYPE_PUBLIC_KEY			0x000e
#define FVE_METADATA_ENTRY_VALUE_TYPE_OFFSET_AND_SIZE		0x000f
#define FVE_METADATA_ENTRY_VALUE_TYPE_CONCAT_HASH_KEY		0x0012

#define FVE_METADATA_ENTRY_TYPE_PROPERTY					0x0000
#define FVE_METADATA_ENTRY_TYPE_VMK							0x0002
#define FVE_METADATA_ENTRY_TYPE_FKEV						0x0003
#define FVE_METADATA_ENTRY_TYPE_VALIDATION					0x0004
#define FVE_METADATA_ENTRY_TYPE_STARTUP_KEY					0x0006
#define FVE_METADATA_ENTRY_TYPE_DRIVE_LABEL					0x0007
#define FVE_METADATA_ENTRY_TYPE_AUTO_UNLOCK					0x000b
#define FVE_METADATA_ENTRY_TYPE_VOLUME_HEADER_BLOCK			0x000f

#define FVE_METADATA_KEY_PROTECTION_TYPE_CLEARTEXT			0x0000
#define FVE_METADATA_KEY_PROTECTION_TYPE_TPM				0x0100
#define FVE_METADATA_KEY_PROTECTION_TYPE_STARTUP_KEY		0x0200
#define FVE_METADATA_KEY_PROTECTION_TYPE_TPM_PIN			0x0500
#define FVE_METADATA_KEY_PROTECTION_TYPE_RECOVERY_PASSWORD	0x0800
#define FVE_METADATA_KEY_PROTECTION_TYPE_PASSWORD			0x2000

#define FVE_METADATA_MAC_LEN								16
#define FVE_METADATA_NONCE_LEN								12
```

`Sources/Bitlocker/password.cpp`:

```cpp
#include "Bitlocker/password.h"

#include <openssl/sha.h>
#include <Bitlocker\bitlocker.h>

void bitlocker_prepare_password(std::string password, unsigned char* password_hash)
{
	std::u16string password_utf16_le = utils::strings::str_to_utf16(password);

	SHA256_CTX ctx = { 0 };
	SHA256_Init(&ctx);
	SHA256_Update(&ctx, password_utf16_le.c_str(), password_utf16_le.size() * 2);
	SHA256_Final(password_hash, &ctx);
	SHA256_Init(&ctx);
	SHA256_Update(&ctx, password_hash, 32);
	SHA256_Final(password_hash, &ctx);
}

bool test_bitlocker_password(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_vmk, ULONG32 enc_size, PBYTE salt, const std::string& password)
{
	unsigned char key_buffer[32] = { 0 };
	unsigned char vmk_buffer[256] = { 0 };

	unsigned char nonce[12] = { 0 };
	*((PULONG64)nonce) = nonce_time;
	*((PULONG32)(nonce + 8)) = nonce_ctr;

	bitlocker_prepare_password(password, key_buffer);
	bitlocker_derive_key(key_buffer, salt, 1048576, key_buffer);
	bitlocker_decrypt_data(enc_vmk, enc_size, key_buffer, mac_val, nonce, vmk_buffer);
	return bitlocker_mac_check(vmk_buffer, key_buffer, nonce, vmk_buffer + 16, enc_size);
}

void get_vmk_from_password(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_vmk, ULONG32 enc_size, PBYTE salt, const std::string& password, PBYTE vmk)
{
	unsigned char key_buffer[32] = { 0 };

	unsigned char nonce[12] = { 0 };
	*((PULONG64)nonce) = nonce_time;
	*((PULONG32)(nonce + 8)) = nonce_ctr;

	bitlocker_prepare_password(password, key_buffer);
	bitlocker_derive_key(key_buffer, salt, 1048576, key_buffer);
	bitlocker_decrypt_data(enc_vmk, enc_size, key_buffer, mac_val, nonce, vmk);
}
```

`Sources/Bitlocker/password.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>

#include <string>
#include <memory>

#include "Utils/buffer.h"
#include "Utils/utils.h"

void get_vmk_from_password(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_vmk, ULONG32 enc_size, PBYTE salt, const std::string& password, PBYTE vmk);

bool test_bitlocker_password(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_vmk, ULONG32 enc_size, PBYTE salt, const std::string& password);
std::shared_ptr<Buffer<PBYTE>> read_bek_file(std::wstring filename);

void bitlocker_prepare_password(std::string password, unsigned char* password_hash);
```

`Sources/Bitlocker/recovery.cpp`:

```cpp
#include "Bitlocker/recovery.h"
#include <Bitlocker\bitlocker.h>

bool bitlocker_check_recovery_key(std::string recovery)
{
	std::vector<std::string> blocks = utils::strings::split(recovery, '-');
	if (blocks.size() != 8) return false;

	for (int b = 0; b < 8; b++)
	{
		if (atol(blocks[b].c_str()) % 11 != 0) return false;
		if (atol(blocks[b].c_str()) > 720896) return false;
		int check = (blocks[b][0] - blocks[b][1] + blocks[b][2] - blocks[b][3] + blocks[b][4] - 48) % 11;
		while (check < 0) check += 11;

		if (check != (blocks[b][5] - 48)) return false;
	}

	return true;
}

void bitlocker_prepare_recovery_key(std::string recovery, unsigned char* recovery_hash)
{
	PUSHORT recovery_hash_tmp = (PUSHORT)recovery_hash;

	ULONG32 blocks[8] = { 0 };

	int ret = sscanf_s(recovery.c_str(), "%6u-%6u-%6u-%6u-%6u-%6u-%6u-%6u", &blocks[0], &blocks[1], &blocks[2], &blocks[3], &blocks[4], &blocks[5], &blocks[6], &blocks[7]);
	if (ret == 8)
	{
		for (int b = 0; b < 8; b++)
		{
			recovery_hash_tmp[b] = (USHORT)(blocks[b] / 11);
		}
	}

	SHA256_CTX ctx = { 0 };
	SHA256_Init(&ctx);
	SHA256_Update(&ctx, recovery_hash, 16);
	SHA256_Final(recovery_hash, &ctx);
}

bool test_bitlocker_recovery(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_vmk, ULONG32 enc_size, PBYTE salt, const std::string& recovery)
{
	if (bitlocker_check_recovery_key(recovery))
	{
		unsigned char nonce[12] = { 0 };
		*((PULONG64)nonce) = nonce_time;
		*((PULONG32)(nonce + 8)) = nonce_ctr;

		unsigned char key_buffer[32] = { 0 };

		unsigned char vmk_buffer[256] = { 0 };

		bitlocker_prepare_recovery_key(recovery, key_buffer);
		bitlocker_derive_key(key_buffer, salt, 1048576, key_buffer);
		bitlocker_decrypt_data(enc_vmk, enc_size, key_buffer, mac_val, nonce, vmk_buffer);
		return bitlocker_mac_check(vmk_buffer, key_buffer, nonce, vmk_buffer + 16, enc_size);
	}

	return false;
}

void get_vmk_from_recovery(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_vmk, ULONG32 enc_size, PBYTE salt, const std::string& recovery, PBYTE vmk)
{
	if (bitlocker_check_recovery_key(recovery))
	{
		unsigned char nonce[12] = { 0 };
		*((PULONG64)nonce) = nonce_time;
		*((PULONG32)(nonce + 8)) = nonce_ctr;

		unsigned char key_buffer[32] = { 0 };

		bitlocker_prepare_recovery_key(recovery, key_buffer);
		bitlocker_derive_key(key_buffer, salt, 1048576, key_buffer);
		bitlocker_decrypt_data(enc_vmk, enc_size, key_buffer, mac_val, nonce, vmk);
	}
}
```

`Sources/Bitlocker/recovery.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>

#include <string>
#include <memory>

#include "Utils/buffer.h"
#include "Utils/utils.h"

bool bitlocker_check_recovery_key(std::string recovery);

void bitlocker_prepare_recovery_key(std::string recovery, unsigned char* recovery_hash);

bool test_bitlocker_recovery(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_vmk, ULONG32 enc_size, PBYTE salt, const std::string& recovery);

void get_vmk_from_recovery(ULONG64 nonce_time, ULONG32 nonce_ctr, PBYTE mac_val, PBYTE enc_vmk, ULONG32 enc_size, PBYTE salt, const std::string& recovery, PBYTE vmk);

```

`Sources/Commands/command_bitdecrypt.cpp`:

```cpp
#include <algorithm>
#include <cstdint>
#include <string>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>
#include <stdexcept>

#include "Drive/disk.h"
#include "Drive/vbr.h"
#include "Drive/reader.h"
#include "Bitlocker/bitlocker.h"
#include "options.h"
#include "Utils/utils.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"

#include <NTFS\ntfs_reader.h>
#include <Bitlocker\decryption.h>

int decrypt_volume(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	std::cout << std::setfill('0');
	utils::ui::title("Decrypt Bitlocker Volume from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	DWORD sector_size = ((PBOOT_SECTOR_FAT32)vol->bootsector())->bytePerSector;

	std::cout << "[+] Opening " << vol->name() << std::endl;

	std::shared_ptr<Reader> reader = std::make_shared<Reader>(utils::strings::from_string(disk->name()));
	reader->seek(vol->offset());

	std::shared_ptr<Buffer<PBYTE>> fvek = utils::convert::from_hex(opts->fvek);

	PBOOT_SECTOR_COMMON pbsc = (PBOOT_SECTOR_COMMON)vol->bootsector();
	if (strncmp((char*)pbsc->oemID, "-FVE-FS-", 8) == 0)
	{
		std::cout << "[+] Reading Bitlocker VBR" << std::endl;
		std::cout << "[-]   Volume State   : " << constants::bitlocker::state(vol->bitlocker().metadata[0].block_header.curr_state) << std::endl;
		std::cout << "[-]   Size           : " << vol->size() << " (" << utils::format::size(vol->size()) << ")" << std::endl;
		std::cout << "[-]   Encrypted Size : " << vol->bitlocker().metadata[0].block_header.encrypted_volume_size << " (" << utils::format::size(vol->bitlocker().metadata[0].block_header.encrypted_volume_size) << ")" << std::endl;
		std::cout << "[-]   Algorithm      : " << constants::bitlocker::algorithm(vol->bitlocker().metadata[0].header.algorithm) << std::endl;

		decrypt_fn decrypt_sector_fn = nullptr;
		switch (vol->bitlocker().metadata[0].header.algorithm)
		{
		case 0x8000:
			decrypt_sector_fn = decrypt_sector_aes_128_diffuser;
			break;
		case 0x8001:
			decrypt_sector_fn = decrypt_sector_aes_256_diffuser;
			break;
		case 0x8002:
			decrypt_sector_fn = decrypt_sector_aes_128;
			break;
		case 0x8003:
			decrypt_sector_fn = decrypt_sector_aes_256;
			break;
		case 0x8004:
			decrypt_sector_fn = decrypt_sector_xts_128;
			break;
		case 0x8005:
			decrypt_sector_fn = decrypt_sector_xts_256;
			break;
		default:
			decrypt_sector_fn = nullptr;
			std::cerr << "[!] Invalid or not implemented decryption algorithm (" << utils::format::hex(vol->bitlocker().metadata[0].header.algorithm, true) << ")" << std::endl;
			return 1;
		}

		FVE_BLOCK_HEADER fve_bh = vol->bitlocker().metadata[0].block_header;

		HANDLE houtput = CreateFileA(opts->output.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		if (houtput == INVALID_HANDLE_VALUE)
		{
			std::cout << "[!] Error creating output file" << std::endl;
			return 1;
		}

		ULONG64 processed_count = 0;
		DWORD64 total_size = vol->bitlocker().metadata[0].block_header.encrypted_volume_size;
		Buffer<PBYTE> sectorBuff(sector_size);
		Buffer<PBYTE> decSectorBuff(sector_size);
		EVP_CIPHER_CTX* pctx = EVP_CIPHER_CTX_new();

		auto prof_start = std::chrono::high_resolution_clock::now();

		reader->seek(vol->offset() + fve_bh.backup_sector_offset);

		DWORD64 sector_offset = fve_bh.backup_sector_offset;
		DWORD written = 0;
		for (DWORD i = 0; i < fve_bh.nb_sectors; i++)
		{
			reader->read(sectorBuff.data(), sector_size);
			decrypt_sector_fn(pctx, sectorBuff.data(), fvek->data(), sector_offset, sector_size, decSectorBuff.data());
			WriteFile(houtput, decSectorBuff.data(), sector_size, &written, NULL);

			sector_offset += sector_size;
			processed_count += sector_size;
		}

		std::cout << "[+] Decrypting sectors" << std::endl;

		sector_offset = (DWORD64)fve_bh.nb_sectors * sector_size;
		reader->seek(vol->offset() + sector_offset);

		DWORD64 sector_offset_max = 1 + ((total_size - 1) / sector_size);
		for (DWORD i = fve_bh.nb_sectors; i < sector_offset_max; i++)
		{
			reader->read(sectorBuff.data(), sector_size);
			decrypt_sector_fn(pctx, sectorBuff.data(), fvek->data(), sector_offset, sector_size, decSectorBuff.data());
			WriteFile(houtput, decSectorBuff.data(), sector_size, &written, NULL);

			sector_offset += sector_size;
			processed_count += sector_size;
			if ((processed_count & 0xfffff) == 0)
			{
				std::cout << "\r[-]   Processed data size : " << utils::format::size(processed_count) << " (" << std::to_string(100 * processed_count / total_size) << "%)";
			}
		}
		std::cout << "\r[-]   Processed data size : " << utils::format::size(processed_count) << " (" << std::to_string(100 * processed_count / total_size) << "%)";
		std::cout << std::endl << "[+] Duration : " << std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now() - prof_start).count() / 1000 << "ms" << std::endl;

		EVP_CIPHER_CTX_free(pctx);
		CloseHandle(houtput);
		std::cout << "[+] Closing Volume" << std::endl;
	}
	else
	{
		std::cout << "[!] Volume is not Bitlocked" << std::endl;
	}
	return 0;
}

namespace commands
{
	namespace bitdecrypt
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
				if (volume != nullptr)
				{
					if (opts->output == "")
					{
						invalid_option(opts, "output", opts->output);
					}
					if (opts->fvek == "")
					{
						invalid_option(opts, "fvek", opts->fvek);
					}
					decrypt_volume(disk, volume, opts);
				}
				else
				{
					invalid_option(opts, "volume", opts->volume);
				}
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_bitlocker.cpp`:

```cpp

#include <algorithm>
#include <cstdint>
#include <string>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>
#include <stdexcept>
#include <fstream>

#include "Drive/disk.h"
#include "Drive/vbr.h"
#include "Bitlocker/bitlocker.h"
#include "Bitlocker/bek.h"
#include "Bitlocker/password.h"
#include "options.h"
#include "Utils/utils.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"
#include <Bitlocker\recovery.h>
#include "commands.h"

void print_test_bitlocker_password(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	std::cout << std::setfill('0');
	utils::ui::title("Bitlocker Password Test for " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	PBOOT_SECTOR_COMMON pbsc = (PBOOT_SECTOR_COMMON)vol->bootsector();
	if (strncmp((char*)pbsc->oemID, "-FVE-FS-", 8) == 0)
	{
		std::cout << "FVE Version    : " << vol->bitlocker().metadata[0].block_header.version << std::endl;
		std::cout << "State          : " << constants::bitlocker::state(vol->bitlocker().metadata[0].block_header.curr_state) << std::endl;
		std::cout << "Size           : " << vol->size() << " (" << utils::format::size(vol->size()) << ")" << std::endl;
		std::cout << "Encrypted Size : " << vol->bitlocker().metadata[0].block_header.encrypted_volume_size << " (" << utils::format::size(vol->bitlocker().metadata[0].block_header.encrypted_volume_size) << ")" << std::endl;
		std::cout << "Algorithm      : " << constants::bitlocker::algorithm(vol->bitlocker().metadata[0].header.algorithm) << std::endl;
		SYSTEMTIME st;
		utils::times::filetime_to_local_systemtime(vol->bitlocker().metadata[0].header.timestamp, &st);
		std::cout << "Timestamp      : " << utils::times::display_systemtime(st) << std::endl;
		std::cout << std::endl;

		std::shared_ptr<utils::ui::Table> table = std::make_shared<utils::ui::Table>();
		table->set_interline(true);

		table->add_header_line("Id");
		table->add_header_line("Type");
		table->add_header_line("GUID");
		table->add_header_line("Password");
		table->add_header_line("Result");

		PFVE_ENTRY fvek_entry = nullptr;
		for (auto& entry : vol->bitlocker().metadata[0].entries)
		{
			if (entry->data()->entry_type == FVE_METADATA_ENTRY_TYPE_FKEV && entry->data()->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_AES_CCM_ENCRYPTED_KEY)
			{
				fvek_entry = entry->data();
			}
		}

		unsigned int n = 0;
		for (auto& entry : vol->bitlocker().metadata[0].entries)
		{
			if (entry->data()->entry_type == FVE_METADATA_ENTRY_TYPE_VMK && entry->data()->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_VOLUME_MASTER_KEY)
			{
				n++;
				if (((PFVE_ENTRY_VMK)entry->data()->data)->protection_type == FVE_METADATA_KEY_PROTECTION_TYPE_PASSWORD)
				{
					table->add_item_line(std::to_string(n));
					table->add_item_line(constants::bitlocker::fve_key_protection_type(((PFVE_ENTRY_VMK)entry->data()->data)->protection_type));
					table->add_item_line(utils::id::guid_to_string(((PFVE_ENTRY_VMK)entry->data()->data)->key_id));

					ULONG64 nonce_time = 0;
					ULONG32 nonce_ctr = 0;
					ULONG32 enc_size = 0;
					BYTE* salt = NULL;
					BYTE* mac_val = NULL;
					BYTE* enc_key = NULL;

					int sub_entry_size_left = entry->data()->size - 36;
					PFVE_ENTRY psubentry = (PFVE_ENTRY)(((PFVE_ENTRY_VMK)entry->data()->data)->subentries);
					while (sub_entry_size_left > 0)
					{
						if (psubentry->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_AES_CCM_ENCRYPTED_KEY)
						{
							nonce_time = ULARGE_INTEGER{ ((PFVE_ENTRY_AES_CCM)psubentry->data)->nonce_time.dwLowDateTime, ((PFVE_ENTRY_AES_CCM)psubentry->data)->nonce_time.dwHighDateTime }.QuadPart;
							nonce_ctr = ((PFVE_ENTRY_AES_CCM)psubentry->data)->nonce_counter;
							mac_val = ((PFVE_ENTRY_AES_CCM)psubentry->data)->mac;
							enc_key = ((PFVE_ENTRY_AES_CCM)psubentry->data)->key;
							enc_size = psubentry->size - 36;
							break;
						}
						if (psubentry->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_STRETCH_KEY)
						{
							salt = ((PFVE_ENTRY_STRETCH_KEY)psubentry->data)->salt;
						}
						sub_entry_size_left -= psubentry->size;
						psubentry = POINTER_ADD(PFVE_ENTRY, psubentry, psubentry->size);
					}

					table->add_item_line(opts->password);

					std::vector<std::string> content;

					bool valid = enc_key && mac_val && salt && test_bitlocker_password(nonce_time, nonce_ctr, mac_val, enc_key, enc_size, salt, opts->password);
					content.push_back(valid ? "Valid" : "Invalid");
					if (valid)
					{
						content.push_back("");

						unsigned char vmk_buffer[256] = { 0 };
						get_vmk_from_password(nonce_time, nonce_ctr, mac_val, enc_key, enc_size, salt, opts->password, vmk_buffer);
						content.push_back("VMK  : " + utils::format::hex(((PFVE_VMK)vmk_buffer)->vmk, 32));

						if (fvek_entry != nullptr)
						{
							unsigned char fvek_buffer[256] = { 0 };

							nonce_time = ULARGE_INTEGER{ ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->nonce_time.dwLowDateTime, ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->nonce_time.dwHighDateTime }.QuadPart;
							nonce_ctr = ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->nonce_counter;
							mac_val = ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->mac;
							enc_key = ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->key;
							enc_size = fvek_entry->size - 36;

							get_fvek_from_vmk(nonce_time, nonce_ctr, mac_val, enc_key, enc_size, ((PFVE_VMK)vmk_buffer)->vmk, fvek_buffer);
							content.push_back("FVEK : " + utils::format::hex(((PFVE_FVEK)fvek_buffer)->fvek, ((PFVE_FVEK)fvek_buffer)->size - 0xc));
						}
					}

					table->add_item_multiline(content);

					table->new_line();
				}
			}
		}

		utils::ui::title("Tested Password:");
		table->render(std::cout);
		std::cout << std::endl;
	}
	else
	{
		std::cout << "[!] Volume is not Bitlocked" << std::endl;
	}
}

void print_test_bitlocker_recovery(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	std::cout << std::setfill('0');
	utils::ui::title("Bitlocker Recovery Key Test for " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	PBOOT_SECTOR_COMMON pbsc = (PBOOT_SECTOR_COMMON)vol->bootsector();
	if (strncmp((char*)pbsc->oemID, "-FVE-FS-", 8) == 0)
	{
		std::cout << "FVE Version    : " << vol->bitlocker().metadata[0].block_header.version << std::endl;
		std::cout << "State          : " << constants::bitlocker::state(vol->bitlocker().metadata[0].block_header.curr_state) << std::endl;
		std::cout << "Size           : " << vol->size() << " (" << utils::format::size(vol->size()) << ")" << std::endl;
		std::cout << "Encrypted Size : " << vol->bitlocker().metadata[0].block_header.encrypted_volume_size << " (" << utils::format::size(vol->bitlocker().metadata[0].block_header.encrypted_volume_size) << ")" << std::endl;
		std::cout << "Algorithm      : " << constants::bitlocker::algorithm(vol->bitlocker().metadata[0].header.algorithm) << std::endl;
		SYSTEMTIME st;
		utils::times::filetime_to_local_systemtime(vol->bitlocker().metadata[0].header.timestamp, &st);
		std::cout << "Timestamp      : " << utils::times::display_systemtime(st) << std::endl;
		std::cout << std::endl;

		std::shared_ptr<utils::ui::Table> table = std::make_shared<utils::ui::Table>();
		table->set_interline(true);

		PFVE_ENTRY fvek_entry = nullptr;
		for (auto& entry : vol->bitlocker().metadata[0].entries)
		{
			if (entry->data()->entry_type == FVE_METADATA_ENTRY_TYPE_FKEV && entry->data()->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_AES_CCM_ENCRYPTED_KEY)
			{
				fvek_entry = entry->data();
			}
		}

		table->add_header_line("Id");
		table->add_header_line("Type");
		table->add_header_line("GUID");
		table->add_header_line("Recovery Key");
		table->add_header_line("Result");

		unsigned int n = 0;
		for (auto& entry : vol->bitlocker().metadata[0].entries)
		{
			if (entry->data()->entry_type == FVE_METADATA_ENTRY_TYPE_VMK && entry->data()->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_VOLUME_MASTER_KEY)
			{
				n++;
				if (((PFVE_ENTRY_VMK)entry->data()->data)->protection_type == FVE_METADATA_KEY_PROTECTION_TYPE_RECOVERY_PASSWORD)
				{
					table->add_item_line(std::to_string(n));
					table->add_item_line(constants::bitlocker::fve_key_protection_type(((PFVE_ENTRY_VMK)entry->data()->data)->protection_type));
					table->add_item_line(utils::id::guid_to_string(((PFVE_ENTRY_VMK)entry->data()->data)->key_id));

					ULONG64 nonce_time = 0;
					ULONG32 nonce_ctr = 0;
					ULONG32 enc_size = 0;
					BYTE* salt = nullptr;
					BYTE* mac_val = nullptr;
					BYTE* enc_key = nullptr;

					int sub_entry_size_left = entry->data()->size - 36;
					PFVE_ENTRY psubentry = (PFVE_ENTRY)(((PFVE_ENTRY_VMK)entry->data()->data)->subentries);
					while (sub_entry_size_left > 0)
					{
						if (psubentry->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_AES_CCM_ENCRYPTED_KEY)
						{
							nonce_time = ULARGE_INTEGER{ ((PFVE_ENTRY_AES_CCM)psubentry->data)->nonce_time.dwLowDateTime, ((PFVE_ENTRY_AES_CCM)psubentry->data)->nonce_time.dwHighDateTime }.QuadPart;
							nonce_ctr = ((PFVE_ENTRY_AES_CCM)psubentry->data)->nonce_counter;
							mac_val = ((PFVE_ENTRY_AES_CCM)psubentry->data)->mac;
							enc_key = ((PFVE_ENTRY_AES_CCM)psubentry->data)->key;
							enc_size = psubentry->size - 36;
							break;
						}
						if (psubentry->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_STRETCH_KEY)
						{
							salt = ((PFVE_ENTRY_STRETCH_KEY)psubentry->data)->salt;
						}
						sub_entry_size_left -= psubentry->size;
						psubentry = POINTER_ADD(PFVE_ENTRY, psubentry, psubentry->size);
					}

					table->add_item_line(opts->recovery);

					std::vector<std::string> content;

					bool valid = mac_val && enc_key && test_bitlocker_recovery(nonce_time, nonce_ctr, mac_val, enc_key, enc_size, salt, opts->recovery);
					content.push_back(valid ? "Valid" : "Invalid");
					if (valid)
					{
						content.push_back("");

						unsigned char vmk_buffer[256] = { 0 };
						get_vmk_from_recovery(nonce_time, nonce_ctr, mac_val, enc_key, enc_size, salt, opts->recovery, vmk_buffer);
						content.push_back("VMK  : " + utils::format::hex(((PFVE_VMK)vmk_buffer)->vmk, 32));

						if (fvek_entry != nullptr)
						{
							unsigned char fvek_buffer[256] = { 0 };

							nonce_time = ULARGE_INTEGER{ ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->nonce_time.dwLowDateTime, ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->nonce_time.dwHighDateTime }.QuadPart;
							nonce_ctr = ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->nonce_counter;
							mac_val = ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->mac;
							enc_key = ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->key;
							enc_size = fvek_entry->size - 36;

							get_fvek_from_vmk(nonce_time, nonce_ctr, mac_val, enc_key, enc_size, ((PFVE_VMK)vmk_buffer)->vmk, fvek_buffer);
							content.push_back("FVEK : " + utils::format::hex(((PFVE_FVEK)fvek_buffer)->fvek, ((PFVE_FVEK)fvek_buffer)->size - 0xc));
						}
					}

					table->add_item_multiline(content);

					table->new_line();
				}
			}
		}

		utils::ui::title("Tested Recovery Key:");
		table->render(std::cout);
		std::cout << std::endl;
	}
	else
	{
		std::cout << "[!] Volume is not Bitlocked" << std::endl;
	}
}

void print_test_bitlocker_bek(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	std::cout << std::setfill('0');
	utils::ui::title("Bitlocker Encryption Key Test for " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	PBOOT_SECTOR_COMMON pbsc = (PBOOT_SECTOR_COMMON)vol->bootsector();
	if (strncmp((char*)pbsc->oemID, "-FVE-FS-", 8) == 0)
	{
		std::cout << "FVE Version    : " << vol->bitlocker().metadata[0].block_header.version << std::endl;
		std::cout << "State          : " << constants::bitlocker::state(vol->bitlocker().metadata[0].block_header.curr_state) << std::endl;
		std::cout << "Size           : " << vol->size() << " (" << utils::format::size(vol->size()) << ")" << std::endl;
		std::cout << "Encrypted Size : " << vol->bitlocker().metadata[0].block_header.encrypted_volume_size << " (" << utils::format::size(vol->bitlocker().metadata[0].block_header.encrypted_volume_size) << ")" << std::endl;
		std::cout << "Algorithm      : " << constants::bitlocker::algorithm(vol->bitlocker().metadata[0].header.algorithm) << std::endl;
		SYSTEMTIME st;
		utils::times::filetime_to_local_systemtime(vol->bitlocker().metadata[0].header.timestamp, &st);
		std::cout << "Timestamp      : " << utils::times::display_systemtime(st) << std::endl;
		std::cout << std::endl;

		std::shared_ptr<utils::ui::Table> table = std::make_shared<utils::ui::Table>();
		table->set_interline(true);

		PFVE_ENTRY fvek_entry = nullptr;
		for (auto& entry : vol->bitlocker().metadata[0].entries)
		{
			if (entry->data()->entry_type == FVE_METADATA_ENTRY_TYPE_FKEV && entry->data()->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_AES_CCM_ENCRYPTED_KEY)
			{
				fvek_entry = entry->data();
			}
		}

		table->add_header_line("Id");
		table->add_header_line("Type");
		table->add_header_line("GUID");
		table->add_header_line("BEK File");
		table->add_header_line("Result");

		unsigned int n = 0;
		for (auto& entry : vol->bitlocker().metadata[0].entries)
		{
			if (entry->data()->entry_type == FVE_METADATA_ENTRY_TYPE_VMK && entry->data()->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_VOLUME_MASTER_KEY)
			{
				n++;
				if (((PFVE_ENTRY_VMK)entry->data()->data)->protection_type == FVE_METADATA_KEY_PROTECTION_TYPE_STARTUP_KEY)
				{
					table->add_item_line(std::to_string(n));
					table->add_item_line(constants::bitlocker::fve_key_protection_type(((PFVE_ENTRY_VMK)entry->data()->data)->protection_type));
					table->add_item_line(utils::id::guid_to_string(((PFVE_ENTRY_VMK)entry->data()->data)->key_id));

					ULONG64 nonce_time = 0;
					ULONG32 nonce_ctr = 0;
					ULONG32 enc_size = 0;
					BYTE* salt = NULL;
					BYTE* mac_val = NULL;
					BYTE* enc_key = NULL;

					int sub_entry_size_left = entry->data()->size - 36;
					PFVE_ENTRY psubentry = (PFVE_ENTRY)(((PFVE_ENTRY_VMK)entry->data()->data)->subentries);
					while (sub_entry_size_left > 0)
					{
						if (psubentry->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_AES_CCM_ENCRYPTED_KEY)
						{
							nonce_time = ULARGE_INTEGER{ ((PFVE_ENTRY_AES_CCM)psubentry->data)->nonce_time.dwLowDateTime, ((PFVE_ENTRY_AES_CCM)psubentry->data)->nonce_time.dwHighDateTime }.QuadPart;
							nonce_ctr = ((PFVE_ENTRY_AES_CCM)psubentry->data)->nonce_counter;
							mac_val = ((PFVE_ENTRY_AES_CCM)psubentry->data)->mac;
							enc_key = ((PFVE_ENTRY_AES_CCM)psubentry->data)->key;
							enc_size = psubentry->size - 36;
							break;
						}
						if (psubentry->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_STRETCH_KEY)
						{
							salt = ((PFVE_ENTRY_STRETCH_KEY)psubentry->data)->salt;
						}
						sub_entry_size_left -= psubentry->size;
						psubentry = POINTER_ADD(PFVE_ENTRY, psubentry, psubentry->size);
					}

					table->add_item_line(utils::files::basename(opts->bek));

					std::vector<std::string> content;

					bool valid = mac_val && enc_key && test_bitlocker_bek(nonce_time, nonce_ctr, mac_val, enc_key, enc_size, salt, opts->bek);
					content.push_back(valid ? "Valid" : "Invalid");
					if (valid)
					{
						content.push_back("");

						unsigned char vmk_buffer[256] = { 0 };
						get_vmk_from_bek(nonce_time, nonce_ctr, mac_val, enc_key, enc_size, salt, opts->bek, vmk_buffer);
						content.push_back("VMK  : " + utils::format::hex(((PFVE_VMK)vmk_buffer)->vmk, 32));

						if (fvek_entry != nullptr)
						{
							unsigned char fvek_buffer[256] = { 0 };

							nonce_time = ULARGE_INTEGER{ ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->nonce_time.dwLowDateTime, ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->nonce_time.dwHighDateTime }.QuadPart;
							nonce_ctr = ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->nonce_counter;
							mac_val = ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->mac;
							enc_key = ((PFVE_ENTRY_AES_CCM)fvek_entry->data)->key;
							enc_size = fvek_entry->size - 36;

							get_fvek_from_vmk(nonce_time, nonce_ctr, mac_val, enc_key, enc_size, ((PFVE_VMK)vmk_buffer)->vmk, fvek_buffer);
							content.push_back("FVEK : " + utils::format::hex(((PFVE_FVEK)fvek_buffer)->fvek, ((PFVE_FVEK)fvek_buffer)->size - 0xc));
						}
					}

					table->add_item_multiline(content);

					table->new_line();
				}
			}
		}

		utils::ui::title("Tested BEK File:");
		table->render(std::cout);
		std::cout << std::endl;
	}
	else
	{
		std::cout << "[!] Volume is not Bitlocked" << std::endl;
	}
}

void print_bitlocker_info(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol) {

	std::cout << std::setfill('0');
	utils::ui::title("Bitlocker Info from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	PBOOT_SECTOR_COMMON pbsc = (PBOOT_SECTOR_COMMON)vol->bootsector();
	if (strncmp((char*)pbsc->oemID, "-FVE-FS-", 8) == 0)
	{
		std::cout << "FVE Version    : " << vol->bitlocker().metadata[0].block_header.version << std::endl;
		std::cout << "State          : " << constants::bitlocker::state(vol->bitlocker().metadata[0].block_header.curr_state) << std::endl;
		std::cout << "Size           : " << vol->size() << " (" << utils::format::size(vol->size()) << ")" << std::endl;
		std::cout << "Encrypted Size : " << vol->bitlocker().metadata[0].block_header.encrypted_volume_size << " (" << utils::format::size(vol->bitlocker().metadata[0].block_header.encrypted_volume_size) << ")" << std::endl;
		std::cout << "Algorithm      : " << constants::bitlocker::algorithm(vol->bitlocker().metadata[0].header.algorithm) << std::endl;
		SYSTEMTIME st;
		utils::times::filetime_to_local_systemtime(vol->bitlocker().metadata[0].header.timestamp, &st);
		std::cout << "Timestamp      : " << utils::times::display_systemtime(st) << std::endl;
		std::cout << std::endl;

		std::shared_ptr<utils::ui::Table> table = std::make_shared<utils::ui::Table>();
		table->set_interline(true);

		table->add_header_line("Id");
		table->add_header_line("Type");
		table->add_header_line("GUID");
		table->add_header_line("Details");

		unsigned int n = 0;
		for (auto& entry : vol->bitlocker().metadata[0].entries)
		{
			if (entry->data()->entry_type == FVE_METADATA_ENTRY_TYPE_VMK && entry->data()->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_VOLUME_MASTER_KEY)
			{
				n++;
				table->add_item_line(std::to_string(n));
				table->add_item_line(constants::bitlocker::fve_key_protection_type(((PFVE_ENTRY_VMK)entry->data()->data)->protection_type));
				table->add_item_line(utils::id::guid_to_string(((PFVE_ENTRY_VMK)entry->data()->data)->key_id));

				ULONG64 nonce_val = 0;
				ULONG32 nonce_ctr = 0;
				BYTE* main_mac_val = NULL;
				BYTE* mac_val = NULL;
				BYTE* enc_key = NULL;
				ULONG32 enc_key_size = 0;

				int sub_entry_size_left = entry->data()->size - 36;
				PFVE_ENTRY psubentry = (PFVE_ENTRY)(((PFVE_ENTRY_VMK)entry->data()->data)->subentries);
				int item_required = 2;
				while (sub_entry_size_left > 0)
				{
					if (psubentry->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_AES_CCM_ENCRYPTED_KEY)
					{
						nonce_val = ULARGE_INTEGER{ ((PFVE_ENTRY_AES_CCM)psubentry->data)->nonce_time.dwLowDateTime, ((PFVE_ENTRY_AES_CCM)psubentry->data)->nonce_time.dwHighDateTime }.QuadPart;
						nonce_ctr = ((PFVE_ENTRY_AES_CCM)psubentry->data)->nonce_counter;
						mac_val = ((PFVE_ENTRY_AES_CCM)psubentry->data)->mac;
						enc_key = ((PFVE_ENTRY_AES_CCM)psubentry->data)->key;
						enc_key_size = psubentry->size - 36;
						item_required--;
					}
					if (psubentry->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_STRETCH_KEY)
					{
						main_mac_val = ((PFVE_ENTRY_STRETCH_KEY)psubentry->data)->salt;
						item_required--;
					}
					sub_entry_size_left -= psubentry->size;
					psubentry = POINTER_ADD(PFVE_ENTRY, psubentry, psubentry->size);
				}

				if (item_required == 0)
				{
					table->add_item_multiline(
						{
						"Nonce         : " + utils::format::hex(nonce_val, false) + utils::format::hex(nonce_ctr, false),
						"MAC           : " + utils::format::hex(main_mac_val, 16, false),
						"Encrypted Key : " + utils::format::hex(enc_key, enc_key_size, false),
						"",
						"JtR Hash      : $bitlocker$1$16$" + utils::format::hex(main_mac_val, 16, false) + "$1048576$12$" + utils::format::hex(nonce_val, false, true) + utils::format::hex(nonce_ctr, false, true) + "$60$" + utils::format::hex(mac_val, 16, false) + utils::format::hex(enc_key, enc_key_size, false)
						}
					);
				}
				else
				{
					table->add_item_line("Datasize: " + std::to_string(psubentry->size));
				}
				table->new_line();
			}
		}

		utils::ui::title("Volume Master Keys:");
		table->render(std::cout);
		std::cout << std::endl;
	}
	else
	{
		std::cout << "[!] Volume is not Bitlocked" << std::endl;
	}
}

std::string get_guid_from_volume(std::shared_ptr<Volume> vol)
{
	for (auto& entry : vol->bitlocker().metadata[0].entries)
	{
		if (entry->data()->entry_type == FVE_METADATA_ENTRY_TYPE_VMK && entry->data()->value_type == FVE_METADATA_ENTRY_VALUE_TYPE_VOLUME_MASTER_KEY)
		{
			if ((((PFVE_ENTRY_VMK)entry->data()->data)->protection_type) == FVE_METADATA_KEY_PROTECTION_TYPE_RECOVERY_PASSWORD)
			{
				return utils::id::guid_to_string(((PFVE_ENTRY_VMK)entry->data()->data)->key_id);
			}
		}
	}
	return "Not found";
}

void list_guid_for_all_disks(std::vector<std::shared_ptr<Disk>> disks)
{
	std::cout << std::setfill('0');
	utils::ui::title("Bitlocker Recovery Key GUIDs");

	std::shared_ptr<utils::ui::Table> table = std::make_shared<utils::ui::Table>();
	table->set_interline(true);

	table->add_header_line("Disk Id:Name");
	table->add_header_line("Volume Id:Label");
	table->add_header_line("GUID");

	for (std::shared_ptr<Disk> disk : core::win::disks::list()) {
		for (std::shared_ptr<Volume> volume : disk->volumes()) {
			if (volume->filesystem() == "Bitlocker")
			{
				table->add_item_line(std::to_string(disk->index()) + ": " + disk->product_id());
				table->add_item_line(std::to_string(volume->index()) + ": " + volume->label());
				table->add_item_line(get_guid_from_volume(volume));
				table->new_line();
			}
		}
	}

	table->render(std::cout);
	std::cout << std::endl;
}

int test_password(std::shared_ptr<Options> opts)
{
	std::ios_base::fmtflags flag_backup(std::cout.flags());

	std::shared_ptr<Disk> disk = get_disk(opts);
	if (disk != nullptr)
	{
		std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
		if (volume != nullptr)
		{
			if (opts->password != "") print_test_bitlocker_password(disk, volume, opts);
			else if (opts->recovery != "") print_test_bitlocker_recovery(disk, volume, opts);
			else if (opts->bek != "") print_test_bitlocker_bek(disk, volume, opts);
		}
		else
		{
			invalid_option(opts, "volume", opts->volume);
		}
	}
	else
	{
		invalid_option(opts, "disk", opts->disk);
	}

	std::cout.flags(flag_backup);
	return 0;
}

int print_bitlocker(std::shared_ptr<Options> opts)
{
	std::ios_base::fmtflags flag_backup(std::cout.flags());

	std::shared_ptr<Disk> disk = get_disk(opts);
	if (disk != nullptr)
	{
		std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
		if (volume != nullptr)
		{
			print_bitlocker_info(disk, volume);
		}
		else
		{
			invalid_option(opts, "volume", opts->volume);
		}
	}
	else
	{
		list_guid_for_all_disks(core::win::disks::list());
	}

	std::cout.flags(flag_backup);
	return 0;
}

namespace commands
{
	namespace bitlocker
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			if (opts->password != "" || opts->recovery != "" || opts->bek != "")
			{
				test_password(opts);
			}
			else
			{
				print_bitlocker(opts);
			}
			return 0;
		}
	}

}

```

`Sources/Commands/command_btree.cpp`:

```cpp
#include <iostream>
#include <iomanip>
#include <memory>

#include "Commands/commands.h"
#include "NTFS/ntfs.h"
#include "NTFS/ntfs_explorer.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"
#include "Utils/utils.h"

#include "options.h"
#include "Drive/disk.h"
#include "Drive/volume.h"
#include <Utils/index_details.h>




int print_btree_info(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);
	std::shared_ptr<MFTRecord> record = commands::helpers::find_record(explorer, opts);
	PMFT_RECORD_HEADER record_header = record->header();

	if (!(record_header->flag & MFT_RECORD_IS_DIRECTORY))
	{
		std::cout << "[!] Inode " << std::to_string(record->header()->MFTRecordIndex) << " is not a directory" << std::endl;
		return 3;
	}

	utils::ui::title("B-tree index (inode:" + std::to_string(record->header()->MFTRecordIndex) + ") from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::shared_ptr<utils::ui::Table> fr_attributes = std::make_shared<utils::ui::Table>();
	fr_attributes->set_interline(true);

	fr_attributes->add_header_line("Id");
	fr_attributes->add_header_line("Type");
	fr_attributes->add_header_line("Non-resident");
	fr_attributes->add_header_line("Length");
	fr_attributes->add_header_line("Overview");

	int n = 1;
	PMFT_RECORD_ATTRIBUTE_HEADER pAttribute = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_HEADER, record_header, record_header->attributeOffset);
	while (pAttribute->TypeCode != $END)
	{
		uint64_t raw_address = 0;
		auto raw_offset = reinterpret_cast<uint64_t>(pAttribute) - reinterpret_cast<uint64_t>(record_header);
		if (pAttribute->FormCode == NON_RESIDENT_FORM)
		{
			raw_address = record->raw_address() + raw_offset + pAttribute->Form.Nonresident.MappingPairsOffset;
		}
		else
		{
			raw_address = record->raw_address() + raw_offset + pAttribute->Form.Resident.ValueOffset;
		}

		if (pAttribute->TypeCode == $INDEX_ROOT || pAttribute->TypeCode == $INDEX_ALLOCATION)
		{
			fr_attributes->add_item_line(std::to_string(n++));
			fr_attributes->add_item_multiline(
				{
					constants::disk::mft::file_record_attribute_type(pAttribute->TypeCode),
					"Raw address: " + utils::format::hex6(raw_address, true),
				}
			);
			fr_attributes->add_item_line((pAttribute->FormCode == NON_RESIDENT_FORM ? "True" : "False"));
			if (pAttribute->FormCode == NON_RESIDENT_FORM)
			{
				fr_attributes->add_item_line(std::to_string(pAttribute->Form.Nonresident.ValidDataLength));
			}
			else
			{
				fr_attributes->add_item_line(std::to_string(pAttribute->Form.Resident.ValueLength));
			}
			switch (pAttribute->TypeCode)
			{
			case $INDEX_ROOT:
			{
				PMFT_RECORD_ATTRIBUTE_INDEX_ROOT pattr = nullptr;
				if (pAttribute->FormCode == RESIDENT_FORM)
				{
					pattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ROOT, pAttribute, pAttribute->Form.Resident.ValueOffset);
				}
				else
				{
					wprintf(L"Non-resident $INDEX_ROOT is not supported");
				};
				fr_attributes->add_item_multiline(commands::mft::print_attribute_index_root(pattr, record->index()));
				break;
			}
			case $INDEX_ALLOCATION:
			{
				fr_attributes->add_item_multiline(commands::mft::print_attribute_index_allocation(pAttribute, record, explorer->reader()->sizes.cluster_size, record->index()));
				break;
			}
			default:
				break;
			}
			fr_attributes->new_line();
		}

		pAttribute = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_HEADER, pAttribute, pAttribute->RecordLength);
	}
	utils::ui::title("Attributes:");
	fr_attributes->render(std::cout);
	std::cout << std::endl;


	std::shared_ptr<IndexDetails> idx_details = std::make_shared<IndexDetails>(record);
	std::shared_ptr<utils::ui::Table> fr_index = std::make_shared<utils::ui::Table>();

	if (idx_details->is_large())
	{
		utils::ui::title("$INDEX_ALLOCATION entries:");
	}
	else
	{
		utils::ui::title("$INDEX_ROOT entries:");
	}

	fr_index->set_interline(true);

	fr_index->add_header_line("VCN");
	fr_index->add_header_line("Raw address");
	fr_index->add_header_line("Size");
	fr_index->add_header_line("Entries");

	for (const auto& v : idx_details->VCN_info())
	{
		std::vector<std::string> lines;
		if (idx_details->is_large())
		{
			fr_index->add_item_line("0x" + utils::format::hex6(v.first));
			fr_index->add_item_line(utils::format::hex6(std::get<0>(v.second), true));
		}
		else
		{
			fr_index->add_item_line("Resident");
			fr_index->add_item_multiline(
				{
					"Record          : " + utils::format::hex6(record->raw_address(), true),
					"Offset to Index : " + utils::format::hex6(std::get<0>(v.second), true)
				}
			);
		}

		lines.clear();

		fr_index->add_item_line(utils::format::hex6(std::get<1>(v.second), true));
		for (auto& e : std::get<2>(v.second))
		{
			lines.push_back(utils::format::hex6(std::get<0>(e)) + ": " + utils::strings::to_utf8(std::get<1>(e)));
		}
		fr_index->add_item_multiline(lines);

		fr_index->new_line();
	}

	fr_index->render(std::cout);
	std::cout << std::endl;

	if (idx_details->is_large())
	{
		utils::ui::title("B-tree index:");

		idx_details->VCNtree()->print();

		std::cout << std::endl;
	}

	return 0;
}


namespace commands
{
	namespace mft
	{
		namespace btree
		{
			int dispatch(std::shared_ptr<Options> opts)
			{
				std::ios_base::fmtflags flag_backup(std::cout.flags());

				std::shared_ptr<Disk> disk = get_disk(opts);
				if (disk != nullptr)
				{
					std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
					if (volume != nullptr)
					{
						if (opts->from != "")
						{
							print_btree_info(disk, volume, opts);
						}
						else
						{
							if (opts->inode >= 0)
							{
								print_btree_info(disk, volume, opts);
							}
							else
							{
								invalid_option(opts, "inode", opts->inode);
							}
						}
					}
					else
					{
						invalid_option(opts, "volume", opts->volume);
					}
				}
				else
				{
					invalid_option(opts, "disk", opts->disk);
				}

				std::cout.flags(flag_backup);
				return 0;
			}
		}
	}
}

```

`Sources/Commands/command_efs_backup.cpp`:

```cpp
#include "Commands/commands.h"
#include "NTFS/ntfs_explorer.h"
#include <Utils/table.h>
#include <Utils/constant_names.h>
#include "EFS/certificate_file.h"
#include <EFS/private_key.h>
#include <EFS/masterkey_file.h>
#include <EFS/key_file.h>
#include <EFS/pkcs12_archive.h>


int backup_keys(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("Backup certificates and keys from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << (vol->name().empty() ? reinterpret_cast<Disk*>(vol->parent())->name() : vol->name()) << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);

	std::cout << "[+] Listing user directories" << std::endl;
	auto user_dirs = explorer->mft()->list("C:\\Users", true, false);
	std::cout << "    " << user_dirs.size() << " directories found" << std::endl;

	std::vector<std::shared_ptr<CertificateFile>> user_certificates;
	std::set<std::string> needed_keys_names;

	std::vector<std::shared_ptr<KeyFile>> user_keys;
	std::set<std::string> needed_masterkeys_names;

	std::vector<std::tuple<std::shared_ptr<MasterKeyFile>, std::string>> user_masterkeys_and_sid;

	std::cout << "[+] Looking for certificates" << std::endl;

	for (auto user_dir : user_dirs)
	{
		auto certificate_files = explorer->mft()->list(utils::strings::to_utf8(L"C:\\Users\\" + std::get<0>(user_dir) + L"\\AppData\\Roaming\\Microsoft\\SystemCertificates\\My\\Certificates"), false, true);
		for (auto certificate_file : certificate_files)
		{
			auto record_certificate_file = explorer->mft()->record_from_number(std::get<1>(certificate_file));
			auto data = record_certificate_file->data();

			std::shared_ptr<CertificateFile> cert = std::make_shared<CertificateFile>(data->data(), data->size());
			if (cert->is_loaded())
			{
				for (auto element : cert->fields())
				{
					DWORD prop_id = std::get<0>(element);
					if (prop_id == CERT_KEY_PROV_INFO_PROP_ID)
					{
						PMY_CRYPT_KEY_PROV_INFO info = reinterpret_cast<PMY_CRYPT_KEY_PROV_INFO>(std::get<1>(element)->data());
						if (((info->Flags & CRYPT_MACHINE_KEYSET) == 0) &&
							(info->ProvType == PROV_RSA_FULL) &&
							(info->KeySpec == AT_KEYEXCHANGE))
						{
							user_certificates.push_back(cert);
							needed_keys_names.insert(cert->info()->container_name);
							std::wcout << L"    - " + std::get<0>(certificate_file) << std::endl;
						}
					}
				}
			}
		}
	}

	if (needed_keys_names.size() == 0)
	{
		std::cout << "[-] No EFS cerfificate found" << std::endl;
		return 0;
	}

	std::cout << "[+] Looking for corresponding private keys" << std::endl;

	for (auto user_dir : user_dirs)
	{
		if (needed_keys_names.size() == 0)
		{
			break;
		}
		auto sid_dirs = explorer->mft()->list(utils::strings::to_utf8(L"C:\\Users\\" + std::get<0>(user_dir) + L"\\AppData\\Roaming\\Microsoft\\Crypto\\RSA"), true, false);
		for (auto sid_dir : sid_dirs)
		{
			if (needed_keys_names.size() == 0)
			{
				break;
			}
			auto key_files = explorer->mft()->list(utils::strings::to_utf8(L"C:\\Users\\" + std::get<0>(user_dir) + L"\\AppData\\Roaming\\Microsoft\\Crypto\\RSA\\" + std::get<0>(sid_dir)), false, true);
			for (auto key_file : key_files)
			{
				auto record_keyfile = explorer->mft()->record_from_number(std::get<1>(key_file));
				auto data = record_keyfile->data();

				std::shared_ptr<KeyFile> kf = std::make_shared<KeyFile>(data->data(), data->size());
				if (kf->is_loaded())
				{
					if (needed_keys_names.find(kf->name()) != needed_keys_names.end())
					{
						user_keys.push_back(kf);
						std::wcout << L"    - " + std::get<0>(key_file) << std::endl;
						auto private_enc = kf->private_key();
						if (private_enc)
						{
							needed_masterkeys_names.insert(utils::id::guid_to_string(private_enc->header()->MasterKeyGuid));
						}
						needed_keys_names.erase(kf->name());
						if (needed_keys_names.size() == 0)
						{
							break;
						}
					}
				}
			}
		}
	}

	if (needed_masterkeys_names.size() == 0)
	{
		std::cout << "[-] No corresponding private key found" << std::endl;
		return 0;
	}

	std::cout << "[+] Looking for corresponding masterkeys" << std::endl;

	for (auto user_dir : user_dirs)
	{
		if (needed_masterkeys_names.size() == 0)
		{
			break;
		}
		auto sid_dirs = explorer->mft()->list(utils::strings::to_utf8(L"C:\\Users\\" + std::get<0>(user_dir) + L"\\AppData\\Roaming\\Microsoft\\Protect"), true, false);
		for (auto sid_dir : sid_dirs)
		{
			if (needed_masterkeys_names.size() == 0)
			{
				break;
			}
			auto masterkey_files = explorer->mft()->list(utils::strings::to_utf8(L"C:\\Users\\" + std::get<0>(user_dir) + L"\\AppData\\Roaming\\Microsoft\\Protect\\" + std::get<0>(sid_dir)), false, true);
			for (auto masterkey_file : masterkey_files)
			{
				auto record_masterkeyfile = explorer->mft()->record_from_number(std::get<1>(masterkey_file));
				auto data = record_masterkeyfile->data();

				if (std::get<0>(masterkey_file) != L"Preferred")
				{
					std::shared_ptr<MasterKeyFile> mkf = std::make_shared<MasterKeyFile>(data->data(), data->size());
					if (mkf->is_loaded())
					{
						if (needed_masterkeys_names.find("{" + mkf->guid() + "}") != needed_masterkeys_names.end())
						{
							user_masterkeys_and_sid.push_back(std::make_tuple(mkf, utils::strings::to_utf8(std::get<0>(sid_dir))));
							std::wcout << L"    - " + std::get<0>(masterkey_file) << std::endl;
						}
						needed_masterkeys_names.erase("{" + mkf->guid() + "}");
						if (needed_masterkeys_names.size() == 0)
						{
							break;
						}
					}
				}
			}
		}
	}

	if (user_masterkeys_and_sid.size() == 0)
	{
		std::cout << "[-] No corresponding master key found" << std::endl;
		return 0;
	}

	std::cout << "[+] Exporting " << user_certificates.size() << " certificates and keys (pass: backup)" << std::endl;

	for (auto cert : user_certificates)
	{
		std::cout << "    - " << cert->hash();

		std::shared_ptr<KeyFile> keyfile = nullptr;
		std::shared_ptr<MasterKeyFile> masterkeyfile = nullptr;
		std::string sid;
		for (auto key : user_keys)
		{
			if (key->name() == cert->info()->container_name)
			{
				keyfile = key;
				break;
			}
		}
		if (keyfile)
		{
			auto private_enc = keyfile->private_key();
			if (private_enc)
			{
				for (auto user_masterkey : user_masterkeys_and_sid)
				{
					if ("{" + std::get<0>(user_masterkey)->guid() + "}" == utils::id::guid_to_string(private_enc->header()->MasterKeyGuid))
					{
						masterkeyfile = std::get<0>(user_masterkey);
						sid = std::get<1>(user_masterkey);
						break;
					}
				}
			}
		}
		if (keyfile && masterkeyfile && sid.length())
		{
			auto masterkey = masterkeyfile->master_key()->decrypt_with_password(sid, opts->password);
			if (masterkey)
			{
				auto decrypted_private_key = keyfile->private_key()->decrypt_with_masterkey(masterkey);
				if (decrypted_private_key != nullptr)
				{
					std::shared_ptr<PKCS12Archive> pkcs12 = std::make_shared<PKCS12Archive>(cert, decrypted_private_key);
					if (opts->output == "")
					{
						opts->output = cert->hash();
					}
					opts->output = utils::files::ensure_file_ext(opts->output, "pfx");

					if (pkcs12->export_to_pfx(opts->output, "backup"))
					{
						std::cout << " : Fail" << std::endl;
						std::cerr << "[!] Unable to export the backup key." << std::endl;
					}
					else
					{
						std::cout << " : Ok" << std::endl;
						std::cout << "      Exported to " << opts->output << std::endl;
					}
				}
				else
				{
					std::cout << " : Fail" << std::endl;
					std::cerr << "[!] Unable to decrypt the private key." << std::endl;
				}
			}
			else
			{
				std::cout << " : Fail" << std::endl;
				std::cerr << "[!] Unable to decrypt the masterkey using provided password." << std::endl;
			}
		}
	}

	return 0;
}

namespace commands
{
	namespace efs
	{
		namespace backup
		{
			int dispatch(std::shared_ptr<Options> opts)
			{
				std::ios_base::fmtflags flag_backup(std::cout.flags());

				std::shared_ptr<Disk> disk = get_disk(opts);
				if (disk != nullptr)
				{
					std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
					if (volume != nullptr)
					{
						if (opts->password != "")
						{
							backup_keys(disk, volume, opts);
						}
						else
						{
							invalid_option(opts, "password", opts->password);
						}
					}
					else
					{
						invalid_option(opts, "volume", opts->volume);
					}
				}
				else
				{
					invalid_option(opts, "disk", opts->disk);
				}

				std::cout.flags(flag_backup);
				return 0;
			}
		}
	}
}

```

`Sources/Commands/command_efs_certificate.cpp`:

```cpp
#include "Commands/commands.h"
#include "NTFS/ntfs_explorer.h"
#include <Utils/table.h>
#include <Utils/constant_names.h>
#include "EFS/certificate_file.h"


int show_certificate(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("Display certificate from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << (vol->name().empty() ? reinterpret_cast<Disk*>(vol->parent())->name() : vol->name()) << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);
	std::shared_ptr<MFTRecord> certificate_file_record = commands::helpers::find_record(explorer, opts);
	auto data = certificate_file_record->data();

	std::shared_ptr<CertificateFile> certificate_file = std::make_shared<CertificateFile>(data->data(), data->size());
	if (!certificate_file->is_loaded())
	{
		std::cerr << "[!] Failed to parse certificate file from record: " << opts->inode << std::endl;
		return 3;
	}

	if (opts->output == "")
	{
		std::shared_ptr<utils::ui::Table> tab = std::make_shared<utils::ui::Table>();
		tab->set_margin_left(4);
		tab->set_cell_max_size(78);
		tab->set_interline(true);
		tab->add_header_line("Id", utils::ui::TableAlign::RIGHT);
		tab->add_header_line("Property");
		tab->add_header_line("Value");

		std::string date;
		PMFT_RECORD_ATTRIBUTE_HEADER stdinfo_att = certificate_file_record->attribute_header($STANDARD_INFORMATION);
		if (stdinfo_att)
		{
			PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION stdinfo = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION, stdinfo_att, stdinfo_att->Form.Resident.ValueOffset);
			SYSTEMTIME st = { 0 };
			utils::times::ull_to_local_systemtime(stdinfo->CreateTime, &st);
			date = utils::times::display_systemtime(st);
		}

		int i = 0;
		tab->add_item_line(std::to_string(i++));
		tab->add_item_line("File");
		tab->add_item_multiline(
			{
				"Creation : " + date,
				"Size     : " + utils::format::size(data->size())
			}
		);

		tab->new_line();

		for (auto element : certificate_file->fields())
		{
			tab->add_item_line(std::to_string(i++));

			DWORD prop_id = std::get<0>(element);
			tab->add_item_line(constants::efs::cert_prop_id(prop_id));

			if (prop_id == CERT_KEY_PROV_INFO_PROP_ID)
			{
				PMY_CRYPT_KEY_PROV_INFO info = reinterpret_cast<PMY_CRYPT_KEY_PROV_INFO>(std::get<1>(element)->data());

				std::vector<std::string> cell = {
					"Container Name : " + utils::strings::to_utf8(POINTER_ADD(wchar_t*, info, info->ContainerNameOffset)),
					"Provider Name  : " + utils::strings::to_utf8(POINTER_ADD(wchar_t*, info, info->ProvNameOffset)),
					"Provider Type  : " + constants::efs::cert_prop_provider_type(info->ProvType),
					"Flags          : " + constants::efs::cert_prop_flags(info->Flags),
					"KeySpec        : " + constants::efs::cert_prop_keyspec(info->KeySpec)
				};
				if (info->ProvParam)
				{
					cell.push_back("");
					auto params = POINTER_ADD(PMY_CRYPT_KEY_PROV_PARAM, info, info->ProvParamOffset);
					for (unsigned int i = 0; i < info->ProvParam; i++)
					{
						auto param = params[i];
						cell.push_back(utils::format::hex(param.dwParam) + " : " + utils::format::hex(param.dwFlags) + " : " + utils::format::hex(param.cbData) + " : " + utils::format::hex(param.pbDataOffset));
					}
				}

				tab->add_item_multiline(cell);
			}
			else if (prop_id == CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID)
			{
				tab->add_item_line(std::to_string(((PDWORD)(std::get<1>(element)->data()))[0]));
			}
			else if (prop_id == CERT_FRIENDLY_NAME_PROP_ID)
			{
				tab->add_item_line(utils::strings::to_utf8(reinterpret_cast<wchar_t*>(std::get<1>(element)->data())));
			}
			else if (prop_id == CERT_CERTIFICATE_FILE)
			{
				auto desc = certificate_file->certificate_ossl_description();
				if (!desc.empty())
				{
					tab->add_item_multiline(desc);
				}
				else
				{
					tab->add_item_line(utils::convert::to_hex(std::get<1>(element)->data(), std::get<1>(element)->size()));
				}
			}
			else
			{
				tab->add_item_line(utils::convert::to_hex(std::get<1>(element)->data(), std::get<1>(element)->size()));
			}

			tab->new_line();
		}
		std::cout << "[+] Certificate" << std::endl;
		tab->render(std::cout);
	}
	else
	{
		if (certificate_file->export_to_PEM(opts->output) == 0)
		{
			std::cout << "[+] Certificate exported to " << opts->output << ".pem" << std::endl;
		}
		else
		{
			std::cerr << "[!] Unable to export the certificate" << std::endl;
		}
	}

	return 0;
}

int list_certificates(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("List certificates from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << (vol->name().empty() ? reinterpret_cast<Disk*>(vol->parent())->name() : vol->name()) << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);

	std::cout << "[+] Listing user directories" << std::endl;
	auto user_dirs = explorer->mft()->list("C:\\Users", true, false);
	std::cout << "    " << user_dirs.size() << " directories found" << std::endl;

	std::cout << "[+] Looking for certificates" << std::endl;

	int certificate_count = 0;

	std::shared_ptr<utils::ui::Table> tab = std::make_shared<utils::ui::Table>();
	tab->set_margin_left(4);
	tab->set_interline(true);
	tab->add_header_line("Id", utils::ui::TableAlign::RIGHT);
	tab->add_header_line("User");
	tab->add_header_line("File");
	tab->add_header_line("Certificate");

	for (auto user_dir : user_dirs)
	{
		auto certificate_files = explorer->mft()->list(utils::strings::to_utf8(L"C:\\Users\\" + std::get<0>(user_dir) + L"\\AppData\\Roaming\\Microsoft\\SystemCertificates\\My\\Certificates"), false, true);
		for (auto certificate_file : certificate_files)
		{
			auto record_certificate_file = explorer->mft()->record_from_number(std::get<1>(certificate_file));
			auto data = record_certificate_file->data();

			tab->add_item_line(std::to_string(certificate_count));
			tab->add_item_line(utils::strings::to_utf8(std::get<0>(user_dir)));

			std::string date;
			PMFT_RECORD_ATTRIBUTE_HEADER stdinfo_att = record_certificate_file->attribute_header($STANDARD_INFORMATION);
			if (stdinfo_att)
			{
				PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION stdinfo = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION, stdinfo_att, stdinfo_att->Form.Resident.ValueOffset);
				SYSTEMTIME st = { 0 };
				utils::times::ull_to_local_systemtime(stdinfo->CreateTime, &st);
				date = utils::times::display_systemtime(st);
			}

			tab->add_item_multiline(
				{
					"Name     : " + utils::strings::to_utf8(std::get<0>(certificate_file)),
					"Record   : " + utils::format::hex6(record_certificate_file->header()->MFTRecordIndex, true),
					"Size     : " + utils::format::size(data->size()),
					"",
					"Creation : " + date
				}
			);

			certificate_count++;
			std::shared_ptr<CertificateFile> cert = std::make_shared<CertificateFile>(data->data(), data->size());
			if (cert->is_loaded())
			{
				auto info = cert->info();
				std::vector<std::string> cell;
				if (info->friendly_name != "")
				{
					cell.push_back("Friendly Name : " + info->friendly_name);
					cell.push_back("");
				}
				if (info->container_name != "") cell.push_back("Container     : " + info->container_name);
				if (info->provider_name != "") cell.push_back("Provider      : " + info->provider_name);
				if (info->provider_type != "") cell.push_back("Type          : " + info->provider_type);
				if (info->keyspec != "") cell.push_back("KeySpec       : " + info->keyspec);
				tab->add_item_multiline(cell);
			}
			else
			{
				tab->add_item_line("Invalid certificate file");
			}

			tab->new_line();
		}
	}

	if (certificate_count == 0)
	{
		std::cout << "[+] No certificate found" << std::endl;
	}
	else
	{
		std::cout << "    " << certificate_count << " certificate(s) found" << std::endl;
		std::cout << "[+] Certificates" << std::endl;
		tab->render(std::cout);
	}

	return 0;
}

namespace commands
{
	namespace efs
	{
		namespace certificate
		{
			int dispatch(std::shared_ptr<Options> opts)
			{
				std::ios_base::fmtflags flag_backup(std::cout.flags());

				std::shared_ptr<Disk> disk = get_disk(opts);
				if (disk != nullptr)
				{
					std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
					if (volume != nullptr)
					{
						if (opts->inode >= 0 || opts->from != "")
						{
							show_certificate(disk, volume, opts);
						}
						else
						{
							list_certificates(disk, volume, opts);
						}
					}
					else
					{
						invalid_option(opts, "volume", opts->volume);
					}
				}
				else
				{
					invalid_option(opts, "disk", opts->disk);
				}

				std::cout.flags(flag_backup);
				return 0;
			}
		}
	}
}

```

`Sources/Commands/command_efs_decrypt.cpp`:

```cpp
#include "Commands/commands.h"
#include "Utils/table.h"
#include "Utils/constant_names.h"
#include <EFS/pkcs12_archive.h>
#include <EFS/fek.h>
#include <openssl/evp.h>
#include <openssl/rsa.h>

static unsigned char EFS_IV[16] = { 0x12, 0x13, 0x16, 0xe9, 0x7b, 0x65, 0x16, 0x58, 0x61, 0x89, 0x91, 0x44, 0xbe, 0xad, 0x89, 0x19 };

std::shared_ptr<Buffer<PEFS_FEK>> decrypt_fek(RSA* private_key, std::shared_ptr<Buffer<PBYTE>> encrypted_fek)
{
	if (encrypted_fek && private_key)
	{
		std::shared_ptr<Buffer<PEFS_FEK>> decrypted_fek = std::make_shared<Buffer<PEFS_FEK>>(encrypted_fek->size());
		int ret = RSA_private_decrypt(encrypted_fek->size(), encrypted_fek->data(), decrypted_fek->address(), private_key, RSA_PKCS1_PADDING);
		if (ret == -1)
		{
			return nullptr;
		}
		else
		{
			decrypted_fek->shrink(ret);
			return decrypted_fek;
		}
	}
	return nullptr;
}

void decrypt_block(std::pair<PBYTE, DWORD> block, std::shared_ptr<Buffer<PEFS_FEK>> fek, DWORD64 index, ULONG32 cluster_size)
{
	EVP_CIPHER_CTX* pctx = EVP_CIPHER_CTX_new();
	unsigned char iv[16];

	memcpy_s(iv, 16, EFS_IV, 16);

	((DWORD64*)iv)[0] += (index * cluster_size);
	((DWORD64*)iv)[1] += (index * cluster_size);

	int outl = block.second;
	EVP_DecryptInit(pctx, utils::crypto::cryptoapi::encryption_to_evp(fek->data()->Algorithm), fek->data()->Key, iv);
	EVP_DecryptUpdate(pctx, block.first, &outl, block.first, block.second);
	block.second = outl;
	EVP_CIPHER_CTX_free(pctx);
}

int decrypt_file(std::shared_ptr<MFTRecord> record, std::shared_ptr<Buffer<PEFS_FEK>> fek, std::shared_ptr<Options> opts, ULONG32 cluster_size)
{
	int ret = 0;
	if (opts->output == "")
	{
		opts->output = utils::strings::to_utf8(record->filename() + L".decrypted");
	}

	BIO* output = BIO_new_file(opts->output.c_str(), "wb");
	if (output)
	{
		DWORD64 written_bytes = 0ULL;
		DWORD res_write = 0;
		DWORD index_block = 0;
		DWORD64 clear_size = record->datasize();
		for (auto data_block : record->process_data("", cluster_size, true))
		{
			if (data_block.second == cluster_size)
			{
				decrypt_block(data_block, fek, index_block, cluster_size);

				int need_to_write = static_cast<int>(min(clear_size - written_bytes, data_block.second));
				if (need_to_write)
				{
					res_write = BIO_write(output, data_block.first, need_to_write);
					if (res_write == 0 || res_write == -1)
					{
						std::cout << "[!] Failed to write decrypted file" << std::endl;
						ret = 3;
					}
					else
					{
						written_bytes += res_write;
					}
				}
			}
			else
			{
				std::cerr << "[!] Wrong block size during decryption (" << data_block.second << ")" << std::endl;
				ret = 4;
				break;
			}
			index_block++;
		}
		BIO_free(output);
	}
	else
	{
		std::cout << "[!] Failed to create decrypted file" << std::endl;
		ret = 1;
	}

	return ret;
}

int load_key_and_decrypt_file(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	utils::ui::title("Decrypt EFS file from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::string keyid;

	std::cout << "[+] Loading PKCS12 input file" << std::endl;
	std::shared_ptr<PKCS12Archive> pkcs12 = std::make_shared<PKCS12Archive>(opts->pfx, opts->password);
	if (pkcs12->certificate() && pkcs12->key())
	{
		keyid = pkcs12->certificate_hash();
		std::cout << "[-] KeyID : " << keyid << std::endl;

	}
	else
	{
		std::cout << "[!] Failed to load PKCS12 file" << std::endl;
		return 2;
	}

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);

	std::shared_ptr<MFTRecord> record = commands::helpers::find_record(explorer, opts);

	PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION stdinfo = nullptr;
	PMFT_RECORD_ATTRIBUTE_HEADER stdinfo_att = record->attribute_header($STANDARD_INFORMATION);
	if (stdinfo_att)
	{
		stdinfo = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION, stdinfo_att, stdinfo_att->Form.Resident.ValueOffset);
	}
	if (stdinfo)
	{
		if (stdinfo->u.Permission.encrypted == 0)
		{
			std::cout << "[!] File is not encrypted" << std::endl;
			return 1;
		}
	}

	std::cout << "[+] Parsing $EFS streams" << std::endl;
	PMFT_RECORD_ATTRIBUTE_HEADER pLogged_utility_attr_header = record->attribute_header($LOGGED_UTILITY_STREAM, "$EFS");
	if (pLogged_utility_attr_header)
	{
		auto efs_header = record->attribute_data<PMFT_RECORD_ATTRIBUTE_EFS_HEADER>(pLogged_utility_attr_header);
		if (efs_header)
		{
			PMFT_RECORD_ATTRIBUTE_EFS_ARRAY_HEADER efs_arr_header = nullptr;
			if (efs_header->data()->OffsetToDDF != 0)
			{
				efs_arr_header = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EFS_ARRAY_HEADER, efs_header->data(), efs_header->data()->OffsetToDDF);
				std::cout << "[-] " << efs_arr_header->Count << " data decryption field(s) found" << std::endl;

				uint32_t i = 0;
				PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY_HEADER entry_header = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY_HEADER, efs_arr_header, 4);
				while (i < efs_arr_header->Count)
				{
					auto fek_enc = std::make_shared<Buffer<PBYTE>>(POINTER_ADD(PBYTE, entry_header, entry_header->FEKOffset), entry_header->FEKSize);
					fek_enc->reverse_bytes();

					PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY entry = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY, entry_header, entry_header->CredentialHeaderOffset);
					PMFT_RECORD_ATTRIBUTE_EFS_DF_CERTIFICATE_THUMBPRINT_HEADER thumprint_header = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EFS_DF_CERTIFICATE_THUMBPRINT_HEADER, entry, entry->cert_thumbprint_header_offset);

					auto cert_fingerprint = std::make_shared<Buffer<PBYTE>>(POINTER_ADD(PBYTE, thumprint_header, thumprint_header->thumbprint_offset), thumprint_header->thumbprint_size);
					std::string ddf_id = utils::strings::to_utf8(cert_fingerprint->to_hex());

					if (ddf_id == keyid)
					{
						std::cout << "[+] Decrypting FEK" << std::endl;
						std::shared_ptr<Buffer<PEFS_FEK>> decrypted_fek = decrypt_fek(EVP_PKEY_get0_RSA(pkcs12->key()), fek_enc);
						if (decrypted_fek)
						{
							std::cout << "[-] FEK" << std::endl;
							std::shared_ptr<utils::ui::Table> table = std::make_shared<utils::ui::Table>();
							table->set_margin_left(4);
							table->add_header_line("Property");
							table->add_header_line("Value");

							table->add_item_line("Entropy");
							table->add_item_line(std::to_string(decrypted_fek->data()->Entropy));
							table->new_line();

							table->add_item_line("Algorithm");
							table->add_item_line(constants::efs::enc_algorithm(decrypted_fek->data()->Algorithm));
							table->new_line();

							table->add_item_line("Key (" + std::to_string((decrypted_fek->size() - 16) * 8) + "bits)");
							table->add_item_line(utils::convert::to_hex(decrypted_fek->data()->Key, decrypted_fek->size() - 16));
							table->new_line();

							table->render(std::cout);
							table = nullptr;

							std::cout << "[+] Decrypting file" << std::endl;
							if (!decrypt_file(record, decrypted_fek, opts, explorer->reader()->sizes.cluster_size))
							{
								std::cout << "[-] Decrypted file written to " << opts->output << " (" << utils::format::size(record->datasize()) << ")" << std::endl;
							}
							else
							{
								std::cerr << "[!] Failed to decrypt the file using FEK" << std::endl;
								return 6;
							}
						}
						else
						{
							std::cerr << "[!] Failed to decrypt encrypted FEK" << std::endl;
							return 5;
						}
					}
					else
					{
						std::cout << "[-] Skipping field: " << i + 1 << " (cert/key not match)" << std::endl;
					}

					entry_header = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY_HEADER, entry_header, entry_header->Length);
					i++;
				}
			}
			else
			{
				std::cout << "[!] Empty data decryption field" << std::endl;
				return 4;
			}
		}
	}
	else
	{
		std::cout << "[!] Unable to find $EFS stream in file" << std::endl;
		return 3;
	}
	return 0;
}


namespace commands
{
	namespace efs
	{
		namespace decrypt
		{
			int dispatch(std::shared_ptr<Options> opts)
			{
				std::ios_base::fmtflags flag_backup(std::cout.flags());

				std::shared_ptr<Disk> disk = get_disk(opts);
				if (disk != nullptr)
				{
					std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
					if (volume != nullptr)
					{
						if (opts->pfx == "") invalid_option(opts, "pfx", opts->pfx);
						if (opts->password == "") invalid_option(opts, "password", opts->password);

						load_key_and_decrypt_file(disk, volume, opts);
					}
					else
					{
						invalid_option(opts, "volume", opts->volume);
					}
				}
				else
				{
					invalid_option(opts, "disk", opts->disk);
				}

				std::cout.flags(flag_backup);
				return 0;
			}
		}
	}
}
```

`Sources/Commands/command_efs_key.cpp`:

```cpp
#include "commands.h"
#include "EFS/masterkey_file.h"
#include "NTFS/ntfs_explorer.h"
#include <Utils/table.h>
#include <Utils/constant_names.h>
#include <EFS/key_file.h>
#include <EFS/private_key.h>

int decrypt_key(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("Decrypt key from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << (vol->name().empty() ? reinterpret_cast<Disk*>(vol->parent())->name() : vol->name()) << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);
	std::shared_ptr<MFTRecord> key_file_record = commands::helpers::find_record(explorer, opts);

	auto data = key_file_record->data();
	std::shared_ptr<KeyFile> key_file = std::make_shared<KeyFile>(data->data(), data->size());
	if (!key_file->is_loaded())
	{
		std::cerr << "[!] Failed to parse key file from record: " << opts->inode << std::endl;
		return 3;
	}

	auto key = key_file->private_key();
	if (key)
	{
		std::cout << "[-] Key" << std::endl;
		std::cout << "    Encryption Algorithm : " << constants::efs::enc_algorithm(key->header()->EncryptionAlgorithm) << std::endl;
		std::cout << "    Hash Algorithm       : " << constants::efs::hash_algorithm(key->header()->HashAlgorithm) << std::endl;
		std::cout << "    Salt                 : " << utils::convert::to_hex(key->salt()->data(), key->salt()->size()) << std::endl;

		std::cout << "[+] Decrypting key" << std::endl;
		std::shared_ptr<PrivateKey> res = key->decrypt_with_masterkey(opts->masterkey);
		if (res == nullptr)
		{
			std::cout << "[!] Failed to decrypt. Check masterkey." << std::endl;
		}
		else
		{
			std::cout << "[+] Key successfully decrypted" << std::endl;
			auto export_flags_enc = key_file->export_flags();
			std::shared_ptr<ExportFlags> export_flags = export_flags_enc->decrypt_with_masterkey(opts->masterkey);
			if (export_flags == nullptr)
			{
				std::cerr << "[!] Failed to decrypt export flags. Check the masterkey" << std::endl;
			}
			else
			{
				std::cout << "[+] Export flags         : " << utils::format::hex(export_flags->flags()) << (export_flags->flags() ? (" (" + constants::efs::export_flag(export_flags->flags()) + ")") : "") << std::endl;
			}

			if (opts->output != "")
			{
				if (res->export_public_to_PEM(opts->output) == 0)
				{
					std::cout << "[+] Public key exported to " << opts->output << ".pub.pem" << "." << std::endl;
				}
				else
				{
					std::cerr << "[!] Unable to export the public key." << std::endl;
				}
				if (res->export_private_to_PEM(opts->output) == 0)
				{
					std::cout << "[+] Private key exported to " << opts->output << ".priv.pem" << "." << std::endl;
				}
				else
				{
					std::cerr << "[!] Unable to export the private key." << std::endl;
				}
			}
			else
			{
				std::cout << "[+] Clear key (" << res->header()->Bitsize << "bits) :" << std::endl;

				std::shared_ptr<utils::ui::Table> tab = std::make_shared<utils::ui::Table>();
				tab->set_margin_left(4);
				tab->set_interline(true);
				tab->add_header_line("Id", utils::ui::TableAlign::RIGHT);
				tab->add_header_line("Property");
				tab->add_header_line("Value");

				int i = 0;
				tab->add_item_line(std::to_string(i++));
				tab->add_item_line("Magic");
				std::string magic_str = { ((char*)(&res->header()->Magic))[0],((char*)(&res->header()->Magic))[1],((char*)(&res->header()->Magic))[2],((char*)(&res->header()->Magic))[3] };
				tab->add_item_line(magic_str);

				tab->new_line();

				tab->add_item_line(std::to_string(i++));
				tab->add_item_line("Bitsize");
				tab->add_item_line(std::to_string(res->header()->Bitsize));

				tab->new_line();

				/*
				tab->add_item_line(std::to_string(i++));
				tab->add_item_line("Permissions");
				tab->add_item_multiline(constants::efs::permissions(res->header()->Permissions));

				tab->new_line();
				*/

				tab->add_item_line(std::to_string(i++));
				tab->add_item_line("Exponent");
				tab->add_item_line(std::to_string(res->header()->Exponent));

				tab->new_line();

				tab->add_item_line(std::to_string(i++));
				tab->add_item_line("Modulus");
				tab->add_item_line(utils::convert::to_hex(res->modulus()->data(), res->modulus()->size()));

				tab->new_line();

				tab->add_item_line(std::to_string(i++));
				tab->add_item_line("Prime1");
				tab->add_item_line(utils::convert::to_hex(res->prime1()->data(), res->prime1()->size()));

				tab->new_line();

				tab->add_item_line(std::to_string(i++));
				tab->add_item_line("Prime2");
				tab->add_item_line(utils::convert::to_hex(res->prime2()->data(), res->prime2()->size()));

				tab->new_line();

				tab->add_item_line(std::to_string(i++));
				tab->add_item_line("Exponent1");
				tab->add_item_line(utils::convert::to_hex(res->exponent1()->data(), res->exponent1()->size()));

				tab->new_line();

				tab->add_item_line(std::to_string(i++));
				tab->add_item_line("Exponent2");
				tab->add_item_line(utils::convert::to_hex(res->exponent2()->data(), res->exponent2()->size()));

				tab->new_line();

				tab->add_item_line(std::to_string(i++));
				tab->add_item_line("Coefficient");
				tab->add_item_line(utils::convert::to_hex(res->coefficient()->data(), res->coefficient()->size()));

				tab->new_line();

				tab->add_item_line(std::to_string(i++));
				tab->add_item_line("Private Exponent");
				tab->add_item_line(utils::convert::to_hex(res->private_exponent()->data(), res->private_exponent()->size()));

				tab->new_line();

				tab->render(std::cout);
			}
		}
	}
	else
	{
		std::cerr << "[!] No key in specified file." << std::endl;
		return 3;
	}

	return 0;
}


std::vector<std::string> print_encrypted_private_key(std::shared_ptr<PrivateKeyEnc> private_key)
{
	std::vector<std::string> cell =
	{
		"Version           : " + std::to_string(private_key->header()->Version),
		"Provider GUID     : " + utils::id::guid_to_string(private_key->header()->ProviderGuid),
		"MasterKey Version : " + std::to_string(private_key->header()->MasterKeyVersion),
		"MasterKey GUID    : " + utils::id::guid_to_string(private_key->header()->MasterKeyGuid),
		"",
		"Description       : " + private_key->description(),
		"Flags             : " + utils::format::hex(private_key->header()->Flags, true),
		"",
		"Encryption Alg    : " + constants::efs::enc_algorithm(private_key->header()->EncryptionAlgorithm),
		"Hash Alg          : " + constants::efs::hash_algorithm(private_key->header()->HashAlgorithm),
		"",
		"Salt              : " + utils::convert::to_hex(private_key->salt()->data(), private_key->salt()->size()),
		""
	};

	if (private_key->header()->HMACLen)
	{
		cell.push_back("HMAC              : " + utils::convert::to_hex(private_key->hmac()->data(), private_key->hmac()->size()));
	}
	else
	{
		cell.push_back("HMAC              : -");
	}

	cell.push_back("HMAC2             : " + utils::convert::to_hex(private_key->hmac2()->data(), private_key->hmac2()->size()));
	cell.push_back("");
	cell.push_back("Encrypted Data    : " + utils::convert::to_hex(private_key->data()->data(), private_key->data()->size()));
	cell.push_back("");
	cell.push_back("Signature Data    : " + utils::convert::to_hex(private_key->signature()->data(), private_key->signature()->size()));

	return cell;
}


int show_key(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("Display key from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << (vol->name().empty() ? reinterpret_cast<Disk*>(vol->parent())->name() : vol->name()) << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);
	std::shared_ptr<MFTRecord> key_file_record = commands::helpers::find_record(explorer, opts);
	auto data = key_file_record->data();

	std::shared_ptr<KeyFile> key_file = std::make_shared<KeyFile>(data->data(), data->size());
	if (!key_file->is_loaded())
	{
		std::cerr << "[!] Failed to parse key file from record: " << opts->inode << std::endl;
		return 3;
	}

	std::shared_ptr<utils::ui::Table> tab = std::make_shared<utils::ui::Table>();
	tab->set_margin_left(4);
	tab->set_interline(true);
	tab->add_header_line("Id", utils::ui::TableAlign::RIGHT);
	tab->add_header_line("Property");
	tab->add_header_line("Value");

	std::string date;
	PMFT_RECORD_ATTRIBUTE_HEADER stdinfo_att = key_file_record->attribute_header($STANDARD_INFORMATION);
	if (stdinfo_att)
	{
		PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION stdinfo = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION, stdinfo_att, stdinfo_att->Form.Resident.ValueOffset);
		SYSTEMTIME st = { 0 };
		utils::times::ull_to_local_systemtime(stdinfo->CreateTime, &st);
		date = utils::times::display_systemtime(st);
	}

	int i = 0;
	tab->add_item_line(std::to_string(i++));
	tab->add_item_line("File");
	tab->add_item_multiline(
		{
			"Creation : " + date,
			"Size     : " + utils::format::size(data->size())
		}
	);

	tab->new_line();

	tab->add_item_line(std::to_string(i++));
	tab->add_item_line("Version");
	tab->add_item_line(std::to_string(key_file->version()));

	tab->new_line();

	tab->add_item_line(std::to_string(i++));
	tab->add_item_line("Name");
	tab->add_item_line(key_file->name());

	tab->new_line();

	tab->add_item_line(std::to_string(i++));
	tab->add_item_line("Flags");
	tab->add_item_line(utils::format::hex(key_file->flags(), true));

	tab->new_line();

	auto sign_public_key = key_file->sign_public_key();
	if (sign_public_key)
	{
		tab->add_item_line(std::to_string(i++));
		tab->add_item_line("PublicKey Signature");
		tab->add_item_line(utils::convert::to_hex(sign_public_key->data(), sign_public_key->size()));
		tab->new_line();
	}

	auto sign_private_key = key_file->sign_private_key();
	if (sign_private_key)
	{
		tab->add_item_line(std::to_string(i++));
		tab->add_item_line("PrivateKey Signature");
		tab->add_item_line(utils::convert::to_hex(sign_private_key->data(), sign_private_key->size()));
		tab->new_line();
	}

	auto public_key = key_file->public_key();
	if (public_key)
	{
		tab->add_item_line(std::to_string(i++));
		tab->add_item_line("PublicKey");

		auto magic = public_key->header()->Magic;
		std::vector<std::string> cell =
		{
				"Magic       : " + utils::format::hex(magic, true) + " (" + ((char*)&magic)[0] + ((char*)&magic)[1] + ((char*)&magic)[2] + ((char*)&magic)[3] + ")",
				"Size        : " + std::to_string(public_key->header()->Bitsize),
				"Exponent    : " + std::to_string(public_key->header()->Exponent),
		};
		/*
		auto permissions_str = constants::efs::permissions(public_key->header()->Permissions);
		for (int pi = 0; pi < permissions_str.size(); pi++)
		{
			if (pi == 0) {
				cell.push_back("");
				cell.push_back("Permissions : " + permissions_str[pi]);
			}
			else
			{
				cell.push_back("              " + permissions_str[pi]);
			}
		}
		*/
		cell.push_back("");
		cell.push_back("Modulus     : " + utils::convert::to_hex(public_key->modulus()->data(), public_key->modulus()->size()));
		tab->add_item_multiline(cell);
		tab->new_line();
	}

	auto private_key = key_file->private_key();
	if (private_key)
	{
		tab->add_item_line(std::to_string(i++));
		tab->add_item_line("Encrypted PrivateKey");

		auto cell = print_encrypted_private_key(private_key);
		tab->add_item_multiline(cell);

		tab->new_line();
	}

	auto hash = key_file->hash();
	if (hash)
	{
		tab->add_item_line(std::to_string(i++));
		tab->add_item_line("Hash");
		tab->add_item_line(utils::convert::to_hex(hash->data(), hash->size()));
		tab->new_line();
	}

	auto export_flag = key_file->export_flags();
	if (export_flag)
	{
		tab->add_item_line(std::to_string(i++));
		tab->add_item_line("ExportFlag");

		auto cell = print_encrypted_private_key(export_flag);
		tab->add_item_multiline(cell);

		tab->new_line();
	}

	std::cout << "[+] Key" << std::endl;
	tab->render(std::cout);

	return 0;
}

int list_keys(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("List keys from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << (vol->name().empty() ? reinterpret_cast<Disk*>(vol->parent())->name() : vol->name()) << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);

	std::cout << "[+] Listing user directories" << std::endl;
	auto user_dirs = explorer->mft()->list("C:\\Users", true, false);
	std::cout << "    " << user_dirs.size() << " directories found" << std::endl;

	std::cout << "[+] Searching for keys" << std::endl;

	int key_count = 0;

	std::shared_ptr<utils::ui::Table> tab = std::make_shared<utils::ui::Table>();
	tab->set_margin_left(4);
	tab->set_interline(true);
	tab->add_header_line("Id", utils::ui::TableAlign::RIGHT);
	tab->add_header_line("User");
	tab->add_header_line("Keyfile");
	tab->add_header_line("Name");
	tab->add_header_line("Creation Date");

	for (auto user_dir : user_dirs)
	{
		auto sid_dirs = explorer->mft()->list(utils::strings::to_utf8(L"C:\\Users\\" + std::get<0>(user_dir) + L"\\AppData\\Roaming\\Microsoft\\Crypto\\RSA"), true, false);
		for (auto sid_dir : sid_dirs)
		{
			auto key_files = explorer->mft()->list(utils::strings::to_utf8(L"C:\\Users\\" + std::get<0>(user_dir) + L"\\AppData\\Roaming\\Microsoft\\Crypto\\RSA\\" + std::get<0>(sid_dir)), false, true);
			for (auto key_file : key_files)
			{
				auto record_keyfile = explorer->mft()->record_from_number(std::get<1>(key_file));
				auto data = record_keyfile->data();

				tab->add_item_line(std::to_string(key_count));
				tab->add_item_line(utils::strings::to_utf8(std::get<0>(user_dir)));
				tab->add_item_multiline(
					{
						"Name   : " + utils::strings::to_utf8(std::get<0>(key_file)),
						"Record : " + utils::format::hex6(record_keyfile->header()->MFTRecordIndex, true),
						"Size   : " + utils::format::size(data->size())
					}
				);

				key_count++;
				std::shared_ptr<KeyFile> kf = std::make_shared<KeyFile>(data->data(), data->size());
				if (kf->is_loaded())
				{
					std::vector<std::string> cell = { "Name      : " + kf->name() };
					auto private_enc = kf->private_key();
					if (private_enc)
					{
						cell.push_back("Masterkey : " + utils::id::guid_to_string(private_enc->header()->MasterKeyGuid));
					}
					tab->add_item_multiline(cell);
				}
				else
				{
					tab->add_item_line("Invalid Key File");
				}

				PMFT_RECORD_ATTRIBUTE_HEADER stdinfo_att = record_keyfile->attribute_header($STANDARD_INFORMATION);
				if (stdinfo_att)
				{
					PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION stdinfo = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION, stdinfo_att, stdinfo_att->Form.Resident.ValueOffset);
					SYSTEMTIME st = { 0 };
					utils::times::ull_to_local_systemtime(stdinfo->CreateTime, &st);
					tab->add_item_line(utils::times::display_systemtime(st));
				}
				else
				{
					tab->add_item_line("");
				}

				tab->new_line();
			}
		}
	}

	if (key_count == 0)
	{
		std::cout << "[+] No key found" << std::endl;
	}
	else
	{
		std::cout << "    " << key_count << " key(s) found" << std::endl;
		std::cout << "[+] Keys" << std::endl;
		tab->render(std::cout);
	}

	return 0;
}

namespace commands
{
	namespace efs
	{
		namespace key
		{
			int dispatch(std::shared_ptr<Options> opts)
			{
				std::ios_base::fmtflags flag_backup(std::cout.flags());

				std::shared_ptr<Disk> disk = get_disk(opts);
				if (disk != nullptr)
				{
					std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
					if (volume != nullptr)
					{
						if (opts->inode >= 0 || opts->from != "")
						{
							if (opts->masterkey != nullptr)
							{
								decrypt_key(disk, volume, opts);
							}
							else
							{
								show_key(disk, volume, opts);
							}
						}
						else
						{
							list_keys(disk, volume, opts);
						}
					}
					else
					{
						invalid_option(opts, "volume", opts->volume);
					}
				}
				else
				{
					invalid_option(opts, "disk", opts->disk);
				}

				std::cout.flags(flag_backup);
				return 0;
			}
		}
	}
}

```

`Sources/Commands/command_efs_masterkey.cpp`:

```cpp
#include "commands.h"
#include "EFS/masterkey_file.h"
#include "NTFS/ntfs_explorer.h"
#include <Utils/table.h>
#include <Utils/constant_names.h>


int decrypt_masterkey(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("Decrypt masterkey from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << (vol->name().empty() ? reinterpret_cast<Disk*>(vol->parent())->name() : vol->name()) << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);
	std::shared_ptr<MFTRecord> masterkey_file_record = commands::helpers::find_record(explorer, opts);
	auto data = masterkey_file_record->data();

	std::shared_ptr<MasterKeyFile> masterkey_file = std::make_shared<MasterKeyFile>(data->data(), data->size());
	if (!masterkey_file->is_loaded())
	{
		std::cerr << "[!] Failed to parse masterkey file from record: " << opts->inode << std::endl;
		return 3;
	}

	auto master_key = masterkey_file->master_key();
	if (master_key)
	{
		std::cout << "[-] Masterkey" << std::endl;
		std::cout << "    Encryption Algorithm : " << constants::efs::enc_algorithm(master_key->header()->Enc_algorithm) << std::endl;
		std::cout << "    Hash Algorithm       : " << constants::efs::hash_algorithm(master_key->header()->Hash_algorithm) << std::endl;
		std::cout << "    Rounds               : " << std::to_string(master_key->header()->Rounds) << std::endl;
		std::cout << "    Salt                 : " << utils::convert::to_hex(master_key->header()->Salt, 16) << std::endl;

		std::cout << "[+] Decrypting masterkey" << std::endl;
		auto res = master_key->decrypt_with_password(opts->sid, opts->password);
		if (res == nullptr)
		{
			std::cout << "[!] Failed to decrypt. Check SID or password." << std::endl;
		}
		else
		{
			std::cout << "[+] Clear masterkey (" << res->size() * 4 << "bits):" << std::endl;

			int i, size = res->size();
			for (i = 0; i < size; i += 32)
			{
				std::cout << "    " << utils::convert::to_hex(res->data() + i, min(32, size - i)) << std::endl;
			}
		}
	}
	else
	{
		std::cerr << "[!] No masterkey in specified file." << std::endl;
		return 3;
	}

	return 0;
}


int show_masterkey(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("Display masterkey from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << (vol->name().empty() ? reinterpret_cast<Disk*>(vol->parent())->name() : vol->name()) << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);
	std::shared_ptr<MFTRecord> masterkey_file_record = commands::helpers::find_record(explorer, opts);

	auto data = masterkey_file_record->data();
	std::shared_ptr<MasterKeyFile> masterkey_file = std::make_shared<MasterKeyFile>(data->data(), data->size());
	if (!masterkey_file->is_loaded())
	{
		std::cerr << "[!] Failed to parse masterkey file from record: " << opts->inode << std::endl;
		return 3;
	}

	std::shared_ptr<utils::ui::Table> tab = std::make_shared<utils::ui::Table>();
	tab->set_margin_left(4);
	tab->set_interline(true);
	tab->add_header_line("Id", utils::ui::TableAlign::RIGHT);
	tab->add_header_line("Property");
	tab->add_header_line("Value");

	std::string date;
	PMFT_RECORD_ATTRIBUTE_HEADER stdinfo_att = masterkey_file_record->attribute_header($STANDARD_INFORMATION);
	if (stdinfo_att)
	{
		PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION stdinfo = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION, stdinfo_att, stdinfo_att->Form.Resident.ValueOffset);
		SYSTEMTIME st = { 0 };
		utils::times::ull_to_local_systemtime(stdinfo->CreateTime, &st);
		date = utils::times::display_systemtime(st);
	}

	int i = 0;
	tab->add_item_line(std::to_string(i++));
	tab->add_item_line("File");
	tab->add_item_multiline(
		{
			"Creation : " + date,
			"Size     : " + utils::format::size(data->size())
		}
	);

	tab->new_line();

	tab->add_item_line(std::to_string(i++));
	tab->add_item_line("Version");
	tab->add_item_line(std::to_string(masterkey_file->version()));

	tab->new_line();

	tab->add_item_line(std::to_string(i++));
	tab->add_item_line("GUID");
	tab->add_item_line(masterkey_file->guid());

	tab->new_line();

	tab->add_item_line(std::to_string(i++));
	tab->add_item_line("Policy");
	tab->add_item_line(utils::format::hex(masterkey_file->policy(), true));

	tab->new_line();

	auto master_key = masterkey_file->master_key();
	if (master_key)
	{
		tab->add_item_line(std::to_string(i++));
		tab->add_item_line("MasterKey");
		tab->add_item_multiline(
			{
				"Version  : " + std::to_string(master_key->header()->Version),
				"Salt     : " + utils::convert::to_hex(master_key->header()->Salt, 16),
				"Rounds   : " + std::to_string(master_key->header()->Rounds),
				"Hash Alg : " + constants::efs::hash_algorithm(master_key->header()->Hash_algorithm),
				"Enc Alg  : " + constants::efs::enc_algorithm(master_key->header()->Enc_algorithm),
				"Enc Key  : " + utils::convert::to_hex(master_key->key()->data(), master_key->key()->size())
			}
		);

		tab->new_line();
	}

	auto backup_key = masterkey_file->backup_key();
	if (backup_key)
	{
		tab->add_item_line(std::to_string(i++));
		tab->add_item_line("BackupKey");
		tab->add_item_multiline(
			{
				"Version  : " + std::to_string(backup_key->header()->Version),
				"Salt     : " + utils::convert::to_hex(backup_key->header()->Salt, 16),
				"Rounds   : " + std::to_string(backup_key->header()->Rounds),
				"Hash Alg : " + constants::efs::hash_algorithm(backup_key->header()->Hash_algorithm),
				"Enc Alg  : " + constants::efs::enc_algorithm(backup_key->header()->Enc_algorithm),
				"Enc Key  : " + utils::convert::to_hex(backup_key->key()->data(), backup_key->key()->size())
			}
		);

		tab->new_line();
	}

	auto domain_key = masterkey_file->domain_key();
	if (domain_key)
	{
		tab->add_item_line(std::to_string(i++));
		tab->add_item_line("DomainKey");
		tab->add_item_multiline(
			{
				"Version     : " + std::to_string(domain_key->header()->Version),
				"GUID        : " + utils::id::guid_to_string(domain_key->header()->Guid),
				"Secret      : " + utils::convert::to_hex(domain_key->secret()->data(), domain_key->secret()->size()),
				"AccessCheck : " + utils::convert::to_hex(domain_key->access_check()->data(), domain_key->access_check()->size())
			}
		);

		tab->new_line();
	}

	auto credhist = masterkey_file->credential_history();
	if (credhist)
	{
		tab->add_item_line(std::to_string(i++));
		tab->add_item_line("CredHist");
		tab->add_item_multiline(
			{
				"Version  : " + std::to_string(credhist->header()->Version),
				"GUID     : " + utils::id::guid_to_string(credhist->header()->Guid)
			}
		);

		tab->new_line();
	}

	std::cout << "[+] MasterKey" << std::endl;
	tab->render(std::cout);

	return 0;
}

int list_masterkeys(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("List masterkeys from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << (vol->name().empty() ? reinterpret_cast<Disk*>(vol->parent())->name() : vol->name()) << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);

	std::cout << "[+] Listing user directories" << std::endl;
	auto user_dirs = explorer->mft()->list("C:\\Users", true, false);
	std::cout << "    " << user_dirs.size() << " directories found" << std::endl;

	std::cout << "[+] Searching for keys" << std::endl;

	int masterkey_count = 0;
	int preferred_count = 0;

	std::shared_ptr<utils::ui::Table> tab = std::make_shared<utils::ui::Table>();
	tab->set_margin_left(4);
	tab->set_interline(true);
	tab->add_header_line("Id", utils::ui::TableAlign::RIGHT);
	tab->add_header_line("User");
	tab->add_header_line("Keyfile");
	tab->add_header_line("Key(s)");
	tab->add_header_line("Creation Date");

	for (auto user_dir : user_dirs)
	{
		auto sid_dirs = explorer->mft()->list(utils::strings::to_utf8(L"C:\\Users\\" + std::get<0>(user_dir) + L"\\AppData\\Roaming\\Microsoft\\Protect"), true, false);
		for (auto sid_dir : sid_dirs)
		{
			auto key_files = explorer->mft()->list(utils::strings::to_utf8(L"C:\\Users\\" + std::get<0>(user_dir) + L"\\AppData\\Roaming\\Microsoft\\Protect\\" + std::get<0>(sid_dir)), false, true);
			for (auto key_file : key_files)
			{
				auto record_keyfile = explorer->mft()->record_from_number(std::get<1>(key_file));
				auto data = record_keyfile->data();

				tab->add_item_line(std::to_string(masterkey_count + preferred_count));
				tab->add_item_line(utils::strings::to_utf8(std::get<0>(user_dir)));
				tab->add_item_multiline(
					{
						"Name   : " + utils::strings::to_utf8(std::get<0>(key_file)),
						"Record : " + utils::format::hex6(record_keyfile->header()->MFTRecordIndex, true),
						"Size   : " + utils::format::size(data->size())
					}
				);

				std::vector<std::string> cell;

				if (std::get<0>(key_file) == L"Preferred")
				{
					preferred_count++;
					PEFS_PREFERRED_FILE pref = reinterpret_cast<PEFS_PREFERRED_FILE>(data->data());
					SYSTEMTIME st;
					utils::times::filetime_to_systemtime(pref->timestamp, &st);

					cell.push_back("Preferred ");
					cell.push_back("    GUID    : " + utils::id::guid_to_string(pref->Guid));
					cell.push_back("    Renew   : " + utils::times::display_systemtime(st));
				}
				else
				{
					masterkey_count++;
					std::shared_ptr<MasterKeyFile> mkf = std::make_shared<MasterKeyFile>(data->data(), data->size());
					if (mkf->is_loaded())
					{
						cell.push_back("GUID        : " + mkf->guid());
						cell.push_back("");

						auto master_key = mkf->master_key();
						if (master_key)
						{
							cell.push_back("MasterKey ");
							cell.push_back("    Version : " + std::to_string(master_key->header()->Version));
							cell.push_back("    Algo    : " + constants::efs::hash_algorithm(master_key->header()->Hash_algorithm) + " - " + constants::efs::enc_algorithm(master_key->header()->Enc_algorithm));
							cell.push_back("    Salt    : " + utils::convert::to_hex(master_key->header()->Salt, 16));
							cell.push_back("    Rounds  : " + std::to_string(master_key->header()->Rounds));
						}
						auto backup_key = mkf->backup_key();
						if (backup_key)
						{
							cell.push_back("BackupKey ");
							cell.push_back("    Version : " + std::to_string(backup_key->header()->Version));
							cell.push_back("    Algo    : " + constants::efs::hash_algorithm(backup_key->header()->Hash_algorithm) + " - " + constants::efs::enc_algorithm(backup_key->header()->Enc_algorithm));
							cell.push_back("    Salt    : " + utils::convert::to_hex(backup_key->header()->Salt, 16));
							cell.push_back("    Rounds  : " + std::to_string(backup_key->header()->Rounds));
						}
						auto cred_hist = mkf->credential_history();
						if (cred_hist)
						{
							cell.push_back("CredHist");
							cell.push_back("    Version : " + std::to_string(cred_hist->header()->Version));
							cell.push_back("    GUID    : " + utils::id::guid_to_string(cred_hist->header()->Guid));
						}
						auto domain_key = mkf->domain_key();
						if (domain_key)
						{
							cell.push_back("DomainKey");
							cell.push_back("    Version : " + std::to_string(domain_key->header()->Version));
							cell.push_back("    GUID    : " + utils::id::guid_to_string(domain_key->header()->Guid));
						}
					}
					else
					{
						cell.push_back("Invalid MasterKey File");
					}
				}
				tab->add_item_multiline(cell);

				PMFT_RECORD_ATTRIBUTE_HEADER stdinfo_att = record_keyfile->attribute_header($STANDARD_INFORMATION);
				if (stdinfo_att)
				{
					PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION stdinfo = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION, stdinfo_att, stdinfo_att->Form.Resident.ValueOffset);
					SYSTEMTIME st = { 0 };
					utils::times::ull_to_local_systemtime(stdinfo->CreateTime, &st);
					tab->add_item_line(utils::times::display_systemtime(st));
				}
				else
				{
					tab->add_item_line("");
				}

				tab->new_line();
			}
		}
	}

	if (masterkey_count == 0)
	{
		std::cout << "[+] No masterkey found" << std::endl;
	}
	else
	{
		std::cout << "    " << masterkey_count << " key(s), " << preferred_count << " preferred file(s) found" << std::endl;
		std::cout << "[+] MasterKeys" << std::endl;
		tab->render(std::cout);
	}

	return 0;
}

namespace commands
{
	namespace efs
	{
		namespace masterkey
		{
			int dispatch(std::shared_ptr<Options> opts)
			{
				std::ios_base::fmtflags flag_backup(std::cout.flags());

				std::shared_ptr<Disk> disk = get_disk(opts);
				if (disk != nullptr)
				{
					std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
					if (volume != nullptr)
					{
						if (opts->inode >= 0 || opts->from != "")
						{
							if (opts->password != "" && opts->sid != "")
							{
								decrypt_masterkey(disk, volume, opts);
							}
							else
							{
								show_masterkey(disk, volume, opts);
							}
						}
						else
						{
							list_masterkeys(disk, volume, opts);
						}
					}
					else
					{
						invalid_option(opts, "volume", opts->volume);
					}
				}
				else
				{
					invalid_option(opts, "disk", opts->disk);
				}

				std::cout.flags(flag_backup);
				return 0;
			}
		}
	}
}

```

`Sources/Commands/command_extract.cpp`:

```cpp
#include "Drive/disk.h"
#include "Utils/utils.h"
#include "options.h"
#include "Commands/commands.h"
#include "NTFS/ntfs.h"
#include "NTFS/ntfs_explorer.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"

#include <nlohmann/json.hpp>

#include <cstdint>
#include <string>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>

int extract_file(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("Extract file from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << (vol->name().empty() ? reinterpret_cast<Disk*>(vol->parent())->name() : vol->name()) << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);
	std::shared_ptr<MFTRecord> record = commands::helpers::find_record(explorer, opts);
	auto [filepath, stream_name] = utils::files::split_file_and_stream(opts->from);

	std::cout << "[-] Record Num  : " << record->header()->MFTRecordIndex << " (" << utils::format::hex(record->header()->MFTRecordIndex, true) << ")" << std::endl;

	std::cout << "[-] Destination : " << opts->output << std::endl;

	PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION stdinfo = nullptr;
	PMFT_RECORD_ATTRIBUTE_HEADER stdinfo_att = record->attribute_header($STANDARD_INFORMATION);
	if (stdinfo_att)
	{
		stdinfo = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION, stdinfo_att, stdinfo_att->Form.Resident.ValueOffset);
	}
	if (stdinfo)
	{
		if (stdinfo->u.Permission.encrypted)
		{
			std::cout << "[!] Extracting encrypted data (not readable)" << std::endl;
		}
	}

	std::cout << "[+] Extracting file..." << std::endl;
	std::wstring output_filename = utils::strings::from_string(opts->output);

	ULONG64 written = record->data_to_file(output_filename, stream_name, true);
	std::cout << "[+] " << written << " bytes (" + utils::format::size(written) << ") written" << std::endl;

	if (stdinfo)
	{
		HANDLE hFile = CreateFileW(output_filename.c_str(), FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL,
			OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			if (!SetFileTime(hFile, (FILETIME*)&stdinfo->CreateTime, (FILETIME*)&stdinfo->ReadTime, (FILETIME*)&stdinfo->AlterTime))
			{
				std::cerr << "[!] Failed to set file time" << std::endl;
			}
			CloseHandle(hFile);
		}

		if (!SetFileAttributesW(output_filename.c_str(), stdinfo->u.dword_part))
		{
			std::cerr << "[!] Failed to set attributes" << std::endl;
		}
	}


	return 0;
}

namespace commands
{
	namespace extract
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
				if (volume != nullptr)
				{
					if (opts->from == "" && opts->sam)
					{
						opts->from = "c:\\windows\\system32\\config\\sam";
					}
					if (opts->from == "" && opts->system)
					{
						opts->from = "c:\\windows\\system32\\config\\system";
					}
					if (opts->output != "")
					{
						extract_file(disk, volume, opts);
					}
					else
					{
						invalid_option(opts, "output", opts->output);
					}
				}
				else
				{
					invalid_option(opts, "volume", opts->volume);
				}
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}
			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_fve.cpp`:

```cpp
#include <algorithm>
#include <cstdint>
#include <string>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>
#include <stdexcept>
#include <distorm.h>

#include "Drive/disk.h"
#include "Drive/vbr.h"
#include "Bitlocker/bitlocker.h"
#include "options.h"
#include "Utils/utils.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"

void print_bitlocker_fve_block_header(FVE_BLOCK_HEADER fve_bh, unsigned long block_id)
{
	utils::ui::title("FVE Metadata Block #" + std::to_string(block_id) + " Header");

	std::string signature = std::string((char*)fve_bh.signature);
	signature.resize(8);
	std::cout << "Signature             : " << signature << std::endl;
	std::cout << "Size                  : " << fve_bh.size << std::endl;
	std::cout << "Version               : " << fve_bh.version << std::endl;
	std::cout << "Current State         : " << constants::bitlocker::state(fve_bh.curr_state) << " (" << fve_bh.curr_state << ")" << std::endl;
	std::cout << "Next State            : " << constants::bitlocker::state(fve_bh.next_state) << " (" << fve_bh.next_state << ")" << std::endl;
	std::cout << "Encrypted Size        : " << fve_bh.encrypted_volume_size << " (" << utils::format::size(fve_bh.encrypted_volume_size) << ")" << std::endl;
	std::cout << "Convert Size          : " << fve_bh.convert_size << std::endl;
	std::cout << "Backup Sectors        : " << fve_bh.nb_sectors << std::endl;
	std::cout << "FVE Block 1           : " << utils::format::hex(fve_bh.block_header_offsets[0]) << std::endl;
	std::cout << "FVE Block 2           : " << utils::format::hex(fve_bh.block_header_offsets[1]) << std::endl;
	std::cout << "FVE Block 3           : " << utils::format::hex(fve_bh.block_header_offsets[2]) << std::endl;
	std::cout << "Backup Sectors Offset : " << utils::format::hex(fve_bh.backup_sector_offset) << std::endl;
	std::cout << std::endl;
}

void print_bitlocker_fve_header(FVE_HEADER fve_h)
{
	utils::ui::title("FVE Metadata Header");

	std::cout << "Size                  : " << fve_h.size << std::endl;
	std::cout << "Version               : " << fve_h.version << std::endl;
	std::cout << "Header Size           : " << fve_h.header_size << std::endl;
	std::cout << "Copy Size             : " << fve_h.copy_size << std::endl;
	std::cout << "Volume GUID           : " << utils::id::guid_to_string(fve_h.volume_guid) << std::endl;
	std::cout << "Next Counter          : " << fve_h.next_counter << std::endl;
	std::cout << "Algorithm             : " << constants::bitlocker::algorithm(fve_h.algorithm) << " (" << utils::format::hex(fve_h.algorithm) << ")" << std::endl;
	SYSTEMTIME st;
	utils::times::filetime_to_local_systemtime(fve_h.timestamp, &st);
	std::cout << "Timestamp             : " << utils::times::display_systemtime(st) << std::endl;
	std::cout << std::endl;
}

std::vector<std::string> get_fve_entry_values(PFVE_ENTRY entry, const std::string& level = "")
{
	std::vector<std::string> ret;
	switch (entry->value_type)
	{
	case FVE_METADATA_ENTRY_VALUE_TYPE_ERASED:
		ret.push_back("Null");
		break;
	case FVE_METADATA_ENTRY_VALUE_TYPE_KEY:
		ret.push_back("Encryption   : " + constants::bitlocker::algorithm(((PFVE_ENTRY_KEY)entry->data)->encryption_method));
		ret.push_back("Key          : " + utils::format::hex(((PFVE_ENTRY_KEY)entry->data)->key, entry->size - 12, false));
		break;
	case FVE_METADATA_ENTRY_VALUE_TYPE_UNICODE_STRING:
	{
		ret.push_back("String        : " + utils::strings::to_utf8(((PFVE_ENTRY_UNICODE)entry->data)->string));
		break;
	}
	case FVE_METADATA_ENTRY_VALUE_TYPE_STRETCH_KEY:
	{
		ret.push_back("Encryption    : " + constants::bitlocker::algorithm(((PFVE_ENTRY_STRETCH_KEY)entry->data)->encryption_method));
		ret.push_back("MAC           : " + utils::format::hex(((PFVE_ENTRY_STRETCH_KEY)entry->data)->salt, 16, false));

		int sub_entry_size_left = entry->size - 28;
		PFVE_ENTRY psubentry = (PFVE_ENTRY)(((PFVE_ENTRY_STRETCH_KEY)entry->data)->subentries);
		int n = 1;
		while (sub_entry_size_left > 0)
		{
			ret.push_back("");
			ret.push_back("Property #" + level + std::to_string(n) + " - " + constants::bitlocker::fve_value_type(psubentry->value_type) + " - " + std::to_string(psubentry->size));
			ret.push_back("--------");
			for (auto& t : get_fve_entry_values(psubentry, std::to_string(n) + ".")) ret.push_back(t);
			sub_entry_size_left -= psubentry->size;
			psubentry = POINTER_ADD(PFVE_ENTRY, psubentry, psubentry->size);
			n++;
		}

		break;
	}
	case FVE_METADATA_ENTRY_VALUE_TYPE_USE_KEY:
	{
		ret.push_back("Encryption    : " + constants::bitlocker::algorithm(((PFVE_ENTRY_USE_KEY)entry->data)->encryption_method));

		int sub_entry_size_left = entry->size - 12;
		PFVE_ENTRY psubentry = (PFVE_ENTRY)(((PFVE_ENTRY_USE_KEY)entry->data)->subentries);
		int n = 1;
		while (sub_entry_size_left > 0)
		{
			ret.push_back("");
			ret.push_back("Property #" + level + std::to_string(n) + " - " + constants::bitlocker::fve_value_type(psubentry->value_type) + " - " + std::to_string(psubentry->size));
			ret.push_back("--------");
			for (auto& t : get_fve_entry_values(psubentry, std::to_string(n) + ".")) ret.push_back(t);
			sub_entry_size_left -= psubentry->size;
			psubentry = POINTER_ADD(PFVE_ENTRY, psubentry, psubentry->size);
			n++;
		}

		break;
	}
	case FVE_METADATA_ENTRY_VALUE_TYPE_AES_CCM_ENCRYPTED_KEY:
	{
		FILETIME nonce_time = ((PFVE_ENTRY_AES_CCM)entry->data)->nonce_time;
		ULARGE_INTEGER nonce_val = { 0 };
		nonce_val.HighPart = nonce_time.dwHighDateTime;
		nonce_val.LowPart = nonce_time.dwLowDateTime;

		SYSTEMTIME st;
		utils::times::filetime_to_local_systemtime(nonce_time, &st);

		ret.push_back("Nonce as Hex  : " + utils::format::hex(nonce_val.QuadPart, false));
		ret.push_back("Nonce as Time : " + utils::times::display_systemtime(st));
		ret.push_back("Nonce Counter : " + utils::format::hex(((PFVE_ENTRY_AES_CCM)entry->data)->nonce_counter));
		ret.push_back("MAC           : " + utils::format::hex(((PFVE_ENTRY_AES_CCM)entry->data)->mac, 16, false));
		ret.push_back("Key           : " + utils::format::hex(((PFVE_ENTRY_AES_CCM)entry->data)->key, entry->size - 36, false));
		break;
	}
	case FVE_METADATA_ENTRY_VALUE_TYPE_TPM_ENCODED_KEY:
	case FVE_METADATA_ENTRY_VALUE_TYPE_VALIDATION:
		break;
	case FVE_METADATA_ENTRY_VALUE_TYPE_VOLUME_MASTER_KEY:
	{
		GUID key_id = ((PFVE_ENTRY_VMK)entry->data)->key_id;
		FILETIME last_change = ((PFVE_ENTRY_VMK)entry->data)->last_change;
		LARGE_INTEGER last_change_val = { 0 };
		last_change_val.HighPart = last_change.dwHighDateTime;
		last_change_val.LowPart = last_change.dwLowDateTime;

		SYSTEMTIME st;
		utils::times::filetime_to_local_systemtime(last_change, &st);

		ret.push_back("Key ID        : " + utils::id::guid_to_string(key_id));
		ret.push_back("Last Change   : " + utils::times::display_systemtime(st));
		ret.push_back("Protection    : " + constants::bitlocker::fve_key_protection_type(((PFVE_ENTRY_VMK)entry->data)->protection_type));

		int sub_entry_size_left = entry->size - 36;
		PFVE_ENTRY psubentry = (PFVE_ENTRY)(((PFVE_ENTRY_VMK)entry->data)->subentries);
		int n = 1;
		while (sub_entry_size_left > 0)
		{
			ret.push_back("");
			ret.push_back("Property #" + level + std::to_string(n) + " - " + constants::bitlocker::fve_value_type(psubentry->value_type) + " - " + std::to_string(psubentry->size));
			ret.push_back("--------");
			for (auto& t : get_fve_entry_values(psubentry, std::to_string(n) + ".")) ret.push_back(t);
			sub_entry_size_left -= psubentry->size;
			psubentry = POINTER_ADD(PFVE_ENTRY, psubentry, psubentry->size);
			n++;
		}
		break;
	}
	case FVE_METADATA_ENTRY_VALUE_TYPE_EXTERNAL_KEY:

	{
		GUID key_id = ((PFVE_ENTRY_EXTERNAL_KEY)entry->data)->key_id;
		FILETIME last_change = ((PFVE_ENTRY_EXTERNAL_KEY)entry->data)->last_change;
		LARGE_INTEGER last_change_val = { 0 };
		last_change_val.HighPart = last_change.dwHighDateTime;
		last_change_val.LowPart = last_change.dwLowDateTime;

		SYSTEMTIME st;
		utils::times::filetime_to_local_systemtime(last_change, &st);

		ret.push_back("Key ID        : " + utils::id::guid_to_string(key_id));
		ret.push_back("Last Change   : " + utils::times::display_systemtime(st));
		ret.push_back("Key           : " + utils::format::hex(((PFVE_ENTRY_EXTERNAL_KEY)entry->data)->key, entry->size - 32, false));
		break;
	}
	case FVE_METADATA_ENTRY_VALUE_TYPE_UPDATE:
	case FVE_METADATA_ENTRY_VALUE_TYPE_ERROR:
	case FVE_METADATA_ENTRY_VALUE_TYPE_ASYMMETRIC_ENCRYPTION:
	case FVE_METADATA_ENTRY_VALUE_TYPE_EXPORTED_KEY:
	case FVE_METADATA_ENTRY_VALUE_TYPE_PUBLIC_KEY:
		break;
	case FVE_METADATA_ENTRY_VALUE_TYPE_OFFSET_AND_SIZE:
	{
		ret.push_back("Offset        : " + utils::format::hex(((PFVE_ENTRY_OFFSET_SIZE)entry->data)->offset));
		ret.push_back("Size          : " + utils::format::hex(((PFVE_ENTRY_OFFSET_SIZE)entry->data)->size));
		break;
	}
	case FVE_METADATA_ENTRY_VALUE_TYPE_CONCAT_HASH_KEY:
	default:
		ret.push_back("Unknown Value Type (" + std::to_string(entry->value_type) + ")");
	}
	return ret;
}

void print_bitlocker_vbr(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, unsigned long block_id) {
	std::cout << std::setfill('0');
	utils::ui::title("FVE Info from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	PBOOT_SECTOR_COMMON pbsc = (PBOOT_SECTOR_COMMON)vol->bootsector();
	if (strncmp((char*)pbsc->oemID, "-FVE-FS-", 8) == 0)
	{
		print_bitlocker_fve_block_header(vol->bitlocker().metadata[block_id].block_header, block_id);
		print_bitlocker_fve_header(vol->bitlocker().metadata[block_id].header);

		std::shared_ptr<utils::ui::Table> fve_entries = std::make_shared<utils::ui::Table>();
		fve_entries->set_interline(true);

		fve_entries->add_header_line("Id");
		fve_entries->add_header_line("Version");
		fve_entries->add_header_line("Size");
		fve_entries->add_header_line("Entry Type");
		fve_entries->add_header_line("Value Type");
		fve_entries->add_header_line("Value");

		unsigned int n = 0;
		for (auto& entry : vol->bitlocker().metadata[block_id].entries)
		{
			n++;
			fve_entries->add_item_line(std::to_string(n));
			fve_entries->add_item_line(std::to_string(entry->data()->version));
			fve_entries->add_item_line(std::to_string(entry->data()->size));
			fve_entries->add_item_line(constants::bitlocker::fve_entry_type(entry->data()->entry_type));
			fve_entries->add_item_line(constants::bitlocker::fve_value_type(entry->data()->value_type));

			fve_entries->add_item_multiline(get_fve_entry_values(entry->data()));

			fve_entries->new_line();
		}

		utils::ui::title("FVE Metadata Entries (" + std::to_string(vol->bitlocker().metadata[block_id].entries.size()) + ")");
		fve_entries->render(std::cout);
		std::cout << std::endl;
	}
	else
	{
		std::cout << "[!] Volume is not Bitlocked" << std::endl;
	}
}

namespace commands {
	namespace fve {
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
				if (volume != nullptr)
				{
					if ((opts->fve_block >= 0) && (opts->fve_block < 3))
					{
						print_bitlocker_vbr(disk, volume, opts->fve_block);
					}
					else
					{
						invalid_option(opts, "fve_block", opts->fve_block);
					}
				}
				else
				{
					invalid_option(opts, "volume", opts->volume);
				}
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_gpt.cpp`:

```cpp
#include "Utils/buffer.h"
#include "Drive/disk.h"
#include "Utils/utils.h"
#include "Utils/table.h"
#include "options.h"
#include "Utils/constant_names.h"

#include <intrin.h>
#include <distorm.h>

#include <algorithm>
#include <cstdint>
#include <string>
#include <iostream>
#include <iomanip>
#include <memory>
#include <stdexcept>

void print_gpt(std::shared_ptr<Disk> disk)
{
	PGPT_HEADER pgpt = disk->gpt();
	if (disk->has_protective_mbr())
	{
		utils::ui::title("GPT from " + disk->name());

		std::vector<GPT_PARTITION_ENTRY> gpt_entries = disk->gpt_entries();

		std::cout << "Signature        : " << pgpt->magic << std::endl;
		std::cout << "Revision         : " << pgpt->revision_high << "." << pgpt->revision_low << std::endl;
		std::cout << "Header Size      : " << pgpt->header_size << std::endl;
		std::cout << "Header CRC32     : " << std::setfill('0') << std::setw(8) << std::hex << _byteswap_ulong(pgpt->header_crc32) << std::endl;
		std::cout << "Reserved         : " << std::setfill('0') << std::setw(8) << std::hex << pgpt->reserved1 << std::endl;
		std::cout << std::dec << std::setw(0);
		std::cout << "Current LBA      : " << pgpt->current_lba << std::endl;
		std::cout << "Backup LBA       : " << pgpt->backup_lba << std::endl;
		std::cout << "First Usable LBA : " << pgpt->first_usable_lba << std::endl;
		std::cout << "Last Usable LBA  : " << pgpt->last_usable_lba << std::endl;
		std::cout << "GUID             : " << utils::id::guid_to_string(pgpt->disk_guid) << std::endl;
		std::cout << "Entry LBA        : " << pgpt->partition_entry_lba << std::endl;
		std::cout << "Entries Num      : " << pgpt->num_partition_entries << std::endl;
		std::cout << "Entries Size     : " << pgpt->sizeof_partition_entry << std::endl;
		std::cout << "Partitions CRC32 : " << std::setfill('0') << std::setw(8) << std::hex << _byteswap_ulong(pgpt->partition_entry_array_crc32) << std::endl;

		std::shared_ptr<utils::ui::Table> partitions = std::make_shared<utils::ui::Table>();

		partitions->add_header_line("Id");
		partitions->add_header_line("Name");
		partitions->add_header_line("GUID");
		partitions->add_header_line("First sector");
		partitions->add_header_line("Last sector");
		partitions->add_header_line("Flags");

		unsigned int n_partitions = 0;
		for (GPT_PARTITION_ENTRY& entry : gpt_entries) {
			n_partitions++;
			partitions->add_item_line(std::to_string(n_partitions));
			partitions->add_item_line(utils::strings::to_utf8(entry.PartitionName));
			partitions->add_item_line(utils::id::guid_to_string(entry.UniquePartitionGUID));
			partitions->add_item_line(std::to_string(entry.StartingLBA));
			partitions->add_item_line(std::to_string(entry.EndingLBA));
			partitions->add_item_line(utils::format::hex(entry.Attributes));
			partitions->new_line();
		}

		std::cout << std::endl << "Partition table  : " << gpt_entries.size() << " entries" << std::endl;
		partitions->render(std::cout);
		std::cout << std::endl;
	}
	else
	{
		std::cerr << "[!] Invalid or non-GPT partition table";
	}
}

namespace commands
{
	namespace gpt
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				print_gpt(disk);
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_help.cpp`:

```cpp
#include "Drive/disk.h"
#include "Utils/utils.h"
#include "options.h"
#include "Utils/constant_names.h"

#include <cstdint>
#include <string>
#include <iostream>
#include <iomanip>
#include <memory>

#define VERSION "1.5"

void usage(const char* binname)
{
	std::cerr << "Usage: " << binname << " command [options]" << std::endl;
	std::cerr << std::endl;
	std::cerr << "Version: " << VERSION << " (Build date: " << __DATE__ << " " << __TIME__ << ")" << std::endl << std::endl;
	std::cerr << "Commands:" << std::endl;
	std::cerr << "  info            : list and display physical disks and volumes" << std::endl;
	std::cerr << "  mbr             : display master boot record" << std::endl;
	std::cerr << "  gpt             : display GUID partition table" << std::endl;
	std::cerr << "  vbr             : display volume boot record" << std::endl;
	std::cerr << "  mft.record      : display master file table" << std::endl;
	std::cerr << "  mft.btree       : display index btree" << std::endl;
	std::cerr << "  extract         : extract a file" << std::endl;
	std::cerr << "  bitlocker       : display bitlocker GUID/status and test password, recovery or BEK file" << std::endl;
	std::cerr << "  bitdecrypt      : decrypt volume to an image file" << std::endl;
	std::cerr << "  fve             : display FVE metadata" << std::endl;
	std::cerr << "  efs.backup      : Export EFS keys from a volume" << std::endl;
	std::cerr << "  efs.decrypt     : Decrypt EFS encrypted file from backup key" << std::endl;
	std::cerr << "  efs.certificate : list, display and export system certificates" << std::endl;
	std::cerr << "  efs.key         : list, display, decrypt and export private keys" << std::endl;
	std::cerr << "  efs.masterkey   : list, display and decrypt masterkeys" << std::endl;
	std::cerr << "  logfile         : dump and parse log file" << std::endl;
	std::cerr << "  usn             : dump and parse usn journal" << std::endl;
	std::cerr << "  shadow          : list volume shadow copies" << std::endl;
	std::cerr << "  reparse         : parse and display reparse points" << std::endl;
	std::cerr << "  undelete        : find deleted files" << std::endl;
	std::cerr << "  shell           : start a mini-shell" << std::endl;
	std::cerr << "  smart           : display SMART data" << std::endl;
	std::cerr << "  help            : display this message or command help" << std::endl;
	std::cerr << std::endl;
	std::cerr << "Need help for a command?" << std::endl;
	std::cerr << "  help [command]" << std::endl;
	std::cerr << std::endl;
}

void command_header(const char* cmd)
{
	std::cerr << cmd << " command" << std::endl;
	for (int i = 0; i < strnlen_s(cmd, 20) + 8; i++) std::cerr << "-";
	std::cerr << std::endl << std::endl;
}

void command_description(const char* name, const char* usage, const char* description)
{
	std::cerr << "  " << name << " " << usage << std::endl;
	std::cerr << std::endl;
	std::cerr << "  - " << description << std::endl;
	std::cerr << std::endl;
}

void command_examples(const char* name, const char* title, const char* example)
{

	std::cerr << "  " << title << ":" << std::endl;
	std::cerr << "  > " << name << " " << example << std::endl;
	std::cerr << std::endl;
}

void print_help_help(const char* name)
{
	command_header("help");
	command_description(name, "help [command]", "Provides help information for all commands");
	command_examples(name, "Example", "help shell");
}

void print_help_info(const char* name)
{
	command_header("info");
	command_description(name, "info (disk id) (volume id)", "Provides a list of physical disks or information for selected disk and volume");
	command_examples(name, "Display the list of physical disks", "info");
	command_examples(name, "Display information on disk 1", "info disk=1");
	command_examples(name, "Display information on disk 2 and volume 1", "info disk=2 volume=1");
}

void print_help_mbr(const char* name)
{
	command_header("mbr");
	command_description(name, "mbr [disk id]", "Provides MBR information and partition table for selected disk");
	command_examples(name, "Display MBR for disk 0", "mbr disk=0");
}

void print_help_gpt(const char* name)
{
	command_header("gpt");
	command_description(name, "gpt [disk id]", "Provides GPT information and partition table for selected disk");
	command_examples(name, "Display GPT for disk 0", "gpt disk=0");
}

void print_help_vbr(const char* name)
{
	command_header("vbr");
	command_description(name, "vbr [disk id] [volume id]", "Provides VBR information and disassembly for selected disk and volume");
	command_examples(name, "Display VBR for disk 0 and volume 2", "vbr disk=0 volume=2");
}

void print_help_mft_record(const char* name)
{
	command_header("mft.record");
	command_description(name, "mft.record [disk id] [volume id] (inode/from)", "Display MFT file record information and detailed attributes for selected disk, volume and inode/path");
	command_examples(name, "Display MFT file record for disk 0, volume 2 and inode 5", "mft.record disk=0 volume=2 inode=5");
	command_examples(name, "Display MFT File record for disk 0, volume 2 and file \"c:\\file.bin\"", "mft.record disk=0 volume=2 from=\"c:\\file.bin\"");
}

void print_help_mft_btree(const char* name)
{
	command_header("mft.btree");
	command_description(name, "mft.btree [disk id] [volume id] (inode/from)", "Display index B-tree nodes and detailed attributes for selected disk, volume and inode/path");
	command_examples(name, "Display Index B-tree for disk 0, volume 2 and inode 5", "mft.btree disk=0 volume=2 inode=5");
	command_examples(name, "Display Index B-tree for disk 0, volume 2 and from \"c:\\file.bin\"", "mft.btree disk=0 volume=2 from \"c:\\file.bin\"");
}

void print_help_bitlocker(const char* name)
{
	command_header("bitlocker");
	command_description(name, "bitlocker [disk id] [volume id] (password | recovery | bek)", "Provides Bitlocker information for selected disk, volume");
	command_examples(name, "Display Bitlocker information for disk 2, volume 4", "bitlocker disk=2 volume=4");
	command_examples(name, "Test a password for encrypted for disk 2 and volume 4", "bitlocker disk=0 volume=2 password=123456");
	command_examples(name, "Test a recovery key for encrypted for disk 2 and volume 4", "bitlocker disk=0 volume=2 recovery=123456-234567-345678-456789-567890-678901-789012-890123");
	command_examples(name, "Test a BEK file for encrypted for disk 2 and volume 4", "bitlocker disk=0 volume=2 bek=H:\\3926293F-E661-4417-A36B-B41175B4D862.BEK");
}

void print_help_bitdecrypt(const char* name)
{
	command_header("bitdecrypt");
	command_description(name, "bitdecrypt [disk id] [volume id] [fvek] [output]", "Decrypt Bitlocker encrypted volume to a file using the Full Volume Encryption Key (FVEK)");
	command_examples(name, "Decrypt disk 2, volume 4 to decrypted.img", "bitdecrypt disk=2 volume=4 fvek=21DA18B8434D864D11654FE84AAB1BDDF135DFDE912EBCAD54A6D87CB8EF64AC output=decrypted.img");
}

void print_help_fve(const char* name)
{
	command_header("fve");
	command_description(name, "fve [disk id] [volume id] (block)", "Display FVE metadata information for an Bitlocker encrypted volume");
	command_examples(name, "Display FVE metadata for disk 0, volume 1", "fve disk=0 volume=1");
	command_examples(name, "Display FVE metadata for disk 2, volume 4 and FVE block 2", "fve disk=2 volume=4 fve_block=2");
}

void print_help_logfile(const char* name)
{
	command_header("logfile");
	command_description(name, "logfile [disk id] [volume id] [output] (format)", "Dump or parse the $LogFile of a NTFS volume ");
	command_examples(name, "Dump raw $LogFile for disk 1, volume 2 to log.dat", "logfile disk=1 volume=2 output=log.dat");
	command_examples(name, "Parse logfile for disk 2, volume 4 and output results in csv file", "logfile disk=2 volume=4 output=log.csv format=csv");
}

void print_help_usn(const char* name)
{
	command_header("usn");
	command_description(name, "usn [disk id] [volume id] [output] (format)", "Dump or parse the $UsnJrnl of a NTFS volume (raw, csv, json)");
	command_examples(name, "Dump raw $UsnJrnl for disk 1, volume 2 to usn.dat", "usn disk=1 volume=2 output=usn.dat");
	command_examples(name, "Parse usn journal for disk 2, volume 4 and output results in json file", "usn disk=2 volume=4 output=usn.json format=json");
}


void print_help_efs_masterkey(const char* name)
{
	command_header("efs.masterkey");
	command_description(name, "efs.masterkey [disk id] [volume id] (inode/from) (sid) (password)", "List, display and decrypt masterkeys on a volume");
	command_examples(name, "List masterkeys for disk 1, volume 2", "efs.masterkey disk=1 volume=2");
	command_examples(name, "Display a masterkey for disk 1, volume 2 and inode 0x1337", "efs.masterkey disk=1 volume=2 inode=0x1337");
	command_examples(name, "Decrypt and display a masterkey using sid and password", "efs.masterkey disk=1 volume=2 inode=0x1337 sid=\"S-1123...1001\" password=\"123456\"");
}


void print_help_efs_backup(const char* name)
{
	command_header("efs.backup");
	command_description(name, "efs.backup [disk id] [volume id] [password]", "Export EFS keys from a volume");
	command_examples(name, "Export EFS keys for disk 1, volume 2 using password:123456", "efs.backup disk=1 volume=2 password=123456");
}

void print_help_efs_decrypt(const char* name)
{
	command_header("efs.decrypt");
	command_description(name, "efs.decrypt [disk id] [volume id] [inode|from] [pfx] [password] (output)", "Decrypt file from inode or path using pfx archive (protected by password) to output");
	command_examples(name, "Decrypt EFS file inode:1234 for disk 1 and volume 2 using backup.pfx protected by password 123456 to mydecryptedfile",
		"efs.decrypt disk=1 volume=2 inode=1234 pfx=backup.pfx password=123456 output=mydecryptedfile");
}

void print_help_efs_key(const char* name)
{
	command_header("efs.key");
	command_description(name, "efs.key [disk id] [volume id] [inode|from] (masterkey) (output) (format)", "List, display and decrypt keys on a volume");
	command_examples(name, "List keys for disk 1, volume 2", "efs.key disk=1 volume=2");
	command_examples(name, "Display a key for disk 1, volume 2 and inode 0x1337", "efs.key disk=1 volume=2 inode=0x1337");
	command_examples(name, "Decrypt a key for inode 0x1337 with masterkey", "efs.key disk=1 volume=2 inode=0x1337 masterkey=DEADBEEF123...321");
	command_examples(name, "Export a key to mykey.pem", "efs.key disk=1 volume=2 inode=0x1337 masterkey=DEADBEEF123...321 output=mykey");
}

void print_help_efs_certificate(const char* name)
{
	command_header("efs.certificate");
	command_description(name, "efs.certificate [disk id] [volume id] [inode|from] (output) (format)", "List and display certificate on a volume");
	command_examples(name, "List certificates for disk 1, volume 2", "efs.certificate disk=1 volume=2");
	command_examples(name, "Display a certificate for disk 1, volume 2 and inode 0x1337", "efs.certificate disk=1 volume=2 inode=0x1337");
	command_examples(name, "Export a certificate to mycert.pem", "efs.certificate disk=1 volume=2 inode=0x1337 output=mycert");
}

void print_help_extract(const char* name)
{
	command_header("extract");
	command_description(name, "extract [disk id] [volume id] [from] [output]", "Extract a file specified by a path in from to output");
	command_examples(name, "Extract a file", "extract disk=0 volume=1 from=\"c:\\windows\\notepad.exe\" output=\"d:\\notepad.exe\"");
	command_examples(name, "Extract SAM hive", "extract disk=0 volume=1 --sam output=\"d:\\sam\"");
	command_examples(name, "Extract SYSTEM file", "extract disk=0 volume=1 --system output=\"d:\\system\"");
}

void print_help_streams(const char* name)
{
	command_header("streams");
	command_description(name, "streams [disk id] [volume id] [from/inode]", "List alternate data streams of a file from its path or inode");
	command_examples(name, "Display the list ADS for c:\\random_file", "streams disk=0 volume=1 from=\"c:\\random_file\"");
}

void print_help_undelete(const char* name)
{
	command_header("undelete");
	command_description(name, "undelete [disk id] [volume id] ([inode] [output])", "List deleted files for selected disk and volume");
	command_examples(name, "Display the list deleted file for disk 0, volume 1", "undelete disk=0 volume=1");
	command_examples(name, "Extract deleted file with inode 41 for disk 2, volume 3 to restored.dat", "undelete disk=2 volume=3 inode=41 output=restored.dat");
}

void print_help_shell(const char* name)
{
	command_header("shell");
	command_description(name, "shell [disk id] [volume id]", "Start a mini-shell for selected disk and volume");
	command_examples(name, "Start a shell for disk 1, volume 1", "shell disk=1 volume=1");
}

void print_help_shadow(const char* name)
{
	command_header("shadow");
	command_description(name, "shadow [disk id] [volume id]", "List volume shadow copies from selected disk and volume");
	command_examples(name, "Display volume shadow copies for disk 1, volume 2", "shadow disk=1 volume=2");
}

void print_help_reparse(const char* name)
{
	command_header("reparse");
	command_description(name, "reparse [disk id] [volume id]", "Parse reparse points from \\$Extend\\$Reparse for selected disk and volume");
	command_examples(name, "Display reparse points for disk 1, volume 1", "reparse disk=1 volume=1");
}

void print_help_image(const char* name)
{
	command_header("image");
	command_description(name, "image [disk id] [volume id] [output]", "Create an image file of a disk or volume");
	command_examples(name, "Create an image of physical drive 2 to z:\\backup.img", "image disk=2 output=z:\\backup.img");
}

void print_help_smart(const char* name)
{
	command_header("smart");
	command_description(name, "smart [disk id]", "Retrieve SMART data for the specified disk");
	command_examples(name, "Display SMART data from physical drive 2", "smart disk=2");
}

namespace commands
{
	namespace help
	{
		void dispatch(std::shared_ptr<Options> opts)
		{
			char name_buf[MAX_PATH] = { 0 };
			GetModuleFileNameA(nullptr, name_buf, MAX_PATH);
			std::string name = utils::files::basename(name_buf);

			if (opts->subcommand == "")
			{
				usage(name.c_str());
			}
			else
			{
				if (opts->subcommand == "help") { print_help_help(name.c_str()); return; }
				if (opts->subcommand == "info") { print_help_info(name.c_str()); return; }
				if (opts->subcommand == "mbr") { print_help_mbr(name.c_str()); return; }
				if (opts->subcommand == "gpt") { print_help_gpt(name.c_str()); return; }
				if (opts->subcommand == "vbr") { print_help_vbr(name.c_str()); return; }
				if (opts->subcommand == "mft") { print_help_mft_record(name.c_str()); return; }
				if (opts->subcommand == "btree") { print_help_mft_btree(name.c_str()); return; }
				if (opts->subcommand == "extract") { print_help_extract(name.c_str()); return; }
				if (opts->subcommand == "bitlocker") { print_help_bitlocker(name.c_str()); return; }
				if (opts->subcommand == "bitdecrypt") { print_help_bitdecrypt(name.c_str()); return; }
				if (opts->subcommand == "fve") { print_help_fve(name.c_str()); return; }
				if (opts->subcommand == "image") { print_help_image(name.c_str()); return; }
				if (opts->subcommand == "shadow") { print_help_shadow(name.c_str()); return; }
				if (opts->subcommand == "logfile") { print_help_logfile(name.c_str()); return; }
				if (opts->subcommand == "reparse") { print_help_reparse(name.c_str()); return; }
				if (opts->subcommand == "usn") { print_help_usn(name.c_str()); return; }
				if (opts->subcommand == "efs.backup") { print_help_efs_backup(name.c_str()); return; }
				if (opts->subcommand == "efs.certificate") { print_help_efs_certificate(name.c_str()); return; }
				if (opts->subcommand == "efs.decrypt") { print_help_efs_decrypt(name.c_str()); return; }
				if (opts->subcommand == "efs.key") { print_help_efs_key(name.c_str()); return; }
				if (opts->subcommand == "efs.masterkey") { print_help_efs_masterkey(name.c_str()); return; }
				if (opts->subcommand == "undelete") { print_help_undelete(name.c_str()); return; }
				if (opts->subcommand == "shell") { print_help_shell(name.c_str()); return; }
				if (opts->subcommand == "smart") { print_help_smart(name.c_str()); return; }
				if (opts->subcommand == "streams") { print_help_streams(name.c_str()); return; }

				usage(name.c_str());
			}
		}
	}
}
```

`Sources/Commands/command_image.cpp`:

```cpp
#include "Drive/disk.h"
#include "Utils/utils.h"
#include "options.h"
#include "Commands/commands.h"
#include "NTFS/ntfs.h"
#include "NTFS/ntfs_explorer.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"

#include <cstdint>
#include <string>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>
#include <iterator>
#include <Utils\progress_bar.h>
#include <future>

#define IMAGE_BLOCK_SIZE (4096)

int create_image(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, const std::string& format, std::string output)
{
	std::shared_ptr<Buffer<PBYTE>> buffer = std::make_shared<Buffer<PBYTE>>(IMAGE_BLOCK_SIZE);

	HANDLE input = INVALID_HANDLE_VALUE;
	DWORD64 size = 0;

	if (vol == nullptr)
	{
		utils::ui::title("Image from " + disk->name());
		std::cout << "[+] Opening " << disk->name() << std::endl;
		input = disk->open();
		size = disk->size();
	}
	else
	{
		utils::ui::title("Image from " + disk->name() + " > Volume:" + std::to_string(vol->index()));
		std::cout << "[+] Opening " << vol->name() << std::endl;
		input = disk->open();
		size = vol->size();

		LARGE_INTEGER result;
		LARGE_INTEGER pos;
		pos.QuadPart = vol->offset();

		SetFilePointerEx(input, pos, &result, SEEK_SET);
	}

	if (input != INVALID_HANDLE_VALUE)
	{
		std::cout << "[-] Size     : " << size << " (" << utils::format::size(size) << ")" << std::endl;
		std::cout << "[-] BlockSize: " << IMAGE_BLOCK_SIZE << std::endl;

		HANDLE houtput = CreateFileA(output.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		if (houtput != INVALID_HANDLE_VALUE)
		{
			auto progress_bar = std::make_shared<ProgressBar>(100, 32, L"[+] Copying  : ");
			progress_bar->set_display_time(true);

			DWORD64 read;

			std::future<void> consumer = std::async(std::launch::async,
				[input, houtput, buffer, size, &read, &progress_bar]() {
					DWORD readBlock = 0;
					DWORD writeBlock = 0;

					for (DWORD64 pos = 0; pos < size; pos += IMAGE_BLOCK_SIZE)
					{
						progress_bar->set_progress(static_cast<int>(100 * pos / size));

						if (!ReadFile(input, buffer->data(), IMAGE_BLOCK_SIZE, &readBlock, NULL))
						{
							std::cerr << "[!] ReadFile failed" << std::endl;
							break;
						}
						else
						{
							if (!WriteFile(houtput, buffer->data(), readBlock, &writeBlock, NULL))
							{
								std::cerr << "[!] WriteFile failed" << std::endl;
								break;
							}
							else
							{
								read += readBlock;
							}
						}
					}
				});

			auto timeout = std::chrono::seconds(1);

			progress_bar->display(std::wcout);
			while (consumer.valid())
			{
				if (consumer.wait_for(timeout) == std::future_status::ready)
				{
					progress_bar->done(std::wcout);
					break;
				}
				progress_bar->display(std::wcout);
			}

			CloseHandle(houtput);
		}
		else
		{
			std::cerr << "[!] Creating output file failed" << std::endl;
			return 1;
		}

		std::cout << "[+] Done" << std::endl;
		CloseHandle(input);
	}
	else
	{
		std::cerr << "[!] Opening source failed" << std::endl;
		return 1;
	}
	return 0;
}

namespace commands
{
	namespace image
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
				if (opts->output != "")
				{
					create_image(disk, volume, opts->format, opts->output);
				}
				else
				{
					invalid_option(opts, "output", opts->output);
				}
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_info.cpp`:

```cpp
#include "Drive/disk.h"
#include "Utils/utils.h"
#include "Utils/table.h"
#include "options.h"
#include "Utils/constant_names.h"
#include "openssl/sha.h"

#include <cstdint>
#include <string>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <memory>

void print_disks_short(std::vector<std::shared_ptr<Disk>> disks) {
	std::shared_ptr<utils::ui::Table> disktable = std::make_shared<utils::ui::Table>();
	disktable->set_margin_left(4);

	disktable->add_header_line("Id");
	disktable->add_header_line("Model");
	disktable->add_header_line("Type");
	disktable->add_header_line("Partition");
	disktable->add_header_line("Size");

	for (std::shared_ptr<Disk> disk : disks) {
		disktable->add_item_line(std::to_string(disk->index()));
		disktable->add_item_line(disk->product_id());

		std::string media_type = constants::disk::media_type(disk->geometry()->Geometry.MediaType);
		if (media_type == "Virtual")
		{
			disktable->add_item_line(media_type);
		}
		else
		{
			disktable->add_item_line(media_type + (disk->is_ssd() ? " SSD" : " HDD"));
		}
		disktable->add_item_line(constants::disk::partition_type(disk->partition_type()));
		disktable->add_item_line(std::to_string(disk->size()) + " (" + utils::format::size(disk->size()) + ")");
		disktable->new_line();
	}

	if (disks.size() > 0)
	{
		utils::ui::title("Disks:");
		disktable->render(std::cout);
	}
	else
	{
		std::cout << "No disk found" << std::endl;
	}
}

void print_hardware_disk(std::shared_ptr<Disk> disk) {
	utils::ui::title("Info for disk: " + disk->name());

	std::cout << "    Model       : " << disk->product_id() << std::endl;
	std::cout << "    Version     : " << disk->product_version() << std::endl;
	std::cout << "    Serial      : " << disk->serial_number() << std::endl;
	std::cout << "    Media Type  : " << constants::disk::media_type(disk->geometry()->Geometry.MediaType) << (disk->is_ssd() ? " SSD" : " HDD") << std::endl;
	std::cout << "    Size        : " << disk->size() << " (" << utils::format::size(disk->size()) << ")" << std::endl;
	std::cout << "    Geometry    : " << std::to_string(disk->geometry()->Geometry.BytesPerSector) << " bytes * " << std::to_string(disk->geometry()->Geometry.SectorsPerTrack) << " sectors * " << std::to_string(disk->geometry()->Geometry.TracksPerCylinder) << " tracks * " << std::to_string(disk->geometry()->Geometry.Cylinders.QuadPart) << " cylinders" << std::endl;
	std::cout << "    Partition   : " << constants::disk::partition_type(disk->partition_type()) << std::endl;
	std::cout << std::endl;

	std::shared_ptr<utils::ui::Table> partitions = std::make_shared<utils::ui::Table>();
	partitions->set_margin_left(4);
	partitions->add_header_line("Id");
	switch (disk->partition_type()) {
	case PARTITION_STYLE_MBR:
	{
		partitions->add_header_line("Boot");
		break;
	}
	case PARTITION_STYLE_GPT:
	{
		partitions->add_header_line("Type");
		break;
	}
	default:
		break;
	}
	partitions->add_header_line("Label");
	partitions->add_header_line("Mounted");
	partitions->add_header_line("Filesystem");
	partitions->add_header_line("Offset");
	partitions->add_header_line("Size");

	for (std::shared_ptr<Volume> volume : disk->volumes()) {
		partitions->add_item_line(std::to_string(volume->index()));

		switch (disk->partition_type()) {
		case PARTITION_STYLE_MBR:
		{
			if (volume->bootable()) partitions->add_item_line("Yes");
			else partitions->add_item_line("No");
			break;
		}
		case PARTITION_STYLE_GPT:
		{
			partitions->add_item_line(volume->guid_type());
			break;
		}
		default:
			break;
		}

		partitions->add_item_line(volume->label());
		partitions->add_item_line(utils::strings::join(volume->mountpoints(), ", "));
		partitions->add_item_line(volume->filesystem());
		partitions->add_item_line(utils::format::hex(volume->offset()));
		partitions->add_item_line(utils::format::hex(volume->size()) + " (" + utils::format::size(volume->size()) + ")");

		partitions->new_line();
	}

	partitions->render(std::cout);
	std::cout << std::endl;
}

void hash_file_sha256(std::string filename, PBYTE output)
{
	Buffer<PCHAR> buffer(4096 * 16);
	SHA256_CTX ctx;
	SHA256_Init(&ctx);

	std::ifstream is(filename.c_str(), std::ifstream::binary);
	if (is.is_open() && buffer.is_valid())
	{
		while (!is.eof())
		{
			is.read(buffer.data(), buffer.size());
			SHA256_Update(&ctx, buffer.data(), static_cast<size_t>(is.gcount()));
		}
		SHA256_Final(output, &ctx);
		is.close();
	}
}

void print_image_disk(std::shared_ptr<Disk> disk) {
	utils::ui::title("Info for image: " + disk->name());

	HANDLE hDisk = CreateFileA(disk->name().c_str(), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if (hDisk != INVALID_HANDLE_VALUE)
	{
		FILETIME creation, write, access;
		SYSTEMTIME creation_s, write_s, access_s;
		if (GetFileTime(hDisk, &creation, &access, &write))
		{
			utils::times::filetime_to_local_systemtime(creation, &creation_s);
			std::cout << "    Creation    : " << utils::times::display_systemtime(creation_s) << std::endl;
			utils::times::filetime_to_local_systemtime(write, &write_s);
			std::cout << "    Modification: " << utils::times::display_systemtime(write_s) << std::endl;
			utils::times::filetime_to_local_systemtime(access, &access_s);
			std::cout << "    Access      : " << utils::times::display_systemtime(access_s) << std::endl;
			std::cout << std::endl;
			if (utils::ui::ask_question("    Hash SHA256"))
			{
				BYTE hashbuf[256 / 8 + 1] = { 0 };
				std::cout << std::endl;
				std::cout << "    Hash SHA256 : Calculating ...";
				hash_file_sha256(disk->name(), hashbuf);
				std::cout << "\r" << "    Hash SHA256 : " << utils::format::hex(hashbuf, 32) << std::endl;
				std::cout << std::endl;
			}
			else
			{
				std::cout << std::endl;
			}
		}
		CloseHandle(hDisk);
	}

	std::cout << "    Size        : " << disk->size() << " (" << utils::format::size(disk->size()) << ")" << std::endl;
	std::cout << "    Volume      : " << constants::disk::partition_type(disk->partition_type()) << std::endl;
	std::cout << std::endl;

	std::shared_ptr<utils::ui::Table> partitions = std::make_shared<utils::ui::Table>();
	partitions->set_margin_left(4);
	partitions->add_header_line("Id");
	switch (disk->partition_type()) {
	case PARTITION_STYLE_MBR:
	{
		partitions->add_header_line("Boot");
		break;
	}
	case PARTITION_STYLE_GPT:
	{
		partitions->add_header_line("Type");
		break;
	}
	default:
		break;
	}
	partitions->add_header_line("Filesystem");
	partitions->add_header_line("Offset");
	partitions->add_header_line("Size");

	for (std::shared_ptr<Volume> volume : disk->volumes()) {
		partitions->add_item_line(std::to_string(volume->index()));

		switch (disk->partition_type()) {
		case PARTITION_STYLE_MBR:
		{
			if (volume->bootable()) partitions->add_item_line("Yes");
			else partitions->add_item_line("No");
			break;
		}
		case PARTITION_STYLE_GPT:
		{
			partitions->add_item_line(volume->guid_type());
			break;
		}
		default:
			break;
		}

		partitions->add_item_line(volume->filesystem());
		partitions->add_item_line(utils::format::hex(volume->offset()));
		partitions->add_item_line(utils::format::hex(volume->size()) + " (" + utils::format::size(volume->size()) + ")");

		partitions->new_line();
	}

	partitions->render(std::cout);
	std::cout << std::endl;
}

void print_hardware_volume(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol) {
	utils::ui::title("Info for PhysicalDrive:" + std::to_string(disk->index()) + " > Volume:" + std::to_string(vol->index()));

	if (vol->serial_number())
	{
		std::cout << "    Serial Number  : ";
		std::cout << utils::format::hex(vol->serial_number() >> 16) << "-" << utils::format::hex(vol->serial_number() & 0xffff) << std::endl;
	}
	if (vol->filesystem().length() > 0)
	{
		std::cout << "    Filesystem     : " << vol->filesystem() << std::endl;
	}
	if (vol->partition_type() == PARTITION_STYLE_MBR)
	{
		std::cout << "    Bootable       : " << (vol->bootable() ? "True" : "False") << std::endl;
	}
	if (vol->partition_type() == PARTITION_STYLE_GPT)
	{
		std::cout << "    GUID           : " << vol->guid_type() << std::endl;
	}
	std::cout << "    Type           : " << constants::disk::drive_type(vol->type()) << std::endl;
	if (vol->label().length() > 0)
	{
		std::cout << "    Label          : " << vol->label() << std::endl;
	}
	std::cout << "    Offset         : " << vol->offset() << " (" << utils::format::size(vol->offset()) << ")" << std::endl;
	std::cout << "    Size           : " << vol->size() << " (" << utils::format::size(vol->size()) << ")" << std::endl;
	std::cout << "    Free           : " << vol->free() << " (" << utils::format::size(vol->free()) << ")" << std::endl;

	std::cout << "    Mounted        : " << (vol->is_mounted() ? "True" : "False");
	if (vol->is_mounted())
	{
		std::cout << " (" << utils::strings::join(vol->mountpoints(), ", ") << ")";
	}
	std::cout << std::endl;
	std::cout << "    Bitlocker      : " << (vol->bitlocker().bitlocked ? "True" : "False");
	if (vol->bitlocker().bitlocked)
	{
		std::cout << " (" << (vol->filesystem().length() == 0 ? "Locked" : "Unlocked") << ")";
	}
	std::cout << std::endl;
}

void print_image_volume(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol) {
	utils::ui::title("Info for image: " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	if (vol->filesystem().length() > 0)
	{
		std::cout << "    Filesystem     : " << vol->filesystem() << std::endl;
	}
	if (vol->partition_type() == PARTITION_STYLE_MBR)
	{
		std::cout << "    Bootable       : " << (vol->bootable() ? "True" : "False") << std::endl;
	}
	if (vol->partition_type() == PARTITION_STYLE_GPT)
	{
		std::cout << "    GUID           : " << vol->guid_type() << std::endl;
	}

	std::cout << "    Offset         : " << vol->offset() << " (" << utils::format::size(vol->offset()) << ")" << std::endl;
	std::cout << "    Size           : " << vol->size() << " (" << utils::format::size(vol->size()) << ")" << std::endl;
	std::cout << "    Bitlocker      : " << (vol->bitlocker().bitlocked ? "True" : "False");
	if (vol->bitlocker().bitlocked)
	{
		std::cout << " (" << (vol->filesystem().length() == 0 ? "Locked" : "Unlocked") << ")";
	}
	std::cout << std::endl;
}

int print_disks(std::shared_ptr<Options> opts)
{
	if ((opts->image == "") && (opts->disk == -1))
	{
		print_disks_short(core::win::disks::list());
		return 0;
	}

	std::shared_ptr<Disk> disk = get_disk(opts);
	if (disk != nullptr)
	{
		if (opts->image != "") print_image_disk(disk);
		else print_hardware_disk(disk);
	}
	else
	{
		invalid_option(opts, "disk", opts->disk);
	}

	return 0;
}

int print_partitions(std::shared_ptr<Options> opts)
{
	std::ios_base::fmtflags flag_backup(std::cout.flags());

	std::shared_ptr<Disk> disk = get_disk(opts);
	if (disk != nullptr)
	{
		std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
		if (volume != nullptr)
		{
			if (opts->image != "")
			{
				print_image_volume(disk, volume);
			}
			else
			{
				print_hardware_volume(disk, volume);
			}
		}
		else
		{
			invalid_option(opts, "volume", opts->volume);
		}
	}
	else
	{
		invalid_option(opts, "disk", opts->disk);
	}

	std::cout.flags(flag_backup);
	return 0;
}

namespace commands
{
	namespace info
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			if ((opts->disk != -1 || opts->image != "") && opts->volume != -1)
			{
				print_partitions(opts);
			}
			else
			{
				print_disks(opts);
			}
			return 0;
		}
	}
}
```

`Sources/Commands/command_logfile.cpp`:

```cpp
#include "Drive/disk.h"
#include "Utils/utils.h"
#include "options.h"
#include "Commands/commands.h"
#include "NTFS/ntfs.h"
#include "NTFS/ntfs_explorer.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"

#include <nlohmann/json.hpp>

#include <cstdint>
#include <string>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>
#include <iterator>

void fixup_sequence(PRECORD_PAGE_HEADER prh)
{
	if (prh->update_sequence_array_count > 1)
	{
		PWORD pfixup = POINTER_ADD(PWORD, prh, prh->update_sequence_array_offset);
		DWORD offset = 0x200 - sizeof(WORD);
		for (int i = 1; i < prh->update_sequence_array_count; i++)
		{
			if (*POINTER_ADD(PWORD, prh, offset) == pfixup[0])
			{
				*POINTER_ADD(PWORD, prh, offset) = pfixup[i];
			}
			offset += 0x200;
			if (offset > 0x1000 - sizeof(WORD))
			{
				break;
			}
		}
	}
}

PRESTART_PAGE_HEADER find_newest_restart_page(PBYTE logfile)
{
	PRESTART_PAGE_HEADER newestRestartPageHeader = nullptr;

	PRESTART_PAGE_HEADER prstpage0 = POINTER_ADD(PRESTART_PAGE_HEADER, logfile, 0);
	PRESTART_PAGE_HEADER prstpage1 = POINTER_ADD(PRESTART_PAGE_HEADER, logfile, 4096);
	PRESTART_AREA prstarea0 = POINTER_ADD(PRESTART_AREA, prstpage0, prstpage0->restart_area_offset);
	PRESTART_AREA prstarea1 = POINTER_ADD(PRESTART_AREA, prstpage1, prstpage1->restart_area_offset);
	if (prstarea0->current_lsn > prstarea1->current_lsn)
	{
		newestRestartPageHeader = prstpage0;
	}
	else
	{
		newestRestartPageHeader = prstpage1;
	}

	return newestRestartPageHeader;
}

std::vector<std::string> get_log_clients(PRESTART_AREA ra)
{
	std::vector<std::string> ret;
	WORD log_clients_count = ra->log_clients;
	if (log_clients_count != MFT_LOGFILE_NO_CLIENT)
	{
		PLOG_CLIENT_RECORD plcr = POINTER_ADD(PLOG_CLIENT_RECORD, ra, ra->client_array_offset);
		for (int i = 0; i < log_clients_count; i++)
		{
			std::wstring client_name = std::wstring(plcr->client_name);
			client_name.resize(plcr->client_name_length);
			ret.push_back(utils::strings::to_utf8(client_name));
			plcr = POINTER_ADD(PLOG_CLIENT_RECORD, plcr, plcr->next_client);
		}
	}
	return ret;
}

void print_record_log(HANDLE outputfile, PRECORD_LOG rl, const std::string& format)
{
	std::string to_write;
	if (format == "csv")
	{
		std::ostringstream entry;
		entry << rl->lsn << ",";
		entry << rl->client_previous_lsn << ",";
		entry << rl->client_undo_next_lsn << ",";
		entry << rl->client_id.client_index << ",";
		entry << rl->record_type << ",";
		entry << rl->transaction_id << ",";
		entry << constants::disk::logfile::operation(rl->redo_operation) << ",";
		entry << constants::disk::logfile::operation(rl->undo_operation) << ",";
		entry << rl->mft_cluster_index << ",";
		entry << rl->target_vcn << ",";
		entry << rl->target_lcn;
		entry << std::endl;
		to_write = entry.str();
	}
	if (format == "json")
	{
		nlohmann::json j;
		j["lsn"] = rl->lsn;
		j["previous_lsn"] = rl->client_previous_lsn;
		j["undonext_lsn"] = rl->client_undo_next_lsn;
		j["client_id"] = rl->client_id.client_index;
		j["record_type"] = rl->record_type;
		j["transaction_id"] = rl->transaction_id;
		j["redo_op"] = constants::disk::logfile::operation(rl->redo_operation);
		j["undo_op"] = constants::disk::logfile::operation(rl->undo_operation);
		j["mft_index"] = rl->mft_cluster_index;
		j["target_vcn"] = rl->target_vcn;
		j["target_lcn"] = rl->target_lcn;
		to_write = j.dump() + ",\n";
	}

	DWORD written = 0;
	DWORD write_size = 0;
	if (!FAILED(SizeTToDWord(to_write.size(), &write_size)))  WriteFile(outputfile, to_write.c_str(), write_size, &written, NULL);
}

int print_logfile_records(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, const std::string& format, std::string output)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	utils::ui::title("LogFile from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << vol->name() << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);

	std::cout << "[+] Reading $LogFile record" << std::endl;
	std::shared_ptr<MFTRecord> record = explorer->mft()->record_from_number(LOG_FILE_NUMBER);

	ULONG64 total_size = record->datasize();
	std::cout << "[+] $LogFile size : " << utils::format::size(total_size) << std::endl;

	HANDLE houtput = CreateFileA(output.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (houtput == INVALID_HANDLE_VALUE)
	{
		std::cout << "[!] Failed to create output file" << std::endl;
		return 1;
	}

	if (format == "raw")
	{
		ULONG64 processed_count = 0;
		for (auto& block : record->process_data())
		{
			DWORD written = 0;
			WriteFile(houtput, block.first, block.second, &written, NULL);
			std::cout << "\r[+] Processed data size : " << std::to_string(processed_count) << " (" << std::to_string(100 * processed_count / total_size) << "%)";
			processed_count += block.second;
		}
	}
	else if (format == "csv" || format == "json")
	{
		if (format == "csv")
		{
			std::string header = "LSN,ClientPreviousLSN,UndoNextLSN,ClientID,RecordType,TransactionID,RedoOperation,UndoOperation,MFTClusterIndex,TargetVCN,TargetLCN\n";
			DWORD written = 0;
			WriteFile(houtput, header.c_str(), static_cast<DWORD>(header.size()), &written, NULL);
		}
		if (format == "json")
		{
			DWORD written = 0;
			WriteFile(houtput, "[\n", 2, &written, NULL);
		}

		std::shared_ptr<Buffer<PBYTE>> logfile = record->data();

		std::cout << "[+] Parsing $LogFile Restart Pages" << std::endl;

		PRESTART_PAGE_HEADER newest_restart_header = find_newest_restart_page(logfile->data());
		PRESTART_AREA newest_restart_area = POINTER_ADD(PRESTART_AREA, newest_restart_header, newest_restart_header->restart_area_offset);

		std::cout << "[+] Newest Restart Page LSN : " << std::to_string(newest_restart_area->current_lsn) << std::endl;

		if (newest_restart_area->flags & MFT_LOGFILE_RESTART_AREA_FLAG_VOLUME_CLEANLY_UNMOUNTED)
		{
			std::cout << "[!] Volume marked as not cleanly unmounted" << std::endl;
		}
		else
		{
			std::cout << "[+] Volume marked as cleanly unmounted" << std::endl;
		}

		//////////

		DWORD client_i = 1;
		for (auto& client : get_log_clients(newest_restart_area))
		{
			std::cout << "[+] Client found : [" << std::to_string(client_i++) << "] " << client << std::endl;
		}

		//////////

		std::cout << "[+] Parsing $LogFile Record Pages" << std::endl;

		std::vector<PRECORD_PAGE_HEADER> record_page_offsets;

		for (DWORD offset = 4 * newest_restart_header->log_page_size; offset < logfile->size(); offset += newest_restart_header->log_page_size)
		{
			PRECORD_PAGE_HEADER prh = POINTER_ADD(PRECORD_PAGE_HEADER, logfile->data(), offset);
			if (memcmp(prh->magic, "RCRD", 4) != 0) {
				continue;
			}
			record_page_offsets.push_back(prh);
		}

		std::cout << "[+] $LogFile Record Page Count : " << std::to_string(record_page_offsets.size()) << std::endl;

		/////////

		std::cout << "[+] Parsing $LogFile Records" << std::endl;

		Buffer<PBYTE> leftover_buffer(8 * 4096);
		DWORD leftover_size = 0;
		DWORD leftover_missing_size = 0;

		DWORD processed = 0;
		for (PRECORD_PAGE_HEADER prh : record_page_offsets)
		{
			fixup_sequence(prh);

			DWORD offset = 64;
			DWORD index = 1;

			if (leftover_size > 0)
			{
				memcpy(leftover_buffer.data() + leftover_size, POINTER_ADD(PBYTE, prh, offset), min(leftover_missing_size, 4096 - offset));
				leftover_missing_size -= min(leftover_missing_size, 4096 - offset);

				if (leftover_missing_size == 0)
				{
					PRECORD_LOG prllo = POINTER_ADD(PRECORD_LOG, leftover_buffer.data(), 0);
					print_record_log(houtput, prllo, format);
					processed++;
					std::cout << "\r[+] $LogFile Record Count : " << std::to_string(processed);

					offset += leftover_missing_size;
					leftover_size = 0;
				}
				else
				{
					continue;
				}
			}

			index = 1;
			DWORD stop = min(prh->header.packed.next_record_offset + MFT_LOGFILE_LOG_RECORD_HEADER_SIZE, 4096 - MFT_LOGFILE_LOG_RECORD_HEADER_SIZE);

			int error = 0;
			while (offset < stop)
			{
				PRECORD_LOG prl = POINTER_ADD(PRECORD_LOG, prh, offset);

				if (error > 1)
				{
					break;
				}

				if (prl->lsn == 0 || prl->record_type == 0 || prl->record_type > 37)
				{
					error++;
					offset = prh->header.packed.next_record_offset;
					continue;
				}

				offset += MFT_LOGFILE_LOG_RECORD_HEADER_SIZE + prl->client_data_length;

				if (prl->flags & LOG_RECORD_MULTI_PAGE)
				{
					memcpy(leftover_buffer.data(), prl, 4096 - prh->header.packed.next_record_offset);
					leftover_size = 4096 - prh->header.packed.next_record_offset;
					leftover_missing_size = prl->client_data_length - (leftover_size - MFT_LOGFILE_LOG_RECORD_HEADER_SIZE);
				}
				else
				{
					print_record_log(houtput, prl, format);
					processed++;
					std::cout << "\r[+] $LogFile Record Count : " << std::to_string(processed);
				}
			}
		}
		if (format == "json")
		{
			DWORD written = 0;
			WriteFile(houtput, "{}]\n", 2, &written, NULL);
		}
		std::cout << std::endl;
	}
	else
	{
		std::cout << "[!] Invalid or missing format" << std::endl;
	}

	CloseHandle(houtput);
	std::cout << "[+] Closing volume" << std::endl;

	return 0;
}

namespace commands {
	namespace logfile {
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
				if (volume != nullptr)
				{
					if (opts->output != "")
					{
						if (opts->format == "") opts->format = "raw";

						print_logfile_records(disk, volume, opts->format, opts->output);
					}
					else
					{
						invalid_option(opts, "output", opts->output);
					}
				}
				else
				{
					invalid_option(opts, "volume", opts->volume);
				}
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_mbr.cpp`:

```cpp
#include "Utils/buffer.h"
#include "Drive/disk.h"
#include "Utils/table.h"
#include "Utils/utils.h"
#include "options.h"
#include "Utils/constant_names.h"

#include <intrin.h>
#include <distorm.h>

#include <algorithm>
#include <cstdint>
#include <string>
#include <iostream>
#include <iomanip>
#include <memory>
#include <stdexcept>

void print_mbr(std::shared_ptr<Disk> disk)
{
	utils::ui::title("MBR from " + disk->name());

	PMBR mbr = disk->mbr();

	std::cout << "    Disk signature  : " << utils::format::hex(_byteswap_ulong(mbr->disk_signature)) << std::endl;
	std::cout << "    Reserved bytes  : " << utils::format::hex(_byteswap_ushort(mbr->reserved)) << std::endl;

	std::shared_ptr<utils::ui::Table> partitions = std::make_shared<utils::ui::Table>();
	partitions->set_margin_left(4);

	partitions->add_header_line("Id");
	partitions->add_header_line("Boot");
	partitions->add_header_line("Flags");
	partitions->add_header_line("Filesystem");
	partitions->add_header_line("First sector");
	partitions->add_header_line("Last sector");
	partitions->add_header_line("Offset");
	partitions->add_header_line("Sectors");
	partitions->add_header_line("Size");

	unsigned int n_partitions = 0;
	for (int i = 0; i < 4; i++) {
		if (mbr->partition[i].partition_type != 0)
		{
			n_partitions++;
			partitions->add_item_line(std::to_string(n_partitions));
			partitions->add_item_line((mbr->partition[i].status == 0x80 ? "Yes" : "No"));
			partitions->add_item_line("Principal");
			partitions->add_item_line(constants::disk::mbr_type(mbr->partition[i].partition_type));
			partitions->add_item_line(std::to_string(mbr->partition[i].first_sector.cylinder) + " " + std::to_string(mbr->partition[i].first_sector.head) + " " + std::to_string(mbr->partition[i].first_sector.sector));
			partitions->add_item_line(std::to_string(mbr->partition[i].last_sector.cylinder) + " " + std::to_string(mbr->partition[i].last_sector.head) + " " + std::to_string(mbr->partition[i].last_sector.sector));
			partitions->add_item_line(std::to_string(mbr->partition[i].first_sector_lba));
			partitions->add_item_line(std::to_string(mbr->partition[i].sectors));
			partitions->add_item_line(utils::format::size(static_cast<DWORD64>(mbr->partition[i].sectors) * 512));
			partitions->new_line();
		}
	}
	for (EBR& ebr : disk->ebrs())
	{
		n_partitions++;
		partitions->add_item_line(std::to_string(n_partitions));
		partitions->add_item_line((ebr.partition[0].status == 0x80 ? "Yes" : "No"));
		partitions->add_item_line("Logical");
		partitions->add_item_line(constants::disk::mbr_type(ebr.partition[0].partition_type));
		partitions->add_item_line(std::to_string(ebr.partition[0].first_sector.cylinder) + " " + std::to_string(ebr.partition[0].first_sector.head) + " " + std::to_string(ebr.partition[0].first_sector.sector));
		partitions->add_item_line(std::to_string(ebr.partition[0].last_sector.cylinder) + " " + std::to_string(ebr.partition[0].last_sector.head) + " " + std::to_string(ebr.partition[0].last_sector.sector));
		partitions->add_item_line(std::to_string(ebr.partition[0].first_sector_lba));
		partitions->add_item_line(std::to_string(ebr.partition[0].sectors));
		partitions->add_item_line(utils::format::size(static_cast<DWORD64>(ebr.partition[0].sectors) * LOGICAL_SECTOR_SIZE));
		partitions->new_line();
	}

	std::cout << std::endl << "    Partition table";
	if (disk->has_protective_mbr())
	{
		std::cout << " (Protective MBR)";
	}
	std::cout << " : " << std::endl;
	partitions->render(std::cout);
	std::cout << std::endl;

	std::cout << "    MBR signature  : " << std::setw(4) << std::hex << _byteswap_ushort(mbr->mbr_signature) << std::endl;

	std::cout << std::endl << "    Strings:" << std::endl;
	std::vector<unsigned long> string_offsets;
	for (int i = 0; i < 3; i++) string_offsets.push_back((mbr->code[0x1b5 + i] & 0xff) + 0x100);

	if (std::all_of(string_offsets.begin(), string_offsets.end(), [string_offsets](int x) { return (x & 0xff) == 0; }))
	{
		std::cout << "        No strings found" << std::endl;
	}
	else
	{
		for (auto& offset : string_offsets)
		{
			if ((offset < 0x1b5) && offset > 0)
			{
				std::cout << "        [" << utils::format::hex((BYTE)(offset & 0xff)) << "] : " << std::string((PCHAR)mbr->code + offset) << std::endl;
			}
		}
	}

	unsigned int size_to_disass = min(*std::min_element(string_offsets.begin(), string_offsets.end()), 0x1b4);
	while (mbr->code[size_to_disass] == 0 && size_to_disass > 0) size_to_disass--;

	std::cout << std::endl;

	if (utils::ui::ask_question("    Disassemble Bootstrap Code"))
	{
		if (size_to_disass)
		{
			std::cout << std::endl;
			for (std::string& line : utils::disass::buffer(mbr->code, size_to_disass, Decode16Bits, 0))
			{
				std::cout << "        " << line << std::endl;
			}
		}
		else {
			std::cout << "        Empty code" << std::endl;
		}
	}
}

namespace commands
{
	namespace mbr
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);

			if (disk != nullptr)
			{
				print_mbr(disk);
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_mft.cpp`:

```cpp
#include <iostream>
#include <iomanip>
#include <memory>

#include "Commands/commands.h"
#include "NTFS/ntfs.h"
#include "NTFS/ntfs_explorer.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"
#include "Utils/utils.h"

#include "options.h"
#include "Drive/disk.h"
#include "Drive/volume.h"
#include <Utils/index_details.h>

std::vector<std::string> print_attribute_standard(PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION pAttribute)
{
	std::vector<std::string> ret;
	if (pAttribute != nullptr)
	{
		SYSTEMTIME st = { 0 };
		utils::times::ull_to_local_systemtime(pAttribute->CreateTime, &st);
		ret.push_back("File Created Time       : " + utils::times::display_systemtime(st));
		utils::times::ull_to_local_systemtime(pAttribute->AlterTime, &st);
		ret.push_back("Last File Write Time    : " + utils::times::display_systemtime(st));
		utils::times::ull_to_local_systemtime(pAttribute->MFTTime, &st);
		ret.push_back("FileRecord Changed Time : " + utils::times::display_systemtime(st));
		utils::times::ull_to_local_systemtime(pAttribute->ReadTime, &st);
		ret.push_back("Last Access Time        : " + utils::times::display_systemtime(st));
		ret.push_back("Permissions             :");
		ret.push_back("  read_only     : " + std::to_string(pAttribute->u.Permission.readonly));
		ret.push_back("  hidden        : " + std::to_string(pAttribute->u.Permission.hidden));
		ret.push_back("  system        : " + std::to_string(pAttribute->u.Permission.system));
		ret.push_back("  device        : " + std::to_string(pAttribute->u.Permission.device));
		ret.push_back("  normal        : " + std::to_string(pAttribute->u.Permission.normal));
		ret.push_back("  temporary     : " + std::to_string(pAttribute->u.Permission.temp));
		ret.push_back("  sparse        : " + std::to_string(pAttribute->u.Permission.sparse));
		ret.push_back("  reparse_point : " + std::to_string(pAttribute->u.Permission.reparse));
		ret.push_back("  compressed    : " + std::to_string(pAttribute->u.Permission.compressed));
		ret.push_back("  offline       : " + std::to_string(pAttribute->u.Permission.offline));
		ret.push_back("  not_indexed   : " + std::to_string(pAttribute->u.Permission.not_indexed));
		ret.push_back("  encrypted     : " + std::to_string(pAttribute->u.Permission.encrypted));
		ret.push_back("Max Number of Versions  : " + std::to_string(pAttribute->MaxVersionNo));
		ret.push_back("Version Number          : " + std::to_string(pAttribute->VersionNo));
	}
	return ret;
}

std::vector<std::string> commands::mft::print_attribute_index_root(PMFT_RECORD_ATTRIBUTE_INDEX_ROOT pAttribute, std::vector<std::shared_ptr<IndexEntry>> entries)
{
	std::vector<std::string> ret;
	if (pAttribute != nullptr)
	{
		ret.push_back("Attribute Type          : " + constants::disk::mft::file_record_index_root_attribute_type(pAttribute->AttrType));
		ret.push_back("Collation Rule          : " + std::to_string(pAttribute->CollRule));
		ret.push_back("Index Alloc Entry Size  : " + std::to_string(pAttribute->IBSize));
		ret.push_back("Cluster/Index Record    : " + std::to_string(pAttribute->ClustersPerIB));
		ret.push_back("-----");
		ret.push_back("First Entry Offset      : " + std::to_string(pAttribute->EntryOffset));
		ret.push_back("Index Entries Size      : " + std::to_string(pAttribute->TotalEntrySize));
		ret.push_back("Index Entries Allocated : " + std::to_string(pAttribute->AllocEntrySize));
		ret.push_back("Flags                   : " + constants::disk::mft::file_record_index_root_attribute_flag(pAttribute->Flags));

		if (pAttribute->Flags == MFT_ATTRIBUTE_INDEX_ROOT_FLAG_SMALL)
		{
			ret.push_back(" ");
			ret.push_back("Index");
			for (auto& entry : entries)
			{
				if (entry->type() == MFT_ATTRIBUTE_INDEX_FILENAME)
				{
					ret.push_back("       " + utils::format::hex(entry->record_number()) + " : " + utils::strings::to_utf8(entry->name()));
				}
				if (entry->type() == MFT_ATTRIBUTE_INDEX_REPARSE)
				{
					ret.push_back("       " + utils::format::hex(entry->record_number()) + " : " + constants::disk::mft::file_record_reparse_point_type(entry->tag()));
				}
			}
		}
	}
	return ret;
}

std::vector<std::string> print_attribute_reparse_point(PMFT_RECORD_ATTRIBUTE_REPARSE_POINT pAttribute)
{
	std::vector<std::string> ret;
	if (pAttribute != nullptr)
	{
		ret.push_back("Type                    : " + constants::disk::mft::file_record_reparse_point_type(pAttribute->ReparseTag));
		ret.push_back("------");

		if (pAttribute->ReparseTag == IO_REPARSE_TAG_SYMLINK)
		{
			std::wstring subs_name = std::wstring(POINTER_ADD(PWCHAR, pAttribute->SymbolicLinkReparseBuffer.PathBuffer, pAttribute->SymbolicLinkReparseBuffer.SubstituteNameOffset));
			subs_name.resize(pAttribute->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof(WCHAR));
			ret.push_back("Substitute Name         : " + utils::strings::to_utf8(subs_name));
			std::wstring display_name = std::wstring(POINTER_ADD(PWCHAR, pAttribute->SymbolicLinkReparseBuffer.PathBuffer, pAttribute->SymbolicLinkReparseBuffer.PrintNameOffset));
			display_name.resize(pAttribute->SymbolicLinkReparseBuffer.PrintNameLength / sizeof(WCHAR));
			ret.push_back("Display Name            : " + utils::strings::to_utf8(display_name));
		}
		else if (pAttribute->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
		{
			std::wstring subs_name = std::wstring(POINTER_ADD(PWCHAR, pAttribute->MountPointReparseBuffer.PathBuffer, pAttribute->MountPointReparseBuffer.SubstituteNameOffset));
			subs_name.resize(pAttribute->MountPointReparseBuffer.SubstituteNameLength / sizeof(WCHAR));
			ret.push_back("Substitute Name         : " + utils::strings::to_utf8(subs_name));
			std::wstring display_name = std::wstring(POINTER_ADD(PWCHAR, pAttribute->MountPointReparseBuffer.PathBuffer, pAttribute->MountPointReparseBuffer.PrintNameOffset));
			display_name.resize(pAttribute->MountPointReparseBuffer.PrintNameLength / sizeof(WCHAR));
			ret.push_back("Display Name            : " + utils::strings::to_utf8(display_name));
		}
		else if (pAttribute->ReparseTag == IO_REPARSE_TAG_WOF)
		{
			ret.push_back("Version                 : " + std::to_string(pAttribute->WindowsOverlayFilterBuffer.Version));
			ret.push_back("Provider                : " + std::to_string(pAttribute->WindowsOverlayFilterBuffer.Provider));
			ret.push_back("File Version            : " + std::to_string(pAttribute->WindowsOverlayFilterBuffer.FileVersionInformation));
			ret.push_back("Compression Algorithm   : " + constants::disk::mft::wof_compression(pAttribute->WindowsOverlayFilterBuffer.CompressionAlgorithm));
		}
		else
		{
			ret.push_back("Unsupported reparse point type");
		}
	}

	return ret;
}

std::vector<std::string> print_attribute_object_id(PMFT_RECORD_ATTRIBUTE_OBJECT_ID pAttribute)
{
	std::vector<std::string> ret;
	if (pAttribute != nullptr)
	{
		ret.push_back("Object Unique ID        : " + utils::id::guid_to_string(pAttribute->object_id));
	}
	return ret;
}

std::vector<std::string> print_attribute_security_descriptor(PMFT_RECORD_ATTRIBUTE_SECURITY_DESCRIPTOR pAttribute)
{
	std::vector<std::string> ret;
	if (pAttribute != nullptr)
	{
		ret.push_back("Revision                : " + std::to_string(pAttribute->Revision));
		ret.push_back("Control Flags           ");
		ret.push_back("  owner defaulted       : " + std::to_string(pAttribute->ControlFlags.OwnerDefaulted));
		ret.push_back("  group defaulted       : " + std::to_string(pAttribute->ControlFlags.GroupDefaulted));
		ret.push_back("  DACL present          : " + std::to_string(pAttribute->ControlFlags.DACLPresent));
		ret.push_back("  DACL defaulted        : " + std::to_string(pAttribute->ControlFlags.DACLDefaulted));
		ret.push_back("  SACL present          : " + std::to_string(pAttribute->ControlFlags.SACLPresent));
		ret.push_back("  SACL defaulted        : " + std::to_string(pAttribute->ControlFlags.SACLDefaulted));
		ret.push_back("  DACL auto inherit req : " + std::to_string(pAttribute->ControlFlags.DACLAutoInheritReq));
		ret.push_back("  SACL auto inherit req : " + std::to_string(pAttribute->ControlFlags.SACLAutoInheritReq));
		ret.push_back("  DACL auto inherit     : " + std::to_string(pAttribute->ControlFlags.DACLAutoInherit));
		ret.push_back("  SACL auto inherit     : " + std::to_string(pAttribute->ControlFlags.SACLAutoInherit));
		ret.push_back("  DACL protected        : " + std::to_string(pAttribute->ControlFlags.DACLProtected));
		ret.push_back("  SACL protected        : " + std::to_string(pAttribute->ControlFlags.SACLProtected));
		ret.push_back("  RM control valid      : " + std::to_string(pAttribute->ControlFlags.RMControlValid));
		ret.push_back("  self relative         : " + std::to_string(pAttribute->ControlFlags.SelfRelative));

		if (pAttribute->UserSIDOffset != 0)
		{
			PSID user_sid = POINTER_ADD(PSID, pAttribute, pAttribute->UserSIDOffset);
			ret.push_back("User  SID               : " + utils::id::sid_to_string(user_sid));
		}
		else
		{
			ret.push_back("User  SID               : not present");
		}
		if (pAttribute->GroupSIDOffset != 0)
		{
			PSID group_sid = POINTER_ADD(PSID, pAttribute, pAttribute->GroupSIDOffset);
			ret.push_back("Group SID               : " + utils::id::sid_to_string(group_sid));
		}
		else
		{
			ret.push_back("Group SID               : not present");
		}
		if (pAttribute->ControlFlags.SACLPresent && pAttribute->SACLOffset != 0)
		{
			PSECURITY_DESCRIPTOR psecd = POINTER_ADD(PACL, pAttribute, 0);
			LPSTR stringSD = NULL;
			ConvertSecurityDescriptorToStringSecurityDescriptor(
				psecd,
				SDDL_REVISION_1,
				SACL_SECURITY_INFORMATION,
				&stringSD,
				NULL
			);
			ret.push_back("SACL                    : " + std::string(stringSD));
			LocalFree(stringSD);
		}
		else
		{
			ret.push_back("SACL                    : not present");
		}
		if (pAttribute->ControlFlags.DACLPresent && pAttribute->DACLOffset != 0)
		{
			PSECURITY_DESCRIPTOR psecd = POINTER_ADD(PACL, pAttribute, 0);
			LPSTR stringSD = NULL;
			ConvertSecurityDescriptorToStringSecurityDescriptor(
				psecd,
				SDDL_REVISION_1,
				DACL_SECURITY_INFORMATION,
				&stringSD,
				NULL
			);
			ret.push_back("DACL                    : " + std::string(stringSD));
			LocalFree(stringSD);
		}
		else
		{
			ret.push_back("DACL                    : not present");
		}
	}
	return ret;
}

std::vector<std::string> print_attribute_filename(PMFT_RECORD_ATTRIBUTE_FILENAME pAttribute)
{
	std::vector<std::string> ret;
	if (pAttribute != nullptr)
	{
		ret.push_back("Parent Dir Record Index : " + std::to_string(pAttribute->ParentDirectory.FileRecordNumber));
		ret.push_back("Parent Dir Sequence Num : " + std::to_string(pAttribute->ParentDirectory.SequenceNumber));
		SYSTEMTIME st = { 0 };
		utils::times::ull_to_local_systemtime(pAttribute->CreationTime, &st);
		ret.push_back("File Created Time       : " + utils::times::display_systemtime(st));
		utils::times::ull_to_local_systemtime(pAttribute->LastWriteTime, &st);
		ret.push_back("Last File Write Time    : " + utils::times::display_systemtime(st));
		utils::times::ull_to_local_systemtime(pAttribute->ChangeTime, &st);
		ret.push_back("FileRecord Changed Time : " + utils::times::display_systemtime(st));
		utils::times::ull_to_local_systemtime(pAttribute->LastAccessTime, &st);
		ret.push_back("Last Access Time        : " + utils::times::display_systemtime(st));
		ret.push_back("Allocated Size          : " + std::to_string(pAttribute->AllocatedSize));
		ret.push_back("Real Size               : " + std::to_string(pAttribute->DataSize));
		ret.push_back("------");
		std::wstring name = std::wstring(pAttribute->Name);
		name.resize(pAttribute->NameLength);
		ret.push_back("NameType                : " + constants::disk::mft::file_record_filename_name_type(pAttribute->NameType));
		ret.push_back("Name                    : " + utils::strings::to_utf8(name));
	}
	return ret;
}

void print_efs_entry(std::vector<std::string>& ret, PMFT_RECORD_ATTRIBUTE_EFS_ARRAY_HEADER efs_arr_header, bool ddf = true)
{
	uint32_t i = 0;
	PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY_HEADER entry_header = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY_HEADER, efs_arr_header, 4);
	while (i < efs_arr_header->Count)
	{
		ret.push_back("");
		PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY entry = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY, entry_header, entry_header->CredentialHeaderOffset);

		PDWORD psid = POINTER_ADD(PDWORD, entry, 12 + entry->SIDOffset);
		std::string sid = "S-1-5-21-";
		sid += std::to_string(psid[0]) + "-";
		sid += std::to_string(psid[1]) + "-";
		sid += std::to_string(psid[2]) + "-";
		sid += std::to_string(psid[3]);

		auto username = utils::id::username_from_sid(sid);

		ret.push_back("Type                    : " + constants::disk::mft::efs_type(entry->Type));
		ret.push_back("");
		if (ddf)
		{
			ret.push_back("User                    : " + username);
			ret.push_back("SID                     : " + sid);
			ret.push_back("");
		}
		ret.push_back("Encrypted FEK " + std::to_string(entry_header->FEKSize * 8) + "bits  : " + utils::convert::to_hex(POINTER_ADD(PBYTE, entry_header, entry_header->FEKOffset), entry_header->FEKSize));
		ret.push_back("");
		if (entry->Type == MFT_ATTRIBUTE_EFS_CONTAINER)
		{
			ret.push_back("EFS Container not implemented");
		}
		else if (entry->Type == MFT_ATTRIBUTE_EFS_CERTIFICATE)
		{
			PMFT_RECORD_ATTRIBUTE_EFS_DF_CERTIFICATE_THUMBPRINT_HEADER thumprint_header = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EFS_DF_CERTIFICATE_THUMBPRINT_HEADER, entry, entry->cert_thumbprint_header_offset);
			ret.push_back("Certificate Fingerprint : " + utils::convert::to_hex(POINTER_ADD(PBYTE, thumprint_header, thumprint_header->thumbprint_offset), thumprint_header->thumbprint_size));

			if (thumprint_header->container_name_offset)
			{
				ret.push_back("Container               : " + utils::strings::to_utf8(POINTER_ADD(PWCHAR, thumprint_header, thumprint_header->container_name_offset)));
			}
			if (thumprint_header->provider_name_offset)
			{
				ret.push_back("Cryptographic Provider  : " + utils::strings::to_utf8(POINTER_ADD(PWCHAR, thumprint_header, thumprint_header->provider_name_offset)));
			}
			if (thumprint_header->user_name_offset)
			{
				ret.push_back("Username                : " + utils::strings::to_utf8(POINTER_ADD(PWCHAR, thumprint_header, thumprint_header->user_name_offset)));
			}
		}
		ret.push_back("");
		ret.push_back(TABLE_SEPARATOR);

		entry_header = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY_HEADER, entry_header, entry_header->Length);
		i++;
	}
}

std::vector<std::string> print_attribute_logged_utility(std::shared_ptr<MFTRecord> record, PMFT_RECORD_ATTRIBUTE_HEADER pAttribute)
{
	char zero_buffer[16] = { 0 };
	std::vector<std::string> ret;
	if (pAttribute != nullptr)
	{
		std::wstring name = std::wstring(POINTER_ADD(PWCHAR, pAttribute, pAttribute->NameOffset));
		name.resize(pAttribute->NameLength);

		if (pAttribute->NameLength > 0)
		{
			ret.push_back("Name                    : " + utils::strings::to_utf8(name));
		}

		ret.push_back("Non Resident            : " + std::string(pAttribute->FormCode == NON_RESIDENT_FORM ? "True" : "False"));

		if (name == L"$EFS")
		{
			auto efs_buffer = record->attribute_data<PBYTE>(pAttribute);
			PMFT_RECORD_ATTRIBUTE_EFS_HEADER efs_header = reinterpret_cast<PMFT_RECORD_ATTRIBUTE_EFS_HEADER>(efs_buffer->data());

			ret.push_back("State                   : " + std::to_string(efs_header->State));
			ret.push_back("EFS Version             : " + std::to_string(efs_header->Version));
			ret.push_back("Crypto API Version      : " + std::to_string(efs_header->CryptoAPIVersion));
			ret.push_back("");
			ret.push_back("FEK MD5 hash            : " + utils::convert::to_hex(efs_header->Checksum, 16));
			if (memcmp(zero_buffer, efs_header->ChecksumDDF, 16) == 16)
			{
				ret.push_back("DDF MD5 hash            : " + utils::convert::to_hex(efs_header->ChecksumDDF, 16));
			}
			if (memcmp(zero_buffer, efs_header->ChecksumDRF, 16) == 16)
			{
				ret.push_back("DRF MD5 hash            : " + utils::convert::to_hex(efs_header->ChecksumDRF, 16));
			}
			ret.push_back("");

			PMFT_RECORD_ATTRIBUTE_EFS_ARRAY_HEADER efs_arr_header = nullptr;
			if (efs_header->OffsetToDDF != 0)
			{
				efs_arr_header = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EFS_ARRAY_HEADER, efs_header, efs_header->OffsetToDDF);
				ret.push_back("Data Decryption Fields  : " + std::to_string(efs_arr_header->Count));
				print_efs_entry(ret, efs_arr_header, true);
			}
			else
			{
				ret.push_back("Data Decryption Field   : 0");
			}
			ret.push_back("");

			if (efs_header->OffsetToDRF != 0)
			{
				efs_arr_header = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EFS_ARRAY_HEADER, efs_header, efs_header->OffsetToDRF);
				ret.push_back("Data Recovery Fields    : " + std::to_string(efs_arr_header->Count));
				print_efs_entry(ret, efs_arr_header, false);
			}
			else
			{
				ret.push_back("Data Recovery Fields    : 0");
			}
			ret.push_back("");

		}
		else if (name == L"$TXF_DATA")
		{
			auto txf_buffer = record->attribute_data<PBYTE>(pAttribute);
			PMFT_RECORD_ATTRIBUTE_TXF txf_header = reinterpret_cast<PMFT_RECORD_ATTRIBUTE_TXF>(txf_buffer->data());
			if (txf_buffer->size() == sizeof(MFT_RECORD_ATTRIBUTE_TXF))
			{
				ret.push_back("");
				ret.push_back("Root File Record Number : " + std::to_string(txf_header->RootRecordNumber.FileRecordNumber));
				ret.push_back("Root Sequence Number    : " + std::to_string(txf_header->RootRecordNumber.SequenceNumber));
				ret.push_back("Flags                   : " + utils::format::hex6(txf_header->Flags, true));
				ret.push_back("Txf File ID             : " + std::to_string(txf_header->TxfFileId));
				ret.push_back("LSN NTFS Metadata       : " + utils::format::hex6(txf_header->LsnNtfsMetadata, true));
				ret.push_back("LSN User Data           : " + utils::format::hex6(txf_header->LsnUserData, true));
				ret.push_back("LSN Directory Index     : " + utils::format::hex6(txf_header->LsnDirectoryIndex, true));
				ret.push_back("USN Index               : " + utils::format::hex6(txf_header->UsnIndex, true));
			}
			else
			{
				ret.push_back("Data                    : " + utils::convert::to_hex(txf_buffer->data(), txf_buffer->size()));
			}
		}
	}
	return ret;
}

std::vector<std::string> print_attribute_bitmap(PMFT_RECORD_ATTRIBUTE_BITMAP pAttribute, DWORD length)
{
	std::vector<std::string> ret;
	DWORD index_node_used = 0;
	for (DWORD i = 0; i < length; i++)
	{
		BYTE b = pAttribute->bitmap[i];
		for (int bit = 0; bit < 8; bit++)
		{
			index_node_used += b & 0x01;
			b >>= 1;
		}
	}
	ret.push_back("Index Node Used         : " + std::to_string(index_node_used));
	return ret;
}

std::vector<std::string> print_attribute_data(std::shared_ptr<MFTRecord> record, PMFT_RECORD_ATTRIBUTE_HEADER pAttribute, ULONG32 cluster_size)
{
	std::vector<std::string> ret;

	std::wstring name = std::wstring(POINTER_ADD(PWCHAR, pAttribute, pAttribute->NameOffset));
	name.resize(pAttribute->NameLength);

	if (pAttribute->NameLength > 0)
	{
		ret.push_back("Name: " + utils::strings::to_utf8(name));
	}

	ULONG64 datasize = record->datasize(utils::strings::to_utf8(name));
	if (record->header()->baseRecord == 0)
	{
		ret.push_back("Size: " + std::to_string(datasize) + " (" + utils::format::size(datasize) + ")");
	}

	if (pAttribute->FormCode == NON_RESIDENT_FORM)
	{
		if (pAttribute->Flags)
		{
			ret.push_back("Flags: ");

			if (pAttribute->Flags & ATTRIBUTE_FLAG_COMPRESSED)
			{
				if (pAttribute->Form.Nonresident.CompressionUnit == 0)
				{
					ret.push_back("    Compressed (Uncompressed data)");
				}
				else
				{
					ret.push_back("    Compressed (unit: " + std::to_string(1 << pAttribute->Form.Nonresident.CompressionUnit) + " clusters)");
				}
			}
			if (pAttribute->Flags & ATTRIBUTE_FLAG_ENCRYPTED) ret.push_back("    Encrypted");
			if (pAttribute->Flags & ATTRIBUTE_FLAG_SPARSE) ret.push_back("    Sparse");
		}

		auto dataruns = record->read_dataruns(pAttribute);
		if (!dataruns.empty())
		{
			ret.push_back("Dataruns: ");
			LONGLONG last = 0;
			ULONGLONG real_size = 0;
			ULONGLONG virtual_size = 0;
			std::set<LONGLONG> offsets;
			for (const auto& run : dataruns)
			{
				if (run.offset == 0)
				{
					virtual_size += (run.length * cluster_size);
				}
				else
				{
					if (offsets.find(run.offset) == offsets.end())
					{
						real_size += (run.length * cluster_size);
						offsets.insert(run.offset);
					}
				}
				ret.push_back("    Length: " + utils::format::hex(static_cast<DWORD>(run.length)) + " Offset: " + utils::format::hex(static_cast<DWORD>(run.offset)) + (last == run.offset ? " (S)" : ""));
			}
			ret.push_back("");
			ret.push_back("Virtual size: " + std::to_string(virtual_size) + " (" + utils::format::size(virtual_size) + ")");
			ret.push_back("Real size   : " + std::to_string(real_size) + " (" + utils::format::size(real_size) + ")");
		}
	}

	return ret;
}

std::vector<std::string> commands::mft::print_attribute_index_allocation(PMFT_RECORD_ATTRIBUTE_HEADER pIndexAttrHeader, std::shared_ptr<MFTRecord> record, ULONG32 cluster_size, std::vector<std::shared_ptr<IndexEntry>> entries, bool full)
{
	std::vector<std::string> ret;

	if (pIndexAttrHeader->FormCode == NON_RESIDENT_FORM)
	{
		ret.push_back("First VCN    : 0x" + utils::format::hex6(pIndexAttrHeader->Form.Nonresident.LowestVcn));
		ret.push_back("Last VCN     : 0x" + utils::format::hex6(pIndexAttrHeader->Form.Nonresident.HighestVcn));
		ret.push_back("");

		auto dataruns = record->read_dataruns(pIndexAttrHeader);
		if (!dataruns.empty())
		{
			ret.push_back("Dataruns     : ");
			LONGLONG last = 0;
			ULONGLONG size_on_disk = 0;
			for (const auto& run : dataruns)
			{
				if (last != run.offset)
				{
					size_on_disk += (run.length * cluster_size);
				}
				ret.push_back("    Length: " + utils::format::hex(static_cast<DWORD>(run.length)) + " Offset: " + utils::format::hex(static_cast<DWORD>(run.offset)) + (last == run.offset ? " (S)" : ""));
				last = run.offset;
			}
			ret.push_back("Size on disk : " + std::to_string(size_on_disk) + " (" + utils::format::size(size_on_disk) + ")");
		}
	}

	if (full)
	{
		ret.push_back(" ");
		ret.push_back("Index");
		for (auto& entry : entries)
		{
			if (entry->type() == MFT_ATTRIBUTE_INDEX_FILENAME)
			{
				ret.push_back("       " + utils::format::hex(entry->record_number()) + " : " + utils::strings::to_utf8(entry->name()));
			}
			if (entry->type() == MFT_ATTRIBUTE_INDEX_REPARSE)
			{
				ret.push_back("       " + utils::format::hex(entry->record_number()) + " : " + constants::disk::mft::file_record_reparse_point_type(entry->tag()));
			}
		}
	}
	return ret;
}

std::vector<std::string> print_attribute_list(PMFT_RECORD_ATTRIBUTE pAttribute, DWORD length)
{
	std::vector<std::string> ret;
	DWORD offset = 0;
	PMFT_RECORD_ATTRIBUTE pAttributeCurr;
	while (offset < length)
	{
		pAttributeCurr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE, pAttribute, offset);

		ret.push_back(constants::disk::mft::file_record_attribute_type(pAttributeCurr->typeID));
		if (pAttributeCurr->nameLength > 0)
		{
			std::wstring name = std::wstring(POINTER_ADD(PWCHAR, pAttributeCurr, pAttributeCurr->nameOffset), pAttributeCurr->nameLength);
			ret.push_back("Name      : " + utils::strings::to_utf8(name));
		}

		ret.push_back("Record Num: " + utils::format::hex((ULONG64)pAttributeCurr->recordNumber));

		offset += pAttributeCurr->recordLength;

		if (offset < length)
		{
			ret.push_back("------");
		}
	}

	return ret;
}

std::vector<std::string> print_attribute_ea_information(PMFT_RECORD_ATTRIBUTE_EA_INFORMATION pAttribute)
{
	std::vector<std::string> ret;

	ret.push_back("Packed size   : " + std::to_string(pAttribute->packed_length));
	ret.push_back("Need EA Count : " + std::to_string(pAttribute->need_ea_count));
	ret.push_back("Unpacked size : " + std::to_string(pAttribute->unpacked_length));

	return ret;
}

std::vector<std::string> print_attribute_ea(std::shared_ptr<Buffer<PMFT_RECORD_ATTRIBUTE_EA>> pAttribute)
{
	std::vector<std::string> ret;

	bool first = true;
	DWORD offset = 0;
	PMFT_RECORD_ATTRIBUTE_EA cur = pAttribute->data();
	while (offset < pAttribute->size())
	{
		PMFT_RECORD_ATTRIBUTE_EA cur = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EA, pAttribute->data(), offset);

		if (first)
		{
			first = false;
		}
		else
		{
			ret.push_back("");
		}

		std::string name = std::string(cur->data, cur->name_length);
		ret.push_back("Name     : " + name);
		ret.push_back("Need EA  : " + std::to_string(cur->flags & 0x80));
		ret.push_back("Value    : ");
		ret.push_back(utils::convert::to_hex(cur->data + cur->name_length + 1, cur->value_length));

		offset += cur->next_entry_offset;
	}

	return ret;
}

int commands::mft::print_mft_info_details(std::shared_ptr<MFTRecord> record, ULONG32 cluster_size)
{
	PMFT_RECORD_HEADER record_header = record->header();

	std::string signature = std::string((PCHAR)record_header->signature);
	std::cout << "Signature         : " << signature.substr(0, 4) << std::endl;
	std::cout << "Update Offset     : " << record_header->updateOffset << std::endl;
	std::cout << "Update Number     : " << record_header->updateNumber << std::endl;
	std::cout << "$LogFile LSN      : " << record_header->logFile << std::endl;
	std::cout << "Sequence Number   : " << record_header->sequenceNumber << std::endl;
	std::cout << "Hardlink Count    : " << record_header->hardLinkCount << std::endl;
	std::cout << "Attribute Offset  : " << record_header->attributeOffset << std::endl;
	std::cout << "Flags             : " << constants::disk::mft::file_record_flags(record_header->flag) << std::endl;
	std::cout << "Real Size         : " << record_header->usedSize << std::endl;
	std::cout << "Allocated Size    : " << record_header->allocatedSize << std::endl;
	std::cout << "Base File Record  : " << utils::format::hex(record_header->baseRecord, true) << std::endl;
	std::cout << "Next Attribute ID : " << record_header->nextAttributeID << std::endl;
	std::cout << "MFT Record Index  : " << record_header->MFTRecordIndex << std::endl;
	std::cout << "Update Seq Number : " << record_header->updateSequenceNumber << std::endl;
	std::cout << "Update Seq Array  : ";
	for (int i = 0; i < record_header->updateNumber - 1; i++) std::cout << utils::format::hex(record_header->updateSequenceArray[i]);
	std::cout << std::endl;
	std::cout << std::endl;

	std::shared_ptr<utils::ui::Table> fr_attributes = std::make_shared<utils::ui::Table>();
	fr_attributes->set_interline(true);

	fr_attributes->add_header_line("Id");
	fr_attributes->add_header_line("Type");
	fr_attributes->add_header_line("Non-resident");
	fr_attributes->add_header_line("Length");
	fr_attributes->add_header_line("Overview");

	int n = 1;
	PMFT_RECORD_ATTRIBUTE_HEADER pAttribute = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_HEADER, record_header, record_header->attributeOffset);
	while (pAttribute->TypeCode != $END)
	{
		uint64_t raw_address = 0;
		auto raw_offset = reinterpret_cast<uint64_t>(pAttribute) - reinterpret_cast<uint64_t>(record_header);
		if (pAttribute->FormCode == NON_RESIDENT_FORM)
		{
			raw_address = record->raw_address() + raw_offset + pAttribute->Form.Nonresident.MappingPairsOffset;
		}
		else
		{
			raw_address = record->raw_address() + raw_offset + pAttribute->Form.Resident.ValueOffset;
		}

		fr_attributes->add_item_line(std::to_string(n++));
		fr_attributes->add_item_multiline(
			{
				constants::disk::mft::file_record_attribute_type(pAttribute->TypeCode),
				"Raw address: " + utils::format::hex6(raw_address, true),
			}
		);
		fr_attributes->add_item_line((pAttribute->FormCode == NON_RESIDENT_FORM ? "True" : "False"));
		if (pAttribute->FormCode == NON_RESIDENT_FORM)
		{
			fr_attributes->add_item_line(std::to_string(pAttribute->Form.Nonresident.ValidDataLength));
		}
		else
		{
			fr_attributes->add_item_line(std::to_string(pAttribute->Form.Resident.ValueLength));
		}
		switch (pAttribute->TypeCode)
		{
		case $FILE_NAME:
		{
			PMFT_RECORD_ATTRIBUTE_FILENAME pattr = nullptr;
			if (pAttribute->FormCode == RESIDENT_FORM)
			{
				pattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_FILENAME, pAttribute, pAttribute->Form.Resident.ValueOffset);
			}
			else
			{
				wprintf(L"Non-resident $FILENAME is not supported");
			}
			fr_attributes->add_item_multiline(print_attribute_filename(pattr));
			break;
		}
		case $STANDARD_INFORMATION:
		{
			PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION pattr = nullptr;
			if (pAttribute->FormCode == RESIDENT_FORM)
			{
				pattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION, pAttribute, pAttribute->Form.Resident.ValueOffset);
			}
			else
			{
				wprintf(L"Non-resident $STANDARD_INFORMATION is not supported");
			}
			fr_attributes->add_item_multiline(print_attribute_standard(pattr));
			break;
		}
		case $OBJECT_ID:
		{
			PMFT_RECORD_ATTRIBUTE_OBJECT_ID pattr = nullptr;
			if (pAttribute->FormCode == RESIDENT_FORM)
			{
				pattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_OBJECT_ID, pAttribute, pAttribute->Form.Resident.ValueOffset);
			}
			else
			{
				wprintf(L"Non-resident $OBJECT_ID is not supported");
			};
			fr_attributes->add_item_multiline(print_attribute_object_id(pattr));
			break;
		}
		case $SECURITY_DESCRIPTOR:
		{
			PMFT_RECORD_ATTRIBUTE_SECURITY_DESCRIPTOR pattr = nullptr;
			if (pAttribute->FormCode == RESIDENT_FORM)
			{
				pattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_SECURITY_DESCRIPTOR, pAttribute, pAttribute->Form.Resident.ValueOffset);
			}
			else
			{
				wprintf(L"Non-resident $SECURITY_DESCRIPTOR is not supported");
			};
			fr_attributes->add_item_multiline(print_attribute_security_descriptor(pattr));
			break;
		}
		case $INDEX_ROOT:
		{
			PMFT_RECORD_ATTRIBUTE_INDEX_ROOT pattr = nullptr;
			if (pAttribute->FormCode == RESIDENT_FORM)
			{
				pattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ROOT, pAttribute, pAttribute->Form.Resident.ValueOffset);
			}
			else
			{
				wprintf(L"Non-resident $INDEX_ROOT is not supported");
			};
			fr_attributes->add_item_multiline(print_attribute_index_root(pattr, record->index()));
			break;
		}
		case $REPARSE_POINT:
		{
			PMFT_RECORD_ATTRIBUTE_REPARSE_POINT pattr = nullptr;
			if (pAttribute->FormCode == RESIDENT_FORM)
			{
				pattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_REPARSE_POINT, pAttribute, pAttribute->Form.Resident.ValueOffset);
			}
			else
			{
				wprintf(L"Non-resident $REPARSE_POINT is not supported");
			}
			fr_attributes->add_item_multiline(print_attribute_reparse_point(pattr));
			break;
		}

		case $INDEX_ALLOCATION:
		{
			fr_attributes->add_item_multiline(print_attribute_index_allocation(pAttribute, record, cluster_size, record->index(), true));
			break;
		}
		case $DATA:
		{
			fr_attributes->set_cell_max_size(46);
			fr_attributes->add_item_multiline(print_attribute_data(record, pAttribute, cluster_size));
			break;
		}
		case $LOGGED_UTILITY_STREAM:
		{
			fr_attributes->add_item_multiline(print_attribute_logged_utility(record, pAttribute));
			break;
		}
		case $BITMAP:
		{
			std::shared_ptr<Buffer<PBYTE>> attr_buf = record->attribute_data<PBYTE>(pAttribute);

			fr_attributes->add_item_multiline(print_attribute_bitmap(reinterpret_cast<PMFT_RECORD_ATTRIBUTE_BITMAP>(attr_buf->data()), attr_buf->size()));

			break;
		}
		case $EA_INFORMATION:
		{
			PMFT_RECORD_ATTRIBUTE_EA_INFORMATION pattr = nullptr;
			if (pAttribute->FormCode == RESIDENT_FORM)
			{
				if (pAttribute->Form.Resident.ValueLength == 0x8)
				{
					pattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_EA_INFORMATION, pAttribute, pAttribute->Form.Resident.ValueOffset);
					fr_attributes->add_item_multiline(print_attribute_ea_information(pattr));
				}
				else
				{
					wprintf(L"$EA_INFORMATION != 8 bytes is not supported");
				}
			}
			else
			{
				wprintf(L"Non-resident $EA_INFORMATION is not supported");
			}

			break;
		}
		case $EA:
		{
			std::shared_ptr<Buffer<PMFT_RECORD_ATTRIBUTE_EA>> pattr = record->attribute_data<PMFT_RECORD_ATTRIBUTE_EA>(pAttribute);
			if (pattr->size() <= 0x10000)
			{
				fr_attributes->add_item_multiline(print_attribute_ea(pattr));
			}
			break;
		}
		case $ATTRIBUTE_LIST:
		{
			PMFT_RECORD_ATTRIBUTE pattr = nullptr;
			std::shared_ptr<Buffer<PBYTE>> attr_buf = nullptr;

			DWORD len = 0;
			if (pAttribute->FormCode == RESIDENT_FORM)
			{
				pattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE, pAttribute, pAttribute->Form.Resident.ValueOffset);
				len = pAttribute->Form.Resident.ValueLength;
			}
			else
			{
				len = pAttribute->Form.Nonresident.ValidDataLength & 0xffffffff;
				attr_buf = record->attribute_data<PBYTE>(pAttribute);
				pattr = (PMFT_RECORD_ATTRIBUTE)attr_buf->data();
			};
			fr_attributes->add_item_multiline(print_attribute_list(pattr, len));
			break;
		}
		default:
			fr_attributes->add_item_line("NYI attribute type");
		}
		fr_attributes->new_line();

		pAttribute = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_HEADER, pAttribute, pAttribute->RecordLength);
	}
	utils::ui::title("Attributes:");
	fr_attributes->render(std::cout);
	std::cout << std::endl;

	return 0;
}


int print_mft_info(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);

	if (opts->inode == -1 && opts->from == "")
	{
		// Default inode to display
		opts->inode = 0;
	}

	std::shared_ptr<MFTRecord> record = commands::helpers::find_record(explorer, opts);

	utils::ui::title("MFT (inode:" + std::to_string(record->header()->MFTRecordIndex) + ") from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	commands::mft::print_mft_info_details(record, explorer->reader()->sizes.cluster_size);

	return 0;
}

namespace commands
{
	namespace mft
	{
		namespace record
		{
			int dispatch(std::shared_ptr<Options> opts)
			{
				std::ios_base::fmtflags flag_backup(std::cout.flags());

				std::shared_ptr<Disk> disk = get_disk(opts);
				if (disk != nullptr)
				{
					std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
					if (volume != nullptr)
					{
						print_mft_info(disk, volume, opts);
					}
					else
					{
						invalid_option(opts, "volume", opts->volume);
					}
				}
				else
				{
					invalid_option(opts, "disk", opts->disk);
				}

				std::cout.flags(flag_backup);
				return 0;
			}
		}
	}
}
```

`Sources/Commands/command_reparse.cpp`:

```cpp
#include "Drive/disk.h"
#include "Utils/utils.h"
#include "options.h"
#include "Commands/commands.h"
#include "NTFS/ntfs.h"
#include "NTFS/ntfs_explorer.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"

#include <nlohmann/json.hpp>

#include <cstdint>
#include <string>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>
#include <iterator>

int print_reparse(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, const std::string& format, std::string output)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	utils::ui::title("Reparse points from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << vol->name() << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);

	std::cout << "[+] Reading $Extend\\$Reparse" << std::endl;

	std::shared_ptr<MFTRecord> record = explorer->mft()->record_from_path("\\$Extend\\$Reparse");

	std::shared_ptr<utils::ui::Table> df_table = std::make_shared<utils::ui::Table>();
	df_table->set_interline(true);

	df_table->add_header_line("Id");
	df_table->add_header_line("MFT Index");
	df_table->add_header_line("Filename");
	df_table->add_header_line("Type");
	df_table->add_header_line("Target/Data");

	int n = 0;
	auto index = record->index();
	std::cout << "[+] " << index.size() << " entries found" << std::endl;

	for (auto b : index)
	{
		std::shared_ptr<MFTRecord> rp = explorer->mft()->record_from_number(b->record_number());
		if (rp)
		{
			auto pattr = rp->attribute_header($REPARSE_POINT, "");
			if (pattr != nullptr)
			{
				if (pattr->FormCode == RESIDENT_FORM)
				{
					df_table->add_item_line(std::to_string(n++));
					df_table->add_item_line(utils::format::hex(rp->header()->MFTRecordIndex));
					df_table->add_item_line(utils::strings::to_utf8(rp->filename()));

					auto rp_value = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_REPARSE_POINT, pattr, pattr->Form.Resident.ValueOffset);

					df_table->add_item_line(constants::disk::mft::file_record_reparse_point_type(rp_value->ReparseTag));

					std::vector<std::string> target;

					if (rp_value->ReparseTag == IO_REPARSE_TAG_SYMLINK)
					{
						std::wstring subs_name = std::wstring(POINTER_ADD(PWCHAR, rp_value->SymbolicLinkReparseBuffer.PathBuffer, rp_value->SymbolicLinkReparseBuffer.SubstituteNameOffset));
						subs_name.resize(rp_value->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof(WCHAR));
						target.push_back(utils::strings::to_utf8(subs_name));
					}
					else if (rp_value->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
					{
						std::wstring subs_name = std::wstring(POINTER_ADD(PWCHAR, rp_value->MountPointReparseBuffer.PathBuffer, rp_value->MountPointReparseBuffer.SubstituteNameOffset));
						subs_name.resize(rp_value->MountPointReparseBuffer.SubstituteNameLength / sizeof(WCHAR));
						target.push_back(utils::strings::to_utf8(subs_name));
					}
					else if (rp_value->ReparseTag == IO_REPARSE_TAG_APPEXECLINK)
					{
						unsigned int idx = 0;
						size_t i = 0;
						while (idx < rp_value->AppExecLinkReparseBuffer.StringCount && i < rp_value->ReparseDataLength)
						{
							std::wstring subs_name = std::wstring(POINTER_ADD(PWCHAR, rp_value->AppExecLinkReparseBuffer.StringBuffer, i));
							target.push_back(utils::strings::to_utf8(subs_name));
							if (idx < rp_value->AppExecLinkReparseBuffer.StringCount - 1) target.push_back("");

							i += (subs_name.length() + 1) * sizeof(WCHAR);
							idx++;
						}
					}
					else
					{
						target.push_back(utils::convert::to_hex(rp_value->GenericReparseBuffer.DataBuffer, rp_value->ReparseDataLength));
					}

					df_table->add_item_multiline(target);

					df_table->new_line();
				}
			}
		}
	}

	df_table->render(std::cout);
	std::cout << std::endl;

	std::cout << "[+] Closing volume" << std::endl;

	return 0;
}

namespace commands {
	namespace reparse {
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
				if (volume != nullptr)
				{
					print_reparse(disk, volume, opts->format, opts->output);
				}
				else
				{
					invalid_option(opts, "volume", opts->volume);
				}
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_shadow.cpp`:

```cpp
#include "Drive/disk.h"
#include "Utils/utils.h"
#include "options.h"
#include "Commands/commands.h"
#include "NTFS/ntfs.h"
#include "NTFS/ntfs_explorer.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"

#include <nlohmann/json.hpp>

#include <cstdint>
#include <string>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>

#include <vss.h>

int print_volumeshadow(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("Volume Shadow from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << vol->name() << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);

	HANDLE hVolume = explorer->handle();

	DWORD read = 0;
	std::shared_ptr<Buffer<PVSS_VOLUME_HEADER>> vssbuf = std::make_shared<Buffer<PVSS_VOLUME_HEADER>>(512);
	SetFilePointer(hVolume, 0x1e00, NULL, FILE_BEGIN);
	if (ReadFile(hVolume, vssbuf->data(), 512, &read, NULL))
	{
		if (IsEqualGUID(vssbuf->data()->vssid, VSS_VOLUME_GUID))
		{
			std::cout << "[+] VSS header found at 0x1e00" << std::endl;

			std::shared_ptr<utils::ui::Table> df_table = std::make_shared<utils::ui::Table>();
			df_table->set_interline(true);

			df_table->add_header_line("SetID/ID");
			df_table->add_header_line("Count");
			df_table->add_header_line("Date");
			df_table->add_header_line("Details");

			LARGE_INTEGER next_offset;
			next_offset.QuadPart = vssbuf->data()->catalog_offset;
			while (next_offset.QuadPart)
			{
				std::shared_ptr<Buffer<PVSS_CATALOG_HEADER>> vsscatbuf = std::make_shared<Buffer<PVSS_CATALOG_HEADER>>(0x1000);
				SetFilePointer(hVolume, next_offset.LowPart, &next_offset.HighPart, FILE_BEGIN);
				if (ReadFile(hVolume, vsscatbuf->data(), 0x1000, &read, NULL))
				{
					auto cat = vsscatbuf->data();
					int i = 0;
					while ((cat->snapshots[i].entry_2.type == 0x2) && (cat->snapshots[i].entry_3.type == 0x3))
					{
						std::shared_ptr<Buffer<PVSS_STORE_HEADER>> store_header_buf = std::make_shared<Buffer<PVSS_STORE_HEADER>>(512);
						LARGE_INTEGER store_header_offset;
						store_header_offset.QuadPart = cat->snapshots[i].entry_3.store_header_offset;
						SetFilePointer(hVolume, store_header_offset.LowPart, &store_header_offset.HighPart, FILE_BEGIN);
						if (ReadFile(hVolume, store_header_buf->data(), 512, &read, NULL))
						{
							df_table->set_cell_max_size(38);
							df_table->add_item_multiline(
								{
								utils::id::guid_to_string(store_header_buf->data()->set_id),
								"",
								utils::id::guid_to_string(store_header_buf->data()->id)
								}
							);

							df_table->add_item_line(std::to_string(store_header_buf->data()->count));

							SYSTEMTIME st;
							utils::times::ull_to_systemtime(cat->snapshots[i].entry_2.creation_time, &st);
							df_table->add_item_line(utils::times::display_systemtime(st));

							std::vector<std::string> cellstrings;
							DWORD serviceMachine_size = (&store_header_buf->data()->machines.Length)[0] / sizeof(WCHAR);
							if (serviceMachine_size)
							{
								std::wstring serviceMachine = (&store_header_buf->data()->machines.Buffer) + 1;
								serviceMachine.resize(serviceMachine_size);
								cellstrings.push_back("Service Machine    : " + utils::strings::to_utf8(serviceMachine));
							}
							DWORD originatingMachine_size = (&store_header_buf->data()->machines.Length)[serviceMachine_size + 1] / sizeof(WCHAR);
							if (serviceMachine_size)
							{
								std::wstring originatingMachine = (&store_header_buf->data()->machines.Buffer) + serviceMachine_size + 2;
								originatingMachine.resize(originatingMachine_size);
								cellstrings.push_back("Originating Machine: " + utils::strings::to_utf8(originatingMachine));
							}
							cellstrings.push_back("State              : " + constants::disk::vss::state(store_header_buf->data()->state - 1));
							cellstrings.push_back("Flags              : 0x" + utils::format::hex((DWORD)store_header_buf->data()->flags));

							for (auto flagsstr : constants::disk::vss::flags(store_header_buf->data()->flags))
							{
								cellstrings.push_back("                   - " + flagsstr);
							}

							df_table->set_cell_max_size(42);
							df_table->add_item_multiline(cellstrings);

							df_table->new_line();
						}

						store_header_buf = nullptr;
						i++;
					}

					next_offset.QuadPart = cat->next_offset;
				}
				else
				{
					break;
				}
				vsscatbuf = nullptr;
			}

			std::cout << std::endl;
			df_table->render(std::cout);
			std::cout << std::endl;
		}
		else
		{
			std::cout << "[+] VSS header not found" << std::endl;
		}
	}

	std::cout << "[+] Closing volume" << std::endl;

	return 0;
}

namespace commands
{
	namespace shadow
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
				if (volume != nullptr)
				{
					print_volumeshadow(disk, volume);
				}
				else
				{
					invalid_option(opts, "volume", opts->volume);
				}
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_shell.cpp`:

```cpp
#include <iostream>
#include <memory>

#include "Commands/commands.h"
#include "NTFS/ntfs_explorer.h"

#include "options.h"
#include "Drive/disk.h"
#include "Drive/volume.h"
#include "Utils/table.h"

#include <iterator>
#include <iomanip>
#include <sstream>
#include <filesystem>
#include <csignal>

#define CTRL_PLUS_D	("\x04")

void signal_callback_handler(int signum) {
	exit(signum);
}

std::vector<std::string> parse_cmd_line(std::string cmdline)
{
	std::vector<std::string> cmds;
	std::istringstream iss(cmdline);

	std::string s;
	while (iss >> std::quoted(s)) {
		cmds.push_back(s);
	}

	return cmds;
}

std::string remove_trailing_path_delimiter(const std::string& s)
{
	std::string ret = s;
	if (ret != "\\")
	{
		ret.pop_back();
	}
	return ret;
}

const std::map<std::string, std::string> help_strings = {
	{"cat", "Print file content (limited to 1Mb file)"},
	{"cp", "Copy file"},
	{"cd", "Change directory"},
	{"exit", "See \"quit\" command."},
	{"ls","List directory content"},
	{"pwd","Print current working directory"},
	{"quit","Quit program"},
	{"rec","Print MFT record details"},
	{"help","This command"} };

void help(std::string cmd)
{
	std::cout << "- Commands" << std::endl;

	for (auto command : help_strings)
	{
		std::cout << "    " << std::setw(4) << command.first << " : " << command.second << std::endl;
	}
}

std::string clean_disk_name(std::shared_ptr<Disk> disk)
{
	if (disk->index() == DISK_INDEX_IMAGE)
	{
		return "(" + std::filesystem::path(disk->name()).filename().string() + ")";
	}
	else
	{
		return std::to_string(disk->index());
	}
}

int explorer(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);
	std::shared_ptr<MFTRecord> current_dir_record = explorer->mft()->record_from_number(ROOT_FILE_NAME_INDEX_NUMBER);
	std::string current_dir = "\\";

	signal(SIGINT, signal_callback_handler);

	std::string cmdline;
	bool quit = false;
	while (!quit)
	{
		std::cout << "disk" << clean_disk_name(disk) << ":volume" << vol->index() << ":" << remove_trailing_path_delimiter(current_dir) << "> ";
		std::cout.flush();
		std::getline(std::cin, cmdline);
		if (std::cin.fail() || std::cin.eof())
		{
			std::cin.clear();
			break;
		}
		std::vector<std::string> cmds = parse_cmd_line(cmdline);

		if (!cmds.empty() && cmds[0] != "")
		{
			if ((cmds[0] == "exit") || (cmds[0] == "quit") || (cmds[0] == CTRL_PLUS_D))
			{
				quit = true;
				continue;
			}
			if (cmds[0] == "cd" && cmds.size() == 2)
			{
				if (cmds[1] == ".")
				{
					continue;
				}
				if (cmds[1] == "..")
				{
					std::filesystem::path path(remove_trailing_path_delimiter(current_dir));
					std::string next_path = path.parent_path().string();

					std::shared_ptr<MFTRecord> next_dir = explorer->mft()->record_from_path(next_path);
					if (next_dir != nullptr)
					{
						current_dir_record = next_dir;
						current_dir = next_path;
						if (current_dir.back() != '\\') current_dir += "\\";
					}
					else
					{
						std::cout << cmds[1] << ": Directory not found" << std::endl;
					}
					continue;
				}
				if (cmds[1] != "")
				{
					std::string next_path = cmds[1];
					std::filesystem::path path(next_path);
					if (path.root_directory() != "\\")
					{
						next_path = current_dir + next_path;
					}
					std::shared_ptr<MFTRecord> next_dir = explorer->mft()->record_from_path(next_path);
					if (next_dir != nullptr)
					{
						if (next_dir->header()->flag & MFT_RECORD_IS_DIRECTORY)
						{
							current_dir_record = next_dir;
							current_dir = next_path;
							if (current_dir.back() != '\\') current_dir += "\\";
						}
						else
						{
							std::cout << cmds[1] << ": Is not a directory" << std::endl;
						}
					}
					else
					{
						std::cout << cmds[1] << ": Directory not found" << std::endl;
					}
				}
				continue;
			}
			if (cmds[0] == "help")
			{
				help(cmds[0]);
				continue;
			}
			if (cmds[0] == "ls")
			{
				std::vector<std::shared_ptr<IndexEntry>> index = current_dir_record->index();
				std::set<DWORD64> win32_named_entries;
				for (auto i : index)
				{
					if (i->name_type() != 2)
					{
						win32_named_entries.insert(i->record_number());
					}
				}

				if (index.size() > 0)
				{
					std::shared_ptr<utils::ui::Table> tab = std::make_shared<utils::ui::Table>();
					tab->set_margin_left(0);
					tab->set_interline(false);
					tab->set_border(false);
					tab->add_header_line("Inode", utils::ui::TableAlign::RIGHT);
					tab->add_header_line("Type");
					tab->add_header_line("Name");
					tab->add_header_line("Size", utils::ui::TableAlign::RIGHT);
					tab->add_header_line("Creation Date");
					tab->add_header_line("Attributes");
					for (auto& entry : index)
					{
						// Skip if there is an entry with non DOS name type
						if ((entry->name_type() == 2) && (win32_named_entries.find(entry->record_number()) != win32_named_entries.end())) continue;

						std::shared_ptr<MFTRecord> entry_rec = explorer->mft()->record_from_number(entry->record_number());
						std::vector<std::string> ads_names = entry_rec->alternate_data_names();

						tab->add_item_line(std::to_string(entry_rec->header()->MFTRecordIndex));
						if (entry_rec->header()->flag & MFT_RECORD_IS_DIRECTORY)
						{
							tab->add_item_line("DIR");
						}
						else
						{
							std::vector<std::string> types;
							types.push_back("");
							for (unsigned int i = 0; i < ads_names.size(); i++)
							{
								types.push_back("ADS");
							}
							tab->add_item_multiline(types);
						}
						std::vector<std::string> names;
						names.push_back(utils::strings::to_utf8(entry->name()));
						for (auto& ads : ads_names)
						{
							names.push_back("  " + ads);
						}
						tab->add_item_multiline(names);
						if (entry_rec->header()->flag & MFT_RECORD_IS_DIRECTORY)
						{
							tab->add_item_line("");
						}
						else
						{
							std::vector<std::string> sizes;
							sizes.push_back(std::to_string(entry_rec->datasize()));
							for (auto& ads : ads_names)
							{
								sizes.push_back(std::to_string(entry_rec->datasize(ads)));
							}
							tab->add_item_multiline(sizes);
						}
						PMFT_RECORD_ATTRIBUTE_HEADER stdinfo_att = entry_rec->attribute_header($STANDARD_INFORMATION);
						if (stdinfo_att)
						{
							PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION stdinfo = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION, stdinfo_att, stdinfo_att->Form.Resident.ValueOffset);
							SYSTEMTIME st = { 0 };
							utils::times::ull_to_local_systemtime(stdinfo->CreateTime, &st);
							tab->add_item_line(utils::times::display_systemtime(st));

							std::vector<std::string> perms;
							if (stdinfo->u.Permission.archive) perms.push_back("Ar");
							if (stdinfo->u.Permission.compressed) perms.push_back("Co");
							if (stdinfo->u.Permission.device) perms.push_back("De");
							if (stdinfo->u.Permission.encrypted) perms.push_back("En");
							if (stdinfo->u.Permission.hidden) perms.push_back("Hi");
							if (stdinfo->u.Permission.normal) perms.push_back("No");
							if (stdinfo->u.Permission.not_indexed) perms.push_back("Ni");
							if (stdinfo->u.Permission.offline) perms.push_back("Of");
							if (stdinfo->u.Permission.readonly) perms.push_back("Ro");
							if (stdinfo->u.Permission.reparse) perms.push_back("Re");
							if (stdinfo->u.Permission.sparse) perms.push_back("Sp");
							if (stdinfo->u.Permission.system) perms.push_back("Sy");
							if (stdinfo->u.Permission.temp) perms.push_back("Tm");

							tab->add_item_line(utils::strings::join(perms, " "));
						}
						else
						{
							tab->add_item_line("");
							tab->add_item_line("");
						}

						tab->new_line();
					}
					std::cout << std::endl;
					tab->render(std::cout);
					std::cout << std::endl;
				}
				continue;
			}
			if (cmds[0] == "rec" && cmds.size() == 2)
			{
				if (cmds[1] != "")
				{
					auto from_file = utils::files::split_file_and_stream(cmds[1]);

					bool found = false;
					std::vector<std::shared_ptr<IndexEntry>> index = current_dir_record->index();
					for (std::shared_ptr<IndexEntry>& entry : index)
					{
						if (_strcmpi(utils::strings::to_utf8(entry->name()).c_str(), from_file.first.c_str()) == 0)
						{
							found = true;
							std::shared_ptr<MFTRecord> target_record = explorer->mft()->record_from_number(entry->record_number());
							commands::mft::print_mft_info_details(target_record, explorer->reader()->sizes.cluster_size);
							break;
						}
					}
					if (!found)
					{
						std::cout << cmds[1] << ": File not found" << std::endl;
					}
				}
				continue;
			}

			if (cmds[0] == "rec" && cmds.size() == 1)
			{
				commands::mft::print_mft_info_details(current_dir_record, explorer->reader()->sizes.cluster_size);
				continue;
			}
			if (cmds[0] == "cat" && cmds.size() == 2)
			{
				if (cmds[1] != "")
				{
					auto from_file = utils::files::split_file_and_stream(cmds[1]);

					bool found = false;
					std::vector<std::shared_ptr<IndexEntry>> index = current_dir_record->index();
					for (std::shared_ptr<IndexEntry>& entry : index)
					{
						if (_strcmpi(utils::strings::to_utf8(entry->name()).c_str(), from_file.first.c_str()) == 0)
						{
							std::shared_ptr<MFTRecord> filetocat_record = explorer->mft()->record_from_number(entry->record_number());
							if (!(filetocat_record->header()->flag & MFT_RECORD_IS_DIRECTORY))
							{
								found = true;
								if (filetocat_record->datasize(from_file.second) <= 1 * 1024 * 1024)
								{
									auto databuf = filetocat_record->data(from_file.second);
									std::string content = std::string((PCHAR)databuf->data(), databuf->size());
									std::cout << content << std::endl;
								}
								else
								{
									std::cout << cmds[1] << ": File too big to be cat-ed" << std::endl;
								}
							}
							break;
						}
					}
					if (!found)
					{
						std::cout << cmds[1] << ": File not found" << std::endl;
					}
				}
				continue;
			}
			if (cmds[0] == "cp" && cmds.size() == 3)
			{
				if (cmds[1] != "" && cmds[2] != "")
				{
					auto from_file = utils::files::split_file_and_stream(cmds[1]);
					std::string copyto = cmds[2];

					bool found = false;
					std::vector<std::shared_ptr<IndexEntry>> index = current_dir_record->index();
					for (std::shared_ptr<IndexEntry>& entry : index)
					{
						if (_strcmpi(utils::strings::to_utf8(entry->name()).c_str(), from_file.first.c_str()) == 0)
						{
							found = true;
							std::shared_ptr<MFTRecord> copyfrom_record = explorer->mft()->record_from_number(entry->record_number());
							if (!(copyfrom_record->header()->flag & MFT_RECORD_IS_DIRECTORY))
							{
								if (copyfrom_record->data_to_file(utils::strings::from_string(copyto).c_str(), from_file.second, true))
								{
									std::cout << "1 file copied" << std::endl;
								}
							}
							else
							{
								std::cout << cmds[1] << ": Is not a file" << std::endl;
							}
							break;
						}
					}
					if (!found)
					{
						std::cout << cmds[1] << ": File not found" << std::endl;
					}
				}
				continue;
			}
			if (cmds[0] == "pwd")
			{
				if (current_dir.size() == 1) std::cout << current_dir << std::endl;
				else std::cout << remove_trailing_path_delimiter(current_dir) << std::endl;
				continue;
			}
			std::cout << "Unknown command : " << cmds[0] << ". Type \"help\" for command list." << std::endl;
		}
	}
	return 0;
}

namespace commands
{
	namespace shell
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
				if (volume != nullptr)
				{
					explorer(disk, volume);
				}
				else
				{
					invalid_option(opts, "volume", opts->volume);
				}
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_smart.cpp`:

```cpp

#include "Utils/buffer.h"
#include "Drive/disk.h"
#include "Drive/smart.h"
#include "Utils/table.h"
#include "Utils/utils.h"
#include "Utils/constant_names.h"
#include "options.h"

#include <algorithm>
#include <cstdint>
#include <string>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>
#include <stdexcept> 


bool smart_is_enabled(HANDLE hDevice, BYTE driveIndex)
{
	SENDCMDINPARAMS stCIP = { 0 };
	SENDCMDOUTPARAMS stCOP = { 0 };
	DWORD dwRet = 0;

	stCIP.cBufferSize = 0;
	stCIP.bDriveNumber = driveIndex;
	stCIP.irDriveRegs.bFeaturesReg = ENABLE_SMART;
	stCIP.irDriveRegs.bSectorCountReg = 1;
	stCIP.irDriveRegs.bSectorNumberReg = 1;
	stCIP.irDriveRegs.bCylLowReg = SMART_CYL_LOW;
	stCIP.irDriveRegs.bCylHighReg = SMART_CYL_HI;
	stCIP.irDriveRegs.bDriveHeadReg = DRIVE_HEAD_REG | ((driveIndex & 1) << 4);
	stCIP.irDriveRegs.bCommandReg = SMART_CMD;

	return DeviceIoControl(hDevice, SMART_SEND_DRIVE_COMMAND, &stCIP, sizeof(stCIP) - 1, &stCOP, sizeof(stCOP) - 1, &dwRet, NULL);
}

bool smart_read_attributes(HANDLE hDevice, BYTE driveIndex, std::shared_ptr<Buffer<PSMART_OUTPUT_ATTRIBUTES>> outputBuffer)
{
	SENDCMDINPARAMS stCIP = { 0 };
	DWORD dwRet = 0;

	stCIP.cBufferSize = READ_ATTRIBUTE_BUFFER_SIZE;
	stCIP.bDriveNumber = driveIndex;
	stCIP.irDriveRegs.bFeaturesReg = READ_ATTRIBUTES;
	stCIP.irDriveRegs.bSectorCountReg = 1;
	stCIP.irDriveRegs.bSectorNumberReg = 1;
	stCIP.irDriveRegs.bCylLowReg = SMART_CYL_LOW;
	stCIP.irDriveRegs.bCylHighReg = SMART_CYL_HI;
	stCIP.irDriveRegs.bDriveHeadReg = DRIVE_HEAD_REG | ((driveIndex & 1) << 4);
	stCIP.irDriveRegs.bCommandReg = SMART_CMD;

	return DeviceIoControl(hDevice, SMART_RCV_DRIVE_DATA, &stCIP, sizeof(stCIP) - 1, outputBuffer->data(), outputBuffer->size() - 1, &dwRet, NULL);
}

bool smart_read_thresholds(HANDLE hDevice, BYTE driveIndex, std::shared_ptr<Buffer<PSMART_OUTPUT_THRESHOLDS>> outputBuffer)
{
	SENDCMDINPARAMS stCIP = { 0 };
	DWORD dwRet = 0;

	stCIP.cBufferSize = READ_THRESHOLD_BUFFER_SIZE;
	stCIP.bDriveNumber = driveIndex;
	stCIP.irDriveRegs.bFeaturesReg = READ_THRESHOLDS;
	stCIP.irDriveRegs.bSectorCountReg = 1;
	stCIP.irDriveRegs.bSectorNumberReg = 1;
	stCIP.irDriveRegs.bCylLowReg = SMART_CYL_LOW;
	stCIP.irDriveRegs.bCylHighReg = SMART_CYL_HI;
	stCIP.irDriveRegs.bDriveHeadReg = DRIVE_HEAD_REG | ((driveIndex & 1) << 4);
	stCIP.irDriveRegs.bCommandReg = SMART_CMD;

	return DeviceIoControl(hDevice, SMART_RCV_DRIVE_DATA, &stCIP, sizeof(stCIP) - 1, outputBuffer->data(), outputBuffer->size() - 1, &dwRet, NULL);
}

bool smart_read_status(HANDLE hDevice, BYTE driveIndex, std::shared_ptr<Buffer<PSMART_OUTPUT_STATUS>> outputBuffer)
{
	SENDCMDINPARAMS stCIP = { 0 };
	DWORD dwRet = 0;

	stCIP.cBufferSize = READ_STATUS_BUFFER_SIZE;
	stCIP.bDriveNumber = driveIndex;
	stCIP.irDriveRegs.bFeaturesReg = RETURN_SMART_STATUS;
	stCIP.irDriveRegs.bSectorCountReg = 1;
	stCIP.irDriveRegs.bSectorNumberReg = 1;
	stCIP.irDriveRegs.bCylLowReg = SMART_CYL_LOW;
	stCIP.irDriveRegs.bCylHighReg = SMART_CYL_HI;
	stCIP.irDriveRegs.bDriveHeadReg = DRIVE_HEAD_REG | ((driveIndex & 1) << 4);
	stCIP.irDriveRegs.bCommandReg = SMART_CMD;

	return DeviceIoControl(hDevice, SMART_SEND_DRIVE_COMMAND, &stCIP, sizeof(stCIP) - 1, outputBuffer->data(), outputBuffer->size() - 1, &dwRet, NULL);
}

bool smart_read_identity(HANDLE hDevice, BYTE driveIndex, std::shared_ptr<Buffer<PSMART_OUTPUT_IDENTITY>> outputBuffer)
{
	SENDCMDINPARAMS stCIP = { 0 };
	DWORD dwRet = 0;

	stCIP.cBufferSize = READ_IDENTITY_BUFFER_SIZE;
	stCIP.bDriveNumber = driveIndex;
	stCIP.irDriveRegs.bFeaturesReg = 0;
	stCIP.irDriveRegs.bSectorCountReg = 1;
	stCIP.irDriveRegs.bSectorNumberReg = 1;
	stCIP.irDriveRegs.bCylLowReg = 0;
	stCIP.irDriveRegs.bCylHighReg = 0;
	stCIP.irDriveRegs.bDriveHeadReg = DRIVE_HEAD_REG | ((driveIndex & 1) << 4);
	stCIP.irDriveRegs.bCommandReg = ID_CMD;

	return DeviceIoControl(hDevice, SMART_RCV_DRIVE_DATA, &stCIP, sizeof(stCIP) - 1, outputBuffer->data(), outputBuffer->size() - 1, &dwRet, NULL);
}

std::string read_string(PVOID buffer, DWORD len)
{
	std::ostringstream os;
	auto char_buffer = reinterpret_cast<PCHAR>(buffer);
	bool first_byte = true;

	for (int i = len - 1; i >= 0; i -= 2)
	{
		os << char_buffer[i - 1] << char_buffer[i];
	}

	std::string ret = utils::strings::reverse(os.str());

	ret.erase(ret.begin(), std::find_if(ret.begin(), ret.end(), [](int ch) {
		return !std::isspace(ch & 0xff) && (ch != 0);
		}));

	return ret;
}

void print_smart_data(std::shared_ptr<Disk> disk)
{
	utils::ui::title("SMART data from " + disk->name());

	HANDLE hDisk = CreateFileA(disk->name().c_str(), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, 0);
	if (hDisk != INVALID_HANDLE_VALUE)
	{
		GETVERSIONINPARAMS versionInfo = { 0 };
		DWORD dwRet = 0;
		bool ret = DeviceIoControl(hDisk, SMART_GET_VERSION, NULL, 0, &versionInfo, sizeof(GETVERSIONINPARAMS), &dwRet, NULL);
		if (ret)
		{
			std::cout << "    Version          : " << std::to_string(versionInfo.bVersion) << " revision " << std::to_string(versionInfo.bRevision) << std::endl;
			std::cout << "    Type             : " << constants::disk::smart::devicemap_type(versionInfo.bIDEDeviceMap) << std::endl;
			std::cout << "    Capabilities     : " << constants::disk::smart::capabilities(versionInfo.fCapabilities) << std::endl;

			if ((versionInfo.fCapabilities & CAP_SMART_CMD) == CAP_SMART_CMD)
			{
				if (smart_is_enabled(hDisk, static_cast<BYTE>(disk->index())))
				{
					dwRet = 0;
					auto statusBuffer = std::make_shared<Buffer<PSMART_OUTPUT_STATUS>>(sizeof(SMART_OUTPUT_STATUS) + READ_STATUS_BUFFER_SIZE);

					if (smart_read_status(hDisk, static_cast<BYTE>(disk->index()), statusBuffer))
					{
						std::cout << "    Status           : " <<
							((statusBuffer->data()->Status.bCylLowReg == SMART_CYL_LOW_BAD && statusBuffer->data()->Status.bCylHighReg == SMART_CYL_HI_BAD) ?
								"Threshold Exceeded Condition!" :
								"Passed") <<
							std::endl << std::endl;
					}
					else
					{
						std::cerr << "[!] Failed to read S.M.A.R.T status." << std::endl;
					}

					auto idBuffer = std::make_shared<Buffer<PSMART_OUTPUT_IDENTITY>>(sizeof(SMART_OUTPUT_IDENTITY) + READ_IDENTITY_BUFFER_SIZE);

					if (smart_read_identity(hDisk, static_cast<BYTE>(disk->index()), idBuffer))
					{
						std::cout << "    -- Device ID" << std::endl;
						std::shared_ptr<utils::ui::Table> table = std::make_shared<utils::ui::Table>();
						table->set_margin_left(4);

						table->add_header_line("Property");
						table->add_header_line("Value");

						table->add_item_line("General Configuration");
						table->add_item_line(utils::format::hex(idBuffer->data()->Identity.wGenConfig, true));
						table->new_line();
						table->add_item_line("Number of Cylinders");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wNumCyls));
						table->new_line();
						table->add_item_line("Reserved");
						table->add_item_line(utils::format::hex(idBuffer->data()->Identity.wReserved, true));
						table->new_line();
						table->add_item_line("Number Of Heads");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wNumHeads));
						table->new_line();
						table->add_item_line("Bytes Per Track");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wBytesPerTrack));
						table->new_line();
						table->add_item_line("Bytes Per Sector");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wBytesPerSector));
						table->new_line();
						table->add_item_line("Sectors Per Track");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wNumSectorsPerTrack));
						table->new_line();
						table->add_item_line("Vendor Unique");
						table->add_item_line(read_string(idBuffer->data()->Identity.wVendorUnique, 6));
						table->new_line();
						table->add_item_line("Seria Number");
						table->add_item_line(read_string(idBuffer->data()->Identity.sSerialNumber, 20));
						table->new_line();
						table->add_item_line("Buffer Type");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wBufferType));
						table->new_line();
						table->add_item_line("Buffer Size");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wBufferSize));
						table->new_line();
						table->add_item_line("ECC Size");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wECCSize));
						table->new_line();
						table->add_item_line("Firmware Revision");
						table->add_item_line(read_string(idBuffer->data()->Identity.sFirmwareRev, 8));
						table->new_line();
						table->add_item_line("Model Number");
						table->add_item_line(read_string(idBuffer->data()->Identity.sModelNumber, 40));
						table->new_line();
						table->add_item_line("Maximum Number of Sectors On R/W");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wMoreVendorUnique));
						table->new_line();
						table->add_item_line("Double Word IO");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wDoubleWordIO));
						table->new_line();
						table->add_item_line("Capabilities");
						table->add_item_multiline(
							{
								std::string("Reserved                 : ") + utils::format::hex(idBuffer->data()->Identity.wCapabilities.Reserved, true),
								std::string("DMA Support              : ") + (idBuffer->data()->Identity.wCapabilities.DMA ? "True" : "False"),
								std::string("LBA Support              : ") + (idBuffer->data()->Identity.wCapabilities.LBA ? "True" : "False"),
								std::string("DisIORDY                 : ") + (idBuffer->data()->Identity.wCapabilities.DisIORDY ? "True" : "False"),
								std::string("IORDY                    : ") + (idBuffer->data()->Identity.wCapabilities.IORDY ? "True" : "False"),
								std::string("Requires ATA soft start  : ") + (idBuffer->data()->Identity.wCapabilities.SoftReset ? "True" : "False"),
								std::string("Overlap Operation support: ") + (idBuffer->data()->Identity.wCapabilities.Overlap ? "True" : "False"),
								std::string("Command Queue Support    : ") + (idBuffer->data()->Identity.wCapabilities.Queue ? "True" : "False"),
								std::string("Interleaved DMA Support  : ") + (idBuffer->data()->Identity.wCapabilities.InlDMA ? "True" : "False")
							}
						);
						table->new_line();
						table->add_item_line("Reserved1");
						table->add_item_line(utils::format::hex(idBuffer->data()->Identity.wReserved1, true));
						table->new_line();
						table->add_item_line("PIO Timing");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wPIOTiming));
						table->new_line();
						table->add_item_line("DMA Timing");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wDMATiming));
						table->new_line();
						table->add_item_line("Field Validity");
						table->add_item_multiline(
							{
								std::string("CHS Number               : ") + (idBuffer->data()->Identity.wFieldValidity.CHSNumber ? "True" : "False"),
								std::string("Cycle Number             : ") + (idBuffer->data()->Identity.wFieldValidity.CycleNumber ? "True" : "False"),
								std::string("Ultra DMA                : ") + (idBuffer->data()->Identity.wFieldValidity.UltraDMA ? "True" : "False")
							}
						);
						table->new_line();
						table->add_item_line("Current numbers of cylinders");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wNumCurCyls));
						table->new_line();
						table->add_item_line("Current numbers of heads");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wNumCurHeads));
						table->new_line();
						table->add_item_line("Current numbers of sectors per track");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wNumCurSectorsPerTrack));
						table->new_line();
						table->add_item_line("Multiple Sector Setting");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wCurSectors));
						table->new_line();
						table->add_item_line("Total Number of Sectors Addressable (LBA)");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.dwTotalSectors));
						table->new_line();
						table->add_item_line("Singleword DMA Transfer Support");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wSingleWordDMA));
						table->new_line();
						table->add_item_line("Multiword DMA Transfer Support");
						std::vector<std::string> multiword_dma_modes;
						if (idBuffer->data()->Identity.wMultiWordDMA.Mode0) multiword_dma_modes.push_back(std::string("Mode 0 (4.17Mb/s)") + (idBuffer->data()->Identity.wMultiWordDMA.Mode0Sel ? " (selected)" : ""));
						if (idBuffer->data()->Identity.wMultiWordDMA.Mode1) multiword_dma_modes.push_back(std::string("Mode 1 (13.3Mb/s)") + (idBuffer->data()->Identity.wMultiWordDMA.Mode1Sel ? " (selected)" : ""));
						if (idBuffer->data()->Identity.wMultiWordDMA.Mode2) multiword_dma_modes.push_back(std::string("Mode 2 (16.7Mb/s)") + (idBuffer->data()->Identity.wMultiWordDMA.Mode2Sel ? " (selected)" : ""));
						table->add_item_multiline(multiword_dma_modes);
						table->new_line();
						table->add_item_line("Advanced PIO Modes");
						table->add_item_line(utils::format::hex(idBuffer->data()->Identity.wPIOCapacity.AdvPOIModes, true));
						table->new_line();
						table->add_item_line("Minimum Multiword DMA Transfer Cycle Time per Word");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wMinMultiWordDMACycle));
						table->new_line();
						table->add_item_line("Recommended Multiword DMA Transfer Cycle Time per Word");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wRecMultiWordDMACycle));
						table->new_line();
						table->add_item_line("Minimum PIO Transfer Cycle Time (No Flow Control)");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wMinPIONoFlowCycle));
						table->new_line();
						table->add_item_line("Minimum PIO Transfer Cycle Time (Flow Control)");
						table->add_item_line(std::to_string(idBuffer->data()->Identity.wMinPOIFlowCycle));
						table->new_line();
						table->add_item_line("ATA Support");
						std::vector<std::string> ata_support;
						if (idBuffer->data()->Identity.wMajorVersion.ATA1) ata_support.push_back(std::string("ATA-1"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA2) ata_support.push_back(std::string("ATA-2"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA3) ata_support.push_back(std::string("ATA-3"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA4) ata_support.push_back(std::string("ATA-4"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA5) ata_support.push_back(std::string("ATA/ATAPI-5"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA6) ata_support.push_back(std::string("ATA/ATAPI-6"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA7) ata_support.push_back(std::string("ATA/ATAPI-7"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA8) ata_support.push_back(std::string("ATA/ATAPI-8"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA9) ata_support.push_back(std::string("ATA/ATAPI-9"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA10) ata_support.push_back(std::string("ATA/ATAPI-10"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA11) ata_support.push_back(std::string("ATA/ATAPI-11"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA12) ata_support.push_back(std::string("ATA/ATAPI-12"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA13) ata_support.push_back(std::string("ATA/ATAPI-13"));
						if (idBuffer->data()->Identity.wMajorVersion.ATA14) ata_support.push_back(std::string("ATA/ATAPI-14"));
						table->add_item_multiline(ata_support);
						table->new_line();
						table->add_item_line("Ultra DMA Transfer Support");
						std::vector<std::string> ultra_dma_modes;
						if (idBuffer->data()->Identity.wUltraDMA.Mode0) ultra_dma_modes.push_back(std::string("Mode 0 (16.7MB/s)") + (idBuffer->data()->Identity.wUltraDMA.Mode0Sel ? " (selected)" : ""));
						if (idBuffer->data()->Identity.wUltraDMA.Mode1) ultra_dma_modes.push_back(std::string("Mode 1 (25.0MB/s)") + (idBuffer->data()->Identity.wUltraDMA.Mode1Sel ? " (selected)" : ""));
						if (idBuffer->data()->Identity.wUltraDMA.Mode2) ultra_dma_modes.push_back(std::string("Mode 2 (33.3MB/s)") + (idBuffer->data()->Identity.wUltraDMA.Mode2Sel ? " (selected)" : ""));
						if (idBuffer->data()->Identity.wUltraDMA.Mode3) ultra_dma_modes.push_back(std::string("Mode 3 (44.4MB/s)") + (idBuffer->data()->Identity.wUltraDMA.Mode3Sel ? " (selected)" : ""));
						if (idBuffer->data()->Identity.wUltraDMA.Mode4) ultra_dma_modes.push_back(std::string("Mode 4 (66.7MB/s)") + (idBuffer->data()->Identity.wUltraDMA.Mode4Sel ? " (selected)" : ""));
						if (idBuffer->data()->Identity.wUltraDMA.Mode5) ultra_dma_modes.push_back(std::string("Mode 5 (100.0MB/s)") + (idBuffer->data()->Identity.wUltraDMA.Mode5Sel ? " (selected)" : ""));
						if (idBuffer->data()->Identity.wUltraDMA.Mode6) ultra_dma_modes.push_back(std::string("Mode 6 (133.0MB/s)") + (idBuffer->data()->Identity.wUltraDMA.Mode6Sel ? " (selected)" : ""));
						if (idBuffer->data()->Identity.wUltraDMA.Mode7) ultra_dma_modes.push_back(std::string("Mode 7 (167.0MB/s)") + (idBuffer->data()->Identity.wUltraDMA.Mode7Sel ? " (selected)" : ""));
						table->add_item_multiline(ultra_dma_modes);
						table->new_line();

						table->render(std::cout);
						std::cout << std::endl;
					}
					else
					{
						std::cerr << "[!] Failed to read S.M.A.R.T status." << std::endl;
					}

					auto attributeBuffer = std::make_shared<Buffer<PSMART_OUTPUT_ATTRIBUTES>>(sizeof(SMART_OUTPUT_ATTRIBUTES) + READ_ATTRIBUTE_BUFFER_SIZE);
					auto thresholdBuffer = std::make_shared<Buffer<PSMART_OUTPUT_THRESHOLDS>>(sizeof(SMART_OUTPUT_THRESHOLDS) + READ_THRESHOLD_BUFFER_SIZE);

					if (smart_read_attributes(hDisk, static_cast<BYTE>(disk->index()), attributeBuffer) &&
						smart_read_thresholds(hDisk, static_cast<BYTE>(disk->index()), thresholdBuffer))
					{
						std::cout << "    -- Attributes" << std::endl;

						std::shared_ptr<utils::ui::Table> table = std::make_shared<utils::ui::Table>();
						table->set_margin_left(4);

						table->add_header_line("Index", utils::ui::TableAlign::RIGHT);
						table->add_header_line("Name");
						table->add_header_line("Flags");
						table->add_header_line("Raw", utils::ui::TableAlign::RIGHT);
						table->add_header_line("Value", utils::ui::TableAlign::RIGHT);
						table->add_header_line("Worst", utils::ui::TableAlign::RIGHT);
						table->add_header_line("Threshold", utils::ui::TableAlign::RIGHT);
						table->add_header_line("Status", utils::ui::TableAlign::RIGHT);

						unsigned int nb_attributes = attributeBuffer->data()->cBufferSize / 0xc;
						PSMART_ATTRIBUTE currAttribute = &attributeBuffer->data()->Attributes[0];
						PSMART_THRESHOLD currThreshold = &thresholdBuffer->data()->Threshold[0];
						for (unsigned int i = 0; i < nb_attributes; i++)
						{
							if (currAttribute->index)
							{
								table->add_item_line(utils::format::hex(currAttribute->index, true));
								table->add_item_line(constants::disk::smart::attribute_name(currAttribute->index));
								table->add_item_line(utils::format::hex(currAttribute->flags, true));
								table->add_item_line(utils::format::hex6(currAttribute->rawValue48, true));
								table->add_item_line(std::to_string(currAttribute->value));
								table->add_item_line(std::to_string(currAttribute->worst));
								table->add_item_line(std::to_string(currThreshold->threshold));
								table->add_item_line(currAttribute->value < currThreshold->threshold ? "Failure" : "Ok");
								table->new_line();
							}
							currAttribute = POINTER_ADD(PSMART_ATTRIBUTE, currAttribute, 0xc);
							currThreshold = POINTER_ADD(PSMART_THRESHOLD, currThreshold, 0xc);
						}

						table->render(std::cout);
						std::cout << std::endl;
					}
					else
					{
						std::cerr << "[!] Failed to read S.M.A.R.T attributes." << std::endl;
					}
				}
				else
				{
					std::cerr << "[!] S.M.A.R.T is not enabled." << std::endl;
				}
			}
			else
			{
				std::cerr << "[!] S.M.A.R.T commands are not supported." << std::endl;
			}
		}
		CloseHandle(hDisk);
	}

	std::cout << std::endl;
}

namespace commands
{
	namespace smart
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);

			if (disk != nullptr)
			{
				print_smart_data(disk);
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_streams.cpp`:

```cpp
#include "Drive/disk.h"
#include "Utils/utils.h"
#include "options.h"
#include "Commands/commands.h"
#include "NTFS/ntfs.h"
#include "NTFS/ntfs_explorer.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"

#include <nlohmann/json.hpp>

#include <cstdint>
#include <string>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>

int list_streams(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("Listing streams from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << (vol->name().empty() ? reinterpret_cast<Disk*>(vol->parent())->name() : vol->name()) << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);
	std::shared_ptr<MFTRecord> record = commands::helpers::find_record(explorer, opts);

	std::cout << "[-] Record Num  : " << record->header()->MFTRecordIndex << " (" << utils::format::hex(record->header()->MFTRecordIndex, true) << ")" << std::endl;

	std::vector<std::string> ads_names = record->alternate_data_names();

	if (ads_names.size() > 0)
	{
		std::cout << "[+] Alternate data stream(s):" << std::endl;

		std::shared_ptr<utils::ui::Table> tab = std::make_shared<utils::ui::Table>();
		tab->set_margin_left(4);
		tab->set_interline(false);
		tab->add_header_line("Id", utils::ui::TableAlign::RIGHT);
		tab->add_header_line("Name");
		tab->add_header_line("Size", utils::ui::TableAlign::RIGHT);

		int i = 0;
		for (auto& ads : ads_names)
		{
			tab->add_item_line(std::to_string(i++));
			tab->add_item_line(ads);
			tab->add_item_line(std::to_string(record->datasize(ads)));
			tab->new_line();
		}

		tab->render(std::cout);
	}
	else
	{
		std::cout << "[+] No alternate data stream" << std::endl;
	}

	return 0;
}

namespace commands {
	namespace streams {
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
				if (volume != nullptr)
				{
					list_streams(disk, volume, opts);
				}
				else
				{
					invalid_option(opts, "volume", opts->volume);
				}
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_undelete.cpp`:

```cpp
#include <algorithm>
#include <cstdint>
#include <string>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>
#include <stdexcept>

#include "Drive/disk.h"
#include "options.h"
#include "NTFS/ntfs.h"
#include "NTFS/ntfs_explorer.h"
#include "NTFS/ntfs.h"
#include "Utils/utils.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"
#include <Commands/commands.h>

bool valid_record(PMFT_RECORD_HEADER ph)
{
	return (
		(memcmp(ph->signature, "FILE", 4) == 0) &&
		(ph->attributeOffset > 0x30) &&
		(ph->attributeOffset < 0x400) &&
		(POINTER_ADD(PMFT_RECORD_ATTRIBUTE_HEADER, ph, ph->attributeOffset)->TypeCode >= 10) &&
		(POINTER_ADD(PMFT_RECORD_ATTRIBUTE_HEADER, ph, ph->attributeOffset)->TypeCode <= 100)
		);
}

std::string get_full_path(DWORD index, std::map<DWORD, std::string>& index_to_name, std::map<DWORD, DWORD>& index_to_parent)
{
	DWORD cur_index = index;
	std::string cur_path = index_to_name[cur_index];

	while (cur_index != ROOT_FILE_NAME_INDEX_NUMBER)
	{
		if (index_to_parent.find(cur_index) != index_to_parent.end())
		{
			cur_index = index_to_parent[cur_index];
			if (index_to_name.find(cur_index) != index_to_name.end())
			{
				cur_path = index_to_name[cur_index] + "\\" + cur_path;
			}
			else
			{
				cur_path = "?\\" + cur_path;
				break;
			}
		}
	}
	return cur_path;
}

LONGLONG check_cluster_used(std::shared_ptr<Buffer<PBYTE>> bitmap, PMFT_DATARUN dt)
{
	DWORD reused = 0;
	LONGLONG start_byte = dt->offset / 8;
	DWORD start_bit = dt->offset % 8;
	LONGLONG stop_byte = (dt->offset + dt->length) / 8;
	DWORD stop_bit = (dt->offset + dt->length) % 8;
	if (stop_bit == 0)
	{
		stop_byte++;
	}

	while (start_byte != stop_byte && start_bit != stop_bit)
	{
		if (bitmap->data()[start_byte] & (0x80 >> start_bit))
		{
			reused++;
		}

		start_bit++;
		if (start_bit == 8)
		{
			start_bit = 0;
			start_byte++;
		}
	}

	return reused;
}

bool check_dataruns_still_valid(ULONG64 datasize, ULONG64 clustersize, const std::vector<MFT_DATARUN>& dataruns)
{
	ULONG64 size_from_dataruns = 0;

	for (auto& dt : dataruns)
	{
		size_from_dataruns += dt.length * clustersize;
	}

	return (datasize >= size_from_dataruns - clustersize) && (datasize <= size_from_dataruns);
}

int print_deleted_files(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts) {
	if (vol->filesystem() != "NTFS" && vol->filesystem() != "Bitlocker")
	{
		std::cerr << "[!] NTFS/Bitlocker volume required" << std::endl;
		return 1;
	}

	utils::ui::title("Undelete from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << vol->name() << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);

	DWORD cluster_size = ((PBOOT_SECTOR_NTFS)explorer->reader()->boot_record())->bytePerSector * ((PBOOT_SECTOR_NTFS)explorer->reader()->boot_record())->sectorPerCluster;
	DWORD record_size = ((PBOOT_SECTOR_NTFS)explorer->reader()->boot_record())->clusterPerRecord >= 0 ? ((PBOOT_SECTOR_NTFS)explorer->reader()->boot_record())->clusterPerRecord * cluster_size : 1 << -((PBOOT_SECTOR_NTFS)explorer->reader()->boot_record())->clusterPerRecord;

	std::shared_ptr<MFTRecord> record = explorer->mft()->record_from_number(0);
	ULONG64 total_size = record->datasize();

	std::cout << "[-] $MFT size     :" << utils::format::size(total_size) << " (~" << std::to_string(total_size / record_size) << " records)" << std::endl;

	std::shared_ptr<MFTRecord> bitmap_record = explorer->mft()->record_from_number(6);

	std::cout << "[-] $BITMAP size  :" << utils::format::size(bitmap_record->datasize()) << std::endl;

	std::shared_ptr<Buffer<PBYTE>> bitmap = bitmap_record->data();

	std::cout << "[+] Searching deleted files" << std::endl;

	std::vector<std::tuple<DWORD, bool, ULONG64, SYSTEMTIME, double>> deleted_files;
	std::map<DWORD, std::string> index_to_name;
	std::map<DWORD, DWORD> index_to_parent;

	const auto& prof_start = std::chrono::high_resolution_clock::now();

	ULONG64 processed_count = 0;
	for (auto& block : record->process_data())
	{
		DWORD offset = 0;
		for (offset = 0; offset <= block.second - record_size; offset += record_size)
		{
			PMFT_RECORD_HEADER pmrh = POINTER_ADD(PMFT_RECORD_HEADER, block.first, offset);
			if (valid_record(pmrh))
			{
				std::shared_ptr<MFTRecord> f = explorer->mft()->record_from_number(pmrh->MFTRecordIndex);

				std::wstring name;
				DWORD parent = 5;
				SYSTEMTIME st = { 0 };

				PMFT_RECORD_ATTRIBUTE_HEADER pattr = f->attribute_header($FILE_NAME, "");
				if (pattr != nullptr)
				{
					auto pattr_filename = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_FILENAME, pattr, pattr->Form.Resident.ValueOffset);
					if (pattr_filename->NameType == 2)
					{
						PMFT_RECORD_ATTRIBUTE_HEADER pattr_long = f->attribute_header($FILE_NAME, "", 1);
						if (pattr_long != nullptr)
						{
							pattr = pattr_long;
						}
					}
				}
				if (pattr != nullptr)
				{
					PMFT_RECORD_ATTRIBUTE_FILENAME psubattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_FILENAME, pattr, pattr->Form.Resident.ValueOffset);
					name = std::wstring(psubattr->Name);
					name.resize(psubattr->NameLength);
					parent = psubattr->ParentDirectory.FileRecordNumber;
				}

				pattr = f->attribute_header($STANDARD_INFORMATION);
				if (pattr != nullptr)
				{
					PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION psubattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION, pattr, pattr->Form.Resident.ValueOffset);
					utils::times::ull_to_local_systemtime(psubattr->MFTTime, &st);
				}

				index_to_name.insert(std::make_pair(pmrh->MFTRecordIndex, utils::strings::to_utf8(name)));
				index_to_parent.insert(std::make_pair(pmrh->MFTRecordIndex, parent));

				if ((pmrh->flag & FILE_RECORD_FLAG_INUSE) == 0)
				{
					double recover_percent = 0.0;
					if ((pmrh->flag & FILE_RECORD_FLAG_DIR) == 0)
					{
						pattr = f->attribute_header($DATA);
						if (pattr != nullptr)
						{
							if (pattr->FormCode == NON_RESIDENT_FORM)
							{
								std::vector<MFT_DATARUN> dataruns = MFTRecord::read_dataruns(pattr);
								if (check_dataruns_still_valid(f->datasize(), cluster_size, dataruns))
								{
									LONGLONG cluster_needed = 0;
									LONGLONG cluster_reused = 0;

									for (auto& dt : dataruns)
									{
										cluster_needed += dt.length;
										cluster_reused += check_cluster_used(bitmap, &dt);
									}

									recover_percent = 100.0 * ((double)cluster_needed - (double)cluster_reused) / (double)cluster_needed;
								}
							}
							else
							{
								recover_percent = 100.0;
							}
						}
					}
					deleted_files.push_back(std::tuple<DWORD, bool, ULONG64, SYSTEMTIME, double>(pmrh->MFTRecordIndex, (pmrh->flag & FILE_RECORD_FLAG_DIR), f->datasize(), st, recover_percent));
				}
			}
		}
		processed_count += block.second;
		std::cout << "\r[-] Processed data: " << std::to_string(processed_count) << " (" << std::to_string(100 * processed_count / total_size) << "%)";
	}
	std::cout << std::endl;

	std::cout << "[-] Duration      : " << std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now() - prof_start).count() / 1000 << "ms" << std::endl;

	std::cout << "[+] Deleted Files : " << deleted_files.size() << std::endl;

	if (deleted_files.size() > 0)
	{
		std::cout << std::endl;

		std::shared_ptr<utils::ui::Table> df_table = std::make_shared<utils::ui::Table>();
		df_table->set_interline(true);

		df_table->add_header_line("Id");
		df_table->add_header_line("MFT Index");
		df_table->add_header_line("Type");
		df_table->add_header_line("Filename");
		df_table->add_header_line("Size");
		df_table->add_header_line("Deletion Date");
		df_table->add_header_line("% Recoverable");

		ULONG n = 0;
		for (auto& deleted_file : deleted_files)
		{
			df_table->add_item_line(std::to_string(n++));
			df_table->add_item_line(utils::format::hex(std::get<0>(deleted_file)));
			df_table->add_item_line((std::get<1>(deleted_file) ? "Dir" : " "));
			df_table->add_item_line(get_full_path(std::get<0>(deleted_file), index_to_name, index_to_parent));
			df_table->add_item_line((std::get<1>(deleted_file) ? " " : utils::format::size(std::get<2>(deleted_file))));
			df_table->add_item_line(utils::times::display_systemtime(std::get<3>(deleted_file)));

			std::ostringstream percent;
			percent << std::fixed << std::setprecision(2) << std::get<4>(deleted_file);
			df_table->add_item_line(percent.str());
			df_table->new_line();
		}

		df_table->render(std::cout);
		std::cout << std::endl;
	}
	return 0;
}

int extract_deleted_file(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, std::shared_ptr<Options> opts)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("Extract deleted file from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	std::cout << "[+] Opening " << vol->name() << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);

	std::cout << "[+] Reading file record : " << std::to_string(opts->inode) << std::endl;

	std::shared_ptr<MFTRecord> record = explorer->mft()->record_from_number(opts->inode);

	auto pattr = record->attribute_header($FILE_NAME);
	if (pattr != nullptr)
	{
		PMFT_RECORD_ATTRIBUTE_FILENAME psubattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_FILENAME, pattr, pattr->Form.Resident.ValueOffset);
		auto name = std::wstring(psubattr->Name);
		name.resize(psubattr->NameLength);

		std::cout << "[+] Extracting ";
		std::wcout << name;
		std::cout << " to " << opts->output << std::endl;

		std::wstring output(opts->output.begin(), opts->output.end());
		record->data_to_file(output, "", true);

		std::cout << "[+] " << record->datasize() << " bytes written" << std::endl;
	}

	return 0;
}

namespace commands
{
	namespace undelete
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
				if (volume != nullptr)
				{
					if (opts->inode >= 0 && !opts->output.empty())
					{
						extract_deleted_file(disk, volume, opts);
					}
					else
					{
						print_deleted_files(disk, volume, opts);
					}
				}
				else
				{
					invalid_option(opts, "volume", opts->volume);
				}
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_usn.cpp`:

```cpp
#include "Drive/disk.h"
#include "Utils/utils.h"
#include "options.h"
#include "Commands/commands.h"
#include "NTFS/ntfs.h"
#include "NTFS/ntfs_explorer.h"
#include "Utils/constant_names.h"
#include "Utils/table.h"

#include <nlohmann/json.hpp>

#include <cstdint>
#include <string>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>

int print_usn_journal(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol, const std::string& format, std::string output)
{
	if (!commands::helpers::is_ntfs(disk, vol)) return 1;

	std::cout << std::setfill('0');
	utils::ui::title("USN Journals from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	DWORD cluster_size = ((PBOOT_SECTOR_NTFS)vol->bootsector())->bytePerSector * ((PBOOT_SECTOR_NTFS)vol->bootsector())->sectorPerCluster;

	std::cout << "[+] Opening " << vol->name() << std::endl;

	std::shared_ptr<NTFSExplorer> explorer = std::make_shared<NTFSExplorer>(vol);

	std::cout << "[+] Finding $Extend\\$UsnJrnl record" << std::endl;

	std::shared_ptr<MFTRecord> record = explorer->mft()->record_from_path("\\$Extend\\$UsnJrnl");

	if (record == nullptr)
	{
		std::cout << "[!] Not found" << std::endl;
		return 2;
	}

	std::cout << "[+] Found in file record : " << std::to_string(record->header()->MFTRecordIndex) << std::endl;

	PMFT_RECORD_HEADER record_header = record->header();

	Buffer<PBYTE> clusterBuf((DWORD64)2 * 1024 * 1024);
	ULONG64 total_size = record->datasize(MFT_ATTRIBUTE_DATA_USN_NAME, true);

	std::cout << "[+] Virtual $J stream size  : " << utils::format::size(total_size) << " (sparse, ~32MiBs on disk by default)" << std::endl;

	ULONG64 processed_size = 0;
	ULONG64 processed_count = 0;
	ULONG64 filled_size = 0;

	std::cout << "[+] Creating " << output << std::endl;

	HANDLE houtput = CreateFileA(output.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (houtput == INVALID_HANDLE_VALUE)
	{
		std::cout << "[!] Error creating output file" << std::endl;
		return 1;
	}

	if (format == "raw")
	{
		for (auto& block : record->process_data(MFT_ATTRIBUTE_DATA_USN_NAME, 1024 * 1024, true))
		{
			std::cout << "\r[+] Processing data: " << utils::format::size(processed_count) << "     ";
			processed_count += block.second;

			DWORD written = 0;
			WriteFile(houtput, block.first, block.second, &written, NULL);
		}
	}
	else if (format == "csv")
	{
		std::string csv_header = "MajorVersion,MinorVersion,FileReferenceNumber,FileReferenceSequenceNumber,ParentFileReferenceNumber,ParentFileReferenceSequenceNumber,Usn,Timestamp,Reason,SourceInfo,SecurityId,FileAttributes,Filename\n";
		DWORD written = 0;
		DWORD read = 0;
		DWORD header_size = 0;
		if (!FAILED(SizeTToDWord(csv_header.size(), &header_size))) WriteFile(houtput, csv_header.c_str(), header_size, &written, NULL);

		for (auto& block : record->process_data(MFT_ATTRIBUTE_DATA_USN_NAME, cluster_size, true))
		{
			read += block.second;

			memcpy(clusterBuf.data() + filled_size, block.first, block.second);
			filled_size += block.second;

			PUSN_RECORD_COMMON_HEADER header = (PUSN_RECORD_COMMON_HEADER)clusterBuf.data();
			while ((filled_size > 0) && (header->RecordLength <= filled_size))
			{
				switch (header->MajorVersion)
				{
				case 0:
				{
					DWORD i = 0;
					while ((i < filled_size) && (((PBYTE)header)[i] == 0)) i++;
					processed_size += i;
					header = POINTER_ADD(PUSN_RECORD_COMMON_HEADER, header, i);
					filled_size -= i;
					break;
				}
				case 2:
				{
					PUSN_RECORD_V2 usn_record = (PUSN_RECORD_V2)header;
					processed_size += usn_record->RecordLength;
					std::wstring a = std::wstring(usn_record->FileName);
					a.resize(usn_record->FileNameLength / sizeof(WCHAR));

					std::cout << "\r[+] Processing entry: " << std::to_string(++processed_count) << " (" << utils::format::size(read) << ")     ";

					std::ostringstream entry;
					entry << usn_record->MajorVersion << ",";
					entry << usn_record->MinorVersion << ",";
					entry << (usn_record->FileReferenceNumber & 0xffffffffffff) << ",";
					entry << (usn_record->FileReferenceNumber >> 48) << ",";
					entry << (usn_record->ParentFileReferenceNumber & 0xffffffffffff) << ",";
					entry << (usn_record->ParentFileReferenceNumber >> 48) << ",";
					entry << usn_record->Usn << ",";
					SYSTEMTIME st = { 0 };
					utils::times::ull_to_local_systemtime(usn_record->TimeStamp.QuadPart, &st);
					entry << utils::times::display_systemtime(st) << ",";
					entry << constants::disk::usn::reasons(usn_record->Reason) << ",";
					entry << std::to_string(usn_record->SourceInfo) << ",";
					entry << std::to_string(usn_record->SecurityId) << ",";
					entry << constants::disk::usn::fileattributes(usn_record->FileAttributes) << ",";
					entry << utils::strings::to_utf8(a) << std::endl;

					std::string line = entry.str();
					DWORD write_size = 0;
					if (!FAILED(SizeTToDWord(line.size(), &write_size))) WriteFile(houtput, line.c_str(), write_size, &written, NULL);

					filled_size -= usn_record->RecordLength;
					header = POINTER_ADD(PUSN_RECORD_COMMON_HEADER, header, usn_record->RecordLength);
					break;
				}
				default:
					std::cout << std::endl << "[!] Unknown USN record version (" << std::to_string(header->MajorVersion) << ")" << std::endl;
					return 1;
				}
			}

			memcpy(clusterBuf.data(), header, (size_t)filled_size);
		}
	}
	else if (format == "json")
	{
		DWORD written = 0;
		DWORD read = 0;
		WriteFile(houtput, "[\n", 2, &written, NULL);

		for (auto& block : record->process_data(MFT_ATTRIBUTE_DATA_USN_NAME, cluster_size, true))
		{
			read += block.second;

			PUSN_RECORD_COMMON_HEADER header = (PUSN_RECORD_COMMON_HEADER)clusterBuf.data();

			memcpy(clusterBuf.data() + filled_size, block.first, block.second);
			filled_size += block.second;

			while ((filled_size > 0) && (header->RecordLength <= filled_size))
			{
				switch (header->MajorVersion)
				{
				case 0:
				{
					DWORD i = 0;
					while ((i < filled_size) && (((PBYTE)header)[i] == 0)) i++;
					processed_size += i;
					header = POINTER_ADD(PUSN_RECORD_COMMON_HEADER, header, i);
					filled_size -= i;
					break;
				}
				case 2:
				{
					PUSN_RECORD_V2 usn_record = (PUSN_RECORD_V2)header;
					processed_size += usn_record->RecordLength;
					std::wstring a = std::wstring(usn_record->FileName);
					a.resize(usn_record->FileNameLength / sizeof(WCHAR));

					std::cout << "\r[+] Processing entry: " << std::to_string(++processed_count) << " (" << utils::format::size(read) << ")     ";

					nlohmann::json entry;
					entry["MajorVersion"] = usn_record->MajorVersion;
					entry["MinorVersion"] = usn_record->MinorVersion;
					entry["FileReferenceNumber"] = (usn_record->FileReferenceNumber & 0xffffffffffff);
					entry["FileReferenceSequenceNumber"] = (usn_record->FileReferenceNumber >> 48);
					entry["ParentFileReferenceNumber"] = (usn_record->ParentFileReferenceNumber & 0xffffffffffff);
					entry["ParentFileReferenceSequenceNumber"] = (usn_record->ParentFileReferenceNumber >> 48);
					entry["Usn"] = usn_record->Usn;
					SYSTEMTIME st = { 0 };
					utils::times::ull_to_local_systemtime(usn_record->TimeStamp.QuadPart, &st);
					entry["Timestamp"] = utils::times::display_systemtime(st);
					entry["Reasons"] = constants::disk::usn::reasons(usn_record->Reason);
					entry["SourceInfo"] = usn_record->SourceInfo;
					entry["SecurityId"] = usn_record->SecurityId;
					entry["FileAttributes"] = constants::disk::usn::fileattributes(usn_record->FileAttributes);
					entry["FileName"] = utils::strings::to_utf8(a);

					std::string line = entry.dump() + ",\n";
					DWORD line_size = 0;

					if (!FAILED(SizeTToDWord(line.size(), &line_size))) WriteFile(houtput, line.c_str(), line_size, &written, NULL);

					filled_size -= usn_record->RecordLength;
					header = POINTER_ADD(PUSN_RECORD_COMMON_HEADER, header, usn_record->RecordLength);
					break;
				}
				default:
					std::cout << std::endl << "[!] Unknown USN record version (" << std::to_string(header->MajorVersion) << ")" << std::endl;
					return 1;
				}
			}

			memcpy(clusterBuf.data(), header, filled_size);
		}

		WriteFile(houtput, "{}]\n", 2, &written, NULL);
	}
	else
	{
		std::cout << "[!] Invalid or missing format" << std::endl;
	}

	CloseHandle(houtput);
	std::cout << std::endl << "[+] Closing volume" << std::endl;

	return 0;
}

namespace commands
{
	namespace usn
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
				if (volume != nullptr)
				{
					if (opts->output != "")
					{
						if (opts->format == "") opts->format = "raw";

						print_usn_journal(disk, volume, opts->format, opts->output);
					}
					else
					{
						invalid_option(opts, "output", opts->output);
					}
				}
				else
				{
					invalid_option(opts, "volume", opts->volume);
				}
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/command_vbr.cpp`:

```cpp
#include <algorithm>
#include <cstdint>
#include <string>
#include <iostream>
#include <iomanip>
#include <memory>
#include <stdexcept>
#include <distorm.h>

#include "Drive/disk.h"
#include "Drive/vbr.h"
#include "options.h"

#include "NTFS/ntfs.h"
#include "Utils/utils.h"

void print_jump(BYTE jump[3])
{
	UINT32 jmp = jump[0] << 16 | jump[1] << 8 | jump[2];
	std::cout << "        Jump             : " << std::hex << std::setfill('0') << std::setw(6) << jmp;

	_DecodeResult res;
	_DecodedInst decodedInstructions[3] = { 0 };
	unsigned int decodedInstructionsCount = 0;
	_OffsetType offset = 0x7c00;

	res = distorm_decode(offset, jump, 3, Decode16Bits, decodedInstructions, 3, &decodedInstructionsCount);
	if (res != DECRES_INPUTERR)
	{
		std::cout << " (" << utils::strings::lower(std::string((char*)decodedInstructions[0].mnemonic.p)) << " ";
		if (decodedInstructions[0].operands.length != 0)
		{
			std::cout << utils::strings::lower(std::string((char*)decodedInstructions[0].operands.p));
		}
		std::cout << ")";
	}
	std::cout << std::dec << std::endl;
}

void print_boot_code(PBYTE code, int size, _OffsetType offset) {
	std::cout << std::endl;
	if (utils::ui::ask_question("    Disassemble Bootstrap Code"))
	{
		if (size)
		{
			std::cout << std::endl;
			for (std::string& line : utils::disass::buffer(code, size, Decode16Bits, offset))
			{
				std::cout << "        " << line << std::endl;
			}
		}
		else {
			std::cout << "        Empty code" << std::endl;
		}
	}
}

void print_strings(PBYTE code, std::vector<unsigned long> offsets)
{
	std::cout << std::endl << "    Strings:" << std::endl;

	if (std::all_of(offsets.begin(), offsets.end(), [offsets](int x) { return x == 0; }))
	{
		std::cout << "        No strings found" << std::endl;
	}
	else
	{
		for (unsigned int i = 0; i < offsets.size(); i++)
		{
			std::string s = std::string((PCHAR)(&code[offsets[i]]));
			if (i < offsets.size() - 1)
			{
				s.resize(offsets[i + 1] - offsets[i]);
			}
			utils::strings::trim(s);
			utils::strings::replace(s, "\x0d\x0a", "\\n");
			std::cout << "        [" << utils::format::hex((BYTE)(offsets[i] & 0xff), false) << "] : " << utils::strings::str_to_utf8(s, CP_OEMCP) << std::endl;
		}
	}
}

void print_bootsector_ntfs(PBOOT_SECTOR_NTFS pbs)
{
	std::cout << "    Structure:" << std::endl;

	print_jump(pbs->jump);

	std::cout << "        OEM id           : " << std::string((char*)pbs->oemID) << std::endl;
	std::cout << "        BytePerSector    : " << pbs->bytePerSector << std::endl;
	std::cout << "        SectorPerCluster : " << (ULONG)pbs->sectorPerCluster << std::endl;
	std::cout << "        Reserved Sectors : " << pbs->reserved << std::endl;
	std::cout << "        Media descriptor : " << (ULONG)pbs->mediaDescriptor << std::endl;
	std::cout << "        SectorPerTrack   : " << pbs->sectorPerTrack << std::endl;
	std::cout << "        Head number      : " << pbs->headNumber << std::endl;
	std::cout << "        Hidden sector    : " << pbs->hiddenSector << std::endl;
	std::cout << "        Total sector     : " << pbs->totalSector << std::endl;
	std::cout << "        MFT cluster      : " << pbs->MFTCluster << std::endl;
	std::cout << "        MFT Mirr cluster : " << pbs->MFTMirrCluster << std::endl;
	std::cout << "        ClusterPerRecord : " << (int)pbs->clusterPerRecord << std::endl;
	std::cout << "        ClusterPerBlock  : " << (int)pbs->clusterPerBlock << std::endl;
	std::cout << "        Serial number    : " << std::hex << std::setfill('0') << std::setw(16) << pbs->serialNumber << std::endl;
	std::cout << "        Checksum         : " << std::hex << std::setfill('0') << std::setw(8) << pbs->checkSum << std::endl;
	std::cout << "        End marker       : " << std::hex << std::setfill('0') << std::setw(2) << (ULONG)pbs->endMarker[0] << (ULONG)pbs->endMarker[1] << std::endl;

	std::vector<unsigned long> string_offsets;
	std::string os = utils::os::short_version();
	if (os == "8" || os == "10")
	{
		for (int i = 0; i < 4; i++)
		{
			WORD offset = ((PWORD)((PBYTE)pbs + 0x1f6))[i];
			if (offset)	string_offsets.push_back(offset);
		}
	}
	else
	{
		for (int i = 0; i < 4; i++)
		{
			BYTE offset = (((PBYTE)(pbs)) + 0x1f8)[i];
			if (offset)	string_offsets.push_back((offset & 0xff) + 0x100);
		}
	}

	print_strings((PBYTE)pbs, string_offsets);

	unsigned int size_to_disass = min(*std::min_element(string_offsets.begin(), string_offsets.end()), 0x1f6);
	while (((PBYTE)pbs)[size_to_disass - 1] == 0 && size_to_disass > 0)
	{
		size_to_disass--;
	}

	print_boot_code(pbs->bootCode, size_to_disass, 0x7c54);
}

void print_bootsector_fat32(PBOOT_SECTOR_FAT32 pbs)
{
	std::cout << "    Structure :" << std::endl;

	print_jump(pbs->jump);

	std::cout << "        OEM id           : " << std::string((char*)pbs->oemID) << std::endl;
	std::cout << "        BytePerSector    : " << pbs->bytePerSector << std::endl;
	std::cout << "        SectorPerCluster : " << (ULONG)pbs->sectorPerCluster << std::endl;
	std::cout << "        Reserved Sectors : " << pbs->reserved0 << std::endl;
	std::cout << "        Number of FATs   : " << (ULONG)pbs->fatCount << std::endl;
	std::cout << "        Root Max Entries : " << pbs->rootMaxEntries << std::endl;
	std::cout << "        Total Sectors    : " << (pbs->totalSectorsSmall == 0 ? pbs->totalSectors : pbs->totalSectorsSmall) << std::endl;
	std::cout << "        Media Type       : " << utils::format::hex(pbs->mediaType, 1) << std::endl;
	std::cout << "        SectorPerFat     : " << (pbs->sectorsPerFatSmall == 0 ? pbs->sectorsPerFat : pbs->sectorsPerFatSmall) << std::endl;
	std::cout << "        SectorPerTrack   : " << pbs->sectorsPerTrack << std::endl;
	std::cout << "        Head Count       : " << pbs->headCount << std::endl;
	std::cout << "        FS Offset        : " << pbs->fsOffset << std::endl;
	std::cout << "        Total Sectors    : " << pbs->totalSectors << std::endl;
	std::cout << "        FAT Flags        : " << utils::format::hex(pbs->fatFlags) << std::endl;
	std::cout << "        FAT Version      : " << utils::format::hex(pbs->version) << std::endl;
	std::cout << "        Root Cluster     : " << pbs->rootCluster << std::endl;
	std::cout << "        FS Info Sector   : " << pbs->fsInfoSector << std::endl;
	std::cout << "        Backup BootSector: " << pbs->backupSector << std::endl;
	std::cout << "        Reserved         : " << utils::format::hex(pbs->reserved1[0]) << std::endl;
	std::cout << "        Reserved         : " << utils::format::hex(pbs->reserved1[1]) << std::endl;
	std::cout << "        Reserved         : " << utils::format::hex(pbs->reserved1[2]) << std::endl;
	std::cout << "        Drive Number     : " << utils::format::hex(pbs->driveNumber) << std::endl;
	std::cout << "        Reserved         : " << utils::format::hex(pbs->reserved2) << std::endl;
	std::cout << "        Ext. Boot Sign   : " << utils::format::hex(pbs->extSig) << std::endl;
	std::cout << "        Serial Number    : " << utils::format::hex(pbs->volumeSerialNumber) << std::endl;
	std::string s = std::string((char*)pbs->label);
	s.resize(11);
	std::cout << "        Volume Name      : " << s << std::endl;
	s = std::string((char*)pbs->fsName);
	s.resize(8);
	std::cout << "        FileSystem Type  : " << s << std::endl;
	std::cout << "        End marker       : " << utils::format::hex(pbs->endMarker, 2) << std::endl;

	std::vector<unsigned long> string_offsets;
	for (int i = 0; i < 3; i++)
	{
		WORD offset = ((PWORD)(((PBYTE)pbs) + 0x1f8))[i];
		if (offset)	string_offsets.push_back(offset);
	}

	print_strings((PBYTE)pbs, string_offsets);

	unsigned int size_to_disass = min(*std::min_element(string_offsets.begin(), string_offsets.end()), 0x1f8);
	while (((PBYTE)pbs)[size_to_disass - 1] == 0 && size_to_disass > 0)
	{
		size_to_disass--;
	}

	print_boot_code((PBYTE)pbs, size_to_disass, 0x7c5a);
}

void print_bootsector_fat1x(PBOOT_SECTOR_FAT1X pbs)
{
	std::cout << "    Structure:" << std::endl;

	print_jump(pbs->jump);

	std::cout << "        OEM id           : " << std::string((char*)pbs->oemID) << std::endl;
	std::cout << "        BytePerSector    : " << pbs->bytesPerSector << std::endl;
	std::cout << "        SectorPerCluster : " << (ULONG)pbs->sectorsPerCluster << std::endl;
	std::cout << "        Reserved Sectors : " << pbs->reservedSectorCount << std::endl;
	std::cout << "        Number of FATs   : " << (ULONG)pbs->fatCount << std::endl;
	std::cout << "        Root Max Entries : " << pbs->rootDirEntryCount << std::endl;
	std::cout << "        Total Sectors    : " << (pbs->totalSectors16 == 0 ? pbs->totalSectors32 : pbs->totalSectors16) << std::endl;
	std::cout << "        Media Type       : " << utils::format::hex(pbs->mediaType) << std::endl;
	std::cout << "        SectorPerFat     : " << pbs->sectorsPerFat16 << std::endl;
	std::cout << "        SectorPerTrack   : " << pbs->sectorsPerTrack << std::endl;
	std::cout << "        Head Count       : " << pbs->headCount << std::endl;
	std::cout << "        Hidden Sectors   : " << pbs->hidddenSectors << std::endl;
	std::cout << "        Total Sectors    : " << pbs->totalSectors32 << std::endl;
	std::cout << "        Drive Number     : " << (ULONG)pbs->driveNumber << std::endl;
	std::cout << "        Reserved         : " << utils::format::hex(pbs->reserved1) << std::endl;
	std::cout << "        Ext. Boot Sign   : " << utils::format::hex(pbs->extSig) << std::endl;
	std::cout << "        Serial Number    : " << utils::format::hex(pbs->volumeSerialNumber) << std::endl;
	std::string s = std::string((char*)pbs->label);
	s.resize(11);
	std::cout << "        Volume Name      : " << s << std::endl;
	s = std::string((char*)pbs->fsName);
	s.resize(8);
	std::cout << "        FileSystem Type  : " << s << std::endl;
	std::cout << "        End marker       : " << utils::format::hex(pbs->endMarker, 2) << std::endl;

	std::vector<unsigned long> string_offsets;
	for (int i = 0; i < 3; i++)
	{
		WORD offset = (((PBYTE)pbs) + 0x1fb)[i];
		if (offset)	string_offsets.push_back(offset + 0x100);
	}

	print_strings((PBYTE)pbs, string_offsets);

	unsigned int size_to_disass = min(*std::min_element(string_offsets.begin(), string_offsets.end()), 0x1fb);
	while (((PBYTE)pbs)[size_to_disass - 1] == 0 && size_to_disass > 0)
	{
		size_to_disass--;
	}

	print_boot_code((PBYTE)pbs, size_to_disass, 0x7c3e);
}

void print_bootsector_bitlocker(PBOOT_SECTOR_BITLOCKER pbs)
{
	std::cout << "    Structure :" << std::endl;

	print_jump(pbs->jump);

	std::cout << "        OEM id           : " << std::string((char*)pbs->oemID) << std::endl;
	std::cout << "        BytePerSector    : " << pbs->bytePerSector << std::endl;
	std::cout << "        SectorPerCluster : " << (ULONG)pbs->sectorPerCluster << std::endl;
	std::cout << "        Reserved Sectors : " << pbs->reserved0 << std::endl;
	std::cout << "        Number of FATs   : " << (ULONG)pbs->fatCount << std::endl;
	std::cout << "        Root Max Entries : " << pbs->rootMaxEntries << std::endl;
	std::cout << "        Total Sectors    : " << (pbs->totalSectorsSmall == 0 ? pbs->totalSectors : pbs->totalSectorsSmall) << std::endl;
	std::cout << "        Media Type       : " << utils::format::hex(pbs->mediaType) << std::endl;
	std::cout << "        SectorPerFat     : " << (pbs->sectorsPerFatSmall == 0 ? pbs->sectorsPerFat : pbs->sectorsPerFatSmall) << std::endl;
	std::cout << "        SectorPerTrack   : " << pbs->sectorsPerTrack << std::endl;
	std::cout << "        Head Count       : " << pbs->headCount << std::endl;
	std::cout << "        FS Offset        : " << pbs->fsOffset << std::endl;
	std::cout << "        Total Sectors    : " << pbs->totalSectors << std::endl;
	std::cout << "        FAT Flags        : " << utils::format::hex(pbs->fatFlags) << std::endl;
	std::cout << "        FAT Version      : " << utils::format::hex(pbs->version) << std::endl;
	std::cout << "        Root Cluster     : " << pbs->rootCluster << std::endl;
	std::cout << "        FS Info Sector   : " << pbs->fsInfoSector << std::endl;
	std::cout << "        Backup BootSector: " << pbs->backupSector << std::endl;
	std::cout << "        Reserved         : " << utils::format::hex(pbs->reserved1[0]) << std::endl;
	std::cout << "        Reserved         : " << utils::format::hex(pbs->reserved1[1]) << std::endl;
	std::cout << "        Reserved         : " << utils::format::hex(pbs->reserved1[2]) << std::endl;
	std::cout << "        Drive Number     : " << utils::format::hex(pbs->driveNumber) << std::endl;
	std::cout << "        Reserved         : " << utils::format::hex(pbs->reserved2) << std::endl;
	std::cout << "        Ext. Boot Sign   : " << utils::format::hex(pbs->extSig) << std::endl;
	std::cout << "        Serial Number    : " << utils::format::hex(pbs->serial) << std::endl;
	std::string s = std::string((char*)pbs->label);
	s.resize(11);
	std::cout << "        Volume Name      : " << s << std::endl;
	s = std::string((char*)pbs->fsName);
	s.resize(8);
	std::cout << "        FileSystem Type  : " << s << std::endl;
	std::cout << "        Volume GUID      : " << utils::id::guid_to_string(pbs->partitionGUID) << std::endl;
	std::cout << "        FVE Block 1      : " << utils::format::hex(pbs->fveBlockOffset[0]) << std::endl;
	std::cout << "        FVE Block 2      : " << utils::format::hex(pbs->fveBlockOffset[1]) << std::endl;
	std::cout << "        FVE Block 3      : " << utils::format::hex(pbs->fveBlockOffset[2]) << std::endl;
	std::cout << "        End marker       : " << utils::format::hex(pbs->endMarker, 2) << std::endl;

	std::vector<unsigned long> string_offsets;
	for (int i = 0; i < 3; i++)
	{
		BYTE offset = pbs->stringOffsets[i];
		string_offsets.push_back(offset + 0x100);
	}

	print_strings((PBYTE)pbs, string_offsets);

	unsigned int size_to_disass = 0xa0;
	while (((PBYTE)pbs)[size_to_disass - 1] == 0 && size_to_disass > 0)
	{
		size_to_disass--;
	}

	print_boot_code((PBYTE)pbs, size_to_disass, 0x7c5a);
}

void print_bootsector(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol) {
	std::cout << std::setfill('0');
	utils::ui::title("VBR from " + disk->name() + " > Volume:" + std::to_string(vol->index()));

	if (vol->filesystem() == "FAT32") print_bootsector_fat32((PBOOT_SECTOR_FAT32)vol->bootsector());
	else if (vol->filesystem() == "FAT16") print_bootsector_fat1x((PBOOT_SECTOR_FAT1X)vol->bootsector());
	else if (vol->filesystem() == "FAT12") print_bootsector_fat1x((PBOOT_SECTOR_FAT1X)vol->bootsector());
	else if (vol->filesystem() == "NTFS") print_bootsector_ntfs((PBOOT_SECTOR_NTFS)vol->bootsector());
	else if (vol->filesystem() == "Bitlocker") print_bootsector_bitlocker((PBOOT_SECTOR_BITLOCKER)vol->bootsector());
	else
	{
		std::cout << "[!] Unsupported BootSector: " << std::string((PCHAR)((PBOOT_SECTOR_COMMON)vol->bootsector())->oemID) << std::endl;
	}
}

namespace commands
{
	namespace vbr
	{
		int dispatch(std::shared_ptr<Options> opts)
		{
			std::ios_base::fmtflags flag_backup(std::cout.flags());

			std::shared_ptr<Disk> disk = get_disk(opts);
			if (disk != nullptr)
			{
				std::shared_ptr<Volume> volume = disk->volumes(opts->volume);
				if (volume != nullptr)
				{
					print_bootsector(disk, volume);
				}
				else
				{
					invalid_option(opts, "volume", opts->volume);
				}
			}
			else
			{
				invalid_option(opts, "disk", opts->disk);
			}

			std::cout.flags(flag_backup);
			return 0;
		}
	}
}
```

`Sources/Commands/commands.cpp`:

```cpp
#include "Commands/commands.h"

#include "Utils/utils.h"

int commands::helpers::is_ntfs(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol)
{
	if ((vol->filesystem() != "NTFS") && (vol->filesystem() != "Bitlocker"))
	{
		std::cerr << "[!] NTFS volume required" << std::endl;
		return 0;
	}
	return 1;
}

std::shared_ptr<MFTRecord> commands::helpers::find_record(std::shared_ptr<NTFSExplorer> ex, std::shared_ptr<Options> opts)
{
	std::shared_ptr<MFTRecord> rec = nullptr;

	auto [filepath, stream_name] = ::utils::files::split_file_and_stream(opts->from);

	if (opts->from != "")
	{
		rec = ex->mft()->record_from_path(filepath);
		if (rec == nullptr)
		{
			invalid_option(opts, "from", opts->from, "Unable to find file record.");
		}
	}
	else
	{
		rec = ex->mft()->record_from_number(opts->inode);
		if (rec == nullptr)
		{
			invalid_option(opts, "inode", opts->inode, "Unable to find file record.");
		}
	}

	return rec;
}
```

`Sources/Commands/commands.h`:

```h
#pragma once

#include <cstdint>

#include "Utils/utils.h"
#include "NTFS/ntfs_mft.h"
#include "NTFS/ntfs_mft_record.h"
#include "options.h"

#include <memory>

namespace commands {

	namespace helpers
	{
		int is_ntfs(std::shared_ptr<Disk> disk, std::shared_ptr<Volume> vol);

		std::shared_ptr<MFTRecord> find_record(std::shared_ptr<NTFSExplorer> ex, std::shared_ptr<Options> opts);
	}

	namespace info
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace efs
	{
		namespace masterkey
		{
			int dispatch(std::shared_ptr<Options> opts);
		}
		namespace key
		{
			int dispatch(std::shared_ptr<Options> opts);
		}
		namespace certificate
		{
			int dispatch(std::shared_ptr<Options> opts);
		}
		namespace backup
		{
			int dispatch(std::shared_ptr<Options> opts);
		}
		namespace decrypt
		{
			int dispatch(std::shared_ptr<Options> opts);
		}
	}

	namespace mbr
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace smart
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace gpt
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace logfile
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace reparse
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace image {
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace shadow {
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace usn
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace extract
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace shell
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace vbr
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace mft
	{
		namespace record
		{
			int dispatch(std::shared_ptr<Options> opts);
		}

		namespace btree
		{
			int dispatch(std::shared_ptr<Options> opts);
		}

		std::vector<std::string> print_attribute_index_root(PMFT_RECORD_ATTRIBUTE_INDEX_ROOT pAttribute, std::vector<std::shared_ptr<IndexEntry>> entries);

		std::vector<std::string> print_attribute_index_allocation(PMFT_RECORD_ATTRIBUTE_HEADER pIndexAttrHeader, std::shared_ptr<MFTRecord> record, ULONG32 cluster_size, std::vector<std::shared_ptr<IndexEntry>> entries, bool full = false);

		int print_mft_info_details(std::shared_ptr<MFTRecord> record, ULONG32 cluster_size);
	}

	namespace fve
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace bitlocker
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace bitdecrypt
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace help
	{
		void dispatch(std::shared_ptr<Options> opts);
	}

	namespace streams
	{
		int dispatch(std::shared_ptr<Options> opts);
	}

	namespace undelete
	{
		int dispatch(std::shared_ptr<Options> opts);
	}
}
```

`Sources/Compression/lznt1.cpp`:

```cpp
#include "lznt1.h"

#include <Compression/ntdll_defs.h>
#include <Utils/utils.h>

int decompress_lznt1(std::shared_ptr<Buffer<PBYTE>> compressed, std::shared_ptr<Buffer<PBYTE>> decompressed, PDWORD final_size)
{
	_RtlDecompressBuffer RtlDecompressBuffer = nullptr;

	utils::dll::ntdll::load_compression_functions(&RtlDecompressBuffer, nullptr, nullptr);

	if (!RtlDecompressBuffer)
	{
		return 1;
	}

	*final_size = 0;
	NTSTATUS status;
	if (status = RtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, decompressed->data(), decompressed->size(), compressed->data(), compressed->size(), final_size))
	{
		return 2;
	}

	if (*final_size == 0)
	{
		return 3;
	}

	return 0;
}

```

`Sources/Compression/lznt1.h`:

```h
#pragma once

#include <memory>
#include "Utils/buffer.h"

int decompress_lznt1(std::shared_ptr<Buffer<PBYTE>> compressed, std::shared_ptr<Buffer<PBYTE>> decompressed, PDWORD final_size);
```

`Sources/Compression/lzx.cpp`:

```cpp
#include "lzx.h"
#include <Compression/ntdll_defs.h>
#include <Utils/utils.h>

static bool parse_chunk_table(std::shared_ptr<Buffer<PBYTE>> compressed, DWORD windows_size, PBYTE* data_start, std::vector<DWORD>& chunks_sizes)
{
	chunks_sizes.clear();
	DWORD last_chunk_offset = 0;
	DWORD current_chunk_offset = 1;
	DWORD chunk_index = 0;
	int64_t remaining_bytes = compressed->size();

	while (remaining_bytes > 0)
	{
		current_chunk_offset = compressed->read_at<DWORD>(sizeof(DWORD) * chunk_index++);
		if (current_chunk_offset < last_chunk_offset || current_chunk_offset > compressed->size() || (current_chunk_offset - last_chunk_offset) > windows_size)
		{
			break;
		}
		else
		{
			chunks_sizes.push_back(current_chunk_offset - last_chunk_offset);
			last_chunk_offset = current_chunk_offset;
			remaining_bytes -= sizeof(DWORD) + (current_chunk_offset - last_chunk_offset);
		}
	}

	if (data_start)
	{
		*data_start = POINTER_ADD(PBYTE, compressed->data(), sizeof(DWORD) * chunks_sizes.size());
	}

	return true;
}

int decompress_lzx(std::shared_ptr<Buffer<PBYTE>> compressed, std::shared_ptr<Buffer<PBYTE>> decompressed, DWORD windows_size)
{
	std::vector<DWORD> chunks_sizes;
	PBYTE decompressed_data = decompressed->data();
	PBYTE compressed_data = nullptr;

	if (parse_chunk_table(compressed, windows_size, &compressed_data, chunks_sizes))
	{
		memcpy_s(decompressed->data(), decompressed->size(), decompressed->data(), decompressed->size());
		std::cout << "[!] LZX compressed files is not supported yet" << std::endl;
	}

	return 0;
}

```

`Sources/Compression/lzx.h`:

```h
#pragma once

#include <memory>
#include "Utils/buffer.h"

int decompress_lzx(std::shared_ptr<Buffer<PBYTE>> compressed, std::shared_ptr<Buffer<PBYTE>> decompressed, DWORD windows_size);
```

`Sources/Compression/ntdll_defs.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>

typedef NTSTATUS(__stdcall* _RtlGetCompressionWorkSpaceSize)(
	USHORT CompressionFormatAndEngine,
	PULONG CompressBufferWorkSpaceSize,
	PULONG CompressFragmentWorkSpaceSize
	);

typedef NTSTATUS(__stdcall* _RtlDecompressBuffer)(
	USHORT CompressionFormat,
	PUCHAR UncompressedBuffer,
	ULONG UncompressedBufferSize,
	PUCHAR CompressedBuffer,
	ULONG CompressedBufferSize,
	PULONG FinalUncompressedSize
	);

typedef NTSTATUS(__stdcall* _RtlDecompressBufferEx)(
	USHORT CompressionFormat,
	PUCHAR UncompressedBuffer,
	ULONG UncompressedBufferSize,
	PUCHAR CompressedBuffer,
	ULONG CompressedBufferSize,
	PULONG FinalUncompressedSize,
	PVOID  WorkSpace
	);

typedef NTSTATUS(__stdcall* _RtlGetCompressionWorkSpaceSize)(
	USHORT CompressionFormatAndEngine,
	PULONG CompressBufferWorkSpaceSize,
	PULONG CompressFragmentWorkSpaceSize
	);

typedef NTSTATUS(__stdcall* _RtlDecompressFragment)(
	USHORT CompressionFormat,
	PUCHAR UncompressedFragment,
	ULONG  UncompressedFragmentSize,
	PUCHAR CompressedBuffer,
	ULONG  CompressedBufferSize,
	ULONG  FragmentOffset,
	PULONG FinalUncompressedSize,
	PVOID  WorkSpace
	);



```

`Sources/Compression/xpress.cpp`:

```cpp
#include "xpress.h"
#include <Compression/ntdll_defs.h>
#include <Utils/utils.h>

static bool parse_chunk_table(std::shared_ptr<Buffer<PBYTE>> compressed, DWORD windows_size, PBYTE* data_start, std::vector<DWORD>& chunks_sizes)
{
	chunks_sizes.clear();
	DWORD last_chunk_offset = 0;
	DWORD current_chunk_offset = 1;
	DWORD chunk_index = 0;
	int64_t remaining_bytes = compressed->size();

	while (remaining_bytes > 0)
	{
		current_chunk_offset = compressed->read_at<DWORD>(sizeof(DWORD) * chunk_index++);
		if (current_chunk_offset < last_chunk_offset || current_chunk_offset > compressed->size() || (current_chunk_offset - last_chunk_offset) > windows_size)
		{
			break;
		}
		else
		{
			chunks_sizes.push_back(current_chunk_offset - last_chunk_offset);
			last_chunk_offset = current_chunk_offset;
			remaining_bytes -= sizeof(DWORD) + (current_chunk_offset - last_chunk_offset);
		}
	}

	if (data_start)
	{
		*data_start = POINTER_ADD(PBYTE, compressed->data(), sizeof(DWORD) * chunks_sizes.size());
	}

	return true;
}


int decompress_xpress(std::shared_ptr<Buffer<PBYTE>> compressed, std::shared_ptr<Buffer<PBYTE>> decompressed, DWORD windows_size, DWORD final_size)
{
	_RtlDecompressBufferEx RtlDecompressBufferEx = nullptr;
	_RtlGetCompressionWorkSpaceSize RtlGetCompressionWorkSpaceSize = nullptr;

	utils::dll::ntdll::load_compression_functions(nullptr, &RtlDecompressBufferEx, &RtlGetCompressionWorkSpaceSize);

	if (!RtlDecompressBufferEx || !RtlGetCompressionWorkSpaceSize)
	{
		return 1;
	}

	ULONG comp_block = 0, comp_frag = 0;
	RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_XPRESS_HUFF, &comp_block, &comp_frag);
	std::shared_ptr<Buffer<LPVOID>> workspace = std::make_shared<Buffer<LPVOID>>(comp_block);

	std::vector<DWORD> chunks_sizes;
	PBYTE decompressed_data = decompressed->data();
	PBYTE compressed_data = nullptr;

	if (parse_chunk_table(compressed, windows_size, &compressed_data, chunks_sizes))
	{
		for (auto& chunk_size : chunks_sizes)
		{
			NTSTATUS status;
			ULONG chunk_final_size = 0;
			if (status = RtlDecompressBufferEx(COMPRESSION_FORMAT_XPRESS_HUFF, decompressed_data, windows_size, compressed_data, chunk_size, &chunk_final_size, workspace->data()))
			{
				return 2;
			}
			else
			{
				decompressed_data = POINTER_ADD(PBYTE, decompressed_data, chunk_final_size);
				compressed_data = POINTER_ADD(PBYTE, compressed_data, chunk_size);
			}
		}

		DWORD remaining_chunk_size = compressed->size() - static_cast<DWORD>(compressed_data - compressed->address());
		if (remaining_chunk_size)
		{
			ULONG chunk_final_size = 0;
			RtlDecompressBufferEx(COMPRESSION_FORMAT_XPRESS_HUFF, decompressed_data, windows_size, compressed_data, remaining_chunk_size, &chunk_final_size, workspace->data());
		}
	}

	if (decompressed->size() > final_size)
	{
		decompressed->shrink(final_size);
	}

	return 0;
}

```

`Sources/Compression/xpress.h`:

```h
#pragma once

#include <memory>
#include "Utils/buffer.h"

int decompress_xpress(std::shared_ptr<Buffer<PBYTE>> compressed, std::shared_ptr<Buffer<PBYTE>> decompressed, DWORD windows_size, DWORD final_size);
```

`Sources/Drive/disk.cpp`:

```cpp
#include "disk.h"
#include "virtual_disk.h"
#include "volume.h"
#include "Utils/buffer.h"
#include "Utils/utils.h"
#include "Utils/constant_names.h"

#include <iostream>

std::shared_ptr<Disk> try_add_disk(int i)
{
	wchar_t diskname[MAX_PATH];
	_swprintf_p(diskname, MAX_PATH, L"\\\\.\\PhysicalDrive%d", i);

	HANDLE hDisk = CreateFileW(diskname, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if (hDisk != INVALID_HANDLE_VALUE)
	{
		std::shared_ptr<Disk> d = std::make_shared<Disk>(hDisk, i);
		CloseHandle(hDisk);
		return d;
	}
	return nullptr;
}

namespace core
{
	namespace win
	{
		namespace disks
		{
			std::vector<std::shared_ptr<Disk>> list()
			{
				std::vector<std::shared_ptr<Disk>> disks;
				int i = 0;
				for (i = 0; ; i++)
				{
					std::shared_ptr<Disk> d = try_add_disk(i);
					if (d != nullptr) disks.push_back(d);
					else break;
				}
				int check_more_disk = i + 5;
				for (i = i + 1; i < check_more_disk; i++)
				{
					std::shared_ptr<Disk> d = try_add_disk(i);
					if (d != nullptr) disks.push_back(d);
					else break;
				}

				i = static_cast<int>(disks.size());
				for (auto virtual_disk : core::win::virtualdisk::list())
				{
					virtual_disk->set_index(i++);
					disks.push_back(virtual_disk);
				}

				return disks;
			}

			std::shared_ptr<Disk> by_index(DWORD index)
			{
				std::vector<std::shared_ptr<Disk>> disks = list();
				if (index < disks.size())
				{
					return disks[index];
				}
				return nullptr;
			}

			std::shared_ptr<Disk> from_image(std::string filename)
			{
				HANDLE hDisk = CreateFileW(utils::strings::from_string(filename).c_str(), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
				if (hDisk != INVALID_HANDLE_VALUE)
				{
					std::shared_ptr<Disk> d = std::make_shared<Disk>(hDisk, filename);
					CloseHandle(hDisk);
					return d;
				}
				return nullptr;
			}
		}
	}
}

chs add_chs(chs& a, chs& b)
{
	chs r = { 0 };
	r.cylinder = a.cylinder + b.cylinder;
	r.head = a.head + b.head;
	r.sector = a.sector + b.sector;
	return r;
}

void Disk::_get_mbr(HANDLE h)
{
	DWORD ior = 0;
	_protective_mbr = false;
	_partition_type = PARTITION_STYLE_RAW;

	LARGE_INTEGER pos = { 0 };
	LARGE_INTEGER result = { 0 };
	SetFilePointerEx(h, pos, &result, SEEK_SET);

	if (ReadFile(h, &_mbr, sizeof(MBR), &ior, NULL))
	{
		int n_partitions = 0;
		for (int i = 0; i < 4; i++)
		{
			if (_mbr.partition[i].partition_type != PARTITION_ENTRY_UNUSED) n_partitions++;
		}

		if (n_partitions) _partition_type = PARTITION_STYLE_MBR;

		_protective_mbr = (n_partitions == 1) && (_mbr.partition[0].partition_type == PARTITION_EDI_HEADER);
		if (_protective_mbr) _partition_type = PARTITION_STYLE_GPT;

		for (int i = 0; i < 4; i++) {
			if ((_mbr.partition[i].partition_type == PARTITION_EXTENDED) || (_mbr.partition[i].partition_type == PARTITION_XINT13_EXTENDED))
			{
				EBR curr_ebr = { 0 };

				uint32_t last_lba = _mbr.partition[i].first_sector_lba;
				chs last_first = _mbr.partition[i].first_sector;
				chs last_last = _mbr.partition[i].last_sector;

				pos.QuadPart = (ULONG64)_mbr.partition[i].first_sector_lba * LOGICAL_SECTOR_SIZE;
				SetFilePointerEx(h, pos, &result, SEEK_SET);
				if (ReadFile(h, &curr_ebr, sizeof(EBR), &ior, NULL))
				{
					while (curr_ebr.mbr_signature == 0xAA55)
					{
						curr_ebr.partition[0].first_sector_lba = last_lba + curr_ebr.partition[0].first_sector_lba;
						curr_ebr.partition[0].first_sector = add_chs(last_first, curr_ebr.partition[0].first_sector);
						curr_ebr.partition[0].last_sector = add_chs(last_last, curr_ebr.partition[0].last_sector);

						last_lba = _mbr.partition[i].first_sector_lba + curr_ebr.partition[1].first_sector_lba;
						last_first = add_chs(_mbr.partition[i].first_sector, curr_ebr.partition[1].first_sector);
						last_last = add_chs(_mbr.partition[i].first_sector, curr_ebr.partition[1].first_sector);

						_ebrs.push_back(curr_ebr);

						if (curr_ebr.partition[1].first_sector_lba)
						{
							pos.QuadPart = ((ULONG64)_mbr.partition[i].first_sector_lba + (ULONG64)curr_ebr.partition[1].first_sector_lba) * LOGICAL_SECTOR_SIZE;
							SetFilePointerEx(h, pos, &result, SEEK_SET);
							if (!ReadFile(h, &curr_ebr, sizeof(EBR), &ior, NULL))
							{
								break;
							}
						}
						else
						{
							break;
						}
					}
				}
				break;
			}
		}
	}
}

void Disk::_get_gpt(HANDLE h) {
	DWORD ior = 0;
	LARGE_INTEGER pos = { 0 };
	LARGE_INTEGER result = { 0 };

	GPT_HEADER loc_gpt = { 0 };

	if (_protective_mbr)
	{
		pos.QuadPart = (ULONG64)_mbr.partition[0].first_sector_lba * LOGICAL_SECTOR_SIZE;
		SetFilePointerEx(h, pos, &result, SEEK_SET);

		if (ReadFile(h, &loc_gpt, sizeof(GPT_HEADER), &ior, NULL))
		{
			memcpy(&_gpt, &loc_gpt, 512);

			Buffer<PGPT_PARTITION_ENTRY> pentries(LOGICAL_SECTOR_SIZE);
			for (ULONG64 entries_offset = 0; entries_offset < 128; entries_offset += 4)
			{
				pos.QuadPart = 2 * LOGICAL_SECTOR_SIZE + (entries_offset / 4 * LOGICAL_SECTOR_SIZE);
				SetFilePointerEx(h, pos, &result, SEEK_SET);

				if (ReadFile(h, pentries.data(), LOGICAL_SECTOR_SIZE, &ior, NULL))
				{
					PGPT_PARTITION_ENTRY pentry = nullptr;
					for (int i = 0; i < 4; i++)
					{
						pentry = pentries.data() + i;
						if (IsEqualGUID(pentry->PartitionTypeGUID, PARTITION_ENTRY_UNUSED_GUID)) return;
						else _gpt_entries.push_back(*pentry);
					}
				}
				else {
					break;
				}
			}
		}
	}
}

void Disk::_get_info_using_ioctl(HANDLE h)
{
	// Size
	DWORD ior = 0;
	_size = 0;
	if (DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, NULL, 0, &_geometry, sizeof(DISK_GEOMETRY_EX), &ior, NULL))
	{
		_size = _geometry.DiskSize.QuadPart;
	}
	else
	{
		LARGE_INTEGER size;
		if (GetFileSizeEx(h, &size))
		{
			_size = size.QuadPart;
		}
	}

	// SSD?

	_is_ssd = false;
	DWORD bytesReturned = 0;

	STORAGE_PROPERTY_QUERY spq;
	spq.PropertyId = (STORAGE_PROPERTY_ID)StorageDeviceTrimProperty;
	spq.QueryType = PropertyStandardQuery;

	DEVICE_TRIM_DESCRIPTOR dtd = { 0 };
	DeviceIoControl(h, IOCTL_STORAGE_QUERY_PROPERTY, &spq, sizeof(spq), &dtd, sizeof(dtd), &bytesReturned, NULL);

	_is_ssd = (dtd.TrimEnabled == TRUE);

	// Device ID

	DWORD cbBytesReturned = 0;
	std::shared_ptr<Buffer<char*>> buf = std::make_shared<Buffer<char*>>(8192);

	STORAGE_PROPERTY_QUERY query = {};
	query.PropertyId = StorageDeviceProperty;
	query.QueryType = PropertyStandardQuery;

	if (DeviceIoControl(h, IOCTL_STORAGE_QUERY_PROPERTY, &query, sizeof(query), (LPVOID)buf->data(), buf->size(), &cbBytesReturned, NULL))
	{
		PSTORAGE_DEVICE_DESCRIPTOR descrip = (PSTORAGE_DEVICE_DESCRIPTOR)buf->data();
		if (descrip->VendorIdOffset != 0)
		{
			_vendor_id = std::string((char*)(buf->address() + descrip->VendorIdOffset));

			if (_vendor_id.length() > 0) {
				if (_vendor_id.back() == ',') _vendor_id.pop_back();
			}
		}
		if (descrip->ProductIdOffset != 0)
		{
			_product_id = std::string((char*)(buf->address() + descrip->ProductIdOffset));
		}
		if (descrip->ProductRevisionOffset != 0)
		{
			_product_version = std::string((char*)(buf->address() + descrip->ProductRevisionOffset));
		}
		if (descrip->SerialNumberOffset != 0)
		{
			_serial_number = std::string((char*)(buf->address() + descrip->SerialNumberOffset));
			if (_serial_number.length() > 0) {
				if (_serial_number.back() == '.') _serial_number.pop_back();
			}
			utils::strings::trim(_serial_number);
		}
	}
}

void Disk::_get_volumes(HANDLE h) {
	DWORD partitionsSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + 127 * sizeof(PARTITION_INFORMATION_EX);
	Buffer<PDRIVE_LAYOUT_INFORMATION_EX> partitions(partitionsSize);

	DWORD ior = 0;
	if (_index != DISK_INDEX_IMAGE && DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_LAYOUT_EX, NULL, 0, (LPVOID)partitions.data(), partitionsSize, &ior, NULL))
	{
		_partition_type = partitions.data()->PartitionStyle;

		for (int iPart = 0; iPart < int(partitions.data()->PartitionCount); iPart++)
		{
			if (partitions.data()->PartitionEntry[iPart].PartitionLength.QuadPart > 0)
			{
				std::shared_ptr<Volume> v = std::make_shared<Volume>(h, partitions.data()->PartitionEntry[iPart], _index, this);
				if (v->name().length() > 0)
				{
					_volumes.push_back(v);
				}
			}
		}
	}
	else
	{
		PMBR pmbr = mbr();
		int partition_index = 0;
		if (has_protective_mbr())
		{
			auto entries = gpt_entries();
			for (auto& entry : entries)
			{
				PARTITION_INFORMATION_EX pex;
				pex.PartitionStyle = PARTITION_STYLE_GPT;
				pex.PartitionNumber = partition_index++;
				pex.StartingOffset.QuadPart = (LONGLONG)entry.StartingLBA * 512;
				pex.PartitionLength.QuadPart = (LONGLONG)entry.EndingLBA * 512;
				pex.Gpt.PartitionType = entry.PartitionTypeGUID;
				pex.Gpt.PartitionId = entry.UniquePartitionGUID;
				std::shared_ptr<Volume> v = std::make_shared<Volume>(h, pex, _index, this);
				_volumes.push_back(v);
			}
		}
		else
		{
			for (int i = 0; i < 4; i++) {
				if (pmbr->partition[i].partition_type != 0)
				{
					PARTITION_INFORMATION_EX pex;
					pex.PartitionStyle = PARTITION_STYLE_MBR;
					pex.PartitionNumber = partition_index++;
					pex.StartingOffset.QuadPart = (LONGLONG)pmbr->partition[i].first_sector_lba * 512;
					pex.PartitionLength.QuadPart = (LONGLONG)pmbr->partition[i].sectors * 512;
					pex.Mbr.BootIndicator = pmbr->partition[i].status == 0x80;
					pex.Mbr.PartitionType = pmbr->partition[i].partition_type;

					if (pex.Mbr.PartitionType == 0xf)
					{
						for (const auto& ebr_entry : _ebrs)
						{
							pex.PartitionNumber = partition_index++;
							pex.StartingOffset.QuadPart = (LONGLONG)ebr_entry.partition[0].first_sector_lba * 512;
							pex.PartitionLength.QuadPart = (LONGLONG)ebr_entry.partition[0].sectors * 512;
							pex.Mbr.BootIndicator = ebr_entry.partition[0].status == 0x80;
							pex.Mbr.PartitionType = ebr_entry.partition[0].partition_type;

							std::shared_ptr<Volume> v = std::make_shared<Volume>(h, pex, _index, this);
							_volumes.push_back(v);
						}
					}
					else
					{
						std::shared_ptr<Volume> v = std::make_shared<Volume>(h, pex, _index, this);
						_volumes.push_back(v);
					}
				}
			}
		}
	}
}

Disk::Disk(HANDLE h, int index)
{
	_index = index;
	_name = "\\\\.\\PhysicalDrive" + std::to_string(index);

	_get_mbr(h);

	_get_gpt(h);

	_get_info_using_ioctl(h);

	_get_volumes(h);
}

Disk::Disk(HANDLE h, std::string filename)
{
	_index = DISK_INDEX_IMAGE;
	_name = filename;

	_get_mbr(h);

	_get_gpt(h);

	_get_info_using_ioctl(h);

	_get_volumes(h);
}

std::shared_ptr<Volume> Disk::volumes(DWORD index) const
{
	std::shared_ptr<Volume> volume = nullptr;
	for (unsigned int i = 0; i < _volumes.size(); i++)
	{
		std::shared_ptr<Volume> v = _volumes[i];
		if (v->index() == index)
		{
			volume = v;
			break;
		}
	}
	return volume;
}

HANDLE Disk::open()
{
	wchar_t diskname[MAX_PATH];
	_swprintf_p(diskname, MAX_PATH, L"\\\\.\\PhysicalDrive%d", _index);

	return CreateFileW(diskname, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
}
```

`Sources/Drive/disk.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>

#include <set>
#include <string>
#include <memory>
#include <vector>

#include "volume.h"
#include "Drive/mbr_gpt.h"

#define DISK_INDEX_IMAGE			(-1)

class Disk
{
protected:
	DWORD				_index = DISK_INDEX_IMAGE;
	std::string			_name;
	DWORD64				_size = 0;
	DWORD				_partition_type = PARTITION_STYLE_MBR;
	DISK_GEOMETRY_EX	_geometry = { 0 };

	MBR					_mbr = { 0 };
	std::vector<EBR>	_ebrs;
	bool				_protective_mbr;

	GPT_HEADER			_gpt = { 0 };
	std::vector<GPT_PARTITION_ENTRY> _gpt_entries;

	std::string         _vendor_id;
	std::string         _product_id;
	std::string         _product_version;
	std::string         _serial_number;
	bool				_is_ssd = false;
	std::vector<std::shared_ptr<Volume>>	_volumes;

	void _get_mbr(HANDLE h);

	void _get_gpt(HANDLE h);

	void _get_info_using_ioctl(HANDLE h);

	void _get_volumes(HANDLE h);

public:
	Disk() {};

	Disk(HANDLE h, int index);

	Disk(HANDLE h, std::string filename);

	DWORD index()								const { return _index; };
	void set_index(DWORD index) { _index = index; }
	std::string name()							const { return _name; };
	std::string vendor_id()						const { return _vendor_id; };
	std::string product_id()					const { return _product_id; };
	std::string product_version()				const { return _product_version; };
	std::string serial_number()					const { return _serial_number; };
	bool has_protective_mbr()					const { return _protective_mbr; }
	DWORD64 size()								const { return _size; };
	DWORD partition_type()						const { return _partition_type; };

	PDISK_GEOMETRY_EX geometry() { return &_geometry; }
	PMBR mbr() { return &_mbr; }
	PGPT_HEADER gpt() { return &_gpt; }
	std::vector<GPT_PARTITION_ENTRY> gpt_entries() { return _gpt_entries; }
	std::vector<EBR> ebrs()						const { return _ebrs; }
	bool is_ssd()								const { return _is_ssd; }

	std::vector<std::shared_ptr<Volume>> volumes()			const { return _volumes; };

	std::shared_ptr<Volume> volumes(DWORD index)	const;

	HANDLE open();
};

namespace core
{
	namespace win
	{
		namespace disks
		{
			std::vector<std::shared_ptr<Disk>> list();

			std::shared_ptr<Disk> by_index(DWORD index);

			std::shared_ptr<Disk> from_image(std::string filename);
		}
	}
}
```

`Sources/Drive/mbr_gpt.h`:

```h
#pragma once

#include <WinIoCtl.h>
#include <Ntddscsi.h>
#include <guiddef.h>
#include <Windows.h>

#include <cstdint>

#define LOGICAL_SECTOR_SIZE				0x200

#define kNominalMediaRotRateWordIndex	217

#define PARTITION_ENTRY_UNUSED          0x00
#define PARTITION_FAT_12                0x01
#define PARTITION_XENIX_1               0x02
#define PARTITION_XENIX_2               0x03
#define PARTITION_FAT_16                0x04
#define PARTITION_EXTENDED              0x05
#define PARTITION_HUGE                  0x06
#define PARTITION_IFS                   0x07
#define PARTITION_OS2BOOTMGR            0x0A
#define PARTITION_FAT32                 0x0B
#define PARTITION_FAT32_XINT13          0x0C
#define PARTITION_XINT13                0x0E
#define PARTITION_XINT13_EXTENDED       0x0F
#define PARTITION_PREP                  0x41
#define PARTITION_LDM                   0x42
#define PARTITION_UNIX                  0x63
#define VALID_NTFT                      0xC0
#define PARTITION_NTFT                  0x80
#define PARTITION_EDI_HEADER            0xEE

// General
const GUID PARTITION_ENTRY_UNUSED_GUID = { 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; // 00000000-0000-0000-0000-000000000000
const GUID PARTITION_MBR_SCHEME_GUID = { 0x024DEE41, 0x33E7, 0x11D3, 0x9D, 0x69, 0x00, 0x08, 0xC7, 0x81, 0xF3, 0x9F }; //024DEE41-33E7-11D3-9D69-0008C781F39F
const GUID PARTITION_SYSTEM_GUID = { 0xc12a7328, 0xf81f, 0x11d2, 0xba, 0x4b, 0x00, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b }; //C12A7328-F81F-11D2-BA4B-00A0C93EC93B
const GUID PARTITION_BIOS_BOOT_GUID = { 0x21686148, 0x6449, 0x6E6F, 0x74, 0x4E, 0x65, 0x65, 0x64, 0x45, 0x46, 0x49 }; //21686148-6449-6E6F-744E-656564454649

// Windows
const GUID PARTITION_MSFT_RESERVED_GUID = { 0xe3c9e316, 0x0b5c, 0x4db8, 0x81, 0x7d, 0xf9, 0x2d, 0xf0, 0x02, 0x15, 0xae }; //E3C9E316-0B5C-4DB8-817D-F92DF00215AE
const GUID PARTITION_BASIC_DATA_GUID = { 0xebd0a0a2, 0xb9e5, 0x4433, 0x87, 0xc0, 0x68, 0xb6, 0xb7, 0x26, 0x99, 0xc7 }; //EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 (also used for Linux data)
const GUID PARTITION_LDM_METADATA_GUID = { 0x5808c8aa, 0x7e8f, 0x42e0, 0x85, 0xd2, 0xe1, 0xe9, 0x04, 0x34, 0xcf, 0xb3 }; //5808C8AA-7E8F-42E0-85D2-E1E90434CFB3
const GUID PARTITION_LDM_DATA_GUID = { 0xaf9b60a0, 0x1431, 0x4f62, 0xbc, 0x68, 0x33, 0x11, 0x71, 0x4a, 0x69, 0xad }; //AF9B60A0-1431-4F62-BC68-3311714A69AD
const GUID PARTITION_MSFT_RECOVERY_GUID = { 0xde94bba4, 0x06d1, 0x4d40, 0xa1, 0x6a, 0xbf, 0xd5, 0x01, 0x79, 0xd6, 0xac }; //DE94BBA4-06D1-4D40-A16A-BFD50179D6AC
const GUID PARTITION_IBM_GPFS_GUID = { 0x37AFFC90, 0xEF7D, 0x4E96, 0x91, 0xC3, 0x2D, 0x7A, 0xE0, 0x55, 0xB1, 0x74 }; //37AFFC90-EF7D-4E96-91C3-2D7AE055B174

// HP-UX
const GUID PARTITION_HPUX_DATA_GUID = { 0x75894C1E, 0x3AEB, 0x11D3, 0xB7, 0xC1, 0x7B, 0x03, 0xA0, 0x00, 0x00, 0x00 }; //75894C1E-3AEB-11D3-B7C1-7B03A0000000
const GUID PARTITION_HPUX_SERVICE_GUID = { 0xE2A1E728, 0x32E3, 0x11D6, 0xA6, 0x82, 0x7B, 0x03, 0xA0, 0x00, 0x00, 0x00 }; //E2A1E728-32E3-11D6-A682-7B03A0000000

// Linux
const GUID PARTITION_LINUX_DATA_GUID = { 0xEBD0A0A2, 0xB9E5, 0x4433, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7 }; //EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 (also used for Windows basic data)
const GUID PARTITION_LINUX_RAID_GUID = { 0xA19D880F, 0x05FC, 0x4D3B, 0xA0, 0x06, 0x74, 0x3F, 0x0F, 0x84, 0x91, 0x1E }; //A19D880F-05FC-4D3B-A006-743F0F84911E
const GUID PARTITION_LINUX_SWAP_GUID = { 0x0657FD6D, 0xA4AB, 0x43C4, 0x84, 0xE5, 0x09, 0x33, 0xC8, 0x4B, 0x4F, 0x4F }; //0657FD6D-A4AB-43C4-84E5-0933C84B4F4F
const GUID PARTITION_LINUX_LVM_GUID = { 0xE6D6D379, 0xF507, 0x44C2, 0xA2, 0x3C, 0x23, 0x8F, 0x2A, 0x3D, 0xF9, 0x28 }; //E6D6D379-F507-44C2-A23C-238F2A3DF928
const GUID PARTITION_LINUX_RESERVED_GUID = { 0x8DA63339, 0x0007, 0x60C0, 0xC4, 0x36, 0x08, 0x3A, 0xC8, 0x23, 0x09, 0x08 }; //8DA63339-0007-60C0-C436-083AC8230908

// FreeBSD
const GUID PARTITION_FREEBSD_BOOT_GUID = { 0x83BD6B9D, 0x7F41, 0x11DC, 0xBE, 0x0B, 0x00, 0x15, 0x60, 0xB8, 0x4F, 0x0F }; //83BD6B9D-7F41-11DC-BE0B-001560B84F0F
const GUID PARTITION_FREEBSD_DATA_GUID = { 0x516E7CB4, 0x6ECF, 0x11D6, 0x8F, 0xF8, 0x00, 0x02, 0x2D, 0x09, 0x71, 0x2B }; //516E7CB4-6ECF-11D6-8FF8-00022D09712B
const GUID PARTITION_FREEBSD_SWAP_GUID = { 0x516E7CB5, 0x6ECF, 0x11D6, 0x8F, 0xF8, 0x00, 0x02, 0x2D, 0x09, 0x71, 0x2B }; //516E7CB5-6ECF-11D6-8FF8-00022D09712B
const GUID PARTITION_FREEBSD_UFS_GUID = { 0x516E7CB6, 0x6ECF, 0x11D6, 0x8F, 0xF8, 0x00, 0x02, 0x2D, 0x09, 0x71, 0x2B }; //516E7CB6-6ECF-11D6-8FF8-00022D09712B
const GUID PARTITION_FREEBSD_VINUM_VM_GUID = { 0x516E7CB8, 0x6ECF, 0x11D6, 0x8F, 0xF8, 0x00, 0x02, 0x2D, 0x09, 0x71, 0x2B }; //516E7CB8-6ECF-11D6-8FF8-00022D09712B
const GUID PARTITION_FREEBSD_ZFS_GUID = { 0x516E7CBA, 0x6ECF, 0x11D6, 0x8F, 0xF8, 0x00, 0x02, 0x2D, 0x09, 0x71, 0x2B }; //516E7CBA-6ECF-11D6-8FF8-00022D09712B

// Mac OS X
const GUID PARTITION_APPLE_HFSP_GUID = { 0x48465300, 0x0000, 0x11AA, 0xAA, 0x11, 0x00, 0x30, 0x65, 0x43, 0xEC, 0xAC }; //48465300-0000-11AA-AA11-00306543ECAC
const GUID PARTITION_APPLE_UFS_GUID = { 0x55465300, 0x0000, 0x11AA, 0xAA, 0x11, 0x00, 0x30, 0x65, 0x43, 0xEC, 0xAC }; //55465300-0000-11AA-AA11-00306543ECAC
const GUID PARTITION_APPLE_ZFS_GUID = { 0x6A898CC3, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A898CC3-1DD2-11B2-99A6-080020736631 (from Solaris /usr)
const GUID PARTITION_APPLE_RAID_GUID = { 0x52414944, 0x0000, 0x11AA, 0xAA, 0x11, 0x00, 0x30, 0x65, 0x43, 0xEC, 0xAC }; //52414944-0000-11AA-AA11-00306543ECAC
const GUID PARTITION_APPLE_RAID_OFFLINE_GUID = { 0x52414944, 0x5F4F, 0x11AA, 0xAA, 0x11, 0x00, 0x30, 0x65, 0x43, 0xEC, 0xAC }; //52414944-5F4F-11AA-AA11-00306543ECAC
const GUID PARTITION_APPLE_BOOT_GUID = { 0x426F6F74, 0x0000, 0x11AA, 0xAA, 0x11, 0x00, 0x30, 0x65, 0x43, 0xEC, 0xAC }; //426F6F74-0000-11AA-AA11-00306543ECAC
const GUID PARTITION_APPLE_LABEL_GUID = { 0x4C616265, 0x6C00, 0x11AA, 0xAA, 0x11, 0x00, 0x30, 0x65, 0x43, 0xEC, 0xAC }; //4C616265-6C00-11AA-AA11-00306543ECAC
const GUID PARTITION_APPLE_TV_RECOVERY_GUID = { 0x5265636F, 0x7665, 0x11AA, 0xAA, 0x11, 0x00, 0x30, 0x65, 0x43, 0xEC, 0xAC }; //5265636F-7665-11AA-AA11-00306543ECAC

// Solaris
const GUID PARTITION_SOLARIS_BOOT_GUID = { 0x6A82CB45, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A82CB45-1DD2-11B2-99A6-080020736631
const GUID PARTITION_SOLARIS_ROOT_GUID = { 0x6A85CF4D, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A85CF4D-1DD2-11B2-99A6-080020736631
const GUID PARTITION_SOLARIS_SWAP_GUID = { 0x6A87C46F, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A87C46F-1DD2-11B2-99A6-080020736631
const GUID PARTITION_SOLARIS_BACKUP_GUID = { 0x6A8B642B, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A8B642B-1DD2-11B2-99A6-080020736631
const GUID PARTITION_SOLARIS_USR_GUID = { 0x6A898CC3, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A898CC3-1DD2-11B2-99A6-080020736631 (also used for Mac OS X ZFS)
const GUID PARTITION_SOLARIS_VAR_GUID = { 0x6A8EF2E9, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A8EF2E9-1DD2-11B2-99A6-080020736631
const GUID PARTITION_SOLARIS_HOME_GUID = { 0x6A90BA39, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A90BA39-1DD2-11B2-99A6-080020736631
const GUID PARTITION_SOLARIS_ALTERNATE_GUID = { 0x6A9283A5, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A9283A5-1DD2-11B2-99A6-080020736631
const GUID PARTITION_SOLARIS_RESERVED_1_GUID = { 0x6A945A3B, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A945A3B-1DD2-11B2-99A6-080020736631
const GUID PARTITION_SOLARIS_RESERVED_2_GUID = { 0x6A9630D1, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A9630D1-1DD2-11B2-99A6-080020736631
const GUID PARTITION_SOLARIS_RESERVED_3_GUID = { 0x6A980767, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A980767-1DD2-11B2-99A6-080020736631
const GUID PARTITION_SOLARIS_RESERVED_4_GUID = { 0x6A96237F, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A96237F-1DD2-11B2-99A6-080020736631
const GUID PARTITION_SOLARIS_RESERVED_5_GUID = { 0x6A8D2AC7, 0x1DD2, 0x11B2, 0x99, 0xA6, 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 }; //6A8D2AC7-1DD2-11B2-99A6-080020736631

// NetBSD
const GUID PARTITION_NETBSD_SWAP_GUID = { 0x49F48D32, 0xB10E, 0x11DC, 0xB9, 0x9B, 0x00, 0x19, 0xD1, 0x87, 0x96, 0x48 }; //49F48D32-B10E-11DC-B99B-0019D1879648
const GUID PARTITION_NETBSD_FFS_GUID = { 0x49F48D5A, 0xB10E, 0x11DC, 0xB9, 0x9B, 0x00, 0x19, 0xD1, 0x87, 0x96, 0x48 }; //49F48D5A-B10E-11DC-B99B-0019D1879648
const GUID PARTITION_NETBSD_LFS_GUID = { 0x49F48D82, 0xB10E, 0x11DC, 0xB9, 0x9B, 0x00, 0x19, 0xD1, 0x87, 0x96, 0x48 }; //49F48D82-B10E-11DC-B99B-0019D1879648
const GUID PARTITION_NETBSD_RAID_GUID = { 0x49F48DAA, 0xB10E, 0x11DC, 0xB9, 0x9B, 0x00, 0x19, 0xD1, 0x87, 0x96, 0x48 }; //49F48DAA-B10E-11DC-B99B-0019D1879648
const GUID PARTITION_NETBSD_CONCATENATED_GUID = { 0x2DB519C4, 0xB10F, 0x11DC, 0xB9, 0x9B, 0x00, 0x19, 0xD1, 0x87, 0x96, 0x48 }; //2DB519C4-B10F-11DC-B99B-0019D1879648
const GUID PARTITION_NETBSD_ENCRYPTED_GUID = { 0x2DB519EC, 0xB10F, 0x11DC, 0xB9, 0x9B, 0x00, 0x19, 0xD1, 0x87, 0x96, 0x48 }; //2DB519EC-B10F-11DC-B99B-0019D1879648

// ChromeOS
const GUID PARTITION_CHROME_KERNEL_GUID = { 0xFE3A2A5D, 0x4F32, 0x41A7, 0xB7, 0x25, 0xAC, 0xCC, 0x32, 0x85, 0xA3, 0x09 }; //FE3A2A5D-4F32-41A7-B725-ACCC3285A309
const GUID PARTITION_CHROME_ROOTFS_GUID = { 0x3CB8E202, 0x3B7E, 0x47DD, 0x8A, 0x3C, 0x7F, 0xF2, 0xA1, 0x3C, 0xFC, 0xEC }; //3CB8E202-3B7E-47DD-8A3C-7FF2A13CFCEC
const GUID PARTITION_CHROME_RESERVED_GUID = { 0x2E0A753D, 0x9E48, 0x43B0, 0x83, 0x37, 0xB1, 0x51, 0x92, 0xCB, 0x1B, 0x5E }; //2E0A753D-9E48-43B0-8337-B15192CB1B5E

#pragma pack(push, 1)

struct chs {
	uint8_t head;
	uint8_t sector;
	uint8_t cylinder;
};

struct mbr_partition {
	uint8_t status;
	struct chs first_sector;
	uint8_t partition_type;
	struct chs last_sector;
	uint32_t first_sector_lba;
	uint32_t sectors;
};

typedef struct {
	char code[440];
	uint32_t disk_signature;
	uint16_t reserved;
	struct mbr_partition partition[4];
	uint16_t mbr_signature;
} MBR, * PMBR;

typedef struct {
	char unused[446];
	struct mbr_partition partition[4];
	uint16_t mbr_signature;
} EBR, * PEBR;

typedef uint64_t EFI_LBA;

typedef struct {
	char magic[8];
	uint16_t revision_low;
	uint16_t revision_high;
	uint32_t header_size;
	uint32_t header_crc32;
	uint32_t reserved1;
	uint64_t current_lba;
	uint64_t backup_lba;
	uint64_t first_usable_lba;
	uint64_t last_usable_lba;
	GUID	 disk_guid;
	uint64_t partition_entry_lba;
	uint32_t num_partition_entries;
	uint32_t sizeof_partition_entry;
	uint32_t partition_entry_array_crc32;
	uint8_t reserved2[420];
}  GPT_HEADER, * PGPT_HEADER;

typedef struct {
	GUID		PartitionTypeGUID;
	GUID		UniquePartitionGUID;
	EFI_LBA		StartingLBA;
	EFI_LBA		EndingLBA;
	uint64_t	Attributes;
	WCHAR		PartitionName[36];
} GPT_PARTITION_ENTRY, * PGPT_PARTITION_ENTRY;

struct ATAIdentifyDeviceQuery
{
	ATA_PASS_THROUGH_EX header;
	WORD data[256];
};

#pragma pack(pop)
```

`Sources/Drive/reader.cpp`:

```cpp
#include "reader.h"

Reader::Reader(std::wstring volume_name, DWORD64 volume_offset)
{
	std::wstring valid_name = volume_name;
	if (valid_name.back() == '\\') valid_name.pop_back();
	_handle_disk = CreateFileW(valid_name.c_str(), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (_handle_disk == INVALID_HANDLE_VALUE)
	{
		printf("CreateFile failed");
	}
	else
	{
		_image_volume_offset = volume_offset;

		LARGE_INTEGER result;
		LARGE_INTEGER pos;
		pos.QuadPart = volume_offset;
		SetFilePointerEx(_handle_disk, pos, &result, SEEK_SET);

		DWORD read = 0;
		seek(0);
		if (!ReadFile(_handle_disk, &_boot_record, 0x200, &read, NULL))
		{
			printf("ReadFile on bootsector failed (%08x)\n", static_cast<unsigned int>(GetLastError()));
		}
	}
}

Reader::Reader(const Reader& reader_copy)
{
	_handle_disk = INVALID_HANDLE_VALUE;

	DuplicateHandle(GetCurrentProcess(), reader_copy.handle(), GetCurrentProcess(), &_handle_disk, DUPLICATE_SAME_ACCESS, TRUE, DUPLICATE_SAME_ACCESS);

	memcpy(_boot_record, reader_copy._boot_record, 512);

	_current_position = reader_copy._current_position;
}

Reader& Reader::operator=(const Reader& e)
{
	_handle_disk = e._handle_disk;

	memcpy(_boot_record, e._boot_record, 512);

	_current_position = e._current_position;

	return *this;
}

Reader::~Reader()
{
	if (_handle_disk != INVALID_HANDLE_VALUE)
	{
		CloseHandle(_handle_disk);
	}
}

bool Reader::seek(ULONG64 position)
{
	if (_current_position != position)
	{
		_current_position = position;

		if (_handle_disk != INVALID_HANDLE_VALUE)
		{
			LARGE_INTEGER pos;
			pos.QuadPart = (LONGLONG)position + _image_volume_offset;
			LARGE_INTEGER result;

			return SetFilePointerEx(_handle_disk, pos, &result, SEEK_SET) || pos.QuadPart != result.QuadPart;
		}
		else
		{
			return false;
		}
	}
	return true;
}

bool Reader::read(LPVOID lpBuffer, ULONG32 nNumberOfBytesToRead)
{
	bool ret = false;
	DWORD readBytes = 0;

	if (_handle_disk != INVALID_HANDLE_VALUE)
	{
		ret = ReadFile(_handle_disk, lpBuffer, nNumberOfBytesToRead, &readBytes, NULL);
		_current_position += readBytes;
		return ret;
	}

	return ret;
}
```

`Sources/Drive/reader.h`:

```h
#pragma once

#include <winsock2.h>
#include <Windows.h>

#include <memory>
#include <string>

class Reader {
protected:
	HANDLE _handle_disk = INVALID_HANDLE_VALUE;

	BYTE _boot_record[512] = { 0 };

	DWORD64 _current_position = 0;
	DWORD64 _image_volume_offset = 0;

public:
	explicit Reader(std::wstring volume_name, DWORD64 volume_offset = 0);

	~Reader();

	Reader(const Reader& reader2);

	Reader& operator= (const Reader& e);

	HANDLE handle() const { return _handle_disk; }

	bool seek(ULONG64 position);

	bool read(LPVOID lpBuffer, ULONG32 nNumberOfBytesToRead);
};
```

`Sources/Drive/smart.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>

#define DRIVE_HEAD_REG				0xA0

#define SMART_CYL_LOW_BAD			0xF4
#define SMART_CYL_HI_BAD			0x2C

#define READ_STATUS_BUFFER_SIZE		512
#define READ_IDENTITY_BUFFER_SIZE	512

#pragma pack(push, 1)

typedef struct _IDINFO
{
	USHORT	wGenConfig;
	USHORT	wNumCyls;
	USHORT	wReserved;
	USHORT	wNumHeads;
	USHORT	wBytesPerTrack;
	USHORT	wBytesPerSector;
	USHORT	wNumSectorsPerTrack;
	USHORT	wVendorUnique[3];
	CHAR	sSerialNumber[20];
	USHORT	wBufferType;
	USHORT	wBufferSize;
	USHORT	wECCSize;
	CHAR	sFirmwareRev[8];
	CHAR	sModelNumber[40];
	USHORT	wMoreVendorUnique;
	USHORT	wDoubleWordIO;
	struct {
		USHORT	Reserved : 8;
		USHORT	DMA : 1;
		USHORT	LBA : 1;
		USHORT	DisIORDY : 1;
		USHORT	IORDY : 1;
		USHORT	SoftReset : 1;
		USHORT	Overlap : 1;
		USHORT	Queue : 1;
		USHORT	InlDMA : 1;
	} wCapabilities;
	USHORT	wReserved1;
	USHORT	wPIOTiming;
	USHORT	wDMATiming;
	struct {
		USHORT	CHSNumber : 1;
		USHORT	CycleNumber : 1;
		USHORT	UltraDMA : 1;
		USHORT	Reserved : 13;
	} wFieldValidity;
	USHORT	wNumCurCyls;
	USHORT	wNumCurHeads;
	USHORT	wNumCurSectorsPerTrack;
	DWORD	wCurSectors;
	struct {
		USHORT	CurNumber : 8;
		USHORT	Multi : 1;
		USHORT	Reserved : 7;
	} wMultSectorStuff;
	ULONG	dwTotalSectors;
	USHORT	wSingleWordDMA;
	struct {
		USHORT Mode0 : 1;
		USHORT Mode1 : 1;
		USHORT Mode2 : 1;
		USHORT  Reserved1 : 5;
		USHORT Mode0Sel : 1;
		USHORT Mode1Sel : 1;
		USHORT Mode2Sel : 1;
		USHORT  Reserved2 : 5;
	} wMultiWordDMA;
	struct {
		USHORT	AdvPOIModes : 8;
		USHORT	Reserved : 8;
	} wPIOCapacity;
	USHORT	wMinMultiWordDMACycle;
	USHORT	wRecMultiWordDMACycle;
	USHORT	wMinPIONoFlowCycle;
	USHORT	wMinPOIFlowCycle;
	USHORT	wReserved69[11];
	struct {
		USHORT	Reserved1 : 1;
		USHORT	ATA1 : 1;
		USHORT	ATA2 : 1;
		USHORT	ATA3 : 1;
		USHORT	ATA4 : 1;
		USHORT	ATA5 : 1;
		USHORT	ATA6 : 1;
		USHORT	ATA7 : 1;
		USHORT	ATA8 : 1;
		USHORT	ATA9 : 1;
		USHORT	ATA10 : 1;
		USHORT	ATA11 : 1;
		USHORT	ATA12 : 1;
		USHORT	ATA13 : 1;
		USHORT	ATA14 : 1;
		USHORT	Reserved2 : 1;
	} wMajorVersion;
	USHORT	wMinorVersion;
	USHORT	wReserved82[6];
	struct {
		USHORT	Mode0 : 1;
		USHORT	Mode1 : 1;
		USHORT	Mode2 : 1;
		USHORT	Mode3 : 1;
		USHORT	Mode4 : 1;
		USHORT	Mode5 : 1;
		USHORT	Mode6 : 1;
		USHORT	Mode7 : 1;
		USHORT	Mode0Sel : 1;
		USHORT	Mode1Sel : 1;
		USHORT	Mode2Sel : 1;
		USHORT	Mode3Sel : 1;
		USHORT	Mode4Sel : 1;
		USHORT	Mode5Sel : 1;
		USHORT	Mode6Sel : 1;
		USHORT	Mode7Sel : 1;
	} wUltraDMA;
	USHORT	wReserved89[167];
} IDINFO, * PIDINFO;

typedef struct
{
	BYTE index;
	WORD flags;
	BYTE value;
	BYTE worst;
	union
	{
		DWORD64 rawValue : 32;
		DWORD64 rawValue48 : 48;
	};
} SMART_ATTRIBUTE, * PSMART_ATTRIBUTE;

typedef struct
{
	BYTE attributeIndex;
	BYTE threshold;
	BYTE unused[10];
} SMART_THRESHOLD, * PSMART_THRESHOLD;

typedef struct
{
	DWORD				cBufferSize;
	DRIVERSTATUS		DriverStatus;
	BYTE				reserved[2];
	SMART_ATTRIBUTE		Attributes[1];
} SMART_OUTPUT_ATTRIBUTES, * PSMART_OUTPUT_ATTRIBUTES;

typedef struct
{
	DWORD				cBufferSize;
	DRIVERSTATUS		DriverStatus;
	BYTE				reserved[2];
	SMART_THRESHOLD		Threshold[1];
} SMART_OUTPUT_THRESHOLDS, * PSMART_OUTPUT_THRESHOLDS;

typedef struct
{
	DWORD				cBufferSize;
	DRIVERSTATUS		DriverStatus;
	IDEREGS				Status;
} SMART_OUTPUT_STATUS, * PSMART_OUTPUT_STATUS;

typedef struct
{
	DWORD				cBufferSize;
	DRIVERSTATUS		DriverStatus;
	IDINFO				Identity;
} SMART_OUTPUT_IDENTITY, * PSMART_OUTPUT_IDENTITY;

#pragma pack(pop)
```

`Sources/Drive/vbr.h`:

```h
#pragma once

#include <Windows.h>

#pragma pack(push, 1)

typedef struct _BOOT_SECTOR_COMMON {
	BYTE        jump[3];
	BYTE        oemID[8];
	WORD        bytePerSector;
	BYTE        sectorPerCluster;
	WORD        reserved;
} BOOT_SECTOR_COMMON, * PBOOT_SECTOR_COMMON;

typedef struct _BOOT_SECTOR_BITLOCKER {
	BYTE        jump[3];
	BYTE        oemID[8];
	WORD        bytePerSector;
	BYTE        sectorPerCluster;
	WORD        reserved0;
	BYTE		fatCount;
	WORD		rootMaxEntries;
	WORD		totalSectorsSmall;
	BYTE		mediaType;
	WORD		sectorsPerFatSmall;
	WORD		sectorsPerTrack;
	WORD		headCount;
	DWORD		fsOffset;
	DWORD		totalSectors;
	DWORD		sectorsPerFat;
	WORD		fatFlags;
	WORD		version;
	DWORD		rootCluster;
	WORD		fsInfoSector;
	WORD		backupSector;
	ULONG32		reserved1[3];
	BYTE		driveNumber;
	BYTE		reserved2;
	BYTE		extSig;
	ULONG32		serial;
	CHAR		label[11];
	CHAR		fsName[8];
	CHAR	    bootCode[70];
	GUID		partitionGUID;
	DWORD64		fveBlockOffset[3];
	CHAR	    bootCode2[307];
	BYTE		stringOffsets[3];
	BYTE		endMarker[2];
} BOOT_SECTOR_BITLOCKER, * PBOOT_SECTOR_BITLOCKER;

typedef struct {
	BYTE	jump[3];
	char    oemID[8];
	WORD	bytesPerSector;
	BYTE	sectorsPerCluster;
	WORD	reservedSectorCount;
	BYTE	fatCount;
	WORD	rootDirEntryCount;
	WORD	totalSectors16;
	BYTE	mediaType;
	WORD	sectorsPerFat16;
	WORD	sectorsPerTrack;
	WORD	headCount;
	DWORD	hidddenSectors;
	DWORD	totalSectors32;
	BYTE	driveNumber;
	BYTE	reserved1;
	BYTE	extSig;
	DWORD	volumeSerialNumber;
	char    label[11];
	char    fsName[8];
	BYTE	bootCode[448];
	BYTE	endMarker[2];
} BOOT_SECTOR_FAT1X, * PBOOT_SECTOR_FAT1X;

typedef struct {
	BYTE        jump[3];
	BYTE        oemID[8];
	WORD        bytePerSector;
	BYTE        sectorPerCluster;
	WORD        reserved0;
	BYTE		fatCount;
	WORD		rootMaxEntries;
	WORD		totalSectorsSmall;
	BYTE		mediaType;
	WORD		sectorsPerFatSmall;
	WORD		sectorsPerTrack;
	WORD		headCount;
	DWORD		fsOffset;
	DWORD		totalSectors;
	DWORD		sectorsPerFat;
	WORD		fatFlags;
	WORD		version;
	DWORD		rootCluster;
	WORD		fsInfoSector;
	WORD		backupSector;
	ULONG32		reserved1[3];
	BYTE		driveNumber;
	BYTE		reserved2;
	BYTE		extSig;
	ULONG32		volumeSerialNumber;
	CHAR		label[11];
	CHAR		fsName[8];
	CHAR		bootCode[420];
	BYTE		endMarker[2];
} BOOT_SECTOR_FAT32, * PBOOT_SECTOR_FAT32;

#pragma pack(pop)
```

`Sources/Drive/virtual_disk.cpp`:

```cpp
#include "Drive/virtual_disk.h"


std::vector<std::shared_ptr<Disk>> core::win::virtualdisk::list()
{
	std::vector<std::shared_ptr<Disk>> vdisks;

	DWORD  CharCount = 0;
	size_t Index = 0;
	WCHAR  PathNames[2 * MAX_PATH] = L"";
	WCHAR  DeviceName[MAX_PATH] = L"";
	WCHAR  VolumeName[MAX_PATH] = L"";

	HANDLE FindHandle = FindFirstVolumeW(VolumeName, ARRAYSIZE(VolumeName));

	if (FindHandle != INVALID_HANDLE_VALUE)
	{
		for (;;)
		{
			Index = wcslen(VolumeName) - 1;

			if (VolumeName[0] == L'\\' || VolumeName[1] == L'\\' || VolumeName[2] == L'?' || VolumeName[3] == L'\\' || VolumeName[Index] == L'\\')
			{
				VolumeName[Index] = L'\0';
				if (!QueryDosDeviceW(&VolumeName[4], DeviceName, ARRAYSIZE(DeviceName)))
				{
					break;
				}
				VolumeName[Index] = L'\\';

				if (GetVolumePathNamesForVolumeNameW(VolumeName, PathNames, 2 * MAX_PATH, &CharCount))
				{
					if (!wcsncmp(DeviceName, L"\\Device\\VeraCryptVolume", 23))
					{
						vdisks.push_back(std::make_shared<VirtualDisk>(VirtualDiskType::VeraCrypt, DeviceName, VolumeName));
					}
					else if (!wcsncmp(DeviceName, L"\\Device\\TrueCryptVolume", 23))
					{
						vdisks.push_back(std::make_shared<VirtualDisk>(VirtualDiskType::TrueCrypt, DeviceName, VolumeName));
					}
				}

				if (!FindNextVolumeW(FindHandle, VolumeName, ARRAYSIZE(VolumeName)))
				{
					DWORD Error = GetLastError();

					if (Error != ERROR_NO_MORE_FILES)
					{
						break;
					}
					Error = ERROR_SUCCESS;
					break;
				}
			}
			else
			{
				break;
			}
		}

		FindVolumeClose(FindHandle);
	}

	return vdisks;
}

VirtualDisk::VirtualDisk(VirtualDiskType type, PWCHAR device_name, PWCHAR volume_name)
{
	_partition_type = PARTITION_STYLE_RAW;

	switch (type)
	{
	case VirtualDiskType::VeraCrypt:
	{
		_product_id = "VeraCrypt";
		break;
	}
	case VirtualDiskType::TrueCrypt:
	{
		_product_id = "TrueCrypt";
		break;
	}
	default:
	{
		_product_id = "Unknown";
	}
	}

	size_t volume_name_len = wcslen(volume_name) - 1;
	volume_name[volume_name_len] = L'\0';

	HANDLE hVol = CreateFileW(volume_name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if (hVol != INVALID_HANDLE_VALUE)
	{
		DWORD ior = 0;
		_size = 0;
		if (DeviceIoControl(hVol, IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, NULL, 0, &_geometry, sizeof(DISK_GEOMETRY_EX), &ior, NULL))
		{
			_size = _geometry.DiskSize.QuadPart;
		}

		PARTITION_INFORMATION_EX pex;
		pex.PartitionStyle = PARTITION_STYLE_RAW;
		pex.PartitionNumber = 0;
		pex.StartingOffset.QuadPart = 0;
		pex.PartitionLength.QuadPart = _geometry.DiskSize.QuadPart;

		volume_name[volume_name_len] = L'\\';

		std::shared_ptr<Volume> v = std::make_shared<Volume>(hVol, pex, 0, this, volume_name);
		_volumes.push_back(v);
		CloseHandle(hVol);
	}
}

VirtualDisk::~VirtualDisk()
{
}

```

`Sources/Drive/virtual_disk.h`:

```h
#pragma once

#include "Drive/disk.h"

enum class VirtualDiskType { TrueCrypt, VeraCrypt };

class VirtualDisk : public Disk
{
private:
public:
	VirtualDisk(VirtualDiskType type, PWCHAR device_name, PWCHAR volume_name);
	~VirtualDisk();

};


namespace core
{
	namespace win
	{
		namespace virtualdisk
		{
			std::vector<std::shared_ptr<Disk>> list();
		}
	}
}

```

`Sources/Drive/volume.cpp`:

```cpp
#include "volume.h"
#include "disk.h"
#include "vbr.h"
#include "Utils/utils.h"
#include "Utils/constant_names.h"

namespace core
{
	namespace win
	{
		namespace volumes
		{
			std::vector<std::shared_ptr<Volume>> list()
			{
				std::vector<std::shared_ptr<Volume>> volumes;

				std::vector<std::shared_ptr<Disk>> disks = disks::list();
				for (auto& disk : disks)
				{
					std::vector<std::shared_ptr<Volume>> diskVols = disk->volumes();
					for (auto& diskVol : diskVols)
					{
						volumes.push_back(diskVol);
					}
				}

				return volumes;
			}
		}
	}
}

int roundUp(int numToRound, int multiple)
{
	if (multiple == 0)
		return numToRound;

	int remainder = numToRound % multiple;
	if (remainder == 0)
		return numToRound;

	return numToRound + multiple - remainder;
}

bool findVolumeName(wchar_t* volName, int diskno, long long offs, long long len)
{
	HANDLE vol = FindFirstVolumeW(volName, MAX_PATH);
	bool success = vol != INVALID_HANDLE_VALUE;
	bool found = false;
	while (success && !found)
	{
		volName[wcslen(volName) - 1] = '\0';
		HANDLE volH = CreateFileW(volName, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);
		volName[wcslen(volName)] = '\\';
		if (volH != INVALID_HANDLE_VALUE)
		{
			DWORD bret = sizeof(VOLUME_DISK_EXTENTS) + 256 * sizeof(DISK_EXTENT);
			std::shared_ptr<Buffer<PVOLUME_DISK_EXTENTS>> vde = std::make_shared<Buffer<PVOLUME_DISK_EXTENTS>>(bret);

			if (DeviceIoControl(volH, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, NULL, 0, vde->data(), bret, &bret, NULL))
			{
				for (unsigned i = 0; i < vde->data()->NumberOfDiskExtents; i++)
				{
					if (vde->data()->Extents[i].DiskNumber == diskno &&
						vde->data()->Extents[i].StartingOffset.QuadPart == offs &&
						vde->data()->Extents[i].ExtentLength.QuadPart == len)
					{
						found = true;
						break;
					}
				}
			}

			CloseHandle(volH);
		}

		if (!found)
		{
			success = FindNextVolumeW(vol, volName, MAX_PATH) != 0;
		}
	}

	FindVolumeClose(vol);
	return found;
}

std::shared_ptr<Buffer<PBYTE>> read_fve(HANDLE h, LARGE_INTEGER offset)
{
	DWORD read = 0;
	std::shared_ptr<Buffer<PBYTE>> fve = std::make_shared<Buffer<PBYTE>>(512);
	SetFilePointer(h, offset.LowPart, &offset.HighPart, FILE_BEGIN);
	if (ReadFile(h, fve->data(), fve->size(), &read, NULL))
	{
		DWORD size = ((PFVE_BLOCK_HEADER)fve->data())->size;
		if (((PFVE_BLOCK_HEADER)fve->data())->version == 2) size *= 16;
		size = roundUp(size, 512);
		fve->resize(size);

		SetFilePointer(h, offset.LowPart, &offset.HighPart, FILE_BEGIN);
		if (ReadFile(h, fve->data(), fve->size(), &read, NULL))
		{
			return fve;
		}
	}
	return nullptr;
}

void Volume::_detect_bitlocker(HANDLE h, PARTITION_INFORMATION_EX p)
{
	DWORD read;
	if (h != INVALID_HANDLE_VALUE)
	{
		_bootsector.resize(512);
		SetFilePointer(h, p.StartingOffset.LowPart, &p.StartingOffset.HighPart, FILE_BEGIN);
		if (ReadFile(h, _bootsector.data(), 512, &read, NULL))
		{
			if (std::memcmp(((PBOOT_SECTOR_COMMON)_bootsector.data())->oemID, "-FVE-FS-", 8) == 0) _bitlocker.bitlocked = TRUE;
			if (std::memcmp(((PBOOT_SECTOR_COMMON)_bootsector.data())->oemID, "MSWIN4.1", 8) == 0) _bitlocker.bitlocked = TRUE;

			if (_bitlocker.bitlocked)
			{
				PBOOT_SECTOR_BITLOCKER pbsb = (PBOOT_SECTOR_BITLOCKER)_bootsector.data();

				for (int block_index = 0; block_index < 3; block_index++)
				{
					LARGE_INTEGER fve_pos = p.StartingOffset;
					fve_pos.QuadPart += pbsb->fveBlockOffset[block_index];
					std::shared_ptr<Buffer<PBYTE>> fve = read_fve(h, fve_pos);
					if (fve != nullptr)
					{
						std::memcpy((void*)&_bitlocker.metadata[block_index].block_header, fve->data(), sizeof(FVE_BLOCK_HEADER));
						std::memcpy((void*)&_bitlocker.metadata[block_index].header, fve->data() + sizeof(FVE_BLOCK_HEADER), sizeof(FVE_HEADER));

						DWORD size_to_read = _bitlocker.metadata[block_index].header.size - _bitlocker.metadata[block_index].header.header_size;

						PFVE_ENTRY entry = (PFVE_ENTRY)(fve->data() + sizeof(FVE_BLOCK_HEADER) + sizeof(FVE_HEADER));
						while (size_to_read > 0)
						{
							std::shared_ptr<Buffer<PFVE_ENTRY>> entrybuf = std::make_shared<Buffer<PFVE_ENTRY>>(entry->size);
							std::memcpy(entrybuf->data(), entry, entry->size);
							_bitlocker.metadata[block_index].entries.push_back(entrybuf);
							entrybuf = nullptr;

							size_to_read -= entry->size;
							entry = (PFVE_ENTRY)(((PBYTE)entry) + entry->size);
						}
					}
				}
			}
		}
	}
}

void Volume::_get_info_by_name(PWCHAR volume_name)
{
	_name = utils::strings::to_utf8(volume_name);

	ULARGE_INTEGER li;
	if (GetDiskFreeSpaceExW(volume_name, NULL, NULL, &li)) _free = li.QuadPart;

	wchar_t labelName[MAX_PATH + 1] = { 0 };
	wchar_t fileSystemName[MAX_PATH + 1] = { 0 };
	DWORD serialNumber = 0;
	DWORD maxComponentLen = 0;
	DWORD fileSystemFlags = 0;
	if (GetVolumeInformationW(volume_name, labelName, MAX_PATH + 1, &serialNumber, &maxComponentLen, &fileSystemFlags, fileSystemName, ARRAYSIZE(fileSystemName)))
	{
		_label = utils::strings::to_utf8(labelName);
		_serial_number = serialNumber;
	}

	DWORD charCount = MAX_PATH;
	std::shared_ptr<Buffer<wchar_t*>> mps = std::make_shared<Buffer<wchar_t*>>(charCount);
	if (!GetVolumePathNamesForVolumeNameW(volume_name, mps->data(), charCount, &charCount))
	{
		if (GetLastError() == ERROR_MORE_DATA)
		{
			mps->resize(charCount);
		}
	}

	if (GetVolumePathNamesForVolumeNameW(volume_name, mps->data(), charCount, &charCount))
	{
		wchar_t* letters = (wchar_t*)mps->data();
		size_t i = 0;
		while (letters[i] != NULL)
		{
			_mountpoints.push_back(utils::strings::to_utf8(letters));
			i += wcslen(letters);
		}
	}

	_type = GetDriveTypeW(volume_name);
}

void Volume::_detect_filesystem(PARTITION_INFORMATION_EX p)
{
	if (_filesystem == "")
	{
		_filesystem = "Unknown";

		PBOOT_SECTOR_COMMON pbsc = (PBOOT_SECTOR_COMMON)_bootsector.data();
		if (strncmp((PCHAR)pbsc->oemID, "NTFS", 4) == 0)
		{
			_filesystem = "NTFS";
		}
		else if (strncmp((PCHAR)pbsc->oemID, "-FVE-FS-", 8) == 0)
		{
			_filesystem = "Bitlocker";
		}
		else if (strncmp((PCHAR)pbsc->oemID, "MSDOS5.0", 8) == 0)
		{
			if (strncmp(((PBOOT_SECTOR_FAT32)pbsc)->fsName, "FAT32   ", 8) == 0)
			{
				_filesystem = "FAT32";
			}
			if (strncmp(((PBOOT_SECTOR_FAT1X)pbsc)->fsName, "FAT16   ", 8) == 0)
			{
				_filesystem = "FAT16";
			}
			if (strncmp(((PBOOT_SECTOR_FAT1X)pbsc)->fsName, "FAT12   ", 8) == 0)
			{
				_filesystem = "FAT12";
			}
		}
		else if (_partition_type == PARTITION_STYLE_MBR)
		{
			_filesystem = constants::disk::mbr_type(p.Mbr.PartitionType);
		}
	}
}

Volume::Volume(HANDLE h, PARTITION_INFORMATION_EX p, int index, PVOID parent, PWCHAR name)
{
	_partition_type = p.PartitionStyle;
	_offset = p.StartingOffset.QuadPart;
	_size = p.PartitionLength.QuadPart;
	_index = p.PartitionNumber;
	_serial_number = 0;
	_free = 0;
	_type = 0;
	_bootable = false;
	_bitlocker.bitlocked = false;
	_parent = parent;

	if (_partition_type == PARTITION_STYLE_MBR)
	{
		_bootable = p.Mbr.BootIndicator;
	}
	else
	{
		_bootable = FALSE;
	}

	if (_partition_type == PARTITION_STYLE_GPT)
	{
		_guid_type = constants::disk::gpt_type(p.Gpt.PartitionType);
	}

	if (_partition_type == PARTITION_STYLE_GPT || _partition_type == PARTITION_STYLE_MBR || _partition_type == PARTITION_STYLE_RAW)
	{
		_detect_bitlocker(h, p);

		if (name)
		{
			_get_info_by_name(name);
		}
		else
		{
			wchar_t volumeName[MAX_PATH];
			if (findVolumeName(volumeName, index, _offset, _size))
			{
				_get_info_by_name(volumeName);
			}
		}

		_detect_filesystem(p);
	}
}

DWORD Volume::disk_index()
{
	if (_parent) return reinterpret_cast<Disk*>(_parent)->index(); else return 0;
}
```

`Sources/Drive/volume.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>

#include <vector>
#include <string>
#include <memory>

#include "Bitlocker/bitlocker.h"

#include "Utils/buffer.h"

typedef struct _bitlocker_info
{
	bool bitlocked = false;
	struct
	{
		FVE_BLOCK_HEADER block_header = { 0 };
		FVE_HEADER		 header = { 0 };
		std::vector<std::shared_ptr<Buffer<PFVE_ENTRY>>> entries;
	} metadata[3];
} bitlocker_info;

class Volume
{
	friend class Disk;
private:
	std::string _name;
	std::string _label;
	std::string _filesystem;
	std::vector<std::string> _mountpoints;
	std::string _guid_type;
	DWORD		_serial_number;
	DWORD		_partition_type;
	DWORD		_type;
	DWORD		_index;
	DWORD64		_offset;
	DWORD64		_size;
	DWORD64		_free;
	BOOL		_bootable;
	bitlocker_info	_bitlocker;
	Buffer<PBYTE> _bootsector;

	PVOID _parent = nullptr;

	void _detect_bitlocker(HANDLE h, PARTITION_INFORMATION_EX p);

	void _get_info_by_name(PWCHAR volume_name);

	void _detect_filesystem(PARTITION_INFORMATION_EX p);

public:
	explicit Volume(HANDLE h, PARTITION_INFORMATION_EX p, int index, PVOID parent, PWCHAR name = nullptr);
	std::string name()						const { return _name; }
	std::string label()						const { return _label; }
	std::string filesystem()				const { return _filesystem; }
	std::vector<std::string> mountpoints()	const { return _mountpoints; }
	std::string guid_type()					const { return _guid_type; }
	DWORD serial_number()					const { return _serial_number; }
	DWORD partition_type()					const { return _partition_type; }
	DWORD type()							const { return _type; }
	DWORD index()							const { return _index; }
	DWORD disk_index();
	PVOID parent()							const { return _parent; }
	DWORD64 offset()						const { return _offset; }
	DWORD64 size()							const { return _size; }
	DWORD64 free()							const { return _free; }
	BOOL bootable()							const { return _bootable; }
	bitlocker_info	bitlocker()				const { return _bitlocker; }
	bool is_mounted()						const { return _mountpoints.size() > 0; }
	PBYTE bootsector()						const { return _bootsector.data(); }
};

namespace core
{
	namespace win
	{
		namespace volumes
		{
			std::vector<std::shared_ptr<Volume>> list();
		}
	}
}
```

`Sources/EFS/certificate_file.cpp`:

```cpp
#include "EFS/certificate_file.h"
#include <Utils/utils.h>
#include <Utils/constant_names.h>


#include <openssl/pem.h>

CertificateFile::CertificateFile(PBYTE data, DWORD size)
{
	DER_ELEMENT e;
	unsigned int pos = 0;

	if (size > 2048)
	{
		return;
	}

	while (pos < size - 12)
	{
		memcpy_s(&e, 12, data + pos, 12);
		if (e.Size != 1)
		{
			_fields.clear();
			break;
		}
		_fields.insert(std::pair(e.Type, std::make_shared<Buffer<PBYTE>>(data + pos + 12, e.Size * e.Count)));
		pos += 12 + e.Size * e.Count;
	}

	if (pos == size)
	{
		_loaded = true;

		for (auto element : _fields)
		{
			DWORD prop_id = std::get<0>(element);

			if (prop_id == CERT_KEY_PROV_INFO_PROP_ID)
			{
				PMY_CRYPT_KEY_PROV_INFO info = reinterpret_cast<PMY_CRYPT_KEY_PROV_INFO>(std::get<1>(element)->data());

				_info.container_name = utils::strings::to_utf8(POINTER_ADD(wchar_t*, info, info->ContainerNameOffset));
				_info.provider_name = utils::strings::to_utf8(POINTER_ADD(wchar_t*, info, info->ProvNameOffset));
				_info.provider_type = constants::efs::cert_prop_provider_type(info->ProvType);
				_info.keyspec = constants::efs::cert_prop_keyspec(info->KeySpec);
			}
			else if (prop_id == CERT_FRIENDLY_NAME_PROP_ID)
			{
				_info.friendly_name = utils::strings::to_utf8(reinterpret_cast<wchar_t*>(std::get<1>(element)->data()));
			}
		}
	}
}

int CertificateFile::export_to_PEM(std::string name)
{
	int ret = 1;
	for (auto element : _fields)
	{
		DWORD prop_id = std::get<0>(element);

		if (prop_id == CERT_CERTIFICATE_FILE)
		{
			const unsigned char* bufder = std::get<1>(element)->data();
			X509* x = d2i_X509(NULL, &bufder, std::get<1>(element)->size());
			if (x)
			{
				BIO* out = BIO_new_file((name + ".pem").c_str(), "wb");
				if (out)
				{
					if (!PEM_write_bio_X509(out, x))
					{
						ret = 3;
					}
					else
					{
						ret = 0;
					}
					BIO_free(out);
				}
				else
				{
					ret = 2;
				}
				X509_free(x);
			}
		}
	}
	return ret;
}

X509* CertificateFile::export_to_X509()
{
	for (auto element : _fields)
	{
		DWORD prop_id = std::get<0>(element);

		if (prop_id == CERT_CERTIFICATE_FILE)
		{
			const unsigned char* bufder = std::get<1>(element)->data();
			X509* x = d2i_X509(NULL, &bufder, std::get<1>(element)->size());
			if (x)
			{
				return x;
			}
		}
	}
	return nullptr;
}

std::vector<std::string> CertificateFile::certificate_ossl_description()
{
	std::vector<std::string> ret;

	for (auto element : _fields)
	{
		DWORD prop_id = std::get<0>(element);

		if (prop_id == CERT_CERTIFICATE_FILE)
		{
			const unsigned char* bufder = std::get<1>(element)->data();
			X509* x = d2i_X509(NULL, &bufder, std::get<1>(element)->size());
			if (x)
			{
				BIO* bio = BIO_new(BIO_s_mem());
				if (bio)
				{
					X509_print(bio, x);

					char* pp;
					unsigned int size = BIO_get_mem_data(bio, &pp);
					pp[size] = '\0';
					auto lines = utils::strings::split(pp, '\n');
					lines.erase(lines.begin(), lines.begin() + 1);
					lines.erase(
						std::remove_if(
							lines.begin(),
							lines.end(),
							[](std::string const& s) { return s.size() < 4; }),
						lines.end());
					for (auto& line : lines)
					{
						line = line.substr(4);
					}
					ret = lines;

					BIO_free(bio);
				}
				X509_free(x);
			}
		}
	}

	return ret;
}

std::string CertificateFile::hash()
{
	for (auto element : _fields)
	{
		DWORD prop_id = std::get<0>(element);

		if (prop_id == CERT_HASH_PROP_ID)
		{
			return utils::convert::to_hex(std::get<1>(element)->data(), std::get<1>(element)->size());
		}
	}
	return "";
}

```

`Sources/EFS/certificate_file.h`:

```h
#pragma once
#include <WinSock2.h>
#include <Windows.h>

#include <memory>
#include <map>
#include <vector>

#include <openssl/x509.h>

#include "Utils/buffer.h"

#define CERT_CERTIFICATE_FILE 32
#define CERT_CERTIFICATE_REVOCATION_LIST 33
#define CERT_CERTIFICATE_TRUST_LIST 34
#define CERT_KEY_ID	35

#pragma pack(push, 1)

typedef struct {
	DWORD	Type;
	DWORD	Size;
	DWORD	Count;
	BYTE	Data[1];
} DER_ELEMENT, * PDER_ELEMENT;

typedef struct {
	DWORD	dwParam;
	DWORD	pbDataOffset;
	DWORD	cbData;
	DWORD	dwFlags;
} MY_CRYPT_KEY_PROV_PARAM, * PMY_CRYPT_KEY_PROV_PARAM;

typedef struct {
	DWORD	ContainerNameOffset;
	DWORD	ProvNameOffset;
	DWORD	ProvType;
	DWORD	Flags;
	DWORD	ProvParam;
	DWORD	ProvParamOffset;
	DWORD	KeySpec;
} MY_CRYPT_KEY_PROV_INFO, * PMY_CRYPT_KEY_PROV_INFO;

typedef struct {
	std::string container_name;
	std::string provider_name;
	std::string provider_type;
	std::string keyspec;
	std::string friendly_name;
} MY_CERT_INFO, * PMY_CERT_INFO;

#pragma pack(pop)

class CertificateFile
{
private:
	bool _loaded = false;

	MY_CERT_INFO _info;

	std::map<DWORD, std::shared_ptr<Buffer<PBYTE>>> _fields;

public:
	CertificateFile(PBYTE data, DWORD size);

	bool is_loaded() { return _loaded; }

	std::map<DWORD, std::shared_ptr<Buffer<PBYTE>>> fields() { return _fields; }

	PMY_CERT_INFO info() { return &_info; }

	std::vector<std::string> certificate_ossl_description();

	std::string hash();

	int export_to_PEM(std::string name);

	X509* export_to_X509();
};

```

`Sources/EFS/export_flags.h`:

```h
#pragma once

#include <Windows.h>

class ExportFlags
{
private:
	DWORD _flags = 0;
public:
	ExportFlags(PBYTE data, DWORD size)
	{
		if (data && size >= 4)
		{
			_flags = reinterpret_cast<DWORD*>(data)[0];
		}
	}

	DWORD flags() { return _flags; }
};
```

`Sources/EFS/export_flags_enc.cpp`:

```cpp
#include "EFS/export_flags_enc.h"
#include <openssl/sha.h>

std::shared_ptr<ExportFlags> ExportFlagsEnc::decrypt_with_masterkey(std::shared_ptr<Buffer<PBYTE>> masterkey)
{
	auto masterkey_hash = std::make_shared<Buffer<PBYTE>>(SHA_DIGEST_LENGTH);
	hash_masterkey(masterkey, masterkey_hash);

	auto derived_intermediate_key = std::make_shared<Buffer<PBYTE>>(_header.HashAlgorithmLen / 8);
	auto salt_and_entropy = std::make_shared<Buffer<PBYTE>>(_salt->size() + sizeof(EXPORTFLAGS_ENTROPY));
	memcpy_s(salt_and_entropy->data(), salt_and_entropy->size(), _salt->data(), _salt->size());
	memcpy_s(salt_and_entropy->data() + _salt->size(), sizeof(EXPORTFLAGS_ENTROPY), EXPORTFLAGS_ENTROPY, sizeof(EXPORTFLAGS_ENTROPY));

	derive_intermediate_key(_header.HashAlgorithm, masterkey_hash, salt_and_entropy, derived_intermediate_key);

	auto export_flag_key = std::make_shared<Buffer<PBYTE>>(derived_intermediate_key->data(), _header.EncryptionAlgorithmLen / 8);
	auto clear_flag = std::make_shared<Buffer<PBYTE>>(_data->size());
	decrypt_key(_header.EncryptionAlgorithm, _data, _salt, export_flag_key, clear_flag);

	return std::make_shared<ExportFlags>(clear_flag->data(), clear_flag->size());

}
```

`Sources/EFS/export_flags_enc.h`:

```h
#pragma once

#include "EFS/private_key.h"
#include "EFS/private_key_enc.h"
#include <EFS/export_flags.h>

#include <memory>

#define EXPORTFLAGS_ENTROPY	"Hj1diQ6kpUx7VC4m"

class ExportFlagsEnc : public PrivateKeyEnc
{
private:
public:
	ExportFlagsEnc(PBYTE data, DWORD size) : PrivateKeyEnc(data, size) {}

	std::shared_ptr<ExportFlags> decrypt_with_masterkey(std::shared_ptr<Buffer<PBYTE>> masterkey);
};
```

`Sources/EFS/fek.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>

#pragma pack(push, 1)

typedef struct {
	DWORD	KeyLength;
	DWORD	Entropy;
	ALG_ID	Algorithm;
	DWORD	Reserved;
	BYTE	Key[1];
} EFS_FEK, * PEFS_FEK;

#pragma pack(pop)

```

`Sources/EFS/key_file.cpp`:

```cpp
#include "EFS/key_file.h"

void KeyFile::_load_keyfile()
{
	DWORD offset = 0;

	if (_buf->data()->NameLen)
	{
		_name = std::string((char*)_buf->data()->Data + offset, _buf->data()->NameLen);
		utils::strings::rtrim(_name);
		offset += _buf->data()->NameLen;
	}

	if (_buf->data()->HmacLen)
	{
		_hmac = std::make_shared<Buffer<PBYTE>>(_buf->data()->Data + offset, _buf->data()->HmacLen);
		offset += _buf->data()->HmacLen;
	}

	if (_buf->data()->SignPublicKeyLen)
	{
		_sign_public_key = std::make_shared<Buffer<PBYTE>>(_buf->data()->Data + offset, _buf->data()->SignPublicKeyLen);
		offset += _buf->data()->SignPublicKeyLen;
	}
	if (_buf->data()->SignPrivateKeyLen)
	{
		_sign_private_key = std::make_shared<Buffer<PBYTE>>(_buf->data()->Data + offset, _buf->data()->SignPrivateKeyLen);
		offset += _buf->data()->SignPrivateKeyLen;
	}
	if (_buf->data()->ExPublicKeyLen)
	{
		_public_key = std::make_shared<PublicKey>(_buf->data()->Data + offset, _buf->data()->ExPublicKeyLen);
		offset += _buf->data()->ExPublicKeyLen;
	}

	if (_buf->data()->ExPrivateKeyLen)
	{
		_private_key = std::make_shared<PrivateKeyEnc>(_buf->data()->Data + offset, _buf->data()->ExPrivateKeyLen);
		offset += _buf->data()->ExPrivateKeyLen;
	}

	if (_buf->data()->SignExportFlagLen)
	{
		_sign_export_flag = std::make_shared<Buffer<PBYTE>>(_buf->data()->Data + offset, _buf->data()->SignExportFlagLen);
		offset += _buf->data()->SignExportFlagLen;
	}
	if (_buf->data()->ExExportFlagLen)
	{
		_export_flag = std::make_shared<ExportFlagsEnc>(_buf->data()->Data + offset, _buf->data()->ExExportFlagLen);
		offset += _buf->data()->ExExportFlagLen;
	}
}

bool KeyFile::_check_file()
{
	if (_buf == nullptr) return false;
	if (_buf->data()->Version > 2) return false;
	if (_buf->data()->Flags != 0LL) return false;
	return true;
}


KeyFile::KeyFile(std::wstring filename)
{
	_buf = Buffer<PKEYFILE_BLOB>::from_file(filename);

	if (_check_file())
	{
		_load_keyfile();
		_loaded = true;
		_buf = nullptr;
	}
}

KeyFile::KeyFile(PBYTE data, DWORD size)
{
	_buf = std::make_shared<Buffer<PKEYFILE_BLOB>>(data, size);

	if (_check_file())
	{
		_load_keyfile();
		_loaded = true;
		_buf = nullptr;
	}
}
```

`Sources/EFS/key_file.h`:

```h
#pragma once
#include <string>
#include <WinSock2.h>
#include <Windows.h>

#include <memory>

#include "Utils/utils.h"
#include <EFS/private_key_enc.h>
#include <EFS/export_flags_enc.h>
#include <EFS/public_key.h>

#pragma pack(push, 1)

typedef struct {
	DWORD	Version;
	DWORD	Flags;
	DWORD	NameLen;
	DWORD	SignPublicKeyLen;
	DWORD	SignPrivateKeyLen;
	DWORD	ExPublicKeyLen;
	DWORD	ExPrivateKeyLen;
	DWORD	HmacLen;
	DWORD	SignExportFlagLen;
	DWORD	ExExportFlagLen;
	BYTE	Data[1];
} KEYFILE_BLOB, * PKEYFILE_BLOB;

#pragma pack(pop)

class KeyFile
{
private:
	bool _loaded = false;
	DWORD _version = 0;
	DWORD _flags = 0;
	std::string _name;

	std::shared_ptr<Buffer<PKEYFILE_BLOB>> _buf = nullptr;

	std::shared_ptr<Buffer<PBYTE>> _sign_public_key = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _sign_private_key = nullptr;
	std::shared_ptr<PublicKey> _public_key = nullptr;
	std::shared_ptr<PrivateKeyEnc> _private_key = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _hmac = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _sign_export_flag = nullptr;
	std::shared_ptr<ExportFlagsEnc> _export_flag = nullptr;

	void _load_keyfile();

	bool _check_file();

public:
	KeyFile(std::wstring filename);

	KeyFile(PBYTE data, DWORD size);

	bool is_loaded() { return _loaded; }

	DWORD version() { return _version; }

	DWORD flags() { return _flags; }

	std::string name() { return _name; }

	std::shared_ptr<Buffer<PBYTE>> sign_public_key() { return _sign_public_key; }

	std::shared_ptr<Buffer<PBYTE>> sign_private_key() { return _sign_private_key; }

	std::shared_ptr<PublicKey> public_key() { return _public_key; }

	std::shared_ptr<PrivateKeyEnc> private_key() { return _private_key; }

	std::shared_ptr<Buffer<PBYTE>> hash() { return _hmac; }

	std::shared_ptr<Buffer<PBYTE>> sign_export_flag() { return _sign_export_flag; }

	std::shared_ptr<ExportFlagsEnc> export_flags() { return _export_flag; }
};
```

`Sources/EFS/masterkey_file.cpp`:

```cpp
#include "EFS/masterkey_file.h"

void MasterKey::hash_password(std::u16string& password, std::shared_ptr<Buffer<PBYTE>> output, int policy)
{
	if (policy & POLICY_HASH)
	{
		SHA_CTX ctx = { 0 };
		SHA1_Init(&ctx);
		SHA1_Update(&ctx, password.c_str(), password.size() * 2);
		SHA1_Final(output->data(), &ctx);
		output->shrink(SHA_DIGEST_LENGTH);
	}
	else
	{
		MD4_CTX ctx = { 0 };
		MD4_Init(&ctx);
		MD4_Update(&ctx, password.c_str(), password.size() * 2);
		MD4_Final(output->data(), &ctx);
		output->shrink(MD4_DIGEST_LENGTH);
	}
}

void MasterKey::derive_intermediate_key_with_sid(std::shared_ptr<Buffer<PBYTE>> password_hash, std::u16string sid, std::shared_ptr<Buffer<PBYTE>> output)
{
	unsigned int output_size = 0;
	HMAC(EVP_sha1(), password_hash->data(), password_hash->size(), (const unsigned char*)sid.c_str(), (sid.length() + 1) * sizeof(wchar_t), output->data(), &output_size);
	output->shrink(output_size);
}

void MasterKey::derive_masterkey_key(const EVP_MD* hash, std::shared_ptr<Buffer<PBYTE>> derived_key, std::shared_ptr<Buffer<PBYTE>> output)
{

	unsigned int hash_len = 0;
	unsigned int block = 1;
	unsigned int needed_bytes = output->size();

	unsigned char salt_and_block[20] = { 0 };

	std::shared_ptr<Buffer<PBYTE>> intermediate_key_a = std::make_shared<Buffer<PBYTE>>(EVP_MD_size(hash));
	std::shared_ptr<Buffer<PBYTE>> intermediate_key_b = std::make_shared<Buffer<PBYTE>>(EVP_MD_size(hash));

	while (needed_bytes)
	{
		memcpy_s(salt_and_block, sizeof(salt_and_block), _header.Salt, sizeof(_header.Salt));
		((PDWORD)salt_and_block)[4] = _byteswap_ulong(block);

		HMAC(hash, derived_key->data(), derived_key->size(), salt_and_block, sizeof(salt_and_block), intermediate_key_a->data(), &hash_len);
		for (DWORD round = 1; round < _header.Rounds; round++)
		{
			HMAC(hash, derived_key->data(), derived_key->size(), intermediate_key_a->data(), intermediate_key_a->size(), intermediate_key_b->data(), &hash_len);
			utils::crypto::xor_buffer(intermediate_key_a->data(), intermediate_key_a->size(), intermediate_key_b->data(), intermediate_key_b->size());
		}

		memcpy_s(output->data() + ((block - 1) * hash_len), min(hash_len, needed_bytes), intermediate_key_a->data(), min(intermediate_key_a->size(), needed_bytes));

		needed_bytes -= min(hash_len, needed_bytes);
		block++;
	}
}

void MasterKey::decrypt_masterkey(const EVP_CIPHER* dec, std::shared_ptr<Buffer<PBYTE>> encrypted_masterkey, std::shared_ptr<Buffer<PBYTE>> masterkey_key, std::shared_ptr<Buffer<PBYTE>> clear_masterkey)
{
	int clear_master_key_size = clear_masterkey->size();
	EVP_CIPHER_CTX* pctx = EVP_CIPHER_CTX_new();
	EVP_DecryptInit(pctx, dec, masterkey_key->data(), masterkey_key->data() + EVP_CIPHER_key_length(dec));
	EVP_DecryptUpdate(pctx, clear_masterkey->data(), &clear_master_key_size, encrypted_masterkey->data(), encrypted_masterkey->size());
	EVP_DecryptFinal(pctx, clear_masterkey->data(), &clear_master_key_size);
	EVP_CIPHER_CTX_cleanup(pctx);
}

bool MasterKey::check_mac(const EVP_MD* hash, std::shared_ptr<Buffer<PBYTE>> derived_key, std::shared_ptr<Buffer<PBYTE>> masterkey)
{
	std::shared_ptr<Buffer<PBYTE>> hmac_a = std::make_shared<Buffer<PBYTE>>(EVP_MD_size(hash));
	std::shared_ptr<Buffer<PBYTE>> hmac_b = std::make_shared<Buffer<PBYTE>>(EVP_MD_size(hash));

	unsigned int hmac_a_len = 0;
	HMAC(hash, derived_key->data(), derived_key->size(), masterkey->data(), 16, hmac_a->data(), &hmac_a_len);
	unsigned int hmac_b_len = 0;
	HMAC(hash, hmac_a->data(), hmac_a_len, masterkey->data() + masterkey->size() - hmac_a_len, hmac_a_len, hmac_b->data(), &hmac_b_len);

	return memcmp(hmac_b->data(), masterkey->data() + 16, hmac_b_len) == 0;
}

std::shared_ptr<Buffer<PBYTE>> MasterKey::extract_masterkey(std::shared_ptr<Buffer<PBYTE>> masterkey_clear)
{
	unsigned int keysize = (masterkey_clear->size() - 16) / 2;
	return std::make_shared<Buffer<PBYTE>>(masterkey_clear->data() + 16 + keysize, keysize);
}

MasterKey::MasterKey(PBYTE data, DWORD64 size, DWORD flags)
{
	memcpy_s(&_header, sizeof(EFS_MASTERKEY), data, sizeof(EFS_MASTERKEY));
	_policy = flags;
	_encrypted_masterkey = std::make_shared<Buffer<PBYTE>>(data + 0x20, static_cast<DWORD>(size & 0xffffffff) - 0x20);
}

std::shared_ptr<Buffer<PBYTE>> MasterKey::decrypt_with_password(std::string sid, std::string password)
{
	std::u16string password_utf16_le = utils::strings::str_to_utf16(password);
	std::u16string sid_utf16_le = utils::strings::str_to_utf16(sid);

	const EVP_MD* hash = utils::crypto::cryptoapi::hash_to_evp(_header.Hash_algorithm);
	const EVP_CIPHER* dec = utils::crypto::cryptoapi::encryption_to_evp(_header.Enc_algorithm);

	auto password_hash = std::make_shared<Buffer<PBYTE>>(SHA_DIGEST_LENGTH);
	auto derived_key = std::make_shared<Buffer<PBYTE>>(SHA_DIGEST_LENGTH);
	auto masterkey_key = std::make_shared<Buffer<PBYTE>>(EVP_CIPHER_key_length(dec) + EVP_CIPHER_iv_length(dec));
	auto clear_masterkey = std::make_shared<Buffer<PBYTE>>(_encrypted_masterkey->size());

	hash_password(password_utf16_le, password_hash, _policy);
	derive_intermediate_key_with_sid(password_hash, sid_utf16_le, derived_key);
	derive_masterkey_key(hash, derived_key, masterkey_key);

	decrypt_masterkey(dec, _encrypted_masterkey, masterkey_key, clear_masterkey);

	if (check_mac(hash, derived_key, clear_masterkey))
	{
		return extract_masterkey(clear_masterkey);
	}

	return nullptr;
}

void MasterKeyFile::_load_keyfile()
{
	if (_buf)
	{
		_version = _buf->data()->Version;
		_policy = _buf->data()->Policy;
		_guid = utils::strings::to_utf8(_buf->data()->Guid);
	}

	if (_buf->data()->MasterKeyLen)
	{
		_masterkey = std::make_shared<MasterKey>(_buf->data()->Data, _buf->data()->MasterKeyLen, _buf->data()->Policy);
	}

	if (_buf->data()->BackupKeyLen)
	{
		_backupkey = std::make_shared<BackupKey>(_buf->data()->Data + _buf->data()->MasterKeyLen, _buf->data()->BackupKeyLen, _buf->data()->Policy);
	}
	if (_buf->data()->CredHistoryLen)
	{
		_credhistory = std::make_shared<CredHistory>(_buf->data()->Data + _buf->data()->MasterKeyLen + _buf->data()->BackupKeyLen, _buf->data()->CredHistoryLen);
	}
	if (_buf->data()->DomainKeyLen)
	{
		_domainkey = std::make_shared<DomainKey>(_buf->data()->Data + _buf->data()->MasterKeyLen + _buf->data()->BackupKeyLen + _buf->data()->CredHistoryLen, _buf->data()->DomainKeyLen, _buf->data()->Policy);
	}
}

bool MasterKeyFile::_check_file()
{
	if (_buf == nullptr) return false;
	if (_buf->data()->Version > 2) return false;
	if (_buf->data()->Zero0 != 0LL) return false;
	if (_buf->data()->Zero1 != 0LL) return false;
	return true;
}

```

`Sources/EFS/masterkey_file.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>
#include <string>
#include <memory>

#include "EFS/masterkey_file.h"
#include "Utils/buffer.h"
#include "Utils/utils.h"

#include <openssl/sha.h>
#include <openssl/md4.h>
#include <openssl/hmac.h>

#define POLICY_HASH (4)

#pragma pack(push, 1)

typedef struct {
	DWORD	Version;
	BYTE	Salt[16];
	DWORD	Rounds;
	ALG_ID	Hash_algorithm;
	ALG_ID	Enc_algorithm;
	BYTE	Key[1];
} EFS_MASTERKEY, * PEFS_MASTERKEY;

typedef struct EFS_CREDHIST {
	DWORD	Version;
	GUID	Guid;
} EFS_CREDHIST, * PEFS_CREDHIST;

typedef struct {
	DWORD	Version;
	DWORD	SecretLen;
	DWORD	AccessCheckLen;
	GUID	Guid;
	BYTE	Data[1];
} EFS_DOMAINKEY, * PEFS_DOMAINKEY;

typedef struct {
	GUID Guid;
	FILETIME timestamp;
} EFS_PREFERRED_FILE, * PEFS_PREFERRED_FILE;

typedef struct {
	DWORD	Version;
	DWORD64	Zero0;
	WCHAR	Guid[36];
	DWORD64	Zero1;
	DWORD	Policy;
	DWORD64	MasterKeyLen;
	DWORD64 BackupKeyLen;
	DWORD64 CredHistoryLen;
	DWORD64	DomainKeyLen;
	BYTE	Data[1];
} EFS_MASTERKEY_FILE, * PEFS_MASTERKEY_FILE;

#pragma pack(pop)

class MasterKey
{
protected:
	DWORD _policy = 0;
	EFS_MASTERKEY _header;
	std::shared_ptr<Buffer<PBYTE>> _encrypted_masterkey = nullptr;

	void hash_password(std::u16string& password, std::shared_ptr<Buffer<PBYTE>> output, int policy);

	void derive_intermediate_key_with_sid(std::shared_ptr<Buffer<PBYTE>> password_hash, std::u16string sid, std::shared_ptr<Buffer<PBYTE>> output);

	void derive_masterkey_key(const EVP_MD* hash, std::shared_ptr<Buffer<PBYTE>> derived_key, std::shared_ptr<Buffer<PBYTE>> output);

	void decrypt_masterkey(const EVP_CIPHER* dec, std::shared_ptr<Buffer<PBYTE>> encrypted_masterkey, std::shared_ptr<Buffer<PBYTE>> masterkey_key, std::shared_ptr<Buffer<PBYTE>> clear_masterkey);

	bool check_mac(const EVP_MD* hash, std::shared_ptr<Buffer<PBYTE>> derived_key, std::shared_ptr<Buffer<PBYTE>> masterkey);

	std::shared_ptr<Buffer<PBYTE>> extract_masterkey(std::shared_ptr<Buffer<PBYTE>> masterkey_clear);

public:
	MasterKey(PBYTE data, DWORD64 size, DWORD flags);

	PEFS_MASTERKEY header() { return &_header; }

	std::shared_ptr<Buffer<PBYTE>> key() { return _encrypted_masterkey; }

	std::shared_ptr<Buffer<PBYTE>> decrypt_with_password(std::string sid, std::string password);
};

class BackupKey : public MasterKey
{
public:
	BackupKey(PBYTE data, DWORD64 size, DWORD flags) : MasterKey(data, size, flags)
	{
	}
};

class DomainKey
{
protected:
	EFS_DOMAINKEY _header;
	std::shared_ptr<Buffer<PBYTE>> _secret = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _access_check = nullptr;

public:
	DomainKey(PBYTE data, DWORD64 size, DWORD flags)
	{
		memcpy_s(&_header, sizeof(EFS_DOMAINKEY), data, sizeof(EFS_DOMAINKEY));
		_secret = std::make_shared<Buffer<PBYTE>>(data + 28, _header.SecretLen);
		_access_check = std::make_shared<Buffer<PBYTE>>(data + 28 + _header.SecretLen, _header.AccessCheckLen);
	}

	PEFS_DOMAINKEY header() { return &_header; }

	std::shared_ptr<Buffer<PBYTE>> secret() { return _secret; }

	std::shared_ptr<Buffer<PBYTE>> access_check() { return _access_check; }
};

class CredHistory
{
protected:
	EFS_CREDHIST _header;
public:
	CredHistory(PBYTE data, DWORD64 size)
	{
		memcpy_s(&_header, sizeof(EFS_CREDHIST), data, sizeof(EFS_CREDHIST));
	}

	PEFS_CREDHIST header() { return &_header; }
};


class MasterKeyFile
{
private:
	bool _loaded = false;
	DWORD _version = 0;
	DWORD _policy = 0;
	std::string _guid;

	std::shared_ptr<Buffer<PEFS_MASTERKEY_FILE>> _buf = nullptr;
	std::shared_ptr<MasterKey> _masterkey = nullptr;
	std::shared_ptr<BackupKey> _backupkey = nullptr;
	std::shared_ptr<DomainKey> _domainkey = nullptr;
	std::shared_ptr<CredHistory> _credhistory = nullptr;

	void _load_keyfile();

	bool _check_file();

public:
	MasterKeyFile(std::wstring filename)
	{
		_buf = Buffer<PEFS_MASTERKEY_FILE>::from_file(filename);

		if (_check_file())
		{
			_load_keyfile();
			_loaded = true;
			_buf = nullptr;
		}
	}

	MasterKeyFile(PBYTE data, DWORD size)
	{
		_buf = std::make_shared<Buffer<PEFS_MASTERKEY_FILE>>(data, size);

		if (_check_file())
		{
			_load_keyfile();
			_loaded = true;
			_buf = nullptr;
		}
	}

	bool is_loaded() { return _loaded; }

	std::string guid() { return _guid; }

	DWORD version() { return _version; }

	DWORD policy() { return _policy; }

	std::shared_ptr<MasterKey> master_key() { return _masterkey; }

	std::shared_ptr<BackupKey> backup_key() { return _backupkey; }

	std::shared_ptr<DomainKey> domain_key() { return _domainkey; }

	std::shared_ptr<CredHistory> credential_history() { return _credhistory; }
};
```

`Sources/EFS/pkcs12_archive.cpp`:

```cpp
#include "EFS/pkcs12_archive.h"

int parse_bag(PKCS12_SAFEBAG* bag, const char* pass, int passlen,
	EVP_PKEY** pkey, STACK_OF(X509)* ocerts);

int parse_bags(const STACK_OF(PKCS12_SAFEBAG)* bags, const char* pass,
	int passlen, EVP_PKEY** pkey, STACK_OF(X509)* ocerts);

int parse_pk12(PKCS12* p12, const char* pass, int passlen,
	EVP_PKEY** pkey, STACK_OF(X509)* ocerts);

PKCS12Archive::PKCS12Archive(std::shared_ptr<CertificateFile> cert, std::shared_ptr<PrivateKey> private_key)
{
	_cert = _build_x509_cert(cert);
	_key = _build_evp_key(private_key);
}

int parse_bag(PKCS12_SAFEBAG* bag, const char* pass, int passlen,
	EVP_PKEY** pkey, STACK_OF(X509)* ocerts)
{
	PKCS8_PRIV_KEY_INFO* p8;
	X509* x509;
	const ASN1_TYPE* attrib;
	ASN1_BMPSTRING* fname = NULL;
	ASN1_OCTET_STRING* lkid = NULL;

	if ((attrib = PKCS12_SAFEBAG_get0_attr(bag, NID_friendlyName)))
		fname = attrib->value.bmpstring;

	if ((attrib = PKCS12_SAFEBAG_get0_attr(bag, NID_localKeyID)))
		lkid = attrib->value.octet_string;

	switch (PKCS12_SAFEBAG_get_nid(bag)) {
	case NID_keyBag:
		if (pkey == NULL || *pkey != NULL)
			return 1;
		*pkey = EVP_PKCS82PKEY(PKCS12_SAFEBAG_get0_p8inf(bag));
		if (*pkey == NULL)
			return 0;
		break;

	case NID_pkcs8ShroudedKeyBag:
		if (pkey == NULL || *pkey != NULL)
			return 1;
		if ((p8 = PKCS12_decrypt_skey(bag, pass, passlen)) == NULL)
			return 0;
		*pkey = EVP_PKCS82PKEY(p8);
		PKCS8_PRIV_KEY_INFO_free(p8);
		if (!(*pkey))
			return 0;
		break;

	case NID_certBag:
		if (ocerts == NULL
			|| PKCS12_SAFEBAG_get_bag_nid(bag) != NID_x509Certificate)
			return 1;
		if ((x509 = PKCS12_SAFEBAG_get1_cert(bag)) == NULL)
			return 0;
		if (lkid && !X509_keyid_set1(x509, lkid->data, lkid->length)) {
			X509_free(x509);
			return 0;
		}
		if (fname) {
			int len, r;
			unsigned char* data;

			len = ASN1_STRING_to_UTF8(&data, fname);
			if (len >= 0) {
				r = X509_alias_set1(x509, data, len);
				OPENSSL_free(data);
				if (!r) {
					X509_free(x509);
					return 0;
				}
			}
		}

		if (!sk_X509_push(ocerts, x509)) {
			X509_free(x509);
			return 0;
		}

		break;

	case NID_safeContentsBag:
		return parse_bags(PKCS12_SAFEBAG_get0_safes(bag), pass, passlen, pkey,
			ocerts);

	default:
		return 1;
	}
	return 1;
}

int parse_bags(const STACK_OF(PKCS12_SAFEBAG)* bags, const char* pass,
	int passlen, EVP_PKEY** pkey, STACK_OF(X509)* ocerts)
{
	int i;
	for (i = 0; i < sk_PKCS12_SAFEBAG_num(bags); i++) {
		if (!parse_bag(sk_PKCS12_SAFEBAG_value(bags, i),
			pass, passlen, pkey, ocerts))
			return 0;
	}
	return 1;
}

int parse_pk12(PKCS12* p12, const char* pass, int passlen,
	EVP_PKEY** pkey, STACK_OF(X509)* ocerts)
{
	STACK_OF(PKCS7)* asafes;
	STACK_OF(PKCS12_SAFEBAG)* bags;
	int i, bagnid;
	PKCS7* p7;

	if ((asafes = PKCS12_unpack_authsafes(p12)) == NULL)
		return 0;
	for (i = 0; i < sk_PKCS7_num(asafes); i++) {
		p7 = sk_PKCS7_value(asafes, i);
		bagnid = OBJ_obj2nid(p7->type);
		if (bagnid == NID_pkcs7_data) {
			bags = PKCS12_unpack_p7data(p7);
		}
		else if (bagnid == NID_pkcs7_encrypted) {
			bags = PKCS12_unpack_p7encdata(p7, pass, passlen);
		}
		else
			continue;
		if (!bags) {
			sk_PKCS7_pop_free(asafes, PKCS7_free);
			return 0;
		}
		if (!parse_bags(bags, pass, passlen, pkey, ocerts)) {
			sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
			sk_PKCS7_pop_free(asafes, PKCS7_free);
			return 0;
		}
		sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	}
	sk_PKCS7_pop_free(asafes, PKCS7_free);
	return 1;
}

EVP_PKEY* PKCS12Archive::_build_evp_key(std::shared_ptr<PrivateKey> privatekey_file)
{
	if (privatekey_file)
	{
		EVP_PKEY* key = EVP_PKEY_new();
		RSA* rsa_key = privatekey_file->export_private_to_RSA();
		if (rsa_key)
		{
			if (EVP_PKEY_assign_RSA(key, rsa_key))
			{
				EVP_PKEY_add1_attr_by_NID(key, NID_ms_csp_name, MBSTRING_ASC, (const unsigned char*)"Microsoft Enhanced Cryptographic Provider v1.0", -1);
				return key;
			}
		}
		if (key)
		{
			EVP_PKEY_free(key);
		}
	}
	return nullptr;
}

X509* PKCS12Archive::_build_x509_cert(std::shared_ptr<CertificateFile> certfile)
{
	if (certfile)
	{
		X509* cert = certfile->export_to_X509();
		if (cert)
		{
			return cert;
		}
	}
	return nullptr;
}

PKCS12Archive::PKCS12Archive(std::string filename, std::string password)
{
	bool err = true;

	PKCS12* p12 = NULL;
	BIO* in = BIO_new_file(filename.c_str(), "rb");
	if (in)
	{
		p12 = d2i_PKCS12_bio(in, &p12);
		if (p12)
		{
			STACK_OF(X509)* _ca = sk_X509_new_null();
			STACK_OF(X509)* ocerts = sk_X509_new_null();
			if (parse_pk12(p12, password.c_str(), static_cast<int>(password.size()), &_key, ocerts))
			{
				X509* x = NULL;
				while ((x = sk_X509_shift(ocerts)) != NULL)
				{
					if (_key != NULL && _cert == NULL)
					{
						if (X509_check_private_key(x, _key))
						{
							_cert = x;
							continue;
						}
					}
				}
				if (_ca)
				{
					sk_X509_push(_ca, x);
				}
				sk_X509_free(ocerts);

				err = false;
			}
			PKCS12_free(p12);
		}

		BIO_free(in);
	}

	if (err)
	{
		if (_key)
		{
			EVP_PKEY_free(_key);
			_key = nullptr;
		}
		if (_cert)
		{
			X509_free(_cert);
			_cert = nullptr;
		}
		if (_ca_chain)
		{
			sk_X509_free(_ca_chain);
			_ca_chain = nullptr;
		}
	}
}

int PKCS12Archive::export_to_pfx(std::string filename, std::string password)
{
	int err = 0;

	if (_cert && _key)
	{
		if (X509_check_private_key(_cert, _key))
		{
			X509_keyid_set1(_cert, NULL, 0);
			X509_alias_set1(_cert, NULL, 0);

			PKCS12* p12 = PKCS12_create(password.c_str(), NULL, _key, _cert, sk_X509_new_null(), NID_undef, NID_undef, 0, -1, KEY_EX);
			if (p12)
			{
				BIO* out = BIO_new_file(filename.c_str(), "wb");
				if (out)
				{
					i2d_PKCS12_bio(out, p12);
					BIO_free(out);
				}
				else
				{
					err = 4;
				}
				PKCS12_free(p12);
			}
			else
			{
				err = 3;
			}
		}
		else
		{
			err = 2;
		}
	}
	else
	{
		err = 1;
	}

	return err;
}

std::string PKCS12Archive::certificate_hash()
{
	if (_cert)
	{
		unsigned int fprint_size;
		auto fprint_type = EVP_sha1();
		unsigned char fprint[EVP_MAX_MD_SIZE];

		X509_digest(_cert, fprint_type, fprint, &fprint_size);
		return utils::strings::lower(utils::convert::to_hex(fprint, fprint_size));
	}
	return "";
}

```

`Sources/EFS/pkcs12_archive.h`:

```h
#pragma once
#include <memory>
#include <openssl/pkcs12.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/x509.h>

#include <EFS/private_key.h>
#include <EFS/certificate_file.h>


class PKCS12Archive
{
private:
	EVP_PKEY* _key = nullptr;
	X509* _cert = nullptr;
	STACK_OF(X509)* _ca_chain = nullptr;

	EVP_PKEY* _build_evp_key(std::shared_ptr<PrivateKey> privatekey_file);

	X509* _build_x509_cert(std::shared_ptr<CertificateFile> certfile);

public:
	explicit PKCS12Archive(std::shared_ptr<CertificateFile> cert, std::shared_ptr<PrivateKey> private_key);

	PKCS12Archive(std::string filename, std::string password);

	int export_to_pfx(std::string filename, std::string password);

	std::string certificate_hash();

	X509* certificate() { return _cert; }

	EVP_PKEY* key() { return _key; }

	STACK_OF(X509)* certs_chain() { return _ca_chain; }
};
```

`Sources/EFS/private_key.cpp`:

```cpp
#include "EFS/private_key.h"
#include <openssl/rsa.h>
#include <openssl/pem.h>

PrivateKey::PrivateKey(PBYTE data, DWORD size)
{
	memcpy_s(&_header, 20, data, 20);

	unsigned int offset = 20;
	_modulus = std::make_shared<Buffer<PBYTE>>(data + offset, _header.Bitsize / 8);
	_modulus->reverse_bytes();
	offset += _header.ModulusLen;

	_prime1 = std::make_shared<Buffer<PBYTE>>(data + offset, _header.Bitsize / 16);
	_prime1->reverse_bytes();
	offset += _header.Bitsize / 16 + 4;

	_prime2 = std::make_shared<Buffer<PBYTE>>(data + offset, _header.Bitsize / 16);
	_prime2->reverse_bytes();
	offset += _header.Bitsize / 16 + 4;

	_exponent1 = std::make_shared<Buffer<PBYTE>>(data + offset, _header.Bitsize / 16);
	_exponent1->reverse_bytes();
	offset += _header.Bitsize / 16 + 4;

	_exponent2 = std::make_shared<Buffer<PBYTE>>(data + offset, _header.Bitsize / 16);
	_exponent2->reverse_bytes();
	offset += _header.Bitsize / 16 + 4;

	_coefficient = std::make_shared<Buffer<PBYTE>>(data + offset, _header.Bitsize / 16);
	_coefficient->reverse_bytes();
	offset += _header.Bitsize / 16 + 4;

	_private_exponent = std::make_shared<Buffer<PBYTE>>(data + offset, _header.Bitsize / 8);
	_private_exponent->reverse_bytes();
	offset += _header.Bitsize / 8 + 4;
}

int PrivateKey::export_private_to_PEM(std::string filename)
{
	int ret = 1;

	RSA* rsa = RSA_new();
	if (rsa != nullptr)
	{
		BIGNUM* p, * q, * n, * e, * d, * dmp1, * dmq1, * iqmp;

		p = BN_new();
		q = BN_new();
		n = BN_new();
		e = BN_new();
		d = BN_new();
		dmp1 = BN_new();
		dmq1 = BN_new();
		iqmp = BN_new();

		auto rev_e = _byteswap_ulong(_header.Exponent);
		BN_bin2bn((unsigned char*)&rev_e, 4, e);
		BN_bin2bn(_modulus->data(), _modulus->size(), n);
		BN_bin2bn(_prime1->data(), _prime1->size(), p);
		BN_bin2bn(_prime2->data(), _prime2->size(), q);
		BN_bin2bn(_private_exponent->data(), _private_exponent->size(), d);
		BN_bin2bn(_exponent1->data(), _exponent1->size(), dmp1);
		BN_bin2bn(_exponent2->data(), _exponent2->size(), dmq1);
		BN_bin2bn(_coefficient->data(), _coefficient->size(), iqmp);

		RSA_set0_factors(rsa, p, q);
		RSA_set0_key(rsa, n, e, d);
		RSA_set0_crt_params(rsa, dmp1, dmq1, iqmp);

		BIO* out = BIO_new_file((filename + ".priv.pem").c_str(), "wb");
		if (out)
		{
			if (!PEM_write_bio_RSAPrivateKey(out, rsa, nullptr, nullptr, 0, nullptr, nullptr))
			{
				ret = 3;
			}
			else
			{
				ret = 0;
			}
			BIO_free(out);
		}
		else
		{
			ret = 2;
		}
		RSA_free(rsa);
	}
	return ret;
}

int PrivateKey::export_public_to_PEM(std::string filename)
{
	int ret = 1;

	RSA* rsa = RSA_new();
	if (rsa != nullptr)
	{
		BIGNUM* n, * e;

		n = BN_new();
		e = BN_new();

		auto rev_e = _byteswap_ulong(_header.Exponent);
		BN_bin2bn((unsigned char*)&rev_e, 4, e);
		BN_bin2bn(_modulus->data(), _modulus->size(), n);

		RSA_set0_key(rsa, n, e, nullptr);

		BIO* out = BIO_new_file((filename + ".pub.pem").c_str(), "wb");
		if (out)
		{
			if (!PEM_write_bio_RSA_PUBKEY(out, rsa))
			{
				ret = 3;
			}
			else
			{
				ret = 0;
			}
			BIO_free(out);
		}
		else
		{
			ret = 2;
		}
		RSA_free(rsa);
	}

	return ret;
}

RSA* PrivateKey::export_private_to_RSA()
{
	RSA* rsa = RSA_new();

	if (rsa != nullptr)
	{
		BIGNUM* p, * q, * n, * e, * d, * dmp1, * dmq1, * iqmp;

		p = BN_new();
		q = BN_new();
		n = BN_new();
		e = BN_new();
		d = BN_new();
		dmp1 = BN_new();
		dmq1 = BN_new();
		iqmp = BN_new();

		auto rev_e = _byteswap_ulong(_header.Exponent);
		BN_bin2bn((unsigned char*)&rev_e, 4, e);
		BN_bin2bn(_modulus->data(), _modulus->size(), n);
		BN_bin2bn(_prime1->data(), _prime1->size(), p);
		BN_bin2bn(_prime2->data(), _prime2->size(), q);
		BN_bin2bn(_private_exponent->data(), _private_exponent->size(), d);
		BN_bin2bn(_exponent1->data(), _exponent1->size(), dmp1);
		BN_bin2bn(_exponent2->data(), _exponent2->size(), dmq1);
		BN_bin2bn(_coefficient->data(), _coefficient->size(), iqmp);

		RSA_set0_factors(rsa, p, q);
		RSA_set0_key(rsa, n, e, d);
		RSA_set0_crt_params(rsa, dmp1, dmq1, iqmp);

		return rsa;
	}
	return nullptr;
}

```

`Sources/EFS/private_key.h`:

```h
#pragma once
#include <WinSock2.h>
#include <Windows.h>

#include <memory>
#include <string>

#include "Utils/utils.h"

#pragma pack(push, 1)

typedef struct {
	DWORD	Magic;
	DWORD	ModulusLen;
	DWORD	Bitsize;
	DWORD	Permissions;
	DWORD	Exponent;
	BYTE	Data[1];
} PRIVATEKEY_BLOB, * PPRIVATEKEY_BLOB;


#pragma pack(pop)

class PrivateKey
{
private:
	PRIVATEKEY_BLOB _header;

	std::shared_ptr<Buffer<PBYTE>> _modulus = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _prime1 = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _prime2 = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _exponent1 = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _exponent2 = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _coefficient = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _private_exponent = nullptr;

public:
	PrivateKey(PBYTE data, DWORD size);

	PPRIVATEKEY_BLOB header() { return &_header; }

	std::shared_ptr<Buffer<PBYTE>> modulus() { return _modulus; }

	std::shared_ptr<Buffer<PBYTE>> prime1() { return _prime1; }

	std::shared_ptr<Buffer<PBYTE>> prime2() { return _prime2; }

	std::shared_ptr<Buffer<PBYTE>> exponent1() { return _exponent1; }

	std::shared_ptr<Buffer<PBYTE>> exponent2() { return _exponent2; }

	std::shared_ptr<Buffer<PBYTE>> coefficient() { return _coefficient; }

	std::shared_ptr<Buffer<PBYTE>> private_exponent() { return _private_exponent; }

	int export_private_to_PEM(std::string filename);

	int export_public_to_PEM(std::string filename);

	RSA* export_private_to_RSA();
};
```

`Sources/EFS/private_key_enc.cpp`:

```cpp
#include "EFS/private_key_enc.h"
#include <openssl/sha.h>
#include <openssl/hmac.h>
#include <EFS/private_key.h>

PrivateKeyEnc::PrivateKeyEnc(PBYTE data, DWORD size)
{
	memcpy_s(&_header, 48, data, 48);
	DWORD offset = 44;

	_header.DescriptionLen = *(PDWORD(data + offset));
	offset += 4;
	_description = utils::strings::to_utf8(std::wstring((wchar_t*)(data + offset), _header.DescriptionLen / sizeof(wchar_t)));
	utils::strings::rtrim(_description);
	offset += _header.DescriptionLen;

	_header.EncryptionAlgorithm = *(PDWORD(data + offset));
	offset += 4;

	_header.EncryptionAlgorithmLen = *(PDWORD(data + offset));
	offset += 4;

	_header.SaltLen = *(PDWORD(data + offset));
	offset += 4;

	_salt = std::make_shared<Buffer<PBYTE>>(data + offset, _header.SaltLen);
	offset += _header.SaltLen;

	_header.HMACLen = *(PDWORD(data + offset));
	offset += 4;

	_hmac = std::make_shared<Buffer<PBYTE>>(data + offset, _header.HMACLen);
	offset += _header.HMACLen;

	_header.HashAlgorithm = *(PDWORD(data + offset));
	offset += 4;

	_header.HashAlgorithmLen = *(PDWORD(data + offset));
	offset += 4;

	_header.HMAC2Len = *(PDWORD(data + offset));
	offset += 4;

	_hmac2 = std::make_shared<Buffer<PBYTE>>(data + offset, _header.HMAC2Len);
	offset += _header.HMAC2Len;

	_header.DataLen = *(PDWORD(data + offset));
	offset += 4;
	_data = std::make_shared<Buffer<PBYTE>>(data + offset, _header.DataLen);
	offset += _header.DataLen;

	_header.SignatureLen = *(PDWORD(data + offset));
	offset += 4;
	_signature = std::make_shared<Buffer<PBYTE>>(data + offset, _header.SignatureLen);
}

void PrivateKeyEnc::hash_masterkey(std::shared_ptr<Buffer<PBYTE>> masterkey, std::shared_ptr<Buffer<PBYTE>> masterkey_hash)
{
	SHA_CTX ctx = { 0 };
	SHA1_Init(&ctx);
	SHA1_Update(&ctx, masterkey->data(), masterkey->size());
	SHA1_Final(masterkey_hash->data(), &ctx);
}

void PrivateKeyEnc::derive_intermediate_key(DWORD hashAlg, std::shared_ptr<Buffer<PBYTE>> masterkey_hash, std::shared_ptr<Buffer<PBYTE>> salt, std::shared_ptr<Buffer<PBYTE>> derive_intermediate_key)
{
	unsigned int output_size = derive_intermediate_key->size();
	auto hash = utils::crypto::cryptoapi::hash_to_evp(hashAlg);
	HMAC(hash, masterkey_hash->data(), masterkey_hash->size(), salt->data(), salt->size(), derive_intermediate_key->data(), &output_size);
	derive_intermediate_key->shrink(output_size);
}

void PrivateKeyEnc::decrypt_key(DWORD decAlg, std::shared_ptr<Buffer<PBYTE>> encrypted, std::shared_ptr<Buffer<PBYTE>> salt, std::shared_ptr<Buffer<PBYTE>> key, std::shared_ptr<Buffer<PBYTE>> clear)
{
	EVP_CIPHER_CTX* pctx = EVP_CIPHER_CTX_new();
	auto dec = utils::crypto::cryptoapi::encryption_to_evp(decAlg);
	int clear_key_size = 0;
	int tmp_size = 0;

	EVP_DecryptInit(pctx, dec, key->data(), 0);
	EVP_DecryptUpdate(pctx, clear->data(), &tmp_size, encrypted->data(), encrypted->size());
	clear_key_size += tmp_size;
	EVP_DecryptFinal(pctx, clear->data() + tmp_size, &tmp_size);
	clear_key_size += tmp_size;
	clear->shrink(clear_key_size);

	EVP_CIPHER_CTX_cleanup(pctx);
}

bool PrivateKeyEnc::check(std::shared_ptr<Buffer<PBYTE>> key)
{
	if (((PDWORD)key->data())[0] != 0x32415352UL) return false;
	if (((PDWORD)key->data())[4] != 65537) return false;
	return true;
}

std::shared_ptr<PrivateKey> PrivateKeyEnc::decrypt_with_masterkey(std::shared_ptr<Buffer<PBYTE>> masterkey)
{
	auto masterkey_hash = std::make_shared<Buffer<PBYTE>>(SHA_DIGEST_LENGTH);
	hash_masterkey(masterkey, masterkey_hash);

	auto derived_intermediate_key = std::make_shared<Buffer<PBYTE>>(_header.HashAlgorithmLen / 8);
	derive_intermediate_key(_header.HashAlgorithm, masterkey_hash, _salt, derived_intermediate_key);

	auto privatekey_key = std::make_shared<Buffer<PBYTE>>(derived_intermediate_key->data(), _header.EncryptionAlgorithmLen / 8);
	auto clear_key = std::make_shared<Buffer<PBYTE>>(_data->size());
	decrypt_key(_header.EncryptionAlgorithm, _data, _salt, privatekey_key, clear_key);

	if (check(clear_key))
	{
		return std::make_shared<PrivateKey>(clear_key->data(), clear_key->size());
	}

	return nullptr;
}
```

`Sources/EFS/private_key_enc.h`:

```h
#pragma once
#include <WinSock2.h>
#include <Windows.h>

#include <memory>
#include <string>

#include "Utils/utils.h"
#include "EFS/private_key.h"

#pragma pack(push, 1)

typedef struct {
	DWORD	Version;
	GUID	ProviderGuid;
	DWORD	MasterKeyVersion;
	GUID	MasterKeyGuid;
	DWORD	Flags;
	DWORD	DescriptionLen;
	DWORD	EncryptionAlgorithm;
	DWORD	EncryptionAlgorithmLen;
	DWORD	SaltLen;
	DWORD	HMACLen;
	DWORD	HashAlgorithm;
	DWORD	HashAlgorithmLen;
	DWORD	HMAC2Len;
	DWORD	DataLen;
	DWORD	SignatureLen;
} PRIVATEKEY_ENC_BLOB, * PPRIVATEKEY_ENC_BLOB;


#pragma pack(pop)

class PrivateKeyEnc
{
protected:
	PRIVATEKEY_ENC_BLOB _header;

	std::string _description;
	std::shared_ptr<Buffer<PBYTE>> _salt = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _hmac = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _hmac2 = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _data = nullptr;
	std::shared_ptr<Buffer<PBYTE>> _signature = nullptr;

	void hash_masterkey(std::shared_ptr<Buffer<PBYTE>> masterkey, std::shared_ptr<Buffer<PBYTE>> masterkey_hash);

	void derive_intermediate_key(DWORD hashAlg, std::shared_ptr<Buffer<PBYTE>> masterkey_hash, std::shared_ptr<Buffer<PBYTE>> salt, std::shared_ptr<Buffer<PBYTE>> derive_intermediate_key);

	void decrypt_key(DWORD decAlg, std::shared_ptr<Buffer<PBYTE>> encrypted, std::shared_ptr<Buffer<PBYTE>> salt, std::shared_ptr<Buffer<PBYTE>> key, std::shared_ptr<Buffer<PBYTE>> clear);

	bool check(std::shared_ptr<Buffer<PBYTE>> key);

public:
	PrivateKeyEnc(PBYTE data, DWORD size);

	std::shared_ptr<PrivateKey> decrypt_with_masterkey(std::shared_ptr<Buffer<PBYTE>> masterkey);

	PPRIVATEKEY_ENC_BLOB header() { return &_header; }

	std::string description() { return _description; }

	std::shared_ptr<Buffer<PBYTE>> salt() { return _salt; }

	std::shared_ptr<Buffer<PBYTE>> hmac() { return _hmac; }

	std::shared_ptr<Buffer<PBYTE>> hmac2() { return _hmac2; }

	std::shared_ptr<Buffer<PBYTE>> data() { return _data; }

	std::shared_ptr<Buffer<PBYTE>> signature() { return _signature; }
};
```

`Sources/EFS/public_key.cpp`:

```cpp

#include "EFS/public_key.h"
#include <openssl/rsa.h>
#include <openssl/pem.h>

PublicKey::PublicKey(PBYTE data, DWORD size)
{
	memcpy_s(&_header, 20, data, 20);
	_modulus = std::make_shared<Buffer<PBYTE>>(data + 20, _header.ModulusLen);
	_modulus->shrink(_header.Bitsize / 8);
	_modulus->reverse_bytes();
}

int PublicKey::export_to_PEM(std::string filename)
{
	int ret = 1;

	RSA* rsa = RSA_new();
	BIGNUM* n, * e;

	if (rsa != nullptr)
	{
		n = BN_new();
		e = BN_new();

		auto rev_e = _byteswap_ulong(_header.Exponent);
		BN_bin2bn((unsigned char*)&rev_e, 4, e);
		BN_bin2bn(_modulus->data(), _modulus->size(), n);

		RSA_set0_key(rsa, n, e, 0);

		BIO* out = BIO_new_file((filename + ".pub.pem").c_str(), "wb");
		if (out)
		{
			if (!PEM_write_bio_RSA_PUBKEY(out, rsa))
			{
				ret = 3;
			}
			else
			{
				ret = 0;
			}
			BIO_free(out);
		}
		else
		{
			ret = 2;
		}
		RSA_free(rsa);
	}

	return ret;
}

```

`Sources/EFS/public_key.h`:

```h
#pragma once
#include <WinSock2.h>
#include <Windows.h>

#include <memory>
#include <string>

#include "Utils/utils.h"

#pragma pack(push, 1)

typedef struct {
	DWORD	Magic;
	DWORD	ModulusLen;
	DWORD	Bitsize;
	DWORD	Permissions;
	DWORD	Exponent;
	BYTE	Modulus[1];
} PUBLICKEY_BLOB, * PPUBLICKEY_BLOB;

#pragma pack(pop)

class PublicKey
{
private:
	PUBLICKEY_BLOB _header;
	std::shared_ptr<Buffer<PBYTE>> _modulus = nullptr;
public:
	PublicKey(PBYTE data, DWORD size);

	PPUBLICKEY_BLOB header() { return &_header; }

	std::shared_ptr<Buffer<PBYTE>> modulus() { return _modulus; }

	int export_to_PEM(std::string filename);
};
```

`Sources/NTFS/ntfs.h`:

```h
#pragma once

#include <Windows.h>
#include <winternl.h>

#define MASTER_FILE_TABLE_NUMBER				(0)
#define MASTER_FILE_TABLE2_NUMBER				(1)
#define LOG_FILE_NUMBER							(2)
#define VOLUME_DASD_NUMBER						(3)
#define ATTRIBUTE_DEF_TABLE_NUMBER				(4)
#define ROOT_FILE_NAME_INDEX_NUMBER				(5)
#define BIT_MAP_FILE_NUMBER						(6)
#define BOOT_FILE_NUMBER						(7)
#define BAD_CLUSTER_FILE_NUMBER					(8)
#define QUOTA_TABLE_NUMBER						(9)
#define UPCASE_TABLE_NUMBER						(10)
#define CAIRO_NUMBER							(11)

#define FIRST_USER_FILE_NUMBER					(16)

#define RESIDENT_FORM							(0x00)
#define NON_RESIDENT_FORM						(0x01)

#define	MFT_RECORD_IN_USE						(0x0001)
#define MFT_RECORD_IS_DIRECTORY					(0x0002)

#define FILE_ATTR_READONLY  					(0x00000001)
#define FILE_ATTR_HIDDEN 						(0x00000002)
#define FILE_ATTR_SYSTEM						(0x00000004)

#define FILE_ATTR_DIRECTORY						(0x00000010)
#define FILE_ATTR_ARCHIVE						(0x00000020)
#define FILE_ATTR_DEVICE						(0x00000040)
#define FILE_ATTR_NORMAL						(0x00000080)
#define FILE_ATTR_TEMPORARY						(0x00000100)
#define FILE_ATTR_SPARSE_FILE					(0x00000200)
#define FILE_ATTR_REPARSE_POINT					(0x00000400)
#define FILE_ATTR_COMPRESSED					(0x00000800)
#define FILE_ATTR_OFFLINE						(0x00001000)
#define FILE_ATTR_NOT_CONTENT_INDEXED			(0x00002000)
#define FILE_ATTR_ENCRYPTED						(0x00004000)
#define FILE_ATTR_VALID_FLAGS					(0x00007fb7)
#define FILE_ATTR_VALID_SET_FLAGS				(0x000031a7)
#define FILE_ATTR_DUP_FILENAME_INDEX_PRESENT	(0x10000000)
#define FILE_ATTR_DUP_VIEW_INDEX_PRESENT		(0x20000000)

#define RESIDENT_FORM							(0x00)
#define NON_RESIDENT_FORM						(0x01)

#define ATTRIBUTE_FLAG_COMPRESSED				(0x0001)
#define ATTRIBUTE_FLAG_ENCRYPTED				(0x4000)
#define ATTRIBUTE_FLAG_SPARSE					(0x8000)

#define $STANDARD_INFORMATION					(0x10)
#define $ATTRIBUTE_LIST							(0x20)
#define $FILE_NAME								(0x30)
#define $OBJECT_ID								(0x40)
#define $SECURITY_DESCRIPTOR					(0x50)
#define $VOLUME_NAME							(0x60)
#define $VOLUME_INFORMATION						(0x70)
#define $DATA									(0x80)
#define $INDEX_ROOT								(0x90)
#define $INDEX_ALLOCATION						(0xA0)
#define $BITMAP									(0xB0)
#define $REPARSE_POINT							(0xC0)
#define $EA_INFORMATION							(0xD0)
#define $EA										(0xE0)
#define $LOGGED_UTILITY_STREAM					(0x100)
#define $END									(0xFFFFFFFF)

#define	FILE_RECORD_FLAG_INUSE					(0x01)
#define	FILE_RECORD_FLAG_DIR					(0x02)

#define	MFT_ATTRIBUTE_INDEX_ROOT_FLAG_SMALL		(0x00)
#define	MFT_ATTRIBUTE_INDEX_ROOT_FLAG_LARGE		(0x01)

#define $I30									(0x30)
#define MFT_ATTRIBUTE_INDEX_FILENAME			("$I30")
#define MFT_ATTRIBUTE_INDEX_REPARSE	         	("$R")

#define MFT_ATTRIBUTE_DATA_USN_NAME				("$J")

#define MFT_ATTRIBUTE_EFS_CONTAINER				(1)
#define MFT_ATTRIBUTE_EFS_CERTIFICATE			(3)

#define	MFT_ATTRIBUTE_INDEX_ENTRY_FLAG_SUBNODE	(0x01)
#define	MFT_ATTRIBUTE_INDEX_ENTRY_FLAG_LAST		(0x02)

#define MFT_DATARUN_END							(0x00)

#define MFT_LOGFILE_RESTART_AREA_FLAG_VOLUME_CLEANLY_UNMOUNTED	(0x2)
#define MFT_LOGFILE_NO_CLIENT					(0xffff)
#define MFT_LOGFILE_LOG_RECORD_HEADER_SIZE		(48)

#define LOG_RECORD_MULTI_PAGE					(1)

#define LOG_RECORD_OP_NOOP 0x00
#define LOG_RECORD_OP_COMPENSATION_LOG_RECORD 0x01
#define LOG_RECORD_OP_INITIALIZE_FILE_RECORD_SEGMENT 0x02
#define LOG_RECORD_OP_DEALLOCATE_FILE_RECORD_SEGMENT 0x03
#define LOG_RECORD_OP_WRITE_END_OF_FILE_RECORD_SEGMENT 0x04
#define LOG_RECORD_OP_CREATE_ATTRIBUTE 0x05
#define LOG_RECORD_OP_DELETE_ATTRIBUTE 0x06
#define LOG_RECORD_OP_UPDATE_RESIDENT_VALUE 0x07
#define LOG_RECORD_OP_UPDATE_NONRESIDENT_VALUE 0x08
#define LOG_RECORD_OP_UPDATE_MAPPING_PAIRS 0x09
#define LOG_RECORD_OP_DELETE_DIRTY_CLUSTERS 0x0A
#define LOG_RECORD_OP_SET_NEW_ATTRIBUTE_SIZES 0x0B
#define LOG_RECORD_OP_ADD_INDEX_ENTRY_ROOT 0x0C
#define LOG_RECORD_OP_DELETE_INDEX_ENTRY_ROOT 0x0D
#define LOG_RECORD_OP_ADD_INDEX_ENTRY_ALLOCATION 0x0E
#define LOG_RECORD_OP_DELETE_INDEX_ENTRY_ALLOCATION 0x0F
#define LOG_RECORD_OP_SET_INDEX_ENTRY_VCN_ALLOCATION 0x12
#define LOG_RECORD_OP_UPDATE_FILE_NAME_ROOT 0x13
#define LOG_RECORD_OP_UPDATE_FILE_NAME_ALLOCATION 0x14
#define LOG_RECORD_OP_SET_BITS_IN_NONRESIDENT_BIT_MAP 0x15
#define LOG_RECORD_OP_CLEAR_BITS_IN_NONRESIDENT_BIT_MAP 0x16
#define LOG_RECORD_OP_PREPARE_TRANSACTION 0x19
#define LOG_RECORD_OP_COMMIT_TRANSACTION 0x1A
#define LOG_RECORD_OP_FORGET_TRANSACTION 0x1B
#define LOG_RECORD_OP_OPEN_NONRESIDENT_ATTRIBUTE 0x1C
#define LOG_RECORD_OP_DIRTY_PAGE_TABLE_DUMP 0x1F
#define LOG_RECORD_OP_TRANSACTION_TABLE_DUMP 0x20
#define LOG_RECORD_OP_UPDATE_RECORD_DATA_ROOT 0x21

const GUID VSS_VOLUME_GUID = { 0x3808876b, 0xc176, 0x4e48, 0xb7, 0xae, 0x04, 0x04, 0x6e, 0x6c, 0xc7, 0x52 };

#pragma pack(push, 1)

typedef struct {
	GUID vssid;
	DWORD version;
	DWORD type;
	DWORD64 current_offset;
	DWORD64 relative_offset;
	DWORD64 zero0;
	DWORD64 catalog_offset;
	DWORD64 maximum_size;
	GUID volume;
	GUID shadow_copy_storage_volume;
} VSS_VOLUME_HEADER, * PVSS_VOLUME_HEADER;

typedef struct {
	DWORD64 type;
	DWORD64 volume_size;
	GUID store_guid;
	DWORD64 sequence_number;
	DWORD64 backup_schema_flags;
	DWORD64 creation_time;
	CHAR padding[72];
} VSS_CATALOG_ENTRY_2, * PVSS_CATALOG_ENTRY_2;

typedef struct {
	DWORD64 type;
	DWORD64 store_block_list_offset;
	GUID store_guid;
	DWORD64 store_header_offset;
	DWORD64 store_block_range_offset;
	DWORD64 store_current_bitmap_offset;
	DWORD64 file_id;
	DWORD64 allocated_size;
	DWORD64 store_previous_bitmap_offset;
	CHAR padding[48];
} VSS_CATALOG_ENTRY_3, * PVSS_CATALOG_ENTRY_3;

typedef struct {
	VSS_CATALOG_ENTRY_2 entry_2;
	VSS_CATALOG_ENTRY_3 entry_3;
} snapshot;

typedef struct {
	GUID vssid;
	DWORD version;
	DWORD type;
	DWORD64 offset_from_prev;
	DWORD64 current_offset;
	DWORD64 next_offset;
	CHAR padding[80];
	snapshot snapshots[1];
} VSS_CATALOG_HEADER, * PVSS_CATALOG_HEADER;

typedef struct {
	GUID vssid;
	DWORD version;
	DWORD type;
	DWORD64 offset_from_prev;
	DWORD64 current_offset;
	DWORD64 next_offset;
	DWORD64 data_size;
	CHAR padding[72];
	GUID info_type;
	GUID id;
	GUID set_id;
	DWORD state;
	DWORD count;
	DWORD64 flags;
	union {
		USHORT Length;
		WCHAR Buffer;
	} machines;
} VSS_STORE_HEADER, * PVSS_STORE_HEADER;

typedef struct {
	DWORD	magic;
	WORD	update_sequence_array_offset;
	WORD	update_sequence_array_count;
	DWORD64	chkdsk_lsn;
	DWORD	system_page_size;
	DWORD	log_page_size;
	WORD	restart_area_offset;
	WORD	minor_version;
	WORD	major_version;
} RESTART_PAGE_HEADER, * PRESTART_PAGE_HEADER;

typedef struct {
	DWORD64 current_lsn;
	WORD	log_clients;
	WORD	client_free_list;
	WORD	client_in_use_list;
	WORD	flags;
	DWORD	seq_number_bits;
	WORD	restart_area_length;
	WORD	client_array_offset;
	DWORD64	file_size;
	DWORD	last_lsn_data_length;
	WORD	log_record_header_length;
	WORD	log_page_data_offset;
	DWORD	restart_log_open_count;
	DWORD	reserved;
} RESTART_AREA, * PRESTART_AREA;

typedef struct {
	CHAR	magic[4];
	WORD	update_sequence_array_offset;
	WORD	update_sequence_array_count;
	union {
		DWORD64 last_lsn;
		DWORD64 file_offset;
	} copy;
	DWORD	flags;
	WORD	page_count;
	WORD	page_position;
	union {
		struct {
			WORD	next_record_offset;
			BYTE	reserved[6];
			DWORD64	last_end_lsn;
		}   packed;
	}   header;
} RECORD_PAGE_HEADER, * PRECORD_PAGE_HEADER;

typedef struct {
	WORD seq_number;
	WORD client_index;
} LOG_CLIENT_ID;

typedef struct {
	DWORD64	oldest_lsn;
	DWORD64	client_restart_lsn;
	WORD	prev_client;
	WORD	next_client;
	WORD	seq_number;
	BYTE	reserved[6];
	DWORD	client_name_length;
	WCHAR	client_name[64];
} LOG_CLIENT_RECORD, * PLOG_CLIENT_RECORD;

typedef struct {
	DWORD64 lsn;
	DWORD64 client_previous_lsn;
	DWORD64 client_undo_next_lsn;
	DWORD	client_data_length;
	LOG_CLIENT_ID client_id;
	DWORD	record_type;
	DWORD	transaction_id;
	WORD	flags;
	WORD	reserved_or_alignment[3];
	WORD	redo_operation;
	WORD	undo_operation;
	WORD	redo_offset;
	WORD	redo_length;
	WORD	undo_offset;
	WORD	undo_length;
	WORD	target_attribute;
	WORD	lcns_to_follow;
	WORD	record_offset;
	WORD	attribute_offset;
	WORD	mft_cluster_index;
	WORD	alignment_or_reserved;
	DWORD64 target_vcn;
	DWORD64 target_lcn;
} RECORD_LOG, * PRECORD_LOG;

typedef struct
{
	LONGLONG    offset;
	ULONGLONG   length;
} MFT_DATARUN, * PMFT_DATARUN;

typedef struct
{
	struct {
		ULONGLONG FileRecordNumber : 48;
		ULONGLONG SequenceNumber : 16;
	} ParentDirectory;
	ULONGLONG CreationTime;
	ULONGLONG ChangeTime;
	ULONGLONG LastWriteTime;
	ULONGLONG LastAccessTime;
	ULONGLONG AllocatedSize;
	ULONGLONG DataSize;
	ULONG FileAttributes;
	union
	{
		struct
		{
			USHORT PackedEaSize;
			USHORT AlignmentOrReserved;
		} EaInfo;
		ULONG ReparseTag;
	} Extended;
	UCHAR NameLength;
	UCHAR NameType;
	WCHAR Name[1];
} MFT_RECORD_ATTRIBUTE_FILENAME, * PMFT_RECORD_ATTRIBUTE_FILENAME;

typedef struct
{
	ULONG  TypeCode;
	DWORD  RecordLength;
	UCHAR  FormCode;
	UCHAR  NameLength;
	USHORT NameOffset;
	USHORT Flags;
	USHORT Instance;

	union
	{
		struct
		{
			ULONG  ValueLength;
			USHORT ValueOffset;
			UCHAR  ResidentFlags;
			UCHAR  Reserved;
		} Resident;

		struct
		{
			LONGLONG LowestVcn;
			LONGLONG HighestVcn;
			USHORT   MappingPairsOffset;
			UCHAR    CompressionUnit;
			UCHAR    Reserved[5];
			ULONGLONG AllocatedLength;
			ULONGLONG FileSize;
			ULONGLONG ValidDataLength;
			ULONGLONG TotalAllocated;
		} Nonresident;
	} Form;
} MFT_RECORD_ATTRIBUTE_HEADER, * PMFT_RECORD_ATTRIBUTE_HEADER;

typedef struct
{
	DWORD       typeID;
	WORD        recordLength;
	BYTE        nameLength;
	BYTE        nameOffset;
	LONGLONG    lowestVCN;
	LONGLONG    recordNumber;
	WORD        sequenceNumber;
	WORD        reserved;
} MFT_RECORD_ATTRIBUTE, * PMFT_RECORD_ATTRIBUTE;

typedef struct
{
	ULONGLONG	CreateTime;
	ULONGLONG	AlterTime;
	ULONGLONG	MFTTime;
	ULONGLONG	ReadTime;
	union {
		struct {
			DWORD readonly : 1;
			DWORD hidden : 1;
			DWORD system : 1;
			DWORD unused0 : 2;
			DWORD archive : 1;
			DWORD device : 1;
			DWORD normal : 1;
			DWORD temp : 1;
			DWORD sparse : 1;
			DWORD reparse : 1;
			DWORD compressed : 1;
			DWORD offline : 1;
			DWORD not_indexed : 1;
			DWORD encrypted : 1;
		} Permission;
		DWORD dword_part;
	} u;
	DWORD		MaxVersionNo;
	DWORD		VersionNo;
	DWORD		ClassId;
	DWORD		OwnerId;
	DWORD		SecurityId;
	ULONGLONG	QuotaCharged;
	ULONGLONG	USN;
} MFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION, * PMFT_RECORD_ATTRIBUTE_STANDARD_INFORMATION;

typedef struct
{
	GUID		object_id;
} MFT_RECORD_ATTRIBUTE_OBJECT_ID, * PMFT_RECORD_ATTRIBUTE_OBJECT_ID;

typedef struct
{
	BYTE		bitmap[1];
} MFT_RECORD_ATTRIBUTE_BITMAP, * PMFT_RECORD_ATTRIBUTE_BITMAP;

typedef struct
{
	USHORT packed_length;
	USHORT need_ea_count;
	DWORD unpacked_length;
} MFT_RECORD_ATTRIBUTE_EA_INFORMATION, * PMFT_RECORD_ATTRIBUTE_EA_INFORMATION;

typedef struct
{
	DWORD next_entry_offset;
	UCHAR flags;
	UCHAR name_length;
	USHORT value_length;
	CHAR data[1];
} MFT_RECORD_ATTRIBUTE_EA, * PMFT_RECORD_ATTRIBUTE_EA;

typedef struct {
	ULONG  ReparseTag;
	USHORT ReparseDataLength;
	USHORT Reserved;
	union {
		struct {
			DWORD Version;
			DWORD Provider;
			DWORD FileVersionInformation;
			DWORD CompressionAlgorithm;
		} WindowsOverlayFilterBuffer;
		struct {
			USHORT SubstituteNameOffset;
			USHORT SubstituteNameLength;
			USHORT PrintNameOffset;
			USHORT PrintNameLength;
			ULONG Flags;
			WCHAR PathBuffer[1];
		} SymbolicLinkReparseBuffer;
		struct {
			USHORT SubstituteNameOffset;
			USHORT SubstituteNameLength;
			USHORT PrintNameOffset;
			USHORT PrintNameLength;
			WCHAR PathBuffer[1];
		} MountPointReparseBuffer;
		struct {
			WCHAR  DataBuffer[1];
		} GenericReparseBuffer;
		struct {
			ULONG StringCount;
			WCHAR  StringBuffer[1];
		} AppExecLinkReparseBuffer;
	} DUMMYUNIONNAME;
} MFT_RECORD_ATTRIBUTE_REPARSE_POINT, * PMFT_RECORD_ATTRIBUTE_REPARSE_POINT;

typedef struct
{
	BYTE		Revision;
	BYTE		unused;
	struct {
		WORD OwnerDefaulted : 1;
		WORD GroupDefaulted : 1;
		WORD DACLPresent : 1;
		WORD DACLDefaulted : 1;
		WORD SACLPresent : 1;
		WORD SACLDefaulted : 1;
		WORD unused : 2;
		WORD DACLAutoInheritReq : 1;
		WORD SACLAutoInheritReq : 1;
		WORD DACLAutoInherit : 1;
		WORD SACLAutoInherit : 1;
		WORD DACLProtected : 1;
		WORD SACLProtected : 1;
		WORD RMControlValid : 1;
		WORD SelfRelative : 1;
	} ControlFlags;
	DWORD UserSIDOffset;
	DWORD GroupSIDOffset;
	DWORD SACLOffset;
	DWORD DACLOffset;
} MFT_RECORD_ATTRIBUTE_SECURITY_DESCRIPTOR, * PMFT_RECORD_ATTRIBUTE_SECURITY_DESCRIPTOR;

typedef struct
{
	DWORD		Magic;
	WORD		OffsetOfUS;
	WORD		SizeOfUS;
	ULONGLONG	LSN;
	ULONGLONG	VCN;
	DWORD		EntryOffset;
	DWORD		TotalEntrySize;
	DWORD		AllocEntrySize;
	BYTE		NotLeaf;
	BYTE		Padding[3];
} MFT_RECORD_ATTRIBUTE_INDEX_BLOCK, * PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK;

typedef struct
{
	DWORD		AttributeLength;
	DWORD		State;
	DWORD		Version;
	DWORD		CryptoAPIVersion;
	BYTE		Checksum[16];
	BYTE		ChecksumDDF[16];
	BYTE		ChecksumDRF[16];
	DWORD		OffsetToDDF;
	DWORD		OffsetToDRF;
} MFT_RECORD_ATTRIBUTE_EFS_HEADER, * PMFT_RECORD_ATTRIBUTE_EFS_HEADER;

typedef struct
{
	struct {
		ULONGLONG FileRecordNumber : 48;
		ULONGLONG SequenceNumber : 16;
	} RootRecordNumber;
	DWORD64		Flags;
	DWORD64		TxfFileId;
	DWORD64		LsnUserData;
	DWORD64		LsnNtfsMetadata;
	DWORD64		LsnDirectoryIndex;
	DWORD64		UsnIndex;
} MFT_RECORD_ATTRIBUTE_TXF, * PMFT_RECORD_ATTRIBUTE_TXF;

typedef struct {
	DWORD		Count;
} MFT_RECORD_ATTRIBUTE_EFS_ARRAY_HEADER, * PMFT_RECORD_ATTRIBUTE_EFS_ARRAY_HEADER;


typedef struct {
	DWORD		Length;
	DWORD		CredentialHeaderOffset;
	DWORD		FEKSize;
	DWORD		FEKOffset;
} MFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY_HEADER, * PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY_HEADER;

typedef struct {
	DWORD		Length;
	DWORD		SIDOffset;
	DWORD		Type;
	union {
		/* CryptoAPI container. */
		struct {
			DWORD container_name_offset;
			DWORD provider_name_offset;
			DWORD public_key_blob_offset;
			DWORD public_key_blob_size;
		};
		/* Certificate thumbprint. */
		struct {
			DWORD cert_thumbprint_header_size;
			DWORD cert_thumbprint_header_offset;
		};
	};
} MFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY, * PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY;

typedef struct {
	DWORD thumbprint_offset;
	DWORD thumbprint_size;
	DWORD container_name_offset;
	DWORD provider_name_offset;
	DWORD user_name_offset;
} MFT_RECORD_ATTRIBUTE_EFS_DF_CERTIFICATE_THUMBPRINT_HEADER, * PMFT_RECORD_ATTRIBUTE_EFS_DF_CERTIFICATE_THUMBPRINT_HEADER;

typedef struct
{
	union
	{
		ULONGLONG FileReference;
		struct
		{
			USHORT DataOffset;
			USHORT DataLength;
			ULONG32 ReservedForZero;
		};
	};
	USHORT Length;
	USHORT AttributeLength;
	USHORT Flags;
	USHORT Reserved;
	union {
		union {
			struct {
				ULONGLONG vcn;
			} asNode;
			struct {
				ULONG32 ReparseTag;
				ULONGLONG FileReference;
			} asKeys;
		} reparse;
		MFT_RECORD_ATTRIBUTE_FILENAME FileName;
	};
} MFT_RECORD_ATTRIBUTE_INDEX_ENTRY, * PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY;

typedef struct
{
	DWORD		AttrType;
	DWORD		CollRule;
	DWORD		IBSize;
	BYTE		ClustersPerIB;
	BYTE		Padding1[3];

	DWORD		EntryOffset;
	DWORD		TotalEntrySize;
	DWORD		AllocEntrySize;
	BYTE		Flags;
	BYTE		Padding2[3];
} MFT_RECORD_ATTRIBUTE_INDEX_ROOT, * PMFT_RECORD_ATTRIBUTE_INDEX_ROOT;

typedef struct
{
	CHAR        signature[4];
	WORD        updateOffset;
	WORD        updateNumber;
	LONGLONG    logFile;
	WORD        sequenceNumber;
	WORD        hardLinkCount;
	WORD        attributeOffset;
	WORD        flag;
	DWORD       usedSize;
	DWORD       allocatedSize;
	LONGLONG    baseRecord;
	WORD        nextAttributeID;
	BYTE        unsed[2];
	DWORD       MFTRecordIndex;
	WORD		updateSequenceNumber;
	WORD		updateSequenceArray[1];
} MFT_RECORD_HEADER, * PMFT_RECORD_HEADER;

typedef struct
{
	BYTE        jump[3];
	BYTE        oemID[8];
	WORD        bytePerSector;
	BYTE        sectorPerCluster;
	BYTE        reserved[2];
	BYTE        zero1[3];
	BYTE        unused1[2];
	BYTE        mediaDescriptor;
	BYTE        zeros2[2];
	WORD        sectorPerTrack;
	WORD        headNumber;
	DWORD       hiddenSector;
	BYTE        unused2[8];
	LONGLONG    totalSector;
	LONGLONG    MFTCluster;
	LONGLONG    MFTMirrCluster;
	INT8		clusterPerRecord;
	BYTE        unused4[3];
	INT8		clusterPerBlock;
	BYTE        unused5[3];
	LONGLONG    serialNumber;
	DWORD       checkSum;
	BYTE        bootCode[0x1aa];
	BYTE		endMarker[2];
} BOOT_SECTOR_NTFS, * PBOOT_SECTOR_NTFS;

#pragma pack(pop)
```

`Sources/NTFS/ntfs_explorer.cpp`:

```cpp
#include "ntfs_explorer.h"

#include "ntfs_mft_record.h"
#include "ntfs_mft.h"
#include <Drive\volume.h>
#include <Drive\disk.h>

NTFSExplorer::NTFSExplorer(std::shared_ptr<Volume> volume)
{
	if (volume->disk_index() != DISK_INDEX_IMAGE)
	{
		_reader = std::make_shared<NTFSReader>(utils::strings::from_string(volume->name()));
	}
	else
	{
		_reader = std::make_shared<NTFSReader>(utils::strings::from_string(reinterpret_cast<Disk*>(volume->parent())->name()), volume->offset());
	}
	_MFT = std::make_shared<MFT>(_reader);
}

NTFSExplorer::~NTFSExplorer()
{
}
```

`Sources/NTFS/ntfs_explorer.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>

#include "ntfs_explorer.h"
#include "ntfs_index_entry.h"
#include "ntfs_mft.h"
#include "ntfs_mft_record.h"
#include "ntfs.h"
#include "ntfs_reader.h"

#include "Drive/volume.h"

#include <memory>
#include <vector>

class NTFSExplorer
{
private:
	std::wstring _volume_name;

	std::shared_ptr<MFT> _MFT;

	std::shared_ptr<NTFSReader> _reader;

public:
	explicit NTFSExplorer(std::shared_ptr<Volume> volume);
	~NTFSExplorer();

	std::wstring volume_name() const { return _volume_name; }

	std::shared_ptr<NTFSReader> reader() { return _reader; }

	HANDLE handle() { return _reader->handle(); }

	std::shared_ptr<MFT> mft() { return _MFT; }
};
```

`Sources/NTFS/ntfs_index_entry.cpp`:

```cpp
#include "ntfs_index_entry.h"

#include "Utils/utils.h"

#include <iostream>

IndexEntry::IndexEntry(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY e, std::string type)
{
	_type = type;

	if (_type == MFT_ATTRIBUTE_INDEX_FILENAME)
	{
		_reference = e->FileReference;
		_parent_reference = e->FileName.ParentDirectory.FileRecordNumber;

		_name = std::wstring(e->FileName.Name);
		_name.resize(e->FileName.NameLength);

		_name_type = e->FileName.NameType;

		_flags = e->Flags;
	}
	if (_type == MFT_ATTRIBUTE_INDEX_REPARSE)
	{
		_reference = e->reparse.asKeys.FileReference;

		_tag = e->reparse.asKeys.ReparseTag;
	}

	_vcn = *POINTER_ADD(PLONGLONG, e, e->Length - 8);
}
```

`Sources/NTFS/ntfs_index_entry.h`:

```h
#pragma once

#include <winsock2.h>
#include <Windows.h>

#include "ntfs.h"

#include <string>

class IndexEntry
{
private:
	DWORD64		_reference;
	DWORD64		_parent_reference;
	std::wstring _name;
	DWORD64		_vcn;
	UCHAR		_name_type;
	DWORD       _tag;
	USHORT		_flags;

	std::string _type;

public:
	explicit IndexEntry(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY e, std::string type);

	std::string type() const { return _type; }

	UCHAR	name_type() const { return _name_type; }

	DWORD64	vcn() const { return _vcn; }
	DWORD	tag() const { return _tag; }
	USHORT	flags() const { return _flags; }

	DWORD64 record_number() const { return _reference & 0xffffffffffff; }

	DWORD64 parent_record_number() const { return _parent_reference & 0xffffffffffff; }

	std::wstring name() const { return _name; }
};

```

`Sources/NTFS/ntfs_mft.cpp`:

```cpp
#include "ntfs_mft.h"
#include "ntfs_mft_record.h"
#include "ntfs_explorer.h"
#include "ntfs_reader.h"

#include <cstring>
#include <iostream>

MFT::MFT(std::shared_ptr<NTFSReader> reader)
{
	_reader = reader;

	_reader->seek(_reader->boot_record()->MFTCluster * _reader->sizes.cluster_size);

	Buffer<PMFT_RECORD_HEADER> rec(_reader->sizes.record_size);
	if (_reader->read(rec.data(), _reader->sizes.record_size))
	{
		_record = std::make_shared<MFTRecord>(rec.data(), this, _reader);

		PMFT_RECORD_ATTRIBUTE_HEADER pAttributeData = _record->attribute_header($DATA);
		if (pAttributeData != nullptr)
		{
			_dataruns = MFTRecord::read_dataruns(pAttributeData);
		}
	}
	else
	{
		wprintf(L"ReadFile on MFTRecord[0] failed");
	}
}

MFT::~MFT()
{
}

std::shared_ptr<MFTRecord> MFT::record_from_path(std::string path, ULONG64 directory_record_number)
{
	std::vector<std::wstring> parts;

	std::filesystem::path p(path);

	if (p.root_directory() != "\\")
	{
		std::cout << "[-] Only absolute paths are supported" << std::endl;
		return nullptr;
	}

	if (p.has_root_name())
	{
		path = path.substr(2);
		p = std::filesystem::path(path);
	}

	for (const auto& part : p)
	{
		parts.push_back(part.generic_wstring());
	}

	std::shared_ptr<MFTRecord> current_dir = record_from_number(directory_record_number);
	std::shared_ptr<MFTRecord> next_dir = nullptr;

	for (size_t i = 1; i < parts.size(); i++)
	{
		bool found = false;
		next_dir = nullptr;
		std::vector<std::shared_ptr<IndexEntry>> index = current_dir->index();
		for (std::shared_ptr<IndexEntry>& entry : index)
		{
			if (_wcsicmp(entry->name().c_str(), parts[i].c_str()) == 0)
			{
				next_dir = record_from_number(entry->record_number());
				found = true;
				break;
			}
		}
		if (!found)
		{
			return nullptr;
		}
		else
		{
			current_dir = next_dir;
		}
	}

	return current_dir;
}

std::shared_ptr<MFTRecord> MFT::record_from_number(ULONG64 record_number)
{
	LONGLONG  sectorOffset = record_number * _reader->sizes.record_size / _reader->boot_record()->bytePerSector;
	DWORD sectorNumber = _reader->sizes.record_size / _reader->boot_record()->bytePerSector;

	std::shared_ptr<Buffer<PMFT_RECORD_HEADER>> buffer = std::make_shared<Buffer<PMFT_RECORD_HEADER>>(_reader->sizes.record_size);

	for (DWORD sector = 0; sector < sectorNumber; sector++)
	{
		ULONGLONG cluster = (sectorOffset + sector) / (_reader->sizes.cluster_size / _reader->boot_record()->bytePerSector);
		LONGLONG vcn = 0LL;
		LONGLONG offset = -1LL;

		for (const MFT_DATARUN& run : _dataruns)
		{
			if (cluster < vcn + run.length)
			{
				offset = (run.offset + cluster - vcn) * _reader->sizes.cluster_size
					+ (sectorOffset + sector) * _reader->boot_record()->bytePerSector % _reader->sizes.cluster_size;
				break;
			}
			vcn += run.length;
		}
		if (offset == -1LL)
		{
			return nullptr;
		}

		_reader->seek(offset);
		if (!_reader->read(buffer->address() + sector * _reader->boot_record()->bytePerSector, _reader->boot_record()->bytePerSector))
		{
			return nullptr;
		}
	}

	return std::make_shared<MFTRecord>(buffer->data(), this, _reader);
}

std::vector<std::tuple<std::wstring, ULONG64>> MFT::list(std::string path, bool directory, bool files)
{
	std::vector<std::tuple<std::wstring, ULONG64>> ret;

	std::shared_ptr<MFTRecord> record = record_from_path(path);

	if (record != nullptr)
	{
		auto index = record->index();

		std::set<DWORD64> win32_named_entries;
		for (auto i : index)
		{
			if (i->name_type() != 2)
			{
				win32_named_entries.insert(i->record_number());
			}
		}

		for (auto& entry : index)
		{
			if ((entry->name_type() == 2) && (win32_named_entries.find(entry->record_number()) != win32_named_entries.end())) continue;

			std::shared_ptr<MFTRecord> entry_rec = record_from_number(entry->record_number());
			if (directory && (entry_rec->header()->flag & MFT_RECORD_IS_DIRECTORY))
			{
				ret.push_back(std::make_tuple(entry->name(), entry->record_number()));
			}
			if (files && ((entry_rec->header()->flag & MFT_RECORD_IS_DIRECTORY) == 0))
			{
				ret.push_back(std::make_tuple(entry->name(), entry->record_number()));
			}
		}
	}

	return ret;
}

```

`Sources/NTFS/ntfs_mft.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>

#include <vector>
#include <string>
#include <memory>

#include <filesystem>

#include "ntfs.h"
#include "ntfs_mft_record.h"
#include "ntfs_explorer.h"
#include "Utils/utils.h"
#include "Utils/buffer.h"

class MFT
{
private:
	std::shared_ptr<MFTRecord> _record;

	std::shared_ptr<NTFSReader> _reader;

	std::vector<MFT_DATARUN> _dataruns;

public:
	explicit MFT(std::shared_ptr<NTFSReader> reader);
	~MFT();

	std::shared_ptr<MFTRecord> record() { return _record; }

	std::shared_ptr<MFTRecord> record_from_path(std::string path, ULONG64 directory_record_number = ROOT_FILE_NAME_INDEX_NUMBER);

	std::shared_ptr<MFTRecord> record_from_number(ULONG64 record_number);

	std::vector<std::tuple<std::wstring, ULONG64>> list(std::string path, bool directory = true, bool files = true);
};
```

`Sources/NTFS/ntfs_mft_record.cpp`:

```cpp
#include "ntfs_mft_record.h"

#include <memory>

#include "Compression/ntdll_defs.h"

#include "Utils/utils.h"
#include "Utils/buffer.h"
#include "NTFS/ntfs_mft.h"
#include "NTFS/ntfs_reader.h"
#include "NTFS/ntfs_index_entry.h"
#include "NTFS/ntfs_explorer.h"
#include <Compression/lznt1.h>
#include <Compression/xpress.h>
#include <Compression/lzx.h>


MFTRecord::MFTRecord(PMFT_RECORD_HEADER pRecordHeader, MFT* mft, std::shared_ptr<NTFSReader> reader)
{
	_reader = reader;
	_mft = mft;

	if (pRecordHeader != NULL)
	{
		_record = std::make_shared<Buffer<PMFT_RECORD_HEADER>>(_reader->sizes.record_size);
		memcpy(_record->data(), pRecordHeader, _reader->sizes.record_size);

		apply_fixups(_record->data(), _record->size(), _record->data()->updateOffset, _record->data()->updateNumber);
	}
}

MFTRecord::~MFTRecord()
{
	_record = nullptr;
}

uint64_t MFTRecord::raw_address()
{
	return _reader->boot_record()->MFTCluster * _reader->sizes.cluster_size + (_record->data()->MFTRecordIndex * _reader->sizes.record_size);
}

uint64_t MFTRecord::raw_address(PMFT_RECORD_ATTRIBUTE_HEADER pAttr, uint64_t offset)
{
	for (auto& dt : read_dataruns(pAttr))
	{
		if (offset >= (dt.length * _reader->sizes.cluster_size))
		{
			offset -= (dt.length * _reader->sizes.cluster_size);
		}
		else
		{
			return (dt.offset * _reader->sizes.cluster_size) + offset;
		}
	}
	return 0;
}

ULONG64 MFTRecord::datasize(std::string stream_name, bool real_size)
{
	if (_record->data()->flag & FILE_RECORD_FLAG_DIR)
	{
		return 0;
	}

	PMFT_RECORD_ATTRIBUTE_HEADER pAttribute = attribute_header($DATA, stream_name);
	if (pAttribute != NULL)
	{
		if (pAttribute->FormCode == RESIDENT_FORM)
		{
			return pAttribute->Form.Resident.ValueLength;
		}
		else
		{
			if (real_size) return pAttribute->Form.Nonresident.FileSize;
			else return pAttribute->Form.Nonresident.AllocatedLength;
		}
	}
	else
	{
		PMFT_RECORD_ATTRIBUTE_HEADER pAttributeList = attribute_header($ATTRIBUTE_LIST);
		if (pAttributeList != NULL)
		{
			std::shared_ptr<Buffer<PMFT_RECORD_ATTRIBUTE>> attribute_list_data = attribute_data<PMFT_RECORD_ATTRIBUTE>(pAttributeList);
			if (attribute_list_data != nullptr)
			{
				DWORD offset = 0;
				while (offset + sizeof(MFT_RECORD_ATTRIBUTE_HEADER) <= attribute_list_data->size())
				{
					PMFT_RECORD_ATTRIBUTE pAttr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE, attribute_list_data->data(), offset);
					if (pAttr->typeID == $DATA)
					{
						std::wstring attr_name = std::wstring(POINTER_ADD(PWCHAR, pAttr, pAttr->nameOffset));
						attr_name.resize(pAttr->nameLength);
						if (((pAttr->nameLength == 0) && (stream_name == "")) || ((pAttr->nameLength > 0) && (stream_name == utils::strings::to_utf8(attr_name))))
						{
							if ((pAttr->recordNumber & 0xffffffffffff) != (header()->MFTRecordIndex & 0xffffffffffff))
							{
								std::shared_ptr<MFTRecord> extRecordHeader = _mft->record_from_number(pAttr->recordNumber & 0xffffffffffff);
								if (extRecordHeader != nullptr)
								{
									return extRecordHeader->datasize(stream_name, real_size);
								}
								else
								{
									break;
								}
							}
							else
							{
								break;
							}
						}
					}

					if (pAttr->recordLength > 0)
					{
						offset += pAttr->recordLength;
					}
					else
					{
						break;
					}
				}
			}
		}
	}
	return 0;
}

std::map<DWORD64, PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK> MFTRecord::parse_index_block(std::shared_ptr<Buffer<PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK>> pIndexBlock)
{
	std::map<DWORD64, PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK> mapVCNToIndexBlock;

	PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK pIndexSubBlockData = pIndexBlock->data();
	DWORD IndexSubBlockDataSize = pIndexBlock->size();
	DWORD blockPos = 0;
	while (blockPos < pIndexBlock->size())
	{
		if (pIndexSubBlockData->Magic == MAGIC_INDX)
		{
			apply_fixups(pIndexSubBlockData, IndexSubBlockDataSize - blockPos, pIndexSubBlockData->OffsetOfUS, pIndexSubBlockData->SizeOfUS);
			mapVCNToIndexBlock[pIndexSubBlockData->VCN] = pIndexSubBlockData;
		}

		blockPos += pIndexSubBlockData->AllocEntrySize + 0x18;
		pIndexSubBlockData = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK, pIndexSubBlockData, pIndexSubBlockData->AllocEntrySize + 0x18);
	}

	return mapVCNToIndexBlock;
}

std::vector<std::shared_ptr<IndexEntry>> parse_entries(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY pIndexEntry, std::map<DWORD64, PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK> vcnToBlock, std::string type)
{
	std::vector<std::shared_ptr<IndexEntry>> ret;
	if (pIndexEntry != nullptr)
	{
		while (TRUE)
		{
			std::shared_ptr<IndexEntry> e = std::make_shared<IndexEntry>(pIndexEntry, type);

			if (pIndexEntry->Flags & MFT_ATTRIBUTE_INDEX_ENTRY_FLAG_SUBNODE)
			{
				PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK block = vcnToBlock[e->vcn()];
				if ((block != nullptr) && (block->Magic == MAGIC_INDX))
				{
					PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY nextEntries = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY, block, block->EntryOffset + 0x18);
					std::vector<std::shared_ptr<IndexEntry>> subentries = parse_entries(nextEntries, vcnToBlock, type);
					ret.insert(ret.end(), subentries.begin(), subentries.end());
				}
			}

			if (pIndexEntry->Flags & MFT_ATTRIBUTE_INDEX_ENTRY_FLAG_LAST)
			{
				if (pIndexEntry->FileReference != 0) ret.push_back(e);
				break;
			}

			ret.push_back(e);

			if (pIndexEntry->Length > 0)
			{
				pIndexEntry = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY, pIndexEntry, pIndexEntry->Length);
			}
			else
			{
				break;
			}
		}
	}
	return ret;
}

std::wstring MFTRecord::filename()
{
	PMFT_RECORD_ATTRIBUTE_HEADER pattr = attribute_header($FILE_NAME, "");
	if (pattr != nullptr)
	{
		auto pattr_filename = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_FILENAME, pattr, pattr->Form.Resident.ValueOffset);
		if (pattr_filename->NameType == 2)
		{
			PMFT_RECORD_ATTRIBUTE_HEADER pattr_long = attribute_header($FILE_NAME, "", 1);
			if (pattr_long != nullptr)
			{
				pattr = pattr_long;
			}
		}
	}

	std::wstring filename;

	if (pattr != nullptr)
	{
		PMFT_RECORD_ATTRIBUTE_FILENAME psubattr = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_FILENAME, pattr, pattr->Form.Resident.ValueOffset);
		filename = std::wstring(psubattr->Name);
		filename.resize(psubattr->NameLength);
	}

	return filename;
}

std::vector<std::shared_ptr<IndexEntry>> MFTRecord::index()
{
	std::vector<std::shared_ptr<IndexEntry>> ret;

	std::string type = MFT_ATTRIBUTE_INDEX_FILENAME;
	PMFT_RECORD_ATTRIBUTE_HEADER pAttr = attribute_header($INDEX_ROOT, type);
	if (pAttr == nullptr)
	{
		type = MFT_ATTRIBUTE_INDEX_REPARSE;
		pAttr = attribute_header($INDEX_ROOT, type);
	}
	if (pAttr == nullptr)
	{
		PMFT_RECORD_ATTRIBUTE_HEADER pAttributeList = attribute_header($ATTRIBUTE_LIST);
		if (pAttributeList != NULL)
		{
			std::shared_ptr<Buffer<PMFT_RECORD_ATTRIBUTE>> attribute_list_data = attribute_data<PMFT_RECORD_ATTRIBUTE>(pAttributeList);
			if (attribute_list_data != nullptr)
			{
				DWORD offset = 0;
				while (offset + sizeof(MFT_RECORD_ATTRIBUTE_HEADER) <= attribute_list_data->size())
				{
					PMFT_RECORD_ATTRIBUTE pAttrListI = POINTER_ADD(PMFT_RECORD_ATTRIBUTE, attribute_list_data->data(), offset);
					if (pAttrListI->typeID == $INDEX_ROOT)
					{
						DWORD64 next_inode = pAttrListI->recordNumber & 0xffffffffffff;
						if (next_inode != _record->data()->MFTRecordIndex)
						{
							std::shared_ptr<MFTRecord> extRecordHeader = _mft->record_from_number(next_inode);
							return extRecordHeader->index();
						}
					}

					if (pAttrListI->recordLength > 0)
					{
						offset += pAttrListI->recordLength;
					}
					else
					{
						break;
					}
				}
			}
		}
	}

	if (pAttr != nullptr)
	{
		PMFT_RECORD_ATTRIBUTE_INDEX_ROOT pAttrIndexRoot = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ROOT, pAttr, pAttr->Form.Resident.ValueOffset);

		std::shared_ptr<Buffer<PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK>> indexBlocks = nullptr;
		std::map<DWORD64, PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK> VCNToBlock;

		if (pAttrIndexRoot->Flags & MFT_ATTRIBUTE_INDEX_ROOT_FLAG_LARGE)
		{
			PMFT_RECORD_ATTRIBUTE_HEADER pAttrAllocation = attribute_header($INDEX_ALLOCATION, type);
			if (pAttrAllocation != nullptr)
			{
				indexBlocks = attribute_data<PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK>(pAttrAllocation);

				VCNToBlock = parse_index_block(indexBlocks);
			}
			else
			{
				wprintf(L"Attribute $INDEX_ALLOCATION not found");
			}
		}

		ret = parse_entries(POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY, pAttrIndexRoot, pAttrIndexRoot->EntryOffset + 0x10), VCNToBlock, type);
	}

	return ret;
}

std::vector<MFT_DATARUN> MFTRecord::read_dataruns(PMFT_RECORD_ATTRIBUTE_HEADER pAttribute)
{
	std::vector<MFT_DATARUN> result;
	LPBYTE runList = POINTER_ADD(LPBYTE, pAttribute, pAttribute->Form.Nonresident.MappingPairsOffset);
	LONGLONG offset = 0LL;

	while (runList[0] != MFT_DATARUN_END)
	{
		int offset_len = runList[0] >> 4;
		int length_len = runList[0] & 0xf;
		runList++;

		ULONGLONG length = 0;
		for (int i = 0; i < length_len; i++)
		{
			length |= (LONGLONG)(runList++[0]) << (i * 8);
		}

		if (offset_len)
		{
			LONGLONG offsetDiff = 0;
			for (int i = 0; i < offset_len; i++)
			{
				offsetDiff |= (LONGLONG)(runList++[0]) << (i * 8);
			}

			if (offsetDiff >= (1LL << ((offset_len * 8) - 1)))
				offsetDiff -= 1LL << (offset_len * 8);

			offset += offsetDiff;
		}

		result.push_back({ offset, length });
	}

	return result;
}

void MFTRecord::apply_fixups(PVOID buffer, DWORD buffer_size, WORD updateOffset, WORD updateSize)
{
	PWORD usarray = POINTER_ADD(PWORD, buffer, updateOffset);
	PWORD sector = (PWORD)buffer;

	DWORD offset = _reader->sizes.sector_size;
	for (DWORD i = 1; i < updateSize; i++)
	{
		if (offset <= buffer_size)
		{
			sector[(offset - 2) / sizeof(WORD)] = usarray[i];
			offset += _reader->sizes.sector_size;
		}
		else
		{
			break;
		}
	}
}

PMFT_RECORD_ATTRIBUTE_HEADER MFTRecord::attribute_header(DWORD type, std::string name, int index)
{
	PMFT_RECORD_ATTRIBUTE_HEADER pAttribute = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_HEADER, _record->data(), _record->data()->attributeOffset);

	while ((pAttribute->TypeCode != $END) && (pAttribute->RecordLength > 0))
	{
		if (pAttribute->TypeCode == type)
		{
			std::string attr_name = utils::strings::to_utf8(std::wstring(POINTER_ADD(PWCHAR, pAttribute, pAttribute->NameOffset), pAttribute->NameLength));
			if (attr_name == name)
			{
				if (index == 0)
				{
					return pAttribute;
				}
				else
				{
					index--;
				}
			}
		}
		pAttribute = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_HEADER, pAttribute, pAttribute->RecordLength);
	}
	return nullptr;
}

ULONG64 MFTRecord::data_to_file(std::wstring dest_filename, std::string stream_name, bool skip_sparse)
{
	ULONG64 written_bytes = 0ULL;

	HANDLE output = CreateFileW(dest_filename.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (output != INVALID_HANDLE_VALUE)
	{
		for (auto& data_block : process_data(stream_name, 1024 * 1024, skip_sparse))
		{
			DWORD written_block;
			if (!WriteFile(output, data_block.first, data_block.second, &written_block, NULL))
			{
				std::cout << "[!] WriteFile failed" << std::endl;
				break;
			}
			else
			{
				written_bytes += written_block;
			}
		}
		CloseHandle(output);
	}
	else
	{
		std::cout << "[!] CreateFile failed" << std::endl;
	}
	return written_bytes;
}

cppcoro::generator<std::pair<PBYTE, DWORD>> MFTRecord::process_data_raw(std::string stream_name, DWORD block_size, bool skip_sparse)
{
	PMFT_RECORD_ATTRIBUTE_HEADER pAttributeData = attribute_header($DATA, stream_name);
	if (pAttributeData != NULL)
	{
		DWORD64 writeSize = 0;
		DWORD64 fixed_blocksize;

		if (pAttributeData->FormCode == RESIDENT_FORM)
		{
			if (pAttributeData->Form.Resident.ValueOffset + pAttributeData->Form.Resident.ValueLength <= pAttributeData->RecordLength)
			{
				PBYTE data = POINTER_ADD(PBYTE, pAttributeData, pAttributeData->Form.Resident.ValueOffset);
				for (DWORD offset = 0; offset < pAttributeData->Form.Resident.ValueLength; offset += block_size)
				{
					co_yield std::pair<PBYTE, DWORD>(data + offset, min(block_size, pAttributeData->Form.Resident.ValueLength - offset));
				}
			}
			else
			{
				std::cout << "[!] Invalid size of resident data" << std::endl;
			}
		}
		else if (pAttributeData->FormCode == NON_RESIDENT_FORM)
		{
			bool err = false;
			std::vector<MFT_DATARUN> data_runs = read_dataruns(pAttributeData);

			if (pAttributeData->Flags & ATTRIBUTE_FLAG_COMPRESSED)
			{
				auto expansion_factor = 0x10ULL;

				LONGLONG last_offset = 0;

				for (const MFT_DATARUN& run : data_runs)
				{
					if (err) break; //-V547

					if (last_offset == run.offset) // Padding run
					{
						continue;
					}
					last_offset = run.offset;

					if (run.offset == 0)
					{
						Buffer<PBYTE> buffer_decompressed(static_cast<DWORD>(block_size));

						RtlZeroMemory(buffer_decompressed.data(), block_size);
						DWORD64 total_size = run.length * _reader->sizes.cluster_size;
						for (DWORD64 i = 0; i < total_size; i += block_size)
						{
							fixed_blocksize = DWORD(min(pAttributeData->Form.Nonresident.FileSize - writeSize, block_size));
							co_yield std::pair<PBYTE, DWORD>(buffer_decompressed.data(), static_cast<DWORD>(fixed_blocksize));
							writeSize += fixed_blocksize;
						}
					}
					else
					{
						_reader->seek(run.offset * _reader->sizes.cluster_size);
						DWORD64 total_size = run.length * _reader->sizes.cluster_size;

						std::shared_ptr<Buffer<PBYTE>> buffer_compressed = std::make_shared<Buffer<PBYTE>>(static_cast<DWORD>(total_size));
						if (!_reader->read(buffer_compressed->data(), static_cast<DWORD>(total_size)))
						{
							std::cout << "[!] ReadFile compressed failed" << std::endl;
							err = true;
							break;
						}

						if (run.length > 0x10) // Uncompressed
						{
							co_yield std::pair<PBYTE, DWORD>(buffer_compressed->data(), buffer_compressed->size());
							writeSize += buffer_compressed->size();
						}
						else
						{
							std::shared_ptr<Buffer<PBYTE>> buffer_decompressed = std::make_shared<Buffer<PBYTE>>(static_cast<DWORD>(total_size * expansion_factor));

							DWORD final_size = 0;
							int dec_status = decompress_lznt1(buffer_compressed, buffer_decompressed, &final_size);

							if (!dec_status)
							{
								co_yield std::pair<PBYTE, DWORD>(buffer_decompressed->data(), final_size);
								writeSize += final_size;
							}
							else
							{
								break;
							}
						}
					}
				}
			}
			else if (stream_name == "WofCompressedData")
			{
				DWORD window_size = 0;
				DWORD is_xpress_compressed = true;

				PMFT_RECORD_ATTRIBUTE_HEADER pAttributeHeaderRP = attribute_header($REPARSE_POINT);
				if (pAttributeHeaderRP != NULL)
				{
					auto pAttributeRP = attribute_data<PMFT_RECORD_ATTRIBUTE_REPARSE_POINT>(pAttributeHeaderRP);
					if (pAttributeRP->data()->ReparseTag = IO_REPARSE_TAG_WOF)
					{
						switch (pAttributeRP->data()->WindowsOverlayFilterBuffer.CompressionAlgorithm)
						{
						case 0: window_size = 4 * 1024; is_xpress_compressed = true; break;
						case 1: window_size = 32 * 1024; is_xpress_compressed = false; break;
						case 2: window_size = 8 * 1024; is_xpress_compressed = true; break;
						case 3: window_size = 16 * 1024; is_xpress_compressed = true; break;
						default:
							window_size = 0;
						}
					}
				}

				if (window_size == 0)
				{
					co_return;
				}

				std::shared_ptr<Buffer<PBYTE>> buffer_compressed = data(stream_name);
				std::shared_ptr<Buffer<PBYTE>> buffer_decompressed = std::make_shared<Buffer<PBYTE>>(datasize("", false));

				DWORD final_size = static_cast<DWORD>(datasize());
				int dec_status = 0;

				if (is_xpress_compressed)
				{
					decompress_xpress(buffer_compressed, buffer_decompressed, window_size, final_size);
				}
				else
				{
					decompress_lzx(buffer_compressed, buffer_decompressed, window_size);
				}

				if (!dec_status)
				{
					co_yield std::pair<PBYTE, DWORD>(buffer_decompressed->data(), buffer_decompressed->size());
					writeSize += buffer_decompressed->size();
				}
			}
			else
			{
				Buffer<PBYTE> buffer(block_size);

				for (const MFT_DATARUN& run : data_runs)
				{
					if (err) break;

					if (run.offset == 0)
					{
						if (!skip_sparse)
						{
							RtlZeroMemory(buffer.data(), block_size);
							DWORD64 total_size = run.length * _reader->sizes.cluster_size;
							for (DWORD64 i = 0; i < total_size; i += block_size)
							{
								fixed_blocksize = DWORD(min(pAttributeData->Form.Nonresident.FileSize - writeSize, block_size));
								co_yield std::pair<PBYTE, DWORD>(buffer.data(), static_cast<DWORD>(fixed_blocksize));
								writeSize += fixed_blocksize;
							}
						}
					}
					else
					{
						_reader->seek(run.offset * _reader->sizes.cluster_size);
						DWORD64 total_size = run.length * _reader->sizes.cluster_size;
						DWORD64 read_block_size = static_cast<DWORD>(min(block_size, total_size));
						for (DWORD64 i = 0; i < total_size; i += read_block_size)
						{
							if (!_reader->read(buffer.data(), static_cast<DWORD>(read_block_size)))
							{
								std::cout << "[!] ReadFile failed" << std::endl;
								err = true;
								break;
							}
							read_block_size = min(read_block_size, total_size - i);
							fixed_blocksize = read_block_size;
							co_yield std::pair<PBYTE, DWORD>(buffer.data(), static_cast<DWORD>(fixed_blocksize));
							writeSize += fixed_blocksize;
						}
					}
				}
			}
		}
	}
	else
	{
		bool data_attribute_found = false;

		PMFT_RECORD_ATTRIBUTE_HEADER pAttributeList = attribute_header($ATTRIBUTE_LIST);
		if (pAttributeList != NULL)
		{
			std::shared_ptr<Buffer<PMFT_RECORD_ATTRIBUTE>> attribute_list_data = attribute_data<PMFT_RECORD_ATTRIBUTE>(pAttributeList);
			if (attribute_list_data != nullptr)
			{
				DWORD offset = 0;

				while (offset + sizeof(MFT_RECORD_ATTRIBUTE) <= attribute_list_data->size())
				{
					PMFT_RECORD_ATTRIBUTE pAttrListI = POINTER_ADD(PMFT_RECORD_ATTRIBUTE, attribute_list_data->data(), offset);
					if (pAttrListI->typeID == $DATA)
					{
						data_attribute_found = true;

						DWORD64 next_inode = pAttrListI->recordNumber & 0xffffffffffff;
						if (next_inode != _record->data()->MFTRecordIndex)
						{
							std::shared_ptr<MFTRecord> extRecordHeader = _mft->record_from_number(pAttrListI->recordNumber & 0xffffffffffff);
							for (std::pair<PBYTE, DWORD> b : extRecordHeader->process_data_raw(stream_name, block_size, skip_sparse))
							{
								co_yield b;
							}
						}
					}

					offset += pAttrListI->recordLength;

					if (pAttrListI->recordLength == 0)
					{
						break;
					}
				}
			}
		}

		if (!data_attribute_found)
		{
			std::cout << "[!] Unable to find corresponding $DATA attribute" << std::endl;
		}
	}
}

cppcoro::generator<std::pair<PBYTE, DWORD>> MFTRecord::process_data(std::string stream_name, DWORD block_size, bool skip_sparse)
{
	ULONG64 final_datasize = datasize("", true);
	bool check_size = final_datasize != 0; // ex: no real size for usn

	for (auto& block : process_data_raw(stream_name, block_size, skip_sparse))
	{
		if (block.second > final_datasize && check_size)
		{
			block.second = static_cast<DWORD>(final_datasize);
		}

		co_yield block;

		if (check_size)
		{
			final_datasize -= block.second;
		}
	}
}

std::shared_ptr<Buffer<PBYTE>> MFTRecord::data(std::string stream_name, bool real_size)
{
	std::shared_ptr<Buffer<PBYTE>> ret = nullptr;

	PMFT_RECORD_ATTRIBUTE_HEADER pAttributeData = attribute_header($DATA, stream_name);
	if (pAttributeData != NULL)
	{
		return attribute_data<PBYTE>(pAttributeData, real_size);
	}
	else
	{
		PMFT_RECORD_ATTRIBUTE_HEADER pAttributeList = attribute_header($ATTRIBUTE_LIST);
		if (pAttributeList != NULL)
		{
			std::shared_ptr<Buffer<PMFT_RECORD_ATTRIBUTE>> attribute_list_data = attribute_data<PMFT_RECORD_ATTRIBUTE>(pAttributeList, real_size);
			if (attribute_list_data != nullptr)
			{
				DWORD offset = 0;
				while (offset + sizeof(MFT_RECORD_ATTRIBUTE_HEADER) <= attribute_list_data->size())
				{
					PMFT_RECORD_ATTRIBUTE pAttrListI = POINTER_ADD(PMFT_RECORD_ATTRIBUTE, attribute_list_data->data(), offset);
					if (pAttrListI->typeID == $DATA)
					{
						std::shared_ptr<MFTRecord> extRecordHeader = _mft->record_from_number(pAttrListI->recordNumber & 0xffffffffffff);
						return extRecordHeader->data(stream_name);
					}

					if (pAttrListI->recordLength > 0)
					{
						offset += pAttrListI->recordLength;
					}
					else
					{
						break;
					}
				}
			}
		}
		std::cout << "[!] Unable to find $DATA attribute" << std::endl;
	}
	return ret;
}

std::vector<std::string> MFTRecord::alternate_data_names()
{
	std::vector<std::string> ret;

	PMFT_RECORD_ATTRIBUTE_HEADER pAttribute = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_HEADER, _record->data(), _record->data()->attributeOffset);
	while (pAttribute->TypeCode != $END)
	{
		if (pAttribute->TypeCode == $DATA)
		{
			if (pAttribute->NameLength != 0)
			{
				std::wstring name = std::wstring(POINTER_ADD(PWCHAR, pAttribute, pAttribute->NameOffset));
				name.resize(pAttribute->NameLength);
				ret.push_back(utils::strings::to_utf8(name));
			}
		}

		if (pAttribute->RecordLength > 0)
		{
			pAttribute = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_HEADER, pAttribute, pAttribute->RecordLength);
		}
		else
		{
			break;
		}

	}

	return ret;
}

```

`Sources/NTFS/ntfs_mft_record.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>
#include <winternl.h>

#include <vector>
#include <memory>
#include <map>
#include <functional>

#include "ntfs.h"
#include "ntfs_index_entry.h"
#include "ntfs_reader.h"

#include "Utils/buffer.h"
#include "Utils/utils.h"

#include <cppcoro/generator.hpp>

#include <memory>
#include <functional>

#define MAGIC_FILE 0x454C4946
#define MAGIC_INDX 0x58444E49

class MFTRecord
{
private:
	std::shared_ptr<NTFSReader> _reader;

	std::shared_ptr<Buffer<PMFT_RECORD_HEADER>> _record = nullptr;

	MFT* _mft = nullptr;

	std::map<DWORD64, PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK> parse_index_block(std::shared_ptr<Buffer<PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK>> pIndexBlock);

public:

	MFTRecord(PMFT_RECORD_HEADER pRH, MFT* mft, std::shared_ptr<NTFSReader> reader);
	~MFTRecord();

	uint64_t raw_address();

	uint64_t raw_address(PMFT_RECORD_ATTRIBUTE_HEADER pAttr, uint64_t offset);

	PMFT_RECORD_HEADER header() { return _record->data(); }

	void apply_fixups(PVOID buffer, DWORD buffer_size, WORD updateOffset, WORD updateSize);

	PMFT_RECORD_ATTRIBUTE_HEADER attribute_header(DWORD type, std::string name = "", int index = 0);

	template<typename T>
	std::shared_ptr<Buffer<T>> attribute_data(PMFT_RECORD_ATTRIBUTE_HEADER pAttributeData, bool real_size = true)
	{
		std::shared_ptr<Buffer<T>> ret = nullptr;

		if (pAttributeData->FormCode == RESIDENT_FORM)
		{
			ret = std::make_shared<Buffer<T>>(pAttributeData->Form.Resident.ValueLength);
			memcpy_s(ret->data(), ret->size(), POINTER_ADD(LPBYTE, pAttributeData, pAttributeData->Form.Resident.ValueOffset), pAttributeData->Form.Resident.ValueLength);
		}
		else if (pAttributeData->FormCode == NON_RESIDENT_FORM)
		{
			ULONGLONG readSize = 0;
			ULONGLONG filesize = pAttributeData->Form.Nonresident.FileSize;

			ret = std::make_shared<Buffer<T>>(pAttributeData->Form.Nonresident.AllocatedLength);

			bool err = false;

			std::vector<MFT_DATARUN> runList = read_dataruns(pAttributeData);
			for (const MFT_DATARUN& run : runList)
			{
				if (err) break; //-V547

				if (run.offset == 0)
				{
					for (ULONGLONG i = 0; i < run.length; i++)
					{
						readSize += min(filesize - readSize, _reader->sizes.cluster_size);
					}
				}
				else
				{
					_reader->seek(run.offset * _reader->sizes.cluster_size);

					if (!_reader->read(POINTER_ADD(PBYTE, ret->data(), DWORD(readSize)), static_cast<DWORD>(run.length) * _reader->sizes.cluster_size))
					{
						std::cout << "[!] ReadFile failed" << std::endl;
						err = true;
						break;
					}
					else
					{
						readSize += min(filesize - readSize, static_cast<DWORD>(run.length) * _reader->sizes.cluster_size);
					}
				}
			}
			if (readSize != filesize)
			{

				std::cout << "[!] Invalid read file size" << std::endl;
				ret = nullptr;
			}
			if (real_size)
			{
				ret->shrink(static_cast<DWORD>(filesize));
			}
		}

		return ret;
	}

	std::wstring filename();

	ULONG64 datasize(std::string stream_name = "", bool real_size = true);

	std::shared_ptr<Buffer<PBYTE>> data(std::string stream_name = "", bool real_size = true);

	ULONG64 data_to_file(std::wstring dest_filename, std::string stream_name = "", bool skip_sparse = false);

	cppcoro::generator<std::pair<PBYTE, DWORD>> process_data_raw(std::string stream_name = "", DWORD blocksize = 1024 * 1024, bool skip_sparse = false);

	cppcoro::generator<std::pair<PBYTE, DWORD>> process_data(std::string stream_name = "", DWORD blocksize = 1024 * 1024, bool skip_sparse = false);

	std::vector<std::string> alternate_data_names();

	std::vector<std::shared_ptr<IndexEntry>> index();

	static std::vector<MFT_DATARUN> read_dataruns(PMFT_RECORD_ATTRIBUTE_HEADER pAttribute);
};
```

`Sources/NTFS/ntfs_reader.cpp`:

```cpp
#include "ntfs_reader.h"

NTFSReader::NTFSReader(std::wstring volume_name, DWORD64 volume_offset) : Reader(volume_name, volume_offset)
{
	PBOOT_SECTOR_NTFS pbs = (PBOOT_SECTOR_NTFS)_boot_record;
	sizes.cluster_size = pbs->bytePerSector * pbs->sectorPerCluster;
	sizes.record_size = pbs->clusterPerRecord >= 0 ? pbs->clusterPerRecord * sizes.cluster_size : 1 << -pbs->clusterPerRecord;
	sizes.block_size = pbs->clusterPerBlock >= 0 ? pbs->clusterPerBlock * sizes.cluster_size : 1 << -pbs->clusterPerBlock;
	sizes.sector_size = pbs->bytePerSector;
}

NTFSReader::~NTFSReader()
{
}
```

`Sources/NTFS/ntfs_reader.h`:

```h
#pragma once

#include <winsock2.h>
#include <Windows.h>

#include "ntfs.h"
#include "Drive/reader.h"

#include <memory>
#include <string>

class NTFSReader : public Reader {
	friend class MFT;
	friend class MFTRecord;
private:

public:
	explicit NTFSReader(std::wstring volume_name, DWORD64 volume_offset = 0);
	~NTFSReader();

	struct {
		ULONG32 cluster_size = 0;

		ULONG32 record_size = 0;

		ULONG32 block_size = 0;

		ULONG32 sector_size = 0;
	} sizes;

	PBOOT_SECTOR_NTFS boot_record() { return (PBOOT_SECTOR_NTFS)&_boot_record; }
};
```

`Sources/Utils/btree.cpp`:

```cpp
#include "Utils/btree.h"
#include <iostream>
#include <Utils/utils.h>

void space(int level = 0, bool leaf = true)
{
	if (leaf)
	{
		for (int i = 0; i < level; i++) std::cout << "     ";
	}
	else
	{
		for (int i = 0; i < level - 1; i++) std::cout << "     ";
		std::cout << "|    ";
	}
}

void node::print(int level)
{
	space(level, true);
	std::cout << " \\___ " << "VCN: " << _vcn << std::endl;
	for (auto& item : _items)
	{
		auto subnode = std::get<1>(item);
		auto inode = std::get<0>(item)->record_number();

		if (subnode != nullptr)
		{
			space(level + 1, true);
			std::cout << "|- " << utils::format::hex6(inode) << (inode == 0 ? " (*)" : (": " + utils::strings::to_utf8(std::get<0>(item)->name()))) << std::endl;
			subnode->print(level + 1);
		}
		else
		{
			if (std::get<0>(item)->record_number() != 0 || std::get<0>(item)->name() == L"$MFT")
			{
				space(level + 1, true);
				std::cout << "|- " << utils::format::hex6(inode) << ": " + utils::strings::to_utf8(std::get<0>(item)->name()) << std::endl;
			}
		}
	}
}

void node::print()
{
	std::cout << "Root" << std::endl;
	for (auto& item : _items)
	{
		auto subnode = std::get<1>(item);

		std::cout << "|- " << utils::format::hex6(std::get<0>(item)->record_number()) << ": " << utils::strings::to_utf8(std::get<0>(item)->name()) << std::endl;

		if (subnode != nullptr)
		{
			subnode->print(0);
		}
	}
}


```

`Sources/Utils/btree.h`:

```h
#pragma once

#include <vector>
#include <memory>
#include <NTFS/ntfs_index_entry.h>

class node
{
private:
	uint64_t _vcn;
	std::vector<std::tuple<std::shared_ptr<IndexEntry>, std::shared_ptr<node>>> _items;



public:
	node(uint64_t vcn)
	{
		_vcn = vcn;
	}

	void add_item(std::shared_ptr<IndexEntry> inode, std::shared_ptr<node> subnodes = nullptr)
	{
		_items.push_back(std::tuple<std::shared_ptr<IndexEntry>, std::shared_ptr<node>>(inode, subnodes));
	}

	void print(int level);

	void print();

	uint64_t vcn() { return _vcn; }

	std::vector<std::tuple<std::shared_ptr<IndexEntry>, std::shared_ptr<node>>>& items() { return _items; }

};

```

`Sources/Utils/buffer.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>
#include <Intsafe.h>

#include <memory>

#include <string>

template< typename T>
class Buffer
{
private:
	T _mem = NULL;
	DWORD _size = 0;

public:
	explicit Buffer() : _mem(NULL), _size(0)
	{
	}

	template< typename V>
	V read_at(DWORD offset)
	{
		return *((V*)(((PBYTE)_mem) + offset));
	}

	explicit Buffer(std::string s)
	{
		_size = s.length();
		_mem = static_cast<T>(malloc(s.length() + 1));
		if (_mem != NULL)
		{
			memcpy_s(_mem, s.length(), s.c_str(), s.length());
		}
		else
		{
			_size = 0;
		}
	}

	explicit Buffer(DWORD64 size)
	{
		_mem = static_cast<T>(malloc(size & 0xffffffff));
		if (_mem != NULL)
		{
			ZeroMemory((void*)_mem, size & 0xffffffff);
			_size = size & 0xffffffff;
		}
		else
		{
			_size = 0;
		}
	}

	explicit Buffer(PBYTE data, DWORD size)
	{
		_mem = static_cast<T>(malloc(size));
		if (_mem != NULL)
		{
			_size = size;
			memcpy_s(_mem, size, data, size);
		}
		else
		{
			_size = 0;
		}
	}

	~Buffer()
	{
		if (_mem != NULL)
		{
			ZeroMemory((void*)_mem, _size);
			free((void*)_mem);

			_mem = NULL;
		}
	}

	DWORD size() const
	{
		return _size;
	}

	T data() const
	{
		return _mem;
	}

	PBYTE address() const
	{
		return (PBYTE)_mem;
	}

	bool is_valid() const
	{
		return _mem != NULL;
	}

	void shrink(DWORD size)
	{
		if (_mem != NULL)
		{
			_size = size;
		}
	}

	bool to_file(std::wstring filename)
	{
		HANDLE hFile = INVALID_HANDLE_VALUE;
		DWORD dwWritten = 0;
		BOOL ret = FALSE;

		if ((hFile = CreateFileW(filename.c_str(), (GENERIC_WRITE), FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, 0, NULL)) != INVALID_HANDLE_VALUE)
		{
			if (WriteFile(hFile, _mem, _size, &dwWritten, NULL))
			{
				if (dwWritten == _size) ret = TRUE;
			}
			CloseHandle(hFile);
		}

		return ret;
	}

	static std::shared_ptr<Buffer<T>> from_file(std::wstring filename)
	{
		HANDLE hFile = INVALID_HANDLE_VALUE;
		DWORD dwWritten = 0;
		std::shared_ptr<Buffer<T>> ret = NULL;

		if ((hFile = CreateFileW(filename.c_str(), (GENERIC_READ), FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
		{
			DWORD dwSizeOfFile = GetFileSize(hFile, NULL);
			if (dwSizeOfFile != INVALID_FILE_SIZE)
			{
				ret = std::make_shared<Buffer<T>>(dwSizeOfFile);
				if (ReadFile(hFile, reinterpret_cast<LPVOID>(ret->data()), ret->size(), &dwWritten, NULL))
				{
					if (dwWritten != ret->size()) ret = NULL;
				}
			}
			CloseHandle(hFile);
		}

		return ret;
	}

	static std::shared_ptr<Buffer<T>> from_hex(std::string hexstring)
	{
		return utils::convert::from_hex(hexstring);
	}

	std::shared_ptr<Buffer<PBYTE>> concat(PBYTE toAddr, size_t toSize)
	{
		std::shared_ptr<Buffer<PBYTE>> conc = std::make_shared<Buffer<PBYTE>>(_size + toSize);
		memcpy_s(conc->data(), conc->size(), _mem, _size);
		memcpy_s(conc->data() + _size, conc->size() - _size, toAddr, toSize);
		return conc;
	}

	void clear()
	{
		if (_mem != NULL)
		{
			ZeroMemory(_mem, _size);
		}
	}

	void resize(DWORD64 size)
	{
		T tmp;
		if (_mem != NULL)
		{
			tmp = static_cast<T>(realloc(_mem, size & 0xffffffff));
			if (tmp != NULL)
			{
				_mem = tmp;
				this->_size = size & 0xffffffff;
			}
			else
			{
				this->_size = 0;
			}
		}
		else
		{
			_mem = static_cast<T>(malloc(size & 0xffffffff));
			if (_mem != NULL)
			{
				ZeroMemory(_mem, size & 0xffffffff);
				this->_size = size & 0xffffffff;
			}
			else
			{
				_size = 0;
			}
		}
	}

	std::wstring to_hex() const
	{
		constexpr wchar_t hexmap[] = { L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7', L'8', L'9', L'a', L'b', L'c', L'd', L'e', L'f' };
		std::wstring s(_size * 2, L' ');
		for (DWORD i = 0; i < _size; ++i)
		{
			s[2 * i] = hexmap[((((PBYTE)_mem)[i]) & 0xF0) >> 4];
			s[2 * i + 1] = hexmap[((PBYTE)_mem)[i] & 0x0F];
		}
		return s;
	}

	void reverse_bytes()
	{
		BYTE* istart = _mem, * iend = istart + _size;
		std::reverse(istart, iend);
	}

	std::string to_base64() const
	{
		return utils::convert::to_base64((const char*)_mem, _size);
	}

	std::string to_string() const
	{
		std::string s = std::string((char*)_mem, _size);
		return s;
	}
};

```

`Sources/Utils/constant_names.cpp`:

```cpp
#include "Utils/constant_names.h"
#include "Utils/utils.h"
#include "Drive/mbr_gpt.h"
#include "Bitlocker/bitlocker.h"
#include "NTFS/ntfs.h"
#include <EFS/certificate_file.h>

#include <map>
#include <vss.h>


std::string constants::disk::smart::attribute_name(DWORD index)
{
	const std::map<DWORD, const PCHAR> attribute_name_map = {
		{0,"Invalid"},
		{ 1, "Read Error Rate" },
		{ 2, "Throughput Performance" },
		{ 3, "Spin Up Time" },
		{ 4, "Start/Stop Count" },
		{ 5, "Reallocated Sector Count" },
		{ 6, "Read Channel Margin" },
		{ 7, "Seek Error Rate" },
		{ 8, "Seek Timer Performance" },
		{ 9, "Power-On Hours Count" },
		{ 10,"Spin Up Retry Count" },
		{ 11,"Calibration Retry Count" },
		{ 12,"Power Cycle Count" },
		{ 13,"Soft Read Error Rate" },
		{ 22,"Current Helium Level" },
		{ 160, "Uncorrectable Sector Count R/W" },
		{ 161, "Remaining Spare Block Percentage" },
		{ 164, "Total Erase Count" },
		{ 165, "Maximum Erase Count" },
		{ 166, "Minimum Erase Count" },
		{ 167, "Average Erase Count" },
		{ 168, "Max Nand Erase Count" },
		{ 169, "Remaining Life Percentage" },
		{ 170, "Available Reserved Space" },
		{ 171, "Ssd Program Fail Count" },
		{ 172, "Ssd Erase Fail Count" },
		{ 173, "Ssd Wear Leveling Count" },
		{ 174, "Unexpected Power Loss Count" },
		{ 175, "Power Loss Protection Failure" },
		{ 176, "Erase Fail Count" },
		{ 177, "Wear Range Delta" },
		{ 178, "Used Reserved Block Count (Chip)" },
		{ 179, "Used Reserved Block Count (Total)" },
		{ 180, "Unused Reserved Block Count Total" },
		{ 181, "Program Fail Count Total" },
		{ 182, "Erase Fail Count" },
		{ 183, "Sata Down Shift Error Count" },
		{ 184, "End-To-End Error" },
		{ 185, "Head Stability" },
		{ 186, "Induced Op Vibration Detection" },
		{ 187, "Reported Uncorrectable Errors" },
		{ 188, "Command Timeout" },
		{ 189, "High Fly Writes" },
		{ 190, "Temperature Difference From 100" },
		{ 191, "G-Sense Error Rate" },
		{ 192, "Power-Off Retract Count" },
		{ 193, "Load/Unload Cycle Count" },
		{ 194, "Temperature" },
		{ 195, "Hardware Ecc Recovered" },
		{ 196, "Reallocation Count" },
		{ 197, "Current Pending Sector Count" },
		{ 198, "Off-Line Scan Uncorrectable Count" },
		{ 199, "Udma Crc Error Rate" },
		{ 200, "Write Error Rate" },
		{ 201, "Soft Read Error Rate" },
		{ 202, "Data Address Mark Errors" },
		{ 203, "Run Out Cancel" },
		{ 204, "Soft Ecc Correction" },
		{ 205, "Thermal Asperity Rate (Tar)" },
		{ 206, "Flying Height" },
		{ 207, "Spin High Current" },
		{ 208, "Spin Buzz" },
		{ 209, "Off-Line Seek Performance" },
		{ 211, "Vibration During Write" },
		{ 212, "Shock During Write" },
		{ 220, "Disk Shift" },
		{ 221, "G-Sense Error Rate" },
		{ 222, "Loaded Hours" },
		{ 223, "Load/Unload Retry Count" },
		{ 224, "Load Friction" },
		{ 225, "Load/Unload Cycle Count" },
		{ 226, "Load-In Time" },
		{ 227, "Torque Amplification Count" },
		{ 228, "Power-Off Retract Count" },
		{ 230, "Life Curve Status" },
		{ 231, "Ssd Life Left" },
		{ 232, "Endurance Remaining" },
		{ 233, "Media Wear Out Indicator" },
		{ 234, "Average Erase Count And Maximum Erase Count" },
		{ 235, "Good Block Count And System Free Block Count" },
		{ 240, "Head Flying Hours" },
		{ 241, "Lifetime Writes From Host Gib" },
		{ 242, "Lifetime Reads From Host Gib" },
		{ 243, "Total Lbas Written Expanded" },
		{ 244, "Total Lbas Read Expanded" },
		{ 249, "Nand Writes Gib" },
		{ 250, "Read Error Retry Rate" },
		{ 251, "Minimum Spares Remaining" },
		{ 252, "Newly Added Bad Flash Block" },
		{ 254, "Free Fall Protection" }
	};

	if (attribute_name_map.find(index) != attribute_name_map.end())
	{
		return attribute_name_map.find(index)->second;
	}
	else
	{
		return "Unknown";
	}
}

std::string constants::disk::smart::devicemap_type(DWORD type)
{
	switch (type)
	{
	case 1 << 0:
		return TEXT("SATA/IDE Master on primary channel");
	case 1 << 1:
		return TEXT("IDE Subordinate on primary channel");
	case 1 << 2:
		return TEXT("IDE Master on secondary channel");
	case 1 << 3:
		return TEXT("IDE Subordinate on secondary channel");
	case 1 << 4:
		return TEXT("ATAPI Master on primary channel");
	case 1 << 5:
		return TEXT("ATAPI Subordinate on primary channel");
	case 1 << 6:
		return TEXT("ATAPI Master on secondary channel");
	case 1 << 7:
		return TEXT("ATAPI Subordinate on secondary channel");
	default:
		return TEXT("UNKNOWN");
	}
}

std::string constants::disk::smart::capabilities(DWORD cap)
{
	std::vector<std::string> ret;

	const std::map<DWORD, const PCHAR> capabilities_map = {
		{ CAP_ATA_ID_CMD, "ATA"},
		{ CAP_ATAPI_ID_CMD, "ATAPI"},
		{ CAP_SMART_CMD, "S.M.A.R.T"}
	};

	for (auto& c : capabilities_map)
	{
		if (cap & c.first) ret.push_back(c.second);
	}

	return utils::strings::join(ret, ", ");
}


std::string constants::disk::mft::file_record_filename_name_type(UCHAR t)
{
	switch (t)
	{
	case 0:
		return TEXT("POSIX");
	case 1:
		return TEXT("WIN32");
	case 2:
		return TEXT("DOS");
	case 3:
		return TEXT("DOS & WIN32");
	default:
		return TEXT("UNKNOWN");
	}
}

std::string constants::disk::mft::efs_type(ULONG32 t)
{
	switch (t)
	{
	case 1: return "CryptoAPI Container";
	case 3: return "Certificate Fingerprint";
	default: return "Unknown type";
	}
}

std::string constants::disk::mft::wof_compression(DWORD c)
{
	switch (c)
	{
	case 0: return "XPRESS 4k";
	case 1: return "LZX 32k";
	case 2: return "XPRESS 8k";
	case 3: return "XPRESS 16k";
	default:
		return TEXT("UNKNOWN");
	}
}


std::string constants::disk::partition_type(DWORD t)
{
	switch (t)
	{
	case PARTITION_STYLE_GPT:
		return TEXT("GPT");
	case PARTITION_STYLE_MBR:
		return TEXT("MBR");
	case PARTITION_STYLE_RAW:
		return TEXT("RAW");
	default:
		return TEXT("UNKNOWN");
	}
}

std::string constants::disk::drive_type(DWORD t)
{
	switch (t)
	{
	case DRIVE_UNKNOWN:
		return TEXT("UNKNOWN");
	case DRIVE_NO_ROOT_DIR:
		return TEXT("No mounted volume");
	case DRIVE_REMOVABLE:
		return TEXT("Removable");
	case DRIVE_FIXED:
		return TEXT("Fixed");
	case DRIVE_REMOTE:
		return TEXT("Remote");
	case DRIVE_CDROM:
		return TEXT("CD-ROM");
	case DRIVE_RAMDISK:
		return TEXT("RAM disk");
	default:
		return TEXT("UNKNOWN");
	}
}

std::string constants::disk::mbr_type(uint8_t type) {
	const char* mbr_types[] = {
		//		00							01								02							03							04					05					06							07								08								09					0A						0B									0C								0D						0E							0F
		/*00*/	"Unused",				"FAT12",						"XENIX root",				"XENIX usr",				"FAT16",			"DOS Extended",	"FAT16 (huge)",			"NTFS / exFAT",				"DELL (spanning) / AIX Boot",	"AIX Data",		"OS/2 Boot / OPUS",	"FAT32",							"FAT32 (LBA)",					"Unknown",					"FAT16 (LBA)",				"DOS Extended (LBA)",
		/*10*/	"Unknown",						"FAT12 (hidden)",				"Config / Diagnostics",	"Unknown",						"FAT16 (hidden)",	"Unknown",				"FAT16 (huge, hidden)",	"NTFS / exFAT (hidden)",		"Unknown",							"Unknown",				"Unknown",					"FAT32 (hidden)",					"FAT32 (LBA, hidden)",			"Unknown",					"FAT16 (LBA, hidden)",		"Unknown",
		/*20*/	"Unknown",						"Unknown",							"Unknown",						"Unknown",						"Unknown",				"Unknown",				"Unknown",						"Rescue (FAT32 or NTFS)",		"Unknown",							"Unknown",				"AFS",					"SylStor",							"Unknown",							"Unknown",					"Unknown",						"Unknown",
		/*30*/	"Unknown",						"Unknown",							"Unknown",						"Unknown",						"Unknown",				"JFS",				"Unknown",						"Unknown",							"THEOS",						"THEOS",			"THEOS",				"THEOS",							"PartitionMagic Recovery",		"Netware (hidden)",	"Unknown",						"Unknown",
		/*40*/	"Pick",					"PPC PReP / RISC Boot",		"LDM/SFS",					"Unknown",						"GoBack",			"Boot-US",			"Unknown",						"Unknown",							"Unknown",							"Unknown",				"Unknown",					"Unknown",								"Oberon",						"QNX4.x",				"QNX4.x",					"QNX4.x",
		/*50*/	"Lynx RTOS",				"Novell",						"Unknown",						"DM 6.0 Aux3",				"DM 6.0 DDO",		"EZ-Drive",		"FAT (AT&T MS-DOS)",		"DrivePro",					"Unknown",							"Unknown",				"Unknown",					"Unknown",								"Unknown",							"Unknown",					"Unknown",						"Unknown",
		/*60*/	"Unknown",						"SpeedStor",					"Unknown",						"UNIX",					"Netware 2",		"Netware 3/4",		"Netware SMS",				"Novell",						"Novell",						"Netware 5+, NSS",	"Unknown",					"Unknown",								"Unknown",							"Unknown",					"Unknown",						"Unknown",
		/*70*/	"DiskSecure Multi-Boot",	"Unknown",							"V7/x86",					"Unknown",						"Scramdisk",		"IBM PC/IX",		"Unknown",						"M2FS/M2CS",					"XOSL FS",						"Unknown",				"Unknown",					"Unknown",								"Unknown",							"Unknown",					"Unknown",						"Unknown",
		/*80*/	"NTFT",					"MINIX",						"Linux Swap / Solaris",	"Linux",					"Hibernation",		"Linux Extended",	"FAT16 (fault tolerant)",	"NTFS (fault tolerant)",		"Linux plaintext part tbl",	"Unknown",				"Linux Kernel",		"FAT32 (fault tolerant)",			"FAT32 (LBA, fault tolerant)",	"FAT12 (hidden, fd)",	"Linux LVM",				"Unknown",
		/*90*/	"FAT16 (hidden, fd)",		"DOS Extended (hidden, fd)",	"FAT16 (huge, hidden, fd)","Hidden Linux",			"Unknown",				"Unknown",				"CHRP ISO-9660",			"FAT32 (hidden, fd)",			"FAT32 (LBA, hidden, fd)",		"Unknown",				"FAT16 (hidden, fd)",	"DOS Extended (LBA, hidden, fd)",	"Unknown",							"Unknown",					"ForthOS",					"BSD/OS",
		/*A0*/	"Hibernation",				"Hibernation",					"Unknown",						"Unknown",						"Unknown",				"BSD",				"OpenBSD",					"NeXTStep",					"Mac OS-X",					"NetBSD",			"Unknown",					"Mac OS-X Boot",					"Unknown",							"Unknown",					"Unknown",						"MacOS X HFS",
		/*B0*/	"BootStar Dummy",			"QNX Neurtino Power-Safe",		"QNX Neurtino Power-Safe",	"QNX Neurtino Power-Safe",	"Unknown",				"Unknown",				"Corrupted FAT16",			"BSDI / Corrupted NTFS",		"BSDI Swap",					"Unknown",				"Unknown",					"Acronis Boot Wizard Hidden",		"Acronis Backup",				"Unknown",					"Solaris 8 Boot",			"Solaris",
		/*C0*/	"Valid NTFT",				"Unknown",							"Hidden Linux",			"Hidden Linux Swap",		"Unknown",				"Unknown",				"Corrupted FAT16",			"Syrinx Boot / Corrupted NTFS","Unknown",							"Unknown",				"Unknown",					"Unknown",								"Unknown",							"Unknown",					"Unknown",						"Unknown",
		/*D0*/	"Unknown",						"Unknown",							"Unknown",						"Unknown",						"Unknown",				"Unknown",				"Unknown",						"Unknown",							"CP/M",						"Unknown",				"Powercopy Backup",	"CP/M",							"Unknown",							"Unknown",					"Dell PowerEdge Server",	"BootIt EMBRM",
		/*E0*/	"Unknown",						"Unknown",							"Unknown",						"Unknown",						"Unknown",				"Unknown",				"Unknown",						"Unknown",							"LUKS",						"Unknown",				"Unknown",					"BeOS BFS",						"SkyOS SkyFS",					"Unknown",					"EFI Header",				"EFI",
		/*F0*/	"Linux/PA-RISC Boot",		"Unknown",							"Unknown",						"Unknown",						"Unknown",				"Unknown",				"Unknown",						"Unknown",							"Unknown",							"Unknown",				"Bochs",				"VMware",							"VMware Swap",					"Linux RAID",			"Windows NT (hidden)",		"Xenix Bad Block Table",
	};
	return mbr_types[type];
}

std::string constants::disk::gpt_type(GUID type) {
	const GUID gpt_guids[] = {
		PARTITION_ENTRY_UNUSED_GUID, PARTITION_MBR_SCHEME_GUID, PARTITION_SYSTEM_GUID, PARTITION_BIOS_BOOT_GUID,
		PARTITION_MSFT_RESERVED_GUID, PARTITION_BASIC_DATA_GUID, PARTITION_LDM_METADATA_GUID, PARTITION_LDM_DATA_GUID, PARTITION_MSFT_RECOVERY_GUID, PARTITION_IBM_GPFS_GUID,
		PARTITION_HPUX_DATA_GUID, PARTITION_HPUX_SERVICE_GUID,
		/*PARTITION_LINUX_DATA_GUID,*/ PARTITION_LINUX_RAID_GUID, PARTITION_LINUX_SWAP_GUID, PARTITION_LINUX_LVM_GUID, PARTITION_LINUX_RESERVED_GUID,
		PARTITION_FREEBSD_BOOT_GUID, PARTITION_FREEBSD_DATA_GUID, PARTITION_FREEBSD_SWAP_GUID, PARTITION_FREEBSD_UFS_GUID, PARTITION_FREEBSD_VINUM_VM_GUID, PARTITION_FREEBSD_ZFS_GUID,
		PARTITION_APPLE_HFSP_GUID, PARTITION_APPLE_UFS_GUID, /*PARTITION_APPLE_ZFS_GUID,*/ PARTITION_APPLE_RAID_GUID, PARTITION_APPLE_RAID_OFFLINE_GUID, PARTITION_APPLE_BOOT_GUID, PARTITION_APPLE_LABEL_GUID, PARTITION_APPLE_TV_RECOVERY_GUID,
		PARTITION_SOLARIS_BOOT_GUID, PARTITION_SOLARIS_ROOT_GUID, PARTITION_SOLARIS_SWAP_GUID, PARTITION_SOLARIS_BACKUP_GUID, PARTITION_SOLARIS_USR_GUID, PARTITION_SOLARIS_VAR_GUID, PARTITION_SOLARIS_HOME_GUID, PARTITION_SOLARIS_ALTERNATE_GUID, PARTITION_SOLARIS_RESERVED_1_GUID, PARTITION_SOLARIS_RESERVED_2_GUID, PARTITION_SOLARIS_RESERVED_3_GUID, PARTITION_SOLARIS_RESERVED_4_GUID, PARTITION_SOLARIS_RESERVED_5_GUID,
		PARTITION_NETBSD_SWAP_GUID, PARTITION_NETBSD_FFS_GUID, PARTITION_NETBSD_LFS_GUID, PARTITION_NETBSD_RAID_GUID, PARTITION_NETBSD_CONCATENATED_GUID, PARTITION_NETBSD_ENCRYPTED_GUID,
		PARTITION_CHROME_KERNEL_GUID, PARTITION_CHROME_ROOTFS_GUID, PARTITION_CHROME_RESERVED_GUID,
	};

	const char* gpt_types[] = {
		"Entry Unused", "MBR Partition Scheme", "EFI System", "BIOS Boot",
		"Microsoft Reserved", "Basic Data", "LDM Metadata", "LDM Data", "WinRE", "IBM GPFS",
		"HPUX Data", "HPUX Service",
		/*"Linux Data",*/ "Linux RAID", "Linux Swap", "Linux LVM", "Linux Reserved",
		"FreeBSD Boot", "FreeBSD Data", "FreeBSD Swap", "FreeBSD UFS", "FreeBSD Vinum VM", "FreeBSD ZFS",
		"Apple HFS+", "Apple UFS", /*"Apple ZFS",*/ "Apple RAID", "Apple RAID Offline", "Apple Boot", "Apple Labe", "Apple TV Recovery",
		"Solaris Boot", "Solaris Root", "Solaris Swap", "Solaris Backup", "Solaris /usr", "Solaris /var", "Solaris /home", "Solaris Alternate", "Solaris Reserved", "Solaris Reserved", "Solaris Reserved", "Solaris Reserved", "Solaris Reserved",
		"NetBSD Swap", "NetBSD FFS", "NetBSD LFS", "NetBSD RAID", "NetBSD Concatenated", "NetBSD Encrypted",
		"ChromeOS Kerne", "ChromeOS rootfs", "ChromeOS Reserved",
	};

	size_t j;
	std::string ret = "Unknown";
	for (j = 0; j < ARRAYSIZE(gpt_guids); ++j) {
		if (IsEqualGUID(type, gpt_guids[j])) {
			ret = gpt_types[j];
			break;
		}
	}

	return ret;
}

std::string constants::disk::media_type(MEDIA_TYPE t)
{
	switch (t) {
	case FixedMedia:
		return "Fixed";
	case RemovableMedia:
		return TEXT("Removable");
	case Unknown:
		return TEXT("Unknown");
	case F5_1Pt2_512:
		return TEXT("5.25\", 1.2MB");
	case F3_1Pt44_512:
		return TEXT("3.5\", 1.44MB");
	case F3_2Pt88_512:
		return TEXT("3.5\", 2.88MB");
	case F3_20Pt8_512:
		return TEXT("3.5\", 20.8MB");
	case F3_720_512:
		return TEXT("3.5\", 720KB");
	case 	F5_360_512:
		return TEXT("5.25\", 360KB");
	case 	F5_320_512:
		return TEXT("5.25\", 320KB");
	case 	F5_320_1024:
		return TEXT("5.25\", 320KB");
	case 	F5_180_512:
		return TEXT("5.25\", 180KB");
	case 	F5_160_512:
		return TEXT("5.25\", 160KB");
	case 	F3_120M_512:
		return TEXT("3.5\", 120M");
	case 	F3_640_512:
		return TEXT("3.5\" , 640KB");
	case 	F5_640_512:
		return TEXT("5.25\", 640KB");
	case 	F5_720_512:
		return TEXT("5.25\", 720KB");
	case 	F3_1Pt2_512:
		return TEXT("3.5\" , 1.2Mb");
	case 	F3_1Pt23_1024:
		return TEXT("3.5\" , 1.23Mb");
	case 	F5_1Pt23_1024:
		return TEXT("5.25\", 1.23MB");
	case 	F3_128Mb_512:
		return TEXT("3.5\" MO 128Mb");
	case 	F3_230Mb_512:
		return TEXT("3.5\" MO 230Mb");
	case 	F8_256_128:
		return TEXT("8\", 256KB");
	case 	F3_200Mb_512:
		return TEXT("3.5\", 200M");
	case 	F3_240M_512:
		return TEXT("3.5\", 240Mb");
	case 	F3_32M_512:
		return TEXT("3.5\", 32Mb");
	default:
		return TEXT("Unknown");
	}
}

std::string constants::bitlocker::state(DWORD s)
{
	switch (s)
	{
	case 0: return "NULL";
	case 1: return "DECRYPTED";
	case 2: return "SWITCHING_ENCRYPTION";
	case 3: return "EOW_ACTIVATED";
	case 4: return "ENCRYPTED";
	case 5: return "SWITCH_ENCRYPTION_PAUSED";
	default:
		return "UNKNOWN";
	}
}

std::string constants::bitlocker::algorithm(DWORD a)
{
	switch (a)
	{
	case 0:
		return "NULL";
	case 0x1000:
	case 0x1001:
		return "STRETCH KEY";
	case 0x2000:
	case 0x2001:
	case 0x2002:
	case 0x2003:
	case 0x2004:
	case 0x2005:
		return "AES-CCM-256";
	case 0x8000:
		return "AES-CBC-128-DIFFUSER";
	case 0x8001:
		return "AES-CBC-256-DIFFUSER";
	case 0x8002:
		return "AES-CBC-128-NODIFFUSER";
	case 0x8003:
		return "AES-CBC-256-NODIFFUSER";
	case 0x8004:
		return "AES-XTS-128";
	case 0x8005:
		return "AES-XTS-256";
	default:
		return "UNKNOWN";
	}
}

std::string constants::bitlocker::fve_entry_type(ULONG32 t)
{
	switch (t)
	{
	case FVE_METADATA_ENTRY_TYPE_PROPERTY: return "Property";
	case FVE_METADATA_ENTRY_TYPE_VMK: return "VMK";
	case FVE_METADATA_ENTRY_TYPE_FKEV: return "FKEV";
	case FVE_METADATA_ENTRY_TYPE_VALIDATION: return "Validation";
	case FVE_METADATA_ENTRY_TYPE_STARTUP_KEY: return "Startup Key";
	case FVE_METADATA_ENTRY_TYPE_DRIVE_LABEL: return "Drive Label";
	case FVE_METADATA_ENTRY_TYPE_AUTO_UNLOCK: return "Auto Unlock";
	case FVE_METADATA_ENTRY_TYPE_VOLUME_HEADER_BLOCK: return "Volume Header Block";
	default:
		return "Unknown (" + utils::format::hex(t) + ")";
	}
}

std::string constants::bitlocker::fve_value_type(ULONG32 t)
{
	switch (t)
	{
	case FVE_METADATA_ENTRY_VALUE_TYPE_ERASED: return "Erased";
	case FVE_METADATA_ENTRY_VALUE_TYPE_KEY: return "Key";
	case FVE_METADATA_ENTRY_VALUE_TYPE_UNICODE_STRING: return "Unicode";
	case FVE_METADATA_ENTRY_VALUE_TYPE_STRETCH_KEY: return "Stretch Key";
	case FVE_METADATA_ENTRY_VALUE_TYPE_USE_KEY: return "Use key";
	case FVE_METADATA_ENTRY_VALUE_TYPE_AES_CCM_ENCRYPTED_KEY: return "AES-CCM";
	case FVE_METADATA_ENTRY_VALUE_TYPE_TPM_ENCODED_KEY: return "TPM Encoded";
	case FVE_METADATA_ENTRY_VALUE_TYPE_VALIDATION: return "Validation";
	case FVE_METADATA_ENTRY_VALUE_TYPE_VOLUME_MASTER_KEY: return "VMK";
	case FVE_METADATA_ENTRY_VALUE_TYPE_EXTERNAL_KEY: return "External Key";
	case FVE_METADATA_ENTRY_VALUE_TYPE_UPDATE: return "Update";
	case FVE_METADATA_ENTRY_VALUE_TYPE_ERROR: return "Error";
	case FVE_METADATA_ENTRY_VALUE_TYPE_ASYMMETRIC_ENCRYPTION: return "Asymmetric Encryption";
	case FVE_METADATA_ENTRY_VALUE_TYPE_EXPORTED_KEY: return "Exported Key";
	case FVE_METADATA_ENTRY_VALUE_TYPE_PUBLIC_KEY: return "Public Key";
	case FVE_METADATA_ENTRY_VALUE_TYPE_OFFSET_AND_SIZE: return "Offset and Size";
	case FVE_METADATA_ENTRY_VALUE_TYPE_CONCAT_HASH_KEY: return "Concat Hash Key";
	default:
		return "Unknown (" + std::to_string(t) + ")";
	}
}

std::string constants::bitlocker::fve_key_protection_type(ULONG32 t)
{
	switch (t)
	{
	case FVE_METADATA_KEY_PROTECTION_TYPE_CLEARTEXT: return "Unprotected";
	case FVE_METADATA_KEY_PROTECTION_TYPE_TPM: return "TPM";
	case FVE_METADATA_KEY_PROTECTION_TYPE_STARTUP_KEY: return "Startup Key";
	case FVE_METADATA_KEY_PROTECTION_TYPE_TPM_PIN: return "TPM and PIN";
	case FVE_METADATA_KEY_PROTECTION_TYPE_RECOVERY_PASSWORD: return "Recovery Password";
	case FVE_METADATA_KEY_PROTECTION_TYPE_PASSWORD: return "Password";
	default:
		return "Unknown (" + utils::format::hex(t) + ")";
	}
}

std::string constants::disk::mft::file_record_flags(ULONG32 f)
{
	switch (f)
	{
	case 0: return "Not in use";
	case MFT_RECORD_IN_USE: return "In use";
	case MFT_RECORD_IS_DIRECTORY: return "Directory";
	case MFT_RECORD_IN_USE | MFT_RECORD_IS_DIRECTORY: return "Directory in use";
	default:
		return "Unknown (" + utils::format::hex(f) + ")";
	}
}

std::string constants::disk::mft::file_record_attribute_type(ULONG32 a)
{
	switch (a)
	{
	case $STANDARD_INFORMATION: return "$STANDARD_INFORMATION";
	case $ATTRIBUTE_LIST: return "$ATTRIBUTE_LIST";
	case $FILE_NAME: return "$FILE_NAME";
	case $OBJECT_ID: return "$OBJECT_ID";
	case $SECURITY_DESCRIPTOR: return "$SECURITY_DESCRIPTOR";
	case $VOLUME_NAME: return "$VOLUME_NAME";
	case $VOLUME_INFORMATION: return "$VOLUME_INFORMATION";
	case $DATA: return "$DATA";
	case $INDEX_ROOT: return "$INDEX_ROOT";
	case $INDEX_ALLOCATION: return "$INDEX_ALLOCATION";
	case $BITMAP: return "$BITMAP";
	case $REPARSE_POINT: return "$REPARSE_POINT";
	case $EA_INFORMATION: return "$EA_INFORMATION";
	case $EA: return "$EA";
	case $LOGGED_UTILITY_STREAM: return "$LOGGED_UTILITY_STREAM";
	case $END: return "$END";
	default:
		return "Unknown (" + utils::format::hex(a) + ")";
	}
}

std::string constants::disk::mft::file_record_index_root_attribute_flag(ULONG32 f)
{
	switch (f)
	{
	case MFT_ATTRIBUTE_INDEX_ROOT_FLAG_SMALL: return "Small Index";
	case MFT_ATTRIBUTE_INDEX_ROOT_FLAG_LARGE: return "Large Index";
	default:
		return "Unknown (" + utils::format::hex(f) + ")";
	}
}

std::string constants::disk::mft::file_record_index_root_attribute_type(ULONG32 a)
{
	switch (a)
	{
	case 0x30: return "Filename";
	case 0x00: return "Reparse points";
	default:
		return "Unknown (" + utils::format::hex(a) + ")";
	}
}

std::string constants::disk::mft::file_record_reparse_point_type(ULONG32 tag)
{
	switch (tag)
	{
	case IO_REPARSE_TAG_MOUNT_POINT: return "Mount Point";
	case IO_REPARSE_TAG_HSM: return "Hierarchical Storage Manager";
	case IO_REPARSE_TAG_HSM2: return "Hierarchical Storage Manager 2";
	case IO_REPARSE_TAG_SIS: return "Single-instance Storage";
	case IO_REPARSE_TAG_WIM: return "WIM Mount";
	case IO_REPARSE_TAG_CSV: return "Clustered Shared Volumes";
	case IO_REPARSE_TAG_DFS: return "Distributed File System";
	case IO_REPARSE_TAG_SYMLINK: return "Symbolic Link";
	case IO_REPARSE_TAG_DFSR: return "DFS filter";
	case IO_REPARSE_TAG_DEDUP: return "Data Deduplication";
	case IO_REPARSE_TAG_NFS: return "Network File System";
	case IO_REPARSE_TAG_FILE_PLACEHOLDER: return "Windows Shell 8.1";
	case IO_REPARSE_TAG_WOF: return "Windows Overlay";
	case IO_REPARSE_TAG_WCI: return "Windows Container Isolation";
	case IO_REPARSE_TAG_WCI_1: return "Windows Container Isolation";
	case IO_REPARSE_TAG_GLOBAL_REPARSE: return "NPFS";
	case IO_REPARSE_TAG_CLOUD: return "Cloud Files";
	case IO_REPARSE_TAG_CLOUD_1: return "Cloud Files (1)";
	case IO_REPARSE_TAG_CLOUD_2: return "Cloud Files (2)";
	case IO_REPARSE_TAG_CLOUD_3: return "Cloud Files (3)";
	case IO_REPARSE_TAG_CLOUD_4: return "Cloud Files (4)";
	case IO_REPARSE_TAG_CLOUD_5: return "Cloud Files (5)";
	case IO_REPARSE_TAG_CLOUD_6: return "Cloud Files (6)";
	case IO_REPARSE_TAG_CLOUD_7: return "Cloud Files (7)";
	case IO_REPARSE_TAG_CLOUD_8: return "Cloud Files (8)";
	case IO_REPARSE_TAG_CLOUD_9: return "Cloud Files (9)";
	case IO_REPARSE_TAG_CLOUD_A: return "Cloud Files (A)";
	case IO_REPARSE_TAG_CLOUD_B: return "Cloud Files (B)";
	case IO_REPARSE_TAG_CLOUD_C: return "Cloud Files (C)";
	case IO_REPARSE_TAG_CLOUD_D: return "Cloud Files (D)";
	case IO_REPARSE_TAG_CLOUD_E: return "Cloud Files (E)";
	case IO_REPARSE_TAG_CLOUD_F: return "Cloud Files (F)";
	case IO_REPARSE_TAG_CLOUD_MASK: return "Cloud Files Mask";
	case IO_REPARSE_TAG_APPEXECLINK: return "AppExecLink";
	case IO_REPARSE_TAG_PROJFS: return "Windows Projected File System";
	case IO_REPARSE_TAG_STORAGE_SYNC: return "Azure File Sync";
	case IO_REPARSE_TAG_WCI_TOMBSTONE: return "Windows Container Isolation";
	case IO_REPARSE_TAG_UNHANDLED: return "Windows Container Isolation";
	case IO_REPARSE_TAG_ONEDRIVE: return "One Drive";
	case IO_REPARSE_TAG_PROJFS_TOMBSTONE: return "Windows Projected File System";
	case IO_REPARSE_TAG_AF_UNIX: return "Windows Subsystem for Linux Socket";
	default:
		return "Unknown (0x" + utils::format::hex(tag) + ")";
	}
}

std::string constants::disk::usn::reasons(DWORD reason)
{
	std::vector<std::string> ret;

	const std::map<DWORD, const PCHAR> reasons_map = {
		{ 0x1, "DATA_OVERWRITE"},
		{ 0x2, "DATA_EXTEND"},
		{ 0x4, "DATA_TRUNCATION"},
		{ 0x10, "NAMED_DATA_OVERWRITE"},
		{ 0x20, "NAMED_DATA_EXTEND"},
		{ 0x40, "NAMED_DATA_TRUNCATION"},
		{ 0x100, "FILE_CREATE"},
		{ 0x200, "FILE_DELETE"},
		{ 0x400, "EA_CHANGE"},
		{ 0x800, "SECURITY_CHANGE"},
		{ 0x1000, "RENAME_OLD_NAME"},
		{ 0x2000, "RENAME_NEW_NAME"},
		{ 0x4000, "INDEXABLE_CHANGE"},
		{ 0x8000, "BASIC_INFO_CHANGE"},
		{ 0x10000, "HARD_LINK_CHANGE"},
		{ 0x20000, "COMPRESSION_CHANGE"},
		{ 0x40000, "ENCRYPTION_CHANGE"},
		{ 0x80000, "OBJECT_ID_CHANGE"},
		{ 0x100000, "REPARSE_POINT_CHANGE"},
		{ 0x200000, "STREAM_CHANGE"},
		{ 0x80000000, "CLOSE"}
	};

	for (auto& r : reasons_map)
	{
		if (reason & r.first) ret.push_back(r.second);
	}

	return utils::strings::join(ret, "+");
}

std::string constants::disk::usn::fileattributes(DWORD attributes)
{
	std::vector<std::string> ret;

	const std::map<DWORD, const PCHAR> attributes_map = {
		{ 0x1, "READONLY"},
		{ 0x2, "HIDDEN"},
		{ 0x4, "SYSTEM"},
		{ 0x10, "DIRECTORY"},
		{ 0x20, "ARCHIVE"},
		{ 0x40, "DEVICE"},
		{ 0x80, "NORMAL"},
		{ 0x100, "TEMPORARY"},
		{ 0x200, "SPARSE_FILE"},
		{ 0x400, "REPARSE_POINT"},
		{ 0x800, "COMPRESSED"},
		{ 0x1000, "OFFLINE"},
		{ 0x2000, "NOT_CONTENT_INDEXED"},
		{ 0x4000, "ENCRYPTED"},
		{ 0x8000, "INTEGRITY_STREAM"},
		{ 0x10000, "VIRTUAL"},
		{ 0x20000, "NO_SCRUB_DATA"},
	};

	for (auto& r : attributes_map)
	{
		if (attributes & r.first) ret.push_back(r.second);
	}

	return utils::strings::join(ret, "+");
}

std::string constants::disk::logfile::operation(WORD w)
{
	switch (w) {
	case LOG_RECORD_OP_NOOP: return "Noop";
	case LOG_RECORD_OP_COMPENSATION_LOG_RECORD: return "CompensationLogRecord";
	case LOG_RECORD_OP_INITIALIZE_FILE_RECORD_SEGMENT: return "InitializeFileRecordSegment";
	case LOG_RECORD_OP_DEALLOCATE_FILE_RECORD_SEGMENT: return "DeallocateFileRecordSegment";
	case LOG_RECORD_OP_WRITE_END_OF_FILE_RECORD_SEGMENT: return "WriteEndOfFileRecordSegment";
	case LOG_RECORD_OP_CREATE_ATTRIBUTE: return "CreateAttribute";
	case LOG_RECORD_OP_DELETE_ATTRIBUTE: return "DeleteAttribute";
	case LOG_RECORD_OP_UPDATE_RESIDENT_VALUE: return "UpdateResidentValue";
	case LOG_RECORD_OP_UPDATE_NONRESIDENT_VALUE: return "UpdateNonresidentValue";
	case LOG_RECORD_OP_UPDATE_MAPPING_PAIRS: return "UpdateMappingPairs";
	case LOG_RECORD_OP_DELETE_DIRTY_CLUSTERS: return "DeleteDirtyClusters";
	case LOG_RECORD_OP_SET_NEW_ATTRIBUTE_SIZES: return "SetNewAttributeSizes";
	case LOG_RECORD_OP_ADD_INDEX_ENTRY_ROOT: return "AddIndexEntryRoot";
	case LOG_RECORD_OP_DELETE_INDEX_ENTRY_ROOT: return "DeleteIndexEntryRoot";
	case LOG_RECORD_OP_ADD_INDEX_ENTRY_ALLOCATION: return "AddIndexEntryAllocation";
	case LOG_RECORD_OP_DELETE_INDEX_ENTRY_ALLOCATION: return "DeleteIndexEntryAllocation";
	case LOG_RECORD_OP_SET_INDEX_ENTRY_VCN_ALLOCATION: return "SetIndexEntryVCNAllocation";
	case LOG_RECORD_OP_UPDATE_FILE_NAME_ROOT: return "UpdateFileNameRoot";
	case LOG_RECORD_OP_UPDATE_FILE_NAME_ALLOCATION: return "UpdateFileNameAllocation";
	case LOG_RECORD_OP_SET_BITS_IN_NONRESIDENT_BIT_MAP: return "SetBitsInNonresidentBitMap";
	case LOG_RECORD_OP_CLEAR_BITS_IN_NONRESIDENT_BIT_MAP: return "ClearBitsInNonresidentBitMap";
	case LOG_RECORD_OP_PREPARE_TRANSACTION: return "PrepareTransaction";
	case LOG_RECORD_OP_COMMIT_TRANSACTION: return "CommitTransaction";
	case LOG_RECORD_OP_FORGET_TRANSACTION: return "ForgetTransaction";
	case LOG_RECORD_OP_OPEN_NONRESIDENT_ATTRIBUTE: return "OpenNonresidentAttribute";
	case LOG_RECORD_OP_DIRTY_PAGE_TABLE_DUMP: return "DirtyPageTableDump";
	case LOG_RECORD_OP_TRANSACTION_TABLE_DUMP: return "TransactionTableDump";
	case LOG_RECORD_OP_UPDATE_RECORD_DATA_ROOT: return "UpdateRecordDataRoot";
	default:
		return "Invalid";
	}
}

std::string constants::disk::vss::state(DWORD64 s)
{
	switch (s)
	{
	case VSS_SS_UNKNOWN: return "Unknown";
	case VSS_SS_PREPARING: return "Preparing";
	case VSS_SS_PROCESSING_PREPARE: return "Processing prepare";
	case VSS_SS_PREPARED: return "Prepared";
	case VSS_SS_PROCESSING_PRECOMMIT: return "Processing precommit";
	case VSS_SS_PRECOMMITTED: return "Precommitted";
	case VSS_SS_PROCESSING_COMMIT: return "Processing committed";
	case VSS_SS_COMMITTED: return "Committed";
	case VSS_SS_PROCESSING_POSTCOMMIT: return "Processing postcommit";
	case VSS_SS_PROCESSING_PREFINALCOMMIT: return "Processing prefinalcommit";
	case VSS_SS_PREFINALCOMMITTED: return "Prefinalcommitted";
	case VSS_SS_PROCESSING_POSTFINALCOMMIT: return "Processing postfinalcommit";
	case VSS_SS_CREATED: return "Created";
	case VSS_SS_ABORTED: return "Aborted";
	case VSS_SS_DELETED: return "Deleted";
	case VSS_SS_POSTCOMMITTED: return "Postcommitted";
	case VSS_SS_COUNT: return "Count";
	default:
		return "Unknown";
	}
}

std::vector<std::string> constants::disk::vss::flags(DWORD64 f)
{
	std::vector<std::string> ret;

	if (f & VSS_VOLSNAP_ATTR_PERSISTENT) ret.push_back("Persistent");
	if (f & VSS_VOLSNAP_ATTR_NO_AUTORECOVERY) ret.push_back("No Autorecovery");
	if (f & VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE) ret.push_back("Client Accessible");
	if (f & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) ret.push_back("No Auto Release");
	if (f & VSS_VOLSNAP_ATTR_NO_WRITERS) ret.push_back("No Writers");
	if (f & VSS_VOLSNAP_ATTR_TRANSPORTABLE) ret.push_back("Transportable");
	if (f & VSS_VOLSNAP_ATTR_NOT_SURFACED) ret.push_back("Not Surfaced");
	if (f & VSS_VOLSNAP_ATTR_NOT_TRANSACTED) ret.push_back("Not Transacted");
	if (f & VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED) ret.push_back("Hardware Assisted");
	if (f & VSS_VOLSNAP_ATTR_DIFFERENTIAL) ret.push_back("Differential");
	if (f & VSS_VOLSNAP_ATTR_PLEX) ret.push_back("Plex");
	if (f & VSS_VOLSNAP_ATTR_IMPORTED) ret.push_back("Imported");
	if (f & VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY) ret.push_back("Exposed Locally");
	if (f & VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY) ret.push_back("Exposed Remotely");
	if (f & VSS_VOLSNAP_ATTR_AUTORECOVER) ret.push_back("Auto Recover");
	if (f & VSS_VOLSNAP_ATTR_ROLLBACK_RECOVERY) ret.push_back("Rollback Recovery");
	if (f & VSS_VOLSNAP_ATTR_DELAYED_POSTSNAPSHOT) ret.push_back("Delayed Postsnapshot");
	if (f & VSS_VOLSNAP_ATTR_TXF_RECOVERY) ret.push_back("TXF Recovery");
	if (f & VSS_VOLSNAP_ATTR_FILE_SHARE) ret.push_back("File Share");

	return ret;
}

std::string constants::efs::hash_algorithm(DWORD hash_alg)
{
	switch (hash_alg)
	{
	case CALG_MD4: return "CALG_MD4";
	case CALG_MD5: return "CALG_MD5";
	case CALG_SHA1: return "CALG_SHA1";
	case CALG_SHA_256: return "CALG_SHA_256";
	case CALG_SHA_384: return "CALG_SHA_384";
	case CALG_SHA_512: return "CALG_SHA_512";
	default:
		return "Unsupported";
	}
}

std::string constants::efs::enc_algorithm(DWORD enc_alg)
{
	switch (enc_alg)
	{
	case CALG_3DES: return "CALG_3DES";
	case CALG_AES_128: return "CALG_AES_128";
	case CALG_AES_192: return "CALG_AES_192";
	case CALG_AES_256: return "CALG_AES_256";
	case CALG_DES: return "CALG_DES";
	case CALG_DESX: return "CALG_DESX";
	default:
		return "Unsupported";
	}
}

std::vector<std::string> constants::efs::permissions(DWORD p)
{
	const static std::map<DWORD, std::string> perms = {
		{CRYPT_ENCRYPT, "CRYPT_ENCRYPT"},
		{CRYPT_DECRYPT, "CRYPT_DECRYPT"},
		{CRYPT_EXPORT , "CRYPT_EXPORT"},
		{CRYPT_READ , "CRYPT_READ"},
		{CRYPT_WRITE, "CRYPT_WRITE"},
		{CRYPT_MAC, "CRYPT_MAC"},
		{CRYPT_EXPORT_KEY , "CRYPT_EXPORT_KEY"},
		{CRYPT_IMPORT_KEY , "CRYPT_IMPORT_KEY"},
	};

	std::vector<std::string> ret;

	for (auto& perm : perms)
	{
		if (p & perm.first)
		{
			ret.push_back(perm.second);
		}
	}

	return ret;
}

std::string constants::efs::cert_prop_provider_type(DWORD t)
{
	switch (t)
	{
	case 0: return "NO_PROV";
	case PROV_RSA_FULL: return "PROV_RSA_FULL";
	case PROV_RSA_SIG: return "PROV_RSA_SIG";
	case PROV_DSS: return "PROV_DSS";
	case PROV_FORTEZZA: return "PROV_FORTEZZA";
	case PROV_MS_EXCHANGE: return "PROV_MS_EXCHANGE";
	case PROV_SSL: return "PROV_SSL";
	case PROV_RSA_SCHANNEL: return "PROV_RSA_SCHANNEL";
	case PROV_DSS_DH: return "PROV_DSS_DH";
	case PROV_EC_ECDSA_SIG: return "PROV_EC_ECDSA_SIG";
	case PROV_EC_ECNRA_SIG: return "PROV_EC_ECNRA_SIG";
	case PROV_EC_ECDSA_FULL: return "PROV_EC_ECDSA_FULL";
	case PROV_EC_ECNRA_FULL: return "PROV_EC_ECNRA_FULL";
	case PROV_DH_SCHANNEL: return "PROV_DH_SCHANNEL";
	case PROV_SPYRUS_LYNKS: return "PROV_SPYRUS_LYNKS";
	case PROV_RNG: return "PROV_RNG";
	case PROV_INTEL_SEC: return "PROV_INTEL_SEC";
	case PROV_REPLACE_OWF: return "PROV_REPLACE_OWF";
	case PROV_RSA_AES: return "PROV_RSA_AES";
	default: return "UNK_PROV (" + utils::format::hex(t, true) + ")";
	}
}

std::string constants::efs::cert_prop_flags(DWORD f)
{
	std::vector<std::string> ret;
	if (f & CERT_SET_KEY_CONTEXT_PROP_ID) ret.push_back("SET_KEY_CONTEXT_PROP_ID");
	if (f & CRYPT_MACHINE_KEYSET) ret.push_back("CRYPT_MACHINE_KEYSET");
	else ret.push_back("CRYPT_USER_KEYSET");
	if (f & CRYPT_SILENT) ret.push_back("CRYPT_SILENT");
	return utils::strings::join(ret, " | ");
}

std::string constants::efs::cert_prop_keyspec(DWORD k)
{
	switch (k)
	{
	case 0: return "NO_KEYSPEC";
	case AT_KEYEXCHANGE: return "AT_KEYEXCHANGE";
	case AT_SIGNATURE: return "AT_SIGNATURE";
	default:
		return "UNK_KEYSPEC (" + utils::format::hex(k, true) + ")";
	}
}

std::string constants::efs::export_flag(DWORD f)
{
	std::string ret;

	if (f & NCRYPT_ALLOW_EXPORT_FLAG) ret += "ALLOW_EXPORT_FLAG";
	if (f & NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG) ret += "PLAINTEXT_EXPORT_FLAG";
	if (f & NCRYPT_ALLOW_ARCHIVING_FLAG) ret += "ALLOW_ARCHIVING_FLAG";
	if (f & NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG) ret += "PLAINTEXT_ARCHIVING_FLAG";

	return ret;
}

std::string constants::efs::cert_prop_id(DWORD p)
{
	switch (p)
	{
	case CERT_CERTIFICATE_FILE: return "CERTIFICATE_FILE_PROP_ID";
	case CERT_CERTIFICATE_REVOCATION_LIST: return "CERTIFICATE_REVOCATION_LIST_PROP_ID";
	case CERT_CERTIFICATE_TRUST_LIST: return "CERTIFICATE_TRUST_LIST_PROP_ID";
	case CERT_KEY_ID: return "KEY_ID_PROP_ID";
	case CERT_KEY_PROV_HANDLE_PROP_ID: return "KEY_PROV_HANDLE_PROP_ID";
	case CERT_KEY_PROV_INFO_PROP_ID: return "KEY_PROV_INFO_PROP_ID";
	case CERT_SHA1_HASH_PROP_ID: return "SHA1_HASH_PROP_ID";
	case CERT_MD5_HASH_PROP_ID: return "MD5_HASH_PROP_ID";
	case CERT_KEY_CONTEXT_PROP_ID: return "KEY_CONTEXT_PROP_ID";
	case CERT_KEY_SPEC_PROP_ID: return "KEY_SPEC_PROP_ID";
	case CERT_IE30_RESERVED_PROP_ID: return "IE30_RESERVED_PROP_ID";
	case CERT_PUBKEY_HASH_RESERVED_PROP_ID: return "PUBKEY_HASH_RESERVED_PROP_ID";
	case CERT_ENHKEY_USAGE_PROP_ID: return "ENHKEY_USAGE_PROP_ID";
	case CERT_NEXT_UPDATE_LOCATION_PROP_ID: return "NEXT_UPDATE_LOCATION_PROP_ID";
	case CERT_FRIENDLY_NAME_PROP_ID: return "FRIENDLY_NAME_PROP_ID";
	case CERT_PVK_FILE_PROP_ID: return "PVK_FILE_PROP_ID";
	case CERT_DESCRIPTION_PROP_ID: return "DESCRIPTION_PROP_ID";
	case CERT_ACCESS_STATE_PROP_ID: return "ACCESS_STATE_PROP_ID";
	case CERT_SIGNATURE_HASH_PROP_ID: return "SIGNATURE_HASH_PROP_ID";
	case CERT_SMART_CARD_DATA_PROP_ID: return "SMART_CARD_DATA_PROP_ID";
	case CERT_EFS_PROP_ID: return "EFS_PROP_ID";
	case CERT_FORTEZZA_DATA_PROP_ID: return "FORTEZZA_DATA_PROP_ID";
	case CERT_ARCHIVED_PROP_ID: return "ARCHIVED_PROP_ID";
	case CERT_KEY_IDENTIFIER_PROP_ID: return "KEY_IDENTIFIER_PROP_ID";
	case CERT_AUTO_ENROLL_PROP_ID: return "AUTO_ENROLL_PROP_ID";
	case CERT_PUBKEY_ALG_PARA_PROP_ID: return "PUBKEY_ALG_PARA_PROP_ID";
	case CERT_CROSS_CERT_DIST_POINTS_PROP_ID: return "CROSS_CERT_DIST_POINTS_PROP_ID";
	case CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID: return "ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID";
	case CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID: return "SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID";
	case CERT_ENROLLMENT_PROP_ID: return "ENROLLMENT_PROP_ID";
	case CERT_DATE_STAMP_PROP_ID: return "DATE_STAMP_PROP_ID";
	case CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID: return "ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID";
	case CERT_SUBJECT_NAME_MD5_HASH_PROP_ID: return "SUBJECT_NAME_MD5_HASH_PROP_ID";
	case CERT_EXTENDED_ERROR_INFO_PROP_ID: return "EXTENDED_ERROR_INFO_PROP_ID";
	case CERT_RENEWAL_PROP_ID: return "RENEWAL_PROP_ID";
	case CERT_ARCHIVED_KEY_HASH_PROP_ID: return "ARCHIVED_KEY_HASH_PROP_ID";
	case CERT_AUTO_ENROLL_RETRY_PROP_ID: return "AUTO_ENROLL_RETRY_PROP_ID";
	case CERT_AIA_URL_RETRIEVED_PROP_ID: return "AIA_URL_RETRIEVED_PROP_ID";
	case CERT_AUTHORITY_INFO_ACCESS_PROP_ID: return "AUTHORITY_INFO_ACCESS_PROP_ID";
	case CERT_BACKED_UP_PROP_ID: return "BACKED_UP_PROP_ID";
	case CERT_OCSP_RESPONSE_PROP_ID: return "OCSP_RESPONSE_PROP_ID";
	case CERT_REQUEST_ORIGINATOR_PROP_ID: return "REQUEST_ORIGINATOR_PROP_ID";
	case CERT_SOURCE_LOCATION_PROP_ID: return "SOURCE_LOCATION_PROP_ID";
	case CERT_SOURCE_URL_PROP_ID: return "SOURCE_URL_PROP_ID";
	case CERT_NEW_KEY_PROP_ID: return "NEW_KEY_PROP_ID";
	case CERT_OCSP_CACHE_PREFIX_PROP_ID: return "OCSP_CACHE_PREFIX_PROP_ID";
	case CERT_SMART_CARD_ROOT_INFO_PROP_ID: return "SMART_CARD_ROOT_INFO_PROP_ID";
	case CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID: return "NO_AUTO_EXPIRE_CHECK_PROP_ID";
	case CERT_NCRYPT_KEY_HANDLE_PROP_ID: return "NCRYPT_KEY_HANDLE_PROP_ID";
	case CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID: return "HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID";
	case CERT_SUBJECT_INFO_ACCESS_PROP_ID: return "SUBJECT_INFO_ACCESS_PROP_ID";
	case CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID: return "CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID";
	case CERT_CA_DISABLE_CRL_PROP_ID: return "CA_DISABLE_CRL_PROP_ID";
	case CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID: return "ROOT_PROGRAM_CERT_POLICIES_PROP_ID";
	case CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID: return "ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID";
	case CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID: return "SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID";
	case CERT_SUBJECT_DISABLE_CRL_PROP_ID: return "SUBJECT_DISABLE_CRL_PROP_ID";
	case CERT_CEP_PROP_ID: return "CEP_PROP_ID";
	case CERT_SIGN_HASH_CNG_ALG_PROP_ID: return "SIGN_HASH_CNG_ALG_PROP_ID";
	case CERT_SCARD_PIN_ID_PROP_ID: return "SCARD_PIN_ID_PROP_ID";
	case CERT_SCARD_PIN_INFO_PROP_ID: return "SCARD_PIN_INFO_PROP_ID";
	case CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID: return "SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID";
	case CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID: return "PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID";
	case CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID: return "ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID";
	case CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID: return "ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID";
	case CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID: return "ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_I";
	case CERT_NO_EXPIRE_NOTIFICATION_PROP_ID: return "NO_EXPIRE_NOTIFICATION_PROP_ID";
	case CERT_AUTH_ROOT_SHA256_HASH_PROP_ID: return "AUTH_ROOT_SHA256_HASH_PROP_ID ";
	case CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID: return "NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID ";
	case CERT_HCRYPTPROV_TRANSFER_PROP_ID: return "HCRYPTPROV_TRANSFER_PROP_ID ";
	case CERT_SMART_CARD_READER_PROP_ID: return "SMART_CARD_READER_PROP_ID ";
	case CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID: return "SEND_AS_TRUSTED_ISSUER_PROP_ID ";
	case CERT_KEY_REPAIR_ATTEMPTED_PROP_ID: return "KEY_REPAIR_ATTEMPTED_PROP_ID ";
	case CERT_DISALLOWED_FILETIME_PROP_ID: return "DISALLOWED_FILETIME_PROP_ID ";
	case CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID: return "ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID ";
	case CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID: return "SMART_CARD_READER_NON_REMOVABLE_PROP_ID ";
	case CERT_SHA256_HASH_PROP_ID: return "SHA256_HASH_PROP_ID ";
	case CERT_SCEP_SERVER_CERTS_PROP_ID: return "SCEP_SERVER_CERTS_PROP_ID ";
	case CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID: return "SCEP_RA_SIGNATURE_CERT_PROP_ID ";
	case CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID: return "SCEP_RA_ENCRYPTION_CERT_PROP_ID ";
	case CERT_SCEP_CA_CERT_PROP_ID: return "SCEP_CA_CERT_PROP_ID ";
	case CERT_SCEP_SIGNER_CERT_PROP_ID: return "SCEP_SIGNER_CERT_PROP_ID ";
	case CERT_SCEP_NONCE_PROP_ID: return "SCEP_NONCE_PROP_ID ";
	case CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID: return "SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID ";
	case CERT_SCEP_FLAGS_PROP_ID: return "SCEP_FLAGS_PROP_ID ";
	case CERT_SCEP_GUID_PROP_ID: return "SCEP_GUID_PROP_ID ";
	case CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID: return "SERIALIZABLE_KEY_CONTEXT_PROP_ID ";
	case CERT_ISOLATED_KEY_PROP_ID: return "ISOLATED_KEY_PROP_ID ";
	case CERT_SERIAL_CHAIN_PROP_ID: return "SERIAL_CHAIN_PROP_ID ";
	case CERT_KEY_CLASSIFICATION_PROP_ID: return "KEY_CLASSIFICATION_PROP_ID ";
	case CERT_OCSP_MUST_STAPLE_PROP_ID: return "OCSP_MUST_STAPLE_PROP_ID ";
	case CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID: return "DISALLOWED_ENHKEY_USAGE_PROP_ID ";
	case CERT_NONCOMPLIANT_ROOT_URL_PROP_ID: return "NONCOMPLIANT_ROOT_URL_PROP_ID ";
	case CERT_PIN_SHA256_HASH_PROP_ID: return "PIN_SHA256_HASH_PROP_ID ";
	case CERT_CLR_DELETE_KEY_PROP_ID: return "CLR_DELETE_KEY_PROP_ID ";
	case CERT_NOT_BEFORE_FILETIME_PROP_ID: return "NOT_BEFORE_FILETIME_PROP_ID";
	case CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID: return "NOT_BEFORE_ENHKEY_USAGE_PROP_ID";
	case CERT_FIRST_RESERVED_PROP_ID: return "FIRST_RESERVED_PROP_ID";
	case CERT_LAST_RESERVED_PROP_ID: return "LAST_RESERVED_PROP_ID";
	case CERT_FIRST_USER_PROP_ID: return "FIRST_USER_PROP_ID";
	case CERT_LAST_USER_PROP_ID: return "LAST_USER_PROP_ID";
	default: return "Unknown Type(" + std::to_string(p) + ")";
	}
}
```

`Sources/Utils/constant_names.h`:

```h
#pragma once

#include <string>
#include <vector>

#include <WinSock2.h>
#include <windows.h>


namespace constants {

	namespace disk
	{
		namespace smart
		{
			std::string attribute_name(DWORD index);

			std::string devicemap_type(DWORD type);

			std::string capabilities(DWORD cap);
		}

		namespace vss
		{
			std::string state(DWORD64 s);

			std::vector<std::string> flags(DWORD64 f);
		}

		std::string partition_type(DWORD t);

		std::string media_type(MEDIA_TYPE t);

		std::string drive_type(DWORD t);

		std::string mbr_type(uint8_t type);

		std::string gpt_type(GUID type);

		namespace mft
		{
			std::string file_record_flags(ULONG32 f);

			std::string file_record_attribute_type(ULONG32 a);

			std::string file_record_index_root_attribute_type(ULONG32 a);

			std::string file_record_index_root_attribute_flag(ULONG32 f);

			std::string file_record_reparse_point_type(ULONG32 t);

			std::string file_record_filename_name_type(UCHAR t);

			std::string efs_type(ULONG32);

			std::string wof_compression(DWORD);
		}

		namespace usn
		{
			std::string reasons(DWORD r);

			std::string fileattributes(DWORD a);
		}

		namespace logfile
		{
			std::string operation(WORD w);
		}
	}

	namespace efs
	{
		std::string hash_algorithm(DWORD r);

		std::string enc_algorithm(DWORD a);

		std::vector<std::string> permissions(DWORD p);

		std::string cert_prop_id(DWORD p);

		std::string cert_prop_provider_type(DWORD t);

		std::string cert_prop_flags(DWORD f);

		std::string cert_prop_keyspec(DWORD k);

		std::string export_flag(DWORD f);
	}

	namespace bitlocker
	{
		std::string state(DWORD s);

		std::string algorithm(DWORD a);

		std::string fve_entry_type(ULONG32 t);

		std::string fve_value_type(ULONG32 t);

		std::string fve_key_protection_type(ULONG32 t);
	}
}

```

`Sources/Utils/crash_handler.cpp`:

```cpp
#include <WinSock2.h>
#include <windows.h>
#include <psapi.h>

#pragma comment(lib, "dbghelp")

#pragma pack( push, before_imagehlp, 8 )
#include <imagehlp.h>
#pragma pack( pop, before_imagehlp )

#include <stdexcept>
#include <iterator>
#include <vector>
#include <iostream>
#include <iomanip>
#include <string>
#include <algorithm>
#include <sstream>
#include <filesystem>

#include "Utils\utils.h"
#include <Utils\table.h>

class Crash
{
private:
	PEXCEPTION_POINTERS _ex;

public:
	explicit Crash(PEXCEPTION_POINTERS pEx)
	{
		_ex = pEx;
	}

	bool dump(std::wstring filename = L"")
	{
		std::wstring dump_filename = filename;
		if (dump_filename.empty())
		{
			wchar_t szExeFileName[MAX_PATH];
			GetModuleFileNameW(NULL, szExeFileName, MAX_PATH);
			std::filesystem::path p(szExeFileName);
			dump_filename = p.replace_extension(".dmp");
		}

		HANDLE hFile = CreateFileW(dump_filename.c_str(), GENERIC_ALL, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			MINIDUMP_EXCEPTION_INFORMATION mdei;

			mdei.ThreadId = GetCurrentThreadId();
			mdei.ExceptionPointers = _ex;
			mdei.ClientPointers = FALSE;

			if (MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, (MINIDUMP_TYPE)(MiniDumpNormal), &mdei, nullptr, nullptr))
			{
				CloseHandle(hFile);
				return true;
			}
			CloseHandle(hFile);
		}
		return false;
	}
};

LONG WINAPI Filter(PEXCEPTION_POINTERS ep)
{
	std::shared_ptr<Crash> ex = std::make_shared<Crash>(ep);
	std::wcout << std::endl << "[!] Sorry, the application has crashed!" << std::endl;

	ex->dump();

	return EXCEPTION_EXECUTE_HANDLER;
}

void install_crash_handler()
{
	SetUnhandledExceptionFilter(&Filter);
}

void uninstall_crash_handler()
{
	SetUnhandledExceptionFilter(nullptr);
}
```

`Sources/Utils/crash_handler.h`:

```h
#pragma once

#include <WinSock2.h>
#include <windows.h>
#include <psapi.h>

#pragma comment(lib, "dbghelp")

#pragma pack( push, before_imagehlp, 8 )
#include <imagehlp.h>
#pragma pack( pop, before_imagehlp )

#include <stdexcept>
#include <iterator>
#include <vector>
#include <iostream>
#include <iomanip>
#include <string>
#include <algorithm>
#include <sstream>

#include "Utils/utils.h"

void install_crash_handler();

void uninstall_crash_handler();

class Crash
{
private:
	PEXCEPTION_POINTERS _ex;
	EXCEPTION_RECORD _exception;
	CONTEXT _context;

	HANDLE _hProcess = INVALID_HANDLE_VALUE;
	HANDLE _hThread = INVALID_HANDLE_VALUE;

public:
	explicit Crash(PEXCEPTION_POINTERS pEx);

	bool dump(std::wstring filename = L"");

	PEXCEPTION_RECORD exception() { return &_exception; }

	PCONTEXT context() { return &_context; }
};

LONG WINAPI Filter(PEXCEPTION_POINTERS ep);

```

`Sources/Utils/index_details.cpp`:

```cpp
#include "Utils/index_details.h"

#include <map>
#include <memory>

#include "Utils/utils.h"



IndexDetails::IndexDetails(std::shared_ptr<MFTRecord> pMFT)
{
	_record = pMFT;

	if (pMFT == nullptr)
	{
		return;
	}

	std::string type = MFT_ATTRIBUTE_INDEX_FILENAME;
	PMFT_RECORD_ATTRIBUTE_HEADER pAttr = pMFT->attribute_header($INDEX_ROOT, type);
	if (pAttr == nullptr)
	{
		type = MFT_ATTRIBUTE_INDEX_REPARSE;
		pAttr = pMFT->attribute_header($INDEX_ROOT, type);
	}

	if (pAttr != nullptr)
	{
		PMFT_RECORD_ATTRIBUTE_INDEX_ROOT pAttrIndexRoot = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ROOT, pAttr, pAttr->Form.Resident.ValueOffset);

		std::shared_ptr<Buffer<PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK>> indexBlocks = nullptr;

		if (pAttrIndexRoot->Flags & MFT_ATTRIBUTE_INDEX_ROOT_FLAG_LARGE)
		{
			_index_large = true;
			std::map<DWORD64, PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK> vcnToBlock;

			PMFT_RECORD_ATTRIBUTE_HEADER pAttrAllocation = pMFT->attribute_header($INDEX_ALLOCATION, type);
			if (pAttrAllocation != nullptr)
			{
				indexBlocks = pMFT->attribute_data<PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK>(pAttrAllocation);

				PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK pIndexSubBlockData = indexBlocks->data();
				DWORD IndexSubBlockDataSize = indexBlocks->size();
				DWORD blockPos = 0;
				while (blockPos < indexBlocks->size())
				{
					if (pIndexSubBlockData->Magic == MAGIC_INDX)
					{
						pMFT->apply_fixups(pIndexSubBlockData, IndexSubBlockDataSize - blockPos, pIndexSubBlockData->OffsetOfUS, pIndexSubBlockData->SizeOfUS);
						vcnToBlock[pIndexSubBlockData->VCN] = pIndexSubBlockData;

						auto entries = _parse_entries_block(POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY, pIndexSubBlockData, pIndexSubBlockData->EntryOffset + 0x18), type);
						auto offset = reinterpret_cast<uint64_t>(vcnToBlock[pIndexSubBlockData->VCN]) - reinterpret_cast<uint64_t>(vcnToBlock[0]);

						_VCNinfo[pIndexSubBlockData->VCN] = std::tuple<uint64_t, DWORD, std::vector<std::tuple<uint64_t, std::wstring>>>(pMFT->raw_address(pAttrAllocation, offset), pIndexSubBlockData->AllocEntrySize + 0x18, entries);
					}

					blockPos += pIndexSubBlockData->AllocEntrySize + 0x18;
					pIndexSubBlockData = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK, pIndexSubBlockData, pIndexSubBlockData->AllocEntrySize + 0x18);
				}

				_VCNtree = _parse_entries_tree(POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY, pAttrIndexRoot, pAttrIndexRoot->EntryOffset + 0x10), vcnToBlock, 0, type);

			}
			else
			{
				wprintf(L"Attribute $INDEX_ALLOCATION not found");
			}
		}
		else
		{
			_index_large = false;
			uint64_t index_offset = reinterpret_cast<uint64_t>(pAttrIndexRoot) - reinterpret_cast<uint64_t>(pMFT->header()) + pAttrIndexRoot->EntryOffset + 0x10;
			auto entries = _parse_entries_block(POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY, pAttrIndexRoot, pAttrIndexRoot->EntryOffset + 0x10), type);

			_VCNinfo[0] = std::tuple<uint64_t, DWORD, std::vector<std::tuple<uint64_t, std::wstring>>>(index_offset, pAttrIndexRoot->AllocEntrySize + 0x18, entries);
		}
	}
}

std::vector<std::tuple<uint64_t, std::wstring>> IndexDetails::_parse_entries_block(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY pIndexEntry, std::string type)
{
	std::vector<std::tuple<uint64_t, std::wstring>> ret;
	if (pIndexEntry != nullptr)
	{
		std::vector<std::shared_ptr<IndexEntry>> entries;
		while (TRUE)
		{
			std::shared_ptr<IndexEntry> e = std::make_shared<IndexEntry>(pIndexEntry, type);

			if (pIndexEntry->Flags & MFT_ATTRIBUTE_INDEX_ENTRY_FLAG_LAST)
			{
				if (pIndexEntry->FileReference != 0) entries.push_back(e);
				break;
			}

			entries.push_back(e);

			if (pIndexEntry->Length > 0)
			{
				pIndexEntry = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY, pIndexEntry, pIndexEntry->Length);
			}
			else
			{
				break;
			}
		}
		for (auto& entry : entries)
		{
			ret.push_back(std::tuple<uint64_t, std::wstring>(entry->record_number(), entry->name()));
		}
	}

	return ret;
}

std::shared_ptr<node> IndexDetails::_parse_entries_tree(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY pIndexEntry, std::map<DWORD64, PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK> vcnToBlock, uint64_t vcn, std::string type)
{
	std::shared_ptr<node> ret = std::make_shared<node>(vcn);

	if (pIndexEntry != nullptr)
	{
		while (TRUE)
		{
			std::shared_ptr<IndexEntry> e = std::make_shared<IndexEntry>(pIndexEntry, type);
			std::shared_ptr<node> subnodes = nullptr;

			if (pIndexEntry->Flags & MFT_ATTRIBUTE_INDEX_ENTRY_FLAG_SUBNODE)
			{
				PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK block = vcnToBlock[e->vcn()];
				if ((block != nullptr) && (block->Magic == MAGIC_INDX))
				{
					PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY nextEntries = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY, block, block->EntryOffset + 0x18);
					subnodes = _parse_entries_tree(nextEntries, vcnToBlock, e->vcn(), type);
				}
			}

			ret->add_item(e, subnodes);

			if (pIndexEntry->Flags & MFT_ATTRIBUTE_INDEX_ENTRY_FLAG_LAST)
			{
				break;
			}

			if (pIndexEntry->Length > 0)
			{
				pIndexEntry = POINTER_ADD(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY, pIndexEntry, pIndexEntry->Length);
			}
			else
			{
				break;
			}
		}
	}

	return ret;
}



```

`Sources/Utils/index_details.h`:

```h
#pragma once

#include <WinSock2.h>
#include <Windows.h>
#include <string>
#include <map>
#include <vector>

#include "NTFS/ntfs.h"
#include "NTFS/ntfs_mft_record.h"
#include <Utils/btree.h>

class IndexDetails
{
private:
	std::shared_ptr<MFTRecord> _record = nullptr;
	bool _index_large = false;
	std::shared_ptr<node> _VCNtree = nullptr;
	std::map <DWORD64, std::tuple<uint64_t, DWORD, std::vector<std::tuple<uint64_t, std::wstring>>>> _VCNinfo;

	std::vector<std::tuple<uint64_t, std::wstring>> _parse_entries_block(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY pIndexEntry, std::string type);

	std::shared_ptr<node> _parse_entries_tree(PMFT_RECORD_ATTRIBUTE_INDEX_ENTRY pIndexEntry, std::map<DWORD64, PMFT_RECORD_ATTRIBUTE_INDEX_BLOCK> vcnToBlock, uint64_t vcn, std::string type);

public:
	explicit IndexDetails(std::shared_ptr<MFTRecord> pRecord);

	bool is_large() { return _index_large; }

	std::shared_ptr<node> VCNtree() { return _VCNtree; }

	std::map <DWORD64, std::tuple<uint64_t, DWORD, std::vector<std::tuple<uint64_t, std::wstring>>>> VCN_info() { return _VCNinfo; }
};

```

`Sources/Utils/progress_bar.h`:

```h
#pragma once

#include <chrono>
#include <iostream>
#include <iomanip>
#include <cmath>

class ProgressBar {
private:
	bool _infinite = false;
	unsigned int _ticks = 0;
	int _total_ticks;
	int _bar_width;

	std::wstring _label = L"";
	wchar_t complete_char = L'#';
	wchar_t incomplete_char = L' ';
	bool display_time = false;

	const std::chrono::steady_clock::time_point start_time = std::chrono::steady_clock::now();

public:
	ProgressBar(int total, int width, std::wstring label = L"") : _total_ticks(total), _bar_width(width), _label(label) {}

	void set_total(int total) noexcept { _total_ticks = total; }

	void set_display_time(bool b) noexcept { display_time = b; }

	void set_label(std::wstring l) noexcept { _label = l; }

	void set_infinite(bool b) noexcept { _infinite = b; }

	void set_bar_type(wchar_t c, wchar_t i) noexcept { complete_char = c; incomplete_char = i; }

	void increment() noexcept { _ticks++; }

	void set_progress(unsigned int p) noexcept { _ticks = p; }

	void display(std::wostream& out)
	{
		const float progress = float(_ticks) / _total_ticks;
		const int pos = static_cast<int>(_bar_width * progress);

		unsigned long long time_elapsed = 0;
		if (display_time)
		{
			const std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();
			time_elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - start_time).count();
		}

		const std::ios_base::fmtflags f(out.flags());

		out << std::left << _label << L"[";

		if (_infinite)
		{
			const int inf_step = _ticks % _bar_width;
			int left = inf_step + 8 - _bar_width;
			if (left > 0)
			{
				for (int i = 0; i < left; ++i) {
					out << '=';
				}
			}
			else
			{
				left = 0;
			}
			for (int i = left; i < inf_step; ++i) {
				out << ' ';
			}
			for (int i = inf_step; i < min(inf_step + 8, _bar_width); ++i) {
				out << '=';
			}
			for (int i = min(inf_step + 8, _bar_width); i < _bar_width; ++i) {
				out << ' ';
			}
			_ticks = _ticks + 1;
		}
		else
		{
			for (int i = 0; i < _bar_width; ++i) {
				if (i < pos) out << complete_char;
				else if (i == pos) out << L">";
				else out << incomplete_char;
			}
		}
		out << std::fixed << std::setprecision(2) << L"] ";
		if (!_infinite)
		{
			out << static_cast<int>(min(progress * 100.0, 100.0)) << L"% ";
		}
		if (display_time)
		{
			out << static_cast<int>(time_elapsed / 1000.0) << L"s";
		}
		out << L"     \r";
		out.flush();

		out.flags(f);
	}

	void done(std::wostream& out)
	{
		_ticks = _total_ticks;
		_infinite = false;
		display(out);
		out << std::endl;
		out.flush();
	}
};

```

`Sources/Utils/table.cpp`:

```cpp
#include "Utils/table.h"
#include "Utils/utils.h"

#include <sstream>
#include <iostream>
#include <iomanip>

utils::ui::Table::Table()
{
	margin_left = 0;
}

void utils::ui::Table::add_header_line(std::string header, utils::ui::TableAlign align)
{
	std::vector<std::string> s;
	s.push_back(header);
	headers.push_back(s);
	column_align.push_back(align);
}

void utils::ui::Table::add_header_multiline(std::initializer_list<std::string> header, utils::ui::TableAlign align)
{
	std::vector<std::string> s;
	for (auto& i : header)
	{
		s.push_back(i);
	}
	headers.push_back(s);
	column_align.push_back(align);
}

void utils::ui::Table::add_item_line(std::string item)
{
	std::vector<std::string> s;
	DWORD value_len = utils::strings::utf8_string_size(item);

	if (value_len < cell_max_size)
	{
		s.push_back(item);
	}
	else
	{
		if (value_len > 2 * cell_max_size)
		{
			cell_max_size = 32;
		}
		for (unsigned int i = 0; i < value_len; i += cell_max_size)
		{
			s.push_back(item.substr(i, cell_max_size));
		}
	}
	current_line.push_back(s);
}

void utils::ui::Table::add_item_multiline(std::initializer_list<std::string> list)
{
	std::vector<std::string> s;
	for (auto& i : list)
	{
		s.push_back(i);
	}
	add_item_multiline(s);
}

void utils::ui::Table::add_item_multiline(std::vector<std::string> list)
{
	std::vector<std::string> s;
	for (auto& i : list)
	{
		auto i_len = utils::strings::utf8_string_size(i);
		if (i_len > cell_max_size) {
			size_t sep = i.find(':');
			if (sep != std::string::npos && sep < i_len - 1 && i[sep + 1] == ' ')
			{
				std::string key = i.substr(0, sep);
				auto key_len = utils::strings::utf8_string_size(key);
				std::string whitespace = "";
				for (unsigned int n = 0; n < key_len; n++) whitespace += " ";
				std::string value = i.substr(sep + 2);
				auto value_len = utils::strings::utf8_string_size(value);
				auto offset = value.length() - value_len;
				if (value_len > cell_max_size)
				{
					auto tmp_max_size = cell_max_size;
					if (value_len > 2 * cell_max_size)
					{
						cell_max_size = 32;
					}
					s.push_back(key + ": " + value.substr(0, cell_max_size + offset));
					value = value.substr(cell_max_size + offset);
					value_len = utils::strings::utf8_string_size(value);
					offset = value.length() - value_len;
					while (value_len > cell_max_size) {
						s.push_back(whitespace + "  " + value.substr(0, cell_max_size + offset));
						value = value.substr(cell_max_size + offset);
						value_len = utils::strings::utf8_string_size(value);
					}
					if (value_len > 0)
					{
						s.push_back(whitespace + "  " + value);
					}
					cell_max_size = tmp_max_size;
				}
				else
				{
					s.push_back(key + ": " + value);
				}
			}
			else
			{
				std::string value = i;

				while (value.length() > cell_max_size) {
					s.push_back(value.substr(0, cell_max_size));
					value = value.substr(cell_max_size);
				}
				if (value.length() > 0) {
					if (value == TABLE_SEPARATOR)
					{
						std::string padded_sep = "";
						for (int i = 0; i < (cell_max_size - strlen(TABLE_SEPARATOR)) / 2; i++)
						{
							padded_sep.append(" ");
						}
						s.push_back(padded_sep + value);
					}
					else
					{
						s.push_back(value);
					}
				}
			}
		}
		else
		{
			s.push_back(i);
		}
	}
	current_line.push_back(s);
}

void utils::ui::Table::set_margin_left(uint32_t margin_left)
{
	this->margin_left = margin_left;
}

void utils::ui::Table::set_cell_max_size(uint32_t max_size)
{
	this->cell_max_size = max_size;
}

void utils::ui::Table::new_line()
{
	data.push_back(current_line);
	current_line.clear();
}

void utils::ui::Table::render(std::ostream& out)
{
	std::ios_base::fmtflags flag_backup(out.flags());
	size_t line_size = 0;
	out << std::unitbuf;

	std::vector<uint32_t> column_size(this->headers.size(), 0);

	unsigned int i;
	for (i = 0; i < this->headers.size(); i++) {
		uint32_t m = 0;
		for (unsigned int j = 0; j < this->data.size(); j++) {
			uint32_t cell_max_width = 0;
			for (unsigned int k = 0; k < this->data[j][i].size(); k++) {
				cell_max_width = max(cell_max_width, utils::strings::utf8_string_size(this->data[j][i][k]));
			}
			m = max(m, cell_max_width);
		}
		for (unsigned int j = 0; j < this->headers[i].size(); j++)
		{
			m = max(m, utils::strings::utf8_string_size(this->headers[i][j]));
		}
		column_size[i] = m;
		line_size += m;
	}
	line_size += 3 * (this->headers.size() - 1);

	out << std::setfill(' ');

	if (border_top)
	{
		for (i = 0; i < margin_left; i++) out << " ";
		if (border_left)
		{
			out << (corner ? "+" : " ") << "-";
		}
		for (i = 0; i < line_size; i++) out << "-";
		if (border_right)
		{
			out << "-" << (corner ? "+" : " ");
		}
		out << std::endl;
	}

	size_t header_lines = 0;
	for (auto& h : headers)
	{
		header_lines = max(header_lines, h.size());
	}
	for (unsigned int header_line_index = 0; header_line_index < header_lines; header_line_index++)
	{
		for (i = 0; i < margin_left; i++) out << " ";
		if (border_left)
		{
			out << "| ";
		}
		for (i = 0; i < headers.size() - 1; i++) {
			out.width(column_size[i]);
			if (header_line_index < headers[i].size()) out << std::left << headers[i][header_line_index];
			else out << std::left << "";
			out << " | ";
		}
		out.width(column_size[i]);
		if (header_line_index < headers[i].size()) out << std::left << headers[i][header_line_index];
		else out << std::left << "";
		if (border_right)
		{
			out << " |";
		}
		out << std::endl;
	}

	for (auto& line : data) {
		// Header / Data line		
		if (interline || header_interline)
		{
			for (i = 0; i < margin_left; i++) out << " ";
			header_interline = false;
			if (border_left)
			{
				out << (corner ? "+" : " ") << "-";
			}
			for (i = 0; i < line_size; i++) out << "-";
			if (border_right)
			{
				out << "-" << (corner ? "+" : " ");
			}
			out << std::endl;
		}

		//for (i = 0; i < margin_left; i++) out << " ";

		// Max cell height for the line
		size_t cell_height = 0;
		for (auto& cell : line)
		{
			cell_height = max(cell_height, cell.size());
		}
		// Print cells
		for (unsigned int lines_i = 0; lines_i < cell_height; lines_i++)
		{
			for (i = 0; i < margin_left; i++) out << " ";
			if (border_left)
			{
				out << "| ";
			}
			size_t fix = 0;
			for (i = 0; i < line.size() - 1; i++)
			{
				out.width(column_size[i]);
				if (lines_i < line[i].size())
				{
					fix = (line[i][lines_i].length() - utils::strings::utf8_string_size(line[i][lines_i]));
					out.width(column_size[i]);

					if (column_align[i] == TableAlign::LEFT) out << std::left << line[i][lines_i];
					else  out << std::right << line[i][lines_i];
				}
				else out << std::left << " ";
				out << " | ";
			}

			if (lines_i < line[i].size())
			{
				fix = (line[i][lines_i].length() - utils::strings::utf8_string_size(line[i][lines_i]));
				out.width(column_size[i] + fix);
				if (column_align[i] == TableAlign::LEFT) out << std::left << line[i][lines_i];
				else out << std::right << line[i][lines_i];
			}
			else {
				out.width(column_size[i]);
				out << std::left << " ";
			}
			if (border_right)
			{
				out << " |";
			}

			out << std::endl;
		}
	}

	if (border_bottom)
	{
		for (i = 0; i < margin_left; i++) out << " ";
		if (border_left)
		{
			out << (corner ? "+" : " ") << "-";
		}
		for (i = 0; i < line_size; i++) out << "-";
		if (border_right)
		{
			out << "-" << (corner ? "+" : " ");
		}
		out << std::endl;
	}
	out.flags(flag_backup);
}

```

`Sources/Utils/table.h`:

```h
#pragma once

#include <string>
#include <vector>

#define TABLE_SEPARATOR "-----"
#define TABLE_MAX_SIZE_DEFAULT (64)

namespace utils
{
	namespace ui {
		enum class TableAlign
		{
			LEFT,
			RIGHT
		};

		class Table
		{
		private:
			std::vector<std::vector<std::string>> headers;
			std::vector<utils::ui::TableAlign> column_align;
			std::vector<std::vector<std::vector<std::string>>> data;
			std::vector<std::vector<std::string>> current_line;

			bool border_top = true;
			bool border_bottom = true;
			bool border_left = true;
			bool border_right = true;
			bool interline = false;
			bool header_interline = true;
			bool corner = true;
			uint32_t margin_left;
			uint32_t cell_max_size = TABLE_MAX_SIZE_DEFAULT;
		public:
			explicit Table();

			void add_header_line(std::string header, utils::ui::TableAlign align = TableAlign::LEFT);

			void add_header_multiline(std::initializer_list<std::string> header, utils::ui::TableAlign align = TableAlign::LEFT);

			void add_item_line(std::string item);

			void add_item_multiline(std::initializer_list<std::string> list);

			void add_item_multiline(std::vector<std::string> list);

			void set_margin_left(uint32_t margin_left);

			void set_cell_max_size(uint32_t max_size);

			void set_corner(bool show) { corner = show; }

			void set_interline(bool show) { interline = show; }

			void set_header_interline(bool show) { header_interline = show; }

			void set_border_left(bool show) { border_left = show; }

			void set_border_top(bool show) { border_top = show; }

			void set_border_right(bool show) { border_right = show; }

			void set_border_bottom(bool show) { border_bottom = show; }

			void set_border(bool show) { border_bottom = show; border_left = show; border_right = show; border_top = show; }

			void new_line();

			void render(std::ostream& out);
		};
	}
}
```

`Sources/Utils/utils.cpp`:

```cpp
#include "Utils.h"

#include <map>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <codecvt>
#include <bitset>
#include <vector>
#include <algorithm>
#include <cctype>
#include <distorm.h>

#include <Mstcpip.h>
#include <Taskschd.h>
#include <comdef.h>
#include <tchar.h>
#include <string.h>
#include <psapi.h>
#include <strsafe.h>
#include <Userenv.h>
#include <Shlobj.h>
#include <Softpub.h>
#include <mscat.h>
#include <Rpc.h>

#include <openssl/bn.h>

#include <filesystem>
#include <regex>

#include "Buffer.h"

#pragma comment(lib, "ntdll")
#pragma comment(lib, "wintrust")
#pragma comment(lib, "advapi32")
#pragma comment(lib, "rpcrt4")
#pragma comment(lib, "ws2_32")
#pragma comment(lib, "shell32")


namespace utils
{
	namespace dirs
	{
		std::string temp()
		{
			TCHAR  infoBuf[MAX_PATH + 1];
			DWORD  bufCharCount = MAX_PATH + 1;

			GetTempPath(bufCharCount, infoBuf);
			return std::string(infoBuf);
		}
	}

	namespace convert
	{
		std::string to_base64(const char* in, size_t in_len)
		{
			std::string ret;
			int i = 0;
			unsigned char char_array_3[3];
			unsigned char char_array_4[4];
			const std::string base64_chars =
				"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
				"abcdefghijklmnopqrstuvwxyz"
				"0123456789+/";

			while (in_len--)
			{
				char_array_3[i++] = *(in++);
				if (i == 3)
				{
					char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
					char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
					char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
					char_array_4[3] = char_array_3[2] & 0x3f;

					for (i = 0; (i < 4); i++)
						ret += base64_chars[char_array_4[i]];
					i = 0;
				}
			}

			if (i)
			{
				for (int j = i; j < 3; j++)
					char_array_3[j] = '\0';

				char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
				char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
				char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
				char_array_4[3] = char_array_3[2] & 0x3f;

				for (int j = 0; (j < i + 1); j++)
					ret += base64_chars[char_array_4[j]];

				while ((i++ < 3))
					ret += '=';
			}

			return ret;
		}

		std::string to_base64(std::string s)
		{
			return to_base64(s.c_str(), s.length());
		}

		std::shared_ptr<Buffer<PBYTE>> from_hex(std::string s)
		{
			BIGNUM* input = BN_new();
			int input_length = BN_hex2bn(&input, s.c_str());
			std::shared_ptr<Buffer<PBYTE>> ret = std::make_shared<Buffer<PBYTE>>((input_length + 1) / 2);
			BN_bn2bin(input, ret->data());
			return ret;
		}

		std::string to_hex(PVOID buffer, unsigned long size)
		{
			std::ostringstream ret;
			PBYTE buf = reinterpret_cast<PBYTE>(buffer);
			if (buffer != nullptr)
			{
				for (unsigned int i = 0; i < size; i++)
				{
					ret << "0123456789ABCDEF"[buf[i] >> 4] << "0123456789ABCDEF"[buf[i] & 0x0F];
				}
			}
			return ret.str();
		}
	}

	namespace strings
	{
		template<typename _Iterator1, typename _Iterator2>
		size_t _inc_utf8_string_iterator(_Iterator1& it, const _Iterator2& last) {
			if (it == last) return 0;
			unsigned char c;
			size_t res = 1;
			for (++it; last != it; ++it, ++res) {
				c = *it;
				if (!(c & 0x80) || ((c & 0xC0) == 0xC0)) break;
			}

			return res;
		}

		DWORD utf8_string_size(const std::string& str) {
			int q = 0;
			size_t i = 0, ix = 0;
			for (q = 0, i = 0, ix = str.length(); i < ix; i++, q++)
			{
				int c = (unsigned char)str[i];
				if (c >= 0 && c <= 127) i += 0; //-V560
				else if ((c & 0xE0) == 0xC0) i += 1;
				else if ((c & 0xF0) == 0xE0) i += 2;
				else if ((c & 0xF8) == 0xF0) i += 3;
				else return 0;
			}
			return q;
		}

		std::string lower(std::string& s)
		{
			transform(s.begin(), s.end(), s.begin(), ::tolower);
			return s;
		}

		std::string upper(std::string& s)
		{
			transform(s.begin(), s.end(), s.begin(), ::toupper);
			return s;
		}

		void ltrim(std::string& s)
		{
			s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
				return !std::isspace(ch & 0xff) && ((ch & 0xff) != 0);
				}));
		}

		void rtrim(std::string& s)
		{
			s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned int ch) {
				return !std::isspace(ch & 0xff) && ((ch & 0xff) != 0);
				}).base(), s.end());
		}

		void trim(std::string& s)
		{
			ltrim(s);
			rtrim(s);
		}

		std::string reverse(std::string input)
		{
			std::reverse(input.begin(), input.end());
			return input;
		}

		void replace(std::string& str, const std::string& from, const std::string& to)
		{
			if (from.empty())
				return;
			size_t start_pos = 0;
			while ((start_pos = str.find(from, start_pos)) != std::string::npos)
			{
				str.replace(start_pos, from.length(), to);
				start_pos += to.length();
			}
		}

		std::string join(std::vector<std::string> items, const std::string separator)
		{
			std::ostringstream out;
			if (items.size() > 0) out << items[0];
			for (unsigned int i = 1; i < items.size(); i++) {
				out << separator << items[i];
			}
			return out.str();
		}

		std::vector<std::string> split(const std::string& text, TCHAR delimiter)
		{
			std::vector<std::string> result;

			std::string::size_type start = 0;
			std::string::size_type end = text.find(delimiter, start);

			while (end != std::string::npos)
			{
				std::string token = text.substr(start, end - start);

				result.push_back(token);

				start = end + 1;
				end = text.find(delimiter, start);
			}

			result.push_back(text.substr(start));

			return result;
		}

		std::wstring from_string(std::string s)
		{
			std::wstring ws;
			ws.assign(s.begin(), s.end());
			return ws;
		}

		std::u16string str_to_utf16(const std::string& s, DWORD encoding)
		{
			std::string utf8 = str_to_utf8(s, encoding);

			std::wstring_convert<std::codecvt_utf8_utf16<char16_t, 0x10ffff,
				std::codecvt_mode::little_endian>, char16_t> cnv;
			return cnv.from_bytes(utf8);
		}

		std::string str_to_utf8(std::string s, DWORD encoding)
		{
			Buffer<PWCHAR> bufw;
			int need_size = MultiByteToWideChar(encoding, 0, s.c_str(), -1, NULL, 0);
			bufw.resize((DWORD64)need_size * sizeof(WCHAR));
			MultiByteToWideChar(encoding, 0, s.c_str(), -1, bufw.data(), need_size);

			Buffer<PCHAR> bufu;
			int utf8len = WideCharToMultiByte(CP_UTF8, 0, bufw.data(), -1, NULL, 0, NULL, NULL);
			bufu.resize(utf8len);
			WideCharToMultiByte(CP_UTF8, 0, bufw.data(), -1, bufu.data(), utf8len, NULL, NULL);

			return bufu.data();
		}

		std::string to_utf8(std::wstring ws, DWORD encoding)
		{
			if (ws.empty()) return "";

			int utf16len = 0;
			if (!FAILED(SizeTToInt(ws.length(), &utf16len)))
			{
				int utf8len = WideCharToMultiByte(encoding, 0, ws.c_str(), utf16len, NULL, 0, NULL, NULL);

				std::string ret(utf8len, 0);
				WideCharToMultiByte(encoding, 0, ws.c_str(), utf16len, &ret[0], utf8len, 0, 0);
				return ret;
			}

			return "";
		}
	}

	namespace format
	{
		std::string size(DWORD64 size)
		{
			double s = static_cast<double>(size);
			std::stringstream stream;
			stream << std::fixed << std::setprecision(2);
			if (s < 1024)
			{
				stream << s << TEXT(" byte") << (s < 2 ? TEXT("") : TEXT("s"));
				return stream.str();
			}
			s /= 1024;
			if (s < 1024)
			{
				stream << s << TEXT(" KiB") << (s < 2 ? TEXT("") : TEXT("s"));
				return stream.str();
			}
			s /= 1024;
			if (s < 1024)
			{
				stream << s << TEXT(" MiB") << (s < 2 ? TEXT("") : TEXT("s"));
				return stream.str();
			}
			s /= 1024;
			if (s < 1024)
			{
				stream << s << TEXT(" GiB") << (s < 2 ? TEXT("") : TEXT("s"));
				return stream.str();
			}
			s /= 1024;
			if (s < 1024)
			{
				stream << s << TEXT(" TiB") << (s < 2 ? TEXT("") : TEXT("s"));
				return stream.str();
			}
			s /= 1024;
			stream << s << TEXT(" PiB") << (s < 2 ? TEXT("") : TEXT("s"));
			return stream.str();
		}

		std::string hex(BYTE value, bool suffix, bool swap)
		{
			std::ostringstream os;
			os << std::hex << std::setw(2) << std::setfill('0') << (ULONG32)value << std::dec;
			if (suffix)
			{
				os << "h";
			}
			return os.str();
		}

		std::string hex(USHORT value, bool suffix, bool swap)
		{
			if (swap)
			{
				value = _byteswap_ushort(value);
			}
			std::ostringstream os;
			os << std::hex << std::setw(4) << std::setfill('0') << value << std::dec;
			if (suffix)
			{
				os << "h";
			}
			return os.str();
		}

		std::string hex(ULONG32 value, bool suffix, bool swap)
		{
			if (swap)
			{
				value = _byteswap_ulong(value);
			}
			std::ostringstream os;
			os << std::hex << std::setw(8) << std::setfill('0') << value << std::dec;
			if (suffix)
			{
				os << "h";
			}
			return os.str();
		}

		std::string hex(DWORD value, bool suffix, bool swap)
		{
			return  hex((ULONG32)value, suffix, swap);
		}

		std::string hex6(ULONG64 value, bool suffix, bool swap)
		{
			if (swap)
			{
				value = _byteswap_uint64(value);
			}
			std::ostringstream os;
			os << std::hex << std::setw(12) << std::setfill('0') << value << std::dec;
			if (suffix)
			{
				os << "h";
			}
			return os.str();
		}

		std::string hex(ULONG64 value, bool suffix, bool swap)
		{
			if (swap)
			{
				value = _byteswap_uint64(value);
			}
			std::ostringstream os;
			os << std::hex << std::setw(16) << std::setfill('0') << value << std::dec;
			if (suffix)
			{
				os << "h";
			}
			return os.str();
		}

		std::string hex(LONG64 value, bool suffix, bool swap)
		{
			return hex((ULONG64)value, suffix, swap);
		}

		std::string hex(std::u16string value, bool suffix, bool swap)
		{
			return hex(((PBYTE)value.c_str()), value.size() * sizeof(char16_t), suffix, swap);
		}

		std::string hex(std::string value, bool suffix, bool swap)
		{
			return hex(((PBYTE)value.c_str()), value.size(), suffix, swap);
		}

		std::string hex(PBYTE value, size_t byte_size, bool suffix, bool swap)
		{
			std::ostringstream os;
			if (swap)
			{
				for (size_t i = 0; i < byte_size; i++)
				{
					os << std::setfill('0') << std::setw(2) << std::hex << (ULONG)value[byte_size - i - 1];
				}
			}
			else
			{
				for (size_t i = 0; i < byte_size; i++)
				{
					os << std::setfill('0') << std::setw(2) << std::hex << (ULONG)value[i];
				}
			}

			os << std::dec;
			if (suffix)
			{
				os << "h";
			}
			return os.str();
		}
	}

	namespace times {


		std::string display_systemtime(SYSTEMTIME st)
		{
			TCHAR buf[64] = { 0 };
			_stprintf_s(buf, TEXT("%04u-%02u-%02u %02u:%02u:%02u"), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
			return std::string(buf);
		}

		BOOL filetime_to_systemtime(FILETIME ft, PSYSTEMTIME pST)
		{
			return FileTimeToSystemTime(&ft, pST);
		}

		BOOL ull_to_systemtime(ULONGLONG ull, PSYSTEMTIME pST)
		{
			FILETIME ft;
			ft.dwLowDateTime = (DWORD)(ull & 0xFFFFFFFF);
			ft.dwHighDateTime = (DWORD)(ull >> 32);
			return filetime_to_systemtime(ft, pST);
		}

		BOOL filetime_to_local_systemtime(FILETIME ft, PSYSTEMTIME pST)
		{
			FILETIME local;
			if (FileTimeToLocalFileTime(&ft, &local))
			{
				if (FileTimeToSystemTime(&local, pST))
				{
					return TRUE;
				}
			}
			return FALSE;
		}

		BOOL ull_to_local_systemtime(ULONGLONG ull, PSYSTEMTIME pST)
		{
			FILETIME ft;
			ft.dwLowDateTime = (DWORD)(ull & 0xFFFFFFFF);
			ft.dwHighDateTime = (DWORD)(ull >> 32);
			return filetime_to_local_systemtime(ft, pST);
		}
	}

	namespace processes {

		BOOL elevated(HANDLE p)
		{
			DWORD dwSize = 0;
			HANDLE hToken = NULL;
			TOKEN_ELEVATION tokenInformation;

			BOOL elevated = FALSE;

			if (OpenProcessToken(p, TOKEN_QUERY, &hToken))
			{
				if (GetTokenInformation(hToken, TokenElevation, &tokenInformation, sizeof(TOKEN_ELEVATION), &dwSize))
					elevated = tokenInformation.TokenIsElevated;
				CloseHandle(hToken);
			}

			return elevated;
		}
	}

	namespace files {

		std::string ensure_file_ext(const std::string& str, std::string ext)
		{
			std::filesystem::path p(str);
			return p.replace_extension(ext).string();
		}

		std::string basename(const std::string& str)
		{
			size_t found = str.find_last_of("/\\");
			if (found == std::string::npos)
			{
				return str;
			}
			else
			{
				return str.substr(found + 1);
			}
		}

		std::pair<std::string, std::string> split_file_and_stream(std::string& str)
		{
			std::filesystem::path p(str);
			std::string fname = str;

			size_t ads_sep = p.filename().string().find(':');
			std::string stream_name = "";
			if (ads_sep != std::string::npos)
			{
				stream_name = p.filename().string().substr(ads_sep + 1);
				size_t last_sep = fname.find_last_of(':');
				fname = fname.substr(0, last_sep);
			}

			return std::make_pair(fname, stream_name);
		}
	}

	namespace id
	{
		std::string guid_to_string(GUID guid)
		{
			char guid_cstr[64];
			snprintf(guid_cstr, sizeof(guid_cstr),
				"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
				guid.Data1, guid.Data2, guid.Data3,
				guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
				guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);

			return std::string(guid_cstr);
		}
		std::string sid_to_string(PSID pid)
		{
			std::string ret;
			LPSTR psSid = NULL;
			if (ConvertSidToStringSidA(pid, &psSid))
			{
				ret = std::string(psSid);
				LocalFree(psSid);
				return ret;
			}
			else
			{
				return "Converting SID failed";
			}
		}

		std::string username_from_sid(std::string sid)
		{
			char oname[512] = { 0 };
			char doname[512] = { 0 };
			DWORD namelen = 512;
			DWORD domainnamelen = 512;

			SID_NAME_USE peUse;

			PSID psid = nullptr;
			std::string username = "";
			if (ConvertStringSidToSidA(sid.c_str(), &psid))
			{
				if (LookupAccountSidA(NULL, psid, oname, &namelen, doname, &domainnamelen, &peUse))
				{
					if (strnlen_s(oname, 512) > 0 && strnlen_s(doname, 512) > 0)
					{
						username = std::string(doname, domainnamelen) + "/" + std::string(oname, namelen);
					}
				}
				FreeSid(psid);
			}
			return username;
		}
	}

	namespace ui
	{
		std::string line(unsigned int length, char type)
		{
			std::string s;
			for (unsigned int i = 0; i < length; i++) s += type;
			return s;
		}

		void title(std::string s, std::ostream& out)
		{
			out << s << std::endl;
			out << line(utils::strings::utf8_string_size(s));
			out << std::endl;
			out << std::endl;
		}

		bool ask_question(std::string question)
		{
			std::string type = "n";

			do
			{
				std::cout << question << " [y/N] ? ";
				std::getline(std::cin, type);
				type = utils::strings::lower(type);
				if (type.empty())
				{
					type = "n";
				}
			} while (!std::cin.fail() && type != "y" && type != "n");

			return type == "y";
		}
	}

}

std::string utils::os::short_version()
{
	OSVERSIONINFOEX osvi;
	SYSTEM_INFO si;
	DWORD dwType = 0;

	std::string osname;

	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

#pragma warning(disable: 28159)
#pragma warning(disable: 4996)
	GetVersionEx((OSVERSIONINFO*)&osvi);

	GetNativeSystemInfo(&si);
	GetProductInfo(osvi.dwMajorVersion, osvi.dwMinorVersion, 0, 0, &dwType);

	if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4)
	{
		if (osvi.dwMajorVersion == 10) osname = "10";

		if (osvi.dwMajorVersion == 6)
		{
			if (osvi.dwMinorVersion == 0) osname = "Vista";
			if (osvi.dwMinorVersion == 1)  osname = "7";
			if (osvi.dwMinorVersion == 2) osname = "8";
		}

		if (osvi.dwMajorVersion == 5)
		{
			osname = "XP";
		}
	}
	else
	{
		osname = "Unsupported";
	}
	return osname;
}

std::vector<std::string> utils::disass::buffer(PVOID code, ULONG32 size, _DecodeType type, _OffsetType offset)
{
	std::vector<std::string> ret;

	_DecodeResult res;
	std::shared_ptr<Buffer<_DecodedInst*>> decodedInstructions = std::make_shared<Buffer<_DecodedInst*>>(1000 * sizeof(_DecodedInst));
	unsigned int decodedInstructionsCount = 0;

	res = distorm_decode(offset, (const unsigned char*)code, size, type, decodedInstructions->data(), 1000, &decodedInstructionsCount);
	if (res != DECRES_INPUTERR)
	{
		for (unsigned int i = 0; i < decodedInstructionsCount; i++)
		{
			std::ostringstream os;
			os << utils::format::hex((WORD)(decodedInstructions->data()[i].offset)) << " : ";
			os.width(14);
			os << std::left << decodedInstructions->data()[i].instructionHex.p << " : ";
			os << utils::strings::lower(std::string((char*)decodedInstructions->data()[i].mnemonic.p)) << " ";
			if (decodedInstructions->data()[i].operands.length != 0)
			{
				os << utils::strings::lower(std::string((char*)decodedInstructions->data()[i].operands.p));
			}
			ret.push_back(os.str());
		}
	}

	return ret;
}

void utils::crypto::xor_buffer(PVOID data, DWORD datalen, PVOID key, DWORD keylen)
{
	for (DWORD i = 0; i < datalen; i++)
	{
		PBYTE(data)[i] ^= PBYTE(key)[i % keylen];
	}
}

const EVP_MD* utils::crypto::cryptoapi::hash_to_evp(DWORD hash_alg)
{
	const EVP_MD* hash = nullptr;
	switch (hash_alg)
	{
	case CALG_MD4: return EVP_md4();
	case CALG_MD5: return EVP_md5();
	case CALG_SHA1: return EVP_sha1();
	case CALG_SHA_256: return EVP_sha256();
	case CALG_SHA_384: return EVP_sha384();
	case CALG_SHA_512: return EVP_sha512();
	default:
		return nullptr;
	}
}

const EVP_CIPHER* utils::crypto::cryptoapi::encryption_to_evp(DWORD enc_alg)
{
	const EVP_CIPHER* enc = nullptr;
	switch (enc_alg)
	{
	case CALG_3DES: return EVP_des_ede3_cbc();
	case CALG_AES_128: return EVP_aes_128_cbc();
	case CALG_AES_192: return EVP_aes_192_cbc();
	case CALG_AES_256: return EVP_aes_256_cbc();
	case CALG_DES: return EVP_des_cbc();
	case CALG_DESX: return EVP_desx_cbc();
	default:
		return nullptr;
	}
}

int utils::dll::ntdll::load_compression_functions(_RtlDecompressBuffer* RtlDecompressBuffer, _RtlDecompressBufferEx* RtlDecompressBufferEx, _RtlGetCompressionWorkSpaceSize* RtlGetCompressionWorkSpaceSize)
{
	auto ntdll = GetModuleHandle("ntdll.dll");
	if (ntdll != nullptr)
	{
		if (RtlDecompressBuffer)
		{
			*RtlDecompressBuffer = (_RtlDecompressBuffer)GetProcAddress(ntdll, "RtlDecompressBuffer");
			if (*RtlDecompressBuffer == nullptr)
			{
				return 4;
			}
		}

		if (RtlGetCompressionWorkSpaceSize)
		{
			*RtlGetCompressionWorkSpaceSize = (_RtlGetCompressionWorkSpaceSize)GetProcAddress(ntdll, "RtlGetCompressionWorkSpaceSize");
			if (*RtlGetCompressionWorkSpaceSize == nullptr)
			{
				return 3;
			}
		}

		if (RtlDecompressBufferEx)
		{
			*RtlDecompressBufferEx = (_RtlDecompressBufferEx)GetProcAddress(ntdll, "RtlDecompressBufferEx");
			if (*RtlDecompressBufferEx == nullptr)
			{
				return 2;
			}
		}
	}
	else
	{
		return 1;
	}
	return 0;
}

```

`Sources/Utils/utils.h`:

```h
#pragma once


#include <string>
#include <vector>
#include <chrono>
#include <set>
#include <functional>
#include <iostream>
#include <distorm.h>

#include <WinSock2.h>
#include <ws2tcpip.h>
#include <Windows.h>
#include <tchar.h>
#include <inttypes.h>
#include <sddl.h>

#include "buffer.h"
#include "Compression/ntdll_defs.h"

#include <openssl/evp.h>
#include <openssl/aes.h>
#include <openssl/des.h>


#define POINTER_ADD(t, p, v)	(reinterpret_cast<t>(reinterpret_cast<uint64_t>(p) + v))

namespace utils
{
	namespace convert
	{
		std::shared_ptr<Buffer<PBYTE>> from_hex(std::string s);

		std::string to_hex(PVOID buffer, unsigned long size);
	}

	namespace strings
	{
		std::string upper(std::string& s);

		std::string lower(std::string& s);

		void ltrim(std::string& s);

		void rtrim(std::string& s);

		void trim(std::string& s);

		DWORD utf8_string_size(const std::string& str);

		std::wstring from_string(std::string s);

		std::u16string str_to_utf16(const std::string& s, DWORD encoding = CP_ACP);

		std::string str_to_utf8(std::string s, DWORD encoding = CP_ACP);

		std::string to_utf8(std::wstring s, DWORD encoding = CP_UTF8);

		std::string reverse(std::string input);

		void replace(std::string& str, const std::string& from, const std::string& to);

		std::vector<std::string> split(const std::string& text, TCHAR delimiter);

		std::string join(std::vector<std::string> items, std::string separator);
	}

	namespace format
	{
		std::string size(DWORD64 size);

		std::string hex(BYTE value, bool suffix = false, bool swap = false);

		std::string hex(USHORT value, bool suffix = false, bool swap = false);

		std::string hex(ULONG32 value, bool suffix = false, bool swap = false);

		std::string hex(DWORD value, bool suffix = false, bool swap = false);

		std::string hex6(ULONG64 value, bool suffix = false, bool swap = false);

		std::string hex(ULONG64 value, bool suffix = false, bool swap = false);

		std::string hex(LONG64 value, bool suffix = false, bool swap = false);

		std::string hex(std::u16string value, bool suffix = false, bool swap = false);

		std::string hex(std::string value, bool suffix = false, bool swap = false);

		std::string hex(PBYTE value, size_t byte_size, bool suffix = false, bool swap = false);
	}

	namespace processes {

		BOOL elevated(HANDLE p);
	}

	namespace files
	{
		std::string ensure_file_ext(const std::string& str, std::string ext);

		std::string basename(const std::string& str);

		std::pair<std::string, std::string> split_file_and_stream(std::string& str);
	}

	namespace times
	{
		std::string display_systemtime(SYSTEMTIME st);

		BOOL filetime_to_systemtime(FILETIME ft, PSYSTEMTIME pST);

		BOOL ull_to_systemtime(ULONGLONG ull, PSYSTEMTIME pST);

		BOOL filetime_to_local_systemtime(FILETIME ft, PSYSTEMTIME pST);

		BOOL ull_to_local_systemtime(ULONGLONG ull, PSYSTEMTIME pST);
	}

	namespace dirs
	{
		std::string temp();
	}

	namespace id
	{
		std::string guid_to_string(GUID id);

		std::string sid_to_string(PSID id);

		std::string username_from_sid(std::string sid);
	}

	namespace os
	{
		std::string short_version();
	}

	namespace ui
	{
		std::string line(unsigned int length, char type = '-');

		void title(std::string s, std::ostream& out = std::cout);

		bool ask_question(std::string question);
	}

	namespace disass
	{
		std::vector<std::string> buffer(PVOID code, ULONG32 size, _DecodeType type, _OffsetType offset);
	}

	namespace crypto
	{
		void xor_buffer(PVOID data, DWORD datalen, PVOID key, DWORD keylen);

		namespace cryptoapi
		{
			const EVP_MD* hash_to_evp(DWORD hash_alg);

			const EVP_CIPHER* encryption_to_evp(DWORD enc_alg);
		}
	}

	namespace dll
	{
		namespace ntdll
		{
			int load_compression_functions(_RtlDecompressBuffer* RtlDecompressBuffer, _RtlDecompressBufferEx* RtlDecompressBufferEx, _RtlGetCompressionWorkSpaceSize* RtlGetCompressionWorkSpaceSize);
		}
	}

}
```

`Sources/main.cpp`:

```cpp
#include <WinSock2.h>
#include <Windows.h>

#include "options.h"
#include "Commands/commands.h"
#include <Utils/crash_handler.h>

#include <iostream>
#include <filesystem>

int main(int argc, char** argv) {
	install_crash_handler();

	SetConsoleOutputCP(CP_UTF8);

	if (!utils::processes::elevated(GetCurrentProcess()))
	{
		std::cerr << "Administrator rights are required to read physical drives" << std::endl;
		return 1;
	}

	std::shared_ptr<Options> opts = parse_options(argc, argv);

	if (opts->show_usage)
	{
		commands::help::dispatch(opts);
	}
	else {
		try {
			if (opts->command == "mbr")						commands::mbr::dispatch(opts);
			else if (opts->command == "shell")				commands::shell::dispatch(opts);
			else if (opts->command == "smart")				commands::smart::dispatch(opts);
			else if (opts->command == "gpt")				commands::gpt::dispatch(opts);
			else if (opts->command == "usn")				commands::usn::dispatch(opts);
			else if (opts->command == "extract")			commands::extract::dispatch(opts);
			else if (opts->command == "vbr")				commands::vbr::dispatch(opts);
			else if (opts->command == "image")				commands::image::dispatch(opts);
			else if (opts->command == "undelete")			commands::undelete::dispatch(opts);
			else if (opts->command == "mft.record")			commands::mft::record::dispatch(opts);
			else if (opts->command == "mft.btree")			commands::mft::btree::dispatch(opts);
			else if (opts->command == "shadow")				commands::shadow::dispatch(opts);
			else if (opts->command == "logfile") 			commands::logfile::dispatch(opts);
			else if (opts->command == "reparse") 			commands::reparse::dispatch(opts);
			else if (opts->command == "streams") 			commands::streams::dispatch(opts);
			else if (opts->command == "efs.backup")			commands::efs::backup::dispatch(opts);
			else if (opts->command == "efs.certificate")	commands::efs::certificate::dispatch(opts);
			else if (opts->command == "efs.decrypt")		commands::efs::decrypt::dispatch(opts);
			else if (opts->command == "efs.masterkey")		commands::efs::masterkey::dispatch(opts);
			else if (opts->command == "efs.key")			commands::efs::key::dispatch(opts);
			else if (opts->command == "bitdecrypt")			commands::bitdecrypt::dispatch(opts);
			else if (opts->command == "bitlocker")			commands::bitlocker::dispatch(opts);
			else if (opts->command == "fve") 				commands::fve::dispatch(opts);
			else if (opts->command == "help")				commands::help::dispatch(opts);
			else if (opts->command == "info")				commands::info::dispatch(opts);
			else
			{
				if (opts->command == "")
				{
					commands::help::dispatch(opts);
				}
				else
				{
					throw std::logic_error("Unknown command '" + opts->command + "'");
				}
			}
		}
		catch (const std::exception& e)
		{
			std::cerr << e.what() << std::endl << std::endl;
			opts->subcommand = "";
			commands::help::dispatch(opts);
		}
	}

	uninstall_crash_handler();

	return 0;
}
```

`Sources/options.cpp`:

```cpp
#include "options.h"
#include <iostream>
#include <algorithm>
#include <cstring>
#include <Commands/commands.h>

bool equals(char* arg, const char* name) { return strncmp(arg, name, strlen(name)) == 0; }

bool is_option(char* arg, const char* name) { return (strncmp(arg, name, strlen(name)) == 0) && (arg[strlen(name)] == '='); }

bool is_number(const std::string& s)
{
	return !s.empty() && std::find_if(s.begin(),
		s.end(), [](unsigned char c) { return !std::isdigit(c); }) == s.end();
}

bool is_hexnum(const std::string& s)
{
	return !s.empty() && std::find_if(s.begin(),
		s.end(), [](unsigned char c) { return !std::isxdigit(c); }) == s.end();
}

void read_option_int64(char* arg, int64_t* pul)
{
	char* pos = strchr(arg, '=');
	if (is_number(pos + 1))
	{
		*pul = std::strtoull(pos + 1, NULL, 10);
	}
	else
	{
		if ((pos[1] == '0') && (pos[2] == 'x'))
		{
			if (is_hexnum(pos + 3))
			{
				*pul = std::strtoull(pos + 3, NULL, 16);
			}
			else
			{
				if (*pos == '=') *pos = 0;
				std::cerr << "[!] " << ((strnlen(pos + 1, 256) == 0) ? "Missing" : "Invalid") << " hex number for \"" << std::string(arg) << "\" argument" << ((strnlen(pos + 1, 256) == 0) ? "" : " (" + std::string(pos + 1) + ")") << std::endl;
				exit(1);
			}
		}
		else
		{
			if (*pos == '=') *pos = 0;
			std::cerr << "[!] " << ((strnlen(pos + 1, 256) == 0) ? "Missing" : "Invalid") << " number for \"" << std::string(arg) << "\" argument" << ((strnlen(pos + 1, 256) == 0) ? "" : " (" + std::string(pos + 1) + ")") << std::endl;
			exit(1);
		}
	}
}
void read_option_int32(char* arg, int32_t* pul)
{
	char* pos = strchr(arg, '=');
	if (is_number(pos + 1))
	{
		*pul = std::strtoul(pos + 1, NULL, 10);
	}
	else
	{
		if ((pos[1] == '0') && (pos[2] == 'x'))
		{
			if (is_hexnum(pos + 3))
			{
				*pul = std::strtoul(pos + 3, NULL, 16);
			}
			else
			{
				if (*pos == '=') *pos = 0;
				std::cerr << "[!] " << ((strnlen(pos + 1, 256) == 0) ? "Missing" : "Invalid") << " hex number for \"" << std::string(arg) << "\" argument" << ((strnlen(pos + 1, 256) == 0) ? "" : " (" + std::string(pos + 1) + ")") << std::endl;
				exit(1);
			}
		}
		else
		{
			if (*pos == '=') *pos = 0;
			std::cerr << "[!] " << ((strnlen(pos + 1, 256) == 0) ? "Missing" : "Invalid") << " number for \"" << std::string(arg) << "\" argument" << ((strnlen(pos + 1, 256) == 0) ? "" : " (" + std::string(pos + 1) + ")") << std::endl;
			exit(1);
		}
	}
}

void read_option_string(char* arg, std::string& s)
{
	char* pos = strchr(arg, '=');
	s = std::string(pos + 1);
}

void read_option_hexbuffer(char* arg, std::shared_ptr<Buffer<PBYTE>>* s)
{
	char* pos = strchr(arg, '=');
	std::string hexbuf = std::string(pos + 1);
	utils::strings::trim(hexbuf);
	*s = Buffer<PBYTE>::from_hex(hexbuf);
}

bool is_help(char* opt)
{
	return (equals(opt, "-h") || equals(opt, "--help") || equals(opt, "/?"));
}

std::shared_ptr<Options> parse_options(int argc, char** argv) {
	std::shared_ptr<Options> ret = std::make_shared<Options>();

	if (argc > 1)
	{
		if (is_help(argv[1])) ret->show_usage = true;
		else ret->command = std::string(argv[1]);
	}

	for (int i = 2; i < argc; i++)
	{
		if (is_option(argv[i], "output")) { read_option_string(argv[i], ret->output); continue; }
		if (is_option(argv[i], "from")) { read_option_string(argv[i], ret->from); continue; }
		if (is_option(argv[i], "disk")) { read_option_int32(argv[i], &ret->disk); continue; }
		if (is_option(argv[i], "volume")) { read_option_int32(argv[i], &ret->volume); continue; }
		if (is_option(argv[i], "inode")) { read_option_int64(argv[i], &ret->inode); continue; }
		if (is_option(argv[i], "fve_block")) { read_option_int32(argv[i], &ret->fve_block); continue; }
		if (is_option(argv[i], "password")) { read_option_string(argv[i], ret->password); continue; }
		if (is_option(argv[i], "sid")) { read_option_string(argv[i], ret->sid); continue; }
		if (is_option(argv[i], "masterkey")) { read_option_hexbuffer(argv[i], &ret->masterkey); continue; }
		if (is_option(argv[i], "pfx")) { read_option_string(argv[i], ret->pfx); continue; }
		if (is_option(argv[i], "recovery")) { read_option_string(argv[i], ret->recovery); continue; }
		if (is_option(argv[i], "image")) { read_option_string(argv[i], ret->image); continue; }
		if (is_option(argv[i], "bek")) { read_option_string(argv[i], ret->bek); continue; }
		if (is_option(argv[i], "fvek")) { read_option_string(argv[i], ret->fvek); continue; }
		if (is_option(argv[i], "format")) { read_option_string(argv[i], ret->format); continue; }
		if (!strncmp(argv[i], "--sam", 5)) { ret->sam = true; continue; }
		if (!strncmp(argv[i], "--system", 8)) { ret->system = true; continue; }
		if (is_help(argv[i])) { ret->show_usage = true; continue; }
		if (ret->subcommand == "") { ret->subcommand = std::string(argv[i]); continue; }

		std::cerr << std::endl << "[!] Invalid option: " << argv[i] << std::endl;
		ret->show_usage = true;
	}

	return ret;
}

std::shared_ptr<Disk> get_disk(std::shared_ptr<Options> opts)
{
	std::shared_ptr<Disk> disk = nullptr;
	if (opts->image != "")
	{
		disk = core::win::disks::from_image(opts->image);
		if (disk == nullptr)
		{
			invalid_option(opts, "image", opts->image);
		}
	}
	else
	{
		if (opts->disk >= 0)
		{
			disk = core::win::disks::by_index(opts->disk);
		}
		else
		{
			invalid_option(opts, "disk", opts->disk);
		}
	}
	return disk;
}

Options::Options()
{
}

void invalid_option(std::shared_ptr<Options> opts, std::string name, int64_t invalid_value, std::string error_msg)
{
	invalid_option(opts, name, invalid_value == -1 ? "" : std::to_string(invalid_value), error_msg);
}

void invalid_option(std::shared_ptr<Options> opts, std::string name, std::string invalid_value, std::string error_msg)
{
	if (invalid_value == "")
	{
		std::cerr << "[!] Missing ";
	}
	else
	{
		std::cerr << "[!] Invalid ";
	}
	std::cerr << name << " option";
	if (invalid_value != "")
	{
		std::cerr << " (" << invalid_value << ")";
	}
	if (error_msg.length())
	{
		std::cerr << ". " << error_msg;
	}
	std::cerr << std::endl << std::endl;

	opts->subcommand = opts->command;
	commands::help::dispatch(opts);
	exit(1);
}
```

`Sources/options.h`:

```h
#pragma once

#include <string>
#include <cstdint>
#include <memory>

#include "Drive/disk.h"

class Options {
private:
public:
	std::string command;
	std::string subcommand;
	std::string from;
	std::string output;
	std::string format;

	std::string password;
	std::string sid;
	std::string recovery;
	std::string bek;
	std::string fvek;
	std::string image;
	std::string pfx;

	std::shared_ptr<Buffer<PBYTE>> masterkey = nullptr;

	int64_t inode = -1;
	int32_t fve_block = -1;
	int32_t disk = -1;
	int32_t volume = -1;

	bool show_usage = false;
	bool sam = false;
	bool system = false;

	explicit Options();
};

std::shared_ptr<Options> parse_options(int argc, char** argv);

std::shared_ptr<Disk> get_disk(std::shared_ptr<Options> opts);


void invalid_option(std::shared_ptr<Options> opts, std::string name, int64_t invalid_value, std::string error_msg = "");

void invalid_option(std::shared_ptr<Options> opts, std::string name, std::string invalid_value, std::string error_msg = "");
```

`vcpkg.json`:

```json
{
  "name": "ntfstool",
  "version-string": "1.3",
  "description": "NTFSTool is a forensic tool for hard disks and NTFS volumes.",
  "homepage": "https://github.com/thewhiteninja/ntfstool",
  "dependencies": [
    {
      "name": "nlohmann-json",
      "platform": "windows"
    },
    {
      "name": "cppcoro",
      "platform": "windows"
    },
    {
      "name": "openssl",
      "platform": "windows"
    },
    {
      "name": "distorm",
      "platform": "windows"
    }
  ]
}

```