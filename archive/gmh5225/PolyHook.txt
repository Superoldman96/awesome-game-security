Project Path: arc_gmh5225_PolyHook_vgogxh47

Source Tree:

```txt
arc_gmh5225_PolyHook_vgogxh47
├── Capstone
│   ├── include
│   │   ├── arm.h
│   │   ├── arm64.h
│   │   ├── capstone.h
│   │   ├── mips.h
│   │   ├── platform.h
│   │   ├── ppc.h
│   │   ├── sparc.h
│   │   ├── systemz.h
│   │   ├── x86.h
│   │   └── xcore.h
│   ├── msvc
│   │   ├── x64
│   │   └── x86
│   └── msvc_vs2017
│       ├── x64
│       └── x86
├── LICENSE.md
├── PolyHook
│   ├── CatchUnitTest.h
│   ├── PolyHook.hpp
│   ├── PolyHook.vcxproj
│   ├── PolyHook.vcxproj.filters
│   └── Tests.cpp
├── PolyHook.sln
└── README.md

```

`Capstone/include/arm.h`:

```h
#ifndef CAPSTONE_ARM_H
#define CAPSTONE_ARM_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> ARM shift type
typedef enum arm_shifter {
	ARM_SFT_INVALID = 0,
	ARM_SFT_ASR,	// shift with immediate const
	ARM_SFT_LSL,	// shift with immediate const
	ARM_SFT_LSR,	// shift with immediate const
	ARM_SFT_ROR,	// shift with immediate const
	ARM_SFT_RRX,	// shift with immediate const
	ARM_SFT_ASR_REG,	// shift with register
	ARM_SFT_LSL_REG,	// shift with register
	ARM_SFT_LSR_REG,	// shift with register
	ARM_SFT_ROR_REG,	// shift with register
	ARM_SFT_RRX_REG,	// shift with register
} arm_shifter;

//> ARM condition code
typedef enum arm_cc {
	ARM_CC_INVALID = 0,
	ARM_CC_EQ,            // Equal                      Equal
	ARM_CC_NE,            // Not equal                  Not equal, or unordered
	ARM_CC_HS,            // Carry set                  >, ==, or unordered
	ARM_CC_LO,            // Carry clear                Less than
	ARM_CC_MI,            // Minus, negative            Less than
	ARM_CC_PL,            // Plus, positive or zero     >, ==, or unordered
	ARM_CC_VS,            // Overflow                   Unordered
	ARM_CC_VC,            // No overflow                Not unordered
	ARM_CC_HI,            // Unsigned higher            Greater than, or unordered
	ARM_CC_LS,            // Unsigned lower or same     Less than or equal
	ARM_CC_GE,            // Greater than or equal      Greater than or equal
	ARM_CC_LT,            // Less than                  Less than, or unordered
	ARM_CC_GT,            // Greater than               Greater than
	ARM_CC_LE,            // Less than or equal         <, ==, or unordered
	ARM_CC_AL             // Always (unconditional)     Always (unconditional)
} arm_cc;

typedef enum arm_sysreg {
	//> Special registers for MSR
	ARM_SYSREG_INVALID = 0,

	// SPSR* registers can be OR combined
	ARM_SYSREG_SPSR_C = 1,
	ARM_SYSREG_SPSR_X = 2,
	ARM_SYSREG_SPSR_S = 4,
	ARM_SYSREG_SPSR_F = 8,

	// CPSR* registers can be OR combined
	ARM_SYSREG_CPSR_C = 16,
	ARM_SYSREG_CPSR_X = 32,
	ARM_SYSREG_CPSR_S = 64,
	ARM_SYSREG_CPSR_F = 128,

	// independent registers
	ARM_SYSREG_APSR = 256,
	ARM_SYSREG_APSR_G,
	ARM_SYSREG_APSR_NZCVQ,
	ARM_SYSREG_APSR_NZCVQG,

	ARM_SYSREG_IAPSR,
	ARM_SYSREG_IAPSR_G,
	ARM_SYSREG_IAPSR_NZCVQG,

	ARM_SYSREG_EAPSR,
	ARM_SYSREG_EAPSR_G,
	ARM_SYSREG_EAPSR_NZCVQG,

	ARM_SYSREG_XPSR,
	ARM_SYSREG_XPSR_G,
	ARM_SYSREG_XPSR_NZCVQG,

	ARM_SYSREG_IPSR,
	ARM_SYSREG_EPSR,
	ARM_SYSREG_IEPSR,

	ARM_SYSREG_MSP,
	ARM_SYSREG_PSP,
	ARM_SYSREG_PRIMASK,
	ARM_SYSREG_BASEPRI,
	ARM_SYSREG_BASEPRI_MAX,
	ARM_SYSREG_FAULTMASK,
	ARM_SYSREG_CONTROL,
} arm_sysreg;

//> The memory barrier constants map directly to the 4-bit encoding of
//> the option field for Memory Barrier operations.
typedef enum arm_mem_barrier {
	ARM_MB_INVALID = 0,
	ARM_MB_RESERVED_0,
	ARM_MB_OSHLD,
	ARM_MB_OSHST,
	ARM_MB_OSH,
	ARM_MB_RESERVED_4,
	ARM_MB_NSHLD,
	ARM_MB_NSHST,
	ARM_MB_NSH,
	ARM_MB_RESERVED_8,
	ARM_MB_ISHLD,
	ARM_MB_ISHST,
	ARM_MB_ISH,
	ARM_MB_RESERVED_12,
	ARM_MB_LD,
	ARM_MB_ST,
	ARM_MB_SY,
} arm_mem_barrier;

//> Operand type for instruction's operands
typedef enum arm_op_type {
	ARM_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	ARM_OP_REG, // = CS_OP_REG (Register operand).
	ARM_OP_IMM, // = CS_OP_IMM (Immediate operand).
	ARM_OP_MEM, // = CS_OP_MEM (Memory operand).
	ARM_OP_FP,  // = CS_OP_FP (Floating-Point operand).
	ARM_OP_CIMM = 64, // C-Immediate (coprocessor registers)
	ARM_OP_PIMM, // P-Immediate (coprocessor registers)
	ARM_OP_SETEND,	// operand for SETEND instruction
	ARM_OP_SYSREG,	// MSR/MSR special register operand
} arm_op_type;

//> Operand type for SETEND instruction
typedef enum arm_setend_type {
	ARM_SETEND_INVALID = 0,	// Uninitialized.
	ARM_SETEND_BE,	// BE operand.
	ARM_SETEND_LE, // LE operand
} arm_setend_type;

typedef enum arm_cpsmode_type {
	ARM_CPSMODE_INVALID = 0,
	ARM_CPSMODE_IE = 2,
	ARM_CPSMODE_ID = 3
} arm_cpsmode_type;

//> Operand type for SETEND instruction
typedef enum arm_cpsflag_type {
	ARM_CPSFLAG_INVALID = 0,
	ARM_CPSFLAG_F = 1,
	ARM_CPSFLAG_I = 2,
	ARM_CPSFLAG_A = 4,
	ARM_CPSFLAG_NONE = 16,	// no flag
} arm_cpsflag_type;

//> Data type for elements of vector instructions.
typedef enum arm_vectordata_type {
	ARM_VECTORDATA_INVALID = 0,

	// Integer type
	ARM_VECTORDATA_I8,
	ARM_VECTORDATA_I16,
	ARM_VECTORDATA_I32,
	ARM_VECTORDATA_I64,

	// Signed integer type
	ARM_VECTORDATA_S8,
	ARM_VECTORDATA_S16,
	ARM_VECTORDATA_S32,
	ARM_VECTORDATA_S64,

	// Unsigned integer type
	ARM_VECTORDATA_U8,
	ARM_VECTORDATA_U16,
	ARM_VECTORDATA_U32,
	ARM_VECTORDATA_U64,

	// Data type for VMUL/VMULL
	ARM_VECTORDATA_P8,

	// Floating type
	ARM_VECTORDATA_F32,
	ARM_VECTORDATA_F64,

	// Convert float <-> float
	ARM_VECTORDATA_F16F64,	// f16.f64
	ARM_VECTORDATA_F64F16,	// f64.f16
	ARM_VECTORDATA_F32F16,	// f32.f16
	ARM_VECTORDATA_F16F32,	// f32.f16
	ARM_VECTORDATA_F64F32,	// f64.f32
	ARM_VECTORDATA_F32F64,	// f32.f64

	// Convert integer <-> float
	ARM_VECTORDATA_S32F32,	// s32.f32
	ARM_VECTORDATA_U32F32,	// u32.f32
	ARM_VECTORDATA_F32S32,	// f32.s32
	ARM_VECTORDATA_F32U32,	// f32.u32
	ARM_VECTORDATA_F64S16,	// f64.s16
	ARM_VECTORDATA_F32S16,	// f32.s16
	ARM_VECTORDATA_F64S32,	// f64.s32
	ARM_VECTORDATA_S16F64,	// s16.f64
	ARM_VECTORDATA_S16F32,	// s16.f64
	ARM_VECTORDATA_S32F64,	// s32.f64
	ARM_VECTORDATA_U16F64,	// u16.f64
	ARM_VECTORDATA_U16F32,	// u16.f32
	ARM_VECTORDATA_U32F64,	// u32.f64
	ARM_VECTORDATA_F64U16,	// f64.u16
	ARM_VECTORDATA_F32U16,	// f32.u16
	ARM_VECTORDATA_F64U32,	// f64.u32
} arm_vectordata_type;

// Instruction's operand referring to memory
// This is associated with ARM_OP_MEM operand type above
typedef struct arm_op_mem {
	unsigned int base;	// base register
	unsigned int index;	// index register
	int scale;	// scale for index register (can be 1, or -1)
	int disp;	// displacement/offset value
} arm_op_mem;

// Instruction operand
typedef struct cs_arm_op {
	int vector_index;	// Vector Index for some vector operands (or -1 if irrelevant)
	struct {
		arm_shifter type;
		unsigned int value;
	} shift;
	arm_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG/SYSREG operand
		int32_t imm;			// immediate value for C-IMM, P-IMM or IMM operand
		double fp;			// floating point value for FP operand
		arm_op_mem mem;		// base/index/scale/disp value for MEM operand
		arm_setend_type setend; // SETEND instruction's operand type
	};
	// in some instructions, an operand can be subtracted or added to
	// the base register,
	bool subtracted; // if TRUE, this operand is subtracted. otherwise, it is added.
} cs_arm_op;

// Instruction structure
typedef struct cs_arm {
	bool usermode;	// User-mode registers to be loaded (for LDM/STM instructions)
	int vector_size; 	// Scalar size for vector instructions
	arm_vectordata_type vector_data; // Data type for elements of vector instructions
	arm_cpsmode_type cps_mode;	// CPS mode for CPS instruction
	arm_cpsflag_type cps_flag;	// CPS mode for CPS instruction
	arm_cc cc;			// conditional code for this insn
	bool update_flags;	// does this insn update flags?
	bool writeback;		// does this insn write-back?
	arm_mem_barrier mem_barrier;	// Option for some memory barrier instructions

	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;

	cs_arm_op operands[36];	// operands for this instruction.
} cs_arm;

//> ARM registers
typedef enum arm_reg {
	ARM_REG_INVALID = 0,
	ARM_REG_APSR,
	ARM_REG_APSR_NZCV,
	ARM_REG_CPSR,
	ARM_REG_FPEXC,
	ARM_REG_FPINST,
	ARM_REG_FPSCR,
	ARM_REG_FPSCR_NZCV,
	ARM_REG_FPSID,
	ARM_REG_ITSTATE,
	ARM_REG_LR,
	ARM_REG_PC,
	ARM_REG_SP,
	ARM_REG_SPSR,
	ARM_REG_D0,
	ARM_REG_D1,
	ARM_REG_D2,
	ARM_REG_D3,
	ARM_REG_D4,
	ARM_REG_D5,
	ARM_REG_D6,
	ARM_REG_D7,
	ARM_REG_D8,
	ARM_REG_D9,
	ARM_REG_D10,
	ARM_REG_D11,
	ARM_REG_D12,
	ARM_REG_D13,
	ARM_REG_D14,
	ARM_REG_D15,
	ARM_REG_D16,
	ARM_REG_D17,
	ARM_REG_D18,
	ARM_REG_D19,
	ARM_REG_D20,
	ARM_REG_D21,
	ARM_REG_D22,
	ARM_REG_D23,
	ARM_REG_D24,
	ARM_REG_D25,
	ARM_REG_D26,
	ARM_REG_D27,
	ARM_REG_D28,
	ARM_REG_D29,
	ARM_REG_D30,
	ARM_REG_D31,
	ARM_REG_FPINST2,
	ARM_REG_MVFR0,
	ARM_REG_MVFR1,
	ARM_REG_MVFR2,
	ARM_REG_Q0,
	ARM_REG_Q1,
	ARM_REG_Q2,
	ARM_REG_Q3,
	ARM_REG_Q4,
	ARM_REG_Q5,
	ARM_REG_Q6,
	ARM_REG_Q7,
	ARM_REG_Q8,
	ARM_REG_Q9,
	ARM_REG_Q10,
	ARM_REG_Q11,
	ARM_REG_Q12,
	ARM_REG_Q13,
	ARM_REG_Q14,
	ARM_REG_Q15,
	ARM_REG_R0,
	ARM_REG_R1,
	ARM_REG_R2,
	ARM_REG_R3,
	ARM_REG_R4,
	ARM_REG_R5,
	ARM_REG_R6,
	ARM_REG_R7,
	ARM_REG_R8,
	ARM_REG_R9,
	ARM_REG_R10,
	ARM_REG_R11,
	ARM_REG_R12,
	ARM_REG_S0,
	ARM_REG_S1,
	ARM_REG_S2,
	ARM_REG_S3,
	ARM_REG_S4,
	ARM_REG_S5,
	ARM_REG_S6,
	ARM_REG_S7,
	ARM_REG_S8,
	ARM_REG_S9,
	ARM_REG_S10,
	ARM_REG_S11,
	ARM_REG_S12,
	ARM_REG_S13,
	ARM_REG_S14,
	ARM_REG_S15,
	ARM_REG_S16,
	ARM_REG_S17,
	ARM_REG_S18,
	ARM_REG_S19,
	ARM_REG_S20,
	ARM_REG_S21,
	ARM_REG_S22,
	ARM_REG_S23,
	ARM_REG_S24,
	ARM_REG_S25,
	ARM_REG_S26,
	ARM_REG_S27,
	ARM_REG_S28,
	ARM_REG_S29,
	ARM_REG_S30,
	ARM_REG_S31,

	ARM_REG_ENDING,		// <-- mark the end of the list or registers

	//> alias registers
	ARM_REG_R13 = ARM_REG_SP,
	ARM_REG_R14 = ARM_REG_LR,
	ARM_REG_R15 = ARM_REG_PC,

	ARM_REG_SB = ARM_REG_R9,
	ARM_REG_SL = ARM_REG_R10,
	ARM_REG_FP = ARM_REG_R11,
	ARM_REG_IP = ARM_REG_R12,
} arm_reg;

//> ARM instruction
typedef enum arm_insn {
	ARM_INS_INVALID = 0,

	ARM_INS_ADC,
	ARM_INS_ADD,
	ARM_INS_ADR,
	ARM_INS_AESD,
	ARM_INS_AESE,
	ARM_INS_AESIMC,
	ARM_INS_AESMC,
	ARM_INS_AND,
	ARM_INS_BFC,
	ARM_INS_BFI,
	ARM_INS_BIC,
	ARM_INS_BKPT,
	ARM_INS_BL,
	ARM_INS_BLX,
	ARM_INS_BX,
	ARM_INS_BXJ,
	ARM_INS_B,
	ARM_INS_CDP,
	ARM_INS_CDP2,
	ARM_INS_CLREX,
	ARM_INS_CLZ,
	ARM_INS_CMN,
	ARM_INS_CMP,
	ARM_INS_CPS,
	ARM_INS_CRC32B,
	ARM_INS_CRC32CB,
	ARM_INS_CRC32CH,
	ARM_INS_CRC32CW,
	ARM_INS_CRC32H,
	ARM_INS_CRC32W,
	ARM_INS_DBG,
	ARM_INS_DMB,
	ARM_INS_DSB,
	ARM_INS_EOR,
	ARM_INS_VMOV,
	ARM_INS_FLDMDBX,
	ARM_INS_FLDMIAX,
	ARM_INS_VMRS,
	ARM_INS_FSTMDBX,
	ARM_INS_FSTMIAX,
	ARM_INS_HINT,
	ARM_INS_HLT,
	ARM_INS_ISB,
	ARM_INS_LDA,
	ARM_INS_LDAB,
	ARM_INS_LDAEX,
	ARM_INS_LDAEXB,
	ARM_INS_LDAEXD,
	ARM_INS_LDAEXH,
	ARM_INS_LDAH,
	ARM_INS_LDC2L,
	ARM_INS_LDC2,
	ARM_INS_LDCL,
	ARM_INS_LDC,
	ARM_INS_LDMDA,
	ARM_INS_LDMDB,
	ARM_INS_LDM,
	ARM_INS_LDMIB,
	ARM_INS_LDRBT,
	ARM_INS_LDRB,
	ARM_INS_LDRD,
	ARM_INS_LDREX,
	ARM_INS_LDREXB,
	ARM_INS_LDREXD,
	ARM_INS_LDREXH,
	ARM_INS_LDRH,
	ARM_INS_LDRHT,
	ARM_INS_LDRSB,
	ARM_INS_LDRSBT,
	ARM_INS_LDRSH,
	ARM_INS_LDRSHT,
	ARM_INS_LDRT,
	ARM_INS_LDR,
	ARM_INS_MCR,
	ARM_INS_MCR2,
	ARM_INS_MCRR,
	ARM_INS_MCRR2,
	ARM_INS_MLA,
	ARM_INS_MLS,
	ARM_INS_MOV,
	ARM_INS_MOVT,
	ARM_INS_MOVW,
	ARM_INS_MRC,
	ARM_INS_MRC2,
	ARM_INS_MRRC,
	ARM_INS_MRRC2,
	ARM_INS_MRS,
	ARM_INS_MSR,
	ARM_INS_MUL,
	ARM_INS_MVN,
	ARM_INS_ORR,
	ARM_INS_PKHBT,
	ARM_INS_PKHTB,
	ARM_INS_PLDW,
	ARM_INS_PLD,
	ARM_INS_PLI,
	ARM_INS_QADD,
	ARM_INS_QADD16,
	ARM_INS_QADD8,
	ARM_INS_QASX,
	ARM_INS_QDADD,
	ARM_INS_QDSUB,
	ARM_INS_QSAX,
	ARM_INS_QSUB,
	ARM_INS_QSUB16,
	ARM_INS_QSUB8,
	ARM_INS_RBIT,
	ARM_INS_REV,
	ARM_INS_REV16,
	ARM_INS_REVSH,
	ARM_INS_RFEDA,
	ARM_INS_RFEDB,
	ARM_INS_RFEIA,
	ARM_INS_RFEIB,
	ARM_INS_RSB,
	ARM_INS_RSC,
	ARM_INS_SADD16,
	ARM_INS_SADD8,
	ARM_INS_SASX,
	ARM_INS_SBC,
	ARM_INS_SBFX,
	ARM_INS_SDIV,
	ARM_INS_SEL,
	ARM_INS_SETEND,
	ARM_INS_SHA1C,
	ARM_INS_SHA1H,
	ARM_INS_SHA1M,
	ARM_INS_SHA1P,
	ARM_INS_SHA1SU0,
	ARM_INS_SHA1SU1,
	ARM_INS_SHA256H,
	ARM_INS_SHA256H2,
	ARM_INS_SHA256SU0,
	ARM_INS_SHA256SU1,
	ARM_INS_SHADD16,
	ARM_INS_SHADD8,
	ARM_INS_SHASX,
	ARM_INS_SHSAX,
	ARM_INS_SHSUB16,
	ARM_INS_SHSUB8,
	ARM_INS_SMC,
	ARM_INS_SMLABB,
	ARM_INS_SMLABT,
	ARM_INS_SMLAD,
	ARM_INS_SMLADX,
	ARM_INS_SMLAL,
	ARM_INS_SMLALBB,
	ARM_INS_SMLALBT,
	ARM_INS_SMLALD,
	ARM_INS_SMLALDX,
	ARM_INS_SMLALTB,
	ARM_INS_SMLALTT,
	ARM_INS_SMLATB,
	ARM_INS_SMLATT,
	ARM_INS_SMLAWB,
	ARM_INS_SMLAWT,
	ARM_INS_SMLSD,
	ARM_INS_SMLSDX,
	ARM_INS_SMLSLD,
	ARM_INS_SMLSLDX,
	ARM_INS_SMMLA,
	ARM_INS_SMMLAR,
	ARM_INS_SMMLS,
	ARM_INS_SMMLSR,
	ARM_INS_SMMUL,
	ARM_INS_SMMULR,
	ARM_INS_SMUAD,
	ARM_INS_SMUADX,
	ARM_INS_SMULBB,
	ARM_INS_SMULBT,
	ARM_INS_SMULL,
	ARM_INS_SMULTB,
	ARM_INS_SMULTT,
	ARM_INS_SMULWB,
	ARM_INS_SMULWT,
	ARM_INS_SMUSD,
	ARM_INS_SMUSDX,
	ARM_INS_SRSDA,
	ARM_INS_SRSDB,
	ARM_INS_SRSIA,
	ARM_INS_SRSIB,
	ARM_INS_SSAT,
	ARM_INS_SSAT16,
	ARM_INS_SSAX,
	ARM_INS_SSUB16,
	ARM_INS_SSUB8,
	ARM_INS_STC2L,
	ARM_INS_STC2,
	ARM_INS_STCL,
	ARM_INS_STC,
	ARM_INS_STL,
	ARM_INS_STLB,
	ARM_INS_STLEX,
	ARM_INS_STLEXB,
	ARM_INS_STLEXD,
	ARM_INS_STLEXH,
	ARM_INS_STLH,
	ARM_INS_STMDA,
	ARM_INS_STMDB,
	ARM_INS_STM,
	ARM_INS_STMIB,
	ARM_INS_STRBT,
	ARM_INS_STRB,
	ARM_INS_STRD,
	ARM_INS_STREX,
	ARM_INS_STREXB,
	ARM_INS_STREXD,
	ARM_INS_STREXH,
	ARM_INS_STRH,
	ARM_INS_STRHT,
	ARM_INS_STRT,
	ARM_INS_STR,
	ARM_INS_SUB,
	ARM_INS_SVC,
	ARM_INS_SWP,
	ARM_INS_SWPB,
	ARM_INS_SXTAB,
	ARM_INS_SXTAB16,
	ARM_INS_SXTAH,
	ARM_INS_SXTB,
	ARM_INS_SXTB16,
	ARM_INS_SXTH,
	ARM_INS_TEQ,
	ARM_INS_TRAP,
	ARM_INS_TST,
	ARM_INS_UADD16,
	ARM_INS_UADD8,
	ARM_INS_UASX,
	ARM_INS_UBFX,
	ARM_INS_UDF,
	ARM_INS_UDIV,
	ARM_INS_UHADD16,
	ARM_INS_UHADD8,
	ARM_INS_UHASX,
	ARM_INS_UHSAX,
	ARM_INS_UHSUB16,
	ARM_INS_UHSUB8,
	ARM_INS_UMAAL,
	ARM_INS_UMLAL,
	ARM_INS_UMULL,
	ARM_INS_UQADD16,
	ARM_INS_UQADD8,
	ARM_INS_UQASX,
	ARM_INS_UQSAX,
	ARM_INS_UQSUB16,
	ARM_INS_UQSUB8,
	ARM_INS_USAD8,
	ARM_INS_USADA8,
	ARM_INS_USAT,
	ARM_INS_USAT16,
	ARM_INS_USAX,
	ARM_INS_USUB16,
	ARM_INS_USUB8,
	ARM_INS_UXTAB,
	ARM_INS_UXTAB16,
	ARM_INS_UXTAH,
	ARM_INS_UXTB,
	ARM_INS_UXTB16,
	ARM_INS_UXTH,
	ARM_INS_VABAL,
	ARM_INS_VABA,
	ARM_INS_VABDL,
	ARM_INS_VABD,
	ARM_INS_VABS,
	ARM_INS_VACGE,
	ARM_INS_VACGT,
	ARM_INS_VADD,
	ARM_INS_VADDHN,
	ARM_INS_VADDL,
	ARM_INS_VADDW,
	ARM_INS_VAND,
	ARM_INS_VBIC,
	ARM_INS_VBIF,
	ARM_INS_VBIT,
	ARM_INS_VBSL,
	ARM_INS_VCEQ,
	ARM_INS_VCGE,
	ARM_INS_VCGT,
	ARM_INS_VCLE,
	ARM_INS_VCLS,
	ARM_INS_VCLT,
	ARM_INS_VCLZ,
	ARM_INS_VCMP,
	ARM_INS_VCMPE,
	ARM_INS_VCNT,
	ARM_INS_VCVTA,
	ARM_INS_VCVTB,
	ARM_INS_VCVT,
	ARM_INS_VCVTM,
	ARM_INS_VCVTN,
	ARM_INS_VCVTP,
	ARM_INS_VCVTT,
	ARM_INS_VDIV,
	ARM_INS_VDUP,
	ARM_INS_VEOR,
	ARM_INS_VEXT,
	ARM_INS_VFMA,
	ARM_INS_VFMS,
	ARM_INS_VFNMA,
	ARM_INS_VFNMS,
	ARM_INS_VHADD,
	ARM_INS_VHSUB,
	ARM_INS_VLD1,
	ARM_INS_VLD2,
	ARM_INS_VLD3,
	ARM_INS_VLD4,
	ARM_INS_VLDMDB,
	ARM_INS_VLDMIA,
	ARM_INS_VLDR,
	ARM_INS_VMAXNM,
	ARM_INS_VMAX,
	ARM_INS_VMINNM,
	ARM_INS_VMIN,
	ARM_INS_VMLA,
	ARM_INS_VMLAL,
	ARM_INS_VMLS,
	ARM_INS_VMLSL,
	ARM_INS_VMOVL,
	ARM_INS_VMOVN,
	ARM_INS_VMSR,
	ARM_INS_VMUL,
	ARM_INS_VMULL,
	ARM_INS_VMVN,
	ARM_INS_VNEG,
	ARM_INS_VNMLA,
	ARM_INS_VNMLS,
	ARM_INS_VNMUL,
	ARM_INS_VORN,
	ARM_INS_VORR,
	ARM_INS_VPADAL,
	ARM_INS_VPADDL,
	ARM_INS_VPADD,
	ARM_INS_VPMAX,
	ARM_INS_VPMIN,
	ARM_INS_VQABS,
	ARM_INS_VQADD,
	ARM_INS_VQDMLAL,
	ARM_INS_VQDMLSL,
	ARM_INS_VQDMULH,
	ARM_INS_VQDMULL,
	ARM_INS_VQMOVUN,
	ARM_INS_VQMOVN,
	ARM_INS_VQNEG,
	ARM_INS_VQRDMULH,
	ARM_INS_VQRSHL,
	ARM_INS_VQRSHRN,
	ARM_INS_VQRSHRUN,
	ARM_INS_VQSHL,
	ARM_INS_VQSHLU,
	ARM_INS_VQSHRN,
	ARM_INS_VQSHRUN,
	ARM_INS_VQSUB,
	ARM_INS_VRADDHN,
	ARM_INS_VRECPE,
	ARM_INS_VRECPS,
	ARM_INS_VREV16,
	ARM_INS_VREV32,
	ARM_INS_VREV64,
	ARM_INS_VRHADD,
	ARM_INS_VRINTA,
	ARM_INS_VRINTM,
	ARM_INS_VRINTN,
	ARM_INS_VRINTP,
	ARM_INS_VRINTR,
	ARM_INS_VRINTX,
	ARM_INS_VRINTZ,
	ARM_INS_VRSHL,
	ARM_INS_VRSHRN,
	ARM_INS_VRSHR,
	ARM_INS_VRSQRTE,
	ARM_INS_VRSQRTS,
	ARM_INS_VRSRA,
	ARM_INS_VRSUBHN,
	ARM_INS_VSELEQ,
	ARM_INS_VSELGE,
	ARM_INS_VSELGT,
	ARM_INS_VSELVS,
	ARM_INS_VSHLL,
	ARM_INS_VSHL,
	ARM_INS_VSHRN,
	ARM_INS_VSHR,
	ARM_INS_VSLI,
	ARM_INS_VSQRT,
	ARM_INS_VSRA,
	ARM_INS_VSRI,
	ARM_INS_VST1,
	ARM_INS_VST2,
	ARM_INS_VST3,
	ARM_INS_VST4,
	ARM_INS_VSTMDB,
	ARM_INS_VSTMIA,
	ARM_INS_VSTR,
	ARM_INS_VSUB,
	ARM_INS_VSUBHN,
	ARM_INS_VSUBL,
	ARM_INS_VSUBW,
	ARM_INS_VSWP,
	ARM_INS_VTBL,
	ARM_INS_VTBX,
	ARM_INS_VCVTR,
	ARM_INS_VTRN,
	ARM_INS_VTST,
	ARM_INS_VUZP,
	ARM_INS_VZIP,
	ARM_INS_ADDW,
	ARM_INS_ASR,
	ARM_INS_DCPS1,
	ARM_INS_DCPS2,
	ARM_INS_DCPS3,
	ARM_INS_IT,
	ARM_INS_LSL,
	ARM_INS_LSR,
	ARM_INS_ASRS,
	ARM_INS_LSRS,
	ARM_INS_ORN,
	ARM_INS_ROR,
	ARM_INS_RRX,
	ARM_INS_SUBS,
	ARM_INS_SUBW,
	ARM_INS_TBB,
	ARM_INS_TBH,
	ARM_INS_CBNZ,
	ARM_INS_CBZ,
	ARM_INS_MOVS,
	ARM_INS_POP,
	ARM_INS_PUSH,

	// special instructions
	ARM_INS_NOP,
	ARM_INS_YIELD,
	ARM_INS_WFE,
	ARM_INS_WFI,
	ARM_INS_SEV,
	ARM_INS_SEVL,
	ARM_INS_VPUSH,
	ARM_INS_VPOP,

	ARM_INS_ENDING,	// <-- mark the end of the list of instructions
} arm_insn;

//> Group of ARM instructions
typedef enum arm_insn_group {
	ARM_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	ARM_GRP_JUMP,	// = CS_GRP_JUMP

	//> Architecture-specific groups
	ARM_GRP_CRYPTO = 128,
	ARM_GRP_DATABARRIER,
	ARM_GRP_DIVIDE,
	ARM_GRP_FPARMV8,
	ARM_GRP_MULTPRO,
	ARM_GRP_NEON,
	ARM_GRP_T2EXTRACTPACK,
	ARM_GRP_THUMB2DSP,
	ARM_GRP_TRUSTZONE,
	ARM_GRP_V4T,
	ARM_GRP_V5T,
	ARM_GRP_V5TE,
	ARM_GRP_V6,
	ARM_GRP_V6T2,
	ARM_GRP_V7,
	ARM_GRP_V8,
	ARM_GRP_VFP2,
	ARM_GRP_VFP3,
	ARM_GRP_VFP4,
	ARM_GRP_ARM,
	ARM_GRP_MCLASS,
	ARM_GRP_NOTMCLASS,
	ARM_GRP_THUMB,
	ARM_GRP_THUMB1ONLY,
	ARM_GRP_THUMB2,
	ARM_GRP_PREV8,
	ARM_GRP_FPVMLX,
	ARM_GRP_MULOPS,
	ARM_GRP_CRC,
	ARM_GRP_DPVFP,
	ARM_GRP_V6M,

	ARM_GRP_ENDING,
} arm_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`Capstone/include/arm64.h`:

```h
#ifndef CAPSTONE_ARM64_H
#define CAPSTONE_ARM64_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> ARM64 shift type
typedef enum arm64_shifter {
	ARM64_SFT_INVALID = 0,
	ARM64_SFT_LSL = 1,
	ARM64_SFT_MSL = 2,
	ARM64_SFT_LSR = 3,
	ARM64_SFT_ASR = 4,
	ARM64_SFT_ROR = 5,
} arm64_shifter;

//> ARM64 extender type
typedef enum arm64_extender {
	ARM64_EXT_INVALID = 0,
	ARM64_EXT_UXTB = 1,
	ARM64_EXT_UXTH = 2,
	ARM64_EXT_UXTW = 3,
	ARM64_EXT_UXTX = 4,
	ARM64_EXT_SXTB = 5,
	ARM64_EXT_SXTH = 6,
	ARM64_EXT_SXTW = 7,
	ARM64_EXT_SXTX = 8,
} arm64_extender;

//> ARM64 condition code
typedef enum arm64_cc {
	ARM64_CC_INVALID = 0,
	ARM64_CC_EQ = 1,     // Equal
	ARM64_CC_NE = 2,     // Not equal:                 Not equal, or unordered
	ARM64_CC_HS = 3,     // Unsigned higher or same:   >, ==, or unordered
	ARM64_CC_LO = 4,     // Unsigned lower or same:    Less than
	ARM64_CC_MI = 5,     // Minus, negative:           Less than
	ARM64_CC_PL = 6,     // Plus, positive or zero:    >, ==, or unordered
	ARM64_CC_VS = 7,     // Overflow:                  Unordered
	ARM64_CC_VC = 8,     // No overflow:               Ordered
	ARM64_CC_HI = 9,     // Unsigned higher:           Greater than, or unordered
	ARM64_CC_LS = 10,     // Unsigned lower or same:    Less than or equal
	ARM64_CC_GE = 11,     // Greater than or equal:     Greater than or equal
	ARM64_CC_LT = 12,     // Less than:                 Less than, or unordered
	ARM64_CC_GT = 13,     // Signed greater than:       Greater than
	ARM64_CC_LE = 14,     // Signed less than or equal: <, ==, or unordered
	ARM64_CC_AL = 15,     // Always (unconditional):    Always (unconditional)
	ARM64_CC_NV = 16,     // Always (unconditional):   Always (unconditional)
	// Note the NV exists purely to disassemble 0b1111. Execution
	// is "always".
} arm64_cc;

//> System registers
typedef enum arm64_mrs_reg {
	//> System registers for MRS
	ARM64_SYSREG_INVALID           = 0,
	ARM64_SYSREG_MDCCSR_EL0        = 0x9808, // 10  011  0000  0001  000
	ARM64_SYSREG_DBGDTRRX_EL0      = 0x9828, // 10  011  0000  0101  000
	ARM64_SYSREG_MDRAR_EL1         = 0x8080, // 10  000  0001  0000  000
	ARM64_SYSREG_OSLSR_EL1         = 0x808c, // 10  000  0001  0001  100
	ARM64_SYSREG_DBGAUTHSTATUS_EL1 = 0x83f6, // 10  000  0111  1110  110
	ARM64_SYSREG_PMCEID0_EL0       = 0xdce6, // 11  011  1001  1100  110
	ARM64_SYSREG_PMCEID1_EL0       = 0xdce7, // 11  011  1001  1100  111
	ARM64_SYSREG_MIDR_EL1          = 0xc000, // 11  000  0000  0000  000
	ARM64_SYSREG_CCSIDR_EL1        = 0xc800, // 11  001  0000  0000  000
	ARM64_SYSREG_CLIDR_EL1         = 0xc801, // 11  001  0000  0000  001
	ARM64_SYSREG_CTR_EL0           = 0xd801, // 11  011  0000  0000  001
	ARM64_SYSREG_MPIDR_EL1         = 0xc005, // 11  000  0000  0000  101
	ARM64_SYSREG_REVIDR_EL1        = 0xc006, // 11  000  0000  0000  110
	ARM64_SYSREG_AIDR_EL1          = 0xc807, // 11  001  0000  0000  111
	ARM64_SYSREG_DCZID_EL0         = 0xd807, // 11  011  0000  0000  111
	ARM64_SYSREG_ID_PFR0_EL1       = 0xc008, // 11  000  0000  0001  000
	ARM64_SYSREG_ID_PFR1_EL1       = 0xc009, // 11  000  0000  0001  001
	ARM64_SYSREG_ID_DFR0_EL1       = 0xc00a, // 11  000  0000  0001  010
	ARM64_SYSREG_ID_AFR0_EL1       = 0xc00b, // 11  000  0000  0001  011
	ARM64_SYSREG_ID_MMFR0_EL1      = 0xc00c, // 11  000  0000  0001  100
	ARM64_SYSREG_ID_MMFR1_EL1      = 0xc00d, // 11  000  0000  0001  101
	ARM64_SYSREG_ID_MMFR2_EL1      = 0xc00e, // 11  000  0000  0001  110
	ARM64_SYSREG_ID_MMFR3_EL1      = 0xc00f, // 11  000  0000  0001  111
	ARM64_SYSREG_ID_ISAR0_EL1      = 0xc010, // 11  000  0000  0010  000
	ARM64_SYSREG_ID_ISAR1_EL1      = 0xc011, // 11  000  0000  0010  001
	ARM64_SYSREG_ID_ISAR2_EL1      = 0xc012, // 11  000  0000  0010  010
	ARM64_SYSREG_ID_ISAR3_EL1      = 0xc013, // 11  000  0000  0010  011
	ARM64_SYSREG_ID_ISAR4_EL1      = 0xc014, // 11  000  0000  0010  100
	ARM64_SYSREG_ID_ISAR5_EL1      = 0xc015, // 11  000  0000  0010  101
	ARM64_SYSREG_ID_A64PFR0_EL1   = 0xc020, // 11  000  0000  0100  000
	ARM64_SYSREG_ID_A64PFR1_EL1   = 0xc021, // 11  000  0000  0100  001
	ARM64_SYSREG_ID_A64DFR0_EL1   = 0xc028, // 11  000  0000  0101  000
	ARM64_SYSREG_ID_A64DFR1_EL1   = 0xc029, // 11  000  0000  0101  001
	ARM64_SYSREG_ID_A64AFR0_EL1   = 0xc02c, // 11  000  0000  0101  100
	ARM64_SYSREG_ID_A64AFR1_EL1   = 0xc02d, // 11  000  0000  0101  101
	ARM64_SYSREG_ID_A64ISAR0_EL1  = 0xc030, // 11  000  0000  0110  000
	ARM64_SYSREG_ID_A64ISAR1_EL1  = 0xc031, // 11  000  0000  0110  001
	ARM64_SYSREG_ID_A64MMFR0_EL1  = 0xc038, // 11  000  0000  0111  000
	ARM64_SYSREG_ID_A64MMFR1_EL1  = 0xc039, // 11  000  0000  0111  001
	ARM64_SYSREG_MVFR0_EL1         = 0xc018, // 11  000  0000  0011  000
	ARM64_SYSREG_MVFR1_EL1         = 0xc019, // 11  000  0000  0011  001
	ARM64_SYSREG_MVFR2_EL1         = 0xc01a, // 11  000  0000  0011  010
	ARM64_SYSREG_RVBAR_EL1         = 0xc601, // 11  000  1100  0000  001
	ARM64_SYSREG_RVBAR_EL2         = 0xe601, // 11  100  1100  0000  001
	ARM64_SYSREG_RVBAR_EL3         = 0xf601, // 11  110  1100  0000  001
	ARM64_SYSREG_ISR_EL1           = 0xc608, // 11  000  1100  0001  000
	ARM64_SYSREG_CNTPCT_EL0        = 0xdf01, // 11  011  1110  0000  001
	ARM64_SYSREG_CNTVCT_EL0        = 0xdf02,  // 11  011  1110  0000  010

	// Trace registers
	ARM64_SYSREG_TRCSTATR          = 0x8818, // 10  001  0000  0011  000
	ARM64_SYSREG_TRCIDR8           = 0x8806, // 10  001  0000  0000  110
	ARM64_SYSREG_TRCIDR9           = 0x880e, // 10  001  0000  0001  110
	ARM64_SYSREG_TRCIDR10          = 0x8816, // 10  001  0000  0010  110
	ARM64_SYSREG_TRCIDR11          = 0x881e, // 10  001  0000  0011  110
	ARM64_SYSREG_TRCIDR12          = 0x8826, // 10  001  0000  0100  110
	ARM64_SYSREG_TRCIDR13          = 0x882e, // 10  001  0000  0101  110
	ARM64_SYSREG_TRCIDR0           = 0x8847, // 10  001  0000  1000  111
	ARM64_SYSREG_TRCIDR1           = 0x884f, // 10  001  0000  1001  111
	ARM64_SYSREG_TRCIDR2           = 0x8857, // 10  001  0000  1010  111
	ARM64_SYSREG_TRCIDR3           = 0x885f, // 10  001  0000  1011  111
	ARM64_SYSREG_TRCIDR4           = 0x8867, // 10  001  0000  1100  111
	ARM64_SYSREG_TRCIDR5           = 0x886f, // 10  001  0000  1101  111
	ARM64_SYSREG_TRCIDR6           = 0x8877, // 10  001  0000  1110  111
	ARM64_SYSREG_TRCIDR7           = 0x887f, // 10  001  0000  1111  111
	ARM64_SYSREG_TRCOSLSR          = 0x888c, // 10  001  0001  0001  100
	ARM64_SYSREG_TRCPDSR           = 0x88ac, // 10  001  0001  0101  100
	ARM64_SYSREG_TRCDEVAFF0        = 0x8bd6, // 10  001  0111  1010  110
	ARM64_SYSREG_TRCDEVAFF1        = 0x8bde, // 10  001  0111  1011  110
	ARM64_SYSREG_TRCLSR            = 0x8bee, // 10  001  0111  1101  110
	ARM64_SYSREG_TRCAUTHSTATUS     = 0x8bf6, // 10  001  0111  1110  110
	ARM64_SYSREG_TRCDEVARCH        = 0x8bfe, // 10  001  0111  1111  110
	ARM64_SYSREG_TRCDEVID          = 0x8b97, // 10  001  0111  0010  111
	ARM64_SYSREG_TRCDEVTYPE        = 0x8b9f, // 10  001  0111  0011  111
	ARM64_SYSREG_TRCPIDR4          = 0x8ba7, // 10  001  0111  0100  111
	ARM64_SYSREG_TRCPIDR5          = 0x8baf, // 10  001  0111  0101  111
	ARM64_SYSREG_TRCPIDR6          = 0x8bb7, // 10  001  0111  0110  111
	ARM64_SYSREG_TRCPIDR7          = 0x8bbf, // 10  001  0111  0111  111
	ARM64_SYSREG_TRCPIDR0          = 0x8bc7, // 10  001  0111  1000  111
	ARM64_SYSREG_TRCPIDR1          = 0x8bcf, // 10  001  0111  1001  111
	ARM64_SYSREG_TRCPIDR2          = 0x8bd7, // 10  001  0111  1010  111
	ARM64_SYSREG_TRCPIDR3          = 0x8bdf, // 10  001  0111  1011  111
	ARM64_SYSREG_TRCCIDR0          = 0x8be7, // 10  001  0111  1100  111
	ARM64_SYSREG_TRCCIDR1          = 0x8bef, // 10  001  0111  1101  111
	ARM64_SYSREG_TRCCIDR2          = 0x8bf7, // 10  001  0111  1110  111
	ARM64_SYSREG_TRCCIDR3          = 0x8bff, // 10  001  0111  1111  111

	// GICv3 registers
	ARM64_SYSREG_ICC_IAR1_EL1      = 0xc660, // 11  000  1100  1100  000
	ARM64_SYSREG_ICC_IAR0_EL1      = 0xc640, // 11  000  1100  1000  000
	ARM64_SYSREG_ICC_HPPIR1_EL1    = 0xc662, // 11  000  1100  1100  010
	ARM64_SYSREG_ICC_HPPIR0_EL1    = 0xc642, // 11  000  1100  1000  010
	ARM64_SYSREG_ICC_RPR_EL1       = 0xc65b, // 11  000  1100  1011  011
	ARM64_SYSREG_ICH_VTR_EL2       = 0xe659, // 11  100  1100  1011  001
	ARM64_SYSREG_ICH_EISR_EL2      = 0xe65b, // 11  100  1100  1011  011
	ARM64_SYSREG_ICH_ELSR_EL2      = 0xe65d, // 11  100  1100  1011  101
} arm64_sysreg;

typedef enum arm64_msr_reg {
	//> System registers for MSR
	ARM64_SYSREG_DBGDTRTX_EL0      = 0x9828, // 10  011  0000  0101  000
	ARM64_SYSREG_OSLAR_EL1         = 0x8084, // 10  000  0001  0000  100
	ARM64_SYSREG_PMSWINC_EL0       = 0xdce4,  // 11  011  1001  1100  100

	// Trace Registers
	ARM64_SYSREG_TRCOSLAR          = 0x8884, // 10  001  0001  0000  100
	ARM64_SYSREG_TRCLAR            = 0x8be6, // 10  001  0111  1100  110

	// GICv3 registers
	ARM64_SYSREG_ICC_EOIR1_EL1     = 0xc661, // 11  000  1100  1100  001
	ARM64_SYSREG_ICC_EOIR0_EL1     = 0xc641, // 11  000  1100  1000  001
	ARM64_SYSREG_ICC_DIR_EL1       = 0xc659, // 11  000  1100  1011  001
	ARM64_SYSREG_ICC_SGI1R_EL1     = 0xc65d, // 11  000  1100  1011  101
	ARM64_SYSREG_ICC_ASGI1R_EL1    = 0xc65e, // 11  000  1100  1011  110
	ARM64_SYSREG_ICC_SGI0R_EL1     = 0xc65f, // 11  000  1100  1011  111
} arm64_msr_reg;

//> System PState Field (MSR instruction)
typedef enum arm64_pstate {
	ARM64_PSTATE_INVALID = 0,
	ARM64_PSTATE_SPSEL = 0x05,
	ARM64_PSTATE_DAIFSET = 0x1e,
	ARM64_PSTATE_DAIFCLR = 0x1f
} arm64_pstate;

//> Vector arrangement specifier (for FloatingPoint/Advanced SIMD insn)
typedef enum arm64_vas {
	ARM64_VAS_INVALID = 0,
	ARM64_VAS_8B,
	ARM64_VAS_16B,
	ARM64_VAS_4H,
	ARM64_VAS_8H,
	ARM64_VAS_2S,
	ARM64_VAS_4S,
	ARM64_VAS_1D,
	ARM64_VAS_2D,
	ARM64_VAS_1Q,
} arm64_vas;

//> Vector element size specifier
typedef enum arm64_vess {
	ARM64_VESS_INVALID = 0,
	ARM64_VESS_B,
	ARM64_VESS_H,
	ARM64_VESS_S,
	ARM64_VESS_D,
} arm64_vess;

//> Memory barrier operands
typedef enum arm64_barrier_op {
	ARM64_BARRIER_INVALID = 0,
	ARM64_BARRIER_OSHLD = 0x1,
	ARM64_BARRIER_OSHST = 0x2,
	ARM64_BARRIER_OSH =   0x3,
	ARM64_BARRIER_NSHLD = 0x5,
	ARM64_BARRIER_NSHST = 0x6,
	ARM64_BARRIER_NSH =   0x7,
	ARM64_BARRIER_ISHLD = 0x9,
	ARM64_BARRIER_ISHST = 0xa,
	ARM64_BARRIER_ISH =   0xb,
	ARM64_BARRIER_LD =    0xd,
	ARM64_BARRIER_ST =    0xe,
	ARM64_BARRIER_SY =    0xf
} arm64_barrier_op;

//> Operand type for instruction's operands
typedef enum arm64_op_type {
	ARM64_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	ARM64_OP_REG, // = CS_OP_REG (Register operand).
	ARM64_OP_IMM, // = CS_OP_IMM (Immediate operand).
	ARM64_OP_MEM, // = CS_OP_MEM (Memory operand).
	ARM64_OP_FP,  // = CS_OP_FP (Floating-Point operand).
	ARM64_OP_CIMM = 64, // C-Immediate
	ARM64_OP_REG_MRS, // MRS register operand.
	ARM64_OP_REG_MSR, // MSR register operand.
	ARM64_OP_PSTATE, // PState operand.
	ARM64_OP_SYS, // SYS operand for IC/DC/AT/TLBI instructions.
	ARM64_OP_PREFETCH, // Prefetch operand (PRFM).
	ARM64_OP_BARRIER, // Memory barrier operand (ISB/DMB/DSB instructions).
} arm64_op_type;

//> TLBI operations
typedef enum arm64_tlbi_op {
	ARM64_TLBI_INVALID = 0,
	ARM64_TLBI_VMALLE1IS,
	ARM64_TLBI_VAE1IS,
	ARM64_TLBI_ASIDE1IS,
	ARM64_TLBI_VAAE1IS,
	ARM64_TLBI_VALE1IS,
	ARM64_TLBI_VAALE1IS,
	ARM64_TLBI_ALLE2IS,
	ARM64_TLBI_VAE2IS,
	ARM64_TLBI_ALLE1IS,
	ARM64_TLBI_VALE2IS,
	ARM64_TLBI_VMALLS12E1IS,
	ARM64_TLBI_ALLE3IS,
	ARM64_TLBI_VAE3IS,
	ARM64_TLBI_VALE3IS,
	ARM64_TLBI_IPAS2E1IS,
	ARM64_TLBI_IPAS2LE1IS,
	ARM64_TLBI_IPAS2E1,
	ARM64_TLBI_IPAS2LE1,
	ARM64_TLBI_VMALLE1,
	ARM64_TLBI_VAE1,
	ARM64_TLBI_ASIDE1,
	ARM64_TLBI_VAAE1,
	ARM64_TLBI_VALE1,
	ARM64_TLBI_VAALE1,
	ARM64_TLBI_ALLE2,
	ARM64_TLBI_VAE2,
	ARM64_TLBI_ALLE1,
	ARM64_TLBI_VALE2,
	ARM64_TLBI_VMALLS12E1,
	ARM64_TLBI_ALLE3,
	ARM64_TLBI_VAE3,
	ARM64_TLBI_VALE3,
} arm64_tlbi_op;

//> AT operations
typedef enum arm64_at_op {
	ARM64_AT_S1E1R,
	ARM64_AT_S1E1W,
	ARM64_AT_S1E0R,
	ARM64_AT_S1E0W,
	ARM64_AT_S1E2R,
	ARM64_AT_S1E2W,
	ARM64_AT_S12E1R,
	ARM64_AT_S12E1W,
	ARM64_AT_S12E0R,
	ARM64_AT_S12E0W,
	ARM64_AT_S1E3R,
	ARM64_AT_S1E3W,
} arm64_at_op;

//> DC operations
typedef enum arm64_dc_op {
	ARM64_DC_INVALID = 0,
	ARM64_DC_ZVA,
	ARM64_DC_IVAC,
	ARM64_DC_ISW,
	ARM64_DC_CVAC,
	ARM64_DC_CSW,
	ARM64_DC_CVAU,
	ARM64_DC_CIVAC,
	ARM64_DC_CISW,
} arm64_dc_op;

//> IC operations
typedef enum arm64_ic_op {
	ARM64_IC_INVALID = 0,
	ARM64_IC_IALLUIS,
	ARM64_IC_IALLU,
	ARM64_IC_IVAU,
} arm64_ic_op;

//> Prefetch operations (PRFM)
typedef enum arm64_prefetch_op {
	ARM64_PRFM_INVALID = 0,
	ARM64_PRFM_PLDL1KEEP = 0x00 + 1,
	ARM64_PRFM_PLDL1STRM = 0x01 + 1,
	ARM64_PRFM_PLDL2KEEP = 0x02 + 1,
	ARM64_PRFM_PLDL2STRM = 0x03 + 1,
	ARM64_PRFM_PLDL3KEEP = 0x04 + 1,
	ARM64_PRFM_PLDL3STRM = 0x05 + 1,
	ARM64_PRFM_PLIL1KEEP = 0x08 + 1,
	ARM64_PRFM_PLIL1STRM = 0x09 + 1,
	ARM64_PRFM_PLIL2KEEP = 0x0a + 1,
	ARM64_PRFM_PLIL2STRM = 0x0b + 1,
	ARM64_PRFM_PLIL3KEEP = 0x0c + 1,
	ARM64_PRFM_PLIL3STRM = 0x0d + 1,
	ARM64_PRFM_PSTL1KEEP = 0x10 + 1,
	ARM64_PRFM_PSTL1STRM = 0x11 + 1,
	ARM64_PRFM_PSTL2KEEP = 0x12 + 1,
	ARM64_PRFM_PSTL2STRM = 0x13 + 1,
	ARM64_PRFM_PSTL3KEEP = 0x14 + 1,
	ARM64_PRFM_PSTL3STRM = 0x15 + 1,
} arm64_prefetch_op;

// Instruction's operand referring to memory
// This is associated with ARM64_OP_MEM operand type above
typedef struct arm64_op_mem {
	unsigned int base;	// base register
	unsigned int index;	// index register
	int32_t disp;	// displacement/offset value
} arm64_op_mem;

// Instruction operand
typedef struct cs_arm64_op {
	int vector_index;	// Vector Index for some vector operands (or -1 if irrelevant)
	arm64_vas vas;		// Vector Arrangement Specifier
	arm64_vess vess;	// Vector Element Size Specifier
	struct {
		arm64_shifter type;	// shifter type of this operand
		unsigned int value;	// shifter value of this operand
	} shift;
	arm64_extender ext;		// extender type of this operand
	arm64_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG operand
		int64_t imm;		// immediate value, or index for C-IMM or IMM operand
		double fp;			// floating point value for FP operand
		arm64_op_mem mem;		// base/index/scale/disp value for MEM operand
		arm64_pstate pstate;		// PState field of MSR instruction.
		unsigned int sys;  // IC/DC/AT/TLBI operation (see arm64_ic_op, arm64_dc_op, arm64_at_op, arm64_tlbi_op)
		arm64_prefetch_op prefetch;  // PRFM operation.
		arm64_barrier_op barrier;  // Memory barrier operation (ISB/DMB/DSB instructions).
	};
} cs_arm64_op;

// Instruction structure
typedef struct cs_arm64 {
	arm64_cc cc;	// conditional code for this insn
	bool update_flags;	// does this insn update flags?
	bool writeback;	// does this insn request writeback? 'True' means 'yes'

	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;

	cs_arm64_op operands[8]; // operands for this instruction.
} cs_arm64;

//> ARM64 registers
typedef enum arm64_reg {
	ARM64_REG_INVALID = 0,

	ARM64_REG_X29,
	ARM64_REG_X30,
	ARM64_REG_NZCV,
	ARM64_REG_SP,
	ARM64_REG_WSP,
	ARM64_REG_WZR,
	ARM64_REG_XZR,
	ARM64_REG_B0,
	ARM64_REG_B1,
	ARM64_REG_B2,
	ARM64_REG_B3,
	ARM64_REG_B4,
	ARM64_REG_B5,
	ARM64_REG_B6,
	ARM64_REG_B7,
	ARM64_REG_B8,
	ARM64_REG_B9,
	ARM64_REG_B10,
	ARM64_REG_B11,
	ARM64_REG_B12,
	ARM64_REG_B13,
	ARM64_REG_B14,
	ARM64_REG_B15,
	ARM64_REG_B16,
	ARM64_REG_B17,
	ARM64_REG_B18,
	ARM64_REG_B19,
	ARM64_REG_B20,
	ARM64_REG_B21,
	ARM64_REG_B22,
	ARM64_REG_B23,
	ARM64_REG_B24,
	ARM64_REG_B25,
	ARM64_REG_B26,
	ARM64_REG_B27,
	ARM64_REG_B28,
	ARM64_REG_B29,
	ARM64_REG_B30,
	ARM64_REG_B31,
	ARM64_REG_D0,
	ARM64_REG_D1,
	ARM64_REG_D2,
	ARM64_REG_D3,
	ARM64_REG_D4,
	ARM64_REG_D5,
	ARM64_REG_D6,
	ARM64_REG_D7,
	ARM64_REG_D8,
	ARM64_REG_D9,
	ARM64_REG_D10,
	ARM64_REG_D11,
	ARM64_REG_D12,
	ARM64_REG_D13,
	ARM64_REG_D14,
	ARM64_REG_D15,
	ARM64_REG_D16,
	ARM64_REG_D17,
	ARM64_REG_D18,
	ARM64_REG_D19,
	ARM64_REG_D20,
	ARM64_REG_D21,
	ARM64_REG_D22,
	ARM64_REG_D23,
	ARM64_REG_D24,
	ARM64_REG_D25,
	ARM64_REG_D26,
	ARM64_REG_D27,
	ARM64_REG_D28,
	ARM64_REG_D29,
	ARM64_REG_D30,
	ARM64_REG_D31,
	ARM64_REG_H0,
	ARM64_REG_H1,
	ARM64_REG_H2,
	ARM64_REG_H3,
	ARM64_REG_H4,
	ARM64_REG_H5,
	ARM64_REG_H6,
	ARM64_REG_H7,
	ARM64_REG_H8,
	ARM64_REG_H9,
	ARM64_REG_H10,
	ARM64_REG_H11,
	ARM64_REG_H12,
	ARM64_REG_H13,
	ARM64_REG_H14,
	ARM64_REG_H15,
	ARM64_REG_H16,
	ARM64_REG_H17,
	ARM64_REG_H18,
	ARM64_REG_H19,
	ARM64_REG_H20,
	ARM64_REG_H21,
	ARM64_REG_H22,
	ARM64_REG_H23,
	ARM64_REG_H24,
	ARM64_REG_H25,
	ARM64_REG_H26,
	ARM64_REG_H27,
	ARM64_REG_H28,
	ARM64_REG_H29,
	ARM64_REG_H30,
	ARM64_REG_H31,
	ARM64_REG_Q0,
	ARM64_REG_Q1,
	ARM64_REG_Q2,
	ARM64_REG_Q3,
	ARM64_REG_Q4,
	ARM64_REG_Q5,
	ARM64_REG_Q6,
	ARM64_REG_Q7,
	ARM64_REG_Q8,
	ARM64_REG_Q9,
	ARM64_REG_Q10,
	ARM64_REG_Q11,
	ARM64_REG_Q12,
	ARM64_REG_Q13,
	ARM64_REG_Q14,
	ARM64_REG_Q15,
	ARM64_REG_Q16,
	ARM64_REG_Q17,
	ARM64_REG_Q18,
	ARM64_REG_Q19,
	ARM64_REG_Q20,
	ARM64_REG_Q21,
	ARM64_REG_Q22,
	ARM64_REG_Q23,
	ARM64_REG_Q24,
	ARM64_REG_Q25,
	ARM64_REG_Q26,
	ARM64_REG_Q27,
	ARM64_REG_Q28,
	ARM64_REG_Q29,
	ARM64_REG_Q30,
	ARM64_REG_Q31,
	ARM64_REG_S0,
	ARM64_REG_S1,
	ARM64_REG_S2,
	ARM64_REG_S3,
	ARM64_REG_S4,
	ARM64_REG_S5,
	ARM64_REG_S6,
	ARM64_REG_S7,
	ARM64_REG_S8,
	ARM64_REG_S9,
	ARM64_REG_S10,
	ARM64_REG_S11,
	ARM64_REG_S12,
	ARM64_REG_S13,
	ARM64_REG_S14,
	ARM64_REG_S15,
	ARM64_REG_S16,
	ARM64_REG_S17,
	ARM64_REG_S18,
	ARM64_REG_S19,
	ARM64_REG_S20,
	ARM64_REG_S21,
	ARM64_REG_S22,
	ARM64_REG_S23,
	ARM64_REG_S24,
	ARM64_REG_S25,
	ARM64_REG_S26,
	ARM64_REG_S27,
	ARM64_REG_S28,
	ARM64_REG_S29,
	ARM64_REG_S30,
	ARM64_REG_S31,
	ARM64_REG_W0,
	ARM64_REG_W1,
	ARM64_REG_W2,
	ARM64_REG_W3,
	ARM64_REG_W4,
	ARM64_REG_W5,
	ARM64_REG_W6,
	ARM64_REG_W7,
	ARM64_REG_W8,
	ARM64_REG_W9,
	ARM64_REG_W10,
	ARM64_REG_W11,
	ARM64_REG_W12,
	ARM64_REG_W13,
	ARM64_REG_W14,
	ARM64_REG_W15,
	ARM64_REG_W16,
	ARM64_REG_W17,
	ARM64_REG_W18,
	ARM64_REG_W19,
	ARM64_REG_W20,
	ARM64_REG_W21,
	ARM64_REG_W22,
	ARM64_REG_W23,
	ARM64_REG_W24,
	ARM64_REG_W25,
	ARM64_REG_W26,
	ARM64_REG_W27,
	ARM64_REG_W28,
	ARM64_REG_W29,
	ARM64_REG_W30,
	ARM64_REG_X0,
	ARM64_REG_X1,
	ARM64_REG_X2,
	ARM64_REG_X3,
	ARM64_REG_X4,
	ARM64_REG_X5,
	ARM64_REG_X6,
	ARM64_REG_X7,
	ARM64_REG_X8,
	ARM64_REG_X9,
	ARM64_REG_X10,
	ARM64_REG_X11,
	ARM64_REG_X12,
	ARM64_REG_X13,
	ARM64_REG_X14,
	ARM64_REG_X15,
	ARM64_REG_X16,
	ARM64_REG_X17,
	ARM64_REG_X18,
	ARM64_REG_X19,
	ARM64_REG_X20,
	ARM64_REG_X21,
	ARM64_REG_X22,
	ARM64_REG_X23,
	ARM64_REG_X24,
	ARM64_REG_X25,
	ARM64_REG_X26,
	ARM64_REG_X27,
	ARM64_REG_X28,

	ARM64_REG_V0,
	ARM64_REG_V1,
	ARM64_REG_V2,
	ARM64_REG_V3,
	ARM64_REG_V4,
	ARM64_REG_V5,
	ARM64_REG_V6,
	ARM64_REG_V7,
	ARM64_REG_V8,
	ARM64_REG_V9,
	ARM64_REG_V10,
	ARM64_REG_V11,
	ARM64_REG_V12,
	ARM64_REG_V13,
	ARM64_REG_V14,
	ARM64_REG_V15,
	ARM64_REG_V16,
	ARM64_REG_V17,
	ARM64_REG_V18,
	ARM64_REG_V19,
	ARM64_REG_V20,
	ARM64_REG_V21,
	ARM64_REG_V22,
	ARM64_REG_V23,
	ARM64_REG_V24,
	ARM64_REG_V25,
	ARM64_REG_V26,
	ARM64_REG_V27,
	ARM64_REG_V28,
	ARM64_REG_V29,
	ARM64_REG_V30,
	ARM64_REG_V31,

	ARM64_REG_ENDING,		// <-- mark the end of the list of registers

	//> alias registers

	ARM64_REG_IP1 = ARM64_REG_X16,
	ARM64_REG_IP0 = ARM64_REG_X17,
	ARM64_REG_FP = ARM64_REG_X29,
	ARM64_REG_LR = ARM64_REG_X30,
} arm64_reg;

//> ARM64 instruction
typedef enum arm64_insn {
	ARM64_INS_INVALID = 0,

	ARM64_INS_ABS,
	ARM64_INS_ADC,
	ARM64_INS_ADDHN,
	ARM64_INS_ADDHN2,
	ARM64_INS_ADDP,
	ARM64_INS_ADD,
	ARM64_INS_ADDV,
	ARM64_INS_ADR,
	ARM64_INS_ADRP,
	ARM64_INS_AESD,
	ARM64_INS_AESE,
	ARM64_INS_AESIMC,
	ARM64_INS_AESMC,
	ARM64_INS_AND,
	ARM64_INS_ASR,
	ARM64_INS_B,
	ARM64_INS_BFM,
	ARM64_INS_BIC,
	ARM64_INS_BIF,
	ARM64_INS_BIT,
	ARM64_INS_BL,
	ARM64_INS_BLR,
	ARM64_INS_BR,
	ARM64_INS_BRK,
	ARM64_INS_BSL,
	ARM64_INS_CBNZ,
	ARM64_INS_CBZ,
	ARM64_INS_CCMN,
	ARM64_INS_CCMP,
	ARM64_INS_CLREX,
	ARM64_INS_CLS,
	ARM64_INS_CLZ,
	ARM64_INS_CMEQ,
	ARM64_INS_CMGE,
	ARM64_INS_CMGT,
	ARM64_INS_CMHI,
	ARM64_INS_CMHS,
	ARM64_INS_CMLE,
	ARM64_INS_CMLT,
	ARM64_INS_CMTST,
	ARM64_INS_CNT,
	ARM64_INS_MOV,
	ARM64_INS_CRC32B,
	ARM64_INS_CRC32CB,
	ARM64_INS_CRC32CH,
	ARM64_INS_CRC32CW,
	ARM64_INS_CRC32CX,
	ARM64_INS_CRC32H,
	ARM64_INS_CRC32W,
	ARM64_INS_CRC32X,
	ARM64_INS_CSEL,
	ARM64_INS_CSINC,
	ARM64_INS_CSINV,
	ARM64_INS_CSNEG,
	ARM64_INS_DCPS1,
	ARM64_INS_DCPS2,
	ARM64_INS_DCPS3,
	ARM64_INS_DMB,
	ARM64_INS_DRPS,
	ARM64_INS_DSB,
	ARM64_INS_DUP,
	ARM64_INS_EON,
	ARM64_INS_EOR,
	ARM64_INS_ERET,
	ARM64_INS_EXTR,
	ARM64_INS_EXT,
	ARM64_INS_FABD,
	ARM64_INS_FABS,
	ARM64_INS_FACGE,
	ARM64_INS_FACGT,
	ARM64_INS_FADD,
	ARM64_INS_FADDP,
	ARM64_INS_FCCMP,
	ARM64_INS_FCCMPE,
	ARM64_INS_FCMEQ,
	ARM64_INS_FCMGE,
	ARM64_INS_FCMGT,
	ARM64_INS_FCMLE,
	ARM64_INS_FCMLT,
	ARM64_INS_FCMP,
	ARM64_INS_FCMPE,
	ARM64_INS_FCSEL,
	ARM64_INS_FCVTAS,
	ARM64_INS_FCVTAU,
	ARM64_INS_FCVT,
	ARM64_INS_FCVTL,
	ARM64_INS_FCVTL2,
	ARM64_INS_FCVTMS,
	ARM64_INS_FCVTMU,
	ARM64_INS_FCVTNS,
	ARM64_INS_FCVTNU,
	ARM64_INS_FCVTN,
	ARM64_INS_FCVTN2,
	ARM64_INS_FCVTPS,
	ARM64_INS_FCVTPU,
	ARM64_INS_FCVTXN,
	ARM64_INS_FCVTXN2,
	ARM64_INS_FCVTZS,
	ARM64_INS_FCVTZU,
	ARM64_INS_FDIV,
	ARM64_INS_FMADD,
	ARM64_INS_FMAX,
	ARM64_INS_FMAXNM,
	ARM64_INS_FMAXNMP,
	ARM64_INS_FMAXNMV,
	ARM64_INS_FMAXP,
	ARM64_INS_FMAXV,
	ARM64_INS_FMIN,
	ARM64_INS_FMINNM,
	ARM64_INS_FMINNMP,
	ARM64_INS_FMINNMV,
	ARM64_INS_FMINP,
	ARM64_INS_FMINV,
	ARM64_INS_FMLA,
	ARM64_INS_FMLS,
	ARM64_INS_FMOV,
	ARM64_INS_FMSUB,
	ARM64_INS_FMUL,
	ARM64_INS_FMULX,
	ARM64_INS_FNEG,
	ARM64_INS_FNMADD,
	ARM64_INS_FNMSUB,
	ARM64_INS_FNMUL,
	ARM64_INS_FRECPE,
	ARM64_INS_FRECPS,
	ARM64_INS_FRECPX,
	ARM64_INS_FRINTA,
	ARM64_INS_FRINTI,
	ARM64_INS_FRINTM,
	ARM64_INS_FRINTN,
	ARM64_INS_FRINTP,
	ARM64_INS_FRINTX,
	ARM64_INS_FRINTZ,
	ARM64_INS_FRSQRTE,
	ARM64_INS_FRSQRTS,
	ARM64_INS_FSQRT,
	ARM64_INS_FSUB,
	ARM64_INS_HINT,
	ARM64_INS_HLT,
	ARM64_INS_HVC,
	ARM64_INS_INS,

	ARM64_INS_ISB,
	ARM64_INS_LD1,
	ARM64_INS_LD1R,
	ARM64_INS_LD2R,
	ARM64_INS_LD2,
	ARM64_INS_LD3R,
	ARM64_INS_LD3,
	ARM64_INS_LD4,
	ARM64_INS_LD4R,

	ARM64_INS_LDARB,
	ARM64_INS_LDARH,
	ARM64_INS_LDAR,
	ARM64_INS_LDAXP,
	ARM64_INS_LDAXRB,
	ARM64_INS_LDAXRH,
	ARM64_INS_LDAXR,
	ARM64_INS_LDNP,
	ARM64_INS_LDP,
	ARM64_INS_LDPSW,
	ARM64_INS_LDRB,
	ARM64_INS_LDR,
	ARM64_INS_LDRH,
	ARM64_INS_LDRSB,
	ARM64_INS_LDRSH,
	ARM64_INS_LDRSW,
	ARM64_INS_LDTRB,
	ARM64_INS_LDTRH,
	ARM64_INS_LDTRSB,

	ARM64_INS_LDTRSH,
	ARM64_INS_LDTRSW,
	ARM64_INS_LDTR,
	ARM64_INS_LDURB,
	ARM64_INS_LDUR,
	ARM64_INS_LDURH,
	ARM64_INS_LDURSB,
	ARM64_INS_LDURSH,
	ARM64_INS_LDURSW,
	ARM64_INS_LDXP,
	ARM64_INS_LDXRB,
	ARM64_INS_LDXRH,
	ARM64_INS_LDXR,
	ARM64_INS_LSL,
	ARM64_INS_LSR,
	ARM64_INS_MADD,
	ARM64_INS_MLA,
	ARM64_INS_MLS,
	ARM64_INS_MOVI,
	ARM64_INS_MOVK,
	ARM64_INS_MOVN,
	ARM64_INS_MOVZ,
	ARM64_INS_MRS,
	ARM64_INS_MSR,
	ARM64_INS_MSUB,
	ARM64_INS_MUL,
	ARM64_INS_MVNI,
	ARM64_INS_NEG,
	ARM64_INS_NOT,
	ARM64_INS_ORN,
	ARM64_INS_ORR,
	ARM64_INS_PMULL2,
	ARM64_INS_PMULL,
	ARM64_INS_PMUL,
	ARM64_INS_PRFM,
	ARM64_INS_PRFUM,
	ARM64_INS_RADDHN,
	ARM64_INS_RADDHN2,
	ARM64_INS_RBIT,
	ARM64_INS_RET,
	ARM64_INS_REV16,
	ARM64_INS_REV32,
	ARM64_INS_REV64,
	ARM64_INS_REV,
	ARM64_INS_ROR,
	ARM64_INS_RSHRN2,
	ARM64_INS_RSHRN,
	ARM64_INS_RSUBHN,
	ARM64_INS_RSUBHN2,
	ARM64_INS_SABAL2,
	ARM64_INS_SABAL,

	ARM64_INS_SABA,
	ARM64_INS_SABDL2,
	ARM64_INS_SABDL,
	ARM64_INS_SABD,
	ARM64_INS_SADALP,
	ARM64_INS_SADDLP,
	ARM64_INS_SADDLV,
	ARM64_INS_SADDL2,
	ARM64_INS_SADDL,
	ARM64_INS_SADDW2,
	ARM64_INS_SADDW,
	ARM64_INS_SBC,
	ARM64_INS_SBFM,
	ARM64_INS_SCVTF,
	ARM64_INS_SDIV,
	ARM64_INS_SHA1C,
	ARM64_INS_SHA1H,
	ARM64_INS_SHA1M,
	ARM64_INS_SHA1P,
	ARM64_INS_SHA1SU0,
	ARM64_INS_SHA1SU1,
	ARM64_INS_SHA256H2,
	ARM64_INS_SHA256H,
	ARM64_INS_SHA256SU0,
	ARM64_INS_SHA256SU1,
	ARM64_INS_SHADD,
	ARM64_INS_SHLL2,
	ARM64_INS_SHLL,
	ARM64_INS_SHL,
	ARM64_INS_SHRN2,
	ARM64_INS_SHRN,
	ARM64_INS_SHSUB,
	ARM64_INS_SLI,
	ARM64_INS_SMADDL,
	ARM64_INS_SMAXP,
	ARM64_INS_SMAXV,
	ARM64_INS_SMAX,
	ARM64_INS_SMC,
	ARM64_INS_SMINP,
	ARM64_INS_SMINV,
	ARM64_INS_SMIN,
	ARM64_INS_SMLAL2,
	ARM64_INS_SMLAL,
	ARM64_INS_SMLSL2,
	ARM64_INS_SMLSL,
	ARM64_INS_SMOV,
	ARM64_INS_SMSUBL,
	ARM64_INS_SMULH,
	ARM64_INS_SMULL2,
	ARM64_INS_SMULL,
	ARM64_INS_SQABS,
	ARM64_INS_SQADD,
	ARM64_INS_SQDMLAL,
	ARM64_INS_SQDMLAL2,
	ARM64_INS_SQDMLSL,
	ARM64_INS_SQDMLSL2,
	ARM64_INS_SQDMULH,
	ARM64_INS_SQDMULL,
	ARM64_INS_SQDMULL2,
	ARM64_INS_SQNEG,
	ARM64_INS_SQRDMULH,
	ARM64_INS_SQRSHL,
	ARM64_INS_SQRSHRN,
	ARM64_INS_SQRSHRN2,
	ARM64_INS_SQRSHRUN,
	ARM64_INS_SQRSHRUN2,
	ARM64_INS_SQSHLU,
	ARM64_INS_SQSHL,
	ARM64_INS_SQSHRN,
	ARM64_INS_SQSHRN2,
	ARM64_INS_SQSHRUN,
	ARM64_INS_SQSHRUN2,
	ARM64_INS_SQSUB,
	ARM64_INS_SQXTN2,
	ARM64_INS_SQXTN,
	ARM64_INS_SQXTUN2,
	ARM64_INS_SQXTUN,
	ARM64_INS_SRHADD,
	ARM64_INS_SRI,
	ARM64_INS_SRSHL,
	ARM64_INS_SRSHR,
	ARM64_INS_SRSRA,
	ARM64_INS_SSHLL2,
	ARM64_INS_SSHLL,
	ARM64_INS_SSHL,
	ARM64_INS_SSHR,
	ARM64_INS_SSRA,
	ARM64_INS_SSUBL2,
	ARM64_INS_SSUBL,
	ARM64_INS_SSUBW2,
	ARM64_INS_SSUBW,
	ARM64_INS_ST1,
	ARM64_INS_ST2,
	ARM64_INS_ST3,
	ARM64_INS_ST4,
	ARM64_INS_STLRB,
	ARM64_INS_STLRH,
	ARM64_INS_STLR,
	ARM64_INS_STLXP,
	ARM64_INS_STLXRB,
	ARM64_INS_STLXRH,
	ARM64_INS_STLXR,
	ARM64_INS_STNP,
	ARM64_INS_STP,
	ARM64_INS_STRB,
	ARM64_INS_STR,
	ARM64_INS_STRH,
	ARM64_INS_STTRB,
	ARM64_INS_STTRH,
	ARM64_INS_STTR,
	ARM64_INS_STURB,
	ARM64_INS_STUR,
	ARM64_INS_STURH,
	ARM64_INS_STXP,
	ARM64_INS_STXRB,
	ARM64_INS_STXRH,
	ARM64_INS_STXR,
	ARM64_INS_SUBHN,
	ARM64_INS_SUBHN2,
	ARM64_INS_SUB,
	ARM64_INS_SUQADD,
	ARM64_INS_SVC,
	ARM64_INS_SYSL,
	ARM64_INS_SYS,
	ARM64_INS_TBL,
	ARM64_INS_TBNZ,
	ARM64_INS_TBX,
	ARM64_INS_TBZ,
	ARM64_INS_TRN1,
	ARM64_INS_TRN2,
	ARM64_INS_UABAL2,
	ARM64_INS_UABAL,
	ARM64_INS_UABA,
	ARM64_INS_UABDL2,
	ARM64_INS_UABDL,
	ARM64_INS_UABD,
	ARM64_INS_UADALP,
	ARM64_INS_UADDLP,
	ARM64_INS_UADDLV,
	ARM64_INS_UADDL2,
	ARM64_INS_UADDL,
	ARM64_INS_UADDW2,
	ARM64_INS_UADDW,
	ARM64_INS_UBFM,
	ARM64_INS_UCVTF,
	ARM64_INS_UDIV,
	ARM64_INS_UHADD,
	ARM64_INS_UHSUB,
	ARM64_INS_UMADDL,
	ARM64_INS_UMAXP,
	ARM64_INS_UMAXV,
	ARM64_INS_UMAX,
	ARM64_INS_UMINP,
	ARM64_INS_UMINV,
	ARM64_INS_UMIN,
	ARM64_INS_UMLAL2,
	ARM64_INS_UMLAL,
	ARM64_INS_UMLSL2,
	ARM64_INS_UMLSL,
	ARM64_INS_UMOV,
	ARM64_INS_UMSUBL,
	ARM64_INS_UMULH,
	ARM64_INS_UMULL2,
	ARM64_INS_UMULL,
	ARM64_INS_UQADD,
	ARM64_INS_UQRSHL,
	ARM64_INS_UQRSHRN,
	ARM64_INS_UQRSHRN2,
	ARM64_INS_UQSHL,
	ARM64_INS_UQSHRN,
	ARM64_INS_UQSHRN2,
	ARM64_INS_UQSUB,
	ARM64_INS_UQXTN2,
	ARM64_INS_UQXTN,
	ARM64_INS_URECPE,
	ARM64_INS_URHADD,
	ARM64_INS_URSHL,
	ARM64_INS_URSHR,
	ARM64_INS_URSQRTE,
	ARM64_INS_URSRA,
	ARM64_INS_USHLL2,
	ARM64_INS_USHLL,
	ARM64_INS_USHL,
	ARM64_INS_USHR,
	ARM64_INS_USQADD,
	ARM64_INS_USRA,
	ARM64_INS_USUBL2,
	ARM64_INS_USUBL,
	ARM64_INS_USUBW2,
	ARM64_INS_USUBW,
	ARM64_INS_UZP1,
	ARM64_INS_UZP2,
	ARM64_INS_XTN2,
	ARM64_INS_XTN,
	ARM64_INS_ZIP1,
	ARM64_INS_ZIP2,

	// alias insn
	ARM64_INS_MNEG,
	ARM64_INS_UMNEGL,
	ARM64_INS_SMNEGL,
	ARM64_INS_NOP,
	ARM64_INS_YIELD,
	ARM64_INS_WFE,
	ARM64_INS_WFI,
	ARM64_INS_SEV,
	ARM64_INS_SEVL,
	ARM64_INS_NGC,
	ARM64_INS_SBFIZ,
	ARM64_INS_UBFIZ,
	ARM64_INS_SBFX,
	ARM64_INS_UBFX,
	ARM64_INS_BFI,
	ARM64_INS_BFXIL,
	ARM64_INS_CMN,
	ARM64_INS_MVN,
	ARM64_INS_TST,
	ARM64_INS_CSET,
	ARM64_INS_CINC,
	ARM64_INS_CSETM,
	ARM64_INS_CINV,
	ARM64_INS_CNEG,
	ARM64_INS_SXTB,
	ARM64_INS_SXTH,
	ARM64_INS_SXTW,
	ARM64_INS_CMP,
	ARM64_INS_UXTB,
	ARM64_INS_UXTH,
	ARM64_INS_UXTW,
	ARM64_INS_IC,
	ARM64_INS_DC,
	ARM64_INS_AT,
	ARM64_INS_TLBI,

	ARM64_INS_ENDING,  // <-- mark the end of the list of insn
} arm64_insn;

//> Group of ARM64 instructions
typedef enum arm64_insn_group {
	ARM64_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	ARM64_GRP_JUMP,	// = CS_GRP_JUMP

	//> Architecture-specific groups
	ARM64_GRP_CRYPTO = 128,
	ARM64_GRP_FPARMV8,
	ARM64_GRP_NEON,
	ARM64_GRP_CRC,

	ARM64_GRP_ENDING,  // <-- mark the end of the list of groups
} arm64_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`Capstone/include/capstone.h`:

```h
#ifndef CAPSTONE_ENGINE_H
#define CAPSTONE_ENGINE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdarg.h>
#if defined(CAPSTONE_HAS_OSXKERNEL)
#include <libkern/libkern.h>
#else
#include <stdlib.h>
#include <stdio.h>
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#pragma warning(disable:4100)
#ifdef CAPSTONE_SHARED
#define CAPSTONE_EXPORT __declspec(dllexport)
#else    // defined(CAPSTONE_STATIC)
#define CAPSTONE_EXPORT
#endif
#else
#ifdef __GNUC__
#define CAPSTONE_EXPORT __attribute__((visibility("default")))
#else
#define CAPSTONE_EXPORT
#endif
#endif

#ifdef __GNUC__
#define CAPSTONE_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define CAPSTONE_DEPRECATED __declspec(deprecated)
#else
#pragma message("WARNING: You need to implement CAPSTONE_DEPRECATED for this compiler")
#define CAPSTONE_DEPRECATED
#endif

// Capstone API version
#define CS_API_MAJOR 3
#define CS_API_MINOR 0

// Macro to create combined version which can be compared to
// result of cs_version() API.
#define CS_MAKE_VERSION(major, minor) ((major << 8) + minor)

// Handle using with all API
typedef size_t csh;

// Architecture type
typedef enum cs_arch {
	CS_ARCH_ARM = 0,	// ARM architecture (including Thumb, Thumb-2)
	CS_ARCH_ARM64,		// ARM-64, also called AArch64
	CS_ARCH_MIPS,		// Mips architecture
	CS_ARCH_X86,		// X86 architecture (including x86 & x86-64)
	CS_ARCH_PPC,		// PowerPC architecture
	CS_ARCH_SPARC,		// Sparc architecture
	CS_ARCH_SYSZ,		// SystemZ architecture
	CS_ARCH_XCORE,		// XCore architecture
	CS_ARCH_MAX,
	CS_ARCH_ALL = 0xFFFF, // All architectures - for cs_support()
} cs_arch;

// Support value to verify diet mode of the engine.
// If cs_support(CS_SUPPORT_DIET) return True, the engine was compiled
// in diet mode.
#define CS_SUPPORT_DIET (CS_ARCH_ALL + 1)

// Support value to verify X86 reduce mode of the engine.
// If cs_support(CS_SUPPORT_X86_REDUCE) return True, the engine was compiled
// in X86 reduce mode.
#define CS_SUPPORT_X86_REDUCE (CS_ARCH_ALL + 2)

// Mode type
typedef enum cs_mode {
	CS_MODE_LITTLE_ENDIAN = 0,	// little-endian mode (default mode)
	CS_MODE_ARM = 0,	// 32-bit ARM
	CS_MODE_16 = 1 << 1,	// 16-bit mode (X86)
	CS_MODE_32 = 1 << 2,	// 32-bit mode (X86)
	CS_MODE_64 = 1 << 3,	// 64-bit mode (X86, PPC)
	CS_MODE_THUMB = 1 << 4,	// ARM's Thumb mode, including Thumb-2
	CS_MODE_MCLASS = 1 << 5,	// ARM's Cortex-M series
	CS_MODE_V8 = 1 << 6,	// ARMv8 A32 encodings for ARM
	CS_MODE_MICRO = 1 << 4, // MicroMips mode (MIPS)
	CS_MODE_MIPS3 = 1 << 5, // Mips III ISA
	CS_MODE_MIPS32R6 = 1 << 6, // Mips32r6 ISA
	CS_MODE_MIPSGP64 = 1 << 7, // General Purpose Registers are 64-bit wide (MIPS)
	CS_MODE_V9 = 1 << 4, // SparcV9 mode (Sparc)
	CS_MODE_BIG_ENDIAN = 1 << 31,	// big-endian mode
	CS_MODE_MIPS32 = CS_MODE_32,	// Mips32 ISA (Mips)
	CS_MODE_MIPS64 = CS_MODE_64,	// Mips64 ISA (Mips)
} cs_mode;

typedef void* (*cs_malloc_t)(size_t size);
typedef void* (*cs_calloc_t)(size_t nmemb, size_t size);
typedef void* (*cs_realloc_t)(void *ptr, size_t size);
typedef void (*cs_free_t)(void *ptr);
typedef int (*cs_vsnprintf_t)(char *str, size_t size, const char *format, va_list ap);


// User-defined dynamic memory related functions: malloc/calloc/realloc/free/vsnprintf()
// By default, Capstone uses system's malloc(), calloc(), realloc(), free() & vsnprintf().
typedef struct cs_opt_mem {
	cs_malloc_t malloc;
	cs_calloc_t calloc;
	cs_realloc_t realloc;
	cs_free_t free;
	cs_vsnprintf_t vsnprintf;
} cs_opt_mem;

// Runtime option for the disassembled engine
typedef enum cs_opt_type {
	CS_OPT_SYNTAX = 1,	// Assembly output syntax
	CS_OPT_DETAIL,	// Break down instruction structure into details
	CS_OPT_MODE,	// Change engine's mode at run-time
	CS_OPT_MEM,	// User-defined dynamic memory related functions
	CS_OPT_SKIPDATA, // Skip data when disassembling. Then engine is in SKIPDATA mode.
	CS_OPT_SKIPDATA_SETUP, // Setup user-defined function for SKIPDATA option
} cs_opt_type;

// Runtime option value (associated with option type above)
typedef enum cs_opt_value {
	CS_OPT_OFF = 0,  // Turn OFF an option - default option of CS_OPT_DETAIL, CS_OPT_SKIPDATA.
	CS_OPT_ON = 3, // Turn ON an option (CS_OPT_DETAIL, CS_OPT_SKIPDATA).
	CS_OPT_SYNTAX_DEFAULT = 0, // Default asm syntax (CS_OPT_SYNTAX).
	CS_OPT_SYNTAX_INTEL, // X86 Intel asm syntax - default on X86 (CS_OPT_SYNTAX).
	CS_OPT_SYNTAX_ATT,   // X86 ATT asm syntax (CS_OPT_SYNTAX).
	CS_OPT_SYNTAX_NOREGNAME, // Prints register name with only number (CS_OPT_SYNTAX)
} cs_opt_value;

//> Common instruction operand types - to be consistent across all architectures.
typedef enum cs_op_type {
	CS_OP_INVALID = 0,  // uninitialized/invalid operand.
	CS_OP_REG,          // Register operand.
	CS_OP_IMM,          // Immediate operand.
	CS_OP_MEM,          // Memory operand.
	CS_OP_FP,           // Floating-Point operand.
} cs_op_type;

//> Common instruction groups - to be consistent across all architectures.
typedef enum cs_group_type {
	CS_GRP_INVALID = 0,  // uninitialized/invalid group.
	CS_GRP_JUMP,    // all jump instructions (conditional+direct+indirect jumps)
	CS_GRP_CALL,    // all call instructions
	CS_GRP_RET,     // all return instructions
	CS_GRP_INT,     // all interrupt instructions (int+syscall)
	CS_GRP_IRET,    // all interrupt return instructions
} cs_group_type;

/*
 User-defined callback function for SKIPDATA option.
 See tests/test_skipdata.c for sample code demonstrating this API.

 @code: the input buffer containing code to be disassembled.
        This is the same buffer passed to cs_disasm().
 @code_size: size (in bytes) of the above @code buffer.
 @offset: the position of the currently-examining byte in the input
      buffer @code mentioned above.
 @user_data: user-data passed to cs_option() via @user_data field in
      cs_opt_skipdata struct below.

 @return: return number of bytes to skip, or 0 to immediately stop disassembling.
*/
typedef size_t (*cs_skipdata_cb_t)(const uint8_t *code, size_t code_size, size_t offset, void *user_data);

// User-customized setup for SKIPDATA option
typedef struct cs_opt_skipdata {
	// Capstone considers data to skip as special "instructions".
	// User can specify the string for this instruction's "mnemonic" here.
	// By default (if @mnemonic is NULL), Capstone use ".byte".
	const char *mnemonic;

	// User-defined callback function to be called when Capstone hits data.
	// If the returned value from this callback is positive (>0), Capstone
	// will skip exactly that number of bytes & continue. Otherwise, if
	// the callback returns 0, Capstone stops disassembling and returns
	// immediately from cs_disasm()
	// NOTE: if this callback pointer is NULL, Capstone would skip a number
	// of bytes depending on architectures, as following:
	// Arm:     2 bytes (Thumb mode) or 4 bytes.
	// Arm64:   4 bytes.
	// Mips:    4 bytes.
	// PowerPC: 4 bytes.
	// Sparc:   4 bytes.
	// SystemZ: 2 bytes.
	// X86:     1 bytes.
	// XCore:   2 bytes.
	cs_skipdata_cb_t callback; 	// default value is NULL

	// User-defined data to be passed to @callback function pointer.
	void *user_data;
} cs_opt_skipdata;


#include "arm.h"
#include "arm64.h"
#include "mips.h"
#include "ppc.h"
#include "sparc.h"
#include "systemz.h"
#include "x86.h"
#include "xcore.h"

// NOTE: All information in cs_detail is only available when CS_OPT_DETAIL = CS_OPT_ON
typedef struct cs_detail {
	uint8_t regs_read[12]; // list of implicit registers read by this insn
	uint8_t regs_read_count; // number of implicit registers read by this insn

	uint8_t regs_write[20]; // list of implicit registers modified by this insn
	uint8_t regs_write_count; // number of implicit registers modified by this insn

	uint8_t groups[8]; // list of group this instruction belong to
	uint8_t groups_count; // number of groups this insn belongs to

	// Architecture-specific instruction info
	union {
		cs_x86 x86;	// X86 architecture, including 16-bit, 32-bit & 64-bit mode
		cs_arm64 arm64;	// ARM64 architecture (aka AArch64)
		cs_arm arm;		// ARM architecture (including Thumb/Thumb2)
		cs_mips mips;	// MIPS architecture
		cs_ppc ppc;	// PowerPC architecture
		cs_sparc sparc;	// Sparc architecture
		cs_sysz sysz;	// SystemZ architecture
		cs_xcore xcore;	// XCore architecture
	};
} cs_detail;

// Detail information of disassembled instruction
typedef struct cs_insn {
	// Instruction ID (basically a numeric ID for the instruction mnemonic)
	// Find the instruction id in the '[ARCH]_insn' enum in the header file 
	// of corresponding architecture, such as 'arm_insn' in arm.h for ARM,
	// 'x86_insn' in x86.h for X86, etc...
	// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	// NOTE: in Skipdata mode, "data" instruction has 0 for this id field.
	unsigned int id;

	// Address (EIP) of this instruction
	// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	uint64_t address;

	// Size of this instruction
	// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	uint16_t size;
	// Machine bytes of this instruction, with number of bytes indicated by @size above
	// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	uint8_t bytes[16];

	// Ascii text of instruction mnemonic
	// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	char mnemonic[32];

	// Ascii text of instruction operands
	// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	char op_str[160];

	// Pointer to cs_detail.
	// NOTE: detail pointer is only valid when both requirements below are met:
	// (1) CS_OP_DETAIL = CS_OPT_ON
	// (2) Engine is not in Skipdata mode (CS_OP_SKIPDATA option set to CS_OPT_ON)
	//
	// NOTE 2: when in Skipdata mode, or when detail mode is OFF, even if this pointer
	//     is not NULL, its content is still irrelevant.
	cs_detail *detail;
} cs_insn;


// Calculate the offset of a disassembled instruction in its buffer, given its position
// in its array of disassembled insn
// NOTE: this macro works with position (>=1), not index
#define CS_INSN_OFFSET(insns, post) (insns[post - 1].address - insns[0].address)


// All type of errors encountered by Capstone API.
// These are values returned by cs_errno()
typedef enum cs_err {
	CS_ERR_OK = 0,   // No error: everything was fine
	CS_ERR_MEM,      // Out-Of-Memory error: cs_open(), cs_disasm(), cs_disasm_iter()
	CS_ERR_ARCH,     // Unsupported architecture: cs_open()
	CS_ERR_HANDLE,   // Invalid handle: cs_op_count(), cs_op_index()
	CS_ERR_CSH,	     // Invalid csh argument: cs_close(), cs_errno(), cs_option()
	CS_ERR_MODE,     // Invalid/unsupported mode: cs_open()
	CS_ERR_OPTION,   // Invalid/unsupported option: cs_option()
	CS_ERR_DETAIL,   // Information is unavailable because detail option is OFF
	CS_ERR_MEMSETUP, // Dynamic memory management uninitialized (see CS_OPT_MEM)
	CS_ERR_VERSION,  // Unsupported version (bindings)
	CS_ERR_DIET,     // Access irrelevant data in "diet" engine
	CS_ERR_SKIPDATA, // Access irrelevant data for "data" instruction in SKIPDATA mode
	CS_ERR_X86_ATT,  // X86 AT&T syntax is unsupported (opt-out at compile time)
	CS_ERR_X86_INTEL, // X86 Intel syntax is unsupported (opt-out at compile time)
} cs_err;

/*
 Return combined API version & major and minor version numbers.

 @major: major number of API version
 @minor: minor number of API version

 @return hexical number as (major << 8 | minor), which encodes both
	 major & minor versions.
	 NOTE: This returned value can be compared with version number made
	 with macro CS_MAKE_VERSION

 For example, second API version would return 1 in @major, and 1 in @minor
 The return value would be 0x0101

 NOTE: if you only care about returned value, but not major and minor values,
 set both @major & @minor arguments to NULL.
*/
CAPSTONE_EXPORT
unsigned int cs_version(int *major, int *minor);


/*
 This API can be used to either ask for archs supported by this library,
 or check to see if the library was compile with 'diet' option (or called
 in 'diet' mode).

 To check if a particular arch is supported by this library, set @query to
 arch mode (CS_ARCH_* value).
 To verify if this library supports all the archs, use CS_ARCH_ALL.

 To check if this library is in 'diet' mode, set @query to CS_SUPPORT_DIET.

 @return True if this library supports the given arch, or in 'diet' mode.
*/
CAPSTONE_EXPORT
bool cs_support(int query);

/*
 Initialize CS handle: this must be done before any usage of CS.

 @arch: architecture type (CS_ARCH_*)
 @mode: hardware mode. This is combined of CS_MODE_*
 @handle: pointer to handle, which will be updated at return time

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err cs_open(cs_arch arch, cs_mode mode, csh *handle);

/*
 Close CS handle: MUST do to release the handle when it is not used anymore.
 NOTE: this must be only called when there is no longer usage of Capstone,
 not even access to cs_insn array. The reason is the this API releases some
 cached memory, thus access to any Capstone API after cs_close() might crash
 your application.

 In fact,this API invalidate @handle by ZERO out its value (i.e *handle = 0).

 @handle: pointer to a handle returned by cs_open()

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err cs_close(csh *handle);

/*
 Set option for disassembling engine at runtime

 @handle: handle returned by cs_open()
 @type: type of option to be set
 @value: option value corresponding with @type

 @return: CS_ERR_OK on success, or other value on failure.
 Refer to cs_err enum for detailed error.

 NOTE: in the case of CS_OPT_MEM, handle's value can be anything,
 so that cs_option(handle, CS_OPT_MEM, value) can (i.e must) be called
 even before cs_open()
*/
CAPSTONE_EXPORT
cs_err cs_option(csh handle, cs_opt_type type, size_t value);

/*
 Report the last error number when some API function fail.
 Like glibc's errno, cs_errno might not retain its old value once accessed.

 @handle: handle returned by cs_open()

 @return: error code of cs_err enum type (CS_ERR_*, see above)
*/
CAPSTONE_EXPORT
cs_err cs_errno(csh handle);


/*
 Return a string describing given error code.

 @code: error code (see CS_ERR_* above)

 @return: returns a pointer to a string that describes the error code
	passed in the argument @code
*/
CAPSTONE_EXPORT
const char *cs_strerror(cs_err code);

/*
 Disassemble binary code, given the code buffer, size, address and number
 of instructions to be decoded.
 This API dynamically allocate memory to contain disassembled instruction.
 Resulted instructions will be put into @*insn

 NOTE 1: this API will automatically determine memory needed to contain
 output disassembled instructions in @insn.

 NOTE 2: caller must free the allocated memory itself to avoid memory leaking.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, the API cs_disasm_iter() might be a better choice than
 cs_disasm(). The reason is that with cs_disasm(), based on limited available
 memory, we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case @count=0,
 when cs_disasm() runs uncontrollably (until either end of input buffer, or
 when it encounters an invalid instruction).
 
 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled.
 @code_size: size of the above code buffer.
 @address: address of the first instruction in given raw code buffer.
 @insn: array of instructions filled in by this API.
	   NOTE: @insn will be allocated by this function, and should be freed
	   with cs_free() API.
 @count: number of instructions to be disassembled, or 0 to get all of them

 @return: the number of successfully disassembled instructions,
 or 0 if this function failed to disassemble the given code

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
size_t cs_disasm(csh handle,
		const uint8_t *code, size_t code_size,
		uint64_t address,
		size_t count,
		cs_insn **insn);

/*
  Deprecated function - to be retired in the next version!
  Use cs_disasm() instead of cs_disasm_ex()
*/
CAPSTONE_EXPORT
CAPSTONE_DEPRECATED
size_t cs_disasm_ex(csh handle,
		const uint8_t *code, size_t code_size,
		uint64_t address,
		size_t count,
		cs_insn **insn);

/*
 Free memory allocated by cs_malloc() or cs_disasm() (argument @insn)

 @insn: pointer returned by @insn argument in cs_disasm() or cs_malloc()
 @count: number of cs_insn structures returned by cs_disasm(), or 1
     to free memory allocated by cs_malloc().
*/
CAPSTONE_EXPORT
void cs_free(cs_insn *insn, size_t count);


/*
 Allocate memory for 1 instruction to be used by cs_disasm_iter().

 @handle: handle returned by cs_open()

 NOTE: when no longer in use, you can reclaim the memory allocated for
 this instruction with cs_free(insn, 1)
*/
CAPSTONE_EXPORT
cs_insn *cs_malloc(csh handle);

/*
 Fast API to disassemble binary code, given the code buffer, size, address
 and number of instructions to be decoded.
 This API put the resulted instruction into a given cache in @insn.
 See tests/test_iter.c for sample code demonstrating this API.

 NOTE 1: this API will update @code, @size & @address to point to the next
 instruction in the input buffer. Therefore, it is convenient to use
 cs_disasm_iter() inside a loop to quickly iterate all the instructions.
 While decoding one instruction at a time can also be achieved with
 cs_disasm(count=1), some benchmarks shown that cs_disasm_iter() can be 30%
 faster on random input.

 NOTE 2: the cache in @insn can be created with cs_malloc() API.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, this API is recommended over cs_disasm(), which
 allocates memory based on the number of instructions to be disassembled.
 The reason is that with cs_disasm(), based on limited available memory,
 we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case
 @count=0, when cs_disasm() runs uncontrollably (until either end of input
 buffer, or when it encounters an invalid instruction).
 
 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled
 @code_size: size of above code
 @address: address of the first insn in given raw code buffer
 @insn: pointer to instruction to be filled in by this API.

 @return: true if this API successfully decode 1 instruction,
 or false otherwise.

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
bool cs_disasm_iter(csh handle,
	const uint8_t **code, size_t *size,
	uint64_t *address, cs_insn *insn);

/*
 Return friendly name of register in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM,
 x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because engine does not
 store register name.

 @handle: handle returned by cs_open()
 @reg_id: register id

 @return: string name of the register, or NULL if @reg_id is invalid.
*/
CAPSTONE_EXPORT
const char *cs_reg_name(csh handle, unsigned int reg_id);

/*
 Return friendly name of an instruction in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store instruction name.

 @handle: handle returned by cs_open()
 @insn_id: instruction id

 @return: string name of the instruction, or NULL if @insn_id is invalid.
*/
CAPSTONE_EXPORT
const char *cs_insn_name(csh handle, unsigned int insn_id);

/*
 Return friendly name of a group id (that an instruction can belong to)
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store group name.

 @handle: handle returned by cs_open()
 @group_id: group id

 @return: string name of the group, or NULL if @group_id is invalid.
*/
CAPSTONE_EXPORT
const char *cs_group_name(csh handle, unsigned int group_id);

/*
 Check if a disassembled instruction belong to a particular group.
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @group_id matches any member of insn->groups array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default).

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @groups array.

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @group_id: group that you want to check if this instruction belong to.

 @return: true if this instruction indeed belongs to aboved group, or false otherwise.
*/
CAPSTONE_EXPORT
bool cs_insn_group(csh handle, const cs_insn *insn, unsigned int group_id);

/*
 Check if a disassembled instruction IMPLICITLY used a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_read array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_read array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction used it.

 @return: true if this instruction indeed implicitly used aboved register, or false otherwise.
*/
CAPSTONE_EXPORT
bool cs_reg_read(csh handle, const cs_insn *insn, unsigned int reg_id);

/*
 Check if a disassembled instruction IMPLICITLY modified a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_write array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_write array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction modified it.

 @return: true if this instruction indeed implicitly modified aboved register, or false otherwise.
*/
CAPSTONE_EXPORT
bool cs_reg_write(csh handle, const cs_insn *insn, unsigned int reg_id);

/*
 Count the number of operands of a given type.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.

 @return: number of operands of given type @op_type in instruction @insn,
 or -1 on failure.
*/
CAPSTONE_EXPORT
int cs_op_count(csh handle, const cs_insn *insn, unsigned int op_type);

/*
 Retrieve the position of operand of given type in <arch>.operands[] array.
 Later, the operand can be accessed using the returned position.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.
 @position: position of the operand to be found. This must be in the range
			[1, cs_op_count(handle, insn, op_type)]

 @return: index of operand of given type @op_type in <arch>.operands[] array
 in instruction @insn, or -1 on failure.
*/
CAPSTONE_EXPORT
int cs_op_index(csh handle, const cs_insn *insn, unsigned int op_type,
		unsigned int position);

#ifdef __cplusplus
}
#endif

#endif

```

`Capstone/include/mips.h`:

```h
#ifndef CAPSTONE_MIPS_H
#define CAPSTONE_MIPS_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

// GCC MIPS toolchain has a default macro called "mips" which breaks
// compilation
#undef mips

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Operand type for instruction's operands
typedef enum mips_op_type {
	MIPS_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	MIPS_OP_REG, // = CS_OP_REG (Register operand).
	MIPS_OP_IMM, // = CS_OP_IMM (Immediate operand).
	MIPS_OP_MEM, // = CS_OP_MEM (Memory operand).
} mips_op_type;

// Instruction's operand referring to memory
// This is associated with MIPS_OP_MEM operand type above
typedef struct mips_op_mem {
	unsigned int base;	// base register
	int64_t disp;	// displacement/offset value
} mips_op_mem;

// Instruction operand
typedef struct cs_mips_op {
	mips_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG operand
		int64_t imm;		// immediate value for IMM operand
		mips_op_mem mem;	// base/index/scale/disp value for MEM operand
	};
} cs_mips_op;

// Instruction structure
typedef struct cs_mips {
	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_mips_op operands[8]; // operands for this instruction.
} cs_mips;

//> MIPS registers
typedef enum mips_reg {
	MIPS_REG_INVALID = 0,
	//> General purpose registers
	MIPS_REG_0,
	MIPS_REG_1,
	MIPS_REG_2,
	MIPS_REG_3,
	MIPS_REG_4,
	MIPS_REG_5,
	MIPS_REG_6,
	MIPS_REG_7,
	MIPS_REG_8,
	MIPS_REG_9,
	MIPS_REG_10,
	MIPS_REG_11,
	MIPS_REG_12,
	MIPS_REG_13,
	MIPS_REG_14,
	MIPS_REG_15,
	MIPS_REG_16,
	MIPS_REG_17,
	MIPS_REG_18,
	MIPS_REG_19,
	MIPS_REG_20,
	MIPS_REG_21,
	MIPS_REG_22,
	MIPS_REG_23,
	MIPS_REG_24,
	MIPS_REG_25,
	MIPS_REG_26,
	MIPS_REG_27,
	MIPS_REG_28,
	MIPS_REG_29,
	MIPS_REG_30,
	MIPS_REG_31,

	//> DSP registers
	MIPS_REG_DSPCCOND,
	MIPS_REG_DSPCARRY,
	MIPS_REG_DSPEFI,
	MIPS_REG_DSPOUTFLAG,
	MIPS_REG_DSPOUTFLAG16_19,
	MIPS_REG_DSPOUTFLAG20,
	MIPS_REG_DSPOUTFLAG21,
	MIPS_REG_DSPOUTFLAG22,
	MIPS_REG_DSPOUTFLAG23,
	MIPS_REG_DSPPOS,
	MIPS_REG_DSPSCOUNT,

	//> ACC registers
	MIPS_REG_AC0,
	MIPS_REG_AC1,
	MIPS_REG_AC2,
	MIPS_REG_AC3,

	//> COP registers
	MIPS_REG_CC0,
	MIPS_REG_CC1,
	MIPS_REG_CC2,
	MIPS_REG_CC3,
	MIPS_REG_CC4,
	MIPS_REG_CC5,
	MIPS_REG_CC6,
	MIPS_REG_CC7,

	//> FPU registers
	MIPS_REG_F0,
	MIPS_REG_F1,
	MIPS_REG_F2,
	MIPS_REG_F3,
	MIPS_REG_F4,
	MIPS_REG_F5,
	MIPS_REG_F6,
	MIPS_REG_F7,
	MIPS_REG_F8,
	MIPS_REG_F9,
	MIPS_REG_F10,
	MIPS_REG_F11,
	MIPS_REG_F12,
	MIPS_REG_F13,
	MIPS_REG_F14,
	MIPS_REG_F15,
	MIPS_REG_F16,
	MIPS_REG_F17,
	MIPS_REG_F18,
	MIPS_REG_F19,
	MIPS_REG_F20,
	MIPS_REG_F21,
	MIPS_REG_F22,
	MIPS_REG_F23,
	MIPS_REG_F24,
	MIPS_REG_F25,
	MIPS_REG_F26,
	MIPS_REG_F27,
	MIPS_REG_F28,
	MIPS_REG_F29,
	MIPS_REG_F30,
	MIPS_REG_F31,

	MIPS_REG_FCC0,
	MIPS_REG_FCC1,
	MIPS_REG_FCC2,
	MIPS_REG_FCC3,
	MIPS_REG_FCC4,
	MIPS_REG_FCC5,
	MIPS_REG_FCC6,
	MIPS_REG_FCC7,

	//> AFPR128
	MIPS_REG_W0,
	MIPS_REG_W1,
	MIPS_REG_W2,
	MIPS_REG_W3,
	MIPS_REG_W4,
	MIPS_REG_W5,
	MIPS_REG_W6,
	MIPS_REG_W7,
	MIPS_REG_W8,
	MIPS_REG_W9,
	MIPS_REG_W10,
	MIPS_REG_W11,
	MIPS_REG_W12,
	MIPS_REG_W13,
	MIPS_REG_W14,
	MIPS_REG_W15,
	MIPS_REG_W16,
	MIPS_REG_W17,
	MIPS_REG_W18,
	MIPS_REG_W19,
	MIPS_REG_W20,
	MIPS_REG_W21,
	MIPS_REG_W22,
	MIPS_REG_W23,
	MIPS_REG_W24,
	MIPS_REG_W25,
	MIPS_REG_W26,
	MIPS_REG_W27,
	MIPS_REG_W28,
	MIPS_REG_W29,
	MIPS_REG_W30,
	MIPS_REG_W31,

	MIPS_REG_HI,
	MIPS_REG_LO,

	MIPS_REG_P0,
	MIPS_REG_P1,
	MIPS_REG_P2,

	MIPS_REG_MPL0,
	MIPS_REG_MPL1,
	MIPS_REG_MPL2,

	MIPS_REG_ENDING,	// <-- mark the end of the list or registers

	// alias registers
	MIPS_REG_ZERO = MIPS_REG_0,
	MIPS_REG_AT = MIPS_REG_1,
	MIPS_REG_V0 = MIPS_REG_2,
	MIPS_REG_V1 = MIPS_REG_3,
	MIPS_REG_A0 = MIPS_REG_4,
	MIPS_REG_A1 = MIPS_REG_5,
	MIPS_REG_A2 = MIPS_REG_6,
	MIPS_REG_A3 = MIPS_REG_7,
	MIPS_REG_T0 = MIPS_REG_8,
	MIPS_REG_T1 = MIPS_REG_9,
	MIPS_REG_T2 = MIPS_REG_10,
	MIPS_REG_T3 = MIPS_REG_11,
	MIPS_REG_T4 = MIPS_REG_12,
	MIPS_REG_T5 = MIPS_REG_13,
	MIPS_REG_T6 = MIPS_REG_14,
	MIPS_REG_T7 = MIPS_REG_15,
	MIPS_REG_S0 = MIPS_REG_16,
	MIPS_REG_S1 = MIPS_REG_17,
	MIPS_REG_S2 = MIPS_REG_18,
	MIPS_REG_S3 = MIPS_REG_19,
	MIPS_REG_S4 = MIPS_REG_20,
	MIPS_REG_S5 = MIPS_REG_21,
	MIPS_REG_S6 = MIPS_REG_22,
	MIPS_REG_S7 = MIPS_REG_23,
	MIPS_REG_T8 = MIPS_REG_24,
	MIPS_REG_T9 = MIPS_REG_25,
	MIPS_REG_K0 = MIPS_REG_26,
	MIPS_REG_K1 = MIPS_REG_27,
	MIPS_REG_GP = MIPS_REG_28,
	MIPS_REG_SP = MIPS_REG_29,
	MIPS_REG_FP = MIPS_REG_30, MIPS_REG_S8 = MIPS_REG_30,
	MIPS_REG_RA = MIPS_REG_31,

	MIPS_REG_HI0 = MIPS_REG_AC0,
	MIPS_REG_HI1 = MIPS_REG_AC1,
	MIPS_REG_HI2 = MIPS_REG_AC2,
	MIPS_REG_HI3 = MIPS_REG_AC3,

	MIPS_REG_LO0 = MIPS_REG_HI0,
	MIPS_REG_LO1 = MIPS_REG_HI1,
	MIPS_REG_LO2 = MIPS_REG_HI2,
	MIPS_REG_LO3 = MIPS_REG_HI3,
} mips_reg;

//> MIPS instruction
typedef enum mips_insn {
	MIPS_INS_INVALID = 0,

	MIPS_INS_ABSQ_S,
	MIPS_INS_ADD,
	MIPS_INS_ADDIUPC,
	MIPS_INS_ADDQH,
	MIPS_INS_ADDQH_R,
	MIPS_INS_ADDQ,
	MIPS_INS_ADDQ_S,
	MIPS_INS_ADDSC,
	MIPS_INS_ADDS_A,
	MIPS_INS_ADDS_S,
	MIPS_INS_ADDS_U,
	MIPS_INS_ADDUH,
	MIPS_INS_ADDUH_R,
	MIPS_INS_ADDU,
	MIPS_INS_ADDU_S,
	MIPS_INS_ADDVI,
	MIPS_INS_ADDV,
	MIPS_INS_ADDWC,
	MIPS_INS_ADD_A,
	MIPS_INS_ADDI,
	MIPS_INS_ADDIU,
	MIPS_INS_ALIGN,
	MIPS_INS_ALUIPC,
	MIPS_INS_AND,
	MIPS_INS_ANDI,
	MIPS_INS_APPEND,
	MIPS_INS_ASUB_S,
	MIPS_INS_ASUB_U,
	MIPS_INS_AUI,
	MIPS_INS_AUIPC,
	MIPS_INS_AVER_S,
	MIPS_INS_AVER_U,
	MIPS_INS_AVE_S,
	MIPS_INS_AVE_U,
	MIPS_INS_BADDU,
	MIPS_INS_BAL,
	MIPS_INS_BALC,
	MIPS_INS_BALIGN,
	MIPS_INS_BC,
	MIPS_INS_BC0F,
	MIPS_INS_BC0FL,
	MIPS_INS_BC0T,
	MIPS_INS_BC0TL,
	MIPS_INS_BC1EQZ,
	MIPS_INS_BC1F,
	MIPS_INS_BC1FL,
	MIPS_INS_BC1NEZ,
	MIPS_INS_BC1T,
	MIPS_INS_BC1TL,
	MIPS_INS_BC2EQZ,
	MIPS_INS_BC2F,
	MIPS_INS_BC2FL,
	MIPS_INS_BC2NEZ,
	MIPS_INS_BC2T,
	MIPS_INS_BC2TL,
	MIPS_INS_BC3F,
	MIPS_INS_BC3FL,
	MIPS_INS_BC3T,
	MIPS_INS_BC3TL,
	MIPS_INS_BCLRI,
	MIPS_INS_BCLR,
	MIPS_INS_BEQ,
	MIPS_INS_BEQC,
	MIPS_INS_BEQL,
	MIPS_INS_BEQZALC,
	MIPS_INS_BEQZC,
	MIPS_INS_BGEC,
	MIPS_INS_BGEUC,
	MIPS_INS_BGEZ,
	MIPS_INS_BGEZAL,
	MIPS_INS_BGEZALC,
	MIPS_INS_BGEZALL,
	MIPS_INS_BGEZALS,
	MIPS_INS_BGEZC,
	MIPS_INS_BGEZL,
	MIPS_INS_BGTZ,
	MIPS_INS_BGTZALC,
	MIPS_INS_BGTZC,
	MIPS_INS_BGTZL,
	MIPS_INS_BINSLI,
	MIPS_INS_BINSL,
	MIPS_INS_BINSRI,
	MIPS_INS_BINSR,
	MIPS_INS_BITREV,
	MIPS_INS_BITSWAP,
	MIPS_INS_BLEZ,
	MIPS_INS_BLEZALC,
	MIPS_INS_BLEZC,
	MIPS_INS_BLEZL,
	MIPS_INS_BLTC,
	MIPS_INS_BLTUC,
	MIPS_INS_BLTZ,
	MIPS_INS_BLTZAL,
	MIPS_INS_BLTZALC,
	MIPS_INS_BLTZALL,
	MIPS_INS_BLTZALS,
	MIPS_INS_BLTZC,
	MIPS_INS_BLTZL,
	MIPS_INS_BMNZI,
	MIPS_INS_BMNZ,
	MIPS_INS_BMZI,
	MIPS_INS_BMZ,
	MIPS_INS_BNE,
	MIPS_INS_BNEC,
	MIPS_INS_BNEGI,
	MIPS_INS_BNEG,
	MIPS_INS_BNEL,
	MIPS_INS_BNEZALC,
	MIPS_INS_BNEZC,
	MIPS_INS_BNVC,
	MIPS_INS_BNZ,
	MIPS_INS_BOVC,
	MIPS_INS_BPOSGE32,
	MIPS_INS_BREAK,
	MIPS_INS_BSELI,
	MIPS_INS_BSEL,
	MIPS_INS_BSETI,
	MIPS_INS_BSET,
	MIPS_INS_BZ,
	MIPS_INS_BEQZ,
	MIPS_INS_B,
	MIPS_INS_BNEZ,
	MIPS_INS_BTEQZ,
	MIPS_INS_BTNEZ,
	MIPS_INS_CACHE,
	MIPS_INS_CEIL,
	MIPS_INS_CEQI,
	MIPS_INS_CEQ,
	MIPS_INS_CFC1,
	MIPS_INS_CFCMSA,
	MIPS_INS_CINS,
	MIPS_INS_CINS32,
	MIPS_INS_CLASS,
	MIPS_INS_CLEI_S,
	MIPS_INS_CLEI_U,
	MIPS_INS_CLE_S,
	MIPS_INS_CLE_U,
	MIPS_INS_CLO,
	MIPS_INS_CLTI_S,
	MIPS_INS_CLTI_U,
	MIPS_INS_CLT_S,
	MIPS_INS_CLT_U,
	MIPS_INS_CLZ,
	MIPS_INS_CMPGDU,
	MIPS_INS_CMPGU,
	MIPS_INS_CMPU,
	MIPS_INS_CMP,
	MIPS_INS_COPY_S,
	MIPS_INS_COPY_U,
	MIPS_INS_CTC1,
	MIPS_INS_CTCMSA,
	MIPS_INS_CVT,
	MIPS_INS_C,
	MIPS_INS_CMPI,
	MIPS_INS_DADD,
	MIPS_INS_DADDI,
	MIPS_INS_DADDIU,
	MIPS_INS_DADDU,
	MIPS_INS_DAHI,
	MIPS_INS_DALIGN,
	MIPS_INS_DATI,
	MIPS_INS_DAUI,
	MIPS_INS_DBITSWAP,
	MIPS_INS_DCLO,
	MIPS_INS_DCLZ,
	MIPS_INS_DDIV,
	MIPS_INS_DDIVU,
	MIPS_INS_DERET,
	MIPS_INS_DEXT,
	MIPS_INS_DEXTM,
	MIPS_INS_DEXTU,
	MIPS_INS_DI,
	MIPS_INS_DINS,
	MIPS_INS_DINSM,
	MIPS_INS_DINSU,
	MIPS_INS_DIV,
	MIPS_INS_DIVU,
	MIPS_INS_DIV_S,
	MIPS_INS_DIV_U,
	MIPS_INS_DLSA,
	MIPS_INS_DMFC0,
	MIPS_INS_DMFC1,
	MIPS_INS_DMFC2,
	MIPS_INS_DMOD,
	MIPS_INS_DMODU,
	MIPS_INS_DMTC0,
	MIPS_INS_DMTC1,
	MIPS_INS_DMTC2,
	MIPS_INS_DMUH,
	MIPS_INS_DMUHU,
	MIPS_INS_DMUL,
	MIPS_INS_DMULT,
	MIPS_INS_DMULTU,
	MIPS_INS_DMULU,
	MIPS_INS_DOTP_S,
	MIPS_INS_DOTP_U,
	MIPS_INS_DPADD_S,
	MIPS_INS_DPADD_U,
	MIPS_INS_DPAQX_SA,
	MIPS_INS_DPAQX_S,
	MIPS_INS_DPAQ_SA,
	MIPS_INS_DPAQ_S,
	MIPS_INS_DPAU,
	MIPS_INS_DPAX,
	MIPS_INS_DPA,
	MIPS_INS_DPOP,
	MIPS_INS_DPSQX_SA,
	MIPS_INS_DPSQX_S,
	MIPS_INS_DPSQ_SA,
	MIPS_INS_DPSQ_S,
	MIPS_INS_DPSUB_S,
	MIPS_INS_DPSUB_U,
	MIPS_INS_DPSU,
	MIPS_INS_DPSX,
	MIPS_INS_DPS,
	MIPS_INS_DROTR,
	MIPS_INS_DROTR32,
	MIPS_INS_DROTRV,
	MIPS_INS_DSBH,
	MIPS_INS_DSHD,
	MIPS_INS_DSLL,
	MIPS_INS_DSLL32,
	MIPS_INS_DSLLV,
	MIPS_INS_DSRA,
	MIPS_INS_DSRA32,
	MIPS_INS_DSRAV,
	MIPS_INS_DSRL,
	MIPS_INS_DSRL32,
	MIPS_INS_DSRLV,
	MIPS_INS_DSUB,
	MIPS_INS_DSUBU,
	MIPS_INS_EHB,
	MIPS_INS_EI,
	MIPS_INS_ERET,
	MIPS_INS_EXT,
	MIPS_INS_EXTP,
	MIPS_INS_EXTPDP,
	MIPS_INS_EXTPDPV,
	MIPS_INS_EXTPV,
	MIPS_INS_EXTRV_RS,
	MIPS_INS_EXTRV_R,
	MIPS_INS_EXTRV_S,
	MIPS_INS_EXTRV,
	MIPS_INS_EXTR_RS,
	MIPS_INS_EXTR_R,
	MIPS_INS_EXTR_S,
	MIPS_INS_EXTR,
	MIPS_INS_EXTS,
	MIPS_INS_EXTS32,
	MIPS_INS_ABS,
	MIPS_INS_FADD,
	MIPS_INS_FCAF,
	MIPS_INS_FCEQ,
	MIPS_INS_FCLASS,
	MIPS_INS_FCLE,
	MIPS_INS_FCLT,
	MIPS_INS_FCNE,
	MIPS_INS_FCOR,
	MIPS_INS_FCUEQ,
	MIPS_INS_FCULE,
	MIPS_INS_FCULT,
	MIPS_INS_FCUNE,
	MIPS_INS_FCUN,
	MIPS_INS_FDIV,
	MIPS_INS_FEXDO,
	MIPS_INS_FEXP2,
	MIPS_INS_FEXUPL,
	MIPS_INS_FEXUPR,
	MIPS_INS_FFINT_S,
	MIPS_INS_FFINT_U,
	MIPS_INS_FFQL,
	MIPS_INS_FFQR,
	MIPS_INS_FILL,
	MIPS_INS_FLOG2,
	MIPS_INS_FLOOR,
	MIPS_INS_FMADD,
	MIPS_INS_FMAX_A,
	MIPS_INS_FMAX,
	MIPS_INS_FMIN_A,
	MIPS_INS_FMIN,
	MIPS_INS_MOV,
	MIPS_INS_FMSUB,
	MIPS_INS_FMUL,
	MIPS_INS_MUL,
	MIPS_INS_NEG,
	MIPS_INS_FRCP,
	MIPS_INS_FRINT,
	MIPS_INS_FRSQRT,
	MIPS_INS_FSAF,
	MIPS_INS_FSEQ,
	MIPS_INS_FSLE,
	MIPS_INS_FSLT,
	MIPS_INS_FSNE,
	MIPS_INS_FSOR,
	MIPS_INS_FSQRT,
	MIPS_INS_SQRT,
	MIPS_INS_FSUB,
	MIPS_INS_SUB,
	MIPS_INS_FSUEQ,
	MIPS_INS_FSULE,
	MIPS_INS_FSULT,
	MIPS_INS_FSUNE,
	MIPS_INS_FSUN,
	MIPS_INS_FTINT_S,
	MIPS_INS_FTINT_U,
	MIPS_INS_FTQ,
	MIPS_INS_FTRUNC_S,
	MIPS_INS_FTRUNC_U,
	MIPS_INS_HADD_S,
	MIPS_INS_HADD_U,
	MIPS_INS_HSUB_S,
	MIPS_INS_HSUB_U,
	MIPS_INS_ILVEV,
	MIPS_INS_ILVL,
	MIPS_INS_ILVOD,
	MIPS_INS_ILVR,
	MIPS_INS_INS,
	MIPS_INS_INSERT,
	MIPS_INS_INSV,
	MIPS_INS_INSVE,
	MIPS_INS_J,
	MIPS_INS_JAL,
	MIPS_INS_JALR,
	MIPS_INS_JALRS,
	MIPS_INS_JALS,
	MIPS_INS_JALX,
	MIPS_INS_JIALC,
	MIPS_INS_JIC,
	MIPS_INS_JR,
	MIPS_INS_JRADDIUSP,
	MIPS_INS_JRC,
	MIPS_INS_JALRC,
	MIPS_INS_LB,
	MIPS_INS_LBUX,
	MIPS_INS_LBU,
	MIPS_INS_LD,
	MIPS_INS_LDC1,
	MIPS_INS_LDC2,
	MIPS_INS_LDC3,
	MIPS_INS_LDI,
	MIPS_INS_LDL,
	MIPS_INS_LDPC,
	MIPS_INS_LDR,
	MIPS_INS_LDXC1,
	MIPS_INS_LH,
	MIPS_INS_LHX,
	MIPS_INS_LHU,
	MIPS_INS_LL,
	MIPS_INS_LLD,
	MIPS_INS_LSA,
	MIPS_INS_LUXC1,
	MIPS_INS_LUI,
	MIPS_INS_LW,
	MIPS_INS_LWC1,
	MIPS_INS_LWC2,
	MIPS_INS_LWC3,
	MIPS_INS_LWL,
	MIPS_INS_LWPC,
	MIPS_INS_LWR,
	MIPS_INS_LWUPC,
	MIPS_INS_LWU,
	MIPS_INS_LWX,
	MIPS_INS_LWXC1,
	MIPS_INS_LI,
	MIPS_INS_MADD,
	MIPS_INS_MADDF,
	MIPS_INS_MADDR_Q,
	MIPS_INS_MADDU,
	MIPS_INS_MADDV,
	MIPS_INS_MADD_Q,
	MIPS_INS_MAQ_SA,
	MIPS_INS_MAQ_S,
	MIPS_INS_MAXA,
	MIPS_INS_MAXI_S,
	MIPS_INS_MAXI_U,
	MIPS_INS_MAX_A,
	MIPS_INS_MAX,
	MIPS_INS_MAX_S,
	MIPS_INS_MAX_U,
	MIPS_INS_MFC0,
	MIPS_INS_MFC1,
	MIPS_INS_MFC2,
	MIPS_INS_MFHC1,
	MIPS_INS_MFHI,
	MIPS_INS_MFLO,
	MIPS_INS_MINA,
	MIPS_INS_MINI_S,
	MIPS_INS_MINI_U,
	MIPS_INS_MIN_A,
	MIPS_INS_MIN,
	MIPS_INS_MIN_S,
	MIPS_INS_MIN_U,
	MIPS_INS_MOD,
	MIPS_INS_MODSUB,
	MIPS_INS_MODU,
	MIPS_INS_MOD_S,
	MIPS_INS_MOD_U,
	MIPS_INS_MOVE,
	MIPS_INS_MOVF,
	MIPS_INS_MOVN,
	MIPS_INS_MOVT,
	MIPS_INS_MOVZ,
	MIPS_INS_MSUB,
	MIPS_INS_MSUBF,
	MIPS_INS_MSUBR_Q,
	MIPS_INS_MSUBU,
	MIPS_INS_MSUBV,
	MIPS_INS_MSUB_Q,
	MIPS_INS_MTC0,
	MIPS_INS_MTC1,
	MIPS_INS_MTC2,
	MIPS_INS_MTHC1,
	MIPS_INS_MTHI,
	MIPS_INS_MTHLIP,
	MIPS_INS_MTLO,
	MIPS_INS_MTM0,
	MIPS_INS_MTM1,
	MIPS_INS_MTM2,
	MIPS_INS_MTP0,
	MIPS_INS_MTP1,
	MIPS_INS_MTP2,
	MIPS_INS_MUH,
	MIPS_INS_MUHU,
	MIPS_INS_MULEQ_S,
	MIPS_INS_MULEU_S,
	MIPS_INS_MULQ_RS,
	MIPS_INS_MULQ_S,
	MIPS_INS_MULR_Q,
	MIPS_INS_MULSAQ_S,
	MIPS_INS_MULSA,
	MIPS_INS_MULT,
	MIPS_INS_MULTU,
	MIPS_INS_MULU,
	MIPS_INS_MULV,
	MIPS_INS_MUL_Q,
	MIPS_INS_MUL_S,
	MIPS_INS_NLOC,
	MIPS_INS_NLZC,
	MIPS_INS_NMADD,
	MIPS_INS_NMSUB,
	MIPS_INS_NOR,
	MIPS_INS_NORI,
	MIPS_INS_NOT,
	MIPS_INS_OR,
	MIPS_INS_ORI,
	MIPS_INS_PACKRL,
	MIPS_INS_PAUSE,
	MIPS_INS_PCKEV,
	MIPS_INS_PCKOD,
	MIPS_INS_PCNT,
	MIPS_INS_PICK,
	MIPS_INS_POP,
	MIPS_INS_PRECEQU,
	MIPS_INS_PRECEQ,
	MIPS_INS_PRECEU,
	MIPS_INS_PRECRQU_S,
	MIPS_INS_PRECRQ,
	MIPS_INS_PRECRQ_RS,
	MIPS_INS_PRECR,
	MIPS_INS_PRECR_SRA,
	MIPS_INS_PRECR_SRA_R,
	MIPS_INS_PREF,
	MIPS_INS_PREPEND,
	MIPS_INS_RADDU,
	MIPS_INS_RDDSP,
	MIPS_INS_RDHWR,
	MIPS_INS_REPLV,
	MIPS_INS_REPL,
	MIPS_INS_RINT,
	MIPS_INS_ROTR,
	MIPS_INS_ROTRV,
	MIPS_INS_ROUND,
	MIPS_INS_SAT_S,
	MIPS_INS_SAT_U,
	MIPS_INS_SB,
	MIPS_INS_SC,
	MIPS_INS_SCD,
	MIPS_INS_SD,
	MIPS_INS_SDBBP,
	MIPS_INS_SDC1,
	MIPS_INS_SDC2,
	MIPS_INS_SDC3,
	MIPS_INS_SDL,
	MIPS_INS_SDR,
	MIPS_INS_SDXC1,
	MIPS_INS_SEB,
	MIPS_INS_SEH,
	MIPS_INS_SELEQZ,
	MIPS_INS_SELNEZ,
	MIPS_INS_SEL,
	MIPS_INS_SEQ,
	MIPS_INS_SEQI,
	MIPS_INS_SH,
	MIPS_INS_SHF,
	MIPS_INS_SHILO,
	MIPS_INS_SHILOV,
	MIPS_INS_SHLLV,
	MIPS_INS_SHLLV_S,
	MIPS_INS_SHLL,
	MIPS_INS_SHLL_S,
	MIPS_INS_SHRAV,
	MIPS_INS_SHRAV_R,
	MIPS_INS_SHRA,
	MIPS_INS_SHRA_R,
	MIPS_INS_SHRLV,
	MIPS_INS_SHRL,
	MIPS_INS_SLDI,
	MIPS_INS_SLD,
	MIPS_INS_SLL,
	MIPS_INS_SLLI,
	MIPS_INS_SLLV,
	MIPS_INS_SLT,
	MIPS_INS_SLTI,
	MIPS_INS_SLTIU,
	MIPS_INS_SLTU,
	MIPS_INS_SNE,
	MIPS_INS_SNEI,
	MIPS_INS_SPLATI,
	MIPS_INS_SPLAT,
	MIPS_INS_SRA,
	MIPS_INS_SRAI,
	MIPS_INS_SRARI,
	MIPS_INS_SRAR,
	MIPS_INS_SRAV,
	MIPS_INS_SRL,
	MIPS_INS_SRLI,
	MIPS_INS_SRLRI,
	MIPS_INS_SRLR,
	MIPS_INS_SRLV,
	MIPS_INS_SSNOP,
	MIPS_INS_ST,
	MIPS_INS_SUBQH,
	MIPS_INS_SUBQH_R,
	MIPS_INS_SUBQ,
	MIPS_INS_SUBQ_S,
	MIPS_INS_SUBSUS_U,
	MIPS_INS_SUBSUU_S,
	MIPS_INS_SUBS_S,
	MIPS_INS_SUBS_U,
	MIPS_INS_SUBUH,
	MIPS_INS_SUBUH_R,
	MIPS_INS_SUBU,
	MIPS_INS_SUBU_S,
	MIPS_INS_SUBVI,
	MIPS_INS_SUBV,
	MIPS_INS_SUXC1,
	MIPS_INS_SW,
	MIPS_INS_SWC1,
	MIPS_INS_SWC2,
	MIPS_INS_SWC3,
	MIPS_INS_SWL,
	MIPS_INS_SWR,
	MIPS_INS_SWXC1,
	MIPS_INS_SYNC,
	MIPS_INS_SYSCALL,
	MIPS_INS_TEQ,
	MIPS_INS_TEQI,
	MIPS_INS_TGE,
	MIPS_INS_TGEI,
	MIPS_INS_TGEIU,
	MIPS_INS_TGEU,
	MIPS_INS_TLBP,
	MIPS_INS_TLBR,
	MIPS_INS_TLBWI,
	MIPS_INS_TLBWR,
	MIPS_INS_TLT,
	MIPS_INS_TLTI,
	MIPS_INS_TLTIU,
	MIPS_INS_TLTU,
	MIPS_INS_TNE,
	MIPS_INS_TNEI,
	MIPS_INS_TRUNC,
	MIPS_INS_V3MULU,
	MIPS_INS_VMM0,
	MIPS_INS_VMULU,
	MIPS_INS_VSHF,
	MIPS_INS_WAIT,
	MIPS_INS_WRDSP,
	MIPS_INS_WSBH,
	MIPS_INS_XOR,
	MIPS_INS_XORI,

	//> some alias instructions
	MIPS_INS_NOP,
	MIPS_INS_NEGU,

	//> special instructions
	MIPS_INS_JALR_HB,	// jump and link with Hazard Barrier
	MIPS_INS_JR_HB,		// jump register with Hazard Barrier

	MIPS_INS_ENDING,
} mips_insn;

//> Group of MIPS instructions
typedef enum mips_insn_group {
	MIPS_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	MIPS_GRP_JUMP,	// = CS_GRP_JUMP

	//> Architecture-specific groups
	MIPS_GRP_BITCOUNT = 128,
	MIPS_GRP_DSP,
	MIPS_GRP_DSPR2,
	MIPS_GRP_FPIDX,
	MIPS_GRP_MSA,
	MIPS_GRP_MIPS32R2,
	MIPS_GRP_MIPS64,
	MIPS_GRP_MIPS64R2,
	MIPS_GRP_SEINREG,
	MIPS_GRP_STDENC,
	MIPS_GRP_SWAP,
	MIPS_GRP_MICROMIPS,
	MIPS_GRP_MIPS16MODE,
	MIPS_GRP_FP64BIT,
	MIPS_GRP_NONANSFPMATH,
	MIPS_GRP_NOTFP64BIT,
	MIPS_GRP_NOTINMICROMIPS,
	MIPS_GRP_NOTNACL,
	MIPS_GRP_NOTMIPS32R6,
	MIPS_GRP_NOTMIPS64R6,
	MIPS_GRP_CNMIPS,
	MIPS_GRP_MIPS32,
	MIPS_GRP_MIPS32R6,
	MIPS_GRP_MIPS64R6,
	MIPS_GRP_MIPS2,
	MIPS_GRP_MIPS3,
	MIPS_GRP_MIPS3_32,
	MIPS_GRP_MIPS3_32R2,
	MIPS_GRP_MIPS4_32,
	MIPS_GRP_MIPS4_32R2,
	MIPS_GRP_MIPS5_32R2,
	MIPS_GRP_GP32BIT,
	MIPS_GRP_GP64BIT,

	MIPS_GRP_ENDING,
} mips_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`Capstone/include/platform.h`:

```h
/* Capstone Disassembly Engine */
/* By Axel Souchet & Nguyen Anh Quynh, 2014 */

// handle C99 issue (for pre-2013 VisualStudio)
#ifndef CAPSTONE_PLATFORM_H
#define CAPSTONE_PLATFORM_H

#if !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))
// MSVC

// stdbool.h
#if (_MSC_VER < 1800)
#ifndef __cplusplus
typedef unsigned char bool;
#define false 0
#define true 1
#endif

#else
// VisualStudio 2013+ -> C99 is supported
#include <stdbool.h>
#endif

#else // not MSVC -> C99 is supported
#include <stdbool.h>
#endif

#endif

```

`Capstone/include/ppc.h`:

```h
#ifndef CAPSTONE_PPC_H
#define CAPSTONE_PPC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> PPC branch codes for some branch instructions
typedef enum ppc_bc {
	PPC_BC_INVALID  = 0,
	PPC_BC_LT       = (0 << 5) | 12,
	PPC_BC_LE       = (1 << 5) |  4,
	PPC_BC_EQ       = (2 << 5) | 12,
	PPC_BC_GE       = (0 << 5) |  4,
	PPC_BC_GT       = (1 << 5) | 12,
	PPC_BC_NE       = (2 << 5) |  4,
	PPC_BC_UN       = (3 << 5) | 12,
	PPC_BC_NU       = (3 << 5) |  4,

	// extra conditions
	PPC_BC_SO = (4 << 5) | 12,	// summary overflow
	PPC_BC_NS = (4 << 5) | 4,	// not summary overflow
} ppc_bc;

//> PPC branch hint for some branch instructions
typedef enum ppc_bh {
	PPC_BH_INVALID = 0,	// no hint
	PPC_BH_PLUS,	// PLUS hint
	PPC_BH_MINUS,	// MINUS hint
} ppc_bh;

//> Operand type for instruction's operands
typedef enum ppc_op_type {
	PPC_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	PPC_OP_REG, // = CS_OP_REG (Register operand).
	PPC_OP_IMM, // = CS_OP_IMM (Immediate operand).
	PPC_OP_MEM, // = CS_OP_MEM (Memory operand).
	PPC_OP_CRX = 64,	// Condition Register field
} ppc_op_type;

// Instruction's operand referring to memory
// This is associated with PPC_OP_MEM operand type above
typedef struct ppc_op_mem {
	unsigned int base;	// base register
	int32_t disp;	// displacement/offset value
} ppc_op_mem;

typedef struct ppc_op_crx {
	unsigned int scale;
	unsigned int reg;
	ppc_bc cond;
} ppc_op_crx;

// Instruction operand
typedef struct cs_ppc_op {
	ppc_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG operand
		int32_t imm;		// immediate value for IMM operand
		ppc_op_mem mem;		// base/disp value for MEM operand
		ppc_op_crx crx;		// operand with condition register
	};
} cs_ppc_op;

// Instruction structure
typedef struct cs_ppc {
	// branch code for branch instructions
	ppc_bc bc;

	// branch hint for branch instructions
	ppc_bh bh;

	// if update_cr0 = True, then this 'dot' insn updates CR0
	bool update_cr0;

	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_ppc_op operands[8]; // operands for this instruction.
} cs_ppc;

//> PPC registers
typedef enum ppc_reg {
	PPC_REG_INVALID = 0,

	PPC_REG_CARRY,
	PPC_REG_CC,
	PPC_REG_CR0,
	PPC_REG_CR1,
	PPC_REG_CR2,
	PPC_REG_CR3,
	PPC_REG_CR4,
	PPC_REG_CR5,
	PPC_REG_CR6,
	PPC_REG_CR7,
	PPC_REG_CTR,
	PPC_REG_F0,
	PPC_REG_F1,
	PPC_REG_F2,
	PPC_REG_F3,
	PPC_REG_F4,
	PPC_REG_F5,
	PPC_REG_F6,
	PPC_REG_F7,
	PPC_REG_F8,
	PPC_REG_F9,
	PPC_REG_F10,
	PPC_REG_F11,
	PPC_REG_F12,
	PPC_REG_F13,
	PPC_REG_F14,
	PPC_REG_F15,
	PPC_REG_F16,
	PPC_REG_F17,
	PPC_REG_F18,
	PPC_REG_F19,
	PPC_REG_F20,
	PPC_REG_F21,
	PPC_REG_F22,
	PPC_REG_F23,
	PPC_REG_F24,
	PPC_REG_F25,
	PPC_REG_F26,
	PPC_REG_F27,
	PPC_REG_F28,
	PPC_REG_F29,
	PPC_REG_F30,
	PPC_REG_F31,
	PPC_REG_LR,
	PPC_REG_R0,
	PPC_REG_R1,
	PPC_REG_R2,
	PPC_REG_R3,
	PPC_REG_R4,
	PPC_REG_R5,
	PPC_REG_R6,
	PPC_REG_R7,
	PPC_REG_R8,
	PPC_REG_R9,
	PPC_REG_R10,
	PPC_REG_R11,
	PPC_REG_R12,
	PPC_REG_R13,
	PPC_REG_R14,
	PPC_REG_R15,
	PPC_REG_R16,
	PPC_REG_R17,
	PPC_REG_R18,
	PPC_REG_R19,
	PPC_REG_R20,
	PPC_REG_R21,
	PPC_REG_R22,
	PPC_REG_R23,
	PPC_REG_R24,
	PPC_REG_R25,
	PPC_REG_R26,
	PPC_REG_R27,
	PPC_REG_R28,
	PPC_REG_R29,
	PPC_REG_R30,
	PPC_REG_R31,
	PPC_REG_V0,
	PPC_REG_V1,
	PPC_REG_V2,
	PPC_REG_V3,
	PPC_REG_V4,
	PPC_REG_V5,
	PPC_REG_V6,
	PPC_REG_V7,
	PPC_REG_V8,
	PPC_REG_V9,
	PPC_REG_V10,
	PPC_REG_V11,
	PPC_REG_V12,
	PPC_REG_V13,
	PPC_REG_V14,
	PPC_REG_V15,
	PPC_REG_V16,
	PPC_REG_V17,
	PPC_REG_V18,
	PPC_REG_V19,
	PPC_REG_V20,
	PPC_REG_V21,
	PPC_REG_V22,
	PPC_REG_V23,
	PPC_REG_V24,
	PPC_REG_V25,
	PPC_REG_V26,
	PPC_REG_V27,
	PPC_REG_V28,
	PPC_REG_V29,
	PPC_REG_V30,
	PPC_REG_V31,
	PPC_REG_VRSAVE,
	PPC_REG_VS0,
	PPC_REG_VS1,
	PPC_REG_VS2,
	PPC_REG_VS3,
	PPC_REG_VS4,
	PPC_REG_VS5,
	PPC_REG_VS6,
	PPC_REG_VS7,
	PPC_REG_VS8,
	PPC_REG_VS9,
	PPC_REG_VS10,
	PPC_REG_VS11,
	PPC_REG_VS12,
	PPC_REG_VS13,
	PPC_REG_VS14,
	PPC_REG_VS15,
	PPC_REG_VS16,
	PPC_REG_VS17,
	PPC_REG_VS18,
	PPC_REG_VS19,
	PPC_REG_VS20,
	PPC_REG_VS21,
	PPC_REG_VS22,
	PPC_REG_VS23,
	PPC_REG_VS24,
	PPC_REG_VS25,
	PPC_REG_VS26,
	PPC_REG_VS27,
	PPC_REG_VS28,
	PPC_REG_VS29,
	PPC_REG_VS30,
	PPC_REG_VS31,
	PPC_REG_VS32,
	PPC_REG_VS33,
	PPC_REG_VS34,
	PPC_REG_VS35,
	PPC_REG_VS36,
	PPC_REG_VS37,
	PPC_REG_VS38,
	PPC_REG_VS39,
	PPC_REG_VS40,
	PPC_REG_VS41,
	PPC_REG_VS42,
	PPC_REG_VS43,
	PPC_REG_VS44,
	PPC_REG_VS45,
	PPC_REG_VS46,
	PPC_REG_VS47,
	PPC_REG_VS48,
	PPC_REG_VS49,
	PPC_REG_VS50,
	PPC_REG_VS51,
	PPC_REG_VS52,
	PPC_REG_VS53,
	PPC_REG_VS54,
	PPC_REG_VS55,
	PPC_REG_VS56,
	PPC_REG_VS57,
	PPC_REG_VS58,
	PPC_REG_VS59,
	PPC_REG_VS60,
	PPC_REG_VS61,
	PPC_REG_VS62,
	PPC_REG_VS63,

	// extra registers for PPCMapping.c
	PPC_REG_RM,
	PPC_REG_CTR8,
	PPC_REG_LR8,
	PPC_REG_CR1EQ,

	PPC_REG_ENDING,   // <-- mark the end of the list of registers
} ppc_reg;

//> PPC instruction
typedef enum ppc_insn {
	PPC_INS_INVALID = 0,

	PPC_INS_ADD,
	PPC_INS_ADDC,
	PPC_INS_ADDE,
	PPC_INS_ADDI,
	PPC_INS_ADDIC,
	PPC_INS_ADDIS,
	PPC_INS_ADDME,
	PPC_INS_ADDZE,
	PPC_INS_AND,
	PPC_INS_ANDC,
	PPC_INS_ANDIS,
	PPC_INS_ANDI,
	PPC_INS_B,
	PPC_INS_BA,
	PPC_INS_BC,
	PPC_INS_BCCTR,
	PPC_INS_BCCTRL,
	PPC_INS_BCL,
	PPC_INS_BCLR,
	PPC_INS_BCLRL,
	PPC_INS_BCTR,
	PPC_INS_BCTRL,
	PPC_INS_BDNZ,
	PPC_INS_BDNZA,
	PPC_INS_BDNZL,
	PPC_INS_BDNZLA,
	PPC_INS_BDNZLR,
	PPC_INS_BDNZLRL,
	PPC_INS_BDZ,
	PPC_INS_BDZA,
	PPC_INS_BDZL,
	PPC_INS_BDZLA,
	PPC_INS_BDZLR,
	PPC_INS_BDZLRL,
	PPC_INS_BL,
	PPC_INS_BLA,
	PPC_INS_BLR,
	PPC_INS_BLRL,
	PPC_INS_BRINC,
	PPC_INS_CMPD,
	PPC_INS_CMPDI,
	PPC_INS_CMPLD,
	PPC_INS_CMPLDI,
	PPC_INS_CMPLW,
	PPC_INS_CMPLWI,
	PPC_INS_CMPW,
	PPC_INS_CMPWI,
	PPC_INS_CNTLZD,
	PPC_INS_CNTLZW,
	PPC_INS_CREQV,
	PPC_INS_CRXOR,
	PPC_INS_CRAND,
	PPC_INS_CRANDC,
	PPC_INS_CRNAND,
	PPC_INS_CRNOR,
	PPC_INS_CROR,
	PPC_INS_CRORC,
	PPC_INS_DCBA,
	PPC_INS_DCBF,
	PPC_INS_DCBI,
	PPC_INS_DCBST,
	PPC_INS_DCBT,
	PPC_INS_DCBTST,
	PPC_INS_DCBZ,
	PPC_INS_DCBZL,
	PPC_INS_DCCCI,
	PPC_INS_DIVD,
	PPC_INS_DIVDU,
	PPC_INS_DIVW,
	PPC_INS_DIVWU,
	PPC_INS_DSS,
	PPC_INS_DSSALL,
	PPC_INS_DST,
	PPC_INS_DSTST,
	PPC_INS_DSTSTT,
	PPC_INS_DSTT,
	PPC_INS_EIEIO,
	PPC_INS_EQV,
	PPC_INS_EVABS,
	PPC_INS_EVADDIW,
	PPC_INS_EVADDSMIAAW,
	PPC_INS_EVADDSSIAAW,
	PPC_INS_EVADDUMIAAW,
	PPC_INS_EVADDUSIAAW,
	PPC_INS_EVADDW,
	PPC_INS_EVAND,
	PPC_INS_EVANDC,
	PPC_INS_EVCMPEQ,
	PPC_INS_EVCMPGTS,
	PPC_INS_EVCMPGTU,
	PPC_INS_EVCMPLTS,
	PPC_INS_EVCMPLTU,
	PPC_INS_EVCNTLSW,
	PPC_INS_EVCNTLZW,
	PPC_INS_EVDIVWS,
	PPC_INS_EVDIVWU,
	PPC_INS_EVEQV,
	PPC_INS_EVEXTSB,
	PPC_INS_EVEXTSH,
	PPC_INS_EVLDD,
	PPC_INS_EVLDDX,
	PPC_INS_EVLDH,
	PPC_INS_EVLDHX,
	PPC_INS_EVLDW,
	PPC_INS_EVLDWX,
	PPC_INS_EVLHHESPLAT,
	PPC_INS_EVLHHESPLATX,
	PPC_INS_EVLHHOSSPLAT,
	PPC_INS_EVLHHOSSPLATX,
	PPC_INS_EVLHHOUSPLAT,
	PPC_INS_EVLHHOUSPLATX,
	PPC_INS_EVLWHE,
	PPC_INS_EVLWHEX,
	PPC_INS_EVLWHOS,
	PPC_INS_EVLWHOSX,
	PPC_INS_EVLWHOU,
	PPC_INS_EVLWHOUX,
	PPC_INS_EVLWHSPLAT,
	PPC_INS_EVLWHSPLATX,
	PPC_INS_EVLWWSPLAT,
	PPC_INS_EVLWWSPLATX,
	PPC_INS_EVMERGEHI,
	PPC_INS_EVMERGEHILO,
	PPC_INS_EVMERGELO,
	PPC_INS_EVMERGELOHI,
	PPC_INS_EVMHEGSMFAA,
	PPC_INS_EVMHEGSMFAN,
	PPC_INS_EVMHEGSMIAA,
	PPC_INS_EVMHEGSMIAN,
	PPC_INS_EVMHEGUMIAA,
	PPC_INS_EVMHEGUMIAN,
	PPC_INS_EVMHESMF,
	PPC_INS_EVMHESMFA,
	PPC_INS_EVMHESMFAAW,
	PPC_INS_EVMHESMFANW,
	PPC_INS_EVMHESMI,
	PPC_INS_EVMHESMIA,
	PPC_INS_EVMHESMIAAW,
	PPC_INS_EVMHESMIANW,
	PPC_INS_EVMHESSF,
	PPC_INS_EVMHESSFA,
	PPC_INS_EVMHESSFAAW,
	PPC_INS_EVMHESSFANW,
	PPC_INS_EVMHESSIAAW,
	PPC_INS_EVMHESSIANW,
	PPC_INS_EVMHEUMI,
	PPC_INS_EVMHEUMIA,
	PPC_INS_EVMHEUMIAAW,
	PPC_INS_EVMHEUMIANW,
	PPC_INS_EVMHEUSIAAW,
	PPC_INS_EVMHEUSIANW,
	PPC_INS_EVMHOGSMFAA,
	PPC_INS_EVMHOGSMFAN,
	PPC_INS_EVMHOGSMIAA,
	PPC_INS_EVMHOGSMIAN,
	PPC_INS_EVMHOGUMIAA,
	PPC_INS_EVMHOGUMIAN,
	PPC_INS_EVMHOSMF,
	PPC_INS_EVMHOSMFA,
	PPC_INS_EVMHOSMFAAW,
	PPC_INS_EVMHOSMFANW,
	PPC_INS_EVMHOSMI,
	PPC_INS_EVMHOSMIA,
	PPC_INS_EVMHOSMIAAW,
	PPC_INS_EVMHOSMIANW,
	PPC_INS_EVMHOSSF,
	PPC_INS_EVMHOSSFA,
	PPC_INS_EVMHOSSFAAW,
	PPC_INS_EVMHOSSFANW,
	PPC_INS_EVMHOSSIAAW,
	PPC_INS_EVMHOSSIANW,
	PPC_INS_EVMHOUMI,
	PPC_INS_EVMHOUMIA,
	PPC_INS_EVMHOUMIAAW,
	PPC_INS_EVMHOUMIANW,
	PPC_INS_EVMHOUSIAAW,
	PPC_INS_EVMHOUSIANW,
	PPC_INS_EVMRA,
	PPC_INS_EVMWHSMF,
	PPC_INS_EVMWHSMFA,
	PPC_INS_EVMWHSMI,
	PPC_INS_EVMWHSMIA,
	PPC_INS_EVMWHSSF,
	PPC_INS_EVMWHSSFA,
	PPC_INS_EVMWHUMI,
	PPC_INS_EVMWHUMIA,
	PPC_INS_EVMWLSMIAAW,
	PPC_INS_EVMWLSMIANW,
	PPC_INS_EVMWLSSIAAW,
	PPC_INS_EVMWLSSIANW,
	PPC_INS_EVMWLUMI,
	PPC_INS_EVMWLUMIA,
	PPC_INS_EVMWLUMIAAW,
	PPC_INS_EVMWLUMIANW,
	PPC_INS_EVMWLUSIAAW,
	PPC_INS_EVMWLUSIANW,
	PPC_INS_EVMWSMF,
	PPC_INS_EVMWSMFA,
	PPC_INS_EVMWSMFAA,
	PPC_INS_EVMWSMFAN,
	PPC_INS_EVMWSMI,
	PPC_INS_EVMWSMIA,
	PPC_INS_EVMWSMIAA,
	PPC_INS_EVMWSMIAN,
	PPC_INS_EVMWSSF,
	PPC_INS_EVMWSSFA,
	PPC_INS_EVMWSSFAA,
	PPC_INS_EVMWSSFAN,
	PPC_INS_EVMWUMI,
	PPC_INS_EVMWUMIA,
	PPC_INS_EVMWUMIAA,
	PPC_INS_EVMWUMIAN,
	PPC_INS_EVNAND,
	PPC_INS_EVNEG,
	PPC_INS_EVNOR,
	PPC_INS_EVOR,
	PPC_INS_EVORC,
	PPC_INS_EVRLW,
	PPC_INS_EVRLWI,
	PPC_INS_EVRNDW,
	PPC_INS_EVSLW,
	PPC_INS_EVSLWI,
	PPC_INS_EVSPLATFI,
	PPC_INS_EVSPLATI,
	PPC_INS_EVSRWIS,
	PPC_INS_EVSRWIU,
	PPC_INS_EVSRWS,
	PPC_INS_EVSRWU,
	PPC_INS_EVSTDD,
	PPC_INS_EVSTDDX,
	PPC_INS_EVSTDH,
	PPC_INS_EVSTDHX,
	PPC_INS_EVSTDW,
	PPC_INS_EVSTDWX,
	PPC_INS_EVSTWHE,
	PPC_INS_EVSTWHEX,
	PPC_INS_EVSTWHO,
	PPC_INS_EVSTWHOX,
	PPC_INS_EVSTWWE,
	PPC_INS_EVSTWWEX,
	PPC_INS_EVSTWWO,
	PPC_INS_EVSTWWOX,
	PPC_INS_EVSUBFSMIAAW,
	PPC_INS_EVSUBFSSIAAW,
	PPC_INS_EVSUBFUMIAAW,
	PPC_INS_EVSUBFUSIAAW,
	PPC_INS_EVSUBFW,
	PPC_INS_EVSUBIFW,
	PPC_INS_EVXOR,
	PPC_INS_EXTSB,
	PPC_INS_EXTSH,
	PPC_INS_EXTSW,
	PPC_INS_FABS,
	PPC_INS_FADD,
	PPC_INS_FADDS,
	PPC_INS_FCFID,
	PPC_INS_FCFIDS,
	PPC_INS_FCFIDU,
	PPC_INS_FCFIDUS,
	PPC_INS_FCMPU,
	PPC_INS_FCPSGN,
	PPC_INS_FCTID,
	PPC_INS_FCTIDUZ,
	PPC_INS_FCTIDZ,
	PPC_INS_FCTIW,
	PPC_INS_FCTIWUZ,
	PPC_INS_FCTIWZ,
	PPC_INS_FDIV,
	PPC_INS_FDIVS,
	PPC_INS_FMADD,
	PPC_INS_FMADDS,
	PPC_INS_FMR,
	PPC_INS_FMSUB,
	PPC_INS_FMSUBS,
	PPC_INS_FMUL,
	PPC_INS_FMULS,
	PPC_INS_FNABS,
	PPC_INS_FNEG,
	PPC_INS_FNMADD,
	PPC_INS_FNMADDS,
	PPC_INS_FNMSUB,
	PPC_INS_FNMSUBS,
	PPC_INS_FRE,
	PPC_INS_FRES,
	PPC_INS_FRIM,
	PPC_INS_FRIN,
	PPC_INS_FRIP,
	PPC_INS_FRIZ,
	PPC_INS_FRSP,
	PPC_INS_FRSQRTE,
	PPC_INS_FRSQRTES,
	PPC_INS_FSEL,
	PPC_INS_FSQRT,
	PPC_INS_FSQRTS,
	PPC_INS_FSUB,
	PPC_INS_FSUBS,
	PPC_INS_ICBI,
	PPC_INS_ICCCI,
	PPC_INS_ISEL,
	PPC_INS_ISYNC,
	PPC_INS_LA,
	PPC_INS_LBZ,
	PPC_INS_LBZU,
	PPC_INS_LBZUX,
	PPC_INS_LBZX,
	PPC_INS_LD,
	PPC_INS_LDARX,
	PPC_INS_LDBRX,
	PPC_INS_LDU,
	PPC_INS_LDUX,
	PPC_INS_LDX,
	PPC_INS_LFD,
	PPC_INS_LFDU,
	PPC_INS_LFDUX,
	PPC_INS_LFDX,
	PPC_INS_LFIWAX,
	PPC_INS_LFIWZX,
	PPC_INS_LFS,
	PPC_INS_LFSU,
	PPC_INS_LFSUX,
	PPC_INS_LFSX,
	PPC_INS_LHA,
	PPC_INS_LHAU,
	PPC_INS_LHAUX,
	PPC_INS_LHAX,
	PPC_INS_LHBRX,
	PPC_INS_LHZ,
	PPC_INS_LHZU,
	PPC_INS_LHZUX,
	PPC_INS_LHZX,
	PPC_INS_LI,
	PPC_INS_LIS,
	PPC_INS_LMW,
	PPC_INS_LSWI,
	PPC_INS_LVEBX,
	PPC_INS_LVEHX,
	PPC_INS_LVEWX,
	PPC_INS_LVSL,
	PPC_INS_LVSR,
	PPC_INS_LVX,
	PPC_INS_LVXL,
	PPC_INS_LWA,
	PPC_INS_LWARX,
	PPC_INS_LWAUX,
	PPC_INS_LWAX,
	PPC_INS_LWBRX,
	PPC_INS_LWZ,
	PPC_INS_LWZU,
	PPC_INS_LWZUX,
	PPC_INS_LWZX,
	PPC_INS_LXSDX,
	PPC_INS_LXVD2X,
	PPC_INS_LXVDSX,
	PPC_INS_LXVW4X,
	PPC_INS_MBAR,
	PPC_INS_MCRF,
	PPC_INS_MFCR,
	PPC_INS_MFCTR,
	PPC_INS_MFDCR,
	PPC_INS_MFFS,
	PPC_INS_MFLR,
	PPC_INS_MFMSR,
	PPC_INS_MFOCRF,
	PPC_INS_MFSPR,
	PPC_INS_MFSR,
	PPC_INS_MFSRIN,
	PPC_INS_MFTB,
	PPC_INS_MFVSCR,
	PPC_INS_MSYNC,
	PPC_INS_MTCRF,
	PPC_INS_MTCTR,
	PPC_INS_MTDCR,
	PPC_INS_MTFSB0,
	PPC_INS_MTFSB1,
	PPC_INS_MTFSF,
	PPC_INS_MTLR,
	PPC_INS_MTMSR,
	PPC_INS_MTMSRD,
	PPC_INS_MTOCRF,
	PPC_INS_MTSPR,
	PPC_INS_MTSR,
	PPC_INS_MTSRIN,
	PPC_INS_MTVSCR,
	PPC_INS_MULHD,
	PPC_INS_MULHDU,
	PPC_INS_MULHW,
	PPC_INS_MULHWU,
	PPC_INS_MULLD,
	PPC_INS_MULLI,
	PPC_INS_MULLW,
	PPC_INS_NAND,
	PPC_INS_NEG,
	PPC_INS_NOP,
	PPC_INS_ORI,
	PPC_INS_NOR,
	PPC_INS_OR,
	PPC_INS_ORC,
	PPC_INS_ORIS,
	PPC_INS_POPCNTD,
	PPC_INS_POPCNTW,
	PPC_INS_RFCI,
	PPC_INS_RFDI,
	PPC_INS_RFI,
	PPC_INS_RFID,
	PPC_INS_RFMCI,
	PPC_INS_RLDCL,
	PPC_INS_RLDCR,
	PPC_INS_RLDIC,
	PPC_INS_RLDICL,
	PPC_INS_RLDICR,
	PPC_INS_RLDIMI,
	PPC_INS_RLWIMI,
	PPC_INS_RLWINM,
	PPC_INS_RLWNM,
	PPC_INS_SC,
	PPC_INS_SLBIA,
	PPC_INS_SLBIE,
	PPC_INS_SLBMFEE,
	PPC_INS_SLBMTE,
	PPC_INS_SLD,
	PPC_INS_SLW,
	PPC_INS_SRAD,
	PPC_INS_SRADI,
	PPC_INS_SRAW,
	PPC_INS_SRAWI,
	PPC_INS_SRD,
	PPC_INS_SRW,
	PPC_INS_STB,
	PPC_INS_STBU,
	PPC_INS_STBUX,
	PPC_INS_STBX,
	PPC_INS_STD,
	PPC_INS_STDBRX,
	PPC_INS_STDCX,
	PPC_INS_STDU,
	PPC_INS_STDUX,
	PPC_INS_STDX,
	PPC_INS_STFD,
	PPC_INS_STFDU,
	PPC_INS_STFDUX,
	PPC_INS_STFDX,
	PPC_INS_STFIWX,
	PPC_INS_STFS,
	PPC_INS_STFSU,
	PPC_INS_STFSUX,
	PPC_INS_STFSX,
	PPC_INS_STH,
	PPC_INS_STHBRX,
	PPC_INS_STHU,
	PPC_INS_STHUX,
	PPC_INS_STHX,
	PPC_INS_STMW,
	PPC_INS_STSWI,
	PPC_INS_STVEBX,
	PPC_INS_STVEHX,
	PPC_INS_STVEWX,
	PPC_INS_STVX,
	PPC_INS_STVXL,
	PPC_INS_STW,
	PPC_INS_STWBRX,
	PPC_INS_STWCX,
	PPC_INS_STWU,
	PPC_INS_STWUX,
	PPC_INS_STWX,
	PPC_INS_STXSDX,
	PPC_INS_STXVD2X,
	PPC_INS_STXVW4X,
	PPC_INS_SUBF,
	PPC_INS_SUBFC,
	PPC_INS_SUBFE,
	PPC_INS_SUBFIC,
	PPC_INS_SUBFME,
	PPC_INS_SUBFZE,
	PPC_INS_SYNC,
	PPC_INS_TD,
	PPC_INS_TDI,
	PPC_INS_TLBIA,
	PPC_INS_TLBIE,
	PPC_INS_TLBIEL,
	PPC_INS_TLBIVAX,
	PPC_INS_TLBLD,
	PPC_INS_TLBLI,
	PPC_INS_TLBRE,
	PPC_INS_TLBSX,
	PPC_INS_TLBSYNC,
	PPC_INS_TLBWE,
	PPC_INS_TRAP,
	PPC_INS_TW,
	PPC_INS_TWI,
	PPC_INS_VADDCUW,
	PPC_INS_VADDFP,
	PPC_INS_VADDSBS,
	PPC_INS_VADDSHS,
	PPC_INS_VADDSWS,
	PPC_INS_VADDUBM,
	PPC_INS_VADDUBS,
	PPC_INS_VADDUHM,
	PPC_INS_VADDUHS,
	PPC_INS_VADDUWM,
	PPC_INS_VADDUWS,
	PPC_INS_VAND,
	PPC_INS_VANDC,
	PPC_INS_VAVGSB,
	PPC_INS_VAVGSH,
	PPC_INS_VAVGSW,
	PPC_INS_VAVGUB,
	PPC_INS_VAVGUH,
	PPC_INS_VAVGUW,
	PPC_INS_VCFSX,
	PPC_INS_VCFUX,
	PPC_INS_VCMPBFP,
	PPC_INS_VCMPEQFP,
	PPC_INS_VCMPEQUB,
	PPC_INS_VCMPEQUH,
	PPC_INS_VCMPEQUW,
	PPC_INS_VCMPGEFP,
	PPC_INS_VCMPGTFP,
	PPC_INS_VCMPGTSB,
	PPC_INS_VCMPGTSH,
	PPC_INS_VCMPGTSW,
	PPC_INS_VCMPGTUB,
	PPC_INS_VCMPGTUH,
	PPC_INS_VCMPGTUW,
	PPC_INS_VCTSXS,
	PPC_INS_VCTUXS,
	PPC_INS_VEXPTEFP,
	PPC_INS_VLOGEFP,
	PPC_INS_VMADDFP,
	PPC_INS_VMAXFP,
	PPC_INS_VMAXSB,
	PPC_INS_VMAXSH,
	PPC_INS_VMAXSW,
	PPC_INS_VMAXUB,
	PPC_INS_VMAXUH,
	PPC_INS_VMAXUW,
	PPC_INS_VMHADDSHS,
	PPC_INS_VMHRADDSHS,
	PPC_INS_VMINFP,
	PPC_INS_VMINSB,
	PPC_INS_VMINSH,
	PPC_INS_VMINSW,
	PPC_INS_VMINUB,
	PPC_INS_VMINUH,
	PPC_INS_VMINUW,
	PPC_INS_VMLADDUHM,
	PPC_INS_VMRGHB,
	PPC_INS_VMRGHH,
	PPC_INS_VMRGHW,
	PPC_INS_VMRGLB,
	PPC_INS_VMRGLH,
	PPC_INS_VMRGLW,
	PPC_INS_VMSUMMBM,
	PPC_INS_VMSUMSHM,
	PPC_INS_VMSUMSHS,
	PPC_INS_VMSUMUBM,
	PPC_INS_VMSUMUHM,
	PPC_INS_VMSUMUHS,
	PPC_INS_VMULESB,
	PPC_INS_VMULESH,
	PPC_INS_VMULEUB,
	PPC_INS_VMULEUH,
	PPC_INS_VMULOSB,
	PPC_INS_VMULOSH,
	PPC_INS_VMULOUB,
	PPC_INS_VMULOUH,
	PPC_INS_VNMSUBFP,
	PPC_INS_VNOR,
	PPC_INS_VOR,
	PPC_INS_VPERM,
	PPC_INS_VPKPX,
	PPC_INS_VPKSHSS,
	PPC_INS_VPKSHUS,
	PPC_INS_VPKSWSS,
	PPC_INS_VPKSWUS,
	PPC_INS_VPKUHUM,
	PPC_INS_VPKUHUS,
	PPC_INS_VPKUWUM,
	PPC_INS_VPKUWUS,
	PPC_INS_VREFP,
	PPC_INS_VRFIM,
	PPC_INS_VRFIN,
	PPC_INS_VRFIP,
	PPC_INS_VRFIZ,
	PPC_INS_VRLB,
	PPC_INS_VRLH,
	PPC_INS_VRLW,
	PPC_INS_VRSQRTEFP,
	PPC_INS_VSEL,
	PPC_INS_VSL,
	PPC_INS_VSLB,
	PPC_INS_VSLDOI,
	PPC_INS_VSLH,
	PPC_INS_VSLO,
	PPC_INS_VSLW,
	PPC_INS_VSPLTB,
	PPC_INS_VSPLTH,
	PPC_INS_VSPLTISB,
	PPC_INS_VSPLTISH,
	PPC_INS_VSPLTISW,
	PPC_INS_VSPLTW,
	PPC_INS_VSR,
	PPC_INS_VSRAB,
	PPC_INS_VSRAH,
	PPC_INS_VSRAW,
	PPC_INS_VSRB,
	PPC_INS_VSRH,
	PPC_INS_VSRO,
	PPC_INS_VSRW,
	PPC_INS_VSUBCUW,
	PPC_INS_VSUBFP,
	PPC_INS_VSUBSBS,
	PPC_INS_VSUBSHS,
	PPC_INS_VSUBSWS,
	PPC_INS_VSUBUBM,
	PPC_INS_VSUBUBS,
	PPC_INS_VSUBUHM,
	PPC_INS_VSUBUHS,
	PPC_INS_VSUBUWM,
	PPC_INS_VSUBUWS,
	PPC_INS_VSUM2SWS,
	PPC_INS_VSUM4SBS,
	PPC_INS_VSUM4SHS,
	PPC_INS_VSUM4UBS,
	PPC_INS_VSUMSWS,
	PPC_INS_VUPKHPX,
	PPC_INS_VUPKHSB,
	PPC_INS_VUPKHSH,
	PPC_INS_VUPKLPX,
	PPC_INS_VUPKLSB,
	PPC_INS_VUPKLSH,
	PPC_INS_VXOR,
	PPC_INS_WAIT,
	PPC_INS_WRTEE,
	PPC_INS_WRTEEI,
	PPC_INS_XOR,
	PPC_INS_XORI,
	PPC_INS_XORIS,
	PPC_INS_XSABSDP,
	PPC_INS_XSADDDP,
	PPC_INS_XSCMPODP,
	PPC_INS_XSCMPUDP,
	PPC_INS_XSCPSGNDP,
	PPC_INS_XSCVDPSP,
	PPC_INS_XSCVDPSXDS,
	PPC_INS_XSCVDPSXWS,
	PPC_INS_XSCVDPUXDS,
	PPC_INS_XSCVDPUXWS,
	PPC_INS_XSCVSPDP,
	PPC_INS_XSCVSXDDP,
	PPC_INS_XSCVUXDDP,
	PPC_INS_XSDIVDP,
	PPC_INS_XSMADDADP,
	PPC_INS_XSMADDMDP,
	PPC_INS_XSMAXDP,
	PPC_INS_XSMINDP,
	PPC_INS_XSMSUBADP,
	PPC_INS_XSMSUBMDP,
	PPC_INS_XSMULDP,
	PPC_INS_XSNABSDP,
	PPC_INS_XSNEGDP,
	PPC_INS_XSNMADDADP,
	PPC_INS_XSNMADDMDP,
	PPC_INS_XSNMSUBADP,
	PPC_INS_XSNMSUBMDP,
	PPC_INS_XSRDPI,
	PPC_INS_XSRDPIC,
	PPC_INS_XSRDPIM,
	PPC_INS_XSRDPIP,
	PPC_INS_XSRDPIZ,
	PPC_INS_XSREDP,
	PPC_INS_XSRSQRTEDP,
	PPC_INS_XSSQRTDP,
	PPC_INS_XSSUBDP,
	PPC_INS_XSTDIVDP,
	PPC_INS_XSTSQRTDP,
	PPC_INS_XVABSDP,
	PPC_INS_XVABSSP,
	PPC_INS_XVADDDP,
	PPC_INS_XVADDSP,
	PPC_INS_XVCMPEQDP,
	PPC_INS_XVCMPEQSP,
	PPC_INS_XVCMPGEDP,
	PPC_INS_XVCMPGESP,
	PPC_INS_XVCMPGTDP,
	PPC_INS_XVCMPGTSP,
	PPC_INS_XVCPSGNDP,
	PPC_INS_XVCPSGNSP,
	PPC_INS_XVCVDPSP,
	PPC_INS_XVCVDPSXDS,
	PPC_INS_XVCVDPSXWS,
	PPC_INS_XVCVDPUXDS,
	PPC_INS_XVCVDPUXWS,
	PPC_INS_XVCVSPDP,
	PPC_INS_XVCVSPSXDS,
	PPC_INS_XVCVSPSXWS,
	PPC_INS_XVCVSPUXDS,
	PPC_INS_XVCVSPUXWS,
	PPC_INS_XVCVSXDDP,
	PPC_INS_XVCVSXDSP,
	PPC_INS_XVCVSXWDP,
	PPC_INS_XVCVSXWSP,
	PPC_INS_XVCVUXDDP,
	PPC_INS_XVCVUXDSP,
	PPC_INS_XVCVUXWDP,
	PPC_INS_XVCVUXWSP,
	PPC_INS_XVDIVDP,
	PPC_INS_XVDIVSP,
	PPC_INS_XVMADDADP,
	PPC_INS_XVMADDASP,
	PPC_INS_XVMADDMDP,
	PPC_INS_XVMADDMSP,
	PPC_INS_XVMAXDP,
	PPC_INS_XVMAXSP,
	PPC_INS_XVMINDP,
	PPC_INS_XVMINSP,
	PPC_INS_XVMSUBADP,
	PPC_INS_XVMSUBASP,
	PPC_INS_XVMSUBMDP,
	PPC_INS_XVMSUBMSP,
	PPC_INS_XVMULDP,
	PPC_INS_XVMULSP,
	PPC_INS_XVNABSDP,
	PPC_INS_XVNABSSP,
	PPC_INS_XVNEGDP,
	PPC_INS_XVNEGSP,
	PPC_INS_XVNMADDADP,
	PPC_INS_XVNMADDASP,
	PPC_INS_XVNMADDMDP,
	PPC_INS_XVNMADDMSP,
	PPC_INS_XVNMSUBADP,
	PPC_INS_XVNMSUBASP,
	PPC_INS_XVNMSUBMDP,
	PPC_INS_XVNMSUBMSP,
	PPC_INS_XVRDPI,
	PPC_INS_XVRDPIC,
	PPC_INS_XVRDPIM,
	PPC_INS_XVRDPIP,
	PPC_INS_XVRDPIZ,
	PPC_INS_XVREDP,
	PPC_INS_XVRESP,
	PPC_INS_XVRSPI,
	PPC_INS_XVRSPIC,
	PPC_INS_XVRSPIM,
	PPC_INS_XVRSPIP,
	PPC_INS_XVRSPIZ,
	PPC_INS_XVRSQRTEDP,
	PPC_INS_XVRSQRTESP,
	PPC_INS_XVSQRTDP,
	PPC_INS_XVSQRTSP,
	PPC_INS_XVSUBDP,
	PPC_INS_XVSUBSP,
	PPC_INS_XVTDIVDP,
	PPC_INS_XVTDIVSP,
	PPC_INS_XVTSQRTDP,
	PPC_INS_XVTSQRTSP,
	PPC_INS_XXLAND,
	PPC_INS_XXLANDC,
	PPC_INS_XXLNOR,
	PPC_INS_XXLOR,
	PPC_INS_XXLXOR,
	PPC_INS_XXMRGHW,
	PPC_INS_XXMRGLW,
	PPC_INS_XXPERMDI,
	PPC_INS_XXSEL,
	PPC_INS_XXSLDWI,
	PPC_INS_XXSPLTW,
	PPC_INS_BCA,
	PPC_INS_BCLA,

	// extra & alias instructions
	PPC_INS_SLWI,
	PPC_INS_SRWI,
	PPC_INS_SLDI,

	PPC_INS_BTA,
	PPC_INS_CRSET,
	PPC_INS_CRNOT,
	PPC_INS_CRMOVE,
	PPC_INS_CRCLR,
	PPC_INS_MFBR0,
	PPC_INS_MFBR1,
	PPC_INS_MFBR2,
	PPC_INS_MFBR3,
	PPC_INS_MFBR4,
	PPC_INS_MFBR5,
	PPC_INS_MFBR6,
	PPC_INS_MFBR7,
	PPC_INS_MFXER,
	PPC_INS_MFRTCU,
	PPC_INS_MFRTCL,
	PPC_INS_MFDSCR,
	PPC_INS_MFDSISR,
	PPC_INS_MFDAR,
	PPC_INS_MFSRR2,
	PPC_INS_MFSRR3,
	PPC_INS_MFCFAR,
	PPC_INS_MFAMR,
	PPC_INS_MFPID,
	PPC_INS_MFTBLO,
	PPC_INS_MFTBHI,
	PPC_INS_MFDBATU,
	PPC_INS_MFDBATL,
	PPC_INS_MFIBATU,
	PPC_INS_MFIBATL,
	PPC_INS_MFDCCR,
	PPC_INS_MFICCR,
	PPC_INS_MFDEAR,
	PPC_INS_MFESR,
	PPC_INS_MFSPEFSCR,
	PPC_INS_MFTCR,
	PPC_INS_MFASR,
	PPC_INS_MFPVR,
	PPC_INS_MFTBU,
	PPC_INS_MTCR,
	PPC_INS_MTBR0,
	PPC_INS_MTBR1,
	PPC_INS_MTBR2,
	PPC_INS_MTBR3,
	PPC_INS_MTBR4,
	PPC_INS_MTBR5,
	PPC_INS_MTBR6,
	PPC_INS_MTBR7,
	PPC_INS_MTXER,
	PPC_INS_MTDSCR,
	PPC_INS_MTDSISR,
	PPC_INS_MTDAR,
	PPC_INS_MTSRR2,
	PPC_INS_MTSRR3,
	PPC_INS_MTCFAR,
	PPC_INS_MTAMR,
	PPC_INS_MTPID,
	PPC_INS_MTTBL,
	PPC_INS_MTTBU,
	PPC_INS_MTTBLO,
	PPC_INS_MTTBHI,
	PPC_INS_MTDBATU,
	PPC_INS_MTDBATL,
	PPC_INS_MTIBATU,
	PPC_INS_MTIBATL,
	PPC_INS_MTDCCR,
	PPC_INS_MTICCR,
	PPC_INS_MTDEAR,
	PPC_INS_MTESR,
	PPC_INS_MTSPEFSCR,
	PPC_INS_MTTCR,
	PPC_INS_NOT,
	PPC_INS_MR,
	PPC_INS_ROTLD,
	PPC_INS_ROTLDI,
	PPC_INS_CLRLDI,
	PPC_INS_ROTLWI,
	PPC_INS_CLRLWI,
	PPC_INS_ROTLW,
	PPC_INS_SUB,
	PPC_INS_SUBC,
	PPC_INS_LWSYNC,
	PPC_INS_PTESYNC,
	PPC_INS_TDLT,
	PPC_INS_TDEQ,
	PPC_INS_TDGT,
	PPC_INS_TDNE,
	PPC_INS_TDLLT,
	PPC_INS_TDLGT,
	PPC_INS_TDU,
	PPC_INS_TDLTI,
	PPC_INS_TDEQI,
	PPC_INS_TDGTI,
	PPC_INS_TDNEI,
	PPC_INS_TDLLTI,
	PPC_INS_TDLGTI,
	PPC_INS_TDUI,
	PPC_INS_TLBREHI,
	PPC_INS_TLBRELO,
	PPC_INS_TLBWEHI,
	PPC_INS_TLBWELO,
	PPC_INS_TWLT,
	PPC_INS_TWEQ,
	PPC_INS_TWGT,
	PPC_INS_TWNE,
	PPC_INS_TWLLT,
	PPC_INS_TWLGT,
	PPC_INS_TWU,
	PPC_INS_TWLTI,
	PPC_INS_TWEQI,
	PPC_INS_TWGTI,
	PPC_INS_TWNEI,
	PPC_INS_TWLLTI,
	PPC_INS_TWLGTI,
	PPC_INS_TWUI,
	PPC_INS_WAITRSV,
	PPC_INS_WAITIMPL,
	PPC_INS_XNOP,
	PPC_INS_XVMOVDP,
	PPC_INS_XVMOVSP,
	PPC_INS_XXSPLTD,
	PPC_INS_XXMRGHD,
	PPC_INS_XXMRGLD,
	PPC_INS_XXSWAPD,
	PPC_INS_BT,
	PPC_INS_BF,
	PPC_INS_BDNZT,
	PPC_INS_BDNZF,
	PPC_INS_BDZF,
	PPC_INS_BDZT,
	PPC_INS_BFA,
	PPC_INS_BDNZTA,
	PPC_INS_BDNZFA,
	PPC_INS_BDZTA,
	PPC_INS_BDZFA,
	PPC_INS_BTCTR,
	PPC_INS_BFCTR,
	PPC_INS_BTCTRL,
	PPC_INS_BFCTRL,
	PPC_INS_BTL,
	PPC_INS_BFL,
	PPC_INS_BDNZTL,
	PPC_INS_BDNZFL,
	PPC_INS_BDZTL,
	PPC_INS_BDZFL,
	PPC_INS_BTLA,
	PPC_INS_BFLA,
	PPC_INS_BDNZTLA,
	PPC_INS_BDNZFLA,
	PPC_INS_BDZTLA,
	PPC_INS_BDZFLA,
	PPC_INS_BTLR,
	PPC_INS_BFLR,
	PPC_INS_BDNZTLR,
	PPC_INS_BDZTLR,
	PPC_INS_BDZFLR,
	PPC_INS_BTLRL,
	PPC_INS_BFLRL,
	PPC_INS_BDNZTLRL,
	PPC_INS_BDNZFLRL,
	PPC_INS_BDZTLRL,
	PPC_INS_BDZFLRL,

	PPC_INS_ENDING,   // <-- mark the end of the list of instructions
} ppc_insn;

//> Group of PPC instructions
typedef enum ppc_insn_group {
	PPC_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	PPC_GRP_JUMP,	// = CS_GRP_JUMP

	//> Architecture-specific groups
	PPC_GRP_ALTIVEC = 128,
	PPC_GRP_MODE32,
	PPC_GRP_MODE64,
	PPC_GRP_BOOKE,
	PPC_GRP_NOTBOOKE,
	PPC_GRP_SPE,
	PPC_GRP_VSX,
	PPC_GRP_E500,
	PPC_GRP_PPC4XX,
	PPC_GRP_PPC6XX,

	PPC_GRP_ENDING,   // <-- mark the end of the list of groups
} ppc_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`Capstone/include/sparc.h`:

```h
#ifndef CAPSTONE_SPARC_H
#define CAPSTONE_SPARC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

// GCC SPARC toolchain has a default macro called "sparc" which breaks
// compilation
#undef sparc

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Enums corresponding to Sparc condition codes, both icc's and fcc's.
typedef enum sparc_cc {
	SPARC_CC_INVALID = 0,	// invalid CC (default)
	//> Integer condition codes
	SPARC_CC_ICC_A   =  8+256,  // Always
	SPARC_CC_ICC_N   =  0+256,  // Never
	SPARC_CC_ICC_NE  =  9+256,  // Not Equal
	SPARC_CC_ICC_E   =  1+256,  // Equal
	SPARC_CC_ICC_G   = 10+256,  // Greater
	SPARC_CC_ICC_LE  =  2+256,  // Less or Equal
	SPARC_CC_ICC_GE  = 11+256,  // Greater or Equal
	SPARC_CC_ICC_L   =  3+256,  // Less
	SPARC_CC_ICC_GU  = 12+256,  // Greater Unsigned
	SPARC_CC_ICC_LEU =  4+256,  // Less or Equal Unsigned
	SPARC_CC_ICC_CC  = 13+256,  // Carry Clear/Great or Equal Unsigned
	SPARC_CC_ICC_CS  =  5+256,  // Carry Set/Less Unsigned
	SPARC_CC_ICC_POS = 14+256,  // Positive
	SPARC_CC_ICC_NEG =  6+256,  // Negative
	SPARC_CC_ICC_VC  = 15+256,  // Overflow Clear
	SPARC_CC_ICC_VS  =  7+256,  // Overflow Set

	//> Floating condition codes
	SPARC_CC_FCC_A   =  8+16+256,  // Always
	SPARC_CC_FCC_N   =  0+16+256,  // Never
	SPARC_CC_FCC_U   =  7+16+256,  // Unordered
	SPARC_CC_FCC_G   =  6+16+256,  // Greater
	SPARC_CC_FCC_UG  =  5+16+256,  // Unordered or Greater
	SPARC_CC_FCC_L   =  4+16+256,  // Less
	SPARC_CC_FCC_UL  =  3+16+256,  // Unordered or Less
	SPARC_CC_FCC_LG  =  2+16+256,  // Less or Greater
	SPARC_CC_FCC_NE  =  1+16+256,  // Not Equal
	SPARC_CC_FCC_E   =  9+16+256,  // Equal
	SPARC_CC_FCC_UE  = 10+16+256,  // Unordered or Equal
	SPARC_CC_FCC_GE  = 11+16+256,  // Greater or Equal
	SPARC_CC_FCC_UGE = 12+16+256,  // Unordered or Greater or Equal
	SPARC_CC_FCC_LE  = 13+16+256,  // Less or Equal
	SPARC_CC_FCC_ULE = 14+16+256,  // Unordered or Less or Equal
	SPARC_CC_FCC_O   = 15+16+256,  // Ordered
} sparc_cc;

//> Branch hint
typedef enum sparc_hint {
	SPARC_HINT_INVALID = 0,	// no hint
	SPARC_HINT_A	= 1 << 0,	// annul delay slot instruction
	SPARC_HINT_PT	= 1 << 1,	// branch taken
	SPARC_HINT_PN	= 1 << 2,	// branch NOT taken
} sparc_hint;

//> Operand type for instruction's operands
typedef enum sparc_op_type {
	SPARC_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	SPARC_OP_REG, // = CS_OP_REG (Register operand).
	SPARC_OP_IMM, // = CS_OP_IMM (Immediate operand).
	SPARC_OP_MEM, // = CS_OP_MEM (Memory operand).
} sparc_op_type;

// Instruction's operand referring to memory
// This is associated with SPARC_OP_MEM operand type above
typedef struct sparc_op_mem {
	uint8_t base;	// base register
	uint8_t index;	// index register
	int32_t disp;	// displacement/offset value
} sparc_op_mem;

// Instruction operand
typedef struct cs_sparc_op {
	sparc_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG operand
		int32_t imm;		// immediate value for IMM operand
		sparc_op_mem mem;		// base/disp value for MEM operand
	};
} cs_sparc_op;

// Instruction structure
typedef struct cs_sparc {
	sparc_cc cc;	// code condition for this insn
	sparc_hint hint;	// branch hint: encoding as bitwise OR of sparc_hint.
	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_sparc_op operands[4]; // operands for this instruction.
} cs_sparc;

//> SPARC registers
typedef enum sparc_reg {
	SPARC_REG_INVALID = 0,

	SPARC_REG_F0,
	SPARC_REG_F1,
	SPARC_REG_F2,
	SPARC_REG_F3,
	SPARC_REG_F4,
	SPARC_REG_F5,
	SPARC_REG_F6,
	SPARC_REG_F7,
	SPARC_REG_F8,
	SPARC_REG_F9,
	SPARC_REG_F10,
	SPARC_REG_F11,
	SPARC_REG_F12,
	SPARC_REG_F13,
	SPARC_REG_F14,
	SPARC_REG_F15,
	SPARC_REG_F16,
	SPARC_REG_F17,
	SPARC_REG_F18,
	SPARC_REG_F19,
	SPARC_REG_F20,
	SPARC_REG_F21,
	SPARC_REG_F22,
	SPARC_REG_F23,
	SPARC_REG_F24,
	SPARC_REG_F25,
	SPARC_REG_F26,
	SPARC_REG_F27,
	SPARC_REG_F28,
	SPARC_REG_F29,
	SPARC_REG_F30,
	SPARC_REG_F31,
	SPARC_REG_F32,
	SPARC_REG_F34,
	SPARC_REG_F36,
	SPARC_REG_F38,
	SPARC_REG_F40,
	SPARC_REG_F42,
	SPARC_REG_F44,
	SPARC_REG_F46,
	SPARC_REG_F48,
	SPARC_REG_F50,
	SPARC_REG_F52,
	SPARC_REG_F54,
	SPARC_REG_F56,
	SPARC_REG_F58,
	SPARC_REG_F60,
	SPARC_REG_F62,
	SPARC_REG_FCC0,	// Floating condition codes
	SPARC_REG_FCC1,
	SPARC_REG_FCC2,
	SPARC_REG_FCC3,
	SPARC_REG_FP,
	SPARC_REG_G0,
	SPARC_REG_G1,
	SPARC_REG_G2,
	SPARC_REG_G3,
	SPARC_REG_G4,
	SPARC_REG_G5,
	SPARC_REG_G6,
	SPARC_REG_G7,
	SPARC_REG_I0,
	SPARC_REG_I1,
	SPARC_REG_I2,
	SPARC_REG_I3,
	SPARC_REG_I4,
	SPARC_REG_I5,
	SPARC_REG_I7,
	SPARC_REG_ICC,	// Integer condition codes
	SPARC_REG_L0,
	SPARC_REG_L1,
	SPARC_REG_L2,
	SPARC_REG_L3,
	SPARC_REG_L4,
	SPARC_REG_L5,
	SPARC_REG_L6,
	SPARC_REG_L7,
	SPARC_REG_O0,
	SPARC_REG_O1,
	SPARC_REG_O2,
	SPARC_REG_O3,
	SPARC_REG_O4,
	SPARC_REG_O5,
	SPARC_REG_O7,
	SPARC_REG_SP,
	SPARC_REG_Y,

	// special register
	SPARC_REG_XCC,

	SPARC_REG_ENDING,   // <-- mark the end of the list of registers

	// extras
	SPARC_REG_O6 = SPARC_REG_SP,
	SPARC_REG_I6 = SPARC_REG_FP,
} sparc_reg;

//> SPARC instruction
typedef enum sparc_insn {
	SPARC_INS_INVALID = 0,

	SPARC_INS_ADDCC,
	SPARC_INS_ADDX,
	SPARC_INS_ADDXCC,
	SPARC_INS_ADDXC,
	SPARC_INS_ADDXCCC,
	SPARC_INS_ADD,
	SPARC_INS_ALIGNADDR,
	SPARC_INS_ALIGNADDRL,
	SPARC_INS_ANDCC,
	SPARC_INS_ANDNCC,
	SPARC_INS_ANDN,
	SPARC_INS_AND,
	SPARC_INS_ARRAY16,
	SPARC_INS_ARRAY32,
	SPARC_INS_ARRAY8,
	SPARC_INS_B,
	SPARC_INS_JMP,
	SPARC_INS_BMASK,
	SPARC_INS_FB,
	SPARC_INS_BRGEZ,
	SPARC_INS_BRGZ,
	SPARC_INS_BRLEZ,
	SPARC_INS_BRLZ,
	SPARC_INS_BRNZ,
	SPARC_INS_BRZ,
	SPARC_INS_BSHUFFLE,
	SPARC_INS_CALL,
	SPARC_INS_CASX,
	SPARC_INS_CAS,
	SPARC_INS_CMASK16,
	SPARC_INS_CMASK32,
	SPARC_INS_CMASK8,
	SPARC_INS_CMP,
	SPARC_INS_EDGE16,
	SPARC_INS_EDGE16L,
	SPARC_INS_EDGE16LN,
	SPARC_INS_EDGE16N,
	SPARC_INS_EDGE32,
	SPARC_INS_EDGE32L,
	SPARC_INS_EDGE32LN,
	SPARC_INS_EDGE32N,
	SPARC_INS_EDGE8,
	SPARC_INS_EDGE8L,
	SPARC_INS_EDGE8LN,
	SPARC_INS_EDGE8N,
	SPARC_INS_FABSD,
	SPARC_INS_FABSQ,
	SPARC_INS_FABSS,
	SPARC_INS_FADDD,
	SPARC_INS_FADDQ,
	SPARC_INS_FADDS,
	SPARC_INS_FALIGNDATA,
	SPARC_INS_FAND,
	SPARC_INS_FANDNOT1,
	SPARC_INS_FANDNOT1S,
	SPARC_INS_FANDNOT2,
	SPARC_INS_FANDNOT2S,
	SPARC_INS_FANDS,
	SPARC_INS_FCHKSM16,
	SPARC_INS_FCMPD,
	SPARC_INS_FCMPEQ16,
	SPARC_INS_FCMPEQ32,
	SPARC_INS_FCMPGT16,
	SPARC_INS_FCMPGT32,
	SPARC_INS_FCMPLE16,
	SPARC_INS_FCMPLE32,
	SPARC_INS_FCMPNE16,
	SPARC_INS_FCMPNE32,
	SPARC_INS_FCMPQ,
	SPARC_INS_FCMPS,
	SPARC_INS_FDIVD,
	SPARC_INS_FDIVQ,
	SPARC_INS_FDIVS,
	SPARC_INS_FDMULQ,
	SPARC_INS_FDTOI,
	SPARC_INS_FDTOQ,
	SPARC_INS_FDTOS,
	SPARC_INS_FDTOX,
	SPARC_INS_FEXPAND,
	SPARC_INS_FHADDD,
	SPARC_INS_FHADDS,
	SPARC_INS_FHSUBD,
	SPARC_INS_FHSUBS,
	SPARC_INS_FITOD,
	SPARC_INS_FITOQ,
	SPARC_INS_FITOS,
	SPARC_INS_FLCMPD,
	SPARC_INS_FLCMPS,
	SPARC_INS_FLUSHW,
	SPARC_INS_FMEAN16,
	SPARC_INS_FMOVD,
	SPARC_INS_FMOVQ,
	SPARC_INS_FMOVRDGEZ,
	SPARC_INS_FMOVRQGEZ,
	SPARC_INS_FMOVRSGEZ,
	SPARC_INS_FMOVRDGZ,
	SPARC_INS_FMOVRQGZ,
	SPARC_INS_FMOVRSGZ,
	SPARC_INS_FMOVRDLEZ,
	SPARC_INS_FMOVRQLEZ,
	SPARC_INS_FMOVRSLEZ,
	SPARC_INS_FMOVRDLZ,
	SPARC_INS_FMOVRQLZ,
	SPARC_INS_FMOVRSLZ,
	SPARC_INS_FMOVRDNZ,
	SPARC_INS_FMOVRQNZ,
	SPARC_INS_FMOVRSNZ,
	SPARC_INS_FMOVRDZ,
	SPARC_INS_FMOVRQZ,
	SPARC_INS_FMOVRSZ,
	SPARC_INS_FMOVS,
	SPARC_INS_FMUL8SUX16,
	SPARC_INS_FMUL8ULX16,
	SPARC_INS_FMUL8X16,
	SPARC_INS_FMUL8X16AL,
	SPARC_INS_FMUL8X16AU,
	SPARC_INS_FMULD,
	SPARC_INS_FMULD8SUX16,
	SPARC_INS_FMULD8ULX16,
	SPARC_INS_FMULQ,
	SPARC_INS_FMULS,
	SPARC_INS_FNADDD,
	SPARC_INS_FNADDS,
	SPARC_INS_FNAND,
	SPARC_INS_FNANDS,
	SPARC_INS_FNEGD,
	SPARC_INS_FNEGQ,
	SPARC_INS_FNEGS,
	SPARC_INS_FNHADDD,
	SPARC_INS_FNHADDS,
	SPARC_INS_FNOR,
	SPARC_INS_FNORS,
	SPARC_INS_FNOT1,
	SPARC_INS_FNOT1S,
	SPARC_INS_FNOT2,
	SPARC_INS_FNOT2S,
	SPARC_INS_FONE,
	SPARC_INS_FONES,
	SPARC_INS_FOR,
	SPARC_INS_FORNOT1,
	SPARC_INS_FORNOT1S,
	SPARC_INS_FORNOT2,
	SPARC_INS_FORNOT2S,
	SPARC_INS_FORS,
	SPARC_INS_FPACK16,
	SPARC_INS_FPACK32,
	SPARC_INS_FPACKFIX,
	SPARC_INS_FPADD16,
	SPARC_INS_FPADD16S,
	SPARC_INS_FPADD32,
	SPARC_INS_FPADD32S,
	SPARC_INS_FPADD64,
	SPARC_INS_FPMERGE,
	SPARC_INS_FPSUB16,
	SPARC_INS_FPSUB16S,
	SPARC_INS_FPSUB32,
	SPARC_INS_FPSUB32S,
	SPARC_INS_FQTOD,
	SPARC_INS_FQTOI,
	SPARC_INS_FQTOS,
	SPARC_INS_FQTOX,
	SPARC_INS_FSLAS16,
	SPARC_INS_FSLAS32,
	SPARC_INS_FSLL16,
	SPARC_INS_FSLL32,
	SPARC_INS_FSMULD,
	SPARC_INS_FSQRTD,
	SPARC_INS_FSQRTQ,
	SPARC_INS_FSQRTS,
	SPARC_INS_FSRA16,
	SPARC_INS_FSRA32,
	SPARC_INS_FSRC1,
	SPARC_INS_FSRC1S,
	SPARC_INS_FSRC2,
	SPARC_INS_FSRC2S,
	SPARC_INS_FSRL16,
	SPARC_INS_FSRL32,
	SPARC_INS_FSTOD,
	SPARC_INS_FSTOI,
	SPARC_INS_FSTOQ,
	SPARC_INS_FSTOX,
	SPARC_INS_FSUBD,
	SPARC_INS_FSUBQ,
	SPARC_INS_FSUBS,
	SPARC_INS_FXNOR,
	SPARC_INS_FXNORS,
	SPARC_INS_FXOR,
	SPARC_INS_FXORS,
	SPARC_INS_FXTOD,
	SPARC_INS_FXTOQ,
	SPARC_INS_FXTOS,
	SPARC_INS_FZERO,
	SPARC_INS_FZEROS,
	SPARC_INS_JMPL,
	SPARC_INS_LDD,
	SPARC_INS_LD,
	SPARC_INS_LDQ,
	SPARC_INS_LDSB,
	SPARC_INS_LDSH,
	SPARC_INS_LDSW,
	SPARC_INS_LDUB,
	SPARC_INS_LDUH,
	SPARC_INS_LDX,
	SPARC_INS_LZCNT,
	SPARC_INS_MEMBAR,
	SPARC_INS_MOVDTOX,
	SPARC_INS_MOV,
	SPARC_INS_MOVRGEZ,
	SPARC_INS_MOVRGZ,
	SPARC_INS_MOVRLEZ,
	SPARC_INS_MOVRLZ,
	SPARC_INS_MOVRNZ,
	SPARC_INS_MOVRZ,
	SPARC_INS_MOVSTOSW,
	SPARC_INS_MOVSTOUW,
	SPARC_INS_MULX,
	SPARC_INS_NOP,
	SPARC_INS_ORCC,
	SPARC_INS_ORNCC,
	SPARC_INS_ORN,
	SPARC_INS_OR,
	SPARC_INS_PDIST,
	SPARC_INS_PDISTN,
	SPARC_INS_POPC,
	SPARC_INS_RD,
	SPARC_INS_RESTORE,
	SPARC_INS_RETT,
	SPARC_INS_SAVE,
	SPARC_INS_SDIVCC,
	SPARC_INS_SDIVX,
	SPARC_INS_SDIV,
	SPARC_INS_SETHI,
	SPARC_INS_SHUTDOWN,
	SPARC_INS_SIAM,
	SPARC_INS_SLLX,
	SPARC_INS_SLL,
	SPARC_INS_SMULCC,
	SPARC_INS_SMUL,
	SPARC_INS_SRAX,
	SPARC_INS_SRA,
	SPARC_INS_SRLX,
	SPARC_INS_SRL,
	SPARC_INS_STBAR,
	SPARC_INS_STB,
	SPARC_INS_STD,
	SPARC_INS_ST,
	SPARC_INS_STH,
	SPARC_INS_STQ,
	SPARC_INS_STX,
	SPARC_INS_SUBCC,
	SPARC_INS_SUBX,
	SPARC_INS_SUBXCC,
	SPARC_INS_SUB,
	SPARC_INS_SWAP,
	SPARC_INS_TADDCCTV,
	SPARC_INS_TADDCC,
	SPARC_INS_T,
	SPARC_INS_TSUBCCTV,
	SPARC_INS_TSUBCC,
	SPARC_INS_UDIVCC,
	SPARC_INS_UDIVX,
	SPARC_INS_UDIV,
	SPARC_INS_UMULCC,
	SPARC_INS_UMULXHI,
	SPARC_INS_UMUL,
	SPARC_INS_UNIMP,
	SPARC_INS_FCMPED,
	SPARC_INS_FCMPEQ,
	SPARC_INS_FCMPES,
	SPARC_INS_WR,
	SPARC_INS_XMULX,
	SPARC_INS_XMULXHI,
	SPARC_INS_XNORCC,
	SPARC_INS_XNOR,
	SPARC_INS_XORCC,
	SPARC_INS_XOR,

	// alias instructions
	SPARC_INS_RET,
	SPARC_INS_RETL,

	SPARC_INS_ENDING,   // <-- mark the end of the list of instructions
} sparc_insn;

//> Group of SPARC instructions
typedef enum sparc_insn_group {
	SPARC_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	SPARC_GRP_JUMP,	// = CS_GRP_JUMP

	//> Architecture-specific groups
	SPARC_GRP_HARDQUAD = 128,
	SPARC_GRP_V9,
	SPARC_GRP_VIS,
	SPARC_GRP_VIS2,
	SPARC_GRP_VIS3, 
	SPARC_GRP_32BIT,
	SPARC_GRP_64BIT,

	SPARC_GRP_ENDING,   // <-- mark the end of the list of groups
} sparc_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`Capstone/include/systemz.h`:

```h
#ifndef CAPSTONE_SYSTEMZ_H
#define CAPSTONE_SYSTEMZ_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Enums corresponding to SystemZ condition codes
typedef enum sysz_cc {
	SYSZ_CC_INVALID = 0,	// invalid CC (default)

	SYSZ_CC_O,
	SYSZ_CC_H,
	SYSZ_CC_NLE,
	SYSZ_CC_L,
	SYSZ_CC_NHE,
	SYSZ_CC_LH,
	SYSZ_CC_NE,
	SYSZ_CC_E,
	SYSZ_CC_NLH,
	SYSZ_CC_HE,
	SYSZ_CC_NL,
	SYSZ_CC_LE,
	SYSZ_CC_NH,
	SYSZ_CC_NO,
} sysz_cc;

//> Operand type for instruction's operands
typedef enum sysz_op_type {
	SYSZ_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	SYSZ_OP_REG, // = CS_OP_REG (Register operand).
	SYSZ_OP_IMM, // = CS_OP_IMM (Immediate operand).
	SYSZ_OP_MEM, // = CS_OP_MEM (Memory operand).
	SYSZ_OP_ACREG = 64,	// Access register operand.
} sysz_op_type;

// Instruction's operand referring to memory
// This is associated with SYSZ_OP_MEM operand type above
typedef struct sysz_op_mem {
	uint8_t base;	// base register
	uint8_t index;	// index register
	uint64_t length;	// BDLAddr operand
	int64_t disp;	// displacement/offset value
} sysz_op_mem;

// Instruction operand
typedef struct cs_sysz_op {
	sysz_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG operand
		int64_t imm;		// immediate value for IMM operand
		sysz_op_mem mem;		// base/disp value for MEM operand
	};
} cs_sysz_op;

// Instruction structure
typedef struct cs_sysz {
	sysz_cc cc;		// Code condition
	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_sysz_op operands[6]; // operands for this instruction.
} cs_sysz;

//> SystemZ registers
typedef enum sysz_reg {
	SYSZ_REG_INVALID = 0,

	SYSZ_REG_0, 
	SYSZ_REG_1, 
	SYSZ_REG_2, 
	SYSZ_REG_3, 
	SYSZ_REG_4, 
	SYSZ_REG_5, 
	SYSZ_REG_6, 
	SYSZ_REG_7, 
	SYSZ_REG_8, 
	SYSZ_REG_9, 
	SYSZ_REG_10,
	SYSZ_REG_11,
	SYSZ_REG_12,
	SYSZ_REG_13,
	SYSZ_REG_14,
	SYSZ_REG_15,
	SYSZ_REG_CC,
	SYSZ_REG_F0,
	SYSZ_REG_F1,
	SYSZ_REG_F2,
	SYSZ_REG_F3,
	SYSZ_REG_F4,
	SYSZ_REG_F5,
	SYSZ_REG_F6,
	SYSZ_REG_F7,
	SYSZ_REG_F8,
	SYSZ_REG_F9,
	SYSZ_REG_F10,
	SYSZ_REG_F11,
	SYSZ_REG_F12,
	SYSZ_REG_F13,
	SYSZ_REG_F14,
	SYSZ_REG_F15,

	SYSZ_REG_R0L,

	SYSZ_REG_ENDING,
} sysz_reg;

//> SystemZ instruction
typedef enum sysz_insn {
	SYSZ_INS_INVALID = 0,

	SYSZ_INS_A,
	SYSZ_INS_ADB,
	SYSZ_INS_ADBR,
	SYSZ_INS_AEB,
	SYSZ_INS_AEBR,
	SYSZ_INS_AFI,
	SYSZ_INS_AG,
	SYSZ_INS_AGF,
	SYSZ_INS_AGFI,
	SYSZ_INS_AGFR,
	SYSZ_INS_AGHI,
	SYSZ_INS_AGHIK,
	SYSZ_INS_AGR,
	SYSZ_INS_AGRK,
	SYSZ_INS_AGSI,
	SYSZ_INS_AH,
	SYSZ_INS_AHI,
	SYSZ_INS_AHIK,
	SYSZ_INS_AHY,
	SYSZ_INS_AIH,
	SYSZ_INS_AL,
	SYSZ_INS_ALC,
	SYSZ_INS_ALCG,
	SYSZ_INS_ALCGR,
	SYSZ_INS_ALCR,
	SYSZ_INS_ALFI,
	SYSZ_INS_ALG,
	SYSZ_INS_ALGF,
	SYSZ_INS_ALGFI,
	SYSZ_INS_ALGFR,
	SYSZ_INS_ALGHSIK,
	SYSZ_INS_ALGR,
	SYSZ_INS_ALGRK,
	SYSZ_INS_ALHSIK,
	SYSZ_INS_ALR,
	SYSZ_INS_ALRK,
	SYSZ_INS_ALY,
	SYSZ_INS_AR,
	SYSZ_INS_ARK,
	SYSZ_INS_ASI,
	SYSZ_INS_AXBR,
	SYSZ_INS_AY,
	SYSZ_INS_BCR,
	SYSZ_INS_BRC,
	SYSZ_INS_BRCL,
	SYSZ_INS_CGIJ,
	SYSZ_INS_CGRJ,
	SYSZ_INS_CIJ,
	SYSZ_INS_CLGIJ,
	SYSZ_INS_CLGRJ,
	SYSZ_INS_CLIJ,
	SYSZ_INS_CLRJ,
	SYSZ_INS_CRJ,
	SYSZ_INS_BER,
	SYSZ_INS_JE,
	SYSZ_INS_JGE,
	SYSZ_INS_LOCE,
	SYSZ_INS_LOCGE,
	SYSZ_INS_LOCGRE,
	SYSZ_INS_LOCRE,
	SYSZ_INS_STOCE,
	SYSZ_INS_STOCGE,
	SYSZ_INS_BHR,
	SYSZ_INS_BHER,
	SYSZ_INS_JHE,
	SYSZ_INS_JGHE,
	SYSZ_INS_LOCHE,
	SYSZ_INS_LOCGHE,
	SYSZ_INS_LOCGRHE,
	SYSZ_INS_LOCRHE,
	SYSZ_INS_STOCHE,
	SYSZ_INS_STOCGHE,
	SYSZ_INS_JH,
	SYSZ_INS_JGH,
	SYSZ_INS_LOCH,
	SYSZ_INS_LOCGH,
	SYSZ_INS_LOCGRH,
	SYSZ_INS_LOCRH,
	SYSZ_INS_STOCH,
	SYSZ_INS_STOCGH,
	SYSZ_INS_CGIJNLH,
	SYSZ_INS_CGRJNLH,
	SYSZ_INS_CIJNLH,
	SYSZ_INS_CLGIJNLH,
	SYSZ_INS_CLGRJNLH,
	SYSZ_INS_CLIJNLH,
	SYSZ_INS_CLRJNLH,
	SYSZ_INS_CRJNLH,
	SYSZ_INS_CGIJE,
	SYSZ_INS_CGRJE,
	SYSZ_INS_CIJE,
	SYSZ_INS_CLGIJE,
	SYSZ_INS_CLGRJE,
	SYSZ_INS_CLIJE,
	SYSZ_INS_CLRJE,
	SYSZ_INS_CRJE,
	SYSZ_INS_CGIJNLE,
	SYSZ_INS_CGRJNLE,
	SYSZ_INS_CIJNLE,
	SYSZ_INS_CLGIJNLE,
	SYSZ_INS_CLGRJNLE,
	SYSZ_INS_CLIJNLE,
	SYSZ_INS_CLRJNLE,
	SYSZ_INS_CRJNLE,
	SYSZ_INS_CGIJH,
	SYSZ_INS_CGRJH,
	SYSZ_INS_CIJH,
	SYSZ_INS_CLGIJH,
	SYSZ_INS_CLGRJH,
	SYSZ_INS_CLIJH,
	SYSZ_INS_CLRJH,
	SYSZ_INS_CRJH,
	SYSZ_INS_CGIJNL,
	SYSZ_INS_CGRJNL,
	SYSZ_INS_CIJNL,
	SYSZ_INS_CLGIJNL,
	SYSZ_INS_CLGRJNL,
	SYSZ_INS_CLIJNL,
	SYSZ_INS_CLRJNL,
	SYSZ_INS_CRJNL,
	SYSZ_INS_CGIJHE,
	SYSZ_INS_CGRJHE,
	SYSZ_INS_CIJHE,
	SYSZ_INS_CLGIJHE,
	SYSZ_INS_CLGRJHE,
	SYSZ_INS_CLIJHE,
	SYSZ_INS_CLRJHE,
	SYSZ_INS_CRJHE,
	SYSZ_INS_CGIJNHE,
	SYSZ_INS_CGRJNHE,
	SYSZ_INS_CIJNHE,
	SYSZ_INS_CLGIJNHE,
	SYSZ_INS_CLGRJNHE,
	SYSZ_INS_CLIJNHE,
	SYSZ_INS_CLRJNHE,
	SYSZ_INS_CRJNHE,
	SYSZ_INS_CGIJL,
	SYSZ_INS_CGRJL,
	SYSZ_INS_CIJL,
	SYSZ_INS_CLGIJL,
	SYSZ_INS_CLGRJL,
	SYSZ_INS_CLIJL,
	SYSZ_INS_CLRJL,
	SYSZ_INS_CRJL,
	SYSZ_INS_CGIJNH,
	SYSZ_INS_CGRJNH,
	SYSZ_INS_CIJNH,
	SYSZ_INS_CLGIJNH,
	SYSZ_INS_CLGRJNH,
	SYSZ_INS_CLIJNH,
	SYSZ_INS_CLRJNH,
	SYSZ_INS_CRJNH,
	SYSZ_INS_CGIJLE,
	SYSZ_INS_CGRJLE,
	SYSZ_INS_CIJLE,
	SYSZ_INS_CLGIJLE,
	SYSZ_INS_CLGRJLE,
	SYSZ_INS_CLIJLE,
	SYSZ_INS_CLRJLE,
	SYSZ_INS_CRJLE,
	SYSZ_INS_CGIJNE,
	SYSZ_INS_CGRJNE,
	SYSZ_INS_CIJNE,
	SYSZ_INS_CLGIJNE,
	SYSZ_INS_CLGRJNE,
	SYSZ_INS_CLIJNE,
	SYSZ_INS_CLRJNE,
	SYSZ_INS_CRJNE,
	SYSZ_INS_CGIJLH,
	SYSZ_INS_CGRJLH,
	SYSZ_INS_CIJLH,
	SYSZ_INS_CLGIJLH,
	SYSZ_INS_CLGRJLH,
	SYSZ_INS_CLIJLH,
	SYSZ_INS_CLRJLH,
	SYSZ_INS_CRJLH,
	SYSZ_INS_BLR,
	SYSZ_INS_BLER,
	SYSZ_INS_JLE,
	SYSZ_INS_JGLE,
	SYSZ_INS_LOCLE,
	SYSZ_INS_LOCGLE,
	SYSZ_INS_LOCGRLE,
	SYSZ_INS_LOCRLE,
	SYSZ_INS_STOCLE,
	SYSZ_INS_STOCGLE,
	SYSZ_INS_BLHR,
	SYSZ_INS_JLH,
	SYSZ_INS_JGLH,
	SYSZ_INS_LOCLH,
	SYSZ_INS_LOCGLH,
	SYSZ_INS_LOCGRLH,
	SYSZ_INS_LOCRLH,
	SYSZ_INS_STOCLH,
	SYSZ_INS_STOCGLH,
	SYSZ_INS_JL,
	SYSZ_INS_JGL,
	SYSZ_INS_LOCL,
	SYSZ_INS_LOCGL,
	SYSZ_INS_LOCGRL,
	SYSZ_INS_LOCRL,
	SYSZ_INS_LOC,
	SYSZ_INS_LOCG,
	SYSZ_INS_LOCGR,
	SYSZ_INS_LOCR,
	SYSZ_INS_STOCL,
	SYSZ_INS_STOCGL,
	SYSZ_INS_BNER,
	SYSZ_INS_JNE,
	SYSZ_INS_JGNE,
	SYSZ_INS_LOCNE,
	SYSZ_INS_LOCGNE,
	SYSZ_INS_LOCGRNE,
	SYSZ_INS_LOCRNE,
	SYSZ_INS_STOCNE,
	SYSZ_INS_STOCGNE,
	SYSZ_INS_BNHR,
	SYSZ_INS_BNHER,
	SYSZ_INS_JNHE,
	SYSZ_INS_JGNHE,
	SYSZ_INS_LOCNHE,
	SYSZ_INS_LOCGNHE,
	SYSZ_INS_LOCGRNHE,
	SYSZ_INS_LOCRNHE,
	SYSZ_INS_STOCNHE,
	SYSZ_INS_STOCGNHE,
	SYSZ_INS_JNH,
	SYSZ_INS_JGNH,
	SYSZ_INS_LOCNH,
	SYSZ_INS_LOCGNH,
	SYSZ_INS_LOCGRNH,
	SYSZ_INS_LOCRNH,
	SYSZ_INS_STOCNH,
	SYSZ_INS_STOCGNH,
	SYSZ_INS_BNLR,
	SYSZ_INS_BNLER,
	SYSZ_INS_JNLE,
	SYSZ_INS_JGNLE,
	SYSZ_INS_LOCNLE,
	SYSZ_INS_LOCGNLE,
	SYSZ_INS_LOCGRNLE,
	SYSZ_INS_LOCRNLE,
	SYSZ_INS_STOCNLE,
	SYSZ_INS_STOCGNLE,
	SYSZ_INS_BNLHR,
	SYSZ_INS_JNLH,
	SYSZ_INS_JGNLH,
	SYSZ_INS_LOCNLH,
	SYSZ_INS_LOCGNLH,
	SYSZ_INS_LOCGRNLH,
	SYSZ_INS_LOCRNLH,
	SYSZ_INS_STOCNLH,
	SYSZ_INS_STOCGNLH,
	SYSZ_INS_JNL,
	SYSZ_INS_JGNL,
	SYSZ_INS_LOCNL,
	SYSZ_INS_LOCGNL,
	SYSZ_INS_LOCGRNL,
	SYSZ_INS_LOCRNL,
	SYSZ_INS_STOCNL,
	SYSZ_INS_STOCGNL,
	SYSZ_INS_BNOR,
	SYSZ_INS_JNO,
	SYSZ_INS_JGNO,
	SYSZ_INS_LOCNO,
	SYSZ_INS_LOCGNO,
	SYSZ_INS_LOCGRNO,
	SYSZ_INS_LOCRNO,
	SYSZ_INS_STOCNO,
	SYSZ_INS_STOCGNO,
	SYSZ_INS_BOR,
	SYSZ_INS_JO,
	SYSZ_INS_JGO,
	SYSZ_INS_LOCO,
	SYSZ_INS_LOCGO,
	SYSZ_INS_LOCGRO,
	SYSZ_INS_LOCRO,
	SYSZ_INS_STOCO,
	SYSZ_INS_STOCGO,
	SYSZ_INS_STOC,
	SYSZ_INS_STOCG,
	SYSZ_INS_BASR,
	SYSZ_INS_BR,
	SYSZ_INS_BRAS,
	SYSZ_INS_BRASL,
	SYSZ_INS_J,
	SYSZ_INS_JG,
	SYSZ_INS_BRCT,
	SYSZ_INS_BRCTG,
	SYSZ_INS_C,
	SYSZ_INS_CDB,
	SYSZ_INS_CDBR,
	SYSZ_INS_CDFBR,
	SYSZ_INS_CDGBR,
	SYSZ_INS_CDLFBR,
	SYSZ_INS_CDLGBR,
	SYSZ_INS_CEB,
	SYSZ_INS_CEBR,
	SYSZ_INS_CEFBR,
	SYSZ_INS_CEGBR,
	SYSZ_INS_CELFBR,
	SYSZ_INS_CELGBR,
	SYSZ_INS_CFDBR,
	SYSZ_INS_CFEBR,
	SYSZ_INS_CFI,
	SYSZ_INS_CFXBR,
	SYSZ_INS_CG,
	SYSZ_INS_CGDBR,
	SYSZ_INS_CGEBR,
	SYSZ_INS_CGF,
	SYSZ_INS_CGFI,
	SYSZ_INS_CGFR,
	SYSZ_INS_CGFRL,
	SYSZ_INS_CGH,
	SYSZ_INS_CGHI,
	SYSZ_INS_CGHRL,
	SYSZ_INS_CGHSI,
	SYSZ_INS_CGR,
	SYSZ_INS_CGRL,
	SYSZ_INS_CGXBR,
	SYSZ_INS_CH,
	SYSZ_INS_CHF,
	SYSZ_INS_CHHSI,
	SYSZ_INS_CHI,
	SYSZ_INS_CHRL,
	SYSZ_INS_CHSI,
	SYSZ_INS_CHY,
	SYSZ_INS_CIH,
	SYSZ_INS_CL,
	SYSZ_INS_CLC,
	SYSZ_INS_CLFDBR,
	SYSZ_INS_CLFEBR,
	SYSZ_INS_CLFHSI,
	SYSZ_INS_CLFI,
	SYSZ_INS_CLFXBR,
	SYSZ_INS_CLG,
	SYSZ_INS_CLGDBR,
	SYSZ_INS_CLGEBR,
	SYSZ_INS_CLGF,
	SYSZ_INS_CLGFI,
	SYSZ_INS_CLGFR,
	SYSZ_INS_CLGFRL,
	SYSZ_INS_CLGHRL,
	SYSZ_INS_CLGHSI,
	SYSZ_INS_CLGR,
	SYSZ_INS_CLGRL,
	SYSZ_INS_CLGXBR,
	SYSZ_INS_CLHF,
	SYSZ_INS_CLHHSI,
	SYSZ_INS_CLHRL,
	SYSZ_INS_CLI,
	SYSZ_INS_CLIH,
	SYSZ_INS_CLIY,
	SYSZ_INS_CLR,
	SYSZ_INS_CLRL,
	SYSZ_INS_CLST,
	SYSZ_INS_CLY,
	SYSZ_INS_CPSDR,
	SYSZ_INS_CR,
	SYSZ_INS_CRL,
	SYSZ_INS_CS,
	SYSZ_INS_CSG,
	SYSZ_INS_CSY,
	SYSZ_INS_CXBR,
	SYSZ_INS_CXFBR,
	SYSZ_INS_CXGBR,
	SYSZ_INS_CXLFBR,
	SYSZ_INS_CXLGBR,
	SYSZ_INS_CY,
	SYSZ_INS_DDB,
	SYSZ_INS_DDBR,
	SYSZ_INS_DEB,
	SYSZ_INS_DEBR,
	SYSZ_INS_DL,
	SYSZ_INS_DLG,
	SYSZ_INS_DLGR,
	SYSZ_INS_DLR,
	SYSZ_INS_DSG,
	SYSZ_INS_DSGF,
	SYSZ_INS_DSGFR,
	SYSZ_INS_DSGR,
	SYSZ_INS_DXBR,
	SYSZ_INS_EAR,
	SYSZ_INS_FIDBR,
	SYSZ_INS_FIDBRA,
	SYSZ_INS_FIEBR,
	SYSZ_INS_FIEBRA,
	SYSZ_INS_FIXBR,
	SYSZ_INS_FIXBRA,
	SYSZ_INS_FLOGR,
	SYSZ_INS_IC,
	SYSZ_INS_ICY,
	SYSZ_INS_IIHF,
	SYSZ_INS_IIHH,
	SYSZ_INS_IIHL,
	SYSZ_INS_IILF,
	SYSZ_INS_IILH,
	SYSZ_INS_IILL,
	SYSZ_INS_IPM,
	SYSZ_INS_L,
	SYSZ_INS_LA,
	SYSZ_INS_LAA,
	SYSZ_INS_LAAG,
	SYSZ_INS_LAAL,
	SYSZ_INS_LAALG,
	SYSZ_INS_LAN,
	SYSZ_INS_LANG,
	SYSZ_INS_LAO,
	SYSZ_INS_LAOG,
	SYSZ_INS_LARL,
	SYSZ_INS_LAX,
	SYSZ_INS_LAXG,
	SYSZ_INS_LAY,
	SYSZ_INS_LB,
	SYSZ_INS_LBH,
	SYSZ_INS_LBR,
	SYSZ_INS_LCDBR,
	SYSZ_INS_LCEBR,
	SYSZ_INS_LCGFR,
	SYSZ_INS_LCGR,
	SYSZ_INS_LCR,
	SYSZ_INS_LCXBR,
	SYSZ_INS_LD,
	SYSZ_INS_LDEB,
	SYSZ_INS_LDEBR,
	SYSZ_INS_LDGR,
	SYSZ_INS_LDR,
	SYSZ_INS_LDXBR,
	SYSZ_INS_LDXBRA,
	SYSZ_INS_LDY,
	SYSZ_INS_LE,
	SYSZ_INS_LEDBR,
	SYSZ_INS_LEDBRA,
	SYSZ_INS_LER,
	SYSZ_INS_LEXBR,
	SYSZ_INS_LEXBRA,
	SYSZ_INS_LEY,
	SYSZ_INS_LFH,
	SYSZ_INS_LG,
	SYSZ_INS_LGB,
	SYSZ_INS_LGBR,
	SYSZ_INS_LGDR,
	SYSZ_INS_LGF,
	SYSZ_INS_LGFI,
	SYSZ_INS_LGFR,
	SYSZ_INS_LGFRL,
	SYSZ_INS_LGH,
	SYSZ_INS_LGHI,
	SYSZ_INS_LGHR,
	SYSZ_INS_LGHRL,
	SYSZ_INS_LGR,
	SYSZ_INS_LGRL,
	SYSZ_INS_LH,
	SYSZ_INS_LHH,
	SYSZ_INS_LHI,
	SYSZ_INS_LHR,
	SYSZ_INS_LHRL,
	SYSZ_INS_LHY,
	SYSZ_INS_LLC,
	SYSZ_INS_LLCH,
	SYSZ_INS_LLCR,
	SYSZ_INS_LLGC,
	SYSZ_INS_LLGCR,
	SYSZ_INS_LLGF,
	SYSZ_INS_LLGFR,
	SYSZ_INS_LLGFRL,
	SYSZ_INS_LLGH,
	SYSZ_INS_LLGHR,
	SYSZ_INS_LLGHRL,
	SYSZ_INS_LLH,
	SYSZ_INS_LLHH,
	SYSZ_INS_LLHR,
	SYSZ_INS_LLHRL,
	SYSZ_INS_LLIHF,
	SYSZ_INS_LLIHH,
	SYSZ_INS_LLIHL,
	SYSZ_INS_LLILF,
	SYSZ_INS_LLILH,
	SYSZ_INS_LLILL,
	SYSZ_INS_LMG,
	SYSZ_INS_LNDBR,
	SYSZ_INS_LNEBR,
	SYSZ_INS_LNGFR,
	SYSZ_INS_LNGR,
	SYSZ_INS_LNR,
	SYSZ_INS_LNXBR,
	SYSZ_INS_LPDBR,
	SYSZ_INS_LPEBR,
	SYSZ_INS_LPGFR,
	SYSZ_INS_LPGR,
	SYSZ_INS_LPR,
	SYSZ_INS_LPXBR,
	SYSZ_INS_LR,
	SYSZ_INS_LRL,
	SYSZ_INS_LRV,
	SYSZ_INS_LRVG,
	SYSZ_INS_LRVGR,
	SYSZ_INS_LRVR,
	SYSZ_INS_LT,
	SYSZ_INS_LTDBR,
	SYSZ_INS_LTEBR,
	SYSZ_INS_LTG,
	SYSZ_INS_LTGF,
	SYSZ_INS_LTGFR,
	SYSZ_INS_LTGR,
	SYSZ_INS_LTR,
	SYSZ_INS_LTXBR,
	SYSZ_INS_LXDB,
	SYSZ_INS_LXDBR,
	SYSZ_INS_LXEB,
	SYSZ_INS_LXEBR,
	SYSZ_INS_LXR,
	SYSZ_INS_LY,
	SYSZ_INS_LZDR,
	SYSZ_INS_LZER,
	SYSZ_INS_LZXR,
	SYSZ_INS_MADB,
	SYSZ_INS_MADBR,
	SYSZ_INS_MAEB,
	SYSZ_INS_MAEBR,
	SYSZ_INS_MDB,
	SYSZ_INS_MDBR,
	SYSZ_INS_MDEB,
	SYSZ_INS_MDEBR,
	SYSZ_INS_MEEB,
	SYSZ_INS_MEEBR,
	SYSZ_INS_MGHI,
	SYSZ_INS_MH,
	SYSZ_INS_MHI,
	SYSZ_INS_MHY,
	SYSZ_INS_MLG,
	SYSZ_INS_MLGR,
	SYSZ_INS_MS,
	SYSZ_INS_MSDB,
	SYSZ_INS_MSDBR,
	SYSZ_INS_MSEB,
	SYSZ_INS_MSEBR,
	SYSZ_INS_MSFI,
	SYSZ_INS_MSG,
	SYSZ_INS_MSGF,
	SYSZ_INS_MSGFI,
	SYSZ_INS_MSGFR,
	SYSZ_INS_MSGR,
	SYSZ_INS_MSR,
	SYSZ_INS_MSY,
	SYSZ_INS_MVC,
	SYSZ_INS_MVGHI,
	SYSZ_INS_MVHHI,
	SYSZ_INS_MVHI,
	SYSZ_INS_MVI,
	SYSZ_INS_MVIY,
	SYSZ_INS_MVST,
	SYSZ_INS_MXBR,
	SYSZ_INS_MXDB,
	SYSZ_INS_MXDBR,
	SYSZ_INS_N,
	SYSZ_INS_NC,
	SYSZ_INS_NG,
	SYSZ_INS_NGR,
	SYSZ_INS_NGRK,
	SYSZ_INS_NI,
	SYSZ_INS_NIHF,
	SYSZ_INS_NIHH,
	SYSZ_INS_NIHL,
	SYSZ_INS_NILF,
	SYSZ_INS_NILH,
	SYSZ_INS_NILL,
	SYSZ_INS_NIY,
	SYSZ_INS_NR,
	SYSZ_INS_NRK,
	SYSZ_INS_NY,
	SYSZ_INS_O,
	SYSZ_INS_OC,
	SYSZ_INS_OG,
	SYSZ_INS_OGR,
	SYSZ_INS_OGRK,
	SYSZ_INS_OI,
	SYSZ_INS_OIHF,
	SYSZ_INS_OIHH,
	SYSZ_INS_OIHL,
	SYSZ_INS_OILF,
	SYSZ_INS_OILH,
	SYSZ_INS_OILL,
	SYSZ_INS_OIY,
	SYSZ_INS_OR,
	SYSZ_INS_ORK,
	SYSZ_INS_OY,
	SYSZ_INS_PFD,
	SYSZ_INS_PFDRL,
	SYSZ_INS_RISBG,
	SYSZ_INS_RISBHG,
	SYSZ_INS_RISBLG,
	SYSZ_INS_RLL,
	SYSZ_INS_RLLG,
	SYSZ_INS_RNSBG,
	SYSZ_INS_ROSBG,
	SYSZ_INS_RXSBG,
	SYSZ_INS_S,
	SYSZ_INS_SDB,
	SYSZ_INS_SDBR,
	SYSZ_INS_SEB,
	SYSZ_INS_SEBR,
	SYSZ_INS_SG,
	SYSZ_INS_SGF,
	SYSZ_INS_SGFR,
	SYSZ_INS_SGR,
	SYSZ_INS_SGRK,
	SYSZ_INS_SH,
	SYSZ_INS_SHY,
	SYSZ_INS_SL,
	SYSZ_INS_SLB,
	SYSZ_INS_SLBG,
	SYSZ_INS_SLBR,
	SYSZ_INS_SLFI,
	SYSZ_INS_SLG,
	SYSZ_INS_SLBGR,
	SYSZ_INS_SLGF,
	SYSZ_INS_SLGFI,
	SYSZ_INS_SLGFR,
	SYSZ_INS_SLGR,
	SYSZ_INS_SLGRK,
	SYSZ_INS_SLL,
	SYSZ_INS_SLLG,
	SYSZ_INS_SLLK,
	SYSZ_INS_SLR,
	SYSZ_INS_SLRK,
	SYSZ_INS_SLY,
	SYSZ_INS_SQDB,
	SYSZ_INS_SQDBR,
	SYSZ_INS_SQEB,
	SYSZ_INS_SQEBR,
	SYSZ_INS_SQXBR,
	SYSZ_INS_SR,
	SYSZ_INS_SRA,
	SYSZ_INS_SRAG,
	SYSZ_INS_SRAK,
	SYSZ_INS_SRK,
	SYSZ_INS_SRL,
	SYSZ_INS_SRLG,
	SYSZ_INS_SRLK,
	SYSZ_INS_SRST,
	SYSZ_INS_ST,
	SYSZ_INS_STC,
	SYSZ_INS_STCH,
	SYSZ_INS_STCY,
	SYSZ_INS_STD,
	SYSZ_INS_STDY,
	SYSZ_INS_STE,
	SYSZ_INS_STEY,
	SYSZ_INS_STFH,
	SYSZ_INS_STG,
	SYSZ_INS_STGRL,
	SYSZ_INS_STH,
	SYSZ_INS_STHH,
	SYSZ_INS_STHRL,
	SYSZ_INS_STHY,
	SYSZ_INS_STMG,
	SYSZ_INS_STRL,
	SYSZ_INS_STRV,
	SYSZ_INS_STRVG,
	SYSZ_INS_STY,
	SYSZ_INS_SXBR,
	SYSZ_INS_SY,
	SYSZ_INS_TM,
	SYSZ_INS_TMHH,
	SYSZ_INS_TMHL,
	SYSZ_INS_TMLH,
	SYSZ_INS_TMLL,
	SYSZ_INS_TMY,
	SYSZ_INS_X,
	SYSZ_INS_XC,
	SYSZ_INS_XG,
	SYSZ_INS_XGR,
	SYSZ_INS_XGRK,
	SYSZ_INS_XI,
	SYSZ_INS_XIHF,
	SYSZ_INS_XILF,
	SYSZ_INS_XIY,
	SYSZ_INS_XR,
	SYSZ_INS_XRK,
	SYSZ_INS_XY,

	SYSZ_INS_ENDING,   // <-- mark the end of the list of instructions
} sysz_insn;

//> Group of SystemZ instructions
typedef enum sysz_insn_group {
	SYSZ_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	SYSZ_GRP_JUMP,	// = CS_GRP_JUMP

	//> Architecture-specific groups
	SYSZ_GRP_DISTINCTOPS = 128,
	SYSZ_GRP_FPEXTENSION,
	SYSZ_GRP_HIGHWORD,
	SYSZ_GRP_INTERLOCKEDACCESS1,
	SYSZ_GRP_LOADSTOREONCOND,

	SYSZ_GRP_ENDING,   // <-- mark the end of the list of groups
} sysz_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`Capstone/include/x86.h`:

```h
#ifndef CAPSTONE_X86_H
#define CAPSTONE_X86_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>

// Calculate relative address for X86-64, given cs_insn structure
#define X86_REL_ADDR(insn) (insn.address + insn.size + insn.detail->x86.disp)

//> X86 registers
typedef enum x86_reg {
	X86_REG_INVALID = 0,
	X86_REG_AH, X86_REG_AL, X86_REG_AX, X86_REG_BH, X86_REG_BL,
	X86_REG_BP, X86_REG_BPL, X86_REG_BX, X86_REG_CH, X86_REG_CL,
	X86_REG_CS, X86_REG_CX, X86_REG_DH, X86_REG_DI, X86_REG_DIL,
	X86_REG_DL, X86_REG_DS, X86_REG_DX, X86_REG_EAX, X86_REG_EBP,
	X86_REG_EBX, X86_REG_ECX, X86_REG_EDI, X86_REG_EDX, X86_REG_EFLAGS,
	X86_REG_EIP, X86_REG_EIZ, X86_REG_ES, X86_REG_ESI, X86_REG_ESP,
	X86_REG_FPSW, X86_REG_FS, X86_REG_GS, X86_REG_IP, X86_REG_RAX,
	X86_REG_RBP, X86_REG_RBX, X86_REG_RCX, X86_REG_RDI, X86_REG_RDX,
	X86_REG_RIP, X86_REG_RIZ, X86_REG_RSI, X86_REG_RSP, X86_REG_SI,
	X86_REG_SIL, X86_REG_SP, X86_REG_SPL, X86_REG_SS, X86_REG_CR0,
	X86_REG_CR1, X86_REG_CR2, X86_REG_CR3, X86_REG_CR4, X86_REG_CR5,
	X86_REG_CR6, X86_REG_CR7, X86_REG_CR8, X86_REG_CR9, X86_REG_CR10,
	X86_REG_CR11, X86_REG_CR12, X86_REG_CR13, X86_REG_CR14, X86_REG_CR15,
	X86_REG_DR0, X86_REG_DR1, X86_REG_DR2, X86_REG_DR3, X86_REG_DR4,
	X86_REG_DR5, X86_REG_DR6, X86_REG_DR7, X86_REG_FP0, X86_REG_FP1,
	X86_REG_FP2, X86_REG_FP3, X86_REG_FP4, X86_REG_FP5, X86_REG_FP6, X86_REG_FP7,
	X86_REG_K0, X86_REG_K1, X86_REG_K2, X86_REG_K3, X86_REG_K4,
	X86_REG_K5, X86_REG_K6, X86_REG_K7, X86_REG_MM0, X86_REG_MM1,
	X86_REG_MM2, X86_REG_MM3, X86_REG_MM4, X86_REG_MM5, X86_REG_MM6,
	X86_REG_MM7, X86_REG_R8, X86_REG_R9, X86_REG_R10, X86_REG_R11,
	X86_REG_R12, X86_REG_R13, X86_REG_R14, X86_REG_R15,
	X86_REG_ST0, X86_REG_ST1, X86_REG_ST2, X86_REG_ST3,
	X86_REG_ST4, X86_REG_ST5, X86_REG_ST6, X86_REG_ST7,
	X86_REG_XMM0, X86_REG_XMM1, X86_REG_XMM2, X86_REG_XMM3, X86_REG_XMM4,
	X86_REG_XMM5, X86_REG_XMM6, X86_REG_XMM7, X86_REG_XMM8, X86_REG_XMM9,
	X86_REG_XMM10, X86_REG_XMM11, X86_REG_XMM12, X86_REG_XMM13, X86_REG_XMM14,
	X86_REG_XMM15, X86_REG_XMM16, X86_REG_XMM17, X86_REG_XMM18, X86_REG_XMM19,
	X86_REG_XMM20, X86_REG_XMM21, X86_REG_XMM22, X86_REG_XMM23, X86_REG_XMM24,
	X86_REG_XMM25, X86_REG_XMM26, X86_REG_XMM27, X86_REG_XMM28, X86_REG_XMM29,
	X86_REG_XMM30, X86_REG_XMM31, X86_REG_YMM0, X86_REG_YMM1, X86_REG_YMM2,
	X86_REG_YMM3, X86_REG_YMM4, X86_REG_YMM5, X86_REG_YMM6, X86_REG_YMM7,
	X86_REG_YMM8, X86_REG_YMM9, X86_REG_YMM10, X86_REG_YMM11, X86_REG_YMM12,
	X86_REG_YMM13, X86_REG_YMM14, X86_REG_YMM15, X86_REG_YMM16, X86_REG_YMM17,
	X86_REG_YMM18, X86_REG_YMM19, X86_REG_YMM20, X86_REG_YMM21, X86_REG_YMM22,
	X86_REG_YMM23, X86_REG_YMM24, X86_REG_YMM25, X86_REG_YMM26, X86_REG_YMM27,
	X86_REG_YMM28, X86_REG_YMM29, X86_REG_YMM30, X86_REG_YMM31, X86_REG_ZMM0,
	X86_REG_ZMM1, X86_REG_ZMM2, X86_REG_ZMM3, X86_REG_ZMM4, X86_REG_ZMM5,
	X86_REG_ZMM6, X86_REG_ZMM7, X86_REG_ZMM8, X86_REG_ZMM9, X86_REG_ZMM10,
	X86_REG_ZMM11, X86_REG_ZMM12, X86_REG_ZMM13, X86_REG_ZMM14, X86_REG_ZMM15,
	X86_REG_ZMM16, X86_REG_ZMM17, X86_REG_ZMM18, X86_REG_ZMM19, X86_REG_ZMM20,
	X86_REG_ZMM21, X86_REG_ZMM22, X86_REG_ZMM23, X86_REG_ZMM24, X86_REG_ZMM25,
	X86_REG_ZMM26, X86_REG_ZMM27, X86_REG_ZMM28, X86_REG_ZMM29, X86_REG_ZMM30,
	X86_REG_ZMM31, X86_REG_R8B, X86_REG_R9B, X86_REG_R10B, X86_REG_R11B,
	X86_REG_R12B, X86_REG_R13B, X86_REG_R14B, X86_REG_R15B, X86_REG_R8D,
	X86_REG_R9D, X86_REG_R10D, X86_REG_R11D, X86_REG_R12D, X86_REG_R13D,
	X86_REG_R14D, X86_REG_R15D, X86_REG_R8W, X86_REG_R9W, X86_REG_R10W,
	X86_REG_R11W, X86_REG_R12W, X86_REG_R13W, X86_REG_R14W, X86_REG_R15W,

	X86_REG_ENDING		// <-- mark the end of the list of registers
} x86_reg;

//> Operand type for instruction's operands
typedef enum x86_op_type {
	X86_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	X86_OP_REG, // = CS_OP_REG (Register operand).
	X86_OP_IMM, // = CS_OP_IMM (Immediate operand).
	X86_OP_MEM, // = CS_OP_MEM (Memory operand).
	X86_OP_FP,  //  = CS_OP_FP  (Floating-Point operand).
} x86_op_type;

//> AVX broadcast type
typedef enum x86_avx_bcast {
	X86_AVX_BCAST_INVALID = 0,	// Uninitialized.
	X86_AVX_BCAST_2,	// AVX512 broadcast type {1to2}
	X86_AVX_BCAST_4,	// AVX512 broadcast type {1to4}
	X86_AVX_BCAST_8,	// AVX512 broadcast type {1to8}
	X86_AVX_BCAST_16,	// AVX512 broadcast type {1to16}
} x86_avx_bcast;

//> SSE Code Condition type
typedef enum x86_sse_cc {
	X86_SSE_CC_INVALID = 0,	// Uninitialized.
	X86_SSE_CC_EQ,
	X86_SSE_CC_LT,
	X86_SSE_CC_LE,
	X86_SSE_CC_UNORD,
	X86_SSE_CC_NEQ,
	X86_SSE_CC_NLT,
	X86_SSE_CC_NLE,
	X86_SSE_CC_ORD,
	X86_SSE_CC_EQ_UQ,
	X86_SSE_CC_NGE,
	X86_SSE_CC_NGT,
	X86_SSE_CC_FALSE,
	X86_SSE_CC_NEQ_OQ,
	X86_SSE_CC_GE,
	X86_SSE_CC_GT,
	X86_SSE_CC_TRUE,
} x86_sse_cc;

//> AVX Code Condition type
typedef enum x86_avx_cc {
	X86_AVX_CC_INVALID = 0,	// Uninitialized.
	X86_AVX_CC_EQ,
	X86_AVX_CC_LT,
	X86_AVX_CC_LE,
	X86_AVX_CC_UNORD,
	X86_AVX_CC_NEQ,
	X86_AVX_CC_NLT,
	X86_AVX_CC_NLE,
	X86_AVX_CC_ORD,
	X86_AVX_CC_EQ_UQ,
	X86_AVX_CC_NGE,
	X86_AVX_CC_NGT,
	X86_AVX_CC_FALSE,
	X86_AVX_CC_NEQ_OQ,
	X86_AVX_CC_GE,
	X86_AVX_CC_GT,
	X86_AVX_CC_TRUE,
	X86_AVX_CC_EQ_OS,
	X86_AVX_CC_LT_OQ,
	X86_AVX_CC_LE_OQ,
	X86_AVX_CC_UNORD_S,
	X86_AVX_CC_NEQ_US,
	X86_AVX_CC_NLT_UQ,
	X86_AVX_CC_NLE_UQ,
	X86_AVX_CC_ORD_S,
	X86_AVX_CC_EQ_US,
	X86_AVX_CC_NGE_UQ,
	X86_AVX_CC_NGT_UQ,
	X86_AVX_CC_FALSE_OS,
	X86_AVX_CC_NEQ_OS,
	X86_AVX_CC_GE_OQ,
	X86_AVX_CC_GT_OQ,
	X86_AVX_CC_TRUE_US,
} x86_avx_cc;

//> AVX static rounding mode type
typedef enum x86_avx_rm {
	X86_AVX_RM_INVALID = 0,	// Uninitialized.
	X86_AVX_RM_RN,	// Round to nearest
	X86_AVX_RM_RD,	// Round down
	X86_AVX_RM_RU,	// Round up
	X86_AVX_RM_RZ,	// Round toward zero
} x86_avx_rm;

//> Instruction prefixes - to be used in cs_x86.prefix[]
typedef enum x86_prefix {
	X86_PREFIX_LOCK		= 	0xf0,	// lock (cs_x86.prefix[0]
	X86_PREFIX_REP		= 	0xf3,	// rep (cs_x86.prefix[0]
	X86_PREFIX_REPNE	= 	0xf2,	// repne (cs_x86.prefix[0]

	X86_PREFIX_CS		= 	0x2e,	// segment override CS (cs_x86.prefix[1]
	X86_PREFIX_SS		= 	0x36,	// segment override SS (cs_x86.prefix[1]
	X86_PREFIX_DS		= 	0x3e,	// segment override DS (cs_x86.prefix[1]
	X86_PREFIX_ES		= 	0x26,	// segment override ES (cs_x86.prefix[1]
	X86_PREFIX_FS		= 	0x64,	// segment override FS (cs_x86.prefix[1]
	X86_PREFIX_GS		= 	0x65,	// segment override GS (cs_x86.prefix[1]

	X86_PREFIX_OPSIZE	=	0x66,	// operand-size override (cs_x86.prefix[2]
	X86_PREFIX_ADDRSIZE	=	0x67,	// address-size override (cs_x86.prefix[3]
} x86_prefix;

// Instruction's operand referring to memory
// This is associated with X86_OP_MEM operand type above
typedef struct x86_op_mem {
	unsigned int segment; // segment register (or X86_REG_INVALID if irrelevant)
	unsigned int base;	// base register (or X86_REG_INVALID if irrelevant)
	unsigned int index;	// index register (or X86_REG_INVALID if irrelevant)
	int scale;	// scale for index register
	int64_t disp;	// displacement value
} x86_op_mem;

// Instruction operand
typedef struct cs_x86_op {
		x86_op_type type;	// operand type
		union {
			x86_reg reg;	// register value for REG operand
			int64_t imm;		// immediate value for IMM operand
			double fp;		// floating point value for FP operand
			x86_op_mem mem;		// base/index/scale/disp value for MEM operand
		};

		// size of this operand (in bytes).
		uint8_t size;

		// AVX broadcast type, or 0 if irrelevant
		x86_avx_bcast avx_bcast;

		// AVX zero opmask {z}
		bool avx_zero_opmask;
} cs_x86_op;

typedef struct x86Offsets {
	uint8_t displacement_offset; //Offset from Instruction->address
	uint8_t displacement_size;   //1,2,4,8

	uint8_t modrm_offset; // ModR/M offset, or 0 when irrelevant.

	uint8_t imm_offset; //Offset of imm value from Instruction->address
	uint8_t imm_size; //size of imm value
}x86Offsets;

// Instruction structure
typedef struct cs_x86 {
	// Instruction prefix, which can be up to 4 bytes.
	// A prefix byte gets value 0 when irrelevant.
	// prefix[0] indicates REP/REPNE/LOCK prefix (See X86_PREFIX_REP/REPNE/LOCK above)
	// prefix[1] indicates segment override (irrelevant for x86_64):
	// See X86_PREFIX_CS/SS/DS/ES/FS/GS above.
	// prefix[2] indicates operand-size override (X86_PREFIX_OPSIZE)
	// prefix[3] indicates address-size override (X86_PREFIX_ADDRSIZE)
	uint8_t prefix[4];

	// Instruction opcode, wich can be from 1 to 4 bytes in size.
	// This contains VEX opcode as well.
	// An trailing opcode byte gets value 0 when irrelevant.
	uint8_t opcode[4];

	// REX prefix: only a non-zero value is relavant for x86_64
	uint8_t rex;

	// Address size, which can be overrided with above prefix[5].
	uint8_t addr_size;

	// ModR/M byte
	uint8_t modrm;

	// SIB value, or 0 when irrelevant.
	uint8_t sib;

	// Displacement value, or 0 when irrelevant.
	int32_t disp;

	/* SIB state */
	// SIB index register, or X86_REG_INVALID when irrelevant.
	x86_reg sib_index;
	// SIB scale. only applicable if sib_index is relavant.
	int8_t sib_scale;
	// SIB base register, or X86_REG_INVALID when irrelevant.
	x86_reg sib_base;

	// SSE Code Condition
	x86_sse_cc sse_cc;

	// AVX Code Condition
	x86_avx_cc avx_cc;

	// AVX Suppress all Exception
	bool avx_sae;

	// AVX static rounding mode
	x86_avx_rm avx_rm;

	// Number of operands of this instruction,
	// or 0 when instruction has no operand.
	uint8_t op_count;

	cs_x86_op operands[8];	// operands for this instruction.
	x86Offsets offsets;
} cs_x86;

//> X86 instructions
typedef enum x86_insn {
	X86_INS_INVALID = 0,

	X86_INS_AAA,
	X86_INS_AAD,
	X86_INS_AAM,
	X86_INS_AAS,
	X86_INS_FABS,
	X86_INS_ADC,
	X86_INS_ADCX,
	X86_INS_ADD,
	X86_INS_ADDPD,
	X86_INS_ADDPS,
	X86_INS_ADDSD,
	X86_INS_ADDSS,
	X86_INS_ADDSUBPD,
	X86_INS_ADDSUBPS,
	X86_INS_FADD,
	X86_INS_FIADD,
	X86_INS_FADDP,
	X86_INS_ADOX,
	X86_INS_AESDECLAST,
	X86_INS_AESDEC,
	X86_INS_AESENCLAST,
	X86_INS_AESENC,
	X86_INS_AESIMC,
	X86_INS_AESKEYGENASSIST,
	X86_INS_AND,
	X86_INS_ANDN,
	X86_INS_ANDNPD,
	X86_INS_ANDNPS,
	X86_INS_ANDPD,
	X86_INS_ANDPS,
	X86_INS_ARPL,
	X86_INS_BEXTR,
	X86_INS_BLCFILL,
	X86_INS_BLCI,
	X86_INS_BLCIC,
	X86_INS_BLCMSK,
	X86_INS_BLCS,
	X86_INS_BLENDPD,
	X86_INS_BLENDPS,
	X86_INS_BLENDVPD,
	X86_INS_BLENDVPS,
	X86_INS_BLSFILL,
	X86_INS_BLSI,
	X86_INS_BLSIC,
	X86_INS_BLSMSK,
	X86_INS_BLSR,
	X86_INS_BOUND,
	X86_INS_BSF,
	X86_INS_BSR,
	X86_INS_BSWAP,
	X86_INS_BT,
	X86_INS_BTC,
	X86_INS_BTR,
	X86_INS_BTS,
	X86_INS_BZHI,
	X86_INS_CALL,
	X86_INS_CBW,
	X86_INS_CDQ,
	X86_INS_CDQE,
	X86_INS_FCHS,
	X86_INS_CLAC,
	X86_INS_CLC,
	X86_INS_CLD,
	X86_INS_CLFLUSH,
	X86_INS_CLGI,
	X86_INS_CLI,
	X86_INS_CLTS,
	X86_INS_CMC,
	X86_INS_CMOVA,
	X86_INS_CMOVAE,
	X86_INS_CMOVB,
	X86_INS_CMOVBE,
	X86_INS_FCMOVBE,
	X86_INS_FCMOVB,
	X86_INS_CMOVE,
	X86_INS_FCMOVE,
	X86_INS_CMOVG,
	X86_INS_CMOVGE,
	X86_INS_CMOVL,
	X86_INS_CMOVLE,
	X86_INS_FCMOVNBE,
	X86_INS_FCMOVNB,
	X86_INS_CMOVNE,
	X86_INS_FCMOVNE,
	X86_INS_CMOVNO,
	X86_INS_CMOVNP,
	X86_INS_FCMOVNU,
	X86_INS_CMOVNS,
	X86_INS_CMOVO,
	X86_INS_CMOVP,
	X86_INS_FCMOVU,
	X86_INS_CMOVS,
	X86_INS_CMP,
	X86_INS_CMPPD,
	X86_INS_CMPPS,
	X86_INS_CMPSB,
	X86_INS_CMPSD,
	X86_INS_CMPSQ,
	X86_INS_CMPSS,
	X86_INS_CMPSW,
	X86_INS_CMPXCHG16B,
	X86_INS_CMPXCHG,
	X86_INS_CMPXCHG8B,
	X86_INS_COMISD,
	X86_INS_COMISS,
	X86_INS_FCOMP,
	X86_INS_FCOMPI,
	X86_INS_FCOMI,
	X86_INS_FCOM,
	X86_INS_FCOS,
	X86_INS_CPUID,
	X86_INS_CQO,
	X86_INS_CRC32,
	X86_INS_CVTDQ2PD,
	X86_INS_CVTDQ2PS,
	X86_INS_CVTPD2DQ,
	X86_INS_CVTPD2PS,
	X86_INS_CVTPS2DQ,
	X86_INS_CVTPS2PD,
	X86_INS_CVTSD2SI,
	X86_INS_CVTSD2SS,
	X86_INS_CVTSI2SD,
	X86_INS_CVTSI2SS,
	X86_INS_CVTSS2SD,
	X86_INS_CVTSS2SI,
	X86_INS_CVTTPD2DQ,
	X86_INS_CVTTPS2DQ,
	X86_INS_CVTTSD2SI,
	X86_INS_CVTTSS2SI,
	X86_INS_CWD,
	X86_INS_CWDE,
	X86_INS_DAA,
	X86_INS_DAS,
	X86_INS_DATA16,
	X86_INS_DEC,
	X86_INS_DIV,
	X86_INS_DIVPD,
	X86_INS_DIVPS,
	X86_INS_FDIVR,
	X86_INS_FIDIVR,
	X86_INS_FDIVRP,
	X86_INS_DIVSD,
	X86_INS_DIVSS,
	X86_INS_FDIV,
	X86_INS_FIDIV,
	X86_INS_FDIVP,
	X86_INS_DPPD,
	X86_INS_DPPS,
	X86_INS_RET,
	X86_INS_ENCLS,
	X86_INS_ENCLU,
	X86_INS_ENTER,
	X86_INS_EXTRACTPS,
	X86_INS_EXTRQ,
	X86_INS_F2XM1,
	X86_INS_LCALL,
	X86_INS_LJMP,
	X86_INS_FBLD,
	X86_INS_FBSTP,
	X86_INS_FCOMPP,
	X86_INS_FDECSTP,
	X86_INS_FEMMS,
	X86_INS_FFREE,
	X86_INS_FICOM,
	X86_INS_FICOMP,
	X86_INS_FINCSTP,
	X86_INS_FLDCW,
	X86_INS_FLDENV,
	X86_INS_FLDL2E,
	X86_INS_FLDL2T,
	X86_INS_FLDLG2,
	X86_INS_FLDLN2,
	X86_INS_FLDPI,
	X86_INS_FNCLEX,
	X86_INS_FNINIT,
	X86_INS_FNOP,
	X86_INS_FNSTCW,
	X86_INS_FNSTSW,
	X86_INS_FPATAN,
	X86_INS_FPREM,
	X86_INS_FPREM1,
	X86_INS_FPTAN,
	X86_INS_FRNDINT,
	X86_INS_FRSTOR,
	X86_INS_FNSAVE,
	X86_INS_FSCALE,
	X86_INS_FSETPM,
	X86_INS_FSINCOS,
	X86_INS_FNSTENV,
	X86_INS_FXAM,
	X86_INS_FXRSTOR,
	X86_INS_FXRSTOR64,
	X86_INS_FXSAVE,
	X86_INS_FXSAVE64,
	X86_INS_FXTRACT,
	X86_INS_FYL2X,
	X86_INS_FYL2XP1,
	X86_INS_MOVAPD,
	X86_INS_MOVAPS,
	X86_INS_ORPD,
	X86_INS_ORPS,
	X86_INS_VMOVAPD,
	X86_INS_VMOVAPS,
	X86_INS_XORPD,
	X86_INS_XORPS,
	X86_INS_GETSEC,
	X86_INS_HADDPD,
	X86_INS_HADDPS,
	X86_INS_HLT,
	X86_INS_HSUBPD,
	X86_INS_HSUBPS,
	X86_INS_IDIV,
	X86_INS_FILD,
	X86_INS_IMUL,
	X86_INS_IN,
	X86_INS_INC,
	X86_INS_INSB,
	X86_INS_INSERTPS,
	X86_INS_INSERTQ,
	X86_INS_INSD,
	X86_INS_INSW,
	X86_INS_INT,
	X86_INS_INT1,
	X86_INS_INT3,
	X86_INS_INTO,
	X86_INS_INVD,
	X86_INS_INVEPT,
	X86_INS_INVLPG,
	X86_INS_INVLPGA,
	X86_INS_INVPCID,
	X86_INS_INVVPID,
	X86_INS_IRET,
	X86_INS_IRETD,
	X86_INS_IRETQ,
	X86_INS_FISTTP,
	X86_INS_FIST,
	X86_INS_FISTP,
	X86_INS_UCOMISD,
	X86_INS_UCOMISS,
	X86_INS_VCMP,
	X86_INS_VCOMISD,
	X86_INS_VCOMISS,
	X86_INS_VCVTSD2SS,
	X86_INS_VCVTSI2SD,
	X86_INS_VCVTSI2SS,
	X86_INS_VCVTSS2SD,
	X86_INS_VCVTTSD2SI,
	X86_INS_VCVTTSD2USI,
	X86_INS_VCVTTSS2SI,
	X86_INS_VCVTTSS2USI,
	X86_INS_VCVTUSI2SD,
	X86_INS_VCVTUSI2SS,
	X86_INS_VUCOMISD,
	X86_INS_VUCOMISS,
	X86_INS_JAE,
	X86_INS_JA,
	X86_INS_JBE,
	X86_INS_JB,
	X86_INS_JCXZ,
	X86_INS_JECXZ,
	X86_INS_JE,
	X86_INS_JGE,
	X86_INS_JG,
	X86_INS_JLE,
	X86_INS_JL,
	X86_INS_JMP,
	X86_INS_JNE,
	X86_INS_JNO,
	X86_INS_JNP,
	X86_INS_JNS,
	X86_INS_JO,
	X86_INS_JP,
	X86_INS_JRCXZ,
	X86_INS_JS,
	X86_INS_KANDB,
	X86_INS_KANDD,
	X86_INS_KANDNB,
	X86_INS_KANDND,
	X86_INS_KANDNQ,
	X86_INS_KANDNW,
	X86_INS_KANDQ,
	X86_INS_KANDW,
	X86_INS_KMOVB,
	X86_INS_KMOVD,
	X86_INS_KMOVQ,
	X86_INS_KMOVW,
	X86_INS_KNOTB,
	X86_INS_KNOTD,
	X86_INS_KNOTQ,
	X86_INS_KNOTW,
	X86_INS_KORB,
	X86_INS_KORD,
	X86_INS_KORQ,
	X86_INS_KORTESTW,
	X86_INS_KORW,
	X86_INS_KSHIFTLW,
	X86_INS_KSHIFTRW,
	X86_INS_KUNPCKBW,
	X86_INS_KXNORB,
	X86_INS_KXNORD,
	X86_INS_KXNORQ,
	X86_INS_KXNORW,
	X86_INS_KXORB,
	X86_INS_KXORD,
	X86_INS_KXORQ,
	X86_INS_KXORW,
	X86_INS_LAHF,
	X86_INS_LAR,
	X86_INS_LDDQU,
	X86_INS_LDMXCSR,
	X86_INS_LDS,
	X86_INS_FLDZ,
	X86_INS_FLD1,
	X86_INS_FLD,
	X86_INS_LEA,
	X86_INS_LEAVE,
	X86_INS_LES,
	X86_INS_LFENCE,
	X86_INS_LFS,
	X86_INS_LGDT,
	X86_INS_LGS,
	X86_INS_LIDT,
	X86_INS_LLDT,
	X86_INS_LMSW,
	X86_INS_OR,
	X86_INS_SUB,
	X86_INS_XOR,
	X86_INS_LODSB,
	X86_INS_LODSD,
	X86_INS_LODSQ,
	X86_INS_LODSW,
	X86_INS_LOOP,
	X86_INS_LOOPE,
	X86_INS_LOOPNE,
	X86_INS_RETF,
	X86_INS_RETFQ,
	X86_INS_LSL,
	X86_INS_LSS,
	X86_INS_LTR,
	X86_INS_XADD,
	X86_INS_LZCNT,
	X86_INS_MASKMOVDQU,
	X86_INS_MAXPD,
	X86_INS_MAXPS,
	X86_INS_MAXSD,
	X86_INS_MAXSS,
	X86_INS_MFENCE,
	X86_INS_MINPD,
	X86_INS_MINPS,
	X86_INS_MINSD,
	X86_INS_MINSS,
	X86_INS_CVTPD2PI,
	X86_INS_CVTPI2PD,
	X86_INS_CVTPI2PS,
	X86_INS_CVTPS2PI,
	X86_INS_CVTTPD2PI,
	X86_INS_CVTTPS2PI,
	X86_INS_EMMS,
	X86_INS_MASKMOVQ,
	X86_INS_MOVD,
	X86_INS_MOVDQ2Q,
	X86_INS_MOVNTQ,
	X86_INS_MOVQ2DQ,
	X86_INS_MOVQ,
	X86_INS_PABSB,
	X86_INS_PABSD,
	X86_INS_PABSW,
	X86_INS_PACKSSDW,
	X86_INS_PACKSSWB,
	X86_INS_PACKUSWB,
	X86_INS_PADDB,
	X86_INS_PADDD,
	X86_INS_PADDQ,
	X86_INS_PADDSB,
	X86_INS_PADDSW,
	X86_INS_PADDUSB,
	X86_INS_PADDUSW,
	X86_INS_PADDW,
	X86_INS_PALIGNR,
	X86_INS_PANDN,
	X86_INS_PAND,
	X86_INS_PAVGB,
	X86_INS_PAVGW,
	X86_INS_PCMPEQB,
	X86_INS_PCMPEQD,
	X86_INS_PCMPEQW,
	X86_INS_PCMPGTB,
	X86_INS_PCMPGTD,
	X86_INS_PCMPGTW,
	X86_INS_PEXTRW,
	X86_INS_PHADDSW,
	X86_INS_PHADDW,
	X86_INS_PHADDD,
	X86_INS_PHSUBD,
	X86_INS_PHSUBSW,
	X86_INS_PHSUBW,
	X86_INS_PINSRW,
	X86_INS_PMADDUBSW,
	X86_INS_PMADDWD,
	X86_INS_PMAXSW,
	X86_INS_PMAXUB,
	X86_INS_PMINSW,
	X86_INS_PMINUB,
	X86_INS_PMOVMSKB,
	X86_INS_PMULHRSW,
	X86_INS_PMULHUW,
	X86_INS_PMULHW,
	X86_INS_PMULLW,
	X86_INS_PMULUDQ,
	X86_INS_POR,
	X86_INS_PSADBW,
	X86_INS_PSHUFB,
	X86_INS_PSHUFW,
	X86_INS_PSIGNB,
	X86_INS_PSIGND,
	X86_INS_PSIGNW,
	X86_INS_PSLLD,
	X86_INS_PSLLQ,
	X86_INS_PSLLW,
	X86_INS_PSRAD,
	X86_INS_PSRAW,
	X86_INS_PSRLD,
	X86_INS_PSRLQ,
	X86_INS_PSRLW,
	X86_INS_PSUBB,
	X86_INS_PSUBD,
	X86_INS_PSUBQ,
	X86_INS_PSUBSB,
	X86_INS_PSUBSW,
	X86_INS_PSUBUSB,
	X86_INS_PSUBUSW,
	X86_INS_PSUBW,
	X86_INS_PUNPCKHBW,
	X86_INS_PUNPCKHDQ,
	X86_INS_PUNPCKHWD,
	X86_INS_PUNPCKLBW,
	X86_INS_PUNPCKLDQ,
	X86_INS_PUNPCKLWD,
	X86_INS_PXOR,
	X86_INS_MONITOR,
	X86_INS_MONTMUL,
	X86_INS_MOV,
	X86_INS_MOVABS,
	X86_INS_MOVBE,
	X86_INS_MOVDDUP,
	X86_INS_MOVDQA,
	X86_INS_MOVDQU,
	X86_INS_MOVHLPS,
	X86_INS_MOVHPD,
	X86_INS_MOVHPS,
	X86_INS_MOVLHPS,
	X86_INS_MOVLPD,
	X86_INS_MOVLPS,
	X86_INS_MOVMSKPD,
	X86_INS_MOVMSKPS,
	X86_INS_MOVNTDQA,
	X86_INS_MOVNTDQ,
	X86_INS_MOVNTI,
	X86_INS_MOVNTPD,
	X86_INS_MOVNTPS,
	X86_INS_MOVNTSD,
	X86_INS_MOVNTSS,
	X86_INS_MOVSB,
	X86_INS_MOVSD,
	X86_INS_MOVSHDUP,
	X86_INS_MOVSLDUP,
	X86_INS_MOVSQ,
	X86_INS_MOVSS,
	X86_INS_MOVSW,
	X86_INS_MOVSX,
	X86_INS_MOVSXD,
	X86_INS_MOVUPD,
	X86_INS_MOVUPS,
	X86_INS_MOVZX,
	X86_INS_MPSADBW,
	X86_INS_MUL,
	X86_INS_MULPD,
	X86_INS_MULPS,
	X86_INS_MULSD,
	X86_INS_MULSS,
	X86_INS_MULX,
	X86_INS_FMUL,
	X86_INS_FIMUL,
	X86_INS_FMULP,
	X86_INS_MWAIT,
	X86_INS_NEG,
	X86_INS_NOP,
	X86_INS_NOT,
	X86_INS_OUT,
	X86_INS_OUTSB,
	X86_INS_OUTSD,
	X86_INS_OUTSW,
	X86_INS_PACKUSDW,
	X86_INS_PAUSE,
	X86_INS_PAVGUSB,
	X86_INS_PBLENDVB,
	X86_INS_PBLENDW,
	X86_INS_PCLMULQDQ,
	X86_INS_PCMPEQQ,
	X86_INS_PCMPESTRI,
	X86_INS_PCMPESTRM,
	X86_INS_PCMPGTQ,
	X86_INS_PCMPISTRI,
	X86_INS_PCMPISTRM,
	X86_INS_PDEP,
	X86_INS_PEXT,
	X86_INS_PEXTRB,
	X86_INS_PEXTRD,
	X86_INS_PEXTRQ,
	X86_INS_PF2ID,
	X86_INS_PF2IW,
	X86_INS_PFACC,
	X86_INS_PFADD,
	X86_INS_PFCMPEQ,
	X86_INS_PFCMPGE,
	X86_INS_PFCMPGT,
	X86_INS_PFMAX,
	X86_INS_PFMIN,
	X86_INS_PFMUL,
	X86_INS_PFNACC,
	X86_INS_PFPNACC,
	X86_INS_PFRCPIT1,
	X86_INS_PFRCPIT2,
	X86_INS_PFRCP,
	X86_INS_PFRSQIT1,
	X86_INS_PFRSQRT,
	X86_INS_PFSUBR,
	X86_INS_PFSUB,
	X86_INS_PHMINPOSUW,
	X86_INS_PI2FD,
	X86_INS_PI2FW,
	X86_INS_PINSRB,
	X86_INS_PINSRD,
	X86_INS_PINSRQ,
	X86_INS_PMAXSB,
	X86_INS_PMAXSD,
	X86_INS_PMAXUD,
	X86_INS_PMAXUW,
	X86_INS_PMINSB,
	X86_INS_PMINSD,
	X86_INS_PMINUD,
	X86_INS_PMINUW,
	X86_INS_PMOVSXBD,
	X86_INS_PMOVSXBQ,
	X86_INS_PMOVSXBW,
	X86_INS_PMOVSXDQ,
	X86_INS_PMOVSXWD,
	X86_INS_PMOVSXWQ,
	X86_INS_PMOVZXBD,
	X86_INS_PMOVZXBQ,
	X86_INS_PMOVZXBW,
	X86_INS_PMOVZXDQ,
	X86_INS_PMOVZXWD,
	X86_INS_PMOVZXWQ,
	X86_INS_PMULDQ,
	X86_INS_PMULHRW,
	X86_INS_PMULLD,
	X86_INS_POP,
	X86_INS_POPAW,
	X86_INS_POPAL,
	X86_INS_POPCNT,
	X86_INS_POPF,
	X86_INS_POPFD,
	X86_INS_POPFQ,
	X86_INS_PREFETCH,
	X86_INS_PREFETCHNTA,
	X86_INS_PREFETCHT0,
	X86_INS_PREFETCHT1,
	X86_INS_PREFETCHT2,
	X86_INS_PREFETCHW,
	X86_INS_PSHUFD,
	X86_INS_PSHUFHW,
	X86_INS_PSHUFLW,
	X86_INS_PSLLDQ,
	X86_INS_PSRLDQ,
	X86_INS_PSWAPD,
	X86_INS_PTEST,
	X86_INS_PUNPCKHQDQ,
	X86_INS_PUNPCKLQDQ,
	X86_INS_PUSH,
	X86_INS_PUSHAW,
	X86_INS_PUSHAL,
	X86_INS_PUSHF,
	X86_INS_PUSHFD,
	X86_INS_PUSHFQ,
	X86_INS_RCL,
	X86_INS_RCPPS,
	X86_INS_RCPSS,
	X86_INS_RCR,
	X86_INS_RDFSBASE,
	X86_INS_RDGSBASE,
	X86_INS_RDMSR,
	X86_INS_RDPMC,
	X86_INS_RDRAND,
	X86_INS_RDSEED,
	X86_INS_RDTSC,
	X86_INS_RDTSCP,
	X86_INS_ROL,
	X86_INS_ROR,
	X86_INS_RORX,
	X86_INS_ROUNDPD,
	X86_INS_ROUNDPS,
	X86_INS_ROUNDSD,
	X86_INS_ROUNDSS,
	X86_INS_RSM,
	X86_INS_RSQRTPS,
	X86_INS_RSQRTSS,
	X86_INS_SAHF,
	X86_INS_SAL,
	X86_INS_SALC,
	X86_INS_SAR,
	X86_INS_SARX,
	X86_INS_SBB,
	X86_INS_SCASB,
	X86_INS_SCASD,
	X86_INS_SCASQ,
	X86_INS_SCASW,
	X86_INS_SETAE,
	X86_INS_SETA,
	X86_INS_SETBE,
	X86_INS_SETB,
	X86_INS_SETE,
	X86_INS_SETGE,
	X86_INS_SETG,
	X86_INS_SETLE,
	X86_INS_SETL,
	X86_INS_SETNE,
	X86_INS_SETNO,
	X86_INS_SETNP,
	X86_INS_SETNS,
	X86_INS_SETO,
	X86_INS_SETP,
	X86_INS_SETS,
	X86_INS_SFENCE,
	X86_INS_SGDT,
	X86_INS_SHA1MSG1,
	X86_INS_SHA1MSG2,
	X86_INS_SHA1NEXTE,
	X86_INS_SHA1RNDS4,
	X86_INS_SHA256MSG1,
	X86_INS_SHA256MSG2,
	X86_INS_SHA256RNDS2,
	X86_INS_SHL,
	X86_INS_SHLD,
	X86_INS_SHLX,
	X86_INS_SHR,
	X86_INS_SHRD,
	X86_INS_SHRX,
	X86_INS_SHUFPD,
	X86_INS_SHUFPS,
	X86_INS_SIDT,
	X86_INS_FSIN,
	X86_INS_SKINIT,
	X86_INS_SLDT,
	X86_INS_SMSW,
	X86_INS_SQRTPD,
	X86_INS_SQRTPS,
	X86_INS_SQRTSD,
	X86_INS_SQRTSS,
	X86_INS_FSQRT,
	X86_INS_STAC,
	X86_INS_STC,
	X86_INS_STD,
	X86_INS_STGI,
	X86_INS_STI,
	X86_INS_STMXCSR,
	X86_INS_STOSB,
	X86_INS_STOSD,
	X86_INS_STOSQ,
	X86_INS_STOSW,
	X86_INS_STR,
	X86_INS_FST,
	X86_INS_FSTP,
	X86_INS_FSTPNCE,
	X86_INS_SUBPD,
	X86_INS_SUBPS,
	X86_INS_FSUBR,
	X86_INS_FISUBR,
	X86_INS_FSUBRP,
	X86_INS_SUBSD,
	X86_INS_SUBSS,
	X86_INS_FSUB,
	X86_INS_FISUB,
	X86_INS_FSUBP,
	X86_INS_SWAPGS,
	X86_INS_SYSCALL,
	X86_INS_SYSENTER,
	X86_INS_SYSEXIT,
	X86_INS_SYSRET,
	X86_INS_T1MSKC,
	X86_INS_TEST,
	X86_INS_UD2,
	X86_INS_FTST,
	X86_INS_TZCNT,
	X86_INS_TZMSK,
	X86_INS_FUCOMPI,
	X86_INS_FUCOMI,
	X86_INS_FUCOMPP,
	X86_INS_FUCOMP,
	X86_INS_FUCOM,
	X86_INS_UD2B,
	X86_INS_UNPCKHPD,
	X86_INS_UNPCKHPS,
	X86_INS_UNPCKLPD,
	X86_INS_UNPCKLPS,
	X86_INS_VADDPD,
	X86_INS_VADDPS,
	X86_INS_VADDSD,
	X86_INS_VADDSS,
	X86_INS_VADDSUBPD,
	X86_INS_VADDSUBPS,
	X86_INS_VAESDECLAST,
	X86_INS_VAESDEC,
	X86_INS_VAESENCLAST,
	X86_INS_VAESENC,
	X86_INS_VAESIMC,
	X86_INS_VAESKEYGENASSIST,
	X86_INS_VALIGND,
	X86_INS_VALIGNQ,
	X86_INS_VANDNPD,
	X86_INS_VANDNPS,
	X86_INS_VANDPD,
	X86_INS_VANDPS,
	X86_INS_VBLENDMPD,
	X86_INS_VBLENDMPS,
	X86_INS_VBLENDPD,
	X86_INS_VBLENDPS,
	X86_INS_VBLENDVPD,
	X86_INS_VBLENDVPS,
	X86_INS_VBROADCASTF128,
	X86_INS_VBROADCASTI128,
	X86_INS_VBROADCASTI32X4,
	X86_INS_VBROADCASTI64X4,
	X86_INS_VBROADCASTSD,
	X86_INS_VBROADCASTSS,
	X86_INS_VCMPPD,
	X86_INS_VCMPPS,
	X86_INS_VCMPSD,
	X86_INS_VCMPSS,
	X86_INS_VCVTDQ2PD,
	X86_INS_VCVTDQ2PS,
	X86_INS_VCVTPD2DQX,
	X86_INS_VCVTPD2DQ,
	X86_INS_VCVTPD2PSX,
	X86_INS_VCVTPD2PS,
	X86_INS_VCVTPD2UDQ,
	X86_INS_VCVTPH2PS,
	X86_INS_VCVTPS2DQ,
	X86_INS_VCVTPS2PD,
	X86_INS_VCVTPS2PH,
	X86_INS_VCVTPS2UDQ,
	X86_INS_VCVTSD2SI,
	X86_INS_VCVTSD2USI,
	X86_INS_VCVTSS2SI,
	X86_INS_VCVTSS2USI,
	X86_INS_VCVTTPD2DQX,
	X86_INS_VCVTTPD2DQ,
	X86_INS_VCVTTPD2UDQ,
	X86_INS_VCVTTPS2DQ,
	X86_INS_VCVTTPS2UDQ,
	X86_INS_VCVTUDQ2PD,
	X86_INS_VCVTUDQ2PS,
	X86_INS_VDIVPD,
	X86_INS_VDIVPS,
	X86_INS_VDIVSD,
	X86_INS_VDIVSS,
	X86_INS_VDPPD,
	X86_INS_VDPPS,
	X86_INS_VERR,
	X86_INS_VERW,
	X86_INS_VEXTRACTF128,
	X86_INS_VEXTRACTF32X4,
	X86_INS_VEXTRACTF64X4,
	X86_INS_VEXTRACTI128,
	X86_INS_VEXTRACTI32X4,
	X86_INS_VEXTRACTI64X4,
	X86_INS_VEXTRACTPS,
	X86_INS_VFMADD132PD,
	X86_INS_VFMADD132PS,
	X86_INS_VFMADD213PD,
	X86_INS_VFMADD213PS,
	X86_INS_VFMADDPD,
	X86_INS_VFMADD231PD,
	X86_INS_VFMADDPS,
	X86_INS_VFMADD231PS,
	X86_INS_VFMADDSD,
	X86_INS_VFMADD213SD,
	X86_INS_VFMADD132SD,
	X86_INS_VFMADD231SD,
	X86_INS_VFMADDSS,
	X86_INS_VFMADD213SS,
	X86_INS_VFMADD132SS,
	X86_INS_VFMADD231SS,
	X86_INS_VFMADDSUB132PD,
	X86_INS_VFMADDSUB132PS,
	X86_INS_VFMADDSUB213PD,
	X86_INS_VFMADDSUB213PS,
	X86_INS_VFMADDSUBPD,
	X86_INS_VFMADDSUB231PD,
	X86_INS_VFMADDSUBPS,
	X86_INS_VFMADDSUB231PS,
	X86_INS_VFMSUB132PD,
	X86_INS_VFMSUB132PS,
	X86_INS_VFMSUB213PD,
	X86_INS_VFMSUB213PS,
	X86_INS_VFMSUBADD132PD,
	X86_INS_VFMSUBADD132PS,
	X86_INS_VFMSUBADD213PD,
	X86_INS_VFMSUBADD213PS,
	X86_INS_VFMSUBADDPD,
	X86_INS_VFMSUBADD231PD,
	X86_INS_VFMSUBADDPS,
	X86_INS_VFMSUBADD231PS,
	X86_INS_VFMSUBPD,
	X86_INS_VFMSUB231PD,
	X86_INS_VFMSUBPS,
	X86_INS_VFMSUB231PS,
	X86_INS_VFMSUBSD,
	X86_INS_VFMSUB213SD,
	X86_INS_VFMSUB132SD,
	X86_INS_VFMSUB231SD,
	X86_INS_VFMSUBSS,
	X86_INS_VFMSUB213SS,
	X86_INS_VFMSUB132SS,
	X86_INS_VFMSUB231SS,
	X86_INS_VFNMADD132PD,
	X86_INS_VFNMADD132PS,
	X86_INS_VFNMADD213PD,
	X86_INS_VFNMADD213PS,
	X86_INS_VFNMADDPD,
	X86_INS_VFNMADD231PD,
	X86_INS_VFNMADDPS,
	X86_INS_VFNMADD231PS,
	X86_INS_VFNMADDSD,
	X86_INS_VFNMADD213SD,
	X86_INS_VFNMADD132SD,
	X86_INS_VFNMADD231SD,
	X86_INS_VFNMADDSS,
	X86_INS_VFNMADD213SS,
	X86_INS_VFNMADD132SS,
	X86_INS_VFNMADD231SS,
	X86_INS_VFNMSUB132PD,
	X86_INS_VFNMSUB132PS,
	X86_INS_VFNMSUB213PD,
	X86_INS_VFNMSUB213PS,
	X86_INS_VFNMSUBPD,
	X86_INS_VFNMSUB231PD,
	X86_INS_VFNMSUBPS,
	X86_INS_VFNMSUB231PS,
	X86_INS_VFNMSUBSD,
	X86_INS_VFNMSUB213SD,
	X86_INS_VFNMSUB132SD,
	X86_INS_VFNMSUB231SD,
	X86_INS_VFNMSUBSS,
	X86_INS_VFNMSUB213SS,
	X86_INS_VFNMSUB132SS,
	X86_INS_VFNMSUB231SS,
	X86_INS_VFRCZPD,
	X86_INS_VFRCZPS,
	X86_INS_VFRCZSD,
	X86_INS_VFRCZSS,
	X86_INS_VORPD,
	X86_INS_VORPS,
	X86_INS_VXORPD,
	X86_INS_VXORPS,
	X86_INS_VGATHERDPD,
	X86_INS_VGATHERDPS,
	X86_INS_VGATHERPF0DPD,
	X86_INS_VGATHERPF0DPS,
	X86_INS_VGATHERPF0QPD,
	X86_INS_VGATHERPF0QPS,
	X86_INS_VGATHERPF1DPD,
	X86_INS_VGATHERPF1DPS,
	X86_INS_VGATHERPF1QPD,
	X86_INS_VGATHERPF1QPS,
	X86_INS_VGATHERQPD,
	X86_INS_VGATHERQPS,
	X86_INS_VHADDPD,
	X86_INS_VHADDPS,
	X86_INS_VHSUBPD,
	X86_INS_VHSUBPS,
	X86_INS_VINSERTF128,
	X86_INS_VINSERTF32X4,
	X86_INS_VINSERTF64X4,
	X86_INS_VINSERTI128,
	X86_INS_VINSERTI32X4,
	X86_INS_VINSERTI64X4,
	X86_INS_VINSERTPS,
	X86_INS_VLDDQU,
	X86_INS_VLDMXCSR,
	X86_INS_VMASKMOVDQU,
	X86_INS_VMASKMOVPD,
	X86_INS_VMASKMOVPS,
	X86_INS_VMAXPD,
	X86_INS_VMAXPS,
	X86_INS_VMAXSD,
	X86_INS_VMAXSS,
	X86_INS_VMCALL,
	X86_INS_VMCLEAR,
	X86_INS_VMFUNC,
	X86_INS_VMINPD,
	X86_INS_VMINPS,
	X86_INS_VMINSD,
	X86_INS_VMINSS,
	X86_INS_VMLAUNCH,
	X86_INS_VMLOAD,
	X86_INS_VMMCALL,
	X86_INS_VMOVQ,
	X86_INS_VMOVDDUP,
	X86_INS_VMOVD,
	X86_INS_VMOVDQA32,
	X86_INS_VMOVDQA64,
	X86_INS_VMOVDQA,
	X86_INS_VMOVDQU16,
	X86_INS_VMOVDQU32,
	X86_INS_VMOVDQU64,
	X86_INS_VMOVDQU8,
	X86_INS_VMOVDQU,
	X86_INS_VMOVHLPS,
	X86_INS_VMOVHPD,
	X86_INS_VMOVHPS,
	X86_INS_VMOVLHPS,
	X86_INS_VMOVLPD,
	X86_INS_VMOVLPS,
	X86_INS_VMOVMSKPD,
	X86_INS_VMOVMSKPS,
	X86_INS_VMOVNTDQA,
	X86_INS_VMOVNTDQ,
	X86_INS_VMOVNTPD,
	X86_INS_VMOVNTPS,
	X86_INS_VMOVSD,
	X86_INS_VMOVSHDUP,
	X86_INS_VMOVSLDUP,
	X86_INS_VMOVSS,
	X86_INS_VMOVUPD,
	X86_INS_VMOVUPS,
	X86_INS_VMPSADBW,
	X86_INS_VMPTRLD,
	X86_INS_VMPTRST,
	X86_INS_VMREAD,
	X86_INS_VMRESUME,
	X86_INS_VMRUN,
	X86_INS_VMSAVE,
	X86_INS_VMULPD,
	X86_INS_VMULPS,
	X86_INS_VMULSD,
	X86_INS_VMULSS,
	X86_INS_VMWRITE,
	X86_INS_VMXOFF,
	X86_INS_VMXON,
	X86_INS_VPABSB,
	X86_INS_VPABSD,
	X86_INS_VPABSQ,
	X86_INS_VPABSW,
	X86_INS_VPACKSSDW,
	X86_INS_VPACKSSWB,
	X86_INS_VPACKUSDW,
	X86_INS_VPACKUSWB,
	X86_INS_VPADDB,
	X86_INS_VPADDD,
	X86_INS_VPADDQ,
	X86_INS_VPADDSB,
	X86_INS_VPADDSW,
	X86_INS_VPADDUSB,
	X86_INS_VPADDUSW,
	X86_INS_VPADDW,
	X86_INS_VPALIGNR,
	X86_INS_VPANDD,
	X86_INS_VPANDND,
	X86_INS_VPANDNQ,
	X86_INS_VPANDN,
	X86_INS_VPANDQ,
	X86_INS_VPAND,
	X86_INS_VPAVGB,
	X86_INS_VPAVGW,
	X86_INS_VPBLENDD,
	X86_INS_VPBLENDMD,
	X86_INS_VPBLENDMQ,
	X86_INS_VPBLENDVB,
	X86_INS_VPBLENDW,
	X86_INS_VPBROADCASTB,
	X86_INS_VPBROADCASTD,
	X86_INS_VPBROADCASTMB2Q,
	X86_INS_VPBROADCASTMW2D,
	X86_INS_VPBROADCASTQ,
	X86_INS_VPBROADCASTW,
	X86_INS_VPCLMULQDQ,
	X86_INS_VPCMOV,
	X86_INS_VPCMP,
	X86_INS_VPCMPD,
	X86_INS_VPCMPEQB,
	X86_INS_VPCMPEQD,
	X86_INS_VPCMPEQQ,
	X86_INS_VPCMPEQW,
	X86_INS_VPCMPESTRI,
	X86_INS_VPCMPESTRM,
	X86_INS_VPCMPGTB,
	X86_INS_VPCMPGTD,
	X86_INS_VPCMPGTQ,
	X86_INS_VPCMPGTW,
	X86_INS_VPCMPISTRI,
	X86_INS_VPCMPISTRM,
	X86_INS_VPCMPQ,
	X86_INS_VPCMPUD,
	X86_INS_VPCMPUQ,
	X86_INS_VPCOMB,
	X86_INS_VPCOMD,
	X86_INS_VPCOMQ,
	X86_INS_VPCOMUB,
	X86_INS_VPCOMUD,
	X86_INS_VPCOMUQ,
	X86_INS_VPCOMUW,
	X86_INS_VPCOMW,
	X86_INS_VPCONFLICTD,
	X86_INS_VPCONFLICTQ,
	X86_INS_VPERM2F128,
	X86_INS_VPERM2I128,
	X86_INS_VPERMD,
	X86_INS_VPERMI2D,
	X86_INS_VPERMI2PD,
	X86_INS_VPERMI2PS,
	X86_INS_VPERMI2Q,
	X86_INS_VPERMIL2PD,
	X86_INS_VPERMIL2PS,
	X86_INS_VPERMILPD,
	X86_INS_VPERMILPS,
	X86_INS_VPERMPD,
	X86_INS_VPERMPS,
	X86_INS_VPERMQ,
	X86_INS_VPERMT2D,
	X86_INS_VPERMT2PD,
	X86_INS_VPERMT2PS,
	X86_INS_VPERMT2Q,
	X86_INS_VPEXTRB,
	X86_INS_VPEXTRD,
	X86_INS_VPEXTRQ,
	X86_INS_VPEXTRW,
	X86_INS_VPGATHERDD,
	X86_INS_VPGATHERDQ,
	X86_INS_VPGATHERQD,
	X86_INS_VPGATHERQQ,
	X86_INS_VPHADDBD,
	X86_INS_VPHADDBQ,
	X86_INS_VPHADDBW,
	X86_INS_VPHADDDQ,
	X86_INS_VPHADDD,
	X86_INS_VPHADDSW,
	X86_INS_VPHADDUBD,
	X86_INS_VPHADDUBQ,
	X86_INS_VPHADDUBW,
	X86_INS_VPHADDUDQ,
	X86_INS_VPHADDUWD,
	X86_INS_VPHADDUWQ,
	X86_INS_VPHADDWD,
	X86_INS_VPHADDWQ,
	X86_INS_VPHADDW,
	X86_INS_VPHMINPOSUW,
	X86_INS_VPHSUBBW,
	X86_INS_VPHSUBDQ,
	X86_INS_VPHSUBD,
	X86_INS_VPHSUBSW,
	X86_INS_VPHSUBWD,
	X86_INS_VPHSUBW,
	X86_INS_VPINSRB,
	X86_INS_VPINSRD,
	X86_INS_VPINSRQ,
	X86_INS_VPINSRW,
	X86_INS_VPLZCNTD,
	X86_INS_VPLZCNTQ,
	X86_INS_VPMACSDD,
	X86_INS_VPMACSDQH,
	X86_INS_VPMACSDQL,
	X86_INS_VPMACSSDD,
	X86_INS_VPMACSSDQH,
	X86_INS_VPMACSSDQL,
	X86_INS_VPMACSSWD,
	X86_INS_VPMACSSWW,
	X86_INS_VPMACSWD,
	X86_INS_VPMACSWW,
	X86_INS_VPMADCSSWD,
	X86_INS_VPMADCSWD,
	X86_INS_VPMADDUBSW,
	X86_INS_VPMADDWD,
	X86_INS_VPMASKMOVD,
	X86_INS_VPMASKMOVQ,
	X86_INS_VPMAXSB,
	X86_INS_VPMAXSD,
	X86_INS_VPMAXSQ,
	X86_INS_VPMAXSW,
	X86_INS_VPMAXUB,
	X86_INS_VPMAXUD,
	X86_INS_VPMAXUQ,
	X86_INS_VPMAXUW,
	X86_INS_VPMINSB,
	X86_INS_VPMINSD,
	X86_INS_VPMINSQ,
	X86_INS_VPMINSW,
	X86_INS_VPMINUB,
	X86_INS_VPMINUD,
	X86_INS_VPMINUQ,
	X86_INS_VPMINUW,
	X86_INS_VPMOVDB,
	X86_INS_VPMOVDW,
	X86_INS_VPMOVMSKB,
	X86_INS_VPMOVQB,
	X86_INS_VPMOVQD,
	X86_INS_VPMOVQW,
	X86_INS_VPMOVSDB,
	X86_INS_VPMOVSDW,
	X86_INS_VPMOVSQB,
	X86_INS_VPMOVSQD,
	X86_INS_VPMOVSQW,
	X86_INS_VPMOVSXBD,
	X86_INS_VPMOVSXBQ,
	X86_INS_VPMOVSXBW,
	X86_INS_VPMOVSXDQ,
	X86_INS_VPMOVSXWD,
	X86_INS_VPMOVSXWQ,
	X86_INS_VPMOVUSDB,
	X86_INS_VPMOVUSDW,
	X86_INS_VPMOVUSQB,
	X86_INS_VPMOVUSQD,
	X86_INS_VPMOVUSQW,
	X86_INS_VPMOVZXBD,
	X86_INS_VPMOVZXBQ,
	X86_INS_VPMOVZXBW,
	X86_INS_VPMOVZXDQ,
	X86_INS_VPMOVZXWD,
	X86_INS_VPMOVZXWQ,
	X86_INS_VPMULDQ,
	X86_INS_VPMULHRSW,
	X86_INS_VPMULHUW,
	X86_INS_VPMULHW,
	X86_INS_VPMULLD,
	X86_INS_VPMULLW,
	X86_INS_VPMULUDQ,
	X86_INS_VPORD,
	X86_INS_VPORQ,
	X86_INS_VPOR,
	X86_INS_VPPERM,
	X86_INS_VPROTB,
	X86_INS_VPROTD,
	X86_INS_VPROTQ,
	X86_INS_VPROTW,
	X86_INS_VPSADBW,
	X86_INS_VPSCATTERDD,
	X86_INS_VPSCATTERDQ,
	X86_INS_VPSCATTERQD,
	X86_INS_VPSCATTERQQ,
	X86_INS_VPSHAB,
	X86_INS_VPSHAD,
	X86_INS_VPSHAQ,
	X86_INS_VPSHAW,
	X86_INS_VPSHLB,
	X86_INS_VPSHLD,
	X86_INS_VPSHLQ,
	X86_INS_VPSHLW,
	X86_INS_VPSHUFB,
	X86_INS_VPSHUFD,
	X86_INS_VPSHUFHW,
	X86_INS_VPSHUFLW,
	X86_INS_VPSIGNB,
	X86_INS_VPSIGND,
	X86_INS_VPSIGNW,
	X86_INS_VPSLLDQ,
	X86_INS_VPSLLD,
	X86_INS_VPSLLQ,
	X86_INS_VPSLLVD,
	X86_INS_VPSLLVQ,
	X86_INS_VPSLLW,
	X86_INS_VPSRAD,
	X86_INS_VPSRAQ,
	X86_INS_VPSRAVD,
	X86_INS_VPSRAVQ,
	X86_INS_VPSRAW,
	X86_INS_VPSRLDQ,
	X86_INS_VPSRLD,
	X86_INS_VPSRLQ,
	X86_INS_VPSRLVD,
	X86_INS_VPSRLVQ,
	X86_INS_VPSRLW,
	X86_INS_VPSUBB,
	X86_INS_VPSUBD,
	X86_INS_VPSUBQ,
	X86_INS_VPSUBSB,
	X86_INS_VPSUBSW,
	X86_INS_VPSUBUSB,
	X86_INS_VPSUBUSW,
	X86_INS_VPSUBW,
	X86_INS_VPTESTMD,
	X86_INS_VPTESTMQ,
	X86_INS_VPTESTNMD,
	X86_INS_VPTESTNMQ,
	X86_INS_VPTEST,
	X86_INS_VPUNPCKHBW,
	X86_INS_VPUNPCKHDQ,
	X86_INS_VPUNPCKHQDQ,
	X86_INS_VPUNPCKHWD,
	X86_INS_VPUNPCKLBW,
	X86_INS_VPUNPCKLDQ,
	X86_INS_VPUNPCKLQDQ,
	X86_INS_VPUNPCKLWD,
	X86_INS_VPXORD,
	X86_INS_VPXORQ,
	X86_INS_VPXOR,
	X86_INS_VRCP14PD,
	X86_INS_VRCP14PS,
	X86_INS_VRCP14SD,
	X86_INS_VRCP14SS,
	X86_INS_VRCP28PD,
	X86_INS_VRCP28PS,
	X86_INS_VRCP28SD,
	X86_INS_VRCP28SS,
	X86_INS_VRCPPS,
	X86_INS_VRCPSS,
	X86_INS_VRNDSCALEPD,
	X86_INS_VRNDSCALEPS,
	X86_INS_VRNDSCALESD,
	X86_INS_VRNDSCALESS,
	X86_INS_VROUNDPD,
	X86_INS_VROUNDPS,
	X86_INS_VROUNDSD,
	X86_INS_VROUNDSS,
	X86_INS_VRSQRT14PD,
	X86_INS_VRSQRT14PS,
	X86_INS_VRSQRT14SD,
	X86_INS_VRSQRT14SS,
	X86_INS_VRSQRT28PD,
	X86_INS_VRSQRT28PS,
	X86_INS_VRSQRT28SD,
	X86_INS_VRSQRT28SS,
	X86_INS_VRSQRTPS,
	X86_INS_VRSQRTSS,
	X86_INS_VSCATTERDPD,
	X86_INS_VSCATTERDPS,
	X86_INS_VSCATTERPF0DPD,
	X86_INS_VSCATTERPF0DPS,
	X86_INS_VSCATTERPF0QPD,
	X86_INS_VSCATTERPF0QPS,
	X86_INS_VSCATTERPF1DPD,
	X86_INS_VSCATTERPF1DPS,
	X86_INS_VSCATTERPF1QPD,
	X86_INS_VSCATTERPF1QPS,
	X86_INS_VSCATTERQPD,
	X86_INS_VSCATTERQPS,
	X86_INS_VSHUFPD,
	X86_INS_VSHUFPS,
	X86_INS_VSQRTPD,
	X86_INS_VSQRTPS,
	X86_INS_VSQRTSD,
	X86_INS_VSQRTSS,
	X86_INS_VSTMXCSR,
	X86_INS_VSUBPD,
	X86_INS_VSUBPS,
	X86_INS_VSUBSD,
	X86_INS_VSUBSS,
	X86_INS_VTESTPD,
	X86_INS_VTESTPS,
	X86_INS_VUNPCKHPD,
	X86_INS_VUNPCKHPS,
	X86_INS_VUNPCKLPD,
	X86_INS_VUNPCKLPS,
	X86_INS_VZEROALL,
	X86_INS_VZEROUPPER,
	X86_INS_WAIT,
	X86_INS_WBINVD,
	X86_INS_WRFSBASE,
	X86_INS_WRGSBASE,
	X86_INS_WRMSR,
	X86_INS_XABORT,
	X86_INS_XACQUIRE,
	X86_INS_XBEGIN,
	X86_INS_XCHG,
	X86_INS_FXCH,
	X86_INS_XCRYPTCBC,
	X86_INS_XCRYPTCFB,
	X86_INS_XCRYPTCTR,
	X86_INS_XCRYPTECB,
	X86_INS_XCRYPTOFB,
	X86_INS_XEND,
	X86_INS_XGETBV,
	X86_INS_XLATB,
	X86_INS_XRELEASE,
	X86_INS_XRSTOR,
	X86_INS_XRSTOR64,
	X86_INS_XSAVE,
	X86_INS_XSAVE64,
	X86_INS_XSAVEOPT,
	X86_INS_XSAVEOPT64,
	X86_INS_XSETBV,
	X86_INS_XSHA1,
	X86_INS_XSHA256,
	X86_INS_XSTORE,
	X86_INS_XTEST,

	X86_INS_ENDING,	// mark the end of the list of insn
} x86_insn;

//> Group of X86 instructions
typedef enum  x86_insn_group {
	X86_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	X86_GRP_JUMP,	// = CS_GRP_JUMP
	// all call instructions
	X86_GRP_CALL,	// = CS_GRP_CALL
	// all return instructions
	X86_GRP_RET,	// = CS_GRP_RET
	// all interrupt instructions (int+syscall)
	X86_GRP_INT,	// = CS_GRP_INT
	// all interrupt return instructions
	X86_GRP_IRET,	// = CS_GRP_IRET

	//> Architecture-specific groups
	X86_GRP_VM = 128,	// all virtualization instructions (VT-x + AMD-V)
	X86_GRP_3DNOW,
	X86_GRP_AES,
	X86_GRP_ADX,
	X86_GRP_AVX,
	X86_GRP_AVX2,
	X86_GRP_AVX512,
	X86_GRP_BMI,
	X86_GRP_BMI2,
	X86_GRP_CMOV,
	X86_GRP_F16C,
	X86_GRP_FMA,
	X86_GRP_FMA4,
	X86_GRP_FSGSBASE,
	X86_GRP_HLE,
	X86_GRP_MMX,
	X86_GRP_MODE32,
	X86_GRP_MODE64,
	X86_GRP_RTM,
	X86_GRP_SHA,
	X86_GRP_SSE1,
	X86_GRP_SSE2,
	X86_GRP_SSE3,
	X86_GRP_SSE41,
	X86_GRP_SSE42,
	X86_GRP_SSE4A,
	X86_GRP_SSSE3,
	X86_GRP_PCLMUL,
	X86_GRP_XOP,
	X86_GRP_CDI,
	X86_GRP_ERI,
	X86_GRP_TBM,
	X86_GRP_16BITMODE,
	X86_GRP_NOT64BITMODE,
	X86_GRP_SGX,
	X86_GRP_DQI,
	X86_GRP_BWI,
	X86_GRP_PFI,
	X86_GRP_VLX,
	X86_GRP_SMAP,
	X86_GRP_NOVLX,

	X86_GRP_ENDING
} x86_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`Capstone/include/xcore.h`:

```h
#ifndef CAPSTONE_XCORE_H
#define CAPSTONE_XCORE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Operand type for instruction's operands
typedef enum xcore_op_type {
	XCORE_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	XCORE_OP_REG, // = CS_OP_REG (Register operand).
	XCORE_OP_IMM, // = CS_OP_IMM (Immediate operand).
	XCORE_OP_MEM, // = CS_OP_MEM (Memory operand).
} xcore_op_type;

// Instruction's operand referring to memory
// This is associated with XCORE_OP_MEM operand type above
typedef struct xcore_op_mem {
	uint8_t base;	// base register
	uint8_t index;	// index register
	int32_t disp;	// displacement/offset value
	int     direct;	// +1: forward, -1: backward
} xcore_op_mem;

// Instruction operand
typedef struct cs_xcore_op {
	xcore_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG operand
		int32_t imm;		// immediate value for IMM operand
		xcore_op_mem mem;		// base/disp value for MEM operand
	};
} cs_xcore_op;

// Instruction structure
typedef struct cs_xcore {
	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_xcore_op operands[8]; // operands for this instruction.
} cs_xcore;

//> XCore registers
typedef enum xcore_reg {
	XCORE_REG_INVALID = 0,

	XCORE_REG_CP,
	XCORE_REG_DP,
	XCORE_REG_LR,
	XCORE_REG_SP,
	XCORE_REG_R0,
	XCORE_REG_R1,
	XCORE_REG_R2,
	XCORE_REG_R3,
	XCORE_REG_R4,
	XCORE_REG_R5,
	XCORE_REG_R6,
	XCORE_REG_R7,
	XCORE_REG_R8,
	XCORE_REG_R9,
	XCORE_REG_R10,
	XCORE_REG_R11,

	//> pseudo registers
	XCORE_REG_PC,	// pc

	// internal thread registers
	// see The-XMOS-XS1-Architecture(X7879A).pdf
	XCORE_REG_SCP,	// save pc
	XCORE_REG_SSR,	// save status
	XCORE_REG_ET,	// exception type
	XCORE_REG_ED,	// exception data
	XCORE_REG_SED,	// save exception data
	XCORE_REG_KEP,	// kernel entry pointer
	XCORE_REG_KSP,	// kernel stack pointer
	XCORE_REG_ID,	// thread ID

	XCORE_REG_ENDING,	// <-- mark the end of the list of registers
} xcore_reg;

//> XCore instruction
typedef enum xcore_insn {
	XCORE_INS_INVALID = 0,

	XCORE_INS_ADD,
	XCORE_INS_ANDNOT,
	XCORE_INS_AND,
	XCORE_INS_ASHR,
	XCORE_INS_BAU,
	XCORE_INS_BITREV,
	XCORE_INS_BLA,
	XCORE_INS_BLAT,
	XCORE_INS_BL,
	XCORE_INS_BF,
	XCORE_INS_BT,
	XCORE_INS_BU,
	XCORE_INS_BRU,
	XCORE_INS_BYTEREV,
	XCORE_INS_CHKCT,
	XCORE_INS_CLRE,
	XCORE_INS_CLRPT,
	XCORE_INS_CLRSR,
	XCORE_INS_CLZ,
	XCORE_INS_CRC8,
	XCORE_INS_CRC32,
	XCORE_INS_DCALL,
	XCORE_INS_DENTSP,
	XCORE_INS_DGETREG,
	XCORE_INS_DIVS,
	XCORE_INS_DIVU,
	XCORE_INS_DRESTSP,
	XCORE_INS_DRET,
	XCORE_INS_ECALLF,
	XCORE_INS_ECALLT,
	XCORE_INS_EDU,
	XCORE_INS_EEF,
	XCORE_INS_EET,
	XCORE_INS_EEU,
	XCORE_INS_ENDIN,
	XCORE_INS_ENTSP,
	XCORE_INS_EQ,
	XCORE_INS_EXTDP,
	XCORE_INS_EXTSP,
	XCORE_INS_FREER,
	XCORE_INS_FREET,
	XCORE_INS_GETD,
	XCORE_INS_GET,
	XCORE_INS_GETN,
	XCORE_INS_GETR,
	XCORE_INS_GETSR,
	XCORE_INS_GETST,
	XCORE_INS_GETTS,
	XCORE_INS_INCT,
	XCORE_INS_INIT,
	XCORE_INS_INPW,
	XCORE_INS_INSHR,
	XCORE_INS_INT,
	XCORE_INS_IN,
	XCORE_INS_KCALL,
	XCORE_INS_KENTSP,
	XCORE_INS_KRESTSP,
	XCORE_INS_KRET,
	XCORE_INS_LADD,
	XCORE_INS_LD16S,
	XCORE_INS_LD8U,
	XCORE_INS_LDA16,
	XCORE_INS_LDAP,
	XCORE_INS_LDAW,
	XCORE_INS_LDC,
	XCORE_INS_LDW,
	XCORE_INS_LDIVU,
	XCORE_INS_LMUL,
	XCORE_INS_LSS,
	XCORE_INS_LSUB,
	XCORE_INS_LSU,
	XCORE_INS_MACCS,
	XCORE_INS_MACCU,
	XCORE_INS_MJOIN,
	XCORE_INS_MKMSK,
	XCORE_INS_MSYNC,
	XCORE_INS_MUL,
	XCORE_INS_NEG,
	XCORE_INS_NOT,
	XCORE_INS_OR,
	XCORE_INS_OUTCT,
	XCORE_INS_OUTPW,
	XCORE_INS_OUTSHR,
	XCORE_INS_OUTT,
	XCORE_INS_OUT,
	XCORE_INS_PEEK,
	XCORE_INS_REMS,
	XCORE_INS_REMU,
	XCORE_INS_RETSP,
	XCORE_INS_SETCLK,
	XCORE_INS_SET,
	XCORE_INS_SETC,
	XCORE_INS_SETD,
	XCORE_INS_SETEV,
	XCORE_INS_SETN,
	XCORE_INS_SETPSC,
	XCORE_INS_SETPT,
	XCORE_INS_SETRDY,
	XCORE_INS_SETSR,
	XCORE_INS_SETTW,
	XCORE_INS_SETV,
	XCORE_INS_SEXT,
	XCORE_INS_SHL,
	XCORE_INS_SHR,
	XCORE_INS_SSYNC,
	XCORE_INS_ST16,
	XCORE_INS_ST8,
	XCORE_INS_STW,
	XCORE_INS_SUB,
	XCORE_INS_SYNCR,
	XCORE_INS_TESTCT,
	XCORE_INS_TESTLCL,
	XCORE_INS_TESTWCT,
	XCORE_INS_TSETMR,
	XCORE_INS_START,
	XCORE_INS_WAITEF,
	XCORE_INS_WAITET,
	XCORE_INS_WAITEU,
	XCORE_INS_XOR,
	XCORE_INS_ZEXT,

	XCORE_INS_ENDING,   // <-- mark the end of the list of instructions
} xcore_insn;

//> Group of XCore instructions
typedef enum xcore_insn_group {
	XCORE_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	XCORE_GRP_JUMP,	// = CS_GRP_JUMP

	XCORE_GRP_ENDING,   // <-- mark the end of the list of groups
} xcore_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`LICENSE.md`:

```md
The MIT License (MIT)

Copyright (c) 2015 Stephen Eckels

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`PolyHook.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.23107.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PolyHook", "PolyHook\PolyHook.vcxproj", "{64269F60-A538-4327-82EE-AB4BF4766CE9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{64269F60-A538-4327-82EE-AB4BF4766CE9}.Debug|x64.ActiveCfg = Debug|x64
		{64269F60-A538-4327-82EE-AB4BF4766CE9}.Debug|x64.Build.0 = Debug|x64
		{64269F60-A538-4327-82EE-AB4BF4766CE9}.Debug|x86.ActiveCfg = Debug|Win32
		{64269F60-A538-4327-82EE-AB4BF4766CE9}.Debug|x86.Build.0 = Debug|Win32
		{64269F60-A538-4327-82EE-AB4BF4766CE9}.Release|x64.ActiveCfg = Release|x64
		{64269F60-A538-4327-82EE-AB4BF4766CE9}.Release|x64.Build.0 = Release|x64
		{64269F60-A538-4327-82EE-AB4BF4766CE9}.Release|x86.ActiveCfg = Release|Win32
		{64269F60-A538-4327-82EE-AB4BF4766CE9}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`PolyHook/CatchUnitTest.h`:

```h

/*
*  Catch v1.5.2
*  Generated: 2016-05-07 23:13:51.221005
*  ----------------------------------------------------------
*  This file has been merged from multiple headers. Please don't edit it directly
*  Copyright (c) 2012 Two Blue Cubes Ltd. All rights reserved.
*
*  Distributed under the Boost Software License, Version 1.0. (See accompanying
*  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
*/
#ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED

#define TWOBLUECUBES_CATCH_HPP_INCLUDED

#ifdef __clang__
#    pragma clang system_header
#elif defined __GNUC__
#    pragma GCC system_header
#endif

// #included from: internal/catch_suppress_warnings.h

#ifdef __clang__
#   ifdef __ICC // icpc defines the __clang__ macro
#       pragma warning(push)
#       pragma warning(disable: 161 1682)
#   else // __ICC
#       pragma clang diagnostic ignored "-Wglobal-constructors"
#       pragma clang diagnostic ignored "-Wvariadic-macros"
#       pragma clang diagnostic ignored "-Wc99-extensions"
#       pragma clang diagnostic ignored "-Wunused-variable"
#       pragma clang diagnostic push
#       pragma clang diagnostic ignored "-Wpadded"
#       pragma clang diagnostic ignored "-Wc++98-compat"
#       pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
#       pragma clang diagnostic ignored "-Wswitch-enum"
#       pragma clang diagnostic ignored "-Wcovered-switch-default"
#    endif
#elif defined __GNUC__
#    pragma GCC diagnostic ignored "-Wvariadic-macros"
#    pragma GCC diagnostic ignored "-Wunused-variable"
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wpadded"
#endif
#if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)
#  define CATCH_IMPL
#endif

#ifdef CATCH_IMPL
#  ifndef CLARA_CONFIG_MAIN
#    define CLARA_CONFIG_MAIN_NOT_DEFINED
#    define CLARA_CONFIG_MAIN
#  endif
#endif

// #included from: internal/catch_notimplemented_exception.h
#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED

// #included from: catch_common.h
#define TWOBLUECUBES_CATCH_COMMON_H_INCLUDED

#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
#ifdef CATCH_CONFIG_COUNTER
#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )
#else
#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
#endif

#define INTERNAL_CATCH_STRINGIFY2( expr ) #expr
#define INTERNAL_CATCH_STRINGIFY( expr ) INTERNAL_CATCH_STRINGIFY2( expr )

#include <sstream>
#include <stdexcept>
#include <algorithm>

// #included from: catch_compiler_capabilities.h
#define TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED

// Detect a number of compiler features - mostly C++11/14 conformance - by compiler
// The following features are defined:
//
// CATCH_CONFIG_CPP11_NULLPTR : is nullptr supported?
// CATCH_CONFIG_CPP11_NOEXCEPT : is noexcept supported?
// CATCH_CONFIG_CPP11_GENERATED_METHODS : The delete and default keywords for compiler generated methods
// CATCH_CONFIG_CPP11_IS_ENUM : std::is_enum is supported?
// CATCH_CONFIG_CPP11_TUPLE : std::tuple is supported
// CATCH_CONFIG_CPP11_LONG_LONG : is long long supported?
// CATCH_CONFIG_CPP11_OVERRIDE : is override supported?
// CATCH_CONFIG_CPP11_UNIQUE_PTR : is unique_ptr supported (otherwise use auto_ptr)

// CATCH_CONFIG_CPP11_OR_GREATER : Is C++11 supported?

// CATCH_CONFIG_VARIADIC_MACROS : are variadic macros supported?
// CATCH_CONFIG_COUNTER : is the __COUNTER__ macro supported?
// ****************
// Note to maintainers: if new toggles are added please document them
// in configuration.md, too
// ****************

// In general each macro has a _NO_<feature name> form
// (e.g. CATCH_CONFIG_CPP11_NO_NULLPTR) which disables the feature.
// Many features, at point of detection, define an _INTERNAL_ macro, so they
// can be combined, en-mass, with the _NO_ forms later.

// All the C++11 features can be disabled with CATCH_CONFIG_NO_CPP11

#if defined(__cplusplus) && __cplusplus >= 201103L
#  define CATCH_CPP11_OR_GREATER
#endif

#ifdef __clang__

#  if __has_feature(cxx_nullptr)
#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
#  endif

#  if __has_feature(cxx_noexcept)
#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
#  endif

#   if defined(CATCH_CPP11_OR_GREATER)
#       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS _Pragma( "clang diagnostic ignored \"-Wparentheses\"" )
#   endif

#endif // __clang__

////////////////////////////////////////////////////////////////////////////////
// Borland
#ifdef __BORLANDC__

#endif // __BORLANDC__

////////////////////////////////////////////////////////////////////////////////
// EDG
#ifdef __EDG_VERSION__

#endif // __EDG_VERSION__

////////////////////////////////////////////////////////////////////////////////
// Digital Mars
#ifdef __DMC__

#endif // __DMC__

////////////////////////////////////////////////////////////////////////////////
// GCC
#ifdef __GNUC__

#   if __GNUC__ == 4 && __GNUC_MINOR__ >= 6 && defined(__GXX_EXPERIMENTAL_CXX0X__)
#       define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
#   endif

#   if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS) && defined(CATCH_CPP11_OR_GREATER)
#       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS _Pragma( "GCC diagnostic ignored \"-Wparentheses\"" )
#   endif

// - otherwise more recent versions define __cplusplus >= 201103L
// and will get picked up below

#endif // __GNUC__

////////////////////////////////////////////////////////////////////////////////
// Visual C++
#ifdef _MSC_VER

#if (_MSC_VER >= 1600)
#   define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
#   define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
#endif

#if (_MSC_VER >= 1900 ) // (VC++ 13 (VS2015))
#define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
#define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#endif

#endif // _MSC_VER

////////////////////////////////////////////////////////////////////////////////

// Use variadic macros if the compiler supports them
#if ( defined _MSC_VER && _MSC_VER > 1400 && !defined __EDGE__) || \
    ( defined __WAVE__ && __WAVE_HAS_VARIADICS ) || \
    ( defined __GNUC__ && __GNUC__ >= 3 ) || \
    ( !defined __cplusplus && __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L )

#define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS

#endif

// Use __COUNTER__ if the compiler supports it
#if ( defined _MSC_VER && _MSC_VER >= 1300 ) || \
    ( defined __GNUC__  && __GNUC__ >= 4 && __GNUC_MINOR__ >= 3 ) || \
    ( defined __clang__ && __clang_major__ >= 3 )

#define CATCH_INTERNAL_CONFIG_COUNTER

#endif

////////////////////////////////////////////////////////////////////////////////
// C++ language feature support

// catch all support for C++11
#if defined(CATCH_CPP11_OR_GREATER)

#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_NULLPTR)
#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
#  endif

#  ifndef CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
#  endif

#  ifndef CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#    define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#  endif

#  ifndef CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM
#    define CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM
#  endif

#  ifndef CATCH_INTERNAL_CONFIG_CPP11_TUPLE
#    define CATCH_INTERNAL_CONFIG_CPP11_TUPLE
#  endif

#  ifndef CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
#    define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
#  endif

#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG)
#    define CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG
#  endif

#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE)
#    define CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE
#  endif
#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR)
#    define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
#  endif

#endif // __cplusplus >= 201103L

// Now set the actual defines based on the above + anything the user has configured
#if defined(CATCH_INTERNAL_CONFIG_CPP11_NULLPTR) && !defined(CATCH_CONFIG_CPP11_NO_NULLPTR) && !defined(CATCH_CONFIG_CPP11_NULLPTR) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_NULLPTR
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_CONFIG_CPP11_NO_NOEXCEPT) && !defined(CATCH_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_NOEXCEPT
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS) && !defined(CATCH_CONFIG_CPP11_NO_GENERATED_METHODS) && !defined(CATCH_CONFIG_CPP11_GENERATED_METHODS) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_GENERATED_METHODS
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM) && !defined(CATCH_CONFIG_CPP11_NO_IS_ENUM) && !defined(CATCH_CONFIG_CPP11_IS_ENUM) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_IS_ENUM
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_TUPLE) && !defined(CATCH_CONFIG_CPP11_NO_TUPLE) && !defined(CATCH_CONFIG_CPP11_TUPLE) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_TUPLE
#endif
#if defined(CATCH_INTERNAL_CONFIG_VARIADIC_MACROS) && !defined(CATCH_CONFIG_NO_VARIADIC_MACROS) && !defined(CATCH_CONFIG_VARIADIC_MACROS)
#   define CATCH_CONFIG_VARIADIC_MACROS
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_NO_LONG_LONG) && !defined(CATCH_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_LONG_LONG
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_NO_OVERRIDE) && !defined(CATCH_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_OVERRIDE
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_NO_UNIQUE_PTR) && !defined(CATCH_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_UNIQUE_PTR
#endif
#if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)
#   define CATCH_CONFIG_COUNTER
#endif

#if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)
#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
#endif

// noexcept support:
#if defined(CATCH_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_NOEXCEPT)
#  define CATCH_NOEXCEPT noexcept
#  define CATCH_NOEXCEPT_IS(x) noexcept(x)
#else
#  define CATCH_NOEXCEPT throw()
#  define CATCH_NOEXCEPT_IS(x)
#endif

// nullptr support
#ifdef CATCH_CONFIG_CPP11_NULLPTR
#   define CATCH_NULL nullptr
#else
#   define CATCH_NULL NULL
#endif

// override support
#ifdef CATCH_CONFIG_CPP11_OVERRIDE
#   define CATCH_OVERRIDE override
#else
#   define CATCH_OVERRIDE
#endif

// unique_ptr support
#ifdef CATCH_CONFIG_CPP11_UNIQUE_PTR
#   define CATCH_AUTO_PTR( T ) std::unique_ptr<T>
#else
#   define CATCH_AUTO_PTR( T ) std::auto_ptr<T>
#endif

namespace Catch {

	struct IConfig;

	struct CaseSensitive {
		enum Choice {
			Yes,
			No
		};
	};

	class NonCopyable {
#ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		NonCopyable(NonCopyable const&) = delete;
		NonCopyable(NonCopyable &&) = delete;
		NonCopyable& operator = (NonCopyable const&) = delete;
		NonCopyable& operator = (NonCopyable &&) = delete;
#else
		NonCopyable(NonCopyable const& info);
		NonCopyable& operator = (NonCopyable const&);
#endif

	protected:
		NonCopyable() {}
		virtual ~NonCopyable();
	};

	class SafeBool {
	public:
		typedef void (SafeBool::*type)() const;

		static type makeSafe(bool value) {
			return value ? &SafeBool::trueValue : 0;
		}
	private:
		void trueValue() const {}
	};

	template<typename ContainerT>
	inline void deleteAll(ContainerT& container) {
		typename ContainerT::const_iterator it = container.begin();
		typename ContainerT::const_iterator itEnd = container.end();
		for (; it != itEnd; ++it)
			delete *it;
	}
	template<typename AssociativeContainerT>
	inline void deleteAllValues(AssociativeContainerT& container) {
		typename AssociativeContainerT::const_iterator it = container.begin();
		typename AssociativeContainerT::const_iterator itEnd = container.end();
		for (; it != itEnd; ++it)
			delete it->second;
	}

	bool startsWith(std::string const& s, std::string const& prefix);
	bool endsWith(std::string const& s, std::string const& suffix);
	bool contains(std::string const& s, std::string const& infix);
	void toLowerInPlace(std::string& s);
	std::string toLower(std::string const& s);
	std::string trim(std::string const& str);
	bool replaceInPlace(std::string& str, std::string const& replaceThis, std::string const& withThis);

	struct pluralise {
		pluralise(std::size_t count, std::string const& label);

		friend std::ostream& operator << (std::ostream& os, pluralise const& pluraliser);

		std::size_t m_count;
		std::string m_label;
	};

	struct SourceLineInfo {

		SourceLineInfo();
		SourceLineInfo(char const* _file, std::size_t _line);
		SourceLineInfo(SourceLineInfo const& other);
#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		SourceLineInfo(SourceLineInfo &&) = default;
		SourceLineInfo& operator = (SourceLineInfo const&) = default;
		SourceLineInfo& operator = (SourceLineInfo &&) = default;
#  endif
		bool empty() const;
		bool operator == (SourceLineInfo const& other) const;
		bool operator < (SourceLineInfo const& other) const;

		std::string file;
		std::size_t line;
	};

	std::ostream& operator << (std::ostream& os, SourceLineInfo const& info);

	// This is just here to avoid compiler warnings with macro constants and boolean literals
	inline bool isTrue(bool value) { return value; }
	inline bool alwaysTrue() { return true; }
	inline bool alwaysFalse() { return false; }

	void throwLogicError(std::string const& message, SourceLineInfo const& locationInfo);

	void seedRng(IConfig const& config);
	unsigned int rngSeed();

	// Use this in variadic streaming macros to allow
	//    >> +StreamEndStop
	// as well as
	//    >> stuff +StreamEndStop
	struct StreamEndStop {
		std::string operator+() {
			return std::string();
		}
	};
	template<typename T>
	T const& operator + (T const& value, StreamEndStop) {
		return value;
	}
}

#define CATCH_INTERNAL_LINEINFO ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )
#define CATCH_INTERNAL_ERROR( msg ) ::Catch::throwLogicError( msg, CATCH_INTERNAL_LINEINFO );

#include <ostream>

namespace Catch {

	class NotImplementedException : public std::exception
	{
	public:
		NotImplementedException(SourceLineInfo const& lineInfo);
		NotImplementedException(NotImplementedException const&) {}

		virtual ~NotImplementedException() CATCH_NOEXCEPT {}

		virtual const char* what() const CATCH_NOEXCEPT;

	private:
		std::string m_what;
		SourceLineInfo m_lineInfo;
	};

} // end namespace Catch

  ///////////////////////////////////////////////////////////////////////////////
#define CATCH_NOT_IMPLEMENTED throw Catch::NotImplementedException( CATCH_INTERNAL_LINEINFO )

  // #included from: internal/catch_context.h
#define TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED

  // #included from: catch_interfaces_generators.h
#define TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED

#include <string>

namespace Catch {

	struct IGeneratorInfo {
		virtual ~IGeneratorInfo();
		virtual bool moveNext() = 0;
		virtual std::size_t getCurrentIndex() const = 0;
	};

	struct IGeneratorsForTest {
		virtual ~IGeneratorsForTest();

		virtual IGeneratorInfo& getGeneratorInfo(std::string const& fileInfo, std::size_t size) = 0;
		virtual bool moveNext() = 0;
	};

	IGeneratorsForTest* createGeneratorsForTest();

} // end namespace Catch

  // #included from: catch_ptr.hpp
#define TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

namespace Catch {

	// An intrusive reference counting smart pointer.
	// T must implement addRef() and release() methods
	// typically implementing the IShared interface
	template<typename T>
	class Ptr {
	public:
		Ptr() : m_p(CATCH_NULL) {}
		Ptr(T* p) : m_p(p) {
			if (m_p)
				m_p->addRef();
		}
		Ptr(Ptr const& other) : m_p(other.m_p) {
			if (m_p)
				m_p->addRef();
		}
		~Ptr() {
			if (m_p)
				m_p->release();
		}
		void reset() {
			if (m_p)
				m_p->release();
			m_p = CATCH_NULL;
		}
		Ptr& operator = (T* p) {
			Ptr temp(p);
			swap(temp);
			return *this;
		}
		Ptr& operator = (Ptr const& other) {
			Ptr temp(other);
			swap(temp);
			return *this;
		}
		void swap(Ptr& other) { std::swap(m_p, other.m_p); }
		T* get() const { return m_p; }
		T& operator*() const { return *m_p; }
		T* operator->() const { return m_p; }
		bool operator !() const { return m_p == CATCH_NULL; }
		operator SafeBool::type() const { return SafeBool::makeSafe(m_p != CATCH_NULL); }

	private:
		T* m_p;
	};

	struct IShared : NonCopyable {
		virtual ~IShared();
		virtual void addRef() const = 0;
		virtual void release() const = 0;
	};

	template<typename T = IShared>
	struct SharedImpl : T {

		SharedImpl() : m_rc(0) {}

		virtual void addRef() const {
			++m_rc;
		}
		virtual void release() const {
			if (--m_rc == 0)
				delete this;
		}

		mutable unsigned int m_rc;
	};

} // end namespace Catch

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#include <memory>
#include <vector>
#include <stdlib.h>

namespace Catch {

	class TestCase;
	class Stream;
	struct IResultCapture;
	struct IRunner;
	struct IGeneratorsForTest;
	struct IConfig;

	struct IContext
	{
		virtual ~IContext();

		virtual IResultCapture* getResultCapture() = 0;
		virtual IRunner* getRunner() = 0;
		virtual size_t getGeneratorIndex(std::string const& fileInfo, size_t totalSize) = 0;
		virtual bool advanceGeneratorsForCurrentTest() = 0;
		virtual Ptr<IConfig const> getConfig() const = 0;
	};

	struct IMutableContext : IContext
	{
		virtual ~IMutableContext();
		virtual void setResultCapture(IResultCapture* resultCapture) = 0;
		virtual void setRunner(IRunner* runner) = 0;
		virtual void setConfig(Ptr<IConfig const> const& config) = 0;
	};

	IContext& getCurrentContext();
	IMutableContext& getCurrentMutableContext();
	void cleanUpContext();
	Stream createStream(std::string const& streamName);

}

// #included from: internal/catch_test_registry.hpp
#define TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED

// #included from: catch_interfaces_testcase.h
#define TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED

#include <vector>

namespace Catch {

	class TestSpec;

	struct ITestCase : IShared {
		virtual void invoke() const = 0;
	protected:
		virtual ~ITestCase();
	};

	class TestCase;
	struct IConfig;

	struct ITestCaseRegistry {
		virtual ~ITestCaseRegistry();
		virtual std::vector<TestCase> const& getAllTests() const = 0;
		virtual std::vector<TestCase> const& getAllTestsSorted(IConfig const& config) const = 0;
	};

	bool matchTest(TestCase const& testCase, TestSpec const& testSpec, IConfig const& config);
	std::vector<TestCase> filterTests(std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config);
	std::vector<TestCase> const& getAllTestCasesSorted(IConfig const& config);

}

namespace Catch {

	template<typename C>
	class MethodTestCase : public SharedImpl<ITestCase> {

	public:
		MethodTestCase(void (C::*method)()) : m_method(method) {}

		virtual void invoke() const {
			C obj;
			(obj.*m_method)();
		}

	private:
		virtual ~MethodTestCase() {}

		void (C::*m_method)();
	};

	typedef void(*TestFunction)();

	struct NameAndDesc {
		NameAndDesc(const char* _name = "", const char* _description = "")
			: name(_name), description(_description)
		{}

		const char* name;
		const char* description;
	};

	void registerTestCase
	(ITestCase* testCase,
		char const* className,
		NameAndDesc const& nameAndDesc,
		SourceLineInfo const& lineInfo);

	struct AutoReg {

		AutoReg
		(TestFunction function,
			SourceLineInfo const& lineInfo,
			NameAndDesc const& nameAndDesc);

		template<typename C>
		AutoReg
		(void (C::*method)(),
			char const* className,
			NameAndDesc const& nameAndDesc,
			SourceLineInfo const& lineInfo) {

			registerTestCase
			(new MethodTestCase<C>(method),
				className,
				nameAndDesc,
				lineInfo);
		}

		~AutoReg();

	private:
		AutoReg(AutoReg const&);
		void operator= (AutoReg const&);
	};

	void registerTestCaseFunction
	(TestFunction function,
		SourceLineInfo const& lineInfo,
		NameAndDesc const& nameAndDesc);

} // end namespace Catch

#ifdef CATCH_CONFIG_VARIADIC_MACROS
  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
        static void TestName(); \
        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &TestName, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( __VA_ARGS__ ) ); }\
        static void TestName()
#define INTERNAL_CATCH_TESTCASE( ... ) \
        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )

  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &QualifiedMethod, "&" #QualifiedMethod, Catch::NameAndDesc( __VA_ARGS__ ), CATCH_INTERNAL_LINEINFO ); }

  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
        namespace{ \
            struct TestName : ClassName{ \
                void test(); \
            }; \
            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( &TestName::test, #ClassName, Catch::NameAndDesc( __VA_ARGS__ ), CATCH_INTERNAL_LINEINFO ); \
        } \
        void TestName::test()
#define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )

  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
        Catch::AutoReg( Function, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( __VA_ARGS__ ) );

#else
  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TESTCASE2( TestName, Name, Desc ) \
        static void TestName(); \
        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &TestName, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( Name, Desc ) ); }\
        static void TestName()
#define INTERNAL_CATCH_TESTCASE( Name, Desc ) \
        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), Name, Desc )

  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, Name, Desc ) \
        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &QualifiedMethod, "&" #QualifiedMethod, Catch::NameAndDesc( Name, Desc ), CATCH_INTERNAL_LINEINFO ); }

  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TEST_CASE_METHOD2( TestCaseName, ClassName, TestName, Desc )\
        namespace{ \
            struct TestCaseName : ClassName{ \
                void test(); \
            }; \
            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( &TestCaseName::test, #ClassName, Catch::NameAndDesc( TestName, Desc ), CATCH_INTERNAL_LINEINFO ); \
        } \
        void TestCaseName::test()
#define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, TestName, Desc )\
        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, TestName, Desc )

  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_REGISTER_TESTCASE( Function, Name, Desc ) \
        Catch::AutoReg( Function, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( Name, Desc ) );
#endif

  // #included from: internal/catch_capture.hpp
#define TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED

  // #included from: catch_result_builder.h
#define TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED

  // #included from: catch_result_type.h
#define TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED

namespace Catch {

	// ResultWas::OfType enum
	struct ResultWas {
		enum OfType {
			Unknown = -1,
			Ok = 0,
			Info = 1,
			Warning = 2,

			FailureBit = 0x10,

			ExpressionFailed = FailureBit | 1,
			ExplicitFailure = FailureBit | 2,

			Exception = 0x100 | FailureBit,

			ThrewException = Exception | 1,
			DidntThrowException = Exception | 2,

			FatalErrorCondition = 0x200 | FailureBit

		};
	};

	inline bool isOk(ResultWas::OfType resultType) {
		return (resultType & ResultWas::FailureBit) == 0;
	}
	inline bool isJustInfo(int flags) {
		return flags == ResultWas::Info;
	}

	// ResultDisposition::Flags enum
	struct ResultDisposition {
		enum Flags {
			Normal = 0x01,

			ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
			FalseTest = 0x04,           // Prefix expression with !
			SuppressFail = 0x08         // Failures are reported but do not fail the test
		};
	};

	inline ResultDisposition::Flags operator | (ResultDisposition::Flags lhs, ResultDisposition::Flags rhs) {
		return static_cast<ResultDisposition::Flags>(static_cast<int>(lhs) | static_cast<int>(rhs));
	}

	inline bool shouldContinueOnFailure(int flags) { return (flags & ResultDisposition::ContinueOnFailure) != 0; }
	inline bool isFalseTest(int flags) { return (flags & ResultDisposition::FalseTest) != 0; }
	inline bool shouldSuppressFailure(int flags) { return (flags & ResultDisposition::SuppressFail) != 0; }

} // end namespace Catch

  // #included from: catch_assertionresult.h
#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED

#include <string>

namespace Catch {

	struct AssertionInfo
	{
		AssertionInfo() {}
		AssertionInfo(std::string const& _macroName,
			SourceLineInfo const& _lineInfo,
			std::string const& _capturedExpression,
			ResultDisposition::Flags _resultDisposition);

		std::string macroName;
		SourceLineInfo lineInfo;
		std::string capturedExpression;
		ResultDisposition::Flags resultDisposition;
	};

	struct AssertionResultData
	{
		AssertionResultData() : resultType(ResultWas::Unknown) {}

		std::string reconstructedExpression;
		std::string message;
		ResultWas::OfType resultType;
	};

	class AssertionResult {
	public:
		AssertionResult();
		AssertionResult(AssertionInfo const& info, AssertionResultData const& data);
		~AssertionResult();
#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		AssertionResult(AssertionResult const&) = default;
		AssertionResult(AssertionResult &&) = default;
		AssertionResult& operator = (AssertionResult const&) = default;
		AssertionResult& operator = (AssertionResult &&) = default;
#  endif

		bool isOk() const;
		bool succeeded() const;
		ResultWas::OfType getResultType() const;
		bool hasExpression() const;
		bool hasMessage() const;
		std::string getExpression() const;
		std::string getExpressionInMacro() const;
		bool hasExpandedExpression() const;
		std::string getExpandedExpression() const;
		std::string getMessage() const;
		SourceLineInfo getSourceInfo() const;
		std::string getTestMacroName() const;

	protected:
		AssertionInfo m_info;
		AssertionResultData m_resultData;
	};

} // end namespace Catch

  // #included from: catch_matchers.hpp
#define TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED

namespace Catch {
	namespace Matchers {
		namespace Impl {

			namespace Generic {
				template<typename ExpressionT> class AllOf;
				template<typename ExpressionT> class AnyOf;
				template<typename ExpressionT> class Not;
			}

			template<typename ExpressionT>
			struct Matcher : SharedImpl<IShared>
			{
				typedef ExpressionT ExpressionType;

				virtual ~Matcher() {}
				virtual Ptr<Matcher> clone() const = 0;
				virtual bool match(ExpressionT const& expr) const = 0;
				virtual std::string toString() const = 0;

				Generic::AllOf<ExpressionT> operator && (Matcher<ExpressionT> const& other) const;
				Generic::AnyOf<ExpressionT> operator || (Matcher<ExpressionT> const& other) const;
				Generic::Not<ExpressionT> operator ! () const;
			};

			template<typename DerivedT, typename ExpressionT>
			struct MatcherImpl : Matcher<ExpressionT> {

				virtual Ptr<Matcher<ExpressionT> > clone() const {
					return Ptr<Matcher<ExpressionT> >(new DerivedT(static_cast<DerivedT const&>(*this)));
				}
			};

			namespace Generic {
				template<typename ExpressionT>
				class Not : public MatcherImpl<Not<ExpressionT>, ExpressionT> {
				public:
					explicit Not(Matcher<ExpressionT> const& matcher) : m_matcher(matcher.clone()) {}
					Not(Not const& other) : m_matcher(other.m_matcher) {}

					virtual bool match(ExpressionT const& expr) const CATCH_OVERRIDE {
						return !m_matcher->match(expr);
					}

					virtual std::string toString() const CATCH_OVERRIDE {
						return "not " + m_matcher->toString();
					}
				private:
					Ptr< Matcher<ExpressionT> > m_matcher;
				};

				template<typename ExpressionT>
				class AllOf : public MatcherImpl<AllOf<ExpressionT>, ExpressionT> {
				public:

					AllOf() {}
					AllOf(AllOf const& other) : m_matchers(other.m_matchers) {}

					AllOf& add(Matcher<ExpressionT> const& matcher) {
						m_matchers.push_back(matcher.clone());
						return *this;
					}
					virtual bool match(ExpressionT const& expr) const
					{
						for (std::size_t i = 0; i < m_matchers.size(); ++i)
							if (!m_matchers[i]->match(expr))
								return false;
						return true;
					}
					virtual std::string toString() const {
						std::ostringstream oss;
						oss << "( ";
						for (std::size_t i = 0; i < m_matchers.size(); ++i) {
							if (i != 0)
								oss << " and ";
							oss << m_matchers[i]->toString();
						}
						oss << " )";
						return oss.str();
					}

					AllOf operator && (Matcher<ExpressionT> const& other) const {
						AllOf allOfExpr(*this);
						allOfExpr.add(other);
						return allOfExpr;
					}

				private:
					std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;
				};

				template<typename ExpressionT>
				class AnyOf : public MatcherImpl<AnyOf<ExpressionT>, ExpressionT> {
				public:

					AnyOf() {}
					AnyOf(AnyOf const& other) : m_matchers(other.m_matchers) {}

					AnyOf& add(Matcher<ExpressionT> const& matcher) {
						m_matchers.push_back(matcher.clone());
						return *this;
					}
					virtual bool match(ExpressionT const& expr) const
					{
						for (std::size_t i = 0; i < m_matchers.size(); ++i)
							if (m_matchers[i]->match(expr))
								return true;
						return false;
					}
					virtual std::string toString() const {
						std::ostringstream oss;
						oss << "( ";
						for (std::size_t i = 0; i < m_matchers.size(); ++i) {
							if (i != 0)
								oss << " or ";
							oss << m_matchers[i]->toString();
						}
						oss << " )";
						return oss.str();
					}

					AnyOf operator || (Matcher<ExpressionT> const& other) const {
						AnyOf anyOfExpr(*this);
						anyOfExpr.add(other);
						return anyOfExpr;
					}

				private:
					std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;
				};

			} // namespace Generic

			template<typename ExpressionT>
			Generic::AllOf<ExpressionT> Matcher<ExpressionT>::operator && (Matcher<ExpressionT> const& other) const {
				Generic::AllOf<ExpressionT> allOfExpr;
				allOfExpr.add(*this);
				allOfExpr.add(other);
				return allOfExpr;
			}

			template<typename ExpressionT>
			Generic::AnyOf<ExpressionT> Matcher<ExpressionT>::operator || (Matcher<ExpressionT> const& other) const {
				Generic::AnyOf<ExpressionT> anyOfExpr;
				anyOfExpr.add(*this);
				anyOfExpr.add(other);
				return anyOfExpr;
			}

			template<typename ExpressionT>
			Generic::Not<ExpressionT> Matcher<ExpressionT>::operator ! () const {
				return Generic::Not<ExpressionT>(*this);
			}

			namespace StdString {

				inline std::string makeString(std::string const& str) { return str; }
				inline std::string makeString(const char* str) { return str ? std::string(str) : std::string(); }

				struct CasedString
				{
					CasedString(std::string const& str, CaseSensitive::Choice caseSensitivity)
						: m_caseSensitivity(caseSensitivity),
						m_str(adjustString(str))
					{}
					std::string adjustString(std::string const& str) const {
						return m_caseSensitivity == CaseSensitive::No
							? toLower(str)
							: str;

					}
					std::string toStringSuffix() const
					{
						return m_caseSensitivity == CaseSensitive::No
							? " (case insensitive)"
							: "";
					}
					CaseSensitive::Choice m_caseSensitivity;
					std::string m_str;
				};

				struct Equals : MatcherImpl<Equals, std::string> {
					Equals(std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes)
						: m_data(str, caseSensitivity)
					{}
					Equals(Equals const& other) : m_data(other.m_data) {}

					virtual ~Equals();

					virtual bool match(std::string const& expr) const {
						return m_data.m_str == m_data.adjustString(expr);;
					}
					virtual std::string toString() const {
						return "equals: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
					}

					CasedString m_data;
				};

				struct Contains : MatcherImpl<Contains, std::string> {
					Contains(std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes)
						: m_data(substr, caseSensitivity) {}
					Contains(Contains const& other) : m_data(other.m_data) {}

					virtual ~Contains();

					virtual bool match(std::string const& expr) const {
						return m_data.adjustString(expr).find(m_data.m_str) != std::string::npos;
					}
					virtual std::string toString() const {
						return "contains: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
					}

					CasedString m_data;
				};

				struct StartsWith : MatcherImpl<StartsWith, std::string> {
					StartsWith(std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes)
						: m_data(substr, caseSensitivity) {}

					StartsWith(StartsWith const& other) : m_data(other.m_data) {}

					virtual ~StartsWith();

					virtual bool match(std::string const& expr) const {
						return startsWith(m_data.adjustString(expr), m_data.m_str);
					}
					virtual std::string toString() const {
						return "starts with: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
					}

					CasedString m_data;
				};

				struct EndsWith : MatcherImpl<EndsWith, std::string> {
					EndsWith(std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes)
						: m_data(substr, caseSensitivity) {}
					EndsWith(EndsWith const& other) : m_data(other.m_data) {}

					virtual ~EndsWith();

					virtual bool match(std::string const& expr) const {
						return endsWith(m_data.adjustString(expr), m_data.m_str);
					}
					virtual std::string toString() const {
						return "ends with: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
					}

					CasedString m_data;
				};
			} // namespace StdString
		} // namespace Impl

		  // The following functions create the actual matcher objects.
		  // This allows the types to be inferred
		template<typename ExpressionT>
		inline Impl::Generic::Not<ExpressionT> Not(Impl::Matcher<ExpressionT> const& m) {
			return Impl::Generic::Not<ExpressionT>(m);
		}

		template<typename ExpressionT>
		inline Impl::Generic::AllOf<ExpressionT> AllOf(Impl::Matcher<ExpressionT> const& m1,
			Impl::Matcher<ExpressionT> const& m2) {
			return Impl::Generic::AllOf<ExpressionT>().add(m1).add(m2);
		}
		template<typename ExpressionT>
		inline Impl::Generic::AllOf<ExpressionT> AllOf(Impl::Matcher<ExpressionT> const& m1,
			Impl::Matcher<ExpressionT> const& m2,
			Impl::Matcher<ExpressionT> const& m3) {
			return Impl::Generic::AllOf<ExpressionT>().add(m1).add(m2).add(m3);
		}
		template<typename ExpressionT>
		inline Impl::Generic::AnyOf<ExpressionT> AnyOf(Impl::Matcher<ExpressionT> const& m1,
			Impl::Matcher<ExpressionT> const& m2) {
			return Impl::Generic::AnyOf<ExpressionT>().add(m1).add(m2);
		}
		template<typename ExpressionT>
		inline Impl::Generic::AnyOf<ExpressionT> AnyOf(Impl::Matcher<ExpressionT> const& m1,
			Impl::Matcher<ExpressionT> const& m2,
			Impl::Matcher<ExpressionT> const& m3) {
			return Impl::Generic::AnyOf<ExpressionT>().add(m1).add(m2).add(m3);
		}

		inline Impl::StdString::Equals      Equals(std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes) {
			return Impl::StdString::Equals(str, caseSensitivity);
		}
		inline Impl::StdString::Equals      Equals(const char* str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes) {
			return Impl::StdString::Equals(Impl::StdString::makeString(str), caseSensitivity);
		}
		inline Impl::StdString::Contains    Contains(std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes) {
			return Impl::StdString::Contains(substr, caseSensitivity);
		}
		inline Impl::StdString::Contains    Contains(const char* substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes) {
			return Impl::StdString::Contains(Impl::StdString::makeString(substr), caseSensitivity);
		}
		inline Impl::StdString::StartsWith  StartsWith(std::string const& substr) {
			return Impl::StdString::StartsWith(substr);
		}
		inline Impl::StdString::StartsWith  StartsWith(const char* substr) {
			return Impl::StdString::StartsWith(Impl::StdString::makeString(substr));
		}
		inline Impl::StdString::EndsWith    EndsWith(std::string const& substr) {
			return Impl::StdString::EndsWith(substr);
		}
		inline Impl::StdString::EndsWith    EndsWith(const char* substr) {
			return Impl::StdString::EndsWith(Impl::StdString::makeString(substr));
		}

	} // namespace Matchers

	using namespace Matchers;

} // namespace Catch

namespace Catch {

	struct TestFailureException {};

	template<typename T> class ExpressionLhs;

	struct STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison;

	struct CopyableStream {
		CopyableStream() {}
		CopyableStream(CopyableStream const& other) {
			oss << other.oss.str();
		}
		CopyableStream& operator=(CopyableStream const& other) {
			oss.str("");
			oss << other.oss.str();
			return *this;
		}
		std::ostringstream oss;
	};

	class ResultBuilder {
	public:
		ResultBuilder(char const* macroName,
			SourceLineInfo const& lineInfo,
			char const* capturedExpression,
			ResultDisposition::Flags resultDisposition,
			char const* secondArg = "");

		template<typename T>
		ExpressionLhs<T const&> operator <= (T const& operand);
		ExpressionLhs<bool> operator <= (bool value);

		template<typename T>
		ResultBuilder& operator << (T const& value) {
			m_stream.oss << value;
			return *this;
		}

		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && (RhsT const&);
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || (RhsT const&);

		ResultBuilder& setResultType(ResultWas::OfType result);
		ResultBuilder& setResultType(bool result);
		ResultBuilder& setLhs(std::string const& lhs);
		ResultBuilder& setRhs(std::string const& rhs);
		ResultBuilder& setOp(std::string const& op);

		void endExpression();

		std::string reconstructExpression() const;
		AssertionResult build() const;

		void useActiveException(ResultDisposition::Flags resultDisposition = ResultDisposition::Normal);
		void captureResult(ResultWas::OfType resultType);
		void captureExpression();
		void captureExpectedException(std::string const& expectedMessage);
		void captureExpectedException(Matchers::Impl::Matcher<std::string> const& matcher);
		void handleResult(AssertionResult const& result);
		void react();
		bool shouldDebugBreak() const;
		bool allowThrows() const;

	private:
		AssertionInfo m_assertionInfo;
		AssertionResultData m_data;
		struct ExprComponents {
			ExprComponents() : testFalse(false) {}
			bool testFalse;
			std::string lhs, rhs, op;
		} m_exprComponents;
		CopyableStream m_stream;

		bool m_shouldDebugBreak;
		bool m_shouldThrow;
	};

} // namespace Catch

  // Include after due to circular dependency:
  // #included from: catch_expression_lhs.hpp
#define TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED

  // #included from: catch_evaluate.hpp
#define TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4389) // '==' : signed/unsigned mismatch
#endif

#include <cstddef>

namespace Catch {
	namespace Internal {

		enum Operator {
			IsEqualTo,
			IsNotEqualTo,
			IsLessThan,
			IsGreaterThan,
			IsLessThanOrEqualTo,
			IsGreaterThanOrEqualTo
		};

		template<Operator Op> struct OperatorTraits { static const char* getName() { return "*error*"; } };
		template<> struct OperatorTraits<IsEqualTo> { static const char* getName() { return "=="; } };
		template<> struct OperatorTraits<IsNotEqualTo> { static const char* getName() { return "!="; } };
		template<> struct OperatorTraits<IsLessThan> { static const char* getName() { return "<"; } };
		template<> struct OperatorTraits<IsGreaterThan> { static const char* getName() { return ">"; } };
		template<> struct OperatorTraits<IsLessThanOrEqualTo> { static const char* getName() { return "<="; } };
		template<> struct OperatorTraits<IsGreaterThanOrEqualTo> { static const char* getName() { return ">="; } };

		template<typename T>
		inline T& opCast(T const& t) { return const_cast<T&>(t); }

		// nullptr_t support based on pull request #154 from Konstantin Baumann
#ifdef CATCH_CONFIG_CPP11_NULLPTR
		inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }
#endif // CATCH_CONFIG_CPP11_NULLPTR

		// So the compare overloads can be operator agnostic we convey the operator as a template
		// enum, which is used to specialise an Evaluator for doing the comparison.
		template<typename T1, typename T2, Operator Op>
		class Evaluator {};

		template<typename T1, typename T2>
		struct Evaluator<T1, T2, IsEqualTo> {
			static bool evaluate(T1 const& lhs, T2 const& rhs) {
				return bool(opCast(lhs) == opCast(rhs));
			}
		};
		template<typename T1, typename T2>
		struct Evaluator<T1, T2, IsNotEqualTo> {
			static bool evaluate(T1 const& lhs, T2 const& rhs) {
				return bool(opCast(lhs) != opCast(rhs));
			}
		};
		template<typename T1, typename T2>
		struct Evaluator<T1, T2, IsLessThan> {
			static bool evaluate(T1 const& lhs, T2 const& rhs) {
				return bool(opCast(lhs) < opCast(rhs));
			}
		};
		template<typename T1, typename T2>
		struct Evaluator<T1, T2, IsGreaterThan> {
			static bool evaluate(T1 const& lhs, T2 const& rhs) {
				return bool(opCast(lhs) > opCast(rhs));
			}
		};
		template<typename T1, typename T2>
		struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {
			static bool evaluate(T1 const& lhs, T2 const& rhs) {
				return bool(opCast(lhs) >= opCast(rhs));
			}
		};
		template<typename T1, typename T2>
		struct Evaluator<T1, T2, IsLessThanOrEqualTo> {
			static bool evaluate(T1 const& lhs, T2 const& rhs) {
				return bool(opCast(lhs) <= opCast(rhs));
			}
		};

		template<Operator Op, typename T1, typename T2>
		bool applyEvaluator(T1 const& lhs, T2 const& rhs) {
			return Evaluator<T1, T2, Op>::evaluate(lhs, rhs);
		}

		// This level of indirection allows us to specialise for integer types
		// to avoid signed/ unsigned warnings

		// "base" overload
		template<Operator Op, typename T1, typename T2>
		bool compare(T1 const& lhs, T2 const& rhs) {
			return Evaluator<T1, T2, Op>::evaluate(lhs, rhs);
		}

		// unsigned X to int
		template<Operator Op> bool compare(unsigned int lhs, int rhs) {
			return applyEvaluator<Op>(lhs, static_cast<unsigned int>(rhs));
		}
		template<Operator Op> bool compare(unsigned long lhs, int rhs) {
			return applyEvaluator<Op>(lhs, static_cast<unsigned int>(rhs));
		}
		template<Operator Op> bool compare(unsigned char lhs, int rhs) {
			return applyEvaluator<Op>(lhs, static_cast<unsigned int>(rhs));
		}

		// unsigned X to long
		template<Operator Op> bool compare(unsigned int lhs, long rhs) {
			return applyEvaluator<Op>(lhs, static_cast<unsigned long>(rhs));
		}
		template<Operator Op> bool compare(unsigned long lhs, long rhs) {
			return applyEvaluator<Op>(lhs, static_cast<unsigned long>(rhs));
		}
		template<Operator Op> bool compare(unsigned char lhs, long rhs) {
			return applyEvaluator<Op>(lhs, static_cast<unsigned long>(rhs));
		}

		// int to unsigned X
		template<Operator Op> bool compare(int lhs, unsigned int rhs) {
			return applyEvaluator<Op>(static_cast<unsigned int>(lhs), rhs);
		}
		template<Operator Op> bool compare(int lhs, unsigned long rhs) {
			return applyEvaluator<Op>(static_cast<unsigned int>(lhs), rhs);
		}
		template<Operator Op> bool compare(int lhs, unsigned char rhs) {
			return applyEvaluator<Op>(static_cast<unsigned int>(lhs), rhs);
		}

		// long to unsigned X
		template<Operator Op> bool compare(long lhs, unsigned int rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}
		template<Operator Op> bool compare(long lhs, unsigned long rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}
		template<Operator Op> bool compare(long lhs, unsigned char rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}

		// pointer to long (when comparing against NULL)
		template<Operator Op, typename T> bool compare(long lhs, T* rhs) {
			return Evaluator<T*, T*, Op>::evaluate(reinterpret_cast<T*>(lhs), rhs);
		}
		template<Operator Op, typename T> bool compare(T* lhs, long rhs) {
			return Evaluator<T*, T*, Op>::evaluate(lhs, reinterpret_cast<T*>(rhs));
		}

		// pointer to int (when comparing against NULL)
		template<Operator Op, typename T> bool compare(int lhs, T* rhs) {
			return Evaluator<T*, T*, Op>::evaluate(reinterpret_cast<T*>(lhs), rhs);
		}
		template<Operator Op, typename T> bool compare(T* lhs, int rhs) {
			return Evaluator<T*, T*, Op>::evaluate(lhs, reinterpret_cast<T*>(rhs));
		}

#ifdef CATCH_CONFIG_CPP11_LONG_LONG
		// long long to unsigned X
		template<Operator Op> bool compare(long long lhs, unsigned int rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}
		template<Operator Op> bool compare(long long lhs, unsigned long rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}
		template<Operator Op> bool compare(long long lhs, unsigned long long rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}
		template<Operator Op> bool compare(long long lhs, unsigned char rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}

		// unsigned long long to X
		template<Operator Op> bool compare(unsigned long long lhs, int rhs) {
			return applyEvaluator<Op>(static_cast<long>(lhs), rhs);
		}
		template<Operator Op> bool compare(unsigned long long lhs, long rhs) {
			return applyEvaluator<Op>(static_cast<long>(lhs), rhs);
		}
		template<Operator Op> bool compare(unsigned long long lhs, long long rhs) {
			return applyEvaluator<Op>(static_cast<long>(lhs), rhs);
		}
		template<Operator Op> bool compare(unsigned long long lhs, char rhs) {
			return applyEvaluator<Op>(static_cast<long>(lhs), rhs);
		}

		// pointer to long long (when comparing against NULL)
		template<Operator Op, typename T> bool compare(long long lhs, T* rhs) {
			return Evaluator<T*, T*, Op>::evaluate(reinterpret_cast<T*>(lhs), rhs);
		}
		template<Operator Op, typename T> bool compare(T* lhs, long long rhs) {
			return Evaluator<T*, T*, Op>::evaluate(lhs, reinterpret_cast<T*>(rhs));
		}
#endif // CATCH_CONFIG_CPP11_LONG_LONG

#ifdef CATCH_CONFIG_CPP11_NULLPTR
		// pointer to nullptr_t (when comparing against nullptr)
		template<Operator Op, typename T> bool compare(std::nullptr_t, T* rhs) {
			return Evaluator<T*, T*, Op>::evaluate(nullptr, rhs);
		}
		template<Operator Op, typename T> bool compare(T* lhs, std::nullptr_t) {
			return Evaluator<T*, T*, Op>::evaluate(lhs, nullptr);
		}
#endif // CATCH_CONFIG_CPP11_NULLPTR

	} // end of namespace Internal
} // end of namespace Catch

#ifdef _MSC_VER
#pragma warning(pop)
#endif

  // #included from: catch_tostring.h
#define TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED

#include <sstream>
#include <iomanip>
#include <limits>
#include <vector>
#include <cstddef>

#ifdef __OBJC__
  // #included from: catch_objc_arc.hpp
#define TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED

#import <Foundation/Foundation.h>

#ifdef __has_feature
#define CATCH_ARC_ENABLED __has_feature(objc_arc)
#else
#define CATCH_ARC_ENABLED 0
#endif

void arcSafeRelease(NSObject* obj);
id performOptionalSelector(id obj, SEL sel);

#if !CATCH_ARC_ENABLED
inline void arcSafeRelease(NSObject* obj) {
	[obj release];
}
inline id performOptionalSelector(id obj, SEL sel) {
	if ([obj respondsToSelector : sel])
		return[obj performSelector : sel];
	return nil;
}
#define CATCH_UNSAFE_UNRETAINED
#define CATCH_ARC_STRONG
#else
inline void arcSafeRelease(NSObject*) {}
inline id performOptionalSelector(id obj, SEL sel) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
#endif
	if ([obj respondsToSelector : sel])
		return[obj performSelector : sel];
#ifdef __clang__
#pragma clang diagnostic pop
#endif
	return nil;
}
#define CATCH_UNSAFE_UNRETAINED __unsafe_unretained
#define CATCH_ARC_STRONG __strong
#endif

#endif

#ifdef CATCH_CONFIG_CPP11_TUPLE
#include <tuple>
#endif

#ifdef CATCH_CONFIG_CPP11_IS_ENUM
#include <type_traits>
#endif

namespace Catch {

	// Why we're here.
	template<typename T>
	std::string toString(T const& value);

	// Built in overloads

	std::string toString(std::string const& value);
	std::string toString(std::wstring const& value);
	std::string toString(const char* const value);
	std::string toString(char* const value);
	std::string toString(const wchar_t* const value);
	std::string toString(wchar_t* const value);
	std::string toString(int value);
	std::string toString(unsigned long value);
	std::string toString(unsigned int value);
	std::string toString(const double value);
	std::string toString(const float value);
	std::string toString(bool value);
	std::string toString(char value);
	std::string toString(signed char value);
	std::string toString(unsigned char value);

#ifdef CATCH_CONFIG_CPP11_LONG_LONG
	std::string toString(long long value);
	std::string toString(unsigned long long value);
#endif

#ifdef CATCH_CONFIG_CPP11_NULLPTR
	std::string toString(std::nullptr_t);
#endif

#ifdef __OBJC__
	std::string toString(NSString const * const& nsstring);
	std::string toString(NSString * CATCH_ARC_STRONG const& nsstring);
	std::string toString(NSObject* const& nsObject);
#endif

	namespace Detail {

		extern const std::string unprintableString;

		struct BorgType {
			template<typename T> BorgType(T const&);
		};

		struct TrueType { char sizer[1]; };
		struct FalseType { char sizer[2]; };

		TrueType& testStreamable(std::ostream&);
		FalseType testStreamable(FalseType);

		FalseType operator<<(std::ostream const&, BorgType const&);

		template<typename T>
		struct IsStreamInsertable {
			static std::ostream &s;
			static T  const&t;
			enum { value = sizeof(testStreamable(s << t)) == sizeof(TrueType) };
		};

#if defined(CATCH_CONFIG_CPP11_IS_ENUM)
		template<typename T,
			bool IsEnum = std::is_enum<T>::value
		>
			struct EnumStringMaker
		{
			static std::string convert(T const&) { return unprintableString; }
		};

		template<typename T>
		struct EnumStringMaker<T, true>
		{
			static std::string convert(T const& v)
			{
				return ::Catch::toString(
					static_cast<typename std::underlying_type<T>::type>(v)
				);
			}
		};
#endif
		template<bool C>
		struct StringMakerBase {
#if defined(CATCH_CONFIG_CPP11_IS_ENUM)
			template<typename T>
			static std::string convert(T const& v)
			{
				return EnumStringMaker<T>::convert(v);
			}
#else
			template<typename T>
			static std::string convert(T const&) { return unprintableString; }
#endif
		};

		template<>
		struct StringMakerBase<true> {
			template<typename T>
			static std::string convert(T const& _value) {
				std::ostringstream oss;
				oss << _value;
				return oss.str();
			}
		};

		std::string rawMemoryToString(const void *object, std::size_t size);

		template<typename T>
		inline std::string rawMemoryToString(const T& object) {
			return rawMemoryToString(&object, sizeof(object));
		}

	} // end namespace Detail

	template<typename T>
	struct StringMaker :
		Detail::StringMakerBase<Detail::IsStreamInsertable<T>::value> {};

	template<typename T>
	struct StringMaker<T*> {
		template<typename U>
		static std::string convert(U* p) {
			if (!p)
				return "NULL";
			else
				return Detail::rawMemoryToString(p);
		}
	};

	template<typename R, typename C>
	struct StringMaker<R C::*> {
		static std::string convert(R C::* p) {
			if (!p)
				return "NULL";
			else
				return Detail::rawMemoryToString(p);
		}
	};

	namespace Detail {
		template<typename InputIterator>
		std::string rangeToString(InputIterator first, InputIterator last);
	}

	//template<typename T, typename Allocator>
	//struct StringMaker<std::vector<T, Allocator> > {
	//    static std::string convert( std::vector<T,Allocator> const& v ) {
	//        return Detail::rangeToString( v.begin(), v.end() );
	//    }
	//};

	template<typename T, typename Allocator>
	std::string toString(std::vector<T, Allocator> const& v) {
		return Detail::rangeToString(v.begin(), v.end());
	}

#ifdef CATCH_CONFIG_CPP11_TUPLE

	// toString for tuples
	namespace TupleDetail {
		template<
			typename Tuple,
			std::size_t N = 0,
			bool = (N < std::tuple_size<Tuple>::value)
			>
			struct ElementPrinter {
			static void print(const Tuple& tuple, std::ostream& os)
			{
				os << (N ? ", " : " ")
					<< Catch::toString(std::get<N>(tuple));
				ElementPrinter<Tuple, N + 1>::print(tuple, os);
			}
		};

		template<
			typename Tuple,
			std::size_t N
		>
			struct ElementPrinter<Tuple, N, false> {
			static void print(const Tuple&, std::ostream&) {}
		};

	}

	template<typename ...Types>
	struct StringMaker<std::tuple<Types...>> {

		static std::string convert(const std::tuple<Types...>& tuple)
		{
			std::ostringstream os;
			os << '{';
			TupleDetail::ElementPrinter<std::tuple<Types...>>::print(tuple, os);
			os << " }";
			return os.str();
		}
	};
#endif // CATCH_CONFIG_CPP11_TUPLE

	namespace Detail {
		template<typename T>
		std::string makeString(T const& value) {
			return StringMaker<T>::convert(value);
		}
	} // end namespace Detail

	  /// \brief converts any type to a string
	  ///
	  /// The default template forwards on to ostringstream - except when an
	  /// ostringstream overload does not exist - in which case it attempts to detect
	  /// that and writes {?}.
	  /// Overload (not specialise) this template for custom typs that you don't want
	  /// to provide an ostream overload for.
	template<typename T>
	std::string toString(T const& value) {
		return StringMaker<T>::convert(value);
	}

	namespace Detail {
		template<typename InputIterator>
		std::string rangeToString(InputIterator first, InputIterator last) {
			std::ostringstream oss;
			oss << "{ ";
			if (first != last) {
				oss << Catch::toString(*first);
				for (++first; first != last; ++first)
					oss << ", " << Catch::toString(*first);
			}
			oss << " }";
			return oss.str();
		}
	}

} // end namespace Catch

namespace Catch {

	// Wraps the LHS of an expression and captures the operator and RHS (if any) -
	// wrapping them all in a ResultBuilder object
	template<typename T>
	class ExpressionLhs {
		ExpressionLhs& operator = (ExpressionLhs const&);
#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		ExpressionLhs& operator = (ExpressionLhs &&) = delete;
#  endif

	public:
		ExpressionLhs(ResultBuilder& rb, T lhs) : m_rb(rb), m_lhs(lhs) {}
#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		ExpressionLhs(ExpressionLhs const&) = default;
		ExpressionLhs(ExpressionLhs &&) = default;
#  endif

		template<typename RhsT>
		ResultBuilder& operator == (RhsT const& rhs) {
			return captureExpression<Internal::IsEqualTo>(rhs);
		}

		template<typename RhsT>
		ResultBuilder& operator != (RhsT const& rhs) {
			return captureExpression<Internal::IsNotEqualTo>(rhs);
		}

		template<typename RhsT>
		ResultBuilder& operator < (RhsT const& rhs) {
			return captureExpression<Internal::IsLessThan>(rhs);
		}

		template<typename RhsT>
		ResultBuilder& operator > (RhsT const& rhs) {
			return captureExpression<Internal::IsGreaterThan>(rhs);
		}

		template<typename RhsT>
		ResultBuilder& operator <= (RhsT const& rhs) {
			return captureExpression<Internal::IsLessThanOrEqualTo>(rhs);
		}

		template<typename RhsT>
		ResultBuilder& operator >= (RhsT const& rhs) {
			return captureExpression<Internal::IsGreaterThanOrEqualTo>(rhs);
		}

		ResultBuilder& operator == (bool rhs) {
			return captureExpression<Internal::IsEqualTo>(rhs);
		}

		ResultBuilder& operator != (bool rhs) {
			return captureExpression<Internal::IsNotEqualTo>(rhs);
		}

		void endExpression() {
			bool value = m_lhs ? true : false;
			m_rb
				.setLhs(Catch::toString(value))
				.setResultType(value)
				.endExpression();
		}

		// Only simple binary expressions are allowed on the LHS.
		// If more complex compositions are required then place the sub expression in parentheses
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator + (RhsT const&);
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator - (RhsT const&);
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator / (RhsT const&);
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator * (RhsT const&);
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && (RhsT const&);
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || (RhsT const&);

	private:
		template<Internal::Operator Op, typename RhsT>
		ResultBuilder& captureExpression(RhsT const& rhs) {
			return m_rb
				.setResultType(Internal::compare<Op>(m_lhs, rhs))
				.setLhs(Catch::toString(m_lhs))
				.setRhs(Catch::toString(rhs))
				.setOp(Internal::OperatorTraits<Op>::getName());
		}

	private:
		ResultBuilder& m_rb;
		T m_lhs;
	};

} // end namespace Catch


namespace Catch {

	template<typename T>
	inline ExpressionLhs<T const&> ResultBuilder::operator <= (T const& operand) {
		return ExpressionLhs<T const&>(*this, operand);
	}

	inline ExpressionLhs<bool> ResultBuilder::operator <= (bool value) {
		return ExpressionLhs<bool>(*this, value);
	}

} // namespace Catch

  // #included from: catch_message.h
#define TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED

#include <string>

namespace Catch {

	struct MessageInfo {
		MessageInfo(std::string const& _macroName,
			SourceLineInfo const& _lineInfo,
			ResultWas::OfType _type);

		std::string macroName;
		SourceLineInfo lineInfo;
		ResultWas::OfType type;
		std::string message;
		unsigned int sequence;

		bool operator == (MessageInfo const& other) const {
			return sequence == other.sequence;
		}
		bool operator < (MessageInfo const& other) const {
			return sequence < other.sequence;
		}
	private:
		static unsigned int globalCount;
	};

	struct MessageBuilder {
		MessageBuilder(std::string const& macroName,
			SourceLineInfo const& lineInfo,
			ResultWas::OfType type)
			: m_info(macroName, lineInfo, type)
		{}

		template<typename T>
		MessageBuilder& operator << (T const& value) {
			m_stream << value;
			return *this;
		}

		MessageInfo m_info;
		std::ostringstream m_stream;
	};

	class ScopedMessage {
	public:
		ScopedMessage(MessageBuilder const& builder);
		ScopedMessage(ScopedMessage const& other);
		~ScopedMessage();

		MessageInfo m_info;
	};

} // end namespace Catch

  // #included from: catch_interfaces_capture.h
#define TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED

#include <string>

namespace Catch {

	class TestCase;
	class AssertionResult;
	struct AssertionInfo;
	struct SectionInfo;
	struct SectionEndInfo;
	struct MessageInfo;
	class ScopedMessageBuilder;
	struct Counts;

	struct IResultCapture {

		virtual ~IResultCapture();

		virtual void assertionEnded(AssertionResult const& result) = 0;
		virtual bool sectionStarted(SectionInfo const& sectionInfo,
			Counts& assertions) = 0;
		virtual void sectionEnded(SectionEndInfo const& endInfo) = 0;
		virtual void sectionEndedEarly(SectionEndInfo const& endInfo) = 0;
		virtual void pushScopedMessage(MessageInfo const& message) = 0;
		virtual void popScopedMessage(MessageInfo const& message) = 0;

		virtual std::string getCurrentTestName() const = 0;
		virtual const AssertionResult* getLastResult() const = 0;

		virtual void handleFatalErrorCondition(std::string const& message) = 0;
	};

	IResultCapture& getResultCapture();
}

// #included from: catch_debugger.h
#define TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED

// #included from: catch_platform.h
#define TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED

#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
#define CATCH_PLATFORM_MAC
#elif  defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
#define CATCH_PLATFORM_IPHONE
#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)
#define CATCH_PLATFORM_WINDOWS
#endif

#include <string>

namespace Catch {

	bool isDebuggerActive();
	void writeToDebugConsole(std::string const& text);
}

#ifdef CATCH_PLATFORM_MAC

// The following code snippet based on:
// http://cocoawithlove.com/2008/03/break-into-debugger.html
#ifdef DEBUG
#if defined(__ppc64__) || defined(__ppc__)
#define CATCH_BREAK_INTO_DEBUGGER() \
                if( Catch::isDebuggerActive() ) { \
                    __asm__("li r0, 20\nsc\nnop\nli r0, 37\nli r4, 2\nsc\nnop\n" \
                    : : : "memory","r0","r3","r4" ); \
                }
#else
#define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) {__asm__("int $3\n" : : );}
#endif
#endif

#elif defined(_MSC_VER)
#define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { __debugbreak(); }
#elif defined(__MINGW32__)
extern "C" __declspec(dllimport) void __stdcall DebugBreak();
#define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { DebugBreak(); }
#endif

#ifndef CATCH_BREAK_INTO_DEBUGGER
#define CATCH_BREAK_INTO_DEBUGGER() Catch::alwaysTrue();
#endif

// #included from: catch_interfaces_runner.h
#define TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED

namespace Catch {
	class TestCase;

	struct IRunner {
		virtual ~IRunner();
		virtual bool aborting() const = 0;
	};
}

///////////////////////////////////////////////////////////////////////////////
// In the event of a failure works out if the debugger needs to be invoked
// and/or an exception thrown and takes appropriate action.
// This needs to be done as a macro so the debugger will stop in the user
// source code rather than in Catch library code
#define INTERNAL_CATCH_REACT( resultBuilder ) \
    if( resultBuilder.shouldDebugBreak() ) CATCH_BREAK_INTO_DEBUGGER(); \
    resultBuilder.react();

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TEST( expr, resultDisposition, macroName ) \
    do { \
        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
        try { \
            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
            ( __catchResult <= expr ).endExpression(); \
        } \
        catch( ... ) { \
            __catchResult.useActiveException( Catch::ResultDisposition::Normal ); \
        } \
        INTERNAL_CATCH_REACT( __catchResult ) \
    } while( Catch::isTrue( false && static_cast<bool>(expr) ) ) // expr here is never evaluated at runtime but it forces the compiler to give it a look

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_IF( expr, resultDisposition, macroName ) \
    INTERNAL_CATCH_TEST( expr, resultDisposition, macroName ); \
    if( Catch::getResultCapture().getLastResult()->succeeded() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_ELSE( expr, resultDisposition, macroName ) \
    INTERNAL_CATCH_TEST( expr, resultDisposition, macroName ); \
    if( !Catch::getResultCapture().getLastResult()->succeeded() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_NO_THROW( expr, resultDisposition, macroName ) \
    do { \
        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
        try { \
            expr; \
            __catchResult.captureResult( Catch::ResultWas::Ok ); \
        } \
        catch( ... ) { \
            __catchResult.useActiveException( resultDisposition ); \
        } \
        INTERNAL_CATCH_REACT( __catchResult ) \
    } while( Catch::alwaysFalse() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_THROWS( expr, resultDisposition, matcher, macroName ) \
    do { \
        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition, #matcher ); \
        if( __catchResult.allowThrows() ) \
            try { \
                expr; \
                __catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \
            } \
            catch( ... ) { \
                __catchResult.captureExpectedException( matcher ); \
            } \
        else \
            __catchResult.captureResult( Catch::ResultWas::Ok ); \
        INTERNAL_CATCH_REACT( __catchResult ) \
    } while( Catch::alwaysFalse() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_THROWS_AS( expr, exceptionType, resultDisposition, macroName ) \
    do { \
        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
        if( __catchResult.allowThrows() ) \
            try { \
                expr; \
                __catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \
            } \
            catch( exceptionType ) { \
                __catchResult.captureResult( Catch::ResultWas::Ok ); \
            } \
            catch( ... ) { \
                __catchResult.useActiveException( resultDisposition ); \
            } \
        else \
            __catchResult.captureResult( Catch::ResultWas::Ok ); \
        INTERNAL_CATCH_REACT( __catchResult ) \
    } while( Catch::alwaysFalse() )

///////////////////////////////////////////////////////////////////////////////
#ifdef CATCH_CONFIG_VARIADIC_MACROS
#define INTERNAL_CATCH_MSG( messageType, resultDisposition, macroName, ... ) \
        do { \
            Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, "", resultDisposition ); \
            __catchResult << __VA_ARGS__ + ::Catch::StreamEndStop(); \
            __catchResult.captureResult( messageType ); \
            INTERNAL_CATCH_REACT( __catchResult ) \
        } while( Catch::alwaysFalse() )
#else
#define INTERNAL_CATCH_MSG( messageType, resultDisposition, macroName, log ) \
        do { \
            Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, "", resultDisposition ); \
            __catchResult << log + ::Catch::StreamEndStop(); \
            __catchResult.captureResult( messageType ); \
            INTERNAL_CATCH_REACT( __catchResult ) \
        } while( Catch::alwaysFalse() )
#endif

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_INFO( log, macroName ) \
    Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage ) = Catch::MessageBuilder( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log;

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CHECK_THAT( arg, matcher, resultDisposition, macroName ) \
    do { \
        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #arg ", " #matcher, resultDisposition ); \
        try { \
            std::string matcherAsString = (matcher).toString(); \
            __catchResult \
                .setLhs( Catch::toString( arg ) ) \
                .setRhs( matcherAsString == Catch::Detail::unprintableString ? #matcher : matcherAsString ) \
                .setOp( "matches" ) \
                .setResultType( (matcher).match( arg ) ); \
            __catchResult.captureExpression(); \
        } catch( ... ) { \
            __catchResult.useActiveException( resultDisposition | Catch::ResultDisposition::ContinueOnFailure ); \
        } \
        INTERNAL_CATCH_REACT( __catchResult ) \
    } while( Catch::alwaysFalse() )

// #included from: internal/catch_section.h
#define TWOBLUECUBES_CATCH_SECTION_H_INCLUDED

// #included from: catch_section_info.h
#define TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED

// #included from: catch_totals.hpp
#define TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED

#include <cstddef>

namespace Catch {

	struct Counts {
		Counts() : passed(0), failed(0), failedButOk(0) {}

		Counts operator - (Counts const& other) const {
			Counts diff;
			diff.passed = passed - other.passed;
			diff.failed = failed - other.failed;
			diff.failedButOk = failedButOk - other.failedButOk;
			return diff;
		}
		Counts& operator += (Counts const& other) {
			passed += other.passed;
			failed += other.failed;
			failedButOk += other.failedButOk;
			return *this;
		}

		std::size_t total() const {
			return passed + failed + failedButOk;
		}
		bool allPassed() const {
			return failed == 0 && failedButOk == 0;
		}
		bool allOk() const {
			return failed == 0;
		}

		std::size_t passed;
		std::size_t failed;
		std::size_t failedButOk;
	};

	struct Totals {

		Totals operator - (Totals const& other) const {
			Totals diff;
			diff.assertions = assertions - other.assertions;
			diff.testCases = testCases - other.testCases;
			return diff;
		}

		Totals delta(Totals const& prevTotals) const {
			Totals diff = *this - prevTotals;
			if (diff.assertions.failed > 0)
				++diff.testCases.failed;
			else if (diff.assertions.failedButOk > 0)
				++diff.testCases.failedButOk;
			else
				++diff.testCases.passed;
			return diff;
		}

		Totals& operator += (Totals const& other) {
			assertions += other.assertions;
			testCases += other.testCases;
			return *this;
		}

		Counts assertions;
		Counts testCases;
	};
}

namespace Catch {

	struct SectionInfo {
		SectionInfo
		(SourceLineInfo const& _lineInfo,
			std::string const& _name,
			std::string const& _description = std::string());

		std::string name;
		std::string description;
		SourceLineInfo lineInfo;
	};

	struct SectionEndInfo {
		SectionEndInfo(SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds)
			: sectionInfo(_sectionInfo), prevAssertions(_prevAssertions), durationInSeconds(_durationInSeconds)
		{}

		SectionInfo sectionInfo;
		Counts prevAssertions;
		double durationInSeconds;
	};

} // end namespace Catch

  // #included from: catch_timer.h
#define TWOBLUECUBES_CATCH_TIMER_H_INCLUDED

#ifdef CATCH_PLATFORM_WINDOWS
typedef unsigned long long uint64_t;
#else
#include <stdint.h>
#endif

namespace Catch {

	class Timer {
	public:
		Timer() : m_ticks(0) {}
		void start();
		unsigned int getElapsedMicroseconds() const;
		unsigned int getElapsedMilliseconds() const;
		double getElapsedSeconds() const;

	private:
		uint64_t m_ticks;
	};

} // namespace Catch

#include <string>

namespace Catch {

	class Section : NonCopyable {
	public:
		Section(SectionInfo const& info);
		~Section();

		// This indicates whether the section should be executed or not
		operator bool() const;

	private:
		SectionInfo m_info;

		std::string m_name;
		Counts m_assertions;
		bool m_sectionIncluded;
		Timer m_timer;
	};

} // end namespace Catch

#ifdef CATCH_CONFIG_VARIADIC_MACROS
#define INTERNAL_CATCH_SECTION( ... ) \
        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) )
#else
#define INTERNAL_CATCH_SECTION( name, desc ) \
        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, name, desc ) )
#endif

  // #included from: internal/catch_generators.hpp
#define TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED

#include <iterator>
#include <vector>
#include <string>
#include <stdlib.h>

namespace Catch {

	template<typename T>
	struct IGenerator {
		virtual ~IGenerator() {}
		virtual T getValue(std::size_t index) const = 0;
		virtual std::size_t size() const = 0;
	};

	template<typename T>
	class BetweenGenerator : public IGenerator<T> {
	public:
		BetweenGenerator(T from, T to) : m_from(from), m_to(to) {}

		virtual T getValue(std::size_t index) const {
			return m_from + static_cast<int>(index);
		}

		virtual std::size_t size() const {
			return static_cast<std::size_t>(1 + m_to - m_from);
		}

	private:

		T m_from;
		T m_to;
	};

	template<typename T>
	class ValuesGenerator : public IGenerator<T> {
	public:
		ValuesGenerator() {}

		void add(T value) {
			m_values.push_back(value);
		}

		virtual T getValue(std::size_t index) const {
			return m_values[index];
		}

		virtual std::size_t size() const {
			return m_values.size();
		}

	private:
		std::vector<T> m_values;
	};

	template<typename T>
	class CompositeGenerator {
	public:
		CompositeGenerator() : m_totalSize(0) {}

		// *** Move semantics, similar to auto_ptr ***
		CompositeGenerator(CompositeGenerator& other)
			: m_fileInfo(other.m_fileInfo),
			m_totalSize(0)
		{
			move(other);
		}

		CompositeGenerator& setFileInfo(const char* fileInfo) {
			m_fileInfo = fileInfo;
			return *this;
		}

		~CompositeGenerator() {
			deleteAll(m_composed);
		}

		operator T () const {
			size_t overallIndex = getCurrentContext().getGeneratorIndex(m_fileInfo, m_totalSize);

			typename std::vector<const IGenerator<T>*>::const_iterator it = m_composed.begin();
			typename std::vector<const IGenerator<T>*>::const_iterator itEnd = m_composed.end();
			for (size_t index = 0; it != itEnd; ++it)
			{
				const IGenerator<T>* generator = *it;
				if (overallIndex >= index && overallIndex < index + generator->size())
				{
					return generator->getValue(overallIndex - index);
				}
				index += generator->size();
			}
			CATCH_INTERNAL_ERROR("Indexed past end of generated range");
			return T(); // Suppress spurious "not all control paths return a value" warning in Visual Studio - if you know how to fix this please do so
		}

		void add(const IGenerator<T>* generator) {
			m_totalSize += generator->size();
			m_composed.push_back(generator);
		}

		CompositeGenerator& then(CompositeGenerator& other) {
			move(other);
			return *this;
		}

		CompositeGenerator& then(T value) {
			ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
			valuesGen->add(value);
			add(valuesGen);
			return *this;
		}

	private:

		void move(CompositeGenerator& other) {
			std::copy(other.m_composed.begin(), other.m_composed.end(), std::back_inserter(m_composed));
			m_totalSize += other.m_totalSize;
			other.m_composed.clear();
		}

		std::vector<const IGenerator<T>*> m_composed;
		std::string m_fileInfo;
		size_t m_totalSize;
	};

	namespace Generators
	{
		template<typename T>
		CompositeGenerator<T> between(T from, T to) {
			CompositeGenerator<T> generators;
			generators.add(new BetweenGenerator<T>(from, to));
			return generators;
		}

		template<typename T>
		CompositeGenerator<T> values(T val1, T val2) {
			CompositeGenerator<T> generators;
			ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
			valuesGen->add(val1);
			valuesGen->add(val2);
			generators.add(valuesGen);
			return generators;
		}

		template<typename T>
		CompositeGenerator<T> values(T val1, T val2, T val3) {
			CompositeGenerator<T> generators;
			ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
			valuesGen->add(val1);
			valuesGen->add(val2);
			valuesGen->add(val3);
			generators.add(valuesGen);
			return generators;
		}

		template<typename T>
		CompositeGenerator<T> values(T val1, T val2, T val3, T val4) {
			CompositeGenerator<T> generators;
			ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
			valuesGen->add(val1);
			valuesGen->add(val2);
			valuesGen->add(val3);
			valuesGen->add(val4);
			generators.add(valuesGen);
			return generators;
		}

	} // end namespace Generators

	using namespace Generators;

} // end namespace Catch

#define INTERNAL_CATCH_LINESTR2( line ) #line
#define INTERNAL_CATCH_LINESTR( line ) INTERNAL_CATCH_LINESTR2( line )

#define INTERNAL_CATCH_GENERATE( expr ) expr.setFileInfo( __FILE__ "(" INTERNAL_CATCH_LINESTR( __LINE__ ) ")" )

  // #included from: internal/catch_interfaces_exception.h
#define TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED

#include <string>
#include <vector>

  // #included from: catch_interfaces_registry_hub.h
#define TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED

#include <string>

namespace Catch {

	class TestCase;
	struct ITestCaseRegistry;
	struct IExceptionTranslatorRegistry;
	struct IExceptionTranslator;
	struct IReporterRegistry;
	struct IReporterFactory;

	struct IRegistryHub {
		virtual ~IRegistryHub();

		virtual IReporterRegistry const& getReporterRegistry() const = 0;
		virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
		virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() = 0;
	};

	struct IMutableRegistryHub {
		virtual ~IMutableRegistryHub();
		virtual void registerReporter(std::string const& name, Ptr<IReporterFactory> const& factory) = 0;
		virtual void registerListener(Ptr<IReporterFactory> const& factory) = 0;
		virtual void registerTest(TestCase const& testInfo) = 0;
		virtual void registerTranslator(const IExceptionTranslator* translator) = 0;
	};

	IRegistryHub& getRegistryHub();
	IMutableRegistryHub& getMutableRegistryHub();
	void cleanUp();
	std::string translateActiveException();

}

namespace Catch {

	typedef std::string(*exceptionTranslateFunction)();

	struct IExceptionTranslator;
	typedef std::vector<const IExceptionTranslator*> ExceptionTranslators;

	struct IExceptionTranslator {
		virtual ~IExceptionTranslator();
		virtual std::string translate(ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd) const = 0;
	};

	struct IExceptionTranslatorRegistry {
		virtual ~IExceptionTranslatorRegistry();

		virtual std::string translateActiveException() const = 0;
	};

	class ExceptionTranslatorRegistrar {
		template<typename T>
		class ExceptionTranslator : public IExceptionTranslator {
		public:

			ExceptionTranslator(std::string(*translateFunction)(T&))
				: m_translateFunction(translateFunction)
			{}

			virtual std::string translate(ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd) const CATCH_OVERRIDE {
				try {
					if (it == itEnd)
						throw;
					else
						return (*it)->translate(it + 1, itEnd);
				}
				catch (T& ex) {
					return m_translateFunction(ex);
				}
			}

		protected:
			std::string(*m_translateFunction)(T&);
		};

	public:
		template<typename T>
		ExceptionTranslatorRegistrar(std::string(*translateFunction)(T&)) {
			getMutableRegistryHub().registerTranslator
			(new ExceptionTranslator<T>(translateFunction));
		}
	};
}

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \
    static std::string translatorName( signature ); \
    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); }\
    static std::string translatorName( signature )

#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )

// #included from: internal/catch_approx.hpp
#define TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED

#include <cmath>
#include <limits>

namespace Catch {
	namespace Detail {

		class Approx {
		public:
			explicit Approx(double value)
				: m_epsilon(std::numeric_limits<float>::epsilon() * 100),
				m_scale(1.0),
				m_value(value)
			{}

			Approx(Approx const& other)
				: m_epsilon(other.m_epsilon),
				m_scale(other.m_scale),
				m_value(other.m_value)
			{}

			static Approx custom() {
				return Approx(0);
			}

			Approx operator()(double value) {
				Approx approx(value);
				approx.epsilon(m_epsilon);
				approx.scale(m_scale);
				return approx;
			}

			friend bool operator == (double lhs, Approx const& rhs) {
				// Thanks to Richard Harris for his help refining this formula
				return fabs(lhs - rhs.m_value) < rhs.m_epsilon * (rhs.m_scale + (std::max)(fabs(lhs), fabs(rhs.m_value)));
			}

			friend bool operator == (Approx const& lhs, double rhs) {
				return operator==(rhs, lhs);
			}

			friend bool operator != (double lhs, Approx const& rhs) {
				return !operator==(lhs, rhs);
			}

			friend bool operator != (Approx const& lhs, double rhs) {
				return !operator==(rhs, lhs);
			}

			Approx& epsilon(double newEpsilon) {
				m_epsilon = newEpsilon;
				return *this;
			}

			Approx& scale(double newScale) {
				m_scale = newScale;
				return *this;
			}

			std::string toString() const {
				std::ostringstream oss;
				oss << "Approx( " << Catch::toString(m_value) << " )";
				return oss.str();
			}

		private:
			double m_epsilon;
			double m_scale;
			double m_value;
		};
	}

	template<>
	inline std::string toString<Detail::Approx>(Detail::Approx const& value) {
		return value.toString();
	}

} // end namespace Catch

  // #included from: internal/catch_interfaces_tag_alias_registry.h
#define TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED

  // #included from: catch_tag_alias.h
#define TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED

#include <string>

namespace Catch {

	struct TagAlias {
		TagAlias(std::string _tag, SourceLineInfo _lineInfo) : tag(_tag), lineInfo(_lineInfo) {}

		std::string tag;
		SourceLineInfo lineInfo;
	};

	struct RegistrarForTagAliases {
		RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const& lineInfo);
	};

} // end namespace Catch

#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); }
  // #included from: catch_option.hpp
#define TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED

namespace Catch {

	// An optional type
	template<typename T>
	class Option {
	public:
		Option() : nullableValue(CATCH_NULL) {}
		Option(T const& _value)
			: nullableValue(new(storage) T(_value))
		{}
		Option(Option const& _other)
			: nullableValue(_other ? new(storage) T(*_other) : CATCH_NULL)
		{}

		~Option() {
			reset();
		}

		Option& operator= (Option const& _other) {
			if (&_other != this) {
				reset();
				if (_other)
					nullableValue = new(storage) T(*_other);
			}
			return *this;
		}
		Option& operator = (T const& _value) {
			reset();
			nullableValue = new(storage) T(_value);
			return *this;
		}

		void reset() {
			if (nullableValue)
				nullableValue->~T();
			nullableValue = CATCH_NULL;
		}

		T& operator*() { return *nullableValue; }
		T const& operator*() const { return *nullableValue; }
		T* operator->() { return nullableValue; }
		const T* operator->() const { return nullableValue; }

		T valueOr(T const& defaultValue) const {
			return nullableValue ? *nullableValue : defaultValue;
		}

		bool some() const { return nullableValue != CATCH_NULL; }
		bool none() const { return nullableValue == CATCH_NULL; }

		bool operator !() const { return nullableValue == CATCH_NULL; }
		operator SafeBool::type() const {
			return SafeBool::makeSafe(some());
		}

	private:
		T* nullableValue;
		char storage[sizeof(T)];
	};

} // end namespace Catch

namespace Catch {

	struct ITagAliasRegistry {
		virtual ~ITagAliasRegistry();
		virtual Option<TagAlias> find(std::string const& alias) const = 0;
		virtual std::string expandAliases(std::string const& unexpandedTestSpec) const = 0;

		static ITagAliasRegistry const& get();
	};

} // end namespace Catch

  // These files are included here so the single_include script doesn't put them
  // in the conditionally compiled sections
  // #included from: internal/catch_test_case_info.h
#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED

#include <string>
#include <set>

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

namespace Catch {

	struct ITestCase;

	struct TestCaseInfo {
		enum SpecialProperties {
			None = 0,
			IsHidden = 1 << 1,
			ShouldFail = 1 << 2,
			MayFail = 1 << 3,
			Throws = 1 << 4
		};

		TestCaseInfo(std::string const& _name,
			std::string const& _className,
			std::string const& _description,
			std::set<std::string> const& _tags,
			SourceLineInfo const& _lineInfo);

		TestCaseInfo(TestCaseInfo const& other);

		friend void setTags(TestCaseInfo& testCaseInfo, std::set<std::string> const& tags);

		bool isHidden() const;
		bool throws() const;
		bool okToFail() const;
		bool expectedToFail() const;

		std::string name;
		std::string className;
		std::string description;
		std::set<std::string> tags;
		std::set<std::string> lcaseTags;
		std::string tagsAsString;
		SourceLineInfo lineInfo;
		SpecialProperties properties;
	};

	class TestCase : public TestCaseInfo {
	public:

		TestCase(ITestCase* testCase, TestCaseInfo const& info);
		TestCase(TestCase const& other);

		TestCase withName(std::string const& _newName) const;

		void invoke() const;

		TestCaseInfo const& getTestCaseInfo() const;

		void swap(TestCase& other);
		bool operator == (TestCase const& other) const;
		bool operator < (TestCase const& other) const;
		TestCase& operator = (TestCase const& other);

	private:
		Ptr<ITestCase> test;
	};

	TestCase makeTestCase(ITestCase* testCase,
		std::string const& className,
		std::string const& name,
		std::string const& description,
		SourceLineInfo const& lineInfo);
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif


#ifdef __OBJC__
// #included from: internal/catch_objc.hpp
#define TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED

#import <objc/runtime.h>

#include <string>

// NB. Any general catch headers included here must be included
// in catch.hpp first to make sure they are included by the single
// header for non obj-usage

///////////////////////////////////////////////////////////////////////////////
// This protocol is really only here for (self) documenting purposes, since
// all its methods are optional.
@protocol OcFixture

@optional

- (void)setUp;
-(void)tearDown;

@end

namespace Catch {

	class OcMethod : public SharedImpl<ITestCase> {

	public:
		OcMethod(Class cls, SEL sel) : m_cls(cls), m_sel(sel) {}

		virtual void invoke() const {
			id obj = [[m_cls alloc] init];

			performOptionalSelector(obj, @selector(setUp)  );
			performOptionalSelector(obj, m_sel);
			performOptionalSelector(obj, @selector(tearDown)  );

			arcSafeRelease(obj);
		}
	private:
		virtual ~OcMethod() {}

		Class m_cls;
		SEL m_sel;
	};

	namespace Detail {

		inline std::string getAnnotation(Class cls,
			std::string const& annotationName,
			std::string const& testCaseName) {
			NSString* selStr = [[NSString alloc] initWithFormat:@"Catch_%s_%s", annotationName.c_str(), testCaseName.c_str()];
				SEL sel = NSSelectorFromString(selStr);
			arcSafeRelease(selStr);
			id value = performOptionalSelector(cls, sel);
			if (value)
				return[(NSString*)value UTF8String];
			return "";
		}
	}

	inline size_t registerTestMethods() {
		size_t noTestMethods = 0;
		int noClasses = objc_getClassList(CATCH_NULL, 0);

		Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc(sizeof(Class) * noClasses);
		objc_getClassList(classes, noClasses);

		for (int c = 0; c < noClasses; c++) {
			Class cls = classes[c];
			{
				u_int count;
				Method* methods = class_copyMethodList(cls, &count);
				for (u_int m = 0; m < count; m++) {
					SEL selector = method_getName(methods[m]);
					std::string methodName = sel_getName(selector);
					if (startsWith(methodName, "Catch_TestCase_")) {
						std::string testCaseName = methodName.substr(15);
						std::string name = Detail::getAnnotation(cls, "Name", testCaseName);
						std::string desc = Detail::getAnnotation(cls, "Description", testCaseName);
						const char* className = class_getName(cls);

						getMutableRegistryHub().registerTest(makeTestCase(new OcMethod(cls, selector), className, name.c_str(), desc.c_str(), SourceLineInfo()));
						noTestMethods++;
					}
				}
				free(methods);
			}
		}
		return noTestMethods;
	}

	namespace Matchers {
		namespace Impl {
			namespace NSStringMatchers {

				template<typename MatcherT>
				struct StringHolder : MatcherImpl<MatcherT, NSString*> {
					StringHolder(NSString* substr) : m_substr([substr copy]) {}
					StringHolder(StringHolder const& other) : m_substr([other.m_substr copy]) {}
					StringHolder() {
						arcSafeRelease(m_substr);
					}

					NSString* m_substr;
				};

				struct Equals : StringHolder<Equals> {
					Equals(NSString* substr) : StringHolder(substr) {}

					virtual bool match(ExpressionType const& str) const {
						return  (str != nil || m_substr == nil) &&
							[str isEqualToString : m_substr];
					}

					virtual std::string toString() const {
						return "equals string: " + Catch::toString(m_substr);
					}
				};

				struct Contains : StringHolder<Contains> {
					Contains(NSString* substr) : StringHolder(substr) {}

					virtual bool match(ExpressionType const& str) const {
						return  (str != nil || m_substr == nil) &&
							[str rangeOfString : m_substr].location != NSNotFound;
					}

					virtual std::string toString() const {
						return "contains string: " + Catch::toString(m_substr);
					}
				};

				struct StartsWith : StringHolder<StartsWith> {
					StartsWith(NSString* substr) : StringHolder(substr) {}

					virtual bool match(ExpressionType const& str) const {
						return  (str != nil || m_substr == nil) &&
							[str rangeOfString : m_substr].location == 0;
					}

					virtual std::string toString() const {
						return "starts with: " + Catch::toString(m_substr);
					}
				};
				struct EndsWith : StringHolder<EndsWith> {
					EndsWith(NSString* substr) : StringHolder(substr) {}

					virtual bool match(ExpressionType const& str) const {
						return  (str != nil || m_substr == nil) &&
							[str rangeOfString : m_substr].location == [str length] - [m_substr length];
					}

					virtual std::string toString() const {
						return "ends with: " + Catch::toString(m_substr);
					}
				};

			} // namespace NSStringMatchers
		} // namespace Impl

		inline Impl::NSStringMatchers::Equals
			Equals(NSString* substr) { return Impl::NSStringMatchers::Equals(substr); }

		inline Impl::NSStringMatchers::Contains
			Contains(NSString* substr) { return Impl::NSStringMatchers::Contains(substr); }

		inline Impl::NSStringMatchers::StartsWith
			StartsWith(NSString* substr) { return Impl::NSStringMatchers::StartsWith(substr); }

		inline Impl::NSStringMatchers::EndsWith
			EndsWith(NSString* substr) { return Impl::NSStringMatchers::EndsWith(substr); }

	} // namespace Matchers

	using namespace Matchers;

} // namespace Catch

  ///////////////////////////////////////////////////////////////////////////////
#define OC_TEST_CASE( name, desc )\
+(NSString*) INTERNAL_CATCH_UNIQUE_NAME( Catch_Name_test ) \
{\
return @ name; \
}\
+(NSString*) INTERNAL_CATCH_UNIQUE_NAME( Catch_Description_test ) \
{ \
return @ desc; \
} \
-(void) INTERNAL_CATCH_UNIQUE_NAME( Catch_TestCase_test )

#endif

#ifdef CATCH_IMPL
  // #included from: internal/catch_impl.hpp
#define TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED

  // Collect all the implementation files together here
  // These are the equivalent of what would usually be cpp files

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wweak-vtables"
#endif

  // #included from: ../catch_session.hpp
#define TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED

  // #included from: internal/catch_commandline.hpp
#define TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED

  // #included from: catch_config.hpp
#define TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED

  // #included from: catch_test_spec_parser.hpp
#define TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

  // #included from: catch_test_spec.hpp
#define TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

  // #included from: catch_wildcard_pattern.hpp
#define TWOBLUECUBES_CATCH_WILDCARD_PATTERN_HPP_INCLUDED

namespace Catch
{
	class WildcardPattern {
		enum WildcardPosition {
			NoWildcard = 0,
			WildcardAtStart = 1,
			WildcardAtEnd = 2,
			WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
		};

	public:

		WildcardPattern(std::string const& pattern, CaseSensitive::Choice caseSensitivity)
			: m_caseSensitivity(caseSensitivity),
			m_wildcard(NoWildcard),
			m_pattern(adjustCase(pattern))
		{
			if (startsWith(m_pattern, "*")) {
				m_pattern = m_pattern.substr(1);
				m_wildcard = WildcardAtStart;
			}
			if (endsWith(m_pattern, "*")) {
				m_pattern = m_pattern.substr(0, m_pattern.size() - 1);
				m_wildcard = static_cast<WildcardPosition>(m_wildcard | WildcardAtEnd);
			}
		}
		virtual ~WildcardPattern();
		virtual bool matches(std::string const& str) const {
			switch (m_wildcard) {
			case NoWildcard:
				return m_pattern == adjustCase(str);
			case WildcardAtStart:
				return endsWith(adjustCase(str), m_pattern);
			case WildcardAtEnd:
				return startsWith(adjustCase(str), m_pattern);
			case WildcardAtBothEnds:
				return contains(adjustCase(str), m_pattern);
			}

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#endif
			throw std::logic_error("Unknown enum");
#ifdef __clang__
#pragma clang diagnostic pop
#endif
		}
	private:
		std::string adjustCase(std::string const& str) const {
			return m_caseSensitivity == CaseSensitive::No ? toLower(str) : str;
		}
		CaseSensitive::Choice m_caseSensitivity;
		WildcardPosition m_wildcard;
		std::string m_pattern;
	};
}

#include <string>
#include <vector>

namespace Catch {

	class TestSpec {
		struct Pattern : SharedImpl<> {
			virtual ~Pattern();
			virtual bool matches(TestCaseInfo const& testCase) const = 0;
		};
		class NamePattern : public Pattern {
		public:
			NamePattern(std::string const& name)
				: m_wildcardPattern(toLower(name), CaseSensitive::No)
			{}
			virtual ~NamePattern();
			virtual bool matches(TestCaseInfo const& testCase) const {
				return m_wildcardPattern.matches(toLower(testCase.name));
			}
		private:
			WildcardPattern m_wildcardPattern;
		};

		class TagPattern : public Pattern {
		public:
			TagPattern(std::string const& tag) : m_tag(toLower(tag)) {}
			virtual ~TagPattern();
			virtual bool matches(TestCaseInfo const& testCase) const {
				return testCase.lcaseTags.find(m_tag) != testCase.lcaseTags.end();
			}
		private:
			std::string m_tag;
		};

		class ExcludedPattern : public Pattern {
		public:
			ExcludedPattern(Ptr<Pattern> const& underlyingPattern) : m_underlyingPattern(underlyingPattern) {}
			virtual ~ExcludedPattern();
			virtual bool matches(TestCaseInfo const& testCase) const { return !m_underlyingPattern->matches(testCase); }
		private:
			Ptr<Pattern> m_underlyingPattern;
		};

		struct Filter {
			std::vector<Ptr<Pattern> > m_patterns;

			bool matches(TestCaseInfo const& testCase) const {
				// All patterns in a filter must match for the filter to be a match
				for (std::vector<Ptr<Pattern> >::const_iterator it = m_patterns.begin(), itEnd = m_patterns.end(); it != itEnd; ++it)
					if (!(*it)->matches(testCase))
						return false;
				return true;
			}
		};

	public:
		bool hasFilters() const {
			return !m_filters.empty();
		}
		bool matches(TestCaseInfo const& testCase) const {
			// A TestSpec matches if any filter matches
			for (std::vector<Filter>::const_iterator it = m_filters.begin(), itEnd = m_filters.end(); it != itEnd; ++it)
				if (it->matches(testCase))
					return true;
			return false;
		}

	private:
		std::vector<Filter> m_filters;

		friend class TestSpecParser;
	};
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

namespace Catch {

	class TestSpecParser {
		enum Mode { None, Name, QuotedName, Tag };
		Mode m_mode;
		bool m_exclusion;
		std::size_t m_start, m_pos;
		std::string m_arg;
		TestSpec::Filter m_currentFilter;
		TestSpec m_testSpec;
		ITagAliasRegistry const* m_tagAliases;

	public:
		TestSpecParser(ITagAliasRegistry const& tagAliases) : m_tagAliases(&tagAliases) {}

		TestSpecParser& parse(std::string const& arg) {
			m_mode = None;
			m_exclusion = false;
			m_start = std::string::npos;
			m_arg = m_tagAliases->expandAliases(arg);
			for (m_pos = 0; m_pos < m_arg.size(); ++m_pos)
				visitChar(m_arg[m_pos]);
			if (m_mode == Name)
				addPattern<TestSpec::NamePattern>();
			return *this;
		}
		TestSpec testSpec() {
			addFilter();
			return m_testSpec;
		}
	private:
		void visitChar(char c) {
			if (m_mode == None) {
				switch (c) {
				case ' ': return;
				case '~': m_exclusion = true; return;
				case '[': return startNewMode(Tag, ++m_pos);
				case '"': return startNewMode(QuotedName, ++m_pos);
				default: startNewMode(Name, m_pos); break;
				}
			}
			if (m_mode == Name) {
				if (c == ',') {
					addPattern<TestSpec::NamePattern>();
					addFilter();
				}
				else if (c == '[') {
					if (subString() == "exclude:")
						m_exclusion = true;
					else
						addPattern<TestSpec::NamePattern>();
					startNewMode(Tag, ++m_pos);
				}
			}
			else if (m_mode == QuotedName && c == '"')
				addPattern<TestSpec::NamePattern>();
			else if (m_mode == Tag && c == ']')
				addPattern<TestSpec::TagPattern>();
		}
		void startNewMode(Mode mode, std::size_t start) {
			m_mode = mode;
			m_start = start;
		}
		std::string subString() const { return m_arg.substr(m_start, m_pos - m_start); }
		template<typename T>
		void addPattern() {
			std::string token = subString();
			if (startsWith(token, "exclude:")) {
				m_exclusion = true;
				token = token.substr(8);
			}
			if (!token.empty()) {
				Ptr<TestSpec::Pattern> pattern = new T(token);
				if (m_exclusion)
					pattern = new TestSpec::ExcludedPattern(pattern);
				m_currentFilter.m_patterns.push_back(pattern);
			}
			m_exclusion = false;
			m_mode = None;
		}
		void addFilter() {
			if (!m_currentFilter.m_patterns.empty()) {
				m_testSpec.m_filters.push_back(m_currentFilter);
				m_currentFilter = TestSpec::Filter();
			}
		}
	};
	inline TestSpec parseTestSpec(std::string const& arg) {
		return TestSpecParser(ITagAliasRegistry::get()).parse(arg).testSpec();
	}

} // namespace Catch

#ifdef __clang__
#pragma clang diagnostic pop
#endif

  // #included from: catch_interfaces_config.h
#define TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED

#include <iostream>
#include <string>
#include <vector>

namespace Catch {

	struct Verbosity {
		enum Level {
			NoOutput = 0,
			Quiet,
			Normal
		};
	};

	struct WarnAbout {
		enum What {
			Nothing = 0x00,
			NoAssertions = 0x01
		};
	};

	struct ShowDurations {
		enum OrNot {
			DefaultForReporter,
			Always,
			Never
		};
	};
	struct RunTests {
		enum InWhatOrder {
			InDeclarationOrder,
			InLexicographicalOrder,
			InRandomOrder
		};
	};
	struct UseColour {
		enum YesOrNo {
			Auto,
			Yes,
			No
		};
	};

	class TestSpec;

	struct IConfig : IShared {

		virtual ~IConfig();

		virtual bool allowThrows() const = 0;
		virtual std::ostream& stream() const = 0;
		virtual std::string name() const = 0;
		virtual bool includeSuccessfulResults() const = 0;
		virtual bool shouldDebugBreak() const = 0;
		virtual bool warnAboutMissingAssertions() const = 0;
		virtual int abortAfter() const = 0;
		virtual bool showInvisibles() const = 0;
		virtual ShowDurations::OrNot showDurations() const = 0;
		virtual TestSpec const& testSpec() const = 0;
		virtual RunTests::InWhatOrder runOrder() const = 0;
		virtual unsigned int rngSeed() const = 0;
		virtual UseColour::YesOrNo useColour() const = 0;
	};
}

// #included from: catch_stream.h
#define TWOBLUECUBES_CATCH_STREAM_H_INCLUDED

// #included from: catch_streambuf.h
#define TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED

#include <streambuf>

namespace Catch {

	class StreamBufBase : public std::streambuf {
	public:
		virtual ~StreamBufBase() CATCH_NOEXCEPT;
	};
}

#include <streambuf>
#include <ostream>
#include <fstream>

namespace Catch {

	std::ostream& cout();
	std::ostream& cerr();

	struct IStream {
		virtual ~IStream() CATCH_NOEXCEPT;
		virtual std::ostream& stream() const = 0;
	};

	class FileStream : public IStream {
		mutable std::ofstream m_ofs;
	public:
		FileStream(std::string const& filename);
		virtual ~FileStream() CATCH_NOEXCEPT;
	public: // IStream
		virtual std::ostream& stream() const CATCH_OVERRIDE;
	};

	class CoutStream : public IStream {
		mutable std::ostream m_os;
	public:
		CoutStream();
		virtual ~CoutStream() CATCH_NOEXCEPT;

	public: // IStream
		virtual std::ostream& stream() const CATCH_OVERRIDE;
	};

	class DebugOutStream : public IStream {
		std::auto_ptr<StreamBufBase> m_streamBuf;
		mutable std::ostream m_os;
	public:
		DebugOutStream();
		virtual ~DebugOutStream() CATCH_NOEXCEPT;

	public: // IStream
		virtual std::ostream& stream() const CATCH_OVERRIDE;
	};
}

#include <memory>
#include <vector>
#include <string>
#include <iostream>
#include <ctime>

#ifndef CATCH_CONFIG_CONSOLE_WIDTH
#define CATCH_CONFIG_CONSOLE_WIDTH 80
#endif

namespace Catch {

	struct ConfigData {

		ConfigData()
			: listTests(false),
			listTags(false),
			listReporters(false),
			listTestNamesOnly(false),
			showSuccessfulTests(false),
			shouldDebugBreak(false),
			noThrow(false),
			showHelp(false),
			showInvisibles(false),
			filenamesAsTags(false),
			abortAfter(-1),
			rngSeed(0),
			verbosity(Verbosity::Normal),
			warnings(WarnAbout::Nothing),
			showDurations(ShowDurations::DefaultForReporter),
			runOrder(RunTests::InDeclarationOrder),
			useColour(UseColour::Auto)
		{}

		bool listTests;
		bool listTags;
		bool listReporters;
		bool listTestNamesOnly;

		bool showSuccessfulTests;
		bool shouldDebugBreak;
		bool noThrow;
		bool showHelp;
		bool showInvisibles;
		bool filenamesAsTags;

		int abortAfter;
		unsigned int rngSeed;

		Verbosity::Level verbosity;
		WarnAbout::What warnings;
		ShowDurations::OrNot showDurations;
		RunTests::InWhatOrder runOrder;
		UseColour::YesOrNo useColour;

		std::string outputFilename;
		std::string name;
		std::string processName;

		std::vector<std::string> reporterNames;
		std::vector<std::string> testsOrTags;
	};

	class Config : public SharedImpl<IConfig> {
	private:
		Config(Config const& other);
		Config& operator = (Config const& other);
		virtual void dummy();
	public:

		Config()
		{}

		Config(ConfigData const& data)
			: m_data(data),
			m_stream(openStream())
		{
			if (!data.testsOrTags.empty()) {
				TestSpecParser parser(ITagAliasRegistry::get());
				for (std::size_t i = 0; i < data.testsOrTags.size(); ++i)
					parser.parse(data.testsOrTags[i]);
				m_testSpec = parser.testSpec();
			}
		}

		virtual ~Config() {
		}

		std::string const& getFilename() const {
			return m_data.outputFilename;
		}

		bool listTests() const { return m_data.listTests; }
		bool listTestNamesOnly() const { return m_data.listTestNamesOnly; }
		bool listTags() const { return m_data.listTags; }
		bool listReporters() const { return m_data.listReporters; }

		std::string getProcessName() const { return m_data.processName; }

		bool shouldDebugBreak() const { return m_data.shouldDebugBreak; }

		std::vector<std::string> getReporterNames() const { return m_data.reporterNames; }

		int abortAfter() const { return m_data.abortAfter; }

		TestSpec const& testSpec() const { return m_testSpec; }

		bool showHelp() const { return m_data.showHelp; }
		bool showInvisibles() const { return m_data.showInvisibles; }

		// IConfig interface
		virtual bool allowThrows() const { return !m_data.noThrow; }
		virtual std::ostream& stream() const { return m_stream->stream(); }
		virtual std::string name() const { return m_data.name.empty() ? m_data.processName : m_data.name; }
		virtual bool includeSuccessfulResults() const { return m_data.showSuccessfulTests; }
		virtual bool warnAboutMissingAssertions() const { return m_data.warnings & WarnAbout::NoAssertions; }
		virtual ShowDurations::OrNot showDurations() const { return m_data.showDurations; }
		virtual RunTests::InWhatOrder runOrder() const { return m_data.runOrder; }
		virtual unsigned int rngSeed() const { return m_data.rngSeed; }
		virtual UseColour::YesOrNo useColour() const { return m_data.useColour; }

	private:

		IStream const* openStream() {
			if (m_data.outputFilename.empty())
				return new CoutStream();
			else if (m_data.outputFilename[0] == '%') {
				if (m_data.outputFilename == "%debug")
					return new DebugOutStream();
				else
					throw std::domain_error("Unrecognised stream: " + m_data.outputFilename);
			}
			else
				return new FileStream(m_data.outputFilename);
		}
		ConfigData m_data;

		std::auto_ptr<IStream const> m_stream;
		TestSpec m_testSpec;
	};

} // end namespace Catch

  // #included from: catch_clara.h
#define TWOBLUECUBES_CATCH_CLARA_H_INCLUDED

  // Use Catch's value for console width (store Clara's off to the side, if present)
#ifdef CLARA_CONFIG_CONSOLE_WIDTH
#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CLARA_CONFIG_CONSOLE_WIDTH
#undef CLARA_CONFIG_CONSOLE_WIDTH
#endif
#define CLARA_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH

  // Declare Clara inside the Catch namespace
#define STITCH_CLARA_OPEN_NAMESPACE namespace Catch {
  // #included from: ../external/clara.h

  // Version 0.0.2.4

  // Only use header guard if we are not using an outer namespace
#if !defined(TWOBLUECUBES_CLARA_H_INCLUDED) || defined(STITCH_CLARA_OPEN_NAMESPACE)

#ifndef STITCH_CLARA_OPEN_NAMESPACE
#define TWOBLUECUBES_CLARA_H_INCLUDED
#define STITCH_CLARA_OPEN_NAMESPACE
#define STITCH_CLARA_CLOSE_NAMESPACE
#else
#define STITCH_CLARA_CLOSE_NAMESPACE }
#endif

#define STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE STITCH_CLARA_OPEN_NAMESPACE

  // ----------- #included from tbc_text_format.h -----------

  // Only use header guard if we are not using an outer namespace
#if !defined(TBC_TEXT_FORMAT_H_INCLUDED) || defined(STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE)
#ifndef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
#define TBC_TEXT_FORMAT_H_INCLUDED
#endif

#include <string>
#include <vector>
#include <sstream>
#include <algorithm>

  // Use optional outer namespace
#ifdef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
namespace STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE {
#endif

	namespace Tbc {

#ifdef TBC_TEXT_FORMAT_CONSOLE_WIDTH
		const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;
#else
		const unsigned int consoleWidth = 80;
#endif

		struct TextAttributes {
			TextAttributes()
				: initialIndent(std::string::npos),
				indent(0),
				width(consoleWidth - 1),
				tabChar('\t')
			{}

			TextAttributes& setInitialIndent(std::size_t _value) { initialIndent = _value; return *this; }
			TextAttributes& setIndent(std::size_t _value) { indent = _value; return *this; }
			TextAttributes& setWidth(std::size_t _value) { width = _value; return *this; }
			TextAttributes& setTabChar(char _value) { tabChar = _value; return *this; }

			std::size_t initialIndent;  // indent of first line, or npos
			std::size_t indent;         // indent of subsequent lines, or all if initialIndent is npos
			std::size_t width;          // maximum width of text, including indent. Longer text will wrap
			char tabChar;               // If this char is seen the indent is changed to current pos
		};

		class Text {
		public:
			Text(std::string const& _str, TextAttributes const& _attr = TextAttributes())
				: attr(_attr)
			{
				std::string wrappableChars = " [({.,/|\\-";
				std::size_t indent = _attr.initialIndent != std::string::npos
					? _attr.initialIndent
					: _attr.indent;
				std::string remainder = _str;

				while (!remainder.empty()) {
					if (lines.size() >= 1000) {
						lines.push_back("... message truncated due to excessive size");
						return;
					}
					std::size_t tabPos = std::string::npos;
					std::size_t width = (std::min)(remainder.size(), _attr.width - indent);
					std::size_t pos = remainder.find_first_of('\n');
					if (pos <= width) {
						width = pos;
					}
					pos = remainder.find_last_of(_attr.tabChar, width);
					if (pos != std::string::npos) {
						tabPos = pos;
						if (remainder[width] == '\n')
							width--;
						remainder = remainder.substr(0, tabPos) + remainder.substr(tabPos + 1);
					}

					if (width == remainder.size()) {
						spliceLine(indent, remainder, width);
					}
					else if (remainder[width] == '\n') {
						spliceLine(indent, remainder, width);
						if (width <= 1 || remainder.size() != 1)
							remainder = remainder.substr(1);
						indent = _attr.indent;
					}
					else {
						pos = remainder.find_last_of(wrappableChars, width);
						if (pos != std::string::npos && pos > 0) {
							spliceLine(indent, remainder, pos);
							if (remainder[0] == ' ')
								remainder = remainder.substr(1);
						}
						else {
							spliceLine(indent, remainder, width - 1);
							lines.back() += "-";
						}
						if (lines.size() == 1)
							indent = _attr.indent;
						if (tabPos != std::string::npos)
							indent += tabPos;
					}
				}
			}

			void spliceLine(std::size_t _indent, std::string& _remainder, std::size_t _pos) {
				lines.push_back(std::string(_indent, ' ') + _remainder.substr(0, _pos));
				_remainder = _remainder.substr(_pos);
			}

			typedef std::vector<std::string>::const_iterator const_iterator;

			const_iterator begin() const { return lines.begin(); }
			const_iterator end() const { return lines.end(); }
			std::string const& last() const { return lines.back(); }
			std::size_t size() const { return lines.size(); }
			std::string const& operator[](std::size_t _index) const { return lines[_index]; }
			std::string toString() const {
				std::ostringstream oss;
				oss << *this;
				return oss.str();
			}

			inline friend std::ostream& operator << (std::ostream& _stream, Text const& _text) {
				for (Text::const_iterator it = _text.begin(), itEnd = _text.end();
					it != itEnd; ++it) {
					if (it != _text.begin())
						_stream << "\n";
					_stream << *it;
				}
				return _stream;
			}

		private:
			std::string str;
			TextAttributes attr;
			std::vector<std::string> lines;
		};

	} // end namespace Tbc

#ifdef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
} // end outer namespace
#endif

#endif // TBC_TEXT_FORMAT_H_INCLUDED

  // ----------- end of #include from tbc_text_format.h -----------
  // ........... back in clara.h

#undef STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE

  // ----------- #included from clara_compilers.h -----------

#ifndef TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED
#define TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED

  // Detect a number of compiler features - mostly C++11/14 conformance - by compiler
  // The following features are defined:
  //
  // CLARA_CONFIG_CPP11_NULLPTR : is nullptr supported?
  // CLARA_CONFIG_CPP11_NOEXCEPT : is noexcept supported?
  // CLARA_CONFIG_CPP11_GENERATED_METHODS : The delete and default keywords for compiler generated methods
  // CLARA_CONFIG_CPP11_OVERRIDE : is override supported?
  // CLARA_CONFIG_CPP11_UNIQUE_PTR : is unique_ptr supported (otherwise use auto_ptr)

  // CLARA_CONFIG_CPP11_OR_GREATER : Is C++11 supported?

  // CLARA_CONFIG_VARIADIC_MACROS : are variadic macros supported?

  // In general each macro has a _NO_<feature name> form
  // (e.g. CLARA_CONFIG_CPP11_NO_NULLPTR) which disables the feature.
  // Many features, at point of detection, define an _INTERNAL_ macro, so they
  // can be combined, en-mass, with the _NO_ forms later.

  // All the C++11 features can be disabled with CLARA_CONFIG_NO_CPP11

#ifdef __clang__

#if __has_feature(cxx_nullptr)
#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
#endif

#if __has_feature(cxx_noexcept)
#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
#endif

#endif // __clang__

  ////////////////////////////////////////////////////////////////////////////////
  // GCC
#ifdef __GNUC__

#if __GNUC__ == 4 && __GNUC_MINOR__ >= 6 && defined(__GXX_EXPERIMENTAL_CXX0X__)
#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
#endif

  // - otherwise more recent versions define __cplusplus >= 201103L
  // and will get picked up below

#endif // __GNUC__

  ////////////////////////////////////////////////////////////////////////////////
  // Visual C++
#ifdef _MSC_VER

#if (_MSC_VER >= 1600)
#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
#define CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
#endif

#if (_MSC_VER >= 1900 ) // (VC++ 13 (VS2015))
#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
#define CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#endif

#endif // _MSC_VER

  ////////////////////////////////////////////////////////////////////////////////
  // C++ language feature support

  // catch all support for C++11
#if defined(__cplusplus) && __cplusplus >= 201103L

#define CLARA_CPP11_OR_GREATER

#if !defined(CLARA_INTERNAL_CONFIG_CPP11_NULLPTR)
#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
#endif

#ifndef CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
#endif

#ifndef CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#define CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#endif

#if !defined(CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE)
#define CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE
#endif
#if !defined(CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR)
#define CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
#endif

#endif // __cplusplus >= 201103L

  // Now set the actual defines based on the above + anything the user has configured
#if defined(CLARA_INTERNAL_CONFIG_CPP11_NULLPTR) && !defined(CLARA_CONFIG_CPP11_NO_NULLPTR) && !defined(CLARA_CONFIG_CPP11_NULLPTR) && !defined(CLARA_CONFIG_NO_CPP11)
#define CLARA_CONFIG_CPP11_NULLPTR
#endif
#if defined(CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_CONFIG_CPP11_NO_NOEXCEPT) && !defined(CLARA_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_CONFIG_NO_CPP11)
#define CLARA_CONFIG_CPP11_NOEXCEPT
#endif
#if defined(CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS) && !defined(CLARA_CONFIG_CPP11_NO_GENERATED_METHODS) && !defined(CLARA_CONFIG_CPP11_GENERATED_METHODS) && !defined(CLARA_CONFIG_NO_CPP11)
#define CLARA_CONFIG_CPP11_GENERATED_METHODS
#endif
#if defined(CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(CLARA_CONFIG_NO_OVERRIDE) && !defined(CLARA_CONFIG_CPP11_OVERRIDE) && !defined(CLARA_CONFIG_NO_CPP11)
#define CLARA_CONFIG_CPP11_OVERRIDE
#endif
#if defined(CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(CLARA_CONFIG_NO_UNIQUE_PTR) && !defined(CLARA_CONFIG_CPP11_UNIQUE_PTR) && !defined(CLARA_CONFIG_NO_CPP11)
#define CLARA_CONFIG_CPP11_UNIQUE_PTR
#endif

  // noexcept support:
#if defined(CLARA_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_NOEXCEPT)
#define CLARA_NOEXCEPT noexcept
#  define CLARA_NOEXCEPT_IS(x) noexcept(x)
#else
#define CLARA_NOEXCEPT throw()
#  define CLARA_NOEXCEPT_IS(x)
#endif

  // nullptr support
#ifdef CLARA_CONFIG_CPP11_NULLPTR
#define CLARA_NULL nullptr
#else
#define CLARA_NULL NULL
#endif

  // override support
#ifdef CLARA_CONFIG_CPP11_OVERRIDE
#define CLARA_OVERRIDE override
#else
#define CLARA_OVERRIDE
#endif

  // unique_ptr support
#ifdef CLARA_CONFIG_CPP11_UNIQUE_PTR
#   define CLARA_AUTO_PTR( T ) std::unique_ptr<T>
#else
#   define CLARA_AUTO_PTR( T ) std::auto_ptr<T>
#endif

#endif // TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED

  // ----------- end of #include from clara_compilers.h -----------
  // ........... back in clara.h

#include <map>
#include <stdexcept>
#include <memory>

#if defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)
#define CLARA_PLATFORM_WINDOWS
#endif

  // Use optional outer namespace
#ifdef STITCH_CLARA_OPEN_NAMESPACE
STITCH_CLARA_OPEN_NAMESPACE
#endif

namespace Clara {

	struct UnpositionalTag {};

	extern UnpositionalTag _;

#ifdef CLARA_CONFIG_MAIN
	UnpositionalTag _;
#endif

	namespace Detail {

#ifdef CLARA_CONSOLE_WIDTH
		const unsigned int consoleWidth = CLARA_CONFIG_CONSOLE_WIDTH;
#else
		const unsigned int consoleWidth = 80;
#endif

		using namespace Tbc;

		inline bool startsWith(std::string const& str, std::string const& prefix) {
			return str.size() >= prefix.size() && str.substr(0, prefix.size()) == prefix;
		}

		template<typename T> struct RemoveConstRef { typedef T type; };
		template<typename T> struct RemoveConstRef<T&> { typedef T type; };
		template<typename T> struct RemoveConstRef<T const&> { typedef T type; };
		template<typename T> struct RemoveConstRef<T const> { typedef T type; };

		template<typename T>    struct IsBool { static const bool value = false; };
		template<>              struct IsBool<bool> { static const bool value = true; };

		template<typename T>
		void convertInto(std::string const& _source, T& _dest) {
			std::stringstream ss;
			ss << _source;
			ss >> _dest;
			if (ss.fail())
				throw std::runtime_error("Unable to convert " + _source + " to destination type");
		}
		inline void convertInto(std::string const& _source, std::string& _dest) {
			_dest = _source;
		}
		inline void convertInto(std::string const& _source, bool& _dest) {
			std::string sourceLC = _source;
			std::transform(sourceLC.begin(), sourceLC.end(), sourceLC.begin(), ::tolower);
			if (sourceLC == "y" || sourceLC == "1" || sourceLC == "true" || sourceLC == "yes" || sourceLC == "on")
				_dest = true;
			else if (sourceLC == "n" || sourceLC == "0" || sourceLC == "false" || sourceLC == "no" || sourceLC == "off")
				_dest = false;
			else
				throw std::runtime_error("Expected a boolean value but did not recognise:\n  '" + _source + "'");
		}

		template<typename ConfigT>
		struct IArgFunction {
			virtual ~IArgFunction() {}
#ifdef CLARA_CONFIG_CPP11_GENERATED_METHODS
			IArgFunction() = default;
			IArgFunction(IArgFunction const&) = default;
#endif
			virtual void set(ConfigT& config, std::string const& value) const = 0;
			virtual bool takesArg() const = 0;
			virtual IArgFunction* clone() const = 0;
		};

		template<typename ConfigT>
		class BoundArgFunction {
		public:
			BoundArgFunction() : functionObj(CLARA_NULL) {}
			BoundArgFunction(IArgFunction<ConfigT>* _functionObj) : functionObj(_functionObj) {}
			BoundArgFunction(BoundArgFunction const& other) : functionObj(other.functionObj ? other.functionObj->clone() : CLARA_NULL) {}
			BoundArgFunction& operator = (BoundArgFunction const& other) {
				IArgFunction<ConfigT>* newFunctionObj = other.functionObj ? other.functionObj->clone() : CLARA_NULL;
				delete functionObj;
				functionObj = newFunctionObj;
				return *this;
			}
			~BoundArgFunction() { delete functionObj; }

			void set(ConfigT& config, std::string const& value) const {
				functionObj->set(config, value);
			}
			bool takesArg() const { return functionObj->takesArg(); }

			bool isSet() const {
				return functionObj != CLARA_NULL;
			}
		private:
			IArgFunction<ConfigT>* functionObj;
		};

		template<typename C>
		struct NullBinder : IArgFunction<C> {
			virtual void set(C&, std::string const&) const {}
			virtual bool takesArg() const { return true; }
			virtual IArgFunction<C>* clone() const { return new NullBinder(*this); }
		};

		template<typename C, typename M>
		struct BoundDataMember : IArgFunction<C> {
			BoundDataMember(M C::* _member) : member(_member) {}
			virtual void set(C& p, std::string const& stringValue) const {
				convertInto(stringValue, p.*member);
			}
			virtual bool takesArg() const { return !IsBool<M>::value; }
			virtual IArgFunction<C>* clone() const { return new BoundDataMember(*this); }
			M C::* member;
		};
		template<typename C, typename M>
		struct BoundUnaryMethod : IArgFunction<C> {
			BoundUnaryMethod(void (C::*_member)(M)) : member(_member) {}
			virtual void set(C& p, std::string const& stringValue) const {
				typename RemoveConstRef<M>::type value;
				convertInto(stringValue, value);
				(p.*member)(value);
			}
			virtual bool takesArg() const { return !IsBool<M>::value; }
			virtual IArgFunction<C>* clone() const { return new BoundUnaryMethod(*this); }
			void (C::*member)(M);
		};
		template<typename C>
		struct BoundNullaryMethod : IArgFunction<C> {
			BoundNullaryMethod(void (C::*_member)()) : member(_member) {}
			virtual void set(C& p, std::string const& stringValue) const {
				bool value;
				convertInto(stringValue, value);
				if (value)
					(p.*member)();
			}
			virtual bool takesArg() const { return false; }
			virtual IArgFunction<C>* clone() const { return new BoundNullaryMethod(*this); }
			void (C::*member)();
		};

		template<typename C>
		struct BoundUnaryFunction : IArgFunction<C> {
			BoundUnaryFunction(void(*_function)(C&)) : function(_function) {}
			virtual void set(C& obj, std::string const& stringValue) const {
				bool value;
				convertInto(stringValue, value);
				if (value)
					function(obj);
			}
			virtual bool takesArg() const { return false; }
			virtual IArgFunction<C>* clone() const { return new BoundUnaryFunction(*this); }
			void(*function)(C&);
		};

		template<typename C, typename T>
		struct BoundBinaryFunction : IArgFunction<C> {
			BoundBinaryFunction(void(*_function)(C&, T)) : function(_function) {}
			virtual void set(C& obj, std::string const& stringValue) const {
				typename RemoveConstRef<T>::type value;
				convertInto(stringValue, value);
				function(obj, value);
			}
			virtual bool takesArg() const { return !IsBool<T>::value; }
			virtual IArgFunction<C>* clone() const { return new BoundBinaryFunction(*this); }
			void(*function)(C&, T);
		};

	} // namespace Detail

	inline std::vector<std::string> argsToVector(int argc, char const* const* const argv) {
		std::vector<std::string> args(static_cast<std::size_t>(argc));
		for (std::size_t i = 0; i < static_cast<std::size_t>(argc); ++i)
			args[i] = argv[i];

		return args;
	}

	class Parser {
		enum Mode { None, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional };
		Mode mode;
		std::size_t from;
		bool inQuotes;
	public:

		struct Token {
			enum Type { Positional, ShortOpt, LongOpt };
			Token(Type _type, std::string const& _data) : type(_type), data(_data) {}
			Type type;
			std::string data;
		};

		Parser() : mode(None), from(0), inQuotes(false) {}

		void parseIntoTokens(std::vector<std::string> const& args, std::vector<Token>& tokens) {
			const std::string doubleDash = "--";
			for (std::size_t i = 1; i < args.size() && args[i] != doubleDash; ++i)
				parseIntoTokens(args[i], tokens);
		}

		void parseIntoTokens(std::string const& arg, std::vector<Token>& tokens) {
			for (std::size_t i = 0; i <= arg.size(); ++i) {
				char c = arg[i];
				if (c == '"')
					inQuotes = !inQuotes;
				mode = handleMode(i, c, arg, tokens);
			}
		}
		Mode handleMode(std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens) {
			switch (mode) {
			case None: return handleNone(i, c);
			case MaybeShortOpt: return handleMaybeShortOpt(i, c);
			case ShortOpt:
			case LongOpt:
			case SlashOpt: return handleOpt(i, c, arg, tokens);
			case Positional: return handlePositional(i, c, arg, tokens);
			default: throw std::logic_error("Unknown mode");
			}
		}

		Mode handleNone(std::size_t i, char c) {
			if (inQuotes) {
				from = i;
				return Positional;
			}
			switch (c) {
			case '-': return MaybeShortOpt;
#ifdef CLARA_PLATFORM_WINDOWS
			case '/': from = i + 1; return SlashOpt;
#endif
			default: from = i; return Positional;
			}
		}
		Mode handleMaybeShortOpt(std::size_t i, char c) {
			switch (c) {
			case '-': from = i + 1; return LongOpt;
			default: from = i; return ShortOpt;
			}
		}
		Mode handleOpt(std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens) {
			if (std::string(":=\0", 5).find(c) == std::string::npos)
				return mode;

			std::string optName = arg.substr(from, i - from);
			if (mode == ShortOpt)
				for (std::size_t j = 0; j < optName.size(); ++j)
					tokens.push_back(Token(Token::ShortOpt, optName.substr(j, 1)));
			else if (mode == SlashOpt && optName.size() == 1)
				tokens.push_back(Token(Token::ShortOpt, optName));
			else
				tokens.push_back(Token(Token::LongOpt, optName));
			return None;
		}
		Mode handlePositional(std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens) {
			if (inQuotes || std::string("\0", 3).find(c) == std::string::npos)
				return mode;

			std::string data = arg.substr(from, i - from);
			tokens.push_back(Token(Token::Positional, data));
			return None;
		}
	};

	template<typename ConfigT>
	struct CommonArgProperties {
		CommonArgProperties() {}
		CommonArgProperties(Detail::BoundArgFunction<ConfigT> const& _boundField) : boundField(_boundField) {}

		Detail::BoundArgFunction<ConfigT> boundField;
		std::string description;
		std::string detail;
		std::string placeholder; // Only value if boundField takes an arg

		bool takesArg() const {
			return !placeholder.empty();
		}
		void validate() const {
			if (!boundField.isSet())
				throw std::logic_error("option not bound");
		}
	};
	struct OptionArgProperties {
		std::vector<std::string> shortNames;
		std::string longName;

		bool hasShortName(std::string const& shortName) const {
			return std::find(shortNames.begin(), shortNames.end(), shortName) != shortNames.end();
		}
		bool hasLongName(std::string const& _longName) const {
			return _longName == longName;
		}
	};
	struct PositionalArgProperties {
		PositionalArgProperties() : position(-1) {}
		int position; // -1 means non-positional (floating)

		bool isFixedPositional() const {
			return position != -1;
		}
	};

	template<typename ConfigT>
	class CommandLine {

		struct Arg : CommonArgProperties<ConfigT>, OptionArgProperties, PositionalArgProperties {
			Arg() {}
			Arg(Detail::BoundArgFunction<ConfigT> const& _boundField) : CommonArgProperties<ConfigT>(_boundField) {}

			using CommonArgProperties<ConfigT>::placeholder; // !TBD

			std::string dbgName() const {
				if (!longName.empty())
					return "--" + longName;
				if (!shortNames.empty())
					return "-" + shortNames[0];
				return "positional args";
			}
			std::string commands() const {
				std::ostringstream oss;
				bool first = true;
				std::vector<std::string>::const_iterator it = shortNames.begin(), itEnd = shortNames.end();
				for (; it != itEnd; ++it) {
					if (first)
						first = false;
					else
						oss << ", ";
					oss << "-" << *it;
				}
				if (!longName.empty()) {
					if (!first)
						oss << ", ";
					oss << "--" << longName;
				}
				if (!placeholder.empty())
					oss << " <" << placeholder << ">";
				return oss.str();
			}
		};

		typedef CLARA_AUTO_PTR(Arg) ArgAutoPtr;

		friend void addOptName(Arg& arg, std::string const& optName)
		{
			if (optName.empty())
				return;
			if (Detail::startsWith(optName, "--")) {
				if (!arg.longName.empty())
					throw std::logic_error("Only one long opt may be specified. '"
						+ arg.longName
						+ "' already specified, now attempting to add '"
						+ optName + "'");
				arg.longName = optName.substr(2);
			}
			else if (Detail::startsWith(optName, "-"))
				arg.shortNames.push_back(optName.substr(1));
			else
				throw std::logic_error("option must begin with - or --. Option was: '" + optName + "'");
		}
		friend void setPositionalArg(Arg& arg, int position)
		{
			arg.position = position;
		}

		class ArgBuilder {
		public:
			ArgBuilder(Arg* arg) : m_arg(arg) {}

			// Bind a non-boolean data member (requires placeholder string)
			template<typename C, typename M>
			void bind(M C::* field, std::string const& placeholder) {
				m_arg->boundField = new Detail::BoundDataMember<C, M>(field);
				m_arg->placeholder = placeholder;
			}
			// Bind a boolean data member (no placeholder required)
			template<typename C>
			void bind(bool C::* field) {
				m_arg->boundField = new Detail::BoundDataMember<C, bool>(field);
			}

			// Bind a method taking a single, non-boolean argument (requires a placeholder string)
			template<typename C, typename M>
			void bind(void (C::* unaryMethod)(M), std::string const& placeholder) {
				m_arg->boundField = new Detail::BoundUnaryMethod<C, M>(unaryMethod);
				m_arg->placeholder = placeholder;
			}

			// Bind a method taking a single, boolean argument (no placeholder string required)
			template<typename C>
			void bind(void (C::* unaryMethod)(bool)) {
				m_arg->boundField = new Detail::BoundUnaryMethod<C, bool>(unaryMethod);
			}

			// Bind a method that takes no arguments (will be called if opt is present)
			template<typename C>
			void bind(void (C::* nullaryMethod)()) {
				m_arg->boundField = new Detail::BoundNullaryMethod<C>(nullaryMethod);
			}

			// Bind a free function taking a single argument - the object to operate on (no placeholder string required)
			template<typename C>
			void bind(void(*unaryFunction)(C&)) {
				m_arg->boundField = new Detail::BoundUnaryFunction<C>(unaryFunction);
			}

			// Bind a free function taking a single argument - the object to operate on (requires a placeholder string)
			template<typename C, typename T>
			void bind(void(*binaryFunction)(C&, T), std::string const& placeholder) {
				m_arg->boundField = new Detail::BoundBinaryFunction<C, T>(binaryFunction);
				m_arg->placeholder = placeholder;
			}

			ArgBuilder& describe(std::string const& description) {
				m_arg->description = description;
				return *this;
			}
			ArgBuilder& detail(std::string const& detail) {
				m_arg->detail = detail;
				return *this;
			}

		protected:
			Arg* m_arg;
		};

		class OptBuilder : public ArgBuilder {
		public:
			OptBuilder(Arg* arg) : ArgBuilder(arg) {}
			OptBuilder(OptBuilder& other) : ArgBuilder(other) {}

			OptBuilder& operator[](std::string const& optName) {
				addOptName(*ArgBuilder::m_arg, optName);
				return *this;
			}
		};

	public:

		CommandLine()
			: m_boundProcessName(new Detail::NullBinder<ConfigT>()),
			m_highestSpecifiedArgPosition(0),
			m_throwOnUnrecognisedTokens(false)
		{}
		CommandLine(CommandLine const& other)
			: m_boundProcessName(other.m_boundProcessName),
			m_options(other.m_options),
			m_positionalArgs(other.m_positionalArgs),
			m_highestSpecifiedArgPosition(other.m_highestSpecifiedArgPosition),
			m_throwOnUnrecognisedTokens(other.m_throwOnUnrecognisedTokens)
		{
			if (other.m_floatingArg.get())
				m_floatingArg.reset(new Arg(*other.m_floatingArg));
		}

		CommandLine& setThrowOnUnrecognisedTokens(bool shouldThrow = true) {
			m_throwOnUnrecognisedTokens = shouldThrow;
			return *this;
		}

		OptBuilder operator[](std::string const& optName) {
			m_options.push_back(Arg());
			addOptName(m_options.back(), optName);
			OptBuilder builder(&m_options.back());
			return builder;
		}

		ArgBuilder operator[](int position) {
			m_positionalArgs.insert(std::make_pair(position, Arg()));
			if (position > m_highestSpecifiedArgPosition)
				m_highestSpecifiedArgPosition = position;
			setPositionalArg(m_positionalArgs[position], position);
			ArgBuilder builder(&m_positionalArgs[position]);
			return builder;
		}

		// Invoke this with the _ instance
		ArgBuilder operator[](UnpositionalTag) {
			if (m_floatingArg.get())
				throw std::logic_error("Only one unpositional argument can be added");
			m_floatingArg.reset(new Arg());
			ArgBuilder builder(m_floatingArg.get());
			return builder;
		}

		template<typename C, typename M>
		void bindProcessName(M C::* field) {
			m_boundProcessName = new Detail::BoundDataMember<C, M>(field);
		}
		template<typename C, typename M>
		void bindProcessName(void (C::*_unaryMethod)(M)) {
			m_boundProcessName = new Detail::BoundUnaryMethod<C, M>(_unaryMethod);
		}

		void optUsage(std::ostream& os, std::size_t indent = 0, std::size_t width = Detail::consoleWidth) const {
			typename std::vector<Arg>::const_iterator itBegin = m_options.begin(), itEnd = m_options.end(), it;
			std::size_t maxWidth = 0;
			for (it = itBegin; it != itEnd; ++it)
				maxWidth = (std::max)(maxWidth, it->commands().size());

			for (it = itBegin; it != itEnd; ++it) {
				Detail::Text usage(it->commands(), Detail::TextAttributes()
					.setWidth(maxWidth + indent)
					.setIndent(indent));
				Detail::Text desc(it->description, Detail::TextAttributes()
					.setWidth(width - maxWidth - 3));

				for (std::size_t i = 0; i < (std::max)(usage.size(), desc.size()); ++i) {
					std::string usageCol = i < usage.size() ? usage[i] : "";
					os << usageCol;

					if (i < desc.size() && !desc[i].empty())
						os << std::string(indent + 2 + maxWidth - usageCol.size(), ' ')
						<< desc[i];
					os << "\n";
				}
			}
		}
		std::string optUsage() const {
			std::ostringstream oss;
			optUsage(oss);
			return oss.str();
		}

		void argSynopsis(std::ostream& os) const {
			for (int i = 1; i <= m_highestSpecifiedArgPosition; ++i) {
				if (i > 1)
					os << " ";
				typename std::map<int, Arg>::const_iterator it = m_positionalArgs.find(i);
				if (it != m_positionalArgs.end())
					os << "<" << it->second.placeholder << ">";
				else if (m_floatingArg.get())
					os << "<" << m_floatingArg->placeholder << ">";
				else
					throw std::logic_error("non consecutive positional arguments with no floating args");
			}
			// !TBD No indication of mandatory args
			if (m_floatingArg.get()) {
				if (m_highestSpecifiedArgPosition > 1)
					os << " ";
				os << "[<" << m_floatingArg->placeholder << "> ...]";
			}
		}
		std::string argSynopsis() const {
			std::ostringstream oss;
			argSynopsis(oss);
			return oss.str();
		}

		void usage(std::ostream& os, std::string const& procName) const {
			validate();
			os << "usage:\n  " << procName << " ";
			argSynopsis(os);
			if (!m_options.empty()) {
				os << " [options]\n\nwhere options are: \n";
				optUsage(os, 2);
			}
			os << "\n";
		}
		std::string usage(std::string const& procName) const {
			std::ostringstream oss;
			usage(oss, procName);
			return oss.str();
		}

		ConfigT parse(std::vector<std::string> const& args) const {
			ConfigT config;
			parseInto(args, config);
			return config;
		}

		std::vector<Parser::Token> parseInto(std::vector<std::string> const& args, ConfigT& config) const {
			std::string processName = args[0];
			std::size_t lastSlash = processName.find_last_of("/\\");
			if (lastSlash != std::string::npos)
				processName = processName.substr(lastSlash + 1);
			m_boundProcessName.set(config, processName);
			std::vector<Parser::Token> tokens;
			Parser parser;
			parser.parseIntoTokens(args, tokens);
			return populate(tokens, config);
		}

		std::vector<Parser::Token> populate(std::vector<Parser::Token> const& tokens, ConfigT& config) const {
			validate();
			std::vector<Parser::Token> unusedTokens = populateOptions(tokens, config);
			unusedTokens = populateFixedArgs(unusedTokens, config);
			unusedTokens = populateFloatingArgs(unusedTokens, config);
			return unusedTokens;
		}

		std::vector<Parser::Token> populateOptions(std::vector<Parser::Token> const& tokens, ConfigT& config) const {
			std::vector<Parser::Token> unusedTokens;
			std::vector<std::string> errors;
			for (std::size_t i = 0; i < tokens.size(); ++i) {
				Parser::Token const& token = tokens[i];
				typename std::vector<Arg>::const_iterator it = m_options.begin(), itEnd = m_options.end();
				for (; it != itEnd; ++it) {
					Arg const& arg = *it;

					try {
						if ((token.type == Parser::Token::ShortOpt && arg.hasShortName(token.data)) ||
							(token.type == Parser::Token::LongOpt && arg.hasLongName(token.data))) {
							if (arg.takesArg()) {
								if (i == tokens.size() - 1 || tokens[i + 1].type != Parser::Token::Positional)
									errors.push_back("Expected argument to option: " + token.data);
								else
									arg.boundField.set(config, tokens[++i].data);
							}
							else {
								arg.boundField.set(config, "true");
							}
							break;
						}
					}
					catch (std::exception& ex) {
						errors.push_back(std::string(ex.what()) + "\n- while parsing: (" + arg.commands() + ")");
					}
				}
				if (it == itEnd) {
					if (token.type == Parser::Token::Positional || !m_throwOnUnrecognisedTokens)
						unusedTokens.push_back(token);
					else if (errors.empty() && m_throwOnUnrecognisedTokens)
						errors.push_back("unrecognised option: " + token.data);
				}
			}
			if (!errors.empty()) {
				std::ostringstream oss;
				for (std::vector<std::string>::const_iterator it = errors.begin(), itEnd = errors.end();
					it != itEnd;
					++it) {
					if (it != errors.begin())
						oss << "\n";
					oss << *it;
				}
				throw std::runtime_error(oss.str());
			}
			return unusedTokens;
		}
		std::vector<Parser::Token> populateFixedArgs(std::vector<Parser::Token> const& tokens, ConfigT& config) const {
			std::vector<Parser::Token> unusedTokens;
			int position = 1;
			for (std::size_t i = 0; i < tokens.size(); ++i) {
				Parser::Token const& token = tokens[i];
				typename std::map<int, Arg>::const_iterator it = m_positionalArgs.find(position);
				if (it != m_positionalArgs.end())
					it->second.boundField.set(config, token.data);
				else
					unusedTokens.push_back(token);
				if (token.type == Parser::Token::Positional)
					position++;
			}
			return unusedTokens;
		}
		std::vector<Parser::Token> populateFloatingArgs(std::vector<Parser::Token> const& tokens, ConfigT& config) const {
			if (!m_floatingArg.get())
				return tokens;
			std::vector<Parser::Token> unusedTokens;
			for (std::size_t i = 0; i < tokens.size(); ++i) {
				Parser::Token const& token = tokens[i];
				if (token.type == Parser::Token::Positional)
					m_floatingArg->boundField.set(config, token.data);
				else
					unusedTokens.push_back(token);
			}
			return unusedTokens;
		}

		void validate() const
		{
			if (m_options.empty() && m_positionalArgs.empty() && !m_floatingArg.get())
				throw std::logic_error("No options or arguments specified");

			for (typename std::vector<Arg>::const_iterator  it = m_options.begin(),
				itEnd = m_options.end();
				it != itEnd; ++it)
				it->validate();
		}

	private:
		Detail::BoundArgFunction<ConfigT> m_boundProcessName;
		std::vector<Arg> m_options;
		std::map<int, Arg> m_positionalArgs;
		ArgAutoPtr m_floatingArg;
		int m_highestSpecifiedArgPosition;
		bool m_throwOnUnrecognisedTokens;
	};

} // end namespace Clara

STITCH_CLARA_CLOSE_NAMESPACE
#undef STITCH_CLARA_OPEN_NAMESPACE
#undef STITCH_CLARA_CLOSE_NAMESPACE

#endif // TWOBLUECUBES_CLARA_H_INCLUDED
#undef STITCH_CLARA_OPEN_NAMESPACE

// Restore Clara's value for console width, if present
#ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
#define CLARA_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
#undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
#endif

#include <fstream>

namespace Catch {

	inline void abortAfterFirst(ConfigData& config) { config.abortAfter = 1; }
	inline void abortAfterX(ConfigData& config, int x) {
		if (x < 1)
			throw std::runtime_error("Value after -x or --abortAfter must be greater than zero");
		config.abortAfter = x;
	}
	inline void addTestOrTags(ConfigData& config, std::string const& _testSpec) { config.testsOrTags.push_back(_testSpec); }
	inline void addReporterName(ConfigData& config, std::string const& _reporterName) { config.reporterNames.push_back(_reporterName); }

	inline void addWarning(ConfigData& config, std::string const& _warning) {
		if (_warning == "NoAssertions")
			config.warnings = static_cast<WarnAbout::What>(config.warnings | WarnAbout::NoAssertions);
		else
			throw std::runtime_error("Unrecognised warning: '" + _warning + "'");
	}
	inline void setOrder(ConfigData& config, std::string const& order) {
		if (startsWith("declared", order))
			config.runOrder = RunTests::InDeclarationOrder;
		else if (startsWith("lexical", order))
			config.runOrder = RunTests::InLexicographicalOrder;
		else if (startsWith("random", order))
			config.runOrder = RunTests::InRandomOrder;
		else
			throw std::runtime_error("Unrecognised ordering: '" + order + "'");
	}
	inline void setRngSeed(ConfigData& config, std::string const& seed) {
		if (seed == "time") {
			config.rngSeed = static_cast<unsigned int>(std::time(0));
		}
		else {
			std::stringstream ss;
			ss << seed;
			ss >> config.rngSeed;
			if (ss.fail())
				throw std::runtime_error("Argment to --rng-seed should be the word 'time' or a number");
		}
	}
	inline void setVerbosity(ConfigData& config, int level) {
		// !TBD: accept strings?
		config.verbosity = static_cast<Verbosity::Level>(level);
	}
	inline void setShowDurations(ConfigData& config, bool _showDurations) {
		config.showDurations = _showDurations
			? ShowDurations::Always
			: ShowDurations::Never;
	}
	inline void setUseColour(ConfigData& config, std::string const& value) {
		std::string mode = toLower(value);

		if (mode == "yes")
			config.useColour = UseColour::Yes;
		else if (mode == "no")
			config.useColour = UseColour::No;
		else if (mode == "auto")
			config.useColour = UseColour::Auto;
		else
			throw std::runtime_error("colour mode must be one of: auto, yes or no");
	}
	inline void forceColour(ConfigData& config) {
		config.useColour = UseColour::Yes;
	}
	inline void loadTestNamesFromFile(ConfigData& config, std::string const& _filename) {
		std::ifstream f(_filename.c_str());
		if (!f.is_open())
			throw std::domain_error("Unable to load input file: " + _filename);

		std::string line;
		while (std::getline(f, line)) {
			line = trim(line);
			if (!line.empty() && !startsWith(line, "#"))
				addTestOrTags(config, "\"" + line + "\",");
		}
	}

	inline Clara::CommandLine<ConfigData> makeCommandLineParser() {

		using namespace Clara;
		CommandLine<ConfigData> cli;

		cli.bindProcessName(&ConfigData::processName);

		cli["-?"]["-h"]["--help"]
			.describe("display usage information")
			.bind(&ConfigData::showHelp);

		cli["-l"]["--list-tests"]
			.describe("list all/matching test cases")
			.bind(&ConfigData::listTests);

		cli["-t"]["--list-tags"]
			.describe("list all/matching tags")
			.bind(&ConfigData::listTags);

		cli["-s"]["--success"]
			.describe("include successful tests in output")
			.bind(&ConfigData::showSuccessfulTests);

		cli["-b"]["--break"]
			.describe("break into debugger on failure")
			.bind(&ConfigData::shouldDebugBreak);

		cli["-e"]["--nothrow"]
			.describe("skip exception tests")
			.bind(&ConfigData::noThrow);

		cli["-i"]["--invisibles"]
			.describe("show invisibles (tabs, newlines)")
			.bind(&ConfigData::showInvisibles);

		cli["-o"]["--out"]
			.describe("output filename")
			.bind(&ConfigData::outputFilename, "filename");

		cli["-r"]["--reporter"]
			//            .placeholder( "name[:filename]" )
			.describe("reporter to use (defaults to console)")
			.bind(&addReporterName, "name");

		cli["-n"]["--name"]
			.describe("suite name")
			.bind(&ConfigData::name, "name");

		cli["-a"]["--abort"]
			.describe("abort at first failure")
			.bind(&abortAfterFirst);

		cli["-x"]["--abortx"]
			.describe("abort after x failures")
			.bind(&abortAfterX, "no. failures");

		cli["-w"]["--warn"]
			.describe("enable warnings")
			.bind(&addWarning, "warning name");

		// - needs updating if reinstated
		//        cli.into( &setVerbosity )
		//            .describe( "level of verbosity (0=no output)" )
		//            .shortOpt( "v")
		//            .longOpt( "verbosity" )
		//            .placeholder( "level" );

		cli[_]
			.describe("which test or tests to use")
			.bind(&addTestOrTags, "test name, pattern or tags");

		cli["-d"]["--durations"]
			.describe("show test durations")
			.bind(&setShowDurations, "yes|no");

		cli["-f"]["--input-file"]
			.describe("load test names to run from a file")
			.bind(&loadTestNamesFromFile, "filename");

		cli["-#"]["--filenames-as-tags"]
			.describe("adds a tag for the filename")
			.bind(&ConfigData::filenamesAsTags);

		// Less common commands which don't have a short form
		cli["--list-test-names-only"]
			.describe("list all/matching test cases names only")
			.bind(&ConfigData::listTestNamesOnly);

		cli["--list-reporters"]
			.describe("list all reporters")
			.bind(&ConfigData::listReporters);

		cli["--order"]
			.describe("test case order (defaults to decl)")
			.bind(&setOrder, "decl|lex|rand");

		cli["--rng-seed"]
			.describe("set a specific seed for random numbers")
			.bind(&setRngSeed, "'time'|number");

		cli["--force-colour"]
			.describe("force colourised output (deprecated)")
			.bind(&forceColour);

		cli["--use-colour"]
			.describe("should output be colourised")
			.bind(&setUseColour, "yes|no");

		return cli;
	}

} // end namespace Catch

  // #included from: internal/catch_list.hpp
#define TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED

  // #included from: catch_text.h
#define TWOBLUECUBES_CATCH_TEXT_H_INCLUDED

#define TBC_TEXT_FORMAT_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH

#define CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE Catch
  // #included from: ../external/tbc_text_format.h
  // Only use header guard if we are not using an outer namespace
#ifndef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
# ifdef TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED
#  ifndef TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
#   define TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
#  endif
# else
#  define TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED
# endif
#endif
#ifndef TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
#include <string>
#include <vector>
#include <sstream>

  // Use optional outer namespace
#ifdef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
namespace CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE {
#endif

	namespace Tbc {

#ifdef TBC_TEXT_FORMAT_CONSOLE_WIDTH
		const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;
#else
		const unsigned int consoleWidth = 80;
#endif

		struct TextAttributes {
			TextAttributes()
				: initialIndent(std::string::npos),
				indent(0),
				width(consoleWidth - 1),
				tabChar('\t')
			{}

			TextAttributes& setInitialIndent(std::size_t _value) { initialIndent = _value; return *this; }
			TextAttributes& setIndent(std::size_t _value) { indent = _value; return *this; }
			TextAttributes& setWidth(std::size_t _value) { width = _value; return *this; }
			TextAttributes& setTabChar(char _value) { tabChar = _value; return *this; }

			std::size_t initialIndent;  // indent of first line, or npos
			std::size_t indent;         // indent of subsequent lines, or all if initialIndent is npos
			std::size_t width;          // maximum width of text, including indent. Longer text will wrap
			char tabChar;               // If this char is seen the indent is changed to current pos
		};

		class Text {
		public:
			Text(std::string const& _str, TextAttributes const& _attr = TextAttributes())
				: attr(_attr)
			{
				std::string wrappableChars = " [({.,/|\\-";
				std::size_t indent = _attr.initialIndent != std::string::npos
					? _attr.initialIndent
					: _attr.indent;
				std::string remainder = _str;

				while (!remainder.empty()) {
					if (lines.size() >= 1000) {
						lines.push_back("... message truncated due to excessive size");
						return;
					}
					std::size_t tabPos = std::string::npos;
					std::size_t width = (std::min)(remainder.size(), _attr.width - indent);
					std::size_t pos = remainder.find_first_of('\n');
					if (pos <= width) {
						width = pos;
					}
					pos = remainder.find_last_of(_attr.tabChar, width);
					if (pos != std::string::npos) {
						tabPos = pos;
						if (remainder[width] == '\n')
							width--;
						remainder = remainder.substr(0, tabPos) + remainder.substr(tabPos + 1);
					}

					if (width == remainder.size()) {
						spliceLine(indent, remainder, width);
					}
					else if (remainder[width] == '\n') {
						spliceLine(indent, remainder, width);
						if (width <= 1 || remainder.size() != 1)
							remainder = remainder.substr(1);
						indent = _attr.indent;
					}
					else {
						pos = remainder.find_last_of(wrappableChars, width);
						if (pos != std::string::npos && pos > 0) {
							spliceLine(indent, remainder, pos);
							if (remainder[0] == ' ')
								remainder = remainder.substr(1);
						}
						else {
							spliceLine(indent, remainder, width - 1);
							lines.back() += "-";
						}
						if (lines.size() == 1)
							indent = _attr.indent;
						if (tabPos != std::string::npos)
							indent += tabPos;
					}
				}
			}

			void spliceLine(std::size_t _indent, std::string& _remainder, std::size_t _pos) {
				lines.push_back(std::string(_indent, ' ') + _remainder.substr(0, _pos));
				_remainder = _remainder.substr(_pos);
			}

			typedef std::vector<std::string>::const_iterator const_iterator;

			const_iterator begin() const { return lines.begin(); }
			const_iterator end() const { return lines.end(); }
			std::string const& last() const { return lines.back(); }
			std::size_t size() const { return lines.size(); }
			std::string const& operator[](std::size_t _index) const { return lines[_index]; }
			std::string toString() const {
				std::ostringstream oss;
				oss << *this;
				return oss.str();
			}

			inline friend std::ostream& operator << (std::ostream& _stream, Text const& _text) {
				for (Text::const_iterator it = _text.begin(), itEnd = _text.end();
					it != itEnd; ++it) {
					if (it != _text.begin())
						_stream << "\n";
					_stream << *it;
				}
				return _stream;
			}

		private:
			std::string str;
			TextAttributes attr;
			std::vector<std::string> lines;
		};

	} // end namespace Tbc

#ifdef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
} // end outer namespace
#endif

#endif // TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
#undef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE

namespace Catch {
	using Tbc::Text;
	using Tbc::TextAttributes;
}

// #included from: catch_console_colour.hpp
#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED

namespace Catch {

	struct Colour {
		enum Code {
			None = 0,

			White,
			Red,
			Green,
			Blue,
			Cyan,
			Yellow,
			Grey,

			Bright = 0x10,

			BrightRed = Bright | Red,
			BrightGreen = Bright | Green,
			LightGrey = Bright | Grey,
			BrightWhite = Bright | White,

			// By intention
			FileName = LightGrey,
			Warning = Yellow,
			ResultError = BrightRed,
			ResultSuccess = BrightGreen,
			ResultExpectedFailure = Warning,

			Error = BrightRed,
			Success = Green,

			OriginalExpression = Cyan,
			ReconstructedExpression = Yellow,

			SecondaryText = LightGrey,
			Headers = White
		};

		// Use constructed object for RAII guard
		Colour(Code _colourCode);
		Colour(Colour const& other);
		~Colour();

		// Use static method for one-shot changes
		static void use(Code _colourCode);

	private:
		bool m_moved;
	};

	inline std::ostream& operator << (std::ostream& os, Colour const&) { return os; }

} // end namespace Catch

  // #included from: catch_interfaces_reporter.h
#define TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED

#include <string>
#include <ostream>
#include <map>
#include <assert.h>

namespace Catch
{
	struct ReporterConfig {
		explicit ReporterConfig(Ptr<IConfig const> const& _fullConfig)
			: m_stream(&_fullConfig->stream()), m_fullConfig(_fullConfig) {}

		ReporterConfig(Ptr<IConfig const> const& _fullConfig, std::ostream& _stream)
			: m_stream(&_stream), m_fullConfig(_fullConfig) {}

		std::ostream& stream() const { return *m_stream; }
		Ptr<IConfig const> fullConfig() const { return m_fullConfig; }

	private:
		std::ostream* m_stream;
		Ptr<IConfig const> m_fullConfig;
	};

	struct ReporterPreferences {
		ReporterPreferences()
			: shouldRedirectStdOut(false)
		{}

		bool shouldRedirectStdOut;
	};

	template<typename T>
	struct LazyStat : Option<T> {
		LazyStat() : used(false) {}
		LazyStat& operator=(T const& _value) {
			Option<T>::operator=(_value);
			used = false;
			return *this;
		}
		void reset() {
			Option<T>::reset();
			used = false;
		}
		bool used;
	};

	struct TestRunInfo {
		TestRunInfo(std::string const& _name) : name(_name) {}
		std::string name;
	};
	struct GroupInfo {
		GroupInfo(std::string const& _name,
			std::size_t _groupIndex,
			std::size_t _groupsCount)
			: name(_name),
			groupIndex(_groupIndex),
			groupsCounts(_groupsCount)
		{}

		std::string name;
		std::size_t groupIndex;
		std::size_t groupsCounts;
	};

	struct AssertionStats {
		AssertionStats(AssertionResult const& _assertionResult,
			std::vector<MessageInfo> const& _infoMessages,
			Totals const& _totals)
			: assertionResult(_assertionResult),
			infoMessages(_infoMessages),
			totals(_totals)
		{
			if (assertionResult.hasMessage()) {
				// Copy message into messages list.
				// !TBD This should have been done earlier, somewhere
				MessageBuilder builder(assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType());
				builder << assertionResult.getMessage();
				builder.m_info.message = builder.m_stream.str();

				infoMessages.push_back(builder.m_info);
			}
		}
		virtual ~AssertionStats();

#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		AssertionStats(AssertionStats const&) = default;
		AssertionStats(AssertionStats &&) = default;
		AssertionStats& operator = (AssertionStats const&) = default;
		AssertionStats& operator = (AssertionStats &&) = default;
#  endif

		AssertionResult assertionResult;
		std::vector<MessageInfo> infoMessages;
		Totals totals;
	};

	struct SectionStats {
		SectionStats(SectionInfo const& _sectionInfo,
			Counts const& _assertions,
			double _durationInSeconds,
			bool _missingAssertions)
			: sectionInfo(_sectionInfo),
			assertions(_assertions),
			durationInSeconds(_durationInSeconds),
			missingAssertions(_missingAssertions)
		{}
		virtual ~SectionStats();
#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		SectionStats(SectionStats const&) = default;
		SectionStats(SectionStats &&) = default;
		SectionStats& operator = (SectionStats const&) = default;
		SectionStats& operator = (SectionStats &&) = default;
#  endif

		SectionInfo sectionInfo;
		Counts assertions;
		double durationInSeconds;
		bool missingAssertions;
	};

	struct TestCaseStats {
		TestCaseStats(TestCaseInfo const& _testInfo,
			Totals const& _totals,
			std::string const& _stdOut,
			std::string const& _stdErr,
			bool _aborting)
			: testInfo(_testInfo),
			totals(_totals),
			stdOut(_stdOut),
			stdErr(_stdErr),
			aborting(_aborting)
		{}
		virtual ~TestCaseStats();

#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		TestCaseStats(TestCaseStats const&) = default;
		TestCaseStats(TestCaseStats &&) = default;
		TestCaseStats& operator = (TestCaseStats const&) = default;
		TestCaseStats& operator = (TestCaseStats &&) = default;
#  endif

		TestCaseInfo testInfo;
		Totals totals;
		std::string stdOut;
		std::string stdErr;
		bool aborting;
	};

	struct TestGroupStats {
		TestGroupStats(GroupInfo const& _groupInfo,
			Totals const& _totals,
			bool _aborting)
			: groupInfo(_groupInfo),
			totals(_totals),
			aborting(_aborting)
		{}
		TestGroupStats(GroupInfo const& _groupInfo)
			: groupInfo(_groupInfo),
			aborting(false)
		{}
		virtual ~TestGroupStats();

#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		TestGroupStats(TestGroupStats const&) = default;
		TestGroupStats(TestGroupStats &&) = default;
		TestGroupStats& operator = (TestGroupStats const&) = default;
		TestGroupStats& operator = (TestGroupStats &&) = default;
#  endif

		GroupInfo groupInfo;
		Totals totals;
		bool aborting;
	};

	struct TestRunStats {
		TestRunStats(TestRunInfo const& _runInfo,
			Totals const& _totals,
			bool _aborting)
			: runInfo(_runInfo),
			totals(_totals),
			aborting(_aborting)
		{}
		virtual ~TestRunStats();

#  ifndef CATCH_CONFIG_CPP11_GENERATED_METHODS
		TestRunStats(TestRunStats const& _other)
			: runInfo(_other.runInfo),
			totals(_other.totals),
			aborting(_other.aborting)
		{}
#  else
		TestRunStats(TestRunStats const&) = default;
		TestRunStats(TestRunStats &&) = default;
		TestRunStats& operator = (TestRunStats const&) = default;
		TestRunStats& operator = (TestRunStats &&) = default;
#  endif

		TestRunInfo runInfo;
		Totals totals;
		bool aborting;
	};

	class MultipleReporters;

	struct IStreamingReporter : IShared {
		virtual ~IStreamingReporter();

		// Implementing class must also provide the following static method:
		// static std::string getDescription();

		virtual ReporterPreferences getPreferences() const = 0;

		virtual void noMatchingTestCases(std::string const& spec) = 0;

		virtual void testRunStarting(TestRunInfo const& testRunInfo) = 0;
		virtual void testGroupStarting(GroupInfo const& groupInfo) = 0;

		virtual void testCaseStarting(TestCaseInfo const& testInfo) = 0;
		virtual void sectionStarting(SectionInfo const& sectionInfo) = 0;

		virtual void assertionStarting(AssertionInfo const& assertionInfo) = 0;

		// The return value indicates if the messages buffer should be cleared:
		virtual bool assertionEnded(AssertionStats const& assertionStats) = 0;

		virtual void sectionEnded(SectionStats const& sectionStats) = 0;
		virtual void testCaseEnded(TestCaseStats const& testCaseStats) = 0;
		virtual void testGroupEnded(TestGroupStats const& testGroupStats) = 0;
		virtual void testRunEnded(TestRunStats const& testRunStats) = 0;

		virtual void skipTest(TestCaseInfo const& testInfo) = 0;

		virtual MultipleReporters* tryAsMulti() { return CATCH_NULL; }
	};

	struct IReporterFactory : IShared {
		virtual ~IReporterFactory();
		virtual IStreamingReporter* create(ReporterConfig const& config) const = 0;
		virtual std::string getDescription() const = 0;
	};

	struct IReporterRegistry {
		typedef std::map<std::string, Ptr<IReporterFactory> > FactoryMap;
		typedef std::vector<Ptr<IReporterFactory> > Listeners;

		virtual ~IReporterRegistry();
		virtual IStreamingReporter* create(std::string const& name, Ptr<IConfig const> const& config) const = 0;
		virtual FactoryMap const& getFactories() const = 0;
		virtual Listeners const& getListeners() const = 0;
	};

	Ptr<IStreamingReporter> addReporter(Ptr<IStreamingReporter> const& existingReporter, Ptr<IStreamingReporter> const& additionalReporter);

}

#include <limits>
#include <algorithm>

namespace Catch {

	inline std::size_t listTests(Config const& config) {

		TestSpec testSpec = config.testSpec();
		if (config.testSpec().hasFilters())
			Catch::cout() << "Matching test cases:\n";
		else {
			Catch::cout() << "All available test cases:\n";
			testSpec = TestSpecParser(ITagAliasRegistry::get()).parse("*").testSpec();
		}

		std::size_t matchedTests = 0;
		TextAttributes nameAttr, tagsAttr;
		nameAttr.setInitialIndent(2).setIndent(4);
		tagsAttr.setIndent(6);

		std::vector<TestCase> matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);
		for (std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
			it != itEnd;
			++it) {
			matchedTests++;
			TestCaseInfo const& testCaseInfo = it->getTestCaseInfo();
			Colour::Code colour = testCaseInfo.isHidden()
				? Colour::SecondaryText
				: Colour::None;
			Colour colourGuard(colour);

			Catch::cout() << Text(testCaseInfo.name, nameAttr) << std::endl;
			if (!testCaseInfo.tags.empty())
				Catch::cout() << Text(testCaseInfo.tagsAsString, tagsAttr) << std::endl;
		}

		if (!config.testSpec().hasFilters())
			Catch::cout() << pluralise(matchedTests, "test case") << "\n" << std::endl;
		else
			Catch::cout() << pluralise(matchedTests, "matching test case") << "\n" << std::endl;
		return matchedTests;
	}

	inline std::size_t listTestsNamesOnly(Config const& config) {
		TestSpec testSpec = config.testSpec();
		if (!config.testSpec().hasFilters())
			testSpec = TestSpecParser(ITagAliasRegistry::get()).parse("*").testSpec();
		std::size_t matchedTests = 0;
		std::vector<TestCase> matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);
		for (std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
			it != itEnd;
			++it) {
			matchedTests++;
			TestCaseInfo const& testCaseInfo = it->getTestCaseInfo();
			Catch::cout() << testCaseInfo.name << std::endl;
		}
		return matchedTests;
	}

	struct TagInfo {
		TagInfo() : count(0) {}
		void add(std::string const& spelling) {
			++count;
			spellings.insert(spelling);
		}
		std::string all() const {
			std::string out;
			for (std::set<std::string>::const_iterator it = spellings.begin(), itEnd = spellings.end();
				it != itEnd;
				++it)
				out += "[" + *it + "]";
			return out;
		}
		std::set<std::string> spellings;
		std::size_t count;
	};

	inline std::size_t listTags(Config const& config) {
		TestSpec testSpec = config.testSpec();
		if (config.testSpec().hasFilters())
			Catch::cout() << "Tags for matching test cases:\n";
		else {
			Catch::cout() << "All available tags:\n";
			testSpec = TestSpecParser(ITagAliasRegistry::get()).parse("*").testSpec();
		}

		std::map<std::string, TagInfo> tagCounts;

		std::vector<TestCase> matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);
		for (std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
			it != itEnd;
			++it) {
			for (std::set<std::string>::const_iterator  tagIt = it->getTestCaseInfo().tags.begin(),
				tagItEnd = it->getTestCaseInfo().tags.end();
				tagIt != tagItEnd;
				++tagIt) {
				std::string tagName = *tagIt;
				std::string lcaseTagName = toLower(tagName);
				std::map<std::string, TagInfo>::iterator countIt = tagCounts.find(lcaseTagName);
				if (countIt == tagCounts.end())
					countIt = tagCounts.insert(std::make_pair(lcaseTagName, TagInfo())).first;
				countIt->second.add(tagName);
			}
		}

		for (std::map<std::string, TagInfo>::const_iterator countIt = tagCounts.begin(),
			countItEnd = tagCounts.end();
			countIt != countItEnd;
			++countIt) {
			std::ostringstream oss;
			oss << "  " << std::setw(2) << countIt->second.count << "  ";
			Text wrapper(countIt->second.all(), TextAttributes()
				.setInitialIndent(0)
				.setIndent(oss.str().size())
				.setWidth(CATCH_CONFIG_CONSOLE_WIDTH - 10));
			Catch::cout() << oss.str() << wrapper << "\n";
		}
		Catch::cout() << pluralise(tagCounts.size(), "tag") << "\n" << std::endl;
		return tagCounts.size();
	}

	inline std::size_t listReporters(Config const& /*config*/) {
		Catch::cout() << "Available reporters:\n";
		IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();
		IReporterRegistry::FactoryMap::const_iterator itBegin = factories.begin(), itEnd = factories.end(), it;
		std::size_t maxNameLen = 0;
		for (it = itBegin; it != itEnd; ++it)
			maxNameLen = (std::max)(maxNameLen, it->first.size());

		for (it = itBegin; it != itEnd; ++it) {
			Text wrapper(it->second->getDescription(), TextAttributes()
				.setInitialIndent(0)
				.setIndent(7 + maxNameLen)
				.setWidth(CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8));
			Catch::cout() << "  "
				<< it->first
				<< ":"
				<< std::string(maxNameLen - it->first.size() + 2, ' ')
				<< wrapper << "\n";
		}
		Catch::cout() << std::endl;
		return factories.size();
	}

	inline Option<std::size_t> list(Config const& config) {
		Option<std::size_t> listedCount;
		if (config.listTests())
			listedCount = listedCount.valueOr(0) + listTests(config);
		if (config.listTestNamesOnly())
			listedCount = listedCount.valueOr(0) + listTestsNamesOnly(config);
		if (config.listTags())
			listedCount = listedCount.valueOr(0) + listTags(config);
		if (config.listReporters())
			listedCount = listedCount.valueOr(0) + listReporters(config);
		return listedCount;
	}

} // end namespace Catch

  // #included from: internal/catch_run_context.hpp
#define TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED

  // #included from: catch_test_case_tracker.hpp
#define TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED

#include <map>
#include <string>
#include <assert.h>
#include <vector>

namespace Catch {
	namespace TestCaseTracking {

		struct ITracker : SharedImpl<> {
			virtual ~ITracker();

			// static queries
			virtual std::string name() const = 0;

			// dynamic queries
			virtual bool isComplete() const = 0; // Successfully completed or failed
			virtual bool isSuccessfullyCompleted() const = 0;
			virtual bool isOpen() const = 0; // Started but not complete
			virtual bool hasChildren() const = 0;

			virtual ITracker& parent() = 0;

			// actions
			virtual void close() = 0; // Successfully complete
			virtual void fail() = 0;
			virtual void markAsNeedingAnotherRun() = 0;

			virtual void addChild(Ptr<ITracker> const& child) = 0;
			virtual ITracker* findChild(std::string const& name) = 0;
			virtual void openChild() = 0;

			// Debug/ checking
			virtual bool isSectionTracker() const = 0;
			virtual bool isIndexTracker() const = 0;
		};

		class TrackerContext {

			enum RunState {
				NotStarted,
				Executing,
				CompletedCycle
			};

			Ptr<ITracker> m_rootTracker;
			ITracker* m_currentTracker;
			RunState m_runState;

		public:

			static TrackerContext& instance() {
				static TrackerContext s_instance;
				return s_instance;
			}

			TrackerContext()
				: m_currentTracker(CATCH_NULL),
				m_runState(NotStarted)
			{}

			ITracker& startRun();

			void endRun() {
				m_rootTracker.reset();
				m_currentTracker = CATCH_NULL;
				m_runState = NotStarted;
			}

			void startCycle() {
				m_currentTracker = m_rootTracker.get();
				m_runState = Executing;
			}
			void completeCycle() {
				m_runState = CompletedCycle;
			}

			bool completedCycle() const {
				return m_runState == CompletedCycle;
			}
			ITracker& currentTracker() {
				return *m_currentTracker;
			}
			void setCurrentTracker(ITracker* tracker) {
				m_currentTracker = tracker;
			}
		};

		class TrackerBase : public ITracker {
		protected:
			enum CycleState {
				NotStarted,
				Executing,
				ExecutingChildren,
				NeedsAnotherRun,
				CompletedSuccessfully,
				Failed
			};
			class TrackerHasName {
				std::string m_name;
			public:
				TrackerHasName(std::string const& name) : m_name(name) {}
				bool operator ()(Ptr<ITracker> const& tracker) {
					return tracker->name() == m_name;
				}
			};
			typedef std::vector<Ptr<ITracker> > Children;
			std::string m_name;
			TrackerContext& m_ctx;
			ITracker* m_parent;
			Children m_children;
			CycleState m_runState;
		public:
			TrackerBase(std::string const& name, TrackerContext& ctx, ITracker* parent)
				: m_name(name),
				m_ctx(ctx),
				m_parent(parent),
				m_runState(NotStarted)
			{}
			virtual ~TrackerBase();

			virtual std::string name() const CATCH_OVERRIDE {
				return m_name;
			}
			virtual bool isComplete() const CATCH_OVERRIDE {
				return m_runState == CompletedSuccessfully || m_runState == Failed;
			}
			virtual bool isSuccessfullyCompleted() const CATCH_OVERRIDE {
				return m_runState == CompletedSuccessfully;
			}
			virtual bool isOpen() const CATCH_OVERRIDE {
				return m_runState != NotStarted && !isComplete();
			}
			virtual bool hasChildren() const CATCH_OVERRIDE {
				return !m_children.empty();
			}

			virtual void addChild(Ptr<ITracker> const& child) CATCH_OVERRIDE {
				m_children.push_back(child);
			}

			virtual ITracker* findChild(std::string const& name) CATCH_OVERRIDE {
				Children::const_iterator it = std::find_if(m_children.begin(), m_children.end(), TrackerHasName(name));
				return(it != m_children.end())
					? it->get()
					: CATCH_NULL;
			}
			virtual ITracker& parent() CATCH_OVERRIDE {
				assert(m_parent); // Should always be non-null except for root
				return *m_parent;
			}

			virtual void openChild() CATCH_OVERRIDE {
				if (m_runState != ExecutingChildren) {
					m_runState = ExecutingChildren;
					if (m_parent)
						m_parent->openChild();
				}
			}

			virtual bool isSectionTracker() const CATCH_OVERRIDE { return false; }
			virtual bool isIndexTracker() const CATCH_OVERRIDE { return false; }

			void open() {
				m_runState = Executing;
				moveToThis();
				if (m_parent)
					m_parent->openChild();
			}

			virtual void close() CATCH_OVERRIDE {

				// Close any still open children (e.g. generators)
				while (&m_ctx.currentTracker() != this)
					m_ctx.currentTracker().close();

				switch (m_runState) {
				case NotStarted:
				case CompletedSuccessfully:
				case Failed:
					throw std::logic_error("Illogical state");

				case NeedsAnotherRun:
					break;;

				case Executing:
					m_runState = CompletedSuccessfully;
					break;
				case ExecutingChildren:
					if (m_children.empty() || m_children.back()->isComplete())
						m_runState = CompletedSuccessfully;
					break;

				default:
					throw std::logic_error("Unexpected state");
				}
				moveToParent();
				m_ctx.completeCycle();
			}
			virtual void fail() CATCH_OVERRIDE {
				m_runState = Failed;
				if (m_parent)
					m_parent->markAsNeedingAnotherRun();
				moveToParent();
				m_ctx.completeCycle();
			}
			virtual void markAsNeedingAnotherRun() CATCH_OVERRIDE {
				m_runState = NeedsAnotherRun;
			}
		private:
			void moveToParent() {
				assert(m_parent);
				m_ctx.setCurrentTracker(m_parent);
			}
			void moveToThis() {
				m_ctx.setCurrentTracker(this);
			}
		};

		class SectionTracker : public TrackerBase {
		public:
			SectionTracker(std::string const& name, TrackerContext& ctx, ITracker* parent)
				: TrackerBase(name, ctx, parent)
			{}
			virtual ~SectionTracker();

			virtual bool isSectionTracker() const CATCH_OVERRIDE { return true; }

			static SectionTracker& acquire(TrackerContext& ctx, std::string const& name) {
				SectionTracker* section = CATCH_NULL;

				ITracker& currentTracker = ctx.currentTracker();
				if (ITracker* childTracker = currentTracker.findChild(name)) {
					assert(childTracker);
					assert(childTracker->isSectionTracker());
					section = static_cast<SectionTracker*>(childTracker);
				}
				else {
					section = new SectionTracker(name, ctx, &currentTracker);
					currentTracker.addChild(section);
				}
				if (!ctx.completedCycle() && !section->isComplete()) {

					section->open();
				}
				return *section;
			}
		};

		class IndexTracker : public TrackerBase {
			int m_size;
			int m_index;
		public:
			IndexTracker(std::string const& name, TrackerContext& ctx, ITracker* parent, int size)
				: TrackerBase(name, ctx, parent),
				m_size(size),
				m_index(-1)
			{}
			virtual ~IndexTracker();

			virtual bool isIndexTracker() const CATCH_OVERRIDE { return true; }

			static IndexTracker& acquire(TrackerContext& ctx, std::string const& name, int size) {
				IndexTracker* tracker = CATCH_NULL;

				ITracker& currentTracker = ctx.currentTracker();
				if (ITracker* childTracker = currentTracker.findChild(name)) {
					assert(childTracker);
					assert(childTracker->isIndexTracker());
					tracker = static_cast<IndexTracker*>(childTracker);
				}
				else {
					tracker = new IndexTracker(name, ctx, &currentTracker, size);
					currentTracker.addChild(tracker);
				}

				if (!ctx.completedCycle() && !tracker->isComplete()) {
					if (tracker->m_runState != ExecutingChildren && tracker->m_runState != NeedsAnotherRun)
						tracker->moveNext();
					tracker->open();
				}

				return *tracker;
			}

			int index() const { return m_index; }

			void moveNext() {
				m_index++;
				m_children.clear();
			}

			virtual void close() CATCH_OVERRIDE {
				TrackerBase::close();
				if (m_runState == CompletedSuccessfully && m_index < m_size - 1)
					m_runState = Executing;
			}
		};

		inline ITracker& TrackerContext::startRun() {
			m_rootTracker = new SectionTracker("{root}", *this, CATCH_NULL);
			m_currentTracker = CATCH_NULL;
			m_runState = Executing;
			return *m_rootTracker;
		}

	} // namespace TestCaseTracking

	using TestCaseTracking::ITracker;
	using TestCaseTracking::TrackerContext;
	using TestCaseTracking::SectionTracker;
	using TestCaseTracking::IndexTracker;

} // namespace Catch

  // #included from: catch_fatal_condition.hpp
#define TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED

namespace Catch {

	// Report the error condition then exit the process
	inline void fatal(std::string const& message, int exitCode) {
		IContext& context = Catch::getCurrentContext();
		IResultCapture* resultCapture = context.getResultCapture();
		resultCapture->handleFatalErrorCondition(message);

		if (Catch::alwaysTrue()) // avoids "no return" warnings
			exit(exitCode);
	}

} // namespace Catch

#if defined ( CATCH_PLATFORM_WINDOWS ) /////////////////////////////////////////

namespace Catch {

	struct FatalConditionHandler {
		void reset() {}
	};

} // namespace Catch

#else // Not Windows - assumed to be POSIX compatible //////////////////////////

#include <signal.h>

namespace Catch {

	struct SignalDefs { int id; const char* name; };
	extern SignalDefs signalDefs[];
	SignalDefs signalDefs[] = {
		{ SIGINT,  "SIGINT - Terminal interrupt signal" },
		{ SIGILL,  "SIGILL - Illegal instruction signal" },
		{ SIGFPE,  "SIGFPE - Floating point error signal" },
		{ SIGSEGV, "SIGSEGV - Segmentation violation signal" },
		{ SIGTERM, "SIGTERM - Termination request signal" },
		{ SIGABRT, "SIGABRT - Abort (abnormal termination) signal" }
	};

	struct FatalConditionHandler {

		static void handleSignal(int sig) {
			for (std::size_t i = 0; i < sizeof(signalDefs) / sizeof(SignalDefs); ++i)
				if (sig == signalDefs[i].id)
					fatal(signalDefs[i].name, -sig);
			fatal("<unknown signal>", -sig);
		}

		FatalConditionHandler() : m_isSet(true) {
			for (std::size_t i = 0; i < sizeof(signalDefs) / sizeof(SignalDefs); ++i)
				signal(signalDefs[i].id, handleSignal);
		}
		~FatalConditionHandler() {
			reset();
		}
		void reset() {
			if (m_isSet) {
				for (std::size_t i = 0; i < sizeof(signalDefs) / sizeof(SignalDefs); ++i)
					signal(signalDefs[i].id, SIG_DFL);
				m_isSet = false;
			}
		}

		bool m_isSet;
	};

} // namespace Catch

#endif // not Windows

#include <set>
#include <string>

namespace Catch {

	class StreamRedirect {

	public:
		StreamRedirect(std::ostream& stream, std::string& targetString)
			: m_stream(stream),
			m_prevBuf(stream.rdbuf()),
			m_targetString(targetString)
		{
			stream.rdbuf(m_oss.rdbuf());
		}

		~StreamRedirect() {
			m_targetString += m_oss.str();
			m_stream.rdbuf(m_prevBuf);
		}

	private:
		std::ostream& m_stream;
		std::streambuf* m_prevBuf;
		std::ostringstream m_oss;
		std::string& m_targetString;
	};

	///////////////////////////////////////////////////////////////////////////

	class RunContext : public IResultCapture, public IRunner {

		RunContext(RunContext const&);
		void operator =(RunContext const&);

	public:

		explicit RunContext(Ptr<IConfig const> const& _config, Ptr<IStreamingReporter> const& reporter)
			: m_runInfo(_config->name()),
			m_context(getCurrentMutableContext()),
			m_activeTestCase(CATCH_NULL),
			m_config(_config),
			m_reporter(reporter)
		{
			m_context.setRunner(this);
			m_context.setConfig(m_config);
			m_context.setResultCapture(this);
			m_reporter->testRunStarting(m_runInfo);
		}

		virtual ~RunContext() {
			m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
		}

		void testGroupStarting(std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount) {
			m_reporter->testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));
		}
		void testGroupEnded(std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount) {
			m_reporter->testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));
		}

		Totals runTest(TestCase const& testCase) {
			Totals prevTotals = m_totals;

			std::string redirectedCout;
			std::string redirectedCerr;

			TestCaseInfo testInfo = testCase.getTestCaseInfo();

			m_reporter->testCaseStarting(testInfo);

			m_activeTestCase = &testCase;

			do {
				m_trackerContext.startRun();
				do {
					m_trackerContext.startCycle();
					m_testCaseTracker = &SectionTracker::acquire(m_trackerContext, testInfo.name);
					runCurrentTest(redirectedCout, redirectedCerr);
				} while (!m_testCaseTracker->isSuccessfullyCompleted() && !aborting());
			}
			// !TBD: deprecated - this will be replaced by indexed trackers
			while (getCurrentContext().advanceGeneratorsForCurrentTest() && !aborting());

			Totals deltaTotals = m_totals.delta(prevTotals);
			if (testInfo.expectedToFail() && deltaTotals.testCases.passed > 0) {
				deltaTotals.assertions.failed++;
				deltaTotals.testCases.passed--;
				deltaTotals.testCases.failed++;
			}
			m_totals.testCases += deltaTotals.testCases;
			m_reporter->testCaseEnded(TestCaseStats(testInfo,
				deltaTotals,
				redirectedCout,
				redirectedCerr,
				aborting()));

			m_activeTestCase = CATCH_NULL;
			m_testCaseTracker = CATCH_NULL;

			return deltaTotals;
		}

		Ptr<IConfig const> config() const {
			return m_config;
		}

	private: // IResultCapture

		virtual void assertionEnded(AssertionResult const& result) {
			if (result.getResultType() == ResultWas::Ok) {
				m_totals.assertions.passed++;
			}
			else if (!result.isOk()) {
				m_totals.assertions.failed++;
			}

			if (m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals)))
				m_messages.clear();

			// Reset working state
			m_lastAssertionInfo = AssertionInfo("", m_lastAssertionInfo.lineInfo, "{Unknown expression after the reported line}", m_lastAssertionInfo.resultDisposition);
			m_lastResult = result;
		}

		virtual bool sectionStarted(
			SectionInfo const& sectionInfo,
			Counts& assertions
		)
		{
			std::ostringstream oss;
			oss << sectionInfo.name << "@" << sectionInfo.lineInfo;

			ITracker& sectionTracker = SectionTracker::acquire(m_trackerContext, oss.str());
			if (!sectionTracker.isOpen())
				return false;
			m_activeSections.push_back(&sectionTracker);

			m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;

			m_reporter->sectionStarting(sectionInfo);

			assertions = m_totals.assertions;

			return true;
		}
		bool testForMissingAssertions(Counts& assertions) {
			if (assertions.total() != 0)
				return false;
			if (!m_config->warnAboutMissingAssertions())
				return false;
			if (m_trackerContext.currentTracker().hasChildren())
				return false;
			m_totals.assertions.failed++;
			assertions.failed++;
			return true;
		}

		virtual void sectionEnded(SectionEndInfo const& endInfo) {
			Counts assertions = m_totals.assertions - endInfo.prevAssertions;
			bool missingAssertions = testForMissingAssertions(assertions);

			if (!m_activeSections.empty()) {
				m_activeSections.back()->close();
				m_activeSections.pop_back();
			}

			m_reporter->sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));
			m_messages.clear();
		}

		virtual void sectionEndedEarly(SectionEndInfo const& endInfo) {
			if (m_unfinishedSections.empty())
				m_activeSections.back()->fail();
			else
				m_activeSections.back()->close();
			m_activeSections.pop_back();

			m_unfinishedSections.push_back(endInfo);
		}

		virtual void pushScopedMessage(MessageInfo const& message) {
			m_messages.push_back(message);
		}

		virtual void popScopedMessage(MessageInfo const& message) {
			m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());
		}

		virtual std::string getCurrentTestName() const {
			return m_activeTestCase
				? m_activeTestCase->getTestCaseInfo().name
				: "";
		}

		virtual const AssertionResult* getLastResult() const {
			return &m_lastResult;
		}

		virtual void handleFatalErrorCondition(std::string const& message) {
			ResultBuilder resultBuilder = makeUnexpectedResultBuilder();
			resultBuilder.setResultType(ResultWas::FatalErrorCondition);
			resultBuilder << message;
			resultBuilder.captureExpression();

			handleUnfinishedSections();

			// Recreate section for test case (as we will lose the one that was in scope)
			TestCaseInfo const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
			SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description);

			Counts assertions;
			assertions.failed = 1;
			SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);
			m_reporter->sectionEnded(testCaseSectionStats);

			TestCaseInfo testInfo = m_activeTestCase->getTestCaseInfo();

			Totals deltaTotals;
			deltaTotals.testCases.failed = 1;
			m_reporter->testCaseEnded(TestCaseStats(testInfo,
				deltaTotals,
				"",
				"",
				false));
			m_totals.testCases.failed++;
			testGroupEnded("", m_totals, 1, 1);
			m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, false));
		}

	public:
		// !TBD We need to do this another way!
		bool aborting() const {
			return m_totals.assertions.failed == static_cast<std::size_t>(m_config->abortAfter());
		}

	private:

		void runCurrentTest(std::string& redirectedCout, std::string& redirectedCerr) {
			TestCaseInfo const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
			SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description);
			m_reporter->sectionStarting(testCaseSection);
			Counts prevAssertions = m_totals.assertions;
			double duration = 0;
			try {
				m_lastAssertionInfo = AssertionInfo("TEST_CASE", testCaseInfo.lineInfo, "", ResultDisposition::Normal);

				seedRng(*m_config);

				Timer timer;
				timer.start();
				if (m_reporter->getPreferences().shouldRedirectStdOut) {
					StreamRedirect coutRedir(Catch::cout(), redirectedCout);
					StreamRedirect cerrRedir(Catch::cerr(), redirectedCerr);
					invokeActiveTestCase();
				}
				else {
					invokeActiveTestCase();
				}
				duration = timer.getElapsedSeconds();
			}
			catch (TestFailureException&) {
				// This just means the test was aborted due to failure
			}
			catch (...) {
				makeUnexpectedResultBuilder().useActiveException();
			}
			m_testCaseTracker->close();
			handleUnfinishedSections();
			m_messages.clear();

			Counts assertions = m_totals.assertions - prevAssertions;
			bool missingAssertions = testForMissingAssertions(assertions);

			if (testCaseInfo.okToFail()) {
				std::swap(assertions.failedButOk, assertions.failed);
				m_totals.assertions.failed -= assertions.failedButOk;
				m_totals.assertions.failedButOk += assertions.failedButOk;
			}

			SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);
			m_reporter->sectionEnded(testCaseSectionStats);
		}

		void invokeActiveTestCase() {
			FatalConditionHandler fatalConditionHandler; // Handle signals
			m_activeTestCase->invoke();
			fatalConditionHandler.reset();
		}

	private:

		ResultBuilder makeUnexpectedResultBuilder() const {
			return ResultBuilder(m_lastAssertionInfo.macroName.c_str(),
				m_lastAssertionInfo.lineInfo,
				m_lastAssertionInfo.capturedExpression.c_str(),
				m_lastAssertionInfo.resultDisposition);
		}

		void handleUnfinishedSections() {
			// If sections ended prematurely due to an exception we stored their
			// infos here so we can tear them down outside the unwind process.
			for (std::vector<SectionEndInfo>::const_reverse_iterator it = m_unfinishedSections.rbegin(),
				itEnd = m_unfinishedSections.rend();
				it != itEnd;
				++it)
				sectionEnded(*it);
			m_unfinishedSections.clear();
		}

		TestRunInfo m_runInfo;
		IMutableContext& m_context;
		TestCase const* m_activeTestCase;
		ITracker* m_testCaseTracker;
		ITracker* m_currentSectionTracker;
		AssertionResult m_lastResult;

		Ptr<IConfig const> m_config;
		Totals m_totals;
		Ptr<IStreamingReporter> m_reporter;
		std::vector<MessageInfo> m_messages;
		AssertionInfo m_lastAssertionInfo;
		std::vector<SectionEndInfo> m_unfinishedSections;
		std::vector<ITracker*> m_activeSections;
		TrackerContext m_trackerContext;
	};

	IResultCapture& getResultCapture() {
		if (IResultCapture* capture = getCurrentContext().getResultCapture())
			return *capture;
		else
			throw std::logic_error("No result capture instance");
	}

} // end namespace Catch

  // #included from: internal/catch_version.h
#define TWOBLUECUBES_CATCH_VERSION_H_INCLUDED

namespace Catch {

	// Versioning information
	struct Version {
		Version(unsigned int _majorVersion,
			unsigned int _minorVersion,
			unsigned int _patchNumber,
			std::string const& _branchName,
			unsigned int _buildNumber);

		unsigned int const majorVersion;
		unsigned int const minorVersion;
		unsigned int const patchNumber;

		// buildNumber is only used if branchName is not null
		std::string const branchName;
		unsigned int const buildNumber;

		friend std::ostream& operator << (std::ostream& os, Version const& version);

	private:
		void operator=(Version const&);
	};

	extern Version libraryVersion;
}

#include <fstream>
#include <stdlib.h>
#include <limits>

namespace Catch {

	Ptr<IStreamingReporter> createReporter(std::string const& reporterName, Ptr<Config> const& config) {
		Ptr<IStreamingReporter> reporter = getRegistryHub().getReporterRegistry().create(reporterName, config.get());
		if (!reporter) {
			std::ostringstream oss;
			oss << "No reporter registered with name: '" << reporterName << "'";
			throw std::domain_error(oss.str());
		}
		return reporter;
	}

	Ptr<IStreamingReporter> makeReporter(Ptr<Config> const& config) {
		std::vector<std::string> reporters = config->getReporterNames();
		if (reporters.empty())
			reporters.push_back("console");

		Ptr<IStreamingReporter> reporter;
		for (std::vector<std::string>::const_iterator it = reporters.begin(), itEnd = reporters.end();
			it != itEnd;
			++it)
			reporter = addReporter(reporter, createReporter(*it, config));
		return reporter;
	}
	Ptr<IStreamingReporter> addListeners(Ptr<IConfig const> const& config, Ptr<IStreamingReporter> reporters) {
		IReporterRegistry::Listeners listeners = getRegistryHub().getReporterRegistry().getListeners();
		for (IReporterRegistry::Listeners::const_iterator it = listeners.begin(), itEnd = listeners.end();
			it != itEnd;
			++it)
			reporters = addReporter(reporters, (*it)->create(ReporterConfig(config)));
		return reporters;
	}

	Totals runTests(Ptr<Config> const& config) {

		Ptr<IConfig const> iconfig = config.get();

		Ptr<IStreamingReporter> reporter = makeReporter(config);
		reporter = addListeners(iconfig, reporter);

		RunContext context(iconfig, reporter);

		Totals totals;

		context.testGroupStarting(config->name(), 1, 1);

		TestSpec testSpec = config->testSpec();
		if (!testSpec.hasFilters())
			testSpec = TestSpecParser(ITagAliasRegistry::get()).parse("~[.]").testSpec(); // All not hidden tests

		std::vector<TestCase> const& allTestCases = getAllTestCasesSorted(*iconfig);
		for (std::vector<TestCase>::const_iterator it = allTestCases.begin(), itEnd = allTestCases.end();
			it != itEnd;
			++it) {
			if (!context.aborting() && matchTest(*it, testSpec, *iconfig))
				totals += context.runTest(*it);
			else
				reporter->skipTest(*it);
		}

		context.testGroupEnded(iconfig->name(), totals, 1, 1);
		return totals;
	}

	void applyFilenamesAsTags(IConfig const& config) {
		std::vector<TestCase> const& tests = getAllTestCasesSorted(config);
		for (std::size_t i = 0; i < tests.size(); ++i) {
			TestCase& test = const_cast<TestCase&>(tests[i]);
			std::set<std::string> tags = test.tags;

			std::string filename = test.lineInfo.file;
			std::string::size_type lastSlash = filename.find_last_of("\\/");
			if (lastSlash != std::string::npos)
				filename = filename.substr(lastSlash + 1);

			std::string::size_type lastDot = filename.find_last_of(".");
			if (lastDot != std::string::npos)
				filename = filename.substr(0, lastDot);

			tags.insert("#" + filename);
			setTags(test, tags);
		}
	}

	class Session : NonCopyable {
		static bool alreadyInstantiated;

	public:

		struct OnUnusedOptions { enum DoWhat { Ignore, Fail }; };

		Session()
			: m_cli(makeCommandLineParser()) {
			if (alreadyInstantiated) {
				std::string msg = "Only one instance of Catch::Session can ever be used";
				Catch::cerr() << msg << std::endl;
				throw std::logic_error(msg);
			}
			alreadyInstantiated = true;
		}
		~Session() {
			Catch::cleanUp();
		}

		void showHelp(std::string const& processName) {
			Catch::cout() << "\nCatch v" << libraryVersion << "\n";

			m_cli.usage(Catch::cout(), processName);
			Catch::cout() << "For more detail usage please see the project docs\n" << std::endl;
		}

		int applyCommandLine(int argc, char const* const* const argv, OnUnusedOptions::DoWhat unusedOptionBehaviour = OnUnusedOptions::Fail) {
			try {
				m_cli.setThrowOnUnrecognisedTokens(unusedOptionBehaviour == OnUnusedOptions::Fail);
				m_unusedTokens = m_cli.parseInto(Clara::argsToVector(argc, argv), m_configData);
				if (m_configData.showHelp)
					showHelp(m_configData.processName);
				m_config.reset();
			}
			catch (std::exception& ex) {
				{
					Colour colourGuard(Colour::Red);
					Catch::cerr()
						<< "\nError(s) in input:\n"
						<< Text(ex.what(), TextAttributes().setIndent(2))
						<< "\n\n";
				}
				m_cli.usage(Catch::cout(), m_configData.processName);
				return (std::numeric_limits<int>::max)();
			}
			return 0;
		}

		void useConfigData(ConfigData const& _configData) {
			m_configData = _configData;
			m_config.reset();
		}

		int run(int argc, char const* const* const argv) {

			int returnCode = applyCommandLine(argc, argv);
			if (returnCode == 0)
				returnCode = run();
			return returnCode;
		}

		int run() {
			if (m_configData.showHelp)
				return 0;

			try
			{
				config(); // Force config to be constructed

				seedRng(*m_config);

				if (m_configData.filenamesAsTags)
					applyFilenamesAsTags(*m_config);

				// Handle list request
				if (Option<std::size_t> listed = list(config()))
					return static_cast<int>(*listed);

				return static_cast<int>(runTests(m_config).assertions.failed);
			}
			catch (std::exception& ex) {
				Catch::cerr() << ex.what() << std::endl;
				return (std::numeric_limits<int>::max)();
			}
		}

		Clara::CommandLine<ConfigData> const& cli() const {
			return m_cli;
		}
		std::vector<Clara::Parser::Token> const& unusedTokens() const {
			return m_unusedTokens;
		}
		ConfigData& configData() {
			return m_configData;
		}
		Config& config() {
			if (!m_config)
				m_config = new Config(m_configData);
			return *m_config;
		}
	private:
		Clara::CommandLine<ConfigData> m_cli;
		std::vector<Clara::Parser::Token> m_unusedTokens;
		ConfigData m_configData;
		Ptr<Config> m_config;
	};

	bool Session::alreadyInstantiated = false;

} // end namespace Catch

  // #included from: catch_registry_hub.hpp
#define TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED

  // #included from: catch_test_case_registry_impl.hpp
#define TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED

#include <vector>
#include <set>
#include <sstream>
#include <iostream>
#include <algorithm>

namespace Catch {

	struct LexSort {
		bool operator() (TestCase i, TestCase j) const { return (i<j); }
	};
	struct RandomNumberGenerator {
		int operator()(int n) const { return std::rand() % n; }
	};

	inline std::vector<TestCase> sortTests(IConfig const& config, std::vector<TestCase> const& unsortedTestCases) {

		std::vector<TestCase> sorted = unsortedTestCases;

		switch (config.runOrder()) {
		case RunTests::InLexicographicalOrder:
			std::sort(sorted.begin(), sorted.end(), LexSort());
			break;
		case RunTests::InRandomOrder:
		{
			seedRng(config);

			RandomNumberGenerator rng;
			std::random_shuffle(sorted.begin(), sorted.end(), rng);
		}
		break;
		case RunTests::InDeclarationOrder:
			// already in declaration order
			break;
		}
		return sorted;
	}
	bool matchTest(TestCase const& testCase, TestSpec const& testSpec, IConfig const& config) {
		return testSpec.matches(testCase) && (config.allowThrows() || !testCase.throws());
	}

	void enforceNoDuplicateTestCases(std::vector<TestCase> const& functions) {
		std::set<TestCase> seenFunctions;
		for (std::vector<TestCase>::const_iterator it = functions.begin(), itEnd = functions.end();
			it != itEnd;
			++it) {
			std::pair<std::set<TestCase>::const_iterator, bool> prev = seenFunctions.insert(*it);
			if (!prev.second) {
				Catch::cerr()
					<< Colour(Colour::Red)
					<< "error: TEST_CASE( \"" << it->name << "\" ) already defined.\n"
					<< "\tFirst seen at " << prev.first->getTestCaseInfo().lineInfo << "\n"
					<< "\tRedefined at " << it->getTestCaseInfo().lineInfo << std::endl;
				exit(1);
			}
		}
	}

	std::vector<TestCase> filterTests(std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config) {
		std::vector<TestCase> filtered;
		filtered.reserve(testCases.size());
		for (std::vector<TestCase>::const_iterator it = testCases.begin(), itEnd = testCases.end();
			it != itEnd;
			++it)
			if (matchTest(*it, testSpec, config))
				filtered.push_back(*it);
		return filtered;
	}
	std::vector<TestCase> const& getAllTestCasesSorted(IConfig const& config) {
		return getRegistryHub().getTestCaseRegistry().getAllTestsSorted(config);
	}

	class TestRegistry : public ITestCaseRegistry {
	public:
		TestRegistry()
			: m_currentSortOrder(RunTests::InDeclarationOrder),
			m_unnamedCount(0)
		{}
		virtual ~TestRegistry();

		virtual void registerTest(TestCase const& testCase) {
			std::string name = testCase.getTestCaseInfo().name;
			if (name == "") {
				std::ostringstream oss;
				oss << "Anonymous test case " << ++m_unnamedCount;
				return registerTest(testCase.withName(oss.str()));
			}
			m_functions.push_back(testCase);
		}

		virtual std::vector<TestCase> const& getAllTests() const {
			return m_functions;
		}
		virtual std::vector<TestCase> const& getAllTestsSorted(IConfig const& config) const {
			if (m_sortedFunctions.empty())
				enforceNoDuplicateTestCases(m_functions);

			if (m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty()) {
				m_sortedFunctions = sortTests(config, m_functions);
				m_currentSortOrder = config.runOrder();
			}
			return m_sortedFunctions;
		}

	private:
		std::vector<TestCase> m_functions;
		mutable RunTests::InWhatOrder m_currentSortOrder;
		mutable std::vector<TestCase> m_sortedFunctions;
		size_t m_unnamedCount;
		std::ios_base::Init m_ostreamInit; // Forces cout/ cerr to be initialised
	};

	///////////////////////////////////////////////////////////////////////////

	class FreeFunctionTestCase : public SharedImpl<ITestCase> {
	public:

		FreeFunctionTestCase(TestFunction fun) : m_fun(fun) {}

		virtual void invoke() const {
			m_fun();
		}

	private:
		virtual ~FreeFunctionTestCase();

		TestFunction m_fun;
	};

	inline std::string extractClassName(std::string const& classOrQualifiedMethodName) {
		std::string className = classOrQualifiedMethodName;
		if (startsWith(className, "&"))
		{
			std::size_t lastColons = className.rfind("::");
			std::size_t penultimateColons = className.rfind("::", lastColons - 1);
			if (penultimateColons == std::string::npos)
				penultimateColons = 1;
			className = className.substr(penultimateColons, lastColons - penultimateColons);
		}
		return className;
	}

	void registerTestCase
	(ITestCase* testCase,
		char const* classOrQualifiedMethodName,
		NameAndDesc const& nameAndDesc,
		SourceLineInfo const& lineInfo) {

		getMutableRegistryHub().registerTest
		(makeTestCase
		(testCase,
			extractClassName(classOrQualifiedMethodName),
			nameAndDesc.name,
			nameAndDesc.description,
			lineInfo));
	}
	void registerTestCaseFunction
	(TestFunction function,
		SourceLineInfo const& lineInfo,
		NameAndDesc const& nameAndDesc) {
		registerTestCase(new FreeFunctionTestCase(function), "", nameAndDesc, lineInfo);
	}

	///////////////////////////////////////////////////////////////////////////

	AutoReg::AutoReg
	(TestFunction function,
		SourceLineInfo const& lineInfo,
		NameAndDesc const& nameAndDesc) {
		registerTestCaseFunction(function, lineInfo, nameAndDesc);
	}

	AutoReg::~AutoReg() {}

} // end namespace Catch

  // #included from: catch_reporter_registry.hpp
#define TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED

#include <map>

namespace Catch {

	class ReporterRegistry : public IReporterRegistry {

	public:

		virtual ~ReporterRegistry() CATCH_OVERRIDE {}

		virtual IStreamingReporter* create(std::string const& name, Ptr<IConfig const> const& config) const CATCH_OVERRIDE {
			FactoryMap::const_iterator it = m_factories.find(name);
			if (it == m_factories.end())
				return CATCH_NULL;
			return it->second->create(ReporterConfig(config));
		}

		void registerReporter(std::string const& name, Ptr<IReporterFactory> const& factory) {
			m_factories.insert(std::make_pair(name, factory));
		}
		void registerListener(Ptr<IReporterFactory> const& factory) {
			m_listeners.push_back(factory);
		}

		virtual FactoryMap const& getFactories() const CATCH_OVERRIDE {
			return m_factories;
		}
		virtual Listeners const& getListeners() const CATCH_OVERRIDE {
			return m_listeners;
		}

	private:
		FactoryMap m_factories;
		Listeners m_listeners;
	};
}

// #included from: catch_exception_translator_registry.hpp
#define TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED

#ifdef __OBJC__
#import "Foundation/Foundation.h"
#endif

namespace Catch {

	class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
	public:
		~ExceptionTranslatorRegistry() {
			deleteAll(m_translators);
		}

		virtual void registerTranslator(const IExceptionTranslator* translator) {
			m_translators.push_back(translator);
		}

		virtual std::string translateActiveException() const {
			try {
#ifdef __OBJC__
				// In Objective-C try objective-c exceptions first
				@try {
					return tryTranslators();
				}
				@catch (NSException *exception) {
					return Catch::toString([exception description]);
				}
#else
				return tryTranslators();
#endif
			}
			catch (TestFailureException&) {
				throw;
			}
			catch (std::exception& ex) {
				return ex.what();
			}
			catch (std::string& msg) {
				return msg;
			}
			catch (const char* msg) {
				return msg;
			}
			catch (...) {
				return "Unknown exception";
			}
		}

		std::string tryTranslators() const {
			if (m_translators.empty())
				throw;
			else
				return m_translators[0]->translate(m_translators.begin() + 1, m_translators.end());
		}

	private:
		std::vector<const IExceptionTranslator*> m_translators;
	};
}

namespace Catch {

	namespace {

		class RegistryHub : public IRegistryHub, public IMutableRegistryHub {

			RegistryHub(RegistryHub const&);
			void operator=(RegistryHub const&);

		public: // IRegistryHub
			RegistryHub() {
			}
			virtual IReporterRegistry const& getReporterRegistry() const CATCH_OVERRIDE {
				return m_reporterRegistry;
			}
			virtual ITestCaseRegistry const& getTestCaseRegistry() const CATCH_OVERRIDE {
				return m_testCaseRegistry;
			}
			virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() CATCH_OVERRIDE {
				return m_exceptionTranslatorRegistry;
			}

		public: // IMutableRegistryHub
			virtual void registerReporter(std::string const& name, Ptr<IReporterFactory> const& factory) CATCH_OVERRIDE {
				m_reporterRegistry.registerReporter(name, factory);
			}
			virtual void registerListener(Ptr<IReporterFactory> const& factory) CATCH_OVERRIDE {
				m_reporterRegistry.registerListener(factory);
			}
			virtual void registerTest(TestCase const& testInfo) CATCH_OVERRIDE {
				m_testCaseRegistry.registerTest(testInfo);
			}
			virtual void registerTranslator(const IExceptionTranslator* translator) CATCH_OVERRIDE {
				m_exceptionTranslatorRegistry.registerTranslator(translator);
			}

		private:
			TestRegistry m_testCaseRegistry;
			ReporterRegistry m_reporterRegistry;
			ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
		};

		// Single, global, instance
		inline RegistryHub*& getTheRegistryHub() {
			static RegistryHub* theRegistryHub = CATCH_NULL;
			if (!theRegistryHub)
				theRegistryHub = new RegistryHub();
			return theRegistryHub;
		}
	}

	IRegistryHub& getRegistryHub() {
		return *getTheRegistryHub();
	}
	IMutableRegistryHub& getMutableRegistryHub() {
		return *getTheRegistryHub();
	}
	void cleanUp() {
		delete getTheRegistryHub();
		getTheRegistryHub() = CATCH_NULL;
		cleanUpContext();
	}
	std::string translateActiveException() {
		return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
	}

} // end namespace Catch

  // #included from: catch_notimplemented_exception.hpp
#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED

#include <ostream>

namespace Catch {

	NotImplementedException::NotImplementedException(SourceLineInfo const& lineInfo)
		: m_lineInfo(lineInfo) {
		std::ostringstream oss;
		oss << lineInfo << ": function ";
		oss << "not implemented";
		m_what = oss.str();
	}

	const char* NotImplementedException::what() const CATCH_NOEXCEPT {
		return m_what.c_str();
	}

} // end namespace Catch

  // #included from: catch_context_impl.hpp
#define TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED

  // #included from: catch_stream.hpp
#define TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED

#include <stdexcept>
#include <cstdio>
#include <iostream>

namespace Catch {

	template<typename WriterF, size_t bufferSize = 256>
	class StreamBufImpl : public StreamBufBase {
		char data[bufferSize];
		WriterF m_writer;

	public:
		StreamBufImpl() {
			setp(data, data + sizeof(data));
		}

		~StreamBufImpl() CATCH_NOEXCEPT {
			sync();
		}

	private:
		int overflow(int c) {
			sync();

			if (c != EOF) {
				if (pbase() == epptr())
					m_writer(std::string(1, static_cast<char>(c)));
				else
					sputc(static_cast<char>(c));
			}
			return 0;
		}

		int sync() {
			if (pbase() != pptr()) {
				m_writer(std::string(pbase(), static_cast<std::string::size_type>(pptr() - pbase())));
				setp(pbase(), epptr());
			}
			return 0;
		}
	};

	///////////////////////////////////////////////////////////////////////////

	FileStream::FileStream(std::string const& filename) {
		m_ofs.open(filename.c_str());
		if (m_ofs.fail()) {
			std::ostringstream oss;
			oss << "Unable to open file: '" << filename << "'";
			throw std::domain_error(oss.str());
		}
	}

	std::ostream& FileStream::stream() const {
		return m_ofs;
	}

	struct OutputDebugWriter {

		void operator()(std::string const&str) {
			writeToDebugConsole(str);
		}
	};

	DebugOutStream::DebugOutStream()
		: m_streamBuf(new StreamBufImpl<OutputDebugWriter>()),
		m_os(m_streamBuf.get())
	{}

	std::ostream& DebugOutStream::stream() const {
		return m_os;
	}

	// Store the streambuf from cout up-front because
	// cout may get redirected when running tests
	CoutStream::CoutStream()
		: m_os(Catch::cout().rdbuf())
	{}

	std::ostream& CoutStream::stream() const {
		return m_os;
	}

#ifndef CATCH_CONFIG_NOSTDOUT // If you #define this you must implement these functions
	std::ostream& cout() {
		return std::cout;
	}
	std::ostream& cerr() {
		return std::cerr;
	}
#endif
}

namespace Catch {

	class Context : public IMutableContext {

		Context() : m_config(CATCH_NULL), m_runner(CATCH_NULL), m_resultCapture(CATCH_NULL) {}
		Context(Context const&);
		void operator=(Context const&);

	public: // IContext
		virtual IResultCapture* getResultCapture() {
			return m_resultCapture;
		}
		virtual IRunner* getRunner() {
			return m_runner;
		}
		virtual size_t getGeneratorIndex(std::string const& fileInfo, size_t totalSize) {
			return getGeneratorsForCurrentTest()
				.getGeneratorInfo(fileInfo, totalSize)
				.getCurrentIndex();
		}
		virtual bool advanceGeneratorsForCurrentTest() {
			IGeneratorsForTest* generators = findGeneratorsForCurrentTest();
			return generators && generators->moveNext();
		}

		virtual Ptr<IConfig const> getConfig() const {
			return m_config;
		}

	public: // IMutableContext
		virtual void setResultCapture(IResultCapture* resultCapture) {
			m_resultCapture = resultCapture;
		}
		virtual void setRunner(IRunner* runner) {
			m_runner = runner;
		}
		virtual void setConfig(Ptr<IConfig const> const& config) {
			m_config = config;
		}

		friend IMutableContext& getCurrentMutableContext();

	private:
		IGeneratorsForTest* findGeneratorsForCurrentTest() {
			std::string testName = getResultCapture()->getCurrentTestName();

			std::map<std::string, IGeneratorsForTest*>::const_iterator it =
				m_generatorsByTestName.find(testName);
			return it != m_generatorsByTestName.end()
				? it->second
				: CATCH_NULL;
		}

		IGeneratorsForTest& getGeneratorsForCurrentTest() {
			IGeneratorsForTest* generators = findGeneratorsForCurrentTest();
			if (!generators) {
				std::string testName = getResultCapture()->getCurrentTestName();
				generators = createGeneratorsForTest();
				m_generatorsByTestName.insert(std::make_pair(testName, generators));
			}
			return *generators;
		}

	private:
		Ptr<IConfig const> m_config;
		IRunner* m_runner;
		IResultCapture* m_resultCapture;
		std::map<std::string, IGeneratorsForTest*> m_generatorsByTestName;
	};

	namespace {
		Context* currentContext = CATCH_NULL;
	}
	IMutableContext& getCurrentMutableContext() {
		if (!currentContext)
			currentContext = new Context();
		return *currentContext;
	}
	IContext& getCurrentContext() {
		return getCurrentMutableContext();
	}

	void cleanUpContext() {
		delete currentContext;
		currentContext = CATCH_NULL;
	}
}

// #included from: catch_console_colour_impl.hpp
#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED

namespace Catch {
	namespace {

		struct IColourImpl {
			virtual ~IColourImpl() {}
			virtual void use(Colour::Code _colourCode) = 0;
		};

		struct NoColourImpl : IColourImpl {
			void use(Colour::Code) {}

			static IColourImpl* instance() {
				static NoColourImpl s_instance;
				return &s_instance;
			}
		};

	} // anon namespace
} // namespace Catch

#if !defined( CATCH_CONFIG_COLOUR_NONE ) && !defined( CATCH_CONFIG_COLOUR_WINDOWS ) && !defined( CATCH_CONFIG_COLOUR_ANSI )
#   ifdef CATCH_PLATFORM_WINDOWS
#       define CATCH_CONFIG_COLOUR_WINDOWS
#   else
#       define CATCH_CONFIG_COLOUR_ANSI
#   endif
#endif

#if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) /////////////////////////////////////////

#ifndef NOMINMAX
#define NOMINMAX
#endif

#ifdef __AFXDLL
#include <AfxWin.h>
#else
#include <windows.h>
#endif

namespace Catch {
	namespace {

		class Win32ColourImpl : public IColourImpl {
		public:
			Win32ColourImpl() : stdoutHandle(GetStdHandle(STD_OUTPUT_HANDLE))
			{
				CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
				GetConsoleScreenBufferInfo(stdoutHandle, &csbiInfo);
				originalForegroundAttributes = csbiInfo.wAttributes & ~(BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY);
				originalBackgroundAttributes = csbiInfo.wAttributes & ~(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY);
			}

			virtual void use(Colour::Code _colourCode) {
				switch (_colourCode) {
				case Colour::None:      return setTextAttribute(originalForegroundAttributes);
				case Colour::White:     return setTextAttribute(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE);
				case Colour::Red:       return setTextAttribute(FOREGROUND_RED);
				case Colour::Green:     return setTextAttribute(FOREGROUND_GREEN);
				case Colour::Blue:      return setTextAttribute(FOREGROUND_BLUE);
				case Colour::Cyan:      return setTextAttribute(FOREGROUND_BLUE | FOREGROUND_GREEN);
				case Colour::Yellow:    return setTextAttribute(FOREGROUND_RED | FOREGROUND_GREEN);
				case Colour::Grey:      return setTextAttribute(0);

				case Colour::LightGrey:     return setTextAttribute(FOREGROUND_INTENSITY);
				case Colour::BrightRed:     return setTextAttribute(FOREGROUND_INTENSITY | FOREGROUND_RED);
				case Colour::BrightGreen:   return setTextAttribute(FOREGROUND_INTENSITY | FOREGROUND_GREEN);
				case Colour::BrightWhite:   return setTextAttribute(FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE);

				case Colour::Bright: throw std::logic_error("not a colour");
				}
			}

		private:
			void setTextAttribute(WORD _textAttribute) {
				SetConsoleTextAttribute(stdoutHandle, _textAttribute | originalBackgroundAttributes);
			}
			HANDLE stdoutHandle;
			WORD originalForegroundAttributes;
			WORD originalBackgroundAttributes;
		};

		IColourImpl* platformColourInstance() {
			static Win32ColourImpl s_instance;

			Ptr<IConfig const> config = getCurrentContext().getConfig();
			UseColour::YesOrNo colourMode = config
				? config->useColour()
				: UseColour::Auto;
			if (colourMode == UseColour::Auto)
				colourMode = !isDebuggerActive()
				? UseColour::Yes
				: UseColour::No;
			return colourMode == UseColour::Yes
				? &s_instance
				: NoColourImpl::instance();
		}

	} // end anon namespace
} // end namespace Catch

#elif defined( CATCH_CONFIG_COLOUR_ANSI ) //////////////////////////////////////

#include <unistd.h>

namespace Catch {
	namespace {

		// use POSIX/ ANSI console terminal codes
		// Thanks to Adam Strzelecki for original contribution
		// (http://github.com/nanoant)
		// https://github.com/philsquared/Catch/pull/131
		class PosixColourImpl : public IColourImpl {
		public:
			virtual void use(Colour::Code _colourCode) {
				switch (_colourCode) {
				case Colour::None:
				case Colour::White:     return setColour("[0m");
				case Colour::Red:       return setColour("[0;31m");
				case Colour::Green:     return setColour("[0;32m");
				case Colour::Blue:      return setColour("[0:34m");
				case Colour::Cyan:      return setColour("[0;36m");
				case Colour::Yellow:    return setColour("[0;33m");
				case Colour::Grey:      return setColour("[1;30m");

				case Colour::LightGrey:     return setColour("[0;37m");
				case Colour::BrightRed:     return setColour("[1;31m");
				case Colour::BrightGreen:   return setColour("[1;32m");
				case Colour::BrightWhite:   return setColour("[1;37m");

				case Colour::Bright: throw std::logic_error("not a colour");
				}
			}
			static IColourImpl* instance() {
				static PosixColourImpl s_instance;
				return &s_instance;
			}

		private:
			void setColour(const char* _escapeCode) {
				Catch::cout() << '\033' << _escapeCode;
			}
		};

		IColourImpl* platformColourInstance() {
			Ptr<IConfig const> config = getCurrentContext().getConfig();
			UseColour::YesOrNo colourMode = config
				? config->useColour()
				: UseColour::Auto;
			if (colourMode == UseColour::Auto)
				colourMode = (!isDebuggerActive() && isatty(STDOUT_FILENO))
				? UseColour::Yes
				: UseColour::No;
			return colourMode == UseColour::Yes
				? PosixColourImpl::instance()
				: NoColourImpl::instance();
		}

	} // end anon namespace
} // end namespace Catch

#else  // not Windows or ANSI ///////////////////////////////////////////////

namespace Catch {

	static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }

} // end namespace Catch

#endif // Windows/ ANSI/ None

namespace Catch {

	Colour::Colour(Code _colourCode) : m_moved(false) { use(_colourCode); }
	Colour::Colour(Colour const& _other) : m_moved(false) { const_cast<Colour&>(_other).m_moved = true; }
	Colour::~Colour() { if (!m_moved) use(None); }

	void Colour::use(Code _colourCode) {
		static IColourImpl* impl = platformColourInstance();
		impl->use(_colourCode);
	}

} // end namespace Catch

  // #included from: catch_generators_impl.hpp
#define TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED

#include <vector>
#include <string>
#include <map>

namespace Catch {

	struct GeneratorInfo : IGeneratorInfo {

		GeneratorInfo(std::size_t size)
			: m_size(size),
			m_currentIndex(0)
		{}

		bool moveNext() {
			if (++m_currentIndex == m_size) {
				m_currentIndex = 0;
				return false;
			}
			return true;
		}

		std::size_t getCurrentIndex() const {
			return m_currentIndex;
		}

		std::size_t m_size;
		std::size_t m_currentIndex;
	};

	///////////////////////////////////////////////////////////////////////////

	class GeneratorsForTest : public IGeneratorsForTest {

	public:
		~GeneratorsForTest() {
			deleteAll(m_generatorsInOrder);
		}

		IGeneratorInfo& getGeneratorInfo(std::string const& fileInfo, std::size_t size) {
			std::map<std::string, IGeneratorInfo*>::const_iterator it = m_generatorsByName.find(fileInfo);
			if (it == m_generatorsByName.end()) {
				IGeneratorInfo* info = new GeneratorInfo(size);
				m_generatorsByName.insert(std::make_pair(fileInfo, info));
				m_generatorsInOrder.push_back(info);
				return *info;
			}
			return *it->second;
		}

		bool moveNext() {
			std::vector<IGeneratorInfo*>::const_iterator it = m_generatorsInOrder.begin();
			std::vector<IGeneratorInfo*>::const_iterator itEnd = m_generatorsInOrder.end();
			for (; it != itEnd; ++it) {
				if ((*it)->moveNext())
					return true;
			}
			return false;
		}

	private:
		std::map<std::string, IGeneratorInfo*> m_generatorsByName;
		std::vector<IGeneratorInfo*> m_generatorsInOrder;
	};

	IGeneratorsForTest* createGeneratorsForTest()
	{
		return new GeneratorsForTest();
	}

} // end namespace Catch

  // #included from: catch_assertionresult.hpp
#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED

namespace Catch {

	AssertionInfo::AssertionInfo(std::string const& _macroName,
		SourceLineInfo const& _lineInfo,
		std::string const& _capturedExpression,
		ResultDisposition::Flags _resultDisposition)
		: macroName(_macroName),
		lineInfo(_lineInfo),
		capturedExpression(_capturedExpression),
		resultDisposition(_resultDisposition)
	{}

	AssertionResult::AssertionResult() {}

	AssertionResult::AssertionResult(AssertionInfo const& info, AssertionResultData const& data)
		: m_info(info),
		m_resultData(data)
	{}

	AssertionResult::~AssertionResult() {}

	// Result was a success
	bool AssertionResult::succeeded() const {
		return Catch::isOk(m_resultData.resultType);
	}

	// Result was a success, or failure is suppressed
	bool AssertionResult::isOk() const {
		return Catch::isOk(m_resultData.resultType) || shouldSuppressFailure(m_info.resultDisposition);
	}

	ResultWas::OfType AssertionResult::getResultType() const {
		return m_resultData.resultType;
	}

	bool AssertionResult::hasExpression() const {
		return !m_info.capturedExpression.empty();
	}

	bool AssertionResult::hasMessage() const {
		return !m_resultData.message.empty();
	}

	std::string AssertionResult::getExpression() const {
		if (isFalseTest(m_info.resultDisposition))
			return "!" + m_info.capturedExpression;
		else
			return m_info.capturedExpression;
	}
	std::string AssertionResult::getExpressionInMacro() const {
		if (m_info.macroName.empty())
			return m_info.capturedExpression;
		else
			return m_info.macroName + "( " + m_info.capturedExpression + " )";
	}

	bool AssertionResult::hasExpandedExpression() const {
		return hasExpression() && getExpandedExpression() != getExpression();
	}

	std::string AssertionResult::getExpandedExpression() const {
		return m_resultData.reconstructedExpression;
	}

	std::string AssertionResult::getMessage() const {
		return m_resultData.message;
	}
	SourceLineInfo AssertionResult::getSourceInfo() const {
		return m_info.lineInfo;
	}

	std::string AssertionResult::getTestMacroName() const {
		return m_info.macroName;
	}

} // end namespace Catch

  // #included from: catch_test_case_info.hpp
#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED

namespace Catch {

	inline TestCaseInfo::SpecialProperties parseSpecialTag(std::string const& tag) {
		if (startsWith(tag, ".") ||
			tag == "hide" ||
			tag == "!hide")
			return TestCaseInfo::IsHidden;
		else if (tag == "!throws")
			return TestCaseInfo::Throws;
		else if (tag == "!shouldfail")
			return TestCaseInfo::ShouldFail;
		else if (tag == "!mayfail")
			return TestCaseInfo::MayFail;
		else
			return TestCaseInfo::None;
	}
	inline bool isReservedTag(std::string const& tag) {
		return parseSpecialTag(tag) == TestCaseInfo::None && tag.size() > 0 && !isalnum(tag[0]);
	}
	inline void enforceNotReservedTag(std::string const& tag, SourceLineInfo const& _lineInfo) {
		if (isReservedTag(tag)) {
			{
				Colour colourGuard(Colour::Red);
				Catch::cerr()
					<< "Tag name [" << tag << "] not allowed.\n"
					<< "Tag names starting with non alpha-numeric characters are reserved\n";
			}
			{
				Colour colourGuard(Colour::FileName);
				Catch::cerr() << _lineInfo << std::endl;
			}
			exit(1);
		}
	}

	TestCase makeTestCase(ITestCase* _testCase,
		std::string const& _className,
		std::string const& _name,
		std::string const& _descOrTags,
		SourceLineInfo const& _lineInfo)
	{
		bool isHidden(startsWith(_name, "./")); // Legacy support

												// Parse out tags
		std::set<std::string> tags;
		std::string desc, tag;
		bool inTag = false;
		for (std::size_t i = 0; i < _descOrTags.size(); ++i) {
			char c = _descOrTags[i];
			if (!inTag) {
				if (c == '[')
					inTag = true;
				else
					desc += c;
			}
			else {
				if (c == ']') {
					TestCaseInfo::SpecialProperties prop = parseSpecialTag(tag);
					if (prop == TestCaseInfo::IsHidden)
						isHidden = true;
					else if (prop == TestCaseInfo::None)
						enforceNotReservedTag(tag, _lineInfo);

					tags.insert(tag);
					tag.clear();
					inTag = false;
				}
				else
					tag += c;
			}
		}
		if (isHidden) {
			tags.insert("hide");
			tags.insert(".");
		}

		TestCaseInfo info(_name, _className, desc, tags, _lineInfo);
		return TestCase(_testCase, info);
	}

	void setTags(TestCaseInfo& testCaseInfo, std::set<std::string> const& tags)
	{
		testCaseInfo.tags = tags;
		testCaseInfo.lcaseTags.clear();

		std::ostringstream oss;
		for (std::set<std::string>::const_iterator it = tags.begin(), itEnd = tags.end(); it != itEnd; ++it) {
			oss << "[" << *it << "]";
			std::string lcaseTag = toLower(*it);
			testCaseInfo.properties = static_cast<TestCaseInfo::SpecialProperties>(testCaseInfo.properties | parseSpecialTag(lcaseTag));
			testCaseInfo.lcaseTags.insert(lcaseTag);
		}
		testCaseInfo.tagsAsString = oss.str();
	}

	TestCaseInfo::TestCaseInfo(std::string const& _name,
		std::string const& _className,
		std::string const& _description,
		std::set<std::string> const& _tags,
		SourceLineInfo const& _lineInfo)
		: name(_name),
		className(_className),
		description(_description),
		lineInfo(_lineInfo),
		properties(None)
	{
		setTags(*this, _tags);
	}

	TestCaseInfo::TestCaseInfo(TestCaseInfo const& other)
		: name(other.name),
		className(other.className),
		description(other.description),
		tags(other.tags),
		lcaseTags(other.lcaseTags),
		tagsAsString(other.tagsAsString),
		lineInfo(other.lineInfo),
		properties(other.properties)
	{}

	bool TestCaseInfo::isHidden() const {
		return (properties & IsHidden) != 0;
	}
	bool TestCaseInfo::throws() const {
		return (properties & Throws) != 0;
	}
	bool TestCaseInfo::okToFail() const {
		return (properties & (ShouldFail | MayFail)) != 0;
	}
	bool TestCaseInfo::expectedToFail() const {
		return (properties & (ShouldFail)) != 0;
	}

	TestCase::TestCase(ITestCase* testCase, TestCaseInfo const& info) : TestCaseInfo(info), test(testCase) {}

	TestCase::TestCase(TestCase const& other)
		: TestCaseInfo(other),
		test(other.test)
	{}

	TestCase TestCase::withName(std::string const& _newName) const {
		TestCase other(*this);
		other.name = _newName;
		return other;
	}

	void TestCase::swap(TestCase& other) {
		test.swap(other.test);
		name.swap(other.name);
		className.swap(other.className);
		description.swap(other.description);
		tags.swap(other.tags);
		lcaseTags.swap(other.lcaseTags);
		tagsAsString.swap(other.tagsAsString);
		std::swap(TestCaseInfo::properties, static_cast<TestCaseInfo&>(other).properties);
		std::swap(lineInfo, other.lineInfo);
	}

	void TestCase::invoke() const {
		test->invoke();
	}

	bool TestCase::operator == (TestCase const& other) const {
		return  test.get() == other.test.get() &&
			name == other.name &&
			className == other.className;
	}

	bool TestCase::operator < (TestCase const& other) const {
		return name < other.name;
	}
	TestCase& TestCase::operator = (TestCase const& other) {
		TestCase temp(other);
		swap(temp);
		return *this;
	}

	TestCaseInfo const& TestCase::getTestCaseInfo() const
	{
		return *this;
	}

} // end namespace Catch

  // #included from: catch_version.hpp
#define TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED

namespace Catch {

	Version::Version
	(unsigned int _majorVersion,
		unsigned int _minorVersion,
		unsigned int _patchNumber,
		std::string const& _branchName,
		unsigned int _buildNumber)
		: majorVersion(_majorVersion),
		minorVersion(_minorVersion),
		patchNumber(_patchNumber),
		branchName(_branchName),
		buildNumber(_buildNumber)
	{}

	std::ostream& operator << (std::ostream& os, Version const& version) {
		os << version.majorVersion << "."
			<< version.minorVersion << "."
			<< version.patchNumber;

		if (!version.branchName.empty()) {
			os << "-" << version.branchName
				<< "." << version.buildNumber;
		}
		return os;
	}

	Version libraryVersion(1, 5, 2, "", 0);

}

// #included from: catch_message.hpp
#define TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED

namespace Catch {

	MessageInfo::MessageInfo(std::string const& _macroName,
		SourceLineInfo const& _lineInfo,
		ResultWas::OfType _type)
		: macroName(_macroName),
		lineInfo(_lineInfo),
		type(_type),
		sequence(++globalCount)
	{}

	// This may need protecting if threading support is added
	unsigned int MessageInfo::globalCount = 0;

	////////////////////////////////////////////////////////////////////////////

	ScopedMessage::ScopedMessage(MessageBuilder const& builder)
		: m_info(builder.m_info)
	{
		m_info.message = builder.m_stream.str();
		getResultCapture().pushScopedMessage(m_info);
	}
	ScopedMessage::ScopedMessage(ScopedMessage const& other)
		: m_info(other.m_info)
	{}

	ScopedMessage::~ScopedMessage() {
		getResultCapture().popScopedMessage(m_info);
	}

} // end namespace Catch

  // #included from: catch_legacy_reporter_adapter.hpp
#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED

  // #included from: catch_legacy_reporter_adapter.h
#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED

namespace Catch
{
	// Deprecated
	struct IReporter : IShared {
		virtual ~IReporter();

		virtual bool shouldRedirectStdout() const = 0;

		virtual void StartTesting() = 0;
		virtual void EndTesting(Totals const& totals) = 0;
		virtual void StartGroup(std::string const& groupName) = 0;
		virtual void EndGroup(std::string const& groupName, Totals const& totals) = 0;
		virtual void StartTestCase(TestCaseInfo const& testInfo) = 0;
		virtual void EndTestCase(TestCaseInfo const& testInfo, Totals const& totals, std::string const& stdOut, std::string const& stdErr) = 0;
		virtual void StartSection(std::string const& sectionName, std::string const& description) = 0;
		virtual void EndSection(std::string const& sectionName, Counts const& assertions) = 0;
		virtual void NoAssertionsInSection(std::string const& sectionName) = 0;
		virtual void NoAssertionsInTestCase(std::string const& testName) = 0;
		virtual void Aborted() = 0;
		virtual void Result(AssertionResult const& result) = 0;
	};

	class LegacyReporterAdapter : public SharedImpl<IStreamingReporter>
	{
	public:
		LegacyReporterAdapter(Ptr<IReporter> const& legacyReporter);
		virtual ~LegacyReporterAdapter();

		virtual ReporterPreferences getPreferences() const;
		virtual void noMatchingTestCases(std::string const&);
		virtual void testRunStarting(TestRunInfo const&);
		virtual void testGroupStarting(GroupInfo const& groupInfo);
		virtual void testCaseStarting(TestCaseInfo const& testInfo);
		virtual void sectionStarting(SectionInfo const& sectionInfo);
		virtual void assertionStarting(AssertionInfo const&);
		virtual bool assertionEnded(AssertionStats const& assertionStats);
		virtual void sectionEnded(SectionStats const& sectionStats);
		virtual void testCaseEnded(TestCaseStats const& testCaseStats);
		virtual void testGroupEnded(TestGroupStats const& testGroupStats);
		virtual void testRunEnded(TestRunStats const& testRunStats);
		virtual void skipTest(TestCaseInfo const&);

	private:
		Ptr<IReporter> m_legacyReporter;
	};
}

namespace Catch
{
	LegacyReporterAdapter::LegacyReporterAdapter(Ptr<IReporter> const& legacyReporter)
		: m_legacyReporter(legacyReporter)
	{}
	LegacyReporterAdapter::~LegacyReporterAdapter() {}

	ReporterPreferences LegacyReporterAdapter::getPreferences() const {
		ReporterPreferences prefs;
		prefs.shouldRedirectStdOut = m_legacyReporter->shouldRedirectStdout();
		return prefs;
	}

	void LegacyReporterAdapter::noMatchingTestCases(std::string const&) {}
	void LegacyReporterAdapter::testRunStarting(TestRunInfo const&) {
		m_legacyReporter->StartTesting();
	}
	void LegacyReporterAdapter::testGroupStarting(GroupInfo const& groupInfo) {
		m_legacyReporter->StartGroup(groupInfo.name);
	}
	void LegacyReporterAdapter::testCaseStarting(TestCaseInfo const& testInfo) {
		m_legacyReporter->StartTestCase(testInfo);
	}
	void LegacyReporterAdapter::sectionStarting(SectionInfo const& sectionInfo) {
		m_legacyReporter->StartSection(sectionInfo.name, sectionInfo.description);
	}
	void LegacyReporterAdapter::assertionStarting(AssertionInfo const&) {
		// Not on legacy interface
	}

	bool LegacyReporterAdapter::assertionEnded(AssertionStats const& assertionStats) {
		if (assertionStats.assertionResult.getResultType() != ResultWas::Ok) {
			for (std::vector<MessageInfo>::const_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();
				it != itEnd;
				++it) {
				if (it->type == ResultWas::Info) {
					ResultBuilder rb(it->macroName.c_str(), it->lineInfo, "", ResultDisposition::Normal);
					rb << it->message;
					rb.setResultType(ResultWas::Info);
					AssertionResult result = rb.build();
					m_legacyReporter->Result(result);
				}
			}
		}
		m_legacyReporter->Result(assertionStats.assertionResult);
		return true;
	}
	void LegacyReporterAdapter::sectionEnded(SectionStats const& sectionStats) {
		if (sectionStats.missingAssertions)
			m_legacyReporter->NoAssertionsInSection(sectionStats.sectionInfo.name);
		m_legacyReporter->EndSection(sectionStats.sectionInfo.name, sectionStats.assertions);
	}
	void LegacyReporterAdapter::testCaseEnded(TestCaseStats const& testCaseStats) {
		m_legacyReporter->EndTestCase
		(testCaseStats.testInfo,
			testCaseStats.totals,
			testCaseStats.stdOut,
			testCaseStats.stdErr);
	}
	void LegacyReporterAdapter::testGroupEnded(TestGroupStats const& testGroupStats) {
		if (testGroupStats.aborting)
			m_legacyReporter->Aborted();
		m_legacyReporter->EndGroup(testGroupStats.groupInfo.name, testGroupStats.totals);
	}
	void LegacyReporterAdapter::testRunEnded(TestRunStats const& testRunStats) {
		m_legacyReporter->EndTesting(testRunStats.totals);
	}
	void LegacyReporterAdapter::skipTest(TestCaseInfo const&) {
	}
}

// #included from: catch_timer.hpp

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wc++11-long-long"
#endif

#ifdef CATCH_PLATFORM_WINDOWS
#include <windows.h>
#else
#include <sys/time.h>
#endif

namespace Catch {

	namespace {
#ifdef CATCH_PLATFORM_WINDOWS
		uint64_t getCurrentTicks() {
			static uint64_t hz = 0, hzo = 0;
			if (!hz) {
				QueryPerformanceFrequency(reinterpret_cast<LARGE_INTEGER*>(&hz));
				QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&hzo));
			}
			uint64_t t;
			QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&t));
			return ((t - hzo) * 1000000) / hz;
		}
#else
		uint64_t getCurrentTicks() {
			timeval t;
			gettimeofday(&t, CATCH_NULL);
			return static_cast<uint64_t>(t.tv_sec) * 1000000ull + static_cast<uint64_t>(t.tv_usec);
		}
#endif
	}

	void Timer::start() {
		m_ticks = getCurrentTicks();
	}
	unsigned int Timer::getElapsedMicroseconds() const {
		return static_cast<unsigned int>(getCurrentTicks() - m_ticks);
	}
	unsigned int Timer::getElapsedMilliseconds() const {
		return static_cast<unsigned int>(getElapsedMicroseconds() / 1000);
	}
	double Timer::getElapsedSeconds() const {
		return getElapsedMicroseconds() / 1000000.0;
	}

} // namespace Catch

#ifdef __clang__
#pragma clang diagnostic pop
#endif
  // #included from: catch_common.hpp
#define TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED

namespace Catch {

	bool startsWith(std::string const& s, std::string const& prefix) {
		return s.size() >= prefix.size() && s.substr(0, prefix.size()) == prefix;
	}
	bool endsWith(std::string const& s, std::string const& suffix) {
		return s.size() >= suffix.size() && s.substr(s.size() - suffix.size(), suffix.size()) == suffix;
	}
	bool contains(std::string const& s, std::string const& infix) {
		return s.find(infix) != std::string::npos;
	}
	void toLowerInPlace(std::string& s) {
		std::transform(s.begin(), s.end(), s.begin(), ::tolower);
	}
	std::string toLower(std::string const& s) {
		std::string lc = s;
		toLowerInPlace(lc);
		return lc;
	}
	std::string trim(std::string const& str) {
		static char const* whitespaceChars = "\n\r\t ";
		std::string::size_type start = str.find_first_not_of(whitespaceChars);
		std::string::size_type end = str.find_last_not_of(whitespaceChars);

		return start != std::string::npos ? str.substr(start, 1 + end - start) : "";
	}

	bool replaceInPlace(std::string& str, std::string const& replaceThis, std::string const& withThis) {
		bool replaced = false;
		std::size_t i = str.find(replaceThis);
		while (i != std::string::npos) {
			replaced = true;
			str = str.substr(0, i) + withThis + str.substr(i + replaceThis.size());
			if (i < str.size() - withThis.size())
				i = str.find(replaceThis, i + withThis.size());
			else
				i = std::string::npos;
		}
		return replaced;
	}

	pluralise::pluralise(std::size_t count, std::string const& label)
		: m_count(count),
		m_label(label)
	{}

	std::ostream& operator << (std::ostream& os, pluralise const& pluraliser) {
		os << pluraliser.m_count << " " << pluraliser.m_label;
		if (pluraliser.m_count != 1)
			os << "s";
		return os;
	}

	SourceLineInfo::SourceLineInfo() : line(0) {}
	SourceLineInfo::SourceLineInfo(char const* _file, std::size_t _line)
		: file(_file),
		line(_line)
	{}
	SourceLineInfo::SourceLineInfo(SourceLineInfo const& other)
		: file(other.file),
		line(other.line)
	{}
	bool SourceLineInfo::empty() const {
		return file.empty();
	}
	bool SourceLineInfo::operator == (SourceLineInfo const& other) const {
		return line == other.line && file == other.file;
	}
	bool SourceLineInfo::operator < (SourceLineInfo const& other) const {
		return line < other.line || (line == other.line  && file < other.file);
	}

	void seedRng(IConfig const& config) {
		if (config.rngSeed() != 0)
			std::srand(config.rngSeed());
	}
	unsigned int rngSeed() {
		return getCurrentContext().getConfig()->rngSeed();
	}

	std::ostream& operator << (std::ostream& os, SourceLineInfo const& info) {
#ifndef __GNUG__
		os << info.file << "(" << info.line << ")";
#else
		os << info.file << ":" << info.line;
#endif
		return os;
	}

	void throwLogicError(std::string const& message, SourceLineInfo const& locationInfo) {
		std::ostringstream oss;
		oss << locationInfo << ": Internal Catch error: '" << message << "'";
		if (alwaysTrue())
			throw std::logic_error(oss.str());
	}
}

// #included from: catch_section.hpp
#define TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED

namespace Catch {

	SectionInfo::SectionInfo
	(SourceLineInfo const& _lineInfo,
		std::string const& _name,
		std::string const& _description)
		: name(_name),
		description(_description),
		lineInfo(_lineInfo)
	{}

	Section::Section(SectionInfo const& info)
		: m_info(info),
		m_sectionIncluded(getResultCapture().sectionStarted(m_info, m_assertions))
	{
		m_timer.start();
	}

	Section::~Section() {
		if (m_sectionIncluded) {
			SectionEndInfo endInfo(m_info, m_assertions, m_timer.getElapsedSeconds());
			if (std::uncaught_exception())
				getResultCapture().sectionEndedEarly(endInfo);
			else
				getResultCapture().sectionEnded(endInfo);
		}
	}

	// This indicates whether the section should be executed or not
	Section::operator bool() const {
		return m_sectionIncluded;
	}

} // end namespace Catch

  // #included from: catch_debugger.hpp
#define TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED

#include <iostream>

#ifdef CATCH_PLATFORM_MAC

#include <assert.h>
#include <stdbool.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/sysctl.h>

namespace Catch {

	// The following function is taken directly from the following technical note:
	// http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html

	// Returns true if the current process is being debugged (either
	// running under the debugger or has a debugger attached post facto).
	bool isDebuggerActive() {

		int                 mib[4];
		struct kinfo_proc   info;
		size_t              size;

		// Initialize the flags so that, if sysctl fails for some bizarre
		// reason, we get a predictable result.

		info.kp_proc.p_flag = 0;

		// Initialize mib, which tells sysctl the info we want, in this case
		// we're looking for information about a specific process ID.

		mib[0] = CTL_KERN;
		mib[1] = KERN_PROC;
		mib[2] = KERN_PROC_PID;
		mib[3] = getpid();

		// Call sysctl.

		size = sizeof(info);
		if (sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, CATCH_NULL, 0) != 0) {
			Catch::cerr() << "\n** Call to sysctl failed - unable to determine if debugger is active **\n" << std::endl;
			return false;
		}

		// We're being debugged if the P_TRACED flag is set.

		return ((info.kp_proc.p_flag & P_TRACED) != 0);
	}
} // namespace Catch

#elif defined(_MSC_VER)
extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
namespace Catch {
	bool isDebuggerActive() {
		return IsDebuggerPresent() != 0;
	}
}
#elif defined(__MINGW32__)
extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
namespace Catch {
	bool isDebuggerActive() {
		return IsDebuggerPresent() != 0;
	}
}
#else
namespace Catch {
	inline bool isDebuggerActive() { return false; }
}
#endif // Platform

#ifdef CATCH_PLATFORM_WINDOWS
extern "C" __declspec(dllimport) void __stdcall OutputDebugStringA(const char*);
namespace Catch {
	void writeToDebugConsole(std::string const& text) {
		::OutputDebugStringA(text.c_str());
	}
}
#else
namespace Catch {
	void writeToDebugConsole(std::string const& text) {
		// !TBD: Need a version for Mac/ XCode and other IDEs
		Catch::cout() << text;
	}
}
#endif // Platform

// #included from: catch_tostring.hpp
#define TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED

namespace Catch {

	namespace Detail {

		const std::string unprintableString = "{?}";

		namespace {
			const int hexThreshold = 255;

			struct Endianness {
				enum Arch { Big, Little };

				static Arch which() {
					union _ {
						int asInt;
						char asChar[sizeof(int)];
					} u;

					u.asInt = 1;
					return (u.asChar[sizeof(int) - 1] == 1) ? Big : Little;
				}
			};
		}

		std::string rawMemoryToString(const void *object, std::size_t size)
		{
			// Reverse order for little endian architectures
			int i = 0, end = static_cast<int>(size), inc = 1;
			if (Endianness::which() == Endianness::Little) {
				i = end - 1;
				end = inc = -1;
			}

			unsigned char const *bytes = static_cast<unsigned char const *>(object);
			std::ostringstream os;
			os << "0x" << std::setfill('0') << std::hex;
			for (; i != end; i += inc)
				os << std::setw(2) << static_cast<unsigned>(bytes[i]);
			return os.str();
		}
	}

	std::string toString(std::string const& value) {
		std::string s = value;
		if (getCurrentContext().getConfig()->showInvisibles()) {
			for (size_t i = 0; i < s.size(); ++i) {
				std::string subs;
				switch (s[i]) {
				case '\n': subs = "\\n"; break;
				case '\t': subs = "\\t"; break;
				default: break;
				}
				if (!subs.empty()) {
					s = s.substr(0, i) + subs + s.substr(i + 1);
					++i;
				}
			}
		}
		return "\"" + s + "\"";
	}
	std::string toString(std::wstring const& value) {

		std::string s;
		s.reserve(value.size());
		for (size_t i = 0; i < value.size(); ++i)
			s += value[i] <= 0xff ? static_cast<char>(value[i]) : '?';
		return Catch::toString(s);
	}

	std::string toString(const char* const value) {
		return value ? Catch::toString(std::string(value)) : std::string("{null string}");
	}

	std::string toString(char* const value) {
		return Catch::toString(static_cast<const char*>(value));
	}

	std::string toString(const wchar_t* const value)
	{
		return value ? Catch::toString(std::wstring(value)) : std::string("{null string}");
	}

	std::string toString(wchar_t* const value)
	{
		return Catch::toString(static_cast<const wchar_t*>(value));
	}

	std::string toString(int value) {
		std::ostringstream oss;
		oss << value;
		if (value > Detail::hexThreshold)
			oss << " (0x" << std::hex << value << ")";
		return oss.str();
	}

	std::string toString(unsigned long value) {
		std::ostringstream oss;
		oss << value;
		if (value > Detail::hexThreshold)
			oss << " (0x" << std::hex << value << ")";
		return oss.str();
	}

	std::string toString(unsigned int value) {
		return Catch::toString(static_cast<unsigned long>(value));
	}

	template<typename T>
	std::string fpToString(T value, int precision) {
		std::ostringstream oss;
		oss << std::setprecision(precision)
			<< std::fixed
			<< value;
		std::string d = oss.str();
		std::size_t i = d.find_last_not_of('0');
		if (i != std::string::npos && i != d.size() - 1) {
			if (d[i] == '.')
				i++;
			d = d.substr(0, i + 1);
		}
		return d;
	}

	std::string toString(const double value) {
		return fpToString(value, 10);
	}
	std::string toString(const float value) {
		return fpToString(value, 5) + "f";
	}

	std::string toString(bool value) {
		return value ? "true" : "false";
	}

	std::string toString(char value) {
		return value < ' '
			? toString(static_cast<unsigned int>(value))
			: Detail::makeString(value);
	}

	std::string toString(signed char value) {
		return toString(static_cast<char>(value));
	}

	std::string toString(unsigned char value) {
		return toString(static_cast<char>(value));
	}

#ifdef CATCH_CONFIG_CPP11_LONG_LONG
	std::string toString(long long value) {
		std::ostringstream oss;
		oss << value;
		if (value > Detail::hexThreshold)
			oss << " (0x" << std::hex << value << ")";
		return oss.str();
	}
	std::string toString(unsigned long long value) {
		std::ostringstream oss;
		oss << value;
		if (value > Detail::hexThreshold)
			oss << " (0x" << std::hex << value << ")";
		return oss.str();
	}
#endif

#ifdef CATCH_CONFIG_CPP11_NULLPTR
	std::string toString(std::nullptr_t) {
		return "nullptr";
	}
#endif

#ifdef __OBJC__
	std::string toString(NSString const * const& nsstring) {
		if (!nsstring)
			return "nil";
		return "@" + toString([nsstring UTF8String]);
	}
	std::string toString(NSString * CATCH_ARC_STRONG const& nsstring) {
		if (!nsstring)
			return "nil";
		return "@" + toString([nsstring UTF8String]);
	}
	std::string toString(NSObject* const& nsObject) {
		return toString([nsObject description]);
	}
#endif

} // end namespace Catch

  // #included from: catch_result_builder.hpp
#define TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED

namespace Catch {

	std::string capturedExpressionWithSecondArgument(std::string const& capturedExpression, std::string const& secondArg) {
		return secondArg.empty() || secondArg == "\"\""
			? capturedExpression
			: capturedExpression + ", " + secondArg;
	}
	ResultBuilder::ResultBuilder(char const* macroName,
		SourceLineInfo const& lineInfo,
		char const* capturedExpression,
		ResultDisposition::Flags resultDisposition,
		char const* secondArg)
		: m_assertionInfo(macroName, lineInfo, capturedExpressionWithSecondArgument(capturedExpression, secondArg), resultDisposition),
		m_shouldDebugBreak(false),
		m_shouldThrow(false)
	{}

	ResultBuilder& ResultBuilder::setResultType(ResultWas::OfType result) {
		m_data.resultType = result;
		return *this;
	}
	ResultBuilder& ResultBuilder::setResultType(bool result) {
		m_data.resultType = result ? ResultWas::Ok : ResultWas::ExpressionFailed;
		return *this;
	}
	ResultBuilder& ResultBuilder::setLhs(std::string const& lhs) {
		m_exprComponents.lhs = lhs;
		return *this;
	}
	ResultBuilder& ResultBuilder::setRhs(std::string const& rhs) {
		m_exprComponents.rhs = rhs;
		return *this;
	}
	ResultBuilder& ResultBuilder::setOp(std::string const& op) {
		m_exprComponents.op = op;
		return *this;
	}

	void ResultBuilder::endExpression() {
		m_exprComponents.testFalse = isFalseTest(m_assertionInfo.resultDisposition);
		captureExpression();
	}

	void ResultBuilder::useActiveException(ResultDisposition::Flags resultDisposition) {
		m_assertionInfo.resultDisposition = resultDisposition;
		m_stream.oss << Catch::translateActiveException();
		captureResult(ResultWas::ThrewException);
	}

	void ResultBuilder::captureResult(ResultWas::OfType resultType) {
		setResultType(resultType);
		captureExpression();
	}
	void ResultBuilder::captureExpectedException(std::string const& expectedMessage) {
		if (expectedMessage.empty())
			captureExpectedException(Matchers::Impl::Generic::AllOf<std::string>());
		else
			captureExpectedException(Matchers::Equals(expectedMessage));
	}

	void ResultBuilder::captureExpectedException(Matchers::Impl::Matcher<std::string> const& matcher) {

		assert(m_exprComponents.testFalse == false);
		AssertionResultData data = m_data;
		data.resultType = ResultWas::Ok;
		data.reconstructedExpression = m_assertionInfo.capturedExpression;

		std::string actualMessage = Catch::translateActiveException();
		if (!matcher.match(actualMessage)) {
			data.resultType = ResultWas::ExpressionFailed;
			data.reconstructedExpression = actualMessage;
		}
		AssertionResult result(m_assertionInfo, data);
		handleResult(result);
	}

	void ResultBuilder::captureExpression() {
		AssertionResult result = build();
		handleResult(result);
	}
	void ResultBuilder::handleResult(AssertionResult const& result)
	{
		getResultCapture().assertionEnded(result);

		if (!result.isOk()) {
			if (getCurrentContext().getConfig()->shouldDebugBreak())
				m_shouldDebugBreak = true;
			if (getCurrentContext().getRunner()->aborting() || (m_assertionInfo.resultDisposition & ResultDisposition::Normal))
				m_shouldThrow = true;
		}
	}
	void ResultBuilder::react() {
		if (m_shouldThrow)
			throw Catch::TestFailureException();
	}

	bool ResultBuilder::shouldDebugBreak() const { return m_shouldDebugBreak; }
	bool ResultBuilder::allowThrows() const { return getCurrentContext().getConfig()->allowThrows(); }

	AssertionResult ResultBuilder::build() const
	{
		assert(m_data.resultType != ResultWas::Unknown);

		AssertionResultData data = m_data;

		// Flip bool results if testFalse is set
		if (m_exprComponents.testFalse) {
			if (data.resultType == ResultWas::Ok)
				data.resultType = ResultWas::ExpressionFailed;
			else if (data.resultType == ResultWas::ExpressionFailed)
				data.resultType = ResultWas::Ok;
		}

		data.message = m_stream.oss.str();
		data.reconstructedExpression = reconstructExpression();
		if (m_exprComponents.testFalse) {
			if (m_exprComponents.op == "")
				data.reconstructedExpression = "!" + data.reconstructedExpression;
			else
				data.reconstructedExpression = "!(" + data.reconstructedExpression + ")";
		}
		return AssertionResult(m_assertionInfo, data);
	}
	std::string ResultBuilder::reconstructExpression() const {
		if (m_exprComponents.op == "")
			return m_exprComponents.lhs.empty() ? m_assertionInfo.capturedExpression : m_exprComponents.op + m_exprComponents.lhs;
		else if (m_exprComponents.op == "matches")
			return m_exprComponents.lhs + " " + m_exprComponents.rhs;
		else if (m_exprComponents.op != "!") {
			if (m_exprComponents.lhs.size() + m_exprComponents.rhs.size() < 40 &&
				m_exprComponents.lhs.find("\n") == std::string::npos &&
				m_exprComponents.rhs.find("\n") == std::string::npos)
				return m_exprComponents.lhs + " " + m_exprComponents.op + " " + m_exprComponents.rhs;
			else
				return m_exprComponents.lhs + "\n" + m_exprComponents.op + "\n" + m_exprComponents.rhs;
		}
		else
			return "{can't expand - use " + m_assertionInfo.macroName + "_FALSE( " + m_assertionInfo.capturedExpression.substr(1) + " ) instead of " + m_assertionInfo.macroName + "( " + m_assertionInfo.capturedExpression + " ) for better diagnostics}";
	}

} // end namespace Catch

  // #included from: catch_tag_alias_registry.hpp
#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED

  // #included from: catch_tag_alias_registry.h
#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED

#include <map>

namespace Catch {

	class TagAliasRegistry : public ITagAliasRegistry {
	public:
		virtual ~TagAliasRegistry();
		virtual Option<TagAlias> find(std::string const& alias) const;
		virtual std::string expandAliases(std::string const& unexpandedTestSpec) const;
		void add(char const* alias, char const* tag, SourceLineInfo const& lineInfo);
		static TagAliasRegistry& get();

	private:
		std::map<std::string, TagAlias> m_registry;
	};

} // end namespace Catch

#include <map>
#include <iostream>

namespace Catch {

	TagAliasRegistry::~TagAliasRegistry() {}

	Option<TagAlias> TagAliasRegistry::find(std::string const& alias) const {
		std::map<std::string, TagAlias>::const_iterator it = m_registry.find(alias);
		if (it != m_registry.end())
			return it->second;
		else
			return Option<TagAlias>();
	}

	std::string TagAliasRegistry::expandAliases(std::string const& unexpandedTestSpec) const {
		std::string expandedTestSpec = unexpandedTestSpec;
		for (std::map<std::string, TagAlias>::const_iterator it = m_registry.begin(), itEnd = m_registry.end();
			it != itEnd;
			++it) {
			std::size_t pos = expandedTestSpec.find(it->first);
			if (pos != std::string::npos) {
				expandedTestSpec = expandedTestSpec.substr(0, pos) +
					it->second.tag +
					expandedTestSpec.substr(pos + it->first.size());
			}
		}
		return expandedTestSpec;
	}

	void TagAliasRegistry::add(char const* alias, char const* tag, SourceLineInfo const& lineInfo) {

		if (!startsWith(alias, "[@") || !endsWith(alias, "]")) {
			std::ostringstream oss;
			oss << "error: tag alias, \"" << alias << "\" is not of the form [@alias name].\n" << lineInfo;
			throw std::domain_error(oss.str().c_str());
		}
		if (!m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second) {
			std::ostringstream oss;
			oss << "error: tag alias, \"" << alias << "\" already registered.\n"
				<< "\tFirst seen at " << find(alias)->lineInfo << "\n"
				<< "\tRedefined at " << lineInfo;
			throw std::domain_error(oss.str().c_str());
		}
	}

	TagAliasRegistry& TagAliasRegistry::get() {
		static TagAliasRegistry instance;
		return instance;

	}

	ITagAliasRegistry::~ITagAliasRegistry() {}
	ITagAliasRegistry const& ITagAliasRegistry::get() { return TagAliasRegistry::get(); }

	RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const& lineInfo) {
		try {
			TagAliasRegistry::get().add(alias, tag, lineInfo);
		}
		catch (std::exception& ex) {
			Colour colourGuard(Colour::Red);
			Catch::cerr() << ex.what() << std::endl;
			exit(1);
		}
	}

} // end namespace Catch

  // #included from: ../reporters/catch_reporter_multi.hpp
#define TWOBLUECUBES_CATCH_REPORTER_MULTI_HPP_INCLUDED

namespace Catch {

	class MultipleReporters : public SharedImpl<IStreamingReporter> {
		typedef std::vector<Ptr<IStreamingReporter> > Reporters;
		Reporters m_reporters;

	public:
		void add(Ptr<IStreamingReporter> const& reporter) {
			m_reporters.push_back(reporter);
		}

	public: // IStreamingReporter

		virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {
			return m_reporters[0]->getPreferences();
		}

		virtual void noMatchingTestCases(std::string const& spec) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->noMatchingTestCases(spec);
		}

		virtual void testRunStarting(TestRunInfo const& testRunInfo) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->testRunStarting(testRunInfo);
		}

		virtual void testGroupStarting(GroupInfo const& groupInfo) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->testGroupStarting(groupInfo);
		}

		virtual void testCaseStarting(TestCaseInfo const& testInfo) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->testCaseStarting(testInfo);
		}

		virtual void sectionStarting(SectionInfo const& sectionInfo) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->sectionStarting(sectionInfo);
		}

		virtual void assertionStarting(AssertionInfo const& assertionInfo) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->assertionStarting(assertionInfo);
		}

		// The return value indicates if the messages buffer should be cleared:
		virtual bool assertionEnded(AssertionStats const& assertionStats) CATCH_OVERRIDE {
			bool clearBuffer = false;
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				clearBuffer |= (*it)->assertionEnded(assertionStats);
			return clearBuffer;
		}

		virtual void sectionEnded(SectionStats const& sectionStats) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->sectionEnded(sectionStats);
		}

		virtual void testCaseEnded(TestCaseStats const& testCaseStats) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->testCaseEnded(testCaseStats);
		}

		virtual void testGroupEnded(TestGroupStats const& testGroupStats) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->testGroupEnded(testGroupStats);
		}

		virtual void testRunEnded(TestRunStats const& testRunStats) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->testRunEnded(testRunStats);
		}

		virtual void skipTest(TestCaseInfo const& testInfo) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->skipTest(testInfo);
		}

		virtual MultipleReporters* tryAsMulti() CATCH_OVERRIDE {
			return this;
		}

	};

	Ptr<IStreamingReporter> addReporter(Ptr<IStreamingReporter> const& existingReporter, Ptr<IStreamingReporter> const& additionalReporter) {
		Ptr<IStreamingReporter> resultingReporter;

		if (existingReporter) {
			MultipleReporters* multi = existingReporter->tryAsMulti();
			if (!multi) {
				multi = new MultipleReporters;
				resultingReporter = Ptr<IStreamingReporter>(multi);
				if (existingReporter)
					multi->add(existingReporter);
			}
			else
				resultingReporter = existingReporter;
			multi->add(additionalReporter);
		}
		else
			resultingReporter = additionalReporter;

		return resultingReporter;
	}

} // end namespace Catch

  // #included from: ../reporters/catch_reporter_xml.hpp
#define TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED

  // #included from: catch_reporter_bases.hpp
#define TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED

#include <cstring>

namespace Catch {

	struct StreamingReporterBase : SharedImpl<IStreamingReporter> {

		StreamingReporterBase(ReporterConfig const& _config)
			: m_config(_config.fullConfig()),
			stream(_config.stream())
		{
			m_reporterPrefs.shouldRedirectStdOut = false;
		}

		virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {
			return m_reporterPrefs;
		}

		virtual ~StreamingReporterBase() CATCH_OVERRIDE;

		virtual void noMatchingTestCases(std::string const&) CATCH_OVERRIDE {}

		virtual void testRunStarting(TestRunInfo const& _testRunInfo) CATCH_OVERRIDE {
			currentTestRunInfo = _testRunInfo;
		}
		virtual void testGroupStarting(GroupInfo const& _groupInfo) CATCH_OVERRIDE {
			currentGroupInfo = _groupInfo;
		}

		virtual void testCaseStarting(TestCaseInfo const& _testInfo) CATCH_OVERRIDE {
			currentTestCaseInfo = _testInfo;
		}
		virtual void sectionStarting(SectionInfo const& _sectionInfo) CATCH_OVERRIDE {
			m_sectionStack.push_back(_sectionInfo);
		}

		virtual void sectionEnded(SectionStats const& /* _sectionStats */) CATCH_OVERRIDE {
			m_sectionStack.pop_back();
		}
		virtual void testCaseEnded(TestCaseStats const& /* _testCaseStats */) CATCH_OVERRIDE {
			currentTestCaseInfo.reset();
		}
		virtual void testGroupEnded(TestGroupStats const& /* _testGroupStats */) CATCH_OVERRIDE {
			currentGroupInfo.reset();
		}
		virtual void testRunEnded(TestRunStats const& /* _testRunStats */) CATCH_OVERRIDE {
			currentTestCaseInfo.reset();
			currentGroupInfo.reset();
			currentTestRunInfo.reset();
		}

		virtual void skipTest(TestCaseInfo const&) CATCH_OVERRIDE {
			// Don't do anything with this by default.
			// It can optionally be overridden in the derived class.
		}

		Ptr<IConfig const> m_config;
		std::ostream& stream;

		LazyStat<TestRunInfo> currentTestRunInfo;
		LazyStat<GroupInfo> currentGroupInfo;
		LazyStat<TestCaseInfo> currentTestCaseInfo;

		std::vector<SectionInfo> m_sectionStack;
		ReporterPreferences m_reporterPrefs;
	};

	struct CumulativeReporterBase : SharedImpl<IStreamingReporter> {
		template<typename T, typename ChildNodeT>
		struct Node : SharedImpl<> {
			explicit Node(T const& _value) : value(_value) {}
			virtual ~Node() {}

			typedef std::vector<Ptr<ChildNodeT> > ChildNodes;
			T value;
			ChildNodes children;
		};
		struct SectionNode : SharedImpl<> {
			explicit SectionNode(SectionStats const& _stats) : stats(_stats) {}
			virtual ~SectionNode();

			bool operator == (SectionNode const& other) const {
				return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
			}
			bool operator == (Ptr<SectionNode> const& other) const {
				return operator==(*other);
			}

			SectionStats stats;
			typedef std::vector<Ptr<SectionNode> > ChildSections;
			typedef std::vector<AssertionStats> Assertions;
			ChildSections childSections;
			Assertions assertions;
			std::string stdOut;
			std::string stdErr;
		};

		struct BySectionInfo {
			BySectionInfo(SectionInfo const& other) : m_other(other) {}
			BySectionInfo(BySectionInfo const& other) : m_other(other.m_other) {}
			bool operator() (Ptr<SectionNode> const& node) const {
				return node->stats.sectionInfo.lineInfo == m_other.lineInfo;
			}
		private:
			void operator=(BySectionInfo const&);
			SectionInfo const& m_other;
		};

		typedef Node<TestCaseStats, SectionNode> TestCaseNode;
		typedef Node<TestGroupStats, TestCaseNode> TestGroupNode;
		typedef Node<TestRunStats, TestGroupNode> TestRunNode;

		CumulativeReporterBase(ReporterConfig const& _config)
			: m_config(_config.fullConfig()),
			stream(_config.stream())
		{
			m_reporterPrefs.shouldRedirectStdOut = false;
		}
		~CumulativeReporterBase();

		virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {
			return m_reporterPrefs;
		}

		virtual void testRunStarting(TestRunInfo const&) CATCH_OVERRIDE {}
		virtual void testGroupStarting(GroupInfo const&) CATCH_OVERRIDE {}

		virtual void testCaseStarting(TestCaseInfo const&) CATCH_OVERRIDE {}

		virtual void sectionStarting(SectionInfo const& sectionInfo) CATCH_OVERRIDE {
			SectionStats incompleteStats(sectionInfo, Counts(), 0, false);
			Ptr<SectionNode> node;
			if (m_sectionStack.empty()) {
				if (!m_rootSection)
					m_rootSection = new SectionNode(incompleteStats);
				node = m_rootSection;
			}
			else {
				SectionNode& parentNode = *m_sectionStack.back();
				SectionNode::ChildSections::const_iterator it =
					std::find_if(parentNode.childSections.begin(),
						parentNode.childSections.end(),
						BySectionInfo(sectionInfo));
				if (it == parentNode.childSections.end()) {
					node = new SectionNode(incompleteStats);
					parentNode.childSections.push_back(node);
				}
				else
					node = *it;
			}
			m_sectionStack.push_back(node);
			m_deepestSection = node;
		}

		virtual void assertionStarting(AssertionInfo const&) CATCH_OVERRIDE {}

		virtual bool assertionEnded(AssertionStats const& assertionStats) CATCH_OVERRIDE {
			assert(!m_sectionStack.empty());
			SectionNode& sectionNode = *m_sectionStack.back();
			sectionNode.assertions.push_back(assertionStats);
			return true;
		}
		virtual void sectionEnded(SectionStats const& sectionStats) CATCH_OVERRIDE {
			assert(!m_sectionStack.empty());
			SectionNode& node = *m_sectionStack.back();
			node.stats = sectionStats;
			m_sectionStack.pop_back();
		}
		virtual void testCaseEnded(TestCaseStats const& testCaseStats) CATCH_OVERRIDE {
			Ptr<TestCaseNode> node = new TestCaseNode(testCaseStats);
			assert(m_sectionStack.size() == 0);
			node->children.push_back(m_rootSection);
			m_testCases.push_back(node);
			m_rootSection.reset();

			assert(m_deepestSection);
			m_deepestSection->stdOut = testCaseStats.stdOut;
			m_deepestSection->stdErr = testCaseStats.stdErr;
		}
		virtual void testGroupEnded(TestGroupStats const& testGroupStats) CATCH_OVERRIDE {
			Ptr<TestGroupNode> node = new TestGroupNode(testGroupStats);
			node->children.swap(m_testCases);
			m_testGroups.push_back(node);
		}
		virtual void testRunEnded(TestRunStats const& testRunStats) CATCH_OVERRIDE {
			Ptr<TestRunNode> node = new TestRunNode(testRunStats);
			node->children.swap(m_testGroups);
			m_testRuns.push_back(node);
			testRunEndedCumulative();
		}
		virtual void testRunEndedCumulative() = 0;

		virtual void skipTest(TestCaseInfo const&) CATCH_OVERRIDE {}

		Ptr<IConfig const> m_config;
		std::ostream& stream;
		std::vector<AssertionStats> m_assertions;
		std::vector<std::vector<Ptr<SectionNode> > > m_sections;
		std::vector<Ptr<TestCaseNode> > m_testCases;
		std::vector<Ptr<TestGroupNode> > m_testGroups;

		std::vector<Ptr<TestRunNode> > m_testRuns;

		Ptr<SectionNode> m_rootSection;
		Ptr<SectionNode> m_deepestSection;
		std::vector<Ptr<SectionNode> > m_sectionStack;
		ReporterPreferences m_reporterPrefs;

	};

	template<char C>
	char const* getLineOfChars() {
		static char line[CATCH_CONFIG_CONSOLE_WIDTH] = { 0 };
		if (!*line) {
			memset(line, C, CATCH_CONFIG_CONSOLE_WIDTH - 1);
			line[CATCH_CONFIG_CONSOLE_WIDTH - 1] = 0;
		}
		return line;
	}

	struct TestEventListenerBase : StreamingReporterBase {
		TestEventListenerBase(ReporterConfig const& _config)
			: StreamingReporterBase(_config)
		{}

		virtual void assertionStarting(AssertionInfo const&) CATCH_OVERRIDE {}
		virtual bool assertionEnded(AssertionStats const&) CATCH_OVERRIDE {
			return false;
		}
	};

} // end namespace Catch

  // #included from: ../internal/catch_reporter_registrars.hpp
#define TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED

namespace Catch {

	template<typename T>
	class LegacyReporterRegistrar {

		class ReporterFactory : public IReporterFactory {
			virtual IStreamingReporter* create(ReporterConfig const& config) const {
				return new LegacyReporterAdapter(new T(config));
			}

			virtual std::string getDescription() const {
				return T::getDescription();
			}
		};

	public:

		LegacyReporterRegistrar(std::string const& name) {
			getMutableRegistryHub().registerReporter(name, new ReporterFactory());
		}
	};

	template<typename T>
	class ReporterRegistrar {

		class ReporterFactory : public SharedImpl<IReporterFactory> {

			// *** Please Note ***:
			// - If you end up here looking at a compiler error because it's trying to register
			// your custom reporter class be aware that the native reporter interface has changed
			// to IStreamingReporter. The "legacy" interface, IReporter, is still supported via
			// an adapter. Just use REGISTER_LEGACY_REPORTER to take advantage of the adapter.
			// However please consider updating to the new interface as the old one is now
			// deprecated and will probably be removed quite soon!
			// Please contact me via github if you have any questions at all about this.
			// In fact, ideally, please contact me anyway to let me know you've hit this - as I have
			// no idea who is actually using custom reporters at all (possibly no-one!).
			// The new interface is designed to minimise exposure to interface changes in the future.
			virtual IStreamingReporter* create(ReporterConfig const& config) const {
				return new T(config);
			}

			virtual std::string getDescription() const {
				return T::getDescription();
			}
		};

	public:

		ReporterRegistrar(std::string const& name) {
			getMutableRegistryHub().registerReporter(name, new ReporterFactory());
		}
	};

	template<typename T>
	class ListenerRegistrar {

		class ListenerFactory : public SharedImpl<IReporterFactory> {

			virtual IStreamingReporter* create(ReporterConfig const& config) const {
				return new T(config);
			}
			virtual std::string getDescription() const {
				return "";
			}
		};

	public:

		ListenerRegistrar() {
			getMutableRegistryHub().registerListener(new ListenerFactory());
		}
	};
}

#define INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) \
    namespace{ Catch::LegacyReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); }

#define INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType ) \
    namespace{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); }

#define INTERNAL_CATCH_REGISTER_LISTENER( listenerType ) \
    namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; }

// #included from: ../internal/catch_xmlwriter.hpp
#define TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED

#include <sstream>
#include <string>
#include <vector>
#include <iomanip>

namespace Catch {

	class XmlEncode {
	public:
		enum ForWhat { ForTextNodes, ForAttributes };

		XmlEncode(std::string const& str, ForWhat forWhat = ForTextNodes)
			: m_str(str),
			m_forWhat(forWhat)
		{}

		void encodeTo(std::ostream& os) const {

			// Apostrophe escaping not necessary if we always use " to write attributes
			// (see: http://www.w3.org/TR/xml/#syntax)

			for (std::size_t i = 0; i < m_str.size(); ++i) {
				char c = m_str[i];
				switch (c) {
				case '<':   os << "&lt;"; break;
				case '&':   os << "&amp;"; break;

				case '>':
					// See: http://www.w3.org/TR/xml/#syntax
					if (i > 2 && m_str[i - 1] == ']' && m_str[i - 2] == ']')
						os << "&gt;";
					else
						os << c;
					break;

				case '\"':
					if (m_forWhat == ForAttributes)
						os << "&quot;";
					else
						os << c;
					break;

				default:
					// Escape control chars - based on contribution by @espenalb in PR #465
					if ((c < '\x09') || (c > '\x0D' && c < '\x20') || c == '\x7F')
						os << "&#x" << std::uppercase << std::hex << static_cast<int>(c);
					else
						os << c;
				}
			}
		}

		friend std::ostream& operator << (std::ostream& os, XmlEncode const& xmlEncode) {
			xmlEncode.encodeTo(os);
			return os;
		}

	private:
		std::string m_str;
		ForWhat m_forWhat;
	};

	class XmlWriter {
	public:

		class ScopedElement {
		public:
			ScopedElement(XmlWriter* writer)
				: m_writer(writer)
			{}

			ScopedElement(ScopedElement const& other)
				: m_writer(other.m_writer) {
				other.m_writer = CATCH_NULL;
			}

			~ScopedElement() {
				if (m_writer)
					m_writer->endElement();
			}

			ScopedElement& writeText(std::string const& text, bool indent = true) {
				m_writer->writeText(text, indent);
				return *this;
			}

			template<typename T>
			ScopedElement& writeAttribute(std::string const& name, T const& attribute) {
				m_writer->writeAttribute(name, attribute);
				return *this;
			}

		private:
			mutable XmlWriter* m_writer;
		};

		XmlWriter()
			: m_tagIsOpen(false),
			m_needsNewline(false),
			m_os(&Catch::cout())
		{}

		XmlWriter(std::ostream& os)
			: m_tagIsOpen(false),
			m_needsNewline(false),
			m_os(&os)
		{}

		~XmlWriter() {
			while (!m_tags.empty())
				endElement();
		}

		XmlWriter& startElement(std::string const& name) {
			ensureTagClosed();
			newlineIfNecessary();
			stream() << m_indent << "<" << name;
			m_tags.push_back(name);
			m_indent += "  ";
			m_tagIsOpen = true;
			return *this;
		}

		ScopedElement scopedElement(std::string const& name) {
			ScopedElement scoped(this);
			startElement(name);
			return scoped;
		}

		XmlWriter& endElement() {
			newlineIfNecessary();
			m_indent = m_indent.substr(0, m_indent.size() - 2);
			if (m_tagIsOpen) {
				stream() << "/>\n";
				m_tagIsOpen = false;
			}
			else {
				stream() << m_indent << "</" << m_tags.back() << ">\n";
			}
			m_tags.pop_back();
			return *this;
		}

		XmlWriter& writeAttribute(std::string const& name, std::string const& attribute) {
			if (!name.empty() && !attribute.empty())
				stream() << " " << name << "=\"" << XmlEncode(attribute, XmlEncode::ForAttributes) << "\"";
			return *this;
		}

		XmlWriter& writeAttribute(std::string const& name, bool attribute) {
			stream() << " " << name << "=\"" << (attribute ? "true" : "false") << "\"";
			return *this;
		}

		template<typename T>
		XmlWriter& writeAttribute(std::string const& name, T const& attribute) {
			std::ostringstream oss;
			oss << attribute;
			return writeAttribute(name, oss.str());
		}

		XmlWriter& writeText(std::string const& text, bool indent = true) {
			if (!text.empty()) {
				bool tagWasOpen = m_tagIsOpen;
				ensureTagClosed();
				if (tagWasOpen && indent)
					stream() << m_indent;
				stream() << XmlEncode(text);
				m_needsNewline = true;
			}
			return *this;
		}

		XmlWriter& writeComment(std::string const& text) {
			ensureTagClosed();
			stream() << m_indent << "<!--" << text << "-->";
			m_needsNewline = true;
			return *this;
		}

		XmlWriter& writeBlankLine() {
			ensureTagClosed();
			stream() << "\n";
			return *this;
		}

		void setStream(std::ostream& os) {
			m_os = &os;
		}

	private:
		XmlWriter(XmlWriter const&);
		void operator=(XmlWriter const&);

		std::ostream& stream() {
			return *m_os;
		}

		void ensureTagClosed() {
			if (m_tagIsOpen) {
				stream() << ">\n";
				m_tagIsOpen = false;
			}
		}

		void newlineIfNecessary() {
			if (m_needsNewline) {
				stream() << "\n";
				m_needsNewline = false;
			}
		}

		bool m_tagIsOpen;
		bool m_needsNewline;
		std::vector<std::string> m_tags;
		std::string m_indent;
		std::ostream* m_os;
	};

}
// #included from: catch_reenable_warnings.h

#define TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED

#ifdef __clang__
#    ifdef __ICC // icpc defines the __clang__ macro
#        pragma warning(pop)
#    else
#        pragma clang diagnostic pop
#    endif
#elif defined __GNUC__
#    pragma GCC diagnostic pop
#endif


namespace Catch {
	class XmlReporter : public StreamingReporterBase {
	public:
		XmlReporter(ReporterConfig const& _config)
			: StreamingReporterBase(_config),
			m_sectionDepth(0)
		{
			m_reporterPrefs.shouldRedirectStdOut = true;
		}

		virtual ~XmlReporter() CATCH_OVERRIDE;

		static std::string getDescription() {
			return "Reports test results as an XML document";
		}

	public: // StreamingReporterBase

		virtual void noMatchingTestCases(std::string const& s) CATCH_OVERRIDE {
			StreamingReporterBase::noMatchingTestCases(s);
		}

		virtual void testRunStarting(TestRunInfo const& testInfo) CATCH_OVERRIDE {
			StreamingReporterBase::testRunStarting(testInfo);
			m_xml.setStream(stream);
			m_xml.startElement("Catch");
			if (!m_config->name().empty())
				m_xml.writeAttribute("name", m_config->name());
		}

		virtual void testGroupStarting(GroupInfo const& groupInfo) CATCH_OVERRIDE {
			StreamingReporterBase::testGroupStarting(groupInfo);
			m_xml.startElement("Group")
				.writeAttribute("name", groupInfo.name);
		}

		virtual void testCaseStarting(TestCaseInfo const& testInfo) CATCH_OVERRIDE {
			StreamingReporterBase::testCaseStarting(testInfo);
			m_xml.startElement("TestCase").writeAttribute("name", trim(testInfo.name));

			if (m_config->showDurations() == ShowDurations::Always)
				m_testCaseTimer.start();
		}

		virtual void sectionStarting(SectionInfo const& sectionInfo) CATCH_OVERRIDE {
			StreamingReporterBase::sectionStarting(sectionInfo);
			if (m_sectionDepth++ > 0) {
				m_xml.startElement("Section")
					.writeAttribute("name", trim(sectionInfo.name))
					.writeAttribute("description", sectionInfo.description);
			}
		}

		virtual void assertionStarting(AssertionInfo const&) CATCH_OVERRIDE { }

		virtual bool assertionEnded(AssertionStats const& assertionStats) CATCH_OVERRIDE {
			const AssertionResult& assertionResult = assertionStats.assertionResult;

			// Print any info messages in <Info> tags.
			if (assertionStats.assertionResult.getResultType() != ResultWas::Ok) {
				for (std::vector<MessageInfo>::const_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();
					it != itEnd;
					++it) {
					if (it->type == ResultWas::Info) {
						m_xml.scopedElement("Info")
							.writeText(it->message);
					}
					else if (it->type == ResultWas::Warning) {
						m_xml.scopedElement("Warning")
							.writeText(it->message);
					}
				}
			}

			// Drop out if result was successful but we're not printing them.
			if (!m_config->includeSuccessfulResults() && isOk(assertionResult.getResultType()))
				return true;

			// Print the expression if there is one.
			if (assertionResult.hasExpression()) {
				m_xml.startElement("Expression")
					.writeAttribute("success", assertionResult.succeeded())
					.writeAttribute("type", assertionResult.getTestMacroName())
					.writeAttribute("filename", assertionResult.getSourceInfo().file)
					.writeAttribute("line", assertionResult.getSourceInfo().line);

				m_xml.scopedElement("Original")
					.writeText(assertionResult.getExpression());
				m_xml.scopedElement("Expanded")
					.writeText(assertionResult.getExpandedExpression());
			}

			// And... Print a result applicable to each result type.
			switch (assertionResult.getResultType()) {
			case ResultWas::ThrewException:
				m_xml.scopedElement("Exception")
					.writeAttribute("filename", assertionResult.getSourceInfo().file)
					.writeAttribute("line", assertionResult.getSourceInfo().line)
					.writeText(assertionResult.getMessage());
				break;
			case ResultWas::FatalErrorCondition:
				m_xml.scopedElement("Fatal Error Condition")
					.writeAttribute("filename", assertionResult.getSourceInfo().file)
					.writeAttribute("line", assertionResult.getSourceInfo().line)
					.writeText(assertionResult.getMessage());
				break;
			case ResultWas::Info:
				m_xml.scopedElement("Info")
					.writeText(assertionResult.getMessage());
				break;
			case ResultWas::Warning:
				// Warning will already have been written
				break;
			case ResultWas::ExplicitFailure:
				m_xml.scopedElement("Failure")
					.writeText(assertionResult.getMessage());
				break;
			default:
				break;
			}

			if (assertionResult.hasExpression())
				m_xml.endElement();

			return true;
		}

		virtual void sectionEnded(SectionStats const& sectionStats) CATCH_OVERRIDE {
			StreamingReporterBase::sectionEnded(sectionStats);
			if (--m_sectionDepth > 0) {
				XmlWriter::ScopedElement e = m_xml.scopedElement("OverallResults");
				e.writeAttribute("successes", sectionStats.assertions.passed);
				e.writeAttribute("failures", sectionStats.assertions.failed);
				e.writeAttribute("expectedFailures", sectionStats.assertions.failedButOk);

				if (m_config->showDurations() == ShowDurations::Always)
					e.writeAttribute("durationInSeconds", sectionStats.durationInSeconds);

				m_xml.endElement();
			}
		}

		virtual void testCaseEnded(TestCaseStats const& testCaseStats) CATCH_OVERRIDE {
			StreamingReporterBase::testCaseEnded(testCaseStats);
			XmlWriter::ScopedElement e = m_xml.scopedElement("OverallResult");
			e.writeAttribute("success", testCaseStats.totals.assertions.allOk());

			if (m_config->showDurations() == ShowDurations::Always)
				e.writeAttribute("durationInSeconds", m_testCaseTimer.getElapsedSeconds());

			m_xml.endElement();
		}

		virtual void testGroupEnded(TestGroupStats const& testGroupStats) CATCH_OVERRIDE {
			StreamingReporterBase::testGroupEnded(testGroupStats);
			// TODO: Check testGroupStats.aborting and act accordingly.
			m_xml.scopedElement("OverallResults")
				.writeAttribute("successes", testGroupStats.totals.assertions.passed)
				.writeAttribute("failures", testGroupStats.totals.assertions.failed)
				.writeAttribute("expectedFailures", testGroupStats.totals.assertions.failedButOk);
			m_xml.endElement();
		}

		virtual void testRunEnded(TestRunStats const& testRunStats) CATCH_OVERRIDE {
			StreamingReporterBase::testRunEnded(testRunStats);
			m_xml.scopedElement("OverallResults")
				.writeAttribute("successes", testRunStats.totals.assertions.passed)
				.writeAttribute("failures", testRunStats.totals.assertions.failed)
				.writeAttribute("expectedFailures", testRunStats.totals.assertions.failedButOk);
			m_xml.endElement();
		}

	private:
		Timer m_testCaseTimer;
		XmlWriter m_xml;
		int m_sectionDepth;
	};

	INTERNAL_CATCH_REGISTER_REPORTER("xml", XmlReporter)

} // end namespace Catch

  // #included from: ../reporters/catch_reporter_junit.hpp
#define TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED

#include <assert.h>

namespace Catch {

	class JunitReporter : public CumulativeReporterBase {
	public:
		JunitReporter(ReporterConfig const& _config)
			: CumulativeReporterBase(_config),
			xml(_config.stream())
		{
			m_reporterPrefs.shouldRedirectStdOut = true;
		}

		virtual ~JunitReporter() CATCH_OVERRIDE;

		static std::string getDescription() {
			return "Reports test results in an XML format that looks like Ant's junitreport target";
		}

		virtual void noMatchingTestCases(std::string const& /*spec*/) CATCH_OVERRIDE {}

		virtual void testRunStarting(TestRunInfo const& runInfo) CATCH_OVERRIDE {
			CumulativeReporterBase::testRunStarting(runInfo);
			xml.startElement("testsuites");
		}

		virtual void testGroupStarting(GroupInfo const& groupInfo) CATCH_OVERRIDE {
			suiteTimer.start();
			stdOutForSuite.str("");
			stdErrForSuite.str("");
			unexpectedExceptions = 0;
			CumulativeReporterBase::testGroupStarting(groupInfo);
		}

		virtual bool assertionEnded(AssertionStats const& assertionStats) CATCH_OVERRIDE {
			if (assertionStats.assertionResult.getResultType() == ResultWas::ThrewException)
				unexpectedExceptions++;
			return CumulativeReporterBase::assertionEnded(assertionStats);
		}

		virtual void testCaseEnded(TestCaseStats const& testCaseStats) CATCH_OVERRIDE {
			stdOutForSuite << testCaseStats.stdOut;
			stdErrForSuite << testCaseStats.stdErr;
			CumulativeReporterBase::testCaseEnded(testCaseStats);
		}

		virtual void testGroupEnded(TestGroupStats const& testGroupStats) CATCH_OVERRIDE {
			double suiteTime = suiteTimer.getElapsedSeconds();
			CumulativeReporterBase::testGroupEnded(testGroupStats);
			writeGroup(*m_testGroups.back(), suiteTime);
		}

		virtual void testRunEndedCumulative() CATCH_OVERRIDE {
			xml.endElement();
		}

		void writeGroup(TestGroupNode const& groupNode, double suiteTime) {
			XmlWriter::ScopedElement e = xml.scopedElement("testsuite");
			TestGroupStats const& stats = groupNode.value;
			xml.writeAttribute("name", stats.groupInfo.name);
			xml.writeAttribute("errors", unexpectedExceptions);
			xml.writeAttribute("failures", stats.totals.assertions.failed - unexpectedExceptions);
			xml.writeAttribute("tests", stats.totals.assertions.total());
			xml.writeAttribute("hostname", "tbd"); // !TBD
			if (m_config->showDurations() == ShowDurations::Never)
				xml.writeAttribute("time", "");
			else
				xml.writeAttribute("time", suiteTime);
			xml.writeAttribute("timestamp", "tbd"); // !TBD

													// Write test cases
			for (TestGroupNode::ChildNodes::const_iterator
				it = groupNode.children.begin(), itEnd = groupNode.children.end();
				it != itEnd;
				++it)
				writeTestCase(**it);

			xml.scopedElement("system-out").writeText(trim(stdOutForSuite.str()), false);
			xml.scopedElement("system-err").writeText(trim(stdErrForSuite.str()), false);
		}

		void writeTestCase(TestCaseNode const& testCaseNode) {
			TestCaseStats const& stats = testCaseNode.value;

			// All test cases have exactly one section - which represents the
			// test case itself. That section may have 0-n nested sections
			assert(testCaseNode.children.size() == 1);
			SectionNode const& rootSection = *testCaseNode.children.front();

			std::string className = stats.testInfo.className;

			if (className.empty()) {
				if (rootSection.childSections.empty())
					className = "global";
			}
			writeSection(className, "", rootSection);
		}

		void writeSection(std::string const& className,
			std::string const& rootName,
			SectionNode const& sectionNode) {
			std::string name = trim(sectionNode.stats.sectionInfo.name);
			if (!rootName.empty())
				name = rootName + "/" + name;

			if (!sectionNode.assertions.empty() ||
				!sectionNode.stdOut.empty() ||
				!sectionNode.stdErr.empty()) {
				XmlWriter::ScopedElement e = xml.scopedElement("testcase");
				if (className.empty()) {
					xml.writeAttribute("classname", name);
					xml.writeAttribute("name", "root");
				}
				else {
					xml.writeAttribute("classname", className);
					xml.writeAttribute("name", name);
				}
				xml.writeAttribute("time", Catch::toString(sectionNode.stats.durationInSeconds));

				writeAssertions(sectionNode);

				if (!sectionNode.stdOut.empty())
					xml.scopedElement("system-out").writeText(trim(sectionNode.stdOut), false);
				if (!sectionNode.stdErr.empty())
					xml.scopedElement("system-err").writeText(trim(sectionNode.stdErr), false);
			}
			for (SectionNode::ChildSections::const_iterator
				it = sectionNode.childSections.begin(),
				itEnd = sectionNode.childSections.end();
				it != itEnd;
				++it)
				if (className.empty())
					writeSection(name, "", **it);
				else
					writeSection(className, name, **it);
		}

		void writeAssertions(SectionNode const& sectionNode) {
			for (SectionNode::Assertions::const_iterator
				it = sectionNode.assertions.begin(), itEnd = sectionNode.assertions.end();
				it != itEnd;
				++it)
				writeAssertion(*it);
		}
		void writeAssertion(AssertionStats const& stats) {
			AssertionResult const& result = stats.assertionResult;
			if (!result.isOk()) {
				std::string elementName;
				switch (result.getResultType()) {
				case ResultWas::ThrewException:
				case ResultWas::FatalErrorCondition:
					elementName = "error";
					break;
				case ResultWas::ExplicitFailure:
					elementName = "failure";
					break;
				case ResultWas::ExpressionFailed:
					elementName = "failure";
					break;
				case ResultWas::DidntThrowException:
					elementName = "failure";
					break;

					// We should never see these here:
				case ResultWas::Info:
				case ResultWas::Warning:
				case ResultWas::Ok:
				case ResultWas::Unknown:
				case ResultWas::FailureBit:
				case ResultWas::Exception:
					elementName = "internalError";
					break;
				}

				XmlWriter::ScopedElement e = xml.scopedElement(elementName);

				xml.writeAttribute("message", result.getExpandedExpression());
				xml.writeAttribute("type", result.getTestMacroName());

				std::ostringstream oss;
				if (!result.getMessage().empty())
					oss << result.getMessage() << "\n";
				for (std::vector<MessageInfo>::const_iterator
					it = stats.infoMessages.begin(),
					itEnd = stats.infoMessages.end();
					it != itEnd;
					++it)
					if (it->type == ResultWas::Info)
						oss << it->message << "\n";

				oss << "at " << result.getSourceInfo();
				xml.writeText(oss.str(), false);
			}
		}

		XmlWriter xml;
		Timer suiteTimer;
		std::ostringstream stdOutForSuite;
		std::ostringstream stdErrForSuite;
		unsigned int unexpectedExceptions;
	};

	INTERNAL_CATCH_REGISTER_REPORTER("junit", JunitReporter)

} // end namespace Catch

  // #included from: ../reporters/catch_reporter_console.hpp
#define TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED

namespace Catch {

	struct ConsoleReporter : StreamingReporterBase {
		ConsoleReporter(ReporterConfig const& _config)
			: StreamingReporterBase(_config),
			m_headerPrinted(false)
		{}

		virtual ~ConsoleReporter() CATCH_OVERRIDE;
		static std::string getDescription() {
			return "Reports test results as plain lines of text";
		}

		virtual void noMatchingTestCases(std::string const& spec) CATCH_OVERRIDE {
			stream << "No test cases matched '" << spec << "'" << std::endl;
		}

		virtual void assertionStarting(AssertionInfo const&) CATCH_OVERRIDE {
		}

		virtual bool assertionEnded(AssertionStats const& _assertionStats) CATCH_OVERRIDE {
			AssertionResult const& result = _assertionStats.assertionResult;

			bool printInfoMessages = true;

			// Drop out if result was successful and we're not printing those
			if (!m_config->includeSuccessfulResults() && result.isOk()) {
				if (result.getResultType() != ResultWas::Warning)
					return false;
				printInfoMessages = false;
			}

			lazyPrint();

			AssertionPrinter printer(stream, _assertionStats, printInfoMessages);
			printer.print();
			stream << std::endl;
			return true;
		}

		virtual void sectionStarting(SectionInfo const& _sectionInfo) CATCH_OVERRIDE {
			m_headerPrinted = false;
			StreamingReporterBase::sectionStarting(_sectionInfo);
		}
		virtual void sectionEnded(SectionStats const& _sectionStats) CATCH_OVERRIDE {
			if (_sectionStats.missingAssertions) {
				lazyPrint();
				Colour colour(Colour::ResultError);
				if (m_sectionStack.size() > 1)
					stream << "\nNo assertions in section";
				else
					stream << "\nNo assertions in test case";
				stream << " '" << _sectionStats.sectionInfo.name << "'\n" << std::endl;
			}
			if (m_headerPrinted) {
				if (m_config->showDurations() == ShowDurations::Always)
					stream << "Completed in " << _sectionStats.durationInSeconds << "s" << std::endl;
				m_headerPrinted = false;
			}
			else {
				if (m_config->showDurations() == ShowDurations::Always)
					stream << _sectionStats.sectionInfo.name << " completed in " << _sectionStats.durationInSeconds << "s" << std::endl;
			}
			StreamingReporterBase::sectionEnded(_sectionStats);
		}

		virtual void testCaseEnded(TestCaseStats const& _testCaseStats) CATCH_OVERRIDE {
			StreamingReporterBase::testCaseEnded(_testCaseStats);
			m_headerPrinted = false;
		}
		virtual void testGroupEnded(TestGroupStats const& _testGroupStats) CATCH_OVERRIDE {
			if (currentGroupInfo.used) {
				printSummaryDivider();
				stream << "Summary for group '" << _testGroupStats.groupInfo.name << "':\n";
				printTotals(_testGroupStats.totals);
				stream << "\n" << std::endl;
			}
			StreamingReporterBase::testGroupEnded(_testGroupStats);
		}
		virtual void testRunEnded(TestRunStats const& _testRunStats) CATCH_OVERRIDE {
			printTotalsDivider(_testRunStats.totals);
			printTotals(_testRunStats.totals);
			stream << std::endl;
			StreamingReporterBase::testRunEnded(_testRunStats);
		}

	private:

		class AssertionPrinter {
			void operator= (AssertionPrinter const&);
		public:
			AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
				: stream(_stream),
				stats(_stats),
				result(_stats.assertionResult),
				colour(Colour::None),
				message(result.getMessage()),
				messages(_stats.infoMessages),
				printInfoMessages(_printInfoMessages)
			{
				switch (result.getResultType()) {
				case ResultWas::Ok:
					colour = Colour::Success;
					passOrFail = "PASSED";
					//if( result.hasMessage() )
					if (_stats.infoMessages.size() == 1)
						messageLabel = "with message";
					if (_stats.infoMessages.size() > 1)
						messageLabel = "with messages";
					break;
				case ResultWas::ExpressionFailed:
					if (result.isOk()) {
						colour = Colour::Success;
						passOrFail = "FAILED - but was ok";
					}
					else {
						colour = Colour::Error;
						passOrFail = "FAILED";
					}
					if (_stats.infoMessages.size() == 1)
						messageLabel = "with message";
					if (_stats.infoMessages.size() > 1)
						messageLabel = "with messages";
					break;
				case ResultWas::ThrewException:
					colour = Colour::Error;
					passOrFail = "FAILED";
					messageLabel = "due to unexpected exception with message";
					break;
				case ResultWas::FatalErrorCondition:
					colour = Colour::Error;
					passOrFail = "FAILED";
					messageLabel = "due to a fatal error condition";
					break;
				case ResultWas::DidntThrowException:
					colour = Colour::Error;
					passOrFail = "FAILED";
					messageLabel = "because no exception was thrown where one was expected";
					break;
				case ResultWas::Info:
					messageLabel = "info";
					break;
				case ResultWas::Warning:
					messageLabel = "warning";
					break;
				case ResultWas::ExplicitFailure:
					passOrFail = "FAILED";
					colour = Colour::Error;
					if (_stats.infoMessages.size() == 1)
						messageLabel = "explicitly with message";
					if (_stats.infoMessages.size() > 1)
						messageLabel = "explicitly with messages";
					break;
					// These cases are here to prevent compiler warnings
				case ResultWas::Unknown:
				case ResultWas::FailureBit:
				case ResultWas::Exception:
					passOrFail = "** internal error **";
					colour = Colour::Error;
					break;
				}
			}

			void print() const {
				printSourceInfo();
				if (stats.totals.assertions.total() > 0) {
					if (result.isOk())
						stream << "\n";
					printResultType();
					printOriginalExpression();
					printReconstructedExpression();
				}
				else {
					stream << "\n";
				}
				printMessage();
			}

		private:
			void printResultType() const {
				if (!passOrFail.empty()) {
					Colour colourGuard(colour);
					stream << passOrFail << ":\n";
				}
			}
			void printOriginalExpression() const {
				if (result.hasExpression()) {
					Colour colourGuard(Colour::OriginalExpression);
					stream << "  ";
					stream << result.getExpressionInMacro();
					stream << "\n";
				}
			}
			void printReconstructedExpression() const {
				if (result.hasExpandedExpression()) {
					stream << "with expansion:\n";
					Colour colourGuard(Colour::ReconstructedExpression);
					stream << Text(result.getExpandedExpression(), TextAttributes().setIndent(2)) << "\n";
				}
			}
			void printMessage() const {
				if (!messageLabel.empty())
					stream << messageLabel << ":" << "\n";
				for (std::vector<MessageInfo>::const_iterator it = messages.begin(), itEnd = messages.end();
					it != itEnd;
					++it) {
					// If this assertion is a warning ignore any INFO messages
					if (printInfoMessages || it->type != ResultWas::Info)
						stream << Text(it->message, TextAttributes().setIndent(2)) << "\n";
				}
			}
			void printSourceInfo() const {
				Colour colourGuard(Colour::FileName);
				stream << result.getSourceInfo() << ": ";
			}

			std::ostream& stream;
			AssertionStats const& stats;
			AssertionResult const& result;
			Colour::Code colour;
			std::string passOrFail;
			std::string messageLabel;
			std::string message;
			std::vector<MessageInfo> messages;
			bool printInfoMessages;
		};

		void lazyPrint() {

			if (!currentTestRunInfo.used)
				lazyPrintRunInfo();
			if (!currentGroupInfo.used)
				lazyPrintGroupInfo();

			if (!m_headerPrinted) {
				printTestCaseAndSectionHeader();
				m_headerPrinted = true;
			}
		}
		void lazyPrintRunInfo() {
			stream << "\n" << getLineOfChars<'~'>() << "\n";
			Colour colour(Colour::SecondaryText);
			stream << currentTestRunInfo->name
				<< " is a Catch v" << libraryVersion << " host application.\n"
				<< "Run with -? for options\n\n";

			if (m_config->rngSeed() != 0)
				stream << "Randomness seeded to: " << m_config->rngSeed() << "\n\n";

			currentTestRunInfo.used = true;
		}
		void lazyPrintGroupInfo() {
			if (!currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1) {
				printClosedHeader("Group: " + currentGroupInfo->name);
				currentGroupInfo.used = true;
			}
		}
		void printTestCaseAndSectionHeader() {
			assert(!m_sectionStack.empty());
			printOpenHeader(currentTestCaseInfo->name);

			if (m_sectionStack.size() > 1) {
				Colour colourGuard(Colour::Headers);

				std::vector<SectionInfo>::const_iterator
					it = m_sectionStack.begin() + 1, // Skip first section (test case)
					itEnd = m_sectionStack.end();
				for (; it != itEnd; ++it)
					printHeaderString(it->name, 2);
			}

			SourceLineInfo lineInfo = m_sectionStack.front().lineInfo;

			if (!lineInfo.empty()) {
				stream << getLineOfChars<'-'>() << "\n";
				Colour colourGuard(Colour::FileName);
				stream << lineInfo << "\n";
			}
			stream << getLineOfChars<'.'>() << "\n" << std::endl;
		}

		void printClosedHeader(std::string const& _name) {
			printOpenHeader(_name);
			stream << getLineOfChars<'.'>() << "\n";
		}
		void printOpenHeader(std::string const& _name) {
			stream << getLineOfChars<'-'>() << "\n";
			{
				Colour colourGuard(Colour::Headers);
				printHeaderString(_name);
			}
		}

		// if string has a : in first line will set indent to follow it on
		// subsequent lines
		void printHeaderString(std::string const& _string, std::size_t indent = 0) {
			std::size_t i = _string.find(": ");
			if (i != std::string::npos)
				i += 2;
			else
				i = 0;
			stream << Text(_string, TextAttributes()
				.setIndent(indent + i)
				.setInitialIndent(indent)) << "\n";
		}

		struct SummaryColumn {

			SummaryColumn(std::string const& _label, Colour::Code _colour)
				: label(_label),
				colour(_colour)
			{}
			SummaryColumn addRow(std::size_t count) {
				std::ostringstream oss;
				oss << count;
				std::string row = oss.str();
				for (std::vector<std::string>::iterator it = rows.begin(); it != rows.end(); ++it) {
					while (it->size() < row.size())
						*it = " " + *it;
					while (it->size() > row.size())
						row = " " + row;
				}
				rows.push_back(row);
				return *this;
			}

			std::string label;
			Colour::Code colour;
			std::vector<std::string> rows;

		};

		void printTotals(Totals const& totals) {
			if (totals.testCases.total() == 0) {
				stream << Colour(Colour::Warning) << "No tests ran\n";
			}
			else if (totals.assertions.total() > 0 && totals.testCases.allPassed()) {
				stream << Colour(Colour::ResultSuccess) << "All tests passed";
				stream << " ("
					<< pluralise(totals.assertions.passed, "assertion") << " in "
					<< pluralise(totals.testCases.passed, "test case") << ")"
					<< "\n";
			}
			else {

				std::vector<SummaryColumn> columns;
				columns.push_back(SummaryColumn("", Colour::None)
					.addRow(totals.testCases.total())
					.addRow(totals.assertions.total()));
				columns.push_back(SummaryColumn("passed", Colour::Success)
					.addRow(totals.testCases.passed)
					.addRow(totals.assertions.passed));
				columns.push_back(SummaryColumn("failed", Colour::ResultError)
					.addRow(totals.testCases.failed)
					.addRow(totals.assertions.failed));
				columns.push_back(SummaryColumn("failed as expected", Colour::ResultExpectedFailure)
					.addRow(totals.testCases.failedButOk)
					.addRow(totals.assertions.failedButOk));

				printSummaryRow("test cases", columns, 0);
				printSummaryRow("assertions", columns, 1);
			}
		}
		void printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row) {
			for (std::vector<SummaryColumn>::const_iterator it = cols.begin(); it != cols.end(); ++it) {
				std::string value = it->rows[row];
				if (it->label.empty()) {
					stream << label << ": ";
					if (value != "0")
						stream << value;
					else
						stream << Colour(Colour::Warning) << "- none -";
				}
				else if (value != "0") {
					stream << Colour(Colour::LightGrey) << " | ";
					stream << Colour(it->colour)
						<< value << " " << it->label;
				}
			}
			stream << "\n";
		}

		static std::size_t makeRatio(std::size_t number, std::size_t total) {
			std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;
			return (ratio == 0 && number > 0) ? 1 : ratio;
		}
		static std::size_t& findMax(std::size_t& i, std::size_t& j, std::size_t& k) {
			if (i > j && i > k)
				return i;
			else if (j > k)
				return j;
			else
				return k;
		}

		void printTotalsDivider(Totals const& totals) {
			if (totals.testCases.total() > 0) {
				std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());
				std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());
				std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());
				while (failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)
					findMax(failedRatio, failedButOkRatio, passedRatio)++;
				while (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)
					findMax(failedRatio, failedButOkRatio, passedRatio)--;

				stream << Colour(Colour::Error) << std::string(failedRatio, '=');
				stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, '=');
				if (totals.testCases.allPassed())
					stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, '=');
				else
					stream << Colour(Colour::Success) << std::string(passedRatio, '=');
			}
			else {
				stream << Colour(Colour::Warning) << std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, '=');
			}
			stream << "\n";
		}
		void printSummaryDivider() {
			stream << getLineOfChars<'-'>() << "\n";
		}

	private:
		bool m_headerPrinted;
	};

	INTERNAL_CATCH_REGISTER_REPORTER("console", ConsoleReporter)

} // end namespace Catch

  // #included from: ../reporters/catch_reporter_compact.hpp
#define TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED

namespace Catch {

	struct CompactReporter : StreamingReporterBase {

		CompactReporter(ReporterConfig const& _config)
			: StreamingReporterBase(_config)
		{}

		virtual ~CompactReporter();

		static std::string getDescription() {
			return "Reports test results on a single line, suitable for IDEs";
		}

		virtual ReporterPreferences getPreferences() const {
			ReporterPreferences prefs;
			prefs.shouldRedirectStdOut = false;
			return prefs;
		}

		virtual void noMatchingTestCases(std::string const& spec) {
			stream << "No test cases matched '" << spec << "'" << std::endl;
		}

		virtual void assertionStarting(AssertionInfo const&) {
		}

		virtual bool assertionEnded(AssertionStats const& _assertionStats) {
			AssertionResult const& result = _assertionStats.assertionResult;

			bool printInfoMessages = true;

			// Drop out if result was successful and we're not printing those
			if (!m_config->includeSuccessfulResults() && result.isOk()) {
				if (result.getResultType() != ResultWas::Warning)
					return false;
				printInfoMessages = false;
			}

			AssertionPrinter printer(stream, _assertionStats, printInfoMessages);
			printer.print();

			stream << std::endl;
			return true;
		}

		virtual void testRunEnded(TestRunStats const& _testRunStats) {
			printTotals(_testRunStats.totals);
			stream << "\n" << std::endl;
			StreamingReporterBase::testRunEnded(_testRunStats);
		}

	private:
		class AssertionPrinter {
			void operator= (AssertionPrinter const&);
		public:
			AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
				: stream(_stream)
				, stats(_stats)
				, result(_stats.assertionResult)
				, messages(_stats.infoMessages)
				, itMessage(_stats.infoMessages.begin())
				, printInfoMessages(_printInfoMessages)
			{}

			void print() {
				printSourceInfo();

				itMessage = messages.begin();

				switch (result.getResultType()) {
				case ResultWas::Ok:
					printResultType(Colour::ResultSuccess, passedString());
					printOriginalExpression();
					printReconstructedExpression();
					if (!result.hasExpression())
						printRemainingMessages(Colour::None);
					else
						printRemainingMessages();
					break;
				case ResultWas::ExpressionFailed:
					if (result.isOk())
						printResultType(Colour::ResultSuccess, failedString() + std::string(" - but was ok"));
					else
						printResultType(Colour::Error, failedString());
					printOriginalExpression();
					printReconstructedExpression();
					printRemainingMessages();
					break;
				case ResultWas::ThrewException:
					printResultType(Colour::Error, failedString());
					printIssue("unexpected exception with message:");
					printMessage();
					printExpressionWas();
					printRemainingMessages();
					break;
				case ResultWas::FatalErrorCondition:
					printResultType(Colour::Error, failedString());
					printIssue("fatal error condition with message:");
					printMessage();
					printExpressionWas();
					printRemainingMessages();
					break;
				case ResultWas::DidntThrowException:
					printResultType(Colour::Error, failedString());
					printIssue("expected exception, got none");
					printExpressionWas();
					printRemainingMessages();
					break;
				case ResultWas::Info:
					printResultType(Colour::None, "info");
					printMessage();
					printRemainingMessages();
					break;
				case ResultWas::Warning:
					printResultType(Colour::None, "warning");
					printMessage();
					printRemainingMessages();
					break;
				case ResultWas::ExplicitFailure:
					printResultType(Colour::Error, failedString());
					printIssue("explicitly");
					printRemainingMessages(Colour::None);
					break;
					// These cases are here to prevent compiler warnings
				case ResultWas::Unknown:
				case ResultWas::FailureBit:
				case ResultWas::Exception:
					printResultType(Colour::Error, "** internal error **");
					break;
				}
			}

		private:
			// Colour::LightGrey

			static Colour::Code dimColour() { return Colour::FileName; }

#ifdef CATCH_PLATFORM_MAC
			static const char* failedString() { return "FAILED"; }
			static const char* passedString() { return "PASSED"; }
#else
			static const char* failedString() { return "failed"; }
			static const char* passedString() { return "passed"; }
#endif

			void printSourceInfo() const {
				Colour colourGuard(Colour::FileName);
				stream << result.getSourceInfo() << ":";
			}

			void printResultType(Colour::Code colour, std::string passOrFail) const {
				if (!passOrFail.empty()) {
					{
						Colour colourGuard(colour);
						stream << " " << passOrFail;
					}
					stream << ":";
				}
			}

			void printIssue(std::string issue) const {
				stream << " " << issue;
			}

			void printExpressionWas() {
				if (result.hasExpression()) {
					stream << ";";
					{
						Colour colour(dimColour());
						stream << " expression was:";
					}
					printOriginalExpression();
				}
			}

			void printOriginalExpression() const {
				if (result.hasExpression()) {
					stream << " " << result.getExpression();
				}
			}

			void printReconstructedExpression() const {
				if (result.hasExpandedExpression()) {
					{
						Colour colour(dimColour());
						stream << " for: ";
					}
					stream << result.getExpandedExpression();
				}
			}

			void printMessage() {
				if (itMessage != messages.end()) {
					stream << " '" << itMessage->message << "'";
					++itMessage;
				}
			}

			void printRemainingMessages(Colour::Code colour = dimColour()) {
				if (itMessage == messages.end())
					return;

				// using messages.end() directly yields compilation error:
				std::vector<MessageInfo>::const_iterator itEnd = messages.end();
				const std::size_t N = static_cast<std::size_t>(std::distance(itMessage, itEnd));

				{
					Colour colourGuard(colour);
					stream << " with " << pluralise(N, "message") << ":";
				}

				for (; itMessage != itEnd; ) {
					// If this assertion is a warning ignore any INFO messages
					if (printInfoMessages || itMessage->type != ResultWas::Info) {
						stream << " '" << itMessage->message << "'";
						if (++itMessage != itEnd) {
							Colour colourGuard(dimColour());
							stream << " and";
						}
					}
				}
			}

		private:
			std::ostream& stream;
			AssertionStats const& stats;
			AssertionResult const& result;
			std::vector<MessageInfo> messages;
			std::vector<MessageInfo>::const_iterator itMessage;
			bool printInfoMessages;
		};

		// Colour, message variants:
		// - white: No tests ran.
		// -   red: Failed [both/all] N test cases, failed [both/all] M assertions.
		// - white: Passed [both/all] N test cases (no assertions).
		// -   red: Failed N tests cases, failed M assertions.
		// - green: Passed [both/all] N tests cases with M assertions.

		std::string bothOrAll(std::size_t count) const {
			return count == 1 ? "" : count == 2 ? "both " : "all ";
		}

		void printTotals(const Totals& totals) const {
			if (totals.testCases.total() == 0) {
				stream << "No tests ran.";
			}
			else if (totals.testCases.failed == totals.testCases.total()) {
				Colour colour(Colour::ResultError);
				const std::string qualify_assertions_failed =
					totals.assertions.failed == totals.assertions.total() ?
					bothOrAll(totals.assertions.failed) : "";
				stream <<
					"Failed " << bothOrAll(totals.testCases.failed)
					<< pluralise(totals.testCases.failed, "test case") << ", "
					"failed " << qualify_assertions_failed <<
					pluralise(totals.assertions.failed, "assertion") << ".";
			}
			else if (totals.assertions.total() == 0) {
				stream <<
					"Passed " << bothOrAll(totals.testCases.total())
					<< pluralise(totals.testCases.total(), "test case")
					<< " (no assertions).";
			}
			else if (totals.assertions.failed) {
				Colour colour(Colour::ResultError);
				stream <<
					"Failed " << pluralise(totals.testCases.failed, "test case") << ", "
					"failed " << pluralise(totals.assertions.failed, "assertion") << ".";
			}
			else {
				Colour colour(Colour::ResultSuccess);
				stream <<
					"Passed " << bothOrAll(totals.testCases.passed)
					<< pluralise(totals.testCases.passed, "test case") <<
					" with " << pluralise(totals.assertions.passed, "assertion") << ".";
			}
		}
	};

	INTERNAL_CATCH_REGISTER_REPORTER("compact", CompactReporter)

} // end namespace Catch

namespace Catch {
	// These are all here to avoid warnings about not having any out of line
	// virtual methods
	NonCopyable::~NonCopyable() {}
	IShared::~IShared() {}
	IStream::~IStream() CATCH_NOEXCEPT {}
	FileStream::~FileStream() CATCH_NOEXCEPT {}
	CoutStream::~CoutStream() CATCH_NOEXCEPT {}
	DebugOutStream::~DebugOutStream() CATCH_NOEXCEPT {}
	StreamBufBase::~StreamBufBase() CATCH_NOEXCEPT {}
	IContext::~IContext() {}
	IResultCapture::~IResultCapture() {}
	ITestCase::~ITestCase() {}
	ITestCaseRegistry::~ITestCaseRegistry() {}
	IRegistryHub::~IRegistryHub() {}
	IMutableRegistryHub::~IMutableRegistryHub() {}
	IExceptionTranslator::~IExceptionTranslator() {}
	IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() {}
	IReporter::~IReporter() {}
	IReporterFactory::~IReporterFactory() {}
	IReporterRegistry::~IReporterRegistry() {}
	IStreamingReporter::~IStreamingReporter() {}
	AssertionStats::~AssertionStats() {}
	SectionStats::~SectionStats() {}
	TestCaseStats::~TestCaseStats() {}
	TestGroupStats::~TestGroupStats() {}
	TestRunStats::~TestRunStats() {}
	CumulativeReporterBase::SectionNode::~SectionNode() {}
	CumulativeReporterBase::~CumulativeReporterBase() {}

	StreamingReporterBase::~StreamingReporterBase() {}
	ConsoleReporter::~ConsoleReporter() {}
	CompactReporter::~CompactReporter() {}
	IRunner::~IRunner() {}
	IMutableContext::~IMutableContext() {}
	IConfig::~IConfig() {}
	XmlReporter::~XmlReporter() {}
	JunitReporter::~JunitReporter() {}
	TestRegistry::~TestRegistry() {}
	FreeFunctionTestCase::~FreeFunctionTestCase() {}
	IGeneratorInfo::~IGeneratorInfo() {}
	IGeneratorsForTest::~IGeneratorsForTest() {}
	WildcardPattern::~WildcardPattern() {}
	TestSpec::Pattern::~Pattern() {}
	TestSpec::NamePattern::~NamePattern() {}
	TestSpec::TagPattern::~TagPattern() {}
	TestSpec::ExcludedPattern::~ExcludedPattern() {}

	Matchers::Impl::StdString::Equals::~Equals() {}
	Matchers::Impl::StdString::Contains::~Contains() {}
	Matchers::Impl::StdString::StartsWith::~StartsWith() {}
	Matchers::Impl::StdString::EndsWith::~EndsWith() {}

	void Config::dummy() {}

	namespace TestCaseTracking {
		ITracker::~ITracker() {}
		TrackerBase::~TrackerBase() {}
		SectionTracker::~SectionTracker() {}
		IndexTracker::~IndexTracker() {}
	}
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#endif

#ifdef CATCH_CONFIG_MAIN
// #included from: internal/catch_default_main.hpp
#define TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED

#ifndef __OBJC__

// Standard C/C++ main entry point
int main(int argc, char * argv[]) {
	return Catch::Session().run(argc, argv);
}

#else // __OBJC__

// Objective-C entry point
int main(int argc, char * const argv[]) {
#if !CATCH_ARC_ENABLED
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
#endif

	Catch::registerTestMethods();
	int result = Catch::Session().run(argc, (char* const*)argv);

#if !CATCH_ARC_ENABLED
	[pool drain];
#endif

	return result;
}

#endif // __OBJC__

#endif

#ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
#  undef CLARA_CONFIG_MAIN
#endif

//////

// If this config identifier is defined then all CATCH macros are prefixed with CATCH_
#ifdef CATCH_CONFIG_PREFIX_ALL

#define CATCH_REQUIRE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal, "CATCH_REQUIRE" )
#define CATCH_REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, "CATCH_REQUIRE_FALSE" )

#define CATCH_REQUIRE_THROWS( expr ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, "", "CATCH_REQUIRE_THROWS" )
#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_THROWS_AS" )
#define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, matcher, "CATCH_REQUIRE_THROWS_WITH" )
#define CATCH_REQUIRE_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_NOTHROW" )

#define CATCH_CHECK( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK" )
#define CATCH_CHECK_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, "CATCH_CHECK_FALSE" )
#define CATCH_CHECKED_IF( expr ) INTERNAL_CATCH_IF( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECKED_IF" )
#define CATCH_CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECKED_ELSE" )
#define CATCH_CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, "CATCH_CHECK_NOFAIL" )

#define CATCH_CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_THROWS" )
#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_THROWS_AS" )
#define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, matcher, "CATCH_CHECK_THROWS_WITH" )
#define CATCH_CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_NOTHROW" )

#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_THAT" )
#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_THAT" )

#define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( msg, "CATCH_INFO" )
#define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, "CATCH_WARN", msg )
#define CATCH_SCOPED_INFO( msg ) INTERNAL_CATCH_INFO( msg, "CATCH_INFO" )
#define CATCH_CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CATCH_CAPTURE" )
#define CATCH_SCOPED_CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CATCH_CAPTURE" )

#ifdef CATCH_CONFIG_VARIADIC_MACROS
#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
#define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
#define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
#define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "CATCH_FAIL", __VA_ARGS__ )
#define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "CATCH_SUCCEED", __VA_ARGS__ )
#else
#define CATCH_TEST_CASE( name, description ) INTERNAL_CATCH_TESTCASE( name, description )
#define CATCH_TEST_CASE_METHOD( className, name, description ) INTERNAL_CATCH_TEST_CASE_METHOD( className, name, description )
#define CATCH_METHOD_AS_TEST_CASE( method, name, description ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, name, description )
#define CATCH_REGISTER_TEST_CASE( function, name, description ) INTERNAL_CATCH_REGISTER_TESTCASE( function, name, description )
#define CATCH_SECTION( name, description ) INTERNAL_CATCH_SECTION( name, description )
#define CATCH_FAIL( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "CATCH_FAIL", msg )
#define CATCH_SUCCEED( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "CATCH_SUCCEED", msg )
#endif
#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE( "", "" )

#define CATCH_REGISTER_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType )
#define CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType )

#define CATCH_GENERATE( expr) INTERNAL_CATCH_GENERATE( expr )

// "BDD-style" convenience wrappers
#ifdef CATCH_CONFIG_VARIADIC_MACROS
#define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )
#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
#else
#define CATCH_SCENARIO( name, tags ) CATCH_TEST_CASE( "Scenario: " name, tags )
#define CATCH_SCENARIO_METHOD( className, name, tags ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " name, tags )
#endif
#define CATCH_GIVEN( desc )    CATCH_SECTION( std::string( "Given: ") + desc, "" )
#define CATCH_WHEN( desc )     CATCH_SECTION( std::string( " When: ") + desc, "" )
#define CATCH_AND_WHEN( desc ) CATCH_SECTION( std::string( "  And: ") + desc, "" )
#define CATCH_THEN( desc )     CATCH_SECTION( std::string( " Then: ") + desc, "" )
#define CATCH_AND_THEN( desc ) CATCH_SECTION( std::string( "  And: ") + desc, "" )

// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
#else

#define REQUIRE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal, "REQUIRE" )
#define REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, "REQUIRE_FALSE" )

#define REQUIRE_THROWS( expr ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, "", "REQUIRE_THROWS" )
#define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::Normal, "REQUIRE_THROWS_AS" )
#define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, matcher, "REQUIRE_THROWS_WITH" )
#define REQUIRE_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::Normal, "REQUIRE_NOTHROW" )

#define CHECK( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECK" )
#define CHECK_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, "CHECK_FALSE" )
#define CHECKED_IF( expr ) INTERNAL_CATCH_IF( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECKED_IF" )
#define CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECKED_ELSE" )
#define CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, "CHECK_NOFAIL" )

#define CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, "", "CHECK_THROWS" )
#define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::ContinueOnFailure, "CHECK_THROWS_AS" )
#define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, matcher, "CHECK_THROWS_WITH" )
#define CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECK_NOTHROW" )

#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::ContinueOnFailure, "CHECK_THAT" )
#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::Normal, "REQUIRE_THAT" )

#define INFO( msg ) INTERNAL_CATCH_INFO( msg, "INFO" )
#define WARN( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, "WARN", msg )
#define SCOPED_INFO( msg ) INTERNAL_CATCH_INFO( msg, "INFO" )
#define CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CAPTURE" )
#define SCOPED_CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CAPTURE" )

#ifdef CATCH_CONFIG_VARIADIC_MACROS
#define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
#define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
#define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
#define FAIL( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "FAIL", __VA_ARGS__ )
#define SUCCEED( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "SUCCEED", __VA_ARGS__ )
#else
#define TEST_CASE( name, description ) INTERNAL_CATCH_TESTCASE( name, description )
#define TEST_CASE_METHOD( className, name, description ) INTERNAL_CATCH_TEST_CASE_METHOD( className, name, description )
#define METHOD_AS_TEST_CASE( method, name, description ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, name, description )
#define REGISTER_TEST_CASE( method, name, description ) INTERNAL_CATCH_REGISTER_TESTCASE( method, name, description )
#define SECTION( name, description ) INTERNAL_CATCH_SECTION( name, description )
#define FAIL( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "FAIL", msg )
#define SUCCEED( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "SUCCEED", msg )
#endif
#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE( "", "" )

#define REGISTER_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType )
#define REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType )

#define GENERATE( expr) INTERNAL_CATCH_GENERATE( expr )

#endif

#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )

// "BDD-style" convenience wrappers
#ifdef CATCH_CONFIG_VARIADIC_MACROS
#define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
#else
#define SCENARIO( name, tags ) TEST_CASE( "Scenario: " name, tags )
#define SCENARIO_METHOD( className, name, tags ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " name, tags )
#endif
#define GIVEN( desc )    SECTION( std::string("   Given: ") + desc, "" )
#define WHEN( desc )     SECTION( std::string("    When: ") + desc, "" )
#define AND_WHEN( desc ) SECTION( std::string("And when: ") + desc, "" )
#define THEN( desc )     SECTION( std::string("    Then: ") + desc, "" )
#define AND_THEN( desc ) SECTION( std::string("     And: ") + desc, "" )

using Catch::Detail::Approx;

#endif // TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED


```

`PolyHook/PolyHook.hpp`:

```hpp
#ifndef POLYHOOK_H
#define POLYHOOK_H
#include <windows.h>
#include "../Capstone/include/capstone.h"
#include <DbgHelp.h>
#include <string>
#include <vector>
#include <mutex>
#include <algorithm>
#include <utility>
#include <TlHelp32.h>
#include <assert.h>
#pragma comment(lib,"Dbghelp.lib")
#pragma comment(lib,"capstone.lib")
#define PLH_SHOW_DEBUG_MESSAGES 1 //To print messages even in release

namespace PLH {
	namespace Tools
	{
		inline void XTrace(const char* fmt, ...)
		{
			va_list args;
			va_start(args, fmt);
#if defined(_DEBUG) || defined(PLH_SHOW_DEBUG_MESSAGES)
			vfprintf_s(stdout, fmt, args);
#endif
			va_end(args);
		}

		class ThreadHandle
		{
		public:
			//Thread ID, OpenThread's AccessFlag 
			ThreadHandle(DWORD ThreadId, DWORD  DesiredAccessFlags) : m_ThreadId(ThreadId), m_IsSuspended(false)
			{
				m_hThread = OpenThread(DesiredAccessFlags, FALSE, ThreadId);
				if(m_hThread == NULL)
					throw "PolyHook: Failed to open thread in class ThreadHandle";
			}

			//Only allow once instance to control a handle
			ThreadHandle(const ThreadHandle& other) = delete; //copy
			ThreadHandle& operator=(const ThreadHandle& other) = delete; //copy assignment

			//Move
			ThreadHandle(ThreadHandle &&other) noexcept
				: m_IsSuspended(other.m_IsSuspended)
				, m_hThread(other.m_hThread)
				, m_ThreadId(other.m_ThreadId)
			{
				other.m_hThread = nullptr;
				other.m_IsSuspended = false;
			}

			//Move assignment
			ThreadHandle& operator=(ThreadHandle &&other) noexcept
			{
				if (this != &other)
				{
					m_IsSuspended = other.m_IsSuspended;
					m_hThread = other.m_hThread;
					m_ThreadId = other.m_ThreadId;

					other.m_hThread = nullptr;
					other.m_IsSuspended = false;
				}
				return *this;
			}


			//false resumes, true suspends
			void ToggleSuspend(bool Suspend)
			{
				if (Suspend && !m_IsSuspended)
				{
					if(SuspendThread(m_hThread) != -1)
						m_IsSuspended = true;
				}else if (!Suspend && m_IsSuspended){
					if(ResumeThread(m_hThread) != -1)
						m_IsSuspended = false;
				}
			}

			~ThreadHandle()
			{
				if (m_IsSuspended)
					ToggleSuspend(false);

				if (m_hThread)
					CloseHandle(m_hThread);
			}
		private:
			bool m_IsSuspended;
			HANDLE m_hThread;
			DWORD m_ThreadId;
		};

		class ThreadManager
		{
		public:
			void SuspendThreads()
			{
				UpdateThreadList(GetCurrentThreadId());
				for (ThreadHandle& ThreadInstance : m_SuspendedThreads)
				{
					ThreadInstance.ToggleSuspend(true);
				}
			}

			void ResumeThreads()
			{
				for (ThreadHandle& ThreadInstance : m_SuspendedThreads)
				{
					ThreadInstance.ToggleSuspend(false);
				}
			}
		private:
			void UpdateThreadList(DWORD CallingThreadId)
			{
				m_SuspendedThreads.clear();
				HANDLE h = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
				if (h == INVALID_HANDLE_VALUE)
					return;

				THREADENTRY32 te;
				te.dwSize = sizeof(te);
				BOOL Result = FALSE;
				//Loop threads
				for (Result = Thread32First(h, &te), te.dwSize = sizeof(te); Result == TRUE && Thread32Next(h, &te); )
				{
					//Verify size field was set properly
					if (te.dwSize < RTL_SIZEOF_THROUGH_FIELD(THREADENTRY32, th32OwnerProcessID))
						continue;
					
					if (te.th32ThreadID != CallingThreadId && te.th32OwnerProcessID == GetCurrentProcessId())
						m_SuspendedThreads.emplace_back(te.th32ThreadID, THREAD_SUSPEND_RESUME);
				}
				CloseHandle(h);
			}
			std::vector<Tools::ThreadHandle> m_SuspendedThreads;
		};

		inline void* Allocate_2GB_IMPL(uint8_t* pStart,size_t Size,int_fast64_t Delta)
		{
			/*These lambda's let us use a single for loop for both the forward and backward loop conditions.
			I passed delta variable as a parameter instead of capturing it because it is faster, it allows
			the compiler to optimize the lambda into a function pointer rather than constructing
			an anonymous class and incur the extra overhead that involves (negligible overhead but why not optimize)*/
			auto Incrementor = [](int_fast64_t Delta,MEMORY_BASIC_INFORMATION& mbi) -> uintptr_t{
				if (Delta > 0)
					return (uintptr_t)mbi.BaseAddress + mbi.RegionSize;
				else
					return (uintptr_t)mbi.BaseAddress - 1; //TO-DO can likely jump much more than 1 byte, figure out what the max is
			};

			auto Comparator = [](long long int Delta,uintptr_t Addr, uintptr_t End)->bool {
				if (Delta > 0)
					return Addr < End;
				else
					return Addr > End;
			};

			//Start at pStart, search 2GB around it (up/down depending on Delta)
			MEMORY_BASIC_INFORMATION mbi;
			for (uintptr_t Addr = (uintptr_t)pStart; Comparator(Delta,Addr, (uintptr_t)pStart + Delta); Addr = Incrementor(Delta,mbi))
			{
				if (!VirtualQuery((LPCVOID)Addr, &mbi, sizeof(mbi)))
					break;

				assert(mbi.RegionSize != 0);

				if (mbi.State != MEM_FREE)
					continue;

				//VirtualAlloc requires 64k aligned addresses
				void* PageBase = (uint8_t*)mbi.BaseAddress - LOWORD(mbi.BaseAddress);
				if (void* Allocated = (uint8_t*)VirtualAlloc(PageBase, Size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE))
					return Allocated;
			}
			return nullptr;
		}

		inline void* AllocateWithin2GB(uint8_t* pStart, size_t Size, size_t& AllocationDelta)
		{
			static const size_t MaxAllocationDelta = 0x80000000; //2GB

			//Attempt to allocate +-2GB from pStart
			AllocationDelta = 0;
			void* Allocated = nullptr;
			Allocated = Tools::Allocate_2GB_IMPL(pStart, Size, (~MaxAllocationDelta) + 1); //Search down first (-2GB) 

			//If search down found nothing
			if (Allocated == nullptr)
				Allocated = Tools::Allocate_2GB_IMPL(pStart, Size, MaxAllocationDelta); //Search up (+2GB)
	
			//Sanity check the delta is less than 2GB
			if (Allocated != nullptr)
			{
				AllocationDelta = std::abs(pStart - Allocated);
				if (AllocationDelta > MaxAllocationDelta)
				{
					//Out of range, free then return
					VirtualFree(Allocated, 0, MEM_RELEASE);
					return nullptr;
				}
			}
			return Allocated;
		}
	}

	class ASMHelper
	{
	public:
		enum DISP
		{
			D_INT64 = 8,
			D_INT32 = 4,
			D_INT16 = 2,
			D_INT8 = 1,
			D_INVALID = -1
		};
		DISP GetDisplacementType(const uint8_t DispVal)
		{
			switch (DispVal)
			{
			case 1:
				return DISP::D_INT8;
			case 2:
				return DISP::D_INT16;
			case 4:
				return DISP::D_INT32;
			case 8:
				return DISP::D_INT64;
			default:
				return DISP::D_INVALID;
			}
		}
		bool IsConditionalJump(const uint8_t* bytes,const uint16_t Size)
		{
			//http://unixwiz.net/techtips/x86-jumps.html
			if (Size < 1)
				return false;

			if (bytes[0] == 0x0F && Size > 1)
			{
				if (bytes[1] >= 0x80 && bytes[1] <= 0x8F)
					return true;
			}

			if (bytes[0] >= 0x70 && bytes[0] <= 0x7F)
				return true;

			if (bytes[0] == 0xE3)
				return true;

			return false;
		}

		template<typename T>
		T GetDisplacement(uint8_t* Instruction, const uint32_t Offset)
		{
			T Disp;
			memset(&Disp, 0x00, sizeof(T));
			memcpy(&Disp, &Instruction[Offset], sizeof(T));
			return Disp;
		}
	};

	class RuntimeError
	{
	public:
		enum class Severity
		{
			Warning, //Might have an issue
			Critical, //Definitely have an issue, but it's not serious
			UnRecoverable, //Definitely have an issue, it's serious
			NoError //Default
		};
		RuntimeError();
		RuntimeError(Severity Sev, const std::string& Msg);
		virtual ~RuntimeError() = default;
		const Severity GetSeverity() const;
		const std::string GetString() const;
	private:
		Severity m_Severity;
		std::string m_Message;
	};

	enum class HookType
	{
		X86Detour,
		X64Detour,
		VFuncSwap,
		VFuncDetour,
		VTableSwap,
		IAT,
		VEH,
		UNKNOWN
	};
	class IHook
	{
	public:
		IHook() = default;
		IHook(IHook&& other) = default; //move
		IHook& operator=(IHook&& other) = default;//move assignment
		IHook(const IHook& other) = delete; //copy
		IHook& operator=(const IHook& other) = delete; //copy assignment
		virtual ~IHook() = default;

		virtual bool Hook() = 0;
		virtual void UnHook() = 0;
		virtual HookType GetType() = 0;

		virtual RuntimeError GetLastError() const;
		virtual void PrintError(const RuntimeError& Err) const;
	protected:
		virtual void PostError(const RuntimeError& Err);

		RuntimeError m_LastError;
	};

	class AbstractDetour :public IHook
	{
	public:
		AbstractDetour();
		AbstractDetour(const AbstractDetour& other) = delete;
		AbstractDetour& operator=(const AbstractDetour& other) = delete;
		virtual ~AbstractDetour();

		template<typename T>
		void SetupHook(T* Src, T* Dest)
		{
			SetupHook((uint8_t*)Src, (uint8_t*)Dest);
		}
		void SetupHook(uint8_t* Src, uint8_t* Dest);

		virtual void UnHook() override;

		template<typename T>
		T GetOriginal()
		{
			return (T)m_Trampoline;
		}
	protected:
		template<typename T>
		T CalculateRelativeDisplacement(uintptr_t From,uintptr_t To, uint_fast32_t InsSize)
		{
			if (To < From)
				return 0 - (From - To) - InsSize;
			return To - (From + InsSize);
		}
		uint_fast32_t CalculateLength(uint8_t* Src, uint_fast32_t NeededLength);
		void RelocateASM(uint8_t* Code, uint_fast32_t* CodeSize, const uintptr_t From, const uintptr_t To);
		void _Relocate(cs_insn* CurIns, const uintptr_t From, const uintptr_t To, const uint8_t DispSize, const uint8_t DispOffset);
		void RelocateConditionalJMP(cs_insn* CurIns, uint_fast32_t* CodeSize, const uintptr_t From, const uintptr_t To, const uint8_t DispSize, const uint8_t DispOffset);
		virtual x86_reg GetIpReg() = 0;
		virtual void FreeTrampoline() = 0;
		virtual void WriteJMP(uintptr_t From, uintptr_t To) = 0;
		virtual int GetJMPSize() = 0;
		void FlushSrcInsCache();
		void Initialize(cs_mode Mode);
		csh m_CapstoneHandle;
		ASMHelper m_ASMInfo;

		uint8_t m_OriginalCode[64];
		uint_fast32_t m_OriginalLength;
		uint8_t* m_Trampoline;
		bool m_NeedFree;
		bool m_Hooked;
		uint8_t* m_hkSrc;
		uint8_t* m_hkDest;
		uint_fast32_t m_hkLength;
		cs_mode m_CapMode;
	};

#ifndef _WIN64
#define Detour X86Detour
	//x86 5 Byte Detour
	class X86Detour :public AbstractDetour
	{
	public:
		friend class VFuncDetour;
		X86Detour();
		X86Detour(X86Detour&& other) = default; //move
		X86Detour& operator=(X86Detour&& other) = default;//move assignment
		X86Detour(const X86Detour& other) = delete; //copy
		X86Detour& operator=(const X86Detour& other) = delete; //copy assignment
		virtual ~X86Detour();

		virtual bool Hook() override;
		virtual HookType GetType() override;
	protected:
		virtual x86_reg GetIpReg() override;
		virtual void FreeTrampoline();
		virtual void WriteJMP(uintptr_t From, uintptr_t To);
		virtual int GetJMPSize();
	private:
		void WriteRelativeJMP(uintptr_t Destination, uintptr_t JMPDestination);
		void WriteAbsoluteJMP(uintptr_t Destination, uintptr_t JMPDestination);
	};
#else
#define Detour X64Detour
	//X64 6 Byte Detour
	class X64Detour :public AbstractDetour
	{
	public:
		friend class VFuncDetour;
		//Credits DarthTon, evolution536
		X64Detour();
		X64Detour(X64Detour&& other) = default; //move
		X64Detour& operator=(X64Detour&& other) = default;//move assignment
		X64Detour(const X64Detour& other) = delete; //copy
		X64Detour& operator=(const X64Detour& other) = delete; //copy assignment
		virtual ~X64Detour();

		virtual bool Hook() override;
		virtual HookType GetType() override;
	protected:
		virtual x86_reg GetIpReg() override;
		virtual void FreeTrampoline() override;
		virtual void WriteJMP(const uintptr_t From,const uintptr_t To) override;
		virtual int GetJMPSize() override;
	private:
		void WriteAbsoluteJMP(const uintptr_t Destination,const uintptr_t JMPDestination);
	};
#endif //END _WIN64 IFDEF

	//Swap Virtual Function Pointer to Destination
	class VFuncSwap : public IHook
	{
	public:
		VFuncSwap();
		VFuncSwap(VFuncSwap&& other) = default;
		VFuncSwap& operator=(VFuncSwap&& other) = default;
		VFuncSwap(const VFuncSwap& other) = delete;
		VFuncSwap& operator=(const VFuncSwap& other) = delete;
		virtual ~VFuncSwap();

		virtual bool Hook() override;
		virtual void UnHook() override;
		virtual HookType GetType() override;

		void SetupHook(uint8_t** Vtable, const uint_fast16_t Index, uint8_t* Dest);
		template<typename T>
		T GetOriginal()
		{
			return (T)m_OrigVFunc;
		}
	private:
		uint8_t** m_hkVtable;
		uint8_t* m_hkDest;
		uint8_t* m_OrigVFunc;
		uint_fast16_t m_hkIndex;
		bool m_Hooked;
	};

	//Detour the Function the VTable Points to
	class VFuncDetour :public IHook
	{
	public:
		VFuncDetour();
		VFuncDetour(VFuncDetour&& other) = default; //move
		VFuncDetour& operator=(VFuncDetour&& other) = default;//move assignment
		VFuncDetour(const VFuncDetour& other) = delete; //copy
		VFuncDetour& operator=(const VFuncDetour& other) = delete; //copy assignment
		virtual ~VFuncDetour();

		virtual bool Hook() override;
		virtual void UnHook() override;
		virtual HookType GetType() override;

		void SetupHook(uint8_t** Vtable, const uint_fast16_t Index, uint8_t* Dest);
		template<typename T>
		T GetOriginal()
		{
			return m_Detour->GetOriginal<T>();
		}
		virtual RuntimeError GetLastError() const override;
	protected:
		virtual void PostError(const RuntimeError& Err) override;
	private:
		std::unique_ptr<Detour> m_Detour;
		/*We don't need an m_Hooked bool because this 
		detour object above handles the unhook on destruction by itself*/
	};

	//Credit to Dogmatt on unknowncheats.me for IsValidPtr
#ifdef _WIN64
#define _PTR_MAX_VALUE ((void*)0x000F000000000000)
#else
#define _PTR_MAX_VALUE ((void*)0xFFF00000)
#endif
	inline bool IsValidPtr(void* p) { return (p >= (void*)0x10000) && (p < _PTR_MAX_VALUE) && p != nullptr; }

	class VTableSwap : public IHook
	{
	public:
		VTableSwap();
		VTableSwap(VTableSwap&& other) = default; //move
		VTableSwap& operator=(VTableSwap&& other) = default;//move assignment
		VTableSwap(const VTableSwap& other) = delete; //copy
		VTableSwap& operator=(const VTableSwap& other) = delete; //copy assignment
		virtual ~VTableSwap();

		virtual bool Hook() override;
		virtual HookType GetType() override;

		template<typename T>
		T HookAdditional(const uint_fast16_t Index, uint8_t* Dest)
		{
			//The makes sure we called Hook first
			if (!m_NeedFree)
				return nullptr;

			m_NewVtable[Index] = Dest;
			return (T)m_OrigVtable[Index];
		}
		virtual void UnHook() override;
		void SetupHook(uint8_t* pClass, const uint_fast16_t Index, uint8_t* Dest);
		template<typename T>
		T GetOriginal()
		{
			return (T)m_hkOriginal;
		}
	private:
		uint_fast16_t GetVFuncCount(uint8_t** pVtable);
		void FreeNewVtable();
		uint8_t** m_NewVtable;
		uint8_t** m_OrigVtable;
		uint8_t*** m_phkClass;
		uint8_t*  m_hkDest;
		uint8_t*  m_hkOriginal;
		uint_fast16_t    m_hkIndex;
		uint_fast16_t    m_VFuncCount;
		bool m_NeedFree;
		bool m_Hooked;
	};

#define ResolveRVA(base,rva) (( (uint8_t*)base) +rva)
	class IATHook:public IHook
	{
	public:
		IATHook();
		IATHook(IATHook&& other) = default; //move
		IATHook& operator=(IATHook&& other) = default;//move assignment
		IATHook(const IATHook& other) = delete; //copy
		IATHook& operator=(const IATHook& other) = delete; //copy assignment
		virtual ~IATHook();

		virtual bool Hook() override;
		virtual void UnHook() override;
		virtual HookType GetType() override;

		template<typename T>
		T GetOriginal()
		{
			return (T)m_pIATFuncOrig;
		}
		void SetupHook(const char* LibraryName,const char* SrcFunc, uint8_t* Dest,const char* Module = "");
	private:
		bool FindIATFunc(const char* LibraryName,const char* FuncName,PIMAGE_THUNK_DATA* pFuncThunkOut,const char* Module = "");
		std::string m_hkSrcFunc;
		std::string m_hkLibraryName;
		std::string m_hkModuleName;
		uint8_t* m_hkDest;
		void* m_pIATFuncOrig;
		bool m_Hooked;
	};

	template<typename Func>
	class FinalAction {
	public:
		FinalAction(Func f) :FinalActionFunc(std::move(f)) {}
		~FinalAction()
		{
			FinalActionFunc();
		}
	private:
		Func FinalActionFunc;

		/*Uses RAII to call a final function on destruction
		C++ 11 version of java's finally (kindof)*/
	};

	template <typename F>
	FinalAction<F> finally(F f) {
		return FinalAction<F>(f);
	}

	class MemoryProtect
	{
	public:
		MemoryProtect(void* Address, size_t Size, DWORD ProtectionFlags);
		~MemoryProtect();
	private:
		bool Protect(void* Address, size_t Size, DWORD ProtectionFlags);
		void* m_Address;
		size_t m_Size;
		DWORD m_Flags;
		DWORD m_OldProtection;
	};

	class VEHHook : public IHook
	{
	public:
		enum class VEHMethod
		{
			INT3_BP,
			HARDWARE_BP,
			GUARD_PAGE,
			ERROR_TYPE
		};
		VEHHook();
		VEHHook(VEHHook&& other) = default; //move
		VEHHook& operator=(VEHHook&& other) = default;//move assignment
		VEHHook(const VEHHook& other) = delete; //copy
		VEHHook& operator=(const VEHHook& other) = delete; //copy assignment
		virtual ~VEHHook();

		virtual bool Hook() override;
		virtual void UnHook() override;
		virtual HookType GetType() override;

		template<typename T>
		T GetOriginal()
		{
			return (T)m_ThisCtx.m_Src;
		}
		void SetupHook(uint8_t* Src, uint8_t* Dest, VEHMethod Method);

		auto GetProtectionObject()
		{
			//Return an object to restore INT3_BP after callback is done
			return finally([&]() {
				if (m_ThisCtx.m_Type == VEHMethod::INT3_BP)
				{
					MemoryProtect Protector(m_ThisCtx.m_Src, 1, PAGE_EXECUTE_READWRITE);
					*m_ThisCtx.m_Src = 0xCC;
				}else if (m_ThisCtx.m_Type == VEHMethod::GUARD_PAGE) {
					DWORD OldProtection;
					VirtualProtect(m_ThisCtx.m_Src, 1, PAGE_EXECUTE_READWRITE | PAGE_GUARD, &OldProtection);
				}
			});
		}
	protected:
		struct HookCtx {
			VEHMethod m_Type;
			uint8_t* m_Src;
			uint8_t* m_Dest;
			uint8_t m_StorageByte;
			/*Different methods store different things in this byte,
			INT3_BP = hold the byte overwritten
			HARDWARE_BP = the index of the debug register we used
			GUARD_PAGE = unused*/

			HookCtx(uint8_t* Src, uint8_t* Dest, VEHMethod Method)
			{
				m_Dest = Dest;
				m_Src = Src;
				m_Type = Method;
			}

			HookCtx()
			{
				m_Type = VEHMethod::ERROR_TYPE;
			}

			friend bool operator==(const HookCtx& Ctx1, const HookCtx& Ctx2)
			{
				if (Ctx1.m_Dest == Ctx2.m_Dest && Ctx1.m_Src == Ctx2.m_Src && Ctx1.m_Type == Ctx2.m_Type)
					return true;
				return false;
			}
		};
	private:
		static bool AreInSamePage(const uint8_t* Addr1,const uint8_t* Addr2);
		static LONG CALLBACK VEHHandler(EXCEPTION_POINTERS* ExceptionInfo);
		static std::vector<HookCtx> m_HookTargets;
		static std::mutex m_TargetMutex;
		HookCtx m_ThisCtx;
		DWORD m_PageSize;
		bool m_Hooked;
	};
}


////////////////////////////////BEGIN IMPLEMENTATION////////////////////////////////
/*Until C++xy release modules I will keep the implementation in the header. This is
a design decision to make it easier for a user to include PolyHook. Since polyhook
relies on capstone, which requires .lib and .h files of it's own, i want to avoid
compiling polyhook into a .lib. This way a user simply includes polyhook.h, and sets
their dependency directories to point to capstone. If compilation speed is an issue
it is trivial to separate the implementation by manually C&P-ing the below lines
into a seperate .cpp.*/

PLH::RuntimeError::RuntimeError()
{
	m_Message = "";
	m_Severity = Severity::NoError;
}

PLH::RuntimeError::RuntimeError(Severity Sev, const std::string& Msg)
{
	m_Severity = Sev;
	m_Message = Msg;
}

const std::string PLH::RuntimeError::GetString() const
{
	return m_Message;
}

const PLH::RuntimeError::Severity PLH::RuntimeError::GetSeverity() const
{
	return m_Severity;
}

void PLH::IHook::PostError(const RuntimeError& Err)
{
	m_LastError = Err;
	PLH::Tools::XTrace("Posted Error [SEVERITY:%d]:\n"
		"%s\n", Err.GetSeverity(), Err.GetString().c_str());
}

void PLH::IHook::PrintError(const RuntimeError& Err) const
{
	std::string Severity = "";
	switch (Err.GetSeverity())
	{
	case PLH::RuntimeError::Severity::Warning:
		Severity = "Warning";
		break;
	case PLH::RuntimeError::Severity::Critical:
		Severity = "Critical";
		break;
	case PLH::RuntimeError::Severity::UnRecoverable:
		Severity = "UnRecoverable";
		break;
	case PLH::RuntimeError::Severity::NoError:
		Severity = "No Error";
		break;
	default:
		Severity = "Unknown";
	}
	PLH::Tools::XTrace("SEVERITY:[%s] %s\n", Severity.c_str(),
		Err.GetString().c_str());
}

PLH::RuntimeError PLH::IHook::GetLastError() const
{
	return m_LastError;
}

PLH::AbstractDetour::AbstractDetour() :IHook(), m_NeedFree(false), m_Hooked(false)
{
#ifdef _WIN64
	Initialize(CS_MODE_64);
#else
	Initialize(CS_MODE_32);
#endif // _WIN64
}

PLH::AbstractDetour::~AbstractDetour()
{
	cs_close(&m_CapstoneHandle);
}

void PLH::AbstractDetour::SetupHook(uint8_t* Src, uint8_t* Dest)
{
	m_hkSrc = Src;
	m_hkDest = Dest;
}

void PLH::AbstractDetour::UnHook()
{
	MemoryProtect Protector(m_hkSrc, m_hkLength, PAGE_EXECUTE_READWRITE);
	memcpy(m_hkSrc, m_OriginalCode, m_OriginalLength); //Copy original from trampoline back to src
	FlushSrcInsCache();
	FreeTrampoline();
	m_Hooked = false;
}

uint_fast32_t PLH::AbstractDetour::CalculateLength(uint8_t* Src, uint_fast32_t NeededLength)
{
	//Grab First 100 bytes of function, disasm until invalid instruction
	cs_insn* InstructionInfo;
	size_t InstructionCount = cs_disasm(m_CapstoneHandle, Src, 0x100, (uintptr_t)Src, 0, &InstructionInfo);

	//Loop over instructions until we have at least NeededLength's Size
	PLH::Tools::XTrace("\nORIGINAL:\n");
	uint_fast32_t InstructionSize = 0;
	bool BigEnough = false;
	for (uint_fast32_t i = 0; i < InstructionCount && !BigEnough; i++)
	{
		cs_insn* CurIns = (cs_insn*)&InstructionInfo[i];
		InstructionSize += CurIns->size;
		if (InstructionSize >= NeededLength)
			BigEnough = true;

		PLH::Tools::XTrace("%I64X [%d]: ", CurIns->address, CurIns->size);
		for (uint_fast32_t j = 0; j < CurIns->size; j++)
			PLH::Tools::XTrace("%02X ", CurIns->bytes[j]);
		PLH::Tools::XTrace("%s %s\n", CurIns->mnemonic, CurIns->op_str);
	}
	if (!BigEnough)
		InstructionSize = 0;

	cs_free(InstructionInfo, InstructionCount);
	return InstructionSize;
}

void PLH::AbstractDetour::RelocateASM(uint8_t* Code, uint_fast32_t* CodeSize, const uintptr_t From, const uintptr_t To)
{
	cs_insn* InstructionInfo;
	size_t InstructionCount = cs_disasm(m_CapstoneHandle, Code, *CodeSize, (uintptr_t)Code, 0, &InstructionInfo);

	PLH::Tools::XTrace("\nTrampoline:\n");
	for (uint_fast32_t i = 0; i < InstructionCount; i++)
	{
		cs_insn* CurIns = (cs_insn*)&InstructionInfo[i];
		cs_x86* x86 = &(CurIns->detail->x86);

		PLH::Tools::XTrace("%I64X: ", CurIns->address);
		for (uint_fast32_t j = 0; j < CurIns->size; j++)
			PLH::Tools::XTrace("%02X ", CurIns->bytes[j]);
		PLH::Tools::XTrace("%s %s\n", CurIns->mnemonic, CurIns->op_str);

		for (uint_fast32_t j = 0; j < x86->op_count; j++)
		{
			cs_x86_op* op = &(x86->operands[j]);
			if (op->type == X86_OP_MEM)
			{
				//MEM are types like lea rcx,[rip+0xdead]
				if (op->mem.base == X86_REG_INVALID)
					continue;

				//Are we relative to instruction pointer?
				if (op->mem.base != GetIpReg())
					continue;

				_Relocate(CurIns, From, To, x86->offsets.displacement_size, x86->offsets.displacement_offset);
			}
			else if (op->type == X86_OP_IMM) {
				//IMM types are like call 0xdeadbeef
				if (x86->op_count > 1) //exclude types like sub rsp,0x20
					continue;

				char* mnemonic = CurIns->mnemonic;
				if (m_ASMInfo.IsConditionalJump(CurIns->bytes, CurIns->size))
				{
					RelocateConditionalJMP(CurIns, CodeSize, From, To, x86->offsets.imm_size, x86->offsets.imm_offset);
					continue;
				}

				//types like push 0x20 slip through, check mnemonic
				if (strcmp(mnemonic, "call") != 0 && strcmp(mnemonic, "jmp") != 0) //probably more types than just these, update list as they're found
					continue;

				_Relocate(CurIns, From, To, x86->offsets.imm_size, x86->offsets.imm_offset);
			}
		}
	}

	PLH::Tools::XTrace("\nFixed Trampoline\n");
	InstructionCount = cs_disasm(m_CapstoneHandle, Code, *CodeSize, (uint64_t)Code, 0, &InstructionInfo);
	for (int i = 0; i < InstructionCount; i++)
	{
		cs_insn* CurIns = (cs_insn*)&InstructionInfo[i];

		PLH::Tools::XTrace("%I64X: ", CurIns->address);
		for (int j = 0; j < CurIns->size; j++)
			PLH::Tools::XTrace("%02X ", CurIns->bytes[j]);
		PLH::Tools::XTrace("%s %s\n", CurIns->mnemonic, CurIns->op_str);
	}
	cs_free(InstructionInfo, InstructionCount);
}

void PLH::AbstractDetour::_Relocate(cs_insn* CurIns, const uintptr_t From, const uintptr_t To, const uint8_t DispSize, const uint8_t DispOffset)
{
	PLH::Tools::XTrace("Relocating...\n");

	ASMHelper::DISP DispType = m_ASMInfo.GetDisplacementType(DispSize);
	if (DispType == ASMHelper::DISP::D_INT8)
	{
		int8_t Disp = m_ASMInfo.GetDisplacement<int8_t>(CurIns->bytes, DispOffset);
		Disp -= (To - From);
		*(int8_t*)(CurIns->address + DispOffset) = Disp;
	}
	else if (DispType == ASMHelper::DISP::D_INT16) {
		int16_t Disp = m_ASMInfo.GetDisplacement<int16_t>(CurIns->bytes, DispOffset);
		Disp -= (To - From);
		*(int16_t*)(CurIns->address + DispOffset) = Disp;
	}
	else if (DispType == ASMHelper::DISP::D_INT32) {
		int32_t Disp = m_ASMInfo.GetDisplacement<int32_t>(CurIns->bytes, DispOffset);
		Disp -= (To - From);
		*(int32_t*)(CurIns->address + DispOffset) = Disp;
	}
}

void PLH::AbstractDetour::FlushSrcInsCache()
{
	/*This method is just a precaution, on x86/x64 it is usually a no-op,
	on other platforms it may be required (ARM i believe?)*/

	//Flush overwritten original
	FlushInstructionCache(GetCurrentProcess(), m_hkSrc, m_OriginalLength);

	//Flush trampoline
	FlushInstructionCache(GetCurrentProcess(), m_Trampoline, m_hkLength);
}

void PLH::AbstractDetour::Initialize(cs_mode Mode)
{
	if (cs_open(CS_ARCH_X86, Mode, &m_CapstoneHandle) != CS_ERR_OK)
		PLH::Tools::XTrace("Error Initializing Capstone x86\n");

	cs_option(m_CapstoneHandle, CS_OPT_DETAIL, CS_OPT_ON);
}

void PLH::AbstractDetour::RelocateConditionalJMP(cs_insn* CurIns, uint_fast32_t* CodeSize, const uintptr_t From, const uintptr_t To, const uint8_t DispSize, const uint8_t DispOffset)
{
	/*This function automatically begins to build a jump table at the end of the trampoline to allow relative jumps to function properly:
	-Changes relative jump to point to an absolute jump
	-Absolute jump then does the long distance to jump to where the relative jump originally went
	*/
	ASMHelper::DISP DispType = m_ASMInfo.GetDisplacementType(DispSize);
	uintptr_t TrampolineEnd = To + (*CodeSize);
	if (DispType == ASMHelper::DISP::D_INT8)
	{
		int8_t Disp = m_ASMInfo.GetDisplacement<int8_t>(CurIns->bytes, DispOffset);
		uintptr_t OriginalDestination = CurIns->address + (Disp - (To - From)) + CurIns->size;
		WriteJMP(TrampolineEnd, OriginalDestination);
		Disp = CalculateRelativeDisplacement<int8_t>(CurIns->address, TrampolineEnd, CurIns->size); //set relative jmp to go to our absolute
		*(int8_t*)(CurIns->address + DispOffset) = Disp;
		(*CodeSize) += GetJMPSize();
	}
	else if (DispType == ASMHelper::DISP::D_INT16) {
		int16_t Disp = Disp = m_ASMInfo.GetDisplacement<int16_t>(CurIns->bytes, DispOffset);
		uintptr_t OriginalDestination = CurIns->address + (Disp - (To - From)) + CurIns->size;
		WriteJMP(TrampolineEnd, OriginalDestination);
		Disp = CalculateRelativeDisplacement<int16_t>(CurIns->address, TrampolineEnd, CurIns->size);
		*(int16_t*)(CurIns->address + DispOffset) = Disp;
		(*CodeSize) += GetJMPSize();
	}
	else if (DispType == ASMHelper::DISP::D_INT32) {
		int32_t Disp = Disp = m_ASMInfo.GetDisplacement<int32_t>(CurIns->bytes, DispOffset);
		uintptr_t OriginalDestination = CurIns->address + (Disp - (To - From)) + CurIns->size;
		WriteJMP(TrampolineEnd, OriginalDestination);
		Disp = CalculateRelativeDisplacement<int32_t>(CurIns->address, TrampolineEnd, CurIns->size);
		*(int32_t*)(CurIns->address + DispOffset) = Disp;
		(*CodeSize) += GetJMPSize();
	}
}

/*----------------------------------------------*/
#ifndef _WIN64
PLH::X86Detour::X86Detour() : AbstractDetour()
{

}

PLH::X86Detour::~X86Detour()
{
	if (m_Hooked)
		UnHook();

	if (m_NeedFree)
		FreeTrampoline();
}

PLH::HookType PLH::X86Detour::GetType()
{
	return PLH::HookType::X86Detour;
}

bool PLH::X86Detour::Hook()
{
	DWORD OldProtection;

	m_hkLength = CalculateLength(m_hkSrc, 5);
	m_OriginalLength = m_hkLength;
	if (m_hkLength == 0)
	{
		PLH::Tools::XTrace("Function to small to hook\n");
		return false;
	}

	//TODO: Add single step support in case processes EIP is on/in the section we write to
	Tools::ThreadManager ThreadMngr;
	ThreadMngr.SuspendThreads();

	m_Trampoline = new uint8_t[m_hkLength + 30];   //Allocate Space for original plus extra to jump back and for jmp table
	m_NeedFree = true;
	VirtualProtect(m_Trampoline, m_hkLength + 30, PAGE_EXECUTE_READWRITE, &OldProtection); //Allow Execution

	memcpy(m_OriginalCode, m_hkSrc, m_hkLength);
	memcpy(m_Trampoline, m_hkSrc, m_hkLength); //Copy original into allocated space
	WriteAbsoluteJMP((uintptr_t)&m_Trampoline[m_hkLength], (uintptr_t)m_hkSrc + m_hkLength); //JMP back to original code, use absolute so we don't accidentally relocate it
	m_hkLength += 6; //Size of above jump
	RelocateASM(m_Trampoline, &m_hkLength, (uintptr_t)m_hkSrc, (uintptr_t)m_Trampoline);

	//Change protection to allow write on original function
	MemoryProtect Protector(m_hkSrc, m_hkLength, PAGE_EXECUTE_READWRITE);
	//Encode Jump from Hooked Function to the Destination function
	WriteRelativeJMP((uintptr_t)m_hkSrc, (uintptr_t)m_hkDest);

	//Write nops over bytes of overwritten instructions
	for (uint_fast16_t i = 5; i < m_OriginalLength; i++)
		m_hkSrc[i] = 0x90;

	ThreadMngr.ResumeThreads();
	FlushSrcInsCache();
	m_Hooked = true;
	PostError(RuntimeError(RuntimeError::Severity::Warning, "PolyHook x86Detour: Some opcodes may not be relocated properly"));
	return true;
	/*Original
	-JMP Destination
	-NOP (extends to length of overwritten opcode)
	-Rest of function

	Destination
	-Do your shit
	-Return Trampoline (goes to trampoline)

	Trampoline
	-Execute Overwritten Opcodes
	-Patch original relative jmps to point to jump table (JE Jumptable entry 1)
	-JMP to rest of function (in original)
	-*BEGIN JUMPTABLE*     <- Allows relative conditional jumps to point back to their original location
	-1)JMP to location of relative jmp one
	-2)JMP to location of relative jmp two
	-2)...continue pattern for all relative jmps
	*/
}

x86_reg PLH::X86Detour::GetIpReg()
{
	return X86_REG_EIP;
}

void PLH::X86Detour::FreeTrampoline()
{
	if (m_NeedFree)
	{
		delete[] m_Trampoline;
		m_NeedFree = false;
	}
}

void PLH::X86Detour::WriteAbsoluteJMP(const uintptr_t Destination, const uintptr_t JMPDestination)
{
	/*
	push <addr>
	ret
	*/
	uint8_t detour[] = { 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0xC3 };
	memcpy((uint8_t*)Destination, detour, sizeof(detour));
	*(uintptr_t*)&((uint8_t*)Destination)[1] = JMPDestination;
}

void PLH::X86Detour::WriteRelativeJMP(const uintptr_t Destination, const uintptr_t JMPDestination)
{
	*(uint8_t*)Destination = 0xE9;       //Write jump opcode to jump back to non overwritten code
	*(long*)(Destination + 1) = CalculateRelativeDisplacement<long>(Destination, JMPDestination, 5);
}

void PLH::X86Detour::WriteJMP(const uintptr_t From, const uintptr_t To)
{
	WriteRelativeJMP(From, To);
}

int PLH::X86Detour::GetJMPSize()
{
	return 5;
}
#else
PLH::X64Detour::X64Detour() :AbstractDetour()
{

}

PLH::X64Detour::~X64Detour()
{
	if (m_Hooked)
		UnHook();

	if (m_NeedFree)
		FreeTrampoline();
}

PLH::HookType PLH::X64Detour::GetType()
{
	return PLH::HookType::X64Detour;
}

bool PLH::X64Detour::Hook()
{
	//Allocate Memory as close as possible to src, to minimize chance 32bit displacements will be out of range (for relative jmp type)
	size_t AllocDelta = 0;
	m_Trampoline = (uint8_t*)Tools::AllocateWithin2GB(m_hkSrc, 0x1000, AllocDelta);
	if (m_Trampoline == nullptr)
	{
		PostError(RuntimeError(RuntimeError::Severity::Critical, "PolyHook x64Detour: Could not allocate within +-2GB...Falling Back to any location"));
		m_Trampoline = (uint8_t*)VirtualAlloc(0, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (m_Trampoline == nullptr)
			return false;
	}
	else {
		//Just some debug output
		double DeltaInGB = AllocDelta / 1000000000.0; //How far was our trampoline allocated from the target, in GB
		double DeltaPercentage = DeltaInGB / .5 * 100.0; //Allowed range is +-2GB, see in percentage how close to tolerance we were
		PLH::Tools::XTrace("PolyHook x64Detour: Allocation within +-2GB Succeeded Delta:[%f GB] Percent Tolerance Used[%f %% out of 2GB]\n", DeltaInGB, DeltaPercentage);
	}
	m_NeedFree = true;

	//Decide which jmp type to use based on function size
	bool UseRelativeJmp = false;
	m_hkLength = CalculateLength(m_hkSrc, 16); //More stable 16 byte jmp
	m_OriginalLength = m_hkLength; //We modify hkLength in Relocation routine
	if (m_hkLength == 0)
	{
		UseRelativeJmp = true;
		m_hkLength = CalculateLength(m_hkSrc, 6); //Smaller, less safe 6 byte (jmp could be out of bounds)
		if (m_hkLength == 0)
		{
			PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook x64Detour: Function to small to hook"));
			return false;
		}
	}
	//TO-DO: Add single step support in case processes RIP is on/in the section we write to
	Tools::ThreadManager ThreadMngr;
	ThreadMngr.SuspendThreads();

	memcpy(m_OriginalCode, m_hkSrc, m_hkLength);
	memcpy(m_Trampoline, m_hkSrc, m_hkLength);
	WriteAbsoluteJMP((uintptr_t)&m_Trampoline[m_hkLength], (uintptr_t)m_hkSrc + m_hkLength);
	m_hkLength += 16; //Size of the above absolute jmp
	RelocateASM(m_Trampoline, &m_hkLength, (uintptr_t)m_hkSrc, (uintptr_t)m_Trampoline);
	//Write the jmp from our trampoline back to the original

	// Build a far jump to the Destination function. (jmps not to address pointed at but to the value in the address)
	MemoryProtect Protector(m_hkSrc, m_hkLength, PAGE_EXECUTE_READWRITE);
	int HookSize = 0;
	if (UseRelativeJmp)
	{
		HookSize = 6;
		m_hkSrc[0] = 0xFF;
		m_hkSrc[1] = 0x25;
		//Write 32Bit Displacement from rip
		*(long*)(m_hkSrc + 2) = CalculateRelativeDisplacement<long>((uintptr_t)m_hkSrc, (uintptr_t)&m_Trampoline[m_hkLength + 16], 6);
		*(uintptr_t*)&m_Trampoline[m_hkLength + 16] = (uintptr_t)m_hkDest; //Write the address into memory at [RIP+Displacement]
	}
	else {
		HookSize = 16;
		WriteAbsoluteJMP((uintptr_t)m_hkSrc, (uintptr_t)m_hkDest);
	}
	//Nop Extra bytes from overwritten opcode
	for (uint_fast16_t i = HookSize; i < m_OriginalLength; i++)
		m_hkSrc[i] = 0x90;

	//Done hooking, resume threads and flush cache (cache flush is usually just a no-op)
	ThreadMngr.ResumeThreads();
	FlushInstructionCache(GetCurrentProcess(), m_hkSrc, m_hkLength);
	m_Hooked = true;
	PostError(RuntimeError(RuntimeError::Severity::Warning, "PolyHook x64Detour: Relocation can be out of range"));
	return true;
}

x86_reg PLH::X64Detour::GetIpReg()
{
	return X86_REG_RIP;
}

void PLH::X64Detour::FreeTrampoline()
{
	if (m_NeedFree)
	{
		VirtualFree(m_Trampoline, 0, MEM_RELEASE);
		m_NeedFree = false;
	}
}

void PLH::X64Detour::WriteAbsoluteJMP(const uintptr_t Destination, const uintptr_t JMPDestination)
{
	/*push rax
	mov rax ...   //Address to original
	xchg qword ptr ss:[rsp], rax
	ret*/
	uint8_t detour[] = { 0x50, 0x48, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x87, 0x04, 0x24, 0xC3 };
	memcpy((uint8_t*)Destination, detour, sizeof(detour));
	*(uintptr_t*)&((uint8_t*)Destination)[3] = JMPDestination;
}

void PLH::X64Detour::WriteJMP(const uintptr_t From, const uintptr_t To)
{
	WriteAbsoluteJMP(From, To);
}

int PLH::X64Detour::GetJMPSize()
{
	return 16;
}
#endif

/*----------------------------------------------*/
PLH::HookType PLH::VFuncSwap::GetType()
{
	return PLH::HookType::VFuncSwap;
}

bool PLH::VFuncSwap::Hook()
{
	MemoryProtect Protector(&m_hkVtable[m_hkIndex], sizeof(void*), PAGE_READWRITE);
	m_OrigVFunc = m_hkVtable[m_hkIndex];
	m_hkVtable[m_hkIndex] = m_hkDest;
	m_Hooked = true;
	return true;
}

void PLH::VFuncSwap::UnHook()
{
	MemoryProtect Protector(&m_hkVtable[m_hkIndex], sizeof(void*), PAGE_READWRITE);
	m_hkVtable[m_hkIndex] = m_OrigVFunc;
	m_Hooked = false;
}

void PLH::VFuncSwap::SetupHook(uint8_t** Vtable, const uint_fast16_t Index, uint8_t* Dest)
{
	m_hkVtable = Vtable;
	m_hkDest = Dest;
	m_hkIndex = Index;
}

PLH::VFuncSwap::VFuncSwap() : m_Hooked(false)
{

}

PLH::VFuncSwap::~VFuncSwap()
{
	if (m_Hooked)
		UnHook();
}
/*----------------------------------------------*/
PLH::VFuncDetour::VFuncDetour() :IHook()
{
	m_Detour = std::make_unique<Detour>();
}

PLH::VFuncDetour::~VFuncDetour()
{

}

PLH::HookType PLH::VFuncDetour::GetType()
{
	return PLH::HookType::VFuncDetour;
}

bool PLH::VFuncDetour::Hook()
{
	return m_Detour->Hook();
}

void PLH::VFuncDetour::UnHook()
{
	m_Detour->UnHook();
}

void PLH::VFuncDetour::SetupHook(uint8_t** Vtable, const uint_fast16_t Index, uint8_t* Dest)
{
	m_Detour->SetupHook(Vtable[Index], Dest);
}

PLH::RuntimeError PLH::VFuncDetour::GetLastError() const
{
	return m_Detour->GetLastError();
}

void PLH::VFuncDetour::PostError(const RuntimeError& Err)
{
	m_Detour->PostError(Err);
}
/*----------------------------------------------*/
PLH::VTableSwap::VTableSwap() :IHook(), m_NeedFree(false), m_Hooked(false)
{

}

PLH::VTableSwap::~VTableSwap()
{
	if (m_Hooked)
		UnHook();

	if (m_NeedFree)
		FreeNewVtable();
}

PLH::HookType PLH::VTableSwap::GetType()
{
	return PLH::HookType::VTableSwap;
}

bool PLH::VTableSwap::Hook()
{
	MemoryProtect Protector(m_phkClass, sizeof(void*), PAGE_READWRITE);
	m_OrigVtable = *m_phkClass;
	m_hkOriginal = m_OrigVtable[m_hkIndex];
	m_VFuncCount = GetVFuncCount(m_OrigVtable);
	m_NewVtable = (uint8_t**) new uintptr_t[m_VFuncCount];
	m_NeedFree = true;
	memcpy(m_NewVtable, m_OrigVtable, sizeof(void*)*m_VFuncCount);
	*m_phkClass = m_NewVtable;
	m_NewVtable[m_hkIndex] = m_hkDest;
	m_Hooked = true;
	return true;
}

void PLH::VTableSwap::UnHook()
{
	MemoryProtect Protector(m_phkClass, sizeof(void*), PAGE_READWRITE);
	*m_phkClass = m_OrigVtable;
	FreeNewVtable();
	m_Hooked = false;
}

void PLH::VTableSwap::SetupHook(uint8_t* pClass, const uint_fast16_t Index, uint8_t* Dest)
{
	m_phkClass = (BYTE***)pClass; //ppp is just convenient to work with
	m_hkDest = Dest;
	m_hkIndex = Index;
}

uint_fast16_t PLH::VTableSwap::GetVFuncCount(uint8_t** pVtable)
{
	int FuncCount = 0;
	for (; ; FuncCount++)
	{
		if (!IsValidPtr(pVtable[FuncCount]))
			break;
	}
	return FuncCount;
}

void PLH::VTableSwap::FreeNewVtable()
{
	if (m_NeedFree)
	{
		delete[] m_NewVtable;
		m_NeedFree = false;
	}
}

/*----------------------------------------------*/
PLH::HookType PLH::IATHook::GetType()
{
	return PLH::HookType::IAT;
}

PLH::IATHook::IATHook() : m_Hooked(false)
{

}

PLH::IATHook::~IATHook()
{
	if (m_Hooked)
		UnHook();
}

bool PLH::IATHook::Hook()
{
	PIMAGE_THUNK_DATA Thunk;
	if (!FindIATFunc(m_hkLibraryName.c_str(), m_hkSrcFunc.c_str(), &Thunk, m_hkModuleName.c_str()))
	{
		PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook IATHook: Failed to find import"));
		return false;
	}

	MemoryProtect Protector(Thunk, sizeof(uintptr_t), PAGE_EXECUTE_READWRITE);
	m_pIATFuncOrig = (void*)Thunk->u1.Function;
	Thunk->u1.Function = (uintptr_t)m_hkDest;
	m_Hooked = true;
	return true;
}

void PLH::IATHook::UnHook()
{
	PIMAGE_THUNK_DATA Thunk;
	if (!FindIATFunc(m_hkLibraryName.c_str(), m_hkSrcFunc.c_str(), &Thunk))
		return;

	MemoryProtect Protector(Thunk, sizeof(ULONG_PTR), PAGE_EXECUTE_READWRITE);
	Thunk->u1.Function = (ULONG_PTR)m_pIATFuncOrig;
	m_Hooked = false;
}

void PLH::IATHook::SetupHook(const char* LibraryName, const char* SrcFunc, uint8_t* Dest, const char* Module)
{
	m_hkLibraryName = LibraryName;
	m_hkSrcFunc = SrcFunc;
	m_hkModuleName = Module;
	m_hkDest = Dest;
}

bool PLH::IATHook::FindIATFunc(const char* LibraryName, const char* FuncName, PIMAGE_THUNK_DATA* pFuncThunkOut, const char* Module)
{
	bool UseModuleName = true;
	if (Module == NULL || Module[0] == '\0') //we received a null module
		UseModuleName = false;

	//Use the module given to us, otherwise use our process base (NULL)
	HINSTANCE hInst = GetModuleHandleA(UseModuleName ? Module : NULL);
	if (!hInst)
	{
		PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook IATHook:Failed to find Module"));
		return false;
	}

	//Get import name table
	ULONG Sz;
	PIMAGE_IMPORT_DESCRIPTOR pImports = (PIMAGE_IMPORT_DESCRIPTOR)
		ImageDirectoryEntryToDataEx(hInst, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &Sz, nullptr);

	for (uint_fast16_t i = 0; pImports[i].Characteristics != 0; i++)
	{
		//Check if we have the correct library (ex: kernel32.dll)
		char* _ModuleName = (char*)ResolveRVA(hInst, pImports[i].Name);
		if (_stricmp(_ModuleName, LibraryName) != 0)
			continue;

		//Original holds the API Names
		PIMAGE_THUNK_DATA pOriginalThunk = (PIMAGE_THUNK_DATA)
			ResolveRVA(hInst, pImports[i].OriginalFirstThunk);

		//FirstThunk is overwritten by loader with API addresses, we change this
		PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)
			ResolveRVA(hInst, pImports[i].FirstThunk);

		if (!pOriginalThunk)
		{
			PostError(RuntimeError(RuntimeError::Severity::Critical, "PolyHook IATHook:PE Files without OriginalFirstThunk are unsupported"));
			return false;
		}

		//Table is null terminated, increment both tables
		for (; pOriginalThunk->u1.Function != NULL; pOriginalThunk++, pThunk++)
		{
			if (IMAGE_SNAP_BY_ORDINAL(pOriginalThunk->u1.Ordinal))
			{
				PLH::Tools::XTrace("Import By Ordinal:[Ordinal:%d]\n", IMAGE_ORDINAL(pOriginalThunk->u1.Ordinal));
				continue;
			}

			PIMAGE_IMPORT_BY_NAME pImport = (PIMAGE_IMPORT_BY_NAME)
				ResolveRVA(hInst, pOriginalThunk->u1.AddressOfData);

			PLH::Tools::XTrace("Import By Name: [Ordinal:%d] [Name:%s]\n", IMAGE_ORDINAL(pOriginalThunk->u1.Ordinal), pImport->Name);

			//Check the name of API given by OriginalFirthThunk (Ex: CreateThread)
			if (_stricmp(FuncName, pImport->Name) != 0)
				continue;

			/*Name matched in OriginalFirstThunk, return FirstThunk
			so we can changed it's address later*/
			*pFuncThunkOut = pThunk;
			return true;
		}
	}
	PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook IATHook:Failed to find import"));
	return false;
}

/*----------------------------------------------*/
PLH::HookType PLH::VEHHook::GetType()
{
	return PLH::HookType::VEH;
}

std::vector<PLH::VEHHook::HookCtx> PLH::VEHHook::m_HookTargets;
std::mutex PLH::VEHHook::m_TargetMutex;
PLH::VEHHook::VEHHook() : m_Hooked(false)
{
	//Get size of pages
	SYSTEM_INFO si;
	GetSystemInfo(&si);
	m_PageSize = si.dwPageSize;

	void* pVEH = AddVectoredExceptionHandler(1, &PLH::VEHHook::VEHHandler);
	if (pVEH == nullptr)
	{
		PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook VEH: Failed to create top level handler"));
	}
}

PLH::VEHHook::~VEHHook()
{
	if (m_Hooked)
		UnHook();
}

bool PLH::VEHHook::AreInSamePage(const uint8_t* Addr1, const uint8_t* Addr2)
{
	//If VQ fails, be safe and say they are in same page
	MEMORY_BASIC_INFORMATION mbi1;
	if (!VirtualQuery(Addr1, &mbi1, sizeof(mbi1)))
		return true;

	MEMORY_BASIC_INFORMATION mbi2;
	if (!VirtualQuery(Addr2, &mbi2, sizeof(mbi2)))
		return true;

	if (mbi1.BaseAddress == mbi2.BaseAddress)
		return true;

	return false;
}

void PLH::VEHHook::SetupHook(uint8_t* Src, uint8_t* Dest, VEHMethod Method)
{
	HookCtx Ctx(Src, Dest, Method);
	m_ThisCtx = Ctx;
}

bool PLH::VEHHook::Hook()
{
	//Lock the TargetMutex for thread safe vector operations
	std::lock_guard<std::mutex> m_Lock(m_TargetMutex);

	if (m_ThisCtx.m_Type == VEHMethod::INT3_BP)
	{
		//Write INT3 BreakPoint
		MemoryProtect Protector(m_ThisCtx.m_Src, 1, PAGE_EXECUTE_READWRITE);
		m_ThisCtx.m_StorageByte = *m_ThisCtx.m_Src;
		*m_ThisCtx.m_Src = 0xCC;
		m_HookTargets.push_back(m_ThisCtx);
	}
	else if (m_ThisCtx.m_Type == VEHMethod::HARDWARE_BP) {
		CONTEXT Ctx;
		Ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;

		if (!GetThreadContext(GetCurrentThread(), &Ctx))
		{
			PostError(PLH::RuntimeError(RuntimeError::Severity::Critical, "Failed to get context"));
			return false;
		}

		uint8_t RegIndex = 0;
		bool FoundReg = false;
		for (; RegIndex < 4; RegIndex++)
		{
			if ((Ctx.Dr7 & (1 << (RegIndex * 2))) == 0)
			{
				FoundReg = true;
				break;
			}
		}
		if (!FoundReg)
		{
			PostError(PLH::RuntimeError(RuntimeError::Severity::Critical, "Failed to find free Reg"));
			return false;
		}

		switch (RegIndex)
		{
		case 0:
			Ctx.Dr0 = (DWORD_PTR)m_ThisCtx.m_Src;
			break;
		case 1:
			Ctx.Dr1 = (DWORD_PTR)m_ThisCtx.m_Src;
			break;
		case 2:
			Ctx.Dr2 = (DWORD_PTR)m_ThisCtx.m_Src;
			break;
		case 3:
			Ctx.Dr3 = (DWORD_PTR)m_ThisCtx.m_Src;
			break;
		default:
			PostError(PLH::RuntimeError(RuntimeError::Severity::Critical, "PolyHook VEH: Invalid Debug Register Index"));
			return false;
		}
		//Turn a local register on
		Ctx.Dr7 |= 1 << (2 * RegIndex);
		m_ThisCtx.m_StorageByte = RegIndex;
		//Still need to call suspend thread *TODO*
		if (!SetThreadContext(GetCurrentThread(), &Ctx))
		{
			PostError(PLH::RuntimeError(RuntimeError::Severity::Critical, "PolyHook VEH: Failed to set thread context"));
			return false;
		}
		m_HookTargets.push_back(m_ThisCtx);
	}
	else if (m_ThisCtx.m_Type == VEHMethod::GUARD_PAGE) {
		//Read current page protection
		MEMORY_BASIC_INFORMATION mbi;
		VirtualQuery(m_ThisCtx.m_Src, &mbi, sizeof(mbi));

		//can't use Page Guards with NO_ACCESS flag
		if (mbi.Protect & PAGE_NOACCESS)
		{
			PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook VEH: Cannot hook page with NOACCESS Flag"));
			return false;
		}

		if (AreInSamePage((BYTE*)&PLH::VEHHook::VEHHandler, m_ThisCtx.m_Src))
		{
			PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook VEH: Cannot hook page on same page as the VEH"));
			return false;
		}

		//!!!!COMPILER SPECIFIC HACK HERE!!!!!
		bool(PLH::VEHHook::* pHookFunc)(void) = &PLH::VEHHook::Hook;
		if (AreInSamePage((BYTE*&)pHookFunc, m_ThisCtx.m_Src))
		{
			PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook VEH: Cannot hook page on same page as the hooking function"));
			return false;
		}

		m_HookTargets.push_back(m_ThisCtx);

		//Write Page Guard protection
		DWORD OldProtection;
		VirtualProtect(m_ThisCtx.m_Src, 1, PAGE_EXECUTE_READWRITE | PAGE_GUARD, &OldProtection);
	}
	m_Hooked = true;
	return true;
}

void PLH::VEHHook::UnHook()
{
	std::lock_guard<std::mutex> m_Lock(m_TargetMutex);

	if (m_ThisCtx.m_Type == VEHMethod::INT3_BP)
	{
		MemoryProtect Protector(m_ThisCtx.m_Src, 1, PAGE_EXECUTE_READWRITE);
		*m_ThisCtx.m_Src = m_ThisCtx.m_StorageByte;
	}
	else if (m_ThisCtx.m_Type == VEHMethod::HARDWARE_BP) {
		CONTEXT Ctx;
		Ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
		if (!GetThreadContext(GetCurrentThread(), &Ctx))
		{
			PostError(PLH::RuntimeError(RuntimeError::Severity::Critical, "Failed to get context"));
			return;
		}
		Ctx.Dr7 &= ~(1 << (2 * m_ThisCtx.m_StorageByte));
		//Still need to call suspend thread
		if (!SetThreadContext(GetCurrentThread(), &Ctx))
		{
			PostError(PLH::RuntimeError(RuntimeError::Severity::Critical, "Failed to set context"));
			return;
		}
	}
	else if (m_ThisCtx.m_Type == VEHMethod::GUARD_PAGE) {
		/*Force an exception, catch it, continue execution, and don't restore protection.
		This effectively unhooks this type of hook, mark volatile so compiler doesn't optimize read away*/
		volatile BYTE GenerateExceptionRead = *m_ThisCtx.m_Src;
	}
	m_HookTargets.erase(std::remove(m_HookTargets.begin(), m_HookTargets.end(), m_ThisCtx), m_HookTargets.end());
	m_Hooked = false;
}

LONG CALLBACK PLH::VEHHook::VEHHandler(EXCEPTION_POINTERS* ExceptionInfo)
{
#ifdef _WIN64
#define XIP Rip
#else
#define XIP Eip
#endif // _WIN64
	std::lock_guard<std::mutex> m_Lock(m_TargetMutex);

	DWORD ExceptionCode = ExceptionInfo->ExceptionRecord->ExceptionCode;
	if (ExceptionCode == EXCEPTION_BREAKPOINT)
	{
		for (HookCtx& Ctx : m_HookTargets)
		{
			if (Ctx.m_Type != VEHMethod::INT3_BP)
				continue;

			//Are we at a breakpoint that we placed?
			if (ExceptionInfo->ContextRecord->XIP != (DWORD_PTR)Ctx.m_Src)
				continue;

			//Remove Int3 Breakpoint
			MemoryProtect Protector(Ctx.m_Src, 1, PAGE_EXECUTE_READWRITE);
			*Ctx.m_Src = Ctx.m_StorageByte;

			//Set instruction pointer to our callback
			ExceptionInfo->ContextRecord->XIP = (DWORD_PTR)Ctx.m_Dest;
			return EXCEPTION_CONTINUE_EXECUTION;
		}
	}
	else if (ExceptionCode == EXCEPTION_SINGLE_STEP) {
		//Intel says clear Dr6, windows may do it for us, lets be safe
		ExceptionInfo->ContextRecord->Dr6 = 0;
		for (HookCtx& Ctx : m_HookTargets)
		{
			if (Ctx.m_Type != VEHMethod::HARDWARE_BP)
				continue;

			//Are we at a breakpoint that we placed?
			if (ExceptionInfo->ContextRecord->XIP != (DWORD_PTR)Ctx.m_Src)
				continue;

			//Clear the Debug Register
			ExceptionInfo->ContextRecord->Dr7 &= ~(1 << (2 * Ctx.m_StorageByte));

			//Set instruction pointer to callback
			ExceptionInfo->ContextRecord->XIP = (DWORD_PTR)Ctx.m_Dest;
			return EXCEPTION_CONTINUE_EXECUTION;
		}
	}
	else if (ExceptionCode == EXCEPTION_GUARD_PAGE) {
		for (HookCtx& Ctx : m_HookTargets)
		{
			//still need to check if exception is in our page
			if (Ctx.m_Type != VEHMethod::GUARD_PAGE)
				continue;

			if (!AreInSamePage((uint8_t*)ExceptionInfo->ContextRecord->XIP, Ctx.m_Src))
				continue;

			if (ExceptionInfo->ContextRecord->XIP == (uintptr_t)Ctx.m_Src)
				ExceptionInfo->ContextRecord->XIP = (uintptr_t)Ctx.m_Dest;

			return EXCEPTION_CONTINUE_EXECUTION;
		}
	}
	return EXCEPTION_CONTINUE_SEARCH;
}

/*----------------------------------------------*/
PLH::MemoryProtect::MemoryProtect(void* Address, size_t Size, DWORD ProtectionFlags)
{
	m_Address = Address;
	m_Size = Size;
	m_Flags = ProtectionFlags;
	Protect(m_Address, m_Size, m_Flags);
}

bool PLH::MemoryProtect::Protect(void* Address, size_t Size, DWORD ProtectionFlags)
{
	return VirtualProtect(Address, Size, ProtectionFlags, &m_OldProtection);
}

PLH::MemoryProtect::~MemoryProtect()
{
	Protect(m_Address, m_Size, m_OldProtection);
}

#endif//end include guard
```

`PolyHook/PolyHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{64269F60-A538-4327-82EE-AB4BF4766CE9}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>PolyHook</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(IncludePath)</IncludePath>
    <LibraryPath>../Capstone/msvc/x86/Debug;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(IncludePath)</IncludePath>
    <LibraryPath>../Capstone/msvc/x64/Debug;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(IncludePath)</IncludePath>
    <LibraryPath>../Capstone/msvc/x86/Release;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(IncludePath)</IncludePath>
    <LibraryPath>../Capstone/msvc/x64/Release;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CatchUnitTest.h" />
    <ClInclude Include="PolyHook.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Tests.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PolyHook/PolyHook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CatchUnitTest.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PolyHook.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Tests.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`PolyHook/Tests.cpp`:

```cpp
// PolyHook.cpp : Defines the entry point for the console application.
//
#include "PolyHook.hpp"
#define CATCH_CONFIG_MAIN
#include "CatchUnitTest.h"

decltype(&MessageBoxA) oMessageBoxA;
int WINAPI hkMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
{
	int Result = oMessageBoxA(hWnd, "Hooked", lpCaption, uType);
	REQUIRE(strcmp("Message",lpText) == 0);
	return -10;
}

TEST_CASE("Hooks MessageBox", "[Detours]")
{
	std::shared_ptr<PLH::Detour> Detour_Ex(new PLH::Detour);
	REQUIRE(Detour_Ex->GetType() == PLH::HookType::Detour);

	Detour_Ex->SetupHook((BYTE*)&MessageBoxA,(BYTE*) &hkMessageBoxA); //can cast to byte* to
	REQUIRE( Detour_Ex->Hook() );
	oMessageBoxA = Detour_Ex->GetOriginal<decltype(&MessageBoxA)>();

	REQUIRE(MessageBoxA(NULL, "Message", "Sample", MB_OK) == -10); //The return value set by our handler
	Detour_Ex->UnHook();
	REQUIRE(MessageBoxA(NULL, "Message", "Sample", MB_OK) == IDOK);

	REQUIRE(Detour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
	REQUIRE(Detour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
}

decltype(&WriteProcessMemory) oWriteProcessMemory;
BYTE DummyBuffer2[] = { 0x13,0x24,0x36,0x38 };
BOOL WINAPI hkWriteProcessMemory(HANDLE  hProcess,LPVOID  lpBaseAddress,LPCVOID lpBuffer,SIZE_T  nSize,SIZE_T  *lpNumberOfBytesWritten)
{
	lpBuffer = &DummyBuffer2;
	nSize = sizeof(DummyBuffer2);
	return oWriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
}

TEST_CASE("Hooks WriteProcessMemory", "[Detours]")
{
	std::shared_ptr<PLH::Detour> Detour_Ex(new PLH::Detour);
	REQUIRE(Detour_Ex->GetType() == PLH::HookType::Detour);

	Detour_Ex->SetupHook((BYTE*)&WriteProcessMemory, (BYTE*)&hkWriteProcessMemory); //can cast to byte* to
	REQUIRE(Detour_Ex->Hook());
	oWriteProcessMemory = Detour_Ex->GetOriginal<decltype(&WriteProcessMemory)>();

	BYTE Buffer[] = { 0x00,0x12,0x44,0x91 };
	BYTE Buffer2[] = { 0x11,0x21,0x56,0x78};

	REQUIRE(Buffer[0] == 0x00);
	SIZE_T Written = 0;
	WriteProcessMemory(GetCurrentProcess(), &Buffer, &Buffer2, sizeof(Buffer2), &Written);
	REQUIRE(Buffer[0] == 0x13); //Make sure our hook changed the data written to the data in the dummy buffer
	Detour_Ex->UnHook();
	
	Written = 0;
	WriteProcessMemory(GetCurrentProcess(), &Buffer, &Buffer2, sizeof(Buffer2), &Written);
	REQUIRE(Buffer[0] == 0x11);
	
	REQUIRE(Detour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
	REQUIRE(Detour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
}

decltype(&GetCommandLineA) oGetCommandLine;
int CommandLineVerifier = 0;
LPSTR WINAPI hkGetCommandLineA()
{
	CommandLineVerifier = 1294;
	LPSTR ReturnVal = oGetCommandLine();
	return ReturnVal;
}

TEST_CASE("Hooks GetCommandLine", "[Detours]")
{
	std::shared_ptr<PLH::Detour> Detour_Ex(new PLH::Detour);
	REQUIRE(Detour_Ex->GetType() == PLH::HookType::Detour);

	Detour_Ex->SetupHook((BYTE*)&GetCommandLineA, (BYTE*)&hkGetCommandLineA); //can cast to byte* to
	REQUIRE(Detour_Ex->Hook());
	oGetCommandLine = Detour_Ex->GetOriginal<decltype(&GetCommandLineA)>();

	REQUIRE(CommandLineVerifier == 0);
	GetCommandLineA();
	REQUIRE(CommandLineVerifier == 1294);
	Detour_Ex->UnHook();
	REQUIRE(CommandLineVerifier == 1294);

	REQUIRE(Detour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
	REQUIRE(Detour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
}
/////////////////////////////////////////////////////////////////////////////////////////////////

typedef DWORD(__stdcall* tGetCurrentThreadId)();
tGetCurrentThreadId oGetCurrentThreadID;

DWORD __stdcall hkGetCurrentThreadId()
{
	return oGetCurrentThreadID() + 1;
}

typedef BOOL(__stdcall* tBitBlt)(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight,
	HDC hdcSrc, int nXSrc, int nYSrc, DWORD dwRop);
tBitBlt oBitBlt;

//Just an int that gets incremented to verify handler got called for unit tests

int BitBltHookVerifier = 0; 
BOOL __stdcall hkBitBlt(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight,
	HDC hdcSrc, int nXSrc, int nYSrc, DWORD dwRop)
{
	BitBltHookVerifier += 1337;
	return oBitBlt(hdcDest, nXDest, nYDest, nWidth, nHeight, hdcSrc, nXSrc, nYSrc, dwRop);
}

TEST_CASE("Hooks Using IAT", "[IATHOOK]")
{
	std::shared_ptr<PLH::IATHook> IATHook_Ex(new PLH::IATHook);
	DWORD RealThreadId = GetCurrentThreadId();

	REQUIRE(IATHook_Ex->GetType() == PLH::HookType::IAT);

	SECTION("GetCurrentThread Hook")
	{
		IATHook_Ex->SetupHook("kernel32.dll", "GetCurrentThreadId", (BYTE*)&hkGetCurrentThreadId);
		REQUIRE(IATHook_Ex->Hook());
		oGetCurrentThreadID = IATHook_Ex->GetOriginal<tGetCurrentThreadId>();
		REQUIRE(GetCurrentThreadId() == RealThreadId + 1);
		IATHook_Ex->UnHook();
		REQUIRE(GetCurrentThreadId() == RealThreadId);

		REQUIRE(IATHook_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
		REQUIRE(IATHook_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
	}
	SECTION("BitBlt Hook")
	{
		REQUIRE(BitBltHookVerifier == 0);
		IATHook_Ex->SetupHook("Gdi32.dll", "BitBlt", (BYTE*)&hkBitBlt);
		REQUIRE(IATHook_Ex->Hook());
		oBitBlt = IATHook_Ex->GetOriginal<tBitBlt>();
		BitBlt(NULL, 0, 0, 0, 0, NULL, 0, 0, 0);
		REQUIRE(BitBltHookVerifier == 1337);
		IATHook_Ex->UnHook();
		BitBlt(NULL, 0, 0, 0, 0, NULL, 0, 0, 0);
		REQUIRE(BitBltHookVerifier == 1337);

		REQUIRE(IATHook_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
		REQUIRE(IATHook_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////

class VirtualTest
{
public:
	virtual int NoParamVirt()
	{
		return 4;
	}
	virtual int NoParamVirt2()
	{
		return 7;
	}
};

typedef int(__thiscall* tVirtNoParams)(DWORD_PTR pThis);
tVirtNoParams oVirtNoParams;
tVirtNoParams oVirtNoParams2;

int __fastcall hkVirtNoParams(DWORD_PTR pThis)
{
	return oVirtNoParams(pThis) + 1;
}

TEST_CASE("Detours a function pointed to in a virtual table", "[VFuncDetour]")
{
	std::shared_ptr<VirtualTest> ClassToHook(new VirtualTest);
	std::shared_ptr<PLH::VFuncDetour> VFuncDetour_Ex(new PLH::VFuncDetour);

	int OriginalRetVal = ClassToHook->NoParamVirt();
	REQUIRE(VFuncDetour_Ex->GetType() == PLH::HookType::VFuncDetour);

	VFuncDetour_Ex->SetupHook(*(BYTE***)ClassToHook.get(), 0, (BYTE*)&hkVirtNoParams);
	REQUIRE(VFuncDetour_Ex->Hook());
	oVirtNoParams = VFuncDetour_Ex->GetOriginal<tVirtNoParams>();
	REQUIRE(ClassToHook->NoParamVirt() == OriginalRetVal + 1);
	VFuncDetour_Ex->UnHook();
	REQUIRE(ClassToHook->NoParamVirt() == OriginalRetVal);

	REQUIRE(VFuncDetour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
	REQUIRE(VFuncDetour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
}

////////////////////////////////////////////////////////////////////////////////////////////////

int __fastcall hkVirtNoParams2(DWORD_PTR pThis)
{
	return oVirtNoParams2(pThis) + 1;
}

TEST_CASE("Replaces the vtable pointer to hook a function", "[VTableSwap]")
{
	std::shared_ptr<VirtualTest> ClassToHook(new VirtualTest);
	std::shared_ptr<PLH::VTableSwap> VTableSwap_Ex(new PLH::VTableSwap);

	REQUIRE(VTableSwap_Ex->GetType() == PLH::HookType::VTableSwap);
	int OriginalRetVal = ClassToHook->NoParamVirt();
	int OriginalRetVal2 = ClassToHook->NoParamVirt2();

	VTableSwap_Ex->SetupHook((BYTE*)ClassToHook.get(), 0, (BYTE*)&hkVirtNoParams);
	REQUIRE(VTableSwap_Ex->Hook());
	oVirtNoParams = VTableSwap_Ex->GetOriginal<tVirtNoParams>();

	REQUIRE(ClassToHook->NoParamVirt() == OriginalRetVal + 1);
	oVirtNoParams2 = VTableSwap_Ex->HookAdditional<tVirtNoParams>(1, (BYTE*)&hkVirtNoParams2);
	REQUIRE(ClassToHook->NoParamVirt2() == OriginalRetVal2 + 1);

	VTableSwap_Ex->UnHook();
	REQUIRE(ClassToHook->NoParamVirt() == OriginalRetVal);
	REQUIRE(ClassToHook->NoParamVirt2() == OriginalRetVal2);


	REQUIRE(VTableSwap_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
	REQUIRE(VTableSwap_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
}

////////////////////////////////////////////////////////////////////////////////////////////////
typedef int(__stdcall* tVEH)(int intparam);
tVEH oVEHTest;
__declspec(noinline) int __stdcall VEHTest(int param)
{
	return 3;
}

std::shared_ptr<PLH::VEHHook> VEHHook_Ex;
__declspec(noinline) int __stdcall hkVEHTest(int param)
{
	auto ProtectionObject = VEHHook_Ex->GetProtectionObject();
	return oVEHTest(param) + 1;
}

TEST_CASE("Hooks a function using vectored exception handler", "[VEHHook]")
{
	////THESE TESTS CANNOT BE RUN IN A DEBUGGER
	//VEHHook_Ex = std::make_shared<PLH::VEHHook>();

	//REQUIRE(VEHHook_Ex->GetType() == PLH::HookType::VEH);
	//int OriginalRetVal = VEHTest(1);

	//SECTION("INT3 Type Breakpoint")
	//{
	//	VEHHook_Ex->SetupHook((BYTE*)&VEHTest, (BYTE*)&hkVEHTest, PLH::VEHHook::VEHMethod::INT3_BP);
	//	REQUIRE(VEHHook_Ex->Hook());
	//	oVEHTest = VEHHook_Ex->GetOriginal<tVEH>();
	//	REQUIRE(VEHTest(3) == OriginalRetVal + 1);
	//	VEHHook_Ex->UnHook();
	//	REQUIRE(VEHTest(3) == OriginalRetVal);
	//}
	//SECTION("Hardware Type Breakpoint")
	//{
	//	VEHHook_Ex->SetupHook((BYTE*)&VEHTest, (BYTE*)&hkVEHTest, PLH::VEHHook::VEHMethod::HARDWARE_BP);
	//	REQUIRE(VEHHook_Ex->Hook());
	//	oVEHTest = VEHHook_Ex->GetOriginal<tVEH>();
	//	REQUIRE(VEHTest(3) == OriginalRetVal + 1);
	//	VEHHook_Ex->UnHook();
	//	REQUIRE(VEHTest(3) == OriginalRetVal);
	//}
	//SECTION("Guard Page Type Hook")
	//{
	//	INFO("This Type may fail, due to the small demo size");
	//	/*!!!!IMPORTANT!!!!!: Since this demo is small it's possible for internal methods to be on the same memory page
	//	as the VEHTest function. If that happens the GUARD_PAGE type method will fail with an unexpected exception.
	//	If this method is used in larger applications this risk is incredibly small, to the point where it should not
	//	be worried about. You CANNOT run this demo under a debugger when using VEH type
	//	*/

	//	VEHHook_Ex->SetupHook((BYTE*)&VEHTest, (BYTE*)&hkVEHTest, PLH::VEHHook::VEHMethod::GUARD_PAGE);
	//	REQUIRE(VEHHook_Ex->Hook());
	//	oVEHTest = VEHHook_Ex->GetOriginal<tVEH>();
	//	REQUIRE(VEHTest(3) == OriginalRetVal + 1);
	//	VEHHook_Ex->UnHook();
	//	REQUIRE(VEHTest(3) == OriginalRetVal);
	//}
}


```

`README.md`:

```md
# PolyHook - x86/x64 Hooking Library
**Provides abstract C++ 11 interface  for various hooking methods**

Technical Writeup: https://www.codeproject.com/articles/1100579/polyhook-the-cplusplus-x-x-hooking-library

# OUTDATED
Please use V2: https://github.com/stevemk14ebr/PolyHook_2_0. Consider sponsoring my development by clicking sponsor up in the top right!

# Hooking Methods*:

1. **_Detour_**
  * Description: Modifies opcode to jmp to hook and allocates a trampoline for jmp back
  * Length Disassembler Support (Capstone)
  * Supports Code Relocation, including EIP/RIP relative instructions

2. **_Virtual Function Detour_** : 
  * Description: Detours the function pointed to by the Vtable

3. **_Virtual Function Pointer Swap_** 
  * Description: Swaps the pointer in the Vtable to your hook
  
4. **_Virtual Table Pointer Swap_**
  * Description: Swaps the Vtable pointer after copying pointers in source Vtable, 
  then swaps virtual function pointer in the new copy

5. **Import Address Table**
  * Description: Swaps pointer in the import address table to the hook

6. **VEH**
  * Description: Intercepts an exception generated on purpose, sets instruction pointer to handler, then resets exception generating mechanism
  * Methods to generate exception: INT3 Breakpoints, Guard Page violations.
  * **Note**: it is important to call the GetProtectionObject function INSIDE of your callback as per my example for all VEH hooks
  * Other exception generation methods are in development

* All methods support x86 and x64
* Relies on modified capstone branch https://github.com/stevemk14ebr/capstone
* More Information can be found at the wiki to the right

Credits to DarthTon, evolution536, Dogmatt

# Samples:
The file Tests.cpp provides examples for every type of hooking method. Accompanied with these examples is unit testing code provided by the fantastic library Catch (https://github.com/philsquared/Catch/blob/master/docs/tutorial.md). With the addition of this code the example may look a little complex, the general interface is extremely simple, all hook types expose setup, hook, and unhook methods:

```C++
std::shared_ptr<PLH::Detour> Detour_Ex(new PLH::Detour);
Detour_Ex->SetupHook((BYTE*)&MessageBoxA,(BYTE*) &hkMessageBoxA); //can cast to byte* to
Detour_Ex->Hook();
oMessageBoxA = Detour_Ex->GetOriginal<tMessageBoxA>();
Detour_Ex->UnHook();
```

# LICENSE:
MIT

```