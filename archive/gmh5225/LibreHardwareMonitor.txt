Project Path: arc_gmh5225_LibreHardwareMonitor_gzqjth7e

Source Tree:

```txt
arc_gmh5225_LibreHardwareMonitor_gzqjth7e
├── Aga.Controls
│   ├── Aga.Controls.csproj
│   ├── Aga.Controls.sln
│   ├── BitmapHelper.cs
│   ├── GifDecoder.cs
│   ├── NumericTextBox.cs
│   ├── PerformanceAnalyzer.cs
│   ├── Properties
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   ├── ResourceHelper.cs
│   ├── Resources
│   │   ├── DVSplit.cur
│   │   ├── Folder.bmp
│   │   ├── FolderClosed.bmp
│   │   ├── Leaf.bmp
│   │   ├── check.bmp
│   │   ├── loading_icon
│   │   ├── minus.bmp
│   │   ├── plus.bmp
│   │   ├── uncheck.bmp
│   │   └── unknown.bmp
│   ├── StringCollectionEditor.cs
│   ├── TextHelper.cs
│   ├── Threading
│   │   ├── AbortableThreadPool.cs
│   │   ├── WorkItem.cs
│   │   └── WorkItemStatus.cs
│   ├── TimeCounter.cs
│   ├── Tree
│   │   ├── AutoRowHeightLayout.cs
│   │   ├── ClassDiagram.cd
│   │   ├── ColumnCollection.cs
│   │   ├── DrawContext.cs
│   │   ├── DropNodeValidatingEventArgs.cs
│   │   ├── DropPosition.cs
│   │   ├── EditorContext.cs
│   │   ├── Enums.cs
│   │   ├── FixedRowHeightLayout.cs
│   │   ├── IRowLayout.cs
│   │   ├── IToolTipProvider.cs
│   │   ├── ITreeModel.cs
│   │   ├── IncrementalSearch.cs
│   │   ├── Input
│   │   │   ├── ClickColumnState.cs
│   │   │   ├── ColumnState.cs
│   │   │   ├── InputState.cs
│   │   │   ├── InputWithControl.cs
│   │   │   ├── InputWithShift.cs
│   │   │   ├── NormalInputState.cs
│   │   │   ├── ReorderColumnState.cs
│   │   │   └── ResizeColumnState.cs
│   │   ├── ListModel.cs
│   │   ├── NativeMethods.cs
│   │   ├── Node.cs
│   │   ├── NodeControlInfo.cs
│   │   ├── NodeControls
│   │   │   ├── BaseTextControl.cs
│   │   │   ├── BindableControl.cs
│   │   │   ├── ClassDiagram.cd
│   │   │   ├── DrawEventArgs.cs
│   │   │   ├── EditEventArgs.cs
│   │   │   ├── EditableControl.cs
│   │   │   ├── ExpandingIcon.cs
│   │   │   ├── InteractiveControl.cs
│   │   │   ├── LabelEventArgs.cs
│   │   │   ├── NodeCheckBox.cs
│   │   │   ├── NodeComboBox.cs
│   │   │   ├── NodeControl.cs
│   │   │   ├── NodeControlValueEventArgs.cs
│   │   │   ├── NodeControlsCollection.cs
│   │   │   ├── NodeDecimalTextBox.cs
│   │   │   ├── NodeEventArgs.cs
│   │   │   ├── NodeIcon.cs
│   │   │   ├── NodeIntegerTextBox.cs
│   │   │   ├── NodeNumericUpDown.cs
│   │   │   ├── NodePlusMinus.cs
│   │   │   ├── NodeStateIcon.cs
│   │   │   └── NodeTextBox.cs
│   │   ├── SortedTreeModel.cs
│   │   ├── TreeColumn.cs
│   │   ├── TreeColumnCollection.cs
│   │   ├── TreeColumnEventArgs.cs
│   │   ├── TreeListAdapter.cs
│   │   ├── TreeModel.cs
│   │   ├── TreeModelBase.cs
│   │   ├── TreeModelEventArgs.cs
│   │   ├── TreeNodeAdv.cs
│   │   ├── TreeNodeAdvMouseEventArgs.cs
│   │   ├── TreePath.cs
│   │   ├── TreePathEventArgs.cs
│   │   ├── TreeViewAdv.Designer.cs
│   │   ├── TreeViewAdv.Draw.cs
│   │   ├── TreeViewAdv.Editor.cs
│   │   ├── TreeViewAdv.Input.cs
│   │   ├── TreeViewAdv.Properties.cs
│   │   ├── TreeViewAdv.cs
│   │   ├── TreeViewAdv.resx
│   │   ├── TreeViewAdvCancelEventArgs.cs
│   │   ├── TreeViewAdvEventArgs.cs
│   │   └── TreeViewRowDrawEventArgs.cs
│   └── license.txt
├── Directory.Build.props
├── InpOut
│   ├── InpOut32.Net
│   │   └── CSharpExample.cs
│   ├── InstallDriver
│   │   ├── InstallDriver.cpp
│   │   ├── InstallDriver.h
│   │   ├── InstallDriver.manifest
│   │   ├── InstallDriver.rc
│   │   ├── InstallDriver.vcproj
│   │   ├── ReadMe.txt
│   │   ├── Resource.h
│   │   ├── stdafx.cpp
│   │   └── stdafx.h
│   ├── ReadMe.txt
│   ├── StdAfx.cpp
│   ├── StdAfx.h
│   ├── hwinterfacedrv.h
│   ├── inpout32.h
│   ├── inpout32.sys
│   ├── inpout32drv.cpp
│   ├── inpout32drv.def
│   ├── inpout32drv.rc
│   ├── inpout32drv.sln
│   ├── inpout32drv.vcproj
│   ├── inpoutx64.sys
│   ├── license.txt
│   ├── osversion.cpp
│   └── resource.h
├── LICENSE
├── LibreHardwareMonitor
│   ├── LibreHardwareMonitor.csproj
│   ├── Program.cs
│   ├── Resources
│   │   ├── Web
│   │   │   ├── css
│   │   │   │   ├── custom-theme
│   │   │   │   │   ├── images
│   │   │   │   │   │   ├── ui-bg_flat_0_aaaaaa_40x100.png
│   │   │   │   │   │   ├── ui-bg_glass_55_fbf9ee_1x400.png
│   │   │   │   │   │   ├── ui-bg_glass_65_ffffff_1x400.png
│   │   │   │   │   │   ├── ui-bg_glass_75_dadada_1x400.png
│   │   │   │   │   │   ├── ui-bg_glass_75_e6e6e6_1x400.png
│   │   │   │   │   │   ├── ui-bg_glass_75_ffffff_1x400.png
│   │   │   │   │   │   ├── ui-bg_highlight-soft_75_cccccc_1x100.png
│   │   │   │   │   │   ├── ui-bg_inset-soft_95_fef1ec_1x100.png
│   │   │   │   │   │   ├── ui-icons_222222_256x240.png
│   │   │   │   │   │   ├── ui-icons_2e83ff_256x240.png
│   │   │   │   │   │   ├── ui-icons_454545_256x240.png
│   │   │   │   │   │   ├── ui-icons_888888_256x240.png
│   │   │   │   │   │   └── ui-icons_cd0a0a_256x240.png
│   │   │   │   │   └── jquery-ui-1.8.16.custom.css
│   │   │   │   ├── jquery.treeTable.css
│   │   │   │   └── ohm_web.css
│   │   │   ├── favicon.ico
│   │   │   ├── images
│   │   │   │   ├── toggle-collapse-dark.png
│   │   │   │   ├── toggle-collapse-light.png
│   │   │   │   ├── toggle-expand-dark.png
│   │   │   │   ├── toggle-expand-light.png
│   │   │   │   └── transparent.png
│   │   │   ├── index.html
│   │   │   └── js
│   │   │       ├── jquery-1.7.2.js
│   │   │       ├── jquery-1.7.2.min.js
│   │   │       ├── jquery-ui-1.8.16.custom.min.js
│   │   │       ├── jquery.tmpl.js
│   │   │       ├── jquery.tmpl.min.js
│   │   │       ├── jquery.treeTable.min.js
│   │   │       ├── knockout-2.1.0.js
│   │   │       ├── knockout-2.1.0.min.js
│   │   │       ├── knockout.mapping-latest.js
│   │   │       ├── knockout.mapping-latest.min.js
│   │   │       └── ohm_web.js
│   │   ├── amd.png
│   │   ├── app.manifest
│   │   ├── ati.png
│   │   ├── barback.png
│   │   ├── barblue.png
│   │   ├── battery.png
│   │   ├── chip.png
│   │   ├── clock.png
│   │   ├── computer.png
│   │   ├── control.png
│   │   ├── cpu.png
│   │   ├── current.png
│   │   ├── data.png
│   │   ├── factor.png
│   │   ├── fan.png
│   │   ├── flow.png
│   │   ├── gadget.png
│   │   ├── gadget.xcf
│   │   ├── hdd.png
│   │   ├── icon.ico
│   │   ├── icon.xcf
│   │   ├── intel.png
│   │   ├── level.png
│   │   ├── load.png
│   │   ├── loudspeaker.png
│   │   ├── mainboard.png
│   │   ├── nic.png
│   │   ├── nvidia.png
│   │   ├── power-supply.png
│   │   ├── power.png
│   │   ├── ram.png
│   │   ├── smallicon.ico
│   │   ├── temperature.png
│   │   ├── throughput.png
│   │   ├── time.png
│   │   └── voltage.png
│   ├── TestScripts
│   │   ├── LiquidCool.py
│   │   ├── basicrest.py
│   │   └── basicwmi.py
│   ├── UI
│   │   ├── AboutBox.Designer.cs
│   │   ├── AboutBox.cs
│   │   ├── AboutBox.resx
│   │   ├── AuthForm.Designer.cs
│   │   ├── AuthForm.cs
│   │   ├── AuthForm.resx
│   │   ├── Gadget.cs
│   │   ├── GadgetWindow.cs
│   │   ├── HardwareNode.cs
│   │   ├── HardwareTypeImage.cs
│   │   ├── IExpandPersistNode.cs
│   │   ├── MainForm.Designer.cs
│   │   ├── MainForm.cs
│   │   ├── MainForm.resx
│   │   ├── Node.cs
│   │   ├── NodeToolTipProvider.cs
│   │   ├── NotifyIconAdv.cs
│   │   ├── ParameterForm.Designer.cs
│   │   ├── ParameterForm.cs
│   │   ├── ParameterForm.resx
│   │   ├── PlotPanel.cs
│   │   ├── PortForm.Designer.cs
│   │   ├── PortForm.cs
│   │   ├── PortForm.resx
│   │   ├── ScaledPlotModel.cs
│   │   ├── SensorGadget.cs
│   │   ├── SensorNode.cs
│   │   ├── SensorNotifyIcon.cs
│   │   ├── ShowDesktop.cs
│   │   ├── SplitContainerAdv.cs
│   │   ├── StartupManager.cs
│   │   ├── SystemTray.cs
│   │   ├── ToolStripRadioButtonMenuItem.cs
│   │   ├── TreeModel.cs
│   │   ├── TypeNode.cs
│   │   ├── UnitManager.cs
│   │   ├── UpdateVisitor.cs
│   │   ├── UserOption.cs
│   │   └── UserRadioGroup.cs
│   ├── Utilities
│   │   ├── EmbeddedResources.cs
│   │   ├── HttpServer.cs
│   │   ├── IconFactory.cs
│   │   ├── Logger.cs
│   │   └── PersistentSettings.cs
│   └── WMI
│       ├── Hardware.cs
│       ├── IWmiObject.cs
│       ├── Sensor.cs
│       └── WmiProvider.cs
├── LibreHardwareMonitor.sln
├── LibreHardwareMonitorLib
│   ├── Hardware
│   │   ├── Battery
│   │   │   ├── Battery.cs
│   │   │   ├── BatteryChemistry.cs
│   │   │   └── BatteryGroup.cs
│   │   ├── CompositeSensor.cs
│   │   ├── Computer.cs
│   │   ├── Control.cs
│   │   ├── Controller
│   │   │   ├── AeroCool
│   │   │   │   ├── AeroCoolGroup.cs
│   │   │   │   └── P7-H1.cs
│   │   │   ├── AquaComputer
│   │   │   │   ├── AquaComputerGroup.cs
│   │   │   │   ├── AquastreamXT.cs
│   │   │   │   ├── D5Next.cs
│   │   │   │   ├── MPS.cs
│   │   │   │   └── Octo.cs
│   │   │   ├── Heatmaster
│   │   │   │   ├── Heatmaster.cs
│   │   │   │   └── HeatmasterGroup.cs
│   │   │   ├── Nzxt
│   │   │   │   ├── GridV3.cs
│   │   │   │   ├── KrakenX3.cs
│   │   │   │   └── NzxtGroup.cs
│   │   │   └── TBalancer
│   │   │       ├── TBalancer.cs
│   │   │       └── TBalancerGroup.cs
│   │   ├── Cpu
│   │   │   ├── Amd0FCpu.cs
│   │   │   ├── Amd10Cpu.cs
│   │   │   ├── Amd17Cpu.cs
│   │   │   ├── AmdCpu.cs
│   │   │   ├── CpuGroup.cs
│   │   │   ├── CpuId.cs
│   │   │   ├── CpuLoad.cs
│   │   │   ├── GenericCpu.cs
│   │   │   └── IntelCpu.cs
│   │   ├── D3DDisplayDevice.cs
│   │   ├── FirmwareTable.cs
│   │   ├── Gpu
│   │   │   ├── AmdGpu.cs
│   │   │   ├── AmdGpuGroup.cs
│   │   │   ├── GenericGpu.cs
│   │   │   ├── IntelGpuGroup.cs
│   │   │   ├── IntelIntegratedGpu.cs
│   │   │   ├── NvidiaGpu.cs
│   │   │   └── NvidiaGroup.cs
│   │   ├── GroupAffinity.cs
│   │   ├── Hardware.cs
│   │   ├── HardwareType.cs
│   │   ├── IComputer.cs
│   │   ├── IControl.cs
│   │   ├── IElement.cs
│   │   ├── IGroup.cs
│   │   ├── IHardware.cs
│   │   ├── IHardwareChanged.cs
│   │   ├── IParameter.cs
│   │   ├── ISensor.cs
│   │   ├── ISensorLimits.cs
│   │   ├── ISettings.cs
│   │   ├── IVisitor.cs
│   │   ├── Identifier.cs
│   │   ├── InpOut.cs
│   │   ├── KernelDriver.cs
│   │   ├── Memory
│   │   │   ├── GenericLinuxMemory.cs
│   │   │   ├── GenericWindowsMemory.cs
│   │   │   └── MemoryGroup.cs
│   │   ├── Motherboard
│   │   │   ├── Identification.cs
│   │   │   ├── Lpc
│   │   │   │   ├── Chip.cs
│   │   │   │   ├── EC
│   │   │   │   │   ├── EmbeddedController.cs
│   │   │   │   │   ├── EmbeddedControllerReader.cs
│   │   │   │   │   ├── EmbeddedControllerSource.cs
│   │   │   │   │   ├── IEmbeddedControllerIO.cs
│   │   │   │   │   ├── WindowsEmbeddedController.cs
│   │   │   │   │   └── WindowsEmbeddedControllerIO.cs
│   │   │   │   ├── F718XX.cs
│   │   │   │   ├── ISuperIO.cs
│   │   │   │   ├── IT87XX.cs
│   │   │   │   ├── LMSensors.cs
│   │   │   │   ├── LPcPort.cs
│   │   │   │   ├── LpcIO.cs
│   │   │   │   ├── Nct677X.cs
│   │   │   │   └── W836XX.cs
│   │   │   ├── Manufacturer.cs
│   │   │   ├── Model.cs
│   │   │   ├── Motherboard.cs
│   │   │   ├── MotherboardGroup.cs
│   │   │   └── SuperIOHardware.cs
│   │   ├── Network
│   │   │   ├── Network.cs
│   │   │   └── NetworkGroup.cs
│   │   ├── OpCode.cs
│   │   ├── Parameter.cs
│   │   ├── ParameterDescription.cs
│   │   ├── Psu
│   │   │   └── Corsair
│   │   │       ├── CorsairPsu.cs
│   │   │       └── CorsairPsuGroup.cs
│   │   ├── Ring0.cs
│   │   ├── RyzenSMU.cs
│   │   ├── SMBios.cs
│   │   ├── Sensor.cs
│   │   ├── SensorVisitor.cs
│   │   ├── Storage
│   │   │   ├── ATAStorage.cs
│   │   │   ├── AbstractStorage.cs
│   │   │   ├── DebugSmart.cs
│   │   │   ├── GenericHardDisk.cs
│   │   │   ├── INVMeDrive.cs
│   │   │   ├── ISmart.cs
│   │   │   ├── NVMeGeneric.cs
│   │   │   ├── NVMeHealthInfo.cs
│   │   │   ├── NVMeInfo.cs
│   │   │   ├── NVMeIntel.cs
│   │   │   ├── NVMeIntelRst.cs
│   │   │   ├── NVMeSamsung.cs
│   │   │   ├── NVMeSmart.cs
│   │   │   ├── NVMeWindows.cs
│   │   │   ├── NamePrefixAttribute.cs
│   │   │   ├── RequireSmartAttribute.cs
│   │   │   ├── SmartAttribute.cs
│   │   │   ├── SmartNames.cs
│   │   │   ├── SsdIndilinx.cs
│   │   │   ├── SsdIntel.cs
│   │   │   ├── SsdMicron.cs
│   │   │   ├── SsdPlextor.cs
│   │   │   ├── SsdSamsung.cs
│   │   │   ├── SsdSandforce.cs
│   │   │   ├── StorageGeneric.cs
│   │   │   ├── StorageGroup.cs
│   │   │   ├── StorageInfo.cs
│   │   │   ├── WindowsSmart.cs
│   │   │   └── WindowsStorage.cs
│   │   └── ThreadAffinity.cs
│   ├── Interop
│   │   ├── AdvApi32.cs
│   │   ├── AtiAdlxx.cs
│   │   ├── CfgMgr32.cs
│   │   ├── D3dkmdt.cs
│   │   ├── D3dkmth.cs
│   │   ├── Ftd2xx.cs
│   │   ├── Gdi32.cs
│   │   ├── InpOut.cs
│   │   ├── Kernel32.cs
│   │   ├── LibC.cs
│   │   ├── NtDll.cs
│   │   ├── NvApi.cs
│   │   ├── NvidiaML.cs
│   │   ├── Ring0.cs
│   │   ├── SetupApi.cs
│   │   └── WinNt.cs
│   ├── LibreHardwareMonitorLib.csproj
│   ├── Resources
│   │   ├── WinRing0.gz
│   │   ├── WinRing0.sys
│   │   ├── WinRing0x64.gz
│   │   ├── WinRing0x64.sys
│   │   ├── inpout32.dll
│   │   ├── inpout32.gz
│   │   ├── inpoutx64.dll
│   │   ├── inpoutx64.gz
│   │   └── packageicon.png
│   └── Software
│       └── OperatingSystem.cs
├── Licenses
│   └── License.html
├── README.md
└── WinRing0
    ├── COPYRIGHT.txt
    ├── MAKEFILE
    ├── OlsIoctl.h
    ├── OpenLibSys.c
    ├── OpenLibSys.h
    ├── OpenLibSys.rc
    └── SOURCES

```

`Aga.Controls/Aga.Controls.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <ProductVersion>9.0.30729</ProductVersion>
    <TargetFramework>net472</TargetFramework>
    <AssemblyTitle>Aga.Controls</AssemblyTitle>
    <Description>http://sourceforge.net/projects/treeviewadv/</Description>
    <Copyright>Copyright © Andrey Gliznetsov 2006 - 2009</Copyright>
    <AssemblyVersion>1.7.0.0</AssemblyVersion>
    <FileVersion>1.7.0.0</FileVersion>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <OutputPath>..\bin\$(Configuration)\</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugType>full</DebugType>
    <DefineConstants>TRACE;DEBUG;PERF_TEST</DefineConstants>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System.Design" />
    <Reference Include="System.Windows.Forms" />
  </ItemGroup>
  <ItemGroup>
    <Compile Update="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeIntegerTextBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeDecimalTextBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="NumericTextBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\ExpandingIcon.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\InteractiveControl.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeViewAdv.Draw.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeViewAdv.Editor.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeViewAdv.Input.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeNumericUpDown.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeViewAdv.Properties.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\BaseTextControl.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\EditableControl.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeComboBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeColumn.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeControl.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\BindableControl.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeCheckBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeIcon.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodePlusMinus.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeTextBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeStateIcon.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeViewAdv.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeViewAdv.Designer.cs">
      <DependentUpon>TreeViewAdv.cs</DependentUpon>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <Content Include="Resources\**" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Update="Properties\Resources.resx">
      <SubType>Designer</SubType>
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <EmbeddedResource Update="Tree\TreeViewAdv.resx">
      <DependentUpon>TreeViewAdv.cs</DependentUpon>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <None Include="Tree\ClassDiagram.cd" />
    <None Include="Tree\NodeControls\ClassDiagram.cd" />
  </ItemGroup>
  <ItemGroup>
    <Compile Remove="Tree\ColumnCollection.cs" />
    <Compile Remove="Tree\NativeMethods.cs" />
  </ItemGroup>
</Project>
```

`Aga.Controls/Aga.Controls.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Aga.Controls", "Aga.Controls.csproj", "{E73BB233-D88B-44A7-A98F-D71EE158381D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Aga.Controls/BitmapHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Drawing.Imaging;

namespace Aga.Controls
{
	public static class BitmapHelper
	{
		[StructLayout(LayoutKind.Sequential)]
		private struct PixelData
		{
			public byte B;
			public byte G;
			public byte R;
			public byte A;
		}

		public static void SetAlphaChanelValue(Bitmap image, byte value)
		{
			if (image == null)
				throw new ArgumentNullException("image");
			if (image.PixelFormat != PixelFormat.Format32bppArgb)
				throw new ArgumentException("Wrong PixelFormat");

			BitmapData bitmapData = image.LockBits(new Rectangle(0, 0, image.Width, image.Height),
									 ImageLockMode.ReadWrite, PixelFormat.Format32bppArgb);
			unsafe
			{
				PixelData* pPixel = (PixelData*)bitmapData.Scan0;
				for (int i = 0; i < bitmapData.Height; i++)
				{
					for (int j = 0; j < bitmapData.Width; j++)
					{
						pPixel->A = value;
						pPixel++;
					}
					pPixel += bitmapData.Stride - (bitmapData.Width * 4);
				}
			}
			image.UnlockBits(bitmapData);
		}
	}
}

```

`Aga.Controls/GifDecoder.cs`:

```cs
#pragma warning disable 675 // Bitwise-or operator used on a sign-extended operand

#region Java Info
/**
 * Class GifDecoder - Decodes a GIF file into one or more frames.
 * <br><pre>
 * Example:
 *    GifDecoder d = new GifDecoder();
 *    d.read("sample.gif");
 *    int n = d.getFrameCount();
 *    for (int i = 0; i < n; i++) {
 *       BufferedImage frame = d.getFrame(i);  // frame i
 *       int t = d.getDelay(i);  // display duration of frame in milliseconds
 *       // do something with frame
 *    }
 * </pre>
 * No copyright asserted on the source code of this class.  May be used for
 * any purpose, however, refer to the Unisys LZW patent for any additional
 * restrictions.  Please forward any corrections to kweiner@fmsware.com.
 *
 * @author Kevin Weiner, FM Software; LZW decoder adapted from John Cristy's ImageMagick.
 * @version 1.03 November 2003
 *
 */
#endregion

using System;
using System.Collections;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;

namespace Aga.Controls
{
	public class GifFrame
	{
		private Image _image;
		public Image Image
		{
			get { return _image; }
		}

		private int _delay;
		public int Delay
		{
			get { return _delay; }
		}

		public GifFrame(Image im, int del)
		{
			_image = im;
			_delay = del;
		}
	}

	public class GifDecoder 
	{
		public const int StatusOK = 0;//File read status: No errors.
		public const int StatusFormatError = 1; //File read status: Error decoding file (may be partially decoded)
		public const int StatusOpenError = 2; //Unable to open source.

		private Stream inStream;
		private int status;

		private int width; // full image width
		private int height; // full image height
		private bool gctFlag; // global color table used
		private int gctSize; // size of global color table
		private int loopCount = 1; // iterations; 0 = repeat forever

		private int[] gct; // global color table
		private int[] lct; // local color table
		private int[] act; // active color table

		private int bgIndex; // background color index
		private int bgColor; // background color
		private int lastBgColor; // previous bg color
		private int pixelAspect; // pixel aspect ratio

		private bool lctFlag; // local color table flag
		private bool interlace; // interlace flag
		private int lctSize; // local color table size

		private int ix, iy, iw, ih; // current image rectangle
		private Rectangle lastRect; // last image rect
		private Image image; // current frame
		private Bitmap bitmap;
		private Image lastImage; // previous frame

		private byte[] block = new byte[256]; // current data block
		private int blockSize = 0; // block size

		// last graphic control extension info
		private int dispose = 0;
		// 0=no action; 1=leave in place; 2=restore to bg; 3=restore to prev
		private int lastDispose = 0;
		private bool transparency = false; // use transparent color
		private int delay = 0; // delay in milliseconds
		private int transIndex; // transparent color index

		private const int MaxStackSize = 4096;
		// max decoder pixel stack size

		// LZW decoder working arrays
		private short[] prefix;
		private byte[] suffix;
		private byte[] pixelStack;
		private byte[] pixels;

		private ArrayList frames; // frames read from current file
		private int frameCount;
		private bool _makeTransparent;

		/**
		 * Gets the number of frames read from file.
		 * @return frame count
		 */
		public int FrameCount
		{
			get
			{
				return frameCount;
			}
		}

		/**
		 * Gets the first (or only) image read.
		 *
		 * @return BufferedImage containing first frame, or null if none.
		 */
		public Image Image
		{
			get
			{
				return GetFrame(0).Image;
			}
		}

		/**
		 * Gets the "Netscape" iteration count, if any.
		 * A count of 0 means repeat indefinitiely.
		 *
		 * @return iteration count if one was specified, else 1.
		 */
		public int LoopCount
		{
			get
			{
				return loopCount;
			}
		}

		public GifDecoder(Stream stream, bool makeTransparent)
		{
			_makeTransparent = makeTransparent;
			if (Read(stream) != 0)
				throw new InvalidOperationException();
		}

		/**
		 * Creates new frame image from current data (and previous
		 * frames as specified by their disposition codes).
		 */
		private int[] GetPixels(Bitmap bitmap)
		{
			int [] pixels = new int [ 3 * image.Width * image.Height ];
			int count = 0;
			for (int th = 0; th < image.Height; th++)
			{
				for (int tw = 0; tw < image.Width; tw++)
				{
					Color color = bitmap.GetPixel(tw, th);
					pixels[count] = color.R;
					count++;
					pixels[count] = color.G;
					count++;
					pixels[count] = color.B;
					count++;
				}
			}
			return pixels;
		}

		private void SetPixels(int[] pixels)
		{
			int count = 0;
			for (int th = 0; th < image.Height; th++)
			{
				for (int tw = 0; tw < image.Width; tw++)
				{
					Color color = Color.FromArgb( pixels[count++] );
					bitmap.SetPixel( tw, th, color );
				}
			}
			if (_makeTransparent)
				bitmap.MakeTransparent(bitmap.GetPixel(0, 0));
		}

		private void SetPixels() 
		{
			// expose destination image's pixels as int array
			//		int[] dest =
			//			(( int ) image.getRaster().getDataBuffer()).getData();
			int[] dest = GetPixels( bitmap );

			// fill in starting image contents based on last image's dispose code
			if (lastDispose > 0) 
			{
				if (lastDispose == 3) 
				{
					// use image before last
					int n = frameCount - 2;
					if (n > 0) 
					{
						lastImage = GetFrame(n - 1).Image;
					} 
					else 
					{
						lastImage = null;
					}
				}

				if (lastImage != null) 
				{
					//				int[] prev =
					//					((DataBufferInt) lastImage.getRaster().getDataBuffer()).getData();
					int[] prev = GetPixels( new Bitmap( lastImage ) );
					Array.Copy(prev, 0, dest, 0, width * height);
					// copy pixels

					if (lastDispose == 2) 
					{
						// fill last image rect area with background color
						Graphics g = Graphics.FromImage( image );
						Color c = Color.Empty;
						if (transparency) 
						{
							c = Color.FromArgb( 0, 0, 0, 0 ); 	// assume background is transparent
						} 
						else 
						{
							c = Color.FromArgb( lastBgColor ) ;
							//						c = new Color(lastBgColor); // use given background color
						}
						Brush brush = new SolidBrush( c );
						g.FillRectangle( brush, lastRect );
						brush.Dispose();
						g.Dispose();
					}
				}
			}

			// copy each source line to the appropriate place in the destination
			int pass = 1;
			int inc = 8;
			int iline = 0;
			for (int i = 0; i < ih; i++) 
			{
				int line = i;
				if (interlace) 
				{
					if (iline >= ih) 
					{
						pass++;
						switch (pass) 
						{
							case 2 :
								iline = 4;
								break;
							case 3 :
								iline = 2;
								inc = 4;
								break;
							case 4 :
								iline = 1;
								inc = 2;
								break;
						}
					}
					line = iline;
					iline += inc;
				}
				line += iy;
				if (line < height) 
				{
					int k = line * width;
					int dx = k + ix; // start of line in dest
					int dlim = dx + iw; // end of dest line
					if ((k + width) < dlim) 
					{
						dlim = k + width; // past dest edge
					}
					int sx = i * iw; // start of line in source
					while (dx < dlim) 
					{
						// map color and insert in destination
						int index = ((int) pixels[sx++]) & 0xff;
						int c = act[index];
						if (c != 0) 
						{
							dest[dx] = c;
						}
						dx++;
					}
				}
			}
			SetPixels( dest );
		}

		/**
		 * Gets the image contents of frame n.
		 *
		 * @return BufferedImage representation of frame.
		 */
		public GifFrame GetFrame(int n) 
		{
			if ((n >= 0) && (n < frameCount))
				return (GifFrame)frames[n];
			else
				throw new ArgumentOutOfRangeException();
		}

		/**
		 * Gets image size.
		 *
		 * @return GIF image dimensions
		 */
		public Size FrameSize
		{
			get
			{
				return new Size(width, height);
			}
		}

		/**
		 * Reads GIF image from stream
		 *
		 * @param BufferedInputStream containing GIF file.
		 * @return read status code (0 = no errors)
		 */
		private int Read( Stream inStream ) 
		{
			Init();
			if ( inStream != null) 
			{
				this.inStream = inStream;
				ReadHeader();
				if (!Error()) 
				{
					ReadContents();
					if (frameCount < 0) 
					{
						status = StatusFormatError;
					}
				}
				inStream.Close();
			} 
			else 
			{
				status = StatusOpenError;
			}
			return status;
		}


		/**
		 * Decodes LZW image data into pixel array.
		 * Adapted from John Cristy's ImageMagick.
		 */
		private void DecodeImageData() 
		{
			int NullCode = -1;
			int npix = iw * ih;
			int available, 
				clear,
				code_mask,
				code_size,
				end_of_information,
				in_code,
				old_code,
				bits,
				code,
				count,
				i,
				datum,
				data_size,
				first,
				top,
				bi,
				pi;

			if ((pixels == null) || (pixels.Length < npix)) 
			{
				pixels = new byte[npix]; // allocate new pixel array
			}
			if (prefix == null) prefix = new short[MaxStackSize];
			if (suffix == null) suffix = new byte[MaxStackSize];
			if (pixelStack == null) pixelStack = new byte[MaxStackSize + 1];

			//  Initialize GIF data stream decoder.

			data_size = Read();
			clear = 1 << data_size;
			end_of_information = clear + 1;
			available = clear + 2;
			old_code = NullCode;
			code_size = data_size + 1;
			code_mask = (1 << code_size) - 1;
			for (code = 0; code < clear; code++) 
			{
				prefix[code] = 0;
				suffix[code] = (byte) code;
			}

			//  Decode GIF pixel stream.

			datum = bits = count = first = top = pi = bi = 0;

			for (i = 0; i < npix;) 
			{
				if (top == 0) 
				{
					if (bits < code_size) 
					{
						//  Load bytes until there are enough bits for a code.
						if (count == 0) 
						{
							// Read a new data block.
							count = ReadBlock();
							if (count <= 0)
								break;
							bi = 0;
						}
						datum += (((int) block[bi]) & 0xff) << bits;
						bits += 8;
						bi++;
						count--;
						continue;
					}

					//  Get the next code.

					code = datum & code_mask;
					datum >>= code_size;
					bits -= code_size;

					//  Interpret the code

					if ((code > available) || (code == end_of_information))
						break;
					if (code == clear) 
					{
						//  Reset decoder.
						code_size = data_size + 1;
						code_mask = (1 << code_size) - 1;
						available = clear + 2;
						old_code = NullCode;
						continue;
					}
					if (old_code == NullCode) 
					{
						pixelStack[top++] = suffix[code];
						old_code = code;
						first = code;
						continue;
					}
					in_code = code;
					if (code == available) 
					{
						pixelStack[top++] = (byte) first;
						code = old_code;
					}
					while (code > clear) 
					{
						pixelStack[top++] = suffix[code];
						code = prefix[code];
					}
					first = ((int) suffix[code]) & 0xff;

					//  Add a new string to the string table,

					if (available >= MaxStackSize)
						break;
					pixelStack[top++] = (byte) first;
					prefix[available] = (short) old_code;
					suffix[available] = (byte) first;
					available++;
					if (((available & code_mask) == 0)
						&& (available < MaxStackSize)) 
					{
						code_size++;
						code_mask += available;
					}
					old_code = in_code;
				}

				//  Pop a pixel off the pixel stack.

				top--;
				pixels[pi++] = pixelStack[top];
				i++;
			}

			for (i = pi; i < npix; i++) 
			{
				pixels[i] = 0; // clear missing pixels
			}

		}

		/**
		 * Returns true if an error was encountered during reading/decoding
		 */
		private bool Error() 
		{
			return status != StatusOK;
		}

		/**
		 * Initializes or re-initializes reader
		 */
		private void Init() 
		{
			status = StatusOK;
			frameCount = 0;
			frames = new ArrayList();
			gct = null;
			lct = null;
		}

		/**
		 * Reads a single byte from the input stream.
		 */
		private int Read() 
		{
			int curByte = 0;
			try 
			{
				curByte = inStream.ReadByte();
			} 
			catch (IOException) 
			{
				status = StatusFormatError;
			}
			return curByte;
		}

		/**
		 * Reads next variable length block from input.
		 *
		 * @return number of bytes stored in "buffer"
		 */
		private int ReadBlock() 
		{
			blockSize = Read();
			int n = 0;
			if (blockSize > 0) 
			{
				try 
				{
					int count = 0;
					while (n < blockSize) 
					{
						count = inStream.Read(block, n, blockSize - n);
						if (count == -1) 
							break;
						n += count;
					}
				} 
				catch (IOException) 
				{
				}

				if (n < blockSize) 
				{
					status = StatusFormatError;
				}
			}
			return n;
		}

		/**
		 * Reads color table as 256 RGB integer values
		 *
		 * @param ncolors int number of colors to read
		 * @return int array containing 256 colors (packed ARGB with full alpha)
		 */
		private int[] ReadColorTable(int ncolors) 
		{
			int nbytes = 3 * ncolors;
			int[] tab = null;
			byte[] c = new byte[nbytes];
			int n = 0;
			try 
			{
				n = inStream.Read(c, 0, c.Length );
			} 
			catch (IOException) 
			{
			}
			if (n < nbytes) 
			{
				status = StatusFormatError;
			} 
			else 
			{
				tab = new int[256]; // max size to avoid bounds checks
				int i = 0;
				int j = 0;
				while (i < ncolors) 
				{
					int r = ((int) c[j++]) & 0xff;
					int g = ((int) c[j++]) & 0xff;
					int b = ((int) c[j++]) & 0xff;
					tab[i++] = ( int ) ( 0xff000000 | (r << 16) | (g << 8) | b );
				}
			}
			return tab;
		}

		/**
		 * Main file parser.  Reads GIF content blocks.
		 */
		private void ReadContents() 
		{
			// read GIF file content blocks
			bool done = false;
			while (!(done || Error())) 
			{
				int code = Read();
				switch (code) 
				{

					case 0x2C : // image separator
						ReadImage();
						break;

					case 0x21 : // extension
						code = Read();
					switch (code) 
					{
						case 0xf9 : // graphics control extension
							ReadGraphicControlExt();
							break;

						case 0xff : // application extension
							ReadBlock();
							String app = "";
							for (int i = 0; i < 11; i++) 
							{
								app += (char) block[i];
							}
							if (app.Equals("NETSCAPE2.0")) 
							{
								ReadNetscapeExt();
							}
							else
								Skip(); // don't care
							break;

						default : // uninteresting extension
							Skip();
							break;
					}
						break;

					case 0x3b : // terminator
						done = true;
						break;

					case 0x00 : // bad byte, but keep going and see what happens
						break;

					default :
						status = StatusFormatError;
						break;
				}
			}
		}

		/**
		 * Reads Graphics Control Extension values
		 */
		private void ReadGraphicControlExt() 
		{
			Read(); // block size
			int packed = Read(); // packed fields
			dispose = (packed & 0x1c) >> 2; // disposal method
			if (dispose == 0) 
			{
				dispose = 1; // elect to keep old image if discretionary
			}
			transparency = (packed & 1) != 0;
			delay = ReadShort() * 10; // delay in milliseconds
			transIndex = Read(); // transparent color index
			Read(); // block terminator
		}

		/**
		 * Reads GIF file header information.
		 */
		private void ReadHeader() 
		{
			String id = "";
			for (int i = 0; i < 6; i++) 
			{
				id += (char) Read();
			}
			if (!id.StartsWith("GIF")) 
			{
				status = StatusFormatError;
				return;
			}

			ReadLSD();
			if (gctFlag && !Error()) 
			{
				gct = ReadColorTable(gctSize);
				bgColor = gct[bgIndex];
			}
		}

		/**
		 * Reads next frame image
		 */
		private void ReadImage() 
		{
			ix = ReadShort(); // (sub)image position & size
			iy = ReadShort();
			iw = ReadShort();
			ih = ReadShort();

			int packed = Read();
			lctFlag = (packed & 0x80) != 0; // 1 - local color table flag
			interlace = (packed & 0x40) != 0; // 2 - interlace flag
			// 3 - sort flag
			// 4-5 - reserved
			lctSize = 2 << (packed & 7); // 6-8 - local color table size

			if (lctFlag) 
			{
				lct = ReadColorTable(lctSize); // read table
				act = lct; // make local table active
			} 
			else 
			{
				act = gct; // make global table active
				if (bgIndex == transIndex)
					bgColor = 0;
			}
			int save = 0;
			if (transparency) 
			{
				save = act[transIndex];
				act[transIndex] = 0; // set transparent color if specified
			}

			if (act == null) 
			{
				status = StatusFormatError; // no color table defined
			}

			if (Error()) return;

			DecodeImageData(); // decode pixel data
			Skip();

			if (Error()) return;

			frameCount++;

			// create new image to receive frame data
			//		image =
			//			new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB_PRE);

			bitmap = new Bitmap( width, height );
			image = bitmap;
			SetPixels(); // transfer pixel data to image

			frames.Add(new GifFrame(bitmap, delay)); // add image to frame list

			if (transparency) 
			{
				act[transIndex] = save;
			}
			ResetFrame();

		}

		/**
		 * Reads Logical Screen Descriptor
		 */
		private void ReadLSD() 
		{

			// logical screen size
			width = ReadShort();
			height = ReadShort();

			// packed fields
			int packed = Read();
			gctFlag = (packed & 0x80) != 0; // 1   : global color table flag
			// 2-4 : color resolution
			// 5   : gct sort flag
			gctSize = 2 << (packed & 7); // 6-8 : gct size

			bgIndex = Read(); // background color index
			pixelAspect = Read(); // pixel aspect ratio
		}

		/**
		 * Reads Netscape extenstion to obtain iteration count
		 */
		private void ReadNetscapeExt() 
		{
			do 
			{
				ReadBlock();
				if (block[0] == 1) 
				{
					// loop count sub-block
					int b1 = ((int) block[1]) & 0xff;
					int b2 = ((int) block[2]) & 0xff;
					loopCount = (b2 << 8) | b1;
				}
			} while ((blockSize > 0) && !Error());
		}

		/**
		 * Reads next 16-bit value, LSB first
		 */
		private int ReadShort() 
		{
			// read 16-bit value, LSB first
			return Read() | (Read() << 8);
		}

		/**
		 * Resets frame state for reading next image.
		 */
		private void ResetFrame() 
		{
			lastDispose = dispose;
			lastRect = new Rectangle(ix, iy, iw, ih);
			lastImage = image;
			lastBgColor = bgColor;
			//		int dispose = 0;
			lct = null;
		}

		/**
		 * Skips variable length blocks up to and including
		 * next zero length block.
		 */
		private void Skip() 
		{
			do 
			{
				ReadBlock();
			} while ((blockSize > 0) && !Error());
		}
	}
}

```

`Aga.Controls/NumericTextBox.cs`:

```cs
using System;
using System.ComponentModel;
using System.Windows.Forms;
using System.Globalization;


namespace Aga.Controls
{
	/// <summary>
	/// Restricts the entry of characters to digits, the negative sign,
	/// the decimal point, and editing keystrokes (backspace).
	/// It does not handle the AltGr key so any keys that can be created in any
	/// combination with AltGr these are not filtered
	/// </summary>
	public class NumericTextBox : TextBox
	{
		private const int WM_PASTE = 0x302;
		private NumberStyles numberStyle = NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign;

		/// <summary>
		/// Restricts the entry of characters to digits, the negative sign,
		/// the decimal point, and editing keystrokes (backspace).
		/// It does not handle the AltGr key
		/// </summary>
		/// <param name="e"></param>
		protected override void OnKeyPress(KeyPressEventArgs e)
		{
			base.OnKeyPress(e);

			e.Handled = invalidNumeric(e.KeyChar);
		}


		/// <summary>
		/// Main method for verifying allowed keypresses.
		/// This does not catch cut paste copy ... operations.
		/// </summary>
		/// <param name="key"></param>
		/// <returns></returns>
		private bool invalidNumeric(char key)
		{
			bool handled = false;

			NumberFormatInfo numberFormatInfo = CultureInfo.CurrentCulture.NumberFormat;
			string decimalSeparator = numberFormatInfo.NumberDecimalSeparator;
			string negativeSign = numberFormatInfo.NegativeSign;

			string keyString = key.ToString();

			if (Char.IsDigit(key))
			{
				// Digits are OK
			}
			else if (AllowDecimalSeparator && keyString.Equals(decimalSeparator))
			{
				if (Text.IndexOf(decimalSeparator) >= 0)
				{
					handled = true;
				}
			}
			else if (AllowNegativeSign && keyString.Equals(negativeSign))
			{
				if (Text.IndexOf(negativeSign) >= 0)
				{
					handled = true;
				}
			}
			else if (key == '\b')
			{
				// Backspace key is OK
			}
			else if ((ModifierKeys & (Keys.Control)) != 0)
			{
				// Let the edit control handle control and alt key combinations
			}
			else
			{
				// Swallow this invalid key and beep
				handled = true;
			}
			return handled;
		}


		/// <summary>
		/// Method invoked when Windows sends a message.
		/// </summary>
		/// <param name="m">Message from Windows.</param>
		/// <remarks>
		/// This is over-ridden so that the user can not use
		/// cut or paste operations to bypass the TextChanging event.
		/// This catches ContextMenu Paste, Shift+Insert, Ctrl+V,
		/// While it is generally frowned upon to override WndProc, no
		/// other simple mechanism was apparent to simultaneously and
		/// transparently intercept so many different operations.
		/// </remarks>
		protected override void WndProc(ref Message m)
		{
			// Switch to handle message...
			switch (m.Msg)
			{
				case WM_PASTE:
					{
						// Get clipboard object to paste
						IDataObject clipboardData = Clipboard.GetDataObject();

						// Get text from clipboard data
						string pasteText = (string)clipboardData.GetData(
								DataFormats.UnicodeText);

						// Get the number of characters to replace
						int selectionLength = SelectionLength;

						// If no replacement or insertion, we are done
						if (pasteText.Length == 0)
						{
							break;
						}
						else if (selectionLength != 0)
						{
							base.Text = base.Text.Remove(SelectionStart, selectionLength);
						}

						bool containsInvalidChars = false;
						foreach (char c in pasteText)
						{
							if (containsInvalidChars)
							{
								break;
							}
							else if (invalidNumeric(c))
							{
								containsInvalidChars = true;
							}
						}

						if (!containsInvalidChars)
						{
							base.Text = base.Text.Insert(SelectionStart, pasteText);
						}

						return;
					}

			}
			base.WndProc(ref m);
		}


		public int IntValue
		{
			get
			{
				int intValue;
				Int32.TryParse(this.Text, numberStyle, CultureInfo.CurrentCulture.NumberFormat, out intValue);
				return intValue;
			}
		}

		public decimal DecimalValue
		{
			get
			{
				decimal decimalValue;
				Decimal.TryParse(this.Text, numberStyle, CultureInfo.CurrentCulture.NumberFormat, out decimalValue);
				return decimalValue;
			}
		}


		private bool allowNegativeSign;
		[DefaultValue(true)]
		public bool AllowNegativeSign
		{
			get { return allowNegativeSign; }
			set { allowNegativeSign = value; }
		}

		private bool allowDecimalSeparator;
		[DefaultValue(true)]
		public bool AllowDecimalSeparator
		{
			get { return allowDecimalSeparator; }
			set { allowDecimalSeparator = value; }
		}

	}

}

```

`Aga.Controls/PerformanceAnalyzer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;

namespace Aga.Controls
{
	/// <summary>
	/// Is used to analyze code performance
	/// </summary>
	public static class PerformanceAnalyzer
	{
		public class PerformanceInfo
		{
			private string _name;
			public string Name
			{
				get { return _name; }
			}

			private int _count = 0;
			public int Count
			{
				get { return _count; }
				set { _count = value; }
			}

			private double _totalTime = 0;
			public double TotalTime
			{
				get { return _totalTime; }
				set { _totalTime = value; }
			}

			private Int64 _start;
			public Int64 Start
			{
				get { return _start; }
				set { _start = value; }
			}

			public PerformanceInfo(string name)
			{
				_name = name;
			}
		}

		private static Dictionary<string, PerformanceInfo> _performances = new Dictionary<string, PerformanceInfo>();

		public static IEnumerable<PerformanceInfo> Performances
		{
			get
			{
				return _performances.Values;
			}
		}

		[Conditional("DEBUG")]
		public static void Start(string pieceOfCode)
		{
			PerformanceInfo info = null;
			lock(_performances)
			{
				if (_performances.ContainsKey(pieceOfCode))
					info = _performances[pieceOfCode];
				else
				{
					info = new PerformanceInfo(pieceOfCode);
					_performances.Add(pieceOfCode, info);
				}

				info.Count++;
				info.Start = TimeCounter.GetStartValue();
			}
		}

		[Conditional("DEBUG")]
		public static void Finish(string pieceOfCode)
		{
			lock (_performances)
			{
				if (_performances.ContainsKey(pieceOfCode))
				{
					PerformanceInfo info = _performances[pieceOfCode];
					info.Count++;
					info.TotalTime += TimeCounter.Finish(info.Start);
				}
			}
		}

		public static void Reset()
		{
			_performances.Clear();
		}

		public static string GenerateReport()
		{
			return GenerateReport(0);
		}

		public static string GenerateReport(string mainPieceOfCode)
		{
			if (_performances.ContainsKey(mainPieceOfCode))
				return GenerateReport(_performances[mainPieceOfCode].TotalTime);
			else
				return GenerateReport(0);
		}

		public static string GenerateReport(double totalTime)
		{
			StringBuilder sb = new StringBuilder();
			int len = 0;
			foreach (PerformanceInfo info in Performances)
				len = Math.Max(info.Name.Length, len);

			sb.AppendLine("Name".PadRight(len) + " Count              Total Time, ms    Avg. Time, ms       Percentage, %");
			sb.AppendLine("----------------------------------------------------------------------------------------------");
			foreach (PerformanceInfo info in Performances)
			{
				sb.Append(info.Name.PadRight(len));
				double p = 0;
				double avgt = 0;
				if (totalTime != 0)
					p = info.TotalTime / totalTime;
				if (info.Count > 0)
					avgt = info.TotalTime * 1000 / info.Count;
				string c = info.Count.ToString("0,0").PadRight(20);
				string tt = (info.TotalTime * 1000).ToString("0,0.00").PadRight(20);
				string t = avgt.ToString("0.0000").PadRight(20);
				string sp = (p * 100).ToString("###").PadRight(20);
				sb.AppendFormat(" " + c + tt + t + sp + "\n");
			}
			return sb.ToString();
		}
	}
}

```

`Aga.Controls/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.235
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Aga.Controls.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Aga.Controls.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        internal static System.Drawing.Bitmap check {
            get {
                object obj = ResourceManager.GetObject("check", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static byte[] DVSplit {
            get {
                object obj = ResourceManager.GetObject("DVSplit", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        internal static System.Drawing.Bitmap Folder {
            get {
                object obj = ResourceManager.GetObject("Folder", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap FolderClosed {
            get {
                object obj = ResourceManager.GetObject("FolderClosed", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap Leaf {
            get {
                object obj = ResourceManager.GetObject("Leaf", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static byte[] loading_icon {
            get {
                object obj = ResourceManager.GetObject("loading_icon", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        internal static System.Drawing.Bitmap minus {
            get {
                object obj = ResourceManager.GetObject("minus", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap plus {
            get {
                object obj = ResourceManager.GetObject("plus", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap uncheck {
            get {
                object obj = ResourceManager.GetObject("uncheck", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap unknown {
            get {
                object obj = ResourceManager.GetObject("unknown", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
    }
}

```

`Aga.Controls/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="check" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\check.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="DVSplit" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\DVSplit.cur;System.Byte[], mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="Folder" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Folder.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="FolderClosed" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\FolderClosed.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Leaf" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Leaf.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="loading_icon" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\loading_icon;System.Byte[], mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="minus" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\minus.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="plus" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\plus.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="uncheck" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\uncheck.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="unknown" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\unknown.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
</root>
```

`Aga.Controls/ResourceHelper.cs`:

```cs
using System;
using System.IO;
using System.Reflection;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls
{
    public static class ResourceHelper
    {
        // VSpilt Cursor with Innerline (symbolisize hidden column)
        private static Cursor _dVSplitCursor = GetCursor(Properties.Resources.DVSplit);
        public static Cursor DVSplitCursor
        {
            get { return _dVSplitCursor; }
        }

		private static GifDecoder _loadingIcon = GetGifDecoder(Properties.Resources.loading_icon);
		public static GifDecoder LoadingIcon
		{
			get { return _loadingIcon; }
		}

        /// <summary>
        /// Help function to convert byte[] from resource into Cursor Type 
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        private static Cursor GetCursor(byte[] data)
        {
            using (MemoryStream s = new MemoryStream(data))
                return new Cursor(s);
        }

		/// <summary>
		/// Help function to convert byte[] from resource into GifDecoder Type 
		/// </summary>
		/// <param name="data"></param>
		/// <returns></returns>
		private static GifDecoder GetGifDecoder(byte[] data)
		{
			using(MemoryStream ms = new MemoryStream(data))
				return new GifDecoder(ms, true);
		}

    }
}

```

`Aga.Controls/StringCollectionEditor.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel.Design;

namespace Aga.Controls
{
	public class StringCollectionEditor : CollectionEditor
	{
		public StringCollectionEditor(Type type): base(type)
		{
		}

		protected override Type CreateCollectionItemType()
		{
			return typeof(string);
		}

		protected override object CreateInstance(Type itemType)
		{
			return "";
		}
	}
}

```

`Aga.Controls/TextHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;

namespace Aga.Controls
{
	public static class TextHelper
	{
		public static StringAlignment TranslateAligment(HorizontalAlignment alignment)
		{
			if (alignment == HorizontalAlignment.Left)
				return StringAlignment.Near;
			else if (alignment == HorizontalAlignment.Right)
				return StringAlignment.Far;
			else
				return StringAlignment.Center;
		}

        public static TextFormatFlags TranslateAligmentToFlag(HorizontalAlignment alignment)
        {
            if (alignment == HorizontalAlignment.Left)
                return TextFormatFlags.Left;
            else if (alignment == HorizontalAlignment.Right)
                return TextFormatFlags.Right;
            else
                return TextFormatFlags.HorizontalCenter;
        }

		public static TextFormatFlags TranslateTrimmingToFlag(StringTrimming trimming)
		{
			if (trimming == StringTrimming.EllipsisCharacter)
				return TextFormatFlags.EndEllipsis;
			else if (trimming == StringTrimming.EllipsisPath)
				return TextFormatFlags.PathEllipsis;
			if (trimming == StringTrimming.EllipsisWord)
				return TextFormatFlags.WordEllipsis;
			if (trimming == StringTrimming.Word)
				return TextFormatFlags.WordBreak;
			else
				return TextFormatFlags.Default;
		}
	}
}

```

`Aga.Controls/Threading/AbortableThreadPool.cs`:

```cs
// Stephen Toub
// stoub@microsoft.com

using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace Aga.Controls.Threading
{
	public class AbortableThreadPool
	{
		private LinkedList<WorkItem> _callbacks = new LinkedList<WorkItem>();
		private Dictionary<WorkItem, Thread> _threads = new Dictionary<WorkItem, Thread>();

		public WorkItem QueueUserWorkItem(WaitCallback callback)
		{
			return QueueUserWorkItem(callback, null);
		}

		public WorkItem QueueUserWorkItem(WaitCallback callback, object state)
		{
			if (callback == null) throw new ArgumentNullException("callback");

			WorkItem item = new WorkItem(callback, state, ExecutionContext.Capture());
			lock (_callbacks)
			{
				_callbacks.AddLast(item);
			}
			ThreadPool.QueueUserWorkItem(new WaitCallback(HandleItem));
			return item;
		}

		private void HandleItem(object ignored)
		{
			WorkItem item = null;
			try
			{
				lock (_callbacks)
				{
					if (_callbacks.Count > 0)
					{
						item = _callbacks.First.Value;
						_callbacks.RemoveFirst();
					}
					if (item == null)
						return;
					_threads.Add(item, Thread.CurrentThread);

				}
				ExecutionContext.Run(item.Context,
					delegate { item.Callback(item.State); }, null);
			}
			finally
			{
				lock (_callbacks)
				{
					if (item != null)
						_threads.Remove(item);
				}
			}
		}

		public bool IsMyThread(Thread thread)
		{
			lock (_callbacks)
			{
				foreach (Thread t in _threads.Values)
				{
					if (t == thread)
						return true;
				}
				return false;
			}
		}

		public WorkItemStatus Cancel(WorkItem item, bool allowAbort)
		{
			if (item == null)
				throw new ArgumentNullException("item");
			lock (_callbacks)
			{
				LinkedListNode<WorkItem> node = _callbacks.Find(item);
				if (node != null)
				{
					_callbacks.Remove(node);
					return WorkItemStatus.Queued;
				}
				else if (_threads.ContainsKey(item))
				{
					if (allowAbort)
					{
						_threads[item].Abort();
						_threads.Remove(item);
						return WorkItemStatus.Aborted;
					}
					else
						return WorkItemStatus.Executing;
				}
				else
					return WorkItemStatus.Completed;
			}
		}

		public void CancelAll(bool allowAbort)
		{
			lock (_callbacks)
			{
				_callbacks.Clear();
				if (allowAbort)
				{
					foreach (Thread t in _threads.Values)
						t.Abort();
				}
			}
		}
	}
}

```

`Aga.Controls/Threading/WorkItem.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace Aga.Controls.Threading
{
	public sealed class WorkItem
	{
		private WaitCallback _callback;
		private object _state;
		private ExecutionContext _ctx;

		internal WorkItem(WaitCallback wc, object state, ExecutionContext ctx)
		{
			_callback = wc; 
			_state = state; 
			_ctx = ctx;
		}

		internal WaitCallback Callback
		{
			get
			{
				return _callback;
			}
		}

		internal object State
		{
			get
			{
				return _state;
			}
		}

		internal ExecutionContext Context
		{
			get
			{
				return _ctx;
			}
		}
	}
}

```

`Aga.Controls/Threading/WorkItemStatus.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Threading
{
	public enum WorkItemStatus 
	{ 
		Completed, 
		Queued, 
		Executing, 
		Aborted 
	}
}

```

`Aga.Controls/TimeCounter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;

namespace Aga.Controls
{
	/// <summary>
	/// High resolution timer, used to test performance
	/// </summary>
	public static class TimeCounter
	{
		private static Int64 _start;

		/// <summary>
		/// Start time counting
		/// </summary>
		public static void Start()
		{
			_start = 0;
			QueryPerformanceCounter(ref _start);
		}

		public static Int64 GetStartValue()
		{
			Int64 t = 0;
			QueryPerformanceCounter(ref t);
			return t;
		}

		/// <summary>
		/// Finish time counting
		/// </summary>
		/// <returns>time in seconds elapsed from Start till Finish	</returns>
		public static double Finish()
		{
			return Finish(_start);
		}

		public static double Finish(Int64 start)
		{
			Int64 finish = 0;
			QueryPerformanceCounter(ref finish);

			Int64 freq = 0;
			QueryPerformanceFrequency(ref freq);
			return (finish - start) / (double)freq;
		}

		[DllImport("Kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryPerformanceCounter(ref Int64 performanceCount);

		[DllImport("Kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryPerformanceFrequency(ref Int64 frequency);
	}
}

```

`Aga.Controls/Tree/AutoRowHeightLayout.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public class AutoRowHeightLayout: IRowLayout
	{
		private DrawContext _measureContext;
		private TreeViewAdv _treeView;
		private List<Rectangle> _rowCache;

		public AutoRowHeightLayout(TreeViewAdv treeView, int rowHeight)
		{
			_rowCache = new List<Rectangle>();
			_treeView = treeView;
			PreferredRowHeight = rowHeight;
			_measureContext = new DrawContext();
			_measureContext.Graphics = Graphics.FromImage(new Bitmap(1, 1));
		}

		private int _rowHeight;
		public int PreferredRowHeight
		{
			get { return _rowHeight; }
			set { _rowHeight = value; }
		}


		public int PageRowCount
		{
			get 
			{
				if (_treeView.RowCount == 0)
					return 0;
				else
				{
					int pageHeight = _treeView.DisplayRectangle.Height - _treeView.ColumnHeaderHeight;
					int y = 0;
					for (int i = _treeView.RowCount - 1; i >= 0; i--)
					{
						y += GetRowHeight(i);
						if (y > pageHeight)
							return Math.Max(0, _treeView.RowCount - 1 - i);
					}
					return _treeView.RowCount;
				}
			}
		}

		public int CurrentPageSize
		{
			get
			{
				if (_treeView.RowCount == 0)
					return 0;
				else
				{
					int pageHeight = _treeView.DisplayRectangle.Height - _treeView.ColumnHeaderHeight;
					int y = 0;
					for (int i = _treeView.FirstVisibleRow; i < _treeView.RowCount; i++)
					{
						y += GetRowHeight(i);
						if (y > pageHeight)
							return Math.Max(0, i - _treeView.FirstVisibleRow);
					}
					return Math.Max(0, _treeView.RowCount - _treeView.FirstVisibleRow);
				}
			}
		}

		public Rectangle GetRowBounds(int rowNo)
		{
			if (rowNo >= _rowCache.Count)
			{
				int count = _rowCache.Count;
				int y = count > 0 ? _rowCache[count - 1].Bottom : 0;
				for (int i = count; i <= rowNo; i++)
				{
					int height = GetRowHeight(i);
					_rowCache.Add(new Rectangle(0, y, 0, height));
					y += height;
				}
				if (rowNo < _rowCache.Count - 1)
					return Rectangle.Empty;
			}
			if (rowNo >= 0 && rowNo < _rowCache.Count)
				return _rowCache[rowNo];
			else
				return Rectangle.Empty;
		}

		private int GetRowHeight(int rowNo)
		{
			if (rowNo < _treeView.RowMap.Count)
			{
				TreeNodeAdv node = _treeView.RowMap[rowNo];
				if (node.Height == null)
				{
					int res = 0;
					_measureContext.Font = _treeView.Font;
					foreach (NodeControl nc in _treeView.NodeControls)
					{
						int h = nc.GetActualSize(node, _measureContext).Height;
						if (h > res)
							res = h;
					}
					node.Height = res;
				}
				return node.Height.Value;
			}
			else
				return 0;
		}

		public int GetRowAt(Point point)
		{
			int py = point.Y - _treeView.ColumnHeaderHeight;
			int y = 0;
			for (int i = _treeView.FirstVisibleRow; i < _treeView.RowCount; i++)
			{
				int h = GetRowHeight(i);
				if (py >= y && py < y + h)
					return i;
				else
					y += h;
			}
			return -1;
		}

		public int GetFirstRow(int lastPageRow)
		{
			int pageHeight = _treeView.DisplayRectangle.Height - _treeView.ColumnHeaderHeight;
			int y = 0;
			for (int i = lastPageRow; i >= 0; i--)
			{
				y += GetRowHeight(i);
				if (y > pageHeight)
					return Math.Max(0, i + 1);
			}
			return 0;
		}

		public void ClearCache()
		{
			_rowCache.Clear();
		}
	}
}

```

`Aga.Controls/Tree/ClassDiagram.cd`:

```cd
<?xml version="1.0" encoding="utf-8"?>
<ClassDiagram MajorVersion="1" MinorVersion="1" MembersFormat="FullSignature">
  <Font Name="Microsoft Sans Serif" Size="8.25" />
  <Class Name="Aga.Controls.Tree.TreeModel" BaseTypeListCollapsed="true">
    <Position X="0.5" Y="7" Width="3.75" />
    <TypeIdentifier>
      <FileName>Tree\TreeModel.cs</FileName>
      <HashCode>AAAkgAAAAAAQAGQAAAAAEAAAEAACQAAAUAAAAAAAAQE=</HashCode>
    </TypeIdentifier>
    <Members>
      <Field Name="_root" Hidden="true" />
    </Members>
    <Compartments>
      <Compartment Name="Fields" Collapsed="true" />
    </Compartments>
    <Lollipop Position="0.2" />
  </Class>
  <Class Name="Aga.Controls.Tree.TreePath">
    <Position X="4.5" Y="4.25" Width="2" />
    <TypeIdentifier>
      <FileName>Tree\TreePath.cs</FileName>
      <HashCode>GABAAAAAAAACAAAAAAIAAAAAAAAACAAAAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
    <Members>
      <Field Name="_path" Hidden="true" />
      <Field Name="Empty" Hidden="true" />
      <Method Name="TreePath" Hidden="true" />
    </Members>
    <Compartments>
      <Compartment Name="Fields" Collapsed="true" />
    </Compartments>
  </Class>
  <Class Name="Aga.Controls.Tree.Node">
    <Position X="4.75" Y="7" Width="2.5" />
    <TypeIdentifier>
      <FileName>Tree\Node.cs</FileName>
      <HashCode>AAAgABAAgCAAAAAAAgAEVAAQAAAQAAAIAAsgCAAAAAA=</HashCode>
    </TypeIdentifier>
    <Members>
      <Field Name="_checkState" Hidden="true" />
      <Field Name="_model" Hidden="true" />
      <Field Name="_nodes" Hidden="true" />
      <Field Name="_parent" Hidden="true" />
      <Field Name="_text" Hidden="true" />
    </Members>
    <Compartments>
      <Compartment Name="Fields" Collapsed="true" />
    </Compartments>
    <NestedTypes>
      <Class Name="Aga.Controls.Tree.Node.NodeCollection" Collapsed="true">
        <TypeIdentifier>
          <NewMemberFileName>Tree\Node.cs</NewMemberFileName>
        </TypeIdentifier>
      </Class>
    </NestedTypes>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeControl">
    <Position X="0.5" Y="0.5" Width="3.75" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeControl.cs</FileName>
      <HashCode>AAAAAAAAgAAAgsIAAAhAQAAwAAAAEAAAAEAIAAAAAAA=</HashCode>
    </TypeIdentifier>
    <Members>
      <Field Name="_column" Hidden="true" />
      <Field Name="_parent" Hidden="true" />
      <Field Name="_toolTipProvider" Hidden="true" />
      <Method Name="AssignParent" Hidden="true" />
    </Members>
  </Class>
  <Interface Name="Aga.Controls.Tree.ITreeModel">
    <Position X="0.5" Y="4.25" Width="3.5" />
    <TypeIdentifier>
      <FileName>Tree\ITreeModel.cs</FileName>
      <HashCode>AAAEAAAAAAAAAEQAAAAAEAAAEAAAQAAAAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Interface>
  <Interface Name="Aga.Controls.Tree.IToolTipProvider">
    <Position X="4.5" Y="0.5" Width="2.75" />
    <TypeIdentifier>
      <FileName>Tree\IToolTipProvider.cs</FileName>
      <HashCode>AAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Interface>
</ClassDiagram>
```

`Aga.Controls/Tree/ColumnCollection.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections.ObjectModel;

namespace Aga.Controls.Tree
{
	/*internal class ColumnCollection: Collection<Column>
	{
		public int TotalWidth
		{
			get
			{
				int res = 0;
				foreach (Column c in Items)
					res += c.Width;
				return res;
			}
		}
	}*/
}

```

`Aga.Controls/Tree/DrawContext.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public struct DrawContext
	{
		private Graphics _graphics;
		public Graphics Graphics
		{
			get { return _graphics; }
			set { _graphics = value; }
		}

		private Rectangle _bounds;
		public Rectangle Bounds
		{
			get { return _bounds; }
			set { _bounds = value; }
		}

		private Font _font;
		public Font Font
		{
			get { return _font; }
			set { _font = value; }
		}

		private DrawSelectionMode _drawSelection;
		public DrawSelectionMode DrawSelection
		{
			get { return _drawSelection; }
			set { _drawSelection = value; }
		}

		private bool _drawFocus;
		public bool DrawFocus
		{
			get { return _drawFocus; }
			set { _drawFocus = value; }
		}

		private NodeControl _currentEditorOwner;
		public NodeControl CurrentEditorOwner
		{
			get { return _currentEditorOwner; }
			set { _currentEditorOwner = value; }
		}

		private bool _enabled;
		public bool Enabled
		{
			get { return _enabled; }
			set { _enabled = value; }
		}
	}
}

```

`Aga.Controls/Tree/DropNodeValidatingEventArgs.cs`:

```cs
using System;
using System.Drawing;

namespace Aga.Controls.Tree
{
	public class DropNodeValidatingEventArgs: EventArgs
	{
		Point _point;
		TreeNodeAdv _node;

		public DropNodeValidatingEventArgs(Point point, TreeNodeAdv node)
		{
			_point = point;
			_node = node;
		}

		public Point Point
		{
			get { return _point; }
		}

		public TreeNodeAdv Node
		{
			get { return _node; }
			set { _node = value; }
		}
	}
}

```

`Aga.Controls/Tree/DropPosition.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public struct DropPosition
	{
		private TreeNodeAdv _node;
		public TreeNodeAdv Node
		{
			get { return _node; }
			set { _node = value; }
		}

		private NodePosition _position;
		public NodePosition Position
		{
			get { return _position; }
			set { _position = value; }
		}
	}
}

```

`Aga.Controls/Tree/EditorContext.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public struct EditorContext
	{
		private TreeNodeAdv _currentNode;
		public TreeNodeAdv CurrentNode
		{
			get { return _currentNode; }
			set { _currentNode = value; }
		}

		private Control _editor;
		public Control Editor
		{
			get { return _editor; }
			set { _editor = value; }
		}

		private NodeControl _owner;
		public NodeControl Owner
		{
			get { return _owner; }
			set { _owner = value; }
		}

		private Rectangle _bounds;
		public Rectangle Bounds
		{
			get { return _bounds; }
			set { _bounds = value; }
		}

		private DrawContext _drawContext;
		public DrawContext DrawContext
		{
			get { return _drawContext; }
			set { _drawContext = value; }
		}
	}
}

```

`Aga.Controls/Tree/Enums.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public enum DrawSelectionMode
	{
		None, Active, Inactive, FullRowSelect
	}

	public enum TreeSelectionMode
	{
		Single, Multi, MultiSameParent
	}

	public enum NodePosition
	{
		Inside, Before, After
	}

	public enum VerticalAlignment
	{
		Top, Bottom, Center
	}

	public enum IncrementalSearchMode
	{
		None, Standard, Continuous
	}

	[Flags]
    public enum GridLineStyle
    {
		None = 0, 
		Horizontal = 1, 
		Vertical = 2, 
		HorizontalAndVertical = 3
    }

	public enum ImageScaleMode
	{
		/// <summary>
		/// Don't scale
		/// </summary>
		Clip,
		/// <summary>
		/// Scales image to fit the display rectangle, aspect ratio is not fixed.
		/// </summary>
		Fit,
		/// <summary>
		/// Scales image down if it is larger than display rectangle, taking aspect ratio into account
		/// </summary>
		ScaleDown,
		/// <summary>
		/// Scales image up if it is smaller than display rectangle, taking aspect ratio into account
		/// </summary>
		ScaleUp,
		/// <summary>
		/// Scales image to match the display rectangle, taking aspect ratio into account
		/// </summary>
		AlwaysScale,

	}
}

```

`Aga.Controls/Tree/FixedRowHeightLayout.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;

namespace Aga.Controls.Tree
{
	internal class FixedRowHeightLayout : IRowLayout
	{
		private TreeViewAdv _treeView;

		public FixedRowHeightLayout(TreeViewAdv treeView, int rowHeight)
		{
			_treeView = treeView;
			PreferredRowHeight = rowHeight;
		}

		private int _rowHeight;
		public int PreferredRowHeight
		{
			get { return _rowHeight; }
			set { _rowHeight = value; }
		}

		public Rectangle GetRowBounds(int rowNo)
		{
			return new Rectangle(0, rowNo * _rowHeight, 0, _rowHeight);
		}

		public int PageRowCount
		{
			get
			{
				return Math.Max((_treeView.DisplayRectangle.Height - _treeView.ColumnHeaderHeight) / _rowHeight, 0);
			}
		}

		public int CurrentPageSize
		{
			get
			{
				return PageRowCount;
			}
		}

		public int GetRowAt(Point point)
		{
			point = new Point(point.X, point.Y + (_treeView.FirstVisibleRow * _rowHeight) - _treeView.ColumnHeaderHeight);
			return point.Y / _rowHeight;
		}

		public int GetFirstRow(int lastPageRow)
		{
			return Math.Max(0, lastPageRow - PageRowCount + 1);
		}

		public void ClearCache()
		{
		}
	}
}

```

`Aga.Controls/Tree/IRowLayout.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;

namespace Aga.Controls.Tree
{
	internal interface IRowLayout
	{
		int PreferredRowHeight
		{
			get;
			set;
		}

		int PageRowCount
		{
			get;
		}

		int CurrentPageSize
		{
			get;
		}

		Rectangle GetRowBounds(int rowNo);

		int GetRowAt(Point point);

		int GetFirstRow(int lastPageRow);

		void ClearCache();
	}
}

```

`Aga.Controls/Tree/IToolTipProvider.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public interface IToolTipProvider
	{
		string GetToolTip(TreeNodeAdv node, NodeControl nodeControl);
	}
}

```

`Aga.Controls/Tree/ITreeModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;

namespace Aga.Controls.Tree
{
	public interface ITreeModel
	{
		IEnumerable GetChildren(TreePath treePath);
		bool IsLeaf(TreePath treePath);

		event EventHandler<TreeModelEventArgs> NodesChanged; 
		event EventHandler<TreeModelEventArgs> NodesInserted;
		event EventHandler<TreeModelEventArgs> NodesRemoved; 
		event EventHandler<TreePathEventArgs> StructureChanged;
	}
}

```

`Aga.Controls/Tree/IncrementalSearch.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using Aga.Controls.Tree.NodeControls;
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;

namespace Aga.Controls.Tree
{
	internal class IncrementalSearch
	{
		private const int SearchTimeout = 300; //end of incremental search timeot in msec

		private TreeViewAdv _tree;
		private TreeNodeAdv _currentNode;
		private string _searchString = "";
		private DateTime _lastKeyPressed = DateTime.Now;

		public IncrementalSearch(TreeViewAdv tree)
		{
			_tree = tree;
		}

		public void Search(Char value)
		{
			if (!Char.IsControl(value))
			{
				Char ch = Char.ToLowerInvariant(value);
				DateTime dt = DateTime.Now;
				TimeSpan ts = dt - _lastKeyPressed;
				_lastKeyPressed = dt;
				if (ts.TotalMilliseconds < SearchTimeout)
				{
					if (_searchString == value.ToString())
						FirstCharSearch(ch);
					else
						ContinuousSearch(ch);
				}
				else
				{
					FirstCharSearch(ch);
				}
			}
		}

		private void ContinuousSearch(Char value)
		{
			if (value == ' ' && String.IsNullOrEmpty(_searchString))
				return; //Ingnore leading space

			_searchString += value;
			DoContinuousSearch();
		}

		private void FirstCharSearch(Char value)
		{
			if (value == ' ')
				return;

			_searchString = value.ToString();
			TreeNodeAdv node = null;
			if (_tree.SelectedNode != null)
				node = _tree.SelectedNode.NextVisibleNode;
			if (node == null)
				node = _tree.Root.NextVisibleNode;

			if (node != null)
				foreach (string label in IterateNodeLabels(node))
				{
					if (label.StartsWith(_searchString))
					{
						_tree.SelectedNode = _currentNode;
						return;
					}
				}
		}

		public virtual void EndSearch()
		{
			_currentNode = null;
			_searchString = "";
		}

		protected IEnumerable<string> IterateNodeLabels(TreeNodeAdv start)
		{
			_currentNode = start;
			while(_currentNode != null)
			{
				foreach (string label in GetNodeLabels(_currentNode))
					yield return label;

				_currentNode = _currentNode.NextVisibleNode;
				if (_currentNode == null)
					_currentNode = _tree.Root;

				if (start == _currentNode)
					break;
			} 
		}

		private IEnumerable<string> GetNodeLabels(TreeNodeAdv node)
		{
			foreach (NodeControl nc in _tree.NodeControls)
			{
				BindableControl bc = nc as BindableControl;
				if (bc != null && bc.IncrementalSearchEnabled)
				{
					object obj = bc.GetValue(node);
					if (obj != null)
						yield return obj.ToString().ToLowerInvariant();
				}
			}
		}

		private bool DoContinuousSearch()
		{
			bool found = false;
			if (!String.IsNullOrEmpty(_searchString))
			{
				TreeNodeAdv node = null;
				if (_tree.SelectedNode != null)
					node = _tree.SelectedNode;
				if (node == null)
					node = _tree.Root.NextVisibleNode;

				if (!String.IsNullOrEmpty(_searchString))
				{
					foreach (string label in IterateNodeLabels(node))
					{
						if (label.StartsWith(_searchString))
						{
							found = true;
							_tree.SelectedNode = _currentNode;
							break;
						}
					}
				}
			}
			return found;
		}

	}
}

```

`Aga.Controls/Tree/Input/ClickColumnState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;

namespace Aga.Controls.Tree
{
	internal class ClickColumnState : ColumnState
	{
		private Point _location;

		public ClickColumnState(TreeViewAdv tree, TreeColumn column, Point location)
			: base(tree, column)
		{
			_location = location;
		}

		public override void KeyDown(KeyEventArgs args)
		{
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
		}

		public override bool MouseMove(MouseEventArgs args)
		{
			if (TreeViewAdv.Dist(_location, args.Location) > TreeViewAdv.ItemDragSensivity
				&& Tree.AllowColumnReorder)
			{
				Tree.Input = new ReorderColumnState(Tree, Column, args.Location);
				Tree.UpdateView();
			}
			return true;
		}

		public override void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
			Tree.ChangeInput();
			Tree.UpdateView();
			Tree.OnColumnClicked(Column);
		}
	}
}

```

`Aga.Controls/Tree/Input/ColumnState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	internal abstract class ColumnState : InputState
	{
		private TreeColumn _column;
		public TreeColumn Column 
		{
			get { return _column; } 
		}

		public ColumnState(TreeViewAdv tree, TreeColumn column)
			: base(tree)
		{
			_column = column;
		}
	}
}

```

`Aga.Controls/Tree/Input/InputState.cs`:

```cs
using System;
using System.Windows.Forms;
namespace Aga.Controls.Tree
{
	internal abstract class InputState
	{
		private TreeViewAdv _tree;

		public TreeViewAdv Tree
		{
			get { return _tree; }
		}

		public InputState(TreeViewAdv tree)
		{
			_tree = tree;
		}

		public abstract void KeyDown(System.Windows.Forms.KeyEventArgs args);
		public abstract void MouseDown(TreeNodeAdvMouseEventArgs args);
		public abstract void MouseUp(TreeNodeAdvMouseEventArgs args);

		/// <summary>
		/// handle OnMouseMove event
		/// </summary>
		/// <param name="args"></param>
		/// <returns>true if event was handled and should be dispatched</returns>
		public virtual bool MouseMove(MouseEventArgs args)
		{
			return false;
		}

		public virtual void MouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
		}
	}
}

```

`Aga.Controls/Tree/Input/InputWithControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	internal class InputWithControl: NormalInputState
	{
		public InputWithControl(TreeViewAdv tree): base(tree)
		{
		}

		protected override void DoMouseOperation(TreeNodeAdvMouseEventArgs args)
		{
			if (Tree.SelectionMode == TreeSelectionMode.Single)
			{
				base.DoMouseOperation(args);
			}
			else if (CanSelect(args.Node))
			{
				args.Node.IsSelected = !args.Node.IsSelected;
				Tree.SelectionStart = args.Node;
			}
		}

		protected override void MouseDownAtEmptySpace(TreeNodeAdvMouseEventArgs args)
		{
		}
	}
}

```

`Aga.Controls/Tree/Input/InputWithShift.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	internal class InputWithShift: NormalInputState
	{
		public InputWithShift(TreeViewAdv tree): base(tree)
		{
		}

		protected override void FocusRow(TreeNodeAdv node)
		{
			Tree.SuspendSelectionEvent = true;
			try
			{
				if (Tree.SelectionMode == TreeSelectionMode.Single || Tree.SelectionStart == null)
					base.FocusRow(node);
				else if (CanSelect(node))
				{
					SelectAllFromStart(node);
					Tree.CurrentNode = node;
					Tree.ScrollTo(node);
				}
			}
			finally
			{
				Tree.SuspendSelectionEvent = false;
			}
		}

		protected override void DoMouseOperation(TreeNodeAdvMouseEventArgs args)
		{
			if (Tree.SelectionMode == TreeSelectionMode.Single || Tree.SelectionStart == null)
			{
				base.DoMouseOperation(args);
			}
			else if (CanSelect(args.Node))
			{
				Tree.SuspendSelectionEvent = true;
				try
				{
					SelectAllFromStart(args.Node);
				}
				finally
				{
					Tree.SuspendSelectionEvent = false;
				}
			}
		}

		protected override void MouseDownAtEmptySpace(TreeNodeAdvMouseEventArgs args)
		{
		}

		private void SelectAllFromStart(TreeNodeAdv node)
		{
			Tree.ClearSelectionInternal();
			int a = node.Row;
			int b = Tree.SelectionStart.Row;
			for (int i = Math.Min(a, b); i <= Math.Max(a, b); i++)
			{
				if (Tree.SelectionMode == TreeSelectionMode.Multi || Tree.RowMap[i].Parent == node.Parent)
					Tree.RowMap[i].IsSelected = true;
			}
		}
	}
}

```

`Aga.Controls/Tree/Input/NormalInputState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;

namespace Aga.Controls.Tree
{
	internal class NormalInputState : InputState
	{
		private bool _mouseDownFlag = false;

		public NormalInputState(TreeViewAdv tree) : base(tree)
		{
		}

		public override void KeyDown(KeyEventArgs args)
		{
			if (Tree.CurrentNode == null && Tree.Root.Nodes.Count > 0)
				Tree.CurrentNode = Tree.Root.Nodes[0];

			if (Tree.CurrentNode != null)
			{
				switch (args.KeyCode)
				{
					case Keys.Right:
						if (!Tree.CurrentNode.IsExpanded)
							Tree.CurrentNode.IsExpanded = true;
						else if (Tree.CurrentNode.Nodes.Count > 0)
							Tree.SelectedNode = Tree.CurrentNode.Nodes[0];
						args.Handled = true;
						break;
					case Keys.Left:
						if (Tree.CurrentNode.IsExpanded)
							Tree.CurrentNode.IsExpanded = false;
						else if (Tree.CurrentNode.Parent != Tree.Root)
							Tree.SelectedNode = Tree.CurrentNode.Parent;
						args.Handled = true;
						break;
					case Keys.Down:
						NavigateForward(1);
						args.Handled = true;
						break;
					case Keys.Up:
						NavigateBackward(1);
						args.Handled = true;
						break;
					case Keys.PageDown:
						NavigateForward(Math.Max(1, Tree.CurrentPageSize - 1));
						args.Handled = true;
						break;
					case Keys.PageUp:
						NavigateBackward(Math.Max(1, Tree.CurrentPageSize - 1));
						args.Handled = true;
						break;
					case Keys.Home:
						if (Tree.RowMap.Count > 0)
							FocusRow(Tree.RowMap[0]);
						args.Handled = true;
						break;
					case Keys.End:
						if (Tree.RowMap.Count > 0)
							FocusRow(Tree.RowMap[Tree.RowMap.Count-1]);
						args.Handled = true;
						break;
					case Keys.Subtract:
						Tree.CurrentNode.Collapse();
						args.Handled = true;
						args.SuppressKeyPress = true;
						break;
					case Keys.Add:
						Tree.CurrentNode.Expand();
						args.Handled = true;
						args.SuppressKeyPress = true;
						break;
					case Keys.Multiply:
						Tree.CurrentNode.ExpandAll();
						args.Handled = true;
						args.SuppressKeyPress = true;
						break;
					case Keys.A:
						if (args.Modifiers == Keys.Control)
							Tree.SelectAllNodes();
						break;
				}
			}
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
			if (args.Node != null)
			{
				Tree.ItemDragMode = true;
				Tree.ItemDragStart = args.Location;

				if (args.Button == MouseButtons.Left || args.Button == MouseButtons.Right)
				{
					Tree.BeginUpdate();
					try
					{
						Tree.CurrentNode = args.Node;
						if (args.Node.IsSelected)
							_mouseDownFlag = true;
						else
						{
							_mouseDownFlag = false;
							DoMouseOperation(args);
						}
					}
					finally
					{
						Tree.EndUpdate();
					}
				}

			}
			else
			{
				Tree.ItemDragMode = false;
				MouseDownAtEmptySpace(args);
			}
		}

		public override void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
			Tree.ItemDragMode = false;
			if (_mouseDownFlag && args.Node != null)
			{
				if (args.Button == MouseButtons.Left)
					DoMouseOperation(args);
				else if (args.Button == MouseButtons.Right)
					Tree.CurrentNode = args.Node;
			}
			_mouseDownFlag = false;
		}


		private void NavigateBackward(int n)
		{
			int row = Math.Max(Tree.CurrentNode.Row - n, 0);
			if (row != Tree.CurrentNode.Row)
				FocusRow(Tree.RowMap[row]);
		}

		private void NavigateForward(int n)
		{
			int row = Math.Min(Tree.CurrentNode.Row + n, Tree.RowCount - 1);
			if (row != Tree.CurrentNode.Row)
				FocusRow(Tree.RowMap[row]);
		}

		protected virtual void MouseDownAtEmptySpace(TreeNodeAdvMouseEventArgs args)
		{
			Tree.ClearSelection();
		}

		protected virtual void FocusRow(TreeNodeAdv node)
		{
			Tree.SuspendSelectionEvent = true;
			try
			{
				Tree.ClearSelectionInternal();
				Tree.CurrentNode = node;
				Tree.SelectionStart = node;
				node.IsSelected = true;
				Tree.ScrollTo(node);
			}
			finally
			{
				Tree.SuspendSelectionEvent = false;
			}
		}

		protected bool CanSelect(TreeNodeAdv node)
		{
			if (Tree.SelectionMode == TreeSelectionMode.MultiSameParent)
			{
				return (Tree.SelectionStart == null || node.Parent == Tree.SelectionStart.Parent);
			}
			else
				return true;
		}

		protected virtual void DoMouseOperation(TreeNodeAdvMouseEventArgs args)
		{
			if (Tree.SelectedNodes.Count == 1 && args.Node != null && args.Node.IsSelected)
				return;

			Tree.SuspendSelectionEvent = true;
			try
			{
				Tree.ClearSelectionInternal();
				if (args.Node != null)
					args.Node.IsSelected = true;
				Tree.SelectionStart = args.Node;
			}
			finally
			{
				Tree.SuspendSelectionEvent = false;
			}
		}
	}
}

```

`Aga.Controls/Tree/Input/ReorderColumnState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;

namespace Aga.Controls.Tree
{
	internal class ReorderColumnState : ColumnState
	{
		#region Properties

		private Point _location;
		public Point Location
		{
			get { return _location; }
		}

		private Bitmap _ghostImage;
		public Bitmap GhostImage
		{
			get { return _ghostImage; }
		}

		private TreeColumn _dropColumn;
		public TreeColumn DropColumn
		{
			get { return _dropColumn; }
		}

		private int _dragOffset;
		public int DragOffset
		{
			get { return _dragOffset; }
		}

		#endregion

		public ReorderColumnState(TreeViewAdv tree, TreeColumn column, Point initialMouseLocation)
			: base(tree, column)
		{
			_location = new Point(initialMouseLocation.X + Tree.OffsetX, 0);
			_dragOffset = tree.GetColumnX(column) - initialMouseLocation.X;
			_ghostImage = column.CreateGhostImage(new Rectangle(0, 0, column.Width, tree.ColumnHeaderHeight), tree.Font);
		}

		public override void KeyDown(KeyEventArgs args)
		{
			args.Handled = true;
			if (args.KeyCode == Keys.Escape)
				FinishResize();
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
		}

		public override void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
			FinishResize();
		}

		public override bool MouseMove(MouseEventArgs args)
		{
			_dropColumn = null;
			_location = new Point(args.X + Tree.OffsetX, 0);
			int x = 0;
			foreach (TreeColumn c in Tree.Columns)
			{
				if (c.IsVisible)
				{
					if (_location.X < x + c.Width / 2)
					{
						_dropColumn = c;
						break;
					}
					x += c.Width;
				}
			}
			Tree.UpdateHeaders();
			return true;
		}

		private void FinishResize()
		{
			Tree.ChangeInput();
			if (Column == DropColumn)
				Tree.UpdateView();
			else
			{
				Tree.Columns.Remove(Column);
				if (DropColumn == null)
					Tree.Columns.Add(Column);
				else
					Tree.Columns.Insert(Tree.Columns.IndexOf(DropColumn), Column);

				Tree.OnColumnReordered(Column);
			}
		}
	}
}
```

`Aga.Controls/Tree/Input/ResizeColumnState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Security.Permissions;
using System.Drawing;

namespace Aga.Controls.Tree
{
	internal class ResizeColumnState: ColumnState
	{
		private Point _initLocation;
		private int _initWidth;

		public ResizeColumnState(TreeViewAdv tree, TreeColumn column, Point p)
			: base(tree, column)
		{
			_initLocation = p;
			_initWidth = column.Width;
		}

		public override void KeyDown(KeyEventArgs args)
		{
			args.Handled = true;
			if (args.KeyCode == Keys.Escape)
				FinishResize();
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
		}

		public override void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
			FinishResize();
		}

		private void FinishResize()
		{
			Tree.ChangeInput();
			Tree.FullUpdate();
			Tree.OnColumnWidthChanged(Column);
		}

        public override bool MouseMove(MouseEventArgs args)
        {
			Column.Width = _initWidth + args.Location.X - _initLocation.X;
            Tree.UpdateView();
            return true;
        }

		public override void MouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
			Tree.AutoSizeColumn(Column);
		}
	}
}

```

`Aga.Controls/Tree/ListModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;

namespace Aga.Controls.Tree
{
	public class ListModel : TreeModelBase
	{
		private IList _list;

		public int Count
		{
			get { return _list.Count; }
		}

		public ListModel()
		{
			_list = new List<object>();
		}

		public ListModel(IList list)
		{
			_list = list;
		}

		public override IEnumerable GetChildren(TreePath treePath)
		{
			return _list;
		}

		public override bool IsLeaf(TreePath treePath)
		{
			return true;
		}

		public void AddRange(IEnumerable items)
		{
			foreach (object obj in items)
				_list.Add(obj);
			OnStructureChanged(new TreePathEventArgs(TreePath.Empty));
		}

		public void Add(object item)
		{
			_list.Add(item);
			OnNodesInserted(new TreeModelEventArgs(TreePath.Empty, new int[] { _list.Count - 1 }, new object[] { item }));
		}

		public void Clear()
		{
			_list.Clear();
			OnStructureChanged(new TreePathEventArgs(TreePath.Empty));
		}
	}
}

```

`Aga.Controls/Tree/NativeMethods.cs`:

```cs
using System;
using System.Drawing;
using System.Runtime.InteropServices;


namespace Aga.Controls.Tree
{
    internal static class NativeMethods
    {
        public const int DCX_WINDOW = 0x01;
        public const int DCX_CACHE = 0x02;
        public const int DCX_NORESETATTRS = 0x04;
        public const int DCX_CLIPCHILDREN = 0x08;
        public const int DCX_CLIPSIBLINGS = 0x10;
        public const int DCX_PARENTCLIP = 0x20;
        public const int DCX_EXCLUDERGN = 0x40;
        public const int DCX_INTERSECTRGN = 0x80;
        public const int DCX_EXCLUDEUPDATE = 0x100;
        public const int DCX_INTERSECTUPDATE = 0x200;
        public const int DCX_LOCKWINDOWUPDATE = 0x400;
        public const int DCX_VALIDATE = 0x200000;

        public const int WM_THEMECHANGED = 0x031A;
        public const int WM_NCPAINT = 0x85;
        public const int WM_NCCALCSIZE = 0x83;

        public const int WS_BORDER = 0x800000;
        public const int WS_EX_CLIENTEDGE = 0x200;

        public const int WVR_HREDRAW = 0x100;
        public const int WVR_VREDRAW = 0x200;
        public const int WVR_REDRAW = (WVR_HREDRAW | WVR_VREDRAW);

        [StructLayout(LayoutKind.Sequential)]
        public struct NCCALCSIZE_PARAMS
        {
            public RECT rgrc0, rgrc1, rgrc2;
            public IntPtr lppos;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT
        {
            public int Left;
            public int Top;
            public int Right;
            public int Bottom;

            public static RECT FromRectangle(Rectangle rectangle)
            {
                RECT result = new RECT();
                result.Left = rectangle.Left;
                result.Top = rectangle.Top;
                result.Right = rectangle.Right;
                result.Bottom = rectangle.Bottom;
                return result;
            }

            public Rectangle ToRectangle()
            {
                return new Rectangle(Left, Top, Right - Left, Bottom - Top);
            }
        }

        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr GetDCEx(IntPtr hWnd, IntPtr hrgnClip, int flags);

        [DllImport("user32.dll")]
        public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);

        [DllImport("user32.dll")]
        public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
    }
}

```

`Aga.Controls/Tree/Node.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections.ObjectModel;
using System.Windows.Forms;
using System.Drawing;

namespace Aga.Controls.Tree
{
	public class Node
	{
		#region NodeCollection

		private class NodeCollection : Collection<Node>
		{
			private Node _owner;

			public NodeCollection(Node owner)
			{
				_owner = owner;
			}

			protected override void ClearItems()
			{
				while (this.Count != 0)
					this.RemoveAt(this.Count - 1);
			}

			protected override void InsertItem(int index, Node item)
			{
				if (item == null)
					throw new ArgumentNullException("item");

				if (item.Parent != _owner)
				{
					if (item.Parent != null)
						item.Parent.Nodes.Remove(item);
					item._parent = _owner;
					item._index = index;
					for (int i = index; i < Count; i++)
						this[i]._index++;
					base.InsertItem(index, item);

					TreeModel model = _owner.FindModel();
					if (model != null)
						model.OnNodeInserted(_owner, index, item);
				}
			}

			protected override void RemoveItem(int index)
			{
				Node item = this[index];
				item._parent = null;
				item._index = -1;
				for (int i = index + 1; i < Count; i++)
					this[i]._index--;
				base.RemoveItem(index);

				TreeModel model = _owner.FindModel();
				if (model != null)
					model.OnNodeRemoved(_owner, index, item);
			}

			protected override void SetItem(int index, Node item)
			{
				if (item == null)
					throw new ArgumentNullException("item");

				RemoveAt(index);
				InsertItem(index, item);
			}
		}

		#endregion

		#region Properties

		private TreeModel _model;
		internal TreeModel Model
		{
			get { return _model; }
			set { _model = value; }
		}

		private NodeCollection _nodes;
		public Collection<Node> Nodes
		{
			get { return _nodes; }
		}

		private Node _parent;
		public Node Parent
		{
			get { return _parent; }
			set 
			{
				if (value != _parent)
				{
					if (_parent != null)
						_parent.Nodes.Remove(this);

					if (value != null)
						value.Nodes.Add(this);
				}
			}
		}

		private int _index = -1;
		public int Index
		{
			get
			{
				return _index;
			}
		}

		public Node PreviousNode
		{
			get
			{
				int index = Index;
				if (index > 0)
					return _parent.Nodes[index - 1];
				else
					return null;
			}
		}

		public Node NextNode
		{
			get
			{
				int index = Index;
				if (index >= 0 && index < _parent.Nodes.Count - 1)
					return _parent.Nodes[index + 1];
				else
					return null;
			}
		}

		private string _text;
		public virtual string Text
		{
			get { return _text; }
			set 
			{
				if (_text != value)
				{
					_text = value;
					NotifyModel();
				}
			}
		}

		private CheckState _checkState;
		public virtual CheckState CheckState
		{
			get { return _checkState; }
			set 
			{
				if (_checkState != value)
				{
					_checkState = value;
					NotifyModel();
				}
			}
		}

		private Image _image;
		public Image Image
		{
			get { return _image; }
			set 
			{
				if (_image != value)
				{
					_image = value;
					NotifyModel();
				}
			}
		}

		private object _tag;
		public object Tag
		{
			get { return _tag; }
			set { _tag = value; }
		}

		public bool IsChecked
		{
			get 
			{ 
				return CheckState != CheckState.Unchecked;
			}
			set 
			{
				if (value)
					CheckState = CheckState.Checked;
				else
					CheckState = CheckState.Unchecked;
			}
		}

		public virtual bool IsLeaf
		{
			get
			{
				return false;
			}
		}

		#endregion

		public Node()
			: this(string.Empty)
		{
		}

		public Node(string text)
		{
			_text = text;
			_nodes = new NodeCollection(this);
		}

		public override string ToString()
		{
			return Text;
		}

		private TreeModel FindModel()
		{
			Node node = this;
			while (node != null)
			{
				if (node.Model != null)
					return node.Model;
				node = node.Parent;
			}
			return null;
		}

		protected void NotifyModel()
		{
			TreeModel model = FindModel();
			if (model != null && Parent != null)
			{
				TreePath path = model.GetPath(Parent);
				if (path != null)
				{
					TreeModelEventArgs args = new TreeModelEventArgs(path, new int[] { Index }, new object[] { this });
					model.OnNodesChanged(args);
				}
			}
		}
	}
}

```

`Aga.Controls/Tree/NodeControlInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using Aga.Controls.Tree.NodeControls;
using System.Drawing;

namespace Aga.Controls.Tree
{
	public struct NodeControlInfo
	{
		public static readonly NodeControlInfo Empty = new NodeControlInfo(null, Rectangle.Empty, null);

		private NodeControl _control;
		public NodeControl Control
		{
			get { return _control; }
		}

		private Rectangle _bounds;
		public Rectangle Bounds
		{
			get { return _bounds; }
		}

		private TreeNodeAdv _node;
		public TreeNodeAdv Node
		{
			get { return _node; }
		}

		public NodeControlInfo(NodeControl control, Rectangle bounds, TreeNodeAdv node)
		{
			_control = control;
			_bounds = bounds;
			_node = node;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/BaseTextControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using System.Reflection;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public abstract class BaseTextControl : EditableControl
	{
		private TextFormatFlags _baseFormatFlags;
        private TextFormatFlags _formatFlags;
        private Pen _focusPen;
		private StringFormat _format;

		#region Properties

		private Font _font = null;
		public Font Font
		{
			get
			{
				if (_font == null)
					return Control.DefaultFont;
				else
					return _font;
			}
			set
			{
				if (value == Control.DefaultFont)
					_font = null;
				else
					_font = value;
			}
		}

		protected bool ShouldSerializeFont()
		{
			return (_font != null);
		}

		private HorizontalAlignment _textAlign = HorizontalAlignment.Left;
		[DefaultValue(HorizontalAlignment.Left)]
		public HorizontalAlignment TextAlign
		{
			get { return _textAlign; }
			set 
			{ 
				_textAlign = value;
				SetFormatFlags();
			}
		}

		private StringTrimming _trimming = StringTrimming.None;
		[DefaultValue(StringTrimming.None)]
		public StringTrimming Trimming
		{
			get { return _trimming; }
			set 
			{ 
				_trimming = value;
				SetFormatFlags();
			}
		}

		private bool _displayHiddenContentInToolTip = true;
		[DefaultValue(true)]
		public bool DisplayHiddenContentInToolTip
		{
			get { return _displayHiddenContentInToolTip; }
			set { _displayHiddenContentInToolTip = value; }
		}

		private bool _useCompatibleTextRendering = false;
		[DefaultValue(false)]
		public bool UseCompatibleTextRendering
		{
			get { return _useCompatibleTextRendering; }
			set { _useCompatibleTextRendering = value; }
		}

		[DefaultValue(false)]
		public bool TrimMultiLine
		{
			get;
			set;
		}

		#endregion

		protected BaseTextControl()
		{
			IncrementalSearchEnabled = true;
			_focusPen = new Pen(Color.Black);
			_focusPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;

			_format = new StringFormat(StringFormatFlags.LineLimit | StringFormatFlags.NoClip | StringFormatFlags.FitBlackBox | StringFormatFlags.MeasureTrailingSpaces);
			_baseFormatFlags = TextFormatFlags.PreserveGraphicsClipping |
						   TextFormatFlags.PreserveGraphicsTranslateTransform;
			SetFormatFlags();
			LeftMargin = 3;
		}

		private void SetFormatFlags()
		{
			_format.Alignment = TextHelper.TranslateAligment(TextAlign);
			_format.Trimming = Trimming;

			_formatFlags = _baseFormatFlags | TextHelper.TranslateAligmentToFlag(TextAlign)
				| TextHelper.TranslateTrimmingToFlag(Trimming);
		}

		public override Size MeasureSize(TreeNodeAdv node, DrawContext context)
		{
			return GetLabelSize(node, context);
		}

		protected Size GetLabelSize(TreeNodeAdv node, DrawContext context)
		{
			return GetLabelSize(node, context, GetLabel(node));
		}

		protected Size GetLabelSize(TreeNodeAdv node, DrawContext context, string label)
		{
			PerformanceAnalyzer.Start("GetLabelSize");
			CheckThread();
			Font font = GetDrawingFont(node, context, label);
			Size s = Size.Empty;
			if (UseCompatibleTextRendering)
				s = TextRenderer.MeasureText(label, font);
			else
			{
				SizeF sf = context.Graphics.MeasureString(label, font);
				s = new Size((int)Math.Ceiling(sf.Width), (int)Math.Ceiling(sf.Height));
			}
			PerformanceAnalyzer.Finish("GetLabelSize");

			if (!s.IsEmpty)
				return s;
			else
				return new Size(10, Font.Height);
		}

		protected Font GetDrawingFont(TreeNodeAdv node, DrawContext context, string label)
		{
			Font font = context.Font;
			if (DrawTextMustBeFired(node))
			{
				DrawEventArgs args = new DrawEventArgs(node, this, context, label);
				args.Font = context.Font;
				OnDrawText(args);
				font = args.Font;
			}
			return font;
		}

		protected void SetEditControlProperties(Control control, TreeNodeAdv node)
		{
			string label = GetLabel(node);
			DrawContext context = new DrawContext();
			context.Font = control.Font;
			control.Font = GetDrawingFont(node, context, label);
		}

		public override void Draw(TreeNodeAdv node, DrawContext context)
		{
			if (context.CurrentEditorOwner == this && node == Parent.CurrentNode)
				return;

			PerformanceAnalyzer.Start("BaseTextControl.Draw");
			string label = GetLabel(node);
			Rectangle bounds = GetBounds(node, context);
			Rectangle focusRect = new Rectangle(bounds.X, context.Bounds.Y,	
				bounds.Width, context.Bounds.Height);

			Brush backgroundBrush;
			Color textColor;
			Font font;
			CreateBrushes(node, context, label, out backgroundBrush, out textColor, out font, ref label);

			if (backgroundBrush != null)
				context.Graphics.FillRectangle(backgroundBrush, focusRect);
			if (context.DrawFocus)
			{
				focusRect.Width--;
				focusRect.Height--;
				if (context.DrawSelection == DrawSelectionMode.None)
					_focusPen.Color = SystemColors.ControlText;
				else
					_focusPen.Color = SystemColors.InactiveCaption;
				context.Graphics.DrawRectangle(_focusPen, focusRect);
			}
			
			PerformanceAnalyzer.Start("BaseTextControl.DrawText");
			if (UseCompatibleTextRendering)
				TextRenderer.DrawText(context.Graphics, label, font, bounds, textColor, _formatFlags);
			else
				context.Graphics.DrawString(label, font, GetFrush(textColor), bounds, _format);
			PerformanceAnalyzer.Finish("BaseTextControl.DrawText");

			PerformanceAnalyzer.Finish("BaseTextControl.Draw");
		}

		private static Dictionary<Color, Brush> _brushes = new Dictionary<Color,Brush>();
		private static Brush GetFrush(Color color)
		{
			Brush br;
			if (_brushes.ContainsKey(color))
				br = _brushes[color];
			else
			{
				br = new SolidBrush(color);
				_brushes.Add(color, br);
			}
			return br;
		}

		private void CreateBrushes(TreeNodeAdv node, DrawContext context, string text, out Brush backgroundBrush, out Color textColor, out Font font, ref string label)
		{
			textColor = SystemColors.ControlText;
			backgroundBrush = null;
			font = context.Font;
			if (context.DrawSelection == DrawSelectionMode.Active)
			{
				textColor = SystemColors.HighlightText;
                backgroundBrush = SystemBrushes.Highlight;
			}
			else if (context.DrawSelection == DrawSelectionMode.Inactive)
			{
				textColor = SystemColors.ControlText;
                backgroundBrush = SystemBrushes.InactiveBorder;
			}
			else if (context.DrawSelection == DrawSelectionMode.FullRowSelect)
				textColor = SystemColors.ControlText;

			if (!context.Enabled)
				textColor = SystemColors.GrayText;

			if (DrawTextMustBeFired(node))
			{
				DrawEventArgs args = new DrawEventArgs(node, this, context, text);
				args.Text = label;
				args.TextColor = textColor;
				args.BackgroundBrush = backgroundBrush;
				args.Font = font;

				OnDrawText(args);

				textColor = args.TextColor;
				backgroundBrush = args.BackgroundBrush;
				font = args.Font;
				label = args.Text;
			}
		}

		public string GetLabel(TreeNodeAdv node)
		{
			if (node != null && node.Tag != null)
			{
				object obj = GetValue(node);
				if (obj != null)
					return FormatLabel(obj);
			}
			return string.Empty;
		}

		protected virtual string FormatLabel(object obj)
		{
			var res = obj.ToString();
			if (TrimMultiLine && res != null)
			{
				string[] parts = res.Split('\n');
				if (parts.Length > 1)
					return parts[0] + "...";
			}
			return res;
		}

		public void SetLabel(TreeNodeAdv node, string value)
		{
			SetValue(node, value);
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				_focusPen.Dispose();
				_format.Dispose();
			}
		}

		/// <summary>
		/// Fires when control is going to draw a text. Can be used to change text or back color
		/// </summary>
		public event EventHandler<DrawEventArgs> DrawText;
		protected virtual void OnDrawText(DrawEventArgs args)
		{
			TreeViewAdv tree = args.Node.Tree;
			if (tree != null)
				tree.FireDrawControl(args);
			if (DrawText != null)
				DrawText(this, args);
		}

		protected virtual bool DrawTextMustBeFired(TreeNodeAdv node)
		{
			return DrawText != null || (node.Tree != null && node.Tree.DrawControlMustBeFired());
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/BindableControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public abstract class BindableControl : NodeControl
	{
		private struct MemberAdapter
		{
			private object _obj;
			private PropertyInfo _pi;
			private FieldInfo _fi;

			public static readonly MemberAdapter Empty = new MemberAdapter();

			public Type MemberType
			{
				get
				{
					if (_pi != null)
						return _pi.PropertyType;
					else if (_fi != null)
						return _fi.FieldType;
					else
						return null;
				}
			}

			public object Value
			{
				get
				{
					if (_pi != null && _pi.CanRead)
						return _pi.GetValue(_obj, null);
					else if (_fi != null)
						return _fi.GetValue(_obj);
					else
						return null;
				}
				set
				{
					if (_pi != null && _pi.CanWrite)
						_pi.SetValue(_obj, value, null);
					else if (_fi != null)
						_fi.SetValue(_obj, value);
				}
			}

			public MemberAdapter(object obj, PropertyInfo pi)
			{
				_obj = obj;
				_pi = pi;
				_fi = null;
			}

			public MemberAdapter(object obj, FieldInfo fi)
			{
				_obj = obj;
				_fi = fi;
				_pi = null;
			}
		}

		#region Properties

		private bool _virtualMode = false;
		[DefaultValue(false), Category("Data")]
		public bool VirtualMode
		{
			get { return _virtualMode; }
			set { _virtualMode = value; }
		}

		private string _propertyName = "";
		[DefaultValue(""), Category("Data")]
		public string DataPropertyName
		{
			get { return _propertyName; }
			set 
			{
				if (_propertyName == null)
					_propertyName = string.Empty;
				_propertyName = value; 
			}
		}

		private bool _incrementalSearchEnabled = false;
		[DefaultValue(false)]
		public bool IncrementalSearchEnabled
		{
			get { return _incrementalSearchEnabled; }
			set { _incrementalSearchEnabled = value; }
		}

		#endregion

		public virtual object GetValue(TreeNodeAdv node)
		{
			if (VirtualMode)
			{
				NodeControlValueEventArgs args = new NodeControlValueEventArgs(node);
				OnValueNeeded(args);
				return args.Value;
			}
			else
			{
				try
				{
					return GetMemberAdapter(node).Value;
				}
				catch (TargetInvocationException ex)
				{
					if (ex.InnerException != null)
						throw new ArgumentException(ex.InnerException.Message, ex.InnerException);
					else
						throw new ArgumentException(ex.Message);
				}
			}
		}

		public virtual void SetValue(TreeNodeAdv node, object value)
		{
			if (VirtualMode)
			{
				NodeControlValueEventArgs args = new NodeControlValueEventArgs(node);
				args.Value = value;
				OnValuePushed(args);
			}
			else
			{
				try
				{
					MemberAdapter ma = GetMemberAdapter(node);
					ma.Value = value;
				}
				catch (TargetInvocationException ex)
				{
					if (ex.InnerException != null)
						throw new ArgumentException(ex.InnerException.Message, ex.InnerException);
					else
						throw new ArgumentException(ex.Message);
				}
			}
		}

		public Type GetPropertyType(TreeNodeAdv node)
		{
			return GetMemberAdapter(node).MemberType;
		}

		private MemberAdapter GetMemberAdapter(TreeNodeAdv node)
		{
			if (node.Tag != null && !string.IsNullOrEmpty(DataPropertyName))
			{
				Type type = node.Tag.GetType();
				PropertyInfo pi = type.GetProperty(DataPropertyName);
				if (pi != null)
					return new MemberAdapter(node.Tag, pi);
				else
				{
					FieldInfo fi = type.GetField(DataPropertyName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
					if (fi != null)
						return new MemberAdapter(node.Tag, fi);
				}
			}
			return MemberAdapter.Empty;
		}

		public override string ToString()
		{
			if (string.IsNullOrEmpty(DataPropertyName))
				return GetType().Name;
			else
				return string.Format("{0} ({1})", GetType().Name, DataPropertyName);
		}

		public event EventHandler<NodeControlValueEventArgs> ValueNeeded;
		private void OnValueNeeded(NodeControlValueEventArgs args)
		{
			if (ValueNeeded != null)
				ValueNeeded(this, args);
		}

		public event EventHandler<NodeControlValueEventArgs> ValuePushed;
		private void OnValuePushed(NodeControlValueEventArgs args)
		{
			if (ValuePushed != null)
				ValuePushed(this, args);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/ClassDiagram.cd`:

```cd
<?xml version="1.0" encoding="utf-8"?>
<ClassDiagram MajorVersion="1" MinorVersion="1">
  <Font Name="Microsoft Sans Serif" Size="8.25" />
  <Class Name="Aga.Controls.Tree.NodeControls.NodeStateIcon" Collapsed="true">
    <Position X="0.5" Y="4" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeStateIcon.cs</FileName>
      <HashCode>ABAAAAAAAAQAQAAAAAAAAAAAAAAAAAAAQIAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.BindableControl" Collapsed="true">
    <Position X="2.75" Y="1.5" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\BindableControl.cs</FileName>
      <HashCode>FAAAAAAQIBAQCgAEAAAAIAAAAAAAAAEMAAACAAAAAAE=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeCheckBox" Collapsed="true">
    <Position X="5" Y="4" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeCheckBox.cs</FileName>
      <HashCode>AAEAAAAAAAACgkQCAAAAAAigAgAAEGABAAAIAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeControl" Collapsed="true">
    <Position X="1.5" Y="0.5" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeControl.cs</FileName>
      <HashCode>AAAAAJAAgIgBkkoQAAgAQAAwAAABEIQAAEBIAAAAAAA=</HashCode>
    </TypeIdentifier>
    <Compartments>
      <Compartment Name="Fields" Collapsed="true" />
    </Compartments>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeIcon" Collapsed="true">
    <Position X="0.5" Y="2.75" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeIcon.cs</FileName>
      <HashCode>ABAAAAAAAAAAAgAAAAAAAAAgAAAAAAAAAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodePlusMinus" Collapsed="true">
    <Position X="0.5" Y="1.5" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodePlusMinus.cs</FileName>
      <HashCode>AAAAAAAAAAAAAgAAAAAAAEAgAAAAMCAAAAAIACAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.BaseTextControl" Collapsed="true">
    <Position X="3" Y="5" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\BaseTextControl.cs</FileName>
      <HashCode>AAAAICBQACAAIgACBCAEAQA8AgmFoAAwAAAAACACAMA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeTextBox" Collapsed="true">
    <Position X="1" Y="6" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeTextBox.cs</FileName>
      <HashCode>QQQAhAAAADAMgAAAABAAAAAAAgEAIAAAAAAAAIAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.EditableControl" Collapsed="true">
    <Position X="3" Y="4" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\EditableControl.cs</FileName>
      <HashCode>QQAgAAAACGgkAMAABAEEkADAEAAUEAAABAGoAAAAAQA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeComboBox" Collapsed="true">
    <Position X="3" Y="6" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeComboBox.cs</FileName>
      <HashCode>wQACAAAAAAAMAEBAAAAAAABAAAAAAAABAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeNumericUpDown" Collapsed="true">
    <Position X="5" Y="6" Width="1.75" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeNumericUpDown.cs</FileName>
      <HashCode>wQAAAACAAAAEAABAIAAQIAAAAAAAAAABAAAIAAAAAII=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.InteractiveControl" Collapsed="true">
    <Position X="4" Y="2.75" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\InteractiveControl.cs</FileName>
      <HashCode>AAAABAAAAAAAAAAACAAAAAAAABAAAQAAAAAAAAIAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeDecimalTextBox" Collapsed="true">
    <Position X="2.5" Y="7" Width="1.75" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeDecimalTextBox.cs</FileName>
      <HashCode>AQAAAAAAAACAAAACAAAAAAQAAAAAIAAAAAgAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeIntegerTextBox" Collapsed="true">
    <Position X="0.5" Y="7" Width="1.75" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeIntegerTextBox.cs</FileName>
      <HashCode>AQAAAAAAAAAAAAACAAAAAAQAAAAAIAAAAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
</ClassDiagram>
```

`Aga.Controls/Tree/NodeControls/DrawEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;

namespace Aga.Controls.Tree.NodeControls
{
	public class DrawEventArgs : NodeEventArgs
	{
		private DrawContext _context;
		public DrawContext Context
		{
			get { return _context; }
		}

		private Brush _textBrush;
		[Obsolete("Use TextColor")]
		public Brush TextBrush
		{
			get { return _textBrush; }
			set { _textBrush = value; }
		}

		private Brush _backgroundBrush;
		public Brush BackgroundBrush
		{
            get { return _backgroundBrush; }
			set { _backgroundBrush = value; }
		}

		private Font _font;
		public Font Font
		{
			get { return _font; }
			set { _font = value; }
		}

		private Color _textColor;
		public Color TextColor
		{
			get { return _textColor; }
			set { _textColor = value; }
		}

		private string _text;
		public string Text
		{
			get { return _text; }
			set { _text = value; }
		}


		private EditableControl _control;
		public EditableControl Control
		{
			get { return _control; }
		}

		public DrawEventArgs(TreeNodeAdv node, EditableControl control, DrawContext context, string text)
			: base(node)
		{
			_control = control;
			_context = context;
			_text = text;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/EditEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;

namespace Aga.Controls.Tree.NodeControls
{
	public class EditEventArgs : NodeEventArgs
	{
		private Control _control;
		public Control Control
		{
			get { return _control; }
		}

		public EditEventArgs(TreeNodeAdv node, Control control)
			: base(node)
		{
			_control = control;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/EditableControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public abstract class EditableControl : InteractiveControl
	{
		private Timer _timer;
		private bool _editFlag;

		#region Properties

		private bool _editOnClick = false;
		[DefaultValue(false)]
		public bool EditOnClick
		{
			get { return _editOnClick; }
			set { _editOnClick = value; }
		}

		#endregion

		protected EditableControl()
		{
			_timer = new Timer();
			_timer.Interval = 500;
			_timer.Tick += new EventHandler(TimerTick);
		}

		private void TimerTick(object sender, EventArgs e)
		{
			_timer.Stop();
			if (_editFlag)
				BeginEdit();
			_editFlag = false;
		}

		public void SetEditorBounds(EditorContext context)
		{
			Size size = CalculateEditorSize(context);
			context.Editor.Bounds = new Rectangle(context.Bounds.X, context.Bounds.Y,
				Math.Min(size.Width, context.Bounds.Width),
				Math.Min(size.Height, Parent.ClientSize.Height - context.Bounds.Y)
			);
		}

		protected abstract Size CalculateEditorSize(EditorContext context);

		protected virtual bool CanEdit(TreeNodeAdv node)
		{
			return (node.Tag != null) && IsEditEnabled(node);
		}

		public void BeginEdit()
		{
			if (Parent != null && Parent.CurrentNode != null && CanEdit(Parent.CurrentNode))
			{
				CancelEventArgs args = new CancelEventArgs();
				OnEditorShowing(args);
				if (!args.Cancel)
				{
					var editor = CreateEditor(Parent.CurrentNode);
					Parent.DisplayEditor(editor, this);
				}
			}
		}

		public void EndEdit(bool applyChanges)
		{
			if (Parent != null)
				if (Parent.HideEditor(applyChanges))
					OnEditorHided();
		}

		public virtual void UpdateEditor(Control control)
		{
		}

		internal void ApplyChanges(TreeNodeAdv node, Control editor)
		{
			DoApplyChanges(node, editor);
			OnChangesApplied();
		}

		internal void DoDisposeEditor(Control editor)
		{
			DisposeEditor(editor);
		}

		protected abstract void DoApplyChanges(TreeNodeAdv node, Control editor);

		protected abstract Control CreateEditor(TreeNodeAdv node);

		protected abstract void DisposeEditor(Control editor);

		public virtual void Cut(Control control)
		{
		}

		public virtual void Copy(Control control)
		{
		}

		public virtual void Paste(Control control)
		{
		}

		public virtual void Delete(Control control)
		{
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
			_editFlag = (!EditOnClick && args.Button == MouseButtons.Left
				&& args.ModifierKeys == Keys.None && args.Node.IsSelected);
		}

		public override void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
			if (args.Node.IsSelected)
			{
				if (EditOnClick && args.Button == MouseButtons.Left && args.ModifierKeys == Keys.None)
				{
					Parent.ItemDragMode = false;
					BeginEdit();
					args.Handled = true;
				}
				else if (_editFlag)// && args.Node.IsSelected)
					_timer.Start();
			}
		}

		public override void MouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
			_editFlag = false;
			_timer.Stop();
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
				_timer.Dispose();
		}

		#region Events

		public event CancelEventHandler EditorShowing;
		protected void OnEditorShowing(CancelEventArgs args)
		{
			if (EditorShowing != null)
				EditorShowing(this, args);
		}

		public event EventHandler EditorHided;
		protected void OnEditorHided()
		{
			if (EditorHided != null)
				EditorHided(this, EventArgs.Empty);
		}

		public event EventHandler ChangesApplied;
		protected void OnChangesApplied()
		{
			if (ChangesApplied != null)
				ChangesApplied(this, EventArgs.Empty);
		}

		#endregion
	}
}

```

`Aga.Controls/Tree/NodeControls/ExpandingIcon.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;

namespace Aga.Controls.Tree.NodeControls
{
	/// <summary>
	/// Displays an animated icon for those nodes, who are in expanding state. 
	/// Parent TreeView must have AsyncExpanding property set to true.
	/// </summary>
	public class ExpandingIcon: NodeControl
	{
		private static GifDecoder _gif = ResourceHelper.LoadingIcon;
		private static int _index = 0;
		private static volatile Thread _animatingThread;
        private static object _lock = new object();

		public override Size MeasureSize(TreeNodeAdv node, DrawContext context)
		{
			return ResourceHelper.LoadingIcon.FrameSize;
		}

		protected override void OnIsVisibleValueNeeded(NodeControlValueEventArgs args)
		{
			args.Value = args.Node.IsExpandingNow;
			base.OnIsVisibleValueNeeded(args);
		}

		public override void Draw(TreeNodeAdv node, DrawContext context)
		{
			Rectangle rect = GetBounds(node, context);
			Image img = _gif.GetFrame(_index).Image;
			context.Graphics.DrawImage(img, rect.Location);
		}

		public static void Start()
		{
            lock (_lock)
            {
                if (_animatingThread == null)
                {
                    _index = 0;
                    _animatingThread = new Thread(new ThreadStart(IterateIcons));
                    _animatingThread.IsBackground = true;
                    _animatingThread.Priority = ThreadPriority.Lowest;
                    _animatingThread.Start();
                }
            }
		}

        public static void Stop()
        {
            lock (_lock)
            {
                _index = 0;
                _animatingThread = null;
            }
        }

		private static void IterateIcons()
		{
            while (_animatingThread != null)
			{
				if (_index < _gif.FrameCount - 1)
					_index++;
				else
					_index = 0;

				if (IconChanged != null)
					IconChanged(null, EventArgs.Empty);

				int delay = _gif.GetFrame(_index).Delay;
				Thread.Sleep(delay);
			}
            System.Diagnostics.Debug.WriteLine("IterateIcons Stopped");
		}

		public static event EventHandler IconChanged;
	}
}

```

`Aga.Controls/Tree/NodeControls/InteractiveControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public abstract class InteractiveControl : BindableControl
	{
		private bool _editEnabled = false;
		[DefaultValue(false)]
		public bool EditEnabled
		{
			get { return _editEnabled; }
			set { _editEnabled = value; }
		}

		protected bool IsEditEnabled(TreeNodeAdv node)
		{
			if (EditEnabled)
			{
				NodeControlValueEventArgs args = new NodeControlValueEventArgs(node);
				args.Value = true;
				OnIsEditEnabledValueNeeded(args);
				return Convert.ToBoolean(args.Value);
			}
			else
				return false;
		}

		public event EventHandler<NodeControlValueEventArgs> IsEditEnabledValueNeeded;
		private void OnIsEditEnabledValueNeeded(NodeControlValueEventArgs args)
		{
			if (IsEditEnabledValueNeeded != null)
				IsEditEnabledValueNeeded(this, args);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/LabelEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree.NodeControls
{
	public class LabelEventArgs : EventArgs
	{
		private object _subject;
		public object Subject
		{
			get { return _subject; }
		}

		private string _oldLabel;
		public string OldLabel
		{
			get { return _oldLabel; }
		}

		private string _newLabel;
		public string NewLabel
		{
			get { return _newLabel; }
		}

		public LabelEventArgs(object subject, string oldLabel, string newLabel)
		{
			_subject = subject;
			_oldLabel = oldLabel;
			_newLabel = newLabel;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeCheckBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using Aga.Controls.Properties;
using System.Reflection;
using System.Windows.Forms;
using System.Windows.Forms.VisualStyles;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeCheckBox : InteractiveControl
	{
		public const int ImageSize = 13;

		private Bitmap _check;
		private Bitmap _uncheck;
		private Bitmap _unknown;

		#region Properties

		private bool _threeState;
		[DefaultValue(false)]
		public bool ThreeState
		{
			get { return _threeState; }
			set { _threeState = value; }
		}

		#endregion

		public NodeCheckBox()
			: this(string.Empty)
		{
		}

		public NodeCheckBox(string propertyName)
		{
			_check = Resources.check;
			_uncheck = Resources.uncheck;
			_unknown = Resources.unknown;
			DataPropertyName = propertyName;
			LeftMargin = 0;
		}

		public override Size MeasureSize(TreeNodeAdv node, DrawContext context)
		{
			int scaledX = node.Tree.GetScaledSize(ImageSize, false);
			int scaledY = node.Tree.GetScaledSize(ImageSize);
			return new Size(scaledX, scaledY);
		}

		public override void Draw(TreeNodeAdv node, DrawContext context)
		{
			Rectangle bounds = GetBounds(node, context);
			CheckState state = GetCheckState(node);
			if (Application.RenderWithVisualStyles)
			{
				VisualStyleRenderer renderer;
				int scaledX = node.Tree.GetScaledSize(ImageSize, false);
				int scaledY = node.Tree.GetScaledSize(ImageSize);
				if (state == CheckState.Indeterminate)
					renderer = new VisualStyleRenderer(VisualStyleElement.Button.CheckBox.MixedNormal);
				else if (state == CheckState.Checked)
					renderer = new VisualStyleRenderer(VisualStyleElement.Button.CheckBox.CheckedNormal);
				else
					renderer = new VisualStyleRenderer(VisualStyleElement.Button.CheckBox.UncheckedNormal);
				renderer.DrawBackground(context.Graphics, new Rectangle(bounds.X, bounds.Y, scaledX, scaledY));
			}
			else
			{
				Image img;
				if (state == CheckState.Indeterminate)
					img = _unknown;
				else if (state == CheckState.Checked)
					img = _check;
				else
					img = _uncheck;
				context.Graphics.DrawImage(img, bounds.Location);
			}
		}

		protected virtual CheckState GetCheckState(TreeNodeAdv node)
		{
			object obj = GetValue(node);
			if (obj is CheckState)
				return (CheckState)obj;
			else if (obj is bool)
				return (bool)obj ? CheckState.Checked : CheckState.Unchecked;
			else
				return CheckState.Unchecked;
		}

		protected virtual void SetCheckState(TreeNodeAdv node, CheckState value)
		{
			if (VirtualMode)
			{
				SetValue(node, value);
				OnCheckStateChanged(node);
			}
			else
			{
				Type type = GetPropertyType(node);
				if (type == typeof(CheckState))
				{
					SetValue(node, value);
					OnCheckStateChanged(node);
				}
				else if (type == typeof(bool))
				{
					SetValue(node, value != CheckState.Unchecked);
					OnCheckStateChanged(node);
				}
			}
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
			if (args.Button == MouseButtons.Left && IsEditEnabled(args.Node))
			{
				DrawContext context = new DrawContext();
				context.Bounds = args.ControlBounds;
				Rectangle rect = GetBounds(args.Node, context);
				if (rect.Contains(args.ViewLocation))
				{
					CheckState state = GetCheckState(args.Node);
					state = GetNewState(state);
					SetCheckState(args.Node, state);
					Parent.UpdateView();
					args.Handled = true;
				}
			}
		}

		public override void MouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
			args.Handled = true;
		}

		private CheckState GetNewState(CheckState state)
		{
			if (state == CheckState.Indeterminate)
				return CheckState.Unchecked;
			else if(state == CheckState.Unchecked)
				return CheckState.Checked;
			else 
				return ThreeState ? CheckState.Indeterminate : CheckState.Unchecked;
		}

		public override void KeyDown(KeyEventArgs args)
		{
			if (args.KeyCode == Keys.Space && EditEnabled)
			{
				Parent.BeginUpdate();
				try
				{
					if (Parent.CurrentNode != null)
					{
						CheckState value = GetNewState(GetCheckState(Parent.CurrentNode));
						foreach (TreeNodeAdv node in Parent.Selection)
							if (IsEditEnabled(node))
								SetCheckState(node, value);
					}
				}
				finally
				{
					Parent.EndUpdate();
				}
				args.Handled = true;
			}
		}

		public event EventHandler<TreePathEventArgs> CheckStateChanged;
		protected void OnCheckStateChanged(TreePathEventArgs args)
		{
			if (CheckStateChanged != null)
				CheckStateChanged(this, args);
		}

		protected void OnCheckStateChanged(TreeNodeAdv node)
		{
			TreePath path = this.Parent.GetPath(node);
			OnCheckStateChanged(new TreePathEventArgs(path));
		}

	}
}

```

`Aga.Controls/Tree/NodeControls/NodeComboBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using System.Reflection;
using System.ComponentModel;
using System.Drawing.Design;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeComboBox : BaseTextControl
	{
		#region Properties

		private int _editorWidth = 100;
		[DefaultValue(100)]
		public int EditorWidth
		{
			get { return _editorWidth; }
			set { _editorWidth = value; }
		}

		private int _editorHeight = 100;
		[DefaultValue(100)]
		public int EditorHeight
		{
			get { return _editorHeight; }
			set { _editorHeight = value; }
		}

		private List<object> _dropDownItems;
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
		[Editor(typeof(StringCollectionEditor), typeof(UITypeEditor)), DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
		public List<object> DropDownItems
		{
			get { return _dropDownItems; }
		}

		#endregion

		public event EventHandler<EditEventArgs> CreatingEditor;

		public NodeComboBox()
		{
			_dropDownItems = new List<object>();
		}

		protected override Size CalculateEditorSize(EditorContext context)
		{
			if (Parent.UseColumns)
			{
				if (context.Editor is CheckedListBox)
					return new Size(context.Bounds.Size.Width, EditorHeight);
				else
					return context.Bounds.Size;
			}
			else
			{
				if (context.Editor is CheckedListBox)
					return new Size(EditorWidth, EditorHeight);
				else
					return new Size(EditorWidth, context.Bounds.Height);
			}
		}

		protected override Control CreateEditor(TreeNodeAdv node)
		{
			Control c;
			object value = GetValue(node);
			if (IsCheckedListBoxRequired(node))
				c = CreateCheckedListBox(node);
			else
				c = CreateCombo(node);
			OnCreatingEditor(new EditEventArgs(node, c));
			return c;
		}

		protected override void DisposeEditor(Control editor)
		{
		}

		protected virtual void OnCreatingEditor(EditEventArgs args)
		{
			if (CreatingEditor != null)
				CreatingEditor(this, args);
		}

		protected virtual bool IsCheckedListBoxRequired(TreeNodeAdv node)
		{
			object value = GetValue(node);
			if (value != null)
			{
				Type t = value.GetType();
				object[] arr = t.GetCustomAttributes(typeof(FlagsAttribute), false);
				return (t.IsEnum && arr.Length == 1);
			}
			return false;
		}

		private Control CreateCombo(TreeNodeAdv node)
		{
			ComboBox comboBox = new ComboBox();
			if (DropDownItems != null)
				comboBox.Items.AddRange(DropDownItems.ToArray());
			comboBox.SelectedItem = GetValue(node);
			comboBox.DropDownStyle = ComboBoxStyle.DropDownList;
			comboBox.DropDownClosed += new EventHandler(EditorDropDownClosed);
			SetEditControlProperties(comboBox, node);
			return comboBox;
		}

		private Control CreateCheckedListBox(TreeNodeAdv node)
		{
			CheckedListBox listBox = new CheckedListBox();
			listBox.CheckOnClick = true;

			object value = GetValue(node);
			Type enumType = GetEnumType(node);
			foreach (object obj in Enum.GetValues(enumType))
			{
				object[] attributes = enumType.GetField(obj.ToString()).GetCustomAttributes(typeof(BrowsableAttribute), false);
				if (attributes.Length == 0 || ((BrowsableAttribute)attributes[0]).Browsable)
					listBox.Items.Add(obj, IsContain(value, obj));
			}

			SetEditControlProperties(listBox, node);
			if (CreatingEditor != null)
				CreatingEditor(this, new EditEventArgs(node, listBox));
			return listBox;
		}

		protected virtual Type GetEnumType(TreeNodeAdv node)
		{
			object value = GetValue(node);
			return value.GetType();
		}

		private bool IsContain(object value, object enumElement)
		{
			if (value == null || enumElement == null)
				return false;
			if (value.GetType().IsEnum)
			{
				int i1 = (int)value;
				int i2 = (int)enumElement;
				return (i1 & i2) == i2;
			}
			else
			{
				var arr = value as object[];
				foreach (object obj in arr)
					if ((int)obj == (int)enumElement)
						return true;
				return false;
			}
		}

		protected override string FormatLabel(object obj)
		{
			var arr = obj as object[];
			if (arr != null)
			{
				StringBuilder sb = new StringBuilder();
				foreach (object t in arr)
				{
					if (sb.Length > 0)
						sb.Append(", ");
					sb.Append(t);
				}
				return sb.ToString();
			}
			else
				return base.FormatLabel(obj);
		}

		void EditorDropDownClosed(object sender, EventArgs e)
		{
			EndEdit(true);
		}

		public override void UpdateEditor(Control control)
		{
			if (control is ComboBox)
				(control as ComboBox).DroppedDown = true;
		}

		protected override void DoApplyChanges(TreeNodeAdv node, Control editor)
		{
			var combo = editor as ComboBox;
			if (combo != null)
			{
				if (combo.DropDownStyle == ComboBoxStyle.DropDown)
					SetValue(node, combo.Text);
				else
					SetValue(node, combo.SelectedItem);
			}
			else
			{
				var listBox = editor as CheckedListBox;
				Type type = GetEnumType(node);
				if (IsFlags(type))
				{
					int res = 0;
					foreach (object obj in listBox.CheckedItems)
						res |= (int)obj;
					object val = Enum.ToObject(type, res);
					SetValue(node, val);
				}
				else
				{
					List<object> list = new List<object>();
					foreach (object obj in listBox.CheckedItems)
						list.Add(obj);
					SetValue(node, list.ToArray());
				}
			}
		}

		private bool IsFlags(Type type)
		{
			object[] atr = type.GetCustomAttributes(typeof(FlagsAttribute), false);
			return atr.Length == 1;
		}

		public override void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
			if (args.Node != null && args.Node.IsSelected) //Workaround of specific ComboBox control behavior
				base.MouseUp(args);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	[DesignTimeVisible(false), ToolboxItem(false)]
	public abstract class NodeControl : Component
	{
		#region Properties

		private TreeViewAdv _parent;
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public TreeViewAdv Parent
		{
			get { return _parent; }
			set 
			{
				if (value != _parent)
				{
					if (_parent != null)
						_parent.NodeControls.Remove(this);

					if (value != null)
						value.NodeControls.Add(this);
				}
			}
		}

		private IToolTipProvider _toolTipProvider;
		[Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public IToolTipProvider ToolTipProvider
		{
			get { return _toolTipProvider; }
			set { _toolTipProvider = value; }
		}

		private TreeColumn _parentColumn;
		public TreeColumn ParentColumn
		{
			get { return _parentColumn; }
			set 
			{ 
				_parentColumn = value; 
				if (_parent != null)
					_parent.FullUpdate();
			}
		}

		private VerticalAlignment _verticalAlign = VerticalAlignment.Center;
		[DefaultValue(VerticalAlignment.Center)]
		public VerticalAlignment VerticalAlign
		{
			get { return _verticalAlign; }
			set 
			{ 
				_verticalAlign = value;
				if (_parent != null)
					_parent.FullUpdate();
			}
		}

		private int _leftMargin = 0;
		public int LeftMargin
		{
			get { return _leftMargin; }
			set 
			{
				if (value < 0)
					throw new ArgumentOutOfRangeException();

				_leftMargin = value;
				if (_parent != null)
					_parent.FullUpdate();
			}
		}
		#endregion

		internal virtual void AssignParent(TreeViewAdv parent)
		{
			_parent = parent;
		}

		protected virtual Rectangle GetBounds(TreeNodeAdv node, DrawContext context)
		{
			Rectangle r = context.Bounds;
			Size s = GetActualSize(node, context);
			Size bs = new Size(r.Width - LeftMargin, Math.Min(r.Height, s.Height));
			switch (VerticalAlign)
			{
				case VerticalAlignment.Top:
					return new Rectangle(new Point(r.X + LeftMargin, r.Y), bs);
				case VerticalAlignment.Bottom:
					return new Rectangle(new Point(r.X + LeftMargin, r.Bottom - s.Height), bs);
				default:
					return new Rectangle(new Point(r.X + LeftMargin, r.Y + (r.Height - s.Height) / 2), bs);
			}
		}

		protected void CheckThread()
		{
			if (Parent != null && Control.CheckForIllegalCrossThreadCalls)
				if (Parent.InvokeRequired)
					throw new InvalidOperationException("Cross-thread calls are not allowed");
		}

		public bool IsVisible(TreeNodeAdv node)
		{
			NodeControlValueEventArgs args = new NodeControlValueEventArgs(node);
			args.Value = true;
			OnIsVisibleValueNeeded(args);
			return Convert.ToBoolean(args.Value);
		}

		internal Size GetActualSize(TreeNodeAdv node, DrawContext context)
		{
			if (IsVisible(node))
			{
				Size s = MeasureSize(node, context);
				return new Size(s.Width + LeftMargin, s.Height);
			}
			else
				return Size.Empty;
		}

		public abstract Size MeasureSize(TreeNodeAdv node, DrawContext context);

		public abstract void Draw(TreeNodeAdv node, DrawContext context);

		public virtual string GetToolTip(TreeNodeAdv node)
		{
			if (ToolTipProvider != null)
				return ToolTipProvider.GetToolTip(node, this);
			else
				return string.Empty;
		}

		public virtual void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
		}

		public virtual void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
		}

		public virtual void MouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
		}

		public virtual void KeyDown(KeyEventArgs args)
		{
		}

		public virtual void KeyUp(KeyEventArgs args)
		{
		}

		public event EventHandler<NodeControlValueEventArgs> IsVisibleValueNeeded;
		protected virtual void OnIsVisibleValueNeeded(NodeControlValueEventArgs args)
		{
			if (IsVisibleValueNeeded != null)
				IsVisibleValueNeeded(this, args);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeControlValueEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeControlValueEventArgs : NodeEventArgs
	{
		private object _value;
		public object Value
		{
			get { return _value; }
			set { _value = value; }
		}

		public NodeControlValueEventArgs(TreeNodeAdv node)
			:base(node)
		{
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeControlsCollection.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel.Design;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Drawing.Design;

namespace Aga.Controls.Tree.NodeControls
{
	internal class NodeControlsCollection : Collection<NodeControl>
	{
		private TreeViewAdv _tree;

		public NodeControlsCollection(TreeViewAdv tree)
		{
			_tree = tree;
		}

		protected override void ClearItems()
		{
			_tree.BeginUpdate();
			try
			{
				while (this.Count != 0)
					this.RemoveAt(this.Count - 1);
			}
			finally
			{
				_tree.EndUpdate();
			}
		}

		protected override void InsertItem(int index, NodeControl item)
		{
			if (item == null)
				throw new ArgumentNullException("item");

			if (item.Parent != _tree)
			{
				if (item.Parent != null)
				{
					item.Parent.NodeControls.Remove(item);
				}
				base.InsertItem(index, item);
				item.AssignParent(_tree);
				_tree.FullUpdate();
			}
		}

		protected override void RemoveItem(int index)
		{
			NodeControl value = this[index];
			value.AssignParent(null);
			base.RemoveItem(index);
			_tree.FullUpdate();
		}

		protected override void SetItem(int index, NodeControl item)
		{
			if (item == null)
				throw new ArgumentNullException("item");

			_tree.BeginUpdate();
			try
			{
				RemoveAt(index);
				InsertItem(index, item);
			}
			finally
			{
				_tree.EndUpdate();
			}
		}
	}

	internal class NodeControlCollectionEditor : CollectionEditor
	{
		private Type[] _types;

		public NodeControlCollectionEditor(Type type)
			: base(type)
		{
			_types = new Type[] { typeof(NodeTextBox), typeof(NodeIntegerTextBox), typeof(NodeDecimalTextBox), 
				typeof(NodeComboBox), typeof(NodeCheckBox),
				typeof(NodeStateIcon), typeof(NodeIcon), typeof(NodeNumericUpDown), typeof(ExpandingIcon)  };
		}

		protected override System.Type[] CreateNewItemTypes()
		{
			return _types;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeDecimalTextBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using System.Reflection;
using System.ComponentModel; 
 
namespace Aga.Controls.Tree.NodeControls
{
	public class NodeDecimalTextBox : NodeTextBox
	{
		private bool _allowDecimalSeparator = true;
		[DefaultValue(true)]
		public bool AllowDecimalSeparator
		{
			get { return _allowDecimalSeparator; }
			set { _allowDecimalSeparator = value; }
		}

		private bool _allowNegativeSign = true;
		[DefaultValue(true)]
		public bool AllowNegativeSign
		{
			get { return _allowNegativeSign; }
			set { _allowNegativeSign = value; }
		}

		protected NodeDecimalTextBox()
		{
		}

		protected override TextBox CreateTextBox()
		{
			NumericTextBox textBox = new NumericTextBox();
			textBox.AllowDecimalSeparator = AllowDecimalSeparator;
			textBox.AllowNegativeSign = AllowNegativeSign;
			return textBox;
		}

		protected override void DoApplyChanges(TreeNodeAdv node, Control editor)
		{
			SetValue(node, (editor as NumericTextBox).DecimalValue);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeEventArgs : EventArgs
	{
		private TreeNodeAdv _node;
		public TreeNodeAdv Node
		{
			get { return _node; }
		}

		public NodeEventArgs(TreeNodeAdv node)
		{
			_node = node;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeIcon.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using Aga.Controls.Properties;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeIcon : BindableControl
	{
		public NodeIcon()
		{
			LeftMargin = 1;
		}

		public override Size MeasureSize(TreeNodeAdv node, DrawContext context)
		{
			Image image = GetIcon(node);
			if (image != null)
			{
				int scaledX = node.Tree.GetScaledSize(image.Size.Width, false);
				int scaledY = node.Tree.GetScaledSize(image.Size.Height);
				return new Size(scaledX, scaledY); ;
			}
			else
			{
				return Size.Empty;
			}
		}


		public override void Draw(TreeNodeAdv node, DrawContext context)
		{
			Image image = GetIcon(node);
			if (image != null)
			{
				Rectangle r = GetBounds(node, context);
				if ( image.Width > 0 && image.Height > 0 )
				{
					switch (_scaleMode)
					{
						case ImageScaleMode.Fit:
							context.Graphics.DrawImage(image, r);
							break;
						case ImageScaleMode.ScaleDown:
							{
								float factor = Math.Min((float)r.Width / (float)image.Width, (float)r.Height / (float)image.Height);
								if (factor < 1)
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width * factor, image.Height * factor);
								else
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width, image.Height);
							} break;
						case ImageScaleMode.ScaleUp:
							{
								float factor = Math.Max((float)r.Width / (float)image.Width, (float)r.Height / (float)image.Height);
								if (factor > 1)
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width * factor, image.Height * factor);
								else
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width, image.Height);
							} break;
						case ImageScaleMode.AlwaysScale:
							{
								float fx = (float)r.Width / (float)image.Width;
								float fy = (float)r.Height / (float)image.Height;
								if (Math.Min(fx, fy) < 1)
								{ //scale down
									float factor = Math.Min(fx, fy);
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width * factor, image.Height * factor);
								}
								else if (Math.Max(fx, fy) > 1)
								{
									float factor = Math.Max(fx, fy);
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width * factor, image.Height * factor);
								}
								else
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width, image.Height);
							} break;
						case ImageScaleMode.Clip:
						default: 
							context.Graphics.DrawImage(image, r.X, r.Y, image.Width, image.Height);
							break;
					}
				}

			}
		}

		protected virtual Image GetIcon(TreeNodeAdv node)
		{
			return GetValue(node) as Image;
		}

        private ImageScaleMode _scaleMode = ImageScaleMode.Clip;
        [DefaultValue("Clip"), Category("Appearance")]
        public ImageScaleMode ScaleMode
        {
            get { return _scaleMode; }
            set { _scaleMode = value; }
        }


	}
}

```

`Aga.Controls/Tree/NodeControls/NodeIntegerTextBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel;
using System.Windows.Forms;

namespace Aga.Controls.Tree.NodeControls
{

	public class NodeIntegerTextBox : NodeTextBox
	{
		private bool _allowNegativeSign = true;
		[DefaultValue(true)]
		public bool AllowNegativeSign
		{
			get { return _allowNegativeSign; }
			set { _allowNegativeSign = value; }
		}

		public NodeIntegerTextBox()
		{
		}

		protected override TextBox CreateTextBox()
		{
			NumericTextBox textBox = new NumericTextBox();
			textBox.AllowDecimalSeparator = false;
			textBox.AllowNegativeSign = AllowNegativeSign;
			return textBox;
		}

		protected override void DoApplyChanges(TreeNodeAdv node, Control editor)
		{
			SetValue(node, (editor as NumericTextBox).IntValue);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeNumericUpDown.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using System.Reflection;
using System.ComponentModel;
using System.Drawing.Design;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeNumericUpDown : BaseTextControl
	{
		#region Properties

		private int _editorWidth = 100;
		[DefaultValue(100)]
		public int EditorWidth
		{
			get { return _editorWidth; }
			set { _editorWidth = value; }
		}

		private int _decimalPlaces = 0;
		[Category("Data"), DefaultValue(0)]
		public int DecimalPlaces
		{
			get
			{
				return this._decimalPlaces;
			}
			set
			{
				this._decimalPlaces = value;
			}
		}

		private decimal _increment = 1;
		[Category("Data"), DefaultValue(1)]
		public decimal Increment
		{
			get
			{
				return this._increment;
			}
			set
			{
				this._increment = value;
			}
		}

		private decimal _minimum = 0;
		[Category("Data"), DefaultValue(0)]
		public decimal Minimum
		{
			get
			{
				return _minimum;
			}
			set
			{
				_minimum = value;
			}
		}

		private decimal _maximum = 100;
		[Category("Data"), DefaultValue(100)]
		public decimal Maximum
		{
			get
			{
				return this._maximum;
			}
			set
			{
				this._maximum = value;
			}
		}

		#endregion

		public NodeNumericUpDown()
		{
		}

		protected override Size CalculateEditorSize(EditorContext context)
		{
			if (Parent.UseColumns)
				return context.Bounds.Size;
			else
				return new Size(EditorWidth, context.Bounds.Height);
		}

		protected override Control CreateEditor(TreeNodeAdv node)
		{
			NumericUpDown num = new NumericUpDown();
			num.Increment = Increment;
			num.DecimalPlaces = DecimalPlaces;
			num.Minimum = Minimum;
			num.Maximum = Maximum;
			num.Value = (decimal)GetValue(node);
			SetEditControlProperties(num, node);
			return num;
		}

		protected override void DisposeEditor(Control editor)
		{
		}

		protected override void DoApplyChanges(TreeNodeAdv node, Control editor)
		{
			SetValue(node, (editor as NumericUpDown).Value);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodePlusMinus.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using Aga.Controls.Properties;
using System.Windows.Forms;
using System.Windows.Forms.VisualStyles;

namespace Aga.Controls.Tree.NodeControls
{
	internal class NodePlusMinus : NodeControl
	{
		public const int ImageSize = 9;
		public const int Width = 16;
		private Bitmap _plus;
		private Bitmap _minus;

		private VisualStyleRenderer _openedRenderer;
		private VisualStyleRenderer OpenedRenderer
		{
			get
			{
				if (_openedRenderer == null)
					_openedRenderer = new VisualStyleRenderer(VisualStyleElement.TreeView.Glyph.Opened);
				return _openedRenderer;

			}
		}

		private VisualStyleRenderer _closedRenderer;
		private VisualStyleRenderer ClosedRenderer
		{
			get
			{
				if (_closedRenderer == null)
					_closedRenderer = new VisualStyleRenderer(VisualStyleElement.TreeView.Glyph.Closed);
				return _closedRenderer;
			}
		}

		public NodePlusMinus()
		{
			_plus = Resources.plus;
			_minus = Resources.minus;
		}

		public override Size MeasureSize(TreeNodeAdv node, DrawContext context)
		{
			int scaledX = node.Tree.GetScaledSize(Width, false);
			int scaledY = node.Tree.GetScaledSize(Width);
			return new Size(scaledX, scaledY);
		}

		public override void Draw(TreeNodeAdv node, DrawContext context)
		{
			if (node.CanExpand)
			{
				Rectangle r = context.Bounds;
				int scaledX = node.Tree.GetScaledSize(ImageSize, false);
				int scaledY = node.Tree.GetScaledSize(ImageSize);
				int dy = (int)Math.Round((float)(r.Height - scaledY) / 2);
				if (Application.RenderWithVisualStyles)
				{
					VisualStyleRenderer renderer;
					if (node.IsExpanded)
						renderer = OpenedRenderer;
					else
						renderer = ClosedRenderer;
					renderer.DrawBackground(context.Graphics, new Rectangle(r.X, r.Y + dy, scaledX, scaledY));
				}
				else
				{
					Image img;
					if (node.IsExpanded)
						img = _minus;
					else
						img = _plus;
					context.Graphics.DrawImageUnscaled(img, new Point(r.X, r.Y + dy));
				}
			}
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
			if (args.Button == MouseButtons.Left)
			{
				args.Handled = true;
				if (args.Node.CanExpand)
					args.Node.IsExpanded = !args.Node.IsExpanded;
			}
		}

		public override void MouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
			args.Handled = true; // Supress expand/collapse when double click on plus/minus
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeStateIcon.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using Aga.Controls.Properties;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeStateIcon: NodeIcon
	{
		private Image _leaf;
		private Image _opened;
		private Image _closed;

		public NodeStateIcon()
		{
			_leaf = MakeTransparent(Resources.Leaf);
			_opened = MakeTransparent(Resources.Folder);
			_closed = MakeTransparent(Resources.FolderClosed);
		}

		private static Image MakeTransparent(Bitmap bitmap)
		{
			bitmap.MakeTransparent(bitmap.GetPixel(0,0));
			return bitmap;
		}

		protected override Image GetIcon(TreeNodeAdv node)
		{
			Image icon = base.GetIcon(node);
			if (icon != null)
				return icon;
			else if (node.IsLeaf)
				return _leaf;
			else if (node.CanExpand && node.IsExpanded)
				return _opened;
			else
				return _closed;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeTextBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using System.Reflection;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeTextBox : BaseTextControl
	{
		private const int MinTextBoxWidth = 30;

		public NodeTextBox()
		{
		}

		protected override Size CalculateEditorSize(EditorContext context)
		{
			if (Parent.UseColumns)
				return context.Bounds.Size;
			else
			{
				Size size = GetLabelSize(context.CurrentNode, context.DrawContext, _label);
				int width = Math.Max(size.Width + Font.Height, MinTextBoxWidth); // reserve a place for new typed character
				return new Size(width, size.Height);
			}
		}

		public override void KeyDown(KeyEventArgs args)
		{
			if (args.KeyCode == Keys.F2 && Parent.CurrentNode != null && EditEnabled)
			{
				args.Handled = true;
				BeginEdit();
			}
		}

		protected override Control CreateEditor(TreeNodeAdv node)
		{
			TextBox textBox = CreateTextBox();
			textBox.TextAlign = TextAlign;
			textBox.Text = GetLabel(node);
			textBox.BorderStyle = BorderStyle.FixedSingle;
			textBox.TextChanged += EditorTextChanged;
			textBox.KeyDown += EditorKeyDown;
			_label = textBox.Text;
			SetEditControlProperties(textBox, node);
			return textBox;
		}

		protected virtual TextBox CreateTextBox()
		{
			return new TextBox();
		}

		protected override void DisposeEditor(Control editor)
		{
			var textBox = editor as TextBox;
			textBox.TextChanged -= EditorTextChanged;
			textBox.KeyDown -= EditorKeyDown;
		}

		private void EditorKeyDown(object sender, KeyEventArgs e)
		{
			if (e.KeyCode == Keys.Escape)
				EndEdit(false);
			else if (e.KeyCode == Keys.Enter)
				EndEdit(true);
		}

		private string _label;
		private void EditorTextChanged(object sender, EventArgs e)
		{
			var textBox = sender as TextBox;
			_label = textBox.Text;
			Parent.UpdateEditorBounds();
		}

		protected override void DoApplyChanges(TreeNodeAdv node, Control editor)
		{
			var label = (editor as TextBox).Text;
			string oldLabel = GetLabel(node);
			if (oldLabel != label)
			{
				SetLabel(node, label);
				OnLabelChanged(node.Tag, oldLabel, label);
			}
		}

		public override void Cut(Control control)
		{
			(control as TextBox).Cut();
		}

		public override void Copy(Control control)
		{
			(control as TextBox).Copy();
		}

		public override void Paste(Control control)
		{
			(control as TextBox).Paste();
		}

		public override void Delete(Control control)
		{
			var textBox = control as TextBox;
			int len = Math.Max(textBox.SelectionLength, 1);
			if (textBox.SelectionStart < textBox.Text.Length)
			{
				int start = textBox.SelectionStart;
				textBox.Text = textBox.Text.Remove(textBox.SelectionStart, len);
				textBox.SelectionStart = start;
			}
		}

		public event EventHandler<LabelEventArgs> LabelChanged;
		protected void OnLabelChanged(object subject, string oldLabel, string newLabel)
		{
			if (LabelChanged != null)
				LabelChanged(this, new LabelEventArgs(subject, oldLabel, newLabel));
		}
	}
}

```

`Aga.Controls/Tree/SortedTreeModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;

namespace Aga.Controls.Tree
{
	public class SortedTreeModel: TreeModelBase
	{
		private ITreeModel _innerModel;
		public ITreeModel InnerModel
		{
			get { return _innerModel; }
		}

		private IComparer _comparer;
		public IComparer Comparer
		{
			get { return _comparer; }
			set 
			{ 
				_comparer = value;
				OnStructureChanged(new TreePathEventArgs(TreePath.Empty));
			}
		}

		public SortedTreeModel(ITreeModel innerModel)
		{
			_innerModel = innerModel;
			_innerModel.NodesChanged += new EventHandler<TreeModelEventArgs>(_innerModel_NodesChanged);
			_innerModel.NodesInserted += new EventHandler<TreeModelEventArgs>(_innerModel_NodesInserted);
			_innerModel.NodesRemoved += new EventHandler<TreeModelEventArgs>(_innerModel_NodesRemoved);
			_innerModel.StructureChanged += new EventHandler<TreePathEventArgs>(_innerModel_StructureChanged);
		}

		void _innerModel_StructureChanged(object sender, TreePathEventArgs e)
		{
			OnStructureChanged(e);
		}

		void _innerModel_NodesRemoved(object sender, TreeModelEventArgs e)
		{
			OnStructureChanged(new TreePathEventArgs(e.Path));
		}

		void _innerModel_NodesInserted(object sender, TreeModelEventArgs e)
		{
			OnStructureChanged(new TreePathEventArgs(e.Path));
		}

		void _innerModel_NodesChanged(object sender, TreeModelEventArgs e)
		{
			OnStructureChanged(new TreePathEventArgs(e.Path));
		}

		public override IEnumerable GetChildren(TreePath treePath)
		{
			if (Comparer != null)
			{
				ArrayList list = new ArrayList();
				IEnumerable res = InnerModel.GetChildren(treePath);
				if (res != null)
				{
					foreach (object obj in res)
						list.Add(obj);
					list.Sort(Comparer);
					return list;
				}
				else
					return null;
			}
			else
				return InnerModel.GetChildren(treePath);
		}

		public override bool IsLeaf(TreePath treePath)
		{
			return InnerModel.IsLeaf(treePath);
		}
	}
}

```

`Aga.Controls/Tree/TreeColumn.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel;
using System.Windows.Forms;
using System.Drawing;
using System.Windows.Forms.VisualStyles;
using System.Drawing.Imaging;

namespace Aga.Controls.Tree
{
	[TypeConverter(typeof(TreeColumn.TreeColumnConverter)), DesignTimeVisible(false), ToolboxItem(false)]
	public class TreeColumn : Component
	{
		private class TreeColumnConverter : ComponentConverter
		{
			public TreeColumnConverter()
				: base(typeof(TreeColumn))
			{
			}

			public override bool GetPropertiesSupported(ITypeDescriptorContext context)
			{
				return false;
			}
		}

		private const int HeaderLeftMargin = 5;
        private const int HeaderRightMargin = 5;   
		private const int SortOrderMarkMargin = 8;

        private TextFormatFlags _headerFlags;
        private TextFormatFlags _baseHeaderFlags = TextFormatFlags.NoPadding | 
                                                   TextFormatFlags.EndEllipsis |
                                                   TextFormatFlags.VerticalCenter |
												TextFormatFlags.PreserveGraphicsTranslateTransform;

		#region Properties

        private TreeColumnCollection _owner;
		internal TreeColumnCollection Owner
		{
			get { return _owner; }
			set { _owner = value; }
		}

		[Browsable(false)]
		public int Index
		{
			get 
			{
				if (Owner != null)
					return Owner.IndexOf(this);
				else
					return -1;
			}
		}

		private string _header;
		[Localizable(true)]
		public string Header
		{
			get { return _header; }
			set 
			{ 
				_header = value;
				OnHeaderChanged();
			}
		}

		private string _tooltipText;
		[Localizable(true)]
		public string TooltipText
		{
			get { return _tooltipText; }
			set { _tooltipText = value; }
		}

		private int _width;
		[DefaultValue(50), Localizable(true)]
		public int Width
		{
			get
            {
                return _width;
            }
			set 
			{
				if (_width != value)
				{
                    _width = Math.Max(MinColumnWidth, value);
                    if (_maxColumnWidth > 0)
                    {
                        _width = Math.Min(_width, MaxColumnWidth);
                    }
					OnWidthChanged();
				}
			}
		}

        private int _minColumnWidth;
        [DefaultValue(0)]
        public int MinColumnWidth
        {
            get { return _minColumnWidth; }
            set
            {
				if (value < 0)
					throw new ArgumentOutOfRangeException("value");

				_minColumnWidth = value;
                Width = Math.Max(value, Width);
            }
        }

        private int _maxColumnWidth;
        [DefaultValue(0)]
        public int MaxColumnWidth
        {
            get { return _maxColumnWidth; }
            set
            {
				if (value < 0)
					throw new ArgumentOutOfRangeException("value");

				_maxColumnWidth = value;
				if (value > 0)
					Width = Math.Min(value, _width);
            }
        }

		private bool _visible = true;
		[DefaultValue(true)]
		public bool IsVisible
		{
			get { return _visible; }
			set 
			{ 
				_visible = value;
				OnIsVisibleChanged();
			}
		}

		private HorizontalAlignment _textAlign = HorizontalAlignment.Left;
		[DefaultValue(HorizontalAlignment.Left)]
		public HorizontalAlignment TextAlign
		{
			get { return _textAlign; }
			set 
			{
				if (value != _textAlign)
				{
					_textAlign = value;
                    _headerFlags = _baseHeaderFlags | TextHelper.TranslateAligmentToFlag(value);
					OnHeaderChanged();
				}
			}
		}

        private bool _sortable = false;
        [DefaultValue(false)]
        public bool Sortable
        {
            get { return _sortable; }
            set { _sortable = value; }
        }

		private SortOrder _sort_order = SortOrder.None;
		public SortOrder SortOrder
		{
			get { return _sort_order; }
			set
			{
				if (value == _sort_order)
					return;
				_sort_order = value;
				OnSortOrderChanged();
			}
		}

		public Size SortMarkSize
		{
			get
			{
				if (Application.RenderWithVisualStyles)
					return new Size(9, 5);
				else
					return new Size(7, 4);
			}
		}
		#endregion

		public TreeColumn(): 
			this(string.Empty, 50)
		{
		}

        public TreeColumn(string header, int width)
		{
			_header = header;
			_width = width;
            _headerFlags = _baseHeaderFlags | TextFormatFlags.Left;
		}

		public override string ToString()
		{
			if (string.IsNullOrEmpty(Header))
				return GetType().Name;
			else
				return Header;
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
		}

		#region Draw

		private static VisualStyleRenderer _normalRenderer;
		private static VisualStyleRenderer _pressedRenderer;
		private static VisualStyleRenderer _hotRenderer;

		private static void CreateRenderers()
		{
			if (Application.RenderWithVisualStyles && _normalRenderer == null)
			{
				_normalRenderer = new VisualStyleRenderer(VisualStyleElement.Header.Item.Normal);
				_pressedRenderer = new VisualStyleRenderer(VisualStyleElement.Header.Item.Pressed);
				_hotRenderer = new VisualStyleRenderer(VisualStyleElement.Header.Item.Hot);
			}
		}

		internal Bitmap CreateGhostImage(Rectangle bounds, Font font)
		{
			Bitmap b = new Bitmap(bounds.Width, bounds.Height, PixelFormat.Format32bppArgb);
			Graphics gr = Graphics.FromImage(b);
			gr.FillRectangle(SystemBrushes.ControlDark, bounds);
			DrawContent(gr, bounds, font);
			BitmapHelper.SetAlphaChanelValue(b, 150);
			return b;
		}

		internal void Draw(Graphics gr, Rectangle bounds, Font font, bool pressed, bool hot)
		{
			DrawBackground(gr, bounds, pressed, hot);
			DrawContent(gr, bounds, font);
		}

        private void DrawContent(Graphics gr, Rectangle bounds, Font font)
        {
            Rectangle innerBounds = new Rectangle(bounds.X + HeaderLeftMargin, bounds.Y,
                                   bounds.Width - HeaderLeftMargin - HeaderRightMargin,
                                   bounds.Height);

            if (SortOrder != SortOrder.None)
				innerBounds.Width -= (SortMarkSize.Width + SortOrderMarkMargin);

            Size maxTextSize = TextRenderer.MeasureText(gr, Header, font, innerBounds.Size, TextFormatFlags.NoPadding);
			Size textSize = TextRenderer.MeasureText(gr, Header, font, innerBounds.Size, _baseHeaderFlags);

            if (SortOrder != SortOrder.None)
            {
				int tw = Math.Min(textSize.Width, innerBounds.Size.Width);

                int x = 0;
                if (TextAlign == HorizontalAlignment.Left)
					x = innerBounds.X + tw + SortOrderMarkMargin;
                else if (TextAlign == HorizontalAlignment.Right)
					x = innerBounds.Right + SortOrderMarkMargin;
                else
					x = innerBounds.X + tw + (innerBounds.Width - tw) / 2 + SortOrderMarkMargin;
                DrawSortMark(gr, bounds, x);
			}

			if (textSize.Width < maxTextSize.Width)
				TextRenderer.DrawText(gr, Header, font, innerBounds, SystemColors.ControlText, _baseHeaderFlags | TextFormatFlags.Left);
            else
				TextRenderer.DrawText(gr, Header, font, innerBounds, SystemColors.ControlText, _headerFlags);
        }

		private void DrawSortMark(Graphics gr, Rectangle bounds, int x)
		{
			int y = bounds.Y + bounds.Height / 2 - 2;
			x = Math.Max(x, bounds.X + SortOrderMarkMargin);

            int w2 = SortMarkSize.Width / 2;
            if (SortOrder == SortOrder.Ascending)
            {
                Point[] points = new Point[] { new Point(x, y), new Point(x + SortMarkSize.Width, y), new Point(x + w2, y + SortMarkSize.Height) };
                gr.FillPolygon(SystemBrushes.ControlDark, points);
            }
            else if (SortOrder == SortOrder.Descending)
            {
                Point[] points = new Point[] { new Point(x - 1, y + SortMarkSize.Height), new Point(x + SortMarkSize.Width, y + SortMarkSize.Height), new Point(x + w2, y - 1) };
                gr.FillPolygon(SystemBrushes.ControlDark, points);
            }
		}

		internal static void DrawDropMark(Graphics gr, Rectangle rect)
		{
			gr.FillRectangle(SystemBrushes.HotTrack, rect.X-1, rect.Y, 2, rect.Height);
		}

		internal static void DrawBackground(Graphics gr, Rectangle bounds, bool pressed, bool hot)
		{
			if (Application.RenderWithVisualStyles)
			{
				CreateRenderers();
				if (pressed)
					_pressedRenderer.DrawBackground(gr, bounds);
				else if (hot)
					_hotRenderer.DrawBackground(gr, bounds);
				else
					_normalRenderer.DrawBackground(gr, bounds);
			}
			else
			{
				gr.FillRectangle(SystemBrushes.Control, bounds);
				Pen p1 = SystemPens.ControlLightLight;
				Pen p2 = SystemPens.ControlDark;
				Pen p3 = SystemPens.ControlDarkDark;
				if (pressed)
					gr.DrawRectangle(p2, bounds.X, bounds.Y, bounds.Width, bounds.Height);
				else
				{
					gr.DrawLine(p1, bounds.X, bounds.Y, bounds.Right, bounds.Y);
					gr.DrawLine(p3, bounds.X, bounds.Bottom, bounds.Right, bounds.Bottom);
					gr.DrawLine(p3, bounds.Right - 1, bounds.Y, bounds.Right - 1, bounds.Bottom - 1);
					gr.DrawLine(p1, bounds.Left, bounds.Y + 1, bounds.Left, bounds.Bottom - 2);
					gr.DrawLine(p2, bounds.Right - 2, bounds.Y + 1, bounds.Right - 2, bounds.Bottom - 2);
					gr.DrawLine(p2, bounds.X, bounds.Bottom - 1, bounds.Right - 2, bounds.Bottom - 1);
				}
			}
		}

		#endregion

		#region Events

		public event EventHandler HeaderChanged;
		private void OnHeaderChanged()
		{
			if (HeaderChanged != null)
				HeaderChanged(this, EventArgs.Empty);
		}

		public event EventHandler SortOrderChanged;
		private void OnSortOrderChanged()
		{
			if (SortOrderChanged != null)
				SortOrderChanged(this, EventArgs.Empty);
		}

		public event EventHandler IsVisibleChanged;
		private void OnIsVisibleChanged()
		{
			if (IsVisibleChanged != null)
				IsVisibleChanged(this, EventArgs.Empty);
		}

		public event EventHandler WidthChanged;
		private void OnWidthChanged()
		{
			if (WidthChanged != null)
				WidthChanged(this, EventArgs.Empty);
		}

		#endregion
	}
}

```

`Aga.Controls/Tree/TreeColumnCollection.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Forms;

namespace Aga.Controls.Tree
{
	internal class TreeColumnCollection : Collection<TreeColumn>
	{
		private TreeViewAdv _treeView;

		public TreeColumnCollection(TreeViewAdv treeView)
		{
			_treeView = treeView;
		}

		protected override void InsertItem(int index, TreeColumn item)
		{
			base.InsertItem(index, item);
			BindEvents(item);
			_treeView.UpdateColumns();
		}

		protected override void RemoveItem(int index)
		{
			UnbindEvents(this[index]);
			base.RemoveItem(index);
			_treeView.UpdateColumns();
		}

		protected override void SetItem(int index, TreeColumn item)
		{
			UnbindEvents(this[index]);
			base.SetItem(index, item);
			item.Owner = this;
			BindEvents(item);
			_treeView.UpdateColumns();
		}

		protected override void ClearItems()
		{
			foreach (TreeColumn c in Items)
				UnbindEvents(c);
			Items.Clear();
			_treeView.UpdateColumns();
		}

		private void BindEvents(TreeColumn item)
		{
			item.Owner = this;
			item.HeaderChanged += HeaderChanged;
			item.IsVisibleChanged += IsVisibleChanged;
			item.WidthChanged += WidthChanged;
			item.SortOrderChanged += SortOrderChanged;
		}

		private void UnbindEvents(TreeColumn item)
		{
			item.Owner = null;
			item.HeaderChanged -= HeaderChanged;
			item.IsVisibleChanged -= IsVisibleChanged;
			item.WidthChanged -= WidthChanged;
			item.SortOrderChanged -= SortOrderChanged;
		}

		void SortOrderChanged(object sender, EventArgs e)
		{
			TreeColumn changed = sender as TreeColumn;
			//Only one column at a time can have a sort property set
			if (changed.SortOrder != SortOrder.None)
			{
				foreach (TreeColumn col in this)
				{
					if (col != changed)
						col.SortOrder = SortOrder.None;
				}
			}
			_treeView.UpdateHeaders();
		}

		void WidthChanged(object sender, EventArgs e)
		{
			_treeView.ChangeColumnWidth(sender as TreeColumn);
		}

		void IsVisibleChanged(object sender, EventArgs e)
		{
			_treeView.FullUpdate();
		}

		void HeaderChanged(object sender, EventArgs e)
		{
			_treeView.UpdateView();
		}
	}
}

```

`Aga.Controls/Tree/TreeColumnEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public class TreeColumnEventArgs: EventArgs
	{
		private TreeColumn _column;
		public TreeColumn Column
		{
			get { return _column; }
		}

		public TreeColumnEventArgs(TreeColumn column)
		{
			_column = column;
		}
	}
}

```

`Aga.Controls/Tree/TreeListAdapter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	/// <summary>
	/// Converts IEnumerable interface to ITreeModel. 
	/// Allows to display a plain list in the TreeView
	/// </summary>
	public class TreeListAdapter : ITreeModel
	{
		private System.Collections.IEnumerable _list;

		public TreeListAdapter(System.Collections.IEnumerable list)
		{
			_list = list;
		}

		#region ITreeModel Members

		public System.Collections.IEnumerable GetChildren(TreePath treePath)
		{
			if (treePath.IsEmpty())
				return _list;
			else
				return null;
		}

		public bool IsLeaf(TreePath treePath)
		{
			return true;
		}

		public event EventHandler<TreeModelEventArgs> NodesChanged;
		public void OnNodesChanged(TreeModelEventArgs args)
		{
			if (NodesChanged != null)
				NodesChanged(this, args);
		}

		public event EventHandler<TreePathEventArgs> StructureChanged;
		public void OnStructureChanged(TreePathEventArgs args)
		{
			if (StructureChanged != null)
				StructureChanged(this, args);
		}

		public event EventHandler<TreeModelEventArgs> NodesInserted;
		public void OnNodeInserted(TreeModelEventArgs args)
		{
			if (NodesInserted != null)
				NodesInserted(this, args);
		}

		public event EventHandler<TreeModelEventArgs> NodesRemoved;
		public void OnNodeRemoved(TreeModelEventArgs args)
		{
			if (NodesRemoved != null)
				NodesRemoved(this, args);
		}

		#endregion
	}
}

```

`Aga.Controls/Tree/TreeModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections.ObjectModel;

namespace Aga.Controls.Tree
{
	/// <summary>
	/// Provides a simple ready to use implementation of <see cref="ITreeModel"/>. Warning: this class is not optimized 
	/// to work with big amount of data. In this case create you own implementation of <c>ITreeModel</c>, and pay attention
	/// on GetChildren and IsLeaf methods.
	/// </summary>
	public class TreeModel : ITreeModel
	{
		private Node _root;
		public Node Root
		{
			get { return _root; }
		}

		public Collection<Node> Nodes
		{
			get { return _root.Nodes; }
		}

		public TreeModel()
		{
			_root = new Node();
			_root.Model = this;
		}

		public TreePath GetPath(Node node)
		{
			if (node == _root)
				return TreePath.Empty;
			else
			{
				Stack<object> stack = new Stack<object>();
				while (node != _root)
				{
					stack.Push(node);
					node = node.Parent;
				}
				return new TreePath(stack.ToArray());
			}
		}

		public Node FindNode(TreePath path)
		{
			if (path.IsEmpty())
				return _root;
			else
				return FindNode(_root, path, 0);
		}

		private Node FindNode(Node root, TreePath path, int level)
		{
			foreach (Node node in root.Nodes)
				if (node == path.FullPath[level])
				{
					if (level == path.FullPath.Length - 1)
						return node;
					else
						return FindNode(node, path, level + 1);
				}
			return null;
		}

		#region ITreeModel Members

		public System.Collections.IEnumerable GetChildren(TreePath treePath)
		{
			Node node = FindNode(treePath);
			if (node != null)
				foreach (Node n in node.Nodes)
					yield return n;
			else
				yield break;
		}

		public bool IsLeaf(TreePath treePath)
		{
			Node node = FindNode(treePath);
			if (node != null)
				return node.IsLeaf;
			else
				throw new ArgumentException("treePath");
		}

		public event EventHandler<TreeModelEventArgs> NodesChanged;
		internal void OnNodesChanged(TreeModelEventArgs args)
		{
			if (NodesChanged != null)
				NodesChanged(this, args);
		}

		public event EventHandler<TreePathEventArgs> StructureChanged;
		public void OnStructureChanged(TreePathEventArgs args)
		{
			if (StructureChanged != null)
				StructureChanged(this, args);
		}

		public event EventHandler<TreeModelEventArgs> NodesInserted;
		internal void OnNodeInserted(Node parent, int index, Node node)
		{
			if (NodesInserted != null)
			{
				TreeModelEventArgs args = new TreeModelEventArgs(GetPath(parent), new int[] { index }, new object[] { node });
				NodesInserted(this, args);
			}

		}

		public event EventHandler<TreeModelEventArgs> NodesRemoved;
		internal void OnNodeRemoved(Node parent, int index, Node node)
		{
			if (NodesRemoved != null)
			{
				TreeModelEventArgs args = new TreeModelEventArgs(GetPath(parent), new int[] { index }, new object[] { node });
				NodesRemoved(this, args);
			}
		}

		#endregion
	}
}

```

`Aga.Controls/Tree/TreeModelBase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public abstract class TreeModelBase: ITreeModel
	{
		public abstract System.Collections.IEnumerable GetChildren(TreePath treePath);
		public abstract bool IsLeaf(TreePath treePath);


		public event EventHandler<TreeModelEventArgs> NodesChanged;
		protected void OnNodesChanged(TreeModelEventArgs args)
		{
			if (NodesChanged != null)
				NodesChanged(this, args);
		}

		public event EventHandler<TreePathEventArgs> StructureChanged;
		protected void OnStructureChanged(TreePathEventArgs args)
		{
			if (StructureChanged != null)
				StructureChanged(this, args);
		}

		public event EventHandler<TreeModelEventArgs> NodesInserted;
		protected void OnNodesInserted(TreeModelEventArgs args)
		{
			if (NodesInserted != null)
				NodesInserted(this, args);
		}

		public event EventHandler<TreeModelEventArgs> NodesRemoved;
		protected void OnNodesRemoved(TreeModelEventArgs args)
		{
			if (NodesRemoved != null)
				NodesRemoved(this, args);
		}

		public virtual void Refresh()
		{
			OnStructureChanged(new TreePathEventArgs(TreePath.Empty));
		}
	}
}

```

`Aga.Controls/Tree/TreeModelEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public class TreeModelEventArgs: TreePathEventArgs
	{
		private object[] _children;
		public object[] Children
		{
			get { return _children; }
		}

		private int[] _indices;
		public int[] Indices
		{
			get { return _indices; }
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="parent">Path to a parent node</param>
		/// <param name="children">Child nodes</param>
		public TreeModelEventArgs(TreePath parent, object[] children)
			: this(parent, null, children)
		{
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="parent">Path to a parent node</param>
		/// <param name="indices">Indices of children in parent nodes collection</param>
		/// <param name="children">Child nodes</param>
		public TreeModelEventArgs(TreePath parent, int[] indices, object[] children)
			: base(parent)
		{
			if (children == null)
				throw new ArgumentNullException();

			if (indices != null && indices.Length != children.Length)
				throw new ArgumentException("indices and children arrays must have the same length");

			_indices = indices;
			_children = children;
		}
	}
}

```

`Aga.Controls/Tree/TreeNodeAdv.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using System.Security.Permissions;

namespace Aga.Controls.Tree
{
	[Serializable]
	public sealed class TreeNodeAdv : ISerializable
	{
		#region NodeCollection
		private class NodeCollection : Collection<TreeNodeAdv>
		{
			private TreeNodeAdv _owner;

			public NodeCollection(TreeNodeAdv owner)
			{
				_owner = owner;
			}

			protected override void ClearItems()
			{
				while (this.Count != 0)
					this.RemoveAt(this.Count - 1);
			}

			protected override void InsertItem(int index, TreeNodeAdv item)
			{
				if (item == null)
					throw new ArgumentNullException("item");

				if (item.Parent != _owner)
				{
					if (item.Parent != null)
						item.Parent.Nodes.Remove(item);
					item._parent = _owner;
					item._index = index;
					for (int i = index; i < Count; i++)
						this[i]._index++;
					base.InsertItem(index, item);
				}

				if (_owner.Tree != null && _owner.Tree.Model == null)
				{
					_owner.Tree.SmartFullUpdate();
				}
			}

			protected override void RemoveItem(int index)
			{
				TreeNodeAdv item = this[index];
				item._parent = null;
				item._index = -1;
				for (int i = index + 1; i < Count; i++)
					this[i]._index--;
				base.RemoveItem(index);

				if (_owner.Tree != null && _owner.Tree.Model == null)
				{
					_owner.Tree.UpdateSelection();
					_owner.Tree.SmartFullUpdate();
				}
			}

			protected override void SetItem(int index, TreeNodeAdv item)
			{
				if (item == null)
					throw new ArgumentNullException("item");
				RemoveAt(index);
				InsertItem(index, item);
			}
		}
		#endregion

		#region Events

		public event EventHandler<TreeViewAdvEventArgs> Collapsing;
		internal void OnCollapsing()
		{
			if (Collapsing != null)
				Collapsing(this, new TreeViewAdvEventArgs(this));
		}

		public event EventHandler<TreeViewAdvEventArgs> Collapsed;
		internal void OnCollapsed()
		{
			if (Collapsed != null)
				Collapsed(this, new TreeViewAdvEventArgs(this));
		}

		public event EventHandler<TreeViewAdvEventArgs> Expanding;
		internal void OnExpanding()
		{
			if (Expanding != null)
				Expanding(this, new TreeViewAdvEventArgs(this));
		}

		public event EventHandler<TreeViewAdvEventArgs> Expanded;
		internal void OnExpanded()
		{
			if (Expanded != null)
				Expanded(this, new TreeViewAdvEventArgs(this));
		}

		#endregion

		#region Properties

		private TreeViewAdv _tree;
		public TreeViewAdv Tree
		{
			get { return _tree; }
		}

		private int _row;
		public int Row
		{
			get { return _row; }
			internal set { _row = value; }
		}

		private int _index = -1;
		public int Index
		{
			get
			{
				return _index;
			}
		}

		private bool _isSelected;
		public bool IsSelected
		{
			get { return _isSelected; }
			set
			{
				if (_isSelected != value)
				{
					if (Tree.IsMyNode(this))
					{
						//_tree.OnSelectionChanging
						if (value)
						{
							if (!_tree.Selection.Contains(this))
								_tree.Selection.Add(this);

							if (_tree.Selection.Count == 1)
								_tree.CurrentNode = this;
						}
						else
							_tree.Selection.Remove(this);
						_tree.UpdateView();
						_tree.OnSelectionChanged();
					}
					_isSelected = value;
				}
			}
		}

		/// <summary>
		/// Returns true if all parent nodes of this node are expanded.
		/// </summary>
		internal bool IsVisible
		{
			get
			{
				TreeNodeAdv node = _parent;
				while (node != null)
				{
					if (!node.IsExpanded)
						return false;
					node = node.Parent;
				}
				return true;
			}
		}

		private bool _isLeaf;
		public bool IsLeaf
		{
			get { return _isLeaf; }
			internal set { _isLeaf = value; }
		}

		private bool _isExpandedOnce;
		public bool IsExpandedOnce
		{
			get { return _isExpandedOnce; }
			internal set { _isExpandedOnce = value; }
		}

		private bool _isExpanded;
		public bool IsExpanded
		{
			get { return _isExpanded; }
			set
			{
				if (value)
					Expand();
				else
					Collapse();
			}
		}

		internal void AssignIsExpanded(bool value)
		{
			_isExpanded = value;
		}

		private TreeNodeAdv _parent;
		public TreeNodeAdv Parent
		{
			get { return _parent; }
		}

		public int Level
		{
			get
			{
				if (_parent == null)
					return 0;
				else
					return _parent.Level + 1;
			}
		}

		public TreeNodeAdv PreviousNode
		{
			get
			{
				if (_parent != null)
				{
					int index = Index;
					if (index > 0)
						return _parent.Nodes[index - 1];
				}
				return null;
			}
		}

		public TreeNodeAdv NextNode
		{
			get
			{
				if (_parent != null)
				{
					int index = Index;
					if (index < _parent.Nodes.Count - 1)
						return _parent.Nodes[index + 1];
				}
				return null;
			}
		}

		internal TreeNodeAdv BottomNode
		{
			get
			{
				TreeNodeAdv parent = this.Parent;
				if (parent != null)
				{
					if (parent.NextNode != null)
						return parent.NextNode;
					else
						return parent.BottomNode;
				}
				return null;
			}
		}

		internal TreeNodeAdv NextVisibleNode
		{
			get
			{
				if (IsExpanded && Nodes.Count > 0)
					return Nodes[0];
				else
				{
					TreeNodeAdv nn = NextNode;
					if (nn != null)
						return nn;
					else
						return BottomNode;
				}
			}
		}

		public bool CanExpand
		{
			get
			{
				return (Nodes.Count > 0 || (!IsExpandedOnce && !IsLeaf));
			}
		}

		private object _tag;
		public object Tag
		{
			get { return _tag; }
		}

		private Collection<TreeNodeAdv> _nodes;
		internal Collection<TreeNodeAdv> Nodes
		{
			get { return _nodes; }
		}

		private ReadOnlyCollection<TreeNodeAdv> _children;
		public ReadOnlyCollection<TreeNodeAdv> Children
		{
			get
			{
				return _children;
			}
		}

		private int? _rightBounds;
		internal int? RightBounds
		{
			get { return _rightBounds; }
			set { _rightBounds = value; }
		}

		private int? _height;
		internal int? Height
		{
			get { return _height; }
			set { _height = value; }
		}

		private bool _isExpandingNow;
		internal bool IsExpandingNow
		{
			get { return _isExpandingNow; }
			set { _isExpandingNow = value; }
		}

		private bool _autoExpandOnStructureChanged = true;
		public bool AutoExpandOnStructureChanged
		{
			get { return _autoExpandOnStructureChanged; }
			set { _autoExpandOnStructureChanged = value; }
		}

		#endregion

		public TreeNodeAdv(object tag)
			: this(null, tag)
		{
		}

		internal TreeNodeAdv(TreeViewAdv tree, object tag)
		{
			_row = -1;
			_tree = tree;
			_nodes = new NodeCollection(this);
			_children = new ReadOnlyCollection<TreeNodeAdv>(_nodes);
			_tag = tag;
		}

		public override string ToString()
		{
			if (Tag != null)
				return Tag.ToString();
			else
				return base.ToString();
		}

		public void Collapse()
		{
			if (_isExpanded)
				Collapse(true);
		}

		public void CollapseAll()
		{
			Collapse(false);
		}

		public void Collapse(bool ignoreChildren)
		{
			SetIsExpanded(false, ignoreChildren);
		}

		public void Expand()
		{
			if (!_isExpanded)
				Expand(true);
		}

		public void ExpandAll()
		{
			Expand(false);
		}

		public void Expand(bool ignoreChildren)
		{
			SetIsExpanded(true, ignoreChildren);
		}

		private void SetIsExpanded(bool value, bool ignoreChildren)
		{
			if (Tree == null)
				_isExpanded = value;
			else
				Tree.SetIsExpanded(this, value, ignoreChildren);
		}

		#region ISerializable Members

		private TreeNodeAdv(SerializationInfo info, StreamingContext context)
			: this(null, null)
		{
			int nodesCount = 0;
			nodesCount = info.GetInt32("NodesCount");
			_isExpanded = info.GetBoolean("IsExpanded");
			_tag = info.GetValue("Tag", typeof(object));

			for (int i = 0; i < nodesCount; i++)
			{
				TreeNodeAdv child = (TreeNodeAdv)info.GetValue("Child" + i, typeof(TreeNodeAdv));
				Nodes.Add(child);
			}

		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			info.AddValue("IsExpanded", IsExpanded);
			info.AddValue("NodesCount", Nodes.Count);
			if ((Tag != null) && Tag.GetType().IsSerializable)
				info.AddValue("Tag", Tag, Tag.GetType());

			for (int i = 0; i < Nodes.Count; i++)
				info.AddValue("Child" + i, Nodes[i], typeof(TreeNodeAdv));

		}

		#endregion
	}
}

```

`Aga.Controls/Tree/TreeNodeAdvMouseEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public class TreeNodeAdvMouseEventArgs : MouseEventArgs
	{
		private TreeNodeAdv _node;
		public TreeNodeAdv Node
		{
			get { return _node; }
			internal set { _node = value; }
		}

		private NodeControl _control;
		public NodeControl Control
		{
			get { return _control; }
			internal set { _control = value; }
		}

		private Point _viewLocation;
		public Point ViewLocation
		{
			get { return _viewLocation; }
			internal set { _viewLocation = value; }
		}

		private Keys _modifierKeys;
		public Keys ModifierKeys
		{
			get { return _modifierKeys; }
			internal set { _modifierKeys = value; }
		}

		private bool _handled;
		public bool Handled
		{
			get { return _handled; }
			set { _handled = value; }
		}

		private Rectangle _controlBounds;
		public Rectangle ControlBounds
		{
			get { return _controlBounds; }
			internal set { _controlBounds = value; }
		}

		public TreeNodeAdvMouseEventArgs(MouseEventArgs args)
			: base(args.Button, args.Clicks, args.X, args.Y, args.Delta)
		{
		}
	}
}

```

`Aga.Controls/Tree/TreePath.cs`:

```cs
using System;
using System.Text;
using System.Collections.ObjectModel;

namespace Aga.Controls.Tree
{
	public class TreePath
	{
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
		public static readonly TreePath Empty = new TreePath();

		private object[] _path;
		public object[] FullPath
		{
			get { return _path; }
		}

		public object LastNode
		{
			get
			{
				if (_path.Length > 0)
					return _path[_path.Length - 1];
				else
					return null;
			}
		}

		public object FirstNode
		{
			get
			{
				if (_path.Length > 0)
					return _path[0];
				else
					return null;
			}
		}

		public TreePath()
		{
			_path = new object[0];
		}

		public TreePath(object node)
		{
			_path = new object[] { node };
		}

		public TreePath(object[] path)
		{
			_path = path;
		}

		public TreePath(TreePath parent, object node)
		{
			_path = new object[parent.FullPath.Length + 1];
			for (int i = 0; i < _path.Length - 1; i++)
				_path[i] = parent.FullPath[i];
			_path[_path.Length - 1] = node;
		}

		public bool IsEmpty()
		{
			return (_path.Length == 0);
		}
	}
}

```

`Aga.Controls/Tree/TreePathEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public class TreePathEventArgs : EventArgs
	{
		private TreePath _path;
		public TreePath Path
		{
			get { return _path; }
		}

		public TreePathEventArgs()
		{
			_path = new TreePath();
		}

		public TreePathEventArgs(TreePath path)
		{
			if (path == null)
				throw new ArgumentNullException();

			_path = path;
		}
	}
}

```

`Aga.Controls/Tree/TreeViewAdv.Designer.cs`:

```cs
using System.Windows.Forms;

namespace Aga.Controls.Tree
{
	partial class TreeViewAdv
	{
		private System.ComponentModel.IContainer components = null;

		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
				if (_dragBitmap != null) _dragBitmap.Dispose();
				if (_dragTimer != null) _dragTimer.Dispose();
				if (_linePen != null) _linePen.Dispose();
				if (_markPen != null) _markPen.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Component Designer generated code
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this._vScrollBar = new System.Windows.Forms.VScrollBar();
			this._hScrollBar = new System.Windows.Forms.HScrollBar();
			this._errorProvider = new System.Windows.Forms.ErrorProvider(this.components);
			((System.ComponentModel.ISupportInitialize)(this._errorProvider)).BeginInit();
			this.SuspendLayout();
			// 
			// _vScrollBar
			// 
			this._vScrollBar.LargeChange = 1;
			this._vScrollBar.Location = new System.Drawing.Point(0, 0);
			this._vScrollBar.Maximum = 0;
			this._vScrollBar.Name = "_vScrollBar";
			this._vScrollBar.Size = new System.Drawing.Size(13, 80);
			this._vScrollBar.TabIndex = 1;
			this._vScrollBar.ValueChanged += new System.EventHandler(this._vScrollBar_ValueChanged);
			this._vScrollBar.Scroll += new System.Windows.Forms.ScrollEventHandler(this._vScrollBar_Scroll);
			// 
			// _hScrollBar
			// 
			this._hScrollBar.LargeChange = 1;
			this._hScrollBar.Location = new System.Drawing.Point(0, 0);
			this._hScrollBar.Maximum = 0;
			this._hScrollBar.Name = "_hScrollBar";
			this._hScrollBar.Size = new System.Drawing.Size(80, 13);
			this._hScrollBar.TabIndex = 2;
			this._hScrollBar.ValueChanged += new System.EventHandler(this._hScrollBar_ValueChanged);
			this._hScrollBar.Scroll += new System.Windows.Forms.ScrollEventHandler(this._hScrollBar_Scroll);
			// 
			// TreeViewAdv
			// 
			this.BackColor = System.Drawing.SystemColors.Window;
			this.Controls.Add(this._vScrollBar);
			this.Controls.Add(this._hScrollBar);
			((System.ComponentModel.ISupportInitialize)(this._errorProvider)).EndInit();
			this.ResumeLayout(false);

		}
		#endregion

		private VScrollBar _vScrollBar;
		private HScrollBar _hScrollBar;
		private ErrorProvider _errorProvider;
	}
}

```

`Aga.Controls/Tree/TreeViewAdv.Draw.cs`:

```cs
using System;
using System.Drawing;
using System.Diagnostics;
using System.Drawing.Drawing2D;
using System.Windows.Forms;
using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public partial class TreeViewAdv
	{
		public void AutoSizeColumn(TreeColumn column)
		{
			if (!Columns.Contains(column))
				throw new ArgumentException("column");

			DrawContext context = new DrawContext();
			context.Graphics = Graphics.FromImage(new Bitmap(1, 1));
			context.Font = this.Font;
			int res = 0;
			for (int row = 0; row < RowCount; row++)
			{
				if (row < RowMap.Count)
				{
					int w = 0;
					TreeNodeAdv node = RowMap[row];
					foreach (NodeControl nc in NodeControls)
					{
						if (nc.ParentColumn == column)
							w += nc.GetActualSize(node, _measureContext).Width;
					}
					res = Math.Max(res, w);
				}
			}

			if (res > 0)
				column.Width = res;
		}

		private void CreatePens()
		{
			CreateLinePen();
			CreateMarkPen();
		}

		private void CreateMarkPen()
		{
			GraphicsPath path = new GraphicsPath();
			path.AddLines(new Point[] { new Point(0, 0), new Point(1, 1), new Point(-1, 1), new Point(0, 0) });
			CustomLineCap cap = new CustomLineCap(null, path);
			cap.WidthScale = 1.0f;

			_markPen = new Pen(_dragDropMarkColor, _dragDropMarkWidth);
			_markPen.CustomStartCap = cap;
			_markPen.CustomEndCap = cap;
		}

		private void CreateLinePen()
		{
			_linePen = new Pen(_lineColor);
			_linePen.DashStyle = DashStyle.Dot;
		}

        protected override void OnPaint(PaintEventArgs e)
        {
            BeginPerformanceCount();
			PerformanceAnalyzer.Start("OnPaint");

            DrawContext context = new DrawContext();
            context.Graphics = e.Graphics;
            context.Font = this.Font;
            context.Enabled = Enabled;

            int y = 0;
            int gridHeight = 0;

            if (UseColumns)
            {
				DrawColumnHeaders(e.Graphics);
				y += ColumnHeaderHeight;
                if (Columns.Count == 0 || e.ClipRectangle.Height <= y)
                    return;
            }

			int firstRowY = _rowLayout.GetRowBounds(FirstVisibleRow).Y;
            y -= firstRowY;

            e.Graphics.ResetTransform();
            e.Graphics.TranslateTransform(-OffsetX, y);
            Rectangle displayRect = DisplayRectangle;
            for (int row = FirstVisibleRow; row < RowCount; row++)
            {
                Rectangle rowRect = _rowLayout.GetRowBounds(row);
                gridHeight += rowRect.Height;
                if (rowRect.Y + y > displayRect.Bottom)
                    break;
                else
                    DrawRow(e, ref context, row, rowRect);
            }

			if ((GridLineStyle & GridLineStyle.Vertical) == GridLineStyle.Vertical && UseColumns)
				DrawVerticalGridLines(e.Graphics, firstRowY);

			if (_dropPosition.Node != null && DragMode && HighlightDropPosition)
                DrawDropMark(e.Graphics);

            e.Graphics.ResetTransform();
            DrawScrollBarsBox(e.Graphics);

            if (DragMode && _dragBitmap != null)
                e.Graphics.DrawImage(_dragBitmap, PointToClient(MousePosition));

			PerformanceAnalyzer.Finish("OnPaint");
			EndPerformanceCount(e);
        }

		private void DrawRow(PaintEventArgs e, ref DrawContext context, int row, Rectangle rowRect)
		{
			TreeNodeAdv node = RowMap[row];
			context.DrawSelection = DrawSelectionMode.None;
			context.CurrentEditorOwner = CurrentEditorOwner;
			if (DragMode)
			{
				if ((_dropPosition.Node == node) && _dropPosition.Position == NodePosition.Inside && HighlightDropPosition)
					context.DrawSelection = DrawSelectionMode.Active;
			}
			else
			{
				if (node.IsSelected && Focused)
					context.DrawSelection = DrawSelectionMode.Active;
				else if (node.IsSelected && !Focused && !HideSelection)
					context.DrawSelection = DrawSelectionMode.Inactive;
			}
			context.DrawFocus = Focused && CurrentNode == node;
			
			OnRowDraw(e, node, context, row, rowRect);

			if ((GridLineStyle & GridLineStyle.Horizontal) == GridLineStyle.Horizontal) {
				e.Graphics.DrawLine(LightGrayPen, 0, rowRect.Bottom, e.Graphics.ClipBounds.Right, rowRect.Bottom);
      }

			if (FullRowSelect)
			{
				context.DrawFocus = false;
				if (context.DrawSelection == DrawSelectionMode.Active || context.DrawSelection == DrawSelectionMode.Inactive)
				{
					Rectangle focusRect = new Rectangle(OffsetX, rowRect.Y, ClientRectangle.Width, rowRect.Height);
					if (context.DrawSelection == DrawSelectionMode.Active)
					{
						e.Graphics.FillRectangle(GrayBrush, focusRect);
						context.DrawSelection = DrawSelectionMode.FullRowSelect;
					}
					else
					{
						e.Graphics.FillRectangle(GrayBrush, focusRect);
						context.DrawSelection = DrawSelectionMode.None;
					}
				}
			}

			if (ShowLines)
				DrawLines(e.Graphics, node, rowRect);

			DrawNode(node, context);
		}

		private Brush GrayBrush = new SolidBrush(Color.FromArgb(240, 240, 240));
		private Pen LightGrayPen = new Pen(Color.FromArgb(247, 247, 247));

		private void DrawVerticalGridLines(Graphics gr, int y)
		{
			int x = 0;
			foreach (TreeColumn c in Columns)
			{
				if (c.IsVisible)
				{
					x += c.Width;
					gr.DrawLine(SystemPens.InactiveBorder, x - 1, y, x - 1, gr.ClipBounds.Bottom);
				}
			}
		}

		private void DrawColumnHeaders(Graphics gr)
		{
			PerformanceAnalyzer.Start("DrawColumnHeaders");
			ReorderColumnState reorder = Input as ReorderColumnState;
			int x = 0;
			TreeColumn.DrawBackground(gr, new Rectangle(0, 0, ClientRectangle.Width + 2, ColumnHeaderHeight - 1), false, false);
			gr.TranslateTransform(-OffsetX, 0);
			foreach (TreeColumn c in Columns)
			{
				if (c.IsVisible)
				{
					if (x >= OffsetX && x - OffsetX < this.Bounds.Width)// skip invisible columns
					{
						Rectangle rect = new Rectangle(x, 0, c.Width, ColumnHeaderHeight - 1);
						gr.SetClip(rect);
						bool pressed = ((Input is ClickColumnState || reorder != null) && ((Input as ColumnState).Column == c));
						c.Draw(gr, rect, Font, pressed, _hotColumn == c);
						gr.ResetClip();

						if (reorder != null && reorder.DropColumn == c)
							TreeColumn.DrawDropMark(gr, rect);
					}
					x += c.Width;
				}
			}

			if (reorder != null)
			{
				if (reorder.DropColumn == null)
					TreeColumn.DrawDropMark(gr, new Rectangle(x, 0, 0, ColumnHeaderHeight));
				gr.DrawImage(reorder.GhostImage, new Point(reorder.Location.X +  + reorder.DragOffset, reorder.Location.Y));
			}
			PerformanceAnalyzer.Finish("DrawColumnHeaders");
		}

		public void DrawNode(TreeNodeAdv node, DrawContext context)
		{
			foreach (NodeControlInfo item in GetNodeControls(node))
			{
				if (item.Bounds.Right >= OffsetX && item.Bounds.X - OffsetX < this.Bounds.Width)// skip invisible nodes
				{
					context.Bounds = item.Bounds;
					context.Graphics.SetClip(context.Bounds);
					item.Control.Draw(node, context);
					context.Graphics.ResetClip();
				}
			}
		}

		private void DrawScrollBarsBox(Graphics gr)
		{
			Rectangle r1 = DisplayRectangle;
			Rectangle r2 = ClientRectangle;
			gr.FillRectangle(SystemBrushes.Control,
				new Rectangle(r1.Right, r1.Bottom, r2.Width - r1.Width, r2.Height - r1.Height));
		}

		private void DrawDropMark(Graphics gr)
		{
			if (_dropPosition.Position == NodePosition.Inside)
				return;

			Rectangle rect = GetNodeBounds(_dropPosition.Node);
			int right = DisplayRectangle.Right - LeftMargin + OffsetX;
			int y = rect.Y;
			if (_dropPosition.Position == NodePosition.After)
				y = rect.Bottom;
			gr.DrawLine(_markPen, rect.X, y, right, y);
		}

		private void DrawLines(Graphics gr, TreeNodeAdv node, Rectangle rowRect)
		{
			if (UseColumns && Columns.Count > 0)
				gr.SetClip(new Rectangle(0, rowRect.Y, Columns[0].Width, rowRect.Bottom));

			TreeNodeAdv curNode = node;
			while (curNode != _root && curNode != null)
			{
				int level = curNode.Level;
				int scaledIndent = node.Tree.GetScaledSize(_indent, false);
				int x = (level - 1) * scaledIndent + NodePlusMinus.ImageSize / 2 + LeftMargin;
				int width = node.Tree.GetScaledSize(NodePlusMinus.Width - NodePlusMinus.ImageSize / 2, false);
				int y = rowRect.Y;
				int y2 = y + rowRect.Height;

				if (curNode == node)
				{
					int midy = y + rowRect.Height / 2;
					gr.DrawLine(_linePen, x, midy, x + width, midy);
					if (curNode.NextNode == null)
						y2 = y + rowRect.Height / 2;
				}

				if (node.Row == 0)
					y = rowRect.Height / 2;
				if (curNode.NextNode != null || curNode == node)
					gr.DrawLine(_linePen, x, y, x, y2);

				curNode = curNode.Parent;
			}

			gr.ResetClip();
		}

		#region Performance

		private double _totalTime;
		private int _paintCount;

		[Conditional("PERF_TEST")]
		private void BeginPerformanceCount()
		{
			_paintCount++;
			TimeCounter.Start();
		}

		[Conditional("PERF_TEST")]
		private void EndPerformanceCount(PaintEventArgs e)
		{
			double time = TimeCounter.Finish();
			_totalTime += time;
			string debugText = string.Format("FPS {0:0.0}; Avg. FPS {1:0.0}",
				1 / time, 1 / (_totalTime / _paintCount));
			e.Graphics.FillRectangle(Brushes.White, new Rectangle(DisplayRectangle.Width - 150, DisplayRectangle.Height - 20, 150, 20));
			e.Graphics.DrawString(debugText, Control.DefaultFont, Brushes.Gray,
				new PointF(DisplayRectangle.Width - 150, DisplayRectangle.Height - 20));
		}
		#endregion

	}
}

```

`Aga.Controls/Tree/TreeViewAdv.Editor.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using Aga.Controls.Tree.NodeControls;
using System.Drawing;

namespace Aga.Controls.Tree
{
	partial class TreeViewAdv
	{
		private TreeNodeAdv _editingNode;

		public EditableControl CurrentEditorOwner { get; private set; }
		public Control CurrentEditor { get; private set; }

		public void HideEditor()
		{
			if (CurrentEditorOwner != null)
				CurrentEditorOwner.EndEdit(false);
		}

		internal void DisplayEditor(Control editor, EditableControl owner)
		{
			if (editor == null || owner == null || CurrentNode == null)
				throw new ArgumentNullException();

			HideEditor(false);

			CurrentEditor = editor;
			CurrentEditorOwner = owner;
			_editingNode = CurrentNode;

			editor.Validating += EditorValidating;
			UpdateEditorBounds();
			UpdateView();
			editor.Parent = this;
			editor.Focus();
			owner.UpdateEditor(editor);
		}

		internal bool HideEditor(bool applyChanges)
		{
			if (CurrentEditor != null)
			{
				if (applyChanges)
				{
					if (!ApplyChanges())
						return false;
				}

				//Check once more if editor was closed in ApplyChanges
				if (CurrentEditor != null)
				{
					CurrentEditor.Validating -= EditorValidating;
					CurrentEditorOwner.DoDisposeEditor(CurrentEditor);

					CurrentEditor.Parent = null;
					CurrentEditor.Dispose();

					CurrentEditor = null;
					CurrentEditorOwner = null;
					_editingNode = null;
				}
			}
			return true;
		}

		private bool ApplyChanges()
		{
			try
			{
				CurrentEditorOwner.ApplyChanges(_editingNode, CurrentEditor);
				_errorProvider.Clear();
				return true;
			}
			catch (ArgumentException ex)
			{
				_errorProvider.SetError(CurrentEditor, ex.Message);
				/*CurrentEditor.Validating -= EditorValidating;
				MessageBox.Show(this, ex.Message, "Value is not valid", MessageBoxButtons.OK, MessageBoxIcon.Warning);
				CurrentEditor.Focus();
				CurrentEditor.Validating += EditorValidating;*/
				return false;
			}
		}

		void EditorValidating(object sender, System.ComponentModel.CancelEventArgs e)
		{
			e.Cancel = !ApplyChanges();
		}

		public void UpdateEditorBounds()
		{
			if (CurrentEditor != null)
			{
				EditorContext context = new EditorContext();
				context.Owner = CurrentEditorOwner;
				context.CurrentNode = CurrentNode;
				context.Editor = CurrentEditor;
				context.DrawContext = _measureContext;
				SetEditorBounds(context);
			}
		}

		private void SetEditorBounds(EditorContext context)
		{
			foreach (NodeControlInfo info in GetNodeControls(context.CurrentNode))
			{
				if (context.Owner == info.Control && info.Control is EditableControl)
				{
					Point p = info.Bounds.Location;
					p.X += info.Control.LeftMargin;
					p.X -= OffsetX;
					p.Y -= (_rowLayout.GetRowBounds(FirstVisibleRow).Y - ColumnHeaderHeight);
					int width = DisplayRectangle.Width - p.X;
					if (UseColumns && info.Control.ParentColumn != null && Columns.Contains(info.Control.ParentColumn))
					{
						Rectangle rect = GetColumnBounds(info.Control.ParentColumn.Index);
						width = rect.Right - OffsetX - p.X;
					}
					context.Bounds = new Rectangle(p.X, p.Y, width, info.Bounds.Height);
					((EditableControl)info.Control).SetEditorBounds(context);
					return;
				}
			}
		}

		private Rectangle GetColumnBounds(int column)
		{
			int x = 0;
			for (int i = 0; i < Columns.Count; i++)
			{
				if (Columns[i].IsVisible)
				{
					if (i < column)
						x += Columns[i].Width;
					else
						return new Rectangle(x, 0, Columns[i].Width, 0);
				}
			}
			return Rectangle.Empty;
		}
	}
}

```

`Aga.Controls/Tree/TreeViewAdv.Input.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using Aga.Controls.Tree.NodeControls;
using System.Drawing.Imaging;
using System.Threading;

namespace Aga.Controls.Tree
{
	public partial class TreeViewAdv
	{
		#region Keys

		protected override bool IsInputChar(char charCode)
		{
			return true;
		}

		protected override bool IsInputKey(Keys keyData)
		{
			if (((keyData & Keys.Up) == Keys.Up)
				|| ((keyData & Keys.Down) == Keys.Down)
				|| ((keyData & Keys.Left) == Keys.Left)
				|| ((keyData & Keys.Right) == Keys.Right))
				return true;
			else
				return base.IsInputKey(keyData);
		}

		internal void ChangeInput()
		{
			if ((ModifierKeys & Keys.Shift) == Keys.Shift)
			{
				if (!(Input is InputWithShift))
					Input = new InputWithShift(this);
			}
			else if ((ModifierKeys & Keys.Control) == Keys.Control)
			{
				if (!(Input is InputWithControl))
					Input = new InputWithControl(this);
			}
			else
			{
				if (!(Input.GetType() == typeof(NormalInputState)))
					Input = new NormalInputState(this);
			}
		}

		protected override void OnKeyDown(KeyEventArgs e)
		{
			base.OnKeyDown(e);
			if (!e.Handled)
			{
				if (e.KeyCode == Keys.ShiftKey || e.KeyCode == Keys.ControlKey)
					ChangeInput();
				Input.KeyDown(e);
				if (!e.Handled)
				{
					foreach (NodeControlInfo item in GetNodeControls(CurrentNode))
					{
						item.Control.KeyDown(e);
						if (e.Handled)
							break;
					}
				}
			}
		}

		protected override void OnKeyUp(KeyEventArgs e)
		{
			base.OnKeyUp(e);
			if (!e.Handled)
			{
				if (e.KeyCode == Keys.ShiftKey || e.KeyCode == Keys.ControlKey)
					ChangeInput();
				if (!e.Handled)
				{
					foreach (NodeControlInfo item in GetNodeControls(CurrentNode))
					{
						item.Control.KeyUp(e);
						if (e.Handled)
							return;
					}
				}
			}
		}

		protected override void OnKeyPress(KeyPressEventArgs e)
		{
			base.OnKeyPress(e);
			if (!e.Handled)
				_search.Search(e.KeyChar);
		}

		#endregion

		#region Mouse

		private TreeNodeAdvMouseEventArgs CreateMouseArgs(MouseEventArgs e)
		{
			TreeNodeAdvMouseEventArgs args = new TreeNodeAdvMouseEventArgs(e);
			args.ViewLocation = new Point(e.X + OffsetX,
				e.Y + _rowLayout.GetRowBounds(FirstVisibleRow).Y - ColumnHeaderHeight);
			args.ModifierKeys = ModifierKeys;
			args.Node = GetNodeAt(e.Location);
			NodeControlInfo info = GetNodeControlInfoAt(args.Node, e.Location);
			args.ControlBounds = info.Bounds;
			args.Control = info.Control;
			return args;
		}

		protected override void OnMouseWheel(MouseEventArgs e)
		{
			_search.EndSearch();
			if (SystemInformation.MouseWheelScrollLines > 0)
			{
				int lines = e.Delta / 120 * SystemInformation.MouseWheelScrollLines;
				int newValue = _vScrollBar.Value - lines;
				newValue = Math.Min(_vScrollBar.Maximum - _vScrollBar.LargeChange + 1, newValue);
				newValue = Math.Min(_vScrollBar.Maximum, newValue);
				_vScrollBar.Value = Math.Max(_vScrollBar.Minimum, newValue);
			}
			base.OnMouseWheel(e);
		}

		protected override void OnMouseDown(MouseEventArgs e)
		{
			if (CurrentEditorOwner != null)
			{
				CurrentEditorOwner.EndEdit(true);
				return;
			}

			if (!Focused)
				Focus();

			_search.EndSearch();
			if (e.Button == MouseButtons.Left)
			{
				TreeColumn c;
				c = GetColumnDividerAt(e.Location);
				if (c != null)
				{
					Input = new ResizeColumnState(this, c, e.Location);
					return;
				}
				c = GetColumnAt(e.Location);
				if (c != null)
				{
					Input = new ClickColumnState(this, c, e.Location);
					UpdateView();
					return;
				}
			}

			ChangeInput();
			TreeNodeAdvMouseEventArgs args = CreateMouseArgs(e);

			if (args.Node != null && args.Control != null)
				args.Control.MouseDown(args);

			if (!args.Handled)
				Input.MouseDown(args);

			base.OnMouseDown(e);
		}

		protected override void OnMouseClick(MouseEventArgs e)
		{
			//TODO: Disable when click on plusminus icon
			TreeNodeAdvMouseEventArgs args = CreateMouseArgs(e);
			if (args.Node != null)
				OnNodeMouseClick(args);

			base.OnMouseClick(e);
		}

		protected override void OnMouseDoubleClick(MouseEventArgs e)
		{
			TreeNodeAdvMouseEventArgs args = CreateMouseArgs(e);

			if (args.Node != null && args.Control != null)
				args.Control.MouseDoubleClick(args);

			if (!args.Handled)
			{
				if (args.Node != null)
					OnNodeMouseDoubleClick(args);
				else
					Input.MouseDoubleClick(args);

				if (!args.Handled)
				{
					if (args.Node != null && args.Button == MouseButtons.Left)
						args.Node.IsExpanded = !args.Node.IsExpanded;
				}
			}

			base.OnMouseDoubleClick(e);
		}

		protected override void OnMouseUp(MouseEventArgs e)
		{
			TreeNodeAdvMouseEventArgs args = CreateMouseArgs(e);
			if (Input is ResizeColumnState)
				Input.MouseUp(args);
			else
			{
				if (args.Node != null && args.Control != null)
					args.Control.MouseUp(args);
				if (!args.Handled)
					Input.MouseUp(args);

				base.OnMouseUp(e);
			}
		}

		protected override void OnMouseMove(MouseEventArgs e)
		{
			if (Input.MouseMove(e))
				return;

			base.OnMouseMove(e);
			SetCursor(e);
			UpdateToolTip(e);
			if (ItemDragMode && Dist(e.Location, ItemDragStart) > ItemDragSensivity
				&& CurrentNode != null && CurrentNode.IsSelected)
			{
				ItemDragMode = false;
				_toolTip.Active = false;
				OnItemDrag(e.Button, Selection.ToArray());
			}
		}

		protected override void OnMouseLeave(EventArgs e)
		{
			_hotColumn = null;
			UpdateHeaders();
			base.OnMouseLeave(e);
		}

		private void SetCursor(MouseEventArgs e)
		{
			TreeColumn col;
			col = GetColumnDividerAt(e.Location);
			if (col == null)
				_innerCursor = null;
			else
			{
				if (col.Width == 0)
					_innerCursor = ResourceHelper.DVSplitCursor;
				else
					_innerCursor = Cursors.VSplit;
			}

			col = GetColumnAt(e.Location);
			if (col != _hotColumn)
			{
				_hotColumn = col;
				UpdateHeaders();
			}
		}

		internal TreeColumn GetColumnAt(Point p)
		{
			if (p.Y > ColumnHeaderHeight)
				return null;

			int x = -OffsetX;
			foreach (TreeColumn col in Columns)
			{
				if (col.IsVisible)
				{
					Rectangle rect = new Rectangle(x, 0, col.Width, ColumnHeaderHeight);
					x += col.Width;
					if (rect.Contains(p))
						return col;
				}
			}
			return null;
		}

		internal int GetColumnX(TreeColumn column)
		{
			int x = -OffsetX;
			foreach (TreeColumn col in Columns)
			{
				if (col.IsVisible)
				{
					if (column == col)
						return x;
					else
						x += col.Width;
				}
			}
			return x;
		}

		internal TreeColumn GetColumnDividerAt(Point p)
		{
			if (p.Y > ColumnHeaderHeight)
				return null;

			int x = -OffsetX;
			TreeColumn prevCol = null;
			Rectangle left, right;
			foreach (TreeColumn col in Columns)
			{
				if (col.IsVisible)
				{
					if (col.Width > 0)
					{
						left = new Rectangle(x, 0, DividerWidth / 2, ColumnHeaderHeight);
						right = new Rectangle(x + col.Width - (DividerWidth / 2), 0, DividerWidth / 2, ColumnHeaderHeight);
						if (left.Contains(p) && prevCol != null)
							return prevCol;
						else if (right.Contains(p))
							return col;
					}
					prevCol = col;
					x += col.Width;
				}
			}

			left = new Rectangle(x, 0, DividerWidth / 2, ColumnHeaderHeight);
			if (left.Contains(p) && prevCol != null)
				return prevCol;

			return null;
		}

		TreeColumn _tooltipColumn;
		private void UpdateToolTip(MouseEventArgs e)
		{
			TreeColumn col = GetColumnAt(e.Location);
			if (col != null)
			{
				if (col != _tooltipColumn)
					SetTooltip(col.TooltipText);
			}
			else
				DisplayNodesTooltip(e);
			_tooltipColumn = col;
		}

		TreeNodeAdv _hotNode;
		NodeControl _hotControl;
		private void DisplayNodesTooltip(MouseEventArgs e)
		{
			if (ShowNodeToolTips)
			{
				TreeNodeAdvMouseEventArgs args = CreateMouseArgs(e);
				if (args.Node != null && args.Control != null)
				{
					if (args.Node != _hotNode || args.Control != _hotControl)
						SetTooltip(GetNodeToolTip(args));
				}
				else
					_toolTip.SetToolTip(this, null);

				_hotControl = args.Control;
				_hotNode = args.Node;
			}
			else
				_toolTip.SetToolTip(this, null);
		}

		private void SetTooltip(string text)
		{
			if (!String.IsNullOrEmpty(text))
			{
				_toolTip.Active = false;
				_toolTip.SetToolTip(this, text);
				_toolTip.Active = true;
			}
			else
				_toolTip.SetToolTip(this, null);
		}

		private string GetNodeToolTip(TreeNodeAdvMouseEventArgs args)
		{
			string msg = args.Control.GetToolTip(args.Node);

			BaseTextControl btc = args.Control as BaseTextControl;
			if (btc != null && btc.DisplayHiddenContentInToolTip && String.IsNullOrEmpty(msg))
			{
				Size ms = btc.GetActualSize(args.Node, _measureContext);
				if (ms.Width > args.ControlBounds.Size.Width || ms.Height > args.ControlBounds.Size.Height
					|| args.ControlBounds.Right - OffsetX > DisplayRectangle.Width)
					msg = btc.GetLabel(args.Node);
			}

			if (String.IsNullOrEmpty(msg) && DefaultToolTipProvider != null)
				msg = DefaultToolTipProvider.GetToolTip(args.Node, args.Control);

			return msg;
		}

		#endregion

		#region DragDrop

		private bool _dragAutoScrollFlag = false;
		private Bitmap _dragBitmap = null;
		private System.Threading.Timer _dragTimer;

		private void StartDragTimer()
		{
			if (_dragTimer == null)
				_dragTimer = new System.Threading.Timer(new TimerCallback(DragTimerTick), null, 0, 100);
		}

		private void StopDragTimer()
		{
			if (_dragTimer != null)
			{
				_dragTimer.Dispose();
				_dragTimer = null;
			}
		}

		private void SetDropPosition(Point pt)
		{
			TreeNodeAdv node = GetNodeAt(pt);
			OnDropNodeValidating(pt, ref node);
			_dropPosition.Node = node;
			if (node != null)
			{
				Rectangle first = _rowLayout.GetRowBounds(FirstVisibleRow);
				Rectangle bounds = _rowLayout.GetRowBounds(node.Row);
				float pos = (pt.Y + first.Y - ColumnHeaderHeight - bounds.Y) / (float)bounds.Height;
				if (pos < TopEdgeSensivity)
					_dropPosition.Position = NodePosition.Before;
				else if (pos > (1 - BottomEdgeSensivity))
					_dropPosition.Position = NodePosition.After;
				else
					_dropPosition.Position = NodePosition.Inside;
			}
		}

		private void DragTimerTick(object state)
		{
			_dragAutoScrollFlag = true;
		}

		private void DragAutoScroll()
		{
			_dragAutoScrollFlag = false;
			Point pt = PointToClient(MousePosition);
			if (pt.Y < 20 && _vScrollBar.Value > 0)
				_vScrollBar.Value--;
			else if (pt.Y > Height - 20 && _vScrollBar.Value <= _vScrollBar.Maximum - _vScrollBar.LargeChange)
				_vScrollBar.Value++;
		}

		public void DoDragDropSelectedNodes(DragDropEffects allowedEffects)
		{
			if (SelectedNodes.Count > 0)
			{
				TreeNodeAdv[] nodes = new TreeNodeAdv[SelectedNodes.Count];
				SelectedNodes.CopyTo(nodes, 0);
				DoDragDrop(nodes, allowedEffects);
			}
		}

		private void CreateDragBitmap(IDataObject data)
		{
			if (UseColumns || !DisplayDraggingNodes)
				return;

			TreeNodeAdv[] nodes = data.GetData(typeof(TreeNodeAdv[])) as TreeNodeAdv[];
			if (nodes != null && nodes.Length > 0)
			{
				Rectangle rect = DisplayRectangle;
				Bitmap bitmap = new Bitmap(rect.Width, rect.Height);
				using (Graphics gr = Graphics.FromImage(bitmap))
				{
					gr.Clear(BackColor);
					DrawContext context = new DrawContext();
					context.Graphics = gr;
					context.Font = Font;
					context.Enabled = true;
					int y = 0;
					int maxWidth = 0;
					foreach (TreeNodeAdv node in nodes)
					{
						if (node.Tree == this)
						{
							int x = 0;
							int height = _rowLayout.GetRowBounds(node.Row).Height;
							foreach (NodeControl c in NodeControls)
							{
								Size s = c.GetActualSize(node, context);
								if (!s.IsEmpty)
								{
									int width = s.Width;
									rect = new Rectangle(x, y, width, height);
									x += (width + 1);
									context.Bounds = rect;
									c.Draw(node, context);
								}
							}
							y += height;
							maxWidth = Math.Max(maxWidth, x);
						}
					}

					if (maxWidth > 0 && y > 0)
					{
						_dragBitmap = new Bitmap(maxWidth, y, PixelFormat.Format32bppArgb);
						using (Graphics tgr = Graphics.FromImage(_dragBitmap))
							tgr.DrawImage(bitmap, Point.Empty);
						BitmapHelper.SetAlphaChanelValue(_dragBitmap, 150);
					}
					else
						_dragBitmap = null;
				}
			}
		}

		protected override void OnDragOver(DragEventArgs drgevent)
		{
			ItemDragMode = false;
			Point pt = PointToClient(new Point(drgevent.X, drgevent.Y));
			if (_dragAutoScrollFlag)
				DragAutoScroll();
			SetDropPosition(pt);
			UpdateView();
			base.OnDragOver(drgevent);
		}

		protected override void OnDragEnter(DragEventArgs drgevent)
		{
			_search.EndSearch();
			DragMode = true;
			CreateDragBitmap(drgevent.Data);
			base.OnDragEnter(drgevent);
		}

		protected override void OnDragLeave(EventArgs e)
		{
			DragMode = false;
			UpdateView();
			base.OnDragLeave(e);
		}

		protected override void OnDragDrop(DragEventArgs drgevent)
		{
			DragMode = false;
			UpdateView();
			base.OnDragDrop(drgevent);
		}

		#endregion
	}
}

```

`Aga.Controls/Tree/TreeViewAdv.Properties.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Design;
using System.Windows.Forms;

using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public partial class TreeViewAdv
	{
		private Cursor _innerCursor = null;

		public override Cursor Cursor
		{
			get
			{
                if (_innerCursor != null)
                    return _innerCursor;
                else
					return base.Cursor;
			}
			set
			{
				base.Cursor = value;
			}
		}

		#region Internal Properties

		private IRowLayout _rowLayout;

		private bool _dragMode;
		private bool DragMode
		{
			get { return _dragMode; }
			set
			{
				_dragMode = value;
				if (!value)
				{
					StopDragTimer();
					if (_dragBitmap != null)
						_dragBitmap.Dispose();
					_dragBitmap = null;
				}
				else
					StartDragTimer();
			}
		}

		internal int ColumnHeaderHeight
		{
			get
			{
				if (UseColumns)
					return _columnHeaderHeight;
				else
					return 0;
			}
		}

		/// <summary>
		/// returns all nodes, which parent is expanded
		/// </summary>
		private IEnumerable<TreeNodeAdv> VisibleNodes
		{
			get
			{
				TreeNodeAdv node = Root;
				while (node != null)
				{
					node = node.NextVisibleNode;
					if (node != null)
						yield return node;
				}
			}
		}

		private bool _suspendSelectionEvent;
		internal bool SuspendSelectionEvent
		{
			get { return _suspendSelectionEvent; }
			set
			{
				if (value != _suspendSelectionEvent)
				{
					_suspendSelectionEvent = value;
					if (!_suspendSelectionEvent && _fireSelectionEvent)
						OnSelectionChanged();
				}
			}
		}

		private List<TreeNodeAdv> _rowMap;
		internal List<TreeNodeAdv> RowMap
		{
			get { return _rowMap; }
		}

		private TreeNodeAdv _selectionStart;
		internal TreeNodeAdv SelectionStart
		{
			get { return _selectionStart; }
			set { _selectionStart = value; }
		}

		private InputState _input;
		internal InputState Input
		{
			get { return _input; }
			set
			{
				_input = value;
			}
		}

		private bool _itemDragMode;
		internal bool ItemDragMode
		{
			get { return _itemDragMode; }
			set { _itemDragMode = value; }
		}

		private Point _itemDragStart;
		internal Point ItemDragStart
		{
			get { return _itemDragStart; }
			set { _itemDragStart = value; }
		}


		/// <summary>
		/// Number of rows fits to the current page
		/// </summary>
		internal int CurrentPageSize
		{
			get
			{
				return _rowLayout.CurrentPageSize;
			}
		}

		/// <summary>
		/// Number of all visible nodes (which parent is expanded)
		/// </summary>
		internal int RowCount
		{
			get
			{
				return RowMap.Count;
			}
		}

		private int _contentWidth = 0;
		private int ContentWidth
		{
			get
			{
				return _contentWidth;
			}
		}

		private int _firstVisibleRow;
		internal int FirstVisibleRow
		{
			get { return _firstVisibleRow; }
			set
			{
				HideEditor();
				_firstVisibleRow = value;
				UpdateView();
			}
		}

		private int _offsetX;
		public int OffsetX
		{
			get { return _offsetX; }
			private set
			{
				HideEditor();
				_offsetX = value;
				UpdateView();
			}
		}

		public override Rectangle DisplayRectangle
		{
			get
			{
				Rectangle r = ClientRectangle;
				//r.Y += ColumnHeaderHeight;
				//r.Height -= ColumnHeaderHeight;
				int w = _vScrollBar.Visible ? _vScrollBar.Width : 0;
				int h = _hScrollBar.Visible ? _hScrollBar.Height : 0;
				return new Rectangle(r.X, r.Y, r.Width - w, r.Height - h);
			}
		}

		private List<TreeNodeAdv> _selection;
		internal List<TreeNodeAdv> Selection
		{
			get { return _selection; }
		}

		#endregion

		#region Public Properties

		#region DesignTime

		private bool _shiftFirstNode;
		[DefaultValue(false), Category("Behavior")]
		public bool ShiftFirstNode
		{
			get { return _shiftFirstNode; }
			set { _shiftFirstNode = value; }
		}

		private bool _displayDraggingNodes;
		[DefaultValue(false), Category("Behavior")]
		public bool DisplayDraggingNodes
		{
			get { return _displayDraggingNodes; }
			set { _displayDraggingNodes = value; }
		}

		private bool _fullRowSelect;
		[DefaultValue(false), Category("Behavior")]
		public bool FullRowSelect
		{
			get { return _fullRowSelect; }
			set
			{
				_fullRowSelect = value;
				UpdateView();
			}
		}

		private bool _useColumns;
		[DefaultValue(false), Category("Behavior")]
		public bool UseColumns
		{
			get { return _useColumns; }
			set
			{
				_useColumns = value;
				FullUpdate();
			}
		}

		private bool _allowColumnReorder;
		[DefaultValue(false), Category("Behavior")]
		public bool AllowColumnReorder
		{
			get { return _allowColumnReorder; }
			set { _allowColumnReorder = value; }
		}

		private bool _showLines = true;
		[DefaultValue(true), Category("Behavior")]
		public bool ShowLines
		{
			get { return _showLines; }
			set
			{
				_showLines = value;
				UpdateView();
			}
		}

		private bool _showPlusMinus = true;
		[DefaultValue(true), Category("Behavior")]
		public bool ShowPlusMinus
		{
			get { return _showPlusMinus; }
			set
			{
				_showPlusMinus = value;
				FullUpdate();
			}
		}

		private bool _showNodeToolTips = false;
		[DefaultValue(false), Category("Behavior")]
		public bool ShowNodeToolTips
		{
			get { return _showNodeToolTips; }
			set { _showNodeToolTips = value; }
		}

		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "value"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic"), DefaultValue(true), Category("Behavior"), Obsolete("No longer used")]
		public bool KeepNodesExpanded
		{
			get { return true; }
			set {}
		}

		private ITreeModel _model;
        /// <Summary>
        /// The model associated with this <see cref="TreeViewAdv"/>.
        /// </Summary>
        /// <seealso cref="ITreeModel"/>
        /// <seealso cref="TreeModel"/>
        [Browsable(false)]
		public ITreeModel Model
		{
			get { return _model; }
			set
			{
				if (_model != value)
				{
					AbortBackgroundExpandingThreads();
					if (_model != null)
						UnbindModelEvents();
					_model = value;
					CreateNodes();
					FullUpdate();
					if (_model != null)
						BindModelEvents();
				}
			}
		}

        private static Font _font = SystemFonts.MessageBoxFont; 
        /// <summary>
        /// The font to render <see cref="TreeViewAdv"/> content in.
        /// </summary>
        [Category("Appearance"), Description("The font to render TreeViewAdv content in.")]
        public override Font Font
        {
            get
            {
                return (base.Font);
            }
            set
            {
                if (value == null)
                    base.Font = _font;
                else
                {
                    if (value == DefaultFont)
                        base.Font = _font;
                    else
                        base.Font = value;
                }
            }
        }
        public override void ResetFont()
        {
            Font = null;
        }
        private bool ShouldSerializeFont()
        {
            return (!Font.Equals(_font));
        }
        // End font property

		private BorderStyle _borderStyle = BorderStyle.Fixed3D;
		[DefaultValue(BorderStyle.Fixed3D), Category("Appearance")]
		public BorderStyle BorderStyle
		{
			get
			{
				return this._borderStyle;
			}
			set
			{
				if (_borderStyle != value)
				{
					_borderStyle = value;
					base.UpdateStyles();
				}
			}
		}

		private bool _autoRowHeight = false;
		/// <summary>
		/// Set to true to expand each row's height to fit the text of it's largest column.
		/// </summary>
		[DefaultValue(false), Category("Appearance"), Description("Expand each row's height to fit the text of it's largest column.")]
		public bool AutoRowHeight
		{
			get
			{
				return _autoRowHeight;
			}
			set
			{
				_autoRowHeight = value;
				if (value)
					_rowLayout = new AutoRowHeightLayout(this, RowHeight);
				else
					_rowLayout = new FixedRowHeightLayout(this, RowHeight);
				FullUpdate();
			}
		}

        private GridLineStyle _gridLineStyle = GridLineStyle.None;
        [DefaultValue(GridLineStyle.None), Category("Appearance")]
        public GridLineStyle GridLineStyle
        {
            get
            {
                return _gridLineStyle;
            }
            set
            {
				if (value != _gridLineStyle)
				{
					_gridLineStyle = value;
					UpdateView();
					OnGridLineStyleChanged();
				}
            }
        }

		private int _rowHeight = 16;
		[DefaultValue(16), Category("Appearance")]
		public int RowHeight
		{
			get
			{
				return _rowHeight;
			}
			set
			{
				if (value <= 0)
					throw new ArgumentOutOfRangeException("value");

				_rowHeight = value;
				_rowLayout.PreferredRowHeight = value;
				FullUpdate();
			}
		}

		private TreeSelectionMode _selectionMode = TreeSelectionMode.Single;
		[DefaultValue(TreeSelectionMode.Single), Category("Behavior")]
		public TreeSelectionMode SelectionMode
		{
			get { return _selectionMode; }
			set { _selectionMode = value; }
		}

		private bool _hideSelection;
		[DefaultValue(false), Category("Behavior")]
		public bool HideSelection
		{
			get { return _hideSelection; }
			set
			{
				_hideSelection = value;
				UpdateView();
			}
		}

		private float _topEdgeSensivity = 0.3f;
		[DefaultValue(0.3f), Category("Behavior")]
		public float TopEdgeSensivity
		{
			get { return _topEdgeSensivity; }
			set
			{
				if (value < 0 || value > 1)
					throw new ArgumentOutOfRangeException();
				_topEdgeSensivity = value;
			}
		}

		private float _bottomEdgeSensivity = 0.3f;
		[DefaultValue(0.3f), Category("Behavior")]
		public float BottomEdgeSensivity
		{
			get { return _bottomEdgeSensivity; }
			set
			{
				if (value < 0 || value > 1)
					throw new ArgumentOutOfRangeException("value should be from 0 to 1");
				_bottomEdgeSensivity = value;
			}
		}

		private bool _loadOnDemand;
		[DefaultValue(false), Category("Behavior")]
		public bool LoadOnDemand
		{
			get { return _loadOnDemand; }
			set { _loadOnDemand = value; }
		}

		private bool _unloadCollapsedOnReload = false;
		[DefaultValue(false), Category("Behavior")]
		public bool UnloadCollapsedOnReload
		{
			get { return _unloadCollapsedOnReload; }
			set { _unloadCollapsedOnReload = value; }
		}

		private int _indent = 19;
		[DefaultValue(19), Category("Behavior")]
		public int Indent
		{
			get { return _indent; }
			set
			{
				_indent = value;
				UpdateView();
			}
		}

		private Color _lineColor = SystemColors.ControlDark;
		[Category("Behavior")]
		public Color LineColor
		{
			get { return _lineColor; }
			set
			{
				_lineColor = value;
				CreateLinePen();
				UpdateView();
			}
		}

		private Color _dragDropMarkColor = Color.Black;
		[Category("Behavior")]
		public Color DragDropMarkColor
		{
			get { return _dragDropMarkColor; }
			set
			{
				_dragDropMarkColor = value;
				CreateMarkPen();
			}
		}

		private float _dragDropMarkWidth = 3.0f;
		[DefaultValue(3.0f), Category("Behavior")]
		public float DragDropMarkWidth
		{
			get { return _dragDropMarkWidth; }
			set
			{
				_dragDropMarkWidth = value;
				CreateMarkPen();
			}
		}

		private bool _highlightDropPosition = true;
		[DefaultValue(true), Category("Behavior")]
		public bool HighlightDropPosition
		{
			get { return _highlightDropPosition; }
			set { _highlightDropPosition = value; }
		}

		private TreeColumnCollection _columns;
		[Category("Behavior"), DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
		public Collection<TreeColumn> Columns
		{
			get { return _columns; }
		}

		private NodeControlsCollection _controls;
		[Category("Behavior"), DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
		[Editor(typeof(NodeControlCollectionEditor), typeof(UITypeEditor))]
		public Collection<NodeControl> NodeControls
		{
			get
			{
				return _controls;
			}
		}

		private bool _asyncExpanding;
		/// <summary>
		/// When set to true, node contents will be read in background thread.
		/// </summary>
		[Category("Behavior"), DefaultValue(false), Description("Read children in a background thread when expanding.")]
		public bool AsyncExpanding
		{
			get { return _asyncExpanding; }
			set { _asyncExpanding = value; }
		}

		#endregion

		#region RunTime

		private IToolTipProvider _defaultToolTipProvider = null;
		[Browsable(false)]
		public IToolTipProvider DefaultToolTipProvider
		{
			get { return _defaultToolTipProvider; }
			set { _defaultToolTipProvider = value; }
		}

		[Browsable(false)]
		public IEnumerable<TreeNodeAdv> AllNodes
		{
			get
			{
				if (_root.Nodes.Count > 0)
				{
					TreeNodeAdv node = _root.Nodes[0];
					while (node != null)
					{
						yield return node;
						if (node.Nodes.Count > 0)
							node = node.Nodes[0];
						else if (node.NextNode != null)
							node = node.NextNode;
						else
							node = node.BottomNode;
					}
				}
			}
		}

		private DropPosition _dropPosition;
		[Browsable(false)]
		public DropPosition DropPosition
		{
			get { return _dropPosition; }
			set { _dropPosition = value; }
		}

		private TreeNodeAdv _root;
		[Browsable(false)]
		public TreeNodeAdv Root
		{
			get { return _root; }
		}

		private ReadOnlyCollection<TreeNodeAdv> _readonlySelection;
		[Browsable(false)]
		public ReadOnlyCollection<TreeNodeAdv> SelectedNodes
		{
			get
			{
				return _readonlySelection;
			}
		}

		[Browsable(false)]
		public TreeNodeAdv SelectedNode
		{
			get
			{
				if (Selection.Count > 0)
				{
					if (CurrentNode != null && CurrentNode.IsSelected)
						return CurrentNode;
					else
						return Selection[0];
				}
				else
					return null;
			}
			set
			{
				if (SelectedNode == value)
					return;

				BeginUpdate();
				try
				{
					if (value == null)
					{
						ClearSelectionInternal();
					}
					else
					{
						if (!IsMyNode(value))
							throw new ArgumentException();

						ClearSelectionInternal();
						value.IsSelected = true;
						CurrentNode = value;
						EnsureVisible(value);
					}
				}
				finally
				{
					EndUpdate();
				}
			}
		}

		private TreeNodeAdv _currentNode;
		[Browsable(false)]
		public TreeNodeAdv CurrentNode
		{
			get { return _currentNode; }
			internal set { _currentNode = value; }
		}

        [Browsable(false)]
        public int ItemCount
        {
            get { return RowMap.Count; }
        }

		/// <summary>
		/// Indicates the distance the content is scrolled to the left
		/// </summary>
		[Browsable(false)]
		public int HorizontalScrollPosition
		{
			get
			{
				if (_hScrollBar.Visible)
					return _hScrollBar.Value;
				else
					return 0;
			}
		}

		#endregion

		#endregion

	}
}

```

`Aga.Controls/Tree/TreeViewAdv.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Drawing;
using System.Security.Permissions;
using System.Threading;
using System.Windows.Forms;
using System.Collections;

using Aga.Controls.Tree.NodeControls;
using Aga.Controls.Threading;


namespace Aga.Controls.Tree
{
	/// <summary>
	/// Extensible advanced <see cref="TreeView"/> implemented in 100% managed C# code.
	/// Features: Model/View architecture. Multiple column per node. Ability to select
	/// multiple tree nodes. Different types of controls for each node column: 
	/// <see cref="CheckBox"/>, Icon, Label... Drag and Drop highlighting. Load on
	/// demand of nodes. Incremental search of nodes.
	/// </summary>
	public partial class TreeViewAdv : Control
	{
		private const int LeftMargin = 7;
		internal const int ItemDragSensivity = 4;
		private readonly int _columnHeaderHeight;
		private const int DividerWidth = 9;
		private const int DividerCorrectionGap = -2;

		private Pen _linePen;
		private Pen _markPen;
		private bool _suspendUpdate;
		private bool _needFullUpdate;
		private bool _fireSelectionEvent;
		private NodePlusMinus _plusMinus;
		private ToolTip _toolTip;
		private DrawContext _measureContext;
		private TreeColumn _hotColumn;
		private IncrementalSearch _search;
		private List<TreeNodeAdv> _expandingNodes = new List<TreeNodeAdv>();
		private AbortableThreadPool _threadPool = new AbortableThreadPool();

		private float dpiX;
		private float dpiY;
		private float dpiXscale = 1;
		private float dpiYscale = 1;

		#region Public Events

		[Category("Action")]
		public event ItemDragEventHandler ItemDrag;
		private void OnItemDrag(MouseButtons buttons, object item)
		{
			if (ItemDrag != null)
				ItemDrag(this, new ItemDragEventArgs(buttons, item));
		}

		[Category("Behavior")]
		public event EventHandler<TreeNodeAdvMouseEventArgs> NodeMouseClick;
		private void OnNodeMouseClick(TreeNodeAdvMouseEventArgs args)
		{
			if (NodeMouseClick != null)
				NodeMouseClick(this, args);
		}

		[Category("Behavior")]
		public event EventHandler<TreeNodeAdvMouseEventArgs> NodeMouseDoubleClick;
		private void OnNodeMouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
			if (NodeMouseDoubleClick != null)
				NodeMouseDoubleClick(this, args);
		}

		[Category("Behavior")]
		public event EventHandler<TreeColumnEventArgs> ColumnWidthChanged;
		internal void OnColumnWidthChanged(TreeColumn column)
		{
			if (ColumnWidthChanged != null)
				ColumnWidthChanged(this, new TreeColumnEventArgs(column));
		}

		[Category("Behavior")]
		public event EventHandler<TreeColumnEventArgs> ColumnReordered;
		internal void OnColumnReordered(TreeColumn column)
		{
			if (ColumnReordered != null)
				ColumnReordered(this, new TreeColumnEventArgs(column));
		}

		[Category("Behavior")]
		public event EventHandler<TreeColumnEventArgs> ColumnClicked;
		internal void OnColumnClicked(TreeColumn column)
		{
			if (ColumnClicked != null)
				ColumnClicked(this, new TreeColumnEventArgs(column));
		}

		[Category("Behavior")]
		public event EventHandler SelectionChanged;
		internal void OnSelectionChanged()
		{
			if (SuspendSelectionEvent)
				_fireSelectionEvent = true;
			else
			{
				_fireSelectionEvent = false;
				if (SelectionChanged != null)
					SelectionChanged(this, EventArgs.Empty);
			}
		}

		[Category("Behavior")]
		public event EventHandler<TreeViewAdvEventArgs> Collapsing;
		private void OnCollapsing(TreeNodeAdv node)
		{
			if (Collapsing != null)
				Collapsing(this, new TreeViewAdvEventArgs(node));
		}

		[Category("Behavior")]
		public event EventHandler<TreeViewAdvEventArgs> Collapsed;
		private void OnCollapsed(TreeNodeAdv node)
		{
			if (Collapsed != null)
				Collapsed(this, new TreeViewAdvEventArgs(node));
		}

		[Category("Behavior")]
		public event EventHandler<TreeViewAdvEventArgs> Expanding;
		private void OnExpanding(TreeNodeAdv node)
		{
			if (Expanding != null)
				Expanding(this, new TreeViewAdvEventArgs(node));
		}

		[Category("Behavior")]
		public event EventHandler<TreeViewAdvEventArgs> Expanded;
		private void OnExpanded(TreeNodeAdv node)
		{
			if (Expanded != null)
				Expanded(this, new TreeViewAdvEventArgs(node));
		}

		[Category("Behavior")]
		public event EventHandler GridLineStyleChanged;
		private void OnGridLineStyleChanged()
		{
			if (GridLineStyleChanged != null)
				GridLineStyleChanged(this, EventArgs.Empty);
		}

		[Category("Behavior")]
		public event ScrollEventHandler Scroll;
		protected virtual void OnScroll(ScrollEventArgs e)
		{
			if (Scroll != null)
				Scroll(this, e);
		}

		[Category("Behavior")]
		public event EventHandler<TreeViewRowDrawEventArgs> RowDraw;
		protected virtual void OnRowDraw(PaintEventArgs e, TreeNodeAdv node, DrawContext context, int row, Rectangle rowRect)
		{
			if (RowDraw != null)
			{
				TreeViewRowDrawEventArgs args = new TreeViewRowDrawEventArgs(e.Graphics, e.ClipRectangle, node, context, row, rowRect);
				RowDraw(this, args);
			}
		}

		/// <summary>
		/// Fires when control is going to draw. Can be used to change text or back color
		/// </summary>
		[Category("Behavior")]
		public event EventHandler<DrawEventArgs> DrawControl;

		internal bool DrawControlMustBeFired()
		{
			return DrawControl != null;
		}

		internal void FireDrawControl(DrawEventArgs args)
		{
			OnDrawControl(args);
		}

		protected virtual void OnDrawControl(DrawEventArgs args)
		{
			if (DrawControl != null)
				DrawControl(this, args);
		}


		[Category("Drag Drop")]
		public event EventHandler<DropNodeValidatingEventArgs> DropNodeValidating;
		protected virtual void OnDropNodeValidating(Point point, ref TreeNodeAdv node)
		{
			if (DropNodeValidating != null)
			{
				DropNodeValidatingEventArgs args = new DropNodeValidatingEventArgs(point, node);
				DropNodeValidating(this, args);
				node = args.Node;
			}
		}
		#endregion

		public TreeViewAdv()
		{
			InitializeComponent();
			SetDPI();
			SetStyle(ControlStyles.AllPaintingInWmPaint
				| ControlStyles.UserPaint
				| ControlStyles.OptimizedDoubleBuffer
				| ControlStyles.ResizeRedraw
				| ControlStyles.Selectable
				, true);


			if (Application.RenderWithVisualStyles)
				_columnHeaderHeight = 20;
			else
				_columnHeaderHeight = 17;
			_columnHeaderHeight = GetScaledSize(_columnHeaderHeight);

			//BorderStyle = BorderStyle.Fixed3D;
			_hScrollBar.Height = SystemInformation.HorizontalScrollBarHeight;
			_vScrollBar.Width = SystemInformation.VerticalScrollBarWidth;
			_rowLayout = new FixedRowHeightLayout(this, RowHeight);
			_rowMap = new List<TreeNodeAdv>();
			_selection = new List<TreeNodeAdv>();
			_readonlySelection = new ReadOnlyCollection<TreeNodeAdv>(_selection);
			_columns = new TreeColumnCollection(this);
			_toolTip = new ToolTip();

			_measureContext = new DrawContext();
			_measureContext.Font = Font;
			_measureContext.Graphics = Graphics.FromImage(new Bitmap(1, 1));

			Input = new NormalInputState(this);
			_search = new IncrementalSearch(this);
			CreateNodes();
			CreatePens();

			ArrangeControls();

			_plusMinus = new NodePlusMinus();
			_controls = new NodeControlsCollection(this);

			Font = _font;
			ExpandingIcon.IconChanged += ExpandingIconChanged;
		}

		public void SetDPI()
		{
			// https://msdn.microsoft.com/en-us/library/windows/desktop/dn469266(v=vs.85).aspx
			const int _default_dpi = 96;
			Graphics g = this.CreateGraphics();

			try
			{
				this.dpiX = g.DpiX;
				this.dpiY = g.DpiY;
			}
			finally
			{
				g.Dispose();
			}
			if (dpiX > 0)
			{
				this.dpiXscale = dpiX / _default_dpi;
			}
			if (dpiY > 0)
			{
				this.dpiYscale = dpiY / _default_dpi;
			}
		}

		public int GetScaledSize(int size, bool useY = true)
		{
			int scaledsize = size;

			if (useY && this.dpiYscale > 1)
			{
				scaledsize = (int)(this.dpiYscale * size);
			}
			else if (this.dpiXscale > 1)
			{
				scaledsize = (int)(this.dpiXscale * size);
			}
			return scaledsize;
		}

		void ExpandingIconChanged(object sender, EventArgs e)
		{
			if (IsHandleCreated && !IsDisposed)
				BeginInvoke(new MethodInvoker(DrawIcons));
		}

		private void DrawIcons()
		{
			using (Graphics gr = Graphics.FromHwnd(this.Handle))
			{
				//Apply the same Graphics Transform logic as used in OnPaint.
				int y = 0;
				if (UseColumns)
				{
					y += ColumnHeaderHeight;
					if (Columns.Count == 0)
						return;
				}
				int firstRowY = _rowLayout.GetRowBounds(FirstVisibleRow).Y;
				y -= firstRowY;
				gr.ResetTransform();
				gr.TranslateTransform(-OffsetX, y);

				DrawContext context = new DrawContext();
				context.Graphics = gr;
				for (int i = 0; i < _expandingNodes.Count; i++)
				{
					foreach (NodeControlInfo item in GetNodeControls(_expandingNodes[i]))
					{
						if (item.Control is ExpandingIcon)
						{
							Rectangle bounds = item.Bounds;
							if (item.Node.Parent == null && UseColumns)
								bounds.Location = Point.Empty; // display root expanding icon at 0,0

							context.Bounds = bounds;
							item.Control.Draw(item.Node, context);
						}
					}
				}
			}
		}

		#region Public Methods

		public TreePath GetPath(TreeNodeAdv node)
		{
			if (node == _root)
				return TreePath.Empty;
			else
			{
				Stack<object> stack = new Stack<object>();
				while (node != _root && node != null)
				{
					stack.Push(node.Tag);
					node = node.Parent;
				}
				return new TreePath(stack.ToArray());
			}
		}

		public TreeNodeAdv GetNodeAt(Point point)
		{
			NodeControlInfo info = GetNodeControlInfoAt(point);
			return info.Node;
		}

		public NodeControlInfo GetNodeControlInfoAt(Point point)
		{
			if (point.X < 0 || point.Y < 0)
				return NodeControlInfo.Empty;

			int row = _rowLayout.GetRowAt(point);
			if (row < RowCount && row >= 0)
				return GetNodeControlInfoAt(RowMap[row], point);
			else
				return NodeControlInfo.Empty;
		}

		private NodeControlInfo GetNodeControlInfoAt(TreeNodeAdv node, Point point)
		{
			Rectangle rect = _rowLayout.GetRowBounds(FirstVisibleRow);
			point.Y += (rect.Y - ColumnHeaderHeight);
			point.X += OffsetX;
			foreach (NodeControlInfo info in GetNodeControls(node))
				if (info.Bounds.Contains(point))
					return info;

			if (FullRowSelect)
				return new NodeControlInfo(null, Rectangle.Empty, node);
			else
				return NodeControlInfo.Empty;
		}

		public void BeginUpdate()
		{
			_suspendUpdate = true;
			SuspendSelectionEvent = true;
		}

		public void EndUpdate()
		{
			_suspendUpdate = false;
			if (_needFullUpdate)
				FullUpdate();
			else
				UpdateView();
			SuspendSelectionEvent = false;
		}

		public void ExpandAll()
		{
			_root.ExpandAll();
		}

		public void CollapseAll()
		{
			_root.CollapseAll();
		}

		/// <summary>
		/// Expand all parent nodes, andd scroll to the specified node
		/// </summary>
		public void EnsureVisible(TreeNodeAdv node)
		{
			if (node == null)
				throw new ArgumentNullException("node");

			if (!IsMyNode(node))
				throw new ArgumentException();

			TreeNodeAdv parent = node.Parent;
			while (parent != _root)
			{
				parent.IsExpanded = true;
				parent = parent.Parent;
			}
			ScrollTo(node);
		}

		/// <summary>
		/// Make node visible, scroll if needed. All parent nodes of the specified node must be expanded
		/// </summary>
		/// <param name="node"></param>
		public void ScrollTo(TreeNodeAdv node)
		{
			if (node == null)
				throw new ArgumentNullException("node");

			if (!IsMyNode(node))
				throw new ArgumentException();

			if (node.Row < 0)
				CreateRowMap();

			int row = -1;

			if (node.Row < FirstVisibleRow)
				row = node.Row;
			else
			{
				int pageStart = _rowLayout.GetRowBounds(FirstVisibleRow).Top;
				int rowBottom = _rowLayout.GetRowBounds(node.Row).Bottom;
				if (rowBottom > pageStart + DisplayRectangle.Height - ColumnHeaderHeight)
					row = _rowLayout.GetFirstRow(node.Row);
			}

			if (row >= _vScrollBar.Minimum && row <= _vScrollBar.Maximum)
				_vScrollBar.Value = row;
		}

		public void ClearSelection()
		{
			BeginUpdate();
			try
			{
				ClearSelectionInternal();
			}
			finally
			{
				EndUpdate();
			}
		}

		internal void ClearSelectionInternal()
		{
			while (Selection.Count > 0)
			{
				var t = Selection[0];
				t.IsSelected = false;
				Selection.Remove(t); //hack
			}
		}

		#endregion

		protected override void OnSizeChanged(EventArgs e)
		{
			ArrangeControls();
			SafeUpdateScrollBars();
			base.OnSizeChanged(e);
		}

		private void ArrangeControls()
		{
			int hBarSize = _hScrollBar.Height;
			int vBarSize = _vScrollBar.Width;
			Rectangle clientRect = ClientRectangle;

			_hScrollBar.SetBounds(clientRect.X, clientRect.Bottom - hBarSize,
				clientRect.Width - vBarSize, hBarSize);

			_vScrollBar.SetBounds(clientRect.Right - vBarSize, clientRect.Y,
				vBarSize, clientRect.Height - hBarSize);
		}

		private void SafeUpdateScrollBars()
		{
			if (InvokeRequired)
				BeginInvoke(new MethodInvoker(UpdateScrollBars));
			else
				UpdateScrollBars();
		}

		private void UpdateScrollBars()
		{
			UpdateVScrollBar();
			UpdateHScrollBar();
			UpdateVScrollBar();
			UpdateHScrollBar();
			_hScrollBar.Width = DisplayRectangle.Width;
			_vScrollBar.Height = DisplayRectangle.Height;
		}

		private void UpdateHScrollBar()
		{
			_hScrollBar.Maximum = ContentWidth;
			_hScrollBar.LargeChange = Math.Max(DisplayRectangle.Width, 0);
			_hScrollBar.SmallChange = 5;
			_hScrollBar.Visible = _hScrollBar.LargeChange < _hScrollBar.Maximum;
			_hScrollBar.Value = Math.Min(_hScrollBar.Value, _hScrollBar.Maximum - _hScrollBar.LargeChange + 1);
		}

		private void UpdateVScrollBar()
		{
			_vScrollBar.Maximum = Math.Max(RowCount - 1, 0);
			_vScrollBar.LargeChange = _rowLayout.PageRowCount;
			_vScrollBar.Visible = (RowCount > 0) && (_vScrollBar.LargeChange <= _vScrollBar.Maximum);
			_vScrollBar.Value = Math.Min(_vScrollBar.Value, _vScrollBar.Maximum - _vScrollBar.LargeChange + 1);
		}

		protected override CreateParams CreateParams
		{
			[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
			get
			{
				CreateParams res = base.CreateParams;
				switch (BorderStyle)
				{
					case BorderStyle.FixedSingle:
						res.Style |= 0x800000;
						break;
					case BorderStyle.Fixed3D:
						res.ExStyle |= 0x200;
						break;
				}
				return res;
			}
		}

		protected override void OnGotFocus(EventArgs e)
		{
			UpdateView();
			ChangeInput();
			base.OnGotFocus(e);
		}

		protected override void OnFontChanged(EventArgs e)
		{
			base.OnFontChanged(e);
			_measureContext.Font = Font;
			FullUpdate();
		}

		internal IEnumerable<NodeControlInfo> GetNodeControls(TreeNodeAdv node)
		{
			if (node == null)
				yield break;
			Rectangle rowRect = _rowLayout.GetRowBounds(node.Row);
			foreach (NodeControlInfo n in GetNodeControls(node, rowRect))
				yield return n;
		}

		internal IEnumerable<NodeControlInfo> GetNodeControls(TreeNodeAdv node, Rectangle rowRect)
		{
			if (node == null)
				yield break;

			int scaledIndent = node.Tree.GetScaledSize(_indent, false);
			int y = rowRect.Y;
			int x = (node.Level - 1) * scaledIndent + LeftMargin;
			int width = 0;
			if (node.Row == 0 && ShiftFirstNode)
				x -= scaledIndent;
			Rectangle rect = Rectangle.Empty;

			if (ShowPlusMinus)
			{
				width = _plusMinus.GetActualSize(node, _measureContext).Width;
				rect = new Rectangle(x, y, width, rowRect.Height);
				if (UseColumns && Columns.Count > 0 && Columns[0].Width < rect.Right)
					rect.Width = Columns[0].Width - x;

				yield return new NodeControlInfo(_plusMinus, rect, node);
				x += width;
			}

			if (!UseColumns)
			{
				foreach (NodeControl c in NodeControls)
				{
					Size s = c.GetActualSize(node, _measureContext);
					if (!s.IsEmpty)
					{
						width = s.Width;
						rect = new Rectangle(x, y, width, rowRect.Height);
						x += rect.Width;
						yield return new NodeControlInfo(c, rect, node);
					}
				}
			}
			else
			{
				int right = 0;
				foreach (TreeColumn col in Columns)
				{
					if (col.IsVisible && col.Width > 0)
					{
						right += col.Width;
						for (int i = 0; i < NodeControls.Count; i++)
						{
							NodeControl nc = NodeControls[i];
							if (nc.ParentColumn == col)
							{
								Size s = nc.GetActualSize(node, _measureContext);
								if (!s.IsEmpty)
								{
									bool isLastControl = true;
									for (int k = i + 1; k < NodeControls.Count; k++)
										if (NodeControls[k].ParentColumn == col)
										{
											isLastControl = false;
											break;
										}

									width = right - x;
									if (!isLastControl)
										width = s.Width;
									int maxWidth = Math.Max(0, right - x);
									rect = new Rectangle(x, y, Math.Min(maxWidth, width), rowRect.Height);
									x += width;
									yield return new NodeControlInfo(nc, rect, node);
								}
							}
						}
						x = right;
					}
				}
			}
		}

		internal static double Dist(Point p1, Point p2)
		{
			return Math.Sqrt(Math.Pow(p1.X - p2.X, 2) + Math.Pow(p1.Y - p2.Y, 2));
		}

		public void FullUpdate()
		{
			HideEditor();
			if (InvokeRequired)
				BeginInvoke(new MethodInvoker(UnsafeFullUpdate));
			else
				UnsafeFullUpdate();
		}

		private void UnsafeFullUpdate()
		{
			_rowLayout.ClearCache();
			CreateRowMap();
			SafeUpdateScrollBars();
			UpdateView();
			_needFullUpdate = false;
		}

		internal void UpdateView()
		{
			if (!_suspendUpdate)
				Invalidate(false);
		}

		internal void UpdateHeaders()
		{
			Invalidate(new Rectangle(0, 0, Width, ColumnHeaderHeight));
		}

		internal void UpdateColumns()
		{
			FullUpdate();
		}

		private void CreateNodes()
		{
			Selection.Clear();
			SelectionStart = null;
			_root = new TreeNodeAdv(this, null);
			_root.IsExpanded = true;
			if (_root.Nodes.Count > 0)
				CurrentNode = _root.Nodes[0];
			else
				CurrentNode = null;
		}

		internal void ReadChilds(TreeNodeAdv parentNode)
		{
			ReadChilds(parentNode, false);
		}

		internal void ReadChilds(TreeNodeAdv parentNode, bool performFullUpdate)
		{
			if (!parentNode.IsLeaf)
			{
				parentNode.IsExpandedOnce = true;
				parentNode.Nodes.Clear();

				if (Model != null)
				{
					IEnumerable items = Model.GetChildren(GetPath(parentNode));
					if (items != null)
						foreach (object obj in items)
						{
							AddNewNode(parentNode, obj, -1);
							if (performFullUpdate)
								FullUpdate();
						}
				}

				if (parentNode.AutoExpandOnStructureChanged)
					parentNode.ExpandAll();
			}
		}

		private void AddNewNode(TreeNodeAdv parent, object tag, int index)
		{
			TreeNodeAdv node = new TreeNodeAdv(this, tag);
			AddNode(parent, index, node);
		}

		private void AddNode(TreeNodeAdv parent, int index, TreeNodeAdv node)
		{
			if (index >= 0 && index < parent.Nodes.Count)
				parent.Nodes.Insert(index, node);
			else
				parent.Nodes.Add(node);

			node.IsLeaf = Model.IsLeaf(GetPath(node));
			if (node.IsLeaf)
				node.Nodes.Clear();
			if (!LoadOnDemand || node.IsExpandedOnce)
				ReadChilds(node);
		}

		private struct ExpandArgs
		{
			public TreeNodeAdv Node;
			public bool Value;
			public bool IgnoreChildren;
		}

		public void AbortBackgroundExpandingThreads()
		{
			_threadPool.CancelAll(true);
			for (int i = 0; i < _expandingNodes.Count; i++)
				_expandingNodes[i].IsExpandingNow = false;
			_expandingNodes.Clear();
			Invalidate();
		}

		internal void SetIsExpanded(TreeNodeAdv node, bool value, bool ignoreChildren)
		{
			ExpandArgs eargs = new ExpandArgs();
			eargs.Node = node;
			eargs.Value = value;
			eargs.IgnoreChildren = ignoreChildren;

			if (AsyncExpanding && LoadOnDemand && !_threadPool.IsMyThread(Thread.CurrentThread))
			{
				WaitCallback wc = delegate(object argument) { SetIsExpanded((ExpandArgs)argument); };
				_threadPool.QueueUserWorkItem(wc, eargs);
			}
			else
				SetIsExpanded(eargs);
		}

		private void SetIsExpanded(ExpandArgs eargs)
		{
			bool update = !eargs.IgnoreChildren && !AsyncExpanding;
			if (update)
				BeginUpdate();
			try
			{
				if (IsMyNode(eargs.Node) && eargs.Node.IsExpanded != eargs.Value)
					SetIsExpanded(eargs.Node, eargs.Value);

				if (!eargs.IgnoreChildren)
					SetIsExpandedRecursive(eargs.Node, eargs.Value);
			}
			finally
			{
				if (update)
					EndUpdate();
			}
		}

		internal void SetIsExpanded(TreeNodeAdv node, bool value)
		{
			if (Root == node && !value)
				return; //Can't collapse root node

			if (value)
			{
				OnExpanding(node);
				node.OnExpanding();
			}
			else
			{
				OnCollapsing(node);
				node.OnCollapsing();
			}

			if (value && !node.IsExpandedOnce)
			{
				if (AsyncExpanding && LoadOnDemand)
				{
					AddExpandingNode(node);
					node.AssignIsExpanded(true);
					Invalidate();
				}
				ReadChilds(node, AsyncExpanding);
				RemoveExpandingNode(node);
			}
			node.AssignIsExpanded(value);
			SmartFullUpdate();

			if (value)
			{
				OnExpanded(node);
				node.OnExpanded();
			}
			else
			{
				OnCollapsed(node);
				node.OnCollapsed();
			}
		}

		private void RemoveExpandingNode(TreeNodeAdv node)
		{
			node.IsExpandingNow = false;
			_expandingNodes.Remove(node);
			if (_expandingNodes.Count <= 0)
				ExpandingIcon.Stop();
		}

		private void AddExpandingNode(TreeNodeAdv node)
		{
			node.IsExpandingNow = true;
			_expandingNodes.Add(node);
			ExpandingIcon.Start();
		}

		internal void SetIsExpandedRecursive(TreeNodeAdv root, bool value)
		{
			for (int i = 0; i < root.Nodes.Count; i++)
			{
				TreeNodeAdv node = root.Nodes[i];
				node.IsExpanded = value;
				SetIsExpandedRecursive(node, value);
			}
		}

		private void CreateRowMap()
		{
			RowMap.Clear();
			int row = 0;
			_contentWidth = 0;
			foreach (TreeNodeAdv node in VisibleNodes)
			{
				node.Row = row;
				RowMap.Add(node);
				if (!UseColumns)
				{
					_contentWidth = Math.Max(_contentWidth, GetNodeWidth(node));
				}
				row++;
			}
			if (UseColumns)
			{
				_contentWidth = 0;
				foreach (TreeColumn col in _columns)
					if (col.IsVisible)
						_contentWidth += col.Width;
			}
		}

		private int GetNodeWidth(TreeNodeAdv node)
		{
			if (node.RightBounds == null)
			{
				Rectangle res = GetNodeBounds(GetNodeControls(node, Rectangle.Empty));
				node.RightBounds = res.Right;
			}
			return node.RightBounds.Value;
		}

		internal Rectangle GetNodeBounds(TreeNodeAdv node)
		{
			return GetNodeBounds(GetNodeControls(node));
		}

		private Rectangle GetNodeBounds(IEnumerable<NodeControlInfo> nodeControls)
		{
			Rectangle res = Rectangle.Empty;
			foreach (NodeControlInfo info in nodeControls)
			{
				if (res == Rectangle.Empty)
					res = info.Bounds;
				else
					res = Rectangle.Union(res, info.Bounds);
			}
			return res;
		}

		private void _vScrollBar_ValueChanged(object sender, EventArgs e)
		{
			FirstVisibleRow = _vScrollBar.Value;
		}

		private void _hScrollBar_ValueChanged(object sender, EventArgs e)
		{
			OffsetX = _hScrollBar.Value;
		}

		private void _vScrollBar_Scroll(object sender, ScrollEventArgs e)
		{
			OnScroll(e);
		}

		private void _hScrollBar_Scroll(object sender, ScrollEventArgs e)
		{
			OnScroll(e);
		}

		internal void SmartFullUpdate()
		{
			if (_suspendUpdate)
				_needFullUpdate = true;
			else
				FullUpdate();
		}

		internal bool IsMyNode(TreeNodeAdv node)
		{
			if (node == null)
				return false;

			if (node.Tree != this)
				return false;

			while (node.Parent != null)
				node = node.Parent;

			return node == _root;
		}

		internal void UpdateSelection()
		{
			bool flag = false;

			if (!IsMyNode(CurrentNode))
				CurrentNode = null;
			if (!IsMyNode(_selectionStart))
				_selectionStart = null;

			for (int i = Selection.Count - 1; i >= 0; i--)
				if (!IsMyNode(Selection[i]))
				{
					flag = true;
					Selection.RemoveAt(i);
				}

			if (flag)
				OnSelectionChanged();
		}

		internal void ChangeColumnWidth(TreeColumn column)
		{
			if (!(_input is ResizeColumnState))
			{
				FullUpdate();
				OnColumnWidthChanged(column);
			}
		}

		public TreeNodeAdv FindNode(TreePath path)
		{
			return FindNode(path, false);
		}

		public TreeNodeAdv FindNode(TreePath path, bool readChilds)
		{
			if (path.IsEmpty())
				return _root;
			else
				return FindNode(_root, path, 0, readChilds);
		}

		private TreeNodeAdv FindNode(TreeNodeAdv root, TreePath path, int level, bool readChilds)
		{
			if (!root.IsExpandedOnce && readChilds)
				ReadChilds(root);

			for (int i = 0; i < root.Nodes.Count; i++)
			{
				TreeNodeAdv node = root.Nodes[i];
				if (node.Tag == path.FullPath[level])
				{
					if (level == path.FullPath.Length - 1)
						return node;
					else
						return FindNode(node, path, level + 1, readChilds);
				}
			}
			return null;
		}

		public TreeNodeAdv FindNodeByTag(object tag)
		{
			return FindNodeByTag(_root, tag);
		}

		private TreeNodeAdv FindNodeByTag(TreeNodeAdv root, object tag)
		{
			foreach (TreeNodeAdv node in root.Nodes)
			{
				if (node.Tag == tag)
					return node;
				TreeNodeAdv res = FindNodeByTag(node, tag);
				if (res != null)
					return res;
			}
			return null;
		}

		public void SelectAllNodes()
		{
			SuspendSelectionEvent = true;
			try
			{
				if (SelectionMode == TreeSelectionMode.MultiSameParent)
				{
					if (CurrentNode != null)
					{
						foreach (TreeNodeAdv n in CurrentNode.Parent.Nodes)
							n.IsSelected = true;
					}
				}
				else if (SelectionMode == TreeSelectionMode.Multi)
				{
					SelectNodes(Root.Nodes);
				}
			}
			finally
			{
				SuspendSelectionEvent = false;
			}
		}

		private void SelectNodes(Collection<TreeNodeAdv> nodes)
		{
			foreach (TreeNodeAdv n in nodes)
			{
				n.IsSelected = true;
				if (n.IsExpanded)
					SelectNodes(n.Nodes);
			}
		}

		#region ModelEvents
		private void BindModelEvents()
		{
			_model.NodesChanged += new EventHandler<TreeModelEventArgs>(_model_NodesChanged);
			_model.NodesInserted += new EventHandler<TreeModelEventArgs>(_model_NodesInserted);
			_model.NodesRemoved += new EventHandler<TreeModelEventArgs>(_model_NodesRemoved);
			_model.StructureChanged += new EventHandler<TreePathEventArgs>(_model_StructureChanged);
		}

		private void UnbindModelEvents()
		{
			_model.NodesChanged -= new EventHandler<TreeModelEventArgs>(_model_NodesChanged);
			_model.NodesInserted -= new EventHandler<TreeModelEventArgs>(_model_NodesInserted);
			_model.NodesRemoved -= new EventHandler<TreeModelEventArgs>(_model_NodesRemoved);
			_model.StructureChanged -= new EventHandler<TreePathEventArgs>(_model_StructureChanged);
		}

		private void _model_StructureChanged(object sender, TreePathEventArgs e)
		{
			if (e.Path == null)
				throw new ArgumentNullException();

			TreeNodeAdv node = FindNode(e.Path);
			if (node != null)
			{
				if (node != Root)
					node.IsLeaf = Model.IsLeaf(GetPath(node));

				var list = new Dictionary<object, object>();
				SaveExpandedNodes(node, list);
				ReadChilds(node);
				RestoreExpandedNodes(node, list);

				UpdateSelection();
				SmartFullUpdate();
			}
			//else 
			//	throw new ArgumentException("Path not found");
		}

		private void RestoreExpandedNodes(TreeNodeAdv node, Dictionary<object, object> list)
		{
			if (node.Tag != null && list.ContainsKey(node.Tag))
			{
				node.IsExpanded = true;
				foreach (var child in node.Children)
					RestoreExpandedNodes(child, list);
			}
		}

		private void SaveExpandedNodes(TreeNodeAdv node, Dictionary<object, object> list)
		{
			if (node.IsExpanded && node.Tag != null)
			{
				list.Add(node.Tag, null);
				foreach (var child in node.Children)
					SaveExpandedNodes(child, list);
			}
		}

		private void _model_NodesRemoved(object sender, TreeModelEventArgs e)
		{
			TreeNodeAdv parent = FindNode(e.Path);
			if (parent != null)
			{
				if (e.Indices != null)
				{
					List<int> list = new List<int>(e.Indices);
					list.Sort();
					for (int n = list.Count - 1; n >= 0; n--)
					{
						int index = list[n];
						if (index >= 0 && index <= parent.Nodes.Count)
							parent.Nodes.RemoveAt(index);
						else
							throw new ArgumentOutOfRangeException("Index out of range");
					}
				}
				else
				{
					for (int i = parent.Nodes.Count - 1; i >= 0; i--)
					{
						for (int n = 0; n < e.Children.Length; n++)
							if (parent.Nodes[i].Tag == e.Children[n])
							{
								parent.Nodes.RemoveAt(i);
								break;
							}
					}
				}
			}
			UpdateSelection();
			SmartFullUpdate();
		}

		private void _model_NodesInserted(object sender, TreeModelEventArgs e)
		{
			if (e.Indices == null)
				throw new ArgumentNullException("Indices");

			TreeNodeAdv parent = FindNode(e.Path);
			if (parent != null)
			{
				for (int i = 0; i < e.Children.Length; i++)
					AddNewNode(parent, e.Children[i], e.Indices[i]);
			}
			SmartFullUpdate();
		}

		private void _model_NodesChanged(object sender, TreeModelEventArgs e)
		{
			TreeNodeAdv parent = FindNode(e.Path);
			if (parent != null && parent.IsVisible && parent.IsExpanded)
			{
				if (InvokeRequired)
					BeginInvoke(new UpdateContentWidthDelegate(ClearNodesSize), e, parent);
				else
					ClearNodesSize(e, parent);
				SmartFullUpdate();
			}
		}

		private delegate void UpdateContentWidthDelegate(TreeModelEventArgs e, TreeNodeAdv parent);
		private void ClearNodesSize(TreeModelEventArgs e, TreeNodeAdv parent)
		{
			if (e.Indices != null)
			{
				foreach (int index in e.Indices)
				{
					if (index >= 0 && index < parent.Nodes.Count)
					{
						TreeNodeAdv node = parent.Nodes[index];
						node.Height = node.RightBounds = null;
					}
					else
						throw new ArgumentOutOfRangeException("Index out of range");
				}
			}
			else
			{
				foreach (TreeNodeAdv node in parent.Nodes)
				{
					foreach (object obj in e.Children)
						if (node.Tag == obj)
						{
							node.Height = node.RightBounds = null;
						}
				}
			}
		}
		#endregion
	}
}

```

`Aga.Controls/Tree/TreeViewAdv.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="_vScrollBar.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>127, 17</value>
  </metadata>
  <metadata name="_hScrollBar.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="_errorProvider.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>236, 17</value>
  </metadata>
  <metadata name="$this.TrayLargeIcon" type="System.Boolean, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>False</value>
  </metadata>
</root>
```

`Aga.Controls/Tree/TreeViewAdvCancelEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public class TreeViewAdvCancelEventArgs : TreeViewAdvEventArgs
	{
		private bool _cancel;

		public bool Cancel
		{
			get { return _cancel; }
			set { _cancel = value; }
		}

		public TreeViewAdvCancelEventArgs(TreeNodeAdv node)
			: base(node)
		{
		}

	}
}

```

`Aga.Controls/Tree/TreeViewAdvEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public class TreeViewAdvEventArgs : EventArgs
	{
		private TreeNodeAdv _node;

		public TreeNodeAdv Node
		{
			get { return _node; }
		}

		public TreeViewAdvEventArgs(TreeNodeAdv node)
		{
			_node = node;
		}
	}
}

```

`Aga.Controls/Tree/TreeViewRowDrawEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;

namespace Aga.Controls.Tree
{
	public class TreeViewRowDrawEventArgs: PaintEventArgs
	{
		TreeNodeAdv _node;
		DrawContext _context;
		int _row;
		Rectangle _rowRect;

		public TreeViewRowDrawEventArgs(Graphics graphics, Rectangle clipRectangle, TreeNodeAdv node, DrawContext context, int row, Rectangle rowRect)
			: base(graphics, clipRectangle)
		{
			_node = node;
			_context = context;
			_row = row;
			_rowRect = rowRect;
		}

		public TreeNodeAdv Node
		{
			get { return _node; }
		}

		public DrawContext Context
		{
			get { return _context; }
		}

		public int Row
		{
			get { return _row; }
		}

		public Rectangle RowRect
		{
			get { return _rowRect; }
		}
	}

}

```

`Aga.Controls/license.txt`:

```txt
The BSD License

Copyright (c) 2009, Andrey Gliznetsov (a.gliznetsov@gmail.com)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided 
that the following conditions are met

- Redistributions of source code must retain the above copyright notice, this list of conditions 
and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
and the following disclaimer in the documentation andor other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

`Directory.Build.props`:

```props
<Project>
  <PropertyGroup>
    <Version>0.9.1</Version>
    <Copyright>LibreHardwareMonitor</Copyright>
  </PropertyGroup>
</Project>

```

`InpOut/InpOut32.Net/CSharpExample.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

using System.Runtime.InteropServices;

namespace InpOut32.Net
{
    public partial class CSharpExample : Form
    {
        
        [DllImport("inpout32.dll")]
        private static extern UInt32 IsInpOutDriverOpen();
        [DllImport("inpout32.dll")]
        private static extern void Out32(short PortAddress, short Data);
        [DllImport("inpout32.dll")]
        private static extern char Inp32(short PortAddress);

        [DllImport("inpout32.dll")]
        private static extern void DlPortWritePortUshort(short PortAddress, ushort Data);
        [DllImport("inpout32.dll")]
        private static extern ushort DlPortReadPortUshort(short PortAddress);

        [DllImport("inpout32.dll")]
        private static extern void DlPortWritePortUlong(int PortAddress, uint Data);
        [DllImport("inpout32.dll")]
        private static extern uint DlPortReadPortUlong(int PortAddress);

        [DllImport("inpoutx64.dll")]
        private static extern bool GetPhysLong(ref int PortAddress, ref uint Data);
        [DllImport("inpoutx64.dll")]
        private static extern bool SetPhysLong(ref int PortAddress, ref uint Data);


        [DllImport("inpoutx64.dll", EntryPoint="IsInpOutDriverOpen")]
        private static extern UInt32 IsInpOutDriverOpen_x64();
        [DllImport("inpoutx64.dll", EntryPoint = "Out32")]
        private static extern void Out32_x64(short PortAddress, short Data);
        [DllImport("inpoutx64.dll", EntryPoint = "Inp32")]
        private static extern char Inp32_x64(short PortAddress);

        [DllImport("inpoutx64.dll", EntryPoint = "DlPortWritePortUshort")]
        private static extern void DlPortWritePortUshort_x64(short PortAddress, ushort Data);
        [DllImport("inpoutx64.dll", EntryPoint = "DlPortReadPortUshort")]
        private static extern ushort DlPortReadPortUshort_x64(short PortAddress);

        [DllImport("inpoutx64.dll", EntryPoint = "DlPortWritePortUlong")]
        private static extern void DlPortWritePortUlong_x64(int PortAddress, uint Data);
        [DllImport("inpoutx64.dll", EntryPoint = "DlPortReadPortUlong")]
        private static extern uint DlPortReadPortUlong_x64(int PortAddress);

        [DllImport("inpoutx64.dll", EntryPoint = "GetPhysLong")]
        private static extern bool GetPhysLong_x64(ref int PortAddress, ref uint Data);
        [DllImport("inpoutx64.dll", EntryPoint = "SetPhysLong")]
        private static extern bool SetPhysLong_x64(ref int PortAddress, ref uint Data);


        bool m_bX64 = false;

        public CSharpExample()
        {
            InitializeComponent();
            try
            {
                uint nResult = 0;
                try
                {
                    nResult = IsInpOutDriverOpen();
                }
                catch (BadImageFormatException)
                {
                    nResult = IsInpOutDriverOpen_x64();
                    if (nResult != 0)
                        m_bX64 = true;

                }

                if (nResult == 0)
                {
                    lblMessage.Text = "Unable to open InpOut32 driver";
                    button1.Enabled = false;
                    button2.Enabled = false;
                    button3.Enabled = false;
                    button4.Enabled = false;
                    button5.Enabled = false;
                    button6.Enabled = false;
                    button7.Enabled = false;
                }
            }
            catch (DllNotFoundException ex)
            {
                System.Diagnostics.Debug.WriteLine(ex.ToString());
                lblMessage.Text = "Unable to find InpOut32.dll";
                button1.Enabled = false;
                button2.Enabled = false;
                button3.Enabled = false;
                button4.Enabled = false;
                button5.Enabled = false;
                button6.Enabled = false;
                button7.Enabled = false;
            }
        }

        private void button1_Click(object sender, EventArgs e)
        {
            try
            {
                short iPort = Convert.ToInt16(textBox1.Text);

                char c;
                if (m_bX64)
                    c = Inp32_x64(iPort);
                else
                    c = Inp32(iPort);
                
                textBox2.Text = Convert.ToInt32(c).ToString();
            }
            catch (Exception ex)
            {
                MessageBox.Show("An error occured:\n" + ex.Message);
            }
        }

        private void button2_Click(object sender, EventArgs e)
        {
            try
            {
                short iPort = Convert.ToInt16(textBox1.Text);
                short iData = Convert.ToInt16(textBox2.Text);
                textBox2.Text = "";
                if (m_bX64)
                    Out32_x64(iPort, iData);
                else
                    Out32(iPort, iData);

                
            }
            catch (Exception ex)
            {
                MessageBox.Show("An error occured:\n" + ex.Message);
            }
        }

        private void button3_Click(object sender, EventArgs e)
        {
            try
            {
                short iPort = Convert.ToInt16(textBox1.Text);
                ushort s;
                if (m_bX64)
                    s = DlPortReadPortUshort_x64(iPort);
                else
                    s = DlPortReadPortUshort(iPort);

                textBox2.Text = Convert.ToUInt16(s).ToString();
            }
            catch (Exception ex)
            {
                MessageBox.Show("An error occured:\n" + ex.Message);
            }
        }

        private void button4_Click(object sender, EventArgs e)
        {
            try
            {
                int nPort = Convert.ToInt32(textBox1.Text);

                uint l;
                if (m_bX64)
                    l = DlPortReadPortUlong_x64(nPort);
                else
                    l = DlPortReadPortUlong(nPort);

                textBox2.Text = l.ToString();
            }
            catch (Exception ex)
            {
                MessageBox.Show("An error occured:\n" + ex.Message);
            }
        }

        private void button5_Click(object sender, EventArgs e)
        {
            try
            {
                short sPort = Convert.ToInt16(textBox1.Text);
                ushort iData = Convert.ToUInt16(textBox2.Text);
                textBox2.Text = "";

                if (m_bX64)
                    DlPortWritePortUshort_x64(sPort, iData);
                else
                    DlPortWritePortUshort(sPort, iData);
            }
            catch (Exception ex)
            {
                MessageBox.Show("An error occured:\n" + ex.Message);
            }
        }

        private void button6_Click(object sender, EventArgs e)
        {
            try
            {
                int nPort = Convert.ToInt32(textBox1.Text);
                uint nData = Convert.ToUInt32(textBox2.Text);
                textBox2.Text = "";
                if (m_bX64)
                    DlPortWritePortUlong_x64(nPort, nData);
                else
                    DlPortWritePortUlong(nPort, nData);
            }
            catch (Exception ex)
            {
                MessageBox.Show("An error occured:\n" + ex.Message);
            }
        }

        private void Beep(uint freq)
        {
            if (m_bX64)
            {
                Out32_x64(0x43, 0xB6);
                Out32_x64(0x42, (byte)(freq & 0xFF));
                Out32_x64(0x42, (byte)(freq >> 9));
                System.Threading.Thread.Sleep(10);
                Out32_x64(0x61, (byte)(Convert.ToByte(Inp32_x64(0x61)) | 0x03));
            }
            else
            {
                Out32(0x43, 0xB6);
                Out32(0x42, (byte)(freq & 0xFF));
                Out32(0x42, (byte)(freq >> 9));
                System.Threading.Thread.Sleep(10);
                Out32(0x61, (byte)(Convert.ToByte(Inp32(0x61)) | 0x03));
               }
        }

        private void StopBeep()
        {
            if (m_bX64)
                Out32_x64(0x61, (byte)(Convert.ToByte(Inp32_x64(0x61)) & 0xFC));
            else
                Out32(0x61, (byte)(Convert.ToByte(Inp32(0x61)) & 0xFC));
        }

        private void CSharpExample_Load(object sender, EventArgs e)
        {
            button7_Click(this, null);
        }


        private void ThreadBeeper()
        {
            for (uint i = 440000; i < 500000; i += 1000)
            {
                uint freq = 1193180000 / i; // 440Hz
                Beep(freq);
            }
            StopBeep();
        }

        private void button7_Click(object sender, EventArgs e)
        {
            System.Threading.Thread t = new System.Threading.Thread(new System.Threading.ThreadStart(ThreadBeeper));
            t.Start();
        }
    }
}
```

`InpOut/InstallDriver/InstallDriver.cpp`:

```cpp
// InstallDriver.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "InstallDriver.h"
#include "..\inpout32.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

// The one and only application object
int APIENTRY _tWinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPTSTR    lpCmdLine,
                     int       nCmdShow)
{
	int nRetCode = 0;
	BOOL bResult = IsInpOutDriverOpen();

	if (IsXP64Bit())
	{
		if (bResult)
			MessageBox(NULL, _T("Successfully installed and opened\n64bit InpOut driver InpOutx64.sys."), _T("InpOut Installation"), 0);
		else
			MessageBox(NULL, _T("Unable to install or open the\n64bit InpOut driver InpOutx64.sys.\n\nPlease try running as Administrator"), _T("InpOut Installation"), 0);
	}
	else
	{
		if (bResult)
			MessageBox(NULL, _T("Successfully installed and opened\n32bit InpOut driver InpOut32.sys."), _T("InpOut Installation"), 0);
		else
			MessageBox(NULL, _T("Unable to install or open the\n32bit InpOut driver InpOut32.sys.\n\nPlease try running as Administrator"), _T("InpOut Installation"), 0);
	}
	return nRetCode;
}

```

`InpOut/InstallDriver/InstallDriver.h`:

```h
#pragma once

#include "resource.h"

```

`InpOut/InstallDriver/InstallDriver.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <!-- Identify the application security requirements. -->
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel
          level="requireAdministrator"
          uiAccess="false"/>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>

```

`InpOut/InstallDriver/InstallDriver.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "afxres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (U.K.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENG)
#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_UK
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,4,0,0
 PRODUCTVERSION 1,4,0,0
 FILEFLAGSMASK 0x17L
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x4L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "080904b0"
        BEGIN
            VALUE "CompanyName", "Highresolution Enterprises"
            VALUE "FileDescription", "InstallDriver Windows Vista/7 support application"
            VALUE "FileVersion", "1, 4, 0, 0"
            VALUE "InternalName", "InstallDriver"
            VALUE "LegalCopyright", "Copyright (C) 2007-2011 Highresolution Enterprises"
            VALUE "OriginalFilename", "InstallDriver.exe"
            VALUE "ProductName", "InstallDriver Application"
            VALUE "ProductVersion", "1, 4, 0, 0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x809, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE 
BEGIN
    IDS_APP_TITLE           "InstallDriver"
END

#endif    // English (U.K.) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`InpOut/InstallDriver/InstallDriver.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="8.00"
	Name="InstallDriver"
	ProjectGUID="{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}"
	RootNamespace="InstallDriver"
	SccProjectName="SAK"
	SccAuxPath="SAK"
	SccLocalPath="SAK"
	SccProvider="SAK"
	Keyword="Win32Proj"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			UseOfMFC="0"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="4"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="inpout32.lib"
				LinkIncremental="2"
				AdditionalLibraryDirectories="$(OutDir)"
				GenerateDebugInformation="true"
				SubSystem="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
				AdditionalManifestFiles="InstallDriver.manifest"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			UseOfMFC="0"
			UseOfATL="0"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS"
				RuntimeLibrary="0"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="inpout32.lib"
				LinkIncremental="1"
				AdditionalLibraryDirectories="$(OutDir)"
				GenerateDebugInformation="true"
				SubSystem="2"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
				AdditionalManifestFiles="InstallDriver.manifest"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath=".\InstallDriver.cpp"
				>
			</File>
			<File
				RelativePath=".\stdafx.cpp"
				>
				<FileConfiguration
					Name="Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath=".\InstallDriver.h"
				>
			</File>
			<File
				RelativePath=".\Resource.h"
				>
			</File>
			<File
				RelativePath=".\stdafx.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
			<File
				RelativePath=".\InstallDriver.manifest"
				>
			</File>
			<File
				RelativePath=".\InstallDriver.rc"
				>
			</File>
		</Filter>
		<File
			RelativePath=".\ReadMe.txt"
			>
		</File>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`InpOut/InstallDriver/ReadMe.txt`:

```txt
========================================================================
    CONSOLE APPLICATION : InstallDriver Project Overview
========================================================================

AppWizard has created this InstallDriver application for you.  

This file contains a summary of what you will find in each of the files that
make up your InstallDriver application.


InstallDriver.vcproj
    This is the main project file for VC++ projects generated using an Application Wizard. 
    It contains information about the version of Visual C++ that generated the file, and 
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

InstallDriver.cpp
    This is the main application source file.

/////////////////////////////////////////////////////////////////////////////
AppWizard has created the following resources:

InstallDriver.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
    Visual C++.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Visual C++ reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named InstallDriver.pch and a precompiled types file named StdAfx.obj.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" comments to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////

```

`InpOut/InstallDriver/Resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by InstallDriver.rc
//
#define IDR_MANIFEST			1
#define IDS_APP_TITLE			103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE	101
#define _APS_NEXT_COMMAND_VALUE		40001
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#endif
#endif

```

`InpOut/InstallDriver/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// InstallDriver.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`InpOut/InstallDriver/stdafx.h`:

```h
// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows XP or later.
#define WINVER 0x0501		// Change this to the appropriate value to target other versions of Windows.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows XP or later.                   
#define _WIN32_WINNT 0x0501	// Change this to the appropriate value to target other versions of Windows.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 6.0 or later.
#define _WIN32_IE 0x0600	// Change this to the appropriate value to target other versions of IE.
#endif

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
```

`InpOut/ReadMe.txt`:

```txt
InpOut32Drv Driver Interface DLL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Modified for x64 compatibility and built by Phillip Gibbons (Phil@highrez.co.uk).
See http://www.highrez.co.uk/Downloads/InpOut32 or the Highrez Forums (http://forums.highrez.co.uk) for information.
Many thanks to Red Fox UK for supporting the community and providing Driver signatures allowing Vista/7 x64 compatibility.



Based on the original written by Logix4U (www.logix4u.net).


Notes:

	The InpOut32 device driver supports writing to "old fashioned" hardware port addresses. 
	It does NOT support USB devices such as USB Parallel ports or even PCI parallel ports (as I am lead to believe).


	The device driver is installed at runtime. To do this however needs administrator privileges.
	On Vista & later, using UAC, you can run the InstallDriver.exe in the \Win32 folder to install the driver 
	appropriate for your OS. Doing so will request elevation and ask for your permission (or for the administrator 
	password). Once the driver is installed for the first time, it can then be used by any user *without* 
	administrator privileges


```

`InpOut/StdAfx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
//	inpout32drv.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`InpOut/StdAfx.h`:

```h
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7ACF5BF3_42A3_43EB_9034_6218487B5231__INCLUDED_)
#define AFX_STDAFX_H__7ACF5BF3_42A3_43EB_9034_6218487B5231__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#ifndef WINVER
#define WINVER 0x0400
#endif

#ifndef _WIN32_WINNT                
#define _WIN32_WINNT 0x0400
#endif						

#ifndef _WIN32_WINDOWS
#define _WIN32_WINDOWS 0x0410
#endif

#ifndef _WIN32_IE
#define _WIN32_IE 0x0600
#endif

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <tchar.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7ACF5BF3_42A3_43EB_9034_6218487B5231__INCLUDED_)

```

`InpOut/hwinterfacedrv.h`:

```h

#define IOCTL_READ_PORT_UCHAR	 -1673519100 //CTL_CODE(40000, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_PORT_UCHAR	 -1673519096 //CTL_CODE(40000, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_READ_PORT_USHORT	 -1673519092 //CTL_CODE(40000, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_PORT_USHORT	 -1673519088 //CTL_CODE(40000, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_READ_PORT_ULONG	 -1673519084 //CTL_CODE(40000, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_PORT_ULONG	 -1673519080 //CTL_CODE(40000, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WINIO_MAPPHYSTOLIN  -1673519076
#define IOCTL_WINIO_UNMAPPHYSADDR -1673519072

BOOL	_stdcall IsXP64Bit();
int		SystemVersion();
BOOL	DisableWOW64(PVOID* oldValue);
BOOL	RevertWOW64(PVOID* oldValue);

#pragma pack(push)
#pragma pack(1)

struct tagPhys32Struct
{
  HANDLE PhysicalMemoryHandle;
  SIZE_T dwPhysMemSizeInBytes;
  PVOID pvPhysAddress;
  PVOID pvPhysMemLin;
};

extern struct tagPhys32Struct Phys32Struct;

#pragma pack(pop)
```

`InpOut/inpout32.h`:

```h
#pragma once

//Functions exported from DLL.
//For easy inclusion is user projects.
//Original InpOut32 function support
void	_stdcall Out32(short PortAddress, short data);
short	_stdcall Inp32(short PortAddress);

//My extra functions for making life easy
BOOL	_stdcall IsInpOutDriverOpen();  //Returns TRUE if the InpOut driver was opened successfully
BOOL	_stdcall IsXP64Bit();			//Returns TRUE if the OS is 64bit (x64) Windows.

//DLLPortIO function support
UCHAR   _stdcall DlPortReadPortUchar (USHORT port);
void    _stdcall DlPortWritePortUchar(USHORT port, UCHAR Value);

USHORT  _stdcall DlPortReadPortUshort (USHORT port);
void    _stdcall DlPortWritePortUshort(USHORT port, USHORT Value);

ULONG	_stdcall DlPortReadPortUlong(ULONG port);
void	_stdcall DlPortWritePortUlong(ULONG port, ULONG Value);

//WinIO function support (Untested and probably does NOT work - esp. on x64!)
PBYTE	_stdcall MapPhysToLin(PBYTE pbPhysAddr, DWORD dwPhysSize, HANDLE *pPhysicalMemoryHandle);
BOOL	_stdcall UnmapPhysicalMemory(HANDLE PhysicalMemoryHandle, PBYTE pbLinAddr);
BOOL	_stdcall GetPhysLong(PBYTE pbPhysAddr, PDWORD pdwPhysVal);
BOOL	_stdcall SetPhysLong(PBYTE pbPhysAddr, DWORD dwPhysVal);






```

`InpOut/inpout32drv.cpp`:

```cpp
/***********************************************************************\
*                                                                       *
* InpOut32drv.cpp                                                       *
*                                                                       *
* The entry point for the InpOut DLL                                    *
* Provides the 32 and 64bit implementation of InpOut32 DLL to install   *
* and call the appropriate driver and write directly to hardware ports. *
*                                                                       *
* Written by Phillip Gibbons (Highrez.co.uk)                            *
* Based on orriginal, written by Logix4U (www.logix4u.net)              *
*                                                                       *
\***********************************************************************/

#include "stdafx.h"
#include <conio.h>
#include <stdlib.h>
#include <stdio.h>

#include "hwinterfacedrv.h"
#include "resource.h"

int inst32();
int inst64();
int start(LPCTSTR pszDriver);

//First, lets set the DRIVERNAME depending on our configuraiton.
#define DRIVERNAMEx64 _T("inpoutx64\0")
#define DRIVERNAMEi386 _T("inpout32\0")

char str[10];
int vv;

HANDLE hdriver=NULL;
TCHAR path[MAX_PATH];
HINSTANCE hmodule;
SECURITY_ATTRIBUTES sa;
int sysver;

int Opendriver(BOOL bX64);
void Closedriver(void);

BOOL APIENTRY DllMain( HINSTANCE  hModule, 
					  DWORD  ul_reason_for_call, 
					  LPVOID lpReserved
					  )
{
	hmodule = hModule;
	BOOL bx64 = IsXP64Bit();
	switch(ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		{
			sysver = SystemVersion();
			if(sysver==2)
			{
				Opendriver(bx64);
			}
		}

		break;
	case DLL_PROCESS_DETACH:
		{
			if(sysver==2)
			{
				Closedriver();
			}
		}
		break;
	}
	return TRUE;
}

/***********************************************************************/

void Closedriver(void)
{
	if (hdriver)
	{
		OutputDebugString(_T("Closing InpOut driver...\n"));
		CloseHandle(hdriver);
		hdriver=NULL;
	}
}

void _stdcall Out32(short PortAddress, short data)
{
	{
		switch(sysver)
		{
		case 1:
#ifdef _M_IX86
			_outp( PortAddress,data);	//Will ONLY compile on i386 architecture
#endif
			break;
		case 2:
			unsigned int error;
			DWORD BytesReturned;        
			BYTE Buffer[3]={NULL};
			unsigned short* pBuffer;
			pBuffer = (unsigned short *)&Buffer[0];
			*pBuffer = LOWORD(PortAddress);
			Buffer[2] = LOBYTE(data);

			error = DeviceIoControl(hdriver,
				IOCTL_WRITE_PORT_UCHAR,
				&Buffer,
				3,
				NULL,
				0,
				&BytesReturned,
				NULL);
			break;
		}
	}
}

/*********************************************************************/

short _stdcall Inp32(short PortAddress)
{
	{
		BYTE retval(0);
		switch(sysver)
		{
		case 1:
#ifdef _M_IX86
			retval = _inp(PortAddress);
#endif
			return retval;
			break;
		case 2:
			unsigned int error;
			DWORD BytesReturned;
			unsigned char Buffer[3]={NULL};
			unsigned short * pBuffer;
			pBuffer = (unsigned short *)&Buffer;
			*pBuffer = LOWORD(PortAddress);
			Buffer[2] = 0;
			error = DeviceIoControl(hdriver,
				IOCTL_READ_PORT_UCHAR,
				&Buffer,
				2,
				&Buffer,
				1,
				&BytesReturned,
				NULL);

			if (error==0)
			{
				DWORD dwError = GetLastError();
				TCHAR tszError[255];
				_stprintf_s(tszError, 255, _T("Error %d\n"), dwError);
				OutputDebugString(tszError);
			}

			//Do this to ensure only the first byte is returned, we dont really want to return a short as were only reading a byte.
			//but we also dont want to change the InpOut interface!
			UCHAR ucRes = (UCHAR)Buffer[0];
			return ucRes;

			break;
		}
	}
	return 0;
}

/*********************************************************************/

int Opendriver(BOOL bX64)
{
	OutputDebugString(_T("Attempting to open InpOut driver...\n"));
	TCHAR szFileName[MAX_PATH] = {NULL};
	_stprintf_s(szFileName, MAX_PATH, _T("\\\\.\\%s"), bX64 ? DRIVERNAMEx64 : DRIVERNAMEi386);

	hdriver = CreateFile(szFileName, 
		GENERIC_READ | GENERIC_WRITE, 
		0, 
		NULL,
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL);

	if(hdriver == INVALID_HANDLE_VALUE) 
	{
		if(start(bX64 ? DRIVERNAMEx64 : DRIVERNAMEi386))
		{
			if (bX64)
				inst64();	//Install the x64 driver
			else
				inst32();	//Install the i386 driver

			int nResult = start(bX64 ? DRIVERNAMEx64 : DRIVERNAMEi386);

			if (nResult == ERROR_SUCCESS)
			{
				hdriver = CreateFile(szFileName, 
					GENERIC_READ | GENERIC_WRITE, 
					0, 
					NULL,
					OPEN_EXISTING, 
					FILE_ATTRIBUTE_NORMAL, 
					NULL);

				if(hdriver != INVALID_HANDLE_VALUE) 
				{
					OutputDebugString(_T("Successfully opened "));
					OutputDebugString(bX64 ? DRIVERNAMEx64 : DRIVERNAMEi386);
					OutputDebugString(_T(" driver\n"));
					return 0;
				}
			}
			else
			{
				TCHAR szMsg[MAX_PATH] = {NULL};
				_stprintf_s(szMsg, MAX_PATH, _T("Unable to open %s driver. Error code %d.\n"), bX64 ? DRIVERNAMEx64 : DRIVERNAMEi386, nResult);
				OutputDebugString(szMsg);

				//RemoveDriver();
			}
		}
		return 1;
	}
	OutputDebugString(_T("Successfully opened "));
	OutputDebugString(bX64 ? DRIVERNAMEx64 : DRIVERNAMEi386);
	OutputDebugString(_T(" driver\n"));
	return 0;
}

/***********************************************************************/
int inst32()
{
	TCHAR szDriverSys[MAX_PATH];
	_tcscpy_s(szDriverSys, MAX_PATH, DRIVERNAMEi386);
	_tcscat_s(szDriverSys, MAX_PATH, _T(".sys\0"));
	
	SC_HANDLE  Mgr;
	SC_HANDLE  Ser;
	GetSystemDirectory(path, MAX_PATH);
	HRSRC hResource = FindResource(hmodule, MAKEINTRESOURCE(IDR_INPOUT32), _T("bin"));
	if(hResource)
	{
		HGLOBAL binGlob = LoadResource(hmodule, hResource);

		if(binGlob)
		{
			void *binData = LockResource(binGlob);

			if(binData)
			{
				HANDLE file;
				
				_tcscat_s(path, sizeof(path), _T("\\Drivers\\"));
				_tcscat_s(path, sizeof(path), szDriverSys);
			
				file = CreateFile(path,
					GENERIC_WRITE,
					0,
					NULL,
					CREATE_ALWAYS,
					0,
					NULL);

				if (file && file != INVALID_HANDLE_VALUE)
				{
					DWORD size, written;
					size = SizeofResource(hmodule, hResource);
					WriteFile(file, binData, size, &written, NULL);
					CloseHandle(file);
				}
				else
				{
					//Error
				}
			}
		}
	}

	Mgr = OpenSCManager (NULL, NULL,SC_MANAGER_ALL_ACCESS);
	if (Mgr == NULL)
	{							//No permission to create service
		if (GetLastError() == ERROR_ACCESS_DENIED) 
		{
			return 5;  // error access denied
		}
	}	
	else
	{
		TCHAR szFullPath[MAX_PATH] = _T("System32\\Drivers\\\0");
		_tcscat_s(szFullPath, MAX_PATH, szDriverSys);
		Ser = CreateService (Mgr,                      
			DRIVERNAMEi386,                        
			DRIVERNAMEi386,                        
			SERVICE_ALL_ACCESS,                
			SERVICE_KERNEL_DRIVER,             
			SERVICE_AUTO_START,               
			SERVICE_ERROR_NORMAL,               
			szFullPath,  
			NULL,                               
			NULL,                              
			NULL,                               
			NULL,                              
			NULL                               
			);
	}
	CloseServiceHandle(Ser);
	CloseServiceHandle(Mgr);

	return 0;
}

int inst64()
{
	TCHAR szDriverSys[MAX_PATH];
	_tcscpy_s(szDriverSys, MAX_PATH, DRIVERNAMEx64);
	_tcscat_s(szDriverSys, MAX_PATH, _T(".sys\0"));
	
	SC_HANDLE  Mgr;
	SC_HANDLE  Ser;
	GetSystemDirectory(path, MAX_PATH);
	HRSRC hResource = FindResource(hmodule, MAKEINTRESOURCE(IDR_INPOUTX64), _T("bin"));
	if(hResource)
	{
		HGLOBAL binGlob = LoadResource(hmodule, hResource);

		if(binGlob)
		{
			void *binData = LockResource(binGlob);

			if(binData)
			{
				HANDLE file;
				_tcscat_s(path, sizeof(path), _T("\\Drivers\\"));
				_tcscat_s(path, sizeof(path), szDriverSys);
			
				PVOID OldValue;
				DisableWOW64(&OldValue);
				file = CreateFile(path,
					GENERIC_WRITE,
					0,
					NULL,
					CREATE_ALWAYS,
					0,
					NULL);

				if(file && file != INVALID_HANDLE_VALUE)
				{
					DWORD size, written;

					size = SizeofResource(hmodule, hResource);
					WriteFile(file, binData, size, &written, NULL);
					CloseHandle(file);
				}
				else
				{
					//error
				}
				RevertWOW64(&OldValue);
			}
		}
	}

	Mgr = OpenSCManager (NULL, NULL,SC_MANAGER_ALL_ACCESS);
	if (Mgr == NULL)
	{							//No permission to create service
		if (GetLastError() == ERROR_ACCESS_DENIED) 
		{
			return 5;  // error access denied
		}
	}	
	else
	{
		TCHAR szFullPath[MAX_PATH] = _T("System32\\Drivers\\\0");
		_tcscat_s(szFullPath, MAX_PATH, szDriverSys);
		Ser = CreateService (Mgr,                      
			DRIVERNAMEx64,                        
			DRIVERNAMEx64,                        
			SERVICE_ALL_ACCESS,                
			SERVICE_KERNEL_DRIVER,             
			SERVICE_AUTO_START,               
			SERVICE_ERROR_NORMAL,               
			szFullPath,  
			NULL,                               
			NULL,                              
			NULL,                               
			NULL,                              
			NULL                               
			);
	}
	CloseServiceHandle(Ser);
	CloseServiceHandle(Mgr);

	return 0;
}

/**************************************************************************/
int start(LPCTSTR pszDriver)
{
	SC_HANDLE  Mgr;
	SC_HANDLE  Ser;

	Mgr = OpenSCManager (NULL, NULL,SC_MANAGER_ALL_ACCESS);

	if (Mgr == NULL)
	{							//No permission to create service
		if (GetLastError() == ERROR_ACCESS_DENIED) 
		{
			Mgr = OpenSCManager (NULL, NULL, GENERIC_READ);
			Ser = OpenService(Mgr, pszDriver, GENERIC_EXECUTE);
			if (Ser)
			{    // we have permission to start the service
				if(!StartService(Ser,0,NULL))
				{
					CloseServiceHandle (Ser);
					return 4; // we could open the service but unable to start
				}
			}
		}
	}
	else
	{// Successfuly opened Service Manager with full access
		Ser = OpenService(Mgr, pszDriver, SERVICE_ALL_ACCESS);
		if (Ser)
		{
			if(!StartService(Ser,0,NULL))
			{
				CloseServiceHandle (Ser);
				return 3; // opened the Service handle with full access permission, but unable to start
			}
			else
			{
				CloseServiceHandle (Ser);
				return 0;
			}
		}
	}
	return 1;
}

BOOL _stdcall IsInpOutDriverOpen()
{
	sysver = SystemVersion();
	if (sysver==2)
	{
		if (hdriver!=INVALID_HANDLE_VALUE && hdriver != NULL)
			return TRUE;
	}
	else if (sysver==1)
	{
		return TRUE;
	}
	return FALSE;
}

UCHAR _stdcall DlPortReadPortUchar (USHORT port)
{
	UCHAR retval(0);
	switch(sysver)
	{
	case 1:
#ifdef _M_IX86
		retval = _inp((USHORT)port);
#endif
		return retval;
		break;
	case 2:
		unsigned int error;
		DWORD BytesReturned;
		BYTE Buffer[3]={NULL};
		unsigned short * pBuffer;
		pBuffer = (unsigned short *)&Buffer;
		*pBuffer = port;
		Buffer[2] = 0;
		error = DeviceIoControl(hdriver,
			IOCTL_READ_PORT_UCHAR,
			&Buffer,
			sizeof(Buffer),
			&Buffer,
			sizeof(Buffer),
			&BytesReturned,
			NULL);

		return((UCHAR)Buffer[0]);

		break;
	}
	return 0;
}

void _stdcall DlPortWritePortUchar (USHORT port, UCHAR Value)
{
	switch(sysver)
	{
	case 1:
#ifdef _M_IX86
		_outp((UINT)port,Value);	//Will ONLY compile on i386 architecture
#endif
		break;
	case 2:
		unsigned int error;
		DWORD BytesReturned;        
		BYTE Buffer[3]={NULL};
		unsigned short * pBuffer;
		pBuffer = (unsigned short *)&Buffer[0];
		*pBuffer = port;
		Buffer[2] = Value;

		error = DeviceIoControl(hdriver,
			IOCTL_WRITE_PORT_UCHAR,
			&Buffer,
			sizeof(Buffer),
			NULL,
			0,
			&BytesReturned,
			NULL);
		break;
	}
}

USHORT _stdcall DlPortReadPortUshort (USHORT port)
{
	if (sysver!=2)
		return 0;

	ULONG retval(0);
	unsigned int error;
	DWORD BytesReturned;
	unsigned short sPort=port;
	error = DeviceIoControl(hdriver,
		IOCTL_READ_PORT_USHORT,
		&sPort,
		sizeof(unsigned short),
		&sPort,
		sizeof(unsigned short),
		&BytesReturned,
		NULL);
	return(sPort);
}

void _stdcall DlPortWritePortUshort (USHORT port, USHORT Value)
{
	if (sysver!=2)
		return;

	unsigned int error;
	DWORD BytesReturned;        
	BYTE Buffer[5]={NULL};
	unsigned short * pBuffer;
	pBuffer = (unsigned short *)&Buffer[0];
	*pBuffer = LOWORD(port);
	*(pBuffer+1) = Value;

	error = DeviceIoControl(hdriver,
		IOCTL_WRITE_PORT_USHORT,
		&Buffer,
		sizeof(Buffer),
		NULL,
		0,
		&BytesReturned,
		NULL);
}

ULONG _stdcall DlPortReadPortUlong(ULONG port)
{
	if (sysver!=2)
		return 0;

	ULONG retval(0);
	unsigned int error;
	DWORD BytesReturned;
	unsigned long lPort=port;

    PULONG  ulBuffer;
    ulBuffer = (PULONG)&lPort;
	ULONG test = ulBuffer[0];

	error = DeviceIoControl(hdriver,
		IOCTL_READ_PORT_ULONG,
		&lPort,
		sizeof(unsigned long),
		&lPort,
		sizeof(unsigned long),
		&BytesReturned,
		NULL);
	return(lPort);
}

void _stdcall DlPortWritePortUlong (ULONG port, ULONG Value)
{
	if (sysver!=2)
		return;

	unsigned int error;
	DWORD BytesReturned;        
	BYTE Buffer[8] = {NULL};
	unsigned long* pBuffer;
	pBuffer = (unsigned long*)&Buffer[0];
	*pBuffer = port;
	*(pBuffer+1) = Value;

	error = DeviceIoControl(hdriver,
		IOCTL_WRITE_PORT_ULONG,
		&Buffer,
		sizeof(Buffer),
		NULL,
		0,
		&BytesReturned,
		NULL);
}


// Support functions for WinIO
PBYTE _stdcall MapPhysToLin(PBYTE pbPhysAddr, DWORD dwPhysSize, HANDLE *pPhysicalMemoryHandle)
{
	PBYTE pbLinAddr;
	tagPhys32Struct Phys32Struct;
	DWORD dwBytesReturned;

	if (sysver!=2)
		return false;

	Phys32Struct.dwPhysMemSizeInBytes = dwPhysSize;
	Phys32Struct.pvPhysAddress = pbPhysAddr;

	if (!DeviceIoControl(hdriver, IOCTL_WINIO_MAPPHYSTOLIN, &Phys32Struct,
		sizeof(tagPhys32Struct), &Phys32Struct, sizeof(tagPhys32Struct),
		&dwBytesReturned, NULL))
		return NULL;
	else
	{
#ifdef _M_X64
		pbLinAddr = (PBYTE)((LONGLONG)Phys32Struct.pvPhysMemLin + (LONGLONG)pbPhysAddr - (LONGLONG)Phys32Struct.pvPhysAddress);
#else
		pbLinAddr = (PBYTE)((DWORD)Phys32Struct.pvPhysMemLin + (DWORD)pbPhysAddr - (DWORD)Phys32Struct.pvPhysAddress);
#endif
		*pPhysicalMemoryHandle = Phys32Struct.PhysicalMemoryHandle;
	}
	return pbLinAddr;
}


BOOL _stdcall UnmapPhysicalMemory(HANDLE PhysicalMemoryHandle, PBYTE pbLinAddr)
{
	tagPhys32Struct Phys32Struct;
	DWORD dwBytesReturned;

	if (sysver!=2)
		return false;

	Phys32Struct.PhysicalMemoryHandle = PhysicalMemoryHandle;
	Phys32Struct.pvPhysMemLin = pbLinAddr;

	if (!DeviceIoControl(hdriver, IOCTL_WINIO_UNMAPPHYSADDR, &Phys32Struct,
		sizeof(tagPhys32Struct), NULL, 0, &dwBytesReturned, NULL))
		return false;

	return true;
}

BOOL _stdcall GetPhysLong(PBYTE pbPhysAddr, PDWORD pdwPhysVal)
{
	PDWORD pdwLinAddr;
	HANDLE PhysicalMemoryHandle;

	if (sysver!=2)
		return false;

	pdwLinAddr = (PDWORD)MapPhysToLin(pbPhysAddr, 4, &PhysicalMemoryHandle);
	if (pdwLinAddr == NULL)
		return false;

	*pdwPhysVal = *pdwLinAddr;
	UnmapPhysicalMemory(PhysicalMemoryHandle, (PBYTE)pdwLinAddr);
	return true;
}


BOOL _stdcall SetPhysLong(PBYTE pbPhysAddr, DWORD dwPhysVal)
{
	PDWORD pdwLinAddr;
	HANDLE PhysicalMemoryHandle;
	if (sysver!=2)
		return false;

	pdwLinAddr = (PDWORD)MapPhysToLin(pbPhysAddr, 4, &PhysicalMemoryHandle);
	if (pdwLinAddr == NULL)
		return false;

	*pdwLinAddr = dwPhysVal;
	UnmapPhysicalMemory(PhysicalMemoryHandle, (PBYTE)pdwLinAddr);
	return true;
}

```

`InpOut/inpout32drv.def`:

```def
EXPORTS

Inp32				  @1
Out32				  @2
IsInpOutDriverOpen	  @3

DlPortReadPortUchar   @4
DlPortWritePortUchar  @5
DlPortReadPortUshort  @6
DlPortWritePortUshort @7
DlPortReadPortUlong   @8
DlPortWritePortUlong  @9
IsXP64Bit			  @10

MapPhysToLin		  @11
UnmapPhysicalMemory	  @12
GetPhysLong			  @13
SetPhysLong			  @14
```

`InpOut/inpout32drv.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "afxres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (U.S.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,5,0,0
 PRODUCTVERSION 1,5,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x21L
#else
 FILEFLAGS 0x20L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "080004b0"
        BEGIN
            VALUE "Comments", "Includes signed x64 drivers for Vista compatibility."
            VALUE "CompanyName", "Highresolution Enterprises"
            VALUE "FileDescription", "inpout32/64"
            VALUE "FileVersion", "1, 5, 0, 0"
            VALUE "InternalName", "inpout32"
            VALUE "LegalCopyright", "Freeware"
            VALUE "LegalTrademarks", "Copyright © 2008-2011 Highresolution Enterprises. Portions Copyright Logix4U"
            VALUE "OriginalFilename", "inpout32.dll"
            VALUE "ProductName", "inpout32"
            VALUE "ProductVersion", "1, 5, 0, 0"
            VALUE "SpecialBuild", "x64 Compatible build\r\nIncludes basic DLPortIO Compatibility\r\nIncludes signed drivers (Thanks to Red Fox UK) for Vista x64 compatiblity.\r\n"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x800, 1200
    END
END

#endif    // English (U.S.) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Neutral (Sys. Default) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEUSD)
#ifdef _WIN32
LANGUAGE LANG_NEUTRAL, SUBLANG_SYS_DEFAULT
#pragma code_page(1252)
#endif //_WIN32

/////////////////////////////////////////////////////////////////////////////
//
// BIN
//

IDR_INPOUT32            BIN                     "inpout32.sys"
IDR_INPOUTX64           BIN                     "inpoutx64.sys"
#endif    // Neutral (Sys. Default) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`InpOut/inpout32drv.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 9.00
# Visual Studio 2005
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "inpout32drv", "inpout32drv.vcproj", "{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "InstallDriver", "InstallDriver\InstallDriver.vcproj", "{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}"
	ProjectSection(ProjectDependencies) = postProject
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3} = {18AEFF0B-D208-45B0-88E1-7057B9BA78F3}
	EndProjectSection
EndProject
Project("{F184B08F-C81C-45F6-A57F-5ABD9991F28F}") = "InpOut32.VB.Net", "InpOut32.Net\InpOut32.VB.Net\InpOut32.VB.Net.vbproj", "{F90F25E7-E912-4948-B9CE-168FFA3014C8}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "InpOut32.CSharp.Net", "InpOut32.Net\InpOut32.CSharp.Net\InpOut32.CSharp.Net.csproj", "{784B3C36-7CAD-4B06-82A5-E60D17193F27}"
EndProject
Global
	GlobalSection(SourceCodeControl) = preSolution
		SccNumberOfProjects = 5
		SccLocalPath0 = .
		SccProjectUniqueName1 = inpout32drv.vcproj
		SccLocalPath1 = .
		SccProjectUniqueName2 = InstallDriver\\InstallDriver.vcproj
		SccLocalPath2 = .
		SccProjectFilePathRelativizedFromConnection2 = InstallDriver\\
		SccProjectUniqueName3 = InpOut32.Net\\InpOut32.VB.Net\\InpOut32.VB.Net.vbproj
		SccLocalPath3 = .
		SccProjectFilePathRelativizedFromConnection3 = InpOut32.Net\\InpOut32.VB.Net\\
		SccProjectUniqueName4 = InpOut32.Net\\InpOut32.CSharp.Net\\InpOut32.CSharp.Net.csproj
		SccProjectName4 = \u0022$/inpout32drv.root/inpout32drv/InpOut32.Net/InpOut32.CSharp.Net\u0022,\u0020DHHAAAAA
		SccLocalPath4 = InpOut32.Net\\InpOut32.CSharp.Net
	EndGlobalSection
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|Mixed Platforms = Debug|Mixed Platforms
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Any CPU = Release|Any CPU
		Release|Mixed Platforms = Release|Mixed Platforms
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Debug|Any CPU.ActiveCfg = Debug|x64
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Debug|Win32.ActiveCfg = Debug|Win32
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Debug|Win32.Build.0 = Debug|Win32
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Debug|x64.ActiveCfg = Debug|x64
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Debug|x64.Build.0 = Debug|x64
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Release|Any CPU.ActiveCfg = Release|x64
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Release|Mixed Platforms.ActiveCfg = Release|x64
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Release|Mixed Platforms.Build.0 = Release|x64
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Release|Win32.ActiveCfg = Release|Win32
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Release|Win32.Build.0 = Release|Win32
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Release|x64.ActiveCfg = Release|x64
		{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}.Release|x64.Build.0 = Release|x64
		{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}.Debug|Win32.ActiveCfg = Debug|Win32
		{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}.Debug|Win32.Build.0 = Debug|Win32
		{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}.Debug|x64.ActiveCfg = Debug|Win32
		{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}.Release|Any CPU.ActiveCfg = Release|Win32
		{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}.Release|Mixed Platforms.Build.0 = Release|Win32
		{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}.Release|Win32.ActiveCfg = Release|Win32
		{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}.Release|Win32.Build.0 = Release|Win32
		{233B1347-4B15-42DC-AC23-C2FE2ABEAF54}.Release|x64.ActiveCfg = Release|Win32
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Debug|Win32.Build.0 = Debug|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Debug|x64.ActiveCfg = Debug|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Debug|x64.Build.0 = Debug|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Release|Any CPU.Build.0 = Release|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Release|Win32.ActiveCfg = Release|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Release|Win32.Build.0 = Release|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Release|x64.ActiveCfg = Release|Any CPU
		{F90F25E7-E912-4948-B9CE-168FFA3014C8}.Release|x64.Build.0 = Release|Any CPU
		{784B3C36-7CAD-4B06-82A5-E60D17193F27}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{784B3C36-7CAD-4B06-82A5-E60D17193F27}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{784B3C36-7CAD-4B06-82A5-E60D17193F27}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{784B3C36-7CAD-4B06-82A5-E60D17193F27}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{784B3C36-7CAD-4B06-82A5-E60D17193F27}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{784B3C36-7CAD-4B06-82A5-E60D17193F27}.Debug|x64.ActiveCfg = Debug|Any CPU
		{784B3C36-7CAD-4B06-82A5-E60D17193F27}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{784B3C36-7CAD-4B06-82A5-E60D17193F27}.Release|Any CPU.Build.0 = Release|Any CPU
		{784B3C36-7CAD-4B06-82A5-E60D17193F27}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{784B3C36-7CAD-4B06-82A5-E60D17193F27}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{784B3C36-7CAD-4B06-82A5-E60D17193F27}.Release|Win32.ActiveCfg = Release|Any CPU
		{784B3C36-7CAD-4B06-82A5-E60D17193F27}.Release|x64.ActiveCfg = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`InpOut/inpout32drv.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="8.00"
	Name="inpout32drv"
	ProjectGUID="{18AEFF0B-D208-45B0-88E1-7057B9BA78F3}"
	RootNamespace="inpout32drv"
	SccProjectName="SAK"
	SccAuxPath="SAK"
	SccLocalPath="SAK"
	SccProvider="SAK"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="2"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				PreprocessorDefinitions="_DEBUG"
				MkTypLibCompatible="true"
				SuppressStartupBanner="true"
				TargetEnvironment="1"
				TypeLibraryName=".\Debug/inpout32drv.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="4"
				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;INPOUT32DRV_EXPORTS"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				UsePrecompiledHeader="2"
				PrecompiledHeaderThrough="stdafx.h"
				PrecompiledHeaderFile="$(IntDir)/inpout32.pch"
				AssemblerListingLocation="$(IntDir)\"
				ObjectFile="$(IntDir)\"
				ProgramDataBaseFileName="$(IntDir)\"
				WarningLevel="3"
				SuppressStartupBanner="true"
				DebugInformationFormat="4"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
				Culture="1033"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)/inpout32.dll"
				LinkIncremental="2"
				SuppressStartupBanner="true"
				ModuleDefinitionFile=".\inpout32drv.def"
				GenerateDebugInformation="true"
				ProgramDatabaseFile="$(OutDir)/inpout32.pdb"
				ImportLibrary="$(OutDir)/inpout32.lib"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
				SuppressStartupBanner="true"
				OutputFile=".\Debug/inpout32drv.bsc"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
				Description="Copy DLL to .NET Demo Project"
				CommandLine="copy &quot;$(TargetPath)&quot; &quot;$(SolutionDir)\InpOut32.Net\InpOut32.CSharp.Net\bin\$(ConfigurationName)\$(TargetFileName)&quot;&#x0D;&#x0A;copy &quot;$(TargetPath)&quot; &quot;$(SolutionDir)\InpOut32.Net\InpOut32.VB.Net\bin\$(ConfigurationName)\$(TargetFileName)&quot;&#x0D;&#x0A;"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="2"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				PreprocessorDefinitions="_DEBUG"
				MkTypLibCompatible="true"
				SuppressStartupBanner="true"
				TargetEnvironment="3"
				TypeLibraryName=".\Debug/inpout32drv.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="4"
				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;INPOUT32DRV_EXPORTS"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				UsePrecompiledHeader="2"
				PrecompiledHeaderThrough="stdafx.h"
				PrecompiledHeaderFile="$(IntDir)/inpoutx64.pch"
				AssemblerListingLocation="$(IntDir)/"
				ObjectFile="$(IntDir)/"
				ProgramDataBaseFileName="$(IntDir)/"
				WarningLevel="3"
				SuppressStartupBanner="true"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
				Culture="1033"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)/inpoutx64.dll"
				LinkIncremental="2"
				SuppressStartupBanner="true"
				ModuleDefinitionFile=".\inpout32drv.def"
				GenerateDebugInformation="true"
				ProgramDatabaseFile="$(OutDir)/inpoutx64.pdb"
				ImportLibrary="$(OutDir)/inpoutx64.lib"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
				SuppressStartupBanner="true"
				OutputFile=".\Debug/inpout32drv.bsc"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
				Description="Copy DLL to .NET Demo Project"
				CommandLine="copy &quot;$(TargetPath)&quot; &quot;$(SolutionDir)\InpOut32.Net\InpOut32.CSharp.Net\bin\$(ConfigurationName)\$(TargetFileName)&quot;&#x0D;&#x0A;copy &quot;$(TargetPath)&quot; &quot;$(SolutionDir)\InpOut32.Net\InpOut32.VB.Net\bin\$(ConfigurationName)\$(TargetFileName)&quot;&#x0D;&#x0A;"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="2"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				PreprocessorDefinitions="NDEBUG"
				MkTypLibCompatible="true"
				SuppressStartupBanner="true"
				TargetEnvironment="1"
				TypeLibraryName=".\Release/inpout32drv.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="2"
				InlineFunctionExpansion="1"
				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;INPOUT32DRV_EXPORTS"
				StringPooling="true"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="2"
				PrecompiledHeaderThrough="stdafx.h"
				PrecompiledHeaderFile="$(IntDir)/inpout32.pch"
				AssemblerListingLocation="$(IntDir)\"
				ObjectFile="$(IntDir)\"
				ProgramDataBaseFileName="$(IntDir)\"
				WarningLevel="3"
				SuppressStartupBanner="true"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
				Culture="1033"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)/inpout32.dll"
				LinkIncremental="1"
				SuppressStartupBanner="true"
				ModuleDefinitionFile=".\inpout32drv.def"
				ProgramDatabaseFile="$(OutDir)/inpout32.pdb"
				ImportLibrary="$(OutDir)/inpout32.lib"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
				SuppressStartupBanner="true"
				OutputFile=".\Release/inpout32drv.bsc"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
				Description="Copy DLL to .NET Demo Project"
				CommandLine="copy &quot;$(TargetPath)&quot; &quot;$(SolutionDir)\InpOut32.Net\InpOut32.CSharp.Net\bin\$(ConfigurationName)\$(TargetFileName)&quot;&#x0D;&#x0A;copy &quot;$(TargetPath)&quot; &quot;$(SolutionDir)\InpOut32.Net\InpOut32.VB.Net\bin\$(ConfigurationName)\$(TargetFileName)&quot;&#x0D;&#x0A;"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="2"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				PreprocessorDefinitions="NDEBUG"
				MkTypLibCompatible="true"
				SuppressStartupBanner="true"
				TargetEnvironment="3"
				TypeLibraryName=".\Release/inpout32drv.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="2"
				InlineFunctionExpansion="1"
				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;INPOUT32DRV_EXPORTS"
				StringPooling="true"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="2"
				PrecompiledHeaderThrough="stdafx.h"
				PrecompiledHeaderFile="$(IntDir)/inpoutx64.pch"
				AssemblerListingLocation="$(IntDir)/"
				ObjectFile="$(IntDir)/"
				ProgramDataBaseFileName="$(IntDir)/"
				WarningLevel="3"
				SuppressStartupBanner="true"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
				Culture="1033"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)/inpoutx64.dll"
				LinkIncremental="1"
				SuppressStartupBanner="true"
				ModuleDefinitionFile=".\inpout32drv.def"
				ProgramDatabaseFile="$(OutDir)/inpoutx64.pdb"
				ImportLibrary="$(OutDir)/inpoutx64.lib"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
				SuppressStartupBanner="true"
				OutputFile=".\Release/inpout32drv.bsc"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
				Description="Copy DLL to .NET Demo Project"
				CommandLine="copy &quot;$(TargetPath)&quot; &quot;$(SolutionDir)\InpOut32.Net\InpOut32.CSharp.Net\bin\$(ConfigurationName)\$(TargetFileName)&quot;&#x0D;&#x0A;copy &quot;$(TargetPath)&quot; &quot;$(SolutionDir)\InpOut32.Net\InpOut32.VB.Net\bin\$(ConfigurationName)\$(TargetFileName)&quot;&#x0D;&#x0A;"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
			>
			<File
				RelativePath="inpout32drv.cpp"
				>
				<FileConfiguration
					Name="Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						PreprocessorDefinitions=""
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Debug|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						PreprocessorDefinitions=""
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						PreprocessorDefinitions=""
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						PreprocessorDefinitions=""
					/>
				</FileConfiguration>
			</File>
			<File
				RelativePath="inpout32drv.def"
				>
			</File>
			<File
				RelativePath="inpout32drv.rc"
				>
				<FileConfiguration
					Name="Debug|Win32"
					>
					<Tool
						Name="VCResourceCompilerTool"
						PreprocessorDefinitions=""
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Debug|x64"
					>
					<Tool
						Name="VCResourceCompilerTool"
						PreprocessorDefinitions=""
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCResourceCompilerTool"
						PreprocessorDefinitions=""
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|x64"
					>
					<Tool
						Name="VCResourceCompilerTool"
						PreprocessorDefinitions=""
					/>
				</FileConfiguration>
			</File>
			<File
				RelativePath="osversion.cpp"
				>
				<FileConfiguration
					Name="Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						PreprocessorDefinitions=""
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Debug|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						PreprocessorDefinitions=""
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						PreprocessorDefinitions=""
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						PreprocessorDefinitions=""
					/>
				</FileConfiguration>
			</File>
			<File
				RelativePath="StdAfx.cpp"
				>
				<FileConfiguration
					Name="Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						PreprocessorDefinitions=""
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Debug|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						PreprocessorDefinitions=""
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						PreprocessorDefinitions=""
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						PreprocessorDefinitions=""
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl"
			>
			<File
				RelativePath="hwinterfacedrv.h"
				>
			</File>
			<File
				RelativePath=".\inpout32.h"
				>
			</File>
			<File
				RelativePath=".\resource.h"
				>
			</File>
			<File
				RelativePath="StdAfx.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
			>
		</Filter>
		<File
			RelativePath=".\inpout32.sys"
			>
		</File>
		<File
			RelativePath=".\inpoutx64.sys"
			>
		</File>
		<File
			RelativePath="ReadMe.txt"
			>
		</File>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`InpOut/license.txt`:

```txt
Copyright (c) <2003-2015> Phil Gibbons <www.highrez.co.uk>
Portions Copyright (c) <2000> <logix4u.net>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:



The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.



THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
```

`InpOut/osversion.cpp`:

```cpp
#include "stdafx.h"
#include "hwinterfacedrv.h"

typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
typedef BOOL (WINAPI *LPFN_WOW64DISABLE) (PVOID*);
typedef BOOL (WINAPI *LPFN_WOW64REVERT) (PVOID);

LPFN_ISWOW64PROCESS	fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(GetModuleHandle(_T("kernel32")),"IsWow64Process");
LPFN_WOW64DISABLE	fnWow64Disable	 = (LPFN_WOW64DISABLE)GetProcAddress(GetModuleHandle(_T("kernel32")),"Wow64DisableWow64FsRedirection");
LPFN_WOW64REVERT	fnWow64Revert	 = (LPFN_WOW64REVERT)GetProcAddress(GetModuleHandle(_T("kernel32")),"Wow64RevertWow64FsRedirection");

//Purpose: Return TRUE if we are running in WOW64 (i.e. a 32bit process on XP x64 edition)
BOOL _stdcall IsXP64Bit()
{
#ifdef _M_X64
	return TRUE;	//Urrr if its a x64 build of the DLL, we MUST be running on X64 nativly!
#endif

    BOOL bIsWow64 = FALSE;
     if (NULL != fnIsWow64Process)
    {
        if (!fnIsWow64Process(GetCurrentProcess(),&bIsWow64))
        {
            // handle error
        }
    }
    return bIsWow64;
}

BOOL DisableWOW64(PVOID* oldValue)
{
#ifdef _M_X64
	return TRUE;		// If were 64b under x64, we dont wanna do anything!
#endif
	return fnWow64Disable(oldValue);
}

BOOL RevertWOW64(PVOID* oldValue)
{
#ifdef _M_X64
	return TRUE;		// If were 64b under x64, we dont wanna do anything!
#endif
	return fnWow64Revert (oldValue);
}

int SystemVersion()
{   
	OSVERSIONINFOEX osvi;
	BOOL bOsVersionInfoEx;

	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

	if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi)) )
	{
		osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

		if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) )
			return 0;  
	}

	switch (osvi.dwPlatformId)
	{      
	case VER_PLATFORM_WIN32_NT:

		return 2;		//WINNT

		break;

	case VER_PLATFORM_WIN32_WINDOWS:

		return 1;		//WIN9X

		break;

	}   
	return 0; 
}

```

`InpOut/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by inpout32drv.rc
//
#define IDR_BIN1                        101
#define IDR_INPOUT32                    101
#define IDR_INPOUTX64		            104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`LICENSE`:

```
Mozilla Public License Version 2.0
==================================

1. Definitions
--------------

1.1. "Contributor"
    means each individual or legal entity that creates, contributes to
    the creation of, or owns Covered Software.

1.2. "Contributor Version"
    means the combination of the Contributions of others (if any) used
    by a Contributor and that particular Contributor's Contribution.

1.3. "Contribution"
    means Covered Software of a particular Contributor.

1.4. "Covered Software"
    means Source Code Form to which the initial Contributor has attached
    the notice in Exhibit A, the Executable Form of such Source Code
    Form, and Modifications of such Source Code Form, in each case
    including portions thereof.

1.5. "Incompatible With Secondary Licenses"
    means

    (a) that the initial Contributor has attached the notice described
        in Exhibit B to the Covered Software; or

    (b) that the Covered Software was made available under the terms of
        version 1.1 or earlier of the License, but not also under the
        terms of a Secondary License.

1.6. "Executable Form"
    means any form of the work other than Source Code Form.

1.7. "Larger Work"
    means a work that combines Covered Software with other material, in
    a separate file or files, that is not Covered Software.

1.8. "License"
    means this document.

1.9. "Licensable"
    means having the right to grant, to the maximum extent possible,
    whether at the time of the initial grant or subsequently, any and
    all of the rights conveyed by this License.

1.10. "Modifications"
    means any of the following:

    (a) any file in Source Code Form that results from an addition to,
        deletion from, or modification of the contents of Covered
        Software; or

    (b) any new file in Source Code Form that contains any Covered
        Software.

1.11. "Patent Claims" of a Contributor
    means any patent claim(s), including without limitation, method,
    process, and apparatus claims, in any patent Licensable by such
    Contributor that would be infringed, but for the grant of the
    License, by the making, using, selling, offering for sale, having
    made, import, or transfer of either its Contributions or its
    Contributor Version.

1.12. "Secondary License"
    means either the GNU General Public License, Version 2.0, the GNU
    Lesser General Public License, Version 2.1, the GNU Affero General
    Public License, Version 3.0, or any later versions of those
    licenses.

1.13. "Source Code Form"
    means the form of the work preferred for making modifications.

1.14. "You" (or "Your")
    means an individual or a legal entity exercising rights under this
    License. For legal entities, "You" includes any entity that
    controls, is controlled by, or is under common control with You. For
    purposes of this definition, "control" means (a) the power, direct
    or indirect, to cause the direction or management of such entity,
    whether by contract or otherwise, or (b) ownership of more than
    fifty percent (50%) of the outstanding shares or beneficial
    ownership of such entity.

2. License Grants and Conditions
--------------------------------

2.1. Grants

Each Contributor hereby grants You a world-wide, royalty-free,
non-exclusive license:

(a) under intellectual property rights (other than patent or trademark)
    Licensable by such Contributor to use, reproduce, make available,
    modify, display, perform, distribute, and otherwise exploit its
    Contributions, either on an unmodified basis, with Modifications, or
    as part of a Larger Work; and

(b) under Patent Claims of such Contributor to make, use, sell, offer
    for sale, have made, import, and otherwise transfer either its
    Contributions or its Contributor Version.

2.2. Effective Date

The licenses granted in Section 2.1 with respect to any Contribution
become effective for each Contribution on the date the Contributor first
distributes such Contribution.

2.3. Limitations on Grant Scope

The licenses granted in this Section 2 are the only rights granted under
this License. No additional rights or licenses will be implied from the
distribution or licensing of Covered Software under this License.
Notwithstanding Section 2.1(b) above, no patent license is granted by a
Contributor:

(a) for any code that a Contributor has removed from Covered Software;
    or

(b) for infringements caused by: (i) Your and any other third party's
    modifications of Covered Software, or (ii) the combination of its
    Contributions with other software (except as part of its Contributor
    Version); or

(c) under Patent Claims infringed by Covered Software in the absence of
    its Contributions.

This License does not grant any rights in the trademarks, service marks,
or logos of any Contributor (except as may be necessary to comply with
the notice requirements in Section 3.4).

2.4. Subsequent Licenses

No Contributor makes additional grants as a result of Your choice to
distribute the Covered Software under a subsequent version of this
License (see Section 10.2) or under the terms of a Secondary License (if
permitted under the terms of Section 3.3).

2.5. Representation

Each Contributor represents that the Contributor believes its
Contributions are its original creation(s) or it has sufficient rights
to grant the rights to its Contributions conveyed by this License.

2.6. Fair Use

This License is not intended to limit any rights You have under
applicable copyright doctrines of fair use, fair dealing, or other
equivalents.

2.7. Conditions

Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
in Section 2.1.

3. Responsibilities
-------------------

3.1. Distribution of Source Form

All distribution of Covered Software in Source Code Form, including any
Modifications that You create or to which You contribute, must be under
the terms of this License. You must inform recipients that the Source
Code Form of the Covered Software is governed by the terms of this
License, and how they can obtain a copy of this License. You may not
attempt to alter or restrict the recipients' rights in the Source Code
Form.

3.2. Distribution of Executable Form

If You distribute Covered Software in Executable Form then:

(a) such Covered Software must also be made available in Source Code
    Form, as described in Section 3.1, and You must inform recipients of
    the Executable Form how they can obtain a copy of such Source Code
    Form by reasonable means in a timely manner, at a charge no more
    than the cost of distribution to the recipient; and

(b) You may distribute such Executable Form under the terms of this
    License, or sublicense it under different terms, provided that the
    license for the Executable Form does not attempt to limit or alter
    the recipients' rights in the Source Code Form under this License.

3.3. Distribution of a Larger Work

You may create and distribute a Larger Work under terms of Your choice,
provided that You also comply with the requirements of this License for
the Covered Software. If the Larger Work is a combination of Covered
Software with a work governed by one or more Secondary Licenses, and the
Covered Software is not Incompatible With Secondary Licenses, this
License permits You to additionally distribute such Covered Software
under the terms of such Secondary License(s), so that the recipient of
the Larger Work may, at their option, further distribute the Covered
Software under the terms of either this License or such Secondary
License(s).

3.4. Notices

You may not remove or alter the substance of any license notices
(including copyright notices, patent notices, disclaimers of warranty,
or limitations of liability) contained within the Source Code Form of
the Covered Software, except that You may alter any license notices to
the extent required to remedy known factual inaccuracies.

3.5. Application of Additional Terms

You may choose to offer, and to charge a fee for, warranty, support,
indemnity or liability obligations to one or more recipients of Covered
Software. However, You may do so only on Your own behalf, and not on
behalf of any Contributor. You must make it absolutely clear that any
such warranty, support, indemnity, or liability obligation is offered by
You alone, and You hereby agree to indemnify every Contributor for any
liability incurred by such Contributor as a result of warranty, support,
indemnity or liability terms You offer. You may include additional
disclaimers of warranty and limitations of liability specific to any
jurisdiction.

4. Inability to Comply Due to Statute or Regulation
---------------------------------------------------

If it is impossible for You to comply with any of the terms of this
License with respect to some or all of the Covered Software due to
statute, judicial order, or regulation then You must: (a) comply with
the terms of this License to the maximum extent possible; and (b)
describe the limitations and the code they affect. Such description must
be placed in a text file included with all distributions of the Covered
Software under this License. Except to the extent prohibited by statute
or regulation, such description must be sufficiently detailed for a
recipient of ordinary skill to be able to understand it.

5. Termination
--------------

5.1. The rights granted under this License will terminate automatically
if You fail to comply with any of its terms. However, if You become
compliant, then the rights granted under this License from a particular
Contributor are reinstated (a) provisionally, unless and until such
Contributor explicitly and finally terminates Your grants, and (b) on an
ongoing basis, if such Contributor fails to notify You of the
non-compliance by some reasonable means prior to 60 days after You have
come back into compliance. Moreover, Your grants from a particular
Contributor are reinstated on an ongoing basis if such Contributor
notifies You of the non-compliance by some reasonable means, this is the
first time You have received notice of non-compliance with this License
from such Contributor, and You become compliant prior to 30 days after
Your receipt of the notice.

5.2. If You initiate litigation against any entity by asserting a patent
infringement claim (excluding declaratory judgment actions,
counter-claims, and cross-claims) alleging that a Contributor Version
directly or indirectly infringes any patent, then the rights granted to
You by any and all Contributors for the Covered Software under Section
2.1 of this License shall terminate.

5.3. In the event of termination under Sections 5.1 or 5.2 above, all
end user license agreements (excluding distributors and resellers) which
have been validly granted by You or Your distributors under this License
prior to termination shall survive termination.

************************************************************************
*                                                                      *
*  6. Disclaimer of Warranty                                           *
*  -------------------------                                           *
*                                                                      *
*  Covered Software is provided under this License on an "as is"       *
*  basis, without warranty of any kind, either expressed, implied, or  *
*  statutory, including, without limitation, warranties that the       *
*  Covered Software is free of defects, merchantable, fit for a        *
*  particular purpose or non-infringing. The entire risk as to the     *
*  quality and performance of the Covered Software is with You.        *
*  Should any Covered Software prove defective in any respect, You     *
*  (not any Contributor) assume the cost of any necessary servicing,   *
*  repair, or correction. This disclaimer of warranty constitutes an   *
*  essential part of this License. No use of any Covered Software is   *
*  authorized under this License except under this disclaimer.         *
*                                                                      *
************************************************************************

************************************************************************
*                                                                      *
*  7. Limitation of Liability                                          *
*  --------------------------                                          *
*                                                                      *
*  Under no circumstances and under no legal theory, whether tort      *
*  (including negligence), contract, or otherwise, shall any           *
*  Contributor, or anyone who distributes Covered Software as          *
*  permitted above, be liable to You for any direct, indirect,         *
*  special, incidental, or consequential damages of any character      *
*  including, without limitation, damages for lost profits, loss of    *
*  goodwill, work stoppage, computer failure or malfunction, or any    *
*  and all other commercial damages or losses, even if such party      *
*  shall have been informed of the possibility of such damages. This   *
*  limitation of liability shall not apply to liability for death or   *
*  personal injury resulting from such party's negligence to the       *
*  extent applicable law prohibits such limitation. Some               *
*  jurisdictions do not allow the exclusion or limitation of           *
*  incidental or consequential damages, so this exclusion and          *
*  limitation may not apply to You.                                    *
*                                                                      *
************************************************************************

8. Litigation
-------------

Any litigation relating to this License may be brought only in the
courts of a jurisdiction where the defendant maintains its principal
place of business and such litigation shall be governed by laws of that
jurisdiction, without reference to its conflict-of-law provisions.
Nothing in this Section shall prevent a party's ability to bring
cross-claims or counter-claims.

9. Miscellaneous
----------------

This License represents the complete agreement concerning the subject
matter hereof. If any provision of this License is held to be
unenforceable, such provision shall be reformed only to the extent
necessary to make it enforceable. Any law or regulation which provides
that the language of a contract shall be construed against the drafter
shall not be used to construe this License against a Contributor.

10. Versions of the License
---------------------------

10.1. New Versions

Mozilla Foundation is the license steward. Except as provided in Section
10.3, no one other than the license steward has the right to modify or
publish new versions of this License. Each version will be given a
distinguishing version number.

10.2. Effect of New Versions

You may distribute the Covered Software under the terms of the version
of the License under which You originally received the Covered Software,
or under the terms of any subsequent version published by the license
steward.

10.3. Modified Versions

If you create software not governed by this License, and you want to
create a new license for such software, you may create and use a
modified version of this License if you rename the license and remove
any references to the name of the license steward (except to note that
such modified license differs from this License).

10.4. Distributing Source Code Form that is Incompatible With Secondary
Licenses

If You choose to distribute Source Code Form that is Incompatible With
Secondary Licenses under the terms of this version of the License, the
notice described in Exhibit B of this License must be attached.

Exhibit A - Source Code Form License Notice
-------------------------------------------

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

If it is not possible or desirable to put the notice in a particular
file, then You may include the notice in a location (such as a LICENSE
file in a relevant directory) where a recipient would be likely to look
for such a notice.

You may add additional accurate notices of copyright ownership.

Exhibit B - "Incompatible With Secondary Licenses" Notice
---------------------------------------------------------

  This Source Code Form is "Incompatible With Secondary Licenses", as
  defined by the Mozilla Public License, v. 2.0.

```

`LibreHardwareMonitor.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29306.81
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "LibreHardwareMonitorLib", "LibreHardwareMonitorLib\LibreHardwareMonitorLib.csproj", "{B0397530-545A-471D-BB74-027AE456DF1A}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "LibreHardwareMonitor", "LibreHardwareMonitor\LibreHardwareMonitor.csproj", "{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}"
	ProjectSection(ProjectDependencies) = postProject
		{B0397530-545A-471D-BB74-027AE456DF1A} = {B0397530-545A-471D-BB74-027AE456DF1A}
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Aga.Controls", "Aga.Controls\Aga.Controls.csproj", "{E73BB233-D88B-44A7-A98F-D71EE158381D}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Controls", "Controls", "{23F54DBD-8998-4E22-A4E4-60F4F77F9B65}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{BAEC1DFE-5D1E-4CDB-8264-6C85B229D812}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		Directory.Build.props = Directory.Build.props
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B0397530-545A-471D-BB74-027AE456DF1A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B0397530-545A-471D-BB74-027AE456DF1A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B0397530-545A-471D-BB74-027AE456DF1A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B0397530-545A-471D-BB74-027AE456DF1A}.Release|Any CPU.Build.0 = Release|Any CPU
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Release|Any CPU.Build.0 = Release|Any CPU
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{E73BB233-D88B-44A7-A98F-D71EE158381D} = {23F54DBD-8998-4E22-A4E4-60F4F77F9B65}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6A8EF661-2BD7-498F-8FB9-28182B3B0BE5}
	EndGlobalSection
EndGlobal

```

`LibreHardwareMonitor/LibreHardwareMonitor.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk.WindowsDesktop">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net472</TargetFramework>
    <AssemblyName>LibreHardwareMonitor</AssemblyName>
    <AssemblyTitle>Libre Hardware Monitor</AssemblyTitle>
    <Copyright>LibreHardwareMonitor</Copyright>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <ApplicationIcon>Resources\icon.ico</ApplicationIcon>
    <ApplicationManifest>Resources\app.manifest</ApplicationManifest>
    <StartupObject>LibreHardwareMonitor.Program</StartupObject>
    <UseWindowsForms>true</UseWindowsForms>
    <OutputPath>..\bin\$(Configuration)\</OutputPath>
	  <LangVersion>latest</LangVersion>
    <PlatformTarget>AnyCPU</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>none</DebugType>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.2" />
    <PackageReference Include="TaskScheduler" Version="2.10.1" />
    <PackageReference Include="OxyPlot.Core" Version="2.1.2" />
    <PackageReference Include="OxyPlot.WindowsForms" Version="2.1.2" />
    <PackageReference Include="System.Management" Version="7.0.0" />
  </ItemGroup>
  <ItemGroup>
    <Reference Include="System.Web" />
    <Reference Include="System.Configuration.Install" />
  </ItemGroup>
  <ItemGroup>
    <Compile Update="UI\AboutBox.Designer.cs">
      <DependentUpon>AboutBox.cs</DependentUpon>
    </Compile>
    <Compile Update="UI\AuthForm.Designer.cs">
      <DependentUpon>AuthForm.cs</DependentUpon>
    </Compile>
    <Compile Update="UI\MainForm.Designer.cs">
      <DependentUpon>MainForm.cs</DependentUpon>
    </Compile>
    <Compile Update="UI\ParameterForm.Designer.cs">
      <DependentUpon>ParameterForm.cs</DependentUpon>
    </Compile>
    <Compile Update="UI\PortForm.Designer.cs">
      <DependentUpon>PortForm.cs</DependentUpon>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Update="UI\AboutBox.resx">
      <DependentUpon>AboutBox.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Update="UI\AuthForm.resx">
      <DependentUpon>AuthForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Update="UI\MainForm.resx">
      <DependentUpon>MainForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Update="UI\ParameterForm.resx">
      <DependentUpon>ParameterForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Update="UI\PortForm.resx">
      <DependentUpon>PortForm.cs</DependentUpon>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Aga.Controls\Aga.Controls.csproj" />
    <ProjectReference Include="..\LibreHardwareMonitorLib\LibreHardwareMonitorLib.csproj" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Resources\**" />
    <None Include="Resources\app.manifest" />
    <None Include="Resources\icon.ico" />
  </ItemGroup>
</Project>

```

`LibreHardwareMonitor/Program.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.IO;
using System.Windows.Forms;
using LibreHardwareMonitor.UI;

namespace LibreHardwareMonitor;

public static class Program
{
    [STAThread]
    public static void Main()
    {
        if (!AllRequiredFilesAvailable())
            Environment.Exit(0);

        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);
        using (MainForm form = new MainForm())
        {
            form.FormClosed += delegate
            {
                Application.Exit();
            };
            Application.Run();
        }
    }

    private static bool IsFileAvailable(string fileName)
    {
        string path = Path.GetDirectoryName(Application.ExecutablePath) + Path.DirectorySeparatorChar;
        if (!File.Exists(path + fileName))
        {
            MessageBox.Show("The following file could not be found: " + fileName +
                            "\nPlease extract all files from the archive.", "Error",
                            MessageBoxButtons.OK, MessageBoxIcon.Error);
            return false;
        }
        return true;
    }

    private static bool AllRequiredFilesAvailable()
    {
        if (!IsFileAvailable("Aga.Controls.dll"))
            return false;

        if (!IsFileAvailable("LibreHardwareMonitorLib.dll"))
            return false;

        if (!IsFileAvailable("OxyPlot.dll"))
            return false;

        if (!IsFileAvailable("OxyPlot.WindowsForms.dll"))
            return false;

        return true;
    }
}

```

`LibreHardwareMonitor/Resources/Web/css/custom-theme/jquery-ui-1.8.16.custom.css`:

```css
/*
 * jQuery UI CSS Framework 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Theming/API
 */

/* Layout helpers
----------------------------------*/
.ui-helper-hidden { display: none; }
.ui-helper-hidden-accessible { position: absolute !important; clip: rect(1px 1px 1px 1px); clip: rect(1px,1px,1px,1px); }
.ui-helper-reset { margin: 0; padding: 0; border: 0; outline: 0; line-height: 1.3; text-decoration: none; font-size: 100%; list-style: none; }
.ui-helper-clearfix:after { content: "."; display: block; height: 0; clear: both; visibility: hidden; }
.ui-helper-clearfix { display: inline-block; }
/* required comment for clearfix to work in Opera \*/
* html .ui-helper-clearfix { height:1%; }
.ui-helper-clearfix { display:block; }
/* end clearfix */
.ui-helper-zfix { width: 100%; height: 100%; top: 0; left: 0; position: absolute; opacity: 0; filter:Alpha(Opacity=0); }


/* Interaction Cues
----------------------------------*/
.ui-state-disabled { cursor: default !important; }


/* Icons
----------------------------------*/

/* states and images */
.ui-icon { display: block; text-indent: -99999px; overflow: hidden; background-repeat: no-repeat; }


/* Misc visuals
----------------------------------*/

/* Overlays */
.ui-widget-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }


/*
 * jQuery UI CSS Framework 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Theming/API
 *
 * To view and modify this theme, visit http://jqueryui.com/themeroller/?ctl=themeroller
 */


/* Component containers
----------------------------------*/
.ui-widget { font-family: Verdana,Arial,sans-serif; font-size: 1.1em; }
.ui-widget .ui-widget { font-size: 1em; }
.ui-widget input, .ui-widget select, .ui-widget textarea, .ui-widget button { font-family: Verdana,Arial,sans-serif; font-size: 1em; }
.ui-widget-content { border: 1px solid #aaaaaa; background: #ffffff url(images/ui-bg_glass_75_ffffff_1x400.png) 50% 50% repeat-x; color: #222222; }
.ui-widget-content a { color: #222222; }
.ui-widget-header { border: 1px solid #aaaaaa; background: #cccccc url(images/ui-bg_highlight-soft_75_cccccc_1x100.png) 50% 50% repeat-x; color: #222222; font-weight: bold; }
.ui-widget-header a { color: #222222; }

/* Interaction states
----------------------------------*/
.ui-state-default, .ui-widget-content .ui-state-default, .ui-widget-header .ui-state-default { border: 1px solid #d3d3d3; background: #e6e6e6 url(images/ui-bg_glass_75_e6e6e6_1x400.png) 50% 50% repeat-x; font-weight: normal; color: #555555; }
.ui-state-default a, .ui-state-default a:link, .ui-state-default a:visited { color: #555555; text-decoration: none; }
.ui-state-hover, .ui-widget-content .ui-state-hover, .ui-widget-header .ui-state-hover, .ui-state-focus, .ui-widget-content .ui-state-focus, .ui-widget-header .ui-state-focus { border: 1px solid #999999; background: #dadada url(images/ui-bg_glass_75_dadada_1x400.png) 50% 50% repeat-x; font-weight: normal; color: #212121; }
.ui-state-hover a, .ui-state-hover a:hover { color: #212121; text-decoration: none; }
.ui-state-active, .ui-widget-content .ui-state-active, .ui-widget-header .ui-state-active { border: 1px solid #aaaaaa; background: #ffffff url(images/ui-bg_glass_65_ffffff_1x400.png) 50% 50% repeat-x; font-weight: normal; color: #212121; }
.ui-state-active a, .ui-state-active a:link, .ui-state-active a:visited { color: #212121; text-decoration: none; }
.ui-widget :active { outline: none; }

/* Interaction Cues
----------------------------------*/
.ui-state-highlight, .ui-widget-content .ui-state-highlight, .ui-widget-header .ui-state-highlight  {border: 1px solid #fcefa1; background: #fbf9ee url(images/ui-bg_glass_55_fbf9ee_1x400.png) 50% 50% repeat-x; color: #363636; }
.ui-state-highlight a, .ui-widget-content .ui-state-highlight a,.ui-widget-header .ui-state-highlight a { color: #363636; }
.ui-state-error, .ui-widget-content .ui-state-error, .ui-widget-header .ui-state-error {border: 1px solid #cd0a0a; background: #fef1ec url(images/ui-bg_inset-soft_95_fef1ec_1x100.png) 50% bottom repeat-x; color: #cd0a0a; }
.ui-state-error a, .ui-widget-content .ui-state-error a, .ui-widget-header .ui-state-error a { color: #cd0a0a; }
.ui-state-error-text, .ui-widget-content .ui-state-error-text, .ui-widget-header .ui-state-error-text { color: #cd0a0a; }
.ui-priority-primary, .ui-widget-content .ui-priority-primary, .ui-widget-header .ui-priority-primary { font-weight: bold; }
.ui-priority-secondary, .ui-widget-content .ui-priority-secondary,  .ui-widget-header .ui-priority-secondary { opacity: .7; filter:Alpha(Opacity=70); font-weight: normal; }
.ui-state-disabled, .ui-widget-content .ui-state-disabled, .ui-widget-header .ui-state-disabled { opacity: .35; filter:Alpha(Opacity=35); background-image: none; }

/* Icons
----------------------------------*/

/* states and images */
.ui-icon { width: 16px; height: 16px; background-image: url(images/ui-icons_222222_256x240.png); }
.ui-widget-content .ui-icon {background-image: url(images/ui-icons_222222_256x240.png); }
.ui-widget-header .ui-icon {background-image: url(images/ui-icons_222222_256x240.png); }
.ui-state-default .ui-icon { background-image: url(images/ui-icons_888888_256x240.png); }
.ui-state-hover .ui-icon, .ui-state-focus .ui-icon {background-image: url(images/ui-icons_454545_256x240.png); }
.ui-state-active .ui-icon {background-image: url(images/ui-icons_454545_256x240.png); }
.ui-state-highlight .ui-icon {background-image: url(images/ui-icons_2e83ff_256x240.png); }
.ui-state-error .ui-icon, .ui-state-error-text .ui-icon {background-image: url(images/ui-icons_cd0a0a_256x240.png); }

/* positioning */
.ui-icon-carat-1-n { background-position: 0 0; }
.ui-icon-carat-1-ne { background-position: -16px 0; }
.ui-icon-carat-1-e { background-position: -32px 0; }
.ui-icon-carat-1-se { background-position: -48px 0; }
.ui-icon-carat-1-s { background-position: -64px 0; }
.ui-icon-carat-1-sw { background-position: -80px 0; }
.ui-icon-carat-1-w { background-position: -96px 0; }
.ui-icon-carat-1-nw { background-position: -112px 0; }
.ui-icon-carat-2-n-s { background-position: -128px 0; }
.ui-icon-carat-2-e-w { background-position: -144px 0; }
.ui-icon-triangle-1-n { background-position: 0 -16px; }
.ui-icon-triangle-1-ne { background-position: -16px -16px; }
.ui-icon-triangle-1-e { background-position: -32px -16px; }
.ui-icon-triangle-1-se { background-position: -48px -16px; }
.ui-icon-triangle-1-s { background-position: -64px -16px; }
.ui-icon-triangle-1-sw { background-position: -80px -16px; }
.ui-icon-triangle-1-w { background-position: -96px -16px; }
.ui-icon-triangle-1-nw { background-position: -112px -16px; }
.ui-icon-triangle-2-n-s { background-position: -128px -16px; }
.ui-icon-triangle-2-e-w { background-position: -144px -16px; }
.ui-icon-arrow-1-n { background-position: 0 -32px; }
.ui-icon-arrow-1-ne { background-position: -16px -32px; }
.ui-icon-arrow-1-e { background-position: -32px -32px; }
.ui-icon-arrow-1-se { background-position: -48px -32px; }
.ui-icon-arrow-1-s { background-position: -64px -32px; }
.ui-icon-arrow-1-sw { background-position: -80px -32px; }
.ui-icon-arrow-1-w { background-position: -96px -32px; }
.ui-icon-arrow-1-nw { background-position: -112px -32px; }
.ui-icon-arrow-2-n-s { background-position: -128px -32px; }
.ui-icon-arrow-2-ne-sw { background-position: -144px -32px; }
.ui-icon-arrow-2-e-w { background-position: -160px -32px; }
.ui-icon-arrow-2-se-nw { background-position: -176px -32px; }
.ui-icon-arrowstop-1-n { background-position: -192px -32px; }
.ui-icon-arrowstop-1-e { background-position: -208px -32px; }
.ui-icon-arrowstop-1-s { background-position: -224px -32px; }
.ui-icon-arrowstop-1-w { background-position: -240px -32px; }
.ui-icon-arrowthick-1-n { background-position: 0 -48px; }
.ui-icon-arrowthick-1-ne { background-position: -16px -48px; }
.ui-icon-arrowthick-1-e { background-position: -32px -48px; }
.ui-icon-arrowthick-1-se { background-position: -48px -48px; }
.ui-icon-arrowthick-1-s { background-position: -64px -48px; }
.ui-icon-arrowthick-1-sw { background-position: -80px -48px; }
.ui-icon-arrowthick-1-w { background-position: -96px -48px; }
.ui-icon-arrowthick-1-nw { background-position: -112px -48px; }
.ui-icon-arrowthick-2-n-s { background-position: -128px -48px; }
.ui-icon-arrowthick-2-ne-sw { background-position: -144px -48px; }
.ui-icon-arrowthick-2-e-w { background-position: -160px -48px; }
.ui-icon-arrowthick-2-se-nw { background-position: -176px -48px; }
.ui-icon-arrowthickstop-1-n { background-position: -192px -48px; }
.ui-icon-arrowthickstop-1-e { background-position: -208px -48px; }
.ui-icon-arrowthickstop-1-s { background-position: -224px -48px; }
.ui-icon-arrowthickstop-1-w { background-position: -240px -48px; }
.ui-icon-arrowreturnthick-1-w { background-position: 0 -64px; }
.ui-icon-arrowreturnthick-1-n { background-position: -16px -64px; }
.ui-icon-arrowreturnthick-1-e { background-position: -32px -64px; }
.ui-icon-arrowreturnthick-1-s { background-position: -48px -64px; }
.ui-icon-arrowreturn-1-w { background-position: -64px -64px; }
.ui-icon-arrowreturn-1-n { background-position: -80px -64px; }
.ui-icon-arrowreturn-1-e { background-position: -96px -64px; }
.ui-icon-arrowreturn-1-s { background-position: -112px -64px; }
.ui-icon-arrowrefresh-1-w { background-position: -128px -64px; }
.ui-icon-arrowrefresh-1-n { background-position: -144px -64px; }
.ui-icon-arrowrefresh-1-e { background-position: -160px -64px; }
.ui-icon-arrowrefresh-1-s { background-position: -176px -64px; }
.ui-icon-arrow-4 { background-position: 0 -80px; }
.ui-icon-arrow-4-diag { background-position: -16px -80px; }
.ui-icon-extlink { background-position: -32px -80px; }
.ui-icon-newwin { background-position: -48px -80px; }
.ui-icon-refresh { background-position: -64px -80px; }
.ui-icon-shuffle { background-position: -80px -80px; }
.ui-icon-transfer-e-w { background-position: -96px -80px; }
.ui-icon-transferthick-e-w { background-position: -112px -80px; }
.ui-icon-folder-collapsed { background-position: 0 -96px; }
.ui-icon-folder-open { background-position: -16px -96px; }
.ui-icon-document { background-position: -32px -96px; }
.ui-icon-document-b { background-position: -48px -96px; }
.ui-icon-note { background-position: -64px -96px; }
.ui-icon-mail-closed { background-position: -80px -96px; }
.ui-icon-mail-open { background-position: -96px -96px; }
.ui-icon-suitcase { background-position: -112px -96px; }
.ui-icon-comment { background-position: -128px -96px; }
.ui-icon-person { background-position: -144px -96px; }
.ui-icon-print { background-position: -160px -96px; }
.ui-icon-trash { background-position: -176px -96px; }
.ui-icon-locked { background-position: -192px -96px; }
.ui-icon-unlocked { background-position: -208px -96px; }
.ui-icon-bookmark { background-position: -224px -96px; }
.ui-icon-tag { background-position: -240px -96px; }
.ui-icon-home { background-position: 0 -112px; }
.ui-icon-flag { background-position: -16px -112px; }
.ui-icon-calendar { background-position: -32px -112px; }
.ui-icon-cart { background-position: -48px -112px; }
.ui-icon-pencil { background-position: -64px -112px; }
.ui-icon-clock { background-position: -80px -112px; }
.ui-icon-disk { background-position: -96px -112px; }
.ui-icon-calculator { background-position: -112px -112px; }
.ui-icon-zoomin { background-position: -128px -112px; }
.ui-icon-zoomout { background-position: -144px -112px; }
.ui-icon-search { background-position: -160px -112px; }
.ui-icon-wrench { background-position: -176px -112px; }
.ui-icon-gear { background-position: -192px -112px; }
.ui-icon-heart { background-position: -208px -112px; }
.ui-icon-star { background-position: -224px -112px; }
.ui-icon-link { background-position: -240px -112px; }
.ui-icon-cancel { background-position: 0 -128px; }
.ui-icon-plus { background-position: -16px -128px; }
.ui-icon-plusthick { background-position: -32px -128px; }
.ui-icon-minus { background-position: -48px -128px; }
.ui-icon-minusthick { background-position: -64px -128px; }
.ui-icon-close { background-position: -80px -128px; }
.ui-icon-closethick { background-position: -96px -128px; }
.ui-icon-key { background-position: -112px -128px; }
.ui-icon-lightbulb { background-position: -128px -128px; }
.ui-icon-scissors { background-position: -144px -128px; }
.ui-icon-clipboard { background-position: -160px -128px; }
.ui-icon-copy { background-position: -176px -128px; }
.ui-icon-contact { background-position: -192px -128px; }
.ui-icon-image { background-position: -208px -128px; }
.ui-icon-video { background-position: -224px -128px; }
.ui-icon-script { background-position: -240px -128px; }
.ui-icon-alert { background-position: 0 -144px; }
.ui-icon-info { background-position: -16px -144px; }
.ui-icon-notice { background-position: -32px -144px; }
.ui-icon-help { background-position: -48px -144px; }
.ui-icon-check { background-position: -64px -144px; }
.ui-icon-bullet { background-position: -80px -144px; }
.ui-icon-radio-off { background-position: -96px -144px; }
.ui-icon-radio-on { background-position: -112px -144px; }
.ui-icon-pin-w { background-position: -128px -144px; }
.ui-icon-pin-s { background-position: -144px -144px; }
.ui-icon-play { background-position: 0 -160px; }
.ui-icon-pause { background-position: -16px -160px; }
.ui-icon-seek-next { background-position: -32px -160px; }
.ui-icon-seek-prev { background-position: -48px -160px; }
.ui-icon-seek-end { background-position: -64px -160px; }
.ui-icon-seek-start { background-position: -80px -160px; }
/* ui-icon-seek-first is deprecated, use ui-icon-seek-start instead */
.ui-icon-seek-first { background-position: -80px -160px; }
.ui-icon-stop { background-position: -96px -160px; }
.ui-icon-eject { background-position: -112px -160px; }
.ui-icon-volume-off { background-position: -128px -160px; }
.ui-icon-volume-on { background-position: -144px -160px; }
.ui-icon-power { background-position: 0 -176px; }
.ui-icon-signal-diag { background-position: -16px -176px; }
.ui-icon-signal { background-position: -32px -176px; }
.ui-icon-battery-0 { background-position: -48px -176px; }
.ui-icon-battery-1 { background-position: -64px -176px; }
.ui-icon-battery-2 { background-position: -80px -176px; }
.ui-icon-battery-3 { background-position: -96px -176px; }
.ui-icon-circle-plus { background-position: 0 -192px; }
.ui-icon-circle-minus { background-position: -16px -192px; }
.ui-icon-circle-close { background-position: -32px -192px; }
.ui-icon-circle-triangle-e { background-position: -48px -192px; }
.ui-icon-circle-triangle-s { background-position: -64px -192px; }
.ui-icon-circle-triangle-w { background-position: -80px -192px; }
.ui-icon-circle-triangle-n { background-position: -96px -192px; }
.ui-icon-circle-arrow-e { background-position: -112px -192px; }
.ui-icon-circle-arrow-s { background-position: -128px -192px; }
.ui-icon-circle-arrow-w { background-position: -144px -192px; }
.ui-icon-circle-arrow-n { background-position: -160px -192px; }
.ui-icon-circle-zoomin { background-position: -176px -192px; }
.ui-icon-circle-zoomout { background-position: -192px -192px; }
.ui-icon-circle-check { background-position: -208px -192px; }
.ui-icon-circlesmall-plus { background-position: 0 -208px; }
.ui-icon-circlesmall-minus { background-position: -16px -208px; }
.ui-icon-circlesmall-close { background-position: -32px -208px; }
.ui-icon-squaresmall-plus { background-position: -48px -208px; }
.ui-icon-squaresmall-minus { background-position: -64px -208px; }
.ui-icon-squaresmall-close { background-position: -80px -208px; }
.ui-icon-grip-dotted-vertical { background-position: 0 -224px; }
.ui-icon-grip-dotted-horizontal { background-position: -16px -224px; }
.ui-icon-grip-solid-vertical { background-position: -32px -224px; }
.ui-icon-grip-solid-horizontal { background-position: -48px -224px; }
.ui-icon-gripsmall-diagonal-se { background-position: -64px -224px; }
.ui-icon-grip-diagonal-se { background-position: -80px -224px; }


/* Misc visuals
----------------------------------*/

/* Corner radius */
.ui-corner-all, .ui-corner-top, .ui-corner-left, .ui-corner-tl { -moz-border-radius-topleft: 4px; -webkit-border-top-left-radius: 4px; -khtml-border-top-left-radius: 4px; border-top-left-radius: 4px; }
.ui-corner-all, .ui-corner-top, .ui-corner-right, .ui-corner-tr { -moz-border-radius-topright: 4px; -webkit-border-top-right-radius: 4px; -khtml-border-top-right-radius: 4px; border-top-right-radius: 4px; }
.ui-corner-all, .ui-corner-bottom, .ui-corner-left, .ui-corner-bl { -moz-border-radius-bottomleft: 4px; -webkit-border-bottom-left-radius: 4px; -khtml-border-bottom-left-radius: 4px; border-bottom-left-radius: 4px; }
.ui-corner-all, .ui-corner-bottom, .ui-corner-right, .ui-corner-br { -moz-border-radius-bottomright: 4px; -webkit-border-bottom-right-radius: 4px; -khtml-border-bottom-right-radius: 4px; border-bottom-right-radius: 4px; }

/* Overlays */
.ui-widget-overlay { background: #aaaaaa url(images/ui-bg_flat_0_aaaaaa_40x100.png) 50% 50% repeat-x; opacity: .30;filter:Alpha(Opacity=30); }
.ui-widget-shadow { margin: -8px 0 0 -8px; padding: 8px; background: #aaaaaa url(images/ui-bg_flat_0_aaaaaa_40x100.png) 50% 50% repeat-x; opacity: .30;filter:Alpha(Opacity=30); -moz-border-radius: 8px; -khtml-border-radius: 8px; -webkit-border-radius: 8px; border-radius: 8px; }/*
 * jQuery UI Button 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button#theming
 */
.ui-button { display: inline-block; position: relative; padding: 0; margin-right: .1em; text-decoration: none !important; cursor: pointer; text-align: center; zoom: 1; overflow: visible; } /* the overflow property removes extra width in IE */
.ui-button-icon-only { width: 2.2em; } /* to make room for the icon, a width needs to be set here */
button.ui-button-icon-only { width: 2.4em; } /* button elements seem to need a little more width */
.ui-button-icons-only { width: 3.4em; } 
button.ui-button-icons-only { width: 3.7em; } 

/*button text element */
.ui-button .ui-button-text { display: block; line-height: 1.4;  }
.ui-button-text-only .ui-button-text { padding: .4em 1em; }
.ui-button-icon-only .ui-button-text, .ui-button-icons-only .ui-button-text { padding: .4em; text-indent: -9999999px; }
.ui-button-text-icon-primary .ui-button-text, .ui-button-text-icons .ui-button-text { padding: .4em 1em .4em 2.1em; }
.ui-button-text-icon-secondary .ui-button-text, .ui-button-text-icons .ui-button-text { padding: .4em 2.1em .4em 1em; }
.ui-button-text-icons .ui-button-text { padding-left: 2.1em; padding-right: 2.1em; }
/* no icon support for input elements, provide padding by default */
input.ui-button { padding: .4em 1em; }

/*button icon element(s) */
.ui-button-icon-only .ui-icon, .ui-button-text-icon-primary .ui-icon, .ui-button-text-icon-secondary .ui-icon, .ui-button-text-icons .ui-icon, .ui-button-icons-only .ui-icon { position: absolute; top: 50%; margin-top: -8px; }
.ui-button-icon-only .ui-icon { left: 50%; margin-left: -8px; }
.ui-button-text-icon-primary .ui-button-icon-primary, .ui-button-text-icons .ui-button-icon-primary, .ui-button-icons-only .ui-button-icon-primary { left: .5em; }
.ui-button-text-icon-secondary .ui-button-icon-secondary, .ui-button-text-icons .ui-button-icon-secondary, .ui-button-icons-only .ui-button-icon-secondary { right: .5em; }
.ui-button-text-icons .ui-button-icon-secondary, .ui-button-icons-only .ui-button-icon-secondary { right: .5em; }

/*button sets*/
.ui-buttonset { margin-right: 7px; }
.ui-buttonset .ui-button { margin-left: 0; margin-right: -.3em; }

/* workarounds */
button.ui-button::-moz-focus-inner { border: 0; padding: 0; } /* reset extra padding in Firefox */
/*
 * jQuery UI Slider 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider#theming
 */
.ui-slider { position: relative; text-align: left; }
.ui-slider .ui-slider-handle { position: absolute; z-index: 2; width: 1.2em; height: 1.2em; cursor: default; }
.ui-slider .ui-slider-range { position: absolute; z-index: 1; font-size: .7em; display: block; border: 0; background-position: 0 0; }

.ui-slider-horizontal { height: .8em; }
.ui-slider-horizontal .ui-slider-handle { top: -.3em; margin-left: -.6em; }
.ui-slider-horizontal .ui-slider-range { top: 0; height: 100%; }
.ui-slider-horizontal .ui-slider-range-min { left: 0; }
.ui-slider-horizontal .ui-slider-range-max { right: 0; }

.ui-slider-vertical { width: .8em; height: 100px; }
.ui-slider-vertical .ui-slider-handle { left: -.3em; margin-left: 0; margin-bottom: -.6em; }
.ui-slider-vertical .ui-slider-range { left: 0; width: 100%; }
.ui-slider-vertical .ui-slider-range-min { bottom: 0; }
.ui-slider-vertical .ui-slider-range-max { top: 0; }
```

`LibreHardwareMonitor/Resources/Web/css/jquery.treeTable.css`:

```css
/* jQuery treeTable stylesheet
 *
 * This file contains styles that are used to display the tree table. Each tree
 * table is assigned the +treeTable+ class.
 * ========================================================================= */

/* jquery.treeTable.collapsible
 * ------------------------------------------------------------------------- */
.treeTable tr td .expander {
  background-position: left center;
  background-repeat: no-repeat;
  cursor: pointer;
  padding: 0;
  zoom: 1; /* IE7 Hack */
}

.treeTable tr.collapsed td .expander {
  background-image: url(../images/toggle-expand-dark.png);
}

.treeTable tr.expanded td .expander {
  background-image: url(../images/toggle-collapse-dark.png);
}

/* jquery.treeTable.sortable
 * ------------------------------------------------------------------------- */
.treeTable tr.selected, .treeTable tr.accept {
  background-color: #3875d7;
  color: #fff;
}

.treeTable tr.collapsed.selected td .expander, .treeTable tr.collapsed.accept td .expander {
  background-image: url(../images/toggle-expand-light.png);
}

.treeTable tr.expanded.selected td .expander, .treeTable tr.expanded.accept td .expander {
  background-image: url(../images/toggle-collapse-light.png);
}

.treeTable .ui-draggable-dragging {
  color: #000;
  z-index: 1;
}

/* Layout helper taken from jQuery UI. This way I don't have to require the
 * full jQuery UI CSS to be loaded. */
.ui-helper-hidden { display: none; }

```

`LibreHardwareMonitor/Resources/Web/css/ohm_web.css`:

```css
body {
	font-size: 62.5%;
}

table
{
  border-collapse:collapse;
}

table, tr
{
 border: 1px solid #F0F0F0;
}

td
{
 padding-right:10px;
}

/* Site
   -------------------------------- */

body {
	font-family: "Trebuchet MS", "Helvetica", "Arial",  "Verdana", "sans-serif";
}

div.header {
	padding:12px;
	font-family: "Trebuchet MS", "Arial", "Helvetica", "Verdana", "sans-serif";
}

div.main {
	clear:both;
	padding:12px;
	font-family: "Trebuchet MS", "Arial", "Helvetica", "Verdana", "sans-serif";
	/*font-size: 1.3em;*/
	/*line-height: 1.4em;*/
}


```

`LibreHardwareMonitor/Resources/Web/index.html`:

```html
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/.  
	 
	 - Copyright (C) 2012 Prince Samuel <prince.samuel@gmail.com>  -->

<html>
<head>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <title>Libre Hardware Monitor - Web Version</title>
    <script type='text/javascript' src='js/jquery-1.7.2.min.js'></script>
    <script type='text/javascript' src='js/jquery.tmpl.min.js'></script>
    <script type='text/javascript' src='js/knockout-2.1.0.min.js'></script>
    <script type='text/javascript' src='js/knockout.mapping-latest.min.js'></script>

    <link href="css/jquery.treeTable.css" rel="stylesheet" type="text/css" />
    <script type='text/javascript' src='js/jquery.treeTable.min.js'></script>

    <link href="css/custom-theme/jquery-ui-1.8.16.custom.css" rel="stylesheet" type="text/css" />
    <link href="css/ohm_web.css" rel="stylesheet" type="text/css" />
    <script type='text/javascript' src='js/jquery-ui-1.8.16.custom.min.js'></script>
    <style>
        #toolbar {
            padding: 10px 10px;
        }

        #slider {
            display: inline-block;
            width: 100px;
        }
    </style>


    <script type='text/javascript' src='js/ohm_web.js'></script>

</head>

  <body>

    <div class="header">

      <span id="toolbar" class="ui-widget-header ui-corner-all">
        <button id="refresh" data-bind="click: update">Refresh</button>
        <input type="checkbox" id="auto_refresh" data-bind="checked: auto_refresh"/><label for="auto_refresh">Auto Refresh</label>
        &nbsp;<div id="slider"></div>&nbsp;&nbsp;&nbsp;&nbsp;<span for="auto_refresh" id="lbl"></span>
      </span>
    </div>

    <div class="main">
      <table data-bind="treeTable: flattened, treeOptions: { initialState: 'expanded', clickableNodeNames: true } ">
        <thead><td>Sensor</td><td>Min</td><td>Value</td><td>Max</td>
          <tbody data-bind="foreach: flattened">
            <tr data-bind="attr: { 'id': 'node-' + id(), 'class': parent.id()?'child-of-node-' + parent.id():'' }">
              <td data-bind="html: '<img src=' + ImageURL() + ' />&nbsp; ' + Text()"></td>
              <td data-bind="text: Min"></td>
              <td data-bind="text: Value"></td>
              <td data-bind="text: Max"></td>
            </tr>
          </tbody>
        </table>
      </div>
    </body>
  </html>

```

`LibreHardwareMonitor/Resources/Web/js/jquery-1.7.2.js`:

```js
/*!
 * jQuery JavaScript Library v1.7.2
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Wed Mar 21 12:46:34 2012 -0700
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.7.2",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.fireWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;

		// Sets many values
		if ( key && typeof key === "object" ) {
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
			}
			chainable = 1;

		// Sets one value
		} else if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = pass === undefined && jQuery.isFunction( value );

			if ( bulk ) {
				// Bulk operations only iterate when executing function values
				if ( exec ) {
					exec = fn;
					fn = function( elem, key, value ) {
						return exec.call( jQuery( elem ), value );
					};

				// Otherwise they run against the entire set
				} else {
					fn.call( elems, value );
					fn = null;
				}
			}

			if ( fn ) {
				for (; i < length; i++ ) {
					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
				}
			}

			chainable = 1;
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

	// Convert flags from String-formatted to Object-formatted
	// (we check in cache first)
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var // Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = [],
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Add one or several callbacks to the list
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					// Inspect recursively
					add( elem );
				} else if ( type === "function" ) {
					// Add if not in unique mode and callback is not in
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		// Fire callbacks
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			fired = true;
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away, unless previous
					// firing was halted (stopOnFalse)
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								// Handle firingIndex and firingLength
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								// Remove the element
								list.splice( i--, 1 );
								// If we have some unicity property then
								// we only need to do this once
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};




var // Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

				// Deprecated
				isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		pixelMargin: true
	};

	// jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead
	jQuery.boxModel = support.boxModel = (document.compatMode === "CSS1Compat");

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "name", "t" );

	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for ( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

	// Null elements to avoid leaks in IE
	fragment = select = opt = div = input = null;

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			marginDiv, conMarginTop, style, html, positionTopLeftWidthHeight,
			paddingMarginBorderVisibility, paddingMarginBorder,
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		conMarginTop = 1;
		paddingMarginBorder = "padding:0;margin:0;border:";
		positionTopLeftWidthHeight = "position:absolute;top:0;left:0;width:1px;height:1px;";
		paddingMarginBorderVisibility = paddingMarginBorder + "0;visibility:hidden;";
		style = "style='" + positionTopLeftWidthHeight + paddingMarginBorder + "5px solid #000;";
		html = "<div " + style + "display:block;'><div style='" + paddingMarginBorder + "0;display:block;overflow:hidden;'></div></div>" +
			"<table " + style + "' cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = paddingMarginBorderVisibility + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td style='" + paddingMarginBorder + "0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check if div with explicit width and no margin-right incorrectly
		// gets computed margin-right based on width of container. For more
		// info see bug #3333
		// Fails in WebKit before Feb 2011 nightlies
		// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
		if ( window.getComputedStyle ) {
			div.innerHTML = "";
			marginDiv = document.createElement( "div" );
			marginDiv.style.width = "0";
			marginDiv.style.marginRight = "0";
			div.style.width = "2px";
			div.appendChild( marginDiv );
			support.reliableMarginRight =
				( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
		}

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.innerHTML = "";
			div.style.width = div.style.padding = "1px";
			div.style.border = 0;
			div.style.overflow = "hidden";
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "block";
			div.style.overflow = "visible";
			div.innerHTML = "<div style='width:5px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
		}

		div.style.cssText = positionTopLeftWidthHeight + paddingMarginBorderVisibility;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

		if ( window.getComputedStyle ) {
			div.style.marginTop = "1%";
			support.pixelMargin = ( window.getComputedStyle( div, null ) || { marginTop: 0 } ).marginTop !== "1%";
		}

		if ( typeof container.style.zoom !== "undefined" ) {
			container.style.zoom = 1;
		}

		body.removeChild( container );
		marginDiv = div = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Users should not attempt to inspect the internal events object using jQuery.data,
		// it is undocumented and subject to change. But does anyone listen? No.
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ internalKey ] : internalKey;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the cache and need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attr = elem.attributes;
					for ( l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split( ".", 2 );
		parts[1] = parts[1] ? "." + parts[1] : "";
		part = parts[1] + "!";

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				data = this.triggerHandler( "getData" + part, [ parts[0] ] );

				// Try to fetch any internally stored data first
				if ( data === undefined && elem ) {
					data = jQuery.data( elem, key );
					data = dataAttr( elem, key, data );
				}

				return data === undefined && parts[1] ?
					this.data( parts[0] ) :
					data;
			}

			parts[1] = value;
			this.each(function() {
				var self = jQuery( this );

				self.triggerHandler( "setData" + part, parts );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + part, parts );
			});
		}, null, value, arguments.length > 1, null, false );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise( object );
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l, isBool,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;
					isBool = rboolean.test( name );

					// See #9699 for explanation of this approach (setting first, then removal)
					// Do not do this for boolean attributes (see #10870)
					if ( !isBool ) {
						jQuery.attr( elem, name, "" );
					}
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( isBool && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true,
		coords: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

	// Apply the nodeHook to tabindex
	jQuery.attrHooks.tabindex.set = nodeHook.set;

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /(?:^|\s)hover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			//   0  1    2   3
			// [ _, tag, id, class ]
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: selector && quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			special = jQuery.event.special[ event.type ] || {},
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers that should run if there are delegated events
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !(event.button && event.type === "click") ) {

			// Pregenerate a single jQuery object for reuse with .is()
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

				// Don't process events on disabled elements (#6911, #8165)
				if ( cur.disabled !== true ) {
					selMatch = {};
					matches = [];
					jqcur[0] = cur;
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];
						sel = handleObj.selector;

						if ( selMatch[ sel ] === undefined ) {
							selMatch[ sel ] = (
								handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
							);
						}
						if ( selMatch[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, matches: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady
		},

		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					form._submit_attached = true;
				}
			});
			// return undefined since we don't need an event listener
		},
		
		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) { // && selector != null
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;

	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];

			parts.push( m[1] );

			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}

				set = posProcess( selector, set, seed );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if ( !expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];

		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent || innerText for elements
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				// Replace IE's carriage returns
				return elem.innerText.replace( rReturn, '' );
			} else {
				// Traverse it's children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

		// If no nodeType, this is expected to be an array
		for ( i = 0; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );

			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}

			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},

	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},

		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) ) {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					if ( type === "first" ) {
						return true;
					}

					node = elem;

					/* falls through */
				case "last":
					while ( (node = node.nextSibling) ) {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}

					doneName = match[0];
					parent = elem.parentNode;

					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;

						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						}

						parent[ expando ] = doneName;
					}

					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},

		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}
// Expose origPOS
// "global" as in regardless of relation to brackets/parens
Expr.match.globalPOS = origPOS;

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}

	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}

		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );

				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );

					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}

				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );

					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}

						} else {
							return makeArray( [], extra );
						}
					}

					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}

			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );

		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try {
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}

	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.globalPOS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				// If this is a positional selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];

		// Array (deprecated as of jQuery 1.7)
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					null;
			}


			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( elem.getElementsByTagName( "*" ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, function( i, elem ) {
					if ( elem.src ) {
						jQuery.ajax({
							type: "GET",
							global: false,
							url: elem.src,
							async: false,
							dataType: "script"
						});
					} else {
						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
					}

					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}
				});
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;

	// IE blanks contents when cloning scripts
	} else if ( nodeName === "script" && dest.text !== src.text ) {
		dest.text = src.text;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );

	// Clear flags for bubbling special change/submit events, they must
	// be reattached when the newly cloned events are first activated
	dest.removeAttribute( "_submit_attached" );
	dest.removeAttribute( "_change_attached" );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

	// nodes may contain either an explicit document object,
	// a jQuery collection or context object.
	// If nodes[0] contains a valid object to assign to doc
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

	// Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	// Skip scripts, get other children
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			// IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType, script, j,
				ret = [];

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div"),
						safeChildNodes = safeFragment.childNodes,
						remove;

					// Append wrapper element to unknown element safe doc fragment
					if ( context === document ) {
						// Use the fragment we've already created for this document
						safeFragment.appendChild( div );
					} else {
						// Use a fragment created with the owner document
						createSafeFragment( context ).appendChild( div );
					}

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;

					// Clear elements from DocumentFragment (safeFragment or otherwise)
					// to avoid hoarding elements. Fixes #11356
					if ( div ) {
						div.parentNode.removeChild( div );

						// Guard against -1 index exceptions in FF3.6
						if ( safeChildNodes.length > 0 ) {
							remove = safeChildNodes[ safeChildNodes.length - 1 ];

							if ( remove && remove.parentNode ) {
								remove.parentNode.removeChild( remove );
							}
						}
					}
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				script = ret[i];
				if ( scripts && jQuery.nodeName( script, "script" ) && (!script.type || rscriptType.test( script.type )) ) {
					scripts.push( script.parentNode ? script.parentNode.removeChild( script ) : script );

				} else {
					if ( script.nodeType === 1 ) {
						var jsTags = jQuery.grep( script.getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( script );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnum = /^[\-+]?(?:\d*\.)?\d+$/i,
	rnumnonpx = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
	rrelNum = /^([\-+])=([\-+.\de]+)/,
	rmargin = /^margin/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },

	// order is important!
	cssExpand = [ "Top", "Right", "Bottom", "Left" ],

	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	return jQuery.access( this, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	}, name, value, arguments.length > 1 );
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {},
			ret, name;

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// DEPRECATED in 1.3, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle, width,
			style = elem.style;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {

			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// WebKit uses "computed value (percentage if specified)" instead of "used value" for margins
		// which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !jQuery.support.pixelMargin && computedStyle && rmargin.test( name ) && rnumnonpx.test( ret ) ) {
			width = style.width;
			style.width = ret;
			ret = computedStyle.width;
			style.width = width;
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( rnumnonpx.test( ret ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		i = name === "width" ? 1 : 0,
		len = 4;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i += 2 ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ];
	}

	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test(val) ) {
		return val;
	}

	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		for ( ; i < len; i += 2 ) {
			val += parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ]) ) || 0;
			}
		}
	}

	return val + "px";
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWidthOrHeight( elem, name, extra );
				} else {
					return jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					});
				}
			}
		},

		set: function( elem, value ) {
			return rnum.test( value ) ?
				value + "px" :
				value;
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						return curCSS( elem, "margin-right" );
					} else {
						return elem.style.marginRight;
					}
				});
			}
		};
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {

	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i,

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ],
				expanded = {};

			for ( i = 0; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};
});




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts,

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for ( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if ( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = ( typeof s.data === "string" ) && /^application\/x\-www\-form\-urlencoded/.test( s.contentType );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									try {
										responses.text = xhr.responseText;
									} catch( _ ) {
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( (display === "" && jQuery.css(elem, "display") === "none") ||
						!jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		function doAnimation() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e, hooks, replace,
				parts, start, end, unit,
				method;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			// first pass over propertys to expand / normalize
			for ( p in prop ) {
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				if ( ( hooks = jQuery.cssHooks[ name ] ) && "expand" in hooks ) {
					replace = hooks.expand( prop[ name ] );
					delete prop[ name ];

					// not quite $.extend, this wont overwrite keys already present.
					// also - reusing 'p' from above because we have the correct "name"
					for ( p in replace ) {
						if ( ! ( p in prop ) ) {
							prop[ p ] = replace[ p ];
						}
					}
				}
			}

			for ( name in prop ) {
				val = prop[ name ];
				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

					// Tracks whether to show or hide based on private
					// data attached to the element
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		}

		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

						// force the next step to be the last
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return ( -Math.cos( p*Math.PI ) / 2 ) + 0.5;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				if ( self.options.hide ) {
					jQuery._data( self.elem, "fxshow" + self.prop, self.start );
				} else if ( self.options.show ) {
					jQuery._data( self.elem, "fxshow" + self.prop, self.end );
				}
			}
		};

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

	// Simple 'show' function
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any flash of content
		if ( dataShow !== undefined ) {
			// This show is picking up where a previous hide or show left off
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom( this.cur(), 0 );
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery( elem ).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						// Toggle data is no longer needed
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}

				// Execute the complete function
				// in the event that the complete function throws an exception
				// we must ensure it won't be called twice. #5684

				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

// Ensure props that can't be negative don't go there on undershoot easing
jQuery.each( fxAttrs.concat.apply( [], fxAttrs ), function( i, prop ) {
	// exclude marginTop, marginLeft, marginBottom and marginRight from this list
	if ( prop.indexOf( "margin" ) ) {
		jQuery.fx.step[ prop ] = function( fx ) {
			jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
		};
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( jQuery.support.boxModel ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var getOffset,
	rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	getOffset = function( elem, doc, docElem, box ) {
		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow( doc ),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	getOffset = function( elem, doc, docElem ) {
		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var elem = this[0],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return null;
	}

	if ( elem === doc.body ) {
		return jQuery.offset.bodyOffset( elem );
	}

	return getOffset( elem, doc, doc.documentElement );
};

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					jQuery.support.boxModel && win.document.documentElement[ method ] ||
						win.document.body[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					 top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	var clientProp = "client" + name,
		scrollProp = "scroll" + name,
		offsetProp = "offset" + name;

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( value ) {
		return jQuery.access( this, function( elem, type, value ) {
			var doc, docElemProp, orig, ret;

			if ( jQuery.isWindow( elem ) ) {
				// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
				doc = elem.document;
				docElemProp = doc.documentElement[ clientProp ];
				return jQuery.support.boxModel && docElemProp ||
					doc.body && doc.body[ clientProp ] || docElemProp;
			}

			// Get document width or height
			if ( elem.nodeType === 9 ) {
				// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
				doc = elem.documentElement;

				// when a window > document, IE6 reports a offset[Width/Height] > client[Width/Height]
				// so we can't use max, as it'll choose the incorrect offset[Width/Height]
				// instead we use the correct client[Width/Height]
				// support:IE6
				if ( doc[ clientProp ] >= doc[ scrollProp ] ) {
					return doc[ clientProp ];
				}

				return Math.max(
					elem.body[ scrollProp ], doc[ scrollProp ],
					elem.body[ offsetProp ], doc[ offsetProp ]
				);
			}

			// Get width or height on the element
			if ( value === undefined ) {
				orig = jQuery.css( elem, type );
				ret = parseFloat( orig );
				return jQuery.isNumeric( ret ) ? ret : orig;
			}

			// Set the width or height on the element
			jQuery( elem ).css( type, value );
		}, type, value, arguments.length, null );
	};
});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );

```

`LibreHardwareMonitor/Resources/Web/js/jquery-1.7.2.min.js`:

```js
/*! jQuery v1.7.2 jquery.com | jquery.org/license */
(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cu(a){if(!cj[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){ck||(ck=c.createElement("iframe"),ck.frameBorder=ck.width=ck.height=0),b.appendChild(ck);if(!cl||!ck.createElement)cl=(ck.contentWindow||ck.contentDocument).document,cl.write((f.support.boxModel?"<!doctype html>":"")+"<html><body>"),cl.close();d=cl.createElement(a),cl.body.appendChild(d),e=f.css(d,"display"),b.removeChild(ck)}cj[a]=e}return cj[a]}function ct(a,b){var c={};f.each(cp.concat.apply([],cp.slice(0,b)),function(){c[this]=a});return c}function cs(){cq=b}function cr(){setTimeout(cs,0);return cq=f.now()}function ci(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ch(){try{return new a.XMLHttpRequest}catch(b){}}function cb(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function ca(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function b_(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bD.test(a)?d(a,e):b_(a+"["+(typeof e=="object"?b:"")+"]",e,c,d)});else if(!c&&f.type(b)==="object")for(var e in b)b_(a+"["+e+"]",b[e],c,d);else d(a,b)}function b$(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function bZ(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bS,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=bZ(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=bZ(a,c,d,e,"*",g));return l}function bY(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bO),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function bB(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?1:0,g=4;if(d>0){if(c!=="border")for(;e<g;e+=2)c||(d-=parseFloat(f.css(a,"padding"+bx[e]))||0),c==="margin"?d+=parseFloat(f.css(a,c+bx[e]))||0:d-=parseFloat(f.css(a,"border"+bx[e]+"Width"))||0;return d+"px"}d=by(a,b);if(d<0||d==null)d=a.style[b];if(bt.test(d))return d;d=parseFloat(d)||0;if(c)for(;e<g;e+=2)d+=parseFloat(f.css(a,"padding"+bx[e]))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+bx[e]+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+bx[e]))||0);return d+"px"}function bo(a){var b=c.createElement("div");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||"").toLowerCase();b==="input"?bm(a):b!=="script"&&typeof a.getElementsByTagName!="undefined"&&f.grep(a.getElementsByTagName("input"),bm)}function bm(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bk(a,b){var c;b.nodeType===1&&(b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase(),c==="object"?b.outerHTML=a.outerHTML:c!=="input"||a.type!=="checkbox"&&a.type!=="radio"?c==="option"?b.selected=a.defaultSelected:c==="input"||c==="textarea"?b.defaultValue=a.defaultValue:c==="script"&&b.text!==a.text&&(b.text=a.text):(a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value)),b.removeAttribute(f.expando),b.removeAttribute("_submit_attached"),b.removeAttribute("_change_attached"))}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c,i[c][d])}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function U(a){var b=V.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+"defer",e=b+"queue",g=b+"mark",h=f._data(a,d);h&&(c==="queue"||!f._data(a,e))&&(c==="mark"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b==="data"&&f.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(k,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNumeric(d)?+d:j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,n=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,q=/(?:^|:|,)(?:\s*\[)+/g,r=/(webkit)[ \/]([\w.]+)/,s=/(opera)(?:.*version)?[ \/]([\w.]+)/,t=/(msie) ([\w.]+)/,u=/(mozilla)(?:.*? rv:([\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+"").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.7.2",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),"slice",F.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").off("ready")}},bindReady:function(){if(!A){A=e.Callbacks("once memory");if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",B,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",B),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a!=null&&a==a.window},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,"constructor")&&!D.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,"@").replace(p,"]").replace(q,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){if(typeof c!="string"||!c)return null;var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,"ms-").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?"":G.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h,i){var j,k=d==null,l=0,m=a.length;if(d&&typeof d=="object"){for(l in d)e.access(a,c,l,d[l],1,h,f);g=1}else if(f!==b){j=i===b&&e.isFunction(f),k&&(j?(j=c,c=function(a,b,c){return j.call(e(a),c)}):(c.call(a,f),c=null));if(c)for(;l<m;l++)c(a[l],d,j?f.call(a[l],l,c(a[l],d)):f,i);g=1}return g?a:k?c.call(a):m?c(a[0],d):h},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf("compatible")<0&&u.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){I["[object "+b+"]"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener("DOMContentLoaded",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m,n=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h==="array"?n(g):h==="function"&&(!a.unique||!p.has(g))&&c.push(g)},o=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,j=!0,m=k||0,k=0,l=c.length;for(;c&&m<l;m++)if(c[m].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}j=!1,c&&(a.once?e===!0?p.disable():c=[]:d&&d.length&&(e=d.shift(),p.fireWith(e[0],e[1])))},p={add:function(){if(c){var a=c.length;n(arguments),j?l=c.length:e&&e!==!0&&(k=a,o(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){j&&f<=l&&(l--,f<=m&&m--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&p.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(j?a.once||d.push([b,c]):(!a.once||!e)&&o(b,c));return this},fire:function(){p.fireWith(this,arguments);return this},fired:function(){return!!i}};return p};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks("once memory"),c=f.Callbacks("once memory"),d=f.Callbacks("memory"),e="pending",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[b,"reject"],progress:[c,"notify"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+"With"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+"With"]=g[j].fireWith;i.done(function(){e="resolved"},c.disable,d.lock).fail(function(){e="rejected"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p=c.createElement("div"),q=c.documentElement;p.setAttribute("className","t"),p.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=p.getElementsByTagName("*"),e=p.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=p.getElementsByTagName("input")[0],b={leadingWhitespace:p.firstChild.nodeType===3,tbody:!p.getElementsByTagName("tbody").length,htmlSerialize:!!p.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:p.className!=="t",enctype:!!c.createElement("form").enctype,html5Clone:c.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,pixelMargin:!0},f.boxModel=b.boxModel=c.compatMode==="CSS1Compat",i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete p.test}catch(r){b.deleteExpando=!1}!p.addEventListener&&p.attachEvent&&p.fireEvent&&(p.attachEvent("onclick",function(){b.noCloneEvent=!1}),p.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),b.radioValue=i.value==="t",i.setAttribute("checked","checked"),i.setAttribute("name","t"),p.appendChild(i),j=c.createDocumentFragment(),j.appendChild(p.lastChild),b.checkClone=j.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,j.removeChild(i),j.appendChild(p);if(p.attachEvent)for(n in{submit:1,change:1,focusin:1})m="on"+n,o=m in p,o||(p.setAttribute(m,"return;"),o=typeof p[m]=="function"),b[n+"Bubbles"]=o;j.removeChild(p),j=g=h=p=i=null,f(function(){var d,e,g,h,i,j,l,m,n,q,r,s,t,u=c.getElementsByTagName("body")[0];!u||(m=1,t="padding:0;margin:0;border:",r="position:absolute;top:0;left:0;width:1px;height:1px;",s=t+"0;visibility:hidden;",n="style='"+r+t+"5px solid #000;",q="<div "+n+"display:block;'><div style='"+t+"0;display:block;overflow:hidden;'></div></div>"+"<table "+n+"' cellpadding='0' cellspacing='0'>"+"<tr><td></td></tr></table>",d=c.createElement("div"),d.style.cssText=s+"width:0;height:0;position:static;top:0;margin-top:"+m+"px",u.insertBefore(d,u.firstChild),p=c.createElement("div"),d.appendChild(p),p.innerHTML="<table><tr><td style='"+t+"0;display:none'></td><td>t</td></tr></table>",k=p.getElementsByTagName("td"),o=k[0].offsetHeight===0,k[0].style.display="",k[1].style.display="none",b.reliableHiddenOffsets=o&&k[0].offsetHeight===0,a.getComputedStyle&&(p.innerHTML="",l=c.createElement("div"),l.style.width="0",l.style.marginRight="0",p.style.width="2px",p.appendChild(l),b.reliableMarginRight=(parseInt((a.getComputedStyle(l,null)||{marginRight:0}).marginRight,10)||0)===0),typeof p.style.zoom!="undefined"&&(p.innerHTML="",p.style.width=p.style.padding="1px",p.style.border=0,p.style.overflow="hidden",p.style.display="inline",p.style.zoom=1,b.inlineBlockNeedsLayout=p.offsetWidth===3,p.style.display="block",p.style.overflow="visible",p.innerHTML="<div style='width:5px;'></div>",b.shrinkWrapBlocks=p.offsetWidth!==3),p.style.cssText=r+s,p.innerHTML=q,e=p.firstChild,g=e.firstChild,i=e.nextSibling.firstChild.firstChild,j={doesNotAddBorder:g.offsetTop!==5,doesAddBorderForTableAndCells:i.offsetTop===5},g.style.position="fixed",g.style.top="20px",j.fixedPosition=g.offsetTop===20||g.offsetTop===15,g.style.position=g.style.top="",e.style.overflow="hidden",e.style.position="relative",j.subtractsBorderForOverflowNotVisible=g.offsetTop===-5,j.doesNotIncludeMarginInBodyOffset=u.offsetTop!==m,a.getComputedStyle&&(p.style.marginTop="1%",b.pixelMargin=(a.getComputedStyle(p,null)||{marginTop:0}).marginTop!=="1%"),typeof d.style.zoom!="undefined"&&(d.style.zoom=1),u.removeChild(d),l=p=d=null,f.extend(b,j))});return b}();var j=/^(?:\{.*\}|\[.*\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c=="string",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c==="events";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h,i,j=this[0],k=0,m=null;if(a===b){if(this.length){m=f.data(j);if(j.nodeType===1&&!f._data(j,"parsedAttrs")){g=j.attributes;for(i=g.length;k<i;k++)h=g[k].name,h.indexOf("data-")===0&&(h=f.camelCase(h.substring(5)),l(j,h,m[h]));f._data(j,"parsedAttrs",!0)}}return m}if(typeof a=="object")return this.each(function(){f.data(this,a)});d=a.split(".",2),d[1]=d[1]?"."+d[1]:"",e=d[1]+"!";return f.access(this,function(c){if(c===b){m=this.triggerHandler("getData"+e,[d[0]]),m===b&&j&&(m=f.data(j,a),m=l(j,a,m));return m===b&&d[1]?this.data(d[0]):m}d[1]=c,this.each(function(){var b=f(this);b.triggerHandler("setData"+e,d),f.data(this,a,c),b.triggerHandler("changeData"+e,d)})},null,c,arguments.length>1,null,!1)},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||"fx")+"mark",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||"fx";var d=c+"mark",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,"mark"))}},queue:function(a,b,c){var d;if(a){b=(b||"fx")+"queue",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e={};d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),f._data(a,b+".run",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+"queue "+b+".run",!0),n(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){var d=2;typeof a!="string"&&(c=a,a="fx",d--);if(arguments.length<d)return f.queue(this[0],a);return c===b?this:this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks("once memory"),!0))h++,l.add(m);m();return d.promise(c)}});var o=/[\n\t\r]/g,p=/\s+/,q=/\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,f.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,f.prop,a,b,arguments.length>1)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(o," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(o," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.type]||f.valHooks[this.nodeName.toLowerCase()];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}if(g){c=f.valHooks[g.type]||f.valHooks[g.nodeName.toLowerCase()];if(c&&"get"in c&&(d=c.get(g,"value"))!==b)return d;d=g.value;return typeof d=="string"?d.replace(q,""):d==null?"":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type==="select-one";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,"optgroup"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute=="undefined")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&"set"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,""+d);return d}if(h&&"get"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h,i=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;i<g;i++)e=d[i],e&&(c=f.propFix[e]||e,h=u.test(e),h||f.attr(a,e,""),a.removeAttribute(v?e:c),h&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,"button"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,"button"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&"set"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&"get"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0,coords:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!=="":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.attrHooks.tabindex.set=w.set,f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===""&&(b="false"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype="encoding"),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\.]*)?(?:\.(.+))?$/,B=/(?:^|\s)hover(\.\S+)?\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,G=function(
a){var b=F.exec(a);b&&(b[1]=(b[1]||"").toLowerCase(),b[3]=b[3]&&new RegExp("(?:^|\\s)"+b[3]+"(?:\\s|$)"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c["class"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,"mouseenter$1 mouseleave$1")};f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler,g=p.selector),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(" ");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||"").split(".").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:g&&G(g),namespace:n.join(".")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent("on"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||"")).split(" ");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp("(^|\\.)"+l.split(".").sort().join("\\.(?:.*\\.)?")+"(\\.|$)"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d==="**"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,["events","handle"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf("!")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)"):null,o=h.indexOf(":")<0?"on"+h:"";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,"events")||{})[c.type]&&f._data(m,"handle"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)&&o&&e[h]&&(h!=="focus"&&h!=="blur"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,"events")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=f.event.special[c.type]||{},j=[],k,l,m,n,o,p,q,r,s,t,u;g[0]=c,c.delegateTarget=this;if(!i.preDispatch||i.preDispatch.call(this,c)!==!1){if(e&&(!c.button||c.type!=="click")){n=f(this),n.context=this.ownerDocument||this;for(m=c.target;m!=this;m=m.parentNode||this)if(m.disabled!==!0){p={},r=[],n[0]=m;for(k=0;k<e;k++)s=d[k],t=s.selector,p[t]===b&&(p[t]=s.quick?H(m,s.quick):n.is(t)),p[t]&&r.push(s);r.length&&j.push({elem:m,matches:r})}}d.length>e&&j.push({elem:this,matches:d.slice(e)});for(k=0;k<j.length&&!c.isPropagationStopped();k++){q=j[k],c.currentTarget=q.elem;for(l=0;l<q.matches.length&&!c.isImmediatePropagationStopped();l++){s=q.matches[l];if(h||!c.namespace&&!s.namespace||c.namespace_re&&c.namespace_re.test(s.namespace))c.data=s.data,c.handleObj=s,o=((f.event.special[s.origType]||{}).handle||s.handler).apply(q.elem,g),o!==b&&(c.result=o,o===!1&&(c.preventDefault(),c.stopPropagation()))}}i.postDispatch&&i.postDispatch.call(this,c);return c.result}},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,"form"))return!1;f.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=f.nodeName(c,"input")||f.nodeName(c,"button")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,"submit._submit",function(a){a._submit_bubble=!0}),d._submit_attached=!0)})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&f.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){if(f.nodeName(this,"form"))return!1;f.event.remove(this,"._submit")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")f.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),f.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate("change",this,a,!0))});return!1}f.event.add(this,"beforeactivate._change",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate("change",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,"._change");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a=="object"){typeof c!="string"&&(d=d||c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.origType+"."+e.namespace:e.origType,e.selector,e.handler);return this}if(typeof a=="object"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c=="function")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||"**",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,"**"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,"lastToggle"+a.guid)||0)%d;f._data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!="string"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d="sizcache"+(Math.random()+"").replace(".",""),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\/g,k=/\r\n/g,l=/\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(""),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]==="~"||w[0]==="+")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q="",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)==="[object Array]")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!=="\\"){g[1]=(g[1]||"").replace(j,""),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)==="\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],"");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e="";if(d){if(d===1||d===9||d===11){if(typeof a.textContent=="string")return a.textContent;if(typeof a.innerText=="string")return a.innerText.replace(k,"");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},"":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("parentNode",b,f,a,d,c)},"~":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("previousSibling",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(j,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,"")},TAG:function(a,b){return a[1].replace(j,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,"");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(j,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||n([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case"only":case"first":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k==="first")return!0;l=a;case"last":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case"nth":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":!f&&m.attr?d!=null:f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return"\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\[]*\])(?![^\(]*\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[r].source.replace(/\\(\d+)/g,q));o.match.globalPOS=p;var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(o.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var k=e,l=e.getAttribute("id"),n=l||d,p=e.parentNode,q=/^\s*[+~]/.test(b);l?n=n.replace(/'/g,"\\$&"):e.setAttribute("id",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll("[id='"+n+"'] "+b),f)}catch(r){}finally{l||k.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;o.order.splice(1,0,"CLASS"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var y=function(a,b,c){var d,e=[],f="",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,"");a=o.relative[a]?a+"*":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[":"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\[\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.globalPOS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),"not",a)},filter:function(a){return this.pushStack(T(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp("<(?:"+V+")[\\s/>]","i"),bd=/checked\s*(?:[^=]|=\s*.checked.)/i,be=/\/(java|ecma)script/i,bf=/^\s*<!(?:\[CDATA\[|\-\-)/,bg={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){return f.access(this,function(a){return a===b?f.text(this):this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a))},null,a,arguments.length)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f
.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){return f.access(this,function(a){var c=this[0]||{},d=0,e=this.length;if(a===b)return c.nodeType===1?c.innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(;d<e;d++)c=this[d]||{},c.nodeType===1&&(f.cleanData(c.getElementsByTagName("*")),c.innerHTML=a);c=0}catch(g){}}c&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,function(a,b){b.src?f.ajax({type:"GET",global:!1,url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bf,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)})}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j=="string"&&j.length<512&&i===c&&j.charAt(0)==="<"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||f.isXMLDoc(a)||!bc.test("<"+a.nodeName+">")?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g,h,i,j=[];b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);for(var k=0,l;(l=a[k])!=null;k++){typeof l=="number"&&(l+="");if(!l)continue;if(typeof l=="string")if(!_.test(l))l=b.createTextNode(l);else{l=l.replace(Y,"<$1></$2>");var m=(Z.exec(l)||["",""])[1].toLowerCase(),n=bg[m]||bg._default,o=n[0],p=b.createElement("div"),q=bh.childNodes,r;b===c?bh.appendChild(p):U(b).appendChild(p),p.innerHTML=n[1]+l+n[2];while(o--)p=p.lastChild;if(!f.support.tbody){var s=$.test(l),t=m==="table"&&!s?p.firstChild&&p.firstChild.childNodes:n[1]==="<table>"&&!s?p.childNodes:[];for(i=t.length-1;i>=0;--i)f.nodeName(t[i],"tbody")&&!t[i].childNodes.length&&t[i].parentNode.removeChild(t[i])}!f.support.leadingWhitespace&&X.test(l)&&p.insertBefore(b.createTextNode(X.exec(l)[0]),p.firstChild),l=p.childNodes,p&&(p.parentNode.removeChild(p),q.length>0&&(r=q[q.length-1],r&&r.parentNode&&r.parentNode.removeChild(r)))}var u;if(!f.support.appendChecked)if(l[0]&&typeof (u=l.length)=="number")for(i=0;i<u;i++)bn(l[i]);else bn(l);l.nodeType?j.push(l):j=f.merge(j,l)}if(d){g=function(a){return!a.type||be.test(a.type)};for(k=0;j[k];k++){h=j[k];if(e&&f.nodeName(h,"script")&&(!h.type||be.test(h.type)))e.push(h.parentNode?h.parentNode.removeChild(h):h);else{if(h.nodeType===1){var v=f.grep(h.getElementsByTagName("script"),g);j.splice.apply(j,[k+1,0].concat(v))}d.appendChild(h)}}}return j},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bp=/alpha\([^)]*\)/i,bq=/opacity=([^)]*)/,br=/([A-Z]|^ms)/g,bs=/^[\-+]?(?:\d*\.)?\d+$/i,bt=/^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,bu=/^([\-+])=([\-+.\de]+)/,bv=/^margin/,bw={position:"absolute",visibility:"hidden",display:"block"},bx=["Top","Right","Bottom","Left"],by,bz,bA;f.fn.css=function(a,c){return f.access(this,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)},a,c,arguments.length>1)},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=by(a,"opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=bu.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(by)return by(a,c)},swap:function(a,b,c){var d={},e,f;for(f in b)d[f]=a.style[f],a.style[f]=b[f];e=c.call(a);for(f in b)a.style[f]=d[f];return e}}),f.curCSS=f.css,c.defaultView&&c.defaultView.getComputedStyle&&(bz=function(a,b){var c,d,e,g,h=a.style;b=b.replace(br,"-$1").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===""&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b))),!f.support.pixelMargin&&e&&bv.test(b)&&bt.test(c)&&(g=h.width,h.width=c,c=e.width,h.width=g);return c}),c.documentElement.currentStyle&&(bA=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f==null&&g&&(e=g[b])&&(f=e),bt.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b==="fontSize"?"1em":f,f=g.pixelLeft+"px",g.left=c,d&&(a.runtimeStyle.left=d));return f===""?"auto":f}),by=bz||bA,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){if(c)return a.offsetWidth!==0?bB(a,b,d):f.swap(a,bw,function(){return bB(a,b,d)})},set:function(a,b){return bs.test(b)?b+"px":b}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return bq.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?"alpha(opacity="+b*100+")":"",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bp,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bp.test(g)?g.replace(bp,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){return f.swap(a,{display:"inline-block"},function(){return b?by(a,"margin-right"):a.style.marginRight})}})}),f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)}),f.each({margin:"",padding:"",border:"Width"},function(a,b){f.cssHooks[a+b]={expand:function(c){var d,e=typeof c=="string"?c.split(" "):[c],f={};for(d=0;d<4;d++)f[a+bx[d]+b]=e[d]||e[d-2]||e[0];return f}}});var bC=/%20/g,bD=/\[\]$/,bE=/\r?\n/g,bF=/#.*$/,bG=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bH=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bI=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bJ=/^(?:GET|HEAD)$/,bK=/^\/\//,bL=/\?/,bM=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bN=/^(?:select|textarea)/i,bO=/\s+/,bP=/([?&])_=[^&]*/,bQ=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bR=f.fn.load,bS={},bT={},bU,bV,bW=["*/"]+["*"];try{bU=e.href}catch(bX){bU=c.createElement("a"),bU.href="",bU=bU.href}bV=bQ.exec(bU.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bR)return bR.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bM,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bN.test(this.nodeName)||bH.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bE,"\r\n")}}):{name:b.name,value:c.replace(bE,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?b$(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b$(a,b);return a},ajaxSettings:{url:bU,isLocal:bI.test(bV[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded; charset=UTF-8",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bW},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bY(bS),ajaxTransport:bY(bT),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?ca(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=cb(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks("once memory"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bG.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bF,"").replace(bK,bV[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bO),d.crossDomain==null&&(r=bQ.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bV[1]&&r[2]==bV[2]&&(r[3]||(r[1]==="http:"?80:443))==(bV[3]||(bV[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),bZ(bS,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bJ.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bL.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bP,"$1_="+x);d.url=y+(y===d.url?(bL.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bW+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=bZ(bT,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)b_(g,a[g],c,e);return d.join("&").replace(bC,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var cc=f.now(),cd=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+cc++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=typeof b.data=="string"&&/^application\/x\-www\-form\-urlencoded/.test(b.contentType);if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(cd.test(b.url)||e&&cd.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(cd,l),b.url===j&&(e&&(k=k.replace(cd,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var ce=a.ActiveXObject?function(){for(var a in cg)cg[a](0,1)}:!1,cf=0,cg;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ch()||ci()}:ch,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,ce&&delete cg[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n);try{m.text=h.responseText}catch(a){}try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cf,ce&&(cg||(cg={},f(a).unload(ce)),cg[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var cj={},ck,cl,cm=/^(?:toggle|show|hide)$/,cn=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,co,cp=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cq;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(ct("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),(e===""&&f.css(d,"display")==="none"||!f.contains(d.ownerDocument.documentElement,d))&&f._data(d,"olddisplay",cu(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(ct("hide",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,"display"),e!=="none"&&!f._data(d,"olddisplay")&&f._data(d,"olddisplay",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(ct("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o,p,q;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]);if((k=f.cssHooks[g])&&"expand"in k){l=k.expand(a[g]),delete a[g];for(i in l)i in a||(a[i]=l[i])}}for(g in a){h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(!f.support.inlineBlockNeedsLayout||cu(this.nodeName)==="inline"?this.style.display="inline-block":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)j=new f.fx(this,b,i),h=a[i],cm.test(h)?(q=f._data(this,"toggle"+i)||(h==="toggle"?d?"show":"hide":0),q?(f._data(this,"toggle"+i,q==="show"?"hide":"show"),j[q]()):j[h]()):(m=cn.exec(h),n=j.cur(),m?(o=parseFloat(m[2]),p=m[3]||(f.cssNumber[i]?"":"px"),p!=="px"&&(f.style(this,i,(o||1)+p),n=(o||1)/j.cur()*n,f.style(this,i,n+p)),m[1]&&(o=(m[1]==="-="?-1:1)*o+n),j.custom(n,o,p)):j.custom(n,h,""));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(".run")===b.length-4&&h(this,g,b);else g[b=a+".run"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:ct("show",1),slideUp:ct("hide",1),slideToggle:ct("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a){return a},swing:function(a){return-Math.cos(a*Math.PI)/2+.5}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cq||cr(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?"":"px"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){f._data(e.elem,"fxshow"+e.prop)===b&&(e.options.hide?f._data(e.elem,"fxshow"+e.prop,e.start):e.options.show&&f._data(e.elem,"fxshow"+e.prop,e.end))},h()&&f.timers.push(h)&&!co&&(co=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,"fxshow"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,"fxshow"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cq||cr(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){h.style["overflow"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,"fxshow"+b,!0),f.removeData(h,"toggle"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(co),co=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(cp.concat.apply([],cp),function(a,b){b.indexOf("margin")&&(f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)})}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cv,cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?cv=function(a,b,c,d){try{d=a.getBoundingClientRect()}catch(e){}if(!d||!f.contains(c,a))return d?{top:d.top,left:d.left}:{top:0,left:0};var g=b.body,h=cy(b),i=c.clientTop||g.clientTop||0,j=c.clientLeft||g.clientLeft||0,k=h.pageYOffset||f.support.boxModel&&c.scrollTop||g.scrollTop,l=h.pageXOffset||f.support.boxModel&&c.scrollLeft||g.scrollLeft,m=d.top+k-i,n=d.left+l-j;return{top:m,left:n}}:cv=function(a,b,c){var d,e=a.offsetParent,g=a,h=b.body,i=b.defaultView,j=i?i.getComputedStyle(a,null):a.currentStyle,k=a.offsetTop,l=a.offsetLeft;while((a=a.parentNode)&&a!==h&&a!==c){if(f.support.fixedPosition&&j.position==="fixed")break;d=i?i.getComputedStyle(a,null):a.currentStyle,k-=a.scrollTop,l-=a.scrollLeft,a===e&&(k+=a.offsetTop,l+=a.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(a.nodeName))&&(k+=parseFloat(d.borderTopWidth)||0,l+=parseFloat(d.borderLeftWidth)||0),g=e,e=a.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"&&(k+=parseFloat(d.borderTopWidth)||0,l+=parseFloat(d.borderLeftWidth)||0),j=d}if(j.position==="relative"||j.position==="static")k+=h.offsetTop,l+=h.offsetLeft;f.support.fixedPosition&&j.position==="fixed"&&(k+=Math.max(c.scrollTop,h.scrollTop),l+=Math.max(c.scrollLeft,h.scrollLeft));return{top:k,left:l}},f.fn.offset=function(a){if(arguments.length)return a===b?this:this.each(function(b){f.offset.setOffset(this,a,b)});var c=this[0],d=c&&c.ownerDocument;if(!d)return null;if(c===d.body)return f.offset.bodyOffset(c);return cv(c,d,d.documentElement)},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,c){var d=/Y/.test(c);f.fn[a]=function(e){return f.access(this,function(a,e,g){var h=cy(a);if(g===b)return h?c in h?h[c]:f.support.boxModel&&h.document.documentElement[e]||h.document.body[e]:a[e];h?h.scrollTo(d?f(h).scrollLeft():g,d?g:f(h).scrollTop()):a[e]=g},a,e,arguments.length,null)}}),f.each({Height:"height",Width:"width"},function(a,c){var d="client"+a,e="scroll"+a,g="offset"+a;f.fn["inner"+a]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,c,"padding")):this[c]():null},f.fn["outer"+a]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,c,a?"margin":"border")):this[c]():null},f.fn[c]=function(a){return f.access(this,function(a,c,h){var i,j,k,l;if(f.isWindow(a)){i=a.document,j=i.documentElement[d];return f.support.boxModel&&j||i.body&&i.body[d]||j}if(a.nodeType===9){i=a.documentElement;if(i[d]>=i[e])return i[d];return Math.max(a.body[e],i[e],a.body[g],i[g])}if(h===b){k=f.css(a,c),l=parseFloat(k);return f.isNumeric(l)?l:k}f(a).css(c,h)},c,a,arguments.length,null)}}),a.jQuery=a.$=f,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return f})})(window);
```

`LibreHardwareMonitor/Resources/Web/js/jquery-ui-1.8.16.custom.min.js`:

```js
/*!
 * jQuery UI 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function(c,j){function k(a,b){var d=a.nodeName.toLowerCase();if("area"===d){b=a.parentNode;d=b.name;if(!a.href||!d||b.nodeName.toLowerCase()!=="map")return false;a=c("img[usemap=#"+d+"]")[0];return!!a&&l(a)}return(/input|select|textarea|button|object/.test(d)?!a.disabled:"a"==d?a.href||b:b)&&l(a)}function l(a){return!c(a).parents().andSelf().filter(function(){return c.curCSS(this,"visibility")==="hidden"||c.expr.filters.hidden(this)}).length}c.ui=c.ui||{};if(!c.ui.version){c.extend(c.ui,{version:"1.8.16",
keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}});c.fn.extend({propAttr:c.fn.prop||c.fn.attr,_focus:c.fn.focus,focus:function(a,b){return typeof a==="number"?this.each(function(){var d=
this;setTimeout(function(){c(d).focus();b&&b.call(d)},a)}):this._focus.apply(this,arguments)},scrollParent:function(){var a;a=c.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(c.curCSS(this,"position",1))&&/(auto|scroll)/.test(c.curCSS(this,"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(c.curCSS(this,
"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0);return/fixed/.test(this.css("position"))||!a.length?c(document):a},zIndex:function(a){if(a!==j)return this.css("zIndex",a);if(this.length){a=c(this[0]);for(var b;a.length&&a[0]!==document;){b=a.css("position");if(b==="absolute"||b==="relative"||b==="fixed"){b=parseInt(a.css("zIndex"),10);if(!isNaN(b)&&b!==0)return b}a=a.parent()}}return 0},disableSelection:function(){return this.bind((c.support.selectstart?"selectstart":
"mousedown")+".ui-disableSelection",function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}});c.each(["Width","Height"],function(a,b){function d(f,g,m,n){c.each(e,function(){g-=parseFloat(c.curCSS(f,"padding"+this,true))||0;if(m)g-=parseFloat(c.curCSS(f,"border"+this+"Width",true))||0;if(n)g-=parseFloat(c.curCSS(f,"margin"+this,true))||0});return g}var e=b==="Width"?["Left","Right"]:["Top","Bottom"],h=b.toLowerCase(),i={innerWidth:c.fn.innerWidth,innerHeight:c.fn.innerHeight,
outerWidth:c.fn.outerWidth,outerHeight:c.fn.outerHeight};c.fn["inner"+b]=function(f){if(f===j)return i["inner"+b].call(this);return this.each(function(){c(this).css(h,d(this,f)+"px")})};c.fn["outer"+b]=function(f,g){if(typeof f!=="number")return i["outer"+b].call(this,f);return this.each(function(){c(this).css(h,d(this,f,true,g)+"px")})}});c.extend(c.expr[":"],{data:function(a,b,d){return!!c.data(a,d[3])},focusable:function(a){return k(a,!isNaN(c.attr(a,"tabindex")))},tabbable:function(a){var b=c.attr(a,
"tabindex"),d=isNaN(b);return(d||b>=0)&&k(a,!d)}});c(function(){var a=document.body,b=a.appendChild(b=document.createElement("div"));c.extend(b.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0});c.support.minHeight=b.offsetHeight===100;c.support.selectstart="onselectstart"in b;a.removeChild(b).style.display="none"});c.extend(c.ui,{plugin:{add:function(a,b,d){a=c.ui[a].prototype;for(var e in d){a.plugins[e]=a.plugins[e]||[];a.plugins[e].push([b,d[e]])}},call:function(a,b,d){if((b=a.plugins[b])&&
a.element[0].parentNode)for(var e=0;e<b.length;e++)a.options[b[e][0]]&&b[e][1].apply(a.element,d)}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(a,b){if(c(a).css("overflow")==="hidden")return false;b=b&&b==="left"?"scrollLeft":"scrollTop";var d=false;if(a[b]>0)return true;a[b]=1;d=a[b]>0;a[b]=0;return d},isOverAxis:function(a,b,d){return a>b&&a<b+d},isOver:function(a,b,d,e,h,i){return c.ui.isOverAxis(a,d,h)&&
c.ui.isOverAxis(b,e,i)}})}})(jQuery);
;/*!
 * jQuery UI Widget 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function(b,j){if(b.cleanData){var k=b.cleanData;b.cleanData=function(a){for(var c=0,d;(d=a[c])!=null;c++)try{b(d).triggerHandler("remove")}catch(e){}k(a)}}else{var l=b.fn.remove;b.fn.remove=function(a,c){return this.each(function(){if(!c)if(!a||b.filter(a,[this]).length)b("*",this).add([this]).each(function(){try{b(this).triggerHandler("remove")}catch(d){}});return l.call(b(this),a,c)})}}b.widget=function(a,c,d){var e=a.split(".")[0],f;a=a.split(".")[1];f=e+"-"+a;if(!d){d=c;c=b.Widget}b.expr[":"][f]=
function(h){return!!b.data(h,a)};b[e]=b[e]||{};b[e][a]=function(h,g){arguments.length&&this._createWidget(h,g)};c=new c;c.options=b.extend(true,{},c.options);b[e][a].prototype=b.extend(true,c,{namespace:e,widgetName:a,widgetEventPrefix:b[e][a].prototype.widgetEventPrefix||a,widgetBaseClass:f},d);b.widget.bridge(a,b[e][a])};b.widget.bridge=function(a,c){b.fn[a]=function(d){var e=typeof d==="string",f=Array.prototype.slice.call(arguments,1),h=this;d=!e&&f.length?b.extend.apply(null,[true,d].concat(f)):
d;if(e&&d.charAt(0)==="_")return h;e?this.each(function(){var g=b.data(this,a),i=g&&b.isFunction(g[d])?g[d].apply(g,f):g;if(i!==g&&i!==j){h=i;return false}}):this.each(function(){var g=b.data(this,a);g?g.option(d||{})._init():b.data(this,a,new c(d,this))});return h}};b.Widget=function(a,c){arguments.length&&this._createWidget(a,c)};b.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:false},_createWidget:function(a,c){b.data(c,this.widgetName,this);this.element=b(c);this.options=
b.extend(true,{},this.options,this._getCreateOptions(),a);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()});this._create();this._trigger("create");this._init()},_getCreateOptions:function(){return b.metadata&&b.metadata.get(this.element[0])[this.widgetName]},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName);this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+
"-disabled ui-state-disabled")},widget:function(){return this.element},option:function(a,c){var d=a;if(arguments.length===0)return b.extend({},this.options);if(typeof a==="string"){if(c===j)return this.options[a];d={};d[a]=c}this._setOptions(d);return this},_setOptions:function(a){var c=this;b.each(a,function(d,e){c._setOption(d,e)});return this},_setOption:function(a,c){this.options[a]=c;if(a==="disabled")this.widget()[c?"addClass":"removeClass"](this.widgetBaseClass+"-disabled ui-state-disabled").attr("aria-disabled",
c);return this},enable:function(){return this._setOption("disabled",false)},disable:function(){return this._setOption("disabled",true)},_trigger:function(a,c,d){var e=this.options[a];c=b.Event(c);c.type=(a===this.widgetEventPrefix?a:this.widgetEventPrefix+a).toLowerCase();d=d||{};if(c.originalEvent){a=b.event.props.length;for(var f;a;){f=b.event.props[--a];c[f]=c.originalEvent[f]}}this.element.trigger(c,d);return!(b.isFunction(e)&&e.call(this.element[0],c,d)===false||c.isDefaultPrevented())}}})(jQuery);
;/*!
 * jQuery UI Mouse 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function(b){var d=false;b(document).mouseup(function(){d=false});b.widget("ui.mouse",{options:{cancel:":input,option",distance:1,delay:0},_mouseInit:function(){var a=this;this.element.bind("mousedown."+this.widgetName,function(c){return a._mouseDown(c)}).bind("click."+this.widgetName,function(c){if(true===b.data(c.target,a.widgetName+".preventClickEvent")){b.removeData(c.target,a.widgetName+".preventClickEvent");c.stopImmediatePropagation();return false}});this.started=false},_mouseDestroy:function(){this.element.unbind("."+
this.widgetName)},_mouseDown:function(a){if(!d){this._mouseStarted&&this._mouseUp(a);this._mouseDownEvent=a;var c=this,f=a.which==1,g=typeof this.options.cancel=="string"&&a.target.nodeName?b(a.target).closest(this.options.cancel).length:false;if(!f||g||!this._mouseCapture(a))return true;this.mouseDelayMet=!this.options.delay;if(!this.mouseDelayMet)this._mouseDelayTimer=setTimeout(function(){c.mouseDelayMet=true},this.options.delay);if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a)){this._mouseStarted=
this._mouseStart(a)!==false;if(!this._mouseStarted){a.preventDefault();return true}}true===b.data(a.target,this.widgetName+".preventClickEvent")&&b.removeData(a.target,this.widgetName+".preventClickEvent");this._mouseMoveDelegate=function(e){return c._mouseMove(e)};this._mouseUpDelegate=function(e){return c._mouseUp(e)};b(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate);a.preventDefault();return d=true}},_mouseMove:function(a){if(b.browser.msie&&
!(document.documentMode>=9)&&!a.button)return this._mouseUp(a);if(this._mouseStarted){this._mouseDrag(a);return a.preventDefault()}if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a))(this._mouseStarted=this._mouseStart(this._mouseDownEvent,a)!==false)?this._mouseDrag(a):this._mouseUp(a);return!this._mouseStarted},_mouseUp:function(a){b(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate);if(this._mouseStarted){this._mouseStarted=
false;a.target==this._mouseDownEvent.target&&b.data(a.target,this.widgetName+".preventClickEvent",true);this._mouseStop(a)}return false},_mouseDistanceMet:function(a){return Math.max(Math.abs(this._mouseDownEvent.pageX-a.pageX),Math.abs(this._mouseDownEvent.pageY-a.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return true}})})(jQuery);
;/*
 * jQuery UI Button 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(b){var h,i,j,g,l=function(){var a=b(this).find(":ui-button");setTimeout(function(){a.button("refresh")},1)},k=function(a){var c=a.name,e=a.form,f=b([]);if(c)f=e?b(e).find("[name='"+c+"']"):b("[name='"+c+"']",a.ownerDocument).filter(function(){return!this.form});return f};b.widget("ui.button",{options:{disabled:null,text:true,label:null,icons:{primary:null,secondary:null}},_create:function(){this.element.closest("form").unbind("reset.button").bind("reset.button",l);if(typeof this.options.disabled!==
"boolean")this.options.disabled=this.element.propAttr("disabled");this._determineButtonType();this.hasTitle=!!this.buttonElement.attr("title");var a=this,c=this.options,e=this.type==="checkbox"||this.type==="radio",f="ui-state-hover"+(!e?" ui-state-active":"");if(c.label===null)c.label=this.buttonElement.html();if(this.element.is(":disabled"))c.disabled=true;this.buttonElement.addClass("ui-button ui-widget ui-state-default ui-corner-all").attr("role","button").bind("mouseenter.button",function(){if(!c.disabled){b(this).addClass("ui-state-hover");
this===h&&b(this).addClass("ui-state-active")}}).bind("mouseleave.button",function(){c.disabled||b(this).removeClass(f)}).bind("click.button",function(d){if(c.disabled){d.preventDefault();d.stopImmediatePropagation()}});this.element.bind("focus.button",function(){a.buttonElement.addClass("ui-state-focus")}).bind("blur.button",function(){a.buttonElement.removeClass("ui-state-focus")});if(e){this.element.bind("change.button",function(){g||a.refresh()});this.buttonElement.bind("mousedown.button",function(d){if(!c.disabled){g=
false;i=d.pageX;j=d.pageY}}).bind("mouseup.button",function(d){if(!c.disabled)if(i!==d.pageX||j!==d.pageY)g=true})}if(this.type==="checkbox")this.buttonElement.bind("click.button",function(){if(c.disabled||g)return false;b(this).toggleClass("ui-state-active");a.buttonElement.attr("aria-pressed",a.element[0].checked)});else if(this.type==="radio")this.buttonElement.bind("click.button",function(){if(c.disabled||g)return false;b(this).addClass("ui-state-active");a.buttonElement.attr("aria-pressed","true");
var d=a.element[0];k(d).not(d).map(function(){return b(this).button("widget")[0]}).removeClass("ui-state-active").attr("aria-pressed","false")});else{this.buttonElement.bind("mousedown.button",function(){if(c.disabled)return false;b(this).addClass("ui-state-active");h=this;b(document).one("mouseup",function(){h=null})}).bind("mouseup.button",function(){if(c.disabled)return false;b(this).removeClass("ui-state-active")}).bind("keydown.button",function(d){if(c.disabled)return false;if(d.keyCode==b.ui.keyCode.SPACE||
d.keyCode==b.ui.keyCode.ENTER)b(this).addClass("ui-state-active")}).bind("keyup.button",function(){b(this).removeClass("ui-state-active")});this.buttonElement.is("a")&&this.buttonElement.keyup(function(d){d.keyCode===b.ui.keyCode.SPACE&&b(this).click()})}this._setOption("disabled",c.disabled);this._resetButton()},_determineButtonType:function(){this.type=this.element.is(":checkbox")?"checkbox":this.element.is(":radio")?"radio":this.element.is("input")?"input":"button";if(this.type==="checkbox"||this.type===
"radio"){var a=this.element.parents().filter(":last"),c="label[for='"+this.element.attr("id")+"']";this.buttonElement=a.find(c);if(!this.buttonElement.length){a=a.length?a.siblings():this.element.siblings();this.buttonElement=a.filter(c);if(!this.buttonElement.length)this.buttonElement=a.find(c)}this.element.addClass("ui-helper-hidden-accessible");(a=this.element.is(":checked"))&&this.buttonElement.addClass("ui-state-active");this.buttonElement.attr("aria-pressed",a)}else this.buttonElement=this.element},
widget:function(){return this.buttonElement},destroy:function(){this.element.removeClass("ui-helper-hidden-accessible");this.buttonElement.removeClass("ui-button ui-widget ui-state-default ui-corner-all ui-state-hover ui-state-active  ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only").removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html());this.hasTitle||this.buttonElement.removeAttr("title");
b.Widget.prototype.destroy.call(this)},_setOption:function(a,c){b.Widget.prototype._setOption.apply(this,arguments);if(a==="disabled")c?this.element.propAttr("disabled",true):this.element.propAttr("disabled",false);else this._resetButton()},refresh:function(){var a=this.element.is(":disabled");a!==this.options.disabled&&this._setOption("disabled",a);if(this.type==="radio")k(this.element[0]).each(function(){b(this).is(":checked")?b(this).button("widget").addClass("ui-state-active").attr("aria-pressed",
"true"):b(this).button("widget").removeClass("ui-state-active").attr("aria-pressed","false")});else if(this.type==="checkbox")this.element.is(":checked")?this.buttonElement.addClass("ui-state-active").attr("aria-pressed","true"):this.buttonElement.removeClass("ui-state-active").attr("aria-pressed","false")},_resetButton:function(){if(this.type==="input")this.options.label&&this.element.val(this.options.label);else{var a=this.buttonElement.removeClass("ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only"),
c=b("<span></span>").addClass("ui-button-text").html(this.options.label).appendTo(a.empty()).text(),e=this.options.icons,f=e.primary&&e.secondary,d=[];if(e.primary||e.secondary){if(this.options.text)d.push("ui-button-text-icon"+(f?"s":e.primary?"-primary":"-secondary"));e.primary&&a.prepend("<span class='ui-button-icon-primary ui-icon "+e.primary+"'></span>");e.secondary&&a.append("<span class='ui-button-icon-secondary ui-icon "+e.secondary+"'></span>");if(!this.options.text){d.push(f?"ui-button-icons-only":
"ui-button-icon-only");this.hasTitle||a.attr("title",c)}}else d.push("ui-button-text-only");a.addClass(d.join(" "))}}});b.widget("ui.buttonset",{options:{items:":button, :submit, :reset, :checkbox, :radio, a, :data(button)"},_create:function(){this.element.addClass("ui-buttonset")},_init:function(){this.refresh()},_setOption:function(a,c){a==="disabled"&&this.buttons.button("option",a,c);b.Widget.prototype._setOption.apply(this,arguments)},refresh:function(){var a=this.element.css("direction")===
"ltr";this.buttons=this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function(){return b(this).button("widget")[0]}).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(a?"ui-corner-left":"ui-corner-right").end().filter(":last").addClass(a?"ui-corner-right":"ui-corner-left").end().end()},destroy:function(){this.element.removeClass("ui-buttonset");this.buttons.map(function(){return b(this).button("widget")[0]}).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
b.Widget.prototype.destroy.call(this)}})})(jQuery);
;/*
 * jQuery UI Slider 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.slider",d.ui.mouse,{widgetEventPrefix:"slide",options:{animate:false,distance:0,max:100,min:0,orientation:"horizontal",range:false,step:1,value:0,values:null},_create:function(){var a=this,b=this.options,c=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),f=b.values&&b.values.length||1,e=[];this._mouseSliding=this._keySliding=false;this._animateOff=true;this._handleIndex=null;this._detectOrientation();this._mouseInit();this.element.addClass("ui-slider ui-slider-"+
this.orientation+" ui-widget ui-widget-content ui-corner-all"+(b.disabled?" ui-slider-disabled ui-disabled":""));this.range=d([]);if(b.range){if(b.range===true){if(!b.values)b.values=[this._valueMin(),this._valueMin()];if(b.values.length&&b.values.length!==2)b.values=[b.values[0],b.values[0]]}this.range=d("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header"+(b.range==="min"||b.range==="max"?" ui-slider-range-"+b.range:""))}for(var j=c.length;j<f;j+=1)e.push("<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>");
this.handles=c.add(d(e.join("")).appendTo(a.element));this.handle=this.handles.eq(0);this.handles.add(this.range).filter("a").click(function(g){g.preventDefault()}).hover(function(){b.disabled||d(this).addClass("ui-state-hover")},function(){d(this).removeClass("ui-state-hover")}).focus(function(){if(b.disabled)d(this).blur();else{d(".ui-slider .ui-state-focus").removeClass("ui-state-focus");d(this).addClass("ui-state-focus")}}).blur(function(){d(this).removeClass("ui-state-focus")});this.handles.each(function(g){d(this).data("index.ui-slider-handle",
g)});this.handles.keydown(function(g){var k=true,l=d(this).data("index.ui-slider-handle"),i,h,m;if(!a.options.disabled){switch(g.keyCode){case d.ui.keyCode.HOME:case d.ui.keyCode.END:case d.ui.keyCode.PAGE_UP:case d.ui.keyCode.PAGE_DOWN:case d.ui.keyCode.UP:case d.ui.keyCode.RIGHT:case d.ui.keyCode.DOWN:case d.ui.keyCode.LEFT:k=false;if(!a._keySliding){a._keySliding=true;d(this).addClass("ui-state-active");i=a._start(g,l);if(i===false)return}break}m=a.options.step;i=a.options.values&&a.options.values.length?
(h=a.values(l)):(h=a.value());switch(g.keyCode){case d.ui.keyCode.HOME:h=a._valueMin();break;case d.ui.keyCode.END:h=a._valueMax();break;case d.ui.keyCode.PAGE_UP:h=a._trimAlignValue(i+(a._valueMax()-a._valueMin())/5);break;case d.ui.keyCode.PAGE_DOWN:h=a._trimAlignValue(i-(a._valueMax()-a._valueMin())/5);break;case d.ui.keyCode.UP:case d.ui.keyCode.RIGHT:if(i===a._valueMax())return;h=a._trimAlignValue(i+m);break;case d.ui.keyCode.DOWN:case d.ui.keyCode.LEFT:if(i===a._valueMin())return;h=a._trimAlignValue(i-
m);break}a._slide(g,l,h);return k}}).keyup(function(g){var k=d(this).data("index.ui-slider-handle");if(a._keySliding){a._keySliding=false;a._stop(g,k);a._change(g,k);d(this).removeClass("ui-state-active")}});this._refreshValue();this._animateOff=false},destroy:function(){this.handles.remove();this.range.remove();this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all").removeData("slider").unbind(".slider");this._mouseDestroy();
return this},_mouseCapture:function(a){var b=this.options,c,f,e,j,g;if(b.disabled)return false;this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()};this.elementOffset=this.element.offset();c=this._normValueFromMouse({x:a.pageX,y:a.pageY});f=this._valueMax()-this._valueMin()+1;j=this;this.handles.each(function(k){var l=Math.abs(c-j.values(k));if(f>l){f=l;e=d(this);g=k}});if(b.range===true&&this.values(1)===b.min){g+=1;e=d(this.handles[g])}if(this._start(a,g)===false)return false;
this._mouseSliding=true;j._handleIndex=g;e.addClass("ui-state-active").focus();b=e.offset();this._clickOffset=!d(a.target).parents().andSelf().is(".ui-slider-handle")?{left:0,top:0}:{left:a.pageX-b.left-e.width()/2,top:a.pageY-b.top-e.height()/2-(parseInt(e.css("borderTopWidth"),10)||0)-(parseInt(e.css("borderBottomWidth"),10)||0)+(parseInt(e.css("marginTop"),10)||0)};this.handles.hasClass("ui-state-hover")||this._slide(a,g,c);return this._animateOff=true},_mouseStart:function(){return true},_mouseDrag:function(a){var b=
this._normValueFromMouse({x:a.pageX,y:a.pageY});this._slide(a,this._handleIndex,b);return false},_mouseStop:function(a){this.handles.removeClass("ui-state-active");this._mouseSliding=false;this._stop(a,this._handleIndex);this._change(a,this._handleIndex);this._clickOffset=this._handleIndex=null;return this._animateOff=false},_detectOrientation:function(){this.orientation=this.options.orientation==="vertical"?"vertical":"horizontal"},_normValueFromMouse:function(a){var b;if(this.orientation==="horizontal"){b=
this.elementSize.width;a=a.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)}else{b=this.elementSize.height;a=a.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)}b=a/b;if(b>1)b=1;if(b<0)b=0;if(this.orientation==="vertical")b=1-b;a=this._valueMax()-this._valueMin();return this._trimAlignValue(this._valueMin()+b*a)},_start:function(a,b){var c={handle:this.handles[b],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(b);
c.values=this.values()}return this._trigger("start",a,c)},_slide:function(a,b,c){var f;if(this.options.values&&this.options.values.length){f=this.values(b?0:1);if(this.options.values.length===2&&this.options.range===true&&(b===0&&c>f||b===1&&c<f))c=f;if(c!==this.values(b)){f=this.values();f[b]=c;a=this._trigger("slide",a,{handle:this.handles[b],value:c,values:f});this.values(b?0:1);a!==false&&this.values(b,c,true)}}else if(c!==this.value()){a=this._trigger("slide",a,{handle:this.handles[b],value:c});
a!==false&&this.value(c)}},_stop:function(a,b){var c={handle:this.handles[b],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(b);c.values=this.values()}this._trigger("stop",a,c)},_change:function(a,b){if(!this._keySliding&&!this._mouseSliding){var c={handle:this.handles[b],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(b);c.values=this.values()}this._trigger("change",a,c)}},value:function(a){if(arguments.length){this.options.value=
this._trimAlignValue(a);this._refreshValue();this._change(null,0)}else return this._value()},values:function(a,b){var c,f,e;if(arguments.length>1){this.options.values[a]=this._trimAlignValue(b);this._refreshValue();this._change(null,a)}else if(arguments.length)if(d.isArray(arguments[0])){c=this.options.values;f=arguments[0];for(e=0;e<c.length;e+=1){c[e]=this._trimAlignValue(f[e]);this._change(null,e)}this._refreshValue()}else return this.options.values&&this.options.values.length?this._values(a):
this.value();else return this._values()},_setOption:function(a,b){var c,f=0;if(d.isArray(this.options.values))f=this.options.values.length;d.Widget.prototype._setOption.apply(this,arguments);switch(a){case "disabled":if(b){this.handles.filter(".ui-state-focus").blur();this.handles.removeClass("ui-state-hover");this.handles.propAttr("disabled",true);this.element.addClass("ui-disabled")}else{this.handles.propAttr("disabled",false);this.element.removeClass("ui-disabled")}break;case "orientation":this._detectOrientation();
this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation);this._refreshValue();break;case "value":this._animateOff=true;this._refreshValue();this._change(null,0);this._animateOff=false;break;case "values":this._animateOff=true;this._refreshValue();for(c=0;c<f;c+=1)this._change(null,c);this._animateOff=false;break}},_value:function(){var a=this.options.value;return a=this._trimAlignValue(a)},_values:function(a){var b,c;if(arguments.length){b=this.options.values[a];
return b=this._trimAlignValue(b)}else{b=this.options.values.slice();for(c=0;c<b.length;c+=1)b[c]=this._trimAlignValue(b[c]);return b}},_trimAlignValue:function(a){if(a<=this._valueMin())return this._valueMin();if(a>=this._valueMax())return this._valueMax();var b=this.options.step>0?this.options.step:1,c=(a-this._valueMin())%b;a=a-c;if(Math.abs(c)*2>=b)a+=c>0?b:-b;return parseFloat(a.toFixed(5))},_valueMin:function(){return this.options.min},_valueMax:function(){return this.options.max},_refreshValue:function(){var a=
this.options.range,b=this.options,c=this,f=!this._animateOff?b.animate:false,e,j={},g,k,l,i;if(this.options.values&&this.options.values.length)this.handles.each(function(h){e=(c.values(h)-c._valueMin())/(c._valueMax()-c._valueMin())*100;j[c.orientation==="horizontal"?"left":"bottom"]=e+"%";d(this).stop(1,1)[f?"animate":"css"](j,b.animate);if(c.options.range===true)if(c.orientation==="horizontal"){if(h===0)c.range.stop(1,1)[f?"animate":"css"]({left:e+"%"},b.animate);if(h===1)c.range[f?"animate":"css"]({width:e-
g+"%"},{queue:false,duration:b.animate})}else{if(h===0)c.range.stop(1,1)[f?"animate":"css"]({bottom:e+"%"},b.animate);if(h===1)c.range[f?"animate":"css"]({height:e-g+"%"},{queue:false,duration:b.animate})}g=e});else{k=this.value();l=this._valueMin();i=this._valueMax();e=i!==l?(k-l)/(i-l)*100:0;j[c.orientation==="horizontal"?"left":"bottom"]=e+"%";this.handle.stop(1,1)[f?"animate":"css"](j,b.animate);if(a==="min"&&this.orientation==="horizontal")this.range.stop(1,1)[f?"animate":"css"]({width:e+"%"},
b.animate);if(a==="max"&&this.orientation==="horizontal")this.range[f?"animate":"css"]({width:100-e+"%"},{queue:false,duration:b.animate});if(a==="min"&&this.orientation==="vertical")this.range.stop(1,1)[f?"animate":"css"]({height:e+"%"},b.animate);if(a==="max"&&this.orientation==="vertical")this.range[f?"animate":"css"]({height:100-e+"%"},{queue:false,duration:b.animate})}}});d.extend(d.ui.slider,{version:"1.8.16"})})(jQuery);
;
```

`LibreHardwareMonitor/Resources/Web/js/jquery.tmpl.js`:

```js
/*!
 * jQuery Templates Plugin 1.0.0pre
 * http://github.com/jquery/jquery-tmpl
 * Requires jQuery 1.4.2
 *
 * Copyright 2011, Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */
(function( jQuery, undefined ){
	var oldManip = jQuery.fn.domManip, tmplItmAtt = "_tmplitem", htmlExpr = /^[^<]*(<[\w\W]+>)[^>]*$|\{\{\! /,
		newTmplItems = {}, wrappedItems = {}, appendToTmplItems, topTmplItem = { key: 0, data: {} }, itemKey = 0, cloneIndex = 0, stack = [];

	function newTmplItem( options, parentItem, fn, data ) {
		// Returns a template item data structure for a new rendered instance of a template (a 'template item').
		// The content field is a hierarchical array of strings and nested items (to be
		// removed and replaced by nodes field of dom elements, once inserted in DOM).
		var newItem = {
			data: data || (data === 0 || data === false) ? data : (parentItem ? parentItem.data : {}),
			_wrap: parentItem ? parentItem._wrap : null,
			tmpl: null,
			parent: parentItem || null,
			nodes: [],
			calls: tiCalls,
			nest: tiNest,
			wrap: tiWrap,
			html: tiHtml,
			update: tiUpdate
		};
		if ( options ) {
			jQuery.extend( newItem, options, { nodes: [], parent: parentItem });
		}
		if ( fn ) {
			// Build the hierarchical content to be used during insertion into DOM
			newItem.tmpl = fn;
			newItem._ctnt = newItem._ctnt || newItem.tmpl( jQuery, newItem );
			newItem.key = ++itemKey;
			// Keep track of new template item, until it is stored as jQuery Data on DOM element
			(stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;
		}
		return newItem;
	}

	// Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).
	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var ret = [], insert = jQuery( selector ), elems, i, l, tmplItems,
				parent = this.length === 1 && this[0].parentNode;

			appendToTmplItems = newTmplItems || {};
			if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
				insert[ original ]( this[0] );
				ret = this;
			} else {
				for ( i = 0, l = insert.length; i < l; i++ ) {
					cloneIndex = i;
					elems = (i > 0 ? this.clone(true) : this).get();
					jQuery( insert[i] )[ original ]( elems );
					ret = ret.concat( elems );
				}
				cloneIndex = 0;
				ret = this.pushStack( ret, name, insert.selector );
			}
			tmplItems = appendToTmplItems;
			appendToTmplItems = null;
			jQuery.tmpl.complete( tmplItems );
			return ret;
		};
	});

	jQuery.fn.extend({
		// Use first wrapped element as template markup.
		// Return wrapped set of template items, obtained by rendering template against data.
		tmpl: function( data, options, parentItem ) {
			return jQuery.tmpl( this[0], data, options, parentItem );
		},

		// Find which rendered template item the first wrapped DOM element belongs to
		tmplItem: function() {
			return jQuery.tmplItem( this[0] );
		},

		// Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.
		template: function( name ) {
			return jQuery.template( name, this[0] );
		},

		domManip: function( args, table, callback, options ) {
			if ( args[0] && jQuery.isArray( args[0] )) {
				var dmArgs = jQuery.makeArray( arguments ), elems = args[0], elemsLength = elems.length, i = 0, tmplItem;
				while ( i < elemsLength && !(tmplItem = jQuery.data( elems[i++], "tmplItem" ))) {}
				if ( tmplItem && cloneIndex ) {
					dmArgs[2] = function( fragClone ) {
						// Handler called by oldManip when rendered template has been inserted into DOM.
						jQuery.tmpl.afterManip( this, fragClone, callback );
					};
				}
				oldManip.apply( this, dmArgs );
			} else {
				oldManip.apply( this, arguments );
			}
			cloneIndex = 0;
			if ( !appendToTmplItems ) {
				jQuery.tmpl.complete( newTmplItems );
			}
			return this;
		}
	});

	jQuery.extend({
		// Return wrapped set of template items, obtained by rendering template against data.
		tmpl: function( tmpl, data, options, parentItem ) {
			var ret, topLevel = !parentItem;
			if ( topLevel ) {
				// This is a top-level tmpl call (not from a nested template using {{tmpl}})
				parentItem = topTmplItem;
				tmpl = jQuery.template[tmpl] || jQuery.template( null, tmpl );
				wrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level
			} else if ( !tmpl ) {
				// The template item is already associated with DOM - this is a refresh.
				// Re-evaluate rendered template for the parentItem
				tmpl = parentItem.tmpl;
				newTmplItems[parentItem.key] = parentItem;
				parentItem.nodes = [];
				if ( parentItem.wrapped ) {
					updateWrapped( parentItem, parentItem.wrapped );
				}
				// Rebuild, without creating a new template item
				return jQuery( build( parentItem, null, parentItem.tmpl( jQuery, parentItem ) ));
			}
			if ( !tmpl ) {
				return []; // Could throw...
			}
			if ( typeof data === "function" ) {
				data = data.call( parentItem || {} );
			}
			if ( options && options.wrapped ) {
				updateWrapped( options, options.wrapped );
			}
			ret = jQuery.isArray( data ) ?
				jQuery.map( data, function( dataItem ) {
					return dataItem ? newTmplItem( options, parentItem, tmpl, dataItem ) : null;
				}) :
				[ newTmplItem( options, parentItem, tmpl, data ) ];
			return topLevel ? jQuery( build( parentItem, null, ret ) ) : ret;
		},

		// Return rendered template item for an element.
		tmplItem: function( elem ) {
			var tmplItem;
			if ( elem instanceof jQuery ) {
				elem = elem[0];
			}
			while ( elem && elem.nodeType === 1 && !(tmplItem = jQuery.data( elem, "tmplItem" )) && (elem = elem.parentNode) ) {}
			return tmplItem || topTmplItem;
		},

		// Set:
		// Use $.template( name, tmpl ) to cache a named template,
		// where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.
		// Use $( "selector" ).template( name ) to provide access by name to a script block template declaration.

		// Get:
		// Use $.template( name ) to access a cached template.
		// Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )
		// will return the compiled template, without adding a name reference.
		// If templateString includes at least one HTML tag, $.template( templateString ) is equivalent
		// to $.template( null, templateString )
		template: function( name, tmpl ) {
			if (tmpl) {
				// Compile template and associate with name
				if ( typeof tmpl === "string" ) {
					// This is an HTML string being passed directly in.
					tmpl = buildTmplFn( tmpl );
				} else if ( tmpl instanceof jQuery ) {
					tmpl = tmpl[0] || {};
				}
				if ( tmpl.nodeType ) {
					// If this is a template block, use cached copy, or generate tmpl function and cache.
					tmpl = jQuery.data( tmpl, "tmpl" ) || jQuery.data( tmpl, "tmpl", buildTmplFn( tmpl.innerHTML ));
					// Issue: In IE, if the container element is not a script block, the innerHTML will remove quotes from attribute values whenever the value does not include white space.
					// This means that foo="${x}" will not work if the value of x includes white space: foo="${x}" -> foo=value of x.
					// To correct this, include space in tag: foo="${ x }" -> foo="value of x"
				}
				return typeof name === "string" ? (jQuery.template[name] = tmpl) : tmpl;
			}
			// Return named compiled template
			return name ? (typeof name !== "string" ? jQuery.template( null, name ):
				(jQuery.template[name] ||
					// If not in map, and not containing at least on HTML tag, treat as a selector.
					// (If integrated with core, use quickExpr.exec)
					jQuery.template( null, htmlExpr.test( name ) ? name : jQuery( name )))) : null;
		},

		encode: function( text ) {
			// Do HTML encoding replacing < > & and ' and " by corresponding entities.
			return ("" + text).split("<").join("&lt;").split(">").join("&gt;").split('"').join("&#34;").split("'").join("&#39;");
		}
	});

	jQuery.extend( jQuery.tmpl, {
		tag: {
			"tmpl": {
				_default: { $2: "null" },
				open: "if($notnull_1){__=__.concat($item.nest($1,$2));}"
				// tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)
				// This means that {{tmpl foo}} treats foo as a template (which IS a function).
				// Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.
			},
			"wrap": {
				_default: { $2: "null" },
				open: "$item.calls(__,$1,$2);__=[];",
				close: "call=$item.calls();__=call._.concat($item.wrap(call,__));"
			},
			"each": {
				_default: { $2: "$index, $value" },
				open: "if($notnull_1){$.each($1a,function($2){with(this){",
				close: "}});}"
			},
			"if": {
				open: "if(($notnull_1) && $1a){",
				close: "}"
			},
			"else": {
				_default: { $1: "true" },
				open: "}else if(($notnull_1) && $1a){"
			},
			"html": {
				// Unecoded expression evaluation.
				open: "if($notnull_1){__.push($1a);}"
			},
			"=": {
				// Encoded expression evaluation. Abbreviated form is ${}.
				_default: { $1: "$data" },
				open: "if($notnull_1){__.push($.encode($1a));}"
			},
			"!": {
				// Comment tag. Skipped by parser
				open: ""
			}
		},

		// This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events
		complete: function( items ) {
			newTmplItems = {};
		},

		// Call this from code which overrides domManip, or equivalent
		// Manage cloning/storing template items etc.
		afterManip: function afterManip( elem, fragClone, callback ) {
			// Provides cloned fragment ready for fixup prior to and after insertion into DOM
			var content = fragClone.nodeType === 11 ?
				jQuery.makeArray(fragClone.childNodes) :
				fragClone.nodeType === 1 ? [fragClone] : [];

			// Return fragment to original caller (e.g. append) for DOM insertion
			callback.call( elem, fragClone );

			// Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.
			storeTmplItems( content );
			cloneIndex++;
		}
	});

	//========================== Private helper functions, used by code above ==========================

	function build( tmplItem, nested, content ) {
		// Convert hierarchical content into flat string array
		// and finally return array of fragments ready for DOM insertion
		var frag, ret = content ? jQuery.map( content, function( item ) {
			return (typeof item === "string") ?
				// Insert template item annotations, to be converted to jQuery.data( "tmplItem" ) when elems are inserted into DOM.
				(tmplItem.key ? item.replace( /(<\w+)(?=[\s>])(?![^>]*_tmplitem)([^>]*)/g, "$1 " + tmplItmAtt + "=\"" + tmplItem.key + "\" $2" ) : item) :
				// This is a child template item. Build nested template.
				build( item, tmplItem, item._ctnt );
		}) :
		// If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}.
		tmplItem;
		if ( nested ) {
			return ret;
		}

		// top-level template
		ret = ret.join("");

		// Support templates which have initial or final text nodes, or consist only of text
		// Also support HTML entities within the HTML markup.
		ret.replace( /^\s*([^<\s][^<]*)?(<[\w\W]+>)([^>]*[^>\s])?\s*$/, function( all, before, middle, after) {
			frag = jQuery( middle ).get();

			storeTmplItems( frag );
			if ( before ) {
				frag = unencode( before ).concat(frag);
			}
			if ( after ) {
				frag = frag.concat(unencode( after ));
			}
		});
		return frag ? frag : unencode( ret );
	}

	function unencode( text ) {
		// Use createElement, since createTextNode will not render HTML entities correctly
		var el = document.createElement( "div" );
		el.innerHTML = text;
		return jQuery.makeArray(el.childNodes);
	}

	// Generate a reusable function that will serve to render a template against data
	function buildTmplFn( markup ) {
		return new Function("jQuery","$item",
			// Use the variable __ to hold a string array while building the compiled template. (See https://github.com/jquery/jquery-tmpl/issues#issue/10).
			"var $=jQuery,call,__=[],$data=$item.data;" +

			// Introduce the data as local variables using with(){}
			"with($data){__.push('" +

			// Convert the template into pure JavaScript
			jQuery.trim(markup)
				.replace( /([\\'])/g, "\\$1" )
				.replace( /[\r\t\n]/g, " " )
				.replace( /\$\{([^\}]*)\}/g, "{{= $1}}" )
				.replace( /\{\{(\/?)(\w+|.)(?:\(((?:[^\}]|\}(?!\}))*?)?\))?(?:\s+(.*?)?)?(\(((?:[^\}]|\}(?!\}))*?)\))?\s*\}\}/g,
				function( all, slash, type, fnargs, target, parens, args ) {
					var tag = jQuery.tmpl.tag[ type ], def, expr, exprAutoFnDetect;
					if ( !tag ) {
						throw "Unknown template tag: " + type;
					}
					def = tag._default || [];
					if ( parens && !/\w$/.test(target)) {
						target += parens;
						parens = "";
					}
					if ( target ) {
						target = unescape( target );
						args = args ? ("," + unescape( args ) + ")") : (parens ? ")" : "");
						// Support for target being things like a.toLowerCase();
						// In that case don't call with template item as 'this' pointer. Just evaluate...
						expr = parens ? (target.indexOf(".") > -1 ? target + unescape( parens ) : ("(" + target + ").call($item" + args)) : target;
						exprAutoFnDetect = parens ? expr : "(typeof(" + target + ")==='function'?(" + target + ").call($item):(" + target + "))";
					} else {
						exprAutoFnDetect = expr = def.$1 || "null";
					}
					fnargs = unescape( fnargs );
					return "');" +
						tag[ slash ? "close" : "open" ]
							.split( "$notnull_1" ).join( target ? "typeof(" + target + ")!=='undefined' && (" + target + ")!=null" : "true" )
							.split( "$1a" ).join( exprAutoFnDetect )
							.split( "$1" ).join( expr )
							.split( "$2" ).join( fnargs || def.$2 || "" ) +
						"__.push('";
				}) +
			"');}return __;"
		);
	}
	function updateWrapped( options, wrapped ) {
		// Build the wrapped content.
		options._wrap = build( options, true,
			// Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.
			jQuery.isArray( wrapped ) ? wrapped : [htmlExpr.test( wrapped ) ? wrapped : jQuery( wrapped ).html()]
		).join("");
	}

	function unescape( args ) {
		return args ? args.replace( /\\'/g, "'").replace(/\\\\/g, "\\" ) : null;
	}
	function outerHtml( elem ) {
		var div = document.createElement("div");
		div.appendChild( elem.cloneNode(true) );
		return div.innerHTML;
	}

	// Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.
	function storeTmplItems( content ) {
		var keySuffix = "_" + cloneIndex, elem, elems, newClonedItems = {}, i, l, m;
		for ( i = 0, l = content.length; i < l; i++ ) {
			if ( (elem = content[i]).nodeType !== 1 ) {
				continue;
			}
			elems = elem.getElementsByTagName("*");
			for ( m = elems.length - 1; m >= 0; m-- ) {
				processItemKey( elems[m] );
			}
			processItemKey( elem );
		}
		function processItemKey( el ) {
			var pntKey, pntNode = el, pntItem, tmplItem, key;
			// Ensure that each rendered template inserted into the DOM has its own template item,
			if ( (key = el.getAttribute( tmplItmAtt ))) {
				while ( pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute( tmplItmAtt ))) { }
				if ( pntKey !== key ) {
					// The next ancestor with a _tmplitem expando is on a different key than this one.
					// So this is a top-level element within this template item
					// Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.
					pntNode = pntNode.parentNode ? (pntNode.nodeType === 11 ? 0 : (pntNode.getAttribute( tmplItmAtt ) || 0)) : 0;
					if ( !(tmplItem = newTmplItems[key]) ) {
						// The item is for wrapped content, and was copied from the temporary parent wrappedItem.
						tmplItem = wrappedItems[key];
						tmplItem = newTmplItem( tmplItem, newTmplItems[pntNode]||wrappedItems[pntNode] );
						tmplItem.key = ++itemKey;
						newTmplItems[itemKey] = tmplItem;
					}
					if ( cloneIndex ) {
						cloneTmplItem( key );
					}
				}
				el.removeAttribute( tmplItmAtt );
			} else if ( cloneIndex && (tmplItem = jQuery.data( el, "tmplItem" )) ) {
				// This was a rendered element, cloned during append or appendTo etc.
				// TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.
				cloneTmplItem( tmplItem.key );
				newTmplItems[tmplItem.key] = tmplItem;
				pntNode = jQuery.data( el.parentNode, "tmplItem" );
				pntNode = pntNode ? pntNode.key : 0;
			}
			if ( tmplItem ) {
				pntItem = tmplItem;
				// Find the template item of the parent element.
				// (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)
				while ( pntItem && pntItem.key != pntNode ) {
					// Add this element as a top-level node for this rendered template item, as well as for any
					// ancestor items between this item and the item of its parent element
					pntItem.nodes.push( el );
					pntItem = pntItem.parent;
				}
				// Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...
				delete tmplItem._ctnt;
				delete tmplItem._wrap;
				// Store template item as jQuery data on the element
				jQuery.data( el, "tmplItem", tmplItem );
			}
			function cloneTmplItem( key ) {
				key = key + keySuffix;
				tmplItem = newClonedItems[key] =
					(newClonedItems[key] || newTmplItem( tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent ));
			}
		}
	}

	//---- Helper functions for template item ----

	function tiCalls( content, tmpl, data, options ) {
		if ( !content ) {
			return stack.pop();
		}
		stack.push({ _: content, tmpl: tmpl, item:this, data: data, options: options });
	}

	function tiNest( tmpl, data, options ) {
		// nested template, using {{tmpl}} tag
		return jQuery.tmpl( jQuery.template( tmpl ), data, options, this );
	}

	function tiWrap( call, wrapped ) {
		// nested template, using {{wrap}} tag
		var options = call.options || {};
		options.wrapped = wrapped;
		// Apply the template, which may incorporate wrapped content,
		return jQuery.tmpl( jQuery.template( call.tmpl ), call.data, options, call.item );
	}

	function tiHtml( filter, textOnly ) {
		var wrapped = this._wrap;
		return jQuery.map(
			jQuery( jQuery.isArray( wrapped ) ? wrapped.join("") : wrapped ).filter( filter || "*" ),
			function(e) {
				return textOnly ?
					e.innerText || e.textContent :
					e.outerHTML || outerHtml(e);
			});
	}

	function tiUpdate() {
		var coll = this.nodes;
		jQuery.tmpl( null, null, null, this).insertBefore( coll[0] );
		jQuery( coll ).remove();
	}
})( jQuery );

```

`LibreHardwareMonitor/Resources/Web/js/jquery.tmpl.min.js`:

```js
/*
 * jQuery Templates Plugin 1.0.0pre
 * http://github.com/jquery/jquery-tmpl
 * Requires jQuery 1.4.2
 *
 * Copyright 2011, Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */
(function(a){var r=a.fn.domManip,d="_tmplitem",q=/^[^<]*(<[\w\W]+>)[^>]*$|\{\{\! /,b={},f={},e,p={key:0,data:{}},i=0,c=0,l=[];function g(g,d,h,e){var c={data:e||(e===0||e===false)?e:d?d.data:{},_wrap:d?d._wrap:null,tmpl:null,parent:d||null,nodes:[],calls:u,nest:w,wrap:x,html:v,update:t};g&&a.extend(c,g,{nodes:[],parent:d});if(h){c.tmpl=h;c._ctnt=c._ctnt||c.tmpl(a,c);c.key=++i;(l.length?f:b)[i]=c}return c}a.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(f,d){a.fn[f]=function(n){var g=[],i=a(n),k,h,m,l,j=this.length===1&&this[0].parentNode;e=b||{};if(j&&j.nodeType===11&&j.childNodes.length===1&&i.length===1){i[d](this[0]);g=this}else{for(h=0,m=i.length;h<m;h++){c=h;k=(h>0?this.clone(true):this).get();a(i[h])[d](k);g=g.concat(k)}c=0;g=this.pushStack(g,f,i.selector)}l=e;e=null;a.tmpl.complete(l);return g}});a.fn.extend({tmpl:function(d,c,b){return a.tmpl(this[0],d,c,b)},tmplItem:function(){return a.tmplItem(this[0])},template:function(b){return a.template(b,this[0])},domManip:function(d,m,k){if(d[0]&&a.isArray(d[0])){var g=a.makeArray(arguments),h=d[0],j=h.length,i=0,f;while(i<j&&!(f=a.data(h[i++],"tmplItem")));if(f&&c)g[2]=function(b){a.tmpl.afterManip(this,b,k)};r.apply(this,g)}else r.apply(this,arguments);c=0;!e&&a.tmpl.complete(b);return this}});a.extend({tmpl:function(d,h,e,c){var i,k=!c;if(k){c=p;d=a.template[d]||a.template(null,d);f={}}else if(!d){d=c.tmpl;b[c.key]=c;c.nodes=[];c.wrapped&&n(c,c.wrapped);return a(j(c,null,c.tmpl(a,c)))}if(!d)return[];if(typeof h==="function")h=h.call(c||{});e&&e.wrapped&&n(e,e.wrapped);i=a.isArray(h)?a.map(h,function(a){return a?g(e,c,d,a):null}):[g(e,c,d,h)];return k?a(j(c,null,i)):i},tmplItem:function(b){var c;if(b instanceof a)b=b[0];while(b&&b.nodeType===1&&!(c=a.data(b,"tmplItem"))&&(b=b.parentNode));return c||p},template:function(c,b){if(b){if(typeof b==="string")b=o(b);else if(b instanceof a)b=b[0]||{};if(b.nodeType)b=a.data(b,"tmpl")||a.data(b,"tmpl",o(b.innerHTML));return typeof c==="string"?(a.template[c]=b):b}return c?typeof c!=="string"?a.template(null,c):a.template[c]||a.template(null,q.test(c)?c:a(c)):null},encode:function(a){return(""+a).split("<").join("&lt;").split(">").join("&gt;").split('"').join("&#34;").split("'").join("&#39;")}});a.extend(a.tmpl,{tag:{tmpl:{_default:{$2:"null"},open:"if($notnull_1){__=__.concat($item.nest($1,$2));}"},wrap:{_default:{$2:"null"},open:"$item.calls(__,$1,$2);__=[];",close:"call=$item.calls();__=call._.concat($item.wrap(call,__));"},each:{_default:{$2:"$index, $value"},open:"if($notnull_1){$.each($1a,function($2){with(this){",close:"}});}"},"if":{open:"if(($notnull_1) && $1a){",close:"}"},"else":{_default:{$1:"true"},open:"}else if(($notnull_1) && $1a){"},html:{open:"if($notnull_1){__.push($1a);}"},"=":{_default:{$1:"$data"},open:"if($notnull_1){__.push($.encode($1a));}"},"!":{open:""}},complete:function(){b={}},afterManip:function(f,b,d){var e=b.nodeType===11?a.makeArray(b.childNodes):b.nodeType===1?[b]:[];d.call(f,b);m(e);c++}});function j(e,g,f){var b,c=f?a.map(f,function(a){return typeof a==="string"?e.key?a.replace(/(<\w+)(?=[\s>])(?![^>]*_tmplitem)([^>]*)/g,"$1 "+d+'="'+e.key+'" $2'):a:j(a,e,a._ctnt)}):e;if(g)return c;c=c.join("");c.replace(/^\s*([^<\s][^<]*)?(<[\w\W]+>)([^>]*[^>\s])?\s*$/,function(f,c,e,d){b=a(e).get();m(b);if(c)b=k(c).concat(b);if(d)b=b.concat(k(d))});return b?b:k(c)}function k(c){var b=document.createElement("div");b.innerHTML=c;return a.makeArray(b.childNodes)}function o(b){return new Function("jQuery","$item","var $=jQuery,call,__=[],$data=$item.data;with($data){__.push('"+a.trim(b).replace(/([\\'])/g,"\\$1").replace(/[\r\t\n]/g," ").replace(/\$\{([^\}]*)\}/g,"{{= $1}}").replace(/\{\{(\/?)(\w+|.)(?:\(((?:[^\}]|\}(?!\}))*?)?\))?(?:\s+(.*?)?)?(\(((?:[^\}]|\}(?!\}))*?)\))?\s*\}\}/g,function(m,l,k,g,b,c,d){var j=a.tmpl.tag[k],i,e,f;if(!j)throw"Unknown template tag: "+k;i=j._default||[];if(c&&!/\w$/.test(b)){b+=c;c=""}if(b){b=h(b);d=d?","+h(d)+")":c?")":"";e=c?b.indexOf(".")>-1?b+h(c):"("+b+").call($item"+d:b;f=c?e:"(typeof("+b+")==='function'?("+b+").call($item):("+b+"))"}else f=e=i.$1||"null";g=h(g);return"');"+j[l?"close":"open"].split("$notnull_1").join(b?"typeof("+b+")!=='undefined' && ("+b+")!=null":"true").split("$1a").join(f).split("$1").join(e).split("$2").join(g||i.$2||"")+"__.push('"})+"');}return __;")}function n(c,b){c._wrap=j(c,true,a.isArray(b)?b:[q.test(b)?b:a(b).html()]).join("")}function h(a){return a?a.replace(/\\'/g,"'").replace(/\\\\/g,"\\"):null}function s(b){var a=document.createElement("div");a.appendChild(b.cloneNode(true));return a.innerHTML}function m(o){var n="_"+c,k,j,l={},e,p,h;for(e=0,p=o.length;e<p;e++){if((k=o[e]).nodeType!==1)continue;j=k.getElementsByTagName("*");for(h=j.length-1;h>=0;h--)m(j[h]);m(k)}function m(j){var p,h=j,k,e,m;if(m=j.getAttribute(d)){while(h.parentNode&&(h=h.parentNode).nodeType===1&&!(p=h.getAttribute(d)));if(p!==m){h=h.parentNode?h.nodeType===11?0:h.getAttribute(d)||0:0;if(!(e=b[m])){e=f[m];e=g(e,b[h]||f[h]);e.key=++i;b[i]=e}c&&o(m)}j.removeAttribute(d)}else if(c&&(e=a.data(j,"tmplItem"))){o(e.key);b[e.key]=e;h=a.data(j.parentNode,"tmplItem");h=h?h.key:0}if(e){k=e;while(k&&k.key!=h){k.nodes.push(j);k=k.parent}delete e._ctnt;delete e._wrap;a.data(j,"tmplItem",e)}function o(a){a=a+n;e=l[a]=l[a]||g(e,b[e.parent.key+n]||e.parent)}}}function u(a,d,c,b){if(!a)return l.pop();l.push({_:a,tmpl:d,item:this,data:c,options:b})}function w(d,c,b){return a.tmpl(a.template(d),c,b,this)}function x(b,d){var c=b.options||{};c.wrapped=d;return a.tmpl(a.template(b.tmpl),b.data,c,b.item)}function v(d,c){var b=this._wrap;return a.map(a(a.isArray(b)?b.join(""):b).filter(d||"*"),function(a){return c?a.innerText||a.textContent:a.outerHTML||s(a)})}function t(){var b=this.nodes;a.tmpl(null,null,null,this).insertBefore(b[0]);a(b).remove()}})(jQuery);
```

`LibreHardwareMonitor/Resources/Web/js/jquery.treeTable.min.js`:

```js
/*
 * jQuery treeTable Plugin VERSION
 * http://ludo.cubicphuse.nl/jquery-plugins/treeTable/doc/
 *
 * Copyright 2011, Ludo van den Boom
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
(function(a){function j(c){var d=c[0].className.split(" ");for(var e=0;e<d.length;e++)if(d[e].match(b.childPrefix))return a(c).siblings("#"+d[e].substring(b.childPrefix.length));return null}function i(b,c){b.insertAfter(c),e(b).reverse().each(function(){i(a(this),b[0])})}function h(c){if(!c.hasClass("initialized")){c.addClass("initialized");var d=e(c);!c.hasClass("parent")&&d.length>0&&c.addClass("parent");if(c.hasClass("parent")){var g=a(c.children("td")[b.treeColumn]),h=f(g)+b.indent;d.each(function(){a(this).children("td")[b.treeColumn].style.paddingLeft=h+"px"});if(b.expandable){g.prepend('<span style="margin-left: -'+b.indent+"px; padding-left: "+b.indent+'px" class="expander"></span>'),a(g[0].firstChild).click(function(){c.toggleBranch()}),b.clickableNodeNames&&(g[0].style.cursor="pointer",a(g).click(function(a){a.target.className!="expander"&&c.toggleBranch()}));if(b.persist){var i=b.persistCookiePrefix+c.attr("id");a.cookie(i)=="true"&&c.addClass("expanded")}!c.hasClass("expanded")&&!c.hasClass("collapsed")&&c.addClass(b.initialState),c.hasClass("expanded")&&c.expand()}}}}function g(c,d){var h=a(c.children("td")[b.treeColumn]);h[0].style.paddingLeft=f(h)+d+"px",e(c).each(function(){g(a(this),d)})}function f(a){var b=parseInt(a[0].style.paddingLeft,10);return isNaN(b)?c:b}function e(c){return a(c).siblings("tr."+b.childPrefix+c[0].id)}function d(a){var b=[];while(a=j(a))b[b.length]=a[0];return b}var b,c;a.fn.treeTable=function(d){b=a.extend({},a.fn.treeTable.defaults,d);return this.each(function(){a(this).addClass("treeTable").find("tbody tr").each(function(){if(!a(this).hasClass("initialized")){var d=a(this)[0].className.search(b.childPrefix)==-1;d&&isNaN(c)&&(c=parseInt(a(a(this).children("td")[b.treeColumn]).css("padding-left"),10)),!d&&b.expandable&&b.initialState=="collapsed"&&a(this).addClass("ui-helper-hidden"),(!b.expandable||d)&&h(a(this))}})})},a.fn.treeTable.defaults={childPrefix:"child-of-",clickableNodeNames:!1,expandable:!0,indent:19,initialState:"collapsed",onNodeShow:null,treeColumn:0,persist:!1,persistCookiePrefix:"treeTable_"},a.fn.collapse=function(){a(this).addClass("collapsed"),e(a(this)).each(function(){a(this).hasClass("collapsed")||a(this).collapse(),a(this).addClass("ui-helper-hidden")});return this},a.fn.expand=function(){a(this).removeClass("collapsed").addClass("expanded"),e(a(this)).each(function(){h(a(this)),a(this).is(".expanded.parent")&&a(this).expand(),a(this).removeClass("ui-helper-hidden"),a.isFunction(b.onNodeShow)&&b.onNodeShow.call()});return this},a.fn.reveal=function(){a(d(a(this)).reverse()).each(function(){h(a(this)),a(this).expand().show()});return this},a.fn.appendBranchTo=function(c){var e=a(this),f=j(e),h=a.map(d(a(c)),function(a){return a.id});a.inArray(e[0].id,h)==-1&&(!f||c.id!=f[0].id)&&c.id!=e[0].id&&(g(e,d(e).length*b.indent*-1),f&&e.removeClass(b.childPrefix+f[0].id),e.addClass(b.childPrefix+c.id),i(e,c),g(e,d(e).length*b.indent));return this},a.fn.reverse=function(){return this.pushStack(this.get().reverse(),arguments)},a.fn.toggleBranch=function(){a(this).hasClass("collapsed")?a(this).expand():a(this).removeClass("expanded").collapse();if(b.persist){var c=b.persistCookiePrefix+a(this).attr("id");a.cookie(c,a(this).hasClass("expanded")?"true":null)}return this}})(jQuery)

```

`LibreHardwareMonitor/Resources/Web/js/knockout-2.1.0.js`:

```js
// Knockout JavaScript library v2.1.0
// (c) Steven Sanderson - http://knockoutjs.com/
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function(window,document,navigator,undefined){
var DEBUG=true;
!function(factory) {
    // Support three module loading scenarios
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
        // [1] CommonJS/Node.js
        var target = module['exports'] || exports; // module.exports is for Node.js
        factory(target);
    } else if (typeof define === 'function' && define['amd']) {
        // [2] AMD anonymous module
        define(['exports'], factory);
    } else {
        // [3] No module loader (plain <script> tag) - put directly in global namespace
        factory(window['ko'] = {});
    }
}(function(koExports){
// Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).
// In the future, the following "ko" variable may be made distinct from "koExports" so that private objects are not externally reachable.
var ko = typeof koExports !== 'undefined' ? koExports : {};
// Google Closure Compiler helpers (used only to make the minified file smaller)
ko.exportSymbol = function(koPath, object) {
	var tokens = koPath.split(".");

	// In the future, "ko" may become distinct from "koExports" (so that non-exported objects are not reachable)
	// At that point, "target" would be set to: (typeof koExports !== "undefined" ? koExports : ko)
	var target = ko;

	for (var i = 0; i < tokens.length - 1; i++)
		target = target[tokens[i]];
	target[tokens[tokens.length - 1]] = object;
};
ko.exportProperty = function(owner, publicName, object) {
  owner[publicName] = object;
};
ko.version = "2.1.0";

ko.exportSymbol('version', ko.version);
ko.utils = new (function () {
    var stringTrimRegex = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;

    // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)
    var knownEvents = {}, knownEventTypesByEventName = {};
    var keyEventTypeName = /Firefox\/2/i.test(navigator.userAgent) ? 'KeyboardEvent' : 'UIEvents';
    knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];
    knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];
    for (var eventType in knownEvents) {
        var knownEventsForType = knownEvents[eventType];
        if (knownEventsForType.length) {
            for (var i = 0, j = knownEventsForType.length; i < j; i++)
                knownEventTypesByEventName[knownEventsForType[i]] = eventType;
        }
    }
    var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406

    // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)
    var ieVersion = (function() {
        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');

        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment
        while (
            div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',
            iElems[0]
        );
        return version > 4 ? version : undefined;
    }());
    var isIe6 = ieVersion === 6,
        isIe7 = ieVersion === 7;

    function isClickOnCheckableElement(element, eventType) {
        if ((ko.utils.tagNameLower(element) !== "input") || !element.type) return false;
        if (eventType.toLowerCase() != "click") return false;
        var inputType = element.type;
        return (inputType == "checkbox") || (inputType == "radio");
    }

    return {
        fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],

        arrayForEach: function (array, action) {
            for (var i = 0, j = array.length; i < j; i++)
                action(array[i]);
        },

        arrayIndexOf: function (array, item) {
            if (typeof Array.prototype.indexOf == "function")
                return Array.prototype.indexOf.call(array, item);
            for (var i = 0, j = array.length; i < j; i++)
                if (array[i] === item)
                    return i;
            return -1;
        },

        arrayFirst: function (array, predicate, predicateOwner) {
            for (var i = 0, j = array.length; i < j; i++)
                if (predicate.call(predicateOwner, array[i]))
                    return array[i];
            return null;
        },

        arrayRemoveItem: function (array, itemToRemove) {
            var index = ko.utils.arrayIndexOf(array, itemToRemove);
            if (index >= 0)
                array.splice(index, 1);
        },

        arrayGetDistinctValues: function (array) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++) {
                if (ko.utils.arrayIndexOf(result, array[i]) < 0)
                    result.push(array[i]);
            }
            return result;
        },

        arrayMap: function (array, mapping) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++)
                result.push(mapping(array[i]));
            return result;
        },

        arrayFilter: function (array, predicate) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++)
                if (predicate(array[i]))
                    result.push(array[i]);
            return result;
        },

        arrayPushAll: function (array, valuesToPush) {
            if (valuesToPush instanceof Array)
                array.push.apply(array, valuesToPush);
            else
                for (var i = 0, j = valuesToPush.length; i < j; i++)
                    array.push(valuesToPush[i]);
            return array;
        },

        extend: function (target, source) {
            if (source) {
                for(var prop in source) {
                    if(source.hasOwnProperty(prop)) {
                        target[prop] = source[prop];
                    }
                }
            }
            return target;
        },

        emptyDomNode: function (domNode) {
            while (domNode.firstChild) {
                ko.removeNode(domNode.firstChild);
            }
        },

        moveCleanedNodesToContainerElement: function(nodes) {
            // Ensure it's a real array, as we're about to reparent the nodes and
            // we don't want the underlying collection to change while we're doing that.
            var nodesArray = ko.utils.makeArray(nodes);

            var container = document.createElement('div');
            for (var i = 0, j = nodesArray.length; i < j; i++) {
                ko.cleanNode(nodesArray[i]);
                container.appendChild(nodesArray[i]);
            }
            return container;
        },

        setDomNodeChildren: function (domNode, childNodes) {
            ko.utils.emptyDomNode(domNode);
            if (childNodes) {
                for (var i = 0, j = childNodes.length; i < j; i++)
                    domNode.appendChild(childNodes[i]);
            }
        },

        replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {
            var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;
            if (nodesToReplaceArray.length > 0) {
                var insertionPoint = nodesToReplaceArray[0];
                var parent = insertionPoint.parentNode;
                for (var i = 0, j = newNodesArray.length; i < j; i++)
                    parent.insertBefore(newNodesArray[i], insertionPoint);
                for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {
                    ko.removeNode(nodesToReplaceArray[i]);
                }
            }
        },

        setOptionNodeSelectionState: function (optionNode, isSelected) {
            // IE6 sometimes throws "unknown error" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.
            if (navigator.userAgent.indexOf("MSIE 6") >= 0)
                optionNode.setAttribute("selected", isSelected);
            else
                optionNode.selected = isSelected;
        },

        stringTrim: function (string) {
            return (string || "").replace(stringTrimRegex, "");
        },

        stringTokenize: function (string, delimiter) {
            var result = [];
            var tokens = (string || "").split(delimiter);
            for (var i = 0, j = tokens.length; i < j; i++) {
                var trimmed = ko.utils.stringTrim(tokens[i]);
                if (trimmed !== "")
                    result.push(trimmed);
            }
            return result;
        },

        stringStartsWith: function (string, startsWith) {
            string = string || "";
            if (startsWith.length > string.length)
                return false;
            return string.substring(0, startsWith.length) === startsWith;
        },

        buildEvalWithinScopeFunction: function (expression, scopeLevels) {
            // Build the source for a function that evaluates "expression"
            // For each scope variable, add an extra level of "with" nesting
            // Example result: with(sc[1]) { with(sc[0]) { return (expression) } }
            var functionBody = "return (" + expression + ")";
            for (var i = 0; i < scopeLevels; i++) {
                functionBody = "with(sc[" + i + "]) { " + functionBody + " } ";
            }
            return new Function("sc", functionBody);
        },

        domNodeIsContainedBy: function (node, containedByNode) {
            if (containedByNode.compareDocumentPosition)
                return (containedByNode.compareDocumentPosition(node) & 16) == 16;
            while (node != null) {
                if (node == containedByNode)
                    return true;
                node = node.parentNode;
            }
            return false;
        },

        domNodeIsAttachedToDocument: function (node) {
            return ko.utils.domNodeIsContainedBy(node, node.ownerDocument);
        },

        tagNameLower: function(element) {
            // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.
            // Possible future optimization: If we know it's an element from an XHTML document (not HTML),
            // we don't need to do the .toLowerCase() as it will always be lower case anyway.
            return element && element.tagName && element.tagName.toLowerCase();
        },

        registerEventHandler: function (element, eventType, handler) {
            var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];
            if (!mustUseAttachEvent && typeof jQuery != "undefined") {
                if (isClickOnCheckableElement(element, eventType)) {
                    // For click events on checkboxes, jQuery interferes with the event handling in an awkward way:
                    // it toggles the element checked state *after* the click event handlers run, whereas native
                    // click events toggle the checked state *before* the event handler.
                    // Fix this by intecepting the handler and applying the correct checkedness before it runs.
                    var originalHandler = handler;
                    handler = function(event, eventData) {
                        var jQuerySuppliedCheckedState = this.checked;
                        if (eventData)
                            this.checked = eventData.checkedStateBeforeEvent !== true;
                        originalHandler.call(this, event);
                        this.checked = jQuerySuppliedCheckedState; // Restore the state jQuery applied
                    };
                }
                jQuery(element)['bind'](eventType, handler);
            } else if (!mustUseAttachEvent && typeof element.addEventListener == "function")
                element.addEventListener(eventType, handler, false);
            else if (typeof element.attachEvent != "undefined")
                element.attachEvent("on" + eventType, function (event) {
                    handler.call(element, event);
                });
            else
                throw new Error("Browser doesn't support addEventListener or attachEvent");
        },

        triggerEvent: function (element, eventType) {
            if (!(element && element.nodeType))
                throw new Error("element must be a DOM node when calling triggerEvent");

            if (typeof jQuery != "undefined") {
                var eventData = [];
                if (isClickOnCheckableElement(element, eventType)) {
                    // Work around the jQuery "click events on checkboxes" issue described above by storing the original checked state before triggering the handler
                    eventData.push({ checkedStateBeforeEvent: element.checked });
                }
                jQuery(element)['trigger'](eventType, eventData);
            } else if (typeof document.createEvent == "function") {
                if (typeof element.dispatchEvent == "function") {
                    var eventCategory = knownEventTypesByEventName[eventType] || "HTMLEvents";
                    var event = document.createEvent(eventCategory);
                    event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);
                    element.dispatchEvent(event);
                }
                else
                    throw new Error("The supplied element doesn't support dispatchEvent");
            } else if (typeof element.fireEvent != "undefined") {
                // Unlike other browsers, IE doesn't change the checked state of checkboxes/radiobuttons when you trigger their "click" event
                // so to make it consistent, we'll do it manually here
                if (isClickOnCheckableElement(element, eventType))
                    element.checked = element.checked !== true;
                element.fireEvent("on" + eventType);
            }
            else
                throw new Error("Browser doesn't support triggering events");
        },

        unwrapObservable: function (value) {
            return ko.isObservable(value) ? value() : value;
        },

        toggleDomNodeCssClass: function (node, className, shouldHaveClass) {
            var currentClassNames = (node.className || "").split(/\s+/);
            var hasClass = ko.utils.arrayIndexOf(currentClassNames, className) >= 0;

            if (shouldHaveClass && !hasClass) {
                node.className += (currentClassNames[0] ? " " : "") + className;
            } else if (hasClass && !shouldHaveClass) {
                var newClassName = "";
                for (var i = 0; i < currentClassNames.length; i++)
                    if (currentClassNames[i] != className)
                        newClassName += currentClassNames[i] + " ";
                node.className = ko.utils.stringTrim(newClassName);
            }
        },

        setTextContent: function(element, textContent) {
            var value = ko.utils.unwrapObservable(textContent);
            if ((value === null) || (value === undefined))
                value = "";

            'innerText' in element ? element.innerText = value
                                   : element.textContent = value;

            if (ieVersion >= 9) {
                // Believe it or not, this actually fixes an IE9 rendering bug
                // (See https://github.com/SteveSanderson/knockout/issues/209)
                element.style.display = element.style.display;
            }
        },

        ensureSelectElementIsRenderedCorrectly: function(selectElement) {
            // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.
            // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)
            if (ieVersion >= 9) {
                var originalWidth = selectElement.style.width;
                selectElement.style.width = 0;
                selectElement.style.width = originalWidth;
            }
        },

        range: function (min, max) {
            min = ko.utils.unwrapObservable(min);
            max = ko.utils.unwrapObservable(max);
            var result = [];
            for (var i = min; i <= max; i++)
                result.push(i);
            return result;
        },

        makeArray: function(arrayLikeObject) {
            var result = [];
            for (var i = 0, j = arrayLikeObject.length; i < j; i++) {
                result.push(arrayLikeObject[i]);
            };
            return result;
        },

        isIe6 : isIe6,
        isIe7 : isIe7,
        ieVersion : ieVersion,

        getFormFields: function(form, fieldName) {
            var fields = ko.utils.makeArray(form.getElementsByTagName("input")).concat(ko.utils.makeArray(form.getElementsByTagName("textarea")));
            var isMatchingField = (typeof fieldName == 'string')
                ? function(field) { return field.name === fieldName }
                : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate
            var matches = [];
            for (var i = fields.length - 1; i >= 0; i--) {
                if (isMatchingField(fields[i]))
                    matches.push(fields[i]);
            };
            return matches;
        },

        parseJson: function (jsonString) {
            if (typeof jsonString == "string") {
                jsonString = ko.utils.stringTrim(jsonString);
                if (jsonString) {
                    if (window.JSON && window.JSON.parse) // Use native parsing where available
                        return window.JSON.parse(jsonString);
                    return (new Function("return " + jsonString))(); // Fallback on less safe parsing for older browsers
                }
            }
            return null;
        },

        stringifyJson: function (data, replacer, space) {   // replacer and space are optional
            if ((typeof JSON == "undefined") || (typeof JSON.stringify == "undefined"))
                throw new Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
            return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);
        },

        postJson: function (urlOrForm, data, options) {
            options = options || {};
            var params = options['params'] || {};
            var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;
            var url = urlOrForm;

            // If we were given a form, use its 'action' URL and pick out any requested field values
            if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === "form")) {
                var originalForm = urlOrForm;
                url = originalForm.action;
                for (var i = includeFields.length - 1; i >= 0; i--) {
                    var fields = ko.utils.getFormFields(originalForm, includeFields[i]);
                    for (var j = fields.length - 1; j >= 0; j--)
                        params[fields[j].name] = fields[j].value;
                }
            }

            data = ko.utils.unwrapObservable(data);
            var form = document.createElement("form");
            form.style.display = "none";
            form.action = url;
            form.method = "post";
            for (var key in data) {
                var input = document.createElement("input");
                input.name = key;
                input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));
                form.appendChild(input);
            }
            for (var key in params) {
                var input = document.createElement("input");
                input.name = key;
                input.value = params[key];
                form.appendChild(input);
            }
            document.body.appendChild(form);
            options['submitter'] ? options['submitter'](form) : form.submit();
            setTimeout(function () { form.parentNode.removeChild(form); }, 0);
        }
    }
})();

ko.exportSymbol('utils', ko.utils);
ko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);
ko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);
ko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);
ko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);
ko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);
ko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);
ko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);
ko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);
ko.exportSymbol('utils.extend', ko.utils.extend);
ko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);
ko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);
ko.exportSymbol('utils.postJson', ko.utils.postJson);
ko.exportSymbol('utils.parseJson', ko.utils.parseJson);
ko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);
ko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);
ko.exportSymbol('utils.range', ko.utils.range);
ko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);
ko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);
ko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);

if (!Function.prototype['bind']) {
    // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)
    // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js
    Function.prototype['bind'] = function (object) {
        var originalFunction = this, args = Array.prototype.slice.call(arguments), object = args.shift();
        return function () {
            return originalFunction.apply(object, args.concat(Array.prototype.slice.call(arguments)));
        };
    };
}

ko.utils.domData = new (function () {
    var uniqueId = 0;
    var dataStoreKeyExpandoPropertyName = "__ko__" + (new Date).getTime();
    var dataStore = {};
    return {
        get: function (node, key) {
            var allDataForNode = ko.utils.domData.getAll(node, false);
            return allDataForNode === undefined ? undefined : allDataForNode[key];
        },
        set: function (node, key, value) {
            if (value === undefined) {
                // Make sure we don't actually create a new domData key if we are actually deleting a value
                if (ko.utils.domData.getAll(node, false) === undefined)
                    return;
            }
            var allDataForNode = ko.utils.domData.getAll(node, true);
            allDataForNode[key] = value;
        },
        getAll: function (node, createIfNotFound) {
            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
            var hasExistingDataStore = dataStoreKey && (dataStoreKey !== "null");
            if (!hasExistingDataStore) {
                if (!createIfNotFound)
                    return undefined;
                dataStoreKey = node[dataStoreKeyExpandoPropertyName] = "ko" + uniqueId++;
                dataStore[dataStoreKey] = {};
            }
            return dataStore[dataStoreKey];
        },
        clear: function (node) {
            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
            if (dataStoreKey) {
                delete dataStore[dataStoreKey];
                node[dataStoreKeyExpandoPropertyName] = null;
            }
        }
    }
})();

ko.exportSymbol('utils.domData', ko.utils.domData);
ko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully

ko.utils.domNodeDisposal = new (function () {
    var domDataKey = "__ko_domNodeDisposal__" + (new Date).getTime();
    var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document
    var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document

    function getDisposeCallbacksCollection(node, createIfNotFound) {
        var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);
        if ((allDisposeCallbacks === undefined) && createIfNotFound) {
            allDisposeCallbacks = [];
            ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);
        }
        return allDisposeCallbacks;
    }
    function destroyCallbacksCollection(node) {
        ko.utils.domData.set(node, domDataKey, undefined);
    }

    function cleanSingleNode(node) {
        // Run all the dispose callbacks
        var callbacks = getDisposeCallbacksCollection(node, false);
        if (callbacks) {
            callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)
            for (var i = 0; i < callbacks.length; i++)
                callbacks[i](node);
        }

        // Also erase the DOM data
        ko.utils.domData.clear(node);

        // Special support for jQuery here because it's so commonly used.
        // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData
        // so notify it to tear down any resources associated with the node & descendants here.
        if ((typeof jQuery == "function") && (typeof jQuery['cleanData'] == "function"))
            jQuery['cleanData']([node]);

        // Also clear any immediate-child comment nodes, as these wouldn't have been found by
        // node.getElementsByTagName("*") in cleanNode() (comment nodes aren't elements)
        if (cleanableNodeTypesWithDescendants[node.nodeType])
            cleanImmediateCommentTypeChildren(node);
    }

    function cleanImmediateCommentTypeChildren(nodeWithChildren) {
        var child, nextChild = nodeWithChildren.firstChild;
        while (child = nextChild) {
            nextChild = child.nextSibling;
            if (child.nodeType === 8)
                cleanSingleNode(child);
        }
    }

    return {
        addDisposeCallback : function(node, callback) {
            if (typeof callback != "function")
                throw new Error("Callback must be a function");
            getDisposeCallbacksCollection(node, true).push(callback);
        },

        removeDisposeCallback : function(node, callback) {
            var callbacksCollection = getDisposeCallbacksCollection(node, false);
            if (callbacksCollection) {
                ko.utils.arrayRemoveItem(callbacksCollection, callback);
                if (callbacksCollection.length == 0)
                    destroyCallbacksCollection(node);
            }
        },

        cleanNode : function(node) {
            // First clean this node, where applicable
            if (cleanableNodeTypes[node.nodeType]) {
                cleanSingleNode(node);

                // ... then its descendants, where applicable
                if (cleanableNodeTypesWithDescendants[node.nodeType]) {
                    // Clone the descendants list in case it changes during iteration
                    var descendants = [];
                    ko.utils.arrayPushAll(descendants, node.getElementsByTagName("*"));
                    for (var i = 0, j = descendants.length; i < j; i++)
                        cleanSingleNode(descendants[i]);
                }
            }
        },

        removeNode : function(node) {
            ko.cleanNode(node);
            if (node.parentNode)
                node.parentNode.removeChild(node);
        }
    }
})();
ko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience
ko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience
ko.exportSymbol('cleanNode', ko.cleanNode);
ko.exportSymbol('removeNode', ko.removeNode);
ko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);
ko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);
ko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);
(function () {
    var leadingCommentRegex = /^(\s*)<!--(.*?)-->/;

    function simpleHtmlParse(html) {
        // Based on jQuery's "clean" function, but only accounting for table-related elements.
        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's "clean" function directly

        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of
        // a descendant node. For example: "<div><!-- mycomment -->abc</div>" will get parsed as "<div>abc</div>"
        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node
        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.

        // Trim whitespace, otherwise indexOf won't work as expected
        var tags = ko.utils.stringTrim(html).toLowerCase(), div = document.createElement("div");

        // Finds the first match from the left column, and returns the corresponding "wrap" data from the right column
        var wrap = tags.match(/^<(thead|tbody|tfoot)/)              && [1, "<table>", "</table>"] ||
                   !tags.indexOf("<tr")                             && [2, "<table><tbody>", "</tbody></table>"] ||
                   (!tags.indexOf("<td") || !tags.indexOf("<th"))   && [3, "<table><tbody><tr>", "</tr></tbody></table>"] ||
                   /* anything else */                                 [0, "", ""];

        // Go to html and back, then peel off extra wrappers
        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.
        var markup = "ignored<div>" + wrap[1] + html + wrap[2] + "</div>";
        if (typeof window['innerShiv'] == "function") {
            div.appendChild(window['innerShiv'](markup));
        } else {
            div.innerHTML = markup;
        }

        // Move to the right depth
        while (wrap[0]--)
            div = div.lastChild;

        return ko.utils.makeArray(div.lastChild.childNodes);
    }

    function jQueryHtmlParse(html) {
        var elems = jQuery['clean']([html]);

        // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.
        // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.
        // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.
        if (elems && elems[0]) {
            // Find the top-most parent element that's a direct child of a document fragment
            var elem = elems[0];
            while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)
                elem = elem.parentNode;
            // ... then detach it
            if (elem.parentNode)
                elem.parentNode.removeChild(elem);
        }

        return elems;
    }

    ko.utils.parseHtmlFragment = function(html) {
        return typeof jQuery != 'undefined' ? jQueryHtmlParse(html)   // As below, benefit from jQuery's optimisations where possible
                                            : simpleHtmlParse(html);  // ... otherwise, this simple logic will do in most common cases.
    };

    ko.utils.setHtml = function(node, html) {
        ko.utils.emptyDomNode(node);

        if ((html !== null) && (html !== undefined)) {
            if (typeof html != 'string')
                html = html.toString();

            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,
            // for example <tr> elements which are not normally allowed to exist on their own.
            // If you've referenced jQuery we'll use that rather than duplicating its code.
            if (typeof jQuery != 'undefined') {
                jQuery(node)['html'](html);
            } else {
                // ... otherwise, use KO's own parsing logic.
                var parsedNodes = ko.utils.parseHtmlFragment(html);
                for (var i = 0; i < parsedNodes.length; i++)
                    node.appendChild(parsedNodes[i]);
            }
        }
    };
})();

ko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);
ko.exportSymbol('utils.setHtml', ko.utils.setHtml);

ko.memoization = (function () {
    var memos = {};

    function randomMax8HexChars() {
        return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);
    }
    function generateRandomId() {
        return randomMax8HexChars() + randomMax8HexChars();
    }
    function findMemoNodes(rootNode, appendToArray) {
        if (!rootNode)
            return;
        if (rootNode.nodeType == 8) {
            var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);
            if (memoId != null)
                appendToArray.push({ domNode: rootNode, memoId: memoId });
        } else if (rootNode.nodeType == 1) {
            for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)
                findMemoNodes(childNodes[i], appendToArray);
        }
    }

    return {
        memoize: function (callback) {
            if (typeof callback != "function")
                throw new Error("You can only pass a function to ko.memoization.memoize()");
            var memoId = generateRandomId();
            memos[memoId] = callback;
            return "<!--[ko_memo:" + memoId + "]-->";
        },

        unmemoize: function (memoId, callbackParams) {
            var callback = memos[memoId];
            if (callback === undefined)
                throw new Error("Couldn't find any memo with ID " + memoId + ". Perhaps it's already been unmemoized.");
            try {
                callback.apply(null, callbackParams || []);
                return true;
            }
            finally { delete memos[memoId]; }
        },

        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {
            var memos = [];
            findMemoNodes(domNode, memos);
            for (var i = 0, j = memos.length; i < j; i++) {
                var node = memos[i].domNode;
                var combinedParams = [node];
                if (extraCallbackParamsArray)
                    ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);
                ko.memoization.unmemoize(memos[i].memoId, combinedParams);
                node.nodeValue = ""; // Neuter this node so we don't try to unmemoize it again
                if (node.parentNode)
                    node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)
            }
        },

        parseMemoText: function (memoText) {
            var match = memoText.match(/^\[ko_memo\:(.*?)\]$/);
            return match ? match[1] : null;
        }
    };
})();

ko.exportSymbol('memoization', ko.memoization);
ko.exportSymbol('memoization.memoize', ko.memoization.memoize);
ko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);
ko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);
ko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);
ko.extenders = {
    'throttle': function(target, timeout) {
        // Throttling means two things:

        // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies
        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate
        target['throttleEvaluation'] = timeout;

        // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*
        //     so the target cannot change value synchronously or faster than a certain rate
        var writeTimeoutInstance = null;
        return ko.dependentObservable({
            'read': target,
            'write': function(value) {
                clearTimeout(writeTimeoutInstance);
                writeTimeoutInstance = setTimeout(function() {
                    target(value);
                }, timeout);
            }
        });
    },

    'notify': function(target, notifyWhen) {
        target["equalityComparer"] = notifyWhen == "always"
            ? function() { return false } // Treat all values as not equal
            : ko.observable["fn"]["equalityComparer"];
        return target;
    }
};

function applyExtenders(requestedExtenders) {
    var target = this;
    if (requestedExtenders) {
        for (var key in requestedExtenders) {
            var extenderHandler = ko.extenders[key];
            if (typeof extenderHandler == 'function') {
                target = extenderHandler(target, requestedExtenders[key]);
            }
        }
    }
    return target;
}

ko.exportSymbol('extenders', ko.extenders);

ko.subscription = function (target, callback, disposeCallback) {
    this.target = target;
    this.callback = callback;
    this.disposeCallback = disposeCallback;
    ko.exportProperty(this, 'dispose', this.dispose);
};
ko.subscription.prototype.dispose = function () {
    this.isDisposed = true;
    this.disposeCallback();
};

ko.subscribable = function () {
    this._subscriptions = {};

    ko.utils.extend(this, ko.subscribable['fn']);
    ko.exportProperty(this, 'subscribe', this.subscribe);
    ko.exportProperty(this, 'extend', this.extend);
    ko.exportProperty(this, 'getSubscriptionsCount', this.getSubscriptionsCount);
}

var defaultEvent = "change";

ko.subscribable['fn'] = {
    subscribe: function (callback, callbackTarget, event) {
        event = event || defaultEvent;
        var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;

        var subscription = new ko.subscription(this, boundCallback, function () {
            ko.utils.arrayRemoveItem(this._subscriptions[event], subscription);
        }.bind(this));

        if (!this._subscriptions[event])
            this._subscriptions[event] = [];
        this._subscriptions[event].push(subscription);
        return subscription;
    },

    "notifySubscribers": function (valueToNotify, event) {
        event = event || defaultEvent;
        if (this._subscriptions[event]) {
            ko.utils.arrayForEach(this._subscriptions[event].slice(0), function (subscription) {
                // In case a subscription was disposed during the arrayForEach cycle, check
                // for isDisposed on each subscription before invoking its callback
                if (subscription && (subscription.isDisposed !== true))
                    subscription.callback(valueToNotify);
            });
        }
    },

    getSubscriptionsCount: function () {
        var total = 0;
        for (var eventName in this._subscriptions) {
            if (this._subscriptions.hasOwnProperty(eventName))
                total += this._subscriptions[eventName].length;
        }
        return total;
    },

    extend: applyExtenders
};


ko.isSubscribable = function (instance) {
    return typeof instance.subscribe == "function" && typeof instance["notifySubscribers"] == "function";
};

ko.exportSymbol('subscribable', ko.subscribable);
ko.exportSymbol('isSubscribable', ko.isSubscribable);

ko.dependencyDetection = (function () {
    var _frames = [];

    return {
        begin: function (callback) {
            _frames.push({ callback: callback, distinctDependencies:[] });
        },

        end: function () {
            _frames.pop();
        },

        registerDependency: function (subscribable) {
            if (!ko.isSubscribable(subscribable))
                throw new Error("Only subscribable things can act as dependencies");
            if (_frames.length > 0) {
                var topFrame = _frames[_frames.length - 1];
                if (ko.utils.arrayIndexOf(topFrame.distinctDependencies, subscribable) >= 0)
                    return;
                topFrame.distinctDependencies.push(subscribable);
                topFrame.callback(subscribable);
            }
        }
    };
})();
var primitiveTypes = { 'undefined':true, 'boolean':true, 'number':true, 'string':true };

ko.observable = function (initialValue) {
    var _latestValue = initialValue;

    function observable() {
        if (arguments.length > 0) {
            // Write

            // Ignore writes if the value hasn't changed
            if ((!observable['equalityComparer']) || !observable['equalityComparer'](_latestValue, arguments[0])) {
                observable.valueWillMutate();
                _latestValue = arguments[0];
                if (DEBUG) observable._latestValue = _latestValue;
                observable.valueHasMutated();
            }
            return this; // Permits chained assignments
        }
        else {
            // Read
            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a "read" operation
            return _latestValue;
        }
    }
    if (DEBUG) observable._latestValue = _latestValue;
    ko.subscribable.call(observable);
    observable.valueHasMutated = function () { observable["notifySubscribers"](_latestValue); }
    observable.valueWillMutate = function () { observable["notifySubscribers"](_latestValue, "beforeChange"); }
    ko.utils.extend(observable, ko.observable['fn']);

    ko.exportProperty(observable, "valueHasMutated", observable.valueHasMutated);
    ko.exportProperty(observable, "valueWillMutate", observable.valueWillMutate);

    return observable;
}

ko.observable['fn'] = {
    "equalityComparer": function valuesArePrimitiveAndEqual(a, b) {
        var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);
        return oldValueIsPrimitive ? (a === b) : false;
    }
};

var protoProperty = ko.observable.protoProperty = "__ko_proto__";
ko.observable['fn'][protoProperty] = ko.observable;

ko.hasPrototype = function(instance, prototype) {
    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;
    if (instance[protoProperty] === prototype) return true;
    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain
};

ko.isObservable = function (instance) {
    return ko.hasPrototype(instance, ko.observable);
}
ko.isWriteableObservable = function (instance) {
    // Observable
    if ((typeof instance == "function") && instance[protoProperty] === ko.observable)
        return true;
    // Writeable dependent observable
    if ((typeof instance == "function") && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))
        return true;
    // Anything else
    return false;
}


ko.exportSymbol('observable', ko.observable);
ko.exportSymbol('isObservable', ko.isObservable);
ko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);
ko.observableArray = function (initialValues) {
    if (arguments.length == 0) {
        // Zero-parameter constructor initializes to empty array
        initialValues = [];
    }
    if ((initialValues !== null) && (initialValues !== undefined) && !('length' in initialValues))
        throw new Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");

    var result = ko.observable(initialValues);
    ko.utils.extend(result, ko.observableArray['fn']);
    return result;
}

ko.observableArray['fn'] = {
    'remove': function (valueOrPredicate) {
        var underlyingArray = this();
        var removedValues = [];
        var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
        for (var i = 0; i < underlyingArray.length; i++) {
            var value = underlyingArray[i];
            if (predicate(value)) {
                if (removedValues.length === 0) {
                    this.valueWillMutate();
                }
                removedValues.push(value);
                underlyingArray.splice(i, 1);
                i--;
            }
        }
        if (removedValues.length) {
            this.valueHasMutated();
        }
        return removedValues;
    },

    'removeAll': function (arrayOfValues) {
        // If you passed zero args, we remove everything
        if (arrayOfValues === undefined) {
            var underlyingArray = this();
            var allValues = underlyingArray.slice(0);
            this.valueWillMutate();
            underlyingArray.splice(0, underlyingArray.length);
            this.valueHasMutated();
            return allValues;
        }
        // If you passed an arg, we interpret it as an array of entries to remove
        if (!arrayOfValues)
            return [];
        return this['remove'](function (value) {
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
        });
    },

    'destroy': function (valueOrPredicate) {
        var underlyingArray = this();
        var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
        this.valueWillMutate();
        for (var i = underlyingArray.length - 1; i >= 0; i--) {
            var value = underlyingArray[i];
            if (predicate(value))
                underlyingArray[i]["_destroy"] = true;
        }
        this.valueHasMutated();
    },

    'destroyAll': function (arrayOfValues) {
        // If you passed zero args, we destroy everything
        if (arrayOfValues === undefined)
            return this['destroy'](function() { return true });

        // If you passed an arg, we interpret it as an array of entries to destroy
        if (!arrayOfValues)
            return [];
        return this['destroy'](function (value) {
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
        });
    },

    'indexOf': function (item) {
        var underlyingArray = this();
        return ko.utils.arrayIndexOf(underlyingArray, item);
    },

    'replace': function(oldItem, newItem) {
        var index = this['indexOf'](oldItem);
        if (index >= 0) {
            this.valueWillMutate();
            this()[index] = newItem;
            this.valueHasMutated();
        }
    }
}

// Populate ko.observableArray.fn with read/write functions from native arrays
ko.utils.arrayForEach(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (methodName) {
    ko.observableArray['fn'][methodName] = function () {
        var underlyingArray = this();
        this.valueWillMutate();
        var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);
        this.valueHasMutated();
        return methodCallResult;
    };
});

// Populate ko.observableArray.fn with read-only functions from native arrays
ko.utils.arrayForEach(["slice"], function (methodName) {
    ko.observableArray['fn'][methodName] = function () {
        var underlyingArray = this();
        return underlyingArray[methodName].apply(underlyingArray, arguments);
    };
});

ko.exportSymbol('observableArray', ko.observableArray);
ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
    var _latestValue,
        _hasBeenEvaluated = false,
        _isBeingEvaluated = false,
        readFunction = evaluatorFunctionOrOptions;

    if (readFunction && typeof readFunction == "object") {
        // Single-parameter syntax - everything is on this "options" param
        options = readFunction;
        readFunction = options["read"];
    } else {
        // Multi-parameter syntax - construct the options according to the params passed
        options = options || {};
        if (!readFunction)
            readFunction = options["read"];
    }
    // By here, "options" is always non-null
    if (typeof readFunction != "function")
        throw new Error("Pass a function that returns the value of the ko.computed");

    var writeFunction = options["write"];
    if (!evaluatorFunctionTarget)
        evaluatorFunctionTarget = options["owner"];

    var _subscriptionsToDependencies = [];
    function disposeAllSubscriptionsToDependencies() {
        ko.utils.arrayForEach(_subscriptionsToDependencies, function (subscription) {
            subscription.dispose();
        });
        _subscriptionsToDependencies = [];
    }
    var dispose = disposeAllSubscriptionsToDependencies;

    // Build "disposeWhenNodeIsRemoved" and "disposeWhenNodeIsRemovedCallback" option values
    // (Note: "disposeWhenNodeIsRemoved" option both proactively disposes as soon as the node is removed using ko.removeNode(),
    // plus adds a "disposeWhen" callback that, on each evaluation, disposes if the node was removed by some other means.)
    var disposeWhenNodeIsRemoved = (typeof options["disposeWhenNodeIsRemoved"] == "object") ? options["disposeWhenNodeIsRemoved"] : null;
    var disposeWhen = options["disposeWhen"] || function() { return false; };
    if (disposeWhenNodeIsRemoved) {
        dispose = function() {
            ko.utils.domNodeDisposal.removeDisposeCallback(disposeWhenNodeIsRemoved, arguments.callee);
            disposeAllSubscriptionsToDependencies();
        };
        ko.utils.domNodeDisposal.addDisposeCallback(disposeWhenNodeIsRemoved, dispose);
        var existingDisposeWhenFunction = disposeWhen;
        disposeWhen = function () {
            return !ko.utils.domNodeIsAttachedToDocument(disposeWhenNodeIsRemoved) || existingDisposeWhenFunction();
        }
    }

    var evaluationTimeoutInstance = null;
    function evaluatePossiblyAsync() {
        var throttleEvaluationTimeout = dependentObservable['throttleEvaluation'];
        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {
            clearTimeout(evaluationTimeoutInstance);
            evaluationTimeoutInstance = setTimeout(evaluateImmediate, throttleEvaluationTimeout);
        } else
            evaluateImmediate();
    }

    function evaluateImmediate() {
        if (_isBeingEvaluated) {
            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.
            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost
            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing
            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387
            return;
        }

        // Don't dispose on first evaluation, because the "disposeWhen" callback might
        // e.g., dispose when the associated DOM element isn't in the doc, and it's not
        // going to be in the doc until *after* the first evaluation
        if (_hasBeenEvaluated && disposeWhen()) {
            dispose();
            return;
        }

        _isBeingEvaluated = true;
        try {
            // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).
            // Then, during evaluation, we cross off any that are in fact still being used.
            var disposalCandidates = ko.utils.arrayMap(_subscriptionsToDependencies, function(item) {return item.target;});

            ko.dependencyDetection.begin(function(subscribable) {
                var inOld;
                if ((inOld = ko.utils.arrayIndexOf(disposalCandidates, subscribable)) >= 0)
                    disposalCandidates[inOld] = undefined; // Don't want to dispose this subscription, as it's still being used
                else
                    _subscriptionsToDependencies.push(subscribable.subscribe(evaluatePossiblyAsync)); // Brand new subscription - add it
            });

            var newValue = readFunction.call(evaluatorFunctionTarget);

            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it
            for (var i = disposalCandidates.length - 1; i >= 0; i--) {
                if (disposalCandidates[i])
                    _subscriptionsToDependencies.splice(i, 1)[0].dispose();
            }
            _hasBeenEvaluated = true;

            dependentObservable["notifySubscribers"](_latestValue, "beforeChange");
            _latestValue = newValue;
            if (DEBUG) dependentObservable._latestValue = _latestValue;
        } finally {
            ko.dependencyDetection.end();
        }

        dependentObservable["notifySubscribers"](_latestValue);
        _isBeingEvaluated = false;

    }

    function dependentObservable() {
        if (arguments.length > 0) {
            set.apply(dependentObservable, arguments);
        } else {
            return get();
        }
    }

    function set() {
        if (typeof writeFunction === "function") {
            // Writing a value
            writeFunction.apply(evaluatorFunctionTarget, arguments);
        } else {
            throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
        }
    }

    function get() {
        // Reading the value
        if (!_hasBeenEvaluated)
            evaluateImmediate();
        ko.dependencyDetection.registerDependency(dependentObservable);
        return _latestValue;
    }

    dependentObservable.getDependenciesCount = function () { return _subscriptionsToDependencies.length; };
    dependentObservable.hasWriteFunction = typeof options["write"] === "function";
    dependentObservable.dispose = function () { dispose(); };

    ko.subscribable.call(dependentObservable);
    ko.utils.extend(dependentObservable, ko.dependentObservable['fn']);

    if (options['deferEvaluation'] !== true)
        evaluateImmediate();

    ko.exportProperty(dependentObservable, 'dispose', dependentObservable.dispose);
    ko.exportProperty(dependentObservable, 'getDependenciesCount', dependentObservable.getDependenciesCount);

    return dependentObservable;
};

ko.isComputed = function(instance) {
    return ko.hasPrototype(instance, ko.dependentObservable);
};

var protoProp = ko.observable.protoProperty; // == "__ko_proto__"
ko.dependentObservable[protoProp] = ko.observable;

ko.dependentObservable['fn'] = {};
ko.dependentObservable['fn'][protoProp] = ko.dependentObservable;

ko.exportSymbol('dependentObservable', ko.dependentObservable);
ko.exportSymbol('computed', ko.dependentObservable); // Make "ko.computed" an alias for "ko.dependentObservable"
ko.exportSymbol('isComputed', ko.isComputed);

(function() {
    var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)

    ko.toJS = function(rootObject) {
        if (arguments.length == 0)
            throw new Error("When calling ko.toJS, pass the object you want to convert.");

        // We just unwrap everything at every level in the object graph
        return mapJsObjectGraph(rootObject, function(valueToMap) {
            // Loop because an observable's value might in turn be another observable wrapper
            for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)
                valueToMap = valueToMap();
            return valueToMap;
        });
    };

    ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional
        var plainJavaScriptObject = ko.toJS(rootObject);
        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);
    };

    function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {
        visitedObjects = visitedObjects || new objectLookup();

        rootObject = mapInputCallback(rootObject);
        var canHaveProperties = (typeof rootObject == "object") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof Date));
        if (!canHaveProperties)
            return rootObject;

        var outputProperties = rootObject instanceof Array ? [] : {};
        visitedObjects.save(rootObject, outputProperties);

        visitPropertiesOrArrayEntries(rootObject, function(indexer) {
            var propertyValue = mapInputCallback(rootObject[indexer]);

            switch (typeof propertyValue) {
                case "boolean":
                case "number":
                case "string":
                case "function":
                    outputProperties[indexer] = propertyValue;
                    break;
                case "object":
                case "undefined":
                    var previouslyMappedValue = visitedObjects.get(propertyValue);
                    outputProperties[indexer] = (previouslyMappedValue !== undefined)
                        ? previouslyMappedValue
                        : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);
                    break;
            }
        });

        return outputProperties;
    }

    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
        if (rootObject instanceof Array) {
            for (var i = 0; i < rootObject.length; i++)
                visitorCallback(i);

            // For arrays, also respect toJSON property for custom mappings (fixes #278)
            if (typeof rootObject['toJSON'] == 'function')
                visitorCallback('toJSON');
        } else {
            for (var propertyName in rootObject)
                visitorCallback(propertyName);
        }
    };

    function objectLookup() {
        var keys = [];
        var values = [];
        this.save = function(key, value) {
            var existingIndex = ko.utils.arrayIndexOf(keys, key);
            if (existingIndex >= 0)
                values[existingIndex] = value;
            else {
                keys.push(key);
                values.push(value);
            }
        };
        this.get = function(key) {
            var existingIndex = ko.utils.arrayIndexOf(keys, key);
            return (existingIndex >= 0) ? values[existingIndex] : undefined;
        };
    };
})();

ko.exportSymbol('toJS', ko.toJS);
ko.exportSymbol('toJSON', ko.toJSON);
(function () {
    var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';

    // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values
    // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values
    // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.
    ko.selectExtensions = {
        readValue : function(element) {
            switch (ko.utils.tagNameLower(element)) {
                case 'option':
                    if (element[hasDomDataExpandoProperty] === true)
                        return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);
                    return element.getAttribute("value");
                case 'select':
                    return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;
                default:
                    return element.value;
            }
        },

        writeValue: function(element, value) {
            switch (ko.utils.tagNameLower(element)) {
                case 'option':
                    switch(typeof value) {
                        case "string":
                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);
                            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node
                                delete element[hasDomDataExpandoProperty];
                            }
                            element.value = value;
                            break;
                        default:
                            // Store arbitrary object using DomData
                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);
                            element[hasDomDataExpandoProperty] = true;

                            // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.
                            element.value = typeof value === "number" ? value : "";
                            break;
                    }
                    break;
                case 'select':
                    for (var i = element.options.length - 1; i >= 0; i--) {
                        if (ko.selectExtensions.readValue(element.options[i]) == value) {
                            element.selectedIndex = i;
                            break;
                        }
                    }
                    break;
                default:
                    if ((value === null) || (value === undefined))
                        value = "";
                    element.value = value;
                    break;
            }
        }
    };
})();

ko.exportSymbol('selectExtensions', ko.selectExtensions);
ko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);
ko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);

ko.jsonExpressionRewriting = (function () {
    var restoreCapturedTokensRegex = /\@ko_token_(\d+)\@/g;
    var javaScriptAssignmentTarget = /^[\_$a-z][\_$a-z0-9]*(\[.*?\])*(\.[\_$a-z][\_$a-z0-9]*(\[.*?\])*)*$/i;
    var javaScriptReservedWords = ["true", "false"];

    function restoreTokens(string, tokens) {
        var prevValue = null;
        while (string != prevValue) { // Keep restoring tokens until it no longer makes a difference (they may be nested)
            prevValue = string;
            string = string.replace(restoreCapturedTokensRegex, function (match, tokenIndex) {
                return tokens[tokenIndex];
            });
        }
        return string;
    }

    function isWriteableValue(expression) {
        if (ko.utils.arrayIndexOf(javaScriptReservedWords, ko.utils.stringTrim(expression).toLowerCase()) >= 0)
            return false;
        return expression.match(javaScriptAssignmentTarget) !== null;
    }

    function ensureQuoted(key) {
        var trimmedKey = ko.utils.stringTrim(key);
        switch (trimmedKey.length && trimmedKey.charAt(0)) {
            case "'":
            case '"':
                return key;
            default:
                return "'" + trimmedKey + "'";
        }
    }

    return {
        bindingRewriteValidators: [],

        parseObjectLiteral: function(objectLiteralString) {
            // A full tokeniser+lexer would add too much weight to this library, so here's a simple parser
            // that is sufficient just to split an object literal string into a set of top-level key-value pairs

            var str = ko.utils.stringTrim(objectLiteralString);
            if (str.length < 3)
                return [];
            if (str.charAt(0) === "{")// Ignore any braces surrounding the whole object literal
                str = str.substring(1, str.length - 1);

            // Pull out any string literals and regex literals
            var tokens = [];
            var tokenStart = null, tokenEndChar;
            for (var position = 0; position < str.length; position++) {
                var c = str.charAt(position);
                if (tokenStart === null) {
                    switch (c) {
                        case '"':
                        case "'":
                        case "/":
                            tokenStart = position;
                            tokenEndChar = c;
                            break;
                    }
                } else if ((c == tokenEndChar) && (str.charAt(position - 1) !== "\\")) {
                    var token = str.substring(tokenStart, position + 1);
                    tokens.push(token);
                    var replacement = "@ko_token_" + (tokens.length - 1) + "@";
                    str = str.substring(0, tokenStart) + replacement + str.substring(position + 1);
                    position -= (token.length - replacement.length);
                    tokenStart = null;
                }
            }

            // Next pull out balanced paren, brace, and bracket blocks
            tokenStart = null;
            tokenEndChar = null;
            var tokenDepth = 0, tokenStartChar = null;
            for (var position = 0; position < str.length; position++) {
                var c = str.charAt(position);
                if (tokenStart === null) {
                    switch (c) {
                        case "{": tokenStart = position; tokenStartChar = c;
                                  tokenEndChar = "}";
                                  break;
                        case "(": tokenStart = position; tokenStartChar = c;
                                  tokenEndChar = ")";
                                  break;
                        case "[": tokenStart = position; tokenStartChar = c;
                                  tokenEndChar = "]";
                                  break;
                    }
                }

                if (c === tokenStartChar)
                    tokenDepth++;
                else if (c === tokenEndChar) {
                    tokenDepth--;
                    if (tokenDepth === 0) {
                        var token = str.substring(tokenStart, position + 1);
                        tokens.push(token);
                        var replacement = "@ko_token_" + (tokens.length - 1) + "@";
                        str = str.substring(0, tokenStart) + replacement + str.substring(position + 1);
                        position -= (token.length - replacement.length);
                        tokenStart = null;
                    }
                }
            }

            // Now we can safely split on commas to get the key/value pairs
            var result = [];
            var keyValuePairs = str.split(",");
            for (var i = 0, j = keyValuePairs.length; i < j; i++) {
                var pair = keyValuePairs[i];
                var colonPos = pair.indexOf(":");
                if ((colonPos > 0) && (colonPos < pair.length - 1)) {
                    var key = pair.substring(0, colonPos);
                    var value = pair.substring(colonPos + 1);
                    result.push({ 'key': restoreTokens(key, tokens), 'value': restoreTokens(value, tokens) });
                } else {
                    result.push({ 'unknown': restoreTokens(pair, tokens) });
                }
            }
            return result;
        },

        insertPropertyAccessorsIntoJson: function (objectLiteralStringOrKeyValueArray) {
            var keyValueArray = typeof objectLiteralStringOrKeyValueArray === "string"
                ? ko.jsonExpressionRewriting.parseObjectLiteral(objectLiteralStringOrKeyValueArray)
                : objectLiteralStringOrKeyValueArray;
            var resultStrings = [], propertyAccessorResultStrings = [];

            var keyValueEntry;
            for (var i = 0; keyValueEntry = keyValueArray[i]; i++) {
                if (resultStrings.length > 0)
                    resultStrings.push(",");

                if (keyValueEntry['key']) {
                    var quotedKey = ensureQuoted(keyValueEntry['key']), val = keyValueEntry['value'];
                    resultStrings.push(quotedKey);
                    resultStrings.push(":");
                    resultStrings.push(val);

                    if (isWriteableValue(ko.utils.stringTrim(val))) {
                        if (propertyAccessorResultStrings.length > 0)
                            propertyAccessorResultStrings.push(", ");
                        propertyAccessorResultStrings.push(quotedKey + " : function(__ko_value) { " + val + " = __ko_value; }");
                    }
                } else if (keyValueEntry['unknown']) {
                    resultStrings.push(keyValueEntry['unknown']);
                }
            }

            var combinedResult = resultStrings.join("");
            if (propertyAccessorResultStrings.length > 0) {
                var allPropertyAccessors = propertyAccessorResultStrings.join("");
                combinedResult = combinedResult + ", '_ko_property_writers' : { " + allPropertyAccessors + " } ";
            }

            return combinedResult;
        },

        keyValueArrayContainsKey: function(keyValueArray, key) {
            for (var i = 0; i < keyValueArray.length; i++)
                if (ko.utils.stringTrim(keyValueArray[i]['key']) == key)
                    return true;
            return false;
        },

        // Internal, private KO utility for updating model properties from within bindings
        // property:            If the property being updated is (or might be) an observable, pass it here
        //                      If it turns out to be a writable observable, it will be written to directly
        // allBindingsAccessor: All bindings in the current execution context.
        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable
        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'
        // value:               The value to be written
        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if
        //                      it is !== existing value on that writable observable
        writeValueToProperty: function(property, allBindingsAccessor, key, value, checkIfDifferent) {
            if (!property || !ko.isWriteableObservable(property)) {
                var propWriters = allBindingsAccessor()['_ko_property_writers'];
                if (propWriters && propWriters[key])
                    propWriters[key](value);
            } else if (!checkIfDifferent || property() !== value) {
                property(value);
            }
        }
    };
})();

ko.exportSymbol('jsonExpressionRewriting', ko.jsonExpressionRewriting);
ko.exportSymbol('jsonExpressionRewriting.bindingRewriteValidators', ko.jsonExpressionRewriting.bindingRewriteValidators);
ko.exportSymbol('jsonExpressionRewriting.parseObjectLiteral', ko.jsonExpressionRewriting.parseObjectLiteral);
ko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.jsonExpressionRewriting.insertPropertyAccessorsIntoJson);
(function() {
    // "Virtual elements" is an abstraction on top of the usual DOM API which understands the notion that comment nodes
    // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).
    // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state
    // of that virtual hierarchy
    //
    // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)
    // without having to scatter special cases all over the binding and templating code.

    // IE 9 cannot reliably read the "nodeValue" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)
    // but it does give them a nonstandard alternative property called "text" that it can read reliably. Other browsers don't have that property.
    // So, use node.text where available, and node.nodeValue elsewhere
    var commentNodesHaveTextProperty = document.createComment("test").text === "<!--test-->";

    var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\s*ko\s+(.*\:.*)\s*-->$/ : /^\s*ko\s+(.*\:.*)\s*$/;
    var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\s*\/ko\s*-->$/ : /^\s*\/ko\s*$/;
    var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };

    function isStartComment(node) {
        return (node.nodeType == 8) && (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);
    }

    function isEndComment(node) {
        return (node.nodeType == 8) && (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(endCommentRegex);
    }

    function getVirtualChildren(startComment, allowUnbalanced) {
        var currentNode = startComment;
        var depth = 1;
        var children = [];
        while (currentNode = currentNode.nextSibling) {
            if (isEndComment(currentNode)) {
                depth--;
                if (depth === 0)
                    return children;
            }

            children.push(currentNode);

            if (isStartComment(currentNode))
                depth++;
        }
        if (!allowUnbalanced)
            throw new Error("Cannot find closing comment tag to match: " + startComment.nodeValue);
        return null;
    }

    function getMatchingEndComment(startComment, allowUnbalanced) {
        var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);
        if (allVirtualChildren) {
            if (allVirtualChildren.length > 0)
                return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;
            return startComment.nextSibling;
        } else
            return null; // Must have no matching end comment, and allowUnbalanced is true
    }

    function getUnbalancedChildTags(node) {
        // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>
        //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->
        var childNode = node.firstChild, captureRemaining = null;
        if (childNode) {
            do {
                if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes
                    captureRemaining.push(childNode);
                else if (isStartComment(childNode)) {
                    var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);
                    if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set
                        childNode = matchingEndComment;
                    else
                        captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point
                } else if (isEndComment(childNode)) {
                    captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing
                }
            } while (childNode = childNode.nextSibling);
        }
        return captureRemaining;
    }

    ko.virtualElements = {
        allowedBindings: {},

        childNodes: function(node) {
            return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;
        },

        emptyNode: function(node) {
            if (!isStartComment(node))
                ko.utils.emptyDomNode(node);
            else {
                var virtualChildren = ko.virtualElements.childNodes(node);
                for (var i = 0, j = virtualChildren.length; i < j; i++)
                    ko.removeNode(virtualChildren[i]);
            }
        },

        setDomNodeChildren: function(node, childNodes) {
            if (!isStartComment(node))
                ko.utils.setDomNodeChildren(node, childNodes);
            else {
                ko.virtualElements.emptyNode(node);
                var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children
                for (var i = 0, j = childNodes.length; i < j; i++)
                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);
            }
        },

        prepend: function(containerNode, nodeToPrepend) {
            if (!isStartComment(containerNode)) {
                if (containerNode.firstChild)
                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);
                else
                    containerNode.appendChild(nodeToPrepend);
            } else {
                // Start comments must always have a parent and at least one following sibling (the end comment)
                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);
            }
        },

        insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {
            if (!isStartComment(containerNode)) {
                // Insert after insertion point
                if (insertAfterNode.nextSibling)
                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
                else
                    containerNode.appendChild(nodeToInsert);
            } else {
                // Children of start comments must always have a parent and at least one following sibling (the end comment)
                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
            }
        },

        firstChild: function(node) {
            if (!isStartComment(node))
                return node.firstChild;
            if (!node.nextSibling || isEndComment(node.nextSibling))
                return null;
            return node.nextSibling;
        },

        nextSibling: function(node) {
            if (isStartComment(node))
                node = getMatchingEndComment(node);
            if (node.nextSibling && isEndComment(node.nextSibling))
                return null;
            return node.nextSibling;
        },

        virtualNodeBindingValue: function(node) {
            var regexMatch = isStartComment(node);
            return regexMatch ? regexMatch[1] : null;
        },

        normaliseVirtualElementDomStructure: function(elementVerified) {
            // Workaround for https://github.com/SteveSanderson/knockout/issues/155
            // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes
            // that are direct descendants of <ul> into the preceding <li>)
            if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])
                return;

            // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags
            // must be intended to appear *after* that child, so move them there.
            var childNode = elementVerified.firstChild;
            if (childNode) {
                do {
                    if (childNode.nodeType === 1) {
                        var unbalancedTags = getUnbalancedChildTags(childNode);
                        if (unbalancedTags) {
                            // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child
                            var nodeToInsertBefore = childNode.nextSibling;
                            for (var i = 0; i < unbalancedTags.length; i++) {
                                if (nodeToInsertBefore)
                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);
                                else
                                    elementVerified.appendChild(unbalancedTags[i]);
                            }
                        }
                    }
                } while (childNode = childNode.nextSibling);
            }
        }
    };
})();
ko.exportSymbol('virtualElements', ko.virtualElements);
ko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);
ko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);
//ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified
ko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);
//ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified
ko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);
ko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);
(function() {
    var defaultBindingAttributeName = "data-bind";

    ko.bindingProvider = function() {
        this.bindingCache = {};
    };

    ko.utils.extend(ko.bindingProvider.prototype, {
        'nodeHasBindings': function(node) {
            switch (node.nodeType) {
                case 1: return node.getAttribute(defaultBindingAttributeName) != null;   // Element
                case 8: return ko.virtualElements.virtualNodeBindingValue(node) != null; // Comment node
                default: return false;
            }
        },

        'getBindings': function(node, bindingContext) {
            var bindingsString = this['getBindingsString'](node, bindingContext);
            return bindingsString ? this['parseBindingsString'](bindingsString, bindingContext) : null;
        },

        // The following function is only used internally by this default provider.
        // It's not part of the interface definition for a general binding provider.
        'getBindingsString': function(node, bindingContext) {
            switch (node.nodeType) {
                case 1: return node.getAttribute(defaultBindingAttributeName);   // Element
                case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node
                default: return null;
            }
        },

        // The following function is only used internally by this default provider.
        // It's not part of the interface definition for a general binding provider.
        'parseBindingsString': function(bindingsString, bindingContext) {
            try {
                var viewModel = bindingContext['$data'],
                    scopes = (typeof viewModel == 'object' && viewModel != null) ? [viewModel, bindingContext] : [bindingContext],
                    bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, scopes.length, this.bindingCache);
                return bindingFunction(scopes);
            } catch (ex) {
                throw new Error("Unable to parse bindings.\nMessage: " + ex + ";\nBindings value: " + bindingsString);
            }
        }
    });

    ko.bindingProvider['instance'] = new ko.bindingProvider();

    function createBindingsStringEvaluatorViaCache(bindingsString, scopesCount, cache) {
        var cacheKey = scopesCount + '_' + bindingsString;
        return cache[cacheKey]
            || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString, scopesCount));
    }

    function createBindingsStringEvaluator(bindingsString, scopesCount) {
        var rewrittenBindings = " { " + ko.jsonExpressionRewriting.insertPropertyAccessorsIntoJson(bindingsString) + " } ";
        return ko.utils.buildEvalWithinScopeFunction(rewrittenBindings, scopesCount);
    }
})();

ko.exportSymbol('bindingProvider', ko.bindingProvider);
(function () {
    ko.bindingHandlers = {};

    ko.bindingContext = function(dataItem, parentBindingContext) {
        if (parentBindingContext) {
            ko.utils.extend(this, parentBindingContext); // Inherit $root and any custom properties
            this['$parentContext'] = parentBindingContext;
            this['$parent'] = parentBindingContext['$data'];
            this['$parents'] = (parentBindingContext['$parents'] || []).slice(0);
            this['$parents'].unshift(this['$parent']);
        } else {
            this['$parents'] = [];
            this['$root'] = dataItem;
        }
        this['$data'] = dataItem;
    }
    ko.bindingContext.prototype['createChildContext'] = function (dataItem) {
        return new ko.bindingContext(dataItem, this);
    };
    ko.bindingContext.prototype['extend'] = function(properties) {
        var clone = ko.utils.extend(new ko.bindingContext(), this);
        return ko.utils.extend(clone, properties);
    };

    function validateThatBindingIsAllowedForVirtualElements(bindingName) {
        var validator = ko.virtualElements.allowedBindings[bindingName];
        if (!validator)
            throw new Error("The binding '" + bindingName + "' cannot be used with virtual elements")
    }

    function applyBindingsToDescendantsInternal (viewModel, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {
        var currentChild, nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);
        while (currentChild = nextInQueue) {
            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position
            nextInQueue = ko.virtualElements.nextSibling(currentChild);
            applyBindingsToNodeAndDescendantsInternal(viewModel, currentChild, bindingContextsMayDifferFromDomParentElement);
        }
    }

    function applyBindingsToNodeAndDescendantsInternal (viewModel, nodeVerified, bindingContextMayDifferFromDomParentElement) {
        var shouldBindDescendants = true;

        // Perf optimisation: Apply bindings only if...
        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)
        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those
        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)
        var isElement = (nodeVerified.nodeType === 1);
        if (isElement) // Workaround IE <= 8 HTML parsing weirdness
            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);

        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)
                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)
        if (shouldApplyBindings)
            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, viewModel, bindingContextMayDifferFromDomParentElement).shouldBindDescendants;

        if (shouldBindDescendants) {
            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,
            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,
            //    hence bindingContextsMayDifferFromDomParentElement is false
            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may
            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,
            //    hence bindingContextsMayDifferFromDomParentElement is true
            applyBindingsToDescendantsInternal(viewModel, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);
        }
    }

    function applyBindingsToNodeInternal (node, bindings, viewModelOrBindingContext, bindingContextMayDifferFromDomParentElement) {
        // Need to be sure that inits are only run once, and updates never run until all the inits have been run
        var initPhase = 0; // 0 = before all inits, 1 = during inits, 2 = after all inits

        // Each time the dependentObservable is evaluated (after data changes),
        // the binding attribute is reparsed so that it can pick out the correct
        // model properties in the context of the changed data.
        // DOM event callbacks need to be able to access this changed data,
        // so we need a single parsedBindings variable (shared by all callbacks
        // associated with this node's bindings) that all the closures can access.
        var parsedBindings;
        function makeValueAccessor(bindingKey) {
            return function () { return parsedBindings[bindingKey] }
        }
        function parsedBindingsAccessor() {
            return parsedBindings;
        }

        var bindingHandlerThatControlsDescendantBindings;
        ko.dependentObservable(
            function () {
                // Ensure we have a nonnull binding context to work with
                var bindingContextInstance = viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)
                    ? viewModelOrBindingContext
                    : new ko.bindingContext(ko.utils.unwrapObservable(viewModelOrBindingContext));
                var viewModel = bindingContextInstance['$data'];

                // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because
                // we can easily recover it just by scanning up the node's ancestors in the DOM
                // (note: here, parent node means "real DOM parent" not "virtual parent", as there's no O(1) way to find the virtual parent)
                if (bindingContextMayDifferFromDomParentElement)
                    ko.storedBindingContextForNode(node, bindingContextInstance);

                // Use evaluatedBindings if given, otherwise fall back on asking the bindings provider to give us some bindings
                var evaluatedBindings = (typeof bindings == "function") ? bindings() : bindings;
                parsedBindings = evaluatedBindings || ko.bindingProvider['instance']['getBindings'](node, bindingContextInstance);

                if (parsedBindings) {
                    // First run all the inits, so bindings can register for notification on changes
                    if (initPhase === 0) {
                        initPhase = 1;
                        for (var bindingKey in parsedBindings) {
                            var binding = ko.bindingHandlers[bindingKey];
                            if (binding && node.nodeType === 8)
                                validateThatBindingIsAllowedForVirtualElements(bindingKey);

                            if (binding && typeof binding["init"] == "function") {
                                var handlerInitFn = binding["init"];
                                var initResult = handlerInitFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance);

                                // If this binding handler claims to control descendant bindings, make a note of this
                                if (initResult && initResult['controlsDescendantBindings']) {
                                    if (bindingHandlerThatControlsDescendantBindings !== undefined)
                                        throw new Error("Multiple bindings (" + bindingHandlerThatControlsDescendantBindings + " and " + bindingKey + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
                                    bindingHandlerThatControlsDescendantBindings = bindingKey;
                                }
                            }
                        }
                        initPhase = 2;
                    }

                    // ... then run all the updates, which might trigger changes even on the first evaluation
                    if (initPhase === 2) {
                        for (var bindingKey in parsedBindings) {
                            var binding = ko.bindingHandlers[bindingKey];
                            if (binding && typeof binding["update"] == "function") {
                                var handlerUpdateFn = binding["update"];
                                handlerUpdateFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance);
                            }
                        }
                    }
                }
            },
            null,
            { 'disposeWhenNodeIsRemoved' : node }
        );

        return {
            shouldBindDescendants: bindingHandlerThatControlsDescendantBindings === undefined
        };
    };

    var storedBindingContextDomDataKey = "__ko_bindingContext__";
    ko.storedBindingContextForNode = function (node, bindingContext) {
        if (arguments.length == 2)
            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);
        else
            return ko.utils.domData.get(node, storedBindingContextDomDataKey);
    }

    ko.applyBindingsToNode = function (node, bindings, viewModel) {
        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness
            ko.virtualElements.normaliseVirtualElementDomStructure(node);
        return applyBindingsToNodeInternal(node, bindings, viewModel, true);
    };

    ko.applyBindingsToDescendants = function(viewModel, rootNode) {
        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)
            applyBindingsToDescendantsInternal(viewModel, rootNode, true);
    };

    ko.applyBindings = function (viewModel, rootNode) {
        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))
            throw new Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
        rootNode = rootNode || window.document.body; // Make "rootNode" parameter optional

        applyBindingsToNodeAndDescendantsInternal(viewModel, rootNode, true);
    };

    // Retrieving binding context from arbitrary nodes
    ko.contextFor = function(node) {
        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)
        switch (node.nodeType) {
            case 1:
            case 8:
                var context = ko.storedBindingContextForNode(node);
                if (context) return context;
                if (node.parentNode) return ko.contextFor(node.parentNode);
                break;
        }
        return undefined;
    };
    ko.dataFor = function(node) {
        var context = ko.contextFor(node);
        return context ? context['$data'] : undefined;
    };

    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);
    ko.exportSymbol('applyBindings', ko.applyBindings);
    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);
    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);
    ko.exportSymbol('contextFor', ko.contextFor);
    ko.exportSymbol('dataFor', ko.dataFor);
})();
// For certain common events (currently just 'click'), allow a simplified data-binding syntax
// e.g. click:handler instead of the usual full-length event:{click:handler}
var eventHandlersWithShortcuts = ['click'];
ko.utils.arrayForEach(eventHandlersWithShortcuts, function(eventName) {
    ko.bindingHandlers[eventName] = {
        'init': function(element, valueAccessor, allBindingsAccessor, viewModel) {
            var newValueAccessor = function () {
                var result = {};
                result[eventName] = valueAccessor();
                return result;
            };
            return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindingsAccessor, viewModel);
        }
    }
});


ko.bindingHandlers['event'] = {
    'init' : function (element, valueAccessor, allBindingsAccessor, viewModel) {
        var eventsToHandle = valueAccessor() || {};
        for(var eventNameOutsideClosure in eventsToHandle) {
            (function() {
                var eventName = eventNameOutsideClosure; // Separate variable to be captured by event handler closure
                if (typeof eventName == "string") {
                    ko.utils.registerEventHandler(element, eventName, function (event) {
                        var handlerReturnValue;
                        var handlerFunction = valueAccessor()[eventName];
                        if (!handlerFunction)
                            return;
                        var allBindings = allBindingsAccessor();

                        try {
                            // Take all the event args, and prefix with the viewmodel
                            var argsForHandler = ko.utils.makeArray(arguments);
                            argsForHandler.unshift(viewModel);
                            handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);
                        } finally {
                            if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                                if (event.preventDefault)
                                    event.preventDefault();
                                else
                                    event.returnValue = false;
                            }
                        }

                        var bubble = allBindings[eventName + 'Bubble'] !== false;
                        if (!bubble) {
                            event.cancelBubble = true;
                            if (event.stopPropagation)
                                event.stopPropagation();
                        }
                    });
                }
            })();
        }
    }
};

ko.bindingHandlers['submit'] = {
    'init': function (element, valueAccessor, allBindingsAccessor, viewModel) {
        if (typeof valueAccessor() != "function")
            throw new Error("The value for a submit binding must be a function");
        ko.utils.registerEventHandler(element, "submit", function (event) {
            var handlerReturnValue;
            var value = valueAccessor();
            try { handlerReturnValue = value.call(viewModel, element); }
            finally {
                if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                    if (event.preventDefault)
                        event.preventDefault();
                    else
                        event.returnValue = false;
                }
            }
        });
    }
};

ko.bindingHandlers['visible'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        var isCurrentlyVisible = !(element.style.display == "none");
        if (value && !isCurrentlyVisible)
            element.style.display = "";
        else if ((!value) && isCurrentlyVisible)
            element.style.display = "none";
    }
}

ko.bindingHandlers['enable'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        if (value && element.disabled)
            element.removeAttribute("disabled");
        else if ((!value) && (!element.disabled))
            element.disabled = true;
    }
};

ko.bindingHandlers['disable'] = {
    'update': function (element, valueAccessor) {
        ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });
    }
};

function ensureDropdownSelectionIsConsistentWithModelValue(element, modelValue, preferModelValue) {
    if (preferModelValue) {
        if (modelValue !== ko.selectExtensions.readValue(element))
            ko.selectExtensions.writeValue(element, modelValue);
    }

    // No matter which direction we're syncing in, we want the end result to be equality between dropdown value and model value.
    // If they aren't equal, either we prefer the dropdown value, or the model value couldn't be represented, so either way,
    // change the model value to match the dropdown.
    if (modelValue !== ko.selectExtensions.readValue(element))
        ko.utils.triggerEvent(element, "change");
};

ko.bindingHandlers['value'] = {
    'init': function (element, valueAccessor, allBindingsAccessor) {
        // Always catch "change" event; possibly other events too if asked
        var eventsToCatch = ["change"];
        var requestedEventsToCatch = allBindingsAccessor()["valueUpdate"];
        if (requestedEventsToCatch) {
            if (typeof requestedEventsToCatch == "string") // Allow both individual event names, and arrays of event names
                requestedEventsToCatch = [requestedEventsToCatch];
            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);
            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);
        }

        var valueUpdateHandler = function() {
            var modelValue = valueAccessor();
            var elementValue = ko.selectExtensions.readValue(element);
            ko.jsonExpressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'value', elementValue, /* checkIfDifferent: */ true);
        }

        // Workaround for https://github.com/SteveSanderson/knockout/issues/122
        // IE doesn't fire "change" events on textboxes if the user selects a value from its autocomplete list
        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == "input" && element.type == "text"
                                       && element.autocomplete != "off" && (!element.form || element.form.autocomplete != "off");
        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, "propertychange") == -1) {
            var propertyChangedFired = false;
            ko.utils.registerEventHandler(element, "propertychange", function () { propertyChangedFired = true });
            ko.utils.registerEventHandler(element, "blur", function() {
                if (propertyChangedFired) {
                    propertyChangedFired = false;
                    valueUpdateHandler();
                }
            });
        }

        ko.utils.arrayForEach(eventsToCatch, function(eventName) {
            // The syntax "after<eventname>" means "run the handler asynchronously after the event"
            // This is useful, for example, to catch "keydown" events after the browser has updated the control
            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)
            var handler = valueUpdateHandler;
            if (ko.utils.stringStartsWith(eventName, "after")) {
                handler = function() { setTimeout(valueUpdateHandler, 0) };
                eventName = eventName.substring("after".length);
            }
            ko.utils.registerEventHandler(element, eventName, handler);
        });
    },
    'update': function (element, valueAccessor) {
        var valueIsSelectOption = ko.utils.tagNameLower(element) === "select";
        var newValue = ko.utils.unwrapObservable(valueAccessor());
        var elementValue = ko.selectExtensions.readValue(element);
        var valueHasChanged = (newValue != elementValue);

        // JavaScript's 0 == "" behavious is unfortunate here as it prevents writing 0 to an empty text box (loose equality suggests the values are the same).
        // We don't want to do a strict equality comparison as that is more confusing for developers in certain cases, so we specifically special case 0 != "" here.
        if ((newValue === 0) && (elementValue !== 0) && (elementValue !== "0"))
            valueHasChanged = true;

        if (valueHasChanged) {
            var applyValueAction = function () { ko.selectExtensions.writeValue(element, newValue); };
            applyValueAction();

            // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread
            // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread
            // to apply the value as well.
            var alsoApplyAsynchronously = valueIsSelectOption;
            if (alsoApplyAsynchronously)
                setTimeout(applyValueAction, 0);
        }

        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,
        // because you're not allowed to have a model value that disagrees with a visible UI selection.
        if (valueIsSelectOption && (element.length > 0))
            ensureDropdownSelectionIsConsistentWithModelValue(element, newValue, /* preferModelValue */ false);
    }
};

ko.bindingHandlers['options'] = {
    'update': function (element, valueAccessor, allBindingsAccessor) {
        if (ko.utils.tagNameLower(element) !== "select")
            throw new Error("options binding applies only to SELECT elements");

        var selectWasPreviouslyEmpty = element.length == 0;
        var previousSelectedValues = ko.utils.arrayMap(ko.utils.arrayFilter(element.childNodes, function (node) {
            return node.tagName && (ko.utils.tagNameLower(node) === "option") && node.selected;
        }), function (node) {
            return ko.selectExtensions.readValue(node) || node.innerText || node.textContent;
        });
        var previousScrollTop = element.scrollTop;

        var value = ko.utils.unwrapObservable(valueAccessor());
        var selectedValue = element.value;

        // Remove all existing <option>s.
        // Need to use .remove() rather than .removeChild() for <option>s otherwise IE behaves oddly (https://github.com/SteveSanderson/knockout/issues/134)
        while (element.length > 0) {
            ko.cleanNode(element.options[0]);
            element.remove(0);
        }

        if (value) {
            var allBindings = allBindingsAccessor();
            if (typeof value.length != "number")
                value = [value];
            if (allBindings['optionsCaption']) {
                var option = document.createElement("option");
                ko.utils.setHtml(option, allBindings['optionsCaption']);
                ko.selectExtensions.writeValue(option, undefined);
                element.appendChild(option);
            }
            for (var i = 0, j = value.length; i < j; i++) {
                var option = document.createElement("option");

                // Apply a value to the option element
                var optionValue = typeof allBindings['optionsValue'] == "string" ? value[i][allBindings['optionsValue']] : value[i];
                optionValue = ko.utils.unwrapObservable(optionValue);
                ko.selectExtensions.writeValue(option, optionValue);

                // Apply some text to the option element
                var optionsTextValue = allBindings['optionsText'];
                var optionText;
                if (typeof optionsTextValue == "function")
                    optionText = optionsTextValue(value[i]); // Given a function; run it against the data value
                else if (typeof optionsTextValue == "string")
                    optionText = value[i][optionsTextValue]; // Given a string; treat it as a property name on the data value
                else
                    optionText = optionValue;				 // Given no optionsText arg; use the data value itself
                if ((optionText === null) || (optionText === undefined))
                    optionText = "";

                ko.utils.setTextContent(option, optionText);

                element.appendChild(option);
            }

            // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.
            // That's why we first added them without selection. Now it's time to set the selection.
            var newOptions = element.getElementsByTagName("option");
            var countSelectionsRetained = 0;
            for (var i = 0, j = newOptions.length; i < j; i++) {
                if (ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[i])) >= 0) {
                    ko.utils.setOptionNodeSelectionState(newOptions[i], true);
                    countSelectionsRetained++;
                }
            }

            element.scrollTop = previousScrollTop;

            if (selectWasPreviouslyEmpty && ('value' in allBindings)) {
                // Ensure consistency between model value and selected option.
                // If the dropdown is being populated for the first time here (or was otherwise previously empty),
                // the dropdown selection state is meaningless, so we preserve the model value.
                ensureDropdownSelectionIsConsistentWithModelValue(element, ko.utils.unwrapObservable(allBindings['value']), /* preferModelValue */ true);
            }

            // Workaround for IE9 bug
            ko.utils.ensureSelectElementIsRenderedCorrectly(element);
        }
    }
};
ko.bindingHandlers['options'].optionValueDomDataKey = '__ko.optionValueDomData__';

ko.bindingHandlers['selectedOptions'] = {
    getSelectedValuesFromSelectNode: function (selectNode) {
        var result = [];
        var nodes = selectNode.childNodes;
        for (var i = 0, j = nodes.length; i < j; i++) {
            var node = nodes[i], tagName = ko.utils.tagNameLower(node);
            if (tagName == "option" && node.selected)
                result.push(ko.selectExtensions.readValue(node));
            else if (tagName == "optgroup") {
                var selectedValuesFromOptGroup = ko.bindingHandlers['selectedOptions'].getSelectedValuesFromSelectNode(node);
                Array.prototype.splice.apply(result, [result.length, 0].concat(selectedValuesFromOptGroup)); // Add new entries to existing 'result' instance
            }
        }
        return result;
    },
    'init': function (element, valueAccessor, allBindingsAccessor) {
        ko.utils.registerEventHandler(element, "change", function () {
            var value = valueAccessor();
            var valueToWrite = ko.bindingHandlers['selectedOptions'].getSelectedValuesFromSelectNode(this);
            ko.jsonExpressionRewriting.writeValueToProperty(value, allBindingsAccessor, 'value', valueToWrite);
        });
    },
    'update': function (element, valueAccessor) {
        if (ko.utils.tagNameLower(element) != "select")
            throw new Error("values binding applies only to SELECT elements");

        var newValue = ko.utils.unwrapObservable(valueAccessor());
        if (newValue && typeof newValue.length == "number") {
            var nodes = element.childNodes;
            for (var i = 0, j = nodes.length; i < j; i++) {
                var node = nodes[i];
                if (ko.utils.tagNameLower(node) === "option")
                    ko.utils.setOptionNodeSelectionState(node, ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0);
            }
        }
    }
};

ko.bindingHandlers['text'] = {
    'update': function (element, valueAccessor) {
        ko.utils.setTextContent(element, valueAccessor());
    }
};

ko.bindingHandlers['html'] = {
    'init': function() {
        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
        return { 'controlsDescendantBindings': true };
    },
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        ko.utils.setHtml(element, value);
    }
};

ko.bindingHandlers['css'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor() || {});
        for (var className in value) {
            if (typeof className == "string") {
                var shouldHaveClass = ko.utils.unwrapObservable(value[className]);
                ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);
            }
        }
    }
};

ko.bindingHandlers['style'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor() || {});
        for (var styleName in value) {
            if (typeof styleName == "string") {
                var styleValue = ko.utils.unwrapObservable(value[styleName]);
                element.style[styleName] = styleValue || ""; // Empty string removes the value, whereas null/undefined have no effect
            }
        }
    }
};

ko.bindingHandlers['uniqueName'] = {
    'init': function (element, valueAccessor) {
        if (valueAccessor()) {
            element.name = "ko_unique_" + (++ko.bindingHandlers['uniqueName'].currentIndex);

            // Workaround IE 6/7 issue
            // - https://github.com/SteveSanderson/knockout/issues/197
            // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/
            if (ko.utils.isIe6 || ko.utils.isIe7)
                element.mergeAttributes(document.createElement("<input name='" + element.name + "'/>"), false);
        }
    }
};
ko.bindingHandlers['uniqueName'].currentIndex = 0;

ko.bindingHandlers['checked'] = {
    'init': function (element, valueAccessor, allBindingsAccessor) {
        var updateHandler = function() {
            var valueToWrite;
            if (element.type == "checkbox") {
                valueToWrite = element.checked;
            } else if ((element.type == "radio") && (element.checked)) {
                valueToWrite = element.value;
            } else {
                return; // "checked" binding only responds to checkboxes and selected radio buttons
            }

            var modelValue = valueAccessor();
            if ((element.type == "checkbox") && (ko.utils.unwrapObservable(modelValue) instanceof Array)) {
                // For checkboxes bound to an array, we add/remove the checkbox value to that array
                // This works for both observable and non-observable arrays
                var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.unwrapObservable(modelValue), element.value);
                if (element.checked && (existingEntryIndex < 0))
                    modelValue.push(element.value);
                else if ((!element.checked) && (existingEntryIndex >= 0))
                    modelValue.splice(existingEntryIndex, 1);
            } else {
                ko.jsonExpressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'checked', valueToWrite, true);
            }
        };
        ko.utils.registerEventHandler(element, "click", updateHandler);

        // IE 6 won't allow radio buttons to be selected unless they have a name
        if ((element.type == "radio") && !element.name)
            ko.bindingHandlers['uniqueName']['init'](element, function() { return true });
    },
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());

        if (element.type == "checkbox") {
            if (value instanceof Array) {
                // When bound to an array, the checkbox being checked represents its value being present in that array
                element.checked = ko.utils.arrayIndexOf(value, element.value) >= 0;
            } else {
                // When bound to anything other value (not an array), the checkbox being checked represents the value being trueish
                element.checked = value;
            }
        } else if (element.type == "radio") {
            element.checked = (element.value == value);
        }
    }
};

var attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };
ko.bindingHandlers['attr'] = {
    'update': function(element, valueAccessor, allBindingsAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor()) || {};
        for (var attrName in value) {
            if (typeof attrName == "string") {
                var attrValue = ko.utils.unwrapObservable(value[attrName]);

                // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
                // when someProp is a "no value"-like value (strictly null, false, or undefined)
                // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
                var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
                if (toRemove)
                    element.removeAttribute(attrName);

                // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the
                // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,
                // but instead of figuring out the mode, we'll just set the attribute through the Javascript
                // property for IE <= 8.
                if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {
                    attrName = attrHtmlToJavascriptMap[attrName];
                    if (toRemove)
                        element.removeAttribute(attrName);
                    else
                        element[attrName] = attrValue;
                } else if (!toRemove) {
                    element.setAttribute(attrName, attrValue.toString());
                }
            }
        }
    }
};

ko.bindingHandlers['hasfocus'] = {
    'init': function(element, valueAccessor, allBindingsAccessor) {
        var writeValue = function(valueToWrite) {
            var modelValue = valueAccessor();
            ko.jsonExpressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'hasfocus', valueToWrite, true);
        };
        ko.utils.registerEventHandler(element, "focus", function() { writeValue(true) });
        ko.utils.registerEventHandler(element, "focusin", function() { writeValue(true) }); // For IE
        ko.utils.registerEventHandler(element, "blur",  function() { writeValue(false) });
        ko.utils.registerEventHandler(element, "focusout",  function() { writeValue(false) }); // For IE
    },
    'update': function(element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        value ? element.focus() : element.blur();
        ko.utils.triggerEvent(element, value ? "focusin" : "focusout"); // For IE, which doesn't reliably fire "focus" or "blur" events synchronously
    }
};

// "with: someExpression" is equivalent to "template: { if: someExpression, data: someExpression }"
ko.bindingHandlers['with'] = {
    makeTemplateValueAccessor: function(valueAccessor) {
        return function() { var value = valueAccessor(); return { 'if': value, 'data': value, 'templateEngine': ko.nativeTemplateEngine.instance } };
    },
    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['with'].makeTemplateValueAccessor(valueAccessor));
    },
    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['with'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);
    }
};
ko.jsonExpressionRewriting.bindingRewriteValidators['with'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['with'] = true;

// "if: someExpression" is equivalent to "template: { if: someExpression }"
ko.bindingHandlers['if'] = {
    makeTemplateValueAccessor: function(valueAccessor) {
        return function() { return { 'if': valueAccessor(), 'templateEngine': ko.nativeTemplateEngine.instance } };
    },
    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['if'].makeTemplateValueAccessor(valueAccessor));
    },
    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['if'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);
    }
};
ko.jsonExpressionRewriting.bindingRewriteValidators['if'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['if'] = true;

// "ifnot: someExpression" is equivalent to "template: { ifnot: someExpression }"
ko.bindingHandlers['ifnot'] = {
    makeTemplateValueAccessor: function(valueAccessor) {
        return function() { return { 'ifnot': valueAccessor(), 'templateEngine': ko.nativeTemplateEngine.instance } };
    },
    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['ifnot'].makeTemplateValueAccessor(valueAccessor));
    },
    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['ifnot'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);
    }
};
ko.jsonExpressionRewriting.bindingRewriteValidators['ifnot'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['ifnot'] = true;

// "foreach: someExpression" is equivalent to "template: { foreach: someExpression }"
// "foreach: { data: someExpression, afterAdd: myfn }" is equivalent to "template: { foreach: someExpression, afterAdd: myfn }"
ko.bindingHandlers['foreach'] = {
    makeTemplateValueAccessor: function(valueAccessor) {
        return function() {
            var bindingValue = ko.utils.unwrapObservable(valueAccessor());

            // If bindingValue is the array, just pass it on its own
            if ((!bindingValue) || typeof bindingValue.length == "number")
                return { 'foreach': bindingValue, 'templateEngine': ko.nativeTemplateEngine.instance };

            // If bindingValue.data is the array, preserve all relevant options
            return {
                'foreach': bindingValue['data'],
                'includeDestroyed': bindingValue['includeDestroyed'],
                'afterAdd': bindingValue['afterAdd'],
                'beforeRemove': bindingValue['beforeRemove'],
                'afterRender': bindingValue['afterRender'],
                'templateEngine': ko.nativeTemplateEngine.instance
            };
        };
    },
    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));
    },
    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);
    }
};
ko.jsonExpressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['foreach'] = true;
// If you want to make a custom template engine,
//
// [1] Inherit from this class (like ko.nativeTemplateEngine does)
// [2] Override 'renderTemplateSource', supplying a function with this signature:
//
//        function (templateSource, bindingContext, options) {
//            // - templateSource.text() is the text of the template you should render
//            // - bindingContext.$data is the data you should pass into the template
//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,
//            //     and bindingContext.$root available in the template too
//            // - options gives you access to any other properties set on "data-bind: { template: options }"
//            //
//            // Return value: an array of DOM nodes
//        }
//
// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:
//
//        function (script) {
//            // Return value: Whatever syntax means "Evaluate the JavaScript statement 'script' and output the result"
//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'
//        }
//
//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.
//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)
//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.

ko.templateEngine = function () { };

ko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) {
    throw new Error("Override renderTemplateSource");
};

ko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {
    throw new Error("Override createJavaScriptEvaluatorBlock");
};

ko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {
    // Named template
    if (typeof template == "string") {
        templateDocument = templateDocument || document;
        var elem = templateDocument.getElementById(template);
        if (!elem)
            throw new Error("Cannot find template with ID " + template);
        return new ko.templateSources.domElement(elem);
    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {
        // Anonymous template
        return new ko.templateSources.anonymousTemplate(template);
    } else
        throw new Error("Unknown template type: " + template);
};

ko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    return this['renderTemplateSource'](templateSource, bindingContext, options);
};

ko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {
    // Skip rewriting if requested
    if (this['allowTemplateRewriting'] === false)
        return true;

    // Perf optimisation - see below
    var templateIsInExternalDocument = templateDocument && templateDocument != document;
    if (!templateIsInExternalDocument && this.knownRewrittenTemplates && this.knownRewrittenTemplates[template])
        return true;

    return this['makeTemplateSource'](template, templateDocument)['data']("isRewritten");
};

ko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    var rewritten = rewriterCallback(templateSource['text']());
    templateSource['text'](rewritten);
    templateSource['data']("isRewritten", true);

    // Perf optimisation - for named templates, track which ones have been rewritten so we can
    // answer 'isTemplateRewritten' *without* having to use getElementById (which is slow on IE < 8)
    //
    // Note that we only cache the status for templates in the main document, because caching on a per-doc
    // basis complicates the implementation excessively. In a future version of KO, we will likely remove
    // this 'isRewritten' cache entirely anyway, because the benefit is extremely minor and only applies
    // to rewritable templates, which are pretty much deprecated since KO 2.0.
    var templateIsInExternalDocument = templateDocument && templateDocument != document;
    if (!templateIsInExternalDocument && typeof template == "string") {
        this.knownRewrittenTemplates = this.knownRewrittenTemplates || {};
        this.knownRewrittenTemplates[template] = true;
    }
};

ko.exportSymbol('templateEngine', ko.templateEngine);

ko.templateRewriting = (function () {
    var memoizeDataBindingAttributeSyntaxRegex = /(<[a-z]+\d*(\s+(?!data-bind=)[a-z0-9\-]+(=(\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind=(["'])([\s\S]*?)\5/gi;
    var memoizeVirtualContainerBindingSyntaxRegex = /<!--\s*ko\b\s*([\s\S]*?)\s*-->/g;

    function validateDataBindValuesForRewriting(keyValueArray) {
        var allValidators = ko.jsonExpressionRewriting.bindingRewriteValidators;
        for (var i = 0; i < keyValueArray.length; i++) {
            var key = keyValueArray[i]['key'];
            if (allValidators.hasOwnProperty(key)) {
                var validator = allValidators[key];

                if (typeof validator === "function") {
                    var possibleErrorMessage = validator(keyValueArray[i]['value']);
                    if (possibleErrorMessage)
                        throw new Error(possibleErrorMessage);
                } else if (!validator) {
                    throw new Error("This template engine does not support the '" + key + "' binding within its templates");
                }
            }
        }
    }

    function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, templateEngine) {
        var dataBindKeyValueArray = ko.jsonExpressionRewriting.parseObjectLiteral(dataBindAttributeValue);
        validateDataBindValuesForRewriting(dataBindKeyValueArray);
        var rewrittenDataBindAttributeValue = ko.jsonExpressionRewriting.insertPropertyAccessorsIntoJson(dataBindKeyValueArray);

        // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional
        // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this
        // extra indirection.
        var applyBindingsToNextSiblingScript = "ko.templateRewriting.applyMemoizedBindingsToNextSibling(function() { \
            return (function() { return { " + rewrittenDataBindAttributeValue + " } })() \
        })";
        return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;
    }

    return {
        ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {
            if (!templateEngine['isTemplateRewritten'](template, templateDocument))
                templateEngine['rewriteTemplate'](template, function (htmlString) {
                    return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);
                }, templateDocument);
        },

        memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {
            return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {
                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[6], /* tagToRetain: */ arguments[1], templateEngine);
            }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {
                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ "<!-- ko -->", templateEngine);
            });
        },

        applyMemoizedBindingsToNextSibling: function (bindings) {
            return ko.memoization.memoize(function (domNode, bindingContext) {
                if (domNode.nextSibling)
                    ko.applyBindingsToNode(domNode.nextSibling, bindings, bindingContext);
            });
        }
    }
})();

ko.exportSymbol('templateRewriting', ko.templateRewriting);
ko.exportSymbol('templateRewriting.applyMemoizedBindingsToNextSibling', ko.templateRewriting.applyMemoizedBindingsToNextSibling); // Exported only because it has to be referenced by string lookup from within rewritten template
(function() {
    // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving
    // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)
    //
    // Two are provided by default:
    //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element
    //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but
    //                                           without reading/writing the actual element text content, since it will be overwritten
    //                                           with the rendered template output.
    // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.
    // Template sources need to have the following functions:
    //   text() 			- returns the template text from your storage location
    //   text(value)		- writes the supplied template text to your storage location
    //   data(key)			- reads values stored using data(key, value) - see below
    //   data(key, value)	- associates "value" with this template and the key "key". Is used to store information like "isRewritten".
    //
    // Optionally, template sources can also have the following functions:
    //   nodes()            - returns a DOM element containing the nodes of this template, where available
    //   nodes(value)       - writes the given DOM element to your storage location
    // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()
    // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().
    //
    // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were
    // using and overriding "makeTemplateSource" to return an instance of your custom template source.

    ko.templateSources = {};

    // ---- ko.templateSources.domElement -----

    ko.templateSources.domElement = function(element) {
        this.domElement = element;
    }

    ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {
        var tagNameLower = ko.utils.tagNameLower(this.domElement),
            elemContentsProperty = tagNameLower === "script" ? "text"
                                 : tagNameLower === "textarea" ? "value"
                                 : "innerHTML";

        if (arguments.length == 0) {
            return this.domElement[elemContentsProperty];
        } else {
            var valueToWrite = arguments[0];
            if (elemContentsProperty === "innerHTML")
                ko.utils.setHtml(this.domElement, valueToWrite);
            else
                this.domElement[elemContentsProperty] = valueToWrite;
        }
    };

    ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {
        if (arguments.length === 1) {
            return ko.utils.domData.get(this.domElement, "templateSourceData_" + key);
        } else {
            ko.utils.domData.set(this.domElement, "templateSourceData_" + key, arguments[1]);
        }
    };

    // ---- ko.templateSources.anonymousTemplate -----
    // Anonymous templates are normally saved/retrieved as DOM nodes through "nodes".
    // For compatibility, you can also read "text"; it will be serialized from the nodes on demand.
    // Writing to "text" is still supported, but then the template data will not be available as DOM nodes.

    var anonymousTemplatesDomDataKey = "__ko_anon_template__";
    ko.templateSources.anonymousTemplate = function(element) {
        this.domElement = element;
    }
    ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();
    ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {
        if (arguments.length == 0) {
            var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {};
            if (templateData.textData === undefined && templateData.containerData)
                templateData.textData = templateData.containerData.innerHTML;
            return templateData.textData;
        } else {
            var valueToWrite = arguments[0];
            ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, {textData: valueToWrite});
        }
    };
    ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {
        if (arguments.length == 0) {
            var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {};
            return templateData.containerData;
        } else {
            var valueToWrite = arguments[0];
            ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, {containerData: valueToWrite});
        }
    };

    ko.exportSymbol('templateSources', ko.templateSources);
    ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);
    ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);
})();
(function () {
    var _templateEngine;
    ko.setTemplateEngine = function (templateEngine) {
        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))
            throw new Error("templateEngine must inherit from ko.templateEngine");
        _templateEngine = templateEngine;
    }

    function invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, action) {
        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);
        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {
            nextInQueue = ko.virtualElements.nextSibling(node);
            if (node.nodeType === 1 || node.nodeType === 8)
                action(node);
        }
    }

    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {
        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element
        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because
        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,
        // (1) Does a regular "applyBindings" to associate bindingContext with this node and to activate any non-memoized bindings
        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)

        if (continuousNodeArray.length) {
            var firstNode = continuousNodeArray[0], lastNode = continuousNodeArray[continuousNodeArray.length - 1];

            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)
            // whereas a regular applyBindings won't introduce new memoized nodes
            invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, function(node) {
                ko.applyBindings(bindingContext, node);
            });
            invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, function(node) {
                ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);
            });
        }
    }

    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {
        return nodeOrNodeArray.nodeType ? nodeOrNodeArray
                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]
                                        : null;
    }

    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {
        options = options || {};
        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
        var templateDocument = firstTargetNode && firstTargetNode.ownerDocument;
        var templateEngineToUse = (options['templateEngine'] || _templateEngine);
        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);
        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);

        // Loosely check result is an array of DOM nodes
        if ((typeof renderedNodesArray.length != "number") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != "number"))
            throw new Error("Template engine must return an array of DOM nodes");

        var haveAddedNodesToParent = false;
        switch (renderMode) {
            case "replaceChildren":
                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = true;
                break;
            case "replaceNode":
                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = true;
                break;
            case "ignoreTargetNode": break;
            default:
                throw new Error("Unknown renderMode: " + renderMode);
        }

        if (haveAddedNodesToParent) {
            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);
            if (options['afterRender'])
                options['afterRender'](renderedNodesArray, bindingContext['$data']);
        }

        return renderedNodesArray;
    }

    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {
        options = options || {};
        if ((options['templateEngine'] || _templateEngine) == undefined)
            throw new Error("Set a template engine before calling renderTemplate");
        renderMode = renderMode || "replaceChildren";

        if (targetNodeOrNodeArray) {
            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);

            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)
            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == "replaceNode") ? firstTargetNode.parentNode : firstTargetNode;

            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes
                function () {
                    // Ensure we've got a proper binding context to work with
                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))
                        ? dataOrBindingContext
                        : new ko.bindingContext(ko.utils.unwrapObservable(dataOrBindingContext));

                    // Support selecting template as a function of the data being rendered
                    var templateName = typeof(template) == 'function' ? template(bindingContext['$data']) : template;

                    var renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);
                    if (renderMode == "replaceNode") {
                        targetNodeOrNodeArray = renderedNodesArray;
                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
                    }
                },
                null,
                { 'disposeWhen': whenToDispose, 'disposeWhenNodeIsRemoved': activelyDisposeWhenNodeIsRemoved }
            );
        } else {
            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node
            return ko.memoization.memoize(function (domNode) {
                ko.renderTemplate(template, dataOrBindingContext, options, domNode, "replaceNode");
            });
        }
    };

    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {
        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.
        var arrayItemContext;

        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode
        var executeTemplateForArrayItem = function (arrayValue, index) {
            // Support selecting template as a function of the data being rendered
            var templateName = typeof(template) == 'function' ? template(arrayValue) : template;
            arrayItemContext = parentBindingContext['createChildContext'](ko.utils.unwrapObservable(arrayValue));
            arrayItemContext['$index'] = index;
            return executeTemplate(null, "ignoreTargetNode", templateName, arrayItemContext, options);
        }

        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode
        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {
            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);
            if (options['afterRender'])
                options['afterRender'](addedNodesArray, arrayValue);
        };

        return ko.dependentObservable(function () {
            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];
            if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
                unwrappedArray = [unwrappedArray];

            // Filter out any entries marked as destroyed
            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
            });

            ko.utils.setDomNodeChildrenFromArrayMapping(targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback);

        }, null, { 'disposeWhenNodeIsRemoved': targetNode });
    };

    var templateSubscriptionDomDataKey = '__ko__templateSubscriptionDomDataKey__';
    function disposeOldSubscriptionAndStoreNewOne(element, newSubscription) {
        var oldSubscription = ko.utils.domData.get(element, templateSubscriptionDomDataKey);
        if (oldSubscription && (typeof(oldSubscription.dispose) == 'function'))
            oldSubscription.dispose();
        ko.utils.domData.set(element, templateSubscriptionDomDataKey, newSubscription);
    }

    ko.bindingHandlers['template'] = {
        'init': function(element, valueAccessor) {
            // Support anonymous templates
            var bindingValue = ko.utils.unwrapObservable(valueAccessor());
            if ((typeof bindingValue != "string") && (!bindingValue['name']) && (element.nodeType == 1 || element.nodeType == 8)) {
                // It's an anonymous template - store the element contents, then clear the element
                var templateNodes = element.nodeType == 1 ? element.childNodes : ko.virtualElements.childNodes(element),
                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent
                new ko.templateSources.anonymousTemplate(element)['nodes'](container);
            }
            return { 'controlsDescendantBindings': true };
        },
        'update': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            var bindingValue = ko.utils.unwrapObservable(valueAccessor());
            var templateName;
            var shouldDisplay = true;

            if (typeof bindingValue == "string") {
                templateName = bindingValue;
            } else {
                templateName = bindingValue['name'];

                // Support "if"/"ifnot" conditions
                if ('if' in bindingValue)
                    shouldDisplay = shouldDisplay && ko.utils.unwrapObservable(bindingValue['if']);
                if ('ifnot' in bindingValue)
                    shouldDisplay = shouldDisplay && !ko.utils.unwrapObservable(bindingValue['ifnot']);
            }

            var templateSubscription = null;

            if ((typeof bindingValue === 'object') && ('foreach' in bindingValue)) { // Note: can't use 'in' operator on strings
                // Render once for each data point (treating data set as empty if shouldDisplay==false)
                var dataArray = (shouldDisplay && bindingValue['foreach']) || [];
                templateSubscription = ko.renderTemplateForEach(templateName || element, dataArray, /* options: */ bindingValue, element, bindingContext);
            } else {
                if (shouldDisplay) {
                    // Render once for this single data point (or use the viewModel if no data was provided)
                    var innerBindingContext = (typeof bindingValue == 'object') && ('data' in bindingValue)
                        ? bindingContext['createChildContext'](ko.utils.unwrapObservable(bindingValue['data'])) // Given an explitit 'data' value, we create a child binding context for it
                        : bindingContext;                                                                       // Given no explicit 'data' value, we retain the same binding context
                    templateSubscription = ko.renderTemplate(templateName || element, innerBindingContext, /* options: */ bindingValue, element);
                } else
                    ko.virtualElements.emptyNode(element);
            }

            // It only makes sense to have a single template subscription per element (otherwise which one should have its output displayed?)
            disposeOldSubscriptionAndStoreNewOne(element, templateSubscription);
        }
    };

    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.
    ko.jsonExpressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {
        var parsedBindingValue = ko.jsonExpressionRewriting.parseObjectLiteral(bindingValue);

        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])
            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)

        if (ko.jsonExpressionRewriting.keyValueArrayContainsKey(parsedBindingValue, "name"))
            return null; // Named templates can be rewritten, so return "no error"
        return "This template engine does not support anonymous templates nested within its templates";
    };

    ko.virtualElements.allowedBindings['template'] = true;
})();

ko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);
ko.exportSymbol('renderTemplate', ko.renderTemplate);

(function () {
    // Simple calculation based on Levenshtein distance.
    function calculateEditDistanceMatrix(oldArray, newArray, maxAllowedDistance) {
        var distances = [];
        for (var i = 0; i <= newArray.length; i++)
            distances[i] = [];

        // Top row - transform old array into empty array via deletions
        for (var i = 0, j = Math.min(oldArray.length, maxAllowedDistance); i <= j; i++)
            distances[0][i] = i;

        // Left row - transform empty array into new array via additions
        for (var i = 1, j = Math.min(newArray.length, maxAllowedDistance); i <= j; i++) {
            distances[i][0] = i;
        }

        // Fill out the body of the array
        var oldIndex, oldIndexMax = oldArray.length, newIndex, newIndexMax = newArray.length;
        var distanceViaAddition, distanceViaDeletion;
        for (oldIndex = 1; oldIndex <= oldIndexMax; oldIndex++) {
            var newIndexMinForRow = Math.max(1, oldIndex - maxAllowedDistance);
            var newIndexMaxForRow = Math.min(newIndexMax, oldIndex + maxAllowedDistance);
            for (newIndex = newIndexMinForRow; newIndex <= newIndexMaxForRow; newIndex++) {
                if (oldArray[oldIndex - 1] === newArray[newIndex - 1])
                    distances[newIndex][oldIndex] = distances[newIndex - 1][oldIndex - 1];
                else {
                    var northDistance = distances[newIndex - 1][oldIndex] === undefined ? Number.MAX_VALUE : distances[newIndex - 1][oldIndex] + 1;
                    var westDistance = distances[newIndex][oldIndex - 1] === undefined ? Number.MAX_VALUE : distances[newIndex][oldIndex - 1] + 1;
                    distances[newIndex][oldIndex] = Math.min(northDistance, westDistance);
                }
            }
        }

        return distances;
    }

    function findEditScriptFromEditDistanceMatrix(editDistanceMatrix, oldArray, newArray) {
        var oldIndex = oldArray.length;
        var newIndex = newArray.length;
        var editScript = [];
        var maxDistance = editDistanceMatrix[newIndex][oldIndex];
        if (maxDistance === undefined)
            return null; // maxAllowedDistance must be too small
        while ((oldIndex > 0) || (newIndex > 0)) {
            var me = editDistanceMatrix[newIndex][oldIndex];
            var distanceViaAdd = (newIndex > 0) ? editDistanceMatrix[newIndex - 1][oldIndex] : maxDistance + 1;
            var distanceViaDelete = (oldIndex > 0) ? editDistanceMatrix[newIndex][oldIndex - 1] : maxDistance + 1;
            var distanceViaRetain = (newIndex > 0) && (oldIndex > 0) ? editDistanceMatrix[newIndex - 1][oldIndex - 1] : maxDistance + 1;
            if ((distanceViaAdd === undefined) || (distanceViaAdd < me - 1)) distanceViaAdd = maxDistance + 1;
            if ((distanceViaDelete === undefined) || (distanceViaDelete < me - 1)) distanceViaDelete = maxDistance + 1;
            if (distanceViaRetain < me - 1) distanceViaRetain = maxDistance + 1;

            if ((distanceViaAdd <= distanceViaDelete) && (distanceViaAdd < distanceViaRetain)) {
                editScript.push({ status: "added", value: newArray[newIndex - 1] });
                newIndex--;
            } else if ((distanceViaDelete < distanceViaAdd) && (distanceViaDelete < distanceViaRetain)) {
                editScript.push({ status: "deleted", value: oldArray[oldIndex - 1] });
                oldIndex--;
            } else {
                editScript.push({ status: "retained", value: oldArray[oldIndex - 1] });
                newIndex--;
                oldIndex--;
            }
        }
        return editScript.reverse();
    }

    ko.utils.compareArrays = function (oldArray, newArray, maxEditsToConsider) {
        if (maxEditsToConsider === undefined) {
            return ko.utils.compareArrays(oldArray, newArray, 1)                 // First consider likely case where there is at most one edit (very fast)
                || ko.utils.compareArrays(oldArray, newArray, 10)                // If that fails, account for a fair number of changes while still being fast
                || ko.utils.compareArrays(oldArray, newArray, Number.MAX_VALUE); // Ultimately give the right answer, even though it may take a long time
        } else {
            oldArray = oldArray || [];
            newArray = newArray || [];
            var editDistanceMatrix = calculateEditDistanceMatrix(oldArray, newArray, maxEditsToConsider);
            return findEditScriptFromEditDistanceMatrix(editDistanceMatrix, oldArray, newArray);
        }
    };
})();

ko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);

(function () {
    // Objective:
    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,
    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node
    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node
    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we
    //   previously mapped - retain those nodes, and just insert/delete other ones

    // "callbackAfterAddingNodes" will be invoked after any "mapping"-generated nodes are inserted into the container node
    // You can use this, for example, to activate bindings on those nodes.

    function fixUpVirtualElements(contiguousNodeArray) {
        // Ensures that contiguousNodeArray really *is* an array of contiguous siblings, even if some of the interior
        // ones have changed since your array was first built (e.g., because your array contains virtual elements, and
        // their virtual children changed when binding was applied to them).
        // This is needed so that we can reliably remove or update the nodes corresponding to a given array item

        if (contiguousNodeArray.length > 2) {
            // Build up the actual new contiguous node set
            var current = contiguousNodeArray[0], last = contiguousNodeArray[contiguousNodeArray.length - 1], newContiguousSet = [current];
            while (current !== last) {
                current = current.nextSibling;
                if (!current) // Won't happen, except if the developer has manually removed some DOM elements (then we're in an undefined scenario)
                    return;
                newContiguousSet.push(current);
            }

            // ... then mutate the input array to match this.
            // (The following line replaces the contents of contiguousNodeArray with newContiguousSet)
            Array.prototype.splice.apply(contiguousNodeArray, [0, contiguousNodeArray.length].concat(newContiguousSet));
        }
    }

    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {
        // Map this array value inside a dependentObservable so we re-map when any dependency changes
        var mappedNodes = [];
        var dependentObservable = ko.dependentObservable(function() {
            var newMappedNodes = mapping(valueToMap, index) || [];

            // On subsequent evaluations, just replace the previously-inserted DOM nodes
            if (mappedNodes.length > 0) {
                fixUpVirtualElements(mappedNodes);
                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);
                if (callbackAfterAddingNodes)
                    callbackAfterAddingNodes(valueToMap, newMappedNodes);
            }

            // Replace the contents of the mappedNodes array, thereby updating the record
            // of which nodes would be deleted if valueToMap was itself later removed
            mappedNodes.splice(0, mappedNodes.length);
            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);
        }, null, { 'disposeWhenNodeIsRemoved': containerNode, 'disposeWhen': function() { return (mappedNodes.length == 0) || !ko.utils.domNodeIsAttachedToDocument(mappedNodes[0]) } });
        return { mappedNodes : mappedNodes, dependentObservable : dependentObservable };
    }

    var lastMappingResultDomDataKey = "setDomNodeChildrenFromArrayMapping_lastMappingResult";

    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {
        // Compare the provided array against the previous one
        array = array || [];
        options = options || {};
        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;
        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];
        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });
        var editScript = ko.utils.compareArrays(lastArray, array);

        // Build the new mapping result
        var newMappingResult = [];
        var lastMappingResultIndex = 0;
        var nodesToDelete = [];
        var newMappingResultIndex = 0;
        var nodesAdded = [];
        var insertAfterNode = null;
        for (var i = 0, j = editScript.length; i < j; i++) {
            switch (editScript[i].status) {
                case "retained":
                    // Just keep the information - don't touch the nodes
                    var dataToRetain = lastMappingResult[lastMappingResultIndex];
                    dataToRetain.indexObservable(newMappingResultIndex);
                    newMappingResultIndex = newMappingResult.push(dataToRetain);
                    if (dataToRetain.domNodes.length > 0)
                        insertAfterNode = dataToRetain.domNodes[dataToRetain.domNodes.length - 1];
                    lastMappingResultIndex++;
                    break;

                case "deleted":
                    // Stop tracking changes to the mapping for these nodes
                    lastMappingResult[lastMappingResultIndex].dependentObservable.dispose();

                    // Queue these nodes for later removal
                    fixUpVirtualElements(lastMappingResult[lastMappingResultIndex].domNodes);
                    ko.utils.arrayForEach(lastMappingResult[lastMappingResultIndex].domNodes, function (node) {
                        nodesToDelete.push({
                          element: node,
                          index: i,
                          value: editScript[i].value
                        });
                        insertAfterNode = node;
                    });
                    lastMappingResultIndex++;
                    break;

                case "added":
                    var valueToMap = editScript[i].value;
                    var indexObservable = ko.observable(newMappingResultIndex);
                    var mapData = mapNodeAndRefreshWhenChanged(domNode, mapping, valueToMap, callbackAfterAddingNodes, indexObservable);
                    var mappedNodes = mapData.mappedNodes;

                    // On the first evaluation, insert the nodes at the current insertion point
                    newMappingResultIndex = newMappingResult.push({
                        arrayEntry: editScript[i].value,
                        domNodes: mappedNodes,
                        dependentObservable: mapData.dependentObservable,
                        indexObservable: indexObservable
                    });
                    for (var nodeIndex = 0, nodeIndexMax = mappedNodes.length; nodeIndex < nodeIndexMax; nodeIndex++) {
                        var node = mappedNodes[nodeIndex];
                        nodesAdded.push({
                          element: node,
                          index: i,
                          value: editScript[i].value
                        });
                        if (insertAfterNode == null) {
                            // Insert "node" (the newly-created node) as domNode's first child
                            ko.virtualElements.prepend(domNode, node);
                        } else {
                            // Insert "node" into "domNode" immediately after "insertAfterNode"
                            ko.virtualElements.insertAfter(domNode, node, insertAfterNode);
                        }
                        insertAfterNode = node;
                    }
                    if (callbackAfterAddingNodes)
                        callbackAfterAddingNodes(valueToMap, mappedNodes, indexObservable);
                    break;
            }
        }

        ko.utils.arrayForEach(nodesToDelete, function (node) { ko.cleanNode(node.element) });

        var invokedBeforeRemoveCallback = false;
        if (!isFirstExecution) {
            if (options['afterAdd']) {
                for (var i = 0; i < nodesAdded.length; i++)
                    options['afterAdd'](nodesAdded[i].element, nodesAdded[i].index, nodesAdded[i].value);
            }
            if (options['beforeRemove']) {
                for (var i = 0; i < nodesToDelete.length; i++)
                    options['beforeRemove'](nodesToDelete[i].element, nodesToDelete[i].index, nodesToDelete[i].value);
                invokedBeforeRemoveCallback = true;
            }
        }
        if (!invokedBeforeRemoveCallback && nodesToDelete.length) {
            for (var i = 0; i < nodesToDelete.length; i++) {
                var element = nodesToDelete[i].element;
                if (element.parentNode)
                    element.parentNode.removeChild(element);
            }
        }

        // Store a copy of the array items we just considered so we can difference it next time
        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);
    }
})();

ko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);
ko.nativeTemplateEngine = function () {
    this['allowTemplateRewriting'] = false;
}

ko.nativeTemplateEngine.prototype = new ko.templateEngine();
ko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) {
    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly
        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,
        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;

    if (templateNodes) {
        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);
    } else {
        var templateText = templateSource['text']();
        return ko.utils.parseHtmlFragment(templateText);
    }
};

ko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();
ko.setTemplateEngine(ko.nativeTemplateEngine.instance);

ko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);
(function() {
    ko.jqueryTmplTemplateEngine = function () {
        // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl
        // doesn't expose a version number, so we have to infer it.
        // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,
        // which KO internally refers to as version "2", so older versions are no longer detected.
        var jQueryTmplVersion = this.jQueryTmplVersion = (function() {
            if ((typeof(jQuery) == "undefined") || !(jQuery['tmpl']))
                return 0;
            // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.
            try {
                if (jQuery['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {
                    // Since 1.0.0pre, custom tags should append markup to an array called "__"
                    return 2; // Final version of jquery.tmpl
                }
            } catch(ex) { /* Apparently not the version we were looking for */ }

            return 1; // Any older version that we don't support
        })();

        function ensureHasReferencedJQueryTemplates() {
            if (jQueryTmplVersion < 2)
                throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
        }

        function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {
            return jQuery['tmpl'](compiledTemplate, data, jQueryTemplateOptions);
        }

        this['renderTemplateSource'] = function(templateSource, bindingContext, options) {
            options = options || {};
            ensureHasReferencedJQueryTemplates();

            // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)
            var precompiled = templateSource['data']('precompiled');
            if (!precompiled) {
                var templateText = templateSource['text']() || "";
                // Wrap in "with($whatever.koBindingContext) { ... }"
                templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}";

                precompiled = jQuery['template'](null, templateText);
                templateSource['data']('precompiled', precompiled);
            }

            var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays
            var jQueryTemplateOptions = jQuery['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);

            var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);
            resultNodes['appendTo'](document.createElement("div")); // Using "appendTo" forces jQuery/jQuery.tmpl to perform necessary cleanup work

            jQuery['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders
            return resultNodes;
        };

        this['createJavaScriptEvaluatorBlock'] = function(script) {
            return "{{ko_code ((function() { return " + script + " })()) }}";
        };

        this['addTemplate'] = function(templateName, templateMarkup) {
            document.write("<script type='text/html' id='" + templateName + "'>" + templateMarkup + "</script>");
        };

        if (jQueryTmplVersion > 0) {
            jQuery['tmpl']['tag']['ko_code'] = {
                open: "__.push($1 || '');"
            };
            jQuery['tmpl']['tag']['ko_with'] = {
                open: "with($1) {",
                close: "} "
            };
        }
    };

    ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();

    // Use this one by default *only if jquery.tmpl is referenced*
    var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();
    if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)
        ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);

    ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);
})();
});
})(window,document,navigator);

```

`LibreHardwareMonitor/Resources/Web/js/knockout-2.1.0.min.js`:

```js
// Knockout JavaScript library v2.1.0
// (c) Steven Sanderson - http://knockoutjs.com/
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function(window,document,navigator,undefined){
function m(w){throw w;}var n=void 0,p=!0,s=null,t=!1;function A(w){return function(){return w}};function E(w){function B(b,c,d){d&&c!==a.k.r(b)&&a.k.S(b,c);c!==a.k.r(b)&&a.a.va(b,"change")}var a="undefined"!==typeof w?w:{};a.b=function(b,c){for(var d=b.split("."),f=a,g=0;g<d.length-1;g++)f=f[d[g]];f[d[d.length-1]]=c};a.B=function(a,c,d){a[c]=d};a.version="2.1.0";a.b("version",a.version);a.a=new function(){function b(b,c){if("input"!==a.a.o(b)||!b.type||"click"!=c.toLowerCase())return t;var e=b.type;return"checkbox"==e||"radio"==e}var c=/^(\s|\u00A0)+|(\s|\u00A0)+$/g,d={},f={};d[/Firefox\/2/i.test(navigator.userAgent)?
"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];d.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");for(var g in d){var e=d[g];if(e.length)for(var h=0,j=e.length;h<j;h++)f[e[h]]=g}var k={propertychange:p},i=function(){for(var a=3,b=document.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="<\!--[if gt IE "+ ++a+"]><i></i><![endif]--\>",c[0];);return 4<a?a:n}();return{Ca:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],
v:function(a,b){for(var c=0,e=a.length;c<e;c++)b(a[c])},j:function(a,b){if("function"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var c=0,e=a.length;c<e;c++)if(a[c]===b)return c;return-1},ab:function(a,b,c){for(var e=0,f=a.length;e<f;e++)if(b.call(c,a[e]))return a[e];return s},ba:function(b,c){var e=a.a.j(b,c);0<=e&&b.splice(e,1)},za:function(b){for(var b=b||[],c=[],e=0,f=b.length;e<f;e++)0>a.a.j(c,b[e])&&c.push(b[e]);return c},T:function(a,b){for(var a=a||[],c=[],
e=0,f=a.length;e<f;e++)c.push(b(a[e]));return c},aa:function(a,b){for(var a=a||[],c=[],e=0,f=a.length;e<f;e++)b(a[e])&&c.push(a[e]);return c},N:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,e=b.length;c<e;c++)a.push(b[c]);return a},extend:function(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a},ga:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},Ab:function(b){for(var b=a.a.L(b),c=document.createElement("div"),e=0,f=b.length;e<f;e++)a.F(b[e]),
c.appendChild(b[e]);return c},X:function(b,c){a.a.ga(b);if(c)for(var e=0,f=c.length;e<f;e++)b.appendChild(c[e])},Na:function(b,c){var e=b.nodeType?[b]:b;if(0<e.length){for(var f=e[0],d=f.parentNode,g=0,h=c.length;g<h;g++)d.insertBefore(c[g],f);g=0;for(h=e.length;g<h;g++)a.removeNode(e[g])}},Pa:function(a,b){0<=navigator.userAgent.indexOf("MSIE 6")?a.setAttribute("selected",b):a.selected=b},w:function(a){return(a||"").replace(c,"")},Ib:function(b,c){for(var e=[],f=(b||"").split(c),g=0,d=f.length;g<
d;g++){var h=a.a.w(f[g]);""!==h&&e.push(h)}return e},Hb:function(a,b){a=a||"";return b.length>a.length?t:a.substring(0,b.length)===b},eb:function(a,b){for(var c="return ("+a+")",e=0;e<b;e++)c="with(sc["+e+"]) { "+c+" } ";return new Function("sc",c)},kb:function(a,b){if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&16);for(;a!=s;){if(a==b)return p;a=a.parentNode}return t},fa:function(b){return a.a.kb(b,b.ownerDocument)},o:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},
n:function(a,c,e){var f=i&&k[c];if(!f&&"undefined"!=typeof jQuery){if(b(a,c))var g=e,e=function(a,b){var c=this.checked;b&&(this.checked=b.fb!==p);g.call(this,a);this.checked=c};jQuery(a).bind(c,e)}else!f&&"function"==typeof a.addEventListener?a.addEventListener(c,e,t):"undefined"!=typeof a.attachEvent?a.attachEvent("on"+c,function(b){e.call(a,b)}):m(Error("Browser doesn't support addEventListener or attachEvent"))},va:function(a,c){(!a||!a.nodeType)&&m(Error("element must be a DOM node when calling triggerEvent"));
if("undefined"!=typeof jQuery){var e=[];b(a,c)&&e.push({fb:a.checked});jQuery(a).trigger(c,e)}else"function"==typeof document.createEvent?"function"==typeof a.dispatchEvent?(e=document.createEvent(f[c]||"HTMLEvents"),e.initEvent(c,p,p,window,0,0,0,0,0,t,t,t,t,0,a),a.dispatchEvent(e)):m(Error("The supplied element doesn't support dispatchEvent")):"undefined"!=typeof a.fireEvent?(b(a,c)&&(a.checked=a.checked!==p),a.fireEvent("on"+c)):m(Error("Browser doesn't support triggering events"))},d:function(b){return a.la(b)?
b():b},Ua:function(b,c,e){var f=(b.className||"").split(/\s+/),g=0<=a.a.j(f,c);if(e&&!g)b.className+=(f[0]?" ":"")+c;else if(g&&!e){e="";for(g=0;g<f.length;g++)f[g]!=c&&(e+=f[g]+" ");b.className=a.a.w(e)}},Qa:function(b,c){var e=a.a.d(c);if(e===s||e===n)e="";"innerText"in b?b.innerText=e:b.textContent=e;9<=i&&(b.style.display=b.style.display)},lb:function(a){if(9<=i){var b=a.style.width;a.style.width=0;a.style.width=b}},Eb:function(b,e){for(var b=a.a.d(b),e=a.a.d(e),c=[],f=b;f<=e;f++)c.push(f);return c},
L:function(a){for(var b=[],e=0,c=a.length;e<c;e++)b.push(a[e]);return b},tb:6===i,ub:7===i,ja:i,Da:function(b,e){for(var c=a.a.L(b.getElementsByTagName("input")).concat(a.a.L(b.getElementsByTagName("textarea"))),f="string"==typeof e?function(a){return a.name===e}:function(a){return e.test(a.name)},g=[],d=c.length-1;0<=d;d--)f(c[d])&&g.push(c[d]);return g},Bb:function(b){return"string"==typeof b&&(b=a.a.w(b))?window.JSON&&window.JSON.parse?window.JSON.parse(b):(new Function("return "+b))():s},sa:function(b,
e,c){("undefined"==typeof JSON||"undefined"==typeof JSON.stringify)&&m(Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js"));return JSON.stringify(a.a.d(b),e,c)},Cb:function(b,e,c){var c=c||{},f=c.params||{},g=c.includeFields||this.Ca,d=b;if("object"==typeof b&&"form"===a.a.o(b))for(var d=b.action,h=g.length-1;0<=h;h--)for(var k=a.a.Da(b,g[h]),
j=k.length-1;0<=j;j--)f[k[j].name]=k[j].value;var e=a.a.d(e),i=document.createElement("form");i.style.display="none";i.action=d;i.method="post";for(var z in e)b=document.createElement("input"),b.name=z,b.value=a.a.sa(a.a.d(e[z])),i.appendChild(b);for(z in f)b=document.createElement("input"),b.name=z,b.value=f[z],i.appendChild(b);document.body.appendChild(i);c.submitter?c.submitter(i):i.submit();setTimeout(function(){i.parentNode.removeChild(i)},0)}}};a.b("utils",a.a);a.b("utils.arrayForEach",a.a.v);
a.b("utils.arrayFirst",a.a.ab);a.b("utils.arrayFilter",a.a.aa);a.b("utils.arrayGetDistinctValues",a.a.za);a.b("utils.arrayIndexOf",a.a.j);a.b("utils.arrayMap",a.a.T);a.b("utils.arrayPushAll",a.a.N);a.b("utils.arrayRemoveItem",a.a.ba);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",a.a.Ca);a.b("utils.getFormFields",a.a.Da);a.b("utils.postJson",a.a.Cb);a.b("utils.parseJson",a.a.Bb);a.b("utils.registerEventHandler",a.a.n);a.b("utils.stringifyJson",a.a.sa);a.b("utils.range",a.a.Eb);
a.b("utils.toggleDomNodeCssClass",a.a.Ua);a.b("utils.triggerEvent",a.a.va);a.b("utils.unwrapObservable",a.a.d);Function.prototype.bind||(Function.prototype.bind=function(a){var c=this,d=Array.prototype.slice.call(arguments),a=d.shift();return function(){return c.apply(a,d.concat(Array.prototype.slice.call(arguments)))}});a.a.f=new function(){var b=0,c="__ko__"+(new Date).getTime(),d={};return{get:function(b,c){var e=a.a.f.getAll(b,t);return e===n?n:e[c]},set:function(b,c,e){e===n&&a.a.f.getAll(b,
t)===n||(a.a.f.getAll(b,p)[c]=e)},getAll:function(a,g){var e=a[c];if(!(e&&"null"!==e)){if(!g)return;e=a[c]="ko"+b++;d[e]={}}return d[e]},clear:function(a){var b=a[c];b&&(delete d[b],a[c]=s)}}};a.b("utils.domData",a.a.f);a.b("utils.domData.clear",a.a.f.clear);a.a.G=new function(){function b(b,c){var f=a.a.f.get(b,d);f===n&&c&&(f=[],a.a.f.set(b,d,f));return f}function c(e){var f=b(e,t);if(f)for(var f=f.slice(0),d=0;d<f.length;d++)f[d](e);a.a.f.clear(e);"function"==typeof jQuery&&"function"==typeof jQuery.cleanData&&
jQuery.cleanData([e]);if(g[e.nodeType])for(f=e.firstChild;e=f;)f=e.nextSibling,8===e.nodeType&&c(e)}var d="__ko_domNodeDisposal__"+(new Date).getTime(),f={1:p,8:p,9:p},g={1:p,9:p};return{wa:function(a,c){"function"!=typeof c&&m(Error("Callback must be a function"));b(a,p).push(c)},Ma:function(c,f){var g=b(c,t);g&&(a.a.ba(g,f),0==g.length&&a.a.f.set(c,d,n))},F:function(b){if(f[b.nodeType]&&(c(b),g[b.nodeType])){var d=[];a.a.N(d,b.getElementsByTagName("*"));for(var b=0,j=d.length;b<j;b++)c(d[b])}},
removeNode:function(b){a.F(b);b.parentNode&&b.parentNode.removeChild(b)}}};a.F=a.a.G.F;a.removeNode=a.a.G.removeNode;a.b("cleanNode",a.F);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",a.a.G);a.b("utils.domNodeDisposal.addDisposeCallback",a.a.G.wa);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.G.Ma);(function(){a.a.pa=function(b){var c;if("undefined"!=typeof jQuery){if((c=jQuery.clean([b]))&&c[0]){for(b=c[0];b.parentNode&&11!==b.parentNode.nodeType;)b=b.parentNode;b.parentNode&&
b.parentNode.removeChild(b)}}else{var d=a.a.w(b).toLowerCase();c=document.createElement("div");d=d.match(/^<(thead|tbody|tfoot)/)&&[1,"<table>","</table>"]||!d.indexOf("<tr")&&[2,"<table><tbody>","</tbody></table>"]||(!d.indexOf("<td")||!d.indexOf("<th"))&&[3,"<table><tbody><tr>","</tr></tbody></table>"]||[0,"",""];b="ignored<div>"+d[1]+b+d[2]+"</div>";for("function"==typeof window.innerShiv?c.appendChild(window.innerShiv(b)):c.innerHTML=b;d[0]--;)c=c.lastChild;c=a.a.L(c.lastChild.childNodes)}return c};
a.a.Y=function(b,c){a.a.ga(b);if(c!==s&&c!==n)if("string"!=typeof c&&(c=c.toString()),"undefined"!=typeof jQuery)jQuery(b).html(c);else for(var d=a.a.pa(c),f=0;f<d.length;f++)b.appendChild(d[f])}})();a.b("utils.parseHtmlFragment",a.a.pa);a.b("utils.setHtml",a.a.Y);a.s=function(){function b(){return(4294967296*(1+Math.random())|0).toString(16).substring(1)}function c(b,g){if(b)if(8==b.nodeType){var e=a.s.Ja(b.nodeValue);e!=s&&g.push({jb:b,yb:e})}else if(1==b.nodeType)for(var e=0,d=b.childNodes,j=d.length;e<
j;e++)c(d[e],g)}var d={};return{na:function(a){"function"!=typeof a&&m(Error("You can only pass a function to ko.memoization.memoize()"));var c=b()+b();d[c]=a;return"<\!--[ko_memo:"+c+"]--\>"},Va:function(a,b){var c=d[a];c===n&&m(Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized."));try{return c.apply(s,b||[]),p}finally{delete d[a]}},Wa:function(b,d){var e=[];c(b,e);for(var h=0,j=e.length;h<j;h++){var k=e[h].jb,i=[k];d&&a.a.N(i,d);a.s.Va(e[h].yb,i);k.nodeValue="";k.parentNode&&
k.parentNode.removeChild(k)}},Ja:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:s}}}();a.b("memoization",a.s);a.b("memoization.memoize",a.s.na);a.b("memoization.unmemoize",a.s.Va);a.b("memoization.parseMemoText",a.s.Ja);a.b("memoization.unmemoizeDomNodeAndDescendants",a.s.Wa);a.Ba={throttle:function(b,c){b.throttleEvaluation=c;var d=s;return a.h({read:b,write:function(a){clearTimeout(d);d=setTimeout(function(){b(a)},c)}})},notify:function(b,c){b.equalityComparer="always"==c?A(t):a.m.fn.equalityComparer;
return b}};a.b("extenders",a.Ba);a.Sa=function(b,c,d){this.target=b;this.ca=c;this.ib=d;a.B(this,"dispose",this.A)};a.Sa.prototype.A=function(){this.sb=p;this.ib()};a.R=function(){this.u={};a.a.extend(this,a.R.fn);a.B(this,"subscribe",this.ta);a.B(this,"extend",this.extend);a.B(this,"getSubscriptionsCount",this.ob)};a.R.fn={ta:function(b,c,d){var d=d||"change",b=c?b.bind(c):b,f=new a.Sa(this,b,function(){a.a.ba(this.u[d],f)}.bind(this));this.u[d]||(this.u[d]=[]);this.u[d].push(f);return f},notifySubscribers:function(b,
c){c=c||"change";this.u[c]&&a.a.v(this.u[c].slice(0),function(a){a&&a.sb!==p&&a.ca(b)})},ob:function(){var a=0,c;for(c in this.u)this.u.hasOwnProperty(c)&&(a+=this.u[c].length);return a},extend:function(b){var c=this;if(b)for(var d in b){var f=a.Ba[d];"function"==typeof f&&(c=f(c,b[d]))}return c}};a.Ga=function(a){return"function"==typeof a.ta&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.R);a.b("isSubscribable",a.Ga);a.U=function(){var b=[];return{bb:function(a){b.push({ca:a,Aa:[]})},
end:function(){b.pop()},La:function(c){a.Ga(c)||m(Error("Only subscribable things can act as dependencies"));if(0<b.length){var d=b[b.length-1];0<=a.a.j(d.Aa,c)||(d.Aa.push(c),d.ca(c))}}}}();var G={undefined:p,"boolean":p,number:p,string:p};a.m=function(b){function c(){if(0<arguments.length){if(!c.equalityComparer||!c.equalityComparer(d,arguments[0]))c.I(),d=arguments[0],c.H();return this}a.U.La(c);return d}var d=b;a.R.call(c);c.H=function(){c.notifySubscribers(d)};c.I=function(){c.notifySubscribers(d,
"beforeChange")};a.a.extend(c,a.m.fn);a.B(c,"valueHasMutated",c.H);a.B(c,"valueWillMutate",c.I);return c};a.m.fn={equalityComparer:function(a,c){return a===s||typeof a in G?a===c:t}};var x=a.m.Db="__ko_proto__";a.m.fn[x]=a.m;a.ia=function(b,c){return b===s||b===n||b[x]===n?t:b[x]===c?p:a.ia(b[x],c)};a.la=function(b){return a.ia(b,a.m)};a.Ha=function(b){return"function"==typeof b&&b[x]===a.m||"function"==typeof b&&b[x]===a.h&&b.pb?p:t};a.b("observable",a.m);a.b("isObservable",a.la);a.b("isWriteableObservable",
a.Ha);a.Q=function(b){0==arguments.length&&(b=[]);b!==s&&(b!==n&&!("length"in b))&&m(Error("The argument passed when initializing an observable array must be an array, or null, or undefined."));var c=a.m(b);a.a.extend(c,a.Q.fn);return c};a.Q.fn={remove:function(a){for(var c=this(),d=[],f="function"==typeof a?a:function(c){return c===a},g=0;g<c.length;g++){var e=c[g];f(e)&&(0===d.length&&this.I(),d.push(e),c.splice(g,1),g--)}d.length&&this.H();return d},removeAll:function(b){if(b===n){var c=this(),
d=c.slice(0);this.I();c.splice(0,c.length);this.H();return d}return!b?[]:this.remove(function(c){return 0<=a.a.j(b,c)})},destroy:function(a){var c=this(),d="function"==typeof a?a:function(c){return c===a};this.I();for(var f=c.length-1;0<=f;f--)d(c[f])&&(c[f]._destroy=p);this.H()},destroyAll:function(b){return b===n?this.destroy(A(p)):!b?[]:this.destroy(function(c){return 0<=a.a.j(b,c)})},indexOf:function(b){var c=this();return a.a.j(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.I(),
this()[d]=c,this.H())}};a.a.v("pop push reverse shift sort splice unshift".split(" "),function(b){a.Q.fn[b]=function(){var a=this();this.I();a=a[b].apply(a,arguments);this.H();return a}});a.a.v(["slice"],function(b){a.Q.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.b("observableArray",a.Q);a.h=function(b,c,d){function f(){a.a.v(v,function(a){a.A()});v=[]}function g(){var a=h.throttleEvaluation;a&&0<=a?(clearTimeout(x),x=setTimeout(e,a)):e()}function e(){if(!l)if(i&&w())u();else{l=
p;try{var b=a.a.T(v,function(a){return a.target});a.U.bb(function(c){var e;0<=(e=a.a.j(b,c))?b[e]=n:v.push(c.ta(g))});for(var e=q.call(c),f=b.length-1;0<=f;f--)b[f]&&v.splice(f,1)[0].A();i=p;h.notifySubscribers(k,"beforeChange");k=e}finally{a.U.end()}h.notifySubscribers(k);l=t}}function h(){if(0<arguments.length)j.apply(h,arguments);else return i||e(),a.U.La(h),k}function j(){"function"===typeof o?o.apply(c,arguments):m(Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters."))}
var k,i=t,l=t,q=b;q&&"object"==typeof q?(d=q,q=d.read):(d=d||{},q||(q=d.read));"function"!=typeof q&&m(Error("Pass a function that returns the value of the ko.computed"));var o=d.write;c||(c=d.owner);var v=[],u=f,r="object"==typeof d.disposeWhenNodeIsRemoved?d.disposeWhenNodeIsRemoved:s,w=d.disposeWhen||A(t);if(r){u=function(){a.a.G.Ma(r,arguments.callee);f()};a.a.G.wa(r,u);var y=w,w=function(){return!a.a.fa(r)||y()}}var x=s;h.nb=function(){return v.length};h.pb="function"===typeof d.write;h.A=function(){u()};
a.R.call(h);a.a.extend(h,a.h.fn);d.deferEvaluation!==p&&e();a.B(h,"dispose",h.A);a.B(h,"getDependenciesCount",h.nb);return h};a.rb=function(b){return a.ia(b,a.h)};w=a.m.Db;a.h[w]=a.m;a.h.fn={};a.h.fn[w]=a.h;a.b("dependentObservable",a.h);a.b("computed",a.h);a.b("isComputed",a.rb);(function(){function b(a,g,e){e=e||new d;a=g(a);if(!("object"==typeof a&&a!==s&&a!==n&&!(a instanceof Date)))return a;var h=a instanceof Array?[]:{};e.save(a,h);c(a,function(c){var d=g(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":h[c]=
d;break;case "object":case "undefined":var i=e.get(d);h[c]=i!==n?i:b(d,g,e)}});return h}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function d(){var b=[],c=[];this.save=function(e,d){var j=a.a.j(b,e);0<=j?c[j]=d:(b.push(e),c.push(d))};this.get=function(e){e=a.a.j(b,e);return 0<=e?c[e]:n}}a.Ta=function(c){0==arguments.length&&m(Error("When calling ko.toJS, pass the object you want to convert."));return b(c,function(b){for(var c=
0;a.la(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,e){b=a.Ta(b);return a.a.sa(b,c,e)}})();a.b("toJS",a.Ta);a.b("toJSON",a.toJSON);(function(){a.k={r:function(b){switch(a.a.o(b)){case "option":return b.__ko__hasDomDataOptionValue__===p?a.a.f.get(b,a.c.options.oa):b.getAttribute("value");case "select":return 0<=b.selectedIndex?a.k.r(b.options[b.selectedIndex]):n;default:return b.value}},S:function(b,c){switch(a.a.o(b)){case "option":switch(typeof c){case "string":a.a.f.set(b,a.c.options.oa,
n);"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__;b.value=c;break;default:a.a.f.set(b,a.c.options.oa,c),b.__ko__hasDomDataOptionValue__=p,b.value="number"===typeof c?c:""}break;case "select":for(var d=b.options.length-1;0<=d;d--)if(a.k.r(b.options[d])==c){b.selectedIndex=d;break}break;default:if(c===s||c===n)c="";b.value=c}}}})();a.b("selectExtensions",a.k);a.b("selectExtensions.readValue",a.k.r);a.b("selectExtensions.writeValue",a.k.S);a.g=function(){function b(a,b){for(var d=
s;a!=d;)d=a,a=a.replace(c,function(a,c){return b[c]});return a}var c=/\@ko_token_(\d+)\@/g,d=/^[\_$a-z][\_$a-z0-9]*(\[.*?\])*(\.[\_$a-z][\_$a-z0-9]*(\[.*?\])*)*$/i,f=["true","false"];return{D:[],W:function(c){var e=a.a.w(c);if(3>e.length)return[];"{"===e.charAt(0)&&(e=e.substring(1,e.length-1));for(var c=[],d=s,f,k=0;k<e.length;k++){var i=e.charAt(k);if(d===s)switch(i){case '"':case "'":case "/":d=k,f=i}else if(i==f&&"\\"!==e.charAt(k-1)){i=e.substring(d,k+1);c.push(i);var l="@ko_token_"+(c.length-
1)+"@",e=e.substring(0,d)+l+e.substring(k+1),k=k-(i.length-l.length),d=s}}f=d=s;for(var q=0,o=s,k=0;k<e.length;k++){i=e.charAt(k);if(d===s)switch(i){case "{":d=k;o=i;f="}";break;case "(":d=k;o=i;f=")";break;case "[":d=k,o=i,f="]"}i===o?q++:i===f&&(q--,0===q&&(i=e.substring(d,k+1),c.push(i),l="@ko_token_"+(c.length-1)+"@",e=e.substring(0,d)+l+e.substring(k+1),k-=i.length-l.length,d=s))}f=[];e=e.split(",");d=0;for(k=e.length;d<k;d++)q=e[d],o=q.indexOf(":"),0<o&&o<q.length-1?(i=q.substring(o+1),f.push({key:b(q.substring(0,
o),c),value:b(i,c)})):f.push({unknown:b(q,c)});return f},ka:function(b){for(var c="string"===typeof b?a.g.W(b):b,h=[],b=[],j,k=0;j=c[k];k++)if(0<h.length&&h.push(","),j.key){var i;a:{i=j.key;var l=a.a.w(i);switch(l.length&&l.charAt(0)){case "'":case '"':break a;default:i="'"+l+"'"}}j=j.value;h.push(i);h.push(":");h.push(j);l=a.a.w(j);if(0<=a.a.j(f,a.a.w(l).toLowerCase())?0:l.match(d)!==s)0<b.length&&b.push(", "),b.push(i+" : function(__ko_value) { "+j+" = __ko_value; }")}else j.unknown&&h.push(j.unknown);
c=h.join("");0<b.length&&(c=c+", '_ko_property_writers' : { "+b.join("")+" } ");return c},wb:function(b,c){for(var d=0;d<b.length;d++)if(a.a.w(b[d].key)==c)return p;return t},$:function(b,c,d,f,k){if(!b||!a.Ha(b)){if((b=c()._ko_property_writers)&&b[d])b[d](f)}else(!k||b()!==f)&&b(f)}}}();a.b("jsonExpressionRewriting",a.g);a.b("jsonExpressionRewriting.bindingRewriteValidators",a.g.D);a.b("jsonExpressionRewriting.parseObjectLiteral",a.g.W);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",
a.g.ka);(function(){function b(a){return 8==a.nodeType&&(g?a.text:a.nodeValue).match(e)}function c(a){return 8==a.nodeType&&(g?a.text:a.nodeValue).match(h)}function d(a,e){for(var d=a,f=1,g=[];d=d.nextSibling;){if(c(d)&&(f--,0===f))return g;g.push(d);b(d)&&f++}e||m(Error("Cannot find closing comment tag to match: "+a.nodeValue));return s}function f(a,b){var c=d(a,b);return c?0<c.length?c[c.length-1].nextSibling:a.nextSibling:s}var g="<\!--test--\>"===document.createComment("test").text,e=g?/^<\!--\s*ko\s+(.*\:.*)\s*--\>$/:
/^\s*ko\s+(.*\:.*)\s*$/,h=g?/^<\!--\s*\/ko\s*--\>$/:/^\s*\/ko\s*$/,j={ul:p,ol:p};a.e={C:{},childNodes:function(a){return b(a)?d(a):a.childNodes},ha:function(c){if(b(c))for(var c=a.e.childNodes(c),e=0,d=c.length;e<d;e++)a.removeNode(c[e]);else a.a.ga(c)},X:function(c,e){if(b(c)){a.e.ha(c);for(var d=c.nextSibling,f=0,g=e.length;f<g;f++)d.parentNode.insertBefore(e[f],d)}else a.a.X(c,e)},Ka:function(a,c){b(a)?a.parentNode.insertBefore(c,a.nextSibling):a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)},
Fa:function(a,c,e){b(a)?a.parentNode.insertBefore(c,e.nextSibling):e.nextSibling?a.insertBefore(c,e.nextSibling):a.appendChild(c)},firstChild:function(a){return!b(a)?a.firstChild:!a.nextSibling||c(a.nextSibling)?s:a.nextSibling},nextSibling:function(a){b(a)&&(a=f(a));return a.nextSibling&&c(a.nextSibling)?s:a.nextSibling},Xa:function(a){return(a=b(a))?a[1]:s},Ia:function(e){if(j[a.a.o(e)]){var d=e.firstChild;if(d){do if(1===d.nodeType){var g;g=d.firstChild;var h=s;if(g){do if(h)h.push(g);else if(b(g)){var o=
f(g,p);o?g=o:h=[g]}else c(g)&&(h=[g]);while(g=g.nextSibling)}if(g=h){h=d.nextSibling;for(o=0;o<g.length;o++)h?e.insertBefore(g[o],h):e.appendChild(g[o])}}while(d=d.nextSibling)}}}}})();a.b("virtualElements",a.e);a.b("virtualElements.allowedBindings",a.e.C);a.b("virtualElements.emptyNode",a.e.ha);a.b("virtualElements.insertAfter",a.e.Fa);a.b("virtualElements.prepend",a.e.Ka);a.b("virtualElements.setDomNodeChildren",a.e.X);(function(){a.J=function(){this.cb={}};a.a.extend(a.J.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind")!=
s;case 8:return a.e.Xa(b)!=s;default:return t}},getBindings:function(a,c){var d=this.getBindingsString(a,c);return d?this.parseBindingsString(d,c):s},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.e.Xa(b);default:return s}},parseBindingsString:function(b,c){try{var d=c.$data,d="object"==typeof d&&d!=s?[d,c]:[c],f=d.length,g=this.cb,e=f+"_"+b,h;if(!(h=g[e])){var j=" { "+a.g.ka(b)+" } ";h=g[e]=a.a.eb(j,f)}return h(d)}catch(k){m(Error("Unable to parse bindings.\nMessage: "+
k+";\nBindings value: "+b))}}});a.J.instance=new a.J})();a.b("bindingProvider",a.J);(function(){function b(b,d,e){for(var h=a.e.firstChild(d);d=h;)h=a.e.nextSibling(d),c(b,d,e)}function c(c,g,e){var h=p,j=1===g.nodeType;j&&a.e.Ia(g);if(j&&e||a.J.instance.nodeHasBindings(g))h=d(g,s,c,e).Gb;h&&b(c,g,!j)}function d(b,c,e,d){function j(a){return function(){return l[a]}}function k(){return l}var i=0,l,q;a.h(function(){var o=e&&e instanceof a.z?e:new a.z(a.a.d(e)),v=o.$data;d&&a.Ra(b,o);if(l=("function"==
typeof c?c():c)||a.J.instance.getBindings(b,o)){if(0===i){i=1;for(var u in l){var r=a.c[u];r&&8===b.nodeType&&!a.e.C[u]&&m(Error("The binding '"+u+"' cannot be used with virtual elements"));if(r&&"function"==typeof r.init&&(r=(0,r.init)(b,j(u),k,v,o))&&r.controlsDescendantBindings)q!==n&&m(Error("Multiple bindings ("+q+" and "+u+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.")),q=u}i=2}if(2===i)for(u in l)(r=a.c[u])&&"function"==
typeof r.update&&(0,r.update)(b,j(u),k,v,o)}},s,{disposeWhenNodeIsRemoved:b});return{Gb:q===n}}a.c={};a.z=function(b,c){c?(a.a.extend(this,c),this.$parentContext=c,this.$parent=c.$data,this.$parents=(c.$parents||[]).slice(0),this.$parents.unshift(this.$parent)):(this.$parents=[],this.$root=b);this.$data=b};a.z.prototype.createChildContext=function(b){return new a.z(b,this)};a.z.prototype.extend=function(b){var c=a.a.extend(new a.z,this);return a.a.extend(c,b)};a.Ra=function(b,c){if(2==arguments.length)a.a.f.set(b,
"__ko_bindingContext__",c);else return a.a.f.get(b,"__ko_bindingContext__")};a.ya=function(b,c,e){1===b.nodeType&&a.e.Ia(b);return d(b,c,e,p)};a.Ya=function(a,c){(1===c.nodeType||8===c.nodeType)&&b(a,c,p)};a.xa=function(a,b){b&&(1!==b.nodeType&&8!==b.nodeType)&&m(Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node"));b=b||window.document.body;c(a,b,p)};a.ea=function(b){switch(b.nodeType){case 1:case 8:var c=a.Ra(b);if(c)return c;if(b.parentNode)return a.ea(b.parentNode)}};
a.hb=function(b){return(b=a.ea(b))?b.$data:n};a.b("bindingHandlers",a.c);a.b("applyBindings",a.xa);a.b("applyBindingsToDescendants",a.Ya);a.b("applyBindingsToNode",a.ya);a.b("contextFor",a.ea);a.b("dataFor",a.hb)})();a.a.v(["click"],function(b){a.c[b]={init:function(c,d,f,g){return a.c.event.init.call(this,c,function(){var a={};a[b]=d();return a},f,g)}}});a.c.event={init:function(b,c,d,f){var g=c()||{},e;for(e in g)(function(){var g=e;"string"==typeof g&&a.a.n(b,g,function(b){var e,i=c()[g];if(i){var l=
d();try{var q=a.a.L(arguments);q.unshift(f);e=i.apply(f,q)}finally{e!==p&&(b.preventDefault?b.preventDefault():b.returnValue=t)}l[g+"Bubble"]===t&&(b.cancelBubble=p,b.stopPropagation&&b.stopPropagation())}})})()}};a.c.submit={init:function(b,c,d,f){"function"!=typeof c()&&m(Error("The value for a submit binding must be a function"));a.a.n(b,"submit",function(a){var e,d=c();try{e=d.call(f,b)}finally{e!==p&&(a.preventDefault?a.preventDefault():a.returnValue=t)}})}};a.c.visible={update:function(b,c){var d=
a.a.d(c()),f="none"!=b.style.display;d&&!f?b.style.display="":!d&&f&&(b.style.display="none")}};a.c.enable={update:function(b,c){var d=a.a.d(c());d&&b.disabled?b.removeAttribute("disabled"):!d&&!b.disabled&&(b.disabled=p)}};a.c.disable={update:function(b,c){a.c.enable.update(b,function(){return!a.a.d(c())})}};a.c.value={init:function(b,c,d){function f(){var e=c(),f=a.k.r(b);a.g.$(e,d,"value",f,p)}var g=["change"],e=d().valueUpdate;e&&("string"==typeof e&&(e=[e]),a.a.N(g,e),g=a.a.za(g));if(a.a.ja&&
("input"==b.tagName.toLowerCase()&&"text"==b.type&&"off"!=b.autocomplete&&(!b.form||"off"!=b.form.autocomplete))&&-1==a.a.j(g,"propertychange")){var h=t;a.a.n(b,"propertychange",function(){h=p});a.a.n(b,"blur",function(){if(h){h=t;f()}})}a.a.v(g,function(c){var e=f;if(a.a.Hb(c,"after")){e=function(){setTimeout(f,0)};c=c.substring(5)}a.a.n(b,c,e)})},update:function(b,c){var d="select"===a.a.o(b),f=a.a.d(c()),g=a.k.r(b),e=f!=g;0===f&&(0!==g&&"0"!==g)&&(e=p);e&&(g=function(){a.k.S(b,f)},g(),d&&setTimeout(g,
0));d&&0<b.length&&B(b,f,t)}};a.c.options={update:function(b,c,d){"select"!==a.a.o(b)&&m(Error("options binding applies only to SELECT elements"));for(var f=0==b.length,g=a.a.T(a.a.aa(b.childNodes,function(b){return b.tagName&&"option"===a.a.o(b)&&b.selected}),function(b){return a.k.r(b)||b.innerText||b.textContent}),e=b.scrollTop,h=a.a.d(c());0<b.length;)a.F(b.options[0]),b.remove(0);if(h){d=d();"number"!=typeof h.length&&(h=[h]);if(d.optionsCaption){var j=document.createElement("option");a.a.Y(j,
d.optionsCaption);a.k.S(j,n);b.appendChild(j)}for(var c=0,k=h.length;c<k;c++){var j=document.createElement("option"),i="string"==typeof d.optionsValue?h[c][d.optionsValue]:h[c],i=a.a.d(i);a.k.S(j,i);var l=d.optionsText,i="function"==typeof l?l(h[c]):"string"==typeof l?h[c][l]:i;if(i===s||i===n)i="";a.a.Qa(j,i);b.appendChild(j)}h=b.getElementsByTagName("option");c=j=0;for(k=h.length;c<k;c++)0<=a.a.j(g,a.k.r(h[c]))&&(a.a.Pa(h[c],p),j++);b.scrollTop=e;f&&"value"in d&&B(b,a.a.d(d.value),p);a.a.lb(b)}}};
a.c.options.oa="__ko.optionValueDomData__";a.c.selectedOptions={Ea:function(b){for(var c=[],b=b.childNodes,d=0,f=b.length;d<f;d++){var g=b[d],e=a.a.o(g);"option"==e&&g.selected?c.push(a.k.r(g)):"optgroup"==e&&(g=a.c.selectedOptions.Ea(g),Array.prototype.splice.apply(c,[c.length,0].concat(g)))}return c},init:function(b,c,d){a.a.n(b,"change",function(){var b=c(),g=a.c.selectedOptions.Ea(this);a.g.$(b,d,"value",g)})},update:function(b,c){"select"!=a.a.o(b)&&m(Error("values binding applies only to SELECT elements"));
var d=a.a.d(c());if(d&&"number"==typeof d.length)for(var f=b.childNodes,g=0,e=f.length;g<e;g++){var h=f[g];"option"===a.a.o(h)&&a.a.Pa(h,0<=a.a.j(d,a.k.r(h)))}}};a.c.text={update:function(b,c){a.a.Qa(b,c())}};a.c.html={init:function(){return{controlsDescendantBindings:p}},update:function(b,c){var d=a.a.d(c());a.a.Y(b,d)}};a.c.css={update:function(b,c){var d=a.a.d(c()||{}),f;for(f in d)if("string"==typeof f){var g=a.a.d(d[f]);a.a.Ua(b,f,g)}}};a.c.style={update:function(b,c){var d=a.a.d(c()||{}),f;
for(f in d)if("string"==typeof f){var g=a.a.d(d[f]);b.style[f]=g||""}}};a.c.uniqueName={init:function(b,c){c()&&(b.name="ko_unique_"+ ++a.c.uniqueName.gb,(a.a.tb||a.a.ub)&&b.mergeAttributes(document.createElement("<input name='"+b.name+"'/>"),t))}};a.c.uniqueName.gb=0;a.c.checked={init:function(b,c,d){a.a.n(b,"click",function(){var f;if("checkbox"==b.type)f=b.checked;else if("radio"==b.type&&b.checked)f=b.value;else return;var g=c();"checkbox"==b.type&&a.a.d(g)instanceof Array?(f=a.a.j(a.a.d(g),b.value),
b.checked&&0>f?g.push(b.value):!b.checked&&0<=f&&g.splice(f,1)):a.g.$(g,d,"checked",f,p)});"radio"==b.type&&!b.name&&a.c.uniqueName.init(b,A(p))},update:function(b,c){var d=a.a.d(c());"checkbox"==b.type?b.checked=d instanceof Array?0<=a.a.j(d,b.value):d:"radio"==b.type&&(b.checked=b.value==d)}};var F={"class":"className","for":"htmlFor"};a.c.attr={update:function(b,c){var d=a.a.d(c())||{},f;for(f in d)if("string"==typeof f){var g=a.a.d(d[f]),e=g===t||g===s||g===n;e&&b.removeAttribute(f);8>=a.a.ja&&
f in F?(f=F[f],e?b.removeAttribute(f):b[f]=g):e||b.setAttribute(f,g.toString())}}};a.c.hasfocus={init:function(b,c,d){function f(b){var e=c();a.g.$(e,d,"hasfocus",b,p)}a.a.n(b,"focus",function(){f(p)});a.a.n(b,"focusin",function(){f(p)});a.a.n(b,"blur",function(){f(t)});a.a.n(b,"focusout",function(){f(t)})},update:function(b,c){var d=a.a.d(c());d?b.focus():b.blur();a.a.va(b,d?"focusin":"focusout")}};a.c["with"]={p:function(b){return function(){var c=b();return{"if":c,data:c,templateEngine:a.q.K}}},
init:function(b,c){return a.c.template.init(b,a.c["with"].p(c))},update:function(b,c,d,f,g){return a.c.template.update(b,a.c["with"].p(c),d,f,g)}};a.g.D["with"]=t;a.e.C["with"]=p;a.c["if"]={p:function(b){return function(){return{"if":b(),templateEngine:a.q.K}}},init:function(b,c){return a.c.template.init(b,a.c["if"].p(c))},update:function(b,c,d,f,g){return a.c.template.update(b,a.c["if"].p(c),d,f,g)}};a.g.D["if"]=t;a.e.C["if"]=p;a.c.ifnot={p:function(b){return function(){return{ifnot:b(),templateEngine:a.q.K}}},
init:function(b,c){return a.c.template.init(b,a.c.ifnot.p(c))},update:function(b,c,d,f,g){return a.c.template.update(b,a.c.ifnot.p(c),d,f,g)}};a.g.D.ifnot=t;a.e.C.ifnot=p;a.c.foreach={p:function(b){return function(){var c=a.a.d(b());return!c||"number"==typeof c.length?{foreach:c,templateEngine:a.q.K}:{foreach:c.data,includeDestroyed:c.includeDestroyed,afterAdd:c.afterAdd,beforeRemove:c.beforeRemove,afterRender:c.afterRender,templateEngine:a.q.K}}},init:function(b,c){return a.c.template.init(b,a.c.foreach.p(c))},
update:function(b,c,d,f,g){return a.c.template.update(b,a.c.foreach.p(c),d,f,g)}};a.g.D.foreach=t;a.e.C.foreach=p;a.t=function(){};a.t.prototype.renderTemplateSource=function(){m(Error("Override renderTemplateSource"))};a.t.prototype.createJavaScriptEvaluatorBlock=function(){m(Error("Override createJavaScriptEvaluatorBlock"))};a.t.prototype.makeTemplateSource=function(b,c){if("string"==typeof b){var c=c||document,d=c.getElementById(b);d||m(Error("Cannot find template with ID "+b));return new a.l.i(d)}if(1==
b.nodeType||8==b.nodeType)return new a.l.M(b);m(Error("Unknown template type: "+b))};a.t.prototype.renderTemplate=function(a,c,d,f){return this.renderTemplateSource(this.makeTemplateSource(a,f),c,d)};a.t.prototype.isTemplateRewritten=function(a,c){return this.allowTemplateRewriting===t||!(c&&c!=document)&&this.V&&this.V[a]?p:this.makeTemplateSource(a,c).data("isRewritten")};a.t.prototype.rewriteTemplate=function(a,c,d){var f=this.makeTemplateSource(a,d),c=c(f.text());f.text(c);f.data("isRewritten",
p);!(d&&d!=document)&&"string"==typeof a&&(this.V=this.V||{},this.V[a]=p)};a.b("templateEngine",a.t);a.Z=function(){function b(b,c,e){for(var b=a.g.W(b),d=a.g.D,j=0;j<b.length;j++){var k=b[j].key;if(d.hasOwnProperty(k)){var i=d[k];"function"===typeof i?(k=i(b[j].value))&&m(Error(k)):i||m(Error("This template engine does not support the '"+k+"' binding within its templates"))}}b="ko.templateRewriting.applyMemoizedBindingsToNextSibling(function() {             return (function() { return { "+a.g.ka(b)+
" } })()         })";return e.createJavaScriptEvaluatorBlock(b)+c}var c=/(<[a-z]+\d*(\s+(?!data-bind=)[a-z0-9\-]+(=(\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind=(["'])([\s\S]*?)\5/gi,d=/<\!--\s*ko\b\s*([\s\S]*?)\s*--\>/g;return{mb:function(b,c,e){c.isTemplateRewritten(b,e)||c.rewriteTemplate(b,function(b){return a.Z.zb(b,c)},e)},zb:function(a,g){return a.replace(c,function(a,c,d,f,i,l,q){return b(q,c,g)}).replace(d,function(a,c){return b(c,"<\!-- ko --\>",g)})},Za:function(b){return a.s.na(function(c,
e){c.nextSibling&&a.ya(c.nextSibling,b,e)})}}}();a.b("templateRewriting",a.Z);a.b("templateRewriting.applyMemoizedBindingsToNextSibling",a.Z.Za);(function(){a.l={};a.l.i=function(a){this.i=a};a.l.i.prototype.text=function(){var b=a.a.o(this.i),b="script"===b?"text":"textarea"===b?"value":"innerHTML";if(0==arguments.length)return this.i[b];var c=arguments[0];"innerHTML"===b?a.a.Y(this.i,c):this.i[b]=c};a.l.i.prototype.data=function(b){if(1===arguments.length)return a.a.f.get(this.i,"templateSourceData_"+
b);a.a.f.set(this.i,"templateSourceData_"+b,arguments[1])};a.l.M=function(a){this.i=a};a.l.M.prototype=new a.l.i;a.l.M.prototype.text=function(){if(0==arguments.length){var b=a.a.f.get(this.i,"__ko_anon_template__")||{};b.ua===n&&b.da&&(b.ua=b.da.innerHTML);return b.ua}a.a.f.set(this.i,"__ko_anon_template__",{ua:arguments[0]})};a.l.i.prototype.nodes=function(){if(0==arguments.length)return(a.a.f.get(this.i,"__ko_anon_template__")||{}).da;a.a.f.set(this.i,"__ko_anon_template__",{da:arguments[0]})};
a.b("templateSources",a.l);a.b("templateSources.domElement",a.l.i);a.b("templateSources.anonymousTemplate",a.l.M)})();(function(){function b(b,c,d){for(var f,c=a.e.nextSibling(c);b&&(f=b)!==c;)b=a.e.nextSibling(f),(1===f.nodeType||8===f.nodeType)&&d(f)}function c(c,d){if(c.length){var f=c[0],g=c[c.length-1];b(f,g,function(b){a.xa(d,b)});b(f,g,function(b){a.s.Wa(b,[d])})}}function d(a){return a.nodeType?a:0<a.length?a[0]:s}function f(b,f,j,k,i){var i=i||{},l=b&&d(b),l=l&&l.ownerDocument,q=i.templateEngine||
g;a.Z.mb(j,q,l);j=q.renderTemplate(j,k,i,l);("number"!=typeof j.length||0<j.length&&"number"!=typeof j[0].nodeType)&&m(Error("Template engine must return an array of DOM nodes"));l=t;switch(f){case "replaceChildren":a.e.X(b,j);l=p;break;case "replaceNode":a.a.Na(b,j);l=p;break;case "ignoreTargetNode":break;default:m(Error("Unknown renderMode: "+f))}l&&(c(j,k),i.afterRender&&i.afterRender(j,k.$data));return j}var g;a.ra=function(b){b!=n&&!(b instanceof a.t)&&m(Error("templateEngine must inherit from ko.templateEngine"));
g=b};a.qa=function(b,c,j,k,i){j=j||{};(j.templateEngine||g)==n&&m(Error("Set a template engine before calling renderTemplate"));i=i||"replaceChildren";if(k){var l=d(k);return a.h(function(){var g=c&&c instanceof a.z?c:new a.z(a.a.d(c)),o="function"==typeof b?b(g.$data):b,g=f(k,i,o,g,j);"replaceNode"==i&&(k=g,l=d(k))},s,{disposeWhen:function(){return!l||!a.a.fa(l)},disposeWhenNodeIsRemoved:l&&"replaceNode"==i?l.parentNode:l})}return a.s.na(function(d){a.qa(b,c,j,d,"replaceNode")})};a.Fb=function(b,
d,g,k,i){function l(a,b){c(b,o);g.afterRender&&g.afterRender(b,a)}function q(c,d){var h="function"==typeof b?b(c):b;o=i.createChildContext(a.a.d(c));o.$index=d;return f(s,"ignoreTargetNode",h,o,g)}var o;return a.h(function(){var b=a.a.d(d)||[];"undefined"==typeof b.length&&(b=[b]);b=a.a.aa(b,function(b){return g.includeDestroyed||b===n||b===s||!a.a.d(b._destroy)});a.a.Oa(k,b,q,g,l)},s,{disposeWhenNodeIsRemoved:k})};a.c.template={init:function(b,c){var d=a.a.d(c());if("string"!=typeof d&&!d.name&&
(1==b.nodeType||8==b.nodeType))d=1==b.nodeType?b.childNodes:a.e.childNodes(b),d=a.a.Ab(d),(new a.l.M(b)).nodes(d);return{controlsDescendantBindings:p}},update:function(b,c,d,f,g){c=a.a.d(c());f=p;"string"==typeof c?d=c:(d=c.name,"if"in c&&(f=f&&a.a.d(c["if"])),"ifnot"in c&&(f=f&&!a.a.d(c.ifnot)));var l=s;"object"===typeof c&&"foreach"in c?l=a.Fb(d||b,f&&c.foreach||[],c,b,g):f?(g="object"==typeof c&&"data"in c?g.createChildContext(a.a.d(c.data)):g,l=a.qa(d||b,g,c,b)):a.e.ha(b);g=l;(c=a.a.f.get(b,"__ko__templateSubscriptionDomDataKey__"))&&
"function"==typeof c.A&&c.A();a.a.f.set(b,"__ko__templateSubscriptionDomDataKey__",g)}};a.g.D.template=function(b){b=a.g.W(b);return 1==b.length&&b[0].unknown||a.g.wb(b,"name")?s:"This template engine does not support anonymous templates nested within its templates"};a.e.C.template=p})();a.b("setTemplateEngine",a.ra);a.b("renderTemplate",a.qa);(function(){a.a.O=function(b,c,d){if(d===n)return a.a.O(b,c,1)||a.a.O(b,c,10)||a.a.O(b,c,Number.MAX_VALUE);for(var b=b||[],c=c||[],f=b,g=c,e=[],h=0;h<=g.length;h++)e[h]=
[];for(var h=0,j=Math.min(f.length,d);h<=j;h++)e[0][h]=h;h=1;for(j=Math.min(g.length,d);h<=j;h++)e[h][0]=h;for(var j=f.length,k,i=g.length,h=1;h<=j;h++){k=Math.max(1,h-d);for(var l=Math.min(i,h+d);k<=l;k++)e[k][h]=f[h-1]===g[k-1]?e[k-1][h-1]:Math.min(e[k-1][h]===n?Number.MAX_VALUE:e[k-1][h]+1,e[k][h-1]===n?Number.MAX_VALUE:e[k][h-1]+1)}d=b.length;f=c.length;g=[];h=e[f][d];if(h===n)e=s;else{for(;0<d||0<f;){j=e[f][d];i=0<f?e[f-1][d]:h+1;l=0<d?e[f][d-1]:h+1;k=0<f&&0<d?e[f-1][d-1]:h+1;if(i===n||i<j-1)i=
h+1;if(l===n||l<j-1)l=h+1;k<j-1&&(k=h+1);i<=l&&i<k?(g.push({status:"added",value:c[f-1]}),f--):(l<i&&l<k?g.push({status:"deleted",value:b[d-1]}):(g.push({status:"retained",value:b[d-1]}),f--),d--)}e=g.reverse()}return e}})();a.b("utils.compareArrays",a.a.O);(function(){function b(a){if(2<a.length){for(var b=a[0],c=a[a.length-1],e=[b];b!==c;){b=b.nextSibling;if(!b)return;e.push(b)}Array.prototype.splice.apply(a,[0,a.length].concat(e))}}function c(c,f,g,e,h){var j=[],c=a.h(function(){var c=f(g,h)||
[];0<j.length&&(b(j),a.a.Na(j,c),e&&e(g,c));j.splice(0,j.length);a.a.N(j,c)},s,{disposeWhenNodeIsRemoved:c,disposeWhen:function(){return 0==j.length||!a.a.fa(j[0])}});return{xb:j,h:c}}a.a.Oa=function(d,f,g,e,h){for(var f=f||[],e=e||{},j=a.a.f.get(d,"setDomNodeChildrenFromArrayMapping_lastMappingResult")===n,k=a.a.f.get(d,"setDomNodeChildrenFromArrayMapping_lastMappingResult")||[],i=a.a.T(k,function(a){return a.$a}),l=a.a.O(i,f),f=[],q=0,o=[],v=0,i=[],u=s,r=0,w=l.length;r<w;r++)switch(l[r].status){case "retained":var y=
k[q];y.qb(v);v=f.push(y);0<y.P.length&&(u=y.P[y.P.length-1]);q++;break;case "deleted":k[q].h.A();b(k[q].P);a.a.v(k[q].P,function(a){o.push({element:a,index:r,value:l[r].value});u=a});q++;break;case "added":for(var y=l[r].value,x=a.m(v),v=c(d,g,y,h,x),C=v.xb,v=f.push({$a:l[r].value,P:C,h:v.h,qb:x}),z=0,B=C.length;z<B;z++){var D=C[z];i.push({element:D,index:r,value:l[r].value});u==s?a.e.Ka(d,D):a.e.Fa(d,D,u);u=D}h&&h(y,C,x)}a.a.v(o,function(b){a.F(b.element)});g=t;if(!j){if(e.afterAdd)for(r=0;r<i.length;r++)e.afterAdd(i[r].element,
i[r].index,i[r].value);if(e.beforeRemove){for(r=0;r<o.length;r++)e.beforeRemove(o[r].element,o[r].index,o[r].value);g=p}}if(!g&&o.length)for(r=0;r<o.length;r++)e=o[r].element,e.parentNode&&e.parentNode.removeChild(e);a.a.f.set(d,"setDomNodeChildrenFromArrayMapping_lastMappingResult",f)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.Oa);a.q=function(){this.allowTemplateRewriting=t};a.q.prototype=new a.t;a.q.prototype.renderTemplateSource=function(b){var c=!(9>a.a.ja)&&b.nodes?b.nodes():s;
if(c)return a.a.L(c.cloneNode(p).childNodes);b=b.text();return a.a.pa(b)};a.q.K=new a.q;a.ra(a.q.K);a.b("nativeTemplateEngine",a.q);(function(){a.ma=function(){var a=this.vb=function(){if("undefined"==typeof jQuery||!jQuery.tmpl)return 0;try{if(0<=jQuery.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();this.renderTemplateSource=function(b,f,g){g=g||{};2>a&&m(Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later."));var e=b.data("precompiled");
e||(e=b.text()||"",e=jQuery.template(s,"{{ko_with $item.koBindingContext}}"+e+"{{/ko_with}}"),b.data("precompiled",e));b=[f.$data];f=jQuery.extend({koBindingContext:f},g.templateOptions);f=jQuery.tmpl(e,b,f);f.appendTo(document.createElement("div"));jQuery.fragments={};return f};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+a+" })()) }}"};this.addTemplate=function(a,b){document.write("<script type='text/html' id='"+a+"'>"+b+"<\/script>")};0<a&&(jQuery.tmpl.tag.ko_code=
{open:"__.push($1 || '');"},jQuery.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.ma.prototype=new a.t;var b=new a.ma;0<b.vb&&a.ra(b);a.b("jqueryTmplTemplateEngine",a.ma)})()}"function"===typeof require&&"object"===typeof exports&&"object"===typeof module?E(module.exports||exports):"function"===typeof define&&define.amd?define(["exports"],E):E(window.ko={});p;
})(window,document,navigator);

```

`LibreHardwareMonitor/Resources/Web/js/knockout.mapping-latest.js`:

```js
// Knockout Mapping plugin v2.1.2
// (c) 2012 Steven Sanderson, Roy Jacobs - http://knockoutjs.com/
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function (factory) {
	// Module systems magic dance.

	if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
		// CommonJS or Node: hard-coded dependency on "knockout"
		factory(require("knockout"), exports);
	} else if (typeof define === "function" && define["amd"]) {
		// AMD anonymous module with hard-coded dependency on "knockout"
		define(["knockout", "exports"], factory);
	} else {
		// <script> tag: use the global `ko` object, attaching a `mapping` property
		factory(ko, ko.mapping = {});
	}
}(function (ko, exports) {
	var DEBUG=true;
	var mappingProperty = "__ko_mapping__";
	var realKoDependentObservable = ko.dependentObservable;
	var mappingNesting = 0;
	var dependentObservables;
	var visitedObjects;

	var _defaultOptions = {
		include: ["_destroy"],
		ignore: [],
		copy: []
	};
	var defaultOptions = _defaultOptions;

	exports.isMapped = function (viewModel) {
		var unwrapped = ko.utils.unwrapObservable(viewModel);
		return unwrapped && unwrapped[mappingProperty];
	}

	exports.fromJS = function (jsObject /*, inputOptions, target*/ ) {
		if (arguments.length == 0) throw new Error("When calling ko.fromJS, pass the object you want to convert.");

		// When mapping is completed, even with an exception, reset the nesting level
		window.setTimeout(function () {
			mappingNesting = 0;
		}, 0);

		if (!mappingNesting++) {
			dependentObservables = [];
			visitedObjects = new objectLookup();
		}

		var options;
		var target;

		if (arguments.length == 2) {
			if (arguments[1][mappingProperty]) {
				target = arguments[1];
			} else {
				options = arguments[1];
			}
		}
		if (arguments.length == 3) {
			options = arguments[1];
			target = arguments[2];
		}

		if (target) {
			options = mergeOptions(target[mappingProperty], options);
		} else {
			options = mergeOptions(options);
		}
		options.mappedProperties = options.mappedProperties || {};

		var result = updateViewModel(target, jsObject, options);
		if (target) {
			result = target;
		}

		// Evaluate any dependent observables that were proxied.
		// Do this in a timeout to defer execution. Basically, any user code that explicitly looks up the DO will perform the first evaluation. Otherwise,
		// it will be done by this code.
		if (!--mappingNesting) {
			window.setTimeout(function () {
				while (dependentObservables.length) {
					var DO = dependentObservables.pop();
					if (DO) DO();
				}
			}, 0);
		}

		// Save any new mapping options in the view model, so that updateFromJS can use them later.
		result[mappingProperty] = mergeOptions(result[mappingProperty], options);

		return result;
	};

	exports.fromJSON = function (jsonString /*, options, target*/ ) {
		var parsed = ko.utils.parseJson(jsonString);
		arguments[0] = parsed;
		return exports.fromJS.apply(this, arguments);
	};

	exports.updateFromJS = function (viewModel) {
		throw new Error("ko.mapping.updateFromJS, use ko.mapping.fromJS instead. Please note that the order of parameters is different!");
	};

	exports.updateFromJSON = function (viewModel) {
		throw new Error("ko.mapping.updateFromJSON, use ko.mapping.fromJSON instead. Please note that the order of parameters is different!");
	};

	exports.toJS = function (rootObject, options) {
		if (arguments.length == 0) throw new Error("When calling ko.mapping.toJS, pass the object you want to convert.");
		// Merge in the options used in fromJS
		options = mergeOptions(rootObject[mappingProperty], options);

		// We just unwrap everything at every level in the object graph
		return visitModel(rootObject, function (x) {
			return ko.utils.unwrapObservable(x)
		}, options);
	};

	exports.toJSON = function (rootObject, options) {
		var plainJavaScriptObject = exports.toJS(rootObject, options);
		return ko.utils.stringifyJson(plainJavaScriptObject);
	};

	exports.visitModel = function (rootObject, callback, options) {
		if (arguments.length == 0) throw new Error("When calling ko.mapping.visitModel, pass the object you want to visit.");
		// Merge in the options used in fromJS
		options = mergeOptions(rootObject[mappingProperty], options);

		return visitModel(rootObject, callback, options);
	};

	exports.defaultOptions = function () {
		if (arguments.length > 0) {
			defaultOptions = arguments[0];
		} else {
			return defaultOptions;
		}
	};

	exports.resetDefaultOptions = function () {
		defaultOptions = {
			include: _defaultOptions.include.slice(0),
			ignore: _defaultOptions.ignore.slice(0),
			copy: _defaultOptions.copy.slice(0)
		};
	};

	exports.getType = function(x) {
		if ((x) && (typeof (x) === "object")) {
			if (x.constructor == (new Date).constructor) return "date";
			if (x.constructor == (new Array).constructor) return "array";
		}
		return typeof x;
	}

	function extendOptionsArray(distArray, sourceArray) {
		return ko.utils.arrayGetDistinctValues(
			ko.utils.arrayPushAll(distArray, sourceArray)
		);
	}

	function extendOptionsObject(target, options) {
		var type = exports.getType,
			name, special = { "include": true, "ignore": true, "copy": true },
			t, o, i = 1, l = arguments.length;
		if (type(target) !== "object") {
			target = {};
		}
		for (; i < l; i++) {
			options = arguments[i];
			if (type(options) !== "object") {
				options = {};
			}
			for (name in options) {
				t = target[name]; o = options[name];
				if (name !== "constructor" && special[name] && type(o) !== "array") {
					if (type(o) !== "string") {
						throw new Error("ko.mapping.defaultOptions()." + name + " should be an array or string.");
					}
					o = [o];
				}
				switch (type(o)) {
				case "object": // Recurse
					t = type(t) === "object" ? t : {};
					target[name] = extendOptionsObject(t, o);
					break;
				case "array":
					t = type(t) === "array" ? t : [];
					target[name] = extendOptionsArray(t, o);
					break;
				default:
					target[name] = o;
				}
			}
		}
		return target;
	}

	function mergeOptions() {
		var options = ko.utils.arrayPushAll([{}, defaultOptions], arguments); // Always use empty object as target to avoid changing default options
		options = extendOptionsObject.apply(this, options);
		return options;
	}

	// When using a 'create' callback, we proxy the dependent observable so that it doesn't immediately evaluate on creation.
	// The reason is that the dependent observables in the user-specified callback may contain references to properties that have not been mapped yet.
	function withProxyDependentObservable(dependentObservables, callback) {
		var localDO = ko.dependentObservable;
		ko.dependentObservable = function (read, owner, options) {
			options = options || {};

			if (read && typeof read == "object") { // mirrors condition in knockout implementation of DO's
				options = read;
			}

			var realDeferEvaluation = options.deferEvaluation;

			var isRemoved = false;

			// We wrap the original dependent observable so that we can remove it from the 'dependentObservables' list we need to evaluate after mapping has
			// completed if the user already evaluated the DO themselves in the meantime.
			var wrap = function (DO) {
				var wrapped = realKoDependentObservable({
					read: function () {
						if (!isRemoved) {
							ko.utils.arrayRemoveItem(dependentObservables, DO);
							isRemoved = true;
						}
						return DO.apply(DO, arguments);
					},
					write: function (val) {
						return DO(val);
					},
					deferEvaluation: true
				});
				if(DEBUG) wrapped._wrapper = true;
				return wrapped;
			};
			
			options.deferEvaluation = true; // will either set for just options, or both read/options.
			var realDependentObservable = new realKoDependentObservable(read, owner, options);

			if (!realDeferEvaluation) {
				realDependentObservable = wrap(realDependentObservable);
				dependentObservables.push(realDependentObservable);
			}

			return realDependentObservable;
		}
		ko.dependentObservable.fn = realKoDependentObservable.fn;
		ko.computed = ko.dependentObservable;
		var result = callback();
		ko.dependentObservable = localDO;
		ko.computed = ko.dependentObservable;
		return result;
	}

	function updateViewModel(mappedRootObject, rootObject, options, parentName, parent, parentPropertyName) {
		var isArray = ko.utils.unwrapObservable(rootObject) instanceof Array;

		// If nested object was already mapped previously, take the options from it
		if (parentName !== undefined && exports.isMapped(mappedRootObject)) {
			options = ko.utils.unwrapObservable(mappedRootObject)[mappingProperty];
			parentName = "";
			parentPropertyName = "";
		}

		parentName = parentName || "";
		parentPropertyName = parentPropertyName || "";

		var callbackParams = {
			data: rootObject,
			parent: parent
		};

		var getCallback = function (name) {
			var callback;
			if (parentName === "") {
				callback = options[name];
			} else if (callback = options[parentName]) {
				callback = callback[name]
			}
			return callback;
		};

		var hasCreateCallback = function () {
			return getCallback("create") instanceof Function;
		};

		var createCallback = function (data) {
			return withProxyDependentObservable(dependentObservables, function () {
				return getCallback("create")({
					data: data || callbackParams.data,
					parent: callbackParams.parent
				});
			});
		};

		var hasUpdateCallback = function () {
			return getCallback("update") instanceof Function;
		};

		var updateCallback = function (obj, data) {
			var params = {
				data: data || callbackParams.data,
				parent: callbackParams.parent,
				target: ko.utils.unwrapObservable(obj)
			};

			if (ko.isWriteableObservable(obj)) {
				params.observable = obj;
			}

			return getCallback("update")(params);
		}

		var alreadyMapped = visitedObjects.get(rootObject);
		if (alreadyMapped) {
			return alreadyMapped;
		}

		if (!isArray) {
			// For atomic types, do a direct update on the observable
			if (!canHaveProperties(rootObject)) {
				switch (exports.getType(rootObject)) {
				case "function":
					if (hasUpdateCallback()) {
						if (ko.isWriteableObservable(rootObject)) {
							rootObject(updateCallback(rootObject));
							mappedRootObject = rootObject;
						} else {
							mappedRootObject = updateCallback(rootObject);
						}
					} else {
						mappedRootObject = rootObject;
					}
					break;
				default:
					if (ko.isWriteableObservable(mappedRootObject)) {
						if (hasUpdateCallback()) {
							mappedRootObject(updateCallback(mappedRootObject));
						} else {
							mappedRootObject(ko.utils.unwrapObservable(rootObject));
						}
					} else {
						if (hasCreateCallback()) {
							mappedRootObject = createCallback();
						} else {
							mappedRootObject = ko.observable(ko.utils.unwrapObservable(rootObject));
						}

						if (hasUpdateCallback()) {
							mappedRootObject(updateCallback(mappedRootObject));
						}
					}
					break;
				}

			} else {
				mappedRootObject = ko.utils.unwrapObservable(mappedRootObject);
				if (!mappedRootObject) {
					if (hasCreateCallback()) {
						var result = createCallback();

						if (hasUpdateCallback()) {
							result = updateCallback(result);
						}

						return result;
					} else {
						if (hasUpdateCallback()) {
							return updateCallback(result);
						}

						mappedRootObject = {};
					}
				}

				if (hasUpdateCallback()) {
					mappedRootObject = updateCallback(mappedRootObject);
				}

				visitedObjects.save(rootObject, mappedRootObject);

				// For non-atomic types, visit all properties and update recursively
				visitPropertiesOrArrayEntries(rootObject, function (indexer) {
					var fullPropertyName = getPropertyName(parentPropertyName, rootObject, indexer);

					if (ko.utils.arrayIndexOf(options.ignore, fullPropertyName) != -1) {
						return;
					}

					if (ko.utils.arrayIndexOf(options.copy, fullPropertyName) != -1) {
						mappedRootObject[indexer] = rootObject[indexer];
						return;
					}

					// In case we are adding an already mapped property, fill it with the previously mapped property value to prevent recursion.
					// If this is a property that was generated by fromJS, we should use the options specified there
					var prevMappedProperty = visitedObjects.get(rootObject[indexer]);
					var value = prevMappedProperty || updateViewModel(mappedRootObject[indexer], rootObject[indexer], options, indexer, mappedRootObject, fullPropertyName);

					if (ko.isWriteableObservable(mappedRootObject[indexer])) {
						mappedRootObject[indexer](ko.utils.unwrapObservable(value));
					} else {
						mappedRootObject[indexer] = value;
					}

					options.mappedProperties[fullPropertyName] = true;
				});
			}
		} else {
			var changes = [];

			var hasKeyCallback = getCallback("key") instanceof Function;
			var keyCallback = hasKeyCallback ? getCallback("key") : function (x) {
				return x;
			};
			if (!ko.isObservable(mappedRootObject)) {
				// When creating the new observable array, also add a bunch of utility functions that take the 'key' of the array items into account.
				mappedRootObject = ko.observableArray([]);

				mappedRootObject.mappedRemove = function (valueOrPredicate) {
					var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) {
							return value === keyCallback(valueOrPredicate);
						};
					return mappedRootObject.remove(function (item) {
						return predicate(keyCallback(item));
					});
				}

				mappedRootObject.mappedRemoveAll = function (arrayOfValues) {
					var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);
					return mappedRootObject.remove(function (item) {
						return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) != -1;
					});
				}

				mappedRootObject.mappedDestroy = function (valueOrPredicate) {
					var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) {
							return value === keyCallback(valueOrPredicate);
						};
					return mappedRootObject.destroy(function (item) {
						return predicate(keyCallback(item));
					});
				}

				mappedRootObject.mappedDestroyAll = function (arrayOfValues) {
					var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);
					return mappedRootObject.destroy(function (item) {
						return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) != -1;
					});
				}

				mappedRootObject.mappedIndexOf = function (item) {
					var keys = filterArrayByKey(mappedRootObject(), keyCallback);
					var key = keyCallback(item);
					return ko.utils.arrayIndexOf(keys, key);
				}

				mappedRootObject.mappedCreate = function (value) {
					if (mappedRootObject.mappedIndexOf(value) !== -1) {
						throw new Error("There already is an object with the key that you specified.");
					}

					var item = hasCreateCallback() ? createCallback(value) : value;
					if (hasUpdateCallback()) {
						var newValue = updateCallback(item, value);
						if (ko.isWriteableObservable(item)) {
							item(newValue);
						} else {
							item = newValue;
						}
					}
					mappedRootObject.push(item);
					return item;
				}
			}

			var currentArrayKeys = filterArrayByKey(ko.utils.unwrapObservable(mappedRootObject), keyCallback).sort();
			var newArrayKeys = filterArrayByKey(rootObject, keyCallback);
			if (hasKeyCallback) newArrayKeys.sort();
			var editScript = ko.utils.compareArrays(currentArrayKeys, newArrayKeys);

			var ignoreIndexOf = {};

			var newContents = [];
			for (var i = 0, j = editScript.length; i < j; i++) {
				var key = editScript[i];
				var mappedItem;
				var fullPropertyName = getPropertyName(parentPropertyName, rootObject, i);
				switch (key.status) {
				case "added":
					var item = getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);
					mappedItem = updateViewModel(undefined, item, options, parentName, mappedRootObject, fullPropertyName);
					if(!hasCreateCallback()) {
						mappedItem = ko.utils.unwrapObservable(mappedItem);
					}

					var index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);
					newContents[index] = mappedItem;
					ignoreIndexOf[index] = true;
					break;
				case "retained":
					var item = getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);
					mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);
					updateViewModel(mappedItem, item, options, parentName, mappedRootObject, fullPropertyName);

					var index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);
					newContents[index] = mappedItem;
					ignoreIndexOf[index] = true;
					break;
				case "deleted":
					mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);
					break;
				}

				changes.push({
					event: key.status,
					item: mappedItem
				});
			}

			mappedRootObject(newContents);

			var arrayChangedCallback = getCallback("arrayChanged");
			if (arrayChangedCallback instanceof Function) {
				ko.utils.arrayForEach(changes, function (change) {
					arrayChangedCallback(change.event, change.item);
				});
			}
		}

		return mappedRootObject;
	}

	function ignorableIndexOf(array, item, ignoreIndices) {
		for (var i = 0, j = array.length; i < j; i++) {
			if (ignoreIndices[i] === true) continue;
			if (array[i] === item) return i;
		}
		return null;
	}

	function mapKey(item, callback) {
		var mappedItem;
		if (callback) mappedItem = callback(item);
		if (exports.getType(mappedItem) === "undefined") mappedItem = item;

		return ko.utils.unwrapObservable(mappedItem);
	}

	function getItemByKey(array, key, callback) {
		var filtered = ko.utils.arrayFilter(ko.utils.unwrapObservable(array), function (item) {
			return mapKey(item, callback) === key;
		});

		if (filtered.length == 0) throw new Error("When calling ko.update*, the key '" + key + "' was not found!");
		if ((filtered.length > 1) && (canHaveProperties(filtered[0]))) throw new Error("When calling ko.update*, the key '" + key + "' was not unique!");

		return filtered[0];
	}

	function filterArrayByKey(array, callback) {
		return ko.utils.arrayMap(ko.utils.unwrapObservable(array), function (item) {
			if (callback) {
				return mapKey(item, callback);
			} else {
				return item;
			}
		});
	}

	function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
		if (rootObject instanceof Array) {
			for (var i = 0; i < rootObject.length; i++)
			visitorCallback(i);
		} else {
			for (var propertyName in rootObject)
			visitorCallback(propertyName);
		}
	};

	function canHaveProperties(object) {
		var type = exports.getType(object);
		return (type === "object" || type === "array") && (object !== null) && (type !== "undefined");
	}

	// Based on the parentName, this creates a fully classified name of a property

	function getPropertyName(parentName, parent, indexer) {
		var propertyName = parentName || "";
		if (parent instanceof Array) {
			if (parentName) {
				propertyName += "[" + indexer + "]";
			}
		} else {
			if (parentName) {
				propertyName += ".";
			}
			propertyName += indexer;
		}
		return propertyName;
	}

	function visitModel(rootObject, callback, options, parentName, fullParentName) {
		// If nested object was already mapped previously, take the options from it
		if (parentName !== undefined && exports.isMapped(rootObject)) {
			//options = ko.utils.unwrapObservable(rootObject)[mappingProperty];
			options = mergeOptions(ko.utils.unwrapObservable(rootObject)[mappingProperty], options);
			parentName = "";
		}

		if (parentName === undefined) { // the first call
			visitedObjects = new objectLookup();
		}

		parentName = parentName || "";

		var mappedRootObject;
		var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);
		if (!canHaveProperties(unwrappedRootObject)) {
			return callback(rootObject, fullParentName);
		} else {
			// Only do a callback, but ignore the results
			callback(rootObject, fullParentName);
			mappedRootObject = unwrappedRootObject instanceof Array ? [] : {};
		}

		visitedObjects.save(rootObject, mappedRootObject);

		var origFullParentName = fullParentName;
		visitPropertiesOrArrayEntries(unwrappedRootObject, function (indexer) {
			if (options.ignore && ko.utils.arrayIndexOf(options.ignore, indexer) != -1) return;

			var propertyValue = unwrappedRootObject[indexer];
			var fullPropertyName = getPropertyName(parentName, unwrappedRootObject, indexer);
			
			// If we don't want to explicitly copy the unmapped property...
			if (ko.utils.arrayIndexOf(options.copy, indexer) === -1) {
				// ...find out if it's a property we want to explicitly include
				if (ko.utils.arrayIndexOf(options.include, indexer) === -1) {
					// Options contains all the properties that were part of the original object.
					// If a property does not exist, and it is not because it is part of an array (e.g. "myProp[3]"), then it should not be unmapped.
					if (options.mappedProperties && !options.mappedProperties[fullPropertyName] && !(unwrappedRootObject instanceof Array)) {
						return;
					}
				}
			}

			fullParentName = getPropertyName(origFullParentName, unwrappedRootObject, indexer);
			
			var propertyType = exports.getType(ko.utils.unwrapObservable(propertyValue));
			switch (propertyType) {
			case "object":
			case "array":
			case "undefined":
				var previouslyMappedValue = visitedObjects.get(propertyValue);
				mappedRootObject[indexer] = (exports.getType(previouslyMappedValue) !== "undefined") ? previouslyMappedValue : visitModel(propertyValue, callback, options, fullPropertyName, fullParentName);
				break;
			default:
				mappedRootObject[indexer] = callback(propertyValue, fullParentName);
			}
		});

		return mappedRootObject;
	}

	function objectLookup() {
		var keys = [];
		var values = [];
		this.save = function (key, value) {
			var existingIndex = ko.utils.arrayIndexOf(keys, key);
			if (existingIndex >= 0) values[existingIndex] = value;
			else {
				keys.push(key);
				values.push(value);
			}
		};
		this.get = function (key) {
			var existingIndex = ko.utils.arrayIndexOf(keys, key);
			return (existingIndex >= 0) ? values[existingIndex] : undefined;
		};
	};
}));
```

`LibreHardwareMonitor/Resources/Web/js/knockout.mapping-latest.min.js`:

```js
// Knockout Mapping plugin v2.1.2
// (c) 2012 Steven Sanderson, Roy Jacobs - http://knockoutjs.com/
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function(e){"function"===typeof require&&"object"===typeof exports&&"object"===typeof module?e(require("knockout"),exports):"function"===typeof define&&define.amd?define(["knockout","exports"],e):e(ko,ko.mapping={})})(function(e,f){function J(a,b){var c=f.getType,d,l={include:!0,ignore:!0,copy:!0},h,g,k=1,p=arguments.length;for("object"!==c(a)&&(a={});k<p;k++)for(d in b=arguments[k],"object"!==c(b)&&(b={}),b){h=a[d];g=b[d];if("constructor"!==d&&l[d]&&"array"!==c(g)){if("string"!==c(g))throw Error("ko.mapping.defaultOptions()."+
d+" should be an array or string.");g=[g]}switch(c(g)){case "object":h="object"===c(h)?h:{};a[d]=J(h,g);break;case "array":h="array"===c(h)?h:[];a[d]=e.utils.arrayGetDistinctValues(e.utils.arrayPushAll(h,g));break;default:a[d]=g}}return a}function i(){var a=e.utils.arrayPushAll([{},q],arguments);return a=J.apply(this,a)}function O(a,b){var c=e.dependentObservable;e.dependentObservable=function(b,c,d){d=d||{};b&&"object"==typeof b&&(d=b);var f=d.deferEvaluation,p=!1,z=function(b){return w({read:function(){p||
(e.utils.arrayRemoveItem(a,b),p=!0);return b.apply(b,arguments)},write:function(a){return b(a)},deferEvaluation:!0})};d.deferEvaluation=!0;b=new w(b,c,d);f||(b=z(b),a.push(b));return b};e.dependentObservable.fn=w.fn;e.computed=e.dependentObservable;var d=b();e.dependentObservable=c;e.computed=e.dependentObservable;return d}function C(a,b,c,d,l,h){var g=e.utils.unwrapObservable(b)instanceof Array;void 0!==d&&f.isMapped(a)&&(c=e.utils.unwrapObservable(a)[r],h=d="");var d=d||"",h=h||"",k=function(a){var b;
if(d==="")b=c[a];else if(b=c[d])b=b[a];return b},p=function(){return k("create")instanceof Function},z=function(a){return O(D,function(){return k("create")({data:a||b,parent:l})})},o=function(){return k("update")instanceof Function},m=function(a,c){var d={data:c||b,parent:l,target:e.utils.unwrapObservable(a)};if(e.isWriteableObservable(a))d.observable=a;return k("update")(d)},v=u.get(b);if(v)return v;if(g){var g=[],j=(v=k("key")instanceof Function)?k("key"):function(a){return a};e.isObservable(a)||
(a=e.observableArray([]),a.mappedRemove=function(b){var c=typeof b=="function"?b:function(a){return a===j(b)};return a.remove(function(a){return c(j(a))})},a.mappedRemoveAll=function(b){var c=A(b,j);return a.remove(function(a){return e.utils.arrayIndexOf(c,j(a))!=-1})},a.mappedDestroy=function(b){var c=typeof b=="function"?b:function(a){return a===j(b)};return a.destroy(function(a){return c(j(a))})},a.mappedDestroyAll=function(b){var c=A(b,j);return a.destroy(function(a){return e.utils.arrayIndexOf(c,
j(a))!=-1})},a.mappedIndexOf=function(b){var c=A(a(),j),b=j(b);return e.utils.arrayIndexOf(c,b)},a.mappedCreate=function(b){if(a.mappedIndexOf(b)!==-1)throw Error("There already is an object with the key that you specified.");var c=p()?z(b):b;if(o()){b=m(c,b);e.isWriteableObservable(c)?c(b):c=b}a.push(c);return c});var n=A(e.utils.unwrapObservable(a),j).sort(),i=A(b,j);v&&i.sort();for(var v=e.utils.compareArrays(n,i),n={},i=[],q=0,y=v.length;q<y;q++){var x=v[q],s,t=E(h,b,q);switch(x.status){case "added":var B=
F(e.utils.unwrapObservable(b),x.value,j);s=C(void 0,B,c,d,a,t);p()||(s=e.utils.unwrapObservable(s));t=K(e.utils.unwrapObservable(b),B,n);i[t]=s;n[t]=!0;break;case "retained":B=F(e.utils.unwrapObservable(b),x.value,j);s=F(a,x.value,j);C(s,B,c,d,a,t);t=K(e.utils.unwrapObservable(b),B,n);i[t]=s;n[t]=!0;break;case "deleted":s=F(a,x.value,j)}g.push({event:x.status,item:s})}a(i);var w=k("arrayChanged");w instanceof Function&&e.utils.arrayForEach(g,function(a){w(a.event,a.item)})}else if(G(b)){a=e.utils.unwrapObservable(a);
if(!a){if(p())return n=z(),o()&&(n=m(n)),n;if(o())return m(n);a={}}o()&&(a=m(a));u.save(b,a);L(b,function(d){var f=E(h,b,d);if(e.utils.arrayIndexOf(c.ignore,f)==-1)if(e.utils.arrayIndexOf(c.copy,f)!=-1)a[d]=b[d];else{var g=u.get(b[d])||C(a[d],b[d],c,d,a,f);if(e.isWriteableObservable(a[d]))a[d](e.utils.unwrapObservable(g));else a[d]=g;c.mappedProperties[f]=true}})}else switch(f.getType(b)){case "function":o()?e.isWriteableObservable(b)?(b(m(b)),a=b):a=m(b):a=b;break;default:e.isWriteableObservable(a)?
o()?a(m(a)):a(e.utils.unwrapObservable(b)):(a=p()?z():e.observable(e.utils.unwrapObservable(b)),o()&&a(m(a)))}return a}function K(a,b,c){for(var d=0,e=a.length;d<e;d++)if(!0!==c[d]&&a[d]===b)return d;return null}function M(a,b){var c;b&&(c=b(a));"undefined"===f.getType(c)&&(c=a);return e.utils.unwrapObservable(c)}function F(a,b,c){a=e.utils.arrayFilter(e.utils.unwrapObservable(a),function(a){return M(a,c)===b});if(0==a.length)throw Error("When calling ko.update*, the key '"+b+"' was not found!");
if(1<a.length&&G(a[0]))throw Error("When calling ko.update*, the key '"+b+"' was not unique!");return a[0]}function A(a,b){return e.utils.arrayMap(e.utils.unwrapObservable(a),function(a){return b?M(a,b):a})}function L(a,b){if(a instanceof Array)for(var c=0;c<a.length;c++)b(c);else for(c in a)b(c)}function G(a){var b=f.getType(a);return("object"===b||"array"===b)&&null!==a&&"undefined"!==b}function E(a,b,c){var d=a||"";b instanceof Array?a&&(d+="["+c+"]"):(a&&(d+="."),d+=c);return d}function H(a,b,
c,d,l){void 0!==d&&f.isMapped(a)&&(c=i(e.utils.unwrapObservable(a)[r],c),d="");void 0===d&&(u=new N);var d=d||"",h,g=e.utils.unwrapObservable(a);if(!G(g))return b(a,l);b(a,l);h=g instanceof Array?[]:{};u.save(a,h);var k=l;L(g,function(a){if(!(c.ignore&&e.utils.arrayIndexOf(c.ignore,a)!=-1)){var i=g[a],o=E(d,g,a);if(!(e.utils.arrayIndexOf(c.copy,a)===-1&&e.utils.arrayIndexOf(c.include,a)===-1&&c.mappedProperties&&!c.mappedProperties[o]&&!(g instanceof Array))){l=E(k,g,a);switch(f.getType(e.utils.unwrapObservable(i))){case "object":case "array":case "undefined":var m=
u.get(i);h[a]=f.getType(m)!=="undefined"?m:H(i,b,c,o,l);break;default:h[a]=b(i,l)}}}});return h}function N(){var a=[],b=[];this.save=function(c,d){var f=e.utils.arrayIndexOf(a,c);0<=f?b[f]=d:(a.push(c),b.push(d))};this.get=function(c){c=e.utils.arrayIndexOf(a,c);return 0<=c?b[c]:void 0}}var r="__ko_mapping__",w=e.dependentObservable,I=0,D,u,y={include:["_destroy"],ignore:[],copy:[]},q=y;f.isMapped=function(a){return(a=e.utils.unwrapObservable(a))&&a[r]};f.fromJS=function(a){if(0==arguments.length)throw Error("When calling ko.fromJS, pass the object you want to convert.");
window.setTimeout(function(){I=0},0);I++||(D=[],u=new N);var b,c;2==arguments.length&&(arguments[1][r]?c=arguments[1]:b=arguments[1]);3==arguments.length&&(b=arguments[1],c=arguments[2]);b=c?i(c[r],b):i(b);b.mappedProperties=b.mappedProperties||{};var d=C(c,a,b);c&&(d=c);--I||window.setTimeout(function(){for(;D.length;){var a=D.pop();a&&a()}},0);d[r]=i(d[r],b);return d};f.fromJSON=function(a){var b=e.utils.parseJson(a);arguments[0]=b;return f.fromJS.apply(this,arguments)};f.updateFromJS=function(){throw Error("ko.mapping.updateFromJS, use ko.mapping.fromJS instead. Please note that the order of parameters is different!");
};f.updateFromJSON=function(){throw Error("ko.mapping.updateFromJSON, use ko.mapping.fromJSON instead. Please note that the order of parameters is different!");};f.toJS=function(a,b){if(0==arguments.length)throw Error("When calling ko.mapping.toJS, pass the object you want to convert.");b=i(a[r],b);return H(a,function(a){return e.utils.unwrapObservable(a)},b)};f.toJSON=function(a,b){var c=f.toJS(a,b);return e.utils.stringifyJson(c)};f.visitModel=function(a,b,c){if(0==arguments.length)throw Error("When calling ko.mapping.visitModel, pass the object you want to visit.");
c=i(a[r],c);return H(a,b,c)};f.defaultOptions=function(){if(0<arguments.length)q=arguments[0];else return q};f.resetDefaultOptions=function(){q={include:y.include.slice(0),ignore:y.ignore.slice(0),copy:y.copy.slice(0)}};f.getType=function(a){if(a&&"object"===typeof a){if(a.constructor==(new Date).constructor)return"date";if(a.constructor==[].constructor)return"array"}return typeof a}});

```

`LibreHardwareMonitor/Resources/Web/js/ohm_web.js`:

```js
/*
 
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
	Copyright (C) 2012 Prince Samuel <prince.samuel@gmail.com>

*/

ko.bindingHandlers.treeTable = {
  update: function(element, valueAccessor, allBindingsAccessor) {
    var dependency = ko.utils.unwrapObservable(valueAccessor()),
    options = ko.toJS(allBindingsAccessor().treeOptions || {});

    setTimeout(function() { $(element).treeTable(options); }, 0);
  } 
};

var node = function(config, parent) {
  this.parent = parent;
  var _this = this;

  var mappingOptions = {
    Children : {
      create: function(args) {
        return new node(args.data, _this);
      }
      ,
      key: function(data) {
        return ko.utils.unwrapObservable(data.id);
      }
    }
  };

  ko.mapping.fromJS(config, mappingOptions, this);
}

$(function(){
  $.getJSON('data.json', function(data) {
    viewModel = new node(data, undefined);

    (function() {
      function flattenChildren(children, result) {
        ko.utils.arrayForEach(children(), function(child) {
          result.push(child);
          if (child.Children) {
            flattenChildren(child.Children, result);
          }
        });
      }

      viewModel.flattened = ko.dependentObservable(function() {
        var result = []; //root node

        if (viewModel.Children) {
          flattenChildren(viewModel.Children, result);   
        }

        return result;
      });

      viewModel.update = function() {
        $.getJSON('data.json', function(data) {
          ko.mapping.fromJS(data, {}, viewModel);
        });
      }

      viewModel.rate = 3000; //milliseconds
      viewModel.timer = {};

      viewModel.startAuto = function (){
        viewModel.timer = setInterval(viewModel.update, viewModel.rate);
      }

      viewModel.stopAuto = function (){
        clearInterval(viewModel.timer);
      }

      viewModel.auto_refresh = ko.observable(false);
      viewModel.toggleAuto = ko.dependentObservable(function() {
        if (viewModel.auto_refresh())
          viewModel.startAuto();
        else
          viewModel.stopAuto();
      }, viewModel);

    })();

    ko.applyBindings(viewModel);
    $("#tree").treeTable({
      initialState: "expanded",
      clickableNodeNames: true
    });
  });
  $( "#refresh" ).button();
  $( "#auto_refresh" ).button();
  $( "#slider" ).slider({
    value:3,
    min: 1,
    max: 10,
    slide: function( event, ui ) {
      viewModel.rate = ui.value * 1000;
      if (viewModel.auto_refresh()) {
        //reset the timer
        viewModel.stopAuto();
        viewModel.startAuto();
      }
      $( "#lbl" ).text( ui.value + "s");
    }
  });
  $( "#lbl" ).text( $( "#slider" ).slider( "value" ) + "s");

});



```

`LibreHardwareMonitor/Resources/app.manifest`:

```manifest
<?xml version="1.0" encoding="utf-8"?>
<asmv1:assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1" 
  xmlns:asmv1="urn:schemas-microsoft-com:asm.v1" 
  xmlns:asmv2="urn:schemas-microsoft-com:asm.v2"
  xmlns:asmv3="urn:schemas-microsoft-com:asm.v3"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel level="highestAvailable" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows Vista -->
      <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
    </application>
  </compatibility>
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>true</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
</asmv1:assembly>

```

`LibreHardwareMonitor/TestScripts/LiquidCool.py`:

```py
################################################################
# Install:
# * python -m pip install colorama
# * python -m pip install requests
#
# Usage:
# * MAKE SURE YOU READ THE WARNING
# * python LiquidCool.py
#
# Description:
# This script implements a simple load based control of two fans
# It first saves the original Fan settings, then starts 
# monitoring the CPU and GPU load. It integrates those values
# to dampen the value changes somewhat. It then uses the maximum
# of the two values to set the fan speeds.
#
# Warning: This script is written as an example and may or may 
# not kill your PC! Use at your own risk!
################################################################

import colorama
import json, requests
import time
import math

url = 'http://127.0.0.1:8085'

params = dict()

pos = lambda x, y: '\x1b[%d;%dH' % (y, x)
clear = lambda : "\033[2J\033[1;1f"

def getValue(sensorId):
	params=dict(id=sensorId, action="Get")
	resp = requests.post(url=url + "/Sensor", params = params, timeout=10);
	result = json.loads(resp.text);

	if result["result"] != "ok":
		raise Exception("Server returned error:\n " + result["message"].replace("\\n", "\n").replace("\\r", ""))
	if result["value"] == None:
		return None;
	else:
		return float(result["value"])

def setValue(sensorId, sensorValue):
	if sensorValue == None:
		sensorValue = "null"
	params=dict(id=sensorId, action="Set", value=sensorValue)
	resp = requests.post(url=url + "/Sensor", params = params, timeout=10);
	result = json.loads(resp.text)
	if result["result"] != "ok":
		raise Exception("Server returned error:\n " + result["message"].replace("\\n", "\n").replace("\\r", ""))

def draw_progressbar(x, y, description, progress):
	p = '#'*math.floor(progress/5)
	p1 = '-'*math.ceil((100-progress)/5)
	print('{0}{1}[{2}{3}] {4}%   '.format(pos(x,y), description, p, p1, math.floor(progress*100)/100), end='')

def integrate(oldval, newval):
	return float(oldval)*0.8 + float(newval) * 0.2

def main():
	colorama.init()

	print(clear())

	try:
		integratedCPU = getValue("/intelcpu/0/load/0");
		integratedGPU = getValue("/nvidiagpu/0/load/0");
		orgFan1 = getValue("/lpc/it8620e/control/0")
		orgFan2 = getValue("/lpc/it8620e/control/1")

		while 1:
			cpuLoad = getValue("/intelcpu/0/load/0");
			gpuLoad = getValue("/nvidiagpu/0/load/0");

			integratedCPU = integrate(integratedCPU, cpuLoad)
			integratedGPU = integrate(integratedGPU, gpuLoad)
			fanVal = max(integratedCPU, integratedGPU)
			fanVal = math.floor(fanVal*0.75)

			draw_progressbar(1, 1, "CPU:  ", cpuLoad)
			draw_progressbar(1, 2, "GPU:  ", gpuLoad)

			draw_progressbar(1, 3, "IGPU: ", integratedCPU)
			draw_progressbar(1, 4, "IGPU: ", integratedGPU)

			draw_progressbar(1, 5, "Fans: ", fanVal)

			setValue("/lpc/it8620e/control/0", fanVal);
			setValue("/lpc/it8620e/control/1", fanVal);
			
			print(pos(1, 1))
			time.sleep(1)
	except:
		print(clear())
		setValue("/lpc/it8620e/control/0", orgFan1);
		setValue("/lpc/it8620e/control/1", orgFan2);
		raise



if __name__ == '__main__':
    main()
```

`LibreHardwareMonitor/TestScripts/basicrest.py`:

```py
################################################################
# Install:
# * python -m pip install requests
#
# Usage:
# * python basicrest.py
#
# Description:
# A simple test of the REST Like API
################################################################

import json, requests
import time

url = 'http://127.0.0.1:8085'

def findSensors(node):
	sensors = {}

	if len(node["Children"]) > 0:
		for child in node["Children"]:
			sensors.update(findSensors(child))
	else:
		if "Type" in node:
			sensors[node["SensorId"]] = node

	return sensors

def getValue(sensorId):
	params=dict(id=sensorId, action="Get")
	resp = requests.post(url=url + "/Sensor", params = params, timeout=10);
	result = json.loads(resp.text);

	if result["result"] != "ok":
		raise Exception("Server returned error:\n " + result["message"].replace("\\n", "\n").replace("\\r", ""))
	if result["value"] == None:
		return None;
	else:
		return float(result["value"])

def setValue(sensorId, sensorValue):
	if sensorValue == None:
		sensorValue = "null"
	params=dict(id=sensorId, action="Set", value=sensorValue)
	resp = requests.post(url=url + "/Sensor", params = params, timeout=10);
	result = json.loads(resp.text)
	if result["result"] != "ok":
		raise Exception("Server returned error:\n " + result["message"].replace("\\n", "\n").replace("\\r", ""))

def main():
	params = dict()

	print("Fetching all sensor ids:")
	resp = requests.get(url=url + "/data.json", params=params, timeout=10)
	data = json.loads(resp.text)
	sensors = findSensors(data)

	for key, value in sensors.items():
		v = getValue(key)
		print(key, ":", v);

	# Change the id to one of yours 
	print("Setting GPU Fan to full speed!")
	setValue("/nvidiagpu/0/control/0", "100.0")
	time.sleep(10);
	print("Returning GPU Fan speed to default")
	setValue("/nvidiagpu/0/control/0", None)


if __name__ == '__main__':
    main()
```

`LibreHardwareMonitor/TestScripts/basicwmi.py`:

```py
################################################################
# Install:
# * python.exe -m pip install pypiwin32
# * python.exe -m pip install wmi
#
# Usage:
# * !! Make sure librehardwaremonitor is running !!
# * python basicwmi.py
################################################################

import wmi

hwmon = wmi.WMI(namespace="root\LibreHardwareMonitor")
sensors = hwmon.Sensor(SensorType="Control")

for s in sensors:
	print s

```

`LibreHardwareMonitor/UI/AboutBox.Designer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.UI
{
    sealed partial class AboutBox
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AboutBox));
            this.okButton = new System.Windows.Forms.Button();
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.projectLinkLabel = new System.Windows.Forms.LinkLabel();
            this.flowLayoutPanel1 = new System.Windows.Forms.FlowLayoutPanel();
            this.licenseLinkLabel = new System.Windows.Forms.LinkLabel();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            this.SuspendLayout();
            //
            // okButton
            //
            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.okButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.okButton.Location = new System.Drawing.Point(269, 79);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(75, 23);
            this.okButton.TabIndex = 0;
            this.okButton.Text = "OK";
            this.okButton.UseVisualStyleBackColor = true;
            //
            // pictureBox1
            //
            this.pictureBox1.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox1.Image")));
            this.pictureBox1.Location = new System.Drawing.Point(10, 11);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(48, 48);
            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
            this.pictureBox1.TabIndex = 1;
            this.pictureBox1.TabStop = false;
            //
            // label1
            //
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(74, 12);
            this.label1.Margin = new System.Windows.Forms.Padding(10, 0, 10, 0);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(117, 13);
            this.label1.TabIndex = 2;
            this.label1.Text = "Libre Hardware Monitor";
            //
            // label2
            //
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(74, 46);
            this.label2.Margin = new System.Windows.Forms.Padding(10, 0, 10, 0);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(250, 13);
            this.label2.TabIndex = 3;
            this.label2.Text = "Copyright © LibreHardwareMonitor and Contributors";
            //
            // label3
            //
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(74, 29);
            this.label3.Margin = new System.Windows.Forms.Padding(10, 0, 10, 0);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(127, 13);
            this.label3.TabIndex = 4;
            this.label3.Text = "Version 9.0.30729.1 Beta";
            //
            // projectLinkLabel
            //
            this.projectLinkLabel.AutoSize = true;
            this.projectLinkLabel.Location = new System.Drawing.Point(164, 80);
            this.projectLinkLabel.Margin = new System.Windows.Forms.Padding(0);
            this.projectLinkLabel.Name = "projectLinkLabel";
            this.projectLinkLabel.Size = new System.Drawing.Size(82, 13);
            this.projectLinkLabel.TabIndex = 6;
            this.projectLinkLabel.TabStop = true;
            this.projectLinkLabel.Text = "Project Website";
            this.projectLinkLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.LinkLabel_LinkClicked);
            //
            // flowLayoutPanel1
            //
            this.flowLayoutPanel1.AutoSize = true;
            this.flowLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.flowLayoutPanel1.Location = new System.Drawing.Point(10, 100);
            this.flowLayoutPanel1.Margin = new System.Windows.Forms.Padding(10, 0, 10, 0);
            this.flowLayoutPanel1.Name = "flowLayoutPanel1";
            this.flowLayoutPanel1.Size = new System.Drawing.Size(0, 0);
            this.flowLayoutPanel1.TabIndex = 8;
            //
            // licenseLinkLabel
            //
            this.licenseLinkLabel.AutoSize = true;
            this.licenseLinkLabel.Location = new System.Drawing.Point(25, 80);
            this.licenseLinkLabel.Margin = new System.Windows.Forms.Padding(0);
            this.licenseLinkLabel.Name = "licenseLinkLabel";
            this.licenseLinkLabel.Size = new System.Drawing.Size(107, 13);
            this.licenseLinkLabel.TabIndex = 9;
            this.licenseLinkLabel.TabStop = true;
            this.licenseLinkLabel.Text = "Licensing Information";
            this.licenseLinkLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.LinkLabel_LinkClicked);
            //
            // AboutBox
            //
            this.AcceptButton = this.okButton;
            this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
            this.AutoSize = true;
            this.ClientSize = new System.Drawing.Size(359, 115);
            this.Controls.Add(this.licenseLinkLabel);
            this.Controls.Add(this.flowLayoutPanel1);
            this.Controls.Add(this.projectLinkLabel);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.pictureBox1);
            this.Controls.Add(this.okButton);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "AboutBox";
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "About";
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.PictureBox pictureBox1;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.LinkLabel projectLinkLabel;
        private System.Windows.Forms.FlowLayoutPanel flowLayoutPanel1;
        private System.Windows.Forms.LinkLabel licenseLinkLabel;
    }
}

```

`LibreHardwareMonitor/UI/AboutBox.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Diagnostics;
using System.Drawing;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI;

public sealed partial class AboutBox : Form
{
    public AboutBox()
    {
        InitializeComponent();
        Font = SystemFonts.MessageBoxFont;
        label3.Text = "Version " + Application.ProductVersion;
        projectLinkLabel.Links.Remove(projectLinkLabel.Links[0]);
        projectLinkLabel.Links.Add(0, projectLinkLabel.Text.Length, "https://github.com/LibreHardwareMonitor/LibreHardwareMonitor");
        licenseLinkLabel.Links.Remove(licenseLinkLabel.Links[0]);
        licenseLinkLabel.Links.Add(0, licenseLinkLabel.Text.Length, "https://www.mozilla.org/en-US/MPL/2.0/");
    }

    private void LinkLabel_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
    {
        try
        {
            Process.Start(new ProcessStartInfo(e.Link.LinkData.ToString()));
        }
        catch { }
    }
}
```

`LibreHardwareMonitor/UI/AboutBox.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="pictureBox1.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAADUJJREFUaEPtWelTVHcWzcyXVBJjkkoqCbJDd9PdNCICouyiuAAKhB3BFZhMLOO+
        ILIoKq6AIIsYMSK474q4BEzUiRInJho1FZNUjeZL/os799zfe90NMpPumi/WVF7VrddU093n3Hvu8rvv
        lT+vP68/r//Dq6WllZqamtmaqKGxgXbv3k3bt2+nrXV1tGXLFqrdtImqa6ppw4ZKKi9fT2vWrKFVq1bR
        ihUraOmyZbR48WL6+OOPqbSslBaVLKIFCxbQvLlzqaioiPLz8yknO4c++iiLMjIyaNasWZSamkozZsyg
        KVOn0OTJkykhIYFi42Jp0qRJNGHCBBo/fjyFhYURQ/uLZv/9AvCcnGy2HLlnZWXxD35EmZmZlJ6eTrNn
        z5YfTktL4x9PoZkzU9lmCojp06ZRcnIyTZmig0mk+Ph4iouPo9jYWIqOjhZgEydOFHDhEeEUxgDHjRtH
        oaGhNHbsWAoJCRGzWILJZLKQwRgk7zG00Wyj2F5l+yvbyFdzczPl5eWxtwoojz2G17m5uUJIEcl4gUhK
        iiIxffp0msYkpiZPpaSkJErUPBrPFhcHEjFCQghERVFkRASFh4ezl8MoVCMREjKWbLYQMjOBE/UfkpEJ
        gNDrr78+/o033rC99tprYxgmSIx8gQDAFxYWUkFBgYQ9l0lkMwFEA5HISNdJaJHQCCAKQmAqCDhFISGe
        4p0IIApRE6MoIjLSTkCPAgi01HxA5qAQjkAwGQ1mCg4OJgaf9+abb6aBBMNEJEaWEyQE8HPmzJF7PpOQ
        KOTkUnZ2NmVyFEBgaARSaMZMlpAeASHAEUhMVBGAjJhATEyMQ0IcgQh7BBwystlCKdg6loLMIRIBU5CZ
        LGYLjRo1qmT06NF5b7311niGCTmNTKCxoZHBF1NRcbGQsEeBZZSVzRFgAvD+LCaQmpaqwIv+p1PyVNY/
        A09iz48EPloDH8X6j7R7XyVp6LhQLQKhEoEgs43BW8jIeRAUFAQCZUyggAmEM8z/TKC+vp6K5hbRXFQO
        PQrIBRDIAvjZlMKVA94e6mkGyokKoLEAOyxhIyMiKSJceRyAdY/DkLxyD0UScw6w5s3WYGrdyERMZpaS
        yXUCu3btouLiuYpAkR4FLn9MALLJzculo0ePUk9PD3V3d1NXVxd9/vnn9Nlnn1F7ezshhxoa6qX0btm8
        hWpqamhDRYWU2+UrltOSJUuorOxvtHDhQv6dYnEQSNlCbBTiXIWsKgIGUxAZDAbXCezcuZPmzpsntRs/
        AAJIaug/n3MB12+//UY//PADfffdd/TNN9/QnTv/oJtffUU3Bm7Q1atXqbe3l86dO0enTp+iY0eOCMnO
        A520b98+2tu8lxobGwm/s3XrVtq4cSP3lA0soTCysddtNptUIatTBAICAlwnAM/Nnz+f5jEJREERyJfG
        c/z4cfr999/pyZMnTOChELh37x59/fXXdPPmTRoYGBACly5dEgInT52iIxytrq5DdODAAXuE6rUIbd68
        mWqqq6mCI5TKuWQ2q4oDEiBgtVhZ/xby9fV1ncC2bdteIJCXly9JC+k8e/aMnv70lB4/fkzff/89ffvt
        t3Tn7l26desW3bgxQNeuXVMROH+OTnMEjh4DAY5ApxaBvZBYA+3YscMuscrKKqlepiCTgLYGK7NYLELK
        x8fbdQJ1dVuGEmCNIoFRLo+wHJ49f0Y///yzROHBgwdCYJAJ3L59mwncoOvXr1Pv5V46f/48EzhNx44d
        o8OHDzsR2OsgwKOJEKiqlGKAZAVgALdaHQS8vLxcJ4CwDieAEoqZBYn7/Plz+uWXX+jJj0zg4QO6fx8E
        BoXAl18ygWvX6XLvZTuBo0ygaxiBRiGwkwlsFQJVVVVcyRK46xq5fCoCFicCnp6e7hCotRNANUKVwBiB
        bqsIqAg8dorAXURAJHSDrl1XEhoaAWcJ6REAAT0CVTIrodqg5g8hwI1sjIeH6wQ28bSJKgTvF3MZLShU
        FShlZooQ+Bdy4OlP9EjPgX9yDty5IzkwwFXIngOcxJIDksRdnMSd1M4EmkeSUGWl9AxDYKAioEeBLYjt
        ww8+dJ0AvhDgYRiB0YkxA2HWQd3/9ddfWT4/0sOHI1Whfrp65Yq9Cp3SqtChQ85VqInQLO1ViEdzSAjN
        zhCoIqDngW7vv/++6wSquayh/ksPQAJzCcUUqhN4+vQpPXr0yF6BBgdVAvf397P2lXQAHNLplvqvgMPa
        2trknLGbCWzbvo1qa2sJv4cIYC4K1CLgTACv3333XWLgrhGAHuH5ojnwPicwNy9MoJh3ICG9+ty/f5+b
        mO79W9THngfwo8dZMlrSQjr4zMGDB2l/x35qbW2hxj17aBcfkuq4XEOu8D4aGSZSRcBRiSAls8VM77zz
        jusE8GWFTjNQbm6ONDHMPogApAPwkA60f/v2La4+X0oDO3/hgpa4xwU4Roz9+/dTW2sbdegJPKwLw/to
        ZJiNQAClFJXILN5XEXj77bddJ1BRsZ4KWffQPsboHE7g9Ix0aTRdh7rU+HCPx4e7AH+bvuIRYqB/gC5f
        vkxnz56lkydP2BNXrzwtLS0CHkdV6N85geGw9eXrFIEARQCVxwoSYkEA7zqB8vJyNX3iDGCfQBUBSAHg
        IRt4XoHvl8pz8eJFh/Z7uh3eZ91jfID2G/c0yhkb3V7pv4oq1q+ndevWyYkMM48REdDyAPcgJsPAXSew
        bu06AQ6TAwzrH1PoVJ71MXEC/C2uOJBNP1cd1P2+vj6pOpiV0K0RKVQdZ++rKbXhBfkA/Jq1a2ScDgzw
        l2ZmAgEGDvAg4RYBfJk60A/dHmD27+jokHKJmeeLL76ga6z7PpYOvA/tAzya1kGWTod4v5WaMLyxbHbX
        71be5/JZW7tZqg+0j99btXq1EPD3BwGDygMGbuJRGvORWwRW85dlc91X518cHdNlDsKsAjlg4oRk+q70
        ScO6wImrmtYZOnXiJNd9NT5L5dESGPLBBIruK97ftJGrD9Yy5bKSWblypYqAf6B0YyEA8HyHuUUAXwjZ
        ZGY41ijYOoAA5HCFy2UvzzrwOmo+EhfeP3FCyeewBl4/4OiVBwclh/Z176+VfRIslE9jiAAIIA8AHHej
        0U0C8AaA65bG8kETm5w4WTx56ZJqVucY+JkzZ7jqnBTt9/Q4PC/g97Uz4b20h+u+vhxD5dG1r3t/2bJl
        QgDHSj+dAPKAgQM8XrtFYPny5eL1dDZ964AmhnMvTlJnRS6n5bAC4HK85P5wiA8tzp5HtJoYvF42IR29
        caHy6EfMpUuXagQ4B/z8pRcYNRK4G9wlgPUggDuvTNDEEuITBIzuccw43d094nWUzM7OA6J5JZsW8Tz+
        fyeDr6urs0sHdX8tSweRBnidAHLAz99PCBgMRomEbm4RWPLpp5TGsz9WJjgDQD7oAVhQ7dq5S7SPA4oD
        eKd4fV/HPklYaH4P13sBzyVTB19TrZoWyuaqVatFOgCPe2lpqTQy9AFFQAPPw12gIdA9AosXLxGvw/Rt
        W3LyNJEQEnlwcFCi0Mly0cGjvKJCCXjOE9R7JO2OHdtoa91WRUDruiCwkrUPqcLzAD87fbaUTSHAgAEe
        RMS4MrlF4JNP/s6SwZYNu072PssnmXsA1oQ4dGD/U1lRSSi38B620aUlpXwAmi/zUy73D1QxyA/SU5+L
        l1Ui1ifwtBhLBvewcWEKPCfwUO8HMqFAqUxuEcBqPDl5BrXXGihpCoNPni7bZixqsaSNiY6R2R3LKdkm
        22yyx8EmARsFi9UxBuvjABqSSkqlbXgZcw88HhCoyYblogPXve/P7/v5+blHoKysjKUyjc63eVDzRiN7
        cBqbY9OMNWF0jNowR04Yuh6ER5GMMJDT1+UgFqwdETEegJDBYGKwJgZqZDJsfA8IMChj2fj5M3hff1mp
        uEUAmkxk0Odax9DpvZ7UXGOguPgkSWJUIuw6nXf9UVFRNCFywpBFrU4GMtHJ6FGyMpl5OX5UnOVLxdls
        WX5UxK+LMpXNyfShORkwb/L18WUSbhIoKSmh2LgkOtsyhk42eQmJpmoDxcQmMngmEAcC2rLWaf8ZFaUW
        tsOJ6Ht/kMDO02q18ayP1bmVZWVhOSF5zSwXE8vFSD6+BvLyCSQv7wDy9vYVEm4RWLRoEXt8Ml1sH8NR
        8JRIXGgbQ62bAlg+atOMCLxIgCPBueEggCXueBoX5pAVdp8LcgNoXra/mETBKQLieY5AIXu/IN2L//Yi
        H3cJLFi4UKpGTGwCaz1RbFI0v45m7bMJcM4BJPNwApEgMGxtHqY9vICh22L7HIwomNXa0GgySz4gB/xZ
        /9C+j48fecO8/dwngK0xzsQoiXkYqbWnMhgvsBtCabQ/A2NJIRqTJkWLfABagIpUrDKQobqgFPr4+JCX
        pyd5eHjQe++9p59zBdwfGf7PZQJ84Y3R2jOpPL6XsJU5G1Yc/6sBkDvGn3HtCQ1feGMUnkXhmRQ+BOYv
        gbn2jEy7XmVPe+CfwZgt/CUw155Saheew+KfwBThelnsj58TD7sQppfNtOuVV/4NcZaFCnU4CO8AAAAA
        SUVORK5CYII=
</value>
  </data>
</root>
```

`LibreHardwareMonitor/UI/AuthForm.Designer.cs`:

```cs
namespace LibreHardwareMonitor.UI
{
    partial class AuthForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AuthForm));
            this.enableHTTPAuthCheckBox = new System.Windows.Forms.CheckBox();
            this.httpAuthUsernameTextBox = new System.Windows.Forms.TextBox();
            this.httpAuthPasswordTextBox = new System.Windows.Forms.TextBox();
            this.httpUsernameLabel = new System.Windows.Forms.Label();
            this.httpPasswordLabel = new System.Windows.Forms.Label();
            this.credentialsGroupBox = new System.Windows.Forms.GroupBox();
            this.httpAuthCancelButton = new System.Windows.Forms.Button();
            this.httpAuthOkButton = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.credentialsGroupBox.SuspendLayout();
            this.SuspendLayout();
            // 
            // enableHTTPAuthCheckBox
            // 
            this.enableHTTPAuthCheckBox.AutoSize = true;
            this.enableHTTPAuthCheckBox.Location = new System.Drawing.Point(12, 12);
            this.enableHTTPAuthCheckBox.Name = "enableHTTPAuthCheckBox";
            this.enableHTTPAuthCheckBox.Size = new System.Drawing.Size(191, 17);
            this.enableHTTPAuthCheckBox.TabIndex = 0;
            this.enableHTTPAuthCheckBox.Text = "Enable HTTP Basic Authentication";
            this.enableHTTPAuthCheckBox.UseVisualStyleBackColor = true;
            this.enableHTTPAuthCheckBox.CheckedChanged += new System.EventHandler(this.EnableHTTPAuthCheckBox_CheckedChanged);
            // 
            // httpAuthUsernameTextBox
            // 
            this.httpAuthUsernameTextBox.Location = new System.Drawing.Point(102, 23);
            this.httpAuthUsernameTextBox.MaxLength = 255;
            this.httpAuthUsernameTextBox.Name = "httpAuthUsernameTextBox";
            this.httpAuthUsernameTextBox.Size = new System.Drawing.Size(171, 20);
            this.httpAuthUsernameTextBox.TabIndex = 1;
            // 
            // httpAuthPasswordTextBox
            // 
            this.httpAuthPasswordTextBox.Location = new System.Drawing.Point(102, 60);
            this.httpAuthPasswordTextBox.MaxLength = 255;
            this.httpAuthPasswordTextBox.Name = "httpAuthPasswordTextBox";
            this.httpAuthPasswordTextBox.PasswordChar = '*';
            this.httpAuthPasswordTextBox.Size = new System.Drawing.Size(171, 20);
            this.httpAuthPasswordTextBox.TabIndex = 2;
            this.httpAuthPasswordTextBox.UseSystemPasswordChar = true;
            // 
            // httpUsernameLabel
            // 
            this.httpUsernameLabel.AutoSize = true;
            this.httpUsernameLabel.Location = new System.Drawing.Point(6, 26);
            this.httpUsernameLabel.Name = "httpUsernameLabel";
            this.httpUsernameLabel.Size = new System.Drawing.Size(90, 13);
            this.httpUsernameLabel.TabIndex = 6;
            this.httpUsernameLabel.Text = "HTTP UserName:";
            // 
            // httpPasswordLabel
            // 
            this.httpPasswordLabel.AutoSize = true;
            this.httpPasswordLabel.Location = new System.Drawing.Point(6, 63);
            this.httpPasswordLabel.Name = "httpPasswordLabel";
            this.httpPasswordLabel.Size = new System.Drawing.Size(88, 13);
            this.httpPasswordLabel.TabIndex = 7;
            this.httpPasswordLabel.Text = "HTTP Password:";
            // 
            // credentialsGroupBox
            // 
            this.credentialsGroupBox.Controls.Add(this.httpAuthUsernameTextBox);
            this.credentialsGroupBox.Controls.Add(this.httpPasswordLabel);
            this.credentialsGroupBox.Controls.Add(this.httpAuthPasswordTextBox);
            this.credentialsGroupBox.Controls.Add(this.httpUsernameLabel);
            this.credentialsGroupBox.Location = new System.Drawing.Point(12, 35);
            this.credentialsGroupBox.Name = "credentialsGroupBox";
            this.credentialsGroupBox.Size = new System.Drawing.Size(279, 100);
            this.credentialsGroupBox.TabIndex = 5;
            this.credentialsGroupBox.TabStop = false;
            this.credentialsGroupBox.Text = "Credentials";
            // 
            // httpAuthCancelButton
            // 
            this.httpAuthCancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.httpAuthCancelButton.Location = new System.Drawing.Point(76, 206);
            this.httpAuthCancelButton.Name = "httpAuthCancelButton";
            this.httpAuthCancelButton.Size = new System.Drawing.Size(75, 23);
            this.httpAuthCancelButton.TabIndex = 3;
            this.httpAuthCancelButton.Text = "Cancel";
            this.httpAuthCancelButton.UseVisualStyleBackColor = true;
            this.httpAuthCancelButton.Click += new System.EventHandler(this.HttpAuthCancelButton_Click);
            // 
            // httpAuthOkButton
            // 
            this.httpAuthOkButton.Location = new System.Drawing.Point(157, 206);
            this.httpAuthOkButton.Name = "httpAuthOkButton";
            this.httpAuthOkButton.Size = new System.Drawing.Size(75, 23);
            this.httpAuthOkButton.TabIndex = 4;
            this.httpAuthOkButton.Text = "OK";
            this.httpAuthOkButton.UseVisualStyleBackColor = true;
            this.httpAuthOkButton.Click += new System.EventHandler(this.HttpAuthOkButton_Click);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(12, 138);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(269, 26);
            this.label1.TabIndex = 8;
            this.label1.Text = "Password is stored hashed, if you forget it you will need \r\nto set a new one.";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(12, 174);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(284, 26);
            this.label2.TabIndex = 9;
            this.label2.Text = "If the web server is running then it will need to be restarted \r\nfor the change t" +
    "o take effect.";
            // 
            // AuthForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.httpAuthCancelButton;
            this.ClientSize = new System.Drawing.Size(305, 241);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.httpAuthOkButton);
            this.Controls.Add(this.httpAuthCancelButton);
            this.Controls.Add(this.credentialsGroupBox);
            this.Controls.Add(this.enableHTTPAuthCheckBox);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "AuthForm";
            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Set HTTP Credentials";
            this.Load += new System.EventHandler(this.AuthForm_Load);
            this.credentialsGroupBox.ResumeLayout(false);
            this.credentialsGroupBox.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.CheckBox enableHTTPAuthCheckBox;
        private System.Windows.Forms.TextBox httpAuthUsernameTextBox;
        private System.Windows.Forms.TextBox httpAuthPasswordTextBox;
        private System.Windows.Forms.Label httpUsernameLabel;
        private System.Windows.Forms.Label httpPasswordLabel;
        private System.Windows.Forms.GroupBox credentialsGroupBox;
        private System.Windows.Forms.Button httpAuthCancelButton;
        private System.Windows.Forms.Button httpAuthOkButton;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
    }
}
```

`LibreHardwareMonitor/UI/AuthForm.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI;

public partial class AuthForm : Form
{
    private readonly MainForm _parent;

    public AuthForm(MainForm m)
    {
        InitializeComponent();
        _parent = m;
    }

    private void AuthForm_Load(object sender, EventArgs e)
    {
        httpAuthUsernameTextBox.Enabled = httpAuthPasswordTextBox.Enabled = enableHTTPAuthCheckBox.Checked = _parent.Server.AuthEnabled;
        httpAuthUsernameTextBox.Text = _parent.Server.UserName;
    }

    private void HttpAuthCancelButton_Click(object sender, EventArgs e)
    {
        Close();
    }

    private void HttpAuthOkButton_Click(object sender, EventArgs e)
    {
        _parent.Server.UserName = httpAuthUsernameTextBox.Text;
        _parent.Server.Password = httpAuthPasswordTextBox.Text;
        _parent.Server.AuthEnabled = enableHTTPAuthCheckBox.Checked;
        _parent.AuthWebServerMenuItemChecked = _parent.Server.AuthEnabled;
        Close();
    }

    private void EnableHTTPAuthCheckBox_CheckedChanged(object sender, EventArgs e)
    {
        httpAuthUsernameTextBox.Enabled = httpAuthPasswordTextBox.Enabled = enableHTTPAuthCheckBox.Checked;
    }
}
```

`LibreHardwareMonitor/UI/AuthForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAMAEBAAAAEAIABoBAAANgAAACAgAAABACAAqBAAAJ4EAAAwMAAAAQAgAKglAABGFQAAKAAAABAA
        AAAgAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEU8OykuDgdIIxQSURwdHU8ZGhpPFhYWTxQU
        FE8SEhJPDxAPTw0KCk8KBQRPCAQDTwcDAU8HAQBPBgQEUQUFBTxLVVb/L215/zdXXP89Ozv/ODc3/zM0
        M/8vLy//Kioq/yYlJf8iJif/Gycp/xggI/8UHiD/Eh4g/w4SE/8GBARRQWRr/xGXtP8yUln/NDIx/y4u
        Lf8qKir/KSgo/ycnJ/8lJCP/Iikq/xs4Pf8aOD7/GzpB/xo4Pf8SGhv/BwMDT01aXP46Ulj+Pzc0/kdH
        R/5MTU3+Q0ND/jw8PP43Nzf+Ly8v/igoKP4lKCn+Iico/hwiI/4cHyD/FBMU/wYHBk9XVVX+Rj8+/klJ
        Sf6ioqL+rq+u/p+fn/6YmJj+j4+P/oSEhP56enr+dXJy/mNgYP4iHx7+Gxka/xUVFf8HBwdPW1pa/kVF
        RP5YWFj+rq6u/r6+vv6wsK/+qamp/qCgoP6UlJT+iYmJ/oGBgf5xcXH+JCQk/hsbG/8WFhb/BwcHT15e
        Xv5ISEj+Wlpa/rW1tf7Gxsb+tra2/qysq/6hoaL+lpaW/oyMjP6EhIT+cnJy/iQkJP4cHBz/GBgY/wcH
        B09jY2P+TUxM/l5eXv7AwMD+0dHR/r6+vv6vr6/+o6Ok/pmYmf6Rk5P+iouK/nd4d/4lJSX+HR0d/xkZ
        Gf8HBwdPZ2dn/lBQUP5iYmL+ysrK/tzc3P7Hxsf+tbS1/qmpqf6fn5/+mJiY/o6Pj/57e3z+JSUm/h4e
        Hv8aGhr/CAgIT2tra/5TU1P+ZGRk/tLS0v7j5eP+zMzM/ry8vP6wsLD+pqam/pubm/6TkZH+f39//igo
        KP4fHx7/HBwc/wkJCk9ubm7+VlVW/mZlZv7X1tf+6Ojo/tPS0/7Hx8f+urq6/qurq/6dnp7+lJSU/oGB
        gP4sLCz+Hx4e/x4dHP8LCwtPb29v/lZWVv5nZ2j+4eHh/vLx8v7Z2dn+zc3N/sDAwP6wsrL+pKOk/pmZ
        mf6Ghob+MDAw/h8gH/8eHx//DQsNT29vb/5YWFj+WVpa/sHBwf7V1dX+wMC//rW1tP6pqan+m5ub/o6P
        jv6FhYX+cXFx/i4qKv4gLC7/Hiot/w4JB09vb3D+Wlla/lJSUf5VVVX+YGBg/ltbWv5VVVP+Tk5O/kdH
        R/5BQUH+Ozs6/jAvL/4oKCj+Izk9/x8tL/8QCQhRbm5u/lVVVf5SUlL+S0tL/kRERP5BQUH+PT09/jk5
        Of41NTX+MzIy/i8vLv4sKSj+Jy4v/h9DTP8iLjH/Ew0KSHp7ev5qamr+ZWVl/mFhYv5cXFz+WFhY/lNS
        U/5NTU3+R0ZH/kJCQv49PDz+NzU1/jAxMf4qMTL/Jigp/x4cHCn//wAAAAEAAAABAAAAAQAAAAEAAAAB
        AAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAKAAAACAAAABAAAAAAQAgAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMBBwcHAwYGBgQGBgYEBgYGBAYG
        BgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYG
        BgQGBgYEBgYGBAYGBgQGBgYEBwcHAwUFBQIAAAAAAAAAAAAAAAAAAAAAAAAAAAoKCgkMDAwgDQ0NKg0N
        DSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0N
        DSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoMDAwlCgoKEQUFBQIAAAAAAAAAAAAAAAAAAAAACAgIFAoK
        CkcMDAxbDAwMXAwMDFwMDAxcDAwMXAwNDFwNDQ1cDQ0NXA0NDVwNDQ1cDQ0NXA0NDVwNDQ5cDg4OXA4O
        DlwODg5cDg4OXA4ODlwODg5cDg4OXA4ODlwODg5cDg4OWw0NDVIMDAwlBwcHAwAAAAAAAAAAAAAAAGFh
        YY9ZWFjFUVBP0kpJSdhIR0fYQkJC2D0+Ptg5OTnZODc22TMyM9kuLi/ZKysr2SYmJtkjIyPZICAf2Rsb
        G9kXFxjZExMT2Q8ODtkNDAzZDQwM2A0MDNgNDAzYDQ0N2A0NDdgODQ27Dg4OWw0NDSoGBgYEAAAAAAAA
        AAAAAAAAYmFhvzxCQ/82Uln/NlJZ/zdPVP89PDz/PDw8/zo6Ov85OTn/ODg4/zY2Nv80NDT/NDQ0/zIy
        Mv8xMTD/Ly4w/yw1OP8qNjj/JzQ1/yYyNP8kMDL/Ii4w/x8sLv8fKy3/HyIi/w0NDdgODg5cDQ0NKgYG
        BgQAAAAAAAAAAAAAAABjY2K/OFRa/xqXsv8bk6v/M11l/z49Pf89PT3/Ozs7/zo6Of83Nzj/NTY1/zQ0
        NP8zMzP/MTEw/y8vL/8uLi7/KzQ2/yk1Nv8nMjT/JjAz/yQvMf8jLjD/ISwu/x8rLf8fISL/DQ0N2A4O
        DlwNDQ0qBgYGBAAAAAAAAAAAAAAAAGZkZL86V13/GpKs/zJkbv9BPz//Pj8+/zw8PP85OTn/Njc2/zQ0
        Nf8zMjP/MjIy/zAwMP8vLy//Li4u/y0sLP8qKSn/I0hQ/yJHUP8hRk//IEZO/yBGTv8fRU3/HztB/yAf
        H/8NDQ3YDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAaWdovz5WW/83YWr/RkND/0FAQP89PT3/ODc3/zIy
        Mf8uLi7/LCws/ysrK/8pKSn/Kioq/ygoKP8nJyf/JSUl/yUkJP8kIyP/IyEh/yMiIv8kIiL/JCMj/yQj
        I/8iISH/ISAg/w0NDdgODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAABqamq/SUhI/0hHR/9GRkb/QUFB/0ZH
        Rv9/f4D/gICA/3h4eP9xcXH/a2tr/2RkZP9dXV7/V1dX/09PT/9ISEj/Q0NC/0BAQP9AQED/Ozs7/yYm
        Jv8jIyP/JCQk/yMjI/8jIyH/DQ0N2A4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAG5ubr9LS0v/SkpL/0hI
        SP9BQUH/i4uL/6ysrP+hoqH/n5+e/52bnf+YmJj/lJSU/5CQj/+Li4v/hYaF/4CAgP97e3r/dXR1/3Fx
        cf9ra2v/Ozs7/yEhIv8kJCT/JCQk/yQkI/8NDQ3YDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAcHBwv01N
        Tf9MTU3/SUpK/0BAP/+Wlpj/q6ur/6inp/+kpKT/oKGg/52cnP+YmJj/k5OT/46Ojv+IiYj/g4OC/319
        ff93d3f/cXFx/3Fxcf8/Pz//ISEh/yQkJP8lJSX/JSQk/w0NDdkODg5cDQ0NKgYGBgQAAAAAAAAAAAAA
        AABycnO/T05P/05PT/9MTEz/QUFB/5ubmv+ysrL/rq6u/6urq/+np6f/oqKi/52dnf+ZmZn/k5OT/42O
        jv+IiIf/gYGB/3x7fP90dXT/cXFx/z8/P/8hISH/JCQl/yUlJf8lJib/DQ0N2Q4ODlwNDQ0qBgYGBAAA
        AAAAAAAAAAAAAHR1db9RUVH/UFBQ/01NTf9CQkL/np6e/7i4uP+0s7T/sbGx/62trf+oqKj/o6Oj/52d
        nf+Yl5f/kZKR/4yMi/+FhYX/fn9//3h4eP9zc3P/Pz8//yIiIv8lJSX/JiYm/yYmJv8NDQ3ZDg4OXA0N
        DSoGBgYEAAAAAAAAAAAAAAAAdnZ2v1RUVP9TU1P/T09P/0VFRf+kpKT/v7+//7u7u/+2trb/sbGx/6mp
        qf+jo6P/nZ2d/5eXl/+QkZH/jo2N/4mJif+CgoL/fHx8/3d3d/9AQED/IiIi/yYmJv8nJyf/Jycn/w0N
        DdkODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAAB4eHi/V1dW/1VVVf9QUFD/RkZG/6moqf/Gxsb/wcHB/7y8
        vP+2trb/q6ys/6Wlpf+fn5//mZiY/5WUlf+RkpL/jI2M/4WFhf9/fn//enp6/0FBQf8iIiP/JiYm/ygn
        KP8oJyf/DQ0N2Q4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAHp6er9YWVn/V1dX/1JSU/9ISEj/ra2t/8zM
        zP/Gxsb/wcHB/7u7u/+wsLD/qamp/6Ojo/+cnZ3/lpaW/5OTk/+Pj47/iIiI/4CBgP98fH3/QkJC/yMj
        I/8nJyf/KCgo/ygoKP8ODg7ZDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAfXx9v1tbW/9ZWVn/VFVV/0hJ
        Sf+xsbH/0tLS/8vLy//FxcX/v7++/7Ozs/+qqqr/pKWk/6Cfn/+ampr/mpia/5GRkf+Li4r/goOD/35+
        fv9CQ0P/IyQk/ycnJ/8pKSn/KSkp/xAQENkODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAAB+fn6/XV1d/1tb
        W/9WVlb/S0lJ/7Oysv/W1tb/z8/P/8nJyf/CwsL/tbW1/66trf+np6f/oqKi/5ycnP+ZmJn/k5OT/4yM
        jP+FhYX/f39//0ZFRv8kJCT/KCgo/ykpKf8pKSn/EhIS2Q4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAIGB
        gb9eXl7/XFxc/1dYV/9KSkr/tLS0/9rb2v/S0tL/zczM/8XFxf+/v7//uLi4/7Gxsf+rq6r/o6Oj/5yc
        nP+UlZT/jY2N/4aFhv+AgID/SUlI/yMjI/8oKCj/KSkp/ykpKf8UFBTZDg4OXA0NDSoGBgYEAAAAAAAA
        AAAAAAAAg4ODv19fX/9eXl7/WVhZ/0tLS/+0tLT/3d3d/9TU1P/Ozs7/x8bH/8DAwP+5ubn/srKy/6ur
        q/+kpKT/nJyc/5WVlv+Ojo7/h4eH/4GBgf9NTU3/IyQk/ygpKP8qKSn/KSkp/xgYGNkODg5cDQ0NKgYG
        BgQAAAAAAAAAAAAAAACFhYW/YGBf/15eXv9aWln/TU1N/7a2tv/e3t7/1dXV/87Pz//Hx8f/wcHB/7m5
        uv+ysrP/rKyr/6SkpP+dnZ3/lZWW/46Ojv+Hh4f/gYGB/1BQUP8kJCT/KSkp/ykpKf8oKCj/GhkZ2Q4O
        DlwNDQ0qBgYGBAAAAAAAAAAAAAAAAIiGhr9gYGD/Xl5e/1paWv9PT0//t7e3/93d3f/U1NT/zs7O/8fH
        x//AwMD/ubm5/7Kysv+rq6v/o6Ok/5ycnP+VlZX/jo6N/4aGhv+BgYH/U1NT/yYmJv8qKir/Kisq/ygo
        Kf8bHBzYDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAioqKv19fX/9eXl7/Wlta/1FRUf+srKz/4uLi/9LS
        0v/Mzcz/xcXG/7+/v/+4ubj/srKx/6urq/+kpKT/nZ2d/5WVlf+Njo7/h4aH/4GBgf9TUlL/KSkp/yws
        LP8qLzH/Jy4v/x4eHtgNDQ1cDQ0NKgYGBgQAAAAAAAAAAAAAAACMi4y/Xl5e/11dXf9aWlr/VVVV/1xc
        XP+qqqr/sbGx/66urv+qqqr/pKSj/52dnf+VlZX/jo6O/4eHh/+Af3//d3l3/3BwcP9paWn/XFxc/zMz
        M/8sLCz/LS0t/yswMf8nLS7/ICAg2A0NDVwNDQ0qBgYGBAAAAAAAAAAAAAAAAI6Ojr9cXFz/XFxc/1pa
        Wv9WV1f/UFFQ/0xMS/9HR0f/RERE/0BBQP8+Pj7/PDw8/zo7Ov84ODj/ODg4/zU1Nf8zMzP/MTEx/zAw
        MP8uLi//Li4u/y4tL/8qPUD/KDk+/yU4O/8jIiLYDQ0NXA0NDSoGBgYEAAAAAAAAAAAAAAAAkZGRv1pb
        W/9bW1r/WFlY/1ZWVv9UVFT/UFBQ/05OTv9MTEz/SklK/0dHR/9FRUX/QkJC/0BAQP8+Pj7/PDw8/zo6
        Ov83ODf/NTU1/zIyMv8xMTH/Ly4u/yk7P/8oO0D/JTpA/yUkJNgNDQ1bDQ0NKgcHBwQAAAAAAAAAAAAA
        AACTk5O/WFhY/1lZWf9YV1j/VVVV/1JSUv9QUFD/Tk5O/01MTf9KSkr/SEhI/0ZGRv9DQkP/QEFA/z8/
        P/89PT3/Ozs6/zg4OP82NTX/MzMz/zExMf8vLi3/IVtn/yovMf8nLi//KCgo0gwMDEcMDAwgBwcHAwAA
        AAAAAAAAAAAAAJKTkr9VVFX/VFVV/1RUVP9SUVH/T09P/01NTv9MS0z/SkpK/0hJSP9HR0f/REVE/0FB
        Qf8/Pz//Pj4+/zs7PP85Ojn/Nzc3/zQ0NP8xMTH/LzAw/y4uLv8tLCz/KS8w/yUtLv8tLS3FCgoKFAoK
        CgkDAwMBAAAAAAAAAAAAAAAAl5aXj5KSkr+QkJC/jYuLv4eHh7+EhIS/gICAv3x8fL93d3e/dHR0v3Bw
        cL9samy/ZmZmv2NjY79fX1+/W1tbv1VVVb9SUlK/Tk5Ov0pKSr9ERES/QUFBvz09Pb85OTm/MzMzvzEx
        MY8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////////gAAAH4AAAB+AA
        AAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AA
        AAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB////////////////ygAAAAwAAAAYAAAAAEA
        IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAACCAgIBwkJCQwICAgOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcH
        Bw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcH
        Bw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOCAgIDgkJCQwICAgHAAAAAgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAICAgHCwsLGQ0NDSwNDQ0yDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0N
        DTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0N
        DTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMg0NDSwLCwsaCAgIBwAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJCQkMDQ0NLA0NDUwODg5XDg4OWQ4ODlkODg5ZDg4OWQ4O
        DlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4O
        DlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OVw0N
        DUwNDQ0sCQkJDAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFBQUOCgoKMgsLC1cLCwtkCwsLZgsL
        C2YLCwtmCwsLZgwMDGYMDAxmDAwMZgwMDGYMDAxmDAwMZgwMDGYMDAxmDAwMZg0NDWYNDQ1mDQ0NZg0N
        DWYNDQ1mDQ0NZg0NDWYNDQ1mDg4OZg4ODmYODg5mDg4OZg4ODmYODg5mDg4OZg4ODmYODg5mDg4OZg4O
        DmYODg5mDg4OZA4ODlcNDQ0yCAgIDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGJiYv9cXFz/Wlpa/1VV
        V/9TU1L/UVFR/05OTv9LSkv/R0dH/0NDQ/9BQUH/Pz4//zw8PP86OTn/NTU1/zIyMv8wMDD/LS0u/yoq
        Kv8mJib/JCMk/yEhIf8eHh7/Gxsc/xkZGf8UFBT/ERER/w8PD/8ODg7/Dg4O/w4ODv8ODg7/Dg4O/w4O
        Dv8ODg7/Dg4O/w4ODv8PDw//Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGJi
        Yf8+PDz/Pzw7/0A7Ov9AOzr/Pzo5/z06Ov89Ojr/Ozs7/zo7Ov87Ojv/Ojo6/zk5Of84ODj/Nzc3/zY2
        Nf81NTT/MzMz/zIyMv8xMTH/MTIx/zAwMP8wMDD/Ly4u/y4tLf8sKiv/Kigo/yknJ/8oJiX/JiQk/yUj
        I/8kIiH/IiEg/yAeHv8gHh3/IB0d/x8eHv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAGNjY/9BPj3/Gpiz/xuWsP8alrD/Gpey/yKClv8+PT3/PT09/zw8PP87Ozv/Ojo6/zk5
        Of84ODj/Nzc3/zY2Nv80NDT/MzMz/zMyMv8yMTH/MDEw/y8vL/8vLy//Li4t/yJWYf8hVF//IVRf/x9T
        Xf8gU13/H1Nc/x9RXP8eUFv/HlFb/x1QWv8cT1n/HFBb/x8eHv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAGRkZP9CPTz/GpWv/xySq/8blK3/JH+S/0A8O/8/Pj7/Pj0+/z08
        PP87Ozv/Ojo6/zk5Of84ODj/Njc3/zU1Nf80NDT/MzMz/zIyMv8xMTH/MDAv/y8vL/8uLi7/LS0s/ywq
        Kv8tKSj/KiYm/yklJf8nJCP/KCIi/yYiIf8lICD/JB8e/yMeHP8iHRz/Hx0d/x8eH/8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGVlZf9GQUD/Gpaw/xuUrf8kgJP/Qj49/0A/
        P/8/Pj//Pj4+/zw8PP86Ojr/OTk5/zc3N/82NTb/NDQ0/zMzM/8yMjL/MTEx/zAwMP8vLzD/Ly8v/y4u
        Lv8tLS3/LCws/ysrKv8gVV//H1Nd/x9UXf8gU13/H1Nc/x9RXP8fUVz/HlFb/x5QW/8dUFv/Hx4f/x8f
        IP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGZmZv9GQkL/GZex/yWB
        k/9GQUH/QkFB/0FBQP8/Pz//PT09/zo7Ov84ODj/NTY1/zMzM/8yMjL/MTEx/zAwMP8vLy//Ly8v/y4u
        Lv8uLi7/LS0t/ysrK/8qKiv/KSkp/ygnJ/8nJib/JiQk/yYjJP8lIyP/JSIj/yUjI/8kIiL/JCIi/yMh
        Iv8iISD/IR8g/x8fH/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGho
        aP9IRUX/JIOY/0dDQv9HRUX/Q0ND/0FBQP8/Pz7/Ozo7/zY2Nv8xMTH/Li4u/ywsLf8tLS3/LCws/ysr
        K/8pKin/KSkp/ygoKP8oKCj/Jycn/ycmJv8lJSX/JSQl/yQkJP8jJCP/IyIj/yIiIv8iIyL/IyMj/yQj
        JP8kJCT/IyMk/yMjI/8jIyP/IiIh/yAgIP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAGlqav9IR0f/SUdH/0lHR/9HR0b/RERF/0FBQf88PDz/Pj8//317ff91dXX/cHBw/2tr
        a/9lZGX/YF9f/1paWv9VVVb/UVFR/0xMTP9HR0f/QUFB/z48PP83ODf/MzMz/zAwMP8wMDD/Ly8w/zAw
        MP8xMDH/Jycn/yEhIv8jIyP/JCQk/yQkJP8jIyT/IyIi/yEhIf8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAG1ra/9KSkr/SkpK/0lJSf9ISEj/RkVF/0BAQP9CQkL/ycnJ/6ur
        q/+fn57/np6e/5ycnP+ampr/l5eX/5SUlP+SkpH/j4+P/4yMjP+Iior/hoeG/4ODg/+AgID/fHx8/3h4
        eP90dHP/cXFx/3Jycv9lZWX/Tk9O/ycnJ/8iIiL/IyQj/yQkJP8jIyP/IyMj/yMhI/8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAG5ubf9LS0z/S0xL/0tLS/9JSUn/RkZG/0A/
        P/+Mi4z/s7Oz/6Ojo/+ioqL/oKCg/56env+cnJz/mZqZ/5eWl/+UlJT/kJGR/46Ojv+Li4v/h4eH/4OD
        g/+Af4D/fHx8/3h4eP91dHT/cHBw/29vb/9wcHD/ZWVl/zAwMP8iIiL/IyMj/yQkJP8kJCT/JCMk/yMk
        I/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHBwb/9NTU3/TU1N/0xM
        TP9KSkr/R0dH/z8+P/+Ojo7/q6ur/6mpqf+np6b/paSk/6Kiov+goKD/nZ6e/5ubm/+YmJj/lZSU/5GR
        kf+Ojo7/ioqL/4eHh/+Dg4P/f39//3x8fP93d3f/c3Nz/29vb/9vb2//cnJy/y8vL/8gISD/IyMj/yUk
        JP8kJCT/JCQk/yQkJP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHFx
        cf9OTk7/Tk5P/01NTf9MTEz/SEhI/0BAQP+QkJD/sLCv/62trf+srKv/qamp/6enp/+kpKX/oaKh/5+f
        n/+cnJz/mJiY/5WVlf+RkZL/jo6O/4qKiv+Ghob/goKC/35+fv96env/dnZ2/3Fycf9vb2//cnJy/y8u
        Lv8hICH/IyMj/yQkJf8lJSX/JCQl/yUlJP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAHNzc/9PT0//T09P/09PT/9NTUz/SUlJ/0FAQf+SkpL/tbS0/7Gxsf+vr7D/rq6u/6ur
        q/+pqan/pqWl/6Kiov+fn5//nJyc/5iZmP+UlZX/kZGR/42Njf+JiYn/hYWF/4GBgf99fX3/eXl5/3R0
        dP9wcHD/cnJy/y4uLv8hISD/JCQk/yUlJf8mJSb/JiUl/yUlJf8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAHR0dP9RUVH/UVBR/09PT/9OTk7/S0pK/0JCQv+VlZX/uLi4/7a1
        tf+zs7P/sbGx/6+vr/+tra3/qaqq/6ampv+ioqP/n5+f/5ycnP+YmJj/lJSU/5CQj/+MjIz/iIiI/4OD
        g/9/f3//e3t7/3d3dv9ycnL/cnJy/y4vL/8hISH/JCQk/yYmJf8mJib/JiYl/yYlJf8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHV1df9TU1T/U1NT/1BRUf9PTk7/TExM/0JC
        Qv+Xl5f/vr6+/7q6uv+3uLf/tbW1/7Kysv+wsLD/rq2t/6uqrP+mp6b/oqKi/5+fn/+bm5v/l5aX/5KS
        kv+Oj47/i4qK/4aGhv+BgoH/fX5+/3l5ef90dHT/c3Nz/y8vL/8jISP/JCQk/yYmJv8nJif/JiYm/yYm
        Jv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHZ3dv9VVVX/VVVV/1NS
        Uv9QUFD/TU1N/0RERP+ampr/wsLC/76/v/+8vLz/ubm6/7a2t/+zs7P/ra2t/6ampv+io6P/np6f/5ub
        mv+Wl5f/k5OS/46Ojv+Njo3/jY2N/4mJiP+Eg4P/f39//3t7e/92d3b/dXV0/y8vL/8hISH/JCUl/yYm
        Jv8nJyf/JyYm/yYnJv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHh3
        eP9WVlb/VlZW/1RUVP9RUVH/Tk5O/0VERP+cnJz/xsbG/8LCw//AwMD/vb69/7q7uv+3t7f/sLCw/6mp
        qf+mpqb/oqGi/52dnf+ZmZn/lZWV/5SUlP+Tk5P/j4+P/4uLi/+Ghob/gYGB/319ff94eHj/dnd2/y8v
        L/8hIiP/JSUl/ycnJv8oJyj/KCcn/ycnJ/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAHl5ef9YWFj/V1dX/1ZWVv9SU1P/T09P/0ZGRv+fn5//ysvK/8bGxv/DxMT/wcHB/729
        vv+6urr/s7Oz/6ysrP+oqKj/pKWk/6CgoP+bm5v/l5eX/5OTk/+SkpL/kJGQ/42Njf+IiIj/g4OD/35/
        f/96env/eHh4/zAwL/8iIiL/JiYl/ycnJ/8oKCj/Jycn/ygnJ/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAHp7e/9ZWVr/WVlZ/1dXV/9UVFX/T1BP/0ZGRv+ioaL/z8/P/8rL
        yv/HyMf/xMTE/8HBwf++vb7/tra2/6+vr/+qq6v/p6en/6Kiov+enp7/mZmZ/5WVlf+UlJT/k5KS/46O
        jv+Kior/hYWF/4CAgP98fHz/eHl6/zAwMP8jIiP/JiYm/ygnKP8oKCr/KCgo/ycoKP8PDw//Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHx8fP9bW1r/Wlpa/1hYWP9VVlb/UFBQ/0dH
        R/+kpKT/0tLS/87Ozv/Ly8v/x8fH/8PExP/AwMD/ubm5/7Kysf+tra3/qaio/6Wlpf+goKD/m5ub/5eW
        l/+ZmZr/lJSU/5CQj/+Li4v/hoaG/4GBgf99fX3/e3t7/zAwMP8jIyP/JiYm/ygoJ/8pKSj/KSgo/ygo
        KP8QEBD/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAH5+ff9cXFz/XFtc/1pZ
        Wf9XV1b/UVFR/0hISP+lpaX/1tbW/9HR0f/Ozs7/y8rK/8bGxv/DwsL/uLi3/6ysrP+nqaf/o6Oi/56e
        nv+ioqL/paWl/5+fn/+bmpv/lZaW/5GRkP+NjYz/iIiH/4KCgv9+fn7/fHx8/zEyMv8jIyP/Jicn/ygo
        KP8pKSn/KCgp/ygpKP8RERH/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAH9/
        f/9dXV3/XV1d/1paW/9YWFf/UlJS/0lJSf+kpKT/2tra/9TU1P/Q0ND/zc3N/8jJyf/ExMT/vb29/7W1
        tv+xsbH/rKys/6ioqP+ioqT/nZ2e/5iYmP+YmJj/l5eX/5KSkv+Ojo3/iImI/4ODg/9/f3//fX19/zQ0
        NP8jIyP/Jycn/ygoKP8pKSn/KSkp/ygoKP8TExP/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAICAgP9eXl7/Xl5e/1xcXP9ZWVn/U1NT/0lJSf+kpKT/3d3d/9fX1v/S0tL/z8/P/8vL
        y//Gxsb/wsLC/72+vv+4uLn/tLS0/7CwsP+srKz/p6em/6Ghof+dnZ3/mJiY/5KTk/+Ojo7/iYmJ/4SE
        hP9/gID/fn5+/zY2Nv8kIyT/Jycn/ygoKP8pKSn/KSkp/ykpKf8WFhb/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAIKCgv9fX17/Xl5e/11cXf9ZWln/VFRU/0pJSv+lpaX/4eHg/9na
        2v/V1dT/0NDQ/83Mzf/Hx8f/w8PD/7++vv+6urr/tbW1/7CwsP+sra3/p6en/6Kiov+enZ3/mZmY/5SU
        k/+Pj4//ioqK/4WFhf+AgID/fX19/zk5Of8jIyT/Jycn/ygoKf8pKSn/KSkp/ykpJ/8YFxj/DQ0NZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIOEhP9gYGD/X19f/15dXf9aWlr/VVVV/0tK
        S/+lpaX/4eLi/9vb2//W1tX/0dHR/83Nzf/IyMj/w8PE/7+/v/+6u7r/tbW1/7Gxsf+tra3/qKio/6Kj
        o/+enp7/mZmZ/5SUlP+Pj4//i4qK/4WFhf+AgID/fn59/zw8PP8kJCT/Jycn/ykpKf8qKin/KSkp/ygn
        KP8ZGRr/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAISEhP9gYGD/X19f/15e
        Xv9aWlv/VlZW/0tLS/+lpaX/4uLi/9zc3P/W19b/0dLR/83Ozv/JyMn/xMTE/7/AwP+7urv/trW2/7Gx
        sf+tra3/qKin/6Ojov+enp7/mZmZ/5SUlP+Pj5D/i4qK/4aFhf+AgID/fn5+/z9AQP8lJSX/KCgn/ykp
        Kf8qKin/KSkp/ygoKP8bGxv/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIWH
        h/9gYGD/X19f/15eXv9aWlv/VlZX/0xMTP+mpqb/4eLh/9vb2//W1tb/0dHR/83Nzf/IyMn/xMTE/7+/
        v/+7u7v/tba1/7Gxsf+tra3/qKio/6Ojo/+enp7/mZmZ/5SUlP+Pj4//ioqK/4WFhf+AgID/fX59/0JC
        Qv8mJib/KCgo/ykpKf8qKir/KSkp/ygoKP8cHBz/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAIiIiP9gYGD/X19f/15eXv9bW1v/WFdX/05OTf+np6f/4eHh/9rZ2v/V1dX/0NDQ/83N
        zf/IyMf/w8PD/76/v/+6urr/tbW1/7CxsP+sra3/p6in/6Kiov+enp7/mZmZ/5OUlP+Pj4//ioqK/4WE
        hf+AgID/fn19/0ZGRv8mJyb/Kikq/yorKv8qKyr/KSkp/ygoKP8dHh7/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAImJif9gYGD/X19f/15eXv9bW1v/WFhY/1BQUP+pqan/6Ojo/9bW
        1v/S09P/z8/P/8vLy//Gxsb/wsLC/76+vv+5ubn/tLS0/7CwsP+srKv/p6em/6Giov+dnZ3/mJiY/5OT
        k/+Oj47/iYmJ/4SEhP9/f4D/e3t7/0pKS/8oKCj/Kysr/ywsLP8rKir/Kikq/yknJ/8fHx//DQ0NZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIuLi/9fX17/Xl5f/11dXf9bW1v/WVhY/1RU
        VP9XV1j//////+Pj4//T09P/z8/P/8rKyv/Fx8f/wcHC/7++v/+5ubn/tbW1/7CwsP+sraz/pqao/6Ki
        ov+enZ7/mZmZ/5STlP+QkJD/i4uL/4aGhv+BgYH/fHx8/zEwL/8rKiz/LCws/y0sLP8rKir/F4GW/ygm
        J/8iIiL/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIyMjP9eXV3/Xl5e/11c
        XP9bW1v/WFlZ/1ZWVf9OTk7/VldW/6enp/+lpaX/pKSk/6Kiov+goKD/nJyc/5iYmP+Tk5P/jo+P/4mJ
        if+FhIX/gICA/3t7fP92dnb/cXJx/21tbf9nZmb/YmJi/11dXf9aWlr/MzMz/ywtLP8uLi3/LS0t/y0t
        Lf8sKin/KScm/ycmJP8kJCT/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAI6O
        jv9cXlz/Xl5e/1tbXP9aWlr/WFhY/1ZWV/9SU1P/Tk9P/0tLSv9HR0f/RERE/0JCQv9AQED/Pj8//zw8
        Pf87Ozv/Ozs8/zo6Ov85OTn/ODg4/zY2Nv81NDX/NDM0/zMzM/8xMTH/MDAw/y8vL/8vLy//Li4u/y8v
        L/8uLy7/Li0t/y0tLP8rKij/F4GW/ygmJ/8mJib/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAJCPkP9dW1v/XV1c/1tbW/9ZWVn/WFhY/1ZWVv9TVFP/UlJR/09PT/9OTk3/S0xL/0pK
        Sv9ISEj/R0ZH/0VERf9CQkP/QUFC/0BAQP8/Pz//Pj4+/z09Pf87Ozv/OTk6/zg4OP82Njf/NTU1/zMz
        M/8yMjL/MTEx/y8wL/8vLy//Ly0t/xeAlf8sKCf/KScm/ykmJf8nJyf/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAJKSkv9aWlr/W1tb/1paWv9ZWVj/V1dX/1ZVVv9UVFT/UlJR/1BP
        UP9OTk7/TU1N/0xMTP9KSkr/SElI/0dHR/9GRkb/RERE/0JCQv9AQED/Pz8//z4+Pv89PT3/Ozs7/zk5
        Of84ODj/Nzc2/zQ0NP8zMzP/MjIy/zAwMP8vLy//Lyws/y4qK/8tKCf/GI6q/ygnJv8pKCn/DQ0NZA4O
        DlcNDQ0yCAgIDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAJOTk/9ZWFj/Wlpa/1lZWf9YWFj/V1dW/1VV
        VP9TU1P/UVFR/1BPUP9PT0//TU5O/0xMTP9LSkv/SUlJ/0hISP9GRkb/RERE/0NCQv9BQUH/QD8//z4/
        Pv89PT7/Ozw8/zo6Ov85OTn/Nzg3/zU1NP8zMzP/MTIy/zAwMP8vLy//Li0t/xeAlf8tJyj/KyYm/ygk
        Jf8rKyv/DQ0NVw0NDUwNDQ0sCQkJDAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAJOTk/9XV1f/WVhY/1hY
        V/9XV1f/VlZW/1VVVf9SUlL/UFFR/09PT/9OTk7/TU1N/0xMTP9LSkr/SUlJ/0dHR/9GRkb/REVE/0JC
        Qv9BQUD/Pz8//z8/Pv89PT3/Ozw8/zo6Ov84ODj/Nzc2/zQ0Nf8zMzP/MTIy/zAwL/8vLy//Li0t/y0s
        LP8rKSj/GI6q/yclJf8tLS3/DAwMMg0NDSwLCwsaCAgIBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJKS
        kv9UVVX/VVVV/1RVVf9TU1P/UlJS/1FRUf9PT0//Tk5O/01NTf9MTEz/SktL/0tJSf9JSUn/SEhI/0ZG
        R/9FRUX/Q0ND/0FBQf9APz//Pj4+/z0+Pf88PDz/Ojo6/zk5Of84ODj/NjY2/zM0M/8yMjH/MDAw/y8v
        L/8uLi7/LS0t/y0tLf8rKSn/KSYm/yclJP8vLy//BwcHDgkJCQwICAgHAAAAAgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAJaVlf+TkpL/kpKS/4+Qj/+NjY3/iYmJ/4eHhv+FhYX/goKD/3+Af/99fHz/enl5/3Z2
        dv90dHT/cnJy/3Bwb/9ra2v/aGho/2VmZf9jZGP/YWFh/15eX/9cXFz/WFhY/1VUVf9TUlL/UFBQ/01N
        Tf9LS0v/SEhI/0NEQ/9BQUH/Pz8//zw9PP85OTn/NjY2/zIyMv8xMTH/AAAAAQAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAf
        AAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAf
        AAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAP///////wAA////////
        AAD///////8AAP///////wAA////////AAA=
</value>
  </data>
</root>
```

`LibreHardwareMonitor/UI/Gadget.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Drawing;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI;

public abstract class Gadget : IDisposable
{
    private readonly GadgetWindow _window;

    public event EventHandler VisibleChanged;

    protected Gadget()
    {
        _window = new GadgetWindow();
        _window.Paint += delegate (object sender, PaintEventArgs e)
        {
            OnPaint(e);
        };
    }

    public virtual void Dispose()
    {
        _window.Dispose();
    }

    public Point Location
    {
        get
        {
            return _window.Location;
        }
        set
        {
            _window.Location = value;
        }
    }

    public event EventHandler LocationChanged
    {
        add
        {
            _window.LocationChanged += value;
        }
        remove
        {
            _window.LocationChanged -= value;
        }
    }

    public virtual Size Size
    {
        get
        {
            return _window.Size;
        }
        set
        {
            _window.Size = value;
        }
    }

    public event EventHandler SizeChanged
    {
        add
        {
            _window.SizeChanged += value;
        }
        remove
        {
            _window.SizeChanged -= value;
        }
    }

    public byte Opacity
    {
        get
        {
            return _window.Opacity;
        }
        set
        {
            _window.Opacity = value;
        }
    }

    public bool LockPositionAndSize
    {
        get
        {
            return _window.LockPositionAndSize;
        }
        set
        {
            _window.LockPositionAndSize = value;
        }
    }

    public bool AlwaysOnTop
    {
        get
        {
            return _window.AlwaysOnTop;
        }
        set
        {
            _window.AlwaysOnTop = value;
        }
    }

    public ContextMenuStrip ContextMenuStrip
    {
        get
        {
            return _window.ContextMenuStrip;
        }
        set
        {
            _window.ContextMenuStrip = value;
        }
    }

    public event HitTestEventHandler HitTest
    {
        add
        {
            _window.HitTest += value;
        }
        remove
        {
            _window.HitTest -= value;
        }
    }

    public event MouseEventHandler MouseDoubleClick
    {
        add
        {
            _window.MouseDoubleClick += value;
        }
        remove
        {
            _window.MouseDoubleClick -= value;
        }
    }

    public bool Visible
    {
        get
        {
            return _window.Visible;
        }
        set
        {
            if (value != _window.Visible)
            {
                _window.Visible = value;
                VisibleChanged?.Invoke(this, EventArgs.Empty);

                if (value)
                    Redraw();
            }
        }
    }

    public void Redraw()
    {
        _window.Redraw();
    }

    protected abstract void OnPaint(PaintEventArgs e);
}
```

`LibreHardwareMonitor/UI/GadgetWindow.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Text;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI;

public sealed class GadgetWindow : NativeWindow, IDisposable
{
    private bool _visible;
    private bool _alwaysOnTop;
    private byte _opacity = 255;
    private Point _location = new Point(100, 100);
    private Size _size = new Size(130, 84);
    private readonly MethodInfo _commandDispatch;
    private IntPtr _handleBitmapDC;
    private Size _bufferSize;
    private Graphics _graphics;

    public event EventHandler SizeChanged;
    public event EventHandler LocationChanged;
    public event HitTestEventHandler HitTest;
    public event MouseEventHandler MouseDoubleClick;

    public GadgetWindow()
    {
        Type commandType = typeof(Form).Assembly.GetType("System.Windows.Forms.Command");
        _commandDispatch = commandType.GetMethod("DispatchID",
                                                 BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public,
                                                 null, new[] { typeof(int) }, null);

        CreateHandle(CreateParams);

        // move window to the bottom
        MoveToBottom(Handle);

        // prevent window from fading to a glass sheet when peek is invoked
        try
        {
            bool value = true;
            NativeMethods.DwmSetWindowAttribute(Handle, WindowAttribute.DWMWA_EXCLUDED_FROM_PEEK, ref value, Marshal.SizeOf(true));
        }
        catch (DllNotFoundException) { }
        catch (EntryPointNotFoundException) { }

        CreateBuffer();
    }

    private void ShowDesktopChanged(bool showDesktop)
    {
        if (showDesktop)
            MoveToTopMost(Handle);
        else
            MoveToBottom(Handle);
    }

    private void MoveToBottom(IntPtr handle)
    {
        NativeMethods.SetWindowPos(handle, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);
    }

    private void MoveToTopMost(IntPtr handle)
    {
        NativeMethods.SetWindowPos(handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);
    }

    private CreateParams CreateParams
    {
        get
        {
            CreateParams cp = new CreateParams
            {
                Width = 4096,
                Height = 4096,
                X = _location.X,
                Y = _location.Y,
                ExStyle = WS_EX_LAYERED | WS_EX_TOOLWINDOW
            };

            return cp;
        }
    }

    protected override void WndProc(ref Message message)
    {
        switch (message.Msg)
        {
            case WM_COMMAND:
                {
                    // need to dispatch the message for the context menu
                    if (message.LParam == IntPtr.Zero)
                        _commandDispatch.Invoke(null, new object[] {message.WParam.ToInt32() & 0xFFFF });
                }
                break;
            case WM_NCHITTEST:
                {
                    message.Result = (IntPtr)HitResult.Caption;
                    if (HitTest != null)
                    {
                        Point p = new Point(
                                            Macros.GET_X_LPARAM(message.LParam) - _location.X,
                                            Macros.GET_Y_LPARAM(message.LParam) - _location.Y
                                           );
                        HitTestEventArgs e = new HitTestEventArgs(p, HitResult.Caption);
                        HitTest(this, e);
                        message.Result = (IntPtr)e.HitResult;
                    }
                }
                break;
            case WM_NCLBUTTONDBLCLK:
                {
                    MouseDoubleClick?.Invoke(this, new MouseEventArgs(MouseButtons.Left, 2, Macros.GET_X_LPARAM(message.LParam) - _location.X, Macros.GET_Y_LPARAM(message.LParam) - _location.Y, 0));
                    message.Result = IntPtr.Zero;
                }
                break;
            case WM_NCRBUTTONDOWN:
                {
                    message.Result = IntPtr.Zero;
                }
                break;
            case WM_NCRBUTTONUP:
                {
                    ContextMenuStrip?.Show(new Point(Macros.GET_X_LPARAM(message.LParam), Macros.GET_Y_LPARAM(message.LParam)));
                    message.Result = IntPtr.Zero;
                }
                break;
            case WM_WINDOWPOSCHANGING:
                {
                    WINDOWPOS wp = (WINDOWPOS)Marshal.PtrToStructure(message.LParam, typeof(WINDOWPOS));
                    if (!LockPositionAndSize)
                    {
                        // prevent the window from leaving the screen
                        if ((wp.flags & SWP_NOMOVE) == 0)
                        {
                            Rectangle rect = Screen.GetWorkingArea(new Rectangle(wp.x, wp.y, wp.cx, wp.cy));
                            const int margin = 16;
                            wp.x = Math.Max(wp.x, rect.Left - wp.cx + margin);
                            wp.x = Math.Min(wp.x, rect.Right - margin);
                            wp.y = Math.Max(wp.y, rect.Top - wp.cy + margin);
                            wp.y = Math.Min(wp.y, rect.Bottom - margin);
                        }

                        // update location and fire event
                        if ((wp.flags & SWP_NOMOVE) == 0)
                        {
                            if (_location.X != wp.x || _location.Y != wp.y)
                            {
                                _location = new Point(wp.x, wp.y);
                                LocationChanged?.Invoke(this, EventArgs.Empty);
                            }
                        }

                        // update size and fire event
                        if ((wp.flags & SWP_NOSIZE) == 0)
                        {
                            if (_size.Width != wp.cx || _size.Height != wp.cy)
                            {
                                _size = new Size(wp.cx, wp.cy);
                                SizeChanged?.Invoke(this, EventArgs.Empty);
                            }
                        }

                        // update the size of the layered window
                        if ((wp.flags & SWP_NOSIZE) == 0)
                            NativeMethods.UpdateLayeredWindow(Handle, IntPtr.Zero, IntPtr.Zero, ref _size, IntPtr.Zero, IntPtr.Zero, 0, IntPtr.Zero, 0);

                        // update the position of the layered window
                        if ((wp.flags & SWP_NOMOVE) == 0)
                            NativeMethods.SetWindowPos(Handle, IntPtr.Zero, _location.X, _location.Y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSENDCHANGING);
                    }

                    // do not forward any move or size messages
                    wp.flags |= SWP_NOSIZE | SWP_NOMOVE;

                    // suppress any frame changed events
                    wp.flags &= ~SWP_FRAMECHANGED;

                    Marshal.StructureToPtr(wp, message.LParam, false);
                    message.Result = IntPtr.Zero;
                }
                break;
            default:
                {
                    base.WndProc(ref message);
                }
                break;
        }
    }

    private BlendFunction CreateBlendFunction()
    {
        return new BlendFunction { BlendOp = AC_SRC_OVER, BlendFlags = 0, SourceConstantAlpha = _opacity, AlphaFormat = AC_SRC_ALPHA };
    }

    private void CreateBuffer()
    {
        IntPtr handleScreenDC = NativeMethods.GetDC(IntPtr.Zero);
        _handleBitmapDC = NativeMethods.CreateCompatibleDC(handleScreenDC);
        NativeMethods.ReleaseDC(IntPtr.Zero, handleScreenDC);
        _bufferSize = _size;

        BITMAPINFO info = new BITMAPINFO();
        info.Size = Marshal.SizeOf(info);
        info.Width = _size.Width;
        info.Height = -_size.Height;
        info.BitCount = 32;
        info.Planes = 1;

        IntPtr hBmp = NativeMethods.CreateDIBSection(_handleBitmapDC, ref info, 0, out IntPtr _, IntPtr.Zero, 0);
        IntPtr hBmpOld = NativeMethods.SelectObject(_handleBitmapDC, hBmp);
        NativeMethods.DeleteObject(hBmpOld);

        _graphics = Graphics.FromHdc(_handleBitmapDC);

        if (Environment.OSVersion.Version.Major > 5)
        {
            _graphics.TextRenderingHint = TextRenderingHint.SystemDefault;
            _graphics.SmoothingMode = SmoothingMode.HighQuality;
        }
    }

    private void DisposeBuffer()
    {
        _graphics.Dispose();
        NativeMethods.DeleteDC(_handleBitmapDC);
    }

    public void Dispose()
    {
        DisposeBuffer();
    }

    public PaintEventHandler Paint;

    public void Redraw()
    {
        if (!_visible || Paint == null)
            return;

        if (_size != _bufferSize)
        {
            DisposeBuffer();
            CreateBuffer();
        }

        Paint(this, new PaintEventArgs(_graphics, new Rectangle(Point.Empty, _size)));
        Point pointSource = Point.Empty;
        BlendFunction blend = CreateBlendFunction();
        NativeMethods.UpdateLayeredWindow(Handle, IntPtr.Zero, IntPtr.Zero, ref _size, _handleBitmapDC, ref pointSource, 0, ref blend, ULW_ALPHA);
        // make sure the window is at the right location
        NativeMethods.SetWindowPos(Handle, IntPtr.Zero, _location.X, _location.Y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSENDCHANGING);
    }

    public byte Opacity
    {
        get
        {
            return _opacity;
        }
        set
        {
            if (_opacity != value)
            {
                _opacity = value;
                BlendFunction blend = CreateBlendFunction();
                NativeMethods.UpdateLayeredWindow(Handle, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, 0, ref blend, ULW_ALPHA);
            }
        }
    }

    public bool Visible
    {
        get
        {
            return _visible;
        }
        set
        {
            if (_visible != value)
            {
                _visible = value;
                NativeMethods.SetWindowPos(Handle, IntPtr.Zero, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER | (value ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));

                if (value)
                {
                    if (!_alwaysOnTop)
                        ShowDesktop.Instance.ShowDesktopChanged += ShowDesktopChanged;
                }
                else
                {
                    if (!_alwaysOnTop)
                        ShowDesktop.Instance.ShowDesktopChanged -= ShowDesktopChanged;
                }
            }
        }
    }

    // if locked, the window can not be moved or resized
    public bool LockPositionAndSize { get; set; }

    public bool AlwaysOnTop
    {
        get
        {
            return _alwaysOnTop;
        }
        set
        {
            if (value != _alwaysOnTop)
            {
                _alwaysOnTop = value;

                if (_alwaysOnTop)
                {
                    if (_visible)
                        ShowDesktop.Instance.ShowDesktopChanged -= ShowDesktopChanged;

                    MoveToTopMost(Handle);
                }
                else
                {
                    MoveToBottom(Handle);

                    if (_visible)
                        ShowDesktop.Instance.ShowDesktopChanged += ShowDesktopChanged;
                }
            }
        }
    }

    public Size Size
    {
        get
        {
            return _size;
        }
        set
        {
            if (_size != value)
            {
                _size = value;
                NativeMethods.UpdateLayeredWindow(Handle, IntPtr.Zero, IntPtr.Zero, ref _size, IntPtr.Zero, IntPtr.Zero, 0, IntPtr.Zero, 0);
                SizeChanged?.Invoke(this, EventArgs.Empty);
            }
        }
    }

    public Point Location
    {
        get
        {
            return _location;
        }
        set
        {
            if (_location != value)
            {
                _location = value;
                NativeMethods.SetWindowPos(Handle, IntPtr.Zero, _location.X, _location.Y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSENDCHANGING);
                LocationChanged?.Invoke(this, EventArgs.Empty);
            }
        }
    }

    public ContextMenuStrip ContextMenuStrip { get; set; }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    private struct BlendFunction
    {
        public byte BlendOp;
        public byte BlendFlags;
        public byte SourceConstantAlpha;
        public byte AlphaFormat;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    private struct WINDOWPOS
    {
        public readonly IntPtr hwnd;
        public readonly IntPtr hwndInsertAfter;
        public int x;
        public int y;
        public readonly int cx;
        public readonly int cy;
        public uint flags;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct BITMAPINFO
    {
        public int Size;
        public int Width;
        public int Height;
        public short Planes;
        public short BitCount;
        public int Compression;
        public int SizeImage;
        public int XPelsPerMeter;
        public int YPelsPerMeter;
        public int ClrUsed;
        public int ClrImportant;
        public int Colors;
    }

    public static readonly IntPtr HWND_BOTTOM = (IntPtr)1;
    public static readonly IntPtr HWND_TOPMOST = (IntPtr)(-1);

    public const int WS_EX_LAYERED = 0x00080000;
    public const int WS_EX_TOOLWINDOW = 0x00000080;

    public const uint SWP_NOSIZE = 0x0001;
    public const uint SWP_NOMOVE = 0x0002;
    public const uint SWP_NOACTIVATE = 0x0010;
    public const uint SWP_FRAMECHANGED = 0x0020;
    public const uint SWP_HIDEWINDOW = 0x0080;
    public const uint SWP_SHOWWINDOW = 0x0040;
    public const uint SWP_NOZORDER = 0x0004;
    public const uint SWP_NOSENDCHANGING = 0x0400;

    public const int ULW_COLORKEY = 0x00000001;
    public const int ULW_ALPHA = 0x00000002;
    public const int ULW_OPAQUE = 0x00000004;

    public const byte AC_SRC_OVER = 0x00;
    public const byte AC_SRC_ALPHA = 0x01;

    public const int WM_NCHITTEST = 0x0084;
    public const int WM_NCLBUTTONDBLCLK = 0x00A3;
    public const int WM_NCLBUTTONDOWN = 0x00A1;
    public const int WM_NCLBUTTONUP = 0x00A2;
    public const int WM_NCRBUTTONDOWN = 0x00A4;
    public const int WM_NCRBUTTONUP = 0x00A5;
    public const int WM_WINDOWPOSCHANGING = 0x0046;
    public const int WM_COMMAND = 0x0111;

    public const int TPM_RIGHTBUTTON = 0x0002;
    public const int TPM_VERTICAL = 0x0040;

    private enum WindowAttribute : int
    {
        DWMWA_NCRENDERING_ENABLED = 1,
        DWMWA_NCRENDERING_POLICY,
        DWMWA_TRANSITIONS_FORCEDISABLED,
        DWMWA_ALLOW_NCPAINT,
        DWMWA_CAPTION_BUTTON_BOUNDS,
        DWMWA_NONCLIENT_RTL_LAYOUT,
        DWMWA_FORCE_ICONIC_REPRESENTATION,
        DWMWA_FLIP3D_POLICY,
        DWMWA_EXTENDED_FRAME_BOUNDS,
        DWMWA_HAS_ICONIC_BITMAP,
        DWMWA_DISALLOW_PEEK,
        DWMWA_EXCLUDED_FROM_PEEK,
        DWMWA_LAST
    }

    /// <summary>
    /// Some macros imported and converted from the Windows SDK
    /// </summary>
    private static class Macros
    {
        public static ushort LOWORD(IntPtr l)
        {
            return (ushort)((ulong)l & 0xFFFF);
        }

        public static ushort HIWORD(IntPtr l)
        {
            return (ushort)(((ulong)l >> 16) & 0xFFFF);
        }

        public static int GET_X_LPARAM(IntPtr lp)
        {
            return (short)LOWORD(lp);
        }

        public static int GET_Y_LPARAM(IntPtr lp)
        {
            return (short)HIWORD(lp);
        }
    }

    /// <summary>
    /// Imported native methods
    /// </summary>
    private static class NativeMethods
    {
        private const string USER = "user32.dll";
        private const string GDI = "gdi32.dll";
        private const string DWMAPI = "dwmapi.dll";

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDst, IntPtr pptDst, ref Size psize, IntPtr hdcSrc, IntPtr pprSrc, int crKey, IntPtr pblend, int dwFlags);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDst, IntPtr pptDst, ref Size psize, IntPtr hdcSrc, ref Point pprSrc, int crKey, ref BlendFunction pblend, int dwFlags);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDst, IntPtr pptDst, IntPtr psize, IntPtr hdcSrc, IntPtr pprSrc, int crKey, ref BlendFunction pblend, int dwFlags);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern IntPtr GetDC(IntPtr hWnd);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern bool TrackPopupMenuEx(IntPtr hMenu, uint uFlags, int x, int y, IntPtr hWnd, IntPtr tpmParams);

        [DllImport(GDI, CallingConvention = CallingConvention.Winapi)]
        public static extern IntPtr CreateCompatibleDC(IntPtr hDC);

        [DllImport(GDI, CallingConvention = CallingConvention.Winapi)]
        public static extern IntPtr CreateDIBSection(IntPtr hdc, [In] ref BITMAPINFO pbmi, uint pila, out IntPtr ppvBits, IntPtr hSection, uint dwOffset);

        [DllImport(GDI, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool DeleteDC(IntPtr hdc);

        [DllImport(GDI, CallingConvention = CallingConvention.Winapi)]
        public static extern IntPtr SelectObject(IntPtr hDC, IntPtr hObject);

        [DllImport(GDI, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool DeleteObject(IntPtr hObject);

        [DllImport(DWMAPI, CallingConvention = CallingConvention.Winapi)]
        public static extern int DwmSetWindowAttribute(IntPtr hwnd, WindowAttribute dwAttribute, ref bool pvAttribute, int cbAttribute);
    }
}

public delegate void HitTestEventHandler(object sender, HitTestEventArgs e);

public enum HitResult
{
    Transparent = -1,
    Nowhere = 0,
    Client = 1,
    Caption = 2,
    Left = 10,
    Right = 11,
    Top = 12,
    TopLeft = 13,
    TopRight = 14,
    Bottom = 15,
    BottomLeft = 16,
    BottomRight = 17,
    Border = 18
}

public class HitTestEventArgs : EventArgs
{
    public HitTestEventArgs(Point location, HitResult hitResult)
    {
        Location = location;
        HitResult = hitResult;
    }
    public Point Location { get; }
    public HitResult HitResult { get; set; }
}
```

`LibreHardwareMonitor/UI/HardwareNode.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;
using System;
using System.Collections.Generic;
using System.Text;

namespace LibreHardwareMonitor.UI;

public class HardwareNode : Node, IExpandPersistNode
{
    private readonly PersistentSettings _settings;
    private readonly UnitManager _unitManager;
    private readonly List<TypeNode> _typeNodes = new List<TypeNode>();
    private readonly string _expandedIdentifier;
    private bool _expanded;

    public event EventHandler PlotSelectionChanged;

    public HardwareNode(IHardware hardware, PersistentSettings settings, UnitManager unitManager)
    {
        _settings = settings;
        _unitManager = unitManager;
        _expandedIdentifier = new Identifier(hardware.Identifier, "expanded").ToString();
        Hardware = hardware;
        Image = HardwareTypeImage.Instance.GetImage(hardware.HardwareType);

        foreach (SensorType sensorType in Enum.GetValues(typeof(SensorType)))
            _typeNodes.Add(new TypeNode(sensorType, hardware.Identifier, _settings));

        foreach (ISensor sensor in hardware.Sensors)
            SensorAdded(sensor);

        hardware.SensorAdded += SensorAdded;
        hardware.SensorRemoved += SensorRemoved;

        _expanded = settings.GetValue(_expandedIdentifier, true);
    }


    public override string Text
    {
        get { return Hardware.Name; }
        set { Hardware.Name = value; }
    }

    public override string ToolTip
    {
        get
        {
            IDictionary<string, string> properties = Hardware.Properties;

            if (properties.Count > 0)
            {
                StringBuilder stringBuilder = new();
                stringBuilder.AppendLine("Hardware properties:");
                    
                foreach (KeyValuePair<string, string> property in properties)
                    stringBuilder.AppendFormat(" • {0}: {1}\n", property.Key, property.Value);

                return stringBuilder.ToString();
            }

            return null;
        }
    }

    public IHardware Hardware { get; }

    public bool Expanded
    {
        get => _expanded;
        set
        {
            _expanded = value;
            _settings.SetValue(_expandedIdentifier, _expanded);
        }
    }

    private void UpdateNode(TypeNode node)
    {
        if (node.Nodes.Count > 0)
        {
            if (!Nodes.Contains(node))
            {
                int i = 0;
                while (i < Nodes.Count && ((TypeNode)Nodes[i]).SensorType < node.SensorType)
                    i++;

                Nodes.Insert(i, node);
            }
        }
        else
        {
            if (Nodes.Contains(node))
                Nodes.Remove(node);
        }
    }

    private void SensorRemoved(ISensor sensor)
    {
        foreach (TypeNode typeNode in _typeNodes)
        {
            if (typeNode.SensorType == sensor.SensorType)
            {
                SensorNode sensorNode = null;
                foreach (Node node in typeNode.Nodes)
                {
                    if (node is SensorNode n && n.Sensor == sensor)
                        sensorNode = n;
                }
                if (sensorNode != null)
                {
                    sensorNode.PlotSelectionChanged -= SensorPlotSelectionChanged;
                    typeNode.Nodes.Remove(sensorNode);
                    UpdateNode(typeNode);
                }
            }
        }
        PlotSelectionChanged?.Invoke(this, null);
    }

    private void InsertSorted(Node node, ISensor sensor)
    {
        int i = 0;
        while (i < node.Nodes.Count && ((SensorNode)node.Nodes[i]).Sensor.Index < sensor.Index)
            i++;

        SensorNode sensorNode = new SensorNode(sensor, _settings, _unitManager);
        sensorNode.PlotSelectionChanged += SensorPlotSelectionChanged;
        node.Nodes.Insert(i, sensorNode);
    }

    private void SensorPlotSelectionChanged(object sender, EventArgs e)
    {
        PlotSelectionChanged?.Invoke(this, null);
    }

    private void SensorAdded(ISensor sensor)
    {
        foreach (TypeNode typeNode in _typeNodes)
        {
            if (typeNode.SensorType == sensor.SensorType)
            {
                InsertSorted(typeNode, sensor);
                UpdateNode(typeNode);
            }
        }

        PlotSelectionChanged?.Invoke(this, null);
    }
}
```

`LibreHardwareMonitor/UI/HardwareTypeImage.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Drawing;
using System.Collections.Generic;
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.UI;

public class HardwareTypeImage
{
    private readonly IDictionary<HardwareType, Image> _images = new Dictionary<HardwareType, Image>();

    private HardwareTypeImage() { }

    public static HardwareTypeImage Instance { get; } = new HardwareTypeImage();

    public Image GetImage(HardwareType hardwareType)
    {
        if (_images.TryGetValue(hardwareType, out Image image))
            return image;


        switch (hardwareType)
        {
            case HardwareType.Cpu:
                image = Utilities.EmbeddedResources.GetImage("cpu.png");
                break;
            case HardwareType.GpuNvidia:
                image = Utilities.EmbeddedResources.GetImage("nvidia.png");
                break;
            case HardwareType.GpuAmd:
                image = Utilities.EmbeddedResources.GetImage("amd.png");
                break;
            case HardwareType.GpuIntel:
                image = Utilities.EmbeddedResources.GetImage("intel.png");
                break;
            case HardwareType.Storage:
                image = Utilities.EmbeddedResources.GetImage("hdd.png");
                break;
            case HardwareType.Motherboard:
                image = Utilities.EmbeddedResources.GetImage("mainboard.png");
                break;
            case HardwareType.SuperIO:
            case HardwareType.EmbeddedController:
                image = Utilities.EmbeddedResources.GetImage("chip.png");
                break;
            case HardwareType.Memory:
                image = Utilities.EmbeddedResources.GetImage("ram.png");
                break;
            case HardwareType.Network:
                image = Utilities.EmbeddedResources.GetImage("nic.png");
                break;
            case HardwareType.Cooler:
                image = Utilities.EmbeddedResources.GetImage("fan.png");
                break;
            case HardwareType.Psu:
                image = Utilities.EmbeddedResources.GetImage("power-supply.png");
                break;
            case HardwareType.Battery:
                image = Utilities.EmbeddedResources.GetImage("battery.png");
                break;
            default:
                image = new Bitmap(1, 1);
                break;
        }
        _images.Add(hardwareType, image);
        return image;
    }
}
```

`LibreHardwareMonitor/UI/IExpandPersistNode.cs`:

```cs
namespace LibreHardwareMonitor.UI;

public interface IExpandPersistNode
{
    bool Expanded { get; set; }
}
```

`LibreHardwareMonitor/UI/MainForm.Designer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.UI
{
    sealed partial class MainForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
            this.sensor = new Aga.Controls.Tree.TreeColumn();
            this.value = new Aga.Controls.Tree.TreeColumn();
            this.min = new Aga.Controls.Tree.TreeColumn();
            this.max = new Aga.Controls.Tree.TreeColumn();
            this.nodeImage = new Aga.Controls.Tree.NodeControls.NodeIcon();
            this.nodeCheckBox = new Aga.Controls.Tree.NodeControls.NodeCheckBox();
            this.nodeTextBoxText = new Aga.Controls.Tree.NodeControls.NodeTextBox();
            this.nodeTextBoxValue = new Aga.Controls.Tree.NodeControls.NodeTextBox();
            this.nodeTextBoxMin = new Aga.Controls.Tree.NodeControls.NodeTextBox();
            this.nodeTextBoxMax = new Aga.Controls.Tree.NodeControls.NodeTextBox();
            this.mainMenu = new System.Windows.Forms.MenuStrip();
            this.fileMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.saveReportMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.MenuItem2 = new System.Windows.Forms.ToolStripSeparator();
            this.resetMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.menuItem5 = new System.Windows.Forms.ToolStripMenuItem();
            this.mainboardMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.cpuMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.ramMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.gpuMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.fanControllerMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.hddMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.nicMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.psuMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.menuItem6 = new System.Windows.Forms.ToolStripSeparator();
            this.exitMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.viewMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.resetMinMaxMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.resetPlotMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.MenuItem3 = new System.Windows.Forms.ToolStripSeparator();
            this.hiddenMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.plotMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.gadgetMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.MenuItem1 = new System.Windows.Forms.ToolStripSeparator();
            this.columnsMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.valueMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.minMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.maxMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.optionsMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.startMinMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.minTrayMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.minCloseMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.startupMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.separatorMenuItem = new System.Windows.Forms.ToolStripSeparator();
            this.temperatureUnitsMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.celsiusMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.fahrenheitMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.plotLocationMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.plotWindowMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.plotBottomMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.plotRightMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.logSeparatorMenuItem = new System.Windows.Forms.ToolStripSeparator();
            this.logSensorsMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.loggingIntervalMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.log1sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log2sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log5sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log10sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log30sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log1minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log2minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log5minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log10minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log30minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log1hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log2hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log6hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.updateIntervalMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.updateInterval250msMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.updateInterval500msMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.updateInterval1sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.updateInterval2sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.updateInterval5sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.updateInterval10sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.sensorValuesTimeWindowMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.timeWindow30sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow1minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow2minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow5minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow10minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow30minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow1hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow2hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow6hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow12hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow24hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.webMenuItemSeparator = new System.Windows.Forms.ToolStripSeparator();
            this.webMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.runWebServerMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.serverPortMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.authWebServerMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.helpMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.aboutMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.treeContextMenu = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.saveFileDialog = new System.Windows.Forms.SaveFileDialog();
            this.timer = new System.Windows.Forms.Timer(this.components);
            this.splitContainer = new LibreHardwareMonitor.UI.SplitContainerAdv();
            this.treeView = new Aga.Controls.Tree.TreeViewAdv();
            this.batteryMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.psuMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.backgroundUpdater = new System.ComponentModel.BackgroundWorker();
            this.mainMenu.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer)).BeginInit();
            this.splitContainer.Panel1.SuspendLayout();
            this.splitContainer.SuspendLayout();
            this.SuspendLayout();
            // 
            // sensor
            // 
            this.sensor.Header = "Sensor";
            this.sensor.SortOrder = System.Windows.Forms.SortOrder.None;
            this.sensor.TooltipText = null;
            this.sensor.Width = 250;
            // 
            // value
            // 
            this.value.Header = "Value";
            this.value.SortOrder = System.Windows.Forms.SortOrder.None;
            this.value.TooltipText = null;
            this.value.Width = 100;
            // 
            // min
            // 
            this.min.Header = "Min";
            this.min.SortOrder = System.Windows.Forms.SortOrder.None;
            this.min.TooltipText = null;
            this.min.Width = 100;
            // 
            // max
            // 
            this.max.Header = "Max";
            this.max.SortOrder = System.Windows.Forms.SortOrder.None;
            this.max.TooltipText = null;
            this.max.Width = 100;
            // 
            // nodeImage
            // 
            this.nodeImage.DataPropertyName = "Image";
            this.nodeImage.LeftMargin = 1;
            this.nodeImage.ParentColumn = this.sensor;
            this.nodeImage.ScaleMode = Aga.Controls.Tree.ImageScaleMode.Fit;
            // 
            // nodeCheckBox
            // 
            this.nodeCheckBox.DataPropertyName = "Plot";
            this.nodeCheckBox.EditEnabled = true;
            this.nodeCheckBox.LeftMargin = 3;
            this.nodeCheckBox.ParentColumn = this.sensor;
            // 
            // nodeTextBoxText
            // 
            this.nodeTextBoxText.DataPropertyName = "Text";
            this.nodeTextBoxText.EditEnabled = true;
            this.nodeTextBoxText.IncrementalSearchEnabled = true;
            this.nodeTextBoxText.LeftMargin = 3;
            this.nodeTextBoxText.ParentColumn = this.sensor;
            this.nodeTextBoxText.Trimming = System.Drawing.StringTrimming.EllipsisCharacter;
            this.nodeTextBoxText.UseCompatibleTextRendering = true;
            // 
            // nodeTextBoxValue
            // 
            this.nodeTextBoxValue.DataPropertyName = "Value";
            this.nodeTextBoxValue.IncrementalSearchEnabled = true;
            this.nodeTextBoxValue.LeftMargin = 3;
            this.nodeTextBoxValue.ParentColumn = this.value;
            this.nodeTextBoxValue.Trimming = System.Drawing.StringTrimming.EllipsisCharacter;
            this.nodeTextBoxValue.UseCompatibleTextRendering = true;
            // 
            // nodeTextBoxMin
            // 
            this.nodeTextBoxMin.DataPropertyName = "Min";
            this.nodeTextBoxMin.IncrementalSearchEnabled = true;
            this.nodeTextBoxMin.LeftMargin = 3;
            this.nodeTextBoxMin.ParentColumn = this.min;
            this.nodeTextBoxMin.Trimming = System.Drawing.StringTrimming.EllipsisCharacter;
            this.nodeTextBoxMin.UseCompatibleTextRendering = true;
            // 
            // nodeTextBoxMax
            // 
            this.nodeTextBoxMax.DataPropertyName = "Max";
            this.nodeTextBoxMax.IncrementalSearchEnabled = true;
            this.nodeTextBoxMax.LeftMargin = 3;
            this.nodeTextBoxMax.ParentColumn = this.max;
            this.nodeTextBoxMax.Trimming = System.Drawing.StringTrimming.EllipsisCharacter;
            this.nodeTextBoxMax.UseCompatibleTextRendering = true;
            // 
            // mainMenu
            // 
            this.mainMenu.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fileMenuItem,
            this.viewMenuItem,
            this.optionsMenuItem,
            this.helpMenuItem});
            this.mainMenu.Location = new System.Drawing.Point(0, 0);
            this.mainMenu.Name = "mainMenu";
            this.mainMenu.Size = new System.Drawing.Size(418, 24);
            this.mainMenu.TabIndex = 1;
            // 
            // fileMenuItem
            // 
            this.fileMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.saveReportMenuItem,
            this.MenuItem2,
            this.resetMenuItem,
            this.menuItem5,
            this.menuItem6,
            this.exitMenuItem});
            this.fileMenuItem.Name = "fileMenuItem";
            this.fileMenuItem.Size = new System.Drawing.Size(37, 20);
            this.fileMenuItem.Text = "File";
            // 
            // saveReportMenuItem
            // 
            this.saveReportMenuItem.Name = "saveReportMenuItem";
            this.saveReportMenuItem.Size = new System.Drawing.Size(180, 22);
            this.saveReportMenuItem.Text = "Save Report...";
            this.saveReportMenuItem.Click += new System.EventHandler(this.SaveReportMenuItem_Click);
            // 
            // MenuItem2
            // 
            this.MenuItem2.Name = "MenuItem2";
            this.MenuItem2.Size = new System.Drawing.Size(177, 6);
            // 
            // resetMenuItem
            // 
            this.resetMenuItem.Name = "resetMenuItem";
            this.resetMenuItem.Size = new System.Drawing.Size(180, 22);
            this.resetMenuItem.Text = "Reset";
            this.resetMenuItem.Click += new System.EventHandler(this.ResetClick);
            // 
            // menuItem5
            // 
            this.menuItem5.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.mainboardMenuItem,
            this.cpuMenuItem,
            this.ramMenuItem,
            this.gpuMenuItem,
            this.fanControllerMenuItem,
            this.hddMenuItem,
            this.nicMenuItem,
            this.psuMenuItem,
            this.batteryMenuItem});
            this.menuItem5.Name = "menuItem5";
            this.menuItem5.Size = new System.Drawing.Size(180, 22);
            this.menuItem5.Text = "Hardware";
            // 
            // mainboardMenuItem
            // 
            this.mainboardMenuItem.Name = "mainboardMenuItem";
            this.mainboardMenuItem.Size = new System.Drawing.Size(180, 22);
            this.mainboardMenuItem.Text = "Motherboard";
            // 
            // cpuMenuItem
            // 
            this.cpuMenuItem.Name = "cpuMenuItem";
            this.cpuMenuItem.Size = new System.Drawing.Size(180, 22);
            this.cpuMenuItem.Text = "CPU";
            // 
            // ramMenuItem
            // 
            this.ramMenuItem.Name = "ramMenuItem";
            this.ramMenuItem.Size = new System.Drawing.Size(180, 22);
            this.ramMenuItem.Text = "RAM";
            // 
            // gpuMenuItem
            // 
            this.gpuMenuItem.Name = "gpuMenuItem";
            this.gpuMenuItem.Size = new System.Drawing.Size(180, 22);
            this.gpuMenuItem.Text = "GPU";
            // 
            // fanControllerMenuItem
            // 
            this.fanControllerMenuItem.Name = "fanControllerMenuItem";
            this.fanControllerMenuItem.Size = new System.Drawing.Size(180, 22);
            this.fanControllerMenuItem.Text = "Fan Controllers";
            // 
            // hddMenuItem
            // 
            this.hddMenuItem.Name = "hddMenuItem";
            this.hddMenuItem.Size = new System.Drawing.Size(180, 22);
            this.hddMenuItem.Text = "Storage Devices";
            // 
            // nicMenuItem
            // 
            this.nicMenuItem.Name = "nicMenuItem";
            this.nicMenuItem.Size = new System.Drawing.Size(180, 22);
            this.nicMenuItem.Text = "Network";
            // 
            // psuMenuItem
            // 
            this.psuMenuItem.Name = "psuMenuItem";
            this.psuMenuItem.Size = new System.Drawing.Size(180, 22);
            this.psuMenuItem.Text = "Power supplies";
            // 
            // menuItem6
            // 
            this.menuItem6.Name = "menuItem6";
            this.menuItem6.Size = new System.Drawing.Size(177, 6);
            // 
            // exitMenuItem
            // 
            this.exitMenuItem.Name = "exitMenuItem";
            this.exitMenuItem.Size = new System.Drawing.Size(180, 22);
            this.exitMenuItem.Text = "Exit";
            this.exitMenuItem.Click += new System.EventHandler(this.ExitClick);
            // 
            // viewMenuItem
            // 
            this.viewMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.resetMinMaxMenuItem,
            this.resetPlotMenuItem,
            this.MenuItem3,
            this.hiddenMenuItem,
            this.plotMenuItem,
            this.gadgetMenuItem,
            this.MenuItem1,
            this.columnsMenuItem});
            this.viewMenuItem.Name = "viewMenuItem";
            this.viewMenuItem.Size = new System.Drawing.Size(44, 20);
            this.viewMenuItem.Text = "View";
            // 
            // resetMinMaxMenuItem
            // 
            this.resetMinMaxMenuItem.Name = "resetMinMaxMenuItem";
            this.resetMinMaxMenuItem.Size = new System.Drawing.Size(188, 22);
            this.resetMinMaxMenuItem.Text = "Reset Min/Max";
            this.resetMinMaxMenuItem.Click += new System.EventHandler(this.ResetMinMaxMenuItem_Click);
            // 
            // resetPlotMenuItem
            // 
            this.resetPlotMenuItem.Name = "resetPlotMenuItem";
            this.resetPlotMenuItem.Size = new System.Drawing.Size(188, 22);
            this.resetPlotMenuItem.Text = "Reset Plot";
            this.resetPlotMenuItem.Click += new System.EventHandler(this.resetPlotMenuItem_Click);
            // 
            // MenuItem3
            // 
            this.MenuItem3.Name = "MenuItem3";
            this.MenuItem3.Size = new System.Drawing.Size(185, 6);
            // 
            // hiddenMenuItem
            // 
            this.hiddenMenuItem.Name = "hiddenMenuItem";
            this.hiddenMenuItem.Size = new System.Drawing.Size(188, 22);
            this.hiddenMenuItem.Text = "Show Hidden Sensors";
            // 
            // plotMenuItem
            // 
            this.plotMenuItem.Name = "plotMenuItem";
            this.plotMenuItem.Size = new System.Drawing.Size(188, 22);
            this.plotMenuItem.Text = "Show Plot";
            // 
            // gadgetMenuItem
            // 
            this.gadgetMenuItem.Name = "gadgetMenuItem";
            this.gadgetMenuItem.Size = new System.Drawing.Size(188, 22);
            this.gadgetMenuItem.Text = "Show Gadget";
            // 
            // MenuItem1
            // 
            this.MenuItem1.Name = "MenuItem1";
            this.MenuItem1.Size = new System.Drawing.Size(185, 6);
            // 
            // columnsMenuItem
            // 
            this.columnsMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.valueMenuItem,
            this.minMenuItem,
            this.maxMenuItem});
            this.columnsMenuItem.Name = "columnsMenuItem";
            this.columnsMenuItem.Size = new System.Drawing.Size(188, 22);
            this.columnsMenuItem.Text = "Columns";
            // 
            // valueMenuItem
            // 
            this.valueMenuItem.Name = "valueMenuItem";
            this.valueMenuItem.Size = new System.Drawing.Size(180, 22);
            this.valueMenuItem.Text = "Value";
            // 
            // minMenuItem
            // 
            this.minMenuItem.Name = "minMenuItem";
            this.minMenuItem.Size = new System.Drawing.Size(180, 22);
            this.minMenuItem.Text = "Min";
            // 
            // maxMenuItem
            // 
            this.maxMenuItem.Name = "maxMenuItem";
            this.maxMenuItem.Size = new System.Drawing.Size(180, 22);
            this.maxMenuItem.Text = "Max";
            // 
            // optionsMenuItem
            // 
            this.optionsMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.startMinMenuItem,
            this.minTrayMenuItem,
            this.minCloseMenuItem,
            this.startupMenuItem,
            this.separatorMenuItem,
            this.temperatureUnitsMenuItem,
            this.plotLocationMenuItem,
            this.logSeparatorMenuItem,
            this.logSensorsMenuItem,
            this.loggingIntervalMenuItem,
            this.updateIntervalMenuItem,
            this.sensorValuesTimeWindowMenuItem,
            this.webMenuItemSeparator,
            this.webMenuItem});
            this.optionsMenuItem.Name = "optionsMenuItem";
            this.optionsMenuItem.Size = new System.Drawing.Size(61, 20);
            this.optionsMenuItem.Text = "Options";
            // 
            // startMinMenuItem
            // 
            this.startMinMenuItem.Name = "startMinMenuItem";
            this.startMinMenuItem.Size = new System.Drawing.Size(221, 22);
            this.startMinMenuItem.Text = "Start Minimized";
            // 
            // minTrayMenuItem
            // 
            this.minTrayMenuItem.Name = "minTrayMenuItem";
            this.minTrayMenuItem.Size = new System.Drawing.Size(221, 22);
            this.minTrayMenuItem.Text = "Minimize To Tray";
            // 
            // minCloseMenuItem
            // 
            this.minCloseMenuItem.Name = "minCloseMenuItem";
            this.minCloseMenuItem.Size = new System.Drawing.Size(221, 22);
            this.minCloseMenuItem.Text = "Minimize On Close";
            // 
            // startupMenuItem
            // 
            this.startupMenuItem.Name = "startupMenuItem";
            this.startupMenuItem.Size = new System.Drawing.Size(221, 22);
            this.startupMenuItem.Text = "Run On Windows Startup";
            // 
            // separatorMenuItem
            // 
            this.separatorMenuItem.Name = "separatorMenuItem";
            this.separatorMenuItem.Size = new System.Drawing.Size(218, 6);
            // 
            // temperatureUnitsMenuItem
            // 
            this.temperatureUnitsMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.celsiusMenuItem,
            this.fahrenheitMenuItem});
            this.temperatureUnitsMenuItem.Name = "temperatureUnitsMenuItem";
            this.temperatureUnitsMenuItem.Size = new System.Drawing.Size(221, 22);
            this.temperatureUnitsMenuItem.Text = "Temperature Unit";
            // 
            // celsiusMenuItem
            // 
            this.celsiusMenuItem.CheckOnClick = true;
            this.celsiusMenuItem.Name = "celsiusMenuItem";
            this.celsiusMenuItem.Size = new System.Drawing.Size(130, 22);
            this.celsiusMenuItem.Text = "Celsius";
            this.celsiusMenuItem.Click += new System.EventHandler(this.CelsiusMenuItem_Click);
            // 
            // fahrenheitMenuItem
            // 
            this.fahrenheitMenuItem.CheckOnClick = true;
            this.fahrenheitMenuItem.Name = "fahrenheitMenuItem";
            this.fahrenheitMenuItem.Size = new System.Drawing.Size(130, 22);
            this.fahrenheitMenuItem.Text = "Fahrenheit";
            this.fahrenheitMenuItem.Click += new System.EventHandler(this.FahrenheitMenuItem_Click);
            // 
            // plotLocationMenuItem
            // 
            this.plotLocationMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.plotWindowMenuItem,
            this.plotBottomMenuItem,
            this.plotRightMenuItem});
            this.plotLocationMenuItem.Name = "plotLocationMenuItem";
            this.plotLocationMenuItem.Size = new System.Drawing.Size(221, 22);
            this.plotLocationMenuItem.Text = "Plot Location";
            // 
            // plotWindowMenuItem
            // 
            this.plotWindowMenuItem.CheckOnClick = true;
            this.plotWindowMenuItem.Name = "plotWindowMenuItem";
            this.plotWindowMenuItem.Size = new System.Drawing.Size(118, 22);
            this.plotWindowMenuItem.Text = "Window";
            // 
            // plotBottomMenuItem
            // 
            this.plotBottomMenuItem.CheckOnClick = true;
            this.plotBottomMenuItem.Name = "plotBottomMenuItem";
            this.plotBottomMenuItem.Size = new System.Drawing.Size(118, 22);
            this.plotBottomMenuItem.Text = "Bottom";
            // 
            // plotRightMenuItem
            // 
            this.plotRightMenuItem.CheckOnClick = true;
            this.plotRightMenuItem.Name = "plotRightMenuItem";
            this.plotRightMenuItem.Size = new System.Drawing.Size(118, 22);
            this.plotRightMenuItem.Text = "Right";
            // 
            // logSeparatorMenuItem
            // 
            this.logSeparatorMenuItem.Name = "logSeparatorMenuItem";
            this.logSeparatorMenuItem.Size = new System.Drawing.Size(218, 6);
            // 
            // logSensorsMenuItem
            // 
            this.logSensorsMenuItem.Name = "logSensorsMenuItem";
            this.logSensorsMenuItem.Size = new System.Drawing.Size(221, 22);
            this.logSensorsMenuItem.Text = "Log Sensors";
            // 
            // loggingIntervalMenuItem
            // 
            this.loggingIntervalMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.log1sMenuItem,
            this.log2sMenuItem,
            this.log5sMenuItem,
            this.log10sMenuItem,
            this.log30sMenuItem,
            this.log1minMenuItem,
            this.log2minMenuItem,
            this.log5minMenuItem,
            this.log10minMenuItem,
            this.log30minMenuItem,
            this.log1hMenuItem,
            this.log2hMenuItem,
            this.log6hMenuItem});
            this.loggingIntervalMenuItem.Name = "loggingIntervalMenuItem";
            this.loggingIntervalMenuItem.Size = new System.Drawing.Size(221, 22);
            this.loggingIntervalMenuItem.Text = "Logging Interval";
            // 
            // log1sMenuItem
            // 
            this.log1sMenuItem.CheckOnClick = true;
            this.log1sMenuItem.Name = "log1sMenuItem";
            this.log1sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log1sMenuItem.Text = "1s";
            // 
            // log2sMenuItem
            // 
            this.log2sMenuItem.CheckOnClick = true;
            this.log2sMenuItem.Name = "log2sMenuItem";
            this.log2sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log2sMenuItem.Text = "2s";
            // 
            // log5sMenuItem
            // 
            this.log5sMenuItem.CheckOnClick = true;
            this.log5sMenuItem.Name = "log5sMenuItem";
            this.log5sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log5sMenuItem.Text = "5s";
            // 
            // log10sMenuItem
            // 
            this.log10sMenuItem.CheckOnClick = true;
            this.log10sMenuItem.Name = "log10sMenuItem";
            this.log10sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log10sMenuItem.Text = "10s";
            // 
            // log30sMenuItem
            // 
            this.log30sMenuItem.CheckOnClick = true;
            this.log30sMenuItem.Name = "log30sMenuItem";
            this.log30sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log30sMenuItem.Text = "30s";
            // 
            // log1minMenuItem
            // 
            this.log1minMenuItem.CheckOnClick = true;
            this.log1minMenuItem.Name = "log1minMenuItem";
            this.log1minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log1minMenuItem.Text = "1min";
            // 
            // log2minMenuItem
            // 
            this.log2minMenuItem.CheckOnClick = true;
            this.log2minMenuItem.Name = "log2minMenuItem";
            this.log2minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log2minMenuItem.Text = "2min";
            // 
            // log5minMenuItem
            // 
            this.log5minMenuItem.CheckOnClick = true;
            this.log5minMenuItem.Name = "log5minMenuItem";
            this.log5minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log5minMenuItem.Text = "5min";
            // 
            // log10minMenuItem
            // 
            this.log10minMenuItem.CheckOnClick = true;
            this.log10minMenuItem.Name = "log10minMenuItem";
            this.log10minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log10minMenuItem.Text = "10min";
            // 
            // log30minMenuItem
            // 
            this.log30minMenuItem.CheckOnClick = true;
            this.log30minMenuItem.Name = "log30minMenuItem";
            this.log30minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log30minMenuItem.Text = "30min";
            // 
            // log1hMenuItem
            // 
            this.log1hMenuItem.CheckOnClick = true;
            this.log1hMenuItem.Name = "log1hMenuItem";
            this.log1hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log1hMenuItem.Text = "1h";
            // 
            // log2hMenuItem
            // 
            this.log2hMenuItem.CheckOnClick = true;
            this.log2hMenuItem.Name = "log2hMenuItem";
            this.log2hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log2hMenuItem.Text = "2h";
            // 
            // log6hMenuItem
            // 
            this.log6hMenuItem.CheckOnClick = true;
            this.log6hMenuItem.Name = "log6hMenuItem";
            this.log6hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log6hMenuItem.Text = "6h";
            //
            // updateIntervalMenuItem
            // 
            this.updateIntervalMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.updateInterval250msMenuItem,
            this.updateInterval500msMenuItem,
            this.updateInterval1sMenuItem,
            this.updateInterval2sMenuItem,
            this.updateInterval5sMenuItem,
            this.updateInterval10sMenuItem});
            this.updateIntervalMenuItem.Name = "updateIntervalMenuItem";
            this.updateIntervalMenuItem.Size = new System.Drawing.Size(221, 22);
            this.updateIntervalMenuItem.Text = "Update Interval";
            // 
            // updateInterval250msMenuItem
            // 
            this.updateInterval250msMenuItem.CheckOnClick = true;
            this.updateInterval250msMenuItem.Name = "updateInterval250msMenuItem";
            this.updateInterval250msMenuItem.Size = new System.Drawing.Size(107, 22);
            this.updateInterval250msMenuItem.Text = "250ms";
            // 
            // updateInterval500msMenuItem
            // 
            this.updateInterval500msMenuItem.CheckOnClick = true;
            this.updateInterval500msMenuItem.Name = "updateInterval500msMenuItem";
            this.updateInterval500msMenuItem.Size = new System.Drawing.Size(107, 22);
            this.updateInterval500msMenuItem.Text = "500ms";
            // 
            // updateInterval1sMenuItem
            // 
            this.updateInterval1sMenuItem.CheckOnClick = true;
            this.updateInterval1sMenuItem.Name = "updateInterval1sMenuItem";
            this.updateInterval1sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.updateInterval1sMenuItem.Text = "1s";
            // 
            // updateInterval2sMenuItem
            // 
            this.updateInterval2sMenuItem.CheckOnClick = true;
            this.updateInterval2sMenuItem.Name = "updateInterval2sMenuItem";
            this.updateInterval2sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.updateInterval2sMenuItem.Text = "2s";
            // 
            // updateInterval5sMenuItem
            // 
            this.updateInterval5sMenuItem.CheckOnClick = true;
            this.updateInterval5sMenuItem.Name = "updateInterval5sMenuItem";
            this.updateInterval5sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.updateInterval5sMenuItem.Text = "5s";
            // 
            // updateInterval10sMenuItem
            // 
            this.updateInterval10sMenuItem.CheckOnClick = true;
            this.updateInterval10sMenuItem.Name = "updateInterval10sMenuItem";
            this.updateInterval10sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.updateInterval10sMenuItem.Text = "10s";
            // 
            // sensorValuesTimeWindowMenuItem
            // 
            this.sensorValuesTimeWindowMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.timeWindow30sMenuItem,
            this.timeWindow1minMenuItem,
            this.timeWindow2minMenuItem,
            this.timeWindow5minMenuItem,
            this.timeWindow10minMenuItem,
            this.timeWindow30minMenuItem,
            this.timeWindow1hMenuItem,
            this.timeWindow2hMenuItem,
            this.timeWindow6hMenuItem,
            this.timeWindow12hMenuItem,
            this.timeWindow24hMenuItem});
            this.sensorValuesTimeWindowMenuItem.Name = "sensorValuesTimeWindowMenuItem";
            this.sensorValuesTimeWindowMenuItem.Size = new System.Drawing.Size(221, 22);
            this.sensorValuesTimeWindowMenuItem.Text = "Sensor Values Time Window";
            // 
            // timeWindow30sMenuItem
            // 
            this.timeWindow30sMenuItem.CheckOnClick = true;
            this.timeWindow30sMenuItem.Name = "timeWindow30sMenuItem";
            this.timeWindow30sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow30sMenuItem.Text = "30s";
            // 
            // timeWindow1minMenuItem
            // 
            this.timeWindow1minMenuItem.CheckOnClick = true;
            this.timeWindow1minMenuItem.Name = "timeWindow1minMenuItem";
            this.timeWindow1minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow1minMenuItem.Text = "1min";
            // 
            // timeWindow2minMenuItem
            // 
            this.timeWindow2minMenuItem.CheckOnClick = true;
            this.timeWindow2minMenuItem.Name = "timeWindow2minMenuItem";
            this.timeWindow2minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow2minMenuItem.Text = "2min";
            // 
            // timeWindow5minMenuItem
            // 
            this.timeWindow5minMenuItem.CheckOnClick = true;
            this.timeWindow5minMenuItem.Name = "timeWindow5minMenuItem";
            this.timeWindow5minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow5minMenuItem.Text = "5min";
            // 
            // timeWindow10minMenuItem
            // 
            this.timeWindow10minMenuItem.CheckOnClick = true;
            this.timeWindow10minMenuItem.Name = "timeWindow10minMenuItem";
            this.timeWindow10minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow10minMenuItem.Text = "10min";
            // 
            // timeWindow30minMenuItem
            // 
            this.timeWindow30minMenuItem.CheckOnClick = true;
            this.timeWindow30minMenuItem.Name = "timeWindow30minMenuItem";
            this.timeWindow30minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow30minMenuItem.Text = "30min";
            // 
            // timeWindow1hMenuItem
            // 
            this.timeWindow1hMenuItem.CheckOnClick = true;
            this.timeWindow1hMenuItem.Name = "timeWindow1hMenuItem";
            this.timeWindow1hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow1hMenuItem.Text = "1h";
            // 
            // timeWindow2hMenuItem
            // 
            this.timeWindow2hMenuItem.CheckOnClick = true;
            this.timeWindow2hMenuItem.Name = "timeWindow2hMenuItem";
            this.timeWindow2hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow2hMenuItem.Text = "2n";
            // 
            // timeWindow6hMenuItem
            // 
            this.timeWindow6hMenuItem.CheckOnClick = true;
            this.timeWindow6hMenuItem.Name = "timeWindow6hMenuItem";
            this.timeWindow6hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow6hMenuItem.Text = "6h";
            // 
            // timeWindow12hMenuItem
            // 
            this.timeWindow12hMenuItem.CheckOnClick = true;
            this.timeWindow12hMenuItem.Name = "timeWindow12hMenuItem";
            this.timeWindow12hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow12hMenuItem.Text = "12h";
            // 
            // timeWindow24hMenuItem
            // 
            this.timeWindow24hMenuItem.CheckOnClick = true;
            this.timeWindow24hMenuItem.Name = "timeWindow24hMenuItem";
            this.timeWindow24hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow24hMenuItem.Text = "24h";
            // 
            // webMenuItemSeparator
            // 
            this.webMenuItemSeparator.Name = "webMenuItemSeparator";
            this.webMenuItemSeparator.Size = new System.Drawing.Size(218, 6);
            // 
            // webMenuItem
            // 
            this.webMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.runWebServerMenuItem,
            this.serverPortMenuItem,
            this.authWebServerMenuItem});
            this.webMenuItem.Name = "webMenuItem";
            this.webMenuItem.Size = new System.Drawing.Size(221, 22);
            this.webMenuItem.Text = "Remote Web Server";
            // 
            // runWebServerMenuItem
            // 
            this.runWebServerMenuItem.Name = "runWebServerMenuItem";
            this.runWebServerMenuItem.Size = new System.Drawing.Size(153, 22);
            this.runWebServerMenuItem.Text = "Run";
            // 
            // serverPortMenuItem
            // 
            this.serverPortMenuItem.Name = "serverPortMenuItem";
            this.serverPortMenuItem.Size = new System.Drawing.Size(153, 22);
            this.serverPortMenuItem.Text = "Port";
            this.serverPortMenuItem.Click += new System.EventHandler(this.ServerPortMenuItem_Click);
            // 
            // authWebServerMenuItem
            // 
            this.authWebServerMenuItem.Name = "authWebServerMenuItem";
            this.authWebServerMenuItem.Size = new System.Drawing.Size(153, 22);
            this.authWebServerMenuItem.Text = "Authentication";
            this.authWebServerMenuItem.Click += new System.EventHandler(this.AuthWebServerMenuItem_Click);
            // 
            // helpMenuItem
            // 
            this.helpMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.aboutMenuItem});
            this.helpMenuItem.Name = "helpMenuItem";
            this.helpMenuItem.Size = new System.Drawing.Size(44, 20);
            this.helpMenuItem.Text = "Help";
            // 
            // aboutMenuItem
            // 
            this.aboutMenuItem.Name = "aboutMenuItem";
            this.aboutMenuItem.Size = new System.Drawing.Size(107, 22);
            this.aboutMenuItem.Text = "About";
            this.aboutMenuItem.Click += new System.EventHandler(this.AboutMenuItem_Click);
            // 
            // treeContextMenu
            // 
            this.treeContextMenu.Name = "treeContextMenu";
            this.treeContextMenu.Size = new System.Drawing.Size(61, 4);
            // 
            // saveFileDialog
            // 
            this.saveFileDialog.DefaultExt = "txt";
            this.saveFileDialog.FileName = "LibreHardwareMonitor.Report.txt";
            this.saveFileDialog.Filter = "Text Documents|*.txt|All Files|*.*";
            this.saveFileDialog.RestoreDirectory = true;
            this.saveFileDialog.Title = "Save Report As";
            // 
            // timer
            // 
            this.timer.Interval = 1000;
            this.timer.Tick += new System.EventHandler(this.Timer_Tick);
            // 
            // splitContainer
            // 
            this.splitContainer.Border3DStyle = System.Windows.Forms.Border3DStyle.Raised;
            this.splitContainer.Color = System.Drawing.SystemColors.Control;
            this.splitContainer.Cursor = System.Windows.Forms.Cursors.Default;
            this.splitContainer.Location = new System.Drawing.Point(12, 12);
            this.splitContainer.Name = "splitContainer";
            this.splitContainer.Orientation = System.Windows.Forms.Orientation.Horizontal;
            // 
            // splitContainer.Panel1
            // 
            this.splitContainer.Panel1.Controls.Add(this.treeView);
            // 
            // splitContainer.Panel2
            // 
            this.splitContainer.Panel2.Cursor = System.Windows.Forms.Cursors.Default;
            this.splitContainer.Size = new System.Drawing.Size(386, 483);
            this.splitContainer.SplitterDistance = 354;
            this.splitContainer.SplitterWidth = 5;
            this.splitContainer.TabIndex = 3;
            // 
            // treeView
            // 
            this.treeView.BackColor = System.Drawing.SystemColors.Window;
            this.treeView.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.treeView.Columns.Add(this.sensor);
            this.treeView.Columns.Add(this.value);
            this.treeView.Columns.Add(this.min);
            this.treeView.Columns.Add(this.max);
            this.treeView.DefaultToolTipProvider = null;
            this.treeView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.treeView.DragDropMarkColor = System.Drawing.Color.Black;
            this.treeView.FullRowSelect = true;
            this.treeView.GridLineStyle = Aga.Controls.Tree.GridLineStyle.Horizontal;
            this.treeView.LineColor = System.Drawing.SystemColors.ControlDark;
            this.treeView.Location = new System.Drawing.Point(0, 0);
            this.treeView.Model = null;
            this.treeView.Name = "treeView";
            this.treeView.NodeControls.Add(this.nodeImage);
            this.treeView.NodeControls.Add(this.nodeCheckBox);
            this.treeView.NodeControls.Add(this.nodeTextBoxText);
            this.treeView.NodeControls.Add(this.nodeTextBoxValue);
            this.treeView.NodeControls.Add(this.nodeTextBoxMin);
            this.treeView.NodeControls.Add(this.nodeTextBoxMax);
            this.treeView.SelectedNode = null;
            this.treeView.Size = new System.Drawing.Size(386, 354);
            this.treeView.TabIndex = 0;
            this.treeView.Text = "treeView";
            this.treeView.UseColumns = true;
            this.treeView.NodeMouseDoubleClick += new System.EventHandler<Aga.Controls.Tree.TreeNodeAdvMouseEventArgs>(this.TreeView_NodeMouseDoubleClick);
            this.treeView.Click += new System.EventHandler(this.TreeView_Click);
            this.treeView.MouseDown += new System.Windows.Forms.MouseEventHandler(this.TreeView_MouseDown);
            this.treeView.MouseMove += new System.Windows.Forms.MouseEventHandler(this.TreeView_MouseMove);
            this.treeView.MouseUp += new System.Windows.Forms.MouseEventHandler(this.TreeView_MouseUp);
            // 
            // batteryMenuItem
            // 
            this.batteryMenuItem.Name = "batteryMenuItem";
            this.batteryMenuItem.Size = new System.Drawing.Size(180, 22);
            this.batteryMenuItem.Text = "Batteries";
            // 
            // MainForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(418, 533);
            this.Controls.Add(this.splitContainer);
            this.Controls.Add(this.mainMenu);
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.MainMenuStrip = this.mainMenu;
            this.Name = "MainForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.Manual;
            this.Text = "Libre Hardware Monitor";
            this.Load += new System.EventHandler(this.MainForm_Load);
            this.ResizeEnd += new System.EventHandler(this.MainForm_MoveOrResize);
            this.Move += new System.EventHandler(this.MainForm_MoveOrResize);
            this.mainMenu.ResumeLayout(false);
            this.mainMenu.PerformLayout();
            this.splitContainer.Panel1.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer)).EndInit();
            this.splitContainer.ResumeLayout(false);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private Aga.Controls.Tree.TreeViewAdv treeView;
        private System.Windows.Forms.MenuStrip mainMenu;
        private System.Windows.Forms.ToolStripMenuItem fileMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exitMenuItem;
        private Aga.Controls.Tree.TreeColumn sensor;
        private Aga.Controls.Tree.TreeColumn value;
        private Aga.Controls.Tree.TreeColumn min;
        private Aga.Controls.Tree.TreeColumn max;
        private Aga.Controls.Tree.NodeControls.NodeIcon nodeImage;
        private Aga.Controls.Tree.NodeControls.NodeTextBox nodeTextBoxText;
        private Aga.Controls.Tree.NodeControls.NodeTextBox nodeTextBoxValue;
        private Aga.Controls.Tree.NodeControls.NodeTextBox nodeTextBoxMin;
        private Aga.Controls.Tree.NodeControls.NodeTextBox nodeTextBoxMax;
        private SplitContainerAdv splitContainer;
        private System.Windows.Forms.ToolStripMenuItem viewMenuItem;
        private System.Windows.Forms.ToolStripMenuItem plotMenuItem;
        private Aga.Controls.Tree.NodeControls.NodeCheckBox nodeCheckBox;
        private System.Windows.Forms.ToolStripMenuItem helpMenuItem;
        private System.Windows.Forms.ToolStripMenuItem aboutMenuItem;
        private System.Windows.Forms.ToolStripMenuItem saveReportMenuItem;
        private System.Windows.Forms.ToolStripMenuItem optionsMenuItem;
        private System.Windows.Forms.ToolStripMenuItem hddMenuItem;
        private System.Windows.Forms.ToolStripMenuItem minTrayMenuItem;
        private System.Windows.Forms.ToolStripSeparator separatorMenuItem;
        private System.Windows.Forms.ContextMenuStrip treeContextMenu;
        private System.Windows.Forms.ToolStripMenuItem startMinMenuItem;
        private System.Windows.Forms.ToolStripMenuItem startupMenuItem;
        private System.Windows.Forms.SaveFileDialog saveFileDialog;
        private System.Windows.Forms.Timer timer;
        private System.Windows.Forms.ToolStripMenuItem hiddenMenuItem;
        private System.Windows.Forms.ToolStripSeparator MenuItem1;
        private System.Windows.Forms.ToolStripMenuItem columnsMenuItem;
        private System.Windows.Forms.ToolStripMenuItem valueMenuItem;
        private System.Windows.Forms.ToolStripMenuItem minMenuItem;
        private System.Windows.Forms.ToolStripMenuItem maxMenuItem;
        private System.Windows.Forms.ToolStripMenuItem temperatureUnitsMenuItem;
        private System.Windows.Forms.ToolStripSeparator webMenuItemSeparator;
        private ToolStripRadioButtonMenuItem celsiusMenuItem;
        private ToolStripRadioButtonMenuItem fahrenheitMenuItem;
        private System.Windows.Forms.ToolStripSeparator MenuItem2;
        private System.Windows.Forms.ToolStripMenuItem resetMinMaxMenuItem;
        private System.Windows.Forms.ToolStripMenuItem resetPlotMenuItem;
        private System.Windows.Forms.ToolStripSeparator MenuItem3;
        private System.Windows.Forms.ToolStripMenuItem gadgetMenuItem;
        private System.Windows.Forms.ToolStripMenuItem minCloseMenuItem;
        private System.Windows.Forms.ToolStripMenuItem resetMenuItem;
        private System.Windows.Forms.ToolStripSeparator menuItem6;
        private System.Windows.Forms.ToolStripMenuItem plotLocationMenuItem;
        private ToolStripRadioButtonMenuItem plotWindowMenuItem;
        private ToolStripRadioButtonMenuItem plotBottomMenuItem;
        private ToolStripRadioButtonMenuItem plotRightMenuItem;
        private System.Windows.Forms.ToolStripMenuItem webMenuItem;
        private System.Windows.Forms.ToolStripMenuItem runWebServerMenuItem;
        private System.Windows.Forms.ToolStripMenuItem serverPortMenuItem;
        private System.Windows.Forms.ToolStripMenuItem menuItem5;
        private System.Windows.Forms.ToolStripMenuItem mainboardMenuItem;
        private System.Windows.Forms.ToolStripMenuItem cpuMenuItem;
        private System.Windows.Forms.ToolStripMenuItem gpuMenuItem;
        private System.Windows.Forms.ToolStripMenuItem fanControllerMenuItem;
        private System.Windows.Forms.ToolStripMenuItem ramMenuItem;
        private System.Windows.Forms.ToolStripMenuItem logSensorsMenuItem;
        private System.Windows.Forms.ToolStripSeparator logSeparatorMenuItem;
        private System.Windows.Forms.ToolStripMenuItem loggingIntervalMenuItem;
        private ToolStripRadioButtonMenuItem log1sMenuItem;
        private ToolStripRadioButtonMenuItem log2sMenuItem;
        private ToolStripRadioButtonMenuItem log5sMenuItem;
        private ToolStripRadioButtonMenuItem log10sMenuItem;
        private ToolStripRadioButtonMenuItem log30sMenuItem;
        private ToolStripRadioButtonMenuItem log1minMenuItem;
        private ToolStripRadioButtonMenuItem log2minMenuItem;
        private ToolStripRadioButtonMenuItem log5minMenuItem;
        private ToolStripRadioButtonMenuItem log10minMenuItem;
        private ToolStripRadioButtonMenuItem log30minMenuItem;
        private ToolStripRadioButtonMenuItem log1hMenuItem;
        private ToolStripRadioButtonMenuItem log2hMenuItem;
        private ToolStripRadioButtonMenuItem log6hMenuItem;
        private System.Windows.Forms.ToolStripMenuItem updateIntervalMenuItem;
        private ToolStripRadioButtonMenuItem updateInterval250msMenuItem;
        private ToolStripRadioButtonMenuItem updateInterval500msMenuItem;
        private ToolStripRadioButtonMenuItem updateInterval1sMenuItem;
        private ToolStripRadioButtonMenuItem updateInterval2sMenuItem;
        private ToolStripRadioButtonMenuItem updateInterval5sMenuItem;
        private ToolStripRadioButtonMenuItem updateInterval10sMenuItem;
        private System.Windows.Forms.ToolStripMenuItem nicMenuItem;
        private System.Windows.Forms.ToolStripMenuItem sensorValuesTimeWindowMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow30sMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow1minMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow2minMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow5minMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow10minMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow30minMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow1hMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow2hMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow6hMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow12hMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow24hMenuItem;
        private System.Windows.Forms.ToolStripMenuItem authWebServerMenuItem;
        private System.Windows.Forms.ToolStripMenuItem psuMenuItem;
        private System.Windows.Forms.ToolStripMenuItem batteryMenuItem;
        private System.ComponentModel.BackgroundWorker backgroundUpdater;
    }
}


```

`LibreHardwareMonitor/UI/MainForm.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using Aga.Controls.Tree;
using Aga.Controls.Tree.NodeControls;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;
using LibreHardwareMonitor.Wmi;

namespace LibreHardwareMonitor.UI;

public sealed partial class MainForm : Form
{
    private readonly UserOption _autoStart;
    private readonly Computer _computer;
    private readonly SensorGadget _gadget;
    private readonly Logger _logger;
    private readonly UserRadioGroup _loggingInterval;
    private readonly UserRadioGroup _updateInterval;
    private readonly UserOption _logSensors;
    private readonly UserOption _minimizeOnClose;
    private readonly UserOption _minimizeToTray;
    private readonly Color[] _plotColorPalette;
    private readonly PlotPanel _plotPanel;
    private readonly UserOption _readBatterySensors;
    private readonly UserOption _readCpuSensors;
    private readonly UserOption _readFanControllersSensors;
    private readonly UserOption _readGpuSensors;
    private readonly UserOption _readHddSensors;
    private readonly UserOption _readMainboardSensors;
    private readonly UserOption _readNicSensors;
    private readonly UserOption _readPsuSensors;
    private readonly UserOption _readRamSensors;
    private readonly Node _root;
    private readonly UserOption _runWebServer;
    private readonly UserRadioGroup _sensorValuesTimeWindow;
    private readonly PersistentSettings _settings;
    private readonly UserOption _showGadget;
    private readonly StartupManager _startupManager = new();
    private readonly SystemTray _systemTray;
    private readonly UnitManager _unitManager;
    private readonly UpdateVisitor _updateVisitor = new();
    private readonly WmiProvider _wmiProvider;

    private int _delayCount;
    private Form _plotForm;
    private UserRadioGroup _plotLocation;
    private bool _selectionDragging;
    private IDictionary<ISensor, Color> _sensorPlotColors = new Dictionary<ISensor, Color>();
    private UserOption _showPlot;

    public MainForm()
    {
        InitializeComponent();

        _settings = new PersistentSettings();
        _settings.Load(Path.ChangeExtension(Application.ExecutablePath, ".config"));

        _unitManager = new UnitManager(_settings);

        // make sure the buffers used for double buffering are not disposed
        // after each draw call
        BufferedGraphicsManager.Current.MaximumBuffer = Screen.PrimaryScreen.Bounds.Size;

        // set the DockStyle here, to avoid conflicts with the MainMenu
        splitContainer.Dock = DockStyle.Fill;

        Font = SystemFonts.MessageBoxFont;
        treeView.Font = SystemFonts.MessageBoxFont;

        // Set the bounds immediately, so that our child components can be
        // properly placed.
        Bounds = new Rectangle
        {
            X = _settings.GetValue("mainForm.Location.X", Location.X),
            Y = _settings.GetValue("mainForm.Location.Y", Location.Y),
            Width = _settings.GetValue("mainForm.Width", 470),
            Height = _settings.GetValue("mainForm.Height", 640)
        };

        _plotPanel = new PlotPanel(_settings, _unitManager) { Font = SystemFonts.MessageBoxFont, Dock = DockStyle.Fill };

        nodeCheckBox.IsVisibleValueNeeded += NodeCheckBox_IsVisibleValueNeeded;
        nodeTextBoxText.DrawText += NodeTextBoxText_DrawText;
        nodeTextBoxValue.DrawText += NodeTextBoxText_DrawText;
        nodeTextBoxMin.DrawText += NodeTextBoxText_DrawText;
        nodeTextBoxMax.DrawText += NodeTextBoxText_DrawText;
        nodeTextBoxText.EditorShowing += NodeTextBoxText_EditorShowing;

        foreach (TreeColumn column in treeView.Columns)
            column.Width = Math.Max(20, Math.Min(400, _settings.GetValue("treeView.Columns." + column.Header + ".Width", column.Width)));

        TreeModel treeModel = new();
        _root = new Node(Environment.MachineName) { Image = EmbeddedResources.GetImage("computer.png") };

        treeModel.Nodes.Add(_root);
        treeView.Model = treeModel;

        _computer = new Computer(_settings);

        _systemTray = new SystemTray(_computer, _settings, _unitManager);
        _systemTray.HideShowCommand += HideShowClick;
        _systemTray.ExitCommand += ExitClick;

        if (Software.OperatingSystem.IsUnix)
        {
            // Unix
            treeView.RowHeight = Math.Max(treeView.RowHeight, 18);
            splitContainer.BorderStyle = BorderStyle.None;
            splitContainer.Border3DStyle = Border3DStyle.Adjust;
            splitContainer.SplitterWidth = 4;
            treeView.BorderStyle = BorderStyle.Fixed3D;
            _plotPanel.BorderStyle = BorderStyle.Fixed3D;
            gadgetMenuItem.Visible = false;
            minCloseMenuItem.Visible = false;
            minTrayMenuItem.Visible = false;
            startMinMenuItem.Visible = false;
        }
        else
        {
            // Windows
            treeView.RowHeight = Math.Max(treeView.Font.Height + 1, 18);
            _gadget = new SensorGadget(_computer, _settings, _unitManager);
            _gadget.HideShowCommand += HideShowClick;
            _wmiProvider = new WmiProvider(_computer);
        }

        treeView.ShowNodeToolTips = true;
        NodeToolTipProvider tooltipProvider = new();
        nodeTextBoxText.ToolTipProvider = tooltipProvider;
        nodeTextBoxValue.ToolTipProvider = tooltipProvider;
        _logger = new Logger(_computer);

        _plotColorPalette = new Color[13];
        _plotColorPalette[0] = Color.Blue;
        _plotColorPalette[1] = Color.OrangeRed;
        _plotColorPalette[2] = Color.Green;
        _plotColorPalette[3] = Color.LightSeaGreen;
        _plotColorPalette[4] = Color.Goldenrod;
        _plotColorPalette[5] = Color.DarkViolet;
        _plotColorPalette[6] = Color.YellowGreen;
        _plotColorPalette[7] = Color.SaddleBrown;
        _plotColorPalette[8] = Color.RoyalBlue;
        _plotColorPalette[9] = Color.DeepPink;
        _plotColorPalette[10] = Color.MediumSeaGreen;
        _plotColorPalette[11] = Color.Olive;
        _plotColorPalette[12] = Color.Firebrick;

        _computer.HardwareAdded += HardwareAdded;
        _computer.HardwareRemoved += HardwareRemoved;
        _computer.Open();

        backgroundUpdater.DoWork += BackgroundUpdater_DoWork;
        timer.Enabled = true;

        UserOption showHiddenSensors = new("hiddenMenuItem", false, hiddenMenuItem, _settings);
        showHiddenSensors.Changed += delegate { treeModel.ForceVisible = showHiddenSensors.Value; };

        UserOption showValue = new("valueMenuItem", true, valueMenuItem, _settings);
        showValue.Changed += delegate { treeView.Columns[1].IsVisible = showValue.Value; };

        UserOption showMin = new("minMenuItem", false, minMenuItem, _settings);
        showMin.Changed += delegate { treeView.Columns[2].IsVisible = showMin.Value; };

        UserOption showMax = new("maxMenuItem", true, maxMenuItem, _settings);
        showMax.Changed += delegate { treeView.Columns[3].IsVisible = showMax.Value; };

        var _ = new UserOption("startMinMenuItem", false, startMinMenuItem, _settings);
        _minimizeToTray = new UserOption("minTrayMenuItem", true, minTrayMenuItem, _settings);
        _minimizeToTray.Changed += delegate { _systemTray.IsMainIconEnabled = _minimizeToTray.Value; };

        _minimizeOnClose = new UserOption("minCloseMenuItem", false, minCloseMenuItem, _settings);

        _autoStart = new UserOption(null, _startupManager.Startup, startupMenuItem, _settings);
        _autoStart.Changed += delegate
        {
            try
            {
                _startupManager.Startup = _autoStart.Value;
            }
            catch (InvalidOperationException)
            {
                MessageBox.Show("Updating the auto-startup option failed.",
                                "Error",
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);

                _autoStart.Value = _startupManager.Startup;
            }
        };

        _readMainboardSensors = new UserOption("mainboardMenuItem", true, mainboardMenuItem, _settings);
        _readMainboardSensors.Changed += delegate { _computer.IsMotherboardEnabled = _readMainboardSensors.Value; };

        _readCpuSensors = new UserOption("cpuMenuItem", true, cpuMenuItem, _settings);
        _readCpuSensors.Changed += delegate { _computer.IsCpuEnabled = _readCpuSensors.Value; };

        _readRamSensors = new UserOption("ramMenuItem", true, ramMenuItem, _settings);
        _readRamSensors.Changed += delegate { _computer.IsMemoryEnabled = _readRamSensors.Value; };

        _readGpuSensors = new UserOption("gpuMenuItem", true, gpuMenuItem, _settings);
        _readGpuSensors.Changed += delegate { _computer.IsGpuEnabled = _readGpuSensors.Value; };

        _readFanControllersSensors = new UserOption("fanControllerMenuItem", true, fanControllerMenuItem, _settings);
        _readFanControllersSensors.Changed += delegate { _computer.IsControllerEnabled = _readFanControllersSensors.Value; };

        _readHddSensors = new UserOption("hddMenuItem", true, hddMenuItem, _settings);
        _readHddSensors.Changed += delegate { _computer.IsStorageEnabled = _readHddSensors.Value; };

        _readNicSensors = new UserOption("nicMenuItem", true, nicMenuItem, _settings);
        _readNicSensors.Changed += delegate { _computer.IsNetworkEnabled = _readNicSensors.Value; };

        _readPsuSensors = new UserOption("psuMenuItem", true, psuMenuItem, _settings);
        _readPsuSensors.Changed += delegate { _computer.IsPsuEnabled = _readPsuSensors.Value; };

        _readBatterySensors = new UserOption("batteryMenuItem", true, batteryMenuItem, _settings);
        _readBatterySensors.Changed += delegate { _computer.IsBatteryEnabled = _readBatterySensors.Value; };

        _showGadget = new UserOption("gadgetMenuItem", false, gadgetMenuItem, _settings);
        _showGadget.Changed += delegate
        {
            if (_gadget != null)
                _gadget.Visible = _showGadget.Value;
        };

        celsiusMenuItem.Checked = _unitManager.TemperatureUnit == TemperatureUnit.Celsius;
        fahrenheitMenuItem.Checked = !celsiusMenuItem.Checked;

        Server = new HttpServer(_root,
                                _settings.GetValue("listenerPort", 8085),
                                _settings.GetValue("authenticationEnabled", false),
                                _settings.GetValue("authenticationUserName", ""),
                                _settings.GetValue("authenticationPassword", ""));

        if (Server.PlatformNotSupported)
        {
            webMenuItemSeparator.Visible = false;
            webMenuItem.Visible = false;
        }

        _runWebServer = new UserOption("runWebServerMenuItem", false, runWebServerMenuItem, _settings);
        _runWebServer.Changed += delegate
        {
            if (_runWebServer.Value)
                Server.StartHttpListener();
            else
                Server.StopHttpListener();
        };

        authWebServerMenuItem.Checked = _settings.GetValue("authenticationEnabled", false);

        _logSensors = new UserOption("logSensorsMenuItem", false, logSensorsMenuItem, _settings);

        _loggingInterval = new UserRadioGroup("loggingInterval",
                                              0,
                                              new[]
                                              {
                                                  log1sMenuItem,
                                                  log2sMenuItem,
                                                  log5sMenuItem,
                                                  log10sMenuItem,
                                                  log30sMenuItem,
                                                  log1minMenuItem,
                                                  log2minMenuItem,
                                                  log5minMenuItem,
                                                  log10minMenuItem,
                                                  log30minMenuItem,
                                                  log1hMenuItem,
                                                  log2hMenuItem,
                                                  log6hMenuItem
                                              },
                                              _settings);

        _loggingInterval.Changed += (sender, e) =>
        {
            switch (_loggingInterval.Value)
            {
                case 0:
                    _logger.LoggingInterval = new TimeSpan(0, 0, 1);
                    break;
                case 1:
                    _logger.LoggingInterval = new TimeSpan(0, 0, 2);
                    break;
                case 2:
                    _logger.LoggingInterval = new TimeSpan(0, 0, 5);
                    break;
                case 3:
                    _logger.LoggingInterval = new TimeSpan(0, 0, 10);
                    break;
                case 4:
                    _logger.LoggingInterval = new TimeSpan(0, 0, 30);
                    break;
                case 5:
                    _logger.LoggingInterval = new TimeSpan(0, 1, 0);
                    break;
                case 6:
                    _logger.LoggingInterval = new TimeSpan(0, 2, 0);
                    break;
                case 7:
                    _logger.LoggingInterval = new TimeSpan(0, 5, 0);
                    break;
                case 8:
                    _logger.LoggingInterval = new TimeSpan(0, 10, 0);
                    break;
                case 9:
                    _logger.LoggingInterval = new TimeSpan(0, 30, 0);
                    break;
                case 10:
                    _logger.LoggingInterval = new TimeSpan(1, 0, 0);
                    break;
                case 11:
                    _logger.LoggingInterval = new TimeSpan(2, 0, 0);
                    break;
                case 12:
                    _logger.LoggingInterval = new TimeSpan(6, 0, 0);
                    break;
            }
        };

        _updateInterval = new UserRadioGroup("updateIntervalMenuItem",
                                             2,
                                             new[]
                                             {
                                                 updateInterval250msMenuItem,
                                                 updateInterval500msMenuItem,
                                                 updateInterval1sMenuItem,
                                                 updateInterval2sMenuItem,
                                                 updateInterval5sMenuItem,
                                                 updateInterval10sMenuItem
                                             },
                                             _settings);

        _updateInterval.Changed += (sender, e) =>
        {
            switch (_updateInterval.Value)
            {
                case 0:
                    timer.Interval = 250;
                    break;
                case 1:
                    timer.Interval = 500;
                    break;
                case 2:
                    timer.Interval = 1000;
                    break;
                case 3:
                    timer.Interval = 2000;
                    break;
                case 4:
                    timer.Interval = 5000;
                    break;
                case 5:
                    timer.Interval = 10000;
                    break;
            }
        };

        _sensorValuesTimeWindow = new UserRadioGroup("sensorValuesTimeWindow",
                                                     10,
                                                     new[]
                                                     {
                                                         timeWindow30sMenuItem,
                                                         timeWindow1minMenuItem,
                                                         timeWindow2minMenuItem,
                                                         timeWindow5minMenuItem,
                                                         timeWindow10minMenuItem,
                                                         timeWindow30minMenuItem,
                                                         timeWindow1hMenuItem,
                                                         timeWindow2hMenuItem,
                                                         timeWindow6hMenuItem,
                                                         timeWindow12hMenuItem,
                                                         timeWindow24hMenuItem
                                                     },
                                                     _settings);

        _sensorValuesTimeWindow.Changed += (sender, e) =>
        {
            TimeSpan timeWindow = TimeSpan.Zero;
            switch (_sensorValuesTimeWindow.Value)
            {
                case 0:
                    timeWindow = new TimeSpan(0, 0, 30);
                    break;
                case 1:
                    timeWindow = new TimeSpan(0, 1, 0);
                    break;
                case 2:
                    timeWindow = new TimeSpan(0, 2, 0);
                    break;
                case 3:
                    timeWindow = new TimeSpan(0, 5, 0);
                    break;
                case 4:
                    timeWindow = new TimeSpan(0, 10, 0);
                    break;
                case 5:
                    timeWindow = new TimeSpan(0, 30, 0);
                    break;
                case 6:
                    timeWindow = new TimeSpan(1, 0, 0);
                    break;
                case 7:
                    timeWindow = new TimeSpan(2, 0, 0);
                    break;
                case 8:
                    timeWindow = new TimeSpan(6, 0, 0);
                    break;
                case 9:
                    timeWindow = new TimeSpan(12, 0, 0);
                    break;
                case 10:
                    timeWindow = new TimeSpan(24, 0, 0);
                    break;
            }

            _computer.Accept(new SensorVisitor(delegate(ISensor sensor) { sensor.ValuesTimeWindow = timeWindow; }));
        };

        InitializePlotForm();
        InitializeSplitter();

        startupMenuItem.Visible = _startupManager.IsAvailable;

        if (startMinMenuItem.Checked)
        {
            if (!minTrayMenuItem.Checked)
            {
                WindowState = FormWindowState.Minimized;
                Show();
            }
        }
        else
        {
            Show();
        }

        // Create a handle, otherwise calling Close() does not fire FormClosed

        // Make sure the settings are saved when the user logs off
        Microsoft.Win32.SystemEvents.SessionEnded += delegate
        {
            _computer.Close();
            SaveConfiguration();
            if (_runWebServer.Value)
                Server.Quit();
        };

        Microsoft.Win32.SystemEvents.PowerModeChanged += PowerModeChanged;
    }

    public bool AuthWebServerMenuItemChecked
    {
        get { return authWebServerMenuItem.Checked; }
        set { authWebServerMenuItem.Checked = value; }
    }

    public HttpServer Server { get; }

    private void BackgroundUpdater_DoWork(object sender, DoWorkEventArgs e)
    {
        _computer.Accept(_updateVisitor);

        if (_logSensors != null && _logSensors.Value && _delayCount >= 4)
            _logger.Log();

        if (_delayCount < 4)
            _delayCount++;

        _plotPanel.InvalidatePlot();
    }

    private void PowerModeChanged(object sender, Microsoft.Win32.PowerModeChangedEventArgs eventArgs)
    {
        if (eventArgs.Mode == Microsoft.Win32.PowerModes.Resume)
        {
            _computer.Reset();
        }
    }

    private void InitializeSplitter()
    {
        splitContainer.SplitterDistance = _settings.GetValue("splitContainer.SplitterDistance", 400);
        splitContainer.SplitterMoved += delegate { _settings.SetValue("splitContainer.SplitterDistance", splitContainer.SplitterDistance); };
    }

    private void InitializePlotForm()
    {
        _plotForm = new Form { FormBorderStyle = FormBorderStyle.SizableToolWindow, ShowInTaskbar = false, StartPosition = FormStartPosition.Manual };
        AddOwnedForm(_plotForm);
        _plotForm.Bounds = new Rectangle
        {
            X = _settings.GetValue("plotForm.Location.X", -100000),
            Y = _settings.GetValue("plotForm.Location.Y", 100),
            Width = _settings.GetValue("plotForm.Width", 600),
            Height = _settings.GetValue("plotForm.Height", 400)
        };

        _showPlot = new UserOption("plotMenuItem", false, plotMenuItem, _settings);
        _plotLocation = new UserRadioGroup("plotLocation", 0, new[] { plotWindowMenuItem, plotBottomMenuItem, plotRightMenuItem }, _settings);

        _showPlot.Changed += delegate
        {
            if (_plotLocation.Value == 0)
            {
                if (_showPlot.Value && Visible)
                    _plotForm.Show();
                else
                    _plotForm.Hide();
            }
            else
            {
                splitContainer.Panel2Collapsed = !_showPlot.Value;
            }

            treeView.Invalidate();
        };

        _plotLocation.Changed += delegate
        {
            switch (_plotLocation.Value)
            {
                case 0:
                    splitContainer.Panel2.Controls.Clear();
                    splitContainer.Panel2Collapsed = true;
                    _plotForm.Controls.Add(_plotPanel);
                    if (_showPlot.Value && Visible)
                        _plotForm.Show();

                    break;
                case 1:
                    _plotForm.Controls.Clear();
                    _plotForm.Hide();
                    splitContainer.Orientation = Orientation.Horizontal;
                    splitContainer.Panel2.Controls.Add(_plotPanel);
                    splitContainer.Panel2Collapsed = !_showPlot.Value;
                    break;
                case 2:
                    _plotForm.Controls.Clear();
                    _plotForm.Hide();
                    splitContainer.Orientation = Orientation.Vertical;
                    splitContainer.Panel2.Controls.Add(_plotPanel);
                    splitContainer.Panel2Collapsed = !_showPlot.Value;
                    break;
            }
        };

        _plotForm.FormClosing += delegate(object sender, FormClosingEventArgs e)
        {
            if (e.CloseReason == CloseReason.UserClosing)
            {
                // just switch off the plotting when the user closes the form
                if (_plotLocation.Value == 0)
                {
                    _showPlot.Value = false;
                }

                e.Cancel = true;
            }
        };

        void MoveOrResizePlotForm(object sender, EventArgs e)
        {
            if (_plotForm.WindowState != FormWindowState.Minimized)
            {
                _settings.SetValue("plotForm.Location.X", _plotForm.Bounds.X);
                _settings.SetValue("plotForm.Location.Y", _plotForm.Bounds.Y);
                _settings.SetValue("plotForm.Width", _plotForm.Bounds.Width);
                _settings.SetValue("plotForm.Height", _plotForm.Bounds.Height);
            }
        }

        _plotForm.Move += MoveOrResizePlotForm;
        _plotForm.Resize += MoveOrResizePlotForm;

        _plotForm.VisibleChanged += delegate
        {
            Rectangle bounds = new(_plotForm.Location, _plotForm.Size);
            Screen screen = Screen.FromRectangle(bounds);
            Rectangle intersection = Rectangle.Intersect(screen.WorkingArea, bounds);
            if (intersection.Width < Math.Min(16, bounds.Width) ||
                intersection.Height < Math.Min(16, bounds.Height))
            {
                _plotForm.Location = new Point(screen.WorkingArea.Width / 2 - bounds.Width / 2,
                                               screen.WorkingArea.Height / 2 - bounds.Height / 2);
            }
        };

        VisibleChanged += delegate
        {
            if (Visible && _showPlot.Value && _plotLocation.Value == 0)
                _plotForm.Show();
            else
                _plotForm.Hide();
        };
    }

    private void InsertSorted(IList<Node> nodes, HardwareNode node)
    {
        int i = 0;
        while (i < nodes.Count && nodes[i] is HardwareNode && ((HardwareNode)nodes[i]).Hardware.HardwareType <= node.Hardware.HardwareType)
            i++;

        nodes.Insert(i, node);
    }

    private void SubHardwareAdded(IHardware hardware, Node node)
    {
        HardwareNode hardwareNode = new(hardware, _settings, _unitManager);
        hardwareNode.PlotSelectionChanged += PlotSelectionChanged;
        InsertSorted(node.Nodes, hardwareNode);
        foreach (IHardware subHardware in hardware.SubHardware)
            SubHardwareAdded(subHardware, hardwareNode);
    }

    private void HardwareAdded(IHardware hardware)
    {
        SubHardwareAdded(hardware, _root);
        PlotSelectionChanged(this, null);
    }

    private void HardwareRemoved(IHardware hardware)
    {
        List<HardwareNode> nodesToRemove = new();
        foreach (Node node in _root.Nodes)
        {
            if (node is HardwareNode hardwareNode && hardwareNode.Hardware == hardware)
                nodesToRemove.Add(hardwareNode);
        }

        foreach (HardwareNode hardwareNode in nodesToRemove)
        {
            _root.Nodes.Remove(hardwareNode);
            hardwareNode.PlotSelectionChanged -= PlotSelectionChanged;
        }

        PlotSelectionChanged(this, null);
    }

    private void NodeTextBoxText_DrawText(object sender, DrawEventArgs e)
    {
        if (e.Node.Tag is Node node)
        {
            if (node.IsVisible)
            {
                if (plotMenuItem.Checked && node is SensorNode sensorNode && _sensorPlotColors.TryGetValue(sensorNode.Sensor, out Color color))
                    e.TextColor = color;
            }
            else
                e.TextColor = Color.DarkGray;
        }
    }

    private void PlotSelectionChanged(object sender, EventArgs e)
    {
        List<ISensor> selected = new();
        IDictionary<ISensor, Color> colors = new Dictionary<ISensor, Color>();
        int colorIndex = 0;

        foreach (TreeNodeAdv node in treeView.AllNodes)
        {
            if (node.Tag is SensorNode sensorNode)
            {
                if (sensorNode.Plot)
                {
                    if (!sensorNode.PenColor.HasValue)
                    {
                        colors.Add(sensorNode.Sensor,
                                   _plotColorPalette[colorIndex % _plotColorPalette.Length]);
                    }

                    selected.Add(sensorNode.Sensor);
                }

                colorIndex++;
            }
        }

        // if a sensor is assigned a color that's already being used by another
        // sensor, try to assign it a new color. This is done only after the
        // previous loop sets an unchanging default color for all sensors, so that
        // colors jump around as little as possible as sensors get added/removed
        // from the plot
        var usedColors = new List<Color>();
        foreach (ISensor curSelectedSensor in selected)
        {
            if (!colors.ContainsKey(curSelectedSensor))
                continue;

            Color curColor = colors[curSelectedSensor];
            if (usedColors.Contains(curColor))
            {
                foreach (Color potentialNewColor in _plotColorPalette)
                {
                    if (!colors.Values.Contains(potentialNewColor))
                    {
                        colors[curSelectedSensor] = potentialNewColor;
                        usedColors.Add(potentialNewColor);
                        break;
                    }
                }
            }
            else
            {
                usedColors.Add(curColor);
            }
        }

        foreach (TreeNodeAdv node in treeView.AllNodes)
        {
            if (node.Tag is SensorNode sensorNode && sensorNode.Plot && sensorNode.PenColor.HasValue)
                colors.Add(sensorNode.Sensor, sensorNode.PenColor.Value);
        }

        _sensorPlotColors = colors;
        _plotPanel.SetSensors(selected, colors);
    }

    private void NodeTextBoxText_EditorShowing(object sender, CancelEventArgs e)
    {
        e.Cancel = !(treeView.CurrentNode != null && (treeView.CurrentNode.Tag is SensorNode || treeView.CurrentNode.Tag is HardwareNode));
    }

    private void NodeCheckBox_IsVisibleValueNeeded(object sender, NodeControlValueEventArgs e)
    {
        e.Value = e.Node.Tag is SensorNode && plotMenuItem.Checked;
    }

    private void ExitClick(object sender, EventArgs e)
    {
        CloseApplication();
    }

    private void Timer_Tick(object sender, EventArgs e)
    {
        treeView.Invalidate();
        _systemTray.Redraw();
        _gadget?.Redraw();
        _wmiProvider?.Update();

        if (!backgroundUpdater.IsBusy)
            backgroundUpdater.RunWorkerAsync();

        RestoreCollapsedNodeState(treeView);
    }

    private void SaveConfiguration()
    {
        if (_plotPanel == null || _settings == null)
            return;

        _plotPanel.SetCurrentSettings();

        foreach (TreeColumn column in treeView.Columns)
            _settings.SetValue("treeView.Columns." + column.Header + ".Width", column.Width);

        _settings.SetValue("listenerPort", Server.ListenerPort);
        _settings.SetValue("authenticationEnabled", Server.AuthEnabled);
        _settings.SetValue("authenticationUserName", Server.UserName);
        _settings.SetValue("authenticationPassword", Server.Password);

        string fileName = Path.ChangeExtension(Application.ExecutablePath, ".config");

        try
        {
            _settings.Save(fileName);
        }
        catch (UnauthorizedAccessException)
        {
            MessageBox.Show("Access to the path '" +
                            fileName +
                            "' is denied. " +
                            "The current settings could not be saved.",
                            "Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
        }
        catch (IOException)
        {
            MessageBox.Show("The path '" +
                            fileName +
                            "' is not writeable. " +
                            "The current settings could not be saved.",
                            "Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
        }
    }

    private void MainForm_Load(object sender, EventArgs e)
    {
        Rectangle newBounds = new()
        {
            X = _settings.GetValue("mainForm.Location.X", Location.X),
            Y = _settings.GetValue("mainForm.Location.Y", Location.Y),
            Width = _settings.GetValue("mainForm.Width", 470),
            Height = _settings.GetValue("mainForm.Height", 640)
        };

        Rectangle fullWorkingArea = new(int.MaxValue, int.MaxValue, int.MinValue, int.MinValue);

        foreach (Screen screen in Screen.AllScreens)
            fullWorkingArea = Rectangle.Union(fullWorkingArea, screen.Bounds);

        Rectangle intersection = Rectangle.Intersect(fullWorkingArea, newBounds);
        if (intersection.Width < 20 || intersection.Height < 20 || !_settings.Contains("mainForm.Location.X"))
        {
            newBounds.X = (Screen.PrimaryScreen.WorkingArea.Width / 2) - (newBounds.Width / 2);
            newBounds.Y = (Screen.PrimaryScreen.WorkingArea.Height / 2) - (newBounds.Height / 2);
        }

        Bounds = newBounds;

        RestoreCollapsedNodeState(treeView);

        FormClosed += MainForm_FormClosed;
    }

    private void RestoreCollapsedNodeState(TreeViewAdv treeViewAdv)
    {
        var collapsedHwNodes = treeViewAdv.AllNodes
                                          .Where(n => n.IsExpanded && n.Tag is IExpandPersistNode expandPersistNode && !expandPersistNode.Expanded)
                                          .OrderByDescending(n => n.Level)
                                          .ToList();

        foreach (TreeNodeAdv node in collapsedHwNodes)
        {
            node.IsExpanded = false;
        }
    }

    private void CloseApplication()
    {
        FormClosed -= MainForm_FormClosed;

        Visible = false;
        _systemTray.IsMainIconEnabled = false;
        timer.Enabled = false;
        _computer.Close();
        SaveConfiguration();
        if (_runWebServer.Value)
            Server.Quit();

        _systemTray.Dispose();
        timer.Dispose();
        backgroundUpdater.Dispose();

        Application.Exit();
    }

    private void MainForm_FormClosed(object sender, FormClosedEventArgs e)
    {
        CloseApplication();
    }

    private void AboutMenuItem_Click(object sender, EventArgs e)
    {
        _ = new AboutBox().ShowDialog();
    }

    private void TreeView_Click(object sender, EventArgs e)
    {
        if (!(e is MouseEventArgs m) || (m.Button != MouseButtons.Left && m.Button != MouseButtons.Right))
            return;

        NodeControlInfo info = treeView.GetNodeControlInfoAt(new Point(m.X, m.Y));
        if (m.Button == MouseButtons.Left && info.Node != null)
        {
            if (info.Node.Tag is IExpandPersistNode expandPersistNode)
            {
                expandPersistNode.Expanded = info.Node.IsExpanded;
            }

            return;
        }

        treeView.SelectedNode = info.Node;
        if (info.Node != null)
        {
            if (info.Node.Tag is SensorNode node && node.Sensor != null)
            {
                treeContextMenu.Items.Clear();
                if (node.Sensor.Parameters.Count > 0)
                {
                    ToolStripItem item = new ToolStripMenuItem("Parameters...");
                    item.Click += delegate { ShowParameterForm(node.Sensor); };
                    treeContextMenu.Items.Add(item);
                }

                if (nodeTextBoxText.EditEnabled)
                {
                    ToolStripItem item = new ToolStripMenuItem("Rename");
                    item.Click += delegate { nodeTextBoxText.BeginEdit(); };
                    treeContextMenu.Items.Add(item);
                }

                if (node.IsVisible)
                {
                    ToolStripItem item = new ToolStripMenuItem("Hide");
                    item.Click += delegate { node.IsVisible = false; };
                    treeContextMenu.Items.Add(item);
                }
                else
                {
                    ToolStripItem item = new ToolStripMenuItem("Unhide");
                    item.Click += delegate { node.IsVisible = true; };
                    treeContextMenu.Items.Add(item);
                }

                treeContextMenu.Items.Add(new ToolStripSeparator());
                {
                    ToolStripItem item = new ToolStripMenuItem("Pen Color...");
                    item.Click += delegate
                    {
                        ColorDialog dialog = new() { Color = node.PenColor.GetValueOrDefault() };
                        if (dialog.ShowDialog() == DialogResult.OK)
                            node.PenColor = dialog.Color;
                    };

                    treeContextMenu.Items.Add(item);
                }

                {
                    ToolStripItem item = new ToolStripMenuItem("Reset Pen Color");
                    item.Click += delegate { node.PenColor = null; };
                    treeContextMenu.Items.Add(item);
                }

                treeContextMenu.Items.Add(new ToolStripSeparator());
                {
                    ToolStripMenuItem item = new("Show in Tray") { Checked = _systemTray.Contains(node.Sensor) };
                    item.Click += delegate
                    {
                        if (item.Checked)
                            _systemTray.Remove(node.Sensor);
                        else
                            _systemTray.Add(node.Sensor, true);
                    };

                    treeContextMenu.Items.Add(item);
                }

                if (_gadget != null)
                {
                    ToolStripMenuItem item = new("Show in Gadget") { Checked = _gadget.Contains(node.Sensor) };
                    item.Click += delegate
                    {
                        if (item.Checked)
                        {
                            _gadget.Remove(node.Sensor);
                        }
                        else
                        {
                            _gadget.Add(node.Sensor);
                        }
                    };

                    treeContextMenu.Items.Add(item);
                }

                if (node.Sensor.Control != null)
                {
                    treeContextMenu.Items.Add(new ToolStripSeparator());
                    IControl control = node.Sensor.Control;
                    ToolStripMenuItem controlItem = new("Control");
                    ToolStripItem defaultItem = new ToolStripMenuItem("Default") { Checked = control.ControlMode == ControlMode.Default };
                    controlItem.DropDownItems.Add(defaultItem);
                    defaultItem.Click += delegate { control.SetDefault(); };
                    ToolStripMenuItem manualItem = new("Manual");
                    controlItem.DropDownItems.Add(manualItem);
                    manualItem.Checked = control.ControlMode == ControlMode.Software;
                    for (int i = 0; i <= 100; i += 5)
                    {
                        if (i <= control.MaxSoftwareValue &&
                            i >= control.MinSoftwareValue)
                        {
                            ToolStripMenuItem item = new ToolStripRadioButtonMenuItem(i + " %");
                            manualItem.DropDownItems.Add(item);
                            item.Checked = control.ControlMode == ControlMode.Software && Math.Round(control.SoftwareValue) == i;
                            int softwareValue = i;
                            item.Click += delegate { control.SetSoftware(softwareValue); };
                        }
                    }

                    treeContextMenu.Items.Add(controlItem);
                }

                treeContextMenu.Show(treeView, new Point(m.X, m.Y));
            }

            if (info.Node.Tag is HardwareNode hardwareNode && hardwareNode.Hardware != null)
            {
                treeContextMenu.Items.Clear();

                if (nodeTextBoxText.EditEnabled)
                {
                    ToolStripItem item = new ToolStripMenuItem("Rename");
                    item.Click += delegate { nodeTextBoxText.BeginEdit(); };
                    treeContextMenu.Items.Add(item);
                }

                treeContextMenu.Show(treeView, new Point(m.X, m.Y));
            }
        }
    }

    private void SaveReportMenuItem_Click(object sender, EventArgs e)
    {
        string report = _computer.GetReport();
        if (saveFileDialog.ShowDialog() == DialogResult.OK)
        {
            using (TextWriter w = new StreamWriter(saveFileDialog.FileName))
            {
                w.Write(report);
            }
        }
    }

    private void SysTrayHideShow()
    {
        Visible = !Visible;
        if (Visible)
            Activate();
    }

    protected override void WndProc(ref Message m)
    {
        const int WM_SYSCOMMAND = 0x112;
        const int SC_MINIMIZE = 0xF020;
        const int SC_CLOSE = 0xF060;

        if (_minimizeToTray.Value && m.Msg == WM_SYSCOMMAND && m.WParam.ToInt64() == SC_MINIMIZE)
        {
            SysTrayHideShow();
        }
        else if (_minimizeOnClose.Value && m.Msg == WM_SYSCOMMAND && m.WParam.ToInt64() == SC_CLOSE)
        {
            //Apparently the user wants to minimize rather than close
            //Now we still need to check if we're going to the tray or not
            //Note: the correct way to do this would be to send out SC_MINIMIZE,
            //but since the code here is so simple,
            //that would just be a waste of time.
            if (_minimizeToTray.Value)
                SysTrayHideShow();
            else
                WindowState = FormWindowState.Minimized;
        }
        else
        {
            base.WndProc(ref m);
        }
    }

    private void HideShowClick(object sender, EventArgs e)
    {
        SysTrayHideShow();
    }

    private void ShowParameterForm(ISensor sensorForm)
    {
        ParameterForm form = new() { Parameters = sensorForm.Parameters, captionLabel = { Text = sensorForm.Name } };
        form.ShowDialog();
    }

    private void TreeView_NodeMouseDoubleClick(object sender, TreeNodeAdvMouseEventArgs e)
    {
        if (e.Node.Tag is SensorNode node && node.Sensor != null && node.Sensor.Parameters.Count > 0)
            ShowParameterForm(node.Sensor);
    }

    private void CelsiusMenuItem_Click(object sender, EventArgs e)
    {
        celsiusMenuItem.Checked = true;
        fahrenheitMenuItem.Checked = false;
        _unitManager.TemperatureUnit = TemperatureUnit.Celsius;
    }

    private void FahrenheitMenuItem_Click(object sender, EventArgs e)
    {
        celsiusMenuItem.Checked = false;
        fahrenheitMenuItem.Checked = true;
        _unitManager.TemperatureUnit = TemperatureUnit.Fahrenheit;
    }

    private void ResetMinMaxMenuItem_Click(object sender, EventArgs e)
    {
        _computer.Accept(new SensorVisitor(delegate(ISensor sensorClick)
        {
            sensorClick.ResetMin();
            sensorClick.ResetMax();
        }));
    }

    private void resetPlotMenuItem_Click(object sender, EventArgs e)
    {
        _computer.Accept(new SensorVisitor(delegate (ISensor sensorClick)
        {
            sensorClick.ClearValues();
        }));
    }

    private void MainForm_MoveOrResize(object sender, EventArgs e)
    {
        if (WindowState != FormWindowState.Minimized)
        {
            _settings.SetValue("mainForm.Location.X", Bounds.X);
            _settings.SetValue("mainForm.Location.Y", Bounds.Y);
            _settings.SetValue("mainForm.Width", Bounds.Width);
            _settings.SetValue("mainForm.Height", Bounds.Height);
        }
    }

    private void ResetClick(object sender, EventArgs e)
    {
        // disable the fallback MainIcon during reset, otherwise icon visibility
        // might be lost
        _systemTray.IsMainIconEnabled = false;
        _computer.Reset();
        // restore the MainIcon setting
        _systemTray.IsMainIconEnabled = _minimizeToTray.Value;
    }

    private void TreeView_MouseMove(object sender, MouseEventArgs e)
    {
        _selectionDragging &= (e.Button & (MouseButtons.Left | MouseButtons.Right)) > 0;
        if (_selectionDragging)
            treeView.SelectedNode = treeView.GetNodeAt(e.Location);
    }

    private void TreeView_MouseDown(object sender, MouseEventArgs e)
    {
        _selectionDragging = true;
    }

    private void TreeView_MouseUp(object sender, MouseEventArgs e)
    {
        _selectionDragging = false;
    }

    private void ServerPortMenuItem_Click(object sender, EventArgs e)
    {
        new PortForm(this).ShowDialog();
    }

    private void AuthWebServerMenuItem_Click(object sender, EventArgs e)
    {
        new AuthForm(this).ShowDialog();
    }
}
```

`LibreHardwareMonitor/UI/MainForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="treeContextMenu.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="saveFileDialog.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>164, 17</value>
  </metadata>
  <metadata name="timer.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>293, 17</value>
  </metadata>
  <metadata name="backgroundWorker1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>483, 17</value>
  </metadata>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAMAEBAAAAEAIABoBAAANgAAACAgAAABACAAqBAAAJ4EAAAwMAAAAQAgAKglAABGFQAAKAAAABAA
        AAAgAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEU8OykuDgdIIxQSURwdHU8ZGhpPFhYWTxQU
        FE8SEhJPDxAPTw0KCk8KBQRPCAQDTwcDAU8HAQBPBgQEUQUFBTxLVVb/L215/zdXXP89Ozv/ODc3/zM0
        M/8vLy//Kioq/yYlJf8iJif/Gycp/xggI/8UHiD/Eh4g/w4SE/8GBARRQWRr/xGXtP8yUln/NDIx/y4u
        Lf8qKir/KSgo/ycnJ/8lJCP/Iikq/xs4Pf8aOD7/GzpB/xo4Pf8SGhv/BwMDT01aXP46Ulj+Pzc0/kdH
        R/5MTU3+Q0ND/jw8PP43Nzf+Ly8v/igoKP4lKCn+Iico/hwiI/4cHyD/FBMU/wYHBk9XVVX+Rj8+/klJ
        Sf6ioqL+rq+u/p+fn/6YmJj+j4+P/oSEhP56enr+dXJy/mNgYP4iHx7+Gxka/xUVFf8HBwdPW1pa/kVF
        RP5YWFj+rq6u/r6+vv6wsK/+qamp/qCgoP6UlJT+iYmJ/oGBgf5xcXH+JCQk/hsbG/8WFhb/BwcHT15e
        Xv5ISEj+Wlpa/rW1tf7Gxsb+tra2/qysq/6hoaL+lpaW/oyMjP6EhIT+cnJy/iQkJP4cHBz/GBgY/wcH
        B09jY2P+TUxM/l5eXv7AwMD+0dHR/r6+vv6vr6/+o6Ok/pmYmf6Rk5P+iouK/nd4d/4lJSX+HR0d/xkZ
        Gf8HBwdPZ2dn/lBQUP5iYmL+ysrK/tzc3P7Hxsf+tbS1/qmpqf6fn5/+mJiY/o6Pj/57e3z+JSUm/h4e
        Hv8aGhr/CAgIT2tra/5TU1P+ZGRk/tLS0v7j5eP+zMzM/ry8vP6wsLD+pqam/pubm/6TkZH+f39//igo
        KP4fHx7/HBwc/wkJCk9ubm7+VlVW/mZlZv7X1tf+6Ojo/tPS0/7Hx8f+urq6/qurq/6dnp7+lJSU/oGB
        gP4sLCz+Hx4e/x4dHP8LCwtPb29v/lZWVv5nZ2j+4eHh/vLx8v7Z2dn+zc3N/sDAwP6wsrL+pKOk/pmZ
        mf6Ghob+MDAw/h8gH/8eHx//DQsNT29vb/5YWFj+WVpa/sHBwf7V1dX+wMC//rW1tP6pqan+m5ub/o6P
        jv6FhYX+cXFx/i4qKv4gLC7/Hiot/w4JB09vb3D+Wlla/lJSUf5VVVX+YGBg/ltbWv5VVVP+Tk5O/kdH
        R/5BQUH+Ozs6/jAvL/4oKCj+Izk9/x8tL/8QCQhRbm5u/lVVVf5SUlL+S0tL/kRERP5BQUH+PT09/jk5
        Of41NTX+MzIy/i8vLv4sKSj+Jy4v/h9DTP8iLjH/Ew0KSHp7ev5qamr+ZWVl/mFhYv5cXFz+WFhY/lNS
        U/5NTU3+R0ZH/kJCQv49PDz+NzU1/jAxMf4qMTL/Jigp/x4cHCn//wAAAAEAAAABAAAAAQAAAAEAAAAB
        AAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAKAAAACAAAABAAAAAAQAgAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMBBwcHAwYGBgQGBgYEBgYGBAYG
        BgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYG
        BgQGBgYEBgYGBAYGBgQGBgYEBwcHAwUFBQIAAAAAAAAAAAAAAAAAAAAAAAAAAAoKCgkMDAwgDQ0NKg0N
        DSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0N
        DSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoMDAwlCgoKEQUFBQIAAAAAAAAAAAAAAAAAAAAACAgIFAoK
        CkcMDAxbDAwMXAwMDFwMDAxcDAwMXAwNDFwNDQ1cDQ0NXA0NDVwNDQ1cDQ0NXA0NDVwNDQ5cDg4OXA4O
        DlwODg5cDg4OXA4ODlwODg5cDg4OXA4ODlwODg5cDg4OWw0NDVIMDAwlBwcHAwAAAAAAAAAAAAAAAGFh
        YY9ZWFjFUVBP0kpJSdhIR0fYQkJC2D0+Ptg5OTnZODc22TMyM9kuLi/ZKysr2SYmJtkjIyPZICAf2Rsb
        G9kXFxjZExMT2Q8ODtkNDAzZDQwM2A0MDNgNDAzYDQ0N2A0NDdgODQ27Dg4OWw0NDSoGBgYEAAAAAAAA
        AAAAAAAAYmFhvzxCQ/82Uln/NlJZ/zdPVP89PDz/PDw8/zo6Ov85OTn/ODg4/zY2Nv80NDT/NDQ0/zIy
        Mv8xMTD/Ly4w/yw1OP8qNjj/JzQ1/yYyNP8kMDL/Ii4w/x8sLv8fKy3/HyIi/w0NDdgODg5cDQ0NKgYG
        BgQAAAAAAAAAAAAAAABjY2K/OFRa/xqXsv8bk6v/M11l/z49Pf89PT3/Ozs7/zo6Of83Nzj/NTY1/zQ0
        NP8zMzP/MTEw/y8vL/8uLi7/KzQ2/yk1Nv8nMjT/JjAz/yQvMf8jLjD/ISwu/x8rLf8fISL/DQ0N2A4O
        DlwNDQ0qBgYGBAAAAAAAAAAAAAAAAGZkZL86V13/GpKs/zJkbv9BPz//Pj8+/zw8PP85OTn/Njc2/zQ0
        Nf8zMjP/MjIy/zAwMP8vLy//Li4u/y0sLP8qKSn/I0hQ/yJHUP8hRk//IEZO/yBGTv8fRU3/HztB/yAf
        H/8NDQ3YDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAaWdovz5WW/83YWr/RkND/0FAQP89PT3/ODc3/zIy
        Mf8uLi7/LCws/ysrK/8pKSn/Kioq/ygoKP8nJyf/JSUl/yUkJP8kIyP/IyEh/yMiIv8kIiL/JCMj/yQj
        I/8iISH/ISAg/w0NDdgODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAABqamq/SUhI/0hHR/9GRkb/QUFB/0ZH
        Rv9/f4D/gICA/3h4eP9xcXH/a2tr/2RkZP9dXV7/V1dX/09PT/9ISEj/Q0NC/0BAQP9AQED/Ozs7/yYm
        Jv8jIyP/JCQk/yMjI/8jIyH/DQ0N2A4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAG5ubr9LS0v/SkpL/0hI
        SP9BQUH/i4uL/6ysrP+hoqH/n5+e/52bnf+YmJj/lJSU/5CQj/+Li4v/hYaF/4CAgP97e3r/dXR1/3Fx
        cf9ra2v/Ozs7/yEhIv8kJCT/JCQk/yQkI/8NDQ3YDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAcHBwv01N
        Tf9MTU3/SUpK/0BAP/+Wlpj/q6ur/6inp/+kpKT/oKGg/52cnP+YmJj/k5OT/46Ojv+IiYj/g4OC/319
        ff93d3f/cXFx/3Fxcf8/Pz//ISEh/yQkJP8lJSX/JSQk/w0NDdkODg5cDQ0NKgYGBgQAAAAAAAAAAAAA
        AABycnO/T05P/05PT/9MTEz/QUFB/5ubmv+ysrL/rq6u/6urq/+np6f/oqKi/52dnf+ZmZn/k5OT/42O
        jv+IiIf/gYGB/3x7fP90dXT/cXFx/z8/P/8hISH/JCQl/yUlJf8lJib/DQ0N2Q4ODlwNDQ0qBgYGBAAA
        AAAAAAAAAAAAAHR1db9RUVH/UFBQ/01NTf9CQkL/np6e/7i4uP+0s7T/sbGx/62trf+oqKj/o6Oj/52d
        nf+Yl5f/kZKR/4yMi/+FhYX/fn9//3h4eP9zc3P/Pz8//yIiIv8lJSX/JiYm/yYmJv8NDQ3ZDg4OXA0N
        DSoGBgYEAAAAAAAAAAAAAAAAdnZ2v1RUVP9TU1P/T09P/0VFRf+kpKT/v7+//7u7u/+2trb/sbGx/6mp
        qf+jo6P/nZ2d/5eXl/+QkZH/jo2N/4mJif+CgoL/fHx8/3d3d/9AQED/IiIi/yYmJv8nJyf/Jycn/w0N
        DdkODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAAB4eHi/V1dW/1VVVf9QUFD/RkZG/6moqf/Gxsb/wcHB/7y8
        vP+2trb/q6ys/6Wlpf+fn5//mZiY/5WUlf+RkpL/jI2M/4WFhf9/fn//enp6/0FBQf8iIiP/JiYm/ygn
        KP8oJyf/DQ0N2Q4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAHp6er9YWVn/V1dX/1JSU/9ISEj/ra2t/8zM
        zP/Gxsb/wcHB/7u7u/+wsLD/qamp/6Ojo/+cnZ3/lpaW/5OTk/+Pj47/iIiI/4CBgP98fH3/QkJC/yMj
        I/8nJyf/KCgo/ygoKP8ODg7ZDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAfXx9v1tbW/9ZWVn/VFVV/0hJ
        Sf+xsbH/0tLS/8vLy//FxcX/v7++/7Ozs/+qqqr/pKWk/6Cfn/+ampr/mpia/5GRkf+Li4r/goOD/35+
        fv9CQ0P/IyQk/ycnJ/8pKSn/KSkp/xAQENkODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAAB+fn6/XV1d/1tb
        W/9WVlb/S0lJ/7Oysv/W1tb/z8/P/8nJyf/CwsL/tbW1/66trf+np6f/oqKi/5ycnP+ZmJn/k5OT/4yM
        jP+FhYX/f39//0ZFRv8kJCT/KCgo/ykpKf8pKSn/EhIS2Q4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAIGB
        gb9eXl7/XFxc/1dYV/9KSkr/tLS0/9rb2v/S0tL/zczM/8XFxf+/v7//uLi4/7Gxsf+rq6r/o6Oj/5yc
        nP+UlZT/jY2N/4aFhv+AgID/SUlI/yMjI/8oKCj/KSkp/ykpKf8UFBTZDg4OXA0NDSoGBgYEAAAAAAAA
        AAAAAAAAg4ODv19fX/9eXl7/WVhZ/0tLS/+0tLT/3d3d/9TU1P/Ozs7/x8bH/8DAwP+5ubn/srKy/6ur
        q/+kpKT/nJyc/5WVlv+Ojo7/h4eH/4GBgf9NTU3/IyQk/ygpKP8qKSn/KSkp/xgYGNkODg5cDQ0NKgYG
        BgQAAAAAAAAAAAAAAACFhYW/YGBf/15eXv9aWln/TU1N/7a2tv/e3t7/1dXV/87Pz//Hx8f/wcHB/7m5
        uv+ysrP/rKyr/6SkpP+dnZ3/lZWW/46Ojv+Hh4f/gYGB/1BQUP8kJCT/KSkp/ykpKf8oKCj/GhkZ2Q4O
        DlwNDQ0qBgYGBAAAAAAAAAAAAAAAAIiGhr9gYGD/Xl5e/1paWv9PT0//t7e3/93d3f/U1NT/zs7O/8fH
        x//AwMD/ubm5/7Kysv+rq6v/o6Ok/5ycnP+VlZX/jo6N/4aGhv+BgYH/U1NT/yYmJv8qKir/Kisq/ygo
        Kf8bHBzYDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAioqKv19fX/9eXl7/Wlta/1FRUf+srKz/4uLi/9LS
        0v/Mzcz/xcXG/7+/v/+4ubj/srKx/6urq/+kpKT/nZ2d/5WVlf+Njo7/h4aH/4GBgf9TUlL/KSkp/yws
        LP8qLzH/Jy4v/x4eHtgNDQ1cDQ0NKgYGBgQAAAAAAAAAAAAAAACMi4y/Xl5e/11dXf9aWlr/VVVV/1xc
        XP+qqqr/sbGx/66urv+qqqr/pKSj/52dnf+VlZX/jo6O/4eHh/+Af3//d3l3/3BwcP9paWn/XFxc/zMz
        M/8sLCz/LS0t/yswMf8nLS7/ICAg2A0NDVwNDQ0qBgYGBAAAAAAAAAAAAAAAAI6Ojr9cXFz/XFxc/1pa
        Wv9WV1f/UFFQ/0xMS/9HR0f/RERE/0BBQP8+Pj7/PDw8/zo7Ov84ODj/ODg4/zU1Nf8zMzP/MTEx/zAw
        MP8uLi//Li4u/y4tL/8qPUD/KDk+/yU4O/8jIiLYDQ0NXA0NDSoGBgYEAAAAAAAAAAAAAAAAkZGRv1pb
        W/9bW1r/WFlY/1ZWVv9UVFT/UFBQ/05OTv9MTEz/SklK/0dHR/9FRUX/QkJC/0BAQP8+Pj7/PDw8/zo6
        Ov83ODf/NTU1/zIyMv8xMTH/Ly4u/yk7P/8oO0D/JTpA/yUkJNgNDQ1bDQ0NKgcHBwQAAAAAAAAAAAAA
        AACTk5O/WFhY/1lZWf9YV1j/VVVV/1JSUv9QUFD/Tk5O/01MTf9KSkr/SEhI/0ZGRv9DQkP/QEFA/z8/
        P/89PT3/Ozs6/zg4OP82NTX/MzMz/zExMf8vLi3/IVtn/yovMf8nLi//KCgo0gwMDEcMDAwgBwcHAwAA
        AAAAAAAAAAAAAJKTkr9VVFX/VFVV/1RUVP9SUVH/T09P/01NTv9MS0z/SkpK/0hJSP9HR0f/REVE/0FB
        Qf8/Pz//Pj4+/zs7PP85Ojn/Nzc3/zQ0NP8xMTH/LzAw/y4uLv8tLCz/KS8w/yUtLv8tLS3FCgoKFAoK
        CgkDAwMBAAAAAAAAAAAAAAAAl5aXj5KSkr+QkJC/jYuLv4eHh7+EhIS/gICAv3x8fL93d3e/dHR0v3Bw
        cL9samy/ZmZmv2NjY79fX1+/W1tbv1VVVb9SUlK/Tk5Ov0pKSr9ERES/QUFBvz09Pb85OTm/MzMzvzEx
        MY8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////////gAAAH4AAAB+AA
        AAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AA
        AAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB////////////////ygAAAAwAAAAYAAAAAEA
        IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAACCAgIBwkJCQwICAgOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcH
        Bw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcH
        Bw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOCAgIDgkJCQwICAgHAAAAAgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAICAgHCwsLGQ0NDSwNDQ0yDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0N
        DTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0N
        DTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMg0NDSwLCwsaCAgIBwAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJCQkMDQ0NLA0NDUwODg5XDg4OWQ4ODlkODg5ZDg4OWQ4O
        DlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4O
        DlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OVw0N
        DUwNDQ0sCQkJDAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFBQUOCgoKMgsLC1cLCwtkCwsLZgsL
        C2YLCwtmCwsLZgwMDGYMDAxmDAwMZgwMDGYMDAxmDAwMZgwMDGYMDAxmDAwMZg0NDWYNDQ1mDQ0NZg0N
        DWYNDQ1mDQ0NZg0NDWYNDQ1mDg4OZg4ODmYODg5mDg4OZg4ODmYODg5mDg4OZg4ODmYODg5mDg4OZg4O
        DmYODg5mDg4OZA4ODlcNDQ0yCAgIDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGJiYv9cXFz/Wlpa/1VV
        V/9TU1L/UVFR/05OTv9LSkv/R0dH/0NDQ/9BQUH/Pz4//zw8PP86OTn/NTU1/zIyMv8wMDD/LS0u/yoq
        Kv8mJib/JCMk/yEhIf8eHh7/Gxsc/xkZGf8UFBT/ERER/w8PD/8ODg7/Dg4O/w4ODv8ODg7/Dg4O/w4O
        Dv8ODg7/Dg4O/w4ODv8PDw//Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGJi
        Yf8+PDz/Pzw7/0A7Ov9AOzr/Pzo5/z06Ov89Ojr/Ozs7/zo7Ov87Ojv/Ojo6/zk5Of84ODj/Nzc3/zY2
        Nf81NTT/MzMz/zIyMv8xMTH/MTIx/zAwMP8wMDD/Ly4u/y4tLf8sKiv/Kigo/yknJ/8oJiX/JiQk/yUj
        I/8kIiH/IiEg/yAeHv8gHh3/IB0d/x8eHv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAGNjY/9BPj3/Gpiz/xuWsP8alrD/Gpey/yKClv8+PT3/PT09/zw8PP87Ozv/Ojo6/zk5
        Of84ODj/Nzc3/zY2Nv80NDT/MzMz/zMyMv8yMTH/MDEw/y8vL/8vLy//Li4t/yJWYf8hVF//IVRf/x9T
        Xf8gU13/H1Nc/x9RXP8eUFv/HlFb/x1QWv8cT1n/HFBb/x8eHv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAGRkZP9CPTz/GpWv/xySq/8blK3/JH+S/0A8O/8/Pj7/Pj0+/z08
        PP87Ozv/Ojo6/zk5Of84ODj/Njc3/zU1Nf80NDT/MzMz/zIyMv8xMTH/MDAv/y8vL/8uLi7/LS0s/ywq
        Kv8tKSj/KiYm/yklJf8nJCP/KCIi/yYiIf8lICD/JB8e/yMeHP8iHRz/Hx0d/x8eH/8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGVlZf9GQUD/Gpaw/xuUrf8kgJP/Qj49/0A/
        P/8/Pj//Pj4+/zw8PP86Ojr/OTk5/zc3N/82NTb/NDQ0/zMzM/8yMjL/MTEx/zAwMP8vLzD/Ly8v/y4u
        Lv8tLS3/LCws/ysrKv8gVV//H1Nd/x9UXf8gU13/H1Nc/x9RXP8fUVz/HlFb/x5QW/8dUFv/Hx4f/x8f
        IP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGZmZv9GQkL/GZex/yWB
        k/9GQUH/QkFB/0FBQP8/Pz//PT09/zo7Ov84ODj/NTY1/zMzM/8yMjL/MTEx/zAwMP8vLy//Ly8v/y4u
        Lv8uLi7/LS0t/ysrK/8qKiv/KSkp/ygnJ/8nJib/JiQk/yYjJP8lIyP/JSIj/yUjI/8kIiL/JCIi/yMh
        Iv8iISD/IR8g/x8fH/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGho
        aP9IRUX/JIOY/0dDQv9HRUX/Q0ND/0FBQP8/Pz7/Ozo7/zY2Nv8xMTH/Li4u/ywsLf8tLS3/LCws/ysr
        K/8pKin/KSkp/ygoKP8oKCj/Jycn/ycmJv8lJSX/JSQl/yQkJP8jJCP/IyIj/yIiIv8iIyL/IyMj/yQj
        JP8kJCT/IyMk/yMjI/8jIyP/IiIh/yAgIP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAGlqav9IR0f/SUdH/0lHR/9HR0b/RERF/0FBQf88PDz/Pj8//317ff91dXX/cHBw/2tr
        a/9lZGX/YF9f/1paWv9VVVb/UVFR/0xMTP9HR0f/QUFB/z48PP83ODf/MzMz/zAwMP8wMDD/Ly8w/zAw
        MP8xMDH/Jycn/yEhIv8jIyP/JCQk/yQkJP8jIyT/IyIi/yEhIf8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAG1ra/9KSkr/SkpK/0lJSf9ISEj/RkVF/0BAQP9CQkL/ycnJ/6ur
        q/+fn57/np6e/5ycnP+ampr/l5eX/5SUlP+SkpH/j4+P/4yMjP+Iior/hoeG/4ODg/+AgID/fHx8/3h4
        eP90dHP/cXFx/3Jycv9lZWX/Tk9O/ycnJ/8iIiL/IyQj/yQkJP8jIyP/IyMj/yMhI/8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAG5ubf9LS0z/S0xL/0tLS/9JSUn/RkZG/0A/
        P/+Mi4z/s7Oz/6Ojo/+ioqL/oKCg/56env+cnJz/mZqZ/5eWl/+UlJT/kJGR/46Ojv+Li4v/h4eH/4OD
        g/+Af4D/fHx8/3h4eP91dHT/cHBw/29vb/9wcHD/ZWVl/zAwMP8iIiL/IyMj/yQkJP8kJCT/JCMk/yMk
        I/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHBwb/9NTU3/TU1N/0xM
        TP9KSkr/R0dH/z8+P/+Ojo7/q6ur/6mpqf+np6b/paSk/6Kiov+goKD/nZ6e/5ubm/+YmJj/lZSU/5GR
        kf+Ojo7/ioqL/4eHh/+Dg4P/f39//3x8fP93d3f/c3Nz/29vb/9vb2//cnJy/y8vL/8gISD/IyMj/yUk
        JP8kJCT/JCQk/yQkJP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHFx
        cf9OTk7/Tk5P/01NTf9MTEz/SEhI/0BAQP+QkJD/sLCv/62trf+srKv/qamp/6enp/+kpKX/oaKh/5+f
        n/+cnJz/mJiY/5WVlf+RkZL/jo6O/4qKiv+Ghob/goKC/35+fv96env/dnZ2/3Fycf9vb2//cnJy/y8u
        Lv8hICH/IyMj/yQkJf8lJSX/JCQl/yUlJP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAHNzc/9PT0//T09P/09PT/9NTUz/SUlJ/0FAQf+SkpL/tbS0/7Gxsf+vr7D/rq6u/6ur
        q/+pqan/pqWl/6Kiov+fn5//nJyc/5iZmP+UlZX/kZGR/42Njf+JiYn/hYWF/4GBgf99fX3/eXl5/3R0
        dP9wcHD/cnJy/y4uLv8hISD/JCQk/yUlJf8mJSb/JiUl/yUlJf8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAHR0dP9RUVH/UVBR/09PT/9OTk7/S0pK/0JCQv+VlZX/uLi4/7a1
        tf+zs7P/sbGx/6+vr/+tra3/qaqq/6ampv+ioqP/n5+f/5ycnP+YmJj/lJSU/5CQj/+MjIz/iIiI/4OD
        g/9/f3//e3t7/3d3dv9ycnL/cnJy/y4vL/8hISH/JCQk/yYmJf8mJib/JiYl/yYlJf8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHV1df9TU1T/U1NT/1BRUf9PTk7/TExM/0JC
        Qv+Xl5f/vr6+/7q6uv+3uLf/tbW1/7Kysv+wsLD/rq2t/6uqrP+mp6b/oqKi/5+fn/+bm5v/l5aX/5KS
        kv+Oj47/i4qK/4aGhv+BgoH/fX5+/3l5ef90dHT/c3Nz/y8vL/8jISP/JCQk/yYmJv8nJif/JiYm/yYm
        Jv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHZ3dv9VVVX/VVVV/1NS
        Uv9QUFD/TU1N/0RERP+ampr/wsLC/76/v/+8vLz/ubm6/7a2t/+zs7P/ra2t/6ampv+io6P/np6f/5ub
        mv+Wl5f/k5OS/46Ojv+Njo3/jY2N/4mJiP+Eg4P/f39//3t7e/92d3b/dXV0/y8vL/8hISH/JCUl/yYm
        Jv8nJyf/JyYm/yYnJv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHh3
        eP9WVlb/VlZW/1RUVP9RUVH/Tk5O/0VERP+cnJz/xsbG/8LCw//AwMD/vb69/7q7uv+3t7f/sLCw/6mp
        qf+mpqb/oqGi/52dnf+ZmZn/lZWV/5SUlP+Tk5P/j4+P/4uLi/+Ghob/gYGB/319ff94eHj/dnd2/y8v
        L/8hIiP/JSUl/ycnJv8oJyj/KCcn/ycnJ/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAHl5ef9YWFj/V1dX/1ZWVv9SU1P/T09P/0ZGRv+fn5//ysvK/8bGxv/DxMT/wcHB/729
        vv+6urr/s7Oz/6ysrP+oqKj/pKWk/6CgoP+bm5v/l5eX/5OTk/+SkpL/kJGQ/42Njf+IiIj/g4OD/35/
        f/96env/eHh4/zAwL/8iIiL/JiYl/ycnJ/8oKCj/Jycn/ygnJ/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAHp7e/9ZWVr/WVlZ/1dXV/9UVFX/T1BP/0ZGRv+ioaL/z8/P/8rL
        yv/HyMf/xMTE/8HBwf++vb7/tra2/6+vr/+qq6v/p6en/6Kiov+enp7/mZmZ/5WVlf+UlJT/k5KS/46O
        jv+Kior/hYWF/4CAgP98fHz/eHl6/zAwMP8jIiP/JiYm/ygnKP8oKCr/KCgo/ycoKP8PDw//Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHx8fP9bW1r/Wlpa/1hYWP9VVlb/UFBQ/0dH
        R/+kpKT/0tLS/87Ozv/Ly8v/x8fH/8PExP/AwMD/ubm5/7Kysf+tra3/qaio/6Wlpf+goKD/m5ub/5eW
        l/+ZmZr/lJSU/5CQj/+Li4v/hoaG/4GBgf99fX3/e3t7/zAwMP8jIyP/JiYm/ygoJ/8pKSj/KSgo/ygo
        KP8QEBD/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAH5+ff9cXFz/XFtc/1pZ
        Wf9XV1b/UVFR/0hISP+lpaX/1tbW/9HR0f/Ozs7/y8rK/8bGxv/DwsL/uLi3/6ysrP+nqaf/o6Oi/56e
        nv+ioqL/paWl/5+fn/+bmpv/lZaW/5GRkP+NjYz/iIiH/4KCgv9+fn7/fHx8/zEyMv8jIyP/Jicn/ygo
        KP8pKSn/KCgp/ygpKP8RERH/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAH9/
        f/9dXV3/XV1d/1paW/9YWFf/UlJS/0lJSf+kpKT/2tra/9TU1P/Q0ND/zc3N/8jJyf/ExMT/vb29/7W1
        tv+xsbH/rKys/6ioqP+ioqT/nZ2e/5iYmP+YmJj/l5eX/5KSkv+Ojo3/iImI/4ODg/9/f3//fX19/zQ0
        NP8jIyP/Jycn/ygoKP8pKSn/KSkp/ygoKP8TExP/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAICAgP9eXl7/Xl5e/1xcXP9ZWVn/U1NT/0lJSf+kpKT/3d3d/9fX1v/S0tL/z8/P/8vL
        y//Gxsb/wsLC/72+vv+4uLn/tLS0/7CwsP+srKz/p6em/6Ghof+dnZ3/mJiY/5KTk/+Ojo7/iYmJ/4SE
        hP9/gID/fn5+/zY2Nv8kIyT/Jycn/ygoKP8pKSn/KSkp/ykpKf8WFhb/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAIKCgv9fX17/Xl5e/11cXf9ZWln/VFRU/0pJSv+lpaX/4eHg/9na
        2v/V1dT/0NDQ/83Mzf/Hx8f/w8PD/7++vv+6urr/tbW1/7CwsP+sra3/p6en/6Kiov+enZ3/mZmY/5SU
        k/+Pj4//ioqK/4WFhf+AgID/fX19/zk5Of8jIyT/Jycn/ygoKf8pKSn/KSkp/ykpJ/8YFxj/DQ0NZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIOEhP9gYGD/X19f/15dXf9aWlr/VVVV/0tK
        S/+lpaX/4eLi/9vb2//W1tX/0dHR/83Nzf/IyMj/w8PE/7+/v/+6u7r/tbW1/7Gxsf+tra3/qKio/6Kj
        o/+enp7/mZmZ/5SUlP+Pj4//i4qK/4WFhf+AgID/fn59/zw8PP8kJCT/Jycn/ykpKf8qKin/KSkp/ygn
        KP8ZGRr/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAISEhP9gYGD/X19f/15e
        Xv9aWlv/VlZW/0tLS/+lpaX/4uLi/9zc3P/W19b/0dLR/83Ozv/JyMn/xMTE/7/AwP+7urv/trW2/7Gx
        sf+tra3/qKin/6Ojov+enp7/mZmZ/5SUlP+Pj5D/i4qK/4aFhf+AgID/fn5+/z9AQP8lJSX/KCgn/ykp
        Kf8qKin/KSkp/ygoKP8bGxv/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIWH
        h/9gYGD/X19f/15eXv9aWlv/VlZX/0xMTP+mpqb/4eLh/9vb2//W1tb/0dHR/83Nzf/IyMn/xMTE/7+/
        v/+7u7v/tba1/7Gxsf+tra3/qKio/6Ojo/+enp7/mZmZ/5SUlP+Pj4//ioqK/4WFhf+AgID/fX59/0JC
        Qv8mJib/KCgo/ykpKf8qKir/KSkp/ygoKP8cHBz/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAIiIiP9gYGD/X19f/15eXv9bW1v/WFdX/05OTf+np6f/4eHh/9rZ2v/V1dX/0NDQ/83N
        zf/IyMf/w8PD/76/v/+6urr/tbW1/7CxsP+sra3/p6in/6Kiov+enp7/mZmZ/5OUlP+Pj4//ioqK/4WE
        hf+AgID/fn19/0ZGRv8mJyb/Kikq/yorKv8qKyr/KSkp/ygoKP8dHh7/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAImJif9gYGD/X19f/15eXv9bW1v/WFhY/1BQUP+pqan/6Ojo/9bW
        1v/S09P/z8/P/8vLy//Gxsb/wsLC/76+vv+5ubn/tLS0/7CwsP+srKv/p6em/6Giov+dnZ3/mJiY/5OT
        k/+Oj47/iYmJ/4SEhP9/f4D/e3t7/0pKS/8oKCj/Kysr/ywsLP8rKir/Kikq/yknJ/8fHx//DQ0NZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIuLi/9fX17/Xl5f/11dXf9bW1v/WVhY/1RU
        VP9XV1j//////+Pj4//T09P/z8/P/8rKyv/Fx8f/wcHC/7++v/+5ubn/tbW1/7CwsP+sraz/pqao/6Ki
        ov+enZ7/mZmZ/5STlP+QkJD/i4uL/4aGhv+BgYH/fHx8/zEwL/8rKiz/LCws/y0sLP8rKir/F4GW/ygm
        J/8iIiL/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIyMjP9eXV3/Xl5e/11c
        XP9bW1v/WFlZ/1ZWVf9OTk7/VldW/6enp/+lpaX/pKSk/6Kiov+goKD/nJyc/5iYmP+Tk5P/jo+P/4mJ
        if+FhIX/gICA/3t7fP92dnb/cXJx/21tbf9nZmb/YmJi/11dXf9aWlr/MzMz/ywtLP8uLi3/LS0t/y0t
        Lf8sKin/KScm/ycmJP8kJCT/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAI6O
        jv9cXlz/Xl5e/1tbXP9aWlr/WFhY/1ZWV/9SU1P/Tk9P/0tLSv9HR0f/RERE/0JCQv9AQED/Pj8//zw8
        Pf87Ozv/Ozs8/zo6Ov85OTn/ODg4/zY2Nv81NDX/NDM0/zMzM/8xMTH/MDAw/y8vL/8vLy//Li4u/y8v
        L/8uLy7/Li0t/y0tLP8rKij/F4GW/ygmJ/8mJib/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAJCPkP9dW1v/XV1c/1tbW/9ZWVn/WFhY/1ZWVv9TVFP/UlJR/09PT/9OTk3/S0xL/0pK
        Sv9ISEj/R0ZH/0VERf9CQkP/QUFC/0BAQP8/Pz//Pj4+/z09Pf87Ozv/OTk6/zg4OP82Njf/NTU1/zMz
        M/8yMjL/MTEx/y8wL/8vLy//Ly0t/xeAlf8sKCf/KScm/ykmJf8nJyf/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAJKSkv9aWlr/W1tb/1paWv9ZWVj/V1dX/1ZVVv9UVFT/UlJR/1BP
        UP9OTk7/TU1N/0xMTP9KSkr/SElI/0dHR/9GRkb/RERE/0JCQv9AQED/Pz8//z4+Pv89PT3/Ozs7/zk5
        Of84ODj/Nzc2/zQ0NP8zMzP/MjIy/zAwMP8vLy//Lyws/y4qK/8tKCf/GI6q/ygnJv8pKCn/DQ0NZA4O
        DlcNDQ0yCAgIDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAJOTk/9ZWFj/Wlpa/1lZWf9YWFj/V1dW/1VV
        VP9TU1P/UVFR/1BPUP9PT0//TU5O/0xMTP9LSkv/SUlJ/0hISP9GRkb/RERE/0NCQv9BQUH/QD8//z4/
        Pv89PT7/Ozw8/zo6Ov85OTn/Nzg3/zU1NP8zMzP/MTIy/zAwMP8vLy//Li0t/xeAlf8tJyj/KyYm/ygk
        Jf8rKyv/DQ0NVw0NDUwNDQ0sCQkJDAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAJOTk/9XV1f/WVhY/1hY
        V/9XV1f/VlZW/1VVVf9SUlL/UFFR/09PT/9OTk7/TU1N/0xMTP9LSkr/SUlJ/0dHR/9GRkb/REVE/0JC
        Qv9BQUD/Pz8//z8/Pv89PT3/Ozw8/zo6Ov84ODj/Nzc2/zQ0Nf8zMzP/MTIy/zAwL/8vLy//Li0t/y0s
        LP8rKSj/GI6q/yclJf8tLS3/DAwMMg0NDSwLCwsaCAgIBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJKS
        kv9UVVX/VVVV/1RVVf9TU1P/UlJS/1FRUf9PT0//Tk5O/01NTf9MTEz/SktL/0tJSf9JSUn/SEhI/0ZG
        R/9FRUX/Q0ND/0FBQf9APz//Pj4+/z0+Pf88PDz/Ojo6/zk5Of84ODj/NjY2/zM0M/8yMjH/MDAw/y8v
        L/8uLi7/LS0t/y0tLf8rKSn/KSYm/yclJP8vLy//BwcHDgkJCQwICAgHAAAAAgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAJaVlf+TkpL/kpKS/4+Qj/+NjY3/iYmJ/4eHhv+FhYX/goKD/3+Af/99fHz/enl5/3Z2
        dv90dHT/cnJy/3Bwb/9ra2v/aGho/2VmZf9jZGP/YWFh/15eX/9cXFz/WFhY/1VUVf9TUlL/UFBQ/01N
        Tf9LS0v/SEhI/0NEQ/9BQUH/Pz8//zw9PP85OTn/NjY2/zIyMv8xMTH/AAAAAQAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAf
        AAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAf
        AAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAP///////wAA////////
        AAD///////8AAP///////wAA////////AAA=
</value>
  </data>
</root>
```

`LibreHardwareMonitor/UI/Node.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.ObjectModel;
using System.Drawing;

namespace LibreHardwareMonitor.UI;

public class Node
{
    private Node _parent;
    private readonly NodeCollection _nodes;
    private string _text;
    private bool _visible;

    public delegate void NodeEventHandler(Node node);
    public event NodeEventHandler IsVisibleChanged;
    public event NodeEventHandler NodeAdded;
    public event NodeEventHandler NodeRemoved;

    private TreeModel RootTreeModel()
    {
        Node node = this;
        while (node != null)
        {
            if (node.Model != null)
                return node.Model;
            node = node._parent;
        }
        return null;
    }

    public Node() : this(string.Empty) { }

    public Node(string text)
    {
        _text = text;
        _nodes = new NodeCollection(this);
        _visible = true;
    }

    public TreeModel Model { get; set; }

    public Node Parent
    {
        get { return _parent; }
        set
        {
            if (value != _parent)
            {
                _parent?._nodes.Remove(this);
                value?._nodes.Add(this);
            }
        }
    }

    public Collection<Node> Nodes
    {
        get { return _nodes; }
    }

    public virtual string Text
    {
        get { return _text; }
        set
        {
            _text = value;
        }
    }

    public virtual string ToolTip { get; }

    public Image Image { get; set; }

    public virtual bool IsVisible
    {
        get { return _visible; }
        set
        {
            if (value != _visible)
            {
                _visible = value;
                TreeModel model = RootTreeModel();
                if (model != null && _parent != null)
                {
                    int index = 0;
                    for (int i = 0; i < _parent._nodes.Count; i++)
                    {
                        Node node = _parent._nodes[i];
                        if (node == this)
                            break;
                        if (node.IsVisible || model.ForceVisible)
                            index++;
                    }
                    if (model.ForceVisible)
                    {
                        model.OnNodeChanged(_parent, index, this);
                    }
                    else
                    {
                        if (value)
                            model.OnNodeInserted(_parent, index, this);
                        else
                            model.OnNodeRemoved(_parent, index, this);
                    }
                }
                IsVisibleChanged?.Invoke(this);
            }
        }
    }

    private class NodeCollection : Collection<Node>
    {
        private readonly Node _owner;

        public NodeCollection(Node owner)
        {
            _owner = owner;
        }

        protected override void ClearItems()
        {
            while (Count != 0)
                RemoveAt(Count - 1);
        }

        protected override void InsertItem(int index, Node item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item));

            if (item._parent != _owner)
            {
                item._parent?._nodes.Remove(item);
                item._parent = _owner;
                base.InsertItem(index, item);

                TreeModel model = _owner.RootTreeModel();
                model?.OnStructureChanged(_owner);
                _owner.NodeAdded?.Invoke(item);
            }
        }

        protected override void RemoveItem(int index)
        {
            Node item = this[index];
            item._parent = null;
            base.RemoveItem(index);

            TreeModel model = _owner.RootTreeModel();
            model?.OnStructureChanged(_owner);
            _owner.NodeRemoved?.Invoke(item);
        }

        protected override void SetItem(int index, Node item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item));

            RemoveAt(index);
            InsertItem(index, item);
        }
    }
}
```

`LibreHardwareMonitor/UI/NodeToolTipProvider.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using Aga.Controls.Tree;
using Aga.Controls.Tree.NodeControls;

namespace LibreHardwareMonitor.UI;

internal class NodeToolTipProvider : IToolTipProvider
{
    public string GetToolTip(TreeNodeAdv node, NodeControl nodeControl) => (node.Tag as Node)?.ToolTip;
}
```

`LibreHardwareMonitor/UI/NotifyIconAdv.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.ComponentModel;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI;

public class NotifyIconAdv : IDisposable
{
    private readonly NotifyIcon _genericNotifyIcon;
    private readonly NotifyIconWindowsImplementation _windowsNotifyIcon;

    public NotifyIconAdv()
    {
        if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
            _genericNotifyIcon = new NotifyIcon();
        else
            _windowsNotifyIcon = new NotifyIconWindowsImplementation();
    }

    public event EventHandler BalloonTipClicked
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipClicked += value;
            else
                _windowsNotifyIcon.BalloonTipClicked += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipClicked -= value;
            else
                _windowsNotifyIcon.BalloonTipClicked -= value;
        }
    }

    public event EventHandler BalloonTipClosed
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipClosed += value;
            else
                _windowsNotifyIcon.BalloonTipClosed += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipClosed -= value;
            else
                _windowsNotifyIcon.BalloonTipClosed -= value;
        }
    }

    public event EventHandler BalloonTipShown
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipShown += value;
            else
                _windowsNotifyIcon.BalloonTipShown += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipShown -= value;
            else
                _windowsNotifyIcon.BalloonTipShown -= value;
        }
    }

    public event EventHandler Click
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.Click += value;
            else
                _windowsNotifyIcon.Click += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.Click -= value;
            else
                _windowsNotifyIcon.Click -= value;
        }
    }

    public event EventHandler DoubleClick
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.DoubleClick += value;
            else
                _windowsNotifyIcon.DoubleClick += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.DoubleClick -= value;
            else
                _windowsNotifyIcon.DoubleClick -= value;
        }
    }

    public event MouseEventHandler MouseClick
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseClick += value;
            else
                _windowsNotifyIcon.MouseClick += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseClick -= value;
            else
                _windowsNotifyIcon.MouseClick -= value;
        }
    }

    public event MouseEventHandler MouseDoubleClick
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseDoubleClick += value;
            else
                _windowsNotifyIcon.MouseDoubleClick += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseDoubleClick -= value;
            else
                _windowsNotifyIcon.MouseDoubleClick -= value;
        }
    }

    public event MouseEventHandler MouseDown
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseDown += value;
            else
                _windowsNotifyIcon.MouseDown += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseDown -= value;
            else
                _windowsNotifyIcon.MouseDown -= value;
        }
    }

    public event MouseEventHandler MouseMove
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseMove += value;
            else
                _windowsNotifyIcon.MouseMove += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseMove -= value;
            else
                _windowsNotifyIcon.MouseMove -= value;
        }
    }

    public event MouseEventHandler MouseUp
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseUp += value;
            else
                _windowsNotifyIcon.MouseUp += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseUp -= value;
            else
                _windowsNotifyIcon.MouseUp -= value;
        }
    }

    public string BalloonTipText
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.BalloonTipText;


            return _windowsNotifyIcon.BalloonTipText;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipText = value;
            else
                _windowsNotifyIcon.BalloonTipText = value;
        }
    }

    public ToolTipIcon BalloonTipIcon
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.BalloonTipIcon;


            return _windowsNotifyIcon.BalloonTipIcon;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipIcon = value;
            else
                _windowsNotifyIcon.BalloonTipIcon = value;
        }
    }

    public string BalloonTipTitle
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.BalloonTipTitle;


            return _windowsNotifyIcon.BalloonTipTitle;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipTitle = value;
            else
                _windowsNotifyIcon.BalloonTipTitle = value;
        }
    }

    public ContextMenuStrip ContextMenuStrip
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.ContextMenuStrip;


            return _windowsNotifyIcon.ContextMenuStrip;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.ContextMenuStrip = value;
            else
                _windowsNotifyIcon.ContextMenuStrip = value;
        }
    }

    public object Tag { get; set; }

    public Icon Icon
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.Icon;


            return _windowsNotifyIcon.Icon;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.Icon = value;
            else
                _windowsNotifyIcon.Icon = value;
        }
    }

    public string Text
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.Text;


            return _windowsNotifyIcon.Text;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.Text = value;
            else
                _windowsNotifyIcon.Text = value;
        }
    }

    public bool Visible
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.Visible;


            return _windowsNotifyIcon.Visible;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.Visible = value;
            else
                _windowsNotifyIcon.Visible = value;
        }
    }

    public void Dispose()
    {
        if (_genericNotifyIcon != null)
            _genericNotifyIcon.Dispose();
        else
            _windowsNotifyIcon.Dispose();
    }

    public void ShowBalloonTip(int timeout)
    {
        ShowBalloonTip(timeout, BalloonTipTitle, BalloonTipText, BalloonTipIcon);
    }

    public void ShowBalloonTip(int timeout, string tipTitle, string tipText,
        ToolTipIcon tipIcon)
    {
        if (_genericNotifyIcon != null)
            _genericNotifyIcon.ShowBalloonTip(timeout, tipTitle, tipText, tipIcon);
        else
            _windowsNotifyIcon.ShowBalloonTip(timeout, tipTitle, tipText, tipIcon);
    }

    private class NotifyIconWindowsImplementation : Component
    {

        private static int _nextId;
        private readonly object _syncObj = new object();
        private Icon _icon;
        private string _text = "";
        private readonly int _id;
        private bool _created;
        private NotifyIconNativeWindow _window;
        private bool _doubleClickDown;
        private bool _visible;
        private readonly MethodInfo _commandDispatch;

        public event EventHandler BalloonTipClicked;
        public event EventHandler BalloonTipClosed;
        public event EventHandler BalloonTipShown;
        public event EventHandler Click;
        public event EventHandler DoubleClick;
        public event MouseEventHandler MouseClick;
        public event MouseEventHandler MouseDoubleClick;
        public event MouseEventHandler MouseDown;
        public event MouseEventHandler MouseMove;
        public event MouseEventHandler MouseUp;

        public string BalloonTipText { get; set; }
        public ToolTipIcon BalloonTipIcon { get; set; }
        public string BalloonTipTitle { get; set; }
        public ContextMenuStrip ContextMenuStrip { get; set; }

        public Icon Icon
        {
            get
            {
                return _icon;
            }
            set
            {
                if (_icon != value)
                {
                    _icon = value;
                    UpdateNotifyIcon(_visible);
                }
            }
        }

        public string Text
        {
            get
            {
                return _text;
            }
            set
            {
                if (value == null)
                    value = "";

                if (value.Length > 63)
                    throw new ArgumentOutOfRangeException();

                if (!value.Equals(_text))
                {
                    _text = value;
                    if (_visible)
                        UpdateNotifyIcon(_visible);
                }
            }
        }

        public bool Visible
        {
            get
            {
                return _visible;
            }
            set
            {
                if (_visible != value)
                {
                    _visible = value;
                    UpdateNotifyIcon(_visible);
                }
            }
        }

        public NotifyIconWindowsImplementation()
        {
            BalloonTipText = "";
            BalloonTipTitle = "";

            _commandDispatch = typeof(Form).Assembly.
                                            GetType("System.Windows.Forms.Command").GetMethod("DispatchID",
                                                                                              BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public,
                                                                                              null, new[] { typeof(int) }, null);

            _id = ++_nextId;
            _window = new NotifyIconNativeWindow(this);
            UpdateNotifyIcon(_visible);
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (_window != null)
                {
                    _icon = null;
                    _text = "";
                    UpdateNotifyIcon(false);
                    _window.DestroyHandle();
                    _window = null;
                    ContextMenuStrip = null;
                }
            }
            else
            {
                if (_window != null && _window.Handle != IntPtr.Zero)
                {
                    NativeMethods.PostMessage(new HandleRef(_window, _window.Handle), WM_CLOSE, 0, 0);
                    _window.ReleaseHandle();
                }
            }
            base.Dispose(disposing);
        }

        public void ShowBalloonTip(int timeout)
        {
            ShowBalloonTip(timeout, BalloonTipTitle, BalloonTipText, BalloonTipIcon);
        }

        public void ShowBalloonTip(int timeout, string tipTitle, string tipText, ToolTipIcon tipIcon)
        {
            if (timeout < 0)
                throw new ArgumentOutOfRangeException(nameof(timeout));

            if (string.IsNullOrEmpty(tipText))
                throw new ArgumentException("tipText");

            if (DesignMode)
                return;

            if (_created)
            {
                NativeMethods.NotifyIconData data = new NativeMethods.NotifyIconData();
                if (_window.Handle == IntPtr.Zero)
                    _window.CreateHandle(new CreateParams());

                data.Window = _window.Handle;
                data.ID = _id;
                data.Flags = NativeMethods.NotifyIconDataFlags.Info;
                data.TimeoutOrVersion = timeout;
                data.InfoTitle = tipTitle;
                data.Info = tipText;
                data.InfoFlags = (int)tipIcon;

                NativeMethods.Shell_NotifyIcon(NativeMethods.NotifyIconMessage.Modify, data);
            }
        }

        private void ShowContextMenu()
        {
            if (ContextMenuStrip == null)
                return;

            NativeMethods.Point p = new NativeMethods.Point();
            NativeMethods.GetCursorPos(ref p);
            NativeMethods.SetForegroundWindow(new HandleRef(_window, _window.Handle));

            ContextMenuStrip?.GetType().InvokeMember("ShowInTaskbar",
                                                     BindingFlags.NonPublic | BindingFlags.InvokeMethod |
                                                     BindingFlags.Instance, null, ContextMenuStrip, new object[] { p.X, p.Y });
        }

        private void UpdateNotifyIcon(bool showNotifyIcon)
        {
            if (DesignMode)
                return;

            lock (_syncObj)
            {
                _window.LockReference(showNotifyIcon);

                NativeMethods.NotifyIconData data = new NativeMethods.NotifyIconData { CallbackMessage = WM_TRAYMOUSEMESSAGE, Flags = NativeMethods.NotifyIconDataFlags.Message };

                if (showNotifyIcon && _window.Handle == IntPtr.Zero)
                    _window.CreateHandle(new CreateParams());

                data.Window = _window.Handle;
                data.ID = _id;

                if (_icon != null)
                {
                    data.Flags |= NativeMethods.NotifyIconDataFlags.Icon;
                    data.Icon = _icon.Handle;
                }

                data.Flags |= NativeMethods.NotifyIconDataFlags.Tip;
                data.Tip = _text;

                if (showNotifyIcon && _icon != null)
                {
                    if (!_created)
                    {
                        if (NativeMethods.Shell_NotifyIcon(NativeMethods.NotifyIconMessage.Modify, data))
                        {
                            _created = true;
                        }
                        else
                        {
                            int i = 0;
                            do
                            {
                                _created = NativeMethods.Shell_NotifyIcon(NativeMethods.NotifyIconMessage.Add, data);
                                if (!_created)
                                {
                                    System.Threading.Thread.Sleep(200);
                                    i++;
                                }
                            } while (!_created && i < 40);
                        }
                    }
                    else
                    {
                        NativeMethods.Shell_NotifyIcon(NativeMethods.NotifyIconMessage.Modify, data);
                    }
                }
                else
                {
                    if (_created)
                    {
                        int i = 0;
                        bool deleted;
                        do
                        {
                            deleted = NativeMethods.Shell_NotifyIcon(NativeMethods.NotifyIconMessage.Delete, data);
                            if (!deleted)
                            {
                                System.Threading.Thread.Sleep(200);
                                i++;
                            }
                        } while (!deleted && i < 40);
                        _created = false;
                    }
                }
            }
        }

        private void ProcessMouseDown(MouseButtons button, bool doubleClick)
        {
            if (doubleClick)
            {
                DoubleClick?.Invoke(this, new MouseEventArgs(button, 2, 0, 0, 0));
                MouseDoubleClick?.Invoke(this, new MouseEventArgs(button, 2, 0, 0, 0));

                _doubleClickDown = true;
            }

            MouseDown?.Invoke(this, new MouseEventArgs(button, doubleClick ? 2 : 1, 0, 0, 0));
        }

        private void ProcessMouseUp(MouseButtons button)
        {
            MouseUp?.Invoke(this, new MouseEventArgs(button, 0, 0, 0, 0));

            if (!_doubleClickDown)
            {
                Click?.Invoke(this, new MouseEventArgs(button, 0, 0, 0, 0));
                MouseClick?.Invoke(this, new MouseEventArgs(button, 0, 0, 0, 0));
            }
            _doubleClickDown = false;
        }

        private void ProcessInitMenuPopup(ref Message message)
        {
            _window.DefWndProc(ref message);
        }

        private void WndProc(ref Message message)
        {
            switch (message.Msg)
            {
                case WM_DESTROY:
                    UpdateNotifyIcon(false);
                    return;
                case WM_COMMAND:
                    if (message.LParam != IntPtr.Zero)
                    {
                        _window.DefWndProc(ref message);
                        return;
                    }
                    _commandDispatch.Invoke(null, new object[] { message.WParam.ToInt32() & 0xFFFF });
                    return;
                case WM_INITMENUPOPUP:
                    ProcessInitMenuPopup(ref message);
                    return;
                case WM_TRAYMOUSEMESSAGE:
                    switch ((int)message.LParam)
                    {
                        case WM_MOUSEMOVE:
                            MouseMove?.Invoke(this,
                                              new MouseEventArgs(Control.MouseButtons, 0, 0, 0, 0));
                            return;
                        case WM_LBUTTONDOWN:
                            ProcessMouseDown(MouseButtons.Left, false);
                            return;
                        case WM_LBUTTONUP:
                            ProcessMouseUp(MouseButtons.Left);
                            return;
                        case WM_LBUTTONDBLCLK:
                            ProcessMouseDown(MouseButtons.Left, true);
                            return;
                        case WM_RBUTTONDOWN:
                            ProcessMouseDown(MouseButtons.Right, false);
                            return;
                        case WM_RBUTTONUP:
                            if (ContextMenuStrip != null)
                                ShowContextMenu();
                            ProcessMouseUp(MouseButtons.Right);
                            return;
                        case WM_RBUTTONDBLCLK:
                            ProcessMouseDown(MouseButtons.Right, true);
                            return;
                        case WM_MBUTTONDOWN:
                            ProcessMouseDown(MouseButtons.Middle, false);
                            return;
                        case WM_MBUTTONUP:
                            ProcessMouseUp(MouseButtons.Middle);
                            return;
                        case WM_MBUTTONDBLCLK:
                            ProcessMouseDown(MouseButtons.Middle, true);
                            return;
                        case NIN_BALLOONSHOW:
                            BalloonTipShown?.Invoke(this, EventArgs.Empty);
                            return;
                        case NIN_BALLOONHIDE:
                        case NIN_BALLOONTIMEOUT:
                            BalloonTipClosed?.Invoke(this, EventArgs.Empty);
                            return;
                        case NIN_BALLOONUSERCLICK:
                            BalloonTipClicked?.Invoke(this, EventArgs.Empty);
                            return;
                        default:
                            return;
                    }
            }

            if (message.Msg == _wmTaskBarCreated)
            {
                lock (_syncObj)
                {
                    _created = false;
                }
                UpdateNotifyIcon(_visible);
            }

            _window.DefWndProc(ref message);
        }

        private class NotifyIconNativeWindow : NativeWindow
        {
            private readonly NotifyIconWindowsImplementation _reference;
            private GCHandle _referenceHandle;

            internal NotifyIconNativeWindow(NotifyIconWindowsImplementation component)
            {
                _reference = component;
            }

            ~NotifyIconNativeWindow()
            {
                if (Handle != IntPtr.Zero)
                    NativeMethods.PostMessage(new HandleRef(this, Handle), WM_CLOSE, 0, 0);
            }

            public void LockReference(bool locked)
            {
                if (locked)
                {
                    if (!_referenceHandle.IsAllocated)
                    {
                        _referenceHandle = GCHandle.Alloc(_reference, GCHandleType.Normal);
                    }
                }
                else
                {
                    if (_referenceHandle.IsAllocated)
                        _referenceHandle.Free();
                }
            }

            protected override void OnThreadException(Exception e)
            {
                Application.OnThreadException(e);
            }

            protected override void WndProc(ref Message m)
            {
                _reference.WndProc(ref m);
            }
        }

        private const int WM_NULL = 0x00;
        private const int WM_DESTROY = 0x02;
        private const int WM_CLOSE = 0x10;
        private const int WM_COMMAND = 0x111;
        private const int WM_INITMENUPOPUP = 0x117;
        private const int WM_MOUSEMOVE = 0x200;
        private const int WM_LBUTTONDOWN = 0x201;
        private const int WM_LBUTTONUP = 0x202;
        private const int WM_LBUTTONDBLCLK = 0x203;
        private const int WM_RBUTTONDOWN = 0x204;
        private const int WM_RBUTTONUP = 0x205;
        private const int WM_RBUTTONDBLCLK = 0x206;
        private const int WM_MBUTTONDOWN = 0x207;
        private const int WM_MBUTTONUP = 0x208;
        private const int WM_MBUTTONDBLCLK = 0x209;
        private const int WM_TRAYMOUSEMESSAGE = 0x800;

        private const int NIN_BALLOONSHOW = 0x402;
        private const int NIN_BALLOONHIDE = 0x403;
        private const int NIN_BALLOONTIMEOUT = 0x404;
        private const int NIN_BALLOONUSERCLICK = 0x405;

        private static readonly int _wmTaskBarCreated = NativeMethods.RegisterWindowMessage("TaskbarCreated");

        private static class NativeMethods
        {
            private const string DllNameUser32 = "user32.dll";
            private const string DllNameShell32 = "shell32.dll";

            [DllImport(DllNameUser32, CharSet = CharSet.Auto)]
            public static extern IntPtr PostMessage(HandleRef hwnd, int msg, int wparam, int lparam);

            [DllImport(DllNameUser32, CharSet = CharSet.Auto)]
            public static extern int RegisterWindowMessage(string msg);

            [Flags]
            public enum NotifyIconDataFlags : int
            {
                Message = 0x1,
                Icon = 0x2,
                Tip = 0x4,
                State = 0x8,
                Info = 0x10
            }

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
            public class NotifyIconData
            {
                private int _size = Marshal.SizeOf(typeof(NotifyIconData));
                public IntPtr Window;
                public int ID;
                public NotifyIconDataFlags Flags;
                public int CallbackMessage;
                public IntPtr Icon;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
                public string Tip;
                public int State;
                public int StateMask;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
                public string Info;
                public int TimeoutOrVersion;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
                public string InfoTitle;
                public int InfoFlags;
            }

            public enum NotifyIconMessage : int
            {
                Add = 0x0,
                Modify = 0x1,
                Delete = 0x2
            }

            [DllImport(DllNameShell32, CharSet = CharSet.Auto)]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool Shell_NotifyIcon(NotifyIconMessage message, NotifyIconData pnid);

            [DllImport(DllNameUser32, CharSet = CharSet.Auto, ExactSpelling = true)]
            public static extern bool TrackPopupMenuEx(HandleRef hmenu, int fuFlags, int x, int y, HandleRef hwnd, IntPtr tpm);

            [StructLayout(LayoutKind.Sequential)]
            public struct Point
            {
                public readonly int X;
                public readonly int Y;
            }

            [DllImport(DllNameUser32, CharSet = CharSet.Auto, ExactSpelling = true)]
            public static extern bool GetCursorPos(ref Point point);

            [DllImport(DllNameUser32, CharSet = CharSet.Auto, ExactSpelling = true)]
            public static extern bool SetForegroundWindow(HandleRef hWnd);
        }
    }
}
```

`LibreHardwareMonitor/UI/ParameterForm.Designer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.UI
{
    partial class ParameterForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle2 = new System.Windows.Forms.DataGridViewCellStyle();
            this.okButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.captionLabel = new System.Windows.Forms.Label();
            this.dataGridView = new System.Windows.Forms.DataGridView();
            this.NameColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Default = new System.Windows.Forms.DataGridViewCheckBoxColumn();
            this.ValueColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.bindingSource = new System.Windows.Forms.BindingSource(this.components);
            this.descriptionLabel = new System.Windows.Forms.Label();
            ((System.ComponentModel.ISupportInitialize)(this.dataGridView)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.bindingSource)).BeginInit();
            this.SuspendLayout();
            //
            // okButton
            //
            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.okButton.Location = new System.Drawing.Point(186, 213);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(75, 23);
            this.okButton.TabIndex = 2;
            this.okButton.Text = "OK";
            this.okButton.UseVisualStyleBackColor = true;
            this.okButton.Click += new System.EventHandler(this.OkButton_Click);
            //
            // cancelButton
            //
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(267, 213);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(75, 23);
            this.cancelButton.TabIndex = 3;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = true;
            //
            // captionLabel
            //
            this.captionLabel.AutoSize = true;
            this.captionLabel.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.captionLabel.Location = new System.Drawing.Point(12, 9);
            this.captionLabel.Name = "captionLabel";
            this.captionLabel.Size = new System.Drawing.Size(80, 13);
            this.captionLabel.TabIndex = 4;
            this.captionLabel.Text = "captionLabel";
            //
            // dataGridView
            //
            this.dataGridView.AllowUserToAddRows = false;
            this.dataGridView.AllowUserToDeleteRows = false;
            this.dataGridView.AllowUserToResizeRows = false;
            this.dataGridView.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
            | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.dataGridView.AutoGenerateColumns = false;
            this.dataGridView.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.Fill;
            this.dataGridView.BackgroundColor = System.Drawing.SystemColors.Window;
            this.dataGridView.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
            this.dataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.dataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.NameColumn,
            this.Default,
            this.ValueColumn});
            this.dataGridView.DataSource = this.bindingSource;
            dataGridViewCellStyle2.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            dataGridViewCellStyle2.BackColor = System.Drawing.SystemColors.Window;
            dataGridViewCellStyle2.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            dataGridViewCellStyle2.ForeColor = System.Drawing.SystemColors.ControlText;
            dataGridViewCellStyle2.SelectionBackColor = System.Drawing.Color.FromArgb(((int)(((byte)(240)))), ((int)(((byte)(240)))), ((int)(((byte)(240)))));
            dataGridViewCellStyle2.SelectionForeColor = System.Drawing.SystemColors.ControlText;
            dataGridViewCellStyle2.WrapMode = System.Windows.Forms.DataGridViewTriState.False;
            this.dataGridView.DefaultCellStyle = dataGridViewCellStyle2;
            this.dataGridView.Location = new System.Drawing.Point(15, 30);
            this.dataGridView.MultiSelect = false;
            this.dataGridView.Name = "dataGridView";
            this.dataGridView.RowHeadersVisible = false;
            this.dataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
            this.dataGridView.ShowRowErrors = false;
            this.dataGridView.Size = new System.Drawing.Size(327, 121);
            this.dataGridView.TabIndex = 0;
            this.dataGridView.CellEndEdit += new System.Windows.Forms.DataGridViewCellEventHandler(this.DataGridView_CellEndEdit);
            this.dataGridView.CellValidating += new System.Windows.Forms.DataGridViewCellValidatingEventHandler(this.DataGridView_CellValidating);
            this.dataGridView.CurrentCellDirtyStateChanged += new System.EventHandler(this.DataGridView_CurrentCellDirtyStateChanged);
            this.dataGridView.RowEnter += new System.Windows.Forms.DataGridViewCellEventHandler(this.DataGridView_RowEnter);
            //
            // NameColumn
            //
            this.NameColumn.DataPropertyName = "Name";
            this.NameColumn.HeaderText = "Name";
            this.NameColumn.Name = "NameColumn";
            this.NameColumn.ReadOnly = true;
            this.NameColumn.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            //
            // Default
            //
            this.Default.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.ColumnHeader;
            this.Default.DataPropertyName = "Default";
            this.Default.HeaderText = "Default";
            this.Default.Name = "Default";
            this.Default.Width = 47;
            //
            // ValueColumn
            //
            this.ValueColumn.DataPropertyName = "Value";
            this.ValueColumn.HeaderText = "Value";
            this.ValueColumn.Name = "ValueColumn";
            this.ValueColumn.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            //
            // bindingSource
            //
            this.bindingSource.AllowNew = false;
            //
            // descriptionLabel
            //
            this.descriptionLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.descriptionLabel.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.descriptionLabel.Location = new System.Drawing.Point(15, 154);
            this.descriptionLabel.Name = "descriptionLabel";
            this.descriptionLabel.Padding = new System.Windows.Forms.Padding(2);
            this.descriptionLabel.Size = new System.Drawing.Size(327, 50);
            this.descriptionLabel.TabIndex = 6;
            this.descriptionLabel.Text = "descriptionLabel";
            //
            // ParameterForm
            //
            this.AcceptButton = this.okButton;
            this.AccessibleName = "";
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(354, 248);
            this.Controls.Add(this.descriptionLabel);
            this.Controls.Add(this.dataGridView);
            this.Controls.Add(this.captionLabel);
            this.Controls.Add(this.cancelButton);
            this.Controls.Add(this.okButton);
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "ParameterForm";
            this.ShowIcon = false;
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Parameters";
            ((System.ComponentModel.ISupportInitialize)(this.dataGridView)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.bindingSource)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.Button cancelButton;
        public System.Windows.Forms.Label captionLabel;
        private System.Windows.Forms.DataGridView dataGridView;
        private System.Windows.Forms.Label descriptionLabel;
        private System.Windows.Forms.BindingSource bindingSource;
        private System.Windows.Forms.DataGridViewTextBoxColumn NameColumn;
        private System.Windows.Forms.DataGridViewCheckBoxColumn Default;
        private System.Windows.Forms.DataGridViewTextBoxColumn ValueColumn;

    }
}

```

`LibreHardwareMonitor/UI/ParameterForm.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.UI;

public partial class ParameterForm : Form
{
    private IReadOnlyList<IParameter> _parameters;
    private BindingList<ParameterRow> _parameterRows;

    public ParameterForm()
    {
        InitializeComponent();
    }

    public IReadOnlyList<IParameter> Parameters
    {
        get
        {
            return _parameters;
        }
        set
        {
            _parameters = value;
            _parameterRows = new BindingList<ParameterRow>();

            foreach (IParameter parameter in _parameters)
            {
                _parameterRows.Add(new ParameterRow(parameter));
            }

            bindingSource.DataSource = _parameterRows;
        }
    }

    private class ParameterRow : INotifyPropertyChanged
    {
        public readonly IParameter Parameter;
        private float _value = float.NaN;
        private bool _default = true;

        public event PropertyChangedEventHandler PropertyChanged;

        private void NotifyPropertyChanged(String propertyName)
        {
            if (PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }

        public ParameterRow(IParameter parameter)
        {
            Parameter = parameter;
            Value = parameter.Value;
            Default = parameter.IsDefault;
        }

        public string Name
        {
            get { return Parameter.Name; }
        }

        public float Value
        {
            get { return _value; }
            set
            {
                _default = false;
                _value = value;
                NotifyPropertyChanged(nameof(Default));
                NotifyPropertyChanged(nameof(Value));
            }
        }

        public bool Default
        {
            get { return _default; }
            set
            {
                _default = value;
                if (_default)
                    _value = Parameter.DefaultValue;
                NotifyPropertyChanged(nameof(Default));
                NotifyPropertyChanged(nameof(Value));
            }
        }
    }

    private void DataGridView_RowEnter(object sender, DataGridViewCellEventArgs e)
    {
        if (e.RowIndex >= 0 && e.RowIndex < _parameters.Count)
            descriptionLabel.Text = _parameters[e.RowIndex].Description;
        else
            descriptionLabel.Text = string.Empty;
    }

    private void DataGridView_CellValidating(object sender, DataGridViewCellValidatingEventArgs e)
    {
        if (e.ColumnIndex == 2 && !float.TryParse(e.FormattedValue.ToString(), out float _))
        {
            dataGridView.Rows[e.RowIndex].Cells[0].ErrorText = "Invalid value";
            e.Cancel = true;
        }
    }

    private void DataGridView_CellEndEdit(object sender, DataGridViewCellEventArgs e)
    {
        dataGridView.Rows[e.RowIndex].Cells[0].ErrorText = string.Empty;
    }

    private void OkButton_Click(object sender, EventArgs e)
    {
        foreach (ParameterRow row in _parameterRows)
        {
            if (row.Default)
                row.Parameter.IsDefault = true;
            else
                row.Parameter.Value = row.Value;
        }
    }

    private void DataGridView_CurrentCellDirtyStateChanged(object sender, EventArgs e)
    {
        if (dataGridView.CurrentCell is DataGridViewCheckBoxCell || dataGridView.CurrentCell is DataGridViewComboBoxCell)
            dataGridView.CommitEdit(DataGridViewDataErrorContexts.Commit);
    }
}
```

`LibreHardwareMonitor/UI/ParameterForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="NameColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="Default.UserAddedColumn" type="System.Boolean, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="ValueColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="bindingSource.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>
```

`LibreHardwareMonitor/UI/PlotPanel.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;
using OxyPlot;
using OxyPlot.Annotations;
using OxyPlot.Axes;
using OxyPlot.WindowsForms;
using OxyPlot.Series;

namespace LibreHardwareMonitor.UI;

public class PlotPanel : UserControl
{
    private readonly PersistentSettings _settings;
    private readonly UnitManager _unitManager;
    private readonly PlotView _plot;
    private readonly PlotModel _model;
    private readonly TimeSpanAxis _timeAxis = new TimeSpanAxis();
    private readonly SortedDictionary<SensorType, LinearAxis> _axes = new SortedDictionary<SensorType, LinearAxis>();
    private readonly Dictionary<SensorType, LineAnnotation> _annotations = new Dictionary<SensorType, LineAnnotation>();
    private UserOption _stackedAxes;
    private UserOption _showAxesLabels;
    private UserOption _timeAxisEnableZoom;
    private UserOption _yAxesEnableZoom;
    private DateTime _now;
    private float _dpiX;
    private float _dpiY;
    private double _dpiXScale = 1;
    private double _dpiYScale = 1;
    private Point _rightClickEnter;
    private bool _cancelContextMenu = false;

    public PlotPanel(PersistentSettings settings, UnitManager unitManager)
    {
        _settings = settings;
        _unitManager = unitManager;

        SetDpi();
        _model = CreatePlotModel();

        _plot = new PlotView { Dock = DockStyle.Fill, Model = _model, BackColor = Color.White, ContextMenuStrip = CreateMenu() };
        _plot.MouseDown += (sender, e) =>
        {
            if (e.Button == MouseButtons.Right)
            {
                _rightClickEnter = e.Location;
            }
        };
        _plot.MouseMove += (sender, e) =>
        {
            if (e.Button == MouseButtons.Right)
            {
                if (!_cancelContextMenu && e.Location.DistanceTo(_rightClickEnter) > 10.0f)
                {
                    _cancelContextMenu = true;
                }
            }
        };

        UpdateAxesPosition();

        SuspendLayout();
        Controls.Add(_plot);
        ResumeLayout(true);
    }

    public void SetCurrentSettings()
    {
        foreach (LinearAxis axis in _axes.Values)
        {
            _settings.SetValue("plotPanel.Min" + axis.Key, (float)axis.ActualMinimum);
            _settings.SetValue("plotPanel.Max" + axis.Key, (float)axis.ActualMaximum);
        }
        _settings.SetValue("plotPanel.MinTimeSpan", (float)_timeAxis.ActualMinimum);
        _settings.SetValue("plotPanel.MaxTimeSpan", (float)_timeAxis.ActualMaximum);
    }

    private ContextMenuStrip CreateMenu()
    {
        ContextMenuStrip menu = new ContextMenuStrip();
        menu.Opening += (sender, e) =>
        {
            if (_cancelContextMenu)
            {
                e.Cancel = true;
                _cancelContextMenu = false;
            }
        };

        ToolStripMenuItem stackedAxesMenuItem = new ToolStripMenuItem("Stacked Axes");
        _stackedAxes = new UserOption("stackedAxes", true, stackedAxesMenuItem, _settings);
        _stackedAxes.Changed += (sender, e) =>
        {
            UpdateAxesPosition();
            InvalidatePlot();
        };
        menu.Items.Add(stackedAxesMenuItem);

        ToolStripMenuItem showAxesLabelsMenuItem = new ToolStripMenuItem("Show Axes Labels");
        _showAxesLabels = new UserOption("showAxesLabels", true, showAxesLabelsMenuItem, _settings);
        _showAxesLabels.Changed += (sender, e) =>
        {
            if (_showAxesLabels.Value)
                _model.PlotMargins = new OxyThickness(double.NaN);
            else
                _model.PlotMargins = new OxyThickness(0);
        };
        menu.Items.Add(showAxesLabelsMenuItem);

        ToolStripMenuItem timeAxisMenuItem = new ToolStripMenuItem("Time Axis");
        ToolStripMenuItem[] timeAxisMenuItems =
        { new ToolStripMenuItem("Enable Zoom"),
            new ToolStripMenuItem("Auto", null, (s, e) => { TimeAxisZoom(0, double.NaN); }),
            new ToolStripMenuItem("5 min", null, (s, e) => { TimeAxisZoom(0, 5 * 60); }),
            new ToolStripMenuItem("10 min", null, (s, e) => { TimeAxisZoom(0, 10 * 60); }),
            new ToolStripMenuItem("20 min", null, (s, e) => { TimeAxisZoom(0, 20 * 60); }),
            new ToolStripMenuItem("30 min", null, (s, e) => { TimeAxisZoom(0, 30 * 60); }),
            new ToolStripMenuItem("45 min", null, (s, e) => { TimeAxisZoom(0, 45 * 60); }),
            new ToolStripMenuItem("1 h", null, (s, e) => { TimeAxisZoom(0, 60 * 60); }),
            new ToolStripMenuItem("1.5 h", null, (s, e) => { TimeAxisZoom(0, 1.5 * 60 * 60); }),
            new ToolStripMenuItem("2 h", null, (s, e) => { TimeAxisZoom(0, 2 * 60 * 60); }),
            new ToolStripMenuItem("3 h", null, (s, e) => { TimeAxisZoom(0, 3 * 60 * 60); }),
            new ToolStripMenuItem("6 h", null, (s, e) => { TimeAxisZoom(0, 6 * 60 * 60); }),
            new ToolStripMenuItem("12 h", null, (s, e) => { TimeAxisZoom(0, 12 * 60 * 60); }),
            new ToolStripMenuItem("24 h", null, (s, e) => { TimeAxisZoom(0, 24 * 60 * 60); }) };

        foreach (ToolStripItem mi in timeAxisMenuItems)
            timeAxisMenuItem.DropDownItems.Add(mi);
        menu.Items.Add(timeAxisMenuItem);

        _timeAxisEnableZoom = new UserOption("timeAxisEnableZoom", true, timeAxisMenuItems[0], _settings);
        _timeAxisEnableZoom.Changed += (sender, e) =>
        {
            _timeAxis.IsZoomEnabled = _timeAxisEnableZoom.Value;
        };

        ToolStripMenuItem yAxesMenuItem = new ToolStripMenuItem("Value Axes");
        ToolStripMenuItem[] yAxesMenuItems =
        { new ToolStripMenuItem("Enable Zoom"),
            new ToolStripMenuItem("Autoscale All", null, (s, e) => { AutoscaleAllYAxes(); }) };

        foreach (ToolStripItem mi in yAxesMenuItems)
            yAxesMenuItem.DropDownItems.Add(mi);
        menu.Items.Add(yAxesMenuItem);

        _yAxesEnableZoom = new UserOption("yAxesEnableZoom", true, yAxesMenuItems[0], _settings);
        _yAxesEnableZoom.Changed += (sender, e) =>
        {
            foreach (LinearAxis axis in _axes.Values)
                axis.IsZoomEnabled = _yAxesEnableZoom.Value;
        };

        return menu;
    }

    private PlotModel CreatePlotModel()
    {
        _timeAxis.Position = AxisPosition.Bottom;
        _timeAxis.MajorGridlineStyle = LineStyle.Solid;
        _timeAxis.MajorGridlineThickness = 1;
        _timeAxis.MajorGridlineColor = OxyColor.FromRgb(192, 192, 192);
        _timeAxis.MinorGridlineStyle = LineStyle.Solid;
        _timeAxis.MinorGridlineThickness = 1;
        _timeAxis.MinorGridlineColor = OxyColor.FromRgb(232, 232, 232);
        _timeAxis.StartPosition = 1;
        _timeAxis.EndPosition = 0;
        _timeAxis.MinimumPadding = 0;
        _timeAxis.MaximumPadding = 0;
        _timeAxis.AbsoluteMinimum = 0;
        _timeAxis.Minimum = 0;
        _timeAxis.AbsoluteMaximum = 24 * 60 * 60;
        _timeAxis.Zoom(
                       _settings.GetValue("plotPanel.MinTimeSpan", 0.0f),
                       _settings.GetValue("plotPanel.MaxTimeSpan", 10.0f * 60));
        _timeAxis.StringFormat = "h:mm";

        var units = new Dictionary<SensorType, string>
        {
            { SensorType.Voltage, "V" },
            { SensorType.Current, "A" },
            { SensorType.Clock, "MHz" },
            { SensorType.Temperature, "°C" },
            { SensorType.Load, "%" },
            { SensorType.Fan, "RPM" },
            { SensorType.Flow, "L/h" },
            { SensorType.Control, "%" },
            { SensorType.Level, "%" },
            { SensorType.Factor, "1" },
            { SensorType.Power, "W" },
            { SensorType.Data, "GB" },
            { SensorType.Frequency, "Hz" },
            { SensorType.Energy, "mWh" },
            { SensorType.Noise, "dBA" }
        };

        foreach (SensorType type in Enum.GetValues(typeof(SensorType)))
        {
            string typeName = type.ToString();
            var axis = new LinearAxis
            {
                Position = AxisPosition.Left,
                MajorGridlineStyle = LineStyle.Solid,
                MajorGridlineThickness = 1,
                MajorGridlineColor = _timeAxis.MajorGridlineColor,
                MinorGridlineStyle = LineStyle.Solid,
                MinorGridlineThickness = 1,
                MinorGridlineColor = _timeAxis.MinorGridlineColor,
                AxislineStyle = LineStyle.Solid,
                Title = typeName,
                Key = typeName,
            };

            var annotation = new LineAnnotation
            {
                Type = LineAnnotationType.Horizontal,
                ClipByXAxis = false,
                ClipByYAxis = false,
                LineStyle = LineStyle.Solid,
                Color = OxyColors.Black,
                YAxisKey = typeName,
                StrokeThickness = 2,
            };

            axis.AxisChanged += (sender, args) => annotation.Y = axis.ActualMinimum;
            axis.TransformChanged += (sender, args) => annotation.Y = axis.ActualMinimum;

            axis.Zoom(_settings.GetValue("plotPanel.Min" + axis.Key, float.NaN), _settings.GetValue("plotPanel.Max" + axis.Key, float.NaN));

            if (units.ContainsKey(type))
                axis.Unit = units[type];

            _axes.Add(type, axis);
            _annotations.Add(type, annotation);
        }

        var model = new ScaledPlotModel(_dpiXScale, _dpiYScale);
        model.Axes.Add(_timeAxis);
        foreach (LinearAxis axis in _axes.Values)
            model.Axes.Add(axis);
        model.IsLegendVisible = false;

        return model;
    }

    private void SetDpi()
    {
        // https://msdn.microsoft.com/en-us/library/windows/desktop/dn469266(v=vs.85).aspx
        const int defaultDpi = 96;
        Graphics g = CreateGraphics();

        try
        {
            _dpiX = g.DpiX;
            _dpiY = g.DpiY;
        }
        finally
        {
            g.Dispose();
        }

        if (_dpiX > 0)
            _dpiXScale = _dpiX / defaultDpi;
        if (_dpiY > 0)
            _dpiYScale = _dpiY / defaultDpi;
    }

    public void SetSensors(List<ISensor> sensors, IDictionary<ISensor, Color> colors)
    {
        _model.Series.Clear();
        var types = new HashSet<SensorType>();


        DataPoint CreateDataPoint(SensorType type, SensorValue value)
        {
            float displayedValue;

            if (type == SensorType.Temperature && _unitManager.TemperatureUnit == TemperatureUnit.Fahrenheit)
            {
                displayedValue = UnitManager.CelsiusToFahrenheit(value.Value).Value;
            }
            else
            {
                displayedValue = value.Value;
            }

            return new DataPoint((_now - value.Time).TotalSeconds, displayedValue);
        }


        foreach (ISensor sensor in sensors)
        {
            var series = new LineSeries
            {
                ItemsSource = sensor.Values.Select(value => CreateDataPoint(sensor.SensorType, value)),
                Color = colors[sensor].ToOxyColor(),
                StrokeThickness = 1,
                YAxisKey = _axes[sensor.SensorType].Key,
                Title = sensor.Hardware.Name + " " + sensor.Name
            };

            _model.Series.Add(series);

            types.Add(sensor.SensorType);
        }

        foreach (KeyValuePair<SensorType, LinearAxis> pair in _axes.Reverse())
        {
            LinearAxis axis = pair.Value;
            SensorType type = pair.Key;
            axis.IsAxisVisible = types.Contains(type);
        }

        UpdateAxesPosition();
        InvalidatePlot();
    }

    private void UpdateAxesPosition()
    {
        if (_stackedAxes.Value)
        {
            int count = _axes.Values.Count(axis => axis.IsAxisVisible);
            double start = 0.0;
            foreach (KeyValuePair<SensorType, LinearAxis> pair in _axes.Reverse())
            {
                LinearAxis axis = pair.Value;
                axis.StartPosition = start;
                double delta = axis.IsAxisVisible ? 1.0 / count : 0;
                start += delta;
                axis.EndPosition = start;
                axis.PositionTier = 0;
                axis.MajorGridlineStyle = LineStyle.Solid;
                axis.MinorGridlineStyle = LineStyle.Solid;
                LineAnnotation annotation = _annotations[pair.Key];
                annotation.Y = axis.ActualMinimum;
                if (!_model.Annotations.Contains(annotation)) 
                    _model.Annotations.Add(annotation);
            }
        }
        else
        {
            int tier = 0;

            foreach (KeyValuePair<SensorType, LinearAxis> pair in _axes.Reverse())
            {
                LinearAxis axis = pair.Value;

                if (axis.IsAxisVisible)
                {
                    axis.StartPosition = 0;
                    axis.EndPosition = 1;
                    axis.PositionTier = tier;
                    tier++;
                }
                else
                {
                    axis.StartPosition = 0;
                    axis.EndPosition = 0;
                    axis.PositionTier = 0;
                }
                axis.MajorGridlineStyle = LineStyle.None;
                axis.MinorGridlineStyle = LineStyle.None;
                LineAnnotation annotation = _annotations[pair.Key];
                if (_model.Annotations.Contains(annotation)) 
                    _model.Annotations.Remove(_annotations[pair.Key]);
            }
        }
    }

    public void InvalidatePlot()
    {
        _now = DateTime.UtcNow;

        if (_axes != null)
        {
            foreach (KeyValuePair<SensorType, LinearAxis> pair in _axes)
            {
                LinearAxis axis = pair.Value;
                SensorType type = pair.Key;
                if (type == SensorType.Temperature)
                    axis.Unit = _unitManager.TemperatureUnit == TemperatureUnit.Celsius ? "°C" : "°F";
                    
                if (!_stackedAxes.Value) 
                    continue;

                var annotation = _annotations[pair.Key];
                annotation.Y = axis.ActualMaximum;
            }
        }

        _plot?.InvalidatePlot(true);
    }

    public void TimeAxisZoom(double min, double max)
    {
        bool timeAxisIsZoomEnabled = _timeAxis.IsZoomEnabled;

        _timeAxis.IsZoomEnabled = true;
        _timeAxis.Zoom(min, max);
        InvalidatePlot();
        _timeAxis.IsZoomEnabled = timeAxisIsZoomEnabled;
    }

    public void AutoscaleAllYAxes()
    {
        foreach (LinearAxis axis in _axes.Values)
            axis.Zoom(double.NaN, double.NaN);
    }
}
```

`LibreHardwareMonitor/UI/PortForm.Designer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.UI
{
    partial class PortForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(PortForm));
            this.portOKButton = new System.Windows.Forms.Button();
            this.portCancelButton = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();
            this.webServerLinkLabel = new System.Windows.Forms.LinkLabel();
            this.portNumericUpDn = new System.Windows.Forms.NumericUpDown();
            this.label5 = new System.Windows.Forms.Label();
            ((System.ComponentModel.ISupportInitialize)(this.portNumericUpDn)).BeginInit();
            this.SuspendLayout();
            // 
            // portOKButton
            // 
            this.portOKButton.Location = new System.Drawing.Point(244, 137);
            this.portOKButton.Name = "portOKButton";
            this.portOKButton.Size = new System.Drawing.Size(75, 23);
            this.portOKButton.TabIndex = 0;
            this.portOKButton.Text = "OK";
            this.portOKButton.UseVisualStyleBackColor = true;
            this.portOKButton.Click += new System.EventHandler(this.PortOKButton_Click);
            // 
            // portCancelButton
            // 
            this.portCancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.portCancelButton.Location = new System.Drawing.Point(162, 137);
            this.portCancelButton.Name = "portCancelButton";
            this.portCancelButton.Size = new System.Drawing.Size(75, 23);
            this.portCancelButton.TabIndex = 1;
            this.portCancelButton.Text = "Cancel";
            this.portCancelButton.UseVisualStyleBackColor = true;
            this.portCancelButton.Click += new System.EventHandler(this.PortCancelButton_Click);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(13, 106);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(377, 13);
            this.label1.TabIndex = 3;
            this.label1.Text = "Note: You will need to open the port in firewall settings of the operating system" +
    ".";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(13, 9);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(193, 13);
            this.label2.TabIndex = 4;
            this.label2.Text = "Port number for  the remote web server:";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(13, 39);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(443, 13);
            this.label3.TabIndex = 5;
            this.label3.Text = "If the web server is running then it will need to be restarted for the port chang" +
    "e to take effect.";
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(13, 62);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(262, 13);
            this.label4.TabIndex = 6;
            this.label4.Text = "The web server will be accessible from the browser at ";
            // 
            // webServerLinkLabel
            // 
            this.webServerLinkLabel.AutoSize = true;
            this.webServerLinkLabel.Location = new System.Drawing.Point(269, 62);
            this.webServerLinkLabel.Name = "webServerLinkLabel";
            this.webServerLinkLabel.Size = new System.Drawing.Size(55, 13);
            this.webServerLinkLabel.TabIndex = 7;
            this.webServerLinkLabel.TabStop = true;
            this.webServerLinkLabel.Text = "linkLabel1";
            this.webServerLinkLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.WebServerLinkLabel_LinkClicked);
            // 
            // portNumericUpDn
            // 
            this.portNumericUpDn.Location = new System.Drawing.Point(208, 7);
            this.portNumericUpDn.Maximum = new decimal(new int[] {
            20000,
            0,
            0,
            0});
            this.portNumericUpDn.Minimum = new decimal(new int[] {
            8080,
            0,
            0,
            0});
            this.portNumericUpDn.Name = "portNumericUpDn";
            this.portNumericUpDn.Size = new System.Drawing.Size(75, 20);
            this.portNumericUpDn.TabIndex = 8;
            this.portNumericUpDn.Value = new decimal(new int[] {
            8080,
            0,
            0,
            0});
            this.portNumericUpDn.ValueChanged += new System.EventHandler(this.PortNumericUpDn_ValueChanged);
            this.portNumericUpDn.KeyUp += new System.Windows.Forms.KeyEventHandler(this.PortNumericUpDn_KeyUp);
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(13, 84);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(304, 13);
            this.label5.TabIndex = 9;
            this.label5.Text = "You will have to start the server by clicking Run from the menu.";
            // 
            // PortForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.portCancelButton;
            this.ClientSize = new System.Drawing.Size(466, 170);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.portNumericUpDn);
            this.Controls.Add(this.webServerLinkLabel);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.portCancelButton);
            this.Controls.Add(this.portOKButton);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "PortForm";
            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Set Port";
            this.Load += new System.EventHandler(this.PortForm_Load);
            ((System.ComponentModel.ISupportInitialize)(this.portNumericUpDn)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button portOKButton;
        private System.Windows.Forms.Button portCancelButton;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.LinkLabel webServerLinkLabel;
        private System.Windows.Forms.NumericUpDown portNumericUpDn;
        private System.Windows.Forms.Label label5;
    }
}

```

`LibreHardwareMonitor/UI/PortForm.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Windows.Forms;
using System.Net;
using System.Net.Sockets;
using System.Diagnostics;

namespace LibreHardwareMonitor.UI;

public partial class PortForm : Form
{
    private readonly MainForm _parent;
    private readonly string _localIP;
    public PortForm(MainForm m)
    {
        InitializeComponent();
        _parent = m;
        _localIP = GetLocalIP();
    }

    private void PortTextBox_TextChanged(object sender, EventArgs e)
    {

    }

    private string GetLocalIP()
    {
        IPHostEntry host;
        string localIP = "?";
        host = Dns.GetHostEntry(Dns.GetHostName());
        foreach (IPAddress ip in host.AddressList)
        {
            if (ip.AddressFamily == AddressFamily.InterNetwork)
                localIP = ip.ToString();
        }
        return localIP;
    }

    private void PortNumericUpDn_ValueChanged(object sender, EventArgs e)
    {
        string url = "http://" + _localIP + ":" + portNumericUpDn.Value + "/";
        webServerLinkLabel.Text = url;
        webServerLinkLabel.Links.Remove(webServerLinkLabel.Links[0]);
        webServerLinkLabel.Links.Add(0, webServerLinkLabel.Text.Length, url);
    }

    private void PortOKButton_Click(object sender, EventArgs e)
    {
        _parent.Server.ListenerPort = (int)portNumericUpDn.Value;
        Close();
    }

    private void PortCancelButton_Click(object sender, EventArgs e)
    {
        Close();
    }

    private void PortForm_Load(object sender, EventArgs e)
    {
        portNumericUpDn.Value = _parent.Server.ListenerPort;
        PortNumericUpDn_ValueChanged(null, null);
    }

    private void WebServerLinkLabel_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
    {
        try
        {
            Process.Start(new ProcessStartInfo(e.Link.LinkData.ToString()));
        }
        catch { }
    }

    private void PortNumericUpDn_KeyUp(object sender, KeyEventArgs e)
    {
        PortNumericUpDn_ValueChanged(null, null);
    }
}
```

`LibreHardwareMonitor/UI/PortForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAMAEBAAAAEAIABoBAAANgAAACAgAAABACAAqBAAAJ4EAAAwMAAAAQAgAKglAABGFQAAKAAAABAA
        AAAgAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEU8OykuDgdIIxQSURwdHU8ZGhpPFhYWTxQU
        FE8SEhJPDxAPTw0KCk8KBQRPCAQDTwcDAU8HAQBPBgQEUQUFBTxLVVb/L215/zdXXP89Ozv/ODc3/zM0
        M/8vLy//Kioq/yYlJf8iJif/Gycp/xggI/8UHiD/Eh4g/w4SE/8GBARRQWRr/xGXtP8yUln/NDIx/y4u
        Lf8qKir/KSgo/ycnJ/8lJCP/Iikq/xs4Pf8aOD7/GzpB/xo4Pf8SGhv/BwMDT01aXP46Ulj+Pzc0/kdH
        R/5MTU3+Q0ND/jw8PP43Nzf+Ly8v/igoKP4lKCn+Iico/hwiI/4cHyD/FBMU/wYHBk9XVVX+Rj8+/klJ
        Sf6ioqL+rq+u/p+fn/6YmJj+j4+P/oSEhP56enr+dXJy/mNgYP4iHx7+Gxka/xUVFf8HBwdPW1pa/kVF
        RP5YWFj+rq6u/r6+vv6wsK/+qamp/qCgoP6UlJT+iYmJ/oGBgf5xcXH+JCQk/hsbG/8WFhb/BwcHT15e
        Xv5ISEj+Wlpa/rW1tf7Gxsb+tra2/qysq/6hoaL+lpaW/oyMjP6EhIT+cnJy/iQkJP4cHBz/GBgY/wcH
        B09jY2P+TUxM/l5eXv7AwMD+0dHR/r6+vv6vr6/+o6Ok/pmYmf6Rk5P+iouK/nd4d/4lJSX+HR0d/xkZ
        Gf8HBwdPZ2dn/lBQUP5iYmL+ysrK/tzc3P7Hxsf+tbS1/qmpqf6fn5/+mJiY/o6Pj/57e3z+JSUm/h4e
        Hv8aGhr/CAgIT2tra/5TU1P+ZGRk/tLS0v7j5eP+zMzM/ry8vP6wsLD+pqam/pubm/6TkZH+f39//igo
        KP4fHx7/HBwc/wkJCk9ubm7+VlVW/mZlZv7X1tf+6Ojo/tPS0/7Hx8f+urq6/qurq/6dnp7+lJSU/oGB
        gP4sLCz+Hx4e/x4dHP8LCwtPb29v/lZWVv5nZ2j+4eHh/vLx8v7Z2dn+zc3N/sDAwP6wsrL+pKOk/pmZ
        mf6Ghob+MDAw/h8gH/8eHx//DQsNT29vb/5YWFj+WVpa/sHBwf7V1dX+wMC//rW1tP6pqan+m5ub/o6P
        jv6FhYX+cXFx/i4qKv4gLC7/Hiot/w4JB09vb3D+Wlla/lJSUf5VVVX+YGBg/ltbWv5VVVP+Tk5O/kdH
        R/5BQUH+Ozs6/jAvL/4oKCj+Izk9/x8tL/8QCQhRbm5u/lVVVf5SUlL+S0tL/kRERP5BQUH+PT09/jk5
        Of41NTX+MzIy/i8vLv4sKSj+Jy4v/h9DTP8iLjH/Ew0KSHp7ev5qamr+ZWVl/mFhYv5cXFz+WFhY/lNS
        U/5NTU3+R0ZH/kJCQv49PDz+NzU1/jAxMf4qMTL/Jigp/x4cHCn//wAAAAEAAAABAAAAAQAAAAEAAAAB
        AAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAKAAAACAAAABAAAAAAQAgAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMBBwcHAwYGBgQGBgYEBgYGBAYG
        BgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYG
        BgQGBgYEBgYGBAYGBgQGBgYEBwcHAwUFBQIAAAAAAAAAAAAAAAAAAAAAAAAAAAoKCgkMDAwgDQ0NKg0N
        DSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0N
        DSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoMDAwlCgoKEQUFBQIAAAAAAAAAAAAAAAAAAAAACAgIFAoK
        CkcMDAxbDAwMXAwMDFwMDAxcDAwMXAwNDFwNDQ1cDQ0NXA0NDVwNDQ1cDQ0NXA0NDVwNDQ5cDg4OXA4O
        DlwODg5cDg4OXA4ODlwODg5cDg4OXA4ODlwODg5cDg4OWw0NDVIMDAwlBwcHAwAAAAAAAAAAAAAAAGFh
        YY9ZWFjFUVBP0kpJSdhIR0fYQkJC2D0+Ptg5OTnZODc22TMyM9kuLi/ZKysr2SYmJtkjIyPZICAf2Rsb
        G9kXFxjZExMT2Q8ODtkNDAzZDQwM2A0MDNgNDAzYDQ0N2A0NDdgODQ27Dg4OWw0NDSoGBgYEAAAAAAAA
        AAAAAAAAYmFhvzxCQ/82Uln/NlJZ/zdPVP89PDz/PDw8/zo6Ov85OTn/ODg4/zY2Nv80NDT/NDQ0/zIy
        Mv8xMTD/Ly4w/yw1OP8qNjj/JzQ1/yYyNP8kMDL/Ii4w/x8sLv8fKy3/HyIi/w0NDdgODg5cDQ0NKgYG
        BgQAAAAAAAAAAAAAAABjY2K/OFRa/xqXsv8bk6v/M11l/z49Pf89PT3/Ozs7/zo6Of83Nzj/NTY1/zQ0
        NP8zMzP/MTEw/y8vL/8uLi7/KzQ2/yk1Nv8nMjT/JjAz/yQvMf8jLjD/ISwu/x8rLf8fISL/DQ0N2A4O
        DlwNDQ0qBgYGBAAAAAAAAAAAAAAAAGZkZL86V13/GpKs/zJkbv9BPz//Pj8+/zw8PP85OTn/Njc2/zQ0
        Nf8zMjP/MjIy/zAwMP8vLy//Li4u/y0sLP8qKSn/I0hQ/yJHUP8hRk//IEZO/yBGTv8fRU3/HztB/yAf
        H/8NDQ3YDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAaWdovz5WW/83YWr/RkND/0FAQP89PT3/ODc3/zIy
        Mf8uLi7/LCws/ysrK/8pKSn/Kioq/ygoKP8nJyf/JSUl/yUkJP8kIyP/IyEh/yMiIv8kIiL/JCMj/yQj
        I/8iISH/ISAg/w0NDdgODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAABqamq/SUhI/0hHR/9GRkb/QUFB/0ZH
        Rv9/f4D/gICA/3h4eP9xcXH/a2tr/2RkZP9dXV7/V1dX/09PT/9ISEj/Q0NC/0BAQP9AQED/Ozs7/yYm
        Jv8jIyP/JCQk/yMjI/8jIyH/DQ0N2A4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAG5ubr9LS0v/SkpL/0hI
        SP9BQUH/i4uL/6ysrP+hoqH/n5+e/52bnf+YmJj/lJSU/5CQj/+Li4v/hYaF/4CAgP97e3r/dXR1/3Fx
        cf9ra2v/Ozs7/yEhIv8kJCT/JCQk/yQkI/8NDQ3YDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAcHBwv01N
        Tf9MTU3/SUpK/0BAP/+Wlpj/q6ur/6inp/+kpKT/oKGg/52cnP+YmJj/k5OT/46Ojv+IiYj/g4OC/319
        ff93d3f/cXFx/3Fxcf8/Pz//ISEh/yQkJP8lJSX/JSQk/w0NDdkODg5cDQ0NKgYGBgQAAAAAAAAAAAAA
        AABycnO/T05P/05PT/9MTEz/QUFB/5ubmv+ysrL/rq6u/6urq/+np6f/oqKi/52dnf+ZmZn/k5OT/42O
        jv+IiIf/gYGB/3x7fP90dXT/cXFx/z8/P/8hISH/JCQl/yUlJf8lJib/DQ0N2Q4ODlwNDQ0qBgYGBAAA
        AAAAAAAAAAAAAHR1db9RUVH/UFBQ/01NTf9CQkL/np6e/7i4uP+0s7T/sbGx/62trf+oqKj/o6Oj/52d
        nf+Yl5f/kZKR/4yMi/+FhYX/fn9//3h4eP9zc3P/Pz8//yIiIv8lJSX/JiYm/yYmJv8NDQ3ZDg4OXA0N
        DSoGBgYEAAAAAAAAAAAAAAAAdnZ2v1RUVP9TU1P/T09P/0VFRf+kpKT/v7+//7u7u/+2trb/sbGx/6mp
        qf+jo6P/nZ2d/5eXl/+QkZH/jo2N/4mJif+CgoL/fHx8/3d3d/9AQED/IiIi/yYmJv8nJyf/Jycn/w0N
        DdkODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAAB4eHi/V1dW/1VVVf9QUFD/RkZG/6moqf/Gxsb/wcHB/7y8
        vP+2trb/q6ys/6Wlpf+fn5//mZiY/5WUlf+RkpL/jI2M/4WFhf9/fn//enp6/0FBQf8iIiP/JiYm/ygn
        KP8oJyf/DQ0N2Q4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAHp6er9YWVn/V1dX/1JSU/9ISEj/ra2t/8zM
        zP/Gxsb/wcHB/7u7u/+wsLD/qamp/6Ojo/+cnZ3/lpaW/5OTk/+Pj47/iIiI/4CBgP98fH3/QkJC/yMj
        I/8nJyf/KCgo/ygoKP8ODg7ZDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAfXx9v1tbW/9ZWVn/VFVV/0hJ
        Sf+xsbH/0tLS/8vLy//FxcX/v7++/7Ozs/+qqqr/pKWk/6Cfn/+ampr/mpia/5GRkf+Li4r/goOD/35+
        fv9CQ0P/IyQk/ycnJ/8pKSn/KSkp/xAQENkODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAAB+fn6/XV1d/1tb
        W/9WVlb/S0lJ/7Oysv/W1tb/z8/P/8nJyf/CwsL/tbW1/66trf+np6f/oqKi/5ycnP+ZmJn/k5OT/4yM
        jP+FhYX/f39//0ZFRv8kJCT/KCgo/ykpKf8pKSn/EhIS2Q4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAIGB
        gb9eXl7/XFxc/1dYV/9KSkr/tLS0/9rb2v/S0tL/zczM/8XFxf+/v7//uLi4/7Gxsf+rq6r/o6Oj/5yc
        nP+UlZT/jY2N/4aFhv+AgID/SUlI/yMjI/8oKCj/KSkp/ykpKf8UFBTZDg4OXA0NDSoGBgYEAAAAAAAA
        AAAAAAAAg4ODv19fX/9eXl7/WVhZ/0tLS/+0tLT/3d3d/9TU1P/Ozs7/x8bH/8DAwP+5ubn/srKy/6ur
        q/+kpKT/nJyc/5WVlv+Ojo7/h4eH/4GBgf9NTU3/IyQk/ygpKP8qKSn/KSkp/xgYGNkODg5cDQ0NKgYG
        BgQAAAAAAAAAAAAAAACFhYW/YGBf/15eXv9aWln/TU1N/7a2tv/e3t7/1dXV/87Pz//Hx8f/wcHB/7m5
        uv+ysrP/rKyr/6SkpP+dnZ3/lZWW/46Ojv+Hh4f/gYGB/1BQUP8kJCT/KSkp/ykpKf8oKCj/GhkZ2Q4O
        DlwNDQ0qBgYGBAAAAAAAAAAAAAAAAIiGhr9gYGD/Xl5e/1paWv9PT0//t7e3/93d3f/U1NT/zs7O/8fH
        x//AwMD/ubm5/7Kysv+rq6v/o6Ok/5ycnP+VlZX/jo6N/4aGhv+BgYH/U1NT/yYmJv8qKir/Kisq/ygo
        Kf8bHBzYDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAioqKv19fX/9eXl7/Wlta/1FRUf+srKz/4uLi/9LS
        0v/Mzcz/xcXG/7+/v/+4ubj/srKx/6urq/+kpKT/nZ2d/5WVlf+Njo7/h4aH/4GBgf9TUlL/KSkp/yws
        LP8qLzH/Jy4v/x4eHtgNDQ1cDQ0NKgYGBgQAAAAAAAAAAAAAAACMi4y/Xl5e/11dXf9aWlr/VVVV/1xc
        XP+qqqr/sbGx/66urv+qqqr/pKSj/52dnf+VlZX/jo6O/4eHh/+Af3//d3l3/3BwcP9paWn/XFxc/zMz
        M/8sLCz/LS0t/yswMf8nLS7/ICAg2A0NDVwNDQ0qBgYGBAAAAAAAAAAAAAAAAI6Ojr9cXFz/XFxc/1pa
        Wv9WV1f/UFFQ/0xMS/9HR0f/RERE/0BBQP8+Pj7/PDw8/zo7Ov84ODj/ODg4/zU1Nf8zMzP/MTEx/zAw
        MP8uLi//Li4u/y4tL/8qPUD/KDk+/yU4O/8jIiLYDQ0NXA0NDSoGBgYEAAAAAAAAAAAAAAAAkZGRv1pb
        W/9bW1r/WFlY/1ZWVv9UVFT/UFBQ/05OTv9MTEz/SklK/0dHR/9FRUX/QkJC/0BAQP8+Pj7/PDw8/zo6
        Ov83ODf/NTU1/zIyMv8xMTH/Ly4u/yk7P/8oO0D/JTpA/yUkJNgNDQ1bDQ0NKgcHBwQAAAAAAAAAAAAA
        AACTk5O/WFhY/1lZWf9YV1j/VVVV/1JSUv9QUFD/Tk5O/01MTf9KSkr/SEhI/0ZGRv9DQkP/QEFA/z8/
        P/89PT3/Ozs6/zg4OP82NTX/MzMz/zExMf8vLi3/IVtn/yovMf8nLi//KCgo0gwMDEcMDAwgBwcHAwAA
        AAAAAAAAAAAAAJKTkr9VVFX/VFVV/1RUVP9SUVH/T09P/01NTv9MS0z/SkpK/0hJSP9HR0f/REVE/0FB
        Qf8/Pz//Pj4+/zs7PP85Ojn/Nzc3/zQ0NP8xMTH/LzAw/y4uLv8tLCz/KS8w/yUtLv8tLS3FCgoKFAoK
        CgkDAwMBAAAAAAAAAAAAAAAAl5aXj5KSkr+QkJC/jYuLv4eHh7+EhIS/gICAv3x8fL93d3e/dHR0v3Bw
        cL9samy/ZmZmv2NjY79fX1+/W1tbv1VVVb9SUlK/Tk5Ov0pKSr9ERES/QUFBvz09Pb85OTm/MzMzvzEx
        MY8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////////gAAAH4AAAB+AA
        AAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AA
        AAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB////////////////ygAAAAwAAAAYAAAAAEA
        IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAACCAgIBwkJCQwICAgOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcH
        Bw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcH
        Bw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOCAgIDgkJCQwICAgHAAAAAgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAICAgHCwsLGQ0NDSwNDQ0yDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0N
        DTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0N
        DTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMg0NDSwLCwsaCAgIBwAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJCQkMDQ0NLA0NDUwODg5XDg4OWQ4ODlkODg5ZDg4OWQ4O
        DlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4O
        DlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OVw0N
        DUwNDQ0sCQkJDAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFBQUOCgoKMgsLC1cLCwtkCwsLZgsL
        C2YLCwtmCwsLZgwMDGYMDAxmDAwMZgwMDGYMDAxmDAwMZgwMDGYMDAxmDAwMZg0NDWYNDQ1mDQ0NZg0N
        DWYNDQ1mDQ0NZg0NDWYNDQ1mDg4OZg4ODmYODg5mDg4OZg4ODmYODg5mDg4OZg4ODmYODg5mDg4OZg4O
        DmYODg5mDg4OZA4ODlcNDQ0yCAgIDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGJiYv9cXFz/Wlpa/1VV
        V/9TU1L/UVFR/05OTv9LSkv/R0dH/0NDQ/9BQUH/Pz4//zw8PP86OTn/NTU1/zIyMv8wMDD/LS0u/yoq
        Kv8mJib/JCMk/yEhIf8eHh7/Gxsc/xkZGf8UFBT/ERER/w8PD/8ODg7/Dg4O/w4ODv8ODg7/Dg4O/w4O
        Dv8ODg7/Dg4O/w4ODv8PDw//Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGJi
        Yf8+PDz/Pzw7/0A7Ov9AOzr/Pzo5/z06Ov89Ojr/Ozs7/zo7Ov87Ojv/Ojo6/zk5Of84ODj/Nzc3/zY2
        Nf81NTT/MzMz/zIyMv8xMTH/MTIx/zAwMP8wMDD/Ly4u/y4tLf8sKiv/Kigo/yknJ/8oJiX/JiQk/yUj
        I/8kIiH/IiEg/yAeHv8gHh3/IB0d/x8eHv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAGNjY/9BPj3/Gpiz/xuWsP8alrD/Gpey/yKClv8+PT3/PT09/zw8PP87Ozv/Ojo6/zk5
        Of84ODj/Nzc3/zY2Nv80NDT/MzMz/zMyMv8yMTH/MDEw/y8vL/8vLy//Li4t/yJWYf8hVF//IVRf/x9T
        Xf8gU13/H1Nc/x9RXP8eUFv/HlFb/x1QWv8cT1n/HFBb/x8eHv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAGRkZP9CPTz/GpWv/xySq/8blK3/JH+S/0A8O/8/Pj7/Pj0+/z08
        PP87Ozv/Ojo6/zk5Of84ODj/Njc3/zU1Nf80NDT/MzMz/zIyMv8xMTH/MDAv/y8vL/8uLi7/LS0s/ywq
        Kv8tKSj/KiYm/yklJf8nJCP/KCIi/yYiIf8lICD/JB8e/yMeHP8iHRz/Hx0d/x8eH/8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGVlZf9GQUD/Gpaw/xuUrf8kgJP/Qj49/0A/
        P/8/Pj//Pj4+/zw8PP86Ojr/OTk5/zc3N/82NTb/NDQ0/zMzM/8yMjL/MTEx/zAwMP8vLzD/Ly8v/y4u
        Lv8tLS3/LCws/ysrKv8gVV//H1Nd/x9UXf8gU13/H1Nc/x9RXP8fUVz/HlFb/x5QW/8dUFv/Hx4f/x8f
        IP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGZmZv9GQkL/GZex/yWB
        k/9GQUH/QkFB/0FBQP8/Pz//PT09/zo7Ov84ODj/NTY1/zMzM/8yMjL/MTEx/zAwMP8vLy//Ly8v/y4u
        Lv8uLi7/LS0t/ysrK/8qKiv/KSkp/ygnJ/8nJib/JiQk/yYjJP8lIyP/JSIj/yUjI/8kIiL/JCIi/yMh
        Iv8iISD/IR8g/x8fH/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGho
        aP9IRUX/JIOY/0dDQv9HRUX/Q0ND/0FBQP8/Pz7/Ozo7/zY2Nv8xMTH/Li4u/ywsLf8tLS3/LCws/ysr
        K/8pKin/KSkp/ygoKP8oKCj/Jycn/ycmJv8lJSX/JSQl/yQkJP8jJCP/IyIj/yIiIv8iIyL/IyMj/yQj
        JP8kJCT/IyMk/yMjI/8jIyP/IiIh/yAgIP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAGlqav9IR0f/SUdH/0lHR/9HR0b/RERF/0FBQf88PDz/Pj8//317ff91dXX/cHBw/2tr
        a/9lZGX/YF9f/1paWv9VVVb/UVFR/0xMTP9HR0f/QUFB/z48PP83ODf/MzMz/zAwMP8wMDD/Ly8w/zAw
        MP8xMDH/Jycn/yEhIv8jIyP/JCQk/yQkJP8jIyT/IyIi/yEhIf8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAG1ra/9KSkr/SkpK/0lJSf9ISEj/RkVF/0BAQP9CQkL/ycnJ/6ur
        q/+fn57/np6e/5ycnP+ampr/l5eX/5SUlP+SkpH/j4+P/4yMjP+Iior/hoeG/4ODg/+AgID/fHx8/3h4
        eP90dHP/cXFx/3Jycv9lZWX/Tk9O/ycnJ/8iIiL/IyQj/yQkJP8jIyP/IyMj/yMhI/8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAG5ubf9LS0z/S0xL/0tLS/9JSUn/RkZG/0A/
        P/+Mi4z/s7Oz/6Ojo/+ioqL/oKCg/56env+cnJz/mZqZ/5eWl/+UlJT/kJGR/46Ojv+Li4v/h4eH/4OD
        g/+Af4D/fHx8/3h4eP91dHT/cHBw/29vb/9wcHD/ZWVl/zAwMP8iIiL/IyMj/yQkJP8kJCT/JCMk/yMk
        I/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHBwb/9NTU3/TU1N/0xM
        TP9KSkr/R0dH/z8+P/+Ojo7/q6ur/6mpqf+np6b/paSk/6Kiov+goKD/nZ6e/5ubm/+YmJj/lZSU/5GR
        kf+Ojo7/ioqL/4eHh/+Dg4P/f39//3x8fP93d3f/c3Nz/29vb/9vb2//cnJy/y8vL/8gISD/IyMj/yUk
        JP8kJCT/JCQk/yQkJP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHFx
        cf9OTk7/Tk5P/01NTf9MTEz/SEhI/0BAQP+QkJD/sLCv/62trf+srKv/qamp/6enp/+kpKX/oaKh/5+f
        n/+cnJz/mJiY/5WVlf+RkZL/jo6O/4qKiv+Ghob/goKC/35+fv96env/dnZ2/3Fycf9vb2//cnJy/y8u
        Lv8hICH/IyMj/yQkJf8lJSX/JCQl/yUlJP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAHNzc/9PT0//T09P/09PT/9NTUz/SUlJ/0FAQf+SkpL/tbS0/7Gxsf+vr7D/rq6u/6ur
        q/+pqan/pqWl/6Kiov+fn5//nJyc/5iZmP+UlZX/kZGR/42Njf+JiYn/hYWF/4GBgf99fX3/eXl5/3R0
        dP9wcHD/cnJy/y4uLv8hISD/JCQk/yUlJf8mJSb/JiUl/yUlJf8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAHR0dP9RUVH/UVBR/09PT/9OTk7/S0pK/0JCQv+VlZX/uLi4/7a1
        tf+zs7P/sbGx/6+vr/+tra3/qaqq/6ampv+ioqP/n5+f/5ycnP+YmJj/lJSU/5CQj/+MjIz/iIiI/4OD
        g/9/f3//e3t7/3d3dv9ycnL/cnJy/y4vL/8hISH/JCQk/yYmJf8mJib/JiYl/yYlJf8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHV1df9TU1T/U1NT/1BRUf9PTk7/TExM/0JC
        Qv+Xl5f/vr6+/7q6uv+3uLf/tbW1/7Kysv+wsLD/rq2t/6uqrP+mp6b/oqKi/5+fn/+bm5v/l5aX/5KS
        kv+Oj47/i4qK/4aGhv+BgoH/fX5+/3l5ef90dHT/c3Nz/y8vL/8jISP/JCQk/yYmJv8nJif/JiYm/yYm
        Jv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHZ3dv9VVVX/VVVV/1NS
        Uv9QUFD/TU1N/0RERP+ampr/wsLC/76/v/+8vLz/ubm6/7a2t/+zs7P/ra2t/6ampv+io6P/np6f/5ub
        mv+Wl5f/k5OS/46Ojv+Njo3/jY2N/4mJiP+Eg4P/f39//3t7e/92d3b/dXV0/y8vL/8hISH/JCUl/yYm
        Jv8nJyf/JyYm/yYnJv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHh3
        eP9WVlb/VlZW/1RUVP9RUVH/Tk5O/0VERP+cnJz/xsbG/8LCw//AwMD/vb69/7q7uv+3t7f/sLCw/6mp
        qf+mpqb/oqGi/52dnf+ZmZn/lZWV/5SUlP+Tk5P/j4+P/4uLi/+Ghob/gYGB/319ff94eHj/dnd2/y8v
        L/8hIiP/JSUl/ycnJv8oJyj/KCcn/ycnJ/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAHl5ef9YWFj/V1dX/1ZWVv9SU1P/T09P/0ZGRv+fn5//ysvK/8bGxv/DxMT/wcHB/729
        vv+6urr/s7Oz/6ysrP+oqKj/pKWk/6CgoP+bm5v/l5eX/5OTk/+SkpL/kJGQ/42Njf+IiIj/g4OD/35/
        f/96env/eHh4/zAwL/8iIiL/JiYl/ycnJ/8oKCj/Jycn/ygnJ/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAHp7e/9ZWVr/WVlZ/1dXV/9UVFX/T1BP/0ZGRv+ioaL/z8/P/8rL
        yv/HyMf/xMTE/8HBwf++vb7/tra2/6+vr/+qq6v/p6en/6Kiov+enp7/mZmZ/5WVlf+UlJT/k5KS/46O
        jv+Kior/hYWF/4CAgP98fHz/eHl6/zAwMP8jIiP/JiYm/ygnKP8oKCr/KCgo/ycoKP8PDw//Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHx8fP9bW1r/Wlpa/1hYWP9VVlb/UFBQ/0dH
        R/+kpKT/0tLS/87Ozv/Ly8v/x8fH/8PExP/AwMD/ubm5/7Kysf+tra3/qaio/6Wlpf+goKD/m5ub/5eW
        l/+ZmZr/lJSU/5CQj/+Li4v/hoaG/4GBgf99fX3/e3t7/zAwMP8jIyP/JiYm/ygoJ/8pKSj/KSgo/ygo
        KP8QEBD/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAH5+ff9cXFz/XFtc/1pZ
        Wf9XV1b/UVFR/0hISP+lpaX/1tbW/9HR0f/Ozs7/y8rK/8bGxv/DwsL/uLi3/6ysrP+nqaf/o6Oi/56e
        nv+ioqL/paWl/5+fn/+bmpv/lZaW/5GRkP+NjYz/iIiH/4KCgv9+fn7/fHx8/zEyMv8jIyP/Jicn/ygo
        KP8pKSn/KCgp/ygpKP8RERH/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAH9/
        f/9dXV3/XV1d/1paW/9YWFf/UlJS/0lJSf+kpKT/2tra/9TU1P/Q0ND/zc3N/8jJyf/ExMT/vb29/7W1
        tv+xsbH/rKys/6ioqP+ioqT/nZ2e/5iYmP+YmJj/l5eX/5KSkv+Ojo3/iImI/4ODg/9/f3//fX19/zQ0
        NP8jIyP/Jycn/ygoKP8pKSn/KSkp/ygoKP8TExP/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAICAgP9eXl7/Xl5e/1xcXP9ZWVn/U1NT/0lJSf+kpKT/3d3d/9fX1v/S0tL/z8/P/8vL
        y//Gxsb/wsLC/72+vv+4uLn/tLS0/7CwsP+srKz/p6em/6Ghof+dnZ3/mJiY/5KTk/+Ojo7/iYmJ/4SE
        hP9/gID/fn5+/zY2Nv8kIyT/Jycn/ygoKP8pKSn/KSkp/ykpKf8WFhb/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAIKCgv9fX17/Xl5e/11cXf9ZWln/VFRU/0pJSv+lpaX/4eHg/9na
        2v/V1dT/0NDQ/83Mzf/Hx8f/w8PD/7++vv+6urr/tbW1/7CwsP+sra3/p6en/6Kiov+enZ3/mZmY/5SU
        k/+Pj4//ioqK/4WFhf+AgID/fX19/zk5Of8jIyT/Jycn/ygoKf8pKSn/KSkp/ykpJ/8YFxj/DQ0NZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIOEhP9gYGD/X19f/15dXf9aWlr/VVVV/0tK
        S/+lpaX/4eLi/9vb2//W1tX/0dHR/83Nzf/IyMj/w8PE/7+/v/+6u7r/tbW1/7Gxsf+tra3/qKio/6Kj
        o/+enp7/mZmZ/5SUlP+Pj4//i4qK/4WFhf+AgID/fn59/zw8PP8kJCT/Jycn/ykpKf8qKin/KSkp/ygn
        KP8ZGRr/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAISEhP9gYGD/X19f/15e
        Xv9aWlv/VlZW/0tLS/+lpaX/4uLi/9zc3P/W19b/0dLR/83Ozv/JyMn/xMTE/7/AwP+7urv/trW2/7Gx
        sf+tra3/qKin/6Ojov+enp7/mZmZ/5SUlP+Pj5D/i4qK/4aFhf+AgID/fn5+/z9AQP8lJSX/KCgn/ykp
        Kf8qKin/KSkp/ygoKP8bGxv/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIWH
        h/9gYGD/X19f/15eXv9aWlv/VlZX/0xMTP+mpqb/4eLh/9vb2//W1tb/0dHR/83Nzf/IyMn/xMTE/7+/
        v/+7u7v/tba1/7Gxsf+tra3/qKio/6Ojo/+enp7/mZmZ/5SUlP+Pj4//ioqK/4WFhf+AgID/fX59/0JC
        Qv8mJib/KCgo/ykpKf8qKir/KSkp/ygoKP8cHBz/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAIiIiP9gYGD/X19f/15eXv9bW1v/WFdX/05OTf+np6f/4eHh/9rZ2v/V1dX/0NDQ/83N
        zf/IyMf/w8PD/76/v/+6urr/tbW1/7CxsP+sra3/p6in/6Kiov+enp7/mZmZ/5OUlP+Pj4//ioqK/4WE
        hf+AgID/fn19/0ZGRv8mJyb/Kikq/yorKv8qKyr/KSkp/ygoKP8dHh7/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAImJif9gYGD/X19f/15eXv9bW1v/WFhY/1BQUP+pqan/6Ojo/9bW
        1v/S09P/z8/P/8vLy//Gxsb/wsLC/76+vv+5ubn/tLS0/7CwsP+srKv/p6em/6Giov+dnZ3/mJiY/5OT
        k/+Oj47/iYmJ/4SEhP9/f4D/e3t7/0pKS/8oKCj/Kysr/ywsLP8rKir/Kikq/yknJ/8fHx//DQ0NZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIuLi/9fX17/Xl5f/11dXf9bW1v/WVhY/1RU
        VP9XV1j//////+Pj4//T09P/z8/P/8rKyv/Fx8f/wcHC/7++v/+5ubn/tbW1/7CwsP+sraz/pqao/6Ki
        ov+enZ7/mZmZ/5STlP+QkJD/i4uL/4aGhv+BgYH/fHx8/zEwL/8rKiz/LCws/y0sLP8rKir/F4GW/ygm
        J/8iIiL/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIyMjP9eXV3/Xl5e/11c
        XP9bW1v/WFlZ/1ZWVf9OTk7/VldW/6enp/+lpaX/pKSk/6Kiov+goKD/nJyc/5iYmP+Tk5P/jo+P/4mJ
        if+FhIX/gICA/3t7fP92dnb/cXJx/21tbf9nZmb/YmJi/11dXf9aWlr/MzMz/ywtLP8uLi3/LS0t/y0t
        Lf8sKin/KScm/ycmJP8kJCT/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAI6O
        jv9cXlz/Xl5e/1tbXP9aWlr/WFhY/1ZWV/9SU1P/Tk9P/0tLSv9HR0f/RERE/0JCQv9AQED/Pj8//zw8
        Pf87Ozv/Ozs8/zo6Ov85OTn/ODg4/zY2Nv81NDX/NDM0/zMzM/8xMTH/MDAw/y8vL/8vLy//Li4u/y8v
        L/8uLy7/Li0t/y0tLP8rKij/F4GW/ygmJ/8mJib/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAJCPkP9dW1v/XV1c/1tbW/9ZWVn/WFhY/1ZWVv9TVFP/UlJR/09PT/9OTk3/S0xL/0pK
        Sv9ISEj/R0ZH/0VERf9CQkP/QUFC/0BAQP8/Pz//Pj4+/z09Pf87Ozv/OTk6/zg4OP82Njf/NTU1/zMz
        M/8yMjL/MTEx/y8wL/8vLy//Ly0t/xeAlf8sKCf/KScm/ykmJf8nJyf/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAJKSkv9aWlr/W1tb/1paWv9ZWVj/V1dX/1ZVVv9UVFT/UlJR/1BP
        UP9OTk7/TU1N/0xMTP9KSkr/SElI/0dHR/9GRkb/RERE/0JCQv9AQED/Pz8//z4+Pv89PT3/Ozs7/zk5
        Of84ODj/Nzc2/zQ0NP8zMzP/MjIy/zAwMP8vLy//Lyws/y4qK/8tKCf/GI6q/ygnJv8pKCn/DQ0NZA4O
        DlcNDQ0yCAgIDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAJOTk/9ZWFj/Wlpa/1lZWf9YWFj/V1dW/1VV
        VP9TU1P/UVFR/1BPUP9PT0//TU5O/0xMTP9LSkv/SUlJ/0hISP9GRkb/RERE/0NCQv9BQUH/QD8//z4/
        Pv89PT7/Ozw8/zo6Ov85OTn/Nzg3/zU1NP8zMzP/MTIy/zAwMP8vLy//Li0t/xeAlf8tJyj/KyYm/ygk
        Jf8rKyv/DQ0NVw0NDUwNDQ0sCQkJDAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAJOTk/9XV1f/WVhY/1hY
        V/9XV1f/VlZW/1VVVf9SUlL/UFFR/09PT/9OTk7/TU1N/0xMTP9LSkr/SUlJ/0dHR/9GRkb/REVE/0JC
        Qv9BQUD/Pz8//z8/Pv89PT3/Ozw8/zo6Ov84ODj/Nzc2/zQ0Nf8zMzP/MTIy/zAwL/8vLy//Li0t/y0s
        LP8rKSj/GI6q/yclJf8tLS3/DAwMMg0NDSwLCwsaCAgIBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJKS
        kv9UVVX/VVVV/1RVVf9TU1P/UlJS/1FRUf9PT0//Tk5O/01NTf9MTEz/SktL/0tJSf9JSUn/SEhI/0ZG
        R/9FRUX/Q0ND/0FBQf9APz//Pj4+/z0+Pf88PDz/Ojo6/zk5Of84ODj/NjY2/zM0M/8yMjH/MDAw/y8v
        L/8uLi7/LS0t/y0tLf8rKSn/KSYm/yclJP8vLy//BwcHDgkJCQwICAgHAAAAAgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAJaVlf+TkpL/kpKS/4+Qj/+NjY3/iYmJ/4eHhv+FhYX/goKD/3+Af/99fHz/enl5/3Z2
        dv90dHT/cnJy/3Bwb/9ra2v/aGho/2VmZf9jZGP/YWFh/15eX/9cXFz/WFhY/1VUVf9TUlL/UFBQ/01N
        Tf9LS0v/SEhI/0NEQ/9BQUH/Pz8//zw9PP85OTn/NjY2/zIyMv8xMTH/AAAAAQAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAf
        AAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAf
        AAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAP///////wAA////////
        AAD///////8AAP///////wAA////////AAA=
</value>
  </data>
</root>
```

`LibreHardwareMonitor/UI/ScaledPlotModel.cs`:

```cs
using OxyPlot;
using OxyPlot.Legends;

namespace LibreHardwareMonitor.UI;

class ScaledPlotModel : PlotModel
{
    public ScaledPlotModel(double dpiXscale, double dpiYscale)
    {
        PlotMargins = new OxyThickness(PlotMargins.Left * dpiXscale,
                                       PlotMargins.Top * dpiYscale,
                                       PlotMargins.Right * dpiXscale,
                                       PlotMargins.Bottom * dpiYscale);

        Padding = new OxyThickness(Padding.Left * dpiXscale,
                                   Padding.Top * dpiYscale,
                                   Padding.Right * dpiXscale,
                                   Padding.Bottom * dpiYscale);

        TitlePadding *= dpiXscale;

        Legend legend = new();

        legend.LegendSymbolLength *= dpiXscale;
        legend.LegendSymbolMargin *= dpiXscale;
        legend.LegendPadding *= dpiXscale;
        legend.LegendColumnSpacing *= dpiXscale;
        legend.LegendItemSpacing *= dpiXscale;
        legend.LegendMargin *= dpiXscale;

        Legends.Add(legend);
    }
}
```

`LibreHardwareMonitor/UI/SensorGadget.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Windows.Forms;
using System.IO;
using System.Linq;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public class SensorGadget : Gadget
{
    private const int TopBorder = 6;
    private const int BottomBorder = 7;
    private const int LeftBorder = 6;
    private const int RightBorder = 7;

    private readonly UnitManager _unitManager;
    private Image _back = Utilities.EmbeddedResources.GetImage("gadget.png");
    private Image _image;
    private Image _fore;
    private Image _barBack = Utilities.EmbeddedResources.GetImage("barback.png");
    private Image _barFore = Utilities.EmbeddedResources.GetImage("barblue.png");
    private Image _background = new Bitmap(1, 1);
    private readonly float _scale;
    private float _fontSize;
    private int _iconSize;
    private int _hardwareLineHeight;
    private int _sensorLineHeight;
    private int _rightMargin;
    private int _leftMargin;
    private int _topMargin;
    private int _bottomMargin;
    private int _progressWidth;

    private readonly IDictionary<IHardware, IList<ISensor>> _sensors = new SortedDictionary<IHardware, IList<ISensor>>(new HardwareComparer());
    private readonly PersistentSettings _settings;
    private readonly UserOption _hardwareNames;

    private Font _largeFont;
    private Font _smallFont;
    private Brush _textBrush;
    private StringFormat _stringFormat;
    private StringFormat _trimStringFormat;
    private StringFormat _alignRightStringFormat;

    public SensorGadget(IComputer computer, PersistentSettings settings, UnitManager unitManager)
    {
        _unitManager = unitManager;
        _settings = settings;
        computer.HardwareAdded += HardwareAdded;
        computer.HardwareRemoved += HardwareRemoved;

        _stringFormat = new StringFormat { FormatFlags = StringFormatFlags.NoWrap };
        _trimStringFormat = new StringFormat { Trimming = StringTrimming.EllipsisCharacter, FormatFlags = StringFormatFlags.NoWrap };
        _alignRightStringFormat = new StringFormat { Alignment = StringAlignment.Far, FormatFlags = StringFormatFlags.NoWrap };

        if (File.Exists("gadget_background.png"))
        {
            try
            {
                Image newBack = new Bitmap("gadget_background.png");
                _back.Dispose();
                _back = newBack;
            }
            catch { }
        }

        if (File.Exists("gadget_image.png"))
        {
            try
            {
                _image = new Bitmap("gadget_image.png");
            }
            catch { }
        }

        if (File.Exists("gadget_foreground.png"))
        {
            try
            {
                _fore = new Bitmap("gadget_foreground.png");
            }
            catch { }
        }

        if (File.Exists("gadget_bar_background.png"))
        {
            try
            {
                Image newBarBack = new Bitmap("gadget_bar_background.png");
                _barBack.Dispose();
                _barBack = newBarBack;
            }
            catch { }
        }

        if (File.Exists("gadget_bar_foreground.png"))
        {
            try
            {
                Image newBarColor = new Bitmap("gadget_bar_foreground.png");
                _barFore.Dispose();
                _barFore = newBarColor;
            }
            catch { }
        }

        Location = new Point(settings.GetValue("sensorGadget.Location.X", 100), settings.GetValue("sensorGadget.Location.Y", 100));
        LocationChanged += delegate
        {
            settings.SetValue("sensorGadget.Location.X", Location.X);
            settings.SetValue("sensorGadget.Location.Y", Location.Y);
        };

        // get the custom to default dpi ratio
        using (Bitmap b = new Bitmap(1, 1))
        {
            _scale = b.HorizontalResolution / 96.0f;
        }

        SetFontSize(settings.GetValue("sensorGadget.FontSize", 7.5f));
        Resize(settings.GetValue("sensorGadget.Width", Size.Width));

        ContextMenuStrip contextMenuStrip = new ContextMenuStrip();
        ToolStripMenuItem hardwareNamesItem = new ToolStripMenuItem("Hardware Names");
        contextMenuStrip.Items.Add(hardwareNamesItem);
        ToolStripMenuItem fontSizeMenu = new ToolStripMenuItem("Font Size");
        for (int i = 0; i < 4; i++)
        {
            float size;
            string name;
            switch (i)
            {
                case 0: size = 6.5f; name = "Small"; break;
                case 1: size = 7.5f; name = "Medium"; break;
                case 2: size = 9f; name = "Large"; break;
                case 3: size = 11f; name = "Very Large"; break;
                default: throw new NotImplementedException();
            }

            ToolStripItem item = new ToolStripMenuItem(name) { Checked = _fontSize == size };
            item.Click += delegate
            {
                SetFontSize(size);
                settings.SetValue("sensorGadget.FontSize", size);
                foreach (ToolStripMenuItem mi in fontSizeMenu.DropDownItems)
                    mi.Checked = mi == item;
            };
            fontSizeMenu.DropDownItems.Add(item);
        }
        contextMenuStrip.Items.Add(fontSizeMenu);

        Color fontColor = settings.GetValue("sensorGadget.FontColor", Color.White);
        int fontColorArgb = fontColor.ToArgb();

        SetFontColor(fontColor);

        IEnumerable<Color> providedColors = Enum.GetValues(typeof(KnownColor))
                                                .Cast<KnownColor>()
                                                .Select(x => Color.FromKnownColor(x))
                                                .Where(x => !x.IsSystemColor && x.Name.Length < 7);

        ToolStripMenuItem fontColorMenu = new ToolStripMenuItem("Font Color");
        foreach (Color color in providedColors)
        {
            ToolStripItem item = new ToolStripMenuItem(color.Name) { Checked = fontColorArgb == color.ToArgb() };
            item.Click += delegate
            {
                SetFontColor(color);
                settings.SetValue("sensorGadget.FontColor", color);
                foreach (ToolStripMenuItem mi in fontColorMenu.DropDownItems)
                    mi.Checked = mi == item;
            };
            fontColorMenu.DropDownItems.Add(item);
        }
        contextMenuStrip.Items.Add(fontColorMenu);
        contextMenuStrip.Items.Add(new ToolStripSeparator());
        ToolStripMenuItem lockItem = new ToolStripMenuItem("Lock Position and Size");
        contextMenuStrip.Items.Add(lockItem);
        contextMenuStrip.Items.Add(new ToolStripSeparator());
        ToolStripMenuItem alwaysOnTopItem = new ToolStripMenuItem("Always on Top");
        contextMenuStrip.Items.Add(alwaysOnTopItem);
        ToolStripMenuItem opacityMenu = new ToolStripMenuItem("Opacity");
        contextMenuStrip.Items.Add(opacityMenu);
        Opacity = (byte)settings.GetValue("sensorGadget.Opacity", 255);

        for (int i = 0; i < 5; i++)
        {
            ToolStripMenuItem item = new ToolStripMenuItem((20 * (i + 1)).ToString() + " %");
            byte o = (byte)(51 * (i + 1));
            item.Checked = Opacity == o;
            item.Click += delegate
            {
                Opacity = o;
                settings.SetValue("sensorGadget.Opacity", Opacity);
                foreach (ToolStripMenuItem mi in opacityMenu.DropDownItems)
                    mi.Checked = mi == item;
            };
            opacityMenu.DropDownItems.Add(item);
        }
        ContextMenuStrip = contextMenuStrip;

        _hardwareNames = new UserOption("sensorGadget.Hardwarenames", true, hardwareNamesItem, settings);
        _hardwareNames.Changed += delegate
        {
            Resize();
        };

        UserOption alwaysOnTop = new UserOption("sensorGadget.AlwaysOnTop", false, alwaysOnTopItem, settings);
        alwaysOnTop.Changed += delegate
        {
            AlwaysOnTop = alwaysOnTop.Value;
        };
        UserOption lockPositionAndSize = new UserOption("sensorGadget.LockPositionAndSize", false, lockItem, settings);
        lockPositionAndSize.Changed += delegate
        {
            LockPositionAndSize = lockPositionAndSize.Value;
        };

        HitTest += delegate (object sender, HitTestEventArgs e)
        {
            if (lockPositionAndSize.Value)
                return;

            if (e.Location.X < LeftBorder)
            {
                e.HitResult = HitResult.Left;
                return;
            }
            if (e.Location.X > Size.Width - 1 - RightBorder)
            {
                e.HitResult = HitResult.Right;
            }
        };

        SizeChanged += delegate
        {
            settings.SetValue("sensorGadget.Width", Size.Width);
            Redraw();
        };

        VisibleChanged += delegate
        {
            Rectangle bounds = new Rectangle(Location, Size);
            Screen screen = Screen.FromRectangle(bounds);
            Rectangle intersection = Rectangle.Intersect(screen.WorkingArea, bounds);
            if (intersection.Width < Math.Min(16, bounds.Width) || intersection.Height < Math.Min(16, bounds.Height))
            {
                Location = new Point(screen.WorkingArea.Width / 2 - bounds.Width / 2, screen.WorkingArea.Height / 2 - bounds.Height / 2);
            }
        };

        MouseDoubleClick += delegate
        {
            SendHideShowCommand();
        };
    }

    public override void Dispose()
    {

        _largeFont.Dispose();
        _largeFont = null;

        _smallFont.Dispose();
        _smallFont = null;

        _textBrush.Dispose();
        _textBrush = null;

        _stringFormat.Dispose();
        _stringFormat = null;

        _trimStringFormat.Dispose();
        _trimStringFormat = null;

        _alignRightStringFormat.Dispose();
        _alignRightStringFormat = null;

        _back.Dispose();
        _back = null;

        _barFore.Dispose();
        _barFore = null;

        _barBack.Dispose();
        _barBack = null;

        _background.Dispose();
        _background = null;

        if (_image != null)
        {
            _image.Dispose();
            _image = null;
        }

        if (_fore != null)
        {
            _fore.Dispose();
            _fore = null;
        }

        base.Dispose();
    }

    private void HardwareRemoved(IHardware hardware)
    {
        hardware.SensorAdded -= SensorAdded;
        hardware.SensorRemoved -= SensorRemoved;

        foreach (ISensor sensor in hardware.Sensors)
            SensorRemoved(sensor);

        foreach (IHardware subHardware in hardware.SubHardware)
            HardwareRemoved(subHardware);
    }

    private void HardwareAdded(IHardware hardware)
    {
        foreach (ISensor sensor in hardware.Sensors)
            SensorAdded(sensor);

        hardware.SensorAdded += SensorAdded;
        hardware.SensorRemoved += SensorRemoved;

        foreach (IHardware subHardware in hardware.SubHardware)
            HardwareAdded(subHardware);
    }

    private void SensorAdded(ISensor sensor)
    {
        if (_settings.GetValue(new Identifier(sensor.Identifier, "gadget").ToString(), false))
            Add(sensor);
    }

    private void SensorRemoved(ISensor sensor)
    {
        if (Contains(sensor))
            Remove(sensor, false);
    }

    public bool Contains(ISensor sensor)
    {
        return _sensors.Values.Any(list => list.Contains(sensor));
    }

    public void Add(ISensor sensor)
    {
        if (Contains(sensor))
            return;


        // get the right hardware
        IHardware hardware = sensor.Hardware;
        while (hardware.Parent != null)
            hardware = hardware.Parent;

        // get the sensor list associated with the hardware
        if (!_sensors.TryGetValue(hardware, out IList<ISensor> list))
        {
            list = new List<ISensor>();
            _sensors.Add(hardware, list);
        }

        // insert the sensor at the right position
        int i = 0;
        while (i < list.Count && (list[i].SensorType < sensor.SensorType || (list[i].SensorType == sensor.SensorType && list[i].Index < sensor.Index)))
            i++;

        list.Insert(i, sensor);

        _settings.SetValue(new Identifier(sensor.Identifier, "gadget").ToString(), true);
        Resize();
    }

    public void Remove(ISensor sensor)
    {
        Remove(sensor, true);
    }

    private void Remove(ISensor sensor, bool deleteConfig)
    {
        if (deleteConfig)
            _settings.Remove(new Identifier(sensor.Identifier, "gadget").ToString());

        foreach (KeyValuePair<IHardware, IList<ISensor>> keyValue in _sensors)
        {
            if (keyValue.Value.Contains(sensor))
            {
                keyValue.Value.Remove(sensor);
                if (keyValue.Value.Count == 0)
                {
                    _sensors.Remove(keyValue.Key);
                    break;
                }
            }
        }
        Resize();
    }

    public event EventHandler HideShowCommand;

    public void SendHideShowCommand()
    {
        HideShowCommand?.Invoke(this, null);
    }

    private Font CreateFont(float size, FontStyle style)
    {
        try
        {
            return new Font(SystemFonts.MessageBoxFont.FontFamily, size, style);
        }
        catch (ArgumentException)
        {
            // if the style is not supported, fall back to the original one
            return new Font(SystemFonts.MessageBoxFont.FontFamily, size,
                            SystemFonts.MessageBoxFont.Style);
        }
    }

    private void SetFontSize(float size)
    {
        _fontSize = size;
        _largeFont = CreateFont(_fontSize, FontStyle.Bold);
        _smallFont = CreateFont(_fontSize, FontStyle.Regular);

        double scaledFontSize = _fontSize * _scale;
        _iconSize = (int)Math.Round(1.5 * scaledFontSize);
        _hardwareLineHeight = (int)Math.Round(1.66 * scaledFontSize);
        _sensorLineHeight = (int)Math.Round(1.33 * scaledFontSize);
        _leftMargin = LeftBorder + (int)Math.Round(0.3 * scaledFontSize);
        _rightMargin = RightBorder + (int)Math.Round(0.3 * scaledFontSize);
        _topMargin = TopBorder;
        _bottomMargin = BottomBorder + (int)Math.Round(0.3 * scaledFontSize);
        _progressWidth = (int)Math.Round(5.3 * scaledFontSize);

        Resize((int)Math.Round(17.3 * scaledFontSize));
    }

    private void SetFontColor(Color color)
    {
        _textBrush?.Dispose();
        _textBrush = new SolidBrush(color);
    }

    private void Resize()
    {
        Resize(Size.Width);
    }

    private void Resize(int width)
    {
        int y = _topMargin;

        foreach (KeyValuePair<IHardware, IList<ISensor>> pair in _sensors)
        {
            if (_hardwareNames.Value)
            {
                if (y > _topMargin)
                    y += _hardwareLineHeight - _sensorLineHeight;
                y += _hardwareLineHeight;
            }
            y += pair.Value.Count * _sensorLineHeight;
        }

        if (_sensors.Count == 0)
            y += 4 * _sensorLineHeight + _hardwareLineHeight;

        y += _bottomMargin;
        Size = new Size(width, y);
    }

    private void DrawImageWidthBorder(Graphics g, int width, int height, Image back, int t, int b, int l, int r)
    {
        GraphicsUnit u = GraphicsUnit.Pixel;

        g.DrawImage(back, new Rectangle(0, 0, l, t), new Rectangle(0, 0, l, t), u);
        g.DrawImage(back, new Rectangle(l, 0, width - l - r, t), new Rectangle(l, 0, back.Width - l - r, t), u);
        g.DrawImage(back, new Rectangle(width - r, 0, r, t), new Rectangle(back.Width - r, 0, r, t), u);

        g.DrawImage(back, new Rectangle(0, t, l, height - t - b), new Rectangle(0, t, l, back.Height - t - b), u);
        g.DrawImage(back, new Rectangle(l, t, width - l - r, height - t - b), new Rectangle(l, t, back.Width - l - r, back.Height - t - b), u);
        g.DrawImage(back, new Rectangle(width - r, t, r, height - t - b), new Rectangle(back.Width - r, t, r, back.Height - t - b), u);

        g.DrawImage(back, new Rectangle(0, height - b, l, b), new Rectangle(0, back.Height - b, l, b), u);
        g.DrawImage(back, new Rectangle(l, height - b, width - l - r, b), new Rectangle(l, back.Height - b, back.Width - l - r, b), u);
        g.DrawImage(back, new Rectangle(width - r, height - b, r, b), new Rectangle(back.Width - r, back.Height - b, r, b), u);
    }

    private void DrawBackground(Graphics g)
    {
        int w = Size.Width;
        int h = Size.Height;

        if (w != _background.Width || h != _background.Height)
        {
            _background.Dispose();
            _background = new Bitmap(w, h, PixelFormat.Format32bppPArgb);

            using (Graphics graphics = Graphics.FromImage(_background))
            {
                DrawImageWidthBorder(graphics, w, h, _back, TopBorder, BottomBorder,LeftBorder, RightBorder);

                if (_fore != null)
                    DrawImageWidthBorder(graphics, w, h, _fore, TopBorder, BottomBorder, LeftBorder, RightBorder);

                if (_image != null)
                {
                    int width = w - LeftBorder - RightBorder;
                    int height = h - TopBorder - BottomBorder;
                    float xRatio = width / (float)_image.Width;
                    float yRatio = height / (float)_image.Height;
                    float destWidth, destHeight;
                    float xOffset, yOffset;

                    if (xRatio < yRatio)
                    {
                        destWidth = width;
                        destHeight = _image.Height * xRatio;
                        xOffset = 0;
                        yOffset = 0.5f * (height - destHeight);
                    }
                    else
                    {
                        destWidth = _image.Width * yRatio;
                        destHeight = height;
                        xOffset = 0.5f * (width - destWidth);
                        yOffset = 0;
                    }

                    graphics.DrawImage(_image, new RectangleF(LeftBorder + xOffset, TopBorder + yOffset, destWidth, destHeight));
                }
            }
        }

        g.DrawImageUnscaled(_background, 0, 0);
    }

    private void DrawProgress(Graphics g, float x, float y, float width, float height, float progress)
    {
        g.DrawImage(_barBack,
                    new RectangleF(x + width * progress, y, width * (1 - progress), height),
                    new RectangleF(_barBack.Width * progress, 0, (1 - progress) * _barBack.Width, _barBack.Height),
                    GraphicsUnit.Pixel);
        g.DrawImage(_barFore,
                    new RectangleF(x, y, width * progress, height),
                    new RectangleF(0, 0, progress * _barFore.Width, _barFore.Height), GraphicsUnit.Pixel);
    }

    protected override void OnPaint(PaintEventArgs e)
    {
        Graphics g = e.Graphics;
        int w = Size.Width;

        g.Clear(Color.Transparent);
        DrawBackground(g);

        int x;
        int y = _topMargin;

        if (_sensors.Count == 0)
        {
            x = LeftBorder + 1;
            g.DrawString("Right-click on a sensor in the main window and select " +
                         "\"Show in Gadget\" to show the sensor here.",
                         _smallFont, _textBrush,
                         new Rectangle(x, y - 1, w - RightBorder - x, 0));
        }

        foreach (KeyValuePair<IHardware, IList<ISensor>> pair in _sensors)
        {
            if (_hardwareNames.Value)
            {
                if (y > _topMargin)
                    y += _hardwareLineHeight - _sensorLineHeight;
                x = LeftBorder + 1;
                g.DrawImage(HardwareTypeImage.Instance.GetImage(pair.Key.HardwareType), new Rectangle(x, y + 1, _iconSize, _iconSize));
                x += _iconSize + 1;
                g.DrawString(pair.Key.Name, _largeFont, _textBrush, new Rectangle(x, y - 1, w - RightBorder - x, 0), _stringFormat);
                y += _hardwareLineHeight;
            }

            foreach (ISensor sensor in pair.Value)
            {
                int remainingWidth;


                if ((sensor.SensorType != SensorType.Load &&
                     sensor.SensorType != SensorType.Control &&
                     sensor.SensorType != SensorType.Level) || !sensor.Value.HasValue)
                {
                    string formatted;

                    if (sensor.Value.HasValue)
                    {
                        string format = "";
                        switch (sensor.SensorType)
                        {
                            case SensorType.Voltage:
                                format = "{0:F3} V";
                                break;
                            case SensorType.Current:
                                format = "{0:F3} A";
                                break;
                            case SensorType.Clock:
                                format = "{0:F0} MHz";
                                break;
                            case SensorType.Frequency:
                                format = "{0:F0} Hz";
                                break;
                            case SensorType.Temperature:
                                format = "{0:F1} °C";
                                break;
                            case SensorType.Fan:
                                format = "{0:F0} RPM";
                                break;
                            case SensorType.Flow:
                                format = "{0:F0} L/h";
                                break;
                            case SensorType.Power:
                                format = "{0:F1} W";
                                break;
                            case SensorType.Data:
                                format = "{0:F1} GB";
                                break;
                            case SensorType.SmallData:
                                format = "{0:F0} MB";
                                break;
                            case SensorType.Factor:
                                format = "{0:F3}";
                                break;
                            case SensorType.TimeSpan:
                                format = "{0:g}";
                                break;
                            case SensorType.Energy:
                                format = "{0:F0} mWh";
                                break;
                            case SensorType.Noise:
                                format = "{0:F0} dBA";
                                break;
                        }

                        if (sensor.SensorType == SensorType.Temperature && _unitManager.TemperatureUnit == TemperatureUnit.Fahrenheit)
                        {
                            formatted = $"{UnitManager.CelsiusToFahrenheit(sensor.Value):F1} °F";
                        }
                        else if (sensor.SensorType == SensorType.Throughput)
                        {
                            string result;
                            switch (sensor.Name)
                            {
                                case "Connection Speed":
                                    {
                                        switch (sensor.Value)
                                        {
                                            case 100000000:
                                                result = "100Mbps";
                                                break;
                                            case 1000000000:
                                                result = "1Gbps";
                                                break;
                                            default:
                                                {
                                                    if (sensor.Value < 1024)
                                                        result = $"{sensor.Value:F0} bps";
                                                    else if (sensor.Value < 1048576)
                                                        result = $"{sensor.Value / 1024:F1} Kbps";
                                                    else if (sensor.Value < 1073741824)
                                                        result = $"{sensor.Value / 1048576:F1} Mbps";
                                                    else
                                                        result = $"{sensor.Value / 1073741824:F1} Gbps";
                                                }
                                                break;
                                        }
                                    }
                                    break;
                                default:
                                    {
                                        if (sensor.Value < 1048576)
                                            result = $"{sensor.Value / 1024:F1} KB/s";
                                        else
                                            result = $"{sensor.Value / 1048576:F1} MB/s";
                                    }
                                    break;
                            }
                            formatted = result;
                        }
                        else if (sensor.SensorType == SensorType.TimeSpan)
                        {
                            formatted = string.Format(format, TimeSpan.FromSeconds(sensor.Value.Value));
                        }
                        else
                        {
                            formatted = string.Format(format, sensor.Value);
                        }
                    }
                    else
                    {
                        formatted = "-";
                    }

                    g.DrawString(formatted, _smallFont, _textBrush, new RectangleF(-1, y - 1, w - _rightMargin + 3, 0), _alignRightStringFormat);

                    remainingWidth = w - (int)Math.Floor(g.MeasureString(formatted, _smallFont, w, StringFormat.GenericTypographic).Width) - _rightMargin;
                }
                else
                {
                    DrawProgress(g, w - _progressWidth - _rightMargin, y + 0.35f * _sensorLineHeight, _progressWidth, 0.6f * _sensorLineHeight, 0.01f * sensor.Value.Value);
                    remainingWidth = w - _progressWidth - _rightMargin;
                }

                remainingWidth -= _leftMargin + 2;
                if (remainingWidth > 0)
                {
                    g.DrawString(sensor.Name, _smallFont, _textBrush, new RectangleF(_leftMargin - 1, y - 1, remainingWidth, 0), _trimStringFormat);
                }
                y += _sensorLineHeight;
            }
        }
    }

    private class HardwareComparer : IComparer<IHardware>
    {
        public int Compare(IHardware x, IHardware y)
        {
            switch (x)
            {
                case null when y == null:
                    return 0;
                case null:
                    return -1;
            }

            if (y == null)
                return 1;

            if (x.HardwareType != y.HardwareType)
                return x.HardwareType.CompareTo(y.HardwareType);

            return x.Identifier.CompareTo(y.Identifier);
        }
    }
}
```

`LibreHardwareMonitor/UI/SensorNode.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Drawing;
using System.Globalization;
using System.Text;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public class SensorNode : Node
{
    private readonly PersistentSettings _settings;
    private readonly UnitManager _unitManager;
    private Color? _penColor;
    private bool _plot;

    public SensorNode(ISensor sensor, PersistentSettings settings, UnitManager unitManager)
    {
        Sensor = sensor;
        _settings = settings;
        _unitManager = unitManager;

        switch (sensor.SensorType)
        {
            case SensorType.Voltage:
                Format = "{0:F3} V";
                break;
            case SensorType.Current:
                Format = "{0:F3} A";
                break;
            case SensorType.Clock:
                Format = "{0:F1} MHz";
                break;
            case SensorType.Load:
                Format = "{0:F1} %";
                break;
            case SensorType.Temperature:
                Format = "{0:F1} °C";
                break;
            case SensorType.Fan:
                Format = "{0:F0} RPM";
                break;
            case SensorType.Flow:
                Format = "{0:F1} L/h";
                break;
            case SensorType.Control:
                Format = "{0:F1} %";
                break;
            case SensorType.Level:
                Format = "{0:F1} %";
                break;
            case SensorType.Power:
                Format = "{0:F1} W";
                break;
            case SensorType.Data:
                Format = "{0:F1} GB";
                break;
            case SensorType.SmallData:
                Format = "{0:F1} MB";
                break;
            case SensorType.Factor:
                Format = "{0:F3}";
                break;
            case SensorType.Frequency:
                Format = "{0:F1} Hz";
                break;
            case SensorType.Throughput:
                Format = "{0:F1} B/s";
                break;
            case SensorType.TimeSpan:
                Format = "{0:g}";
                break;
            case SensorType.Energy:
                Format = "{0:F0} mWh";
                break;
            case SensorType.Noise:
                Format = "{0:F0} dBA";
                break;
        }

        bool hidden = settings.GetValue(new Identifier(sensor.Identifier, "hidden").ToString(), sensor.IsDefaultHidden);
        base.IsVisible = !hidden;
        Plot = settings.GetValue(new Identifier(sensor.Identifier, "plot").ToString(), false);
        string id = new Identifier(sensor.Identifier, "penColor").ToString();

        if (settings.Contains(id))
            PenColor = settings.GetValue(id, Color.Black);
    }

    public event EventHandler PlotSelectionChanged;

    public string Format { get; set; } = "";

    public override bool IsVisible
    {
        get { return base.IsVisible; }
        set
        {
            base.IsVisible = value;
            _settings.SetValue(new Identifier(Sensor.Identifier, "hidden").ToString(), !value);
        }
    }

    public string Max
    {
        get { return ValueToString(Sensor.Max); }
    }

    public string Min
    {
        get { return ValueToString(Sensor.Min); }
    }

    public Color? PenColor
    {
        get { return _penColor; }
        set
        {
            _penColor = value;

            string id = new Identifier(Sensor.Identifier, "penColor").ToString();
            if (value.HasValue)
                _settings.SetValue(id, value.Value);
            else
                _settings.Remove(id);

            PlotSelectionChanged?.Invoke(this, null);
        }
    }

    public bool Plot
    {
        get { return _plot; }
        set
        {
            _plot = value;
            _settings.SetValue(new Identifier(Sensor.Identifier, "plot").ToString(), value);
            PlotSelectionChanged?.Invoke(this, null);
        }
    }

    public ISensor Sensor { get; }

    public override string Text
    {
        get { return Sensor.Name; }
        set { Sensor.Name = value; }
    }

    public override string ToolTip
    {
        get
        {
            StringBuilder stringBuilder = new();

            if (Sensor is ICriticalSensorLimits criticalSensorLimits)
                OptionallyAppendCriticalRange(stringBuilder, criticalSensorLimits.CriticalLowLimit, criticalSensorLimits.CriticalHighLimit, "critical");

            if (Sensor is ISensorLimits sensorLimits)
                OptionallyAppendCriticalRange(stringBuilder, sensorLimits.LowLimit, sensorLimits.HighLimit, "normal");

            return stringBuilder.ToString();
        }
    }

    public string Value
    {
        get { return ValueToString(Sensor.Value); }
    }

    public string ValueToString(float? value)
    {
        if (value.HasValue)
        {
            switch (Sensor.SensorType)
            {
                case SensorType.Temperature when _unitManager.TemperatureUnit == TemperatureUnit.Fahrenheit:
                    {
                        return $"{value * 1.8 + 32:F1} °F";
                    }
                case SensorType.Throughput:
                    {
                        string result;
                        switch (Sensor.Name)
                        {
                            case "Connection Speed":
                                {
                                    switch (value)
                                    {
                                        case 100000000:
                                            {
                                                result = "100Mbps";
                                                break;
                                            }
                                        case 1000000000:
                                            {
                                                result = "1Gbps";
                                                break;
                                            }
                                        default:
                                            {
                                                if (value < 1024)
                                                    result = $"{value:F0} bps";
                                                else if (value < 1048576)
                                                    result = $"{value / 1024:F1} Kbps";
                                                else if (value < 1073741824)
                                                    result = $"{value / 1048576:F1} Mbps";
                                                else
                                                    result = $"{value / 1073741824:F1} Gbps";
                                            }

                                            break;
                                    }

                                    break;
                                }
                            default:
                                {
                                    const int _1MB = 1048576;

                                    result = value < _1MB ? $"{value / 1024:F1} KB/s" : $"{value / _1MB:F1} MB/s";

                                    break;
                                }
                        }

                        return result;
                    }
                case SensorType.TimeSpan:
                    {
                        return value.HasValue ? string.Format(Format, TimeSpan.FromSeconds(value.Value)) : "-";
                    }
                default:
                    {
                        return string.Format(Format, value);
                    }
            }
        }

        return "-";
    }

    private void OptionallyAppendCriticalRange(StringBuilder str, float? min, float? max, string kind)
    {
        if (min.HasValue)
        {
            str.AppendLine(max.HasValue
                               ? $"{CultureInfo.CurrentUICulture.TextInfo.ToTitleCase(kind)} range: {ValueToString(min)} to {ValueToString(max)}."
                               : $"Minimal {kind} value: {ValueToString(min)}.");
        }
        else if (max.HasValue)
        {
            str.AppendLine($"Maximal {kind} value: {ValueToString(max)}.");
        }
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;

        if (!(obj is SensorNode s))
            return false;


        return (Sensor == s.Sensor);
    }

    public override int GetHashCode()
    {
        return Sensor.GetHashCode();
    }
}
```

`LibreHardwareMonitor/UI/SensorNotifyIcon.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Drawing.Text;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public class SensorNotifyIcon : IDisposable
{
    private readonly UnitManager _unitManager;
    private readonly NotifyIconAdv _notifyIcon;
    private readonly Bitmap _bitmap;
    private readonly Graphics _graphics;
    private Color _color;
    private Color _darkColor;
    private Brush _brush;
    private Brush _darkBrush;
    private readonly Pen _pen;
    private readonly Font _font;
    private readonly Font _smallFont;

    public SensorNotifyIcon(SystemTray sensorSystemTray, ISensor sensor, PersistentSettings settings, UnitManager unitManager)
    {
        _unitManager = unitManager;
        Sensor = sensor;
        _notifyIcon = new NotifyIconAdv();

        Color defaultColor = Color.White;
        if (sensor.SensorType == SensorType.Load || sensor.SensorType == SensorType.Control || sensor.SensorType == SensorType.Level)
            defaultColor = Color.FromArgb(0xff, 0x70, 0x8c, 0xf1);

        Color = settings.GetValue(new Identifier(sensor.Identifier, "traycolor").ToString(), defaultColor);

        _pen = new Pen(Color.FromArgb(96, Color.Black));
        ContextMenuStrip contextMenuStrip = new ContextMenuStrip();
        ToolStripItem hideShowItem = new ToolStripMenuItem("Hide/Show");
        hideShowItem.Click += delegate
        {
            sensorSystemTray.SendHideShowCommand();
        };
        contextMenuStrip.Items.Add(hideShowItem);
        contextMenuStrip.Items.Add(new ToolStripSeparator());
        ToolStripItem removeItem = new ToolStripMenuItem("Remove Sensor");
        removeItem.Click += delegate
        {
            sensorSystemTray.Remove(Sensor);
        };
        contextMenuStrip.Items.Add(removeItem);
        ToolStripItem colorItem = new ToolStripMenuItem("Change Color...");
        colorItem.Click += delegate
        {
            ColorDialog dialog = new ColorDialog { Color = Color };
            if (dialog.ShowDialog() == DialogResult.OK)
            {
                Color = dialog.Color;
                settings.SetValue(new Identifier(sensor.Identifier,
                                                 "traycolor").ToString(), Color);
            }
        };
        contextMenuStrip.Items.Add(colorItem);
        contextMenuStrip.Items.Add(new ToolStripSeparator());
        ToolStripItem exitItem = new ToolStripMenuItem("Exit");
        exitItem.Click += delegate
        {
            sensorSystemTray.SendExitCommand();
        };
        contextMenuStrip.Items.Add(exitItem);
        _notifyIcon.ContextMenuStrip = contextMenuStrip;
        _notifyIcon.DoubleClick += delegate
        {
            sensorSystemTray.SendHideShowCommand();
        };

        // get the default dpi to create an icon with the correct size
        float dpiX, dpiY;
        using (Bitmap b = new Bitmap(1, 1, PixelFormat.Format32bppArgb))
        {
            dpiX = b.HorizontalResolution;
            dpiY = b.VerticalResolution;
        }

        // adjust the size of the icon to current dpi (default is 16x16 at 96 dpi)
        int width = (int)Math.Round(16 * dpiX / 96);
        int height = (int)Math.Round(16 * dpiY / 96);

        // make sure it does never get smaller than 16x16
        width = width < 16 ? 16 : width;
        height = height < 16 ? 16 : height;

        // adjust the font size to the icon size
        FontFamily family = SystemFonts.MessageBoxFont.FontFamily;
        float baseSize;
        switch (family.Name)
        {
            case "Segoe UI": baseSize = 12; break;
            case "Tahoma": baseSize = 11; break;
            default: baseSize = 12; break;
        }

        _font = new Font(family, baseSize * width / 16.0f, GraphicsUnit.Pixel);
        _smallFont = new Font(family, 0.75f * baseSize * width / 16.0f, GraphicsUnit.Pixel);

        _bitmap = new Bitmap(width, height, PixelFormat.Format32bppArgb);
        _graphics = Graphics.FromImage(_bitmap);
        if (Environment.OSVersion.Version.Major > 5)
        {
            _graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            _graphics.SmoothingMode = SmoothingMode.HighQuality;
        }
    }

    public ISensor Sensor { get; }

    public Color Color
    {
        get { return _color; }
        set
        {
            _color = value;
            _darkColor = Color.FromArgb(255, _color.R / 3, _color.G / 3, _color.B / 3);
            Brush brush = _brush;
            _brush = new SolidBrush(_color);
            brush?.Dispose();
            Brush darkBrush = _darkBrush;
            _darkBrush = new SolidBrush(_darkColor);
            darkBrush?.Dispose();
        }
    }

    public void Dispose()
    {
        Icon icon = _notifyIcon.Icon;
        _notifyIcon.Icon = null;
        icon?.Destroy();
        _notifyIcon.Dispose();

        _brush?.Dispose();
        _darkBrush?.Dispose();
        _pen.Dispose();
        _graphics.Dispose();
        _bitmap.Dispose();
        _font.Dispose();
        _smallFont.Dispose();
    }

    private string GetString()
    {
        if (!Sensor.Value.HasValue)
            return "-";

        switch (Sensor.SensorType)
        {
            case SensorType.Temperature:
                return _unitManager.TemperatureUnit == TemperatureUnit.Fahrenheit ? $"{UnitManager.CelsiusToFahrenheit(Sensor.Value):F0}" : $"{Sensor.Value:F0}";
            case SensorType.TimeSpan:
                return $"{TimeSpan.FromSeconds(Sensor.Value.Value):g}";
            case SensorType.Clock:
            case SensorType.Fan:
            case SensorType.Flow:
                return $"{1e-3f * Sensor.Value:F1}";
            case SensorType.Voltage:
            case SensorType.Current:
            case SensorType.SmallData:
            case SensorType.Factor:
            case SensorType.Throughput:
                return $"{Sensor.Value:F1}";
            case SensorType.Control:
            case SensorType.Frequency:
            case SensorType.Level:
            case SensorType.Power:
            case SensorType.Data:
            case SensorType.Load:
            case SensorType.Energy:
            case SensorType.Noise:
                return $"{Sensor.Value:F0}";
            default:
                return "-";
        }
    }

    private Icon CreateTransparentIcon()
    {
        string text = GetString();
        int count = 0;
        for (int i = 0; i < text.Length; i++)
            if ((text[i] >= '0' && text[i] <= '9') || text[i] == '-')
                count++;
        bool small = count > 2;

        _graphics.Clear(Color.Transparent);
        Rectangle bounds = new Rectangle(Point.Empty, _bitmap.Size);
        TextRenderer.DrawText(_graphics, text, small ? _smallFont : _font, bounds, _color, Color.Transparent, TextFormatFlags.HorizontalCenter | TextFormatFlags.VerticalCenter);

        return IconFactory.Create(_bitmap);
    }

    private Icon CreatePercentageIcon()
    {
        try
        {
            _graphics.Clear(Color.Transparent);
        }
        catch (ArgumentException)
        {
            _graphics.Clear(Color.Black);
        }
        _graphics.FillRectangle(_darkBrush, 0.5f, -0.5f, _bitmap.Width - 2, _bitmap.Height);
        float value = Sensor.Value.GetValueOrDefault();
        float y = (float)(_bitmap.Height * 0.01f) * (100 - value);
        _graphics.FillRectangle(_brush, 0.5f, -0.5f + y, _bitmap.Width - 2, _bitmap.Height - y);
        _graphics.DrawRectangle(_pen, 1, 0, _bitmap.Width - 3, _bitmap.Height - 1);

        return IconFactory.Create(_bitmap);
    }

    public void Update()
    {
        Icon icon = _notifyIcon.Icon;

        switch (Sensor.SensorType)
        {
            case SensorType.Load:
            case SensorType.Control:
            case SensorType.Level:
                _notifyIcon.Icon = CreatePercentageIcon();
                break;
            default:
                _notifyIcon.Icon = CreateTransparentIcon();
                break;
        }

        icon?.Destroy();

        string format = "";
        switch (Sensor.SensorType)
        {
            case SensorType.Voltage: format = "\n{0}: {1:F2} V"; break;
            case SensorType.Current: format = "\n{0}: {1:F2} A"; break;
            case SensorType.Clock: format = "\n{0}: {1:F0} MHz"; break;
            case SensorType.Load: format = "\n{0}: {1:F1} %"; break;
            case SensorType.Temperature: format = "\n{0}: {1:F1} °C"; break;
            case SensorType.Fan: format = "\n{0}: {1:F0} RPM"; break;
            case SensorType.Flow: format = "\n{0}: {1:F0} L/h"; break;
            case SensorType.Control: format = "\n{0}: {1:F1} %"; break;
            case SensorType.Level: format = "\n{0}: {1:F1} %"; break;
            case SensorType.Power: format = "\n{0}: {1:F0} W"; break;
            case SensorType.Data: format = "\n{0}: {1:F0} GB"; break;
            case SensorType.Factor: format = "\n{0}: {1:F3} GB"; break;
            case SensorType.Energy: format = "\n{0}: {0:F0} mWh"; break;
            case SensorType.Noise: format = "\n{0}: {0:F0} dBA"; break;
        }
        string formattedValue = string.Format(format, Sensor.Name, Sensor.Value);

        if (Sensor.SensorType == SensorType.Temperature && _unitManager.TemperatureUnit == TemperatureUnit.Fahrenheit)
        {
            format = "\n{0}: {1:F1} °F";
            formattedValue = string.Format(format, Sensor.Name, UnitManager.CelsiusToFahrenheit(Sensor.Value));
        }

        string hardwareName = Sensor.Hardware.Name;
        hardwareName = hardwareName.Substring(0, Math.Min(63 - formattedValue.Length, hardwareName.Length));
        string text = hardwareName + formattedValue;
        if (text.Length > 63)
            text = null;

        _notifyIcon.Text = text;
        _notifyIcon.Visible = true;
    }
}
```

`LibreHardwareMonitor/UI/ShowDesktop.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI;

public class ShowDesktop : IDisposable
{
    private readonly NativeWindow _referenceWindow;
    private readonly string _referenceWindowCaption = "LibreHardwareMonitorShowDesktopReferenceWindow";
    private readonly System.Threading.Timer _timer;
    private bool _showDesktop;

    /// <summary>
    /// Prevents a default instance of the <see cref="ShowDesktop" /> class from being created.
    /// </summary>
    private ShowDesktop()
    {
        // Create a reference window to detect show desktop
        _referenceWindow = new NativeWindow();

        CreateParams cp = new CreateParams { ExStyle = GadgetWindow.WS_EX_TOOLWINDOW, Caption = _referenceWindowCaption };
        _referenceWindow.CreateHandle(cp);
        NativeMethods.SetWindowPos(_referenceWindow.Handle,
                                   GadgetWindow.HWND_BOTTOM,
                                   0,
                                   0,
                                   0,
                                   0,
                                   GadgetWindow.SWP_NOMOVE |
                                   GadgetWindow.SWP_NOSIZE |
                                   GadgetWindow.SWP_NOACTIVATE |
                                   GadgetWindow.SWP_NOSENDCHANGING);

        // start a repeated timer to detect "Show Desktop" events
        _timer = new System.Threading.Timer(OnTimer, null, System.Threading.Timeout.Infinite, System.Threading.Timeout.Infinite);
    }

    public delegate void ShowDesktopChangedEventHandler(bool showDesktop);

    private event ShowDesktopChangedEventHandler ShowDesktopChangedEvent;

    // notify when the "show desktop" mode is changed
    public event ShowDesktopChangedEventHandler ShowDesktopChanged
    {
        add
        {
            // start the monitor timer when someone is listening
            if (ShowDesktopChangedEvent == null)
                StartTimer();

            ShowDesktopChangedEvent += value;
        }
        remove
        {
            ShowDesktopChangedEvent -= value;
            // stop the monitor timer if nobody is interested
            if (ShowDesktopChangedEvent == null)
                StopTimer();
        }
    }

    public static ShowDesktop Instance { get; } = new ShowDesktop();

    /// <inheritdoc />
    public void Dispose()
    {
        _timer?.Dispose();
        _referenceWindow.ReleaseHandle();
    }

    private void StartTimer()
    {
        _timer.Change(0, 200);
    }

    private void StopTimer()
    {
        _timer.Change(System.Threading.Timeout.Infinite, System.Threading.Timeout.Infinite);
    }

    // the desktop worker window (if available) can hide the reference window
    private IntPtr GetDesktopWorkerWindow()
    {
        IntPtr shellWindow = NativeMethods.GetShellWindow();
        if (shellWindow == IntPtr.Zero)
            return IntPtr.Zero;


        NativeMethods.GetWindowThreadProcessId(shellWindow, out int shellId);

        IntPtr workerWindow = IntPtr.Zero;
        while ((workerWindow = NativeMethods.FindWindowEx(IntPtr.Zero, workerWindow, "WorkerW", null)) != IntPtr.Zero)
        {
            NativeMethods.GetWindowThreadProcessId(workerWindow, out int workerId);
            if (workerId == shellId)
            {
                IntPtr window = NativeMethods.FindWindowEx(workerWindow, IntPtr.Zero, "SHELLDLL_DefView", null);
                if (window != IntPtr.Zero)
                {
                    IntPtr desktopWindow = NativeMethods.FindWindowEx(window, IntPtr.Zero, "SysListView32", null);
                    if (desktopWindow != IntPtr.Zero)
                        return workerWindow;
                }
            }
        }

        return IntPtr.Zero;
    }

    private void OnTimer(object state)
    {
        bool showDesktopDetected;

        IntPtr workerWindow = GetDesktopWorkerWindow();
        if (workerWindow != IntPtr.Zero)
        {
            // search if the reference window is behind the worker window
            IntPtr reference = NativeMethods.FindWindowEx(IntPtr.Zero, workerWindow, null, _referenceWindowCaption);
            showDesktopDetected = reference != IntPtr.Zero;
        }
        else
        {
            // if there is no worker window, then nothing can hide the reference
            showDesktopDetected = false;
        }

        if (_showDesktop != showDesktopDetected)
        {
            _showDesktop = showDesktopDetected;
            ShowDesktopChangedEvent?.Invoke(_showDesktop);
        }
    }

    private static class NativeMethods
    {
        private const string USER = "user32.dll";

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern IntPtr GetShellWindow();

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern int GetWindowThreadProcessId(IntPtr hWnd, out int processId);
    }
}
```

`LibreHardwareMonitor/UI/SplitContainerAdv.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Drawing;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI;

public class SplitContainerAdv : SplitContainer
{
    private int _delta;
    private Border3DStyle _border3DStyle = Border3DStyle.Raised;
    private Color _bgColor = SystemColors.Control;

    public SplitContainerAdv()
    {
        SetStyle(ControlStyles.ResizeRedraw, true);
        SetStyle(ControlStyles.AllPaintingInWmPaint, true);
        SetStyle(ControlStyles.UserPaint, true);
        SetStyle(ControlStyles.OptimizedDoubleBuffer, true);
        SetStyle(ControlStyles.ContainerControl, true);
        UpdateStyles();
    }

    protected override void OnPaint(PaintEventArgs e)
    {
        base.OnPaint(e);
        Graphics g = e.Graphics;
        Rectangle r = SplitterRectangle;

        using (SolidBrush brush = new SolidBrush(_bgColor))
            g.FillRectangle(brush, r);

        ControlPaint.DrawBorder3D(g, r, _border3DStyle);
    }

    protected override void OnKeyDown(KeyEventArgs e)
    {
        if (!IsSplitterFixed)
        {
            switch (e.KeyData)
            {
                case Keys.Right:
                case Keys.Down:
                    SplitterDistance += SplitterIncrement;
                    break;
                case Keys.Left:
                case Keys.Up:
                    SplitterDistance -= SplitterIncrement;
                    break;
            }

            Invalidate();
        }
    }

    protected override void OnMouseDown(MouseEventArgs e)
    {
        if (Orientation == Orientation.Vertical)
        {
            _delta = SplitterDistance - e.X;
            Cursor.Current = Cursors.VSplit;
        }
        else
        {
            _delta = SplitterDistance - e.Y;
            Cursor.Current = Cursors.HSplit;
        }
        IsSplitterFixed = true;
    }

    protected override void OnMouseMove(MouseEventArgs e)
    {
        if (IsSplitterFixed)
        {
            if (e.Button == MouseButtons.Left)
            {
                if (Orientation == Orientation.Vertical)
                {
                    if (e.X > 0 && e.X < Width)
                        SplitterDistance = e.X + _delta < 0 ? 0 : e.X + _delta;
                }
                else
                {
                    if (e.Y > 0 && e.Y < Height)
                        SplitterDistance = e.Y + _delta < 0 ? 0 : e.Y + _delta;
                }
            }
            else
            {
                IsSplitterFixed = false;
            }
            Invalidate();
        }
        else
        {
            if (SplitterRectangle.Contains(e.Location))
                Cursor = Orientation == Orientation.Vertical ? Cursors.VSplit : Cursors.HSplit;
        }
    }

    protected override void OnMouseLeave(EventArgs e)
    {
        base.OnMouseLeave(e);
        Cursor = Cursors.Default;
    }

    protected override void OnMouseUp(MouseEventArgs e)
    {
        _delta = 0;
        IsSplitterFixed = false;
        Cursor.Current = Cursors.Default;
    }

    public Border3DStyle Border3DStyle
    {
        get { return _border3DStyle; }
        set
        {
            _border3DStyle = value;
            Invalidate(false);
        }
    }

    public Color Color
    {
        get { return _bgColor; }
        set
        {
            _bgColor = value;
            Invalidate(false);
        }
    }
}
```

`LibreHardwareMonitor/UI/StartupManager.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.IO;
using System.Linq;
using System.Security;
using System.Security.Principal;
using System.Windows.Forms;
using Microsoft.Win32;
using Microsoft.Win32.TaskScheduler;
using Action = Microsoft.Win32.TaskScheduler.Action;

namespace LibreHardwareMonitor.UI;

public class StartupManager
{
    private const string RegistryPath = @"Software\Microsoft\Windows\CurrentVersion\Run";
    private bool _startup;

    public StartupManager()
    {
        if (Environment.OSVersion.Platform >= PlatformID.Unix)
        {
            IsAvailable = false;
            return;
        }

        if (IsAdministrator() && TaskService.Instance.Connected)
        {
            IsAvailable = true;

            Task task = GetTask();
            if (task != null)
            {
                foreach (Action action in task.Definition.Actions)
                {
                    if (action.ActionType == TaskActionType.Execute && action is ExecAction execAction)
                    {
                        if (execAction.Path.Equals(Application.ExecutablePath, StringComparison.OrdinalIgnoreCase))
                            _startup = true;
                    }
                }
            }
        }
        else
        {
            try
            {
                using (RegistryKey registryKey = Registry.CurrentUser.OpenSubKey(RegistryPath))
                {
                    string value = (string)registryKey?.GetValue(nameof(LibreHardwareMonitor));

                    if (value != null)
                        _startup = value == Application.ExecutablePath;
                }

                IsAvailable = true;
            }
            catch (SecurityException)
            {
                IsAvailable = false;
            }
        }
    }

    public bool IsAvailable { get; }

    public bool Startup
    {
        get { return _startup; }
        set
        {
            if (_startup != value)
            {
                if (IsAvailable)
                {
                    if (TaskService.Instance.Connected)
                    {
                        if (value)
                            CreateTask();
                        else
                            DeleteTask();

                        _startup = value;
                    }
                    else
                    {
                        try
                        {
                            if (value)
                                CreateRegistryKey();
                            else
                                DeleteRegistryKey();

                            _startup = value;
                        }
                        catch (UnauthorizedAccessException)
                        {
                            throw new InvalidOperationException();
                        }
                    }
                }
                else
                {
                    throw new InvalidOperationException();
                }
            }
        }
    }

    private static bool IsAdministrator()
    {
        try
        {
            WindowsIdentity identity = WindowsIdentity.GetCurrent();
            WindowsPrincipal principal = new WindowsPrincipal(identity);

            return principal.IsInRole(WindowsBuiltInRole.Administrator);
        }
        catch
        {
            return false;
        }
    }

    private static Task GetTask()
    {
        try
        {
            return TaskService.Instance.AllTasks.FirstOrDefault(x => x.Name.Equals(nameof(LibreHardwareMonitor), StringComparison.OrdinalIgnoreCase));
        }
        catch
        {
            return null;
        }
    }

    private void CreateTask()
    {
        TaskDefinition taskDefinition = TaskService.Instance.NewTask();
        taskDefinition.RegistrationInfo.Description = "Starts LibreHardwareMonitor on Windows startup.";

        taskDefinition.Triggers.Add(new LogonTrigger());

        taskDefinition.Settings.StartWhenAvailable = true;
        taskDefinition.Settings.DisallowStartIfOnBatteries = false;
        taskDefinition.Settings.StopIfGoingOnBatteries = false;
        taskDefinition.Settings.ExecutionTimeLimit = TimeSpan.Zero;
        taskDefinition.Settings.AllowHardTerminate = false;

        taskDefinition.Principal.RunLevel = TaskRunLevel.Highest;
        taskDefinition.Principal.LogonType = TaskLogonType.InteractiveToken;

        taskDefinition.Actions.Add(new ExecAction(Application.ExecutablePath, "", Path.GetDirectoryName(Application.ExecutablePath)));

        TaskService.Instance.RootFolder.RegisterTaskDefinition(nameof(LibreHardwareMonitor), taskDefinition);
    }

    private static void DeleteTask()
    {
        Task task = GetTask();
        task?.Folder.DeleteTask(task.Name, false);
    }

    private static void CreateRegistryKey()
    {
        RegistryKey registryKey = Registry.CurrentUser.CreateSubKey(RegistryPath);
        registryKey?.SetValue(nameof(LibreHardwareMonitor), Application.ExecutablePath);
    }

    private static void DeleteRegistryKey()
    {
        RegistryKey registryKey = Registry.CurrentUser.CreateSubKey(RegistryPath);
        registryKey?.DeleteValue(nameof(LibreHardwareMonitor));
    }
}
```

`LibreHardwareMonitor/UI/SystemTray.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Windows.Forms;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public class SystemTray : IDisposable
{
    private IComputer _computer;
    private readonly PersistentSettings _settings;
    private readonly UnitManager _unitManager;
    private readonly List<SensorNotifyIcon> _sensorList = new List<SensorNotifyIcon>();
    private bool _mainIconEnabled;
    private readonly NotifyIconAdv _mainIcon;

    public SystemTray(IComputer computer, PersistentSettings settings, UnitManager unitManager)
    {
        _computer = computer;
        _settings = settings;
        _unitManager = unitManager;
        computer.HardwareAdded += HardwareAdded;
        computer.HardwareRemoved += HardwareRemoved;

        _mainIcon = new NotifyIconAdv();

        ContextMenuStrip contextMenuStrip = new ContextMenuStrip();
        ToolStripItem hideShowItem = new ToolStripMenuItem("Hide/Show");
        hideShowItem.Click += delegate
        {
            SendHideShowCommand();
        };
        contextMenuStrip.Items.Add(hideShowItem);
        contextMenuStrip.Items.Add(new ToolStripSeparator());
        ToolStripItem exitItem = new ToolStripMenuItem("Exit");
        exitItem.Click += delegate
        {
            SendExitCommand();
        };
        contextMenuStrip.Items.Add(exitItem);
        _mainIcon.ContextMenuStrip = contextMenuStrip;
        _mainIcon.DoubleClick += delegate
        {
            SendHideShowCommand();
        };
        _mainIcon.Icon = EmbeddedResources.GetIcon("smallicon.ico");
        _mainIcon.Text = "Libre Hardware Monitor";
    }

    private void HardwareRemoved(IHardware hardware)
    {
        hardware.SensorAdded -= SensorAdded;
        hardware.SensorRemoved -= SensorRemoved;

        foreach (ISensor sensor in hardware.Sensors)
            SensorRemoved(sensor);

        foreach (IHardware subHardware in hardware.SubHardware)
            HardwareRemoved(subHardware);
    }

    private void HardwareAdded(IHardware hardware)
    {
        foreach (ISensor sensor in hardware.Sensors)
            SensorAdded(sensor);

        hardware.SensorAdded += SensorAdded;
        hardware.SensorRemoved += SensorRemoved;

        foreach (IHardware subHardware in hardware.SubHardware)
            HardwareAdded(subHardware);
    }

    private void SensorAdded(ISensor sensor)
    {
        if (_settings.GetValue(new Identifier(sensor.Identifier, "tray").ToString(), false))
            Add(sensor, false);
    }

    private void SensorRemoved(ISensor sensor)
    {
        if (Contains(sensor))
            Remove(sensor, false);
    }

    public void Dispose()
    {
        foreach (SensorNotifyIcon icon in _sensorList)
            icon.Dispose();
        _mainIcon.Dispose();
    }

    public void Redraw()
    {
        foreach (SensorNotifyIcon icon in _sensorList)
            icon.Update();
    }

    public bool Contains(ISensor sensor)
    {
        foreach (SensorNotifyIcon icon in _sensorList)
            if (icon.Sensor == sensor)
                return true;
        return false;
    }

    public void Add(ISensor sensor, bool balloonTip)
    {
        if (Contains(sensor))
            return;


        _sensorList.Add(new SensorNotifyIcon(this, sensor, _settings, _unitManager));
        UpdateMainIconVisibility();
        _settings.SetValue(new Identifier(sensor.Identifier, "tray").ToString(), true);
    }

    public void Remove(ISensor sensor)
    {
        Remove(sensor, true);
    }

    private void Remove(ISensor sensor, bool deleteConfig)
    {
        if (deleteConfig)
        {
            _settings.Remove(new Identifier(sensor.Identifier, "tray").ToString());
            _settings.Remove(new Identifier(sensor.Identifier, "traycolor").ToString());
        }
        SensorNotifyIcon instance = null;
        foreach (SensorNotifyIcon icon in _sensorList)
        {
            if (icon.Sensor == sensor)
                instance = icon;
        }
        if (instance != null)
        {
            _sensorList.Remove(instance);
            UpdateMainIconVisibility();
            instance.Dispose();
        }
    }

    public event EventHandler HideShowCommand;

    public void SendHideShowCommand()
    {
        HideShowCommand?.Invoke(this, null);
    }

    public event EventHandler ExitCommand;

    public void SendExitCommand()
    {
        ExitCommand?.Invoke(this, null);
    }

    private void UpdateMainIconVisibility()
    {
        if (_mainIconEnabled)
            _mainIcon.Visible = _sensorList.Count == 0;
        else
            _mainIcon.Visible = false;
    }

    public bool IsMainIconEnabled
    {
        get { return _mainIconEnabled; }
        set
        {
            if (_mainIconEnabled != value)
            {
                _mainIconEnabled = value;
                UpdateMainIconVisibility();
            }
        }
    }
}
```

`LibreHardwareMonitor/UI/ToolStripRadioButtonMenuItem.cs`:

```cs
using System;
using System.Drawing;
using System.Windows.Forms;
using System.Windows.Forms.VisualStyles;

namespace LibreHardwareMonitor.UI;

/// <summary>
/// https://docs.microsoft.com/en-us/dotnet/desktop/winforms/controls/how-to-display-option-buttons-in-a-menustrip-windows-forms
/// </summary>
public class ToolStripRadioButtonMenuItem : ToolStripMenuItem
{
    public ToolStripRadioButtonMenuItem()
        : base()
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(string text)
        : base(text, null, (EventHandler)null)
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(Image image)
        : base(null, image, (EventHandler)null)
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(string text, Image image)
        : base(text, image, (EventHandler)null)
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(string text, Image image,
        EventHandler onClick)
        : base(text, image, onClick)
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(string text, Image image,
        EventHandler onClick, string name)
        : base(text, image, onClick, name)
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(string text, Image image,
        params ToolStripItem[] dropDownItems)
        : base(text, image, dropDownItems)
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(string text, Image image,
        EventHandler onClick, Keys shortcutKeys)
        : base(text, image, onClick)
    {
        Initialize();
        ShortcutKeys = shortcutKeys;
    }

    // Called by all constructors to initialize CheckOnClick.
    private void Initialize()
    {
        CheckOnClick = true;
    }

    protected override void OnCheckedChanged(EventArgs e)
    {
        base.OnCheckedChanged(e);

        // If this item is no longer in the checked state or if its
        // parent has not yet been initialized, do nothing.
        if (!Checked || Parent == null) return;

        // Clear the checked state for all siblings.
        foreach (ToolStripItem item in Parent.Items)
        {
            if (item is ToolStripRadioButtonMenuItem radioItem
             && radioItem != this
             && radioItem.Checked)
            {
                radioItem.Checked = false;

                // Only one item can be selected at a time,
                // so there is no need to continue.
                return;
            }
        }
    }

    protected override void OnClick(EventArgs e)
    {
        // If the item is already in the checked state, do not call
        // the base method, which would toggle the value.
        if (Checked) return;

        base.OnClick(e);
    }

    // Let the item paint itself, and then paint the RadioButton
    // where the check mark is normally displayed.
    protected override void OnPaint(PaintEventArgs e)
    {
        if (Image != null)
        {
            // If the client sets the Image property, the selection behavior
            // remains unchanged, but the RadioButton is not displayed and the
            // selection is indicated only by the selection rectangle.
            base.OnPaint(e);
            return;
        }
        else
        {
            // If the Image property is not set, call the base OnPaint method
            // with the CheckState property temporarily cleared to prevent
            // the check mark from being painted.
            CheckState currentState = CheckState;
            CheckState = CheckState.Unchecked;
            base.OnPaint(e);
            CheckState = currentState;
        }

        // Determine the correct state of the RadioButton.
        RadioButtonState buttonState = RadioButtonState.UncheckedNormal;
        if (Enabled)
        {
            if (mouseDownState)
            {
                if (Checked)
                    buttonState = RadioButtonState.CheckedPressed;
                else
                    buttonState = RadioButtonState.UncheckedPressed;
            }
            else if (mouseHoverState)
            {
                if (Checked) 
                    buttonState = RadioButtonState.CheckedHot;
                else
                    buttonState = RadioButtonState.UncheckedHot;
            }
            else
            {
                if (Checked)
                    buttonState = RadioButtonState.CheckedNormal;
            }
        }
        else
        {
            if (Checked)
                buttonState = RadioButtonState.CheckedDisabled;
            else 
                buttonState = RadioButtonState.UncheckedDisabled;
        }

        // Calculate the position at which to display the RadioButton.
        int offset = (ContentRectangle.Height -
                      RadioButtonRenderer.GetGlyphSize(
                                                       e.Graphics, buttonState).Height) / 2;

        Point imageLocation = new Point(
                                        ContentRectangle.Location.X + 4,
                                        ContentRectangle.Location.Y + offset);

        // Paint the RadioButton.
        RadioButtonRenderer.DrawRadioButton(e.Graphics, imageLocation, buttonState);
    }

    private bool mouseHoverState;

    protected override void OnMouseEnter(EventArgs e)
    {
        mouseHoverState = true;

        // Force the item to repaint with the new RadioButton state.
        Invalidate();

        base.OnMouseEnter(e);
    }

    protected override void OnMouseLeave(EventArgs e)
    {
        mouseHoverState = false;
        base.OnMouseLeave(e);
    }

    private bool mouseDownState;

    protected override void OnMouseDown(MouseEventArgs e)
    {
        mouseDownState = true;

        // Force the item to repaint with the new RadioButton state.
        Invalidate();

        base.OnMouseDown(e);
    }

    protected override void OnMouseUp(MouseEventArgs e)
    {
        mouseDownState = false;
        base.OnMouseUp(e);
    }

    // Enable the item only if its parent item is in the checked state
    // and its Enabled property has not been explicitly set to false.
    public override bool Enabled
    {
        get
        {
            // Use the base value in design mode to prevent the designer
            // from setting the base value to the calculated value.
            if (!DesignMode
             && OwnerItem is ToolStripMenuItem ownerMenuItem
             && ownerMenuItem.CheckOnClick)
            {
                return base.Enabled && ownerMenuItem.Checked;
            }
            else
            {
                return base.Enabled;
            }
        }
        set
        {
            base.Enabled = value;
        }
    }

    // When OwnerItem becomes available, if it is a ToolStripMenuItem
    // with a CheckOnClick property value of true, subscribe to its
    // CheckedChanged event.
    protected override void OnOwnerChanged(EventArgs e)
    {
        if (OwnerItem is ToolStripMenuItem ownerMenuItem
         && ownerMenuItem.CheckOnClick)
        {
            ownerMenuItem.CheckedChanged +=
                new EventHandler(OwnerMenuItem_CheckedChanged);
        }
        base.OnOwnerChanged(e);
    }

    // When the checked state of the parent item changes,
    // repaint the item so that the new Enabled state is displayed.
    private void OwnerMenuItem_CheckedChanged(object sender, EventArgs e)
    {
        Invalidate();
    }
}
```

`LibreHardwareMonitor/UI/TreeModel.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Aga.Controls.Tree;

namespace LibreHardwareMonitor.UI;

public class TreeModel : ITreeModel
{
    private readonly Node _root;
    private bool _forceVisible;

    public TreeModel()
    {
        _root = new Node { Model = this };
    }

    public TreePath GetPath(Node node)
    {
        if (node == _root)
            return TreePath.Empty;


        Stack<object> stack = new Stack<object>();
        while (node != _root)
        {
            stack.Push(node);
            node = node.Parent;
        }
        return new TreePath(stack.ToArray());
    }

    public Collection<Node> Nodes
    {
        get { return _root.Nodes; }
    }

    private Node GetNode(TreePath treePath)
    {
        Node parent = _root;
        foreach (object obj in treePath.FullPath)
        {
            if (!(obj is Node node) || node.Parent != parent)
                return null;
            parent = node;
        }
        return parent;
    }

    public IEnumerable GetChildren(TreePath treePath)
    {
        Node node = GetNode(treePath);
        if (node != null)
        {
            return node.Nodes.Where(n => _forceVisible || n.IsVisible).ToList();
        }

        return Enumerable.Empty<Node>();
    }

    public bool IsLeaf(TreePath treePath)
    {
        return false;
    }

    public bool ForceVisible
    {
        get
        {
            return _forceVisible;
        }
        set
        {
            if (value != _forceVisible)
            {
                _forceVisible = value;
                OnStructureChanged(_root);
            }
        }
    }

#pragma warning disable 67
    public event EventHandler<TreeModelEventArgs> NodesChanged;
    public event EventHandler<TreePathEventArgs> StructureChanged;
    public event EventHandler<TreeModelEventArgs> NodesInserted;
    public event EventHandler<TreeModelEventArgs> NodesRemoved;
#pragma warning restore 67

    public void OnNodeChanged(Node parent, int index, Node node)
    {
        if (parent != null)
        {
            TreePath path = GetPath(parent);
            if (path != null)
                NodesChanged?.Invoke(this, new TreeModelEventArgs(path, new[] { index }, new object[] { node }));
        }
    }

    public void OnStructureChanged(Node node)
    {
        StructureChanged?.Invoke(this, new TreeModelEventArgs(GetPath(node), new object[0]));
    }

    public void OnNodeInserted(Node parent, int index, Node node)
    {
        TreeModelEventArgs args = new TreeModelEventArgs(GetPath(parent), new[] { index }, new object[] { node });
        NodesInserted?.Invoke(this, args);
    }

    public void OnNodeRemoved(Node parent, int index, Node node)
    {
        TreeModelEventArgs args = new TreeModelEventArgs(GetPath(parent), new[] { index }, new object[] { node });
        NodesRemoved?.Invoke(this, args);
    }

}

```

`LibreHardwareMonitor/UI/TypeNode.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public sealed class TypeNode : Node, IExpandPersistNode
{
    private readonly PersistentSettings _settings;
    private readonly string _expandedIdentifier;
    private bool _expanded;

    public TypeNode(SensorType sensorType, Identifier parentId, PersistentSettings settings)
    {
        SensorType = sensorType;
        _expandedIdentifier = new Identifier(parentId, SensorType.ToString(), ".expanded").ToString();
        _settings = settings;

        switch (sensorType)
        {
            case SensorType.Voltage:
                Image = Utilities.EmbeddedResources.GetImage("voltage.png");
                Text = "Voltages";
                break;
            case SensorType.Current:
                Image = Utilities.EmbeddedResources.GetImage("voltage.png");
                Text = "Currents";
                break;
            case SensorType.Energy:
                Image = Utilities.EmbeddedResources.GetImage("battery.png");
                Text = "Capacities";
                break;
            case SensorType.Clock:
                Image = Utilities.EmbeddedResources.GetImage("clock.png");
                Text = "Clocks";
                break;
            case SensorType.Load:
                Image = Utilities.EmbeddedResources.GetImage("load.png");
                Text = "Load";
                break;
            case SensorType.Temperature:
                Image = Utilities.EmbeddedResources.GetImage("temperature.png");
                Text = "Temperatures";
                break;
            case SensorType.Fan:
                Image = Utilities.EmbeddedResources.GetImage("fan.png");
                Text = "Fans";
                break;
            case SensorType.Flow:
                Image = Utilities.EmbeddedResources.GetImage("flow.png");
                Text = "Flows";
                break;
            case SensorType.Control:
                Image = Utilities.EmbeddedResources.GetImage("control.png");
                Text = "Controls";
                break;
            case SensorType.Level:
                Image = Utilities.EmbeddedResources.GetImage("level.png");
                Text = "Levels";
                break;
            case SensorType.Power:
                Image = Utilities.EmbeddedResources.GetImage("power.png");
                Text = "Powers";
                break;
            case SensorType.Data:
                Image = Utilities.EmbeddedResources.GetImage("data.png");
                Text = "Data";
                break;
            case SensorType.SmallData:
                Image = Utilities.EmbeddedResources.GetImage("data.png");
                Text = "Data";
                break;
            case SensorType.Factor:
                Image = Utilities.EmbeddedResources.GetImage("factor.png");
                Text = "Factors";
                break;
            case SensorType.Frequency:
                Image = Utilities.EmbeddedResources.GetImage("clock.png");
                Text = "Frequencies";
                break;
            case SensorType.Throughput:
                Image = Utilities.EmbeddedResources.GetImage("throughput.png");
                Text = "Throughput";
                break;
            case SensorType.TimeSpan:
                Image = Utilities.EmbeddedResources.GetImage("time.png");
                Text = "Times";
                break;
            case SensorType.Noise:
                Image = Utilities.EmbeddedResources.GetImage("loudspeaker.png");
                Text = "Noise Levels";
                break;
        }

        NodeAdded += TypeNode_NodeAdded;
        NodeRemoved += TypeNode_NodeRemoved;
        _expanded = settings.GetValue(_expandedIdentifier, true);
    }

    private void TypeNode_NodeRemoved(Node node)
    {
        node.IsVisibleChanged -= Node_IsVisibleChanged;
        Node_IsVisibleChanged(null);
    }

    private void TypeNode_NodeAdded(Node node)
    {
        node.IsVisibleChanged += Node_IsVisibleChanged;
        Node_IsVisibleChanged(null);
    }

    private void Node_IsVisibleChanged(Node node)
    {
        foreach (Node n in Nodes)
        {
            if (n.IsVisible)
            {
                IsVisible = true;
                return;
            }
        }
        IsVisible = false;
    }

    public SensorType SensorType { get; }

    public bool Expanded
    {
        get => _expanded;
        set
        {
            _expanded = value;
            _settings.SetValue(_expandedIdentifier, _expanded);
        }
    }
}
```

`LibreHardwareMonitor/UI/UnitManager.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public enum TemperatureUnit
{
    Celsius = 0,
    Fahrenheit = 1
}

public class UnitManager
{

    private readonly PersistentSettings _settings;
    private TemperatureUnit _temperatureUnit;

    public UnitManager(PersistentSettings settings)
    {
        _settings = settings;
        _temperatureUnit = (TemperatureUnit)settings.GetValue("TemperatureUnit", (int)TemperatureUnit.Celsius);
    }

    public TemperatureUnit TemperatureUnit
    {
        get { return _temperatureUnit; }
        set
        {
            _temperatureUnit = value;
            _settings.SetValue("TemperatureUnit", (int)_temperatureUnit);
        }
    }

    public static float? CelsiusToFahrenheit(float? valueInCelsius)
    {
        return valueInCelsius * 1.8f + 32;
    }
}
```

`LibreHardwareMonitor/UI/UpdateVisitor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.UI;

public class UpdateVisitor : IVisitor
{
    public void VisitComputer(IComputer computer)
    {
        computer.Traverse(this);
    }

    public void VisitHardware(IHardware hardware)
    {
        hardware.Update();
        foreach (IHardware subHardware in hardware.SubHardware)
            subHardware.Accept(this);
    }

    public void VisitSensor(ISensor sensor) { }

    public void VisitParameter(IParameter parameter) { }
}
```

`LibreHardwareMonitor/UI/UserOption.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Windows.Forms;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public class UserOption
{
    private readonly string _name;
    private bool _value;
    private readonly ToolStripMenuItem _menuItem;
    private event EventHandler _changed;
    private readonly PersistentSettings _settings;

    public UserOption(string name, bool value, ToolStripMenuItem menuItem, PersistentSettings settings)
    {
        _settings = settings;
        _name = name;
        _value = name != null ? settings.GetValue(name, value) : value;
        _menuItem = menuItem;
        _menuItem.Checked = _value;
        _menuItem.Click += MenuItem_Click;
    }

    private void MenuItem_Click(object sender, EventArgs e)
    {
        Value = !Value;
    }

    public bool Value
    {
        get { return _value; }
        set
        {
            if (_value != value)
            {
                _value = value;
                if (_name != null)
                    _settings.SetValue(_name, value);
                _menuItem.Checked = value;
                _changed?.Invoke(this, null);
            }
        }
    }

    public event EventHandler Changed
    {
        add
        {
            _changed += value;
            _changed?.Invoke(this, null);
        }
        remove
        {
            _changed -= value;
        }
    }
}
```

`LibreHardwareMonitor/UI/UserRadioGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Windows.Forms;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public class UserRadioGroup
{
    private readonly string _name;
    private int _value;
    private readonly ToolStripMenuItem[] _menuItems;
    private event EventHandler _changed;
    private readonly PersistentSettings _settings;

    public UserRadioGroup(string name, int value, ToolStripMenuItem[] menuItems, PersistentSettings settings)
    {
        _settings = settings;
        _name = name;
        _value = name != null ? settings.GetValue(name, value) : value;
        _menuItems = menuItems;
        _value = Math.Max(Math.Min(_value, menuItems.Length - 1), 0);

        for (int i = 0; i < _menuItems.Length; i++)
        {
            _menuItems[i].Checked = i == _value;
            int index = i;
            _menuItems[i].Click += delegate
            {
                Value = index;
            };
        }
    }

    public int Value
    {
        get { return _value; }
        set
        {
            if (_value != value)
            {
                _value = value;
                if (_name != null)
                    _settings.SetValue(_name, value);
                for (int i = 0; i < _menuItems.Length; i++)
                    _menuItems[i].Checked = i == value;
                _changed?.Invoke(this, null);
            }
        }
    }

    public event EventHandler Changed
    {
        add
        {
            _changed += value;
            _changed?.Invoke(this, null);
        }
        remove
        {
            _changed -= value;
        }
    }
}
```

`LibreHardwareMonitor/Utilities/EmbeddedResources.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Drawing;
using System.IO;
using System.Reflection;

namespace LibreHardwareMonitor.Utilities;

public class EmbeddedResources
{
    public static Image GetImage(string name)
    {
        name = "LibreHardwareMonitor.Resources." + name;
        string[] names = Assembly.GetExecutingAssembly().GetManifestResourceNames();

        for (int i = 0; i < names.Length; i++)
        {
            if (names[i].Replace('\\', '.') == name)
            {
                using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(names[i]))
                {
                    // "You must keep the stream open for the lifetime of the Image."
                    Image image = Image.FromStream(stream);

                    // so we just create a copy of the image
                    Bitmap bitmap = new Bitmap(image);

                    // and dispose it right here
                    image.Dispose();

                    return bitmap;
                }
            }
        }
        return new Bitmap(1, 1);
    }

    public static Icon GetIcon(string name)
    {
        name = "LibreHardwareMonitor.Resources." + name;
        string[] names = Assembly.GetExecutingAssembly().GetManifestResourceNames();
        for (int i = 0; i < names.Length; i++)
        {
            if (names[i].Replace('\\', '.') == name)
            {
                using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(names[i]))
                {
                    return new Icon(stream);
                }
            }
        }
        return null;
    }

}
```

`LibreHardwareMonitor/Utilities/HttpServer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Web;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.UI;
using Newtonsoft.Json.Linq;

namespace LibreHardwareMonitor.Utilities;

public class HttpServer
{
    private readonly HttpListener _listener;
    private readonly Node _root;
    private Thread _listenerThread;

    public HttpServer(Node node, int port, bool authEnabled = false, string userName = "", string password = "")
    {
        _root = node;
        ListenerPort = port;
        AuthEnabled = authEnabled;
        UserName = userName;
        Password = password;

        try
        {
            _listener = new HttpListener { IgnoreWriteExceptions = true };
        }
        catch (PlatformNotSupportedException)
        {
            _listener = null;
        }
    }

    ~HttpServer()
    {
        if (PlatformNotSupported)
            return;


        StopHttpListener();
        _listener.Abort();
    }

    public bool AuthEnabled { get; set; }

    public int ListenerPort { get; set; }

    public string Password
    {
        get { return PasswordSHA256; }
        set { PasswordSHA256 = ComputeSHA256(value); }
    }

    public bool PlatformNotSupported
    {
        get { return _listener == null; }
    }

    public string UserName { get; set; }

    private string PasswordSHA256 { get; set; }

    public bool StartHttpListener()
    {
        if (PlatformNotSupported)
            return false;


        try
        {
            if (_listener.IsListening)
                return true;


            string prefix = "http://+:" + ListenerPort + "/";
            _listener.Prefixes.Clear();
            _listener.Prefixes.Add(prefix);
            _listener.Realm = "Libre Hardware Monitor";
            _listener.AuthenticationSchemes = AuthEnabled ? AuthenticationSchemes.Basic : AuthenticationSchemes.Anonymous;
            _listener.Start();

            if (_listenerThread == null)
            {
                _listenerThread = new Thread(HandleRequests);
                _listenerThread.Start();
            }
        }
        catch (Exception)
        {
            return false;
        }

        return true;
    }

    public bool StopHttpListener()
    {
        if (PlatformNotSupported)
            return false;


        try
        {
            _listenerThread?.Abort();
            _listener.Stop();
            _listenerThread = null;
        }
        catch (HttpListenerException)
        { }
        catch (ThreadAbortException)
        { }
        catch (NullReferenceException)
        { }
        catch (Exception)
        { }

        return true;
    }

    private void HandleRequests()
    {
        while (_listener.IsListening)
        {
            IAsyncResult context = _listener.BeginGetContext(ListenerCallback, _listener);
            context.AsyncWaitHandle.WaitOne();
        }
    }

    public static IDictionary<string, string> ToDictionary(NameValueCollection col)
    {
        IDictionary<string, string> dict = new Dictionary<string, string>();
        foreach (string k in col.AllKeys)
        {
            dict.Add(k, col[k]);
        }

        return dict;
    }

    public SensorNode FindSensor(Node node, string id)
    {
        if (node is SensorNode sNode)
        {
            if (sNode.Sensor.Identifier.ToString() == id)
                return sNode;
        }

        foreach (Node child in node.Nodes)
        {
            SensorNode s = FindSensor(child, id);
            if (s != null)
            {
                return s;
            }
        }

        return null;
    }

    public void SetSensorControlValue(SensorNode sNode, string value)
    {
        if (sNode.Sensor.Control == null)
        {
            throw new ArgumentException("Specified sensor '" + sNode.Sensor.Identifier + "' can not be set");
        }

        if (value == "null")
        {
            sNode.Sensor.Control.SetDefault();
        }
        else
        {
            sNode.Sensor.Control.SetSoftware(float.Parse(value, CultureInfo.InvariantCulture));
        }
    }

    //Handles "/Sensor" requests.
    //Parameters are taken from the query part of the URL.
    //Get:
    //http://localhost:8085/Sensor?action=Get&id=/some/node/path/0
    //The output is either:
    //{"result":"fail","message":"Some error message"}
    //or:
    //{"result":"ok","value":42.0, "format":"{0:F2} RPM"}
    //
    //Set:
    //http://localhost:8085/Sensor?action=Set&id=/some/node/path/0&value=42.0
    //http://localhost:8085/Sensor?action=Set&id=/some/node/path/0&value=null
    //The output is either:
    //{"result":"fail","message":"Some error message"}
    //or:
    //{"result":"ok"}
    private void HandleSensorRequest(HttpListenerRequest request, JObject result)
    {
        IDictionary<string, string> dict = ToDictionary(HttpUtility.ParseQueryString(request.Url.Query));

        if (dict.ContainsKey("action"))
        {
            if (dict.ContainsKey("id"))
            {
                SensorNode sNode = FindSensor(_root, dict["id"]);

                if (sNode == null)
                {
                    throw new ArgumentException("Unknown id " + dict["id"] + " specified");
                }

                switch (dict["action"])
                {
                    case "Set" when dict.ContainsKey("value"):
                        SetSensorControlValue(sNode, dict["value"]);
                        break;
                    case "Set":
                        throw new ArgumentNullException("No value provided");
                    case "Get":
                        result["value"] = sNode.Sensor.Value;
                        result["format"] = sNode.Format;
                        break;
                    default:
                        throw new ArgumentException("Unknown action type " + dict["action"]);
                }
            }
            else
            {
                throw new ArgumentNullException("No id provided");
            }
        }
        else
        {
            throw new ArgumentNullException("No action provided");
        }
    }

    //Handles http POST requests in a REST like manner.
    //Currently the only supported base URL is http://localhost:8085/Sensor.
    private string HandlePostRequest(HttpListenerRequest request)
    {
        JObject result = new JObject { ["result"] = "ok" };

        try
        {
            if (request.Url.Segments.Length == 2)
            {
                if (request.Url.Segments[1] == "Sensor")
                {
                    HandleSensorRequest(request, result);
                }
                else
                {
                    throw new ArgumentException("Invalid URL ('" + request.Url.Segments[1] + "'), possible values: ['Sensor']");
                }
            }
            else
                throw new ArgumentException("Empty URL, possible values: ['Sensor']");
        }
        catch (Exception e)
        {
            result["result"] = "fail";
            result["message"] = e.ToString();
        }
#if DEBUG
        return result.ToString(Newtonsoft.Json.Formatting.Indented);
#else
            return result.ToString(Newtonsoft.Json.Formatting.None);
#endif
    }

    private void ListenerCallback(IAsyncResult result)
    {
        HttpListener listener = (HttpListener)result.AsyncState;
        if (listener == null || !listener.IsListening)
            return;


        // Call EndGetContext to complete the asynchronous operation.
        HttpListenerContext context;
        try
        {
            context = listener.EndGetContext(result);
        }
        catch (Exception)
        {
            return;
        }

        HttpListenerRequest request = context.Request;

        bool authenticated;

        if (AuthEnabled)
        {
            try
            {
                HttpListenerBasicIdentity identity = (HttpListenerBasicIdentity)context.User.Identity;
                authenticated = (identity.Name == UserName) & (ComputeSHA256(identity.Password) == Password);
            }
            catch
            {
                authenticated = false;
            }
        }
        else
        {
            authenticated = true;
        }

        if (authenticated)
        {
            switch (request.HttpMethod)
            {
                case "POST":
                    {
                        string postResult = HandlePostRequest(request);

                        Stream output = context.Response.OutputStream;
                        byte[] utfBytes = Encoding.UTF8.GetBytes(postResult);

                        context.Response.AddHeader("Cache-Control", "no-cache");
                        context.Response.ContentLength64 = utfBytes.Length;
                        context.Response.ContentType = "application/json";

                        output.Write(utfBytes, 0, utfBytes.Length);
                        output.Close();

                        break;
                    }
                case "GET":
                    {
                        string requestedFile = request.RawUrl.Substring(1);

                        if (requestedFile == "data.json")
                        {
                            SendJson(context.Response, request);
                            return;
                        }

                        if (requestedFile.Contains("images_icon"))
                        {
                            ServeResourceImage(context.Response,
                                               requestedFile.Replace("images_icon/", string.Empty));

                            return;
                        }

                        // default file to be served
                        if (string.IsNullOrEmpty(requestedFile))
                            requestedFile = "index.html";

                        string[] splits = requestedFile.Split('.');
                        string ext = splits[splits.Length - 1];
                        ServeResourceFile(context.Response, "Web." + requestedFile.Replace('/', '.'), ext);

                        break;
                    }
                default:
                    {
                        context.Response.StatusCode = 404;
                        break;
                    }
            }
        }
        else
        {
            context.Response.StatusCode = 401;
        }

        if (context.Response.StatusCode == 401)
        {
            const string responseString = @"<HTML><HEAD><TITLE>401 Unauthorized</TITLE></HEAD>
  <BODY><H4>401 Unauthorized</H4>
  Authorization required.</BODY></HTML> ";

            byte[] buffer = Encoding.UTF8.GetBytes(responseString);
            context.Response.ContentLength64 = buffer.Length;
            context.Response.StatusCode = 401;
            Stream output = context.Response.OutputStream;
            output.Write(buffer, 0, buffer.Length);
            output.Close();
        }

        try
        {
            context.Response.Close();
        }
        catch
        {
            // client closed connection before the content was sent
        }
    }

    private void ServeResourceFile(HttpListenerResponse response, string name, string ext)
    {
        // resource names do not support the hyphen
        name = "LibreHardwareMonitor.Resources." +
               name.Replace("custom-theme", "custom_theme");

        string[] names =
            Assembly.GetExecutingAssembly().GetManifestResourceNames();

        for (int i = 0; i < names.Length; i++)
        {
            if (names[i].Replace('\\', '.') == name)
            {
                using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(names[i]))
                {
                    response.ContentType = GetContentType("." + ext);
                    response.ContentLength64 = stream.Length;
                    byte[] buffer = new byte[512 * 1024];
                    try
                    {
                        Stream output = response.OutputStream;
                        int len;
                        while ((len = stream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            output.Write(buffer, 0, len);
                        }

                        output.Flush();
                        output.Close();
                        response.Close();
                    }
                    catch (HttpListenerException)
                    { }
                    catch (InvalidOperationException)
                    { }

                    return;
                }
            }
        }

        response.StatusCode = 404;
        response.Close();
    }

    private void ServeResourceImage(HttpListenerResponse response, string name)
    {
        name = "LibreHardwareMonitor.Resources." + name;

        string[] names = Assembly.GetExecutingAssembly().GetManifestResourceNames();

        for (int i = 0; i < names.Length; i++)
        {
            if (names[i].Replace('\\', '.') == name)
            {
                using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(names[i]))
                {
                    Image image = Image.FromStream(stream);
                    response.ContentType = "image/png";
                    try
                    {
                        Stream output = response.OutputStream;
                        using (MemoryStream ms = new MemoryStream())
                        {
                            image.Save(ms, ImageFormat.Png);
                            ms.WriteTo(output);
                        }

                        output.Close();
                    }
                    catch (HttpListenerException)
                    { }

                    image.Dispose();
                    response.Close();
                    return;
                }
            }
        }

        response.StatusCode = 404;
        response.Close();
    }

    private void SendJson(HttpListenerResponse response, HttpListenerRequest request = null)
    {
        JObject json = new JObject();

        int nodeIndex = 0;

        json["id"] = nodeIndex++;
        json["Text"] = "Sensor";
        json["Min"] = "Min";
        json["Value"] = "Value";
        json["Max"] = "Max";
        json["ImageURL"] = string.Empty;

        JArray children = new JArray { GenerateJsonForNode(_root, ref nodeIndex) };
        json["Children"] = children;
#if DEBUG
        string responseContent = json.ToString(Newtonsoft.Json.Formatting.Indented);
#else
            string responseContent = json.ToString(Newtonsoft.Json.Formatting.None);
#endif
        byte[] buffer = Encoding.UTF8.GetBytes(responseContent);

        bool acceptGzip;
        try
        {
            acceptGzip = (request != null) && (request.Headers["Accept-Encoding"].ToLower().IndexOf("gzip", StringComparison.OrdinalIgnoreCase) >= 0);
        }
        catch
        {
            acceptGzip = false;
        }

        if (acceptGzip)
            response.AddHeader("Content-Encoding", "gzip");

        response.AddHeader("Cache-Control", "no-cache");
        response.AddHeader("Access-Control-Allow-Origin", "*");
        response.ContentType = "application/json";
        try
        {
            if (acceptGzip)
            {
                using (var ms = new MemoryStream())
                {
                    using (var zip = new GZipStream(ms, CompressionMode.Compress, true))
                        zip.Write(buffer, 0, buffer.Length);

                    buffer = ms.ToArray();
                }
            }

            response.ContentLength64 = buffer.Length;
            Stream output = response.OutputStream;
            output.Write(buffer, 0, buffer.Length);
            output.Close();
        }
        catch (HttpListenerException)
        { }

        response.Close();
    }

    private JObject GenerateJsonForNode(Node n, ref int nodeIndex)
    {
        JObject jsonNode = new JObject
        {
            ["id"] = nodeIndex++,
            ["Text"] = n.Text,
            ["Min"] = string.Empty,
            ["Value"] = string.Empty,
            ["Max"] = string.Empty
        };

        if (n is SensorNode sensorNode)
        {
            jsonNode["SensorId"] = sensorNode.Sensor.Identifier.ToString();
            jsonNode["Type"] = sensorNode.Sensor.SensorType.ToString();
            jsonNode["Min"] = sensorNode.Min;
            jsonNode["Value"] = sensorNode.Value;
            jsonNode["Max"] = sensorNode.Max;
            jsonNode["ImageURL"] = "images/transparent.png";
        }
        else if (n is HardwareNode hardwareNode)
        {
            jsonNode["ImageURL"] = "images_icon/" + GetHardwareImageFile(hardwareNode);
        }
        else if (n is TypeNode typeNode)
        {
            jsonNode["ImageURL"] = "images_icon/" + GetTypeImageFile(typeNode);
        }
        else
        {
            jsonNode["ImageURL"] = "images_icon/computer.png";
        }

        JArray children = new JArray();
        foreach (Node child in n.Nodes)
        {
            children.Add(GenerateJsonForNode(child, ref nodeIndex));
        }

        jsonNode["Children"] = children;

        return jsonNode;
    }

    private static string GetContentType(string extension)
    {
        switch (extension)
        {
            case ".avi": return "video/x-msvideo";
            case ".css": return "text/css";
            case ".doc": return "application/msword";
            case ".gif": return "image/gif";
            case ".htm":
            case ".html": return "text/html";
            case ".jpg":
            case ".jpeg": return "image/jpeg";
            case ".js": return "application/x-javascript";
            case ".mp3": return "audio/mpeg";
            case ".png": return "image/png";
            case ".pdf": return "application/pdf";
            case ".ppt": return "application/vnd.ms-powerpoint";
            case ".zip": return "application/zip";
            case ".txt": return "text/plain";
            default: return "application/octet-stream";
        }
    }

    private static string GetHardwareImageFile(HardwareNode hn)
    {
        switch (hn.Hardware.HardwareType)
        {
            case HardwareType.Cpu:
                return "cpu.png";
            case HardwareType.GpuNvidia:
                return "nvidia.png";
            case HardwareType.GpuAmd:
                return "ati.png";
            case HardwareType.GpuIntel:
                return "intel.png";
            case HardwareType.Storage:
                return "hdd.png";
            case HardwareType.Motherboard:
                return "mainboard.png";
            case HardwareType.SuperIO:
                return "chip.png";
            case HardwareType.Memory:
                return "ram.png";
            case HardwareType.Cooler:
                return "fan.png";
            case HardwareType.Network:
                return "nic.png";
            case HardwareType.Psu:
                return "power-supply.png";
            case HardwareType.Battery:
                return "battery.png";
            default:
                return "cpu.png";
        }
    }

    private static string GetTypeImageFile(TypeNode tn)
    {
        switch (tn.SensorType)
        {
            case SensorType.Voltage:
            case SensorType.Current:
                return "voltage.png";
            case SensorType.Clock:
                return "clock.png";
            case SensorType.Load:
                return "load.png";
            case SensorType.Temperature:
                return "temperature.png";
            case SensorType.Fan:
                return "fan.png";
            case SensorType.Flow:
                return "flow.png";
            case SensorType.Control:
                return "control.png";
            case SensorType.Level:
                return "level.png";
            case SensorType.Power:
                return "power.png";
            case SensorType.Noise:
                return "loudspeaker.png";
            case SensorType.Throughput:
                return "throughput.png";
            default:
                return "power.png";
        }
    }

    private string ComputeSHA256(string text)
    {
        using (SHA256 hash = SHA256.Create())
        {
            return string.Concat(hash
                                .ComputeHash(Encoding.UTF8.GetBytes(text))
                                .Select(item => item.ToString("x2")));
        }
    }

    public void Quit()
    {
        if (PlatformNotSupported)
            return;


        StopHttpListener();
        _listener.Abort();
    }
}
```

`LibreHardwareMonitor/Utilities/IconFactory.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Utilities;

public static class IconFactory
{
    private struct BITMAPINFOHEADER
    {
        public readonly uint Size;
        public readonly int Width;
        public readonly int Height;
        public readonly ushort Planes;
        public readonly ushort BitCount;
        public readonly uint Compression;
        public readonly uint SizeImage;
        public readonly int XPelsPerMeter;
        public readonly int YPelsPerMeter;
        public readonly uint ClrUsed;
        public readonly uint ClrImportant;

        public BITMAPINFOHEADER(int width, int height, int bitCount)
        {
            Size = 40;
            Width = width;
            Height = height;
            Planes = 1;
            BitCount = (ushort)bitCount;
            Compression = 0;
            SizeImage = 0;
            XPelsPerMeter = 0;
            YPelsPerMeter = 0;
            ClrUsed = 0;
            ClrImportant = 0;
        }

        public void Write(BinaryWriter bw)
        {
            bw.Write(Size);
            bw.Write(Width);
            bw.Write(Height);
            bw.Write(Planes);
            bw.Write(BitCount);
            bw.Write(Compression);
            bw.Write(SizeImage);
            bw.Write(XPelsPerMeter);
            bw.Write(YPelsPerMeter);
            bw.Write(ClrUsed);
            bw.Write(ClrImportant);
        }
    }

    private struct ICONIMAGE
    {
        public BITMAPINFOHEADER Header;
        public readonly byte[] Colors;
        public readonly int MaskSize;

        public ICONIMAGE(int width, int height, byte[] colors)
        {
            Header = new BITMAPINFOHEADER(width, height << 1, (8 * colors.Length) / (width * height));
            Colors = colors;
            MaskSize = (width * height) >> 3;
        }

        public void Write(BinaryWriter bw)
        {
            Header.Write(bw);
            int stride = Header.Width << 2;
            for (int i = (Header.Height >> 1) - 1; i >= 0; i--)
                bw.Write(Colors, i * stride, stride);
            for (int i = 0; i < 2 * MaskSize; i++)
                bw.Write((byte)0);
        }
    }

    private struct ICONDIRENTRY
    {
        public readonly byte Width;
        public readonly byte Height;
        public readonly byte ColorCount;
        public readonly byte Reserved;
        public readonly ushort Planes;
        public readonly ushort BitCount;
        public readonly uint BytesInRes;
        public uint ImageOffset;

        public ICONDIRENTRY(ICONIMAGE image, int imageOffset)
        {
            Width = (byte)image.Header.Width;
            Height = (byte)(image.Header.Height >> 1);
            ColorCount = 0;
            Reserved = 0;
            Planes = image.Header.Planes;
            BitCount = image.Header.BitCount;
            BytesInRes = (uint)(image.Header.Size + image.Colors.Length + image.MaskSize + image.MaskSize);
            ImageOffset = (uint)imageOffset;
        }

        public void Write(BinaryWriter bw)
        {
            bw.Write(Width);
            bw.Write(Height);
            bw.Write(ColorCount);
            bw.Write(Reserved);
            bw.Write(Planes);
            bw.Write(BitCount);
            bw.Write(BytesInRes);
            bw.Write(ImageOffset);
        }

        public uint Size
        {
            get { return 16; }
        }
    }

    private struct ICONDIR
    {
        public readonly ushort Reserved;
        public readonly ushort Type;
        public readonly ushort Count;
        public readonly ICONDIRENTRY[] Entries;

        public ICONDIR(ICONDIRENTRY[] entries)
        {
            Reserved = 0;
            Type = 1;
            Count = (ushort)entries.Length;
            Entries = entries;
        }

        public void Write(BinaryWriter bw)
        {
            bw.Write(Reserved);
            bw.Write(Type);
            bw.Write(Count);
            for (int i = 0; i < Entries.Length; i++)
                Entries[i].Write(bw);
        }

        public uint Size
        {
            get
            {
                return (uint)(6 + Entries.Length * (Entries.Length > 0 ? Entries[0].Size : 0));
            }
        }
    }

    private static readonly BinaryWriter BinaryWriter = new BinaryWriter(new MemoryStream());

    public static Icon Create(byte[] colors, int width, int height, PixelFormat format)
    {
        if (format != PixelFormat.Format32bppArgb)
            throw new NotImplementedException();

        ICONIMAGE image = new ICONIMAGE(width, height, colors);
        ICONDIR dir = new ICONDIR(new[] { new ICONDIRENTRY(image, 0) });
        dir.Entries[0].ImageOffset = dir.Size;

        BinaryWriter.BaseStream.Position = 0;
        dir.Write(BinaryWriter);
        image.Write(BinaryWriter);

        BinaryWriter.BaseStream.Position = 0;
        Icon icon = new Icon(BinaryWriter.BaseStream);

        return icon;
    }

    [DllImport("user32", SetLastError = true)]
    static extern bool DestroyIcon(IntPtr handle);

    public static Icon Create(Bitmap bitmap)
    {
        IntPtr hIcon = bitmap.GetHicon();
        Icon icon = Icon.FromHandle(hIcon);

        return icon;
    }

    public static void Destroy(this Icon icon)
    {
        DestroyIcon(icon.Handle);
        icon.Dispose();
    }
}
```

`LibreHardwareMonitor/Utilities/Logger.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.Utilities;

public class Logger
{
    private const string FileNameFormat = "LibreHardwareMonitorLog-{0:yyyy-MM-dd}.csv";

    private readonly IComputer _computer;

    private DateTime _day = DateTime.MinValue;
    private string _fileName;
    private string[] _identifiers;
    private ISensor[] _sensors;
    private DateTime _lastLoggedTime = DateTime.MinValue;

    public Logger(IComputer computer)
    {
        _computer = computer;
        _computer.HardwareAdded += HardwareAdded;
        _computer.HardwareRemoved += HardwareRemoved;
    }

    private void HardwareRemoved(IHardware hardware)
    {
        hardware.SensorAdded -= SensorAdded;
        hardware.SensorRemoved -= SensorRemoved;

        foreach (ISensor sensor in hardware.Sensors)
            SensorRemoved(sensor);

        foreach (IHardware subHardware in hardware.SubHardware)
            HardwareRemoved(subHardware);
    }

    private void HardwareAdded(IHardware hardware)
    {
        foreach (ISensor sensor in hardware.Sensors)
            SensorAdded(sensor);

        hardware.SensorAdded += SensorAdded;
        hardware.SensorRemoved += SensorRemoved;

        foreach (IHardware subHardware in hardware.SubHardware)
            HardwareAdded(subHardware);
    }

    private void SensorAdded(ISensor sensor)
    {
        if (_sensors == null)
            return;

        for (int i = 0; i < _sensors.Length; i++)
        {
            if (sensor.Identifier.ToString() == _identifiers[i])
                _sensors[i] = sensor;
        }
    }

    private void SensorRemoved(ISensor sensor)
    {
        if (_sensors == null)
            return;

        for (int i = 0; i < _sensors.Length; i++)
        {
            if (sensor == _sensors[i])
                _sensors[i] = null;
        }
    }

    private static string GetFileName(DateTime date)
    {
        return AppDomain.CurrentDomain.BaseDirectory + Path.DirectorySeparatorChar + string.Format(FileNameFormat, date);
    }

    private bool OpenExistingLogFile()
    {
        if (!File.Exists(_fileName))
            return false;

        try
        {
            string line;
            using (StreamReader reader = new StreamReader(_fileName))
                line = reader.ReadLine();

            if (string.IsNullOrEmpty(line))
                return false;

            _identifiers = line.Split(',').Skip(1).ToArray();
        }
        catch
        {
            _identifiers = null;
            return false;
        }

        if (_identifiers.Length == 0)
        {
            _identifiers = null;
            return false;
        }

        _sensors = new ISensor[_identifiers.Length];
        SensorVisitor visitor = new SensorVisitor(sensor =>
        {
            for (int i = 0; i < _identifiers.Length; i++)
                if (sensor.Identifier.ToString() == _identifiers[i])
                    _sensors[i] = sensor;
        });
        visitor.VisitComputer(_computer);
        return true;
    }

    private void CreateNewLogFile()
    {
        IList<ISensor> list = new List<ISensor>();
        SensorVisitor visitor = new SensorVisitor(sensor =>
        {
            list.Add(sensor);
        });
        visitor.VisitComputer(_computer);
        _sensors = list.ToArray();
        _identifiers = _sensors.Select(s => s.Identifier.ToString()).ToArray();

        using (StreamWriter writer = new StreamWriter(_fileName, false))
        {
            writer.Write(",");
            for (int i = 0; i < _sensors.Length; i++)
            {
                writer.Write(_sensors[i].Identifier);
                if (i < _sensors.Length - 1)
                    writer.Write(",");
                else
                    writer.WriteLine();
            }

            writer.Write("Time,");
            for (int i = 0; i < _sensors.Length; i++)
            {
                writer.Write('"');
                writer.Write(_sensors[i].Name);
                writer.Write('"');
                if (i < _sensors.Length - 1)
                    writer.Write(",");
                else
                    writer.WriteLine();
            }
        }
    }

    public TimeSpan LoggingInterval { get; set; }

    public void Log()
    {
        DateTime now = DateTime.Now;

        if (_lastLoggedTime + LoggingInterval - new TimeSpan(5000000) > now)
            return;

        if (_day != now.Date || !File.Exists(_fileName))
        {
            _day = now.Date;
            _fileName = GetFileName(_day);

            if (!OpenExistingLogFile())
                CreateNewLogFile();
        }

        try
        {
            using (StreamWriter writer = new StreamWriter(new FileStream(_fileName, FileMode.Append, FileAccess.Write, FileShare.ReadWrite)))
            {
                writer.Write(now.ToString("G", CultureInfo.InvariantCulture));
                writer.Write(",");
                for (int i = 0; i < _sensors.Length; i++)
                {
                    if (_sensors[i] != null)
                    {
                        float? value = _sensors[i].Value;
                        if (value.HasValue)
                            writer.Write(value.Value.ToString("R", CultureInfo.InvariantCulture));
                    }
                    if (i < _sensors.Length - 1)
                        writer.Write(",");
                    else
                        writer.WriteLine();
                }
            }
        }
        catch (IOException) { }

        _lastLoggedTime = now;
    }
}
```

`LibreHardwareMonitor/Utilities/PersistentSettings.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.Utilities;

public class PersistentSettings : ISettings
{
    private readonly IDictionary<string, string> _settings = new Dictionary<string, string>();

    public void Load(string fileName)
    {
        XmlDocument doc = new XmlDocument();
        try
        {
            doc.Load(fileName);
        }
        catch
        {
            try
            {
                File.Delete(fileName);
            }
            catch { }

            string backupFileName = fileName + ".backup";
            try
            {
                doc.Load(backupFileName);
            }
            catch
            {
                try
                {
                    File.Delete(backupFileName);
                }
                catch { }

                return;
            }
        }

        XmlNodeList list = doc.GetElementsByTagName("appSettings");
        foreach (XmlNode node in list)
        {
            XmlNode parent = node.ParentNode;
            if (parent != null && parent.Name == "configuration" && parent.ParentNode is XmlDocument)
            {
                foreach (XmlNode child in node.ChildNodes)
                {
                    if (child.Name == "add")
                    {
                        XmlAttributeCollection attributes = child.Attributes;
                        XmlAttribute keyAttribute = attributes["key"];
                        XmlAttribute valueAttribute = attributes["value"];
                        if (keyAttribute != null && valueAttribute != null && keyAttribute.Value != null)
                        {
                            _settings.Add(keyAttribute.Value, valueAttribute.Value);
                        }
                    }
                }
            }
        }
    }

    public void Save(string fileName)
    {
        XmlDocument doc = new XmlDocument();
        doc.AppendChild(doc.CreateXmlDeclaration("1.0", "utf-8", null));
        XmlElement configuration = doc.CreateElement("configuration");
        doc.AppendChild(configuration);
        XmlElement appSettings = doc.CreateElement("appSettings");
        configuration.AppendChild(appSettings);
        foreach (KeyValuePair<string, string> keyValuePair in _settings)
        {
            XmlElement add = doc.CreateElement("add");
            add.SetAttribute("key", keyValuePair.Key);
            add.SetAttribute("value", keyValuePair.Value);
            appSettings.AppendChild(add);
        }

        byte[] file;
        using (var memory = new MemoryStream())
        {
            using (var writer = new StreamWriter(memory, Encoding.UTF8))
            {
                doc.Save(writer);
            }
            file = memory.ToArray();
        }

        string backupFileName = fileName + ".backup";
        if (File.Exists(fileName))
        {
            try
            {
                File.Delete(backupFileName);
            }
            catch { }
            try
            {
                File.Move(fileName, backupFileName);
            }
            catch { }
        }

        using (var stream = new FileStream(fileName, FileMode.Create, FileAccess.Write))
        {
            stream.Write(file, 0, file.Length);
        }

        try
        {
            File.Delete(backupFileName);
        }
        catch { }
    }

    public bool Contains(string name)
    {
        return _settings.ContainsKey(name);
    }

    public void SetValue(string name, string value)
    {
        _settings[name] = value;
    }

    public string GetValue(string name, string value)
    {
        if (_settings.TryGetValue(name, out string result))
            return result;


        return value;
    }

    public void Remove(string name)
    {
        _settings.Remove(name);
    }

    public void SetValue(string name, int value)
    {
        _settings[name] = value.ToString();
    }

    public int GetValue(string name, int value)
    {
        if (_settings.TryGetValue(name, out string str))
        {
            if (int.TryParse(str, out int parsedValue))
                return parsedValue;


            return value;
        }

        return value;
    }

    public void SetValue(string name, float value)
    {
        _settings[name] = value.ToString(CultureInfo.InvariantCulture);
    }

    public float GetValue(string name, float value)
    {
        if (_settings.TryGetValue(name, out string str))
        {
            if (float.TryParse(str, NumberStyles.Float, CultureInfo.InvariantCulture, out float parsedValue))
                return parsedValue;
        }

        return value;

    }

    public double GetValue(string name, double value)
    {
        if (_settings.TryGetValue(name, out string str))
        {
            if (double.TryParse(str, NumberStyles.Float, CultureInfo.InvariantCulture, out double parsedValue))
                return parsedValue;
        }

        return value;
    }
        
    public void SetValue(string name, bool value)
    {
        _settings[name] = value ? "true" : "false";
    }

    public bool GetValue(string name, bool value)
    {
        if (_settings.TryGetValue(name, out string str))
        {
            return str == "true";
        }

        return value;
    }

    public void SetValue(string name, Color color)
    {
        _settings[name] = color.ToArgb().ToString("X8");
    }

    public Color GetValue(string name, Color value)
    {
        if (_settings.TryGetValue(name, out string str))
        {
            if (int.TryParse(str, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out int parsedValue))
                return Color.FromArgb(parsedValue);
        }

        return value;
    }
}
```

`LibreHardwareMonitor/WMI/Hardware.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Management.Instrumentation;
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.Wmi;

[InstrumentationClass(InstrumentationType.Instance)]
public class Hardware : IWmiObject
{
    #region WMI Exposed

    public string HardwareType { get; }
    public string Identifier { get; }
    public string Name { get; }
    public string Parent { get; }

    #endregion

    public Hardware(IHardware hardware)
    {
        Name = hardware.Name;
        Identifier = hardware.Identifier.ToString();
        HardwareType = hardware.HardwareType.ToString();
        Parent = (hardware.Parent != null)
            ? hardware.Parent.Identifier.ToString()
            : "";
    }

    public void Update() { }
}
```

`LibreHardwareMonitor/WMI/IWmiObject.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Wmi;

interface IWmiObject
{
    // Both of these get exposed to WMI
    string Name { get; }
    string Identifier { get; }

    // Not exposed.
    void Update();
}
```

`LibreHardwareMonitor/WMI/Sensor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Management.Instrumentation;
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.Wmi;

[InstrumentationClass(InstrumentationType.Instance)]
public class Sensor : IWmiObject
{
    private readonly ISensor _sensor;

    #region WMI Exposed

    public string SensorType { get; }
    public string Identifier { get; }
    public string Parent { get; }
    public string Name { get; }
    public float Value { get; private set; }
    public float Min { get; private set; }
    public float Max { get; private set; }
    public int Index { get; }

    #endregion

    public Sensor(ISensor sensor)
    {
        Name = sensor.Name;
        Index = sensor.Index;

        SensorType = sensor.SensorType.ToString();
        Identifier = sensor.Identifier.ToString();
        Parent = sensor.Hardware.Identifier.ToString();

        _sensor = sensor;
    }

    public void Update()
    {
        Value = _sensor.Value ?? 0;

        if (_sensor.Min != null)
            Min = (float)_sensor.Min;

        if (_sensor.Max != null)
            Max = (float)_sensor.Max;
    }
}
```

`LibreHardwareMonitor/WMI/WmiProvider.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Management.Instrumentation;
using LibreHardwareMonitor.Hardware;

[assembly: Instrumented("root/LibreHardwareMonitor")]

[System.ComponentModel.RunInstaller(true)]
public class InstanceInstaller : DefaultManagementProjectInstaller
{ }

namespace LibreHardwareMonitor.Wmi
{
    /// <summary>
    /// The WMI Provider.
    /// This class is not exposed to WMI itself.
    /// </summary>
    public class WmiProvider : IDisposable
    {
        private readonly object _activeInstancesLock = new();
        private readonly List<IWmiObject> _activeInstances;

        public WmiProvider(IComputer computer)
        {
            _activeInstances = new List<IWmiObject>();
            foreach (IHardware hardware in computer.Hardware)
                OnHardwareAdded(hardware);

            computer.HardwareAdded += OnHardwareAdded;
            computer.HardwareRemoved += OnHardwareRemoved;
        }

        public void Update()
        {
            lock (_activeInstancesLock)
            {
                foreach (IWmiObject instance in _activeInstances)
                    instance.Update();
            }
        }

        private void OnHardwareAdded(IHardware hardware)
        {
            lock (_activeInstancesLock)
            {
                if (!_activeInstances.Exists(h => h.Identifier == hardware.Identifier.ToString()))
                {
                    foreach (ISensor sensor in hardware.Sensors)
                        OnSensorAdded(sensor);

                    hardware.SensorAdded += OnSensorAdded;
                    hardware.SensorRemoved += HardwareSensorRemoved;

                    Hardware hw = new(hardware);
                    _activeInstances.Add(hw);

                    try
                    {
                        Instrumentation.Publish(hw);
                    }
                    catch
                    { }
                }
            }

            foreach (IHardware subHardware in hardware.SubHardware)
                OnHardwareAdded(subHardware);
        }

        private void OnSensorAdded(ISensor data)
        {
            Sensor sensor = new(data);

            lock (_activeInstancesLock)
                _activeInstances.Add(sensor);

            try
            {
                Instrumentation.Publish(sensor);
            }
            catch
            { }
        }

        private void OnHardwareRemoved(IHardware hardware)
        {
            hardware.SensorAdded -= OnSensorAdded;
            hardware.SensorRemoved -= HardwareSensorRemoved;

            foreach (ISensor sensor in hardware.Sensors)
                HardwareSensorRemoved(sensor);

            foreach (IHardware subHardware in hardware.SubHardware)
                OnHardwareRemoved(subHardware);

            RevokeInstance(hardware.Identifier.ToString());
        }

        private void HardwareSensorRemoved(ISensor sensor)
        {
            RevokeInstance(sensor.Identifier.ToString());
        }

        private void RevokeInstance(string identifier)
        {
            lock (_activeInstancesLock)
            {
                int instanceIndex = _activeInstances.FindIndex(item => item.Identifier == identifier);
                if (instanceIndex == -1)
                    return;

                try
                {
                    Instrumentation.Revoke(_activeInstances[instanceIndex]);
                }
                catch
                { }

                _activeInstances.RemoveAt(instanceIndex);
            }
        }

        public void Dispose()
        {
            lock (_activeInstancesLock)
            {
                foreach (IWmiObject instance in _activeInstances)
                {
                    try
                    {
                        Instrumentation.Revoke(instance);
                    }
                    catch
                    { }
                }
            }
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Battery/Battery.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Linq;
using System.Runtime.InteropServices;
using LibreHardwareMonitor.Interop;
using Microsoft.Win32.SafeHandles;

namespace LibreHardwareMonitor.Hardware.Battery;

internal sealed class Battery : Hardware
{
    private readonly SafeFileHandle _batteryHandle;
    private readonly Kernel32.BATTERY_INFORMATION _batteryInformation;
    private readonly uint _batteryTag;
    private readonly Sensor _chargeDischargeCurrent;
    private readonly Sensor _chargeDischargeRate;
    private readonly Sensor _chargeLevel;
    private readonly Sensor _degradationPercentage;
    private readonly Sensor _designedCapacity;
    private readonly Sensor _fullChargedCapacity;
    private readonly Sensor _remainingCapacity;
    private readonly Sensor _remainingTime;
    private readonly Sensor _voltage;

    public Battery
    (
        string name,
        string manufacturer,
        SafeFileHandle batteryHandle,
        Kernel32.BATTERY_INFORMATION batteryInfo,
        uint batteryTag,
        ISettings settings) :
        base(name, new Identifier("battery"), settings)
    {
        Name = name;
        Manufacturer = manufacturer;

        _batteryTag = batteryTag;
        _batteryHandle = batteryHandle;
        _batteryInformation = batteryInfo;

        if (batteryInfo.Chemistry.SequenceEqual(new[] { 'P', 'b', 'A', 'c' }))
        {
            Chemistry = BatteryChemistry.LeadAcid;
        }
        else if (batteryInfo.Chemistry.SequenceEqual(new[] { 'L', 'I', 'O', 'N' }) || batteryInfo.Chemistry.SequenceEqual(new[] { 'L', 'i', '-', 'I' }))
        {
            Chemistry = BatteryChemistry.LithiumIon;
        }
        else if (batteryInfo.Chemistry.SequenceEqual(new[] { 'N', 'i', 'C', 'd' }))
        {
            Chemistry = BatteryChemistry.NickelCadmium;
        }
        else if (batteryInfo.Chemistry.SequenceEqual(new[] { 'N', 'i', 'M', 'H' }))
        {
            Chemistry = BatteryChemistry.NickelMetalHydride;
        }
        else if (batteryInfo.Chemistry.SequenceEqual(new[] { 'N', 'i', 'Z', 'n' }))
        {
            Chemistry = BatteryChemistry.NickelZinc;
        }
        else if (batteryInfo.Chemistry.SequenceEqual(new[] { 'R', 'A', 'M', '\x00' }))
        {
            Chemistry = BatteryChemistry.AlkalineManganese;
        }
        else
        {
            Chemistry = BatteryChemistry.Unknown;
        }

        DegradationLevel = 100f - (batteryInfo.FullChargedCapacity * 100f / batteryInfo.DesignedCapacity);
        DesignedCapacity = batteryInfo.DesignedCapacity;
        FullChargedCapacity = batteryInfo.FullChargedCapacity;

        _chargeLevel = new Sensor("Charge Level", 0, SensorType.Level, this, settings);
        ActivateSensor(_chargeLevel);

        _voltage = new Sensor("Voltage", 1, SensorType.Voltage, this, settings);
        ActivateSensor(_voltage);

        _chargeDischargeCurrent = new Sensor("Current", 2, SensorType.Current, this, settings);
        ActivateSensor(_chargeDischargeCurrent);

        _designedCapacity = new Sensor("Designed Capacity", 3, SensorType.Energy, this, settings);
        ActivateSensor(_designedCapacity);

        _fullChargedCapacity = new Sensor("Full Charged Capacity", 4, SensorType.Energy, this, settings);
        ActivateSensor(_fullChargedCapacity);

        _remainingCapacity = new Sensor("Remaining Capacity", 5, SensorType.Energy, this, settings);
        ActivateSensor(_remainingCapacity);

        _chargeDischargeRate = new Sensor("Charge/Discharge Rate", 0, SensorType.Power, this, settings);
        ActivateSensor(_chargeDischargeRate);

        _degradationPercentage = new Sensor("Degradation Level", 0, SensorType.Level, this, settings);
        ActivateSensor(_degradationPercentage);

        _remainingTime = new Sensor("Remaining Time (Estimated)", 0, SensorType.TimeSpan, this, settings);
        ActivateSensor(_remainingTime);
    }

    public float ChargeDischargeCurrent { get; private set; }

    public float ChargeDischargeRate { get; private set; }

    public float ChargeLevel { get; private set; }

    public BatteryChemistry Chemistry { get; }

    public float DegradationLevel { get; }

    public float DesignedCapacity { get; }

    public float FullChargedCapacity { get; }

    public override HardwareType HardwareType => HardwareType.Battery;

    public string Manufacturer { get; }

    public float RemainingCapacity { get; private set; }

    public uint RemainingTime { get; private set; }

    public float Voltage { get; private set; }

    public override void Update()
    {
        Kernel32.BATTERY_WAIT_STATUS bws = default;
        bws.BatteryTag = _batteryTag;
        Kernel32.BATTERY_STATUS batteryStatus = default;
        if (Kernel32.DeviceIoControl(_batteryHandle,
                                     Kernel32.IOCTL.IOCTL_BATTERY_QUERY_STATUS,
                                     ref bws,
                                     Marshal.SizeOf(bws),
                                     ref batteryStatus,
                                     Marshal.SizeOf(batteryStatus),
                                     out _,
                                     IntPtr.Zero))
        {
            _designedCapacity.Value = Convert.ToSingle(_batteryInformation.DesignedCapacity);
            _fullChargedCapacity.Value = Convert.ToSingle(_batteryInformation.FullChargedCapacity);

            _remainingCapacity.Value = Convert.ToSingle(batteryStatus.Capacity);
            RemainingCapacity = Convert.ToSingle(batteryStatus.Capacity);

            _voltage.Value = Convert.ToSingle(batteryStatus.Voltage) / 1000f;
            Voltage = Convert.ToSingle(batteryStatus.Voltage) / 1000f;

            _chargeLevel.Value = _remainingCapacity.Value * 100f / _fullChargedCapacity.Value;
            ChargeLevel = (_remainingCapacity.Value * 100f / _fullChargedCapacity.Value).GetValueOrDefault();

            ChargeDischargeRate = batteryStatus.Rate / 1000f;

            switch (batteryStatus.Rate)
            {
                case > 0:
                    _chargeDischargeRate.Name = "Charge Rate";
                    _chargeDischargeRate.Value = batteryStatus.Rate / 1000f;

                    _chargeDischargeCurrent.Name = "Charge Current";
                    _chargeDischargeCurrent.Value = _chargeDischargeRate.Value / _voltage.Value;
                    ChargeDischargeCurrent = (_chargeDischargeRate.Value / _voltage.Value).GetValueOrDefault();

                    break;
                case < 0:
                    _chargeDischargeRate.Name = "Discharge Rate";
                    _chargeDischargeRate.Value = Math.Abs(batteryStatus.Rate) / 1000f;

                    _chargeDischargeCurrent.Name = "Discharge Current";
                    _chargeDischargeCurrent.Value = _chargeDischargeRate.Value / _voltage.Value;
                    ChargeDischargeCurrent = (_chargeDischargeRate.Value / _voltage.Value).GetValueOrDefault();

                    break;
                default:
                    _chargeDischargeRate.Name = "Charge/Discharge Rate";
                    _chargeDischargeRate.Value = 0f;
                    ChargeDischargeRate = 0f;

                    _chargeDischargeCurrent.Name = "Charge/Discharge Current";
                    _chargeDischargeCurrent.Value = 0f;
                    ChargeDischargeCurrent = 0f;

                    break;
            }

            _degradationPercentage.Value = 100f - (_fullChargedCapacity.Value * 100f / _designedCapacity.Value);
        }

        uint estimatedRunTime = 0;
        Kernel32.BATTERY_QUERY_INFORMATION bqi = default;
        bqi.BatteryTag = _batteryTag;
        bqi.InformationLevel = Kernel32.BATTERY_QUERY_INFORMATION_LEVEL.BatteryEstimatedTime;
        if (Kernel32.DeviceIoControl(_batteryHandle,
                                     Kernel32.IOCTL.IOCTL_BATTERY_QUERY_INFORMATION,
                                     ref bqi,
                                     Marshal.SizeOf(bqi),
                                     ref estimatedRunTime,
                                     Marshal.SizeOf<uint>(),
                                     out _,
                                     IntPtr.Zero))
        {
            RemainingTime = estimatedRunTime;
            if (estimatedRunTime != Kernel32.BATTERY_UNKNOWN_TIME)
            {
                ActivateSensor(_remainingTime);
                _remainingTime.Value = estimatedRunTime;
            }
            else
            {
                DeactivateSensor(_remainingTime);
            }
        }
    }

    public override void Close()
    {
        base.Close();
        _batteryHandle.Close();
    }
}
```

`LibreHardwareMonitorLib/Hardware/Battery/BatteryChemistry.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Battery;

internal enum BatteryChemistry
{
    Unknown,
    LeadAcid,
    NickelCadmium,
    NickelMetalHydride,
    LithiumIon,
    NickelZinc,
    AlkalineManganese
}

```

`LibreHardwareMonitorLib/Hardware/Battery/BatteryGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using LibreHardwareMonitor.Interop;
using Microsoft.Win32.SafeHandles;

namespace LibreHardwareMonitor.Hardware.Battery;

internal class BatteryGroup : IGroup
{
    private readonly List<Battery> _hardware = new();

    public unsafe BatteryGroup(ISettings settings)
    {
        // No implementation for battery information on Unix systems
        if (Software.OperatingSystem.IsUnix)
            return;

        IntPtr hdev = SetupApi.SetupDiGetClassDevs(ref SetupApi.GUID_DEVICE_BATTERY, IntPtr.Zero, IntPtr.Zero, SetupApi.DIGCF_PRESENT | SetupApi.DIGCF_DEVICEINTERFACE);
        if (hdev != SetupApi.INVALID_HANDLE_VALUE)
        {
            for (uint i = 0; ; i++)
            {
                SetupApi.SP_DEVICE_INTERFACE_DATA did = default;
                did.cbSize = (uint)Marshal.SizeOf(typeof(SetupApi.SP_DEVICE_INTERFACE_DATA));

                if (!SetupApi.SetupDiEnumDeviceInterfaces(hdev,
                                                          IntPtr.Zero,
                                                          ref SetupApi.GUID_DEVICE_BATTERY,
                                                          i,
                                                          ref did))
                {
                    if (Marshal.GetLastWin32Error() == SetupApi.ERROR_NO_MORE_ITEMS)
                        break;
                }
                else
                {
                    SetupApi.SetupDiGetDeviceInterfaceDetail(hdev,
                                                             did,
                                                             IntPtr.Zero,
                                                             0,
                                                             out uint cbRequired,
                                                             IntPtr.Zero);

                    if (Marshal.GetLastWin32Error() == SetupApi.ERROR_INSUFFICIENT_BUFFER)
                    {
                        IntPtr pdidd = Kernel32.LocalAlloc(Kernel32.LPTR, cbRequired);
                        Marshal.WriteInt32(pdidd, Environment.Is64BitOperatingSystem ? 8 : 4); // cbSize.

                        if (SetupApi.SetupDiGetDeviceInterfaceDetail(hdev,
                                                                     did,
                                                                     pdidd,
                                                                     cbRequired,
                                                                     out _,
                                                                     IntPtr.Zero))
                        {
                            string devicePath = new((char*)(pdidd + 4));

                            SafeFileHandle battery = Kernel32.CreateFile(devicePath, FileAccess.ReadWrite, FileShare.ReadWrite, IntPtr.Zero, FileMode.Open, FileAttributes.Normal, IntPtr.Zero);
                            if (!battery.IsInvalid)
                            {
                                Kernel32.BATTERY_QUERY_INFORMATION bqi = default;

                                uint dwWait = 0;
                                if (Kernel32.DeviceIoControl(battery,
                                                             Kernel32.IOCTL.IOCTL_BATTERY_QUERY_TAG,
                                                             ref dwWait,
                                                             Marshal.SizeOf(dwWait),
                                                             ref bqi.BatteryTag,
                                                             Marshal.SizeOf(bqi.BatteryTag),
                                                             out _,
                                                             IntPtr.Zero))
                                {
                                    Kernel32.BATTERY_INFORMATION bi = default;
                                    bqi.InformationLevel = Kernel32.BATTERY_QUERY_INFORMATION_LEVEL.BatteryInformation;

                                    if (Kernel32.DeviceIoControl(battery,
                                                                 Kernel32.IOCTL.IOCTL_BATTERY_QUERY_INFORMATION,
                                                                 ref bqi,
                                                                 Marshal.SizeOf(bqi),
                                                                 ref bi,
                                                                 Marshal.SizeOf(bi),
                                                                 out _,
                                                                 IntPtr.Zero))
                                    {
                                        // Only batteries count.
                                        if (bi.Capabilities == Kernel32.BatteryCapabilities.BATTERY_SYSTEM_BATTERY)
                                        {
                                            const int maxLoadString = 100;

                                            IntPtr ptrDevName = Marshal.AllocCoTaskMem(maxLoadString);
                                            bqi.InformationLevel = Kernel32.BATTERY_QUERY_INFORMATION_LEVEL.BatteryDeviceName;

                                            if (Kernel32.DeviceIoControl(battery,
                                                                         Kernel32.IOCTL.IOCTL_BATTERY_QUERY_INFORMATION,
                                                                         ref bqi,
                                                                         Marshal.SizeOf(bqi),
                                                                         ptrDevName,
                                                                         maxLoadString,
                                                                         out _,
                                                                         IntPtr.Zero))
                                            {
                                                IntPtr ptrManName = Marshal.AllocCoTaskMem(maxLoadString);
                                                bqi.InformationLevel = Kernel32.BATTERY_QUERY_INFORMATION_LEVEL.BatteryManufactureName;

                                                if (Kernel32.DeviceIoControl(battery,
                                                                             Kernel32.IOCTL.IOCTL_BATTERY_QUERY_INFORMATION,
                                                                             ref bqi,
                                                                             Marshal.SizeOf(bqi),
                                                                             ptrManName,
                                                                             maxLoadString,
                                                                             out _,
                                                                             IntPtr.Zero))
                                                {
                                                    string name = Marshal.PtrToStringUni(ptrDevName);
                                                    string manufacturer = Marshal.PtrToStringUni(ptrManName);

                                                    _hardware.Add(new Battery(name, manufacturer, battery, bi, bqi.BatteryTag, settings));
                                                }

                                                Marshal.FreeCoTaskMem(ptrManName);
                                            }

                                            Marshal.FreeCoTaskMem(ptrDevName);
                                        }
                                    }
                                }
                            }
                        }

                        Kernel32.LocalFree(pdidd);
                    }
                }
            }

            SetupApi.SetupDiDestroyDeviceInfoList(hdev);
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<IHardware> Hardware => _hardware;

    /// <inheritdoc />
    public void Close()
    {
        foreach (Battery battery in _hardware)
            battery.Close();
    }

    /// <inheritdoc />
    public string GetReport()
    {
        StringBuilder reportBuilder = new();

        uint count = 1;

        foreach (Battery bat in _hardware)
        {
            string chemistry = bat.Chemistry switch
            {
                BatteryChemistry.LeadAcid => "Lead Acid",
                BatteryChemistry.NickelCadmium => "Nickel-Cadmium",
                BatteryChemistry.NickelMetalHydride => "Nickel-Metal Hydride",
                BatteryChemistry.LithiumIon => "Lithium Ion",
                BatteryChemistry.NickelZinc => "Nickel-Zinc",
                BatteryChemistry.AlkalineManganese => "Rechargeable Alkaline-Manganese",
                _ => "Unknown"
            };

            reportBuilder.Append("Battery #").Append(count).AppendLine(":")
                         .Append(" Name: ").AppendLine(bat.Name)
                         .Append(" Manufacturer: ").AppendLine(bat.Manufacturer)
                         .Append(" Chemistry: ").AppendLine(chemistry)
                         .Append(" Degradation Level: ").AppendFormat("{0:F2}", bat.DegradationLevel).AppendLine(" %")
                         .Append(" Designed Capacity: ").Append(bat.DesignedCapacity).AppendLine(" mWh")
                         .Append(" Full Charged Capacity: ").Append(bat.FullChargedCapacity).AppendLine(" mWh")
                         .Append(" Remaining Capacity: ").Append(bat.RemainingCapacity).AppendLine(" mWh")
                         .Append(" Charge Level: ").AppendFormat("{0:F2}", bat.RemainingCapacity * 100f / bat.FullChargedCapacity).AppendLine(" %")
                         .Append(" Voltage: ").AppendFormat("{0:F3}", bat.Voltage).AppendLine(" V");

            if (bat.RemainingTime != Kernel32.BATTERY_UNKNOWN_TIME)
            {
                reportBuilder.Append(" Remaining Time (Estimated): ").AppendFormat("{0:g}", TimeSpan.FromSeconds(bat.RemainingTime)).AppendLine();
            }

            switch (bat.ChargeDischargeRate)
            {
                case > 0:
                    reportBuilder.Append(" Charge Rate: ").AppendFormat("{0:F1}", bat.ChargeDischargeRate).AppendLine(" W")
                                 .Append(" Charge Current: ").AppendFormat("{0:F3}", bat.ChargeDischargeRate / bat.Voltage).AppendLine(" A");

                    break;
                case < 0:
                    reportBuilder.Append(" Discharge Rate: ").AppendFormat("{0:F1}", Math.Abs(bat.ChargeDischargeRate)).AppendLine(" W")
                                 .Append(" Discharge Current: ").AppendFormat("{0:F3}", Math.Abs(bat.ChargeDischargeRate) / bat.Voltage).AppendLine(" A");

                    break;
                default:
                    reportBuilder.AppendLine(" Charge/Discharge Rate: 0 W")
                                 .AppendLine(" Charge/Discharge Current: 0 A");

                    break;
            }

            reportBuilder.AppendLine();
            count++;
        }

        return reportBuilder.ToString();
    }
}
```

`LibreHardwareMonitorLib/Hardware/CompositeSensor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Linq;

namespace LibreHardwareMonitor.Hardware;

internal class CompositeSensor : Sensor
{
    private readonly ISensor[] _components;
    private readonly Func<float, ISensor, float> _reducer;
    private readonly float _seedValue;

    public CompositeSensor
    (
        string name,
        int index,
        SensorType sensorType,
        Hardware hardware,
        ISettings settings,
        ISensor[] components,
        Func<float, ISensor, float> reducer,
        float seedValue = .0f)
        : base(name, index, sensorType, hardware, settings)
    {
        _components = components;
        _reducer = reducer;
        _seedValue = seedValue;
    }

    public override float? Value
    {
        get { return _components.Aggregate(_seedValue, _reducer); }
        set => throw new NotImplementedException();
    }
}
```

`LibreHardwareMonitorLib/Hardware/Computer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using LibreHardwareMonitor.Hardware.Battery;
using LibreHardwareMonitor.Hardware.Controller.AeroCool;
using LibreHardwareMonitor.Hardware.Controller.AquaComputer;
using LibreHardwareMonitor.Hardware.Controller.Heatmaster;
using LibreHardwareMonitor.Hardware.Controller.Nzxt;
using LibreHardwareMonitor.Hardware.Controller.TBalancer;
using LibreHardwareMonitor.Hardware.CPU;
using LibreHardwareMonitor.Hardware.Gpu;
using LibreHardwareMonitor.Hardware.Memory;
using LibreHardwareMonitor.Hardware.Motherboard;
using LibreHardwareMonitor.Hardware.Network;
using LibreHardwareMonitor.Hardware.Psu.Corsair;
using LibreHardwareMonitor.Hardware.Storage;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Stores all hardware groups and decides which devices should be enabled and updated.
/// </summary>
public class Computer : IComputer
{
    private readonly List<IGroup> _groups = new();
    private readonly object _lock = new();
    private readonly ISettings _settings;
        
    private bool _batteryEnabled;
    private bool _controllerEnabled;
    private bool _cpuEnabled;
    private bool _gpuEnabled;
    private bool _memoryEnabled;
    private bool _motherboardEnabled;
    private bool _networkEnabled;
    private bool _open;
    private bool _psuEnabled;
    private SMBios _smbios;
    private bool _storageEnabled;

    /// <summary>
    /// Creates a new <see cref="IComputer" /> instance with basic initial <see cref="Settings" />.
    /// </summary>
    public Computer()
    {
        _settings = new Settings();
    }

    /// <summary>
    /// Creates a new <see cref="IComputer" /> instance with additional <see cref="ISettings" />.
    /// </summary>
    /// <param name="settings">Computer settings that will be transferred to each <see cref="IHardware" />.</param>
    public Computer(ISettings settings)
    {
        _settings = settings ?? new Settings();
    }

    /// <inheritdoc />
    public event HardwareEventHandler HardwareAdded;

    /// <inheritdoc />
    public event HardwareEventHandler HardwareRemoved;

    /// <inheritdoc />
    public IList<IHardware> Hardware
    {
        get
        {
            lock (_lock)
            {
                List<IHardware> list = new();

                foreach (IGroup group in _groups)
                    list.AddRange(group.Hardware);

                return list;
            }
        }
    }

    /// <inheritdoc />
    public bool IsBatteryEnabled
    {
        get { return _batteryEnabled; }
        set
        {
            if (_open && value != _batteryEnabled)
            {
                if (value)
                {
                    Add(new BatteryGroup(_settings));
                }
                else
                {
                    RemoveType<BatteryGroup>();
                }
            }

            _batteryEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsControllerEnabled
    {
        get { return _controllerEnabled; }
        set
        {
            if (_open && value != _controllerEnabled)
            {
                if (value)
                {
                    Add(new TBalancerGroup(_settings));
                    Add(new HeatmasterGroup(_settings));
                    Add(new AquaComputerGroup(_settings));
                    Add(new AeroCoolGroup(_settings));
                    Add(new NzxtGroup(_settings));
                }
                else
                {
                    RemoveType<TBalancerGroup>();
                    RemoveType<HeatmasterGroup>();
                    RemoveType<AquaComputerGroup>();
                    RemoveType<AeroCoolGroup>();
                    RemoveType<NzxtGroup>();
                }
            }

            _controllerEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsCpuEnabled
    {
        get { return _cpuEnabled; }
        set
        {
            if (_open && value != _cpuEnabled)
            {
                if (value)
                    Add(new CpuGroup(_settings));
                else
                    RemoveType<CpuGroup>();
            }

            _cpuEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsGpuEnabled
    {
        get { return _gpuEnabled; }
        set
        {
            if (_open && value != _gpuEnabled)
            {
                if (value)
                {
                    Add(new AmdGpuGroup(_settings));
                    Add(new NvidiaGroup(_settings));
                    Add(new IntelGpuGroup(GetIntelCpus(), _settings));
                }
                else
                {
                    RemoveType<AmdGpuGroup>();
                    RemoveType<NvidiaGroup>();
                    RemoveType<IntelGpuGroup>();
                }
            }

            _gpuEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsMemoryEnabled
    {
        get { return _memoryEnabled; }
        set
        {
            if (_open && value != _memoryEnabled)
            {
                if (value)
                    Add(new MemoryGroup(_settings));
                else
                    RemoveType<MemoryGroup>();
            }

            _memoryEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsMotherboardEnabled
    {
        get { return _motherboardEnabled; }
        set
        {
            if (_open && value != _motherboardEnabled)
            {
                if (value)
                    Add(new MotherboardGroup(_smbios, _settings));
                else
                    RemoveType<MotherboardGroup>();
            }

            _motherboardEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsNetworkEnabled
    {
        get { return _networkEnabled; }
        set
        {
            if (_open && value != _networkEnabled)
            {
                if (value)
                    Add(new NetworkGroup(_settings));
                else
                    RemoveType<NetworkGroup>();
            }

            _networkEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsPsuEnabled
    {
        get { return _psuEnabled; }
        set
        {
            if (_open && value != _psuEnabled)
            {
                if (value)
                {
                    Add(new CorsairPsuGroup(_settings));
                }
                else
                {
                    RemoveType<CorsairPsuGroup>();
                }
            }

            _psuEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsStorageEnabled
    {
        get { return _storageEnabled; }
        set
        {
            if (_open && value != _storageEnabled)
            {
                if (value)
                    Add(new StorageGroup(_settings));
                else
                    RemoveType<StorageGroup>();
            }

            _storageEnabled = value;
        }
    }

    /// <summary>
    /// Contains computer information table read in accordance with <see href="https://www.dmtf.org/standards/smbios">System Management BIOS (SMBIOS) Reference Specification</see>.
    /// </summary>
    public SMBios SMBios
    {
        get
        {
            if (!_open)
                throw new InvalidOperationException("SMBIOS cannot be accessed before opening.");

            return _smbios;
        }
    }

    //// <inheritdoc />
    public string GetReport()
    {
        lock (_lock)
        {
            using StringWriter w = new(CultureInfo.InvariantCulture);

            w.WriteLine();
            w.WriteLine(nameof(LibreHardwareMonitor) + " Report");
            w.WriteLine();

            Version version = typeof(Computer).Assembly.GetName().Version;

            NewSection(w);
            w.Write("Version: ");
            w.WriteLine(version.ToString());
            w.WriteLine();

            NewSection(w);
            w.Write("Common Language Runtime: ");
            w.WriteLine(Environment.Version.ToString());
            w.Write("Operating System: ");
            w.WriteLine(Environment.OSVersion.ToString());
            w.Write("Process Type: ");
            w.WriteLine(IntPtr.Size == 4 ? "32-Bit" : "64-Bit");
            w.WriteLine();

            string r = Ring0.GetReport();
            if (r != null)
            {
                NewSection(w);
                w.Write(r);
                w.WriteLine();
            }

            NewSection(w);
            w.WriteLine("Sensors");
            w.WriteLine();

            foreach (IGroup group in _groups)
            {
                foreach (IHardware hardware in group.Hardware)
                    ReportHardwareSensorTree(hardware, w, string.Empty);
            }

            w.WriteLine();

            NewSection(w);
            w.WriteLine("Parameters");
            w.WriteLine();

            foreach (IGroup group in _groups)
            {
                foreach (IHardware hardware in group.Hardware)
                    ReportHardwareParameterTree(hardware, w, string.Empty);
            }

            w.WriteLine();

            foreach (IGroup group in _groups)
            {
                string report = group.GetReport();
                if (!string.IsNullOrEmpty(report))
                {
                    NewSection(w);
                    w.Write(report);
                }

                foreach (IHardware hardware in group.Hardware)
                    ReportHardware(hardware, w);
            }

            return w.ToString();
        }
    }

    /// <summary>
    /// Triggers the <see cref="IVisitor.VisitComputer" /> method for the given observer.
    /// </summary>
    /// <param name="visitor">Observer who call to devices.</param>
    public void Accept(IVisitor visitor)
    {
        if (visitor == null)
            throw new ArgumentNullException(nameof(visitor));

        visitor.VisitComputer(this);
    }

    /// <summary>
    /// Triggers the <see cref="IElement.Accept" /> method with the given visitor for each device in each group.
    /// </summary>
    /// <param name="visitor">Observer who call to devices.</param>
    public void Traverse(IVisitor visitor)
    {
        lock (_lock)
        {
            // Use a for-loop instead of foreach to avoid a collection modified exception after sleep, even though everything is under a lock.
            for (int i = 0; i < _groups.Count; i++)
            {
                IGroup group = _groups[i];

                for (int j = 0; j < group.Hardware.Count; j++)
                    group.Hardware[j].Accept(visitor);
            }
        }
    }

    private void HardwareAddedEvent(IHardware hardware)
    {
        HardwareAdded?.Invoke(hardware);
    }

    private void HardwareRemovedEvent(IHardware hardware)
    {
        HardwareRemoved?.Invoke(hardware);
    }

    private void Add(IGroup group)
    {
        if (group == null)
            return;

        lock (_lock)
        {
            if (_groups.Contains(group))
                return;

            _groups.Add(group);

            if (group is IHardwareChanged hardwareChanged)
            {
                hardwareChanged.HardwareAdded += HardwareAddedEvent;
                hardwareChanged.HardwareRemoved += HardwareRemovedEvent;
            }
        }

        if (HardwareAdded != null)
        {
            foreach (IHardware hardware in group.Hardware)
                HardwareAdded(hardware);
        }
    }

    private void Remove(IGroup group)
    {
        lock (_lock)
        {
            if (!_groups.Contains(group))
                return;

            _groups.Remove(group);

            if (group is IHardwareChanged hardwareChanged)
            {
                hardwareChanged.HardwareAdded -= HardwareAddedEvent;
                hardwareChanged.HardwareRemoved -= HardwareRemovedEvent;
            }
        }

        if (HardwareRemoved != null)
        {
            foreach (IHardware hardware in group.Hardware)
                HardwareRemoved(hardware);
        }

        group.Close();
    }

    private void RemoveType<T>() where T : IGroup
    {
        List<T> list = new();

        lock (_lock)
        {
            foreach (IGroup group in _groups)
            {
                if (group is T t)
                    list.Add(t);
            }
        }

        foreach (T group in list)
            Remove(group);
    }

    /// <summary>
    /// If hasn't been opened before, opens <see cref="SMBios" />, <see cref="Ring0" />, <see cref="OpCode" /> and triggers the private <see cref="AddGroups" /> method depending on which categories are
    /// enabled.
    /// </summary>
    public void Open()
    {
        if (_open)
            return;

        _smbios = new SMBios();

        Ring0.Open();
        OpCode.Open();

        AddGroups();

        _open = true;
    }

    private void AddGroups()
    {
        if (_motherboardEnabled)
            Add(new MotherboardGroup(_smbios, _settings));

        if (_cpuEnabled)
            Add(new CpuGroup(_settings));

        if (_memoryEnabled)
            Add(new MemoryGroup(_settings));

        if (_gpuEnabled)
        {
            Add(new AmdGpuGroup(_settings));
            Add(new NvidiaGroup(_settings));
            Add(new IntelGpuGroup(GetIntelCpus(), _settings));
        }

        if (_controllerEnabled)
        {
            Add(new TBalancerGroup(_settings));
            Add(new HeatmasterGroup(_settings));
            Add(new AquaComputerGroup(_settings));
            Add(new AeroCoolGroup(_settings));
            Add(new NzxtGroup(_settings));
        }

        if (_storageEnabled)
            Add(new StorageGroup(_settings));

        if (_networkEnabled)
            Add(new NetworkGroup(_settings));

        if (_psuEnabled)
            Add(new CorsairPsuGroup(_settings));

        if (_batteryEnabled)
            Add(new BatteryGroup(_settings));
    }

    private static void NewSection(TextWriter writer)
    {
        for (int i = 0; i < 8; i++)
            writer.Write("----------");

        writer.WriteLine();
        writer.WriteLine();
    }

    private static int CompareSensor(ISensor a, ISensor b)
    {
        int c = a.SensorType.CompareTo(b.SensorType);
        if (c == 0)
            return a.Index.CompareTo(b.Index);

        return c;
    }

    private static void ReportHardwareSensorTree(IHardware hardware, TextWriter w, string space)
    {
        w.WriteLine("{0}|", space);
        w.WriteLine("{0}+- {1} ({2})", space, hardware.Name, hardware.Identifier);

        ISensor[] sensors = hardware.Sensors;
        Array.Sort(sensors, CompareSensor);

        foreach (ISensor sensor in sensors)
            w.WriteLine("{0}|  +- {1,-14} : {2,8:G6} {3,8:G6} {4,8:G6} ({5})", space, sensor.Name, sensor.Value, sensor.Min, sensor.Max, sensor.Identifier);

        foreach (IHardware subHardware in hardware.SubHardware)
            ReportHardwareSensorTree(subHardware, w, "|  ");
    }

    private static void ReportHardwareParameterTree(IHardware hardware, TextWriter w, string space)
    {
        w.WriteLine("{0}|", space);
        w.WriteLine("{0}+- {1} ({2})", space, hardware.Name, hardware.Identifier);

        ISensor[] sensors = hardware.Sensors;
        Array.Sort(sensors, CompareSensor);

        foreach (ISensor sensor in sensors)
        {
            string innerSpace = space + "|  ";
            if (sensor.Parameters.Count > 0)
            {
                w.WriteLine("{0}|", innerSpace);
                w.WriteLine("{0}+- {1} ({2})", innerSpace, sensor.Name, sensor.Identifier);

                foreach (IParameter parameter in sensor.Parameters)
                {
                    string innerInnerSpace = innerSpace + "|  ";
                    w.WriteLine("{0}+- {1} : {2}", innerInnerSpace, parameter.Name, string.Format(CultureInfo.InvariantCulture, "{0} : {1}", parameter.DefaultValue, parameter.Value));
                }
            }
        }

        foreach (IHardware subHardware in hardware.SubHardware)
            ReportHardwareParameterTree(subHardware, w, "|  ");
    }

    private static void ReportHardware(IHardware hardware, TextWriter w)
    {
        string hardwareReport = hardware.GetReport();
        if (!string.IsNullOrEmpty(hardwareReport))
        {
            NewSection(w);
            w.Write(hardwareReport);
        }

        foreach (IHardware subHardware in hardware.SubHardware)
            ReportHardware(subHardware, w);
    }

    /// <summary>
    /// If opened before, removes all <see cref="IGroup" /> and triggers <see cref="OpCode.Close" />, <see cref="InpOut.Close" /> and <see cref="Ring0.Close" />.
    /// </summary>
    public void Close()
    {
        if (!_open)
            return;

        lock (_lock)
        {
            while (_groups.Count > 0)
            {
                IGroup group = _groups[_groups.Count - 1];
                Remove(group);
            }
        }

        OpCode.Close();
        InpOut.Close();
        Ring0.Close();

        _smbios = null;
        _open = false;
    }

    /// <summary>
    /// If opened before, removes all <see cref="IGroup" /> and recreates it.
    /// </summary>
    public void Reset()
    {
        if (!_open)
            return;

        RemoveGroups();
        AddGroups();
    }

    private void RemoveGroups()
    {
        lock (_lock)
        {
            while (_groups.Count > 0)
            {
                IGroup group = _groups[_groups.Count - 1];
                Remove(group);
            }
        }
    }

    private List<IntelCpu> GetIntelCpus()
    {
        // Create a temporary cpu group if one has not been added.
        lock (_lock)
        {
            IGroup cpuGroup = _groups.Find(x => x is CpuGroup) ?? new CpuGroup(_settings);
            return cpuGroup.Hardware.Select(x => x as IntelCpu).ToList();
        }
    }

    /// <summary>
    /// <see cref="Computer" /> specific additional settings passed to its <see cref="IHardware" />.
    /// </summary>
    private class Settings : ISettings
    {
        public bool Contains(string name)
        {
            return false;
        }

        public void SetValue(string name, string value)
        { }

        public string GetValue(string name, string value)
        {
            return value;
        }

        public void Remove(string name)
        { }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Control.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Globalization;

namespace LibreHardwareMonitor.Hardware;

internal delegate void ControlEventHandler(Control control);

internal class Control : IControl
{
    private readonly ISettings _settings;
    private ControlMode _mode;
    private float _softwareValue;

    public Control
    (
        ISensor sensor,
        ISettings settings,
        float minSoftwareValue,
        float maxSoftwareValue)
    {
        _settings = settings;

        Identifier = new Identifier(sensor.Identifier, "control");
        Sensor = sensor;
        MinSoftwareValue = minSoftwareValue;
        MaxSoftwareValue = maxSoftwareValue;

        if (!float.TryParse(settings.GetValue(new Identifier(Identifier, "value").ToString(), "0"), NumberStyles.Float, CultureInfo.InvariantCulture, out _softwareValue))
            _softwareValue = 0;

        if (!int.TryParse(settings.GetValue(new Identifier(Identifier, "mode").ToString(), ((int)ControlMode.Undefined).ToString(CultureInfo.InvariantCulture)),
                          NumberStyles.Integer,
                          CultureInfo.InvariantCulture,
                          out int mode))
        {
            _mode = ControlMode.Undefined;
        }
        else
            _mode = (ControlMode)mode;
    }

    internal event ControlEventHandler ControlModeChanged;

    internal event ControlEventHandler SoftwareControlValueChanged;

    public ControlMode ControlMode
    {
        get { return _mode; }
        private set
        {
            if (_mode != value)
            {
                _mode = value;
                ControlModeChanged?.Invoke(this);
                _settings.SetValue(new Identifier(Identifier, "mode").ToString(), ((int)_mode).ToString(CultureInfo.InvariantCulture));
            }
        }
    }

    public Identifier Identifier { get; }

    public float MaxSoftwareValue { get; }

    public float MinSoftwareValue { get; }

    public ISensor Sensor { get; }

    public float SoftwareValue
    {
        get { return _softwareValue; }
        private set
        {
            if (_softwareValue != value)
            {
                _softwareValue = value;
                SoftwareControlValueChanged?.Invoke(this);
                _settings.SetValue(new Identifier(Identifier, "value").ToString(), value.ToString(CultureInfo.InvariantCulture));
            }
        }
    }

    public void SetDefault()
    {
        ControlMode = ControlMode.Default;
    }

    public void SetSoftware(float value)
    {
        ControlMode = ControlMode.Software;
        SoftwareValue = value;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AeroCool/AeroCoolGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AeroCool;

public class AeroCoolGroup : IGroup
{
    private readonly List<IHardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public AeroCoolGroup(ISettings settings)
    {
        _report.AppendLine("AeroCool Hardware");
        _report.AppendLine();

        foreach (HidDevice dev in DeviceList.Local.GetHidDevices(0x2E97))
        {
            int hubno = dev.ProductID - 0x1000;
            if (dev.DevicePath.Contains("mi_02") && hubno is >= 1 and <= 8)
            {
                var device = new P7H1(dev, settings);
                _report.AppendLine($"Device name: {device.Name}");
                _report.AppendLine($"HUB number: {device.HubNumber}");
                _report.AppendLine();
                _hardware.Add(device);
            }
        }

        if (_hardware.Count == 0)
        {
            _report.AppendLine("No AeroCool Hardware found.");
            _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (IHardware iHardware in _hardware)
        {
            if (iHardware is Hardware hardware)
                hardware.Close();
        }
    }

    public string GetReport()
    {
        return _report.ToString();
    }
}
```

`LibreHardwareMonitorLib/Hardware/Controller/AeroCool/P7-H1.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Threading.Tasks;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AeroCool;

internal sealed class P7H1 : Hardware
{
    private const byte REPORT_ID = 0x0;
    private readonly HidDevice _device;

    private readonly Sensor[] _rpm = new Sensor[5];
    private readonly float[] _speeds = new float[5];
    private readonly HidStream _stream;
    private bool _running;

    public P7H1(HidDevice dev, ISettings settings) : base("AeroCool P7-H1", new Identifier(dev.DevicePath), settings)
    {
        _device = dev;
        HubNumber = _device.ProductID - 0x1000;
        Name = $"AeroCool P7-H1 #{HubNumber}";

        if (_device.TryOpen(out _stream))
        {
            _running = true;

            Task.Run(ReadStream);

            for (int i = 0; i < 5; i++)
            {
                _rpm[i] = new Sensor($"Fan #{i + 1}", i, SensorType.Fan, this, settings);
                ActivateSensor(_rpm[i]);
            }
        }
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public int HubNumber { get; }

    private void ReadStream()
    {
        byte[] inputReportBuffer = new byte[_device.GetMaxInputReportLength()];

        while (_running)
        {
            IAsyncResult ar = null;

            while (_running)
            {
                ar ??= _stream.BeginRead(inputReportBuffer, 0, inputReportBuffer.Length, null, null);

                if (ar.IsCompleted)
                {
                    int byteCount = _stream.EndRead(ar);
                    ar = null;

                    if (byteCount == 16 && inputReportBuffer[0] == REPORT_ID)
                    {
                        for (int i = 0; i < 5; i++)
                        {
                            _speeds[i] = (inputReportBuffer[(i * 3) + 2] * 256) + inputReportBuffer[(i * 3) + 3];
                        }
                    }
                }
                else
                {
                    ar.AsyncWaitHandle.WaitOne(1000);
                }
            }
        }
    }

    public override void Close()
    {
        _running = false;
        _stream.Close();
        base.Close();
    }

    public override void Update()
    {
        for (int i = 0; i < 5; i++)
        {
            _rpm[i].Value = _speeds[i];
        }
    }
}
```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/AquaComputerGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;

public class AquaComputerGroup : IGroup
{
    private readonly List<IHardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public AquaComputerGroup(ISettings settings)
    {
        _report.AppendLine("AquaComputer Hardware");
        _report.AppendLine();

        foreach (HidDevice dev in DeviceList.Local.GetHidDevices(0x0c70))
        {
            string productName = dev.GetProductName();
            productName = productName.Substring(0, 1).ToUpper() + productName.Substring(1);

            switch (dev.ProductID)
            {
                case 0xF00E:
                    var d5Next = new D5Next(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {d5Next.FirmwareVersion}");
                    _report.AppendLine();
                    _hardware.Add(d5Next);
                    break;

                case 0xf0b6:
                    var aquastreamXt = new AquastreamXT(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Device variant: {aquastreamXt.Variant}");
                    _report.AppendLine($"Firmware version: {aquastreamXt.FirmwareVersion}");
                    _report.AppendLine($"{aquastreamXt.Status}");
                    _report.AppendLine();
                    _hardware.Add(aquastreamXt);
                    break;

                case 0xf003:
                    var mps = new MPS(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {mps.FirmwareVersion}");
                    _report.AppendLine($"{mps.Status}");
                    _report.AppendLine();
                    _hardware.Add(mps);
                    break;

                case 0xF011:
                    var octo = new Octo(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {octo.FirmwareVersion}");
                    _report.AppendLine();
                    _hardware.Add(octo);
                    break;

                default:
                    _report.AppendLine($"Unknown Hardware PID: {dev.ProductID} Name: {productName}");
                    _report.AppendLine();
                    break;
            }
        }

        if (_hardware.Count == 0)
        {
            _report.AppendLine("No AquaComputer Hardware found.");
            _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (IHardware iHardware in _hardware)
        {
            if (iHardware is Hardware hardware)
                hardware.Close();
        }
    }

    public string GetReport()
    {
        return _report.ToString();
    }
}
```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/AquastreamXT.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;
//TODO:
//Check tested and fix unknown variables in Update()
//Check if property "Variant" is valid interpreted
//Implement Fan Control in SetControl()

internal sealed class AquastreamXT : Hardware
{
    private readonly Sensor _fanControl;
    private readonly Sensor[] _frequencies = new Sensor[2];
    private readonly Sensor _pumpFlow;
    private readonly Sensor _pumpPower;
    private readonly byte[] _rawData = new byte[64];
    private readonly Sensor[] _rpmSensors = new Sensor[2];
    private readonly HidStream _stream;
    private readonly Sensor[] _temperatures = new Sensor[3];
    private readonly Sensor[] _voltages = new Sensor[2];

    public AquastreamXT(HidDevice dev, ISettings settings) : base("Aquastream XT", new Identifier(dev.DevicePath), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            do
            {
                _rawData[0] = 0x4;
                _stream.GetFeature(_rawData);
            }
            while (_rawData[0] != 0x4);

            Name = $"Aquastream XT {Variant}";
            FirmwareVersion = BitConverter.ToUInt16(_rawData, 50);

            _temperatures[0] = new Sensor("External Fan VRM", 0, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[0]);
            _temperatures[1] = new Sensor("External", 1, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[1]);
            _temperatures[2] = new Sensor("Internal Water", 2, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[2]);

            _voltages[0] = new Sensor("External Fan", 1, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_voltages[0]);
            _voltages[1] = new Sensor("Pump", 2, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_voltages[1]);

            _pumpPower = new Sensor("Pump", 0, SensorType.Power, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_pumpPower);

            _pumpFlow = new Sensor("Pump", 0, SensorType.Flow, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_pumpFlow);

            _rpmSensors[0] = new Sensor("External Fan", 0, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_rpmSensors[0]);
            _rpmSensors[1] = new Sensor("Pump", 1, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_rpmSensors[1]);

            _fanControl = new Sensor("External Fan", 0, SensorType.Control, this, Array.Empty<ParameterDescription>(), settings);
            _fanControl.Control = new Control(_fanControl, settings, 0, 100);

            ActivateSensor(_fanControl);
            _frequencies[0] = new Sensor("Pump Frequency", 0, SensorType.Frequency, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_frequencies[0]);
            _frequencies[1] = new Sensor("Pump MaxFrequency", 1, SensorType.Frequency, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_frequencies[1]);
        }
    }

    public ushort FirmwareVersion { get; private set; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public string Status
    {
        get
        {
            FirmwareVersion = BitConverter.ToUInt16(_rawData, 50);
            return FirmwareVersion < 1008 ? $"Status: Untested Firmware Version {FirmwareVersion}! Please consider Updating to Version 1018" : "Status: OK";
        }
    }

    //TODO: Check if valid
    public string Variant
    {
        get
        {
            MODE mode = (MODE)_rawData[33];

            if (mode.HasFlag(MODE.MODE_PUMP_ADV))
                return "Ultra + Internal Flow Sensor";

            if (mode.HasFlag(MODE.MODE_FAN_CONTROLLER))
                return "Ultra";

            if (mode.HasFlag(MODE.MODE_FAN_AMP))
                return "Advanced";

            return "Standard";
        }
    }

    public override void Close()
    {
        _stream.Close();

        base.Close();
    }

    //TODO: Check tested and fix unknown variables
    public override void Update()
    {
        _rawData[0] = 0x4;
        _stream.GetFeature(_rawData);

        if (_rawData[0] != 0x4)
            return;

        //var rawSensorsFan = BitConverter.ToUInt16(rawData, 1);                        //unknown - redundant?
        //var rawSensorsExt = BitConverter.ToUInt16(rawData, 3);                        //unknown - redundant?
        //var rawSensorsWater = BitConverter.ToUInt16(rawData, 5);                      //unknown - redundant?

        _voltages[0].Value = BitConverter.ToUInt16(_rawData, 7) / 61f; //External Fan Voltage: tested - OK
        _voltages[1].Value = BitConverter.ToUInt16(_rawData, 9) / 61f; //Pump Voltage: tested - OK
        _pumpPower.Value = _voltages[1].Value * BitConverter.ToInt16(_rawData, 11) / 625f; //Pump Voltage * Pump Current: tested - OK

        _temperatures[0].Value = BitConverter.ToUInt16(_rawData, 13) / 100f; //External Fan VRM Temperature: untested
        _temperatures[1].Value = BitConverter.ToUInt16(_rawData, 15) / 100f; //External Temperature Sensor: untested
        _temperatures[2].Value = BitConverter.ToUInt16(_rawData, 17) / 100f; //Internal Water Temperature Sensor: tested - OK

        _frequencies[0].Value = (1f / BitConverter.ToInt16(_rawData, 19)) * 750000; //Pump Frequency: tested - OK
        _rpmSensors[1].Value = _frequencies[0].Value * 60f; //Pump RPM: tested - OK
        _frequencies[1].Value = (1f / BitConverter.ToUInt16(_rawData, 21)) * 750000; //Pump Max Frequency: tested - OK

        _pumpFlow.Value = BitConverter.ToUInt32(_rawData, 23); //Internal Pump Flow Sensor: unknown

        _rpmSensors[0].Value = BitConverter.ToUInt32(_rawData, 27); //External Fan RPM: untested

        _fanControl.Value = 100f / byte.MaxValue * _rawData[31]; //External Fan Control: tested, External Fan Voltage scales by this value - OK
    }

    [Flags]
    [SuppressMessage("ReSharper", "InconsistentNaming")]
    private enum MODE : byte
    {
        MODE_PUMP_ADV = 1,
        MODE_FAN_AMP = 2,
        MODE_FAN_CONTROLLER = 4
    }
}
```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/D5Next.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;

internal sealed class D5Next : Hardware
{
    //Available Reports, found them by looking at the below methods
    //var test = dev.GetRawReportDescriptor();
    //var test2 = dev.GetReportDescriptor();

    // ID 1; Length 158; INPUT
    // ID 2; Length 11; OUTPUT
    // ID 3; Length 1025; <-- works FEATURE
    // ID 8; Length 1025; <-- works FEATURE
    // ID 12; Length 1025; <-- 0xC FEATURE

    private readonly byte[] _rawData = new byte[1025];
    private readonly Sensor[] _rpmSensors = new Sensor[1];
    private readonly HidStream _stream;
    private readonly Sensor[] _temperatures = new Sensor[1];

    public D5Next(HidDevice dev, ISettings settings) : base("D5Next", new Identifier(dev.DevicePath), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            //Reading output report instead of feature report, as the measurements are in the output report
            _stream.Read(_rawData);

            Name = "D5Next";
            FirmwareVersion = Convert.ToUInt16(_rawData[14] | (_rawData[13] << 8));
            _temperatures[0] = new Sensor("Water Temperature", 0, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[0]);

            _rpmSensors[0] = new Sensor("Pump", 0, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_rpmSensors[0]);
        }
    }

    public ushort FirmwareVersion { get; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public override void Close()
    {
        _stream.Close();
        base.Close();
    }

    public override void Update()
    {
        //Reading output report instead of feature report, as the measurements are in the output report
        _stream.Read(_rawData);
        _temperatures[0].Value = (_rawData[88] | (_rawData[87] << 8)) / 100f; //Water Temp
        _rpmSensors[0].Value = _rawData[117] | (_rawData[116] << 8); //Pump RPM
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/MPS.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;

internal sealed class MPS : Hardware
{
    public const int ExternalTemperature = 43;
    public const int InternalWaterTemperature = 45;
    public const int PumpFlow = 35;
    private const byte MPS_REPORT_ID = 0x2;

    private readonly Sensor _pumpFlow;
    private readonly byte[] _rawData = new byte[64];
    private readonly HidStream _stream;
    private readonly Sensor[] _temperatures = new Sensor[2];

    private ushort _externalTemperature;

    public MPS(HidDevice dev, ISettings settings) : base("MPS", new Identifier(dev.DevicePath), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            do
            {
                _rawData[0] = MPS_REPORT_ID;
                _stream.GetFeature(_rawData);
            }
            while (_rawData[0] != MPS_REPORT_ID);

            Name = "MPS";
            FirmwareVersion = ExtractFirmwareVersion();

            _temperatures[0] = new Sensor("External", 0, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[0]);
            _temperatures[1] = new Sensor("Internal Water", 1, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[1]);

            _pumpFlow = new Sensor("Pump", 0, SensorType.Flow, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_pumpFlow);
        }
    }

    public ushort FirmwareVersion { get; private set; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public string Status
    {
        get
        {
            FirmwareVersion = ExtractFirmwareVersion();
            if (FirmwareVersion < 1012)
            {
                return $"Status: Untested Firmware Version {FirmwareVersion}! Please consider Updating to Version 1012";
            }

            return "Status: OK";
        }
    }

    public override void Close()
    {
        _stream.Close();

        base.Close();
    }

    public override void Update()
    {
        _rawData[0] = MPS_REPORT_ID;
        _stream.GetFeature(_rawData);

        if (_rawData[0] != MPS_REPORT_ID)
            return;

        _pumpFlow.Value = BitConverter.ToUInt16(_rawData, PumpFlow) / 10f;

        _externalTemperature = BitConverter.ToUInt16(_rawData, ExternalTemperature);
        //sensor reading returns Int16.MaxValue (32767), when not connected
        if (_externalTemperature != short.MaxValue)
        {
            _temperatures[0].Value = _externalTemperature / 100f;
        }
        else
        {
            _temperatures[0].Value = null;
        }

        _temperatures[1].Value = BitConverter.ToUInt16(_rawData, InternalWaterTemperature) / 100f;
    }

    private ushort ExtractFirmwareVersion()
    {
        return BitConverter.ToUInt16(_rawData, 3);
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/Octo.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;

internal sealed class Octo : Hardware
{
    private readonly byte[] _rawData = new byte[1025];
    private readonly Sensor[] _rpmSensors = new Sensor[8];
    private readonly HidStream _stream;
    private readonly Sensor[] _temperatures = new Sensor[4];
    private readonly Sensor[] _voltages = new Sensor[9];
    private readonly Sensor[] _currents = new Sensor[8];
    private readonly Sensor[] _powers = new Sensor[8];

    public Octo(HidDevice dev, ISettings settings) : base("Octo", new Identifier(dev.DevicePath), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            //Reading output report instead of feature report, as the measurements are in the output report
            _stream.Read(_rawData);
                
            Name = "OCTO";
            FirmwareVersion = GetConvertedValue(OctoDataIndexes.FIRMWARE_VERSION).GetValueOrDefault(0);

            // Initialize the 4 temperature sensors
            for (int i = 0; i < 4; i++)
            {
                _temperatures[i] = new Sensor($"Temperature {i+1}", i, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_temperatures[i]);
            }

            // Initialize the 8 fan speed sensors
            for (int i = 0; i < 8; i++)
            {
                _rpmSensors[i] = new Sensor($"Fan {i+1}", i, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_rpmSensors[i]);
            }
                
            // Initialize the input voltage sensor
            _voltages[0] = new Sensor("Input", 0, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_voltages[0]);

            // Initialize the 8 fan voltage sensors
            for (int i = 1; i < 9; i++)
            {
                _voltages[i] = new Sensor($"Fan {i}", i, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_voltages[i]);
            }
                
            // Initialize the 8 fan current sensors
            for (int i = 0; i < 8; i++)
            {
                _currents[i] = new Sensor($"Fan {i+1}", i, SensorType.Current, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_currents[i]);
            }
                
            // Initialize the 8 fan power sensors
            for (int i = 0; i < 8; i++)
            {
                _powers[i] = new Sensor($"Fan {i+1}", i, SensorType.Power, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_powers[i]);
            }
        }
    }

    public ushort FirmwareVersion { get; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public override void Close()
    {
        _stream.Close();
        base.Close();
    }

    public override void Update()
    {
        //Reading output report instead of feature report, as the measurements are in the output report
        _stream.Read(_rawData);
            
        _temperatures[0].Value = GetConvertedValue(OctoDataIndexes.TEMP_1) / 100f; // Temp 1
        _temperatures[1].Value = GetConvertedValue(OctoDataIndexes.TEMP_2) / 100f; // Temp 2
        _temperatures[2].Value = GetConvertedValue(OctoDataIndexes.TEMP_3) / 100f; // Temp 3
        _temperatures[3].Value = GetConvertedValue(OctoDataIndexes.TEMP_4) / 100f; // Temp 4

        _rpmSensors[0].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_1); // Fan 1 speed
        _rpmSensors[1].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_2); // Fan 2 speed
        _rpmSensors[2].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_3); // Fan 3 speed
        _rpmSensors[3].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_4); // Fan 4 speed
        _rpmSensors[4].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_5); // Fan 5 speed
        _rpmSensors[5].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_6); // Fan 6 speed
        _rpmSensors[6].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_7); // Fan 7 speed
        _rpmSensors[7].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_8); // Fan 8 speed
            
        _voltages[0].Value = GetConvertedValue(OctoDataIndexes.VOLTAGE) / 100f; // Input voltage
        _voltages[1].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_1) / 100f; // Fan 1 voltage
        _voltages[2].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_2) / 100f; // Fan 2 voltage
        _voltages[3].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_3) / 100f; // Fan 3 voltage
        _voltages[4].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_4) / 100f; // Fan 4 voltage
        _voltages[5].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_5) / 100f; // Fan 5 voltage
        _voltages[6].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_6) / 100f; // Fan 6 voltage
        _voltages[7].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_7) / 100f; // Fan 7 voltage
        _voltages[8].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_8) / 100f; // Fan 8 voltage
            
        _currents[0].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_1) / 1000f; // Fan 1 current
        _currents[1].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_2) / 1000f; // Fan 2 current
        _currents[2].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_3) / 1000f; // Fan 3 current
        _currents[3].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_4) / 1000f; // Fan 4 current
        _currents[4].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_5) / 1000f; // Fan 5 current
        _currents[5].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_6) / 1000f; // Fan 6 current
        _currents[6].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_7) / 1000f; // Fan 7 current
        _currents[7].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_8) / 1000f; // Fan 8 current
            
        _powers[0].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_1) / 100f; // Fan 1 power
        _powers[1].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_2) / 100f; // Fan 2 power
        _powers[2].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_3) / 100f; // Fan 3 power
        _powers[3].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_4) / 100f; // Fan 4 power
        _powers[4].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_5) / 100f; // Fan 5 power
        _powers[5].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_6) / 100f; // Fan 6 power
        _powers[6].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_7) / 100f; // Fan 7 power
        _powers[7].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_8) / 100f; // Fan 8 power
    }

    private sealed class OctoDataIndexes
    {
        public const int FIRMWARE_VERSION = 13;
            
        public const int TEMP_1 = 61;
        public const int TEMP_2 = 63;
        public const int TEMP_3 = 65;
        public const int TEMP_4 = 67;

        public const int FAN_SPEED_1 = 133;
        public const int FAN_SPEED_2 = 146;
        public const int FAN_SPEED_3 = 159;
        public const int FAN_SPEED_4 = 172;
        public const int FAN_SPEED_5 = 185;
        public const int FAN_SPEED_6 = 198;
        public const int FAN_SPEED_7 = 211;
        public const int FAN_SPEED_8 = 224;
            
        public const int FAN_POWER_1 = 131;
        public const int FAN_POWER_2 = 144;
        public const int FAN_POWER_3 = 157;
        public const int FAN_POWER_4 = 170;
        public const int FAN_POWER_5 = 183;
        public const int FAN_POWER_6 = 196;
        public const int FAN_POWER_7 = 209;
        public const int FAN_POWER_8 = 222;

        public const int VOLTAGE = 117;
        public const int FAN_VOLTAGE_1 = 127;
        public const int FAN_VOLTAGE_2 = 140;
        public const int FAN_VOLTAGE_3 = 153;
        public const int FAN_VOLTAGE_4 = 166;
        public const int FAN_VOLTAGE_5 = 179;
        public const int FAN_VOLTAGE_6 = 192;
        public const int FAN_VOLTAGE_7 = 205;
        public const int FAN_VOLTAGE_8 = 218;
            
        public const int FAN_CURRENT_1 = 129;
        public const int FAN_CURRENT_2 = 142;
        public const int FAN_CURRENT_3 = 155;
        public const int FAN_CURRENT_4 = 168;
        public const int FAN_CURRENT_5 = 181;
        public const int FAN_CURRENT_6 = 194;
        public const int FAN_CURRENT_7 = 207;
        public const int FAN_CURRENT_8 = 220;
    }

    private ushort? GetConvertedValue(int index)
    {
        if (_rawData[index] == sbyte.MaxValue)
            return null;
            
        return Convert.ToUInt16(_rawData[index + 1] | (_rawData[index] << 8));
    }
}
```

`LibreHardwareMonitorLib/Hardware/Controller/Heatmaster/Heatmaster.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;
using System.IO;
using System.IO.Ports;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace LibreHardwareMonitor.Hardware.Controller.Heatmaster;

internal sealed class Heatmaster : Hardware, IDisposable
{
    private readonly bool _available;
    private readonly StringBuilder _buffer = new();
    private readonly Sensor[] _controls;
    private readonly Sensor[] _fans;
    private readonly int _firmwareCrc;
    private readonly int _firmwareRevision;
    private readonly Sensor[] _flows;
    private readonly int _hardwareRevision;
    private readonly string _portName;
    private readonly Sensor[] _relays;
    private readonly Sensor[] _temperatures;
    private SerialPort _serialPort;

    public Heatmaster(string portName, ISettings settings) : base("Heatmaster", new Identifier("heatmaster", portName.TrimStart('/').ToLowerInvariant()), settings)
    {
        _portName = portName;
        try
        {
            _serialPort = new SerialPort(portName, 38400, Parity.None, 8, StopBits.One);
            _serialPort.Open();
            _serialPort.NewLine = ((char)0x0D).ToString();

            _hardwareRevision = ReadInteger(0, 'H');
            _firmwareRevision = ReadInteger(0, 'V');
            _firmwareCrc = ReadInteger(0, 'C');

            int fanCount = Math.Min(ReadInteger(32, '?'), 4);
            int temperatureCount = Math.Min(ReadInteger(48, '?'), 6);
            int flowCount = Math.Min(ReadInteger(64, '?'), 1);
            int relayCount = Math.Min(ReadInteger(80, '?'), 1);

            _fans = new Sensor[fanCount];
            _controls = new Sensor[fanCount];
            for (int i = 0; i < fanCount; i++)
            {
                int device = 33 + i;
                string name = ReadString(device, 'C');
                _fans[i] = new Sensor(name, device, SensorType.Fan, this, settings) { Value = ReadInteger(device, 'R') };
                ActivateSensor(_fans[i]);
                _controls[i] = new Sensor(name, device, SensorType.Control, this, settings) { Value = (100 / 255.0f) * ReadInteger(device, 'P') };
                ActivateSensor(_controls[i]);
            }

            _temperatures = new Sensor[temperatureCount];
            for (int i = 0; i < temperatureCount; i++)
            {
                int device = 49 + i;
                string name = ReadString(device, 'C');
                _temperatures[i] = new Sensor(name, device, SensorType.Temperature, this, settings);
                int value = ReadInteger(device, 'T');
                _temperatures[i].Value = 0.1f * value;
                if (value != -32768)
                    ActivateSensor(_temperatures[i]);
            }

            _flows = new Sensor[flowCount];
            for (int i = 0; i < flowCount; i++)
            {
                int device = 65 + i;
                string name = ReadString(device, 'C');
                _flows[i] = new Sensor(name, device, SensorType.Flow, this, settings) { Value = 0.1f * ReadInteger(device, 'L') };
                ActivateSensor(_flows[i]);
            }

            _relays = new Sensor[relayCount];
            for (int i = 0; i < relayCount; i++)
            {
                int device = 81 + i;
                string name = ReadString(device, 'C');
                _relays[i] = new Sensor(name, device, SensorType.Control, this, settings)
                {
                    Value = 100 * ReadInteger(device, 'S')
                };
                ActivateSensor(_relays[i]);
            }

            // set the update rate to 2 Hz
            WriteInteger(0, 'L', 2);
            _available = true;
        }
        catch (IOException)
        { }
        catch (TimeoutException)
        { }
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public void Dispose()
    {
        if (_serialPort != null)
        {
            _serialPort.Dispose();
            _serialPort = null;
        }
    }

    private string ReadLine(int timeout)
    {
        int i = 0;
        StringBuilder builder = new();
        while (i <= timeout)
        {
            while (_serialPort.BytesToRead > 0)
            {
                byte b = (byte)_serialPort.ReadByte();
                switch (b)
                {
                    case 0xAA: return ((char)b).ToString();
                    case 0x0D: return builder.ToString();
                    default:
                        builder.Append((char)b);
                        break;
                }
            }

            i++;
            Thread.Sleep(1);
        }

        throw new TimeoutException();
    }

    private string ReadField(int device, char field)
    {
        _serialPort.WriteLine("[0:" + device + "]R" + field);
        for (int i = 0; i < 5; i++)
        {
            string s = ReadLine(200);
            Match match = Regex.Match(s, @"-\[0:" + device.ToString(CultureInfo.InvariantCulture) + @"\]R" + Regex.Escape(field.ToString(CultureInfo.InvariantCulture)) + ":(.*)");
            if (match.Success)
                return match.Groups[1].Value;
        }

        return null;
    }

    private string ReadString(int device, char field)
    {
        string s = ReadField(device, field);
        if (s?[0] == '"' && s[s.Length - 1] == '"')
            return s.Substring(1, s.Length - 2);

        return null;
    }

    private int ReadInteger(int device, char field)
    {
        string s = ReadField(device, field);
        if (int.TryParse(s, out int i))
            return i;

        return 0;
    }

    private void WriteField(int device, char field, string value)
    {
        _serialPort.WriteLine("[0:" + device + "]W" + field + ":" + value);
        for (int i = 0; i < 5; i++)
        {
            string s = ReadLine(200);
            Match match = Regex.Match(s, @"-\[0:" + device.ToString(CultureInfo.InvariantCulture) + @"\]W" + Regex.Escape(field.ToString(CultureInfo.InvariantCulture)) + ":" + value);
            if (match.Success)
                return;
        }
    }

    private void WriteInteger(int device, char field, int value)
    {
        WriteField(device, field, value.ToString(CultureInfo.InvariantCulture));
    }

    private void ProcessUpdateLine(string line)
    {
        Match match = Regex.Match(line, @">\[0:(\d+)\]([0-9:\|-]+)");
        if (match.Success && int.TryParse(match.Groups[1].Value, out int device))
        {
            foreach (string s in match.Groups[2].Value.Split('|'))
            {
                string[] strings = s.Split(':');
                int[] ints = new int[strings.Length];
                bool valid = true;
                for (int i = 0; i < ints.Length; i++)
                {
                    if (!int.TryParse(strings[i], out ints[i]))
                    {
                        valid = false;
                        break;
                    }
                }

                if (!valid)
                    continue;

                switch (device)
                {
                    case 32:
                        if (ints.Length == 3 && ints[0] <= _fans.Length)
                        {
                            _fans[ints[0] - 1].Value = ints[1];
                            _controls[ints[0] - 1].Value = (100 / 255.0f) * ints[2];
                        }

                        break;
                    case 48:
                        if (ints.Length == 2 && ints[0] <= _temperatures.Length)
                            _temperatures[ints[0] - 1].Value = 0.1f * ints[1];

                        break;
                    case 64:
                        if (ints.Length == 3 && ints[0] <= _flows.Length)
                            _flows[ints[0] - 1].Value = 0.1f * ints[1];

                        break;
                    case 80:
                        if (ints.Length == 2 && ints[0] <= _relays.Length)
                            _relays[ints[0] - 1].Value = 100 * ints[1];

                        break;
                }
            }
        }
    }

    public override void Update()
    {
        if (!_available)
            return;

        while (_serialPort.IsOpen && _serialPort.BytesToRead > 0)
        {
            byte b = (byte)_serialPort.ReadByte();
            if (b == 0x0D)
            {
                ProcessUpdateLine(_buffer.ToString());
                _buffer.Length = 0;
            }
            else
            {
                _buffer.Append((char)b);
            }
        }
    }

    public override string GetReport()
    {
        StringBuilder r = new();
        r.AppendLine("Heatmaster");
        r.AppendLine();
        r.Append("Port: ");
        r.AppendLine(_portName);
        r.Append("Hardware Revision: ");
        r.AppendLine(_hardwareRevision.ToString(CultureInfo.InvariantCulture));
        r.Append("Firmware Revision: ");
        r.AppendLine(_firmwareRevision.ToString(CultureInfo.InvariantCulture));
        r.Append("Firmware CRC: ");
        r.AppendLine(_firmwareCrc.ToString(CultureInfo.InvariantCulture));
        r.AppendLine();
        return r.ToString();
    }

    public override void Close()
    {
        _serialPort.Close();
        _serialPort.Dispose();
        _serialPort = null;
        base.Close();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Heatmaster/HeatmasterGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO.Ports;
using System.Security;
using System.Text;
using System.Threading;
using Microsoft.Win32;

namespace LibreHardwareMonitor.Hardware.Controller.Heatmaster;

internal class HeatmasterGroup : IGroup
{
    private readonly List<Heatmaster> _hardware = new();
    private readonly StringBuilder _report = new();

    public HeatmasterGroup(ISettings settings)
    {
        // No implementation for Heatmaster on Unix systems
        if (Software.OperatingSystem.IsUnix)
            return;

        string[] portNames = GetRegistryPortNames();
        for (int i = 0; i < portNames.Length; i++)
        {
            bool isValid = false;
            try
            {
                using SerialPort serialPort = new(portNames[i], 38400, Parity.None, 8, StopBits.One);
                serialPort.NewLine = ((char)0x0D).ToString();
                _report.Append("Port Name: ");
                _report.AppendLine(portNames[i]);
                try
                {
                    serialPort.Open();
                }
                catch (UnauthorizedAccessException)
                {
                    _report.AppendLine("Exception: Access Denied");
                }

                if (serialPort.IsOpen)
                {
                    serialPort.DiscardInBuffer();
                    serialPort.DiscardOutBuffer();
                    serialPort.Write(new byte[] { 0xAA }, 0, 1);

                    int j = 0;
                    while (serialPort.BytesToRead == 0 && j < 10)
                    {
                        Thread.Sleep(20);
                        j++;
                    }

                    if (serialPort.BytesToRead > 0)
                    {
                        bool flag = false;
                        while (serialPort.BytesToRead > 0 && !flag)
                        {
                            flag |= serialPort.ReadByte() == 0xAA;
                        }

                        if (flag)
                        {
                            serialPort.WriteLine("[0:0]RH");
                            try
                            {
                                int k = 0;
                                int revision = 0;
                                while (k < 5)
                                {
                                    string line = ReadLine(serialPort, 100);
                                    if (line.StartsWith("-[0:0]RH:", StringComparison.Ordinal))
                                    {
                                        revision = int.Parse(line.Substring(9), CultureInfo.InvariantCulture);
                                        break;
                                    }

                                    k++;
                                }

                                isValid = revision == 770;
                                if (!isValid)
                                {
                                    _report.Append("Status: Wrong Hardware Revision " + revision.ToString(CultureInfo.InvariantCulture));
                                }
                            }
                            catch (TimeoutException)
                            {
                                _report.AppendLine("Status: Timeout Reading Revision");
                            }
                        }
                        else
                        {
                            _report.AppendLine("Status: Wrong Startflag");
                        }
                    }
                    else
                    {
                        _report.AppendLine("Status: No Response");
                    }

                    serialPort.DiscardInBuffer();
                }
                else
                {
                    _report.AppendLine("Status: Port not Open");
                }
            }
            catch (Exception e)
            {
                _report.AppendLine(e.ToString());
            }

            if (isValid)
            {
                _report.AppendLine("Status: OK");
                _hardware.Add(new Heatmaster(portNames[i], settings));
            }

            _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        if (_report.Length > 0)
        {
            StringBuilder r = new();
            r.AppendLine("Serial Port Heatmaster");
            r.AppendLine();
            r.Append(_report);
            r.AppendLine();
            return r.ToString();
        }

        return null;
    }

    public void Close()
    {
        foreach (Heatmaster heatmaster in _hardware)
            heatmaster.Close();
    }

    private static string ReadLine(SerialPort port, int timeout)
    {
        int i = 0;
        StringBuilder builder = new();
        while (i < timeout)
        {
            while (port.BytesToRead > 0)
            {
                byte b = (byte)port.ReadByte();
                switch (b)
                {
                    case 0xAA: return ((char)b).ToString();
                    case 0x0D: return builder.ToString();
                    default:
                        builder.Append((char)b);
                        break;
                }
            }

            i++;
            Thread.Sleep(1);
        }

        throw new TimeoutException();
    }

    private static string[] GetRegistryPortNames()
    {
        List<string> result = new();
        string[] paths = { string.Empty, "&MI_00" };
        try
        {
            foreach (string path in paths)
            {
                RegistryKey key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Enum\USB\VID_10C4&PID_EA60" + path);
                if (key != null)
                {
                    foreach (string subKeyName in key.GetSubKeyNames())
                    {
                        RegistryKey subKey = key.OpenSubKey(subKeyName + "\\" + "Device Parameters");
                        if (subKey?.GetValue("PortName") is string name && !result.Contains(name))
                            result.Add(name);
                    }
                }
            }
        }
        catch (SecurityException)
        { }

        return result.ToArray();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Nzxt/GridV3.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Threading;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.Nzxt;

/// <summary>
/// Support for the NZXT GRID+ V3 devices.
/// </summary>
internal sealed class GridV3 : Hardware
{
    // Some initialization messages to send to the controller. No visible effects but NZXT CAM send them.
    private static readonly byte[] _initialize1 = { 0x01, 0x5c };
    private static readonly byte[] _initialize2 = { 0x01, 0x5d };
    private static readonly byte[] _initialize3 = { 0x01, 0x59 };

    private const int FANS_COUNT = 6;

    private readonly byte[] _setFanSpeedMsg;
    private readonly HidStream _stream;
    private readonly Dictionary<int, byte[]> _rawData = new();

    private readonly Sensor _noise;
    private readonly Sensor[] _currents = new Sensor[FANS_COUNT];
    private readonly Sensor[] _powers = new Sensor[FANS_COUNT];
    private readonly Sensor[] _pwmControls = new Sensor[FANS_COUNT];
    private readonly Sensor[] _rpmSensors = new Sensor[FANS_COUNT];
    private readonly Sensor[] _voltages = new Sensor[FANS_COUNT];

    private readonly Control[] _fanControls = new Control[FANS_COUNT];

    public GridV3(HidDevice dev, ISettings settings) : base("NZXT GRID+ V3", new Identifier("nzxt", "gridv3", dev.GetSerialNumber().TrimStart('0')), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            for (int fanID = 0; fanID < FANS_COUNT; fanID++)
            {
                _rawData[fanID] = new byte[21];
            }

            _setFanSpeedMsg = new byte[65];
            _setFanSpeedMsg[0] = 0x02;
            _setFanSpeedMsg[1] = 0x4d;
            _setFanSpeedMsg[3] = 0x00;

            _stream.Write(_initialize1);
            _stream.Write(_initialize2);
            _stream.Write(_initialize3);

            do
            {
                _stream.Read(_rawData[0]);
                if (_rawData[0][0] == 0x04)
                {
                    FirmwareVersion = $"{_rawData[0][11]}.{_rawData[0][14]}";
                }
            }
            while (FirmwareVersion == null);

            Name = "NZXT GRID+ V3";

            // Initialize all sensors and controls for all fans
            for (int i = 0; i < FANS_COUNT; i++)
            {
                _rpmSensors[i] = new Sensor($"GRID Fan #{i + 1}", i, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
                _voltages[i] = new Sensor($"GRID Fan #{i + 1}", i, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
                _currents[i] = new Sensor($"GRID Fan #{i + 1}", i, SensorType.Current, this, Array.Empty<ParameterDescription>(), settings);
                _powers[i] = new Sensor($"GRID Fan #{i + 1}", i, SensorType.Power, this, Array.Empty<ParameterDescription>(), settings);
                _pwmControls[i] = new Sensor($"GRID Fan #{i + 1}", i, SensorType.Control, this, Array.Empty<ParameterDescription>(), settings);

                _fanControls[i] = new Control(_pwmControls[i], settings, 0, 100);

                _pwmControls[i].Control = _fanControls[i];
                _fanControls[i].ControlModeChanged += SoftwareControlValueChanged;
                _fanControls[i].SoftwareControlValueChanged += SoftwareControlValueChanged;
                SoftwareControlValueChanged(_fanControls[i]);

                ActivateSensor(_rpmSensors[i]);
                ActivateSensor(_voltages[i]);
                ActivateSensor(_currents[i]);
                ActivateSensor(_powers[i]);
                ActivateSensor(_pwmControls[i]);

                // NZXT GRID does not report current PWM value. So we need to initialize it with some value to keep GUI and device values in sync.
                _fanControls[i].SetDefault();
            }
            _noise = new Sensor("GRID Noise", 0, SensorType.Noise, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_noise);

            Thread readGridReports = new(ContinuousRead) { IsBackground = true };
            readGridReports.Start(_rawData);
        }
    }

    public string FirmwareVersion { get; }

    public override HardwareType HardwareType => HardwareType.Cooler;

    private void SoftwareControlValueChanged(Control control)
    {
        if (control.ControlMode == ControlMode.Software)
        {
            float value = control.SoftwareValue;
            byte fanSpeed = (byte)(value > 100 ? 100 : value < 0 ? 0 : value); // Clamp the value, anything out of range will fail

            //_controlling = true;
            _setFanSpeedMsg[2] = (byte)control.Sensor.Index;
            _setFanSpeedMsg[4] = fanSpeed;

            _stream.Write(_setFanSpeedMsg);

            _pwmControls[control.Sensor.Index].Value = value;
        }
        else if (control.ControlMode == ControlMode.Default)
        {
            // There isn't a "default" mode, but let's say a safe setting is 40%
            _setFanSpeedMsg[2] = (byte)control.Sensor.Index;
            _setFanSpeedMsg[4] = 40;

            _stream.Write(_setFanSpeedMsg);

            _pwmControls[control.Sensor.Index].Value = 40;
        }
    }

    public override void Close()
    {
        _stream?.Close();
        base.Close();
    }

    private void ContinuousRead(object state)
    {
        byte[] buffer = new byte[_rawData[0].Length];
        while (_stream.CanRead)
        {
            try
            {
                _stream.Read(buffer); // This is a blocking call, will wait for bytes to become available
                if (buffer[0] == 0x04)
                {
                    lock (_rawData)
                    {
                        int fanID = (buffer[15] >> 4) & 0x0f;
                        Array.Copy(buffer, _rawData[fanID], buffer.Length);
                    }
                }
            }
            catch (TimeoutException)
            {
                // Don't care, just make sure the stream is still open
                Thread.Sleep(500);
            }
            catch (ObjectDisposedException)
            {
                // Could be unplugged, or the app is stopping...
                return;
            }
        }
    }

    public override void Update()
    {
        // The NZXT GRID+ V3 series sends updates periodically. We have to read it in a seperate thread, this call just reads that data.
        lock (_rawData)
        {
            for (int fanID = 0; fanID < FANS_COUNT; fanID++)
            {
                _rpmSensors[fanID].Value = (_rawData[fanID][3] << 8) | _rawData[fanID][4];
                _voltages[fanID].Value = _rawData[fanID][7] + _rawData[fanID][8] / 100.0f;
                _currents[fanID].Value = _rawData[fanID][9] + _rawData[fanID][10] / 100.0f;
                _powers[fanID].Value = _currents[fanID].Value * _voltages[fanID].Value;
            }
            _noise.Value = _rawData[2][1];
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Nzxt/KrakenX3.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Linq;
using System.Threading;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.Nzxt;

/**
     * Support for the Kraken X3 devices from NZXT
     */
internal sealed class KrakenX3 : Hardware
{
    // Some fixed messages to send to the pump for basic monitoring and control
    private static readonly byte[] _getFirmwareInfo = { 0x10, 0x01 };
    private static readonly byte[] _initialize1 = { 0x70, 0x02, 0x01, 0xb8, 0x0b };
    private static readonly byte[] _initialize2 = { 0x70, 0x01 };
    private static readonly byte[][] _setPumpTargetMap = new byte[101][]; // Sacrifice memory to speed this up with a lookup instead of a copy operation

    private readonly Sensor _pump;
    private readonly Sensor _pumpRpm;
    private readonly byte[] _rawData = new byte[64];
    private readonly HidStream _stream;
    private readonly Sensor _temperature;

    private volatile bool _controlling;

    static KrakenX3()
    {
        byte[] setPumpSpeedHeader = { 0x72, 0x01, 0x00, 0x00 };

        for (byte speed = 0; speed < _setPumpTargetMap.Length; speed++)
            _setPumpTargetMap[speed] = setPumpSpeedHeader.Concat(Enumerable.Repeat(speed, 40).Concat(new byte[20])).ToArray();
    }

    public KrakenX3(HidDevice dev, ISettings settings) : base("Nzxt Kraken X3", new Identifier("nzxt", "krakenx3", dev.GetSerialNumber().TrimStart('0')), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            _stream.ReadTimeout = 5000; // The NZXT device returns with data that we need periodically without writing... 
            _stream.Write(_initialize1);
            _stream.Write(_initialize2);

            _stream.Write(_getFirmwareInfo);
            do
            {
                _stream.Read(_rawData);
                if (_rawData[0] == 0x11 && _rawData[1] == 0x01)
                {
                    FirmwareVersion = $"{_rawData[0x11]}.{_rawData[0x12]}.{_rawData[0x13]}";
                }
            }
            while (FirmwareVersion == null);

            Name = "Nzxt Kraken X3";

            _pump = new Sensor("Pump Control", 0, SensorType.Control, this, Array.Empty<ParameterDescription>(), settings);
            Control pumpControl = new(_pump, settings, 0, 100);
            _pump.Control = pumpControl;
            pumpControl.ControlModeChanged += SoftwareControlValueChanged;
            pumpControl.SoftwareControlValueChanged += SoftwareControlValueChanged;
            SoftwareControlValueChanged(pumpControl);
            ActivateSensor(_pump);

            _pumpRpm = new Sensor("Pump", 0, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_pumpRpm);

            _temperature = new Sensor("Internal Water", 0, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperature);

            ThreadPool.UnsafeQueueUserWorkItem(ContinuousRead, _rawData);
        }
    }

    public string FirmwareVersion { get; }

    public override HardwareType HardwareType => HardwareType.Cooler;

    public string Status => FirmwareVersion != "2.1.0" ? $"Status: Untested Firmware Version {FirmwareVersion}! Please consider Updating to Version 2.1.0" : "Status: OK";

    private void SoftwareControlValueChanged(Control control)
    {
        if (control.ControlMode == ControlMode.Software)
        {
            float value = control.SoftwareValue;
            byte pumpSpeedIndex = (byte)(value > 100 ? 100 : value < 0 ? 0 : value); // Clamp the value, anything out of range will fail

            _controlling = true;
            _stream.Write(_setPumpTargetMap[pumpSpeedIndex]);
            _pump.Value = value;
        }
        else if (control.ControlMode == ControlMode.Default)
        {
            // There isn't a "default" mode with this pump, but a safe setting is 40%
            _stream.Write(_setPumpTargetMap[40]);
        }
    }

    public override void Close()
    {
        base.Close();
        _stream?.Close();
    }

    private void ContinuousRead(object state)
    {
        byte[] buffer = new byte[_rawData.Length];
        while (_stream.CanRead)
        {
            try
            {
                _stream.Read(buffer); // This is a blocking call, will wait for bytes to become available

                lock (_rawData)
                {
                    Array.Copy(buffer, _rawData, buffer.Length);
                }
            }
            catch (TimeoutException)
            {
                // Don't care, just make sure the stream is still open
                Thread.Sleep(500);
            }
            catch (ObjectDisposedException)
            {
                // Could be unplugged, or the app is stopping...
                return;
            }
        }
    }

    public override void Update()
    {
        // The NZXT Kraken X3 series sends updates periodically. We have to read it in a seperate thread, this call just reads that data.
        lock (_rawData)
        {
            if (_rawData[0] == 0x75 && _rawData[1] == 0x02)
            {
                _temperature.Value = _rawData[15] + (_rawData[16] / 10.0f);
                _pumpRpm.Value = (_rawData[18] << 8) | _rawData[17];

                // The following logic makes sure the pump is set to the controlling value. This pump sometimes sets itself to 0% when instructed to a value.
                if (!_controlling)
                {
                    _pump.Value = _rawData[19];
                }
                else if (_pump.Value != _rawData[19])
                {
                    float value = _pump.Value.GetValueOrDefault();
                    byte pumpSpeedIndex = (byte)(value > 100 ? 100 : value < 0 ? 0 : value); // Clamp the value, anything out of range will fail
                    _stream.Write(_setPumpTargetMap[pumpSpeedIndex]);
                }
                else
                {
                    _controlling = false;
                }
            }
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Nzxt/NzxtGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.Nzxt;

internal class NzxtGroup : IGroup
{
    private readonly List<IHardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public NzxtGroup(ISettings settings)
    {
        _report.AppendLine("Nzxt Hardware");
        _report.AppendLine();

        foreach (HidDevice dev in DeviceList.Local.GetHidDevices(0x1e71))
        {
            string productName = dev.GetProductName();

            switch (dev.ProductID)
            {
                case 0x2007:
                    var device = new KrakenX3(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {device.FirmwareVersion}");
                    _report.AppendLine($"{device.Status}");
                    _report.AppendLine();
                    _hardware.Add(device);
                    break;
                case 0x1711:
                    var gridv3 = new GridV3(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {gridv3.FirmwareVersion}");
                    _report.AppendLine();
                    _hardware.Add(gridv3);
                    break;

                default:
                    _report.AppendLine($"Unknown Hardware PID: {dev.ProductID} Name: {productName}");
                    _report.AppendLine();
                    break;
            }
        }

        if (_hardware.Count == 0)
        {
            _report.AppendLine("No Nzxt Hardware found.");
            _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (IHardware iHardware in _hardware)
        {
            if (iHardware is Hardware hardware)
                hardware.Close();
        }
    }

    public string GetReport()
    {
        return _report.ToString();
    }
}
```

`LibreHardwareMonitorLib/Hardware/Controller/TBalancer/TBalancer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using LibreHardwareMonitor.Interop;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Hardware.Controller.TBalancer;

internal class TBalancer : Hardware
{
    internal const byte EndFlag = 254;
    internal const byte StartFlag = 100;

    private readonly MethodDelegate _alternativeRequest;
    private readonly Sensor[] _analogTemperatures = new Sensor[4];
    private readonly Sensor[] _controls = new Sensor[4];
    private readonly List<ISensor> _deactivating = new();
    private readonly Sensor[] _digitalTemperatures = new Sensor[8];
    private readonly Sensor[] _fans = new Sensor[4];
    private readonly Sensor[] _miniNgControls = new Sensor[4];
    private readonly Sensor[] _miniNgFans = new Sensor[4];
    private readonly Sensor[] _miniNgTemperatures = new Sensor[4];
    private readonly int _portIndex;
    private readonly byte _protocolVersion;
    private readonly Sensor[] _sensorHubFlows = new Sensor[2];
    private readonly Sensor[] _sensorHubTemperatures = new Sensor[6];
    private byte[] _alternativeData = Array.Empty<byte>();
    private readonly byte[] _data = new byte[285];
    private Ftd2xx.FT_HANDLE _handle;
    private byte[] _primaryData = Array.Empty<byte>();

    public TBalancer(int portIndex, byte protocolVersion, ISettings settings) :
        base("T-Balancer bigNG", new Identifier("bigng", portIndex.ToString(CultureInfo.InvariantCulture)), settings)
    {
        _portIndex = portIndex;
        _protocolVersion = protocolVersion;

        ParameterDescription[] parameter = { new("Offset [°C]", "Temperature offset.", 0) };
        int offset = 0;
        for (int i = 0; i < _digitalTemperatures.Length; i++)
            _digitalTemperatures[i] = new Sensor("Digital Sensor " + i, offset + i, SensorType.Temperature, this, parameter, settings);

        offset += _digitalTemperatures.Length;

        for (int i = 0; i < _analogTemperatures.Length; i++)
            _analogTemperatures[i] = new Sensor("Analog Sensor " + (i + 1), offset + i, SensorType.Temperature, this, parameter, settings);

        offset += _analogTemperatures.Length;

        for (int i = 0; i < _sensorHubTemperatures.Length; i++)
            _sensorHubTemperatures[i] = new Sensor("Sensorhub Sensor " + i, offset + i, SensorType.Temperature, this, parameter, settings);

        offset += _sensorHubTemperatures.Length;

        for (int i = 0; i < _miniNgTemperatures.Length; i++)
            _miniNgTemperatures[i] = new Sensor("miniNG #" + ((i / 2) + 1) + " Sensor " + ((i % 2) + 1), offset + i, SensorType.Temperature, this, parameter, settings);

        for (int i = 0; i < _sensorHubFlows.Length; i++)
        {
            _sensorHubFlows[i] = new Sensor("Flowmeter " + (i + 1),
                                            i,
                                            SensorType.Flow,
                                            this,
                                            new[] { new ParameterDescription("Impulse Rate", "The impulse rate of the flowmeter in pulses/L", 509) },
                                            settings);
        }

        for (int i = 0; i < _controls.Length; i++)
        {
            _controls[i] = new Sensor("Fan Channel " + i, i, SensorType.Control, this, settings);
        }

        for (int i = 0; i < _miniNgControls.Length; i++)
        {
            _miniNgControls[i] = new Sensor("miniNG #" + ((i / 2) + 1) + " Fan Channel " + ((i % 2) + 1), 4 + i, SensorType.Control, this, settings);
        }

        _alternativeRequest = DelayedAlternativeRequest;

        Open();
        Update();
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    protected override void ActivateSensor(ISensor sensor)
    {
        _deactivating.Remove(sensor);
        base.ActivateSensor(sensor);
    }

    protected override void DeactivateSensor(ISensor sensor)
    {
        if (_deactivating.Contains(sensor))
        {
            _deactivating.Remove(sensor);
            base.DeactivateSensor(sensor);
        }
        else if (_active.Contains(sensor))
        {
            _deactivating.Add(sensor);
        }
    }

    private void ReadMiniNg(int number)
    {
        int offset = 1 + (number * 65);

        if (_data[offset + 61] != EndFlag)
            return;

        for (int i = 0; i < 2; i++)
        {
            Sensor sensor = _miniNgTemperatures[(number * 2) + i];
            if (_data[offset + 7 + i] > 0)
            {
                sensor.Value = (0.5f * _data[offset + 7 + i]) +
                               sensor.Parameters[0].Value;

                ActivateSensor(sensor);
            }
            else
            {
                DeactivateSensor(sensor);
            }
        }

        for (int i = 0; i < 2; i++)
        {
            _miniNgFans[(number * 2) + i] ??= new Sensor("miniNG #" + (number + 1) + " Fan Channel " + (i + 1), 4 + (number * 2) + i, SensorType.Fan, this, _settings);

            Sensor sensor = _miniNgFans[(number * 2) + i];
            sensor.Value = 20.0f * _data[offset + 43 + (2 * i)];
            ActivateSensor(sensor);
        }

        for (int i = 0; i < 2; i++)
        {
            Sensor sensor = _miniNgControls[(number * 2) + i];
            sensor.Value = _data[offset + 15 + i];
            ActivateSensor(sensor);
        }
    }

    private void ReadData()
    {
        Ftd2xx.Read(_handle, _data);
        if (_data[0] != StartFlag)
        {
            Ftd2xx.FT_Purge(_handle, Ftd2xx.FT_PURGE.FT_PURGE_RX);
            return;
        }

        if (_data[1] is 255 or 88)
        {
            // bigNG

            if (_data[274] != _protocolVersion)
                return;

            if (_primaryData.Length == 0)
                _primaryData = new byte[_data.Length];

            _data.CopyTo(_primaryData, 0);

            for (int i = 0; i < _digitalTemperatures.Length; i++)
            {
                if (_data[238 + i] > 0)
                {
                    _digitalTemperatures[i].Value = (0.5f * _data[238 + i]) + _digitalTemperatures[i].Parameters[0].Value;
                    ActivateSensor(_digitalTemperatures[i]);
                }
                else
                {
                    DeactivateSensor(_digitalTemperatures[i]);
                }
            }

            for (int i = 0; i < _analogTemperatures.Length; i++)
            {
                if (_data[260 + i] > 0)
                {
                    _analogTemperatures[i].Value = (0.5f * _data[260 + i]) + _analogTemperatures[i].Parameters[0].Value;
                    ActivateSensor(_analogTemperatures[i]);
                }
                else
                {
                    DeactivateSensor(_analogTemperatures[i]);
                }
            }

            for (int i = 0; i < _sensorHubTemperatures.Length; i++)
            {
                if (_data[246 + i] > 0)
                {
                    _sensorHubTemperatures[i].Value = (0.5f * _data[246 + i]) + _sensorHubTemperatures[i].Parameters[0].Value;
                    ActivateSensor(_sensorHubTemperatures[i]);
                }
                else
                {
                    DeactivateSensor(_sensorHubTemperatures[i]);
                }
            }

            for (int i = 0; i < _sensorHubFlows.Length; i++)
            {
                if (_data[231 + i] > 0 && _data[234] > 0)
                {
                    float pulsesPerSecond = (_data[231 + i] * 4.0f) / _data[234];
                    float pulsesPerLiter = _sensorHubFlows[i].Parameters[0].Value;
                    _sensorHubFlows[i].Value = pulsesPerSecond * 3600 / pulsesPerLiter;
                    ActivateSensor(_sensorHubFlows[i]);
                }
                else
                {
                    DeactivateSensor(_sensorHubFlows[i]);
                }
            }

            for (int i = 0; i < _fans.Length; i++)
            {
                float maxRpm = 11.5f * ((_data[149 + (2 * i)] << 8) | _data[148 + (2 * i)]);

                _fans[i] ??= new Sensor("Fan Channel " + i,
                                        i,
                                        SensorType.Fan,
                                        this,
                                        new[]
                                        {
                                            new ParameterDescription("MaxRPM",
                                                                     "Maximum revolutions per minute (RPM) of the fan.",
                                                                     maxRpm)
                                        },
                                        _settings);

                float value;
                if ((_data[136] & (1 << i)) == 0) // pwm mode
                    value = 0.02f * _data[137 + i];
                else // analog mode
                    value = 0.01f * _data[141 + i];

                _fans[i].Value = _fans[i].Parameters[0].Value * value;
                ActivateSensor(_fans[i]);

                _controls[i].Value = 100 * value;
                ActivateSensor(_controls[i]);
            }
        }
        else if (_data[1] == 253)
        {
            // miniNG #1
            if (_alternativeData.Length == 0)
                _alternativeData = new byte[_data.Length];

            _data.CopyTo(_alternativeData, 0);

            ReadMiniNg(0);
            if (_data[66] == 253) // miniNG #2
                ReadMiniNg(1);
        }
    }

    public override string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("T-Balancer bigNG");
        r.AppendLine();
        r.Append("Port Index: ");
        r.AppendLine(_portIndex.ToString(CultureInfo.InvariantCulture));
        r.AppendLine();

        r.AppendLine("Primary System Information Answer");
        r.AppendLine();
        r.AppendLine("       00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
        r.AppendLine();
        for (int i = 0; i <= 0x11; i++)
        {
            r.Append(" ");
            r.Append((i << 4).ToString("X3", CultureInfo.InvariantCulture));
            r.Append("  ");
            for (int j = 0; j <= 0xF; j++)
            {
                int index = (i << 4) | j;
                if (index < _primaryData.Length)
                {
                    r.Append(" ");
                    r.Append(_primaryData[index].ToString("X2", CultureInfo.InvariantCulture));
                }
            }

            r.AppendLine();
        }

        r.AppendLine();

        if (_alternativeData.Length > 0)
        {
            r.AppendLine("Alternative System Information Answer");
            r.AppendLine();
            r.AppendLine("       00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
            r.AppendLine();
            for (int i = 0; i <= 0x11; i++)
            {
                r.Append(" ");
                r.Append((i << 4).ToString("X3", CultureInfo.InvariantCulture));
                r.Append("  ");
                for (int j = 0; j <= 0xF; j++)
                {
                    int index = (i << 4) | j;
                    if (index < _alternativeData.Length)
                    {
                        r.Append(" ");
                        r.Append(_alternativeData[index].ToString("X2", CultureInfo.InvariantCulture));
                    }
                }

                r.AppendLine();
            }

            r.AppendLine();
        }

        return r.ToString();
    }

    private void DelayedAlternativeRequest()
    {
        System.Threading.Thread.Sleep(500);
        Ftd2xx.Write(_handle, new byte[] { 0x37 });
    }

    public void Open()
    {
        Ftd2xx.FT_Open(_portIndex, out _handle);
        Ftd2xx.FT_SetBaudRate(_handle, 19200);
        Ftd2xx.FT_SetDataCharacteristics(_handle, 8, 1, 0);
        Ftd2xx.FT_SetFlowControl(_handle, Ftd2xx.FT_FLOW_CONTROL.FT_FLOW_RTS_CTS, 0x11, 0x13);
        Ftd2xx.FT_SetTimeouts(_handle, 1000, 1000);
        Ftd2xx.FT_Purge(_handle, Ftd2xx.FT_PURGE.FT_PURGE_ALL);
    }

    public sealed override void Update()
    {
        while (Ftd2xx.BytesToRead(_handle) >= 285)
            ReadData();

        if (Ftd2xx.BytesToRead(_handle) == 1)
            Ftd2xx.ReadByte(_handle);

        Ftd2xx.Write(_handle, new byte[] { 0x38 });
        _alternativeRequest.BeginInvoke(null, null);
    }

    public override void Close()
    {
        Ftd2xx.FT_Close(_handle);
        base.Close();
    }

    private delegate void MethodDelegate();
}

```

`LibreHardwareMonitorLib/Hardware/Controller/TBalancer/TBalancerGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Threading;
using LibreHardwareMonitor.Interop;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Hardware.Controller.TBalancer;

internal class TBalancerGroup : IGroup
{
    private readonly List<TBalancer> _hardware = new();
    private readonly StringBuilder _report = new();

    public TBalancerGroup(ISettings settings)
    {
        uint numDevices;

        try
        {
            if (!Ftd2xx.DllExists())
            {
                _report.AppendLine("Status: missing DLL");
                return;
            }

            if (Ftd2xx.FT_CreateDeviceInfoList(out numDevices) != Ftd2xx.FT_STATUS.FT_OK)
            {
                _report.AppendLine("Status: FT_CreateDeviceInfoList failed");
                return;
            }
        }
        catch (Exception e) when (e is DllNotFoundException or ArgumentNullException or EntryPointNotFoundException or BadImageFormatException)
        {
            return;
        }

        Ftd2xx.FT_DEVICE_INFO_NODE[] info = new Ftd2xx.FT_DEVICE_INFO_NODE[numDevices];
        if (Ftd2xx.FT_GetDeviceInfoList(info, ref numDevices) != Ftd2xx.FT_STATUS.FT_OK)
        {
            _report.AppendLine("Status: FT_GetDeviceInfoList failed");
            return;
        }

        // make sure numDevices is not larger than the info array
        if (numDevices > info.Length)
            numDevices = (uint)info.Length;

        for (int i = 0; i < numDevices; i++)
        {
            _report.Append("Device Index: ");
            _report.AppendLine(i.ToString(CultureInfo.InvariantCulture));
            _report.Append("Device Type: ");
            _report.AppendLine(info[i].Type.ToString());

            // the T-Balancer always uses an FT232BM
            if (info[i].Type != Ftd2xx.FT_DEVICE.FT_DEVICE_232BM)
            {
                _report.AppendLine("Status: Wrong device type");
                continue;
            }

            Ftd2xx.FT_STATUS status = Ftd2xx.FT_Open(i, out Ftd2xx.FT_HANDLE handle);
            if (status != Ftd2xx.FT_STATUS.FT_OK)
            {
                _report.AppendLine("Open Status: " + status);
                continue;
            }

            Ftd2xx.FT_SetBaudRate(handle, 19200);
            Ftd2xx.FT_SetDataCharacteristics(handle, 8, 1, 0);
            Ftd2xx.FT_SetFlowControl(handle, Ftd2xx.FT_FLOW_CONTROL.FT_FLOW_RTS_CTS, 0x11, 0x13);
            Ftd2xx.FT_SetTimeouts(handle, 1000, 1000);
            Ftd2xx.FT_Purge(handle, Ftd2xx.FT_PURGE.FT_PURGE_ALL);

            status = Ftd2xx.Write(handle, new byte[] { 0x38 });
            if (status != Ftd2xx.FT_STATUS.FT_OK)
            {
                _report.AppendLine("Write Status: " + status);
                Ftd2xx.FT_Close(handle);
                continue;
            }

            bool isValid = false;
            byte protocolVersion = 0;

            int j = 0;
            while (Ftd2xx.BytesToRead(handle) == 0 && j < 2)
            {
                Thread.Sleep(100);
                j++;
            }

            if (Ftd2xx.BytesToRead(handle) > 0)
            {
                if (Ftd2xx.ReadByte(handle) == TBalancer.StartFlag)
                {
                    while (Ftd2xx.BytesToRead(handle) < 284 && j < 5)
                    {
                        Thread.Sleep(100);
                        j++;
                    }

                    int length = Ftd2xx.BytesToRead(handle);
                    if (length >= 284)
                    {
                        byte[] data = new byte[285];
                        data[0] = TBalancer.StartFlag;
                        for (int k = 1; k < data.Length; k++)
                            data[k] = Ftd2xx.ReadByte(handle);

                        // check protocol version 2X (protocols seen: 2C, 2A, 28)
                        isValid = (data[274] & 0xF0) == 0x20;
                        protocolVersion = data[274];
                        if (!isValid)
                        {
                            _report.Append("Status: Wrong Protocol Version: 0x");
                            _report.AppendLine(protocolVersion.ToString("X", CultureInfo.InvariantCulture));
                        }
                    }
                    else
                    {
                        _report.AppendLine("Status: Wrong Message Length: " + length);
                    }
                }
                else
                {
                    _report.AppendLine("Status: Wrong Startflag");
                }
            }
            else
            {
                _report.AppendLine("Status: No Response");
            }

            Ftd2xx.FT_Purge(handle, Ftd2xx.FT_PURGE.FT_PURGE_ALL);
            Ftd2xx.FT_Close(handle);

            if (isValid)
            {
                _report.AppendLine("Status: OK");
                _hardware.Add(new TBalancer(i, protocolVersion, settings));
            }

            if (i < numDevices - 1)
                _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        if (_report.Length > 0)
        {
            StringBuilder r = new();
            r.AppendLine("FTD2XX");
            r.AppendLine();
            r.Append(_report);
            r.AppendLine();
            return r.ToString();
        }

        return null;
    }

    public void Close()
    {
        foreach (TBalancer balancer in _hardware)
            balancer.Close();
    }
}
```

`LibreHardwareMonitorLib/Hardware/Cpu/Amd0FCpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;
using System.Text;
using System.Threading;

namespace LibreHardwareMonitor.Hardware.CPU;

internal sealed class Amd0FCpu : AmdCpu
{
    private readonly Sensor _busClock;
    private readonly Sensor[] _coreClocks;
    private readonly Sensor[] _coreTemperatures;
    private readonly uint _miscellaneousControlAddress;

    private readonly byte _thermSenseCoreSelCPU0;
    private readonly byte _thermSenseCoreSelCPU1;

    public Amd0FCpu(int processorIndex, CpuId[][] cpuId, ISettings settings) : base(processorIndex, cpuId, settings)
    {
        float offset = -49.0f;

        // AM2+ 65nm +21 offset
        uint model = cpuId[0][0].Model;
        if (model is >= 0x69 and not 0xc1 and not 0x6c and not 0x7c)
            offset += 21;

        if (model < 40)
        {
            // AMD Athlon 64 Processors
            _thermSenseCoreSelCPU0 = 0x0;
            _thermSenseCoreSelCPU1 = 0x4;
        }
        else
        {
            // AMD NPT Family 0Fh Revision F, G have the core selection swapped
            _thermSenseCoreSelCPU0 = 0x4;
            _thermSenseCoreSelCPU1 = 0x0;
        }

        // check if processor supports a digital thermal sensor
        if (cpuId[0][0].ExtData.GetLength(0) > 7 && (cpuId[0][0].ExtData[7, 3] & 1) != 0)
        {
            _coreTemperatures = new Sensor[_coreCount];
            for (int i = 0; i < _coreCount; i++)
            {
                _coreTemperatures[i] = new Sensor("Core #" + (i + 1),
                                                  i,
                                                  SensorType.Temperature,
                                                  this,
                                                  new[] { new ParameterDescription("Offset [°C]", "Temperature offset of the thermal sensor.\nTemperature = Value + Offset.", offset) },
                                                  settings);
            }
        }
        else
        {
            _coreTemperatures = Array.Empty<Sensor>();
        }

        _miscellaneousControlAddress = GetPciAddress(MISCELLANEOUS_CONTROL_FUNCTION, MISCELLANEOUS_CONTROL_DEVICE_ID);
        _busClock = new Sensor("Bus Speed", 0, SensorType.Clock, this, settings);
        _coreClocks = new Sensor[_coreCount];
        for (int i = 0; i < _coreClocks.Length; i++)
        {
            _coreClocks[i] = new Sensor(CoreString(i), i + 1, SensorType.Clock, this, settings);
            if (HasTimeStampCounter)
                ActivateSensor(_coreClocks[i]);
        }

        Update();
    }

    protected override uint[] GetMsrs()
    {
        return new[] { FIDVID_STATUS };
    }

    public override string GetReport()
    {
        StringBuilder r = new();
        r.Append(base.GetReport());
        r.Append("Miscellaneous Control Address: 0x");
        r.AppendLine(_miscellaneousControlAddress.ToString("X", CultureInfo.InvariantCulture));
        r.AppendLine();
        return r.ToString();
    }

    public override void Update()
    {
        base.Update();

        if (Ring0.WaitPciBusMutex(10))
        {
            if (_miscellaneousControlAddress != Interop.Ring0.INVALID_PCI_ADDRESS)
            {
                for (uint i = 0; i < _coreTemperatures.Length; i++)
                {
                    if (Ring0.WritePciConfig(_miscellaneousControlAddress,
                                             THERMTRIP_STATUS_REGISTER,
                                             i > 0 ? _thermSenseCoreSelCPU1 : _thermSenseCoreSelCPU0))
                    {
                        if (Ring0.ReadPciConfig(_miscellaneousControlAddress, THERMTRIP_STATUS_REGISTER, out uint value))
                        {
                            _coreTemperatures[i].Value = ((value >> 16) & 0xFF) + _coreTemperatures[i].Parameters[0].Value;
                            ActivateSensor(_coreTemperatures[i]);
                        }
                        else
                        {
                            DeactivateSensor(_coreTemperatures[i]);
                        }
                    }
                }
            }

            Ring0.ReleasePciBusMutex();
        }

        if (HasTimeStampCounter)
        {
            double newBusClock = 0;

            for (int i = 0; i < _coreClocks.Length; i++)
            {
                Thread.Sleep(1);

                if (Ring0.ReadMsr(FIDVID_STATUS, out uint eax, out uint _, _cpuId[i][0].Affinity))
                {
                    // CurrFID can be found in eax bits 0-5, MaxFID in 16-21
                    // 8-13 hold StartFID, we don't use that here.
                    double curMp = 0.5 * ((eax & 0x3F) + 8);
                    double maxMp = 0.5 * ((eax >> 16 & 0x3F) + 8);
                    _coreClocks[i].Value = (float)(curMp * TimeStampCounterFrequency / maxMp);
                    newBusClock = (float)(TimeStampCounterFrequency / maxMp);
                }
                else
                {
                    // Fail-safe value - if the code above fails, we'll use this instead
                    _coreClocks[i].Value = (float)TimeStampCounterFrequency;
                }
            }

            if (newBusClock > 0)
            {
                _busClock.Value = (float)newBusClock;
                ActivateSensor(_busClock);
            }
        }
    }

    // ReSharper disable InconsistentNaming
    private const uint FIDVID_STATUS = 0xC0010042;
    private const ushort MISCELLANEOUS_CONTROL_DEVICE_ID = 0x1103;
    private const byte MISCELLANEOUS_CONTROL_FUNCTION = 3;
    private const uint THERMTRIP_STATUS_REGISTER = 0xE4;
    // ReSharper restore InconsistentNaming
}
```

`LibreHardwareMonitorLib/Hardware/Cpu/Amd10Cpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;
using System.Threading;

namespace LibreHardwareMonitor.Hardware.CPU;

internal sealed class Amd10Cpu : AmdCpu
{
    private readonly Sensor _busClock;
    private readonly Sensor[] _coreClocks;
    private readonly Sensor _coreTemperature;
    private readonly Sensor _coreVoltage;
    private readonly byte _cStatesIoOffset;
    private readonly Sensor[] _cStatesResidency;
    private readonly bool _hasSmuTemperatureRegister;
    private readonly bool _isSvi2;
    private readonly uint _miscellaneousControlAddress;
    private readonly Sensor _northbridgeVoltage;
    private readonly FileStream _temperatureStream;
    private readonly double _timeStampCounterMultiplier;

    public Amd10Cpu(int processorIndex, CpuId[][] cpuId, ISettings settings) : base(processorIndex, cpuId, settings)
    {
        // AMD family 1Xh processors support only one temperature sensor
        ushort miscellaneousControlDeviceId;
        _coreTemperature = new Sensor("CPU Cores", 0, SensorType.Temperature, this, new[] { new ParameterDescription("Offset [°C]", "Temperature offset.", 0) }, settings);
        _coreVoltage = new Sensor("CPU Cores", 0, SensorType.Voltage, this, settings);
        ActivateSensor(_coreVoltage);
        _northbridgeVoltage = new Sensor("Northbridge", 0, SensorType.Voltage, this, settings);
        ActivateSensor(_northbridgeVoltage);

        _isSvi2 = (_family == 0x15 && _model >= 0x10) || _family == 0x16;

        switch (_family)
        {
            case 0x10:
                miscellaneousControlDeviceId = FAMILY_10H_MISCELLANEOUS_CONTROL_DEVICE_ID;
                break;
            case 0x11:
                miscellaneousControlDeviceId = FAMILY_11H_MISCELLANEOUS_CONTROL_DEVICE_ID;
                break;
            case 0x12:
                miscellaneousControlDeviceId = FAMILY_12H_MISCELLANEOUS_CONTROL_DEVICE_ID;
                break;
            case 0x14:
                miscellaneousControlDeviceId = FAMILY_14H_MISCELLANEOUS_CONTROL_DEVICE_ID;
                break;
            case 0x15:
                switch (_model & 0xF0)
                {
                    case 0x00:
                        miscellaneousControlDeviceId = FAMILY_15H_MODEL_00_MISC_CONTROL_DEVICE_ID;
                        break;
                    case 0x10:
                        miscellaneousControlDeviceId = FAMILY_15H_MODEL_10_MISC_CONTROL_DEVICE_ID;
                        break;
                    case 0x30:
                        miscellaneousControlDeviceId = FAMILY_15H_MODEL_30_MISC_CONTROL_DEVICE_ID;
                        break;
                    case 0x70:
                        miscellaneousControlDeviceId = FAMILY_15H_MODEL_70_MISC_CONTROL_DEVICE_ID;
                        _hasSmuTemperatureRegister = true;
                        break;
                    case 0x60:
                        miscellaneousControlDeviceId = FAMILY_15H_MODEL_60_MISC_CONTROL_DEVICE_ID;
                        _hasSmuTemperatureRegister = true;
                        break;
                    default:
                        miscellaneousControlDeviceId = 0;
                        break;
                }

                break;
            case 0x16:
                miscellaneousControlDeviceId = (_model & 0xF0) switch
                {
                    0x00 => FAMILY_16H_MODEL_00_MISC_CONTROL_DEVICE_ID,
                    0x30 => FAMILY_16H_MODEL_30_MISC_CONTROL_DEVICE_ID,
                    _ => 0
                };
                break;
            default:
                miscellaneousControlDeviceId = 0;
                break;
        }

        // get the pci address for the Miscellaneous Control registers
        _miscellaneousControlAddress = GetPciAddress(MISCELLANEOUS_CONTROL_FUNCTION, miscellaneousControlDeviceId);
        _busClock = new Sensor("Bus Speed", 0, SensorType.Clock, this, settings);
        _coreClocks = new Sensor[_coreCount];
        for (int i = 0; i < _coreClocks.Length; i++)
        {
            _coreClocks[i] = new Sensor(CoreString(i), i + 1, SensorType.Clock, this, settings);
            if (HasTimeStampCounter)
                ActivateSensor(_coreClocks[i]);
        }

        bool corePerformanceBoostSupport = (cpuId[0][0].ExtData[7, 3] & (1 << 9)) > 0;

        // set affinity to the first thread for all frequency estimations
        GroupAffinity previousAffinity = ThreadAffinity.Set(cpuId[0][0].Affinity);

        // disable core performance boost
        Ring0.ReadMsr(HWCR, out uint hwcrEax, out uint hwcrEdx);
        if (corePerformanceBoostSupport)
            Ring0.WriteMsr(HWCR, hwcrEax | (1 << 25), hwcrEdx);

        Ring0.ReadMsr(PERF_CTL_0, out uint ctlEax, out uint ctlEdx);
        Ring0.ReadMsr(PERF_CTR_0, out uint ctrEax, out uint ctrEdx);

        _timeStampCounterMultiplier = EstimateTimeStampCounterMultiplier();

        // restore the performance counter registers
        Ring0.WriteMsr(PERF_CTL_0, ctlEax, ctlEdx);
        Ring0.WriteMsr(PERF_CTR_0, ctrEax, ctrEdx);

        // restore core performance boost
        if (corePerformanceBoostSupport)
            Ring0.WriteMsr(HWCR, hwcrEax, hwcrEdx);

        // restore the thread affinity.
        ThreadAffinity.Set(previousAffinity);

        // the file reader for lm-sensors support on Linux
        _temperatureStream = null;

        if (Software.OperatingSystem.IsUnix)
        {
            foreach (string path in Directory.GetDirectories("/sys/class/hwmon/"))
            {
                string name = null;
                try
                {
                    using StreamReader reader = new(path + "/device/name");

                    name = reader.ReadLine();
                }
                catch (IOException)
                { }

                _temperatureStream = name switch
                {
                    "k10temp" => new FileStream(path + "/device/temp1_input", FileMode.Open, FileAccess.Read, FileShare.ReadWrite),
                    _ => _temperatureStream
                };
            }
        }

        uint addr = Ring0.GetPciAddress(0, 20, 0);
        if (Ring0.ReadPciConfig(addr, 0, out uint dev))
        {
            Ring0.ReadPciConfig(addr, 8, out uint rev);

            _cStatesIoOffset = dev switch
            {
                0x43851002 => (byte)((rev & 0xFF) < 0x40 ? 0xB3 : 0x9C),
                0x780B1022 or 0x790B1022 => 0x9C,
                _ => _cStatesIoOffset
            };
        }

        if (_cStatesIoOffset != 0)
        {
            _cStatesResidency = new[] { new Sensor("CPU Package C2", 0, SensorType.Level, this, settings), new Sensor("CPU Package C3", 1, SensorType.Level, this, settings) };
            ActivateSensor(_cStatesResidency[0]);
            ActivateSensor(_cStatesResidency[1]);
        }

        Update();
    }

    private double EstimateTimeStampCounterMultiplier()
    {
        // preload the function
        EstimateTimeStampCounterMultiplier(0);
        EstimateTimeStampCounterMultiplier(0);

        // estimate the multiplier
        List<double> estimate = new(3);
        for (int i = 0; i < 3; i++)
            estimate.Add(EstimateTimeStampCounterMultiplier(0.025));

        estimate.Sort();
        return estimate[1];
    }

    private double EstimateTimeStampCounterMultiplier(double timeWindow)
    {
        // select event "076h CPU Clocks not Halted" and enable the counter
        Ring0.WriteMsr(PERF_CTL_0,
                       (1 << 22) | // enable performance counter
                       (1 << 17) | // count events in user mode
                       (1 << 16) | // count events in operating-system mode
                       0x76,
                       0x00000000);

        // set the counter to 0
        Ring0.WriteMsr(PERF_CTR_0, 0, 0);

        long ticks = (long)(timeWindow * Stopwatch.Frequency);

        long timeBegin = Stopwatch.GetTimestamp() +
                         (long)Math.Ceiling(0.001 * ticks);

        long timeEnd = timeBegin + ticks;
        while (Stopwatch.GetTimestamp() < timeBegin)
        { }

        Ring0.ReadMsr(PERF_CTR_0, out uint lsbBegin, out uint msbBegin);

        while (Stopwatch.GetTimestamp() < timeEnd)
        { }

        Ring0.ReadMsr(PERF_CTR_0, out uint lsbEnd, out uint msbEnd);
        Ring0.ReadMsr(COFVID_STATUS, out uint eax, out uint _);
        double coreMultiplier = GetCoreMultiplier(eax);

        ulong countBegin = ((ulong)msbBegin << 32) | lsbBegin;
        ulong countEnd = ((ulong)msbEnd << 32) | lsbEnd;

        double coreFrequency = 1e-6 * ((double)(countEnd - countBegin) * Stopwatch.Frequency) / (timeEnd - timeBegin);
        double busFrequency = coreFrequency / coreMultiplier;
        return 0.25 * Math.Round(4 * TimeStampCounterFrequency / busFrequency);
    }

    protected override uint[] GetMsrs()
    {
        return new[] { PERF_CTL_0, PERF_CTR_0, HWCR, P_STATE_0, COFVID_STATUS };
    }

    public override string GetReport()
    {
        StringBuilder r = new();
        r.Append(base.GetReport());
        r.Append("Miscellaneous Control Address: 0x");
        r.AppendLine(_miscellaneousControlAddress.ToString("X", CultureInfo.InvariantCulture));
        r.Append("Time Stamp Counter Multiplier: ");
        r.AppendLine(_timeStampCounterMultiplier.ToString(CultureInfo.InvariantCulture));
        if (_family == 0x14)
        {
            Ring0.ReadPciConfig(_miscellaneousControlAddress, CLOCK_POWER_TIMING_CONTROL_0_REGISTER, out uint value);
            r.Append("PCI Register D18F3xD4: ");
            r.AppendLine(value.ToString("X8", CultureInfo.InvariantCulture));
        }

        r.AppendLine();
        return r.ToString();
    }

    private double GetCoreMultiplier(uint cofVidEax)
    {
        uint cpuDid;
        uint cpuFid;

        switch (_family)
        {
            case 0x10:
            case 0x11:
            case 0x15:
            case 0x16:
                // 8:6 CpuDid: current core divisor ID
                // 5:0 CpuFid: current core frequency ID
                cpuDid = (cofVidEax >> 6) & 7;
                cpuFid = cofVidEax & 0x1F;
                return 0.5 * (cpuFid + 0x10) / (1 << (int)cpuDid);

            case 0x12:
                // 8:4 CpuFid: current CPU core frequency ID
                // 3:0 CpuDid: current CPU core divisor ID
                cpuFid = (cofVidEax >> 4) & 0x1F;
                cpuDid = cofVidEax & 0xF;
                double divisor = cpuDid switch
                {
                    0 => 1,
                    1 => 1.5,
                    2 => 2,
                    3 => 3,
                    4 => 4,
                    5 => 6,
                    6 => 8,
                    7 => 12,
                    8 => 16,
                    _ => 1
                };
                return (cpuFid + 0x10) / divisor;

            case 0x14:
                // 8:4: current CPU core divisor ID most significant digit
                // 3:0: current CPU core divisor ID least significant digit
                uint divisorIdMsd = (cofVidEax >> 4) & 0x1F;
                uint divisorIdLsd = cofVidEax & 0xF;
                Ring0.ReadPciConfig(_miscellaneousControlAddress, CLOCK_POWER_TIMING_CONTROL_0_REGISTER, out uint value);
                uint frequencyId = value & 0x1F;
                return (frequencyId + 0x10) / (divisorIdMsd + (divisorIdLsd * 0.25) + 1);

            default:
                return 1;
        }
    }

    private static string ReadFirstLine(Stream stream)
    {
        StringBuilder stringBuilder = new();

        try
        {
            stream.Seek(0, SeekOrigin.Begin);
            int b = stream.ReadByte();
            while (b is not -1 and not 10)
            {
                stringBuilder.Append((char)b);
                b = stream.ReadByte();
            }
        }
        catch
        { }

        return stringBuilder.ToString();
    }

    public override void Update()
    {
        base.Update();

        if (_temperatureStream == null)
        {
            if (_miscellaneousControlAddress != Interop.Ring0.INVALID_PCI_ADDRESS)
            {
                bool isValueValid = _hasSmuTemperatureRegister
                    ? ReadSmuRegister(SMU_REPORTED_TEMP_CTRL_OFFSET, out uint value)
                    : Ring0.ReadPciConfig(_miscellaneousControlAddress, REPORTED_TEMPERATURE_CONTROL_REGISTER, out value);

                if (isValueValid)
                {
                    if ((_family == 0x15 || _family == 0x16) && (value & 0x30000) == 0x3000)
                    {
                        if (_family == 0x15 && (_model & 0xF0) == 0x00)
                        {
                            _coreTemperature.Value = (((value >> 21) & 0x7FC) / 8.0f) + _coreTemperature.Parameters[0].Value - 49;
                        }
                        else
                        {
                            _coreTemperature.Value = (((value >> 21) & 0x7FF) / 8.0f) + _coreTemperature.Parameters[0].Value - 49;
                        }
                    }
                    else
                    {
                        _coreTemperature.Value = (((value >> 21) & 0x7FF) / 8.0f) + _coreTemperature.Parameters[0].Value;
                    }

                    ActivateSensor(_coreTemperature);
                }
                else
                {
                    DeactivateSensor(_coreTemperature);
                }
            }
            else
            {
                DeactivateSensor(_coreTemperature);
            }
        }
        else
        {
            string s = ReadFirstLine(_temperatureStream);
            try
            {
                _coreTemperature.Value = 0.001f * long.Parse(s, CultureInfo.InvariantCulture);
                ActivateSensor(_coreTemperature);
            }
            catch
            {
                DeactivateSensor(_coreTemperature);
            }
        }

        if (HasTimeStampCounter)
        {
            double newBusClock = 0;
            float maxCoreVoltage = 0, maxNbVoltage = 0;

            for (int i = 0; i < _coreClocks.Length; i++)
            {
                Thread.Sleep(1);

                if (Ring0.ReadMsr(COFVID_STATUS, out uint curEax, out uint _, _cpuId[i][0].Affinity))
                {
                    double multiplier = GetCoreMultiplier(curEax);

                    _coreClocks[i].Value = (float)(multiplier * TimeStampCounterFrequency / _timeStampCounterMultiplier);
                    newBusClock = (float)(TimeStampCounterFrequency / _timeStampCounterMultiplier);
                }
                else
                {
                    _coreClocks[i].Value = (float)TimeStampCounterFrequency;
                }

                float SVI2Volt(uint vid) => vid < 0b1111_1000 ? 1.5500f - (0.00625f * vid) : 0;

                float SVI1Volt(uint vid) => vid < 0x7C ? 1.550f - (0.0125f * vid) : 0;

                float newCoreVoltage, newNbVoltage;
                uint coreVid60 = (curEax >> 9) & 0x7F;
                if (_isSvi2)
                {
                    newCoreVoltage = SVI2Volt((curEax >> 13 & 0x80) | coreVid60);
                    newNbVoltage = SVI2Volt(curEax >> 24);
                }
                else
                {
                    newCoreVoltage = SVI1Volt(coreVid60);
                    newNbVoltage = SVI1Volt(curEax >> 25);
                }

                if (newCoreVoltage > maxCoreVoltage)
                    maxCoreVoltage = newCoreVoltage;

                if (newNbVoltage > maxNbVoltage)
                    maxNbVoltage = newNbVoltage;
            }

            _coreVoltage.Value = maxCoreVoltage;
            _northbridgeVoltage.Value = maxNbVoltage;

            if (newBusClock > 0)
            {
                _busClock.Value = (float)newBusClock;
                ActivateSensor(_busClock);
            }
        }

        if (_cStatesResidency != null)
        {
            for (int i = 0; i < _cStatesResidency.Length; i++)
            {
                Ring0.WriteIoPort(CSTATES_IO_PORT, (byte)(_cStatesIoOffset + i));
                _cStatesResidency[i].Value = Ring0.ReadIoPort(CSTATES_IO_PORT + 1) / 256f * 100;
            }
        }
    }

    private static bool ReadSmuRegister(uint address, out uint value)
    {
        if (Ring0.WaitPciBusMutex(10))
        {
            if (!Ring0.WritePciConfig(0, 0xB8, address))
            {
                value = 0;

                Ring0.ReleasePciBusMutex();
                return false;
            }

            bool result = Ring0.ReadPciConfig(0, 0xBC, out value);

            Ring0.ReleasePciBusMutex();
            return result;
        }

        value = 0;
        return false;
    }

    public override void Close()
    {
        _temperatureStream?.Close();
        base.Close();
    }

    // ReSharper disable InconsistentNaming
    private const uint CLOCK_POWER_TIMING_CONTROL_0_REGISTER = 0xD4;
    private const uint COFVID_STATUS = 0xC0010071;
    private const uint CSTATES_IO_PORT = 0xCD6;
    private const uint SMU_REPORTED_TEMP_CTRL_OFFSET = 0xD8200CA4;
    private const uint HWCR = 0xC0010015;
    private const byte MISCELLANEOUS_CONTROL_FUNCTION = 3;
    private const uint P_STATE_0 = 0xC0010064;
    private const uint PERF_CTL_0 = 0xC0010000;
    private const uint PERF_CTR_0 = 0xC0010004;
    private const uint REPORTED_TEMPERATURE_CONTROL_REGISTER = 0xA4;

    private const ushort FAMILY_10H_MISCELLANEOUS_CONTROL_DEVICE_ID = 0x1203;
    private const ushort FAMILY_11H_MISCELLANEOUS_CONTROL_DEVICE_ID = 0x1303;
    private const ushort FAMILY_12H_MISCELLANEOUS_CONTROL_DEVICE_ID = 0x1703;
    private const ushort FAMILY_14H_MISCELLANEOUS_CONTROL_DEVICE_ID = 0x1703;
    private const ushort FAMILY_15H_MODEL_00_MISC_CONTROL_DEVICE_ID = 0x1603;
    private const ushort FAMILY_15H_MODEL_10_MISC_CONTROL_DEVICE_ID = 0x1403;
    private const ushort FAMILY_15H_MODEL_30_MISC_CONTROL_DEVICE_ID = 0x141D;
    private const ushort FAMILY_15H_MODEL_60_MISC_CONTROL_DEVICE_ID = 0x1573;
    private const ushort FAMILY_15H_MODEL_70_MISC_CONTROL_DEVICE_ID = 0x15B3;
    private const ushort FAMILY_16H_MODEL_00_MISC_CONTROL_DEVICE_ID = 0x1533;
    private const ushort FAMILY_16H_MODEL_30_MISC_CONTROL_DEVICE_ID = 0x1583;
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/Amd17Cpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LibreHardwareMonitor.Hardware.CPU;

internal sealed class Amd17Cpu : AmdCpu
{
    private readonly Processor _processor;
    private readonly Dictionary<SensorType, int> _sensorTypeIndex;
    private readonly RyzenSMU _smu;

    public Amd17Cpu(int processorIndex, CpuId[][] cpuId, ISettings settings) : base(processorIndex, cpuId, settings)
    {
        _sensorTypeIndex = new Dictionary<SensorType, int>();
        foreach (SensorType type in Enum.GetValues(typeof(SensorType)))
        {
            _sensorTypeIndex.Add(type, 0);
        }

        _sensorTypeIndex[SensorType.Load] = _active.Count(x => x.SensorType == SensorType.Load);

        _smu = new RyzenSMU(_family, _model, _packageType);

        // Add all numa nodes.
        // Register ..1E_2, [10:8] + 1
        _processor = new Processor(this);

        // Add all numa nodes.
        int coreId = 0;
        int lastCoreId = -1; // Invalid id.

        // Ryzen 3000's skip some core ids.
        // So start at 1 and count upwards when the read core changes.
        foreach (CpuId[] cpu in cpuId.OrderBy(x => x[0].ExtData[0x1e, 1] & 0xFF))
        {
            CpuId thread = cpu[0];

            // CPUID_Fn8000001E_EBX, Register ..1E_1, [7:0]
            // threads per core =  CPUID_Fn8000001E_EBX[15:8] + 1
            // CoreId: core ID =  CPUID_Fn8000001E_EBX[7:0]
            int coreIdRead = (int)(thread.ExtData[0x1e, 1] & 0xff);

            // CPUID_Fn8000001E_ECX, Node Identifiers, Register ..1E_2
            // NodesPerProcessor =  CPUID_Fn8000001E_ECX[10:8]
            // nodeID =  CPUID_Fn8000001E_ECX[7:0]
            int nodeId = (int)(thread.ExtData[0x1e, 2] & 0xff);

            if (coreIdRead != lastCoreId)
            {
                coreId++;
            }

            lastCoreId = coreIdRead;

            _processor.AppendThread(thread, nodeId, coreId);
        }

        Update();
    }

    protected override uint[] GetMsrs()
    {
        return new[] { PERF_CTL_0, PERF_CTR_0, HWCR, MSR_PSTATE_0, COFVID_STATUS };
    }

    public override string GetReport()
    {
        StringBuilder r = new();
        r.Append(base.GetReport());
        r.Append(_smu.GetReport());
        return r.ToString();
    }

    public override void Update()
    {
        base.Update();

        _processor.UpdateSensors();

        foreach (NumaNode node in _processor.Nodes)
        {
            NumaNode.UpdateSensors();

            foreach (Core c in node.Cores)
            {
                c.UpdateSensors();
            }
        }
    }

    private class Processor
    {
        private readonly Sensor _busClock;
        private readonly Sensor[] _ccdTemperatures;
        private readonly Sensor _coreTemperatureTctl;
        private readonly Sensor _coreTemperatureTctlTdie;
        private readonly Sensor _coreTemperatureTdie;
        private readonly Sensor _coreVoltage;
        private readonly Amd17Cpu _cpu;
        private readonly Sensor _packagePower;
        private readonly Dictionary<KeyValuePair<uint, RyzenSMU.SmuSensorType>, Sensor> _smuSensors = new();
        private readonly Sensor _socVoltage;

        private Sensor _ccdsAverageTemperature;
        private Sensor _ccdsMaxTemperature;
        private DateTime _lastPwrTime = new(0);
        private uint _lastPwrValue;

        public Processor(Hardware hardware)
        {
            _cpu = (Amd17Cpu)hardware;

            _packagePower = new Sensor("Package", _cpu._sensorTypeIndex[SensorType.Power]++, SensorType.Power, _cpu, _cpu._settings);
            _coreTemperatureTctl = new Sensor("Core (Tctl)", _cpu._sensorTypeIndex[SensorType.Temperature]++, SensorType.Temperature, _cpu, _cpu._settings);
            _coreTemperatureTdie = new Sensor("Core (Tdie)", _cpu._sensorTypeIndex[SensorType.Temperature]++, SensorType.Temperature, _cpu, _cpu._settings);
            _coreTemperatureTctlTdie = new Sensor("Core (Tctl/Tdie)", _cpu._sensorTypeIndex[SensorType.Temperature]++, SensorType.Temperature, _cpu, _cpu._settings);
            _ccdTemperatures = new Sensor[8]; // Hardcoded until there's a way to get max CCDs.
            _coreVoltage = new Sensor("Core (SVI2 TFN)", _cpu._sensorTypeIndex[SensorType.Voltage]++, SensorType.Voltage, _cpu, _cpu._settings);
            _socVoltage = new Sensor("SoC (SVI2 TFN)", _cpu._sensorTypeIndex[SensorType.Voltage]++, SensorType.Voltage, _cpu, _cpu._settings);
            _busClock = new Sensor("Bus Speed", _cpu._sensorTypeIndex[SensorType.Clock]++, SensorType.Clock, _cpu, _cpu._settings);

            _cpu.ActivateSensor(_packagePower);

            foreach (KeyValuePair<uint, RyzenSMU.SmuSensorType> sensor in _cpu._smu.GetPmTableStructure())
            {
                _smuSensors.Add(sensor, new Sensor(sensor.Value.Name, _cpu._sensorTypeIndex[sensor.Value.Type]++, sensor.Value.Type, _cpu, _cpu._settings));
            }
        }

        public List<NumaNode> Nodes { get; } = new();

        public void UpdateSensors()
        {
            NumaNode node = Nodes[0];
            Core core = node?.Cores[0];
            CpuId cpuId = core?.Threads[0];

            if (cpuId == null)
                return;

            GroupAffinity previousAffinity = ThreadAffinity.Set(cpuId.Affinity);

            // MSRC001_0299
            // TU [19:16]
            // ESU [12:8] -> Unit 15.3 micro Joule per increment
            // PU [3:0]
            Ring0.ReadMsr(MSR_PWR_UNIT, out uint _, out uint _);

            // MSRC001_029B
            // total_energy [31:0]
            DateTime sampleTime = DateTime.Now;
            Ring0.ReadMsr(MSR_PKG_ENERGY_STAT, out uint eax, out _);

            uint totalEnergy = eax;

            uint smuSvi0Tfn = 0;
            uint smuSvi0TelPlane0 = 0;
            uint smuSvi0TelPlane1 = 0;

            if (Ring0.WaitPciBusMutex(10))
            {
                // THM_TCON_CUR_TMP
                // CUR_TEMP [31:21]
                Ring0.WritePciConfig(0x00, FAMILY_17H_PCI_CONTROL_REGISTER, F17H_M01H_THM_TCON_CUR_TMP);
                Ring0.ReadPciConfig(0x00, FAMILY_17H_PCI_CONTROL_REGISTER + 4, out uint temperature);

                // SVI0_TFN_PLANE0 [0]
                // SVI0_TFN_PLANE1 [1]
                Ring0.WritePciConfig(0x00, FAMILY_17H_PCI_CONTROL_REGISTER, F17H_M01H_SVI + 0x8);
                Ring0.ReadPciConfig(0x00, FAMILY_17H_PCI_CONTROL_REGISTER + 4, out smuSvi0Tfn);

                bool supportsPerCcdTemperatures = false;

                // TODO: find a better way because these will probably keep changing in the future.

                uint sviPlane0Offset;
                uint sviPlane1Offset;
                switch (cpuId.Model)
                {
                    case 0x31: // Threadripper 3000.
                        sviPlane0Offset = F17H_M01H_SVI + 0x14;
                        sviPlane1Offset = F17H_M01H_SVI + 0x10;
                        supportsPerCcdTemperatures = true;
                        break;

                    case 0x71: // Zen 2.
                    case 0x21: // Zen 3.
                        sviPlane0Offset = F17H_M01H_SVI + 0x10;
                        sviPlane1Offset = F17H_M01H_SVI + 0xC;
                        supportsPerCcdTemperatures = true;
                        break;

                    case 0x61:
                        sviPlane0Offset = F17H_M01H_SVI + 0x10;
                        sviPlane1Offset = F17H_M01H_SVI + 0xC;
                        supportsPerCcdTemperatures = true;
                        break;

                    default: // Zen and Zen+.
                        sviPlane0Offset = F17H_M01H_SVI + 0xC;
                        sviPlane1Offset = F17H_M01H_SVI + 0x10;
                        break;
                }

                // SVI0_PLANE0_VDDCOR [24:16]
                // SVI0_PLANE0_IDDCOR [7:0]
                Ring0.WritePciConfig(0x00, FAMILY_17H_PCI_CONTROL_REGISTER, sviPlane0Offset);
                Ring0.ReadPciConfig(0x00, FAMILY_17H_PCI_CONTROL_REGISTER + 4, out smuSvi0TelPlane0);

                // SVI0_PLANE1_VDDCOR [24:16]
                // SVI0_PLANE1_IDDCOR [7:0]
                Ring0.WritePciConfig(0x00, FAMILY_17H_PCI_CONTROL_REGISTER, sviPlane1Offset);
                Ring0.ReadPciConfig(0x00, FAMILY_17H_PCI_CONTROL_REGISTER + 4, out smuSvi0TelPlane1);

                ThreadAffinity.Set(previousAffinity);

                // power consumption
                // power.Value = (float) ((double)pu * 0.125);
                // esu = 15.3 micro Joule per increment
                if (_lastPwrTime.Ticks == 0)
                {
                    _lastPwrTime = sampleTime;
                    _lastPwrValue = totalEnergy;
                }

                // ticks diff
                TimeSpan time = sampleTime - _lastPwrTime;
                long pwr;
                if (_lastPwrValue <= totalEnergy)
                    pwr = totalEnergy - _lastPwrValue;
                else
                    pwr = (0xffffffff - _lastPwrValue) + totalEnergy;

                // update for next sample
                _lastPwrTime = sampleTime;
                _lastPwrValue = totalEnergy;

                double energy = 15.3e-6 * pwr;
                energy /= time.TotalSeconds;

                if (!double.IsNaN(energy))
                    _packagePower.Value = (float)energy;

                // current temp Bit [31:21]
                // If bit 19 of the Temperature Control register is set, there is an additional offset of 49 degrees C.
                bool tempOffsetFlag = (temperature & F17H_TEMP_OFFSET_FLAG) != 0;
                temperature = (temperature >> 21) * 125;

                float offset = 0.0f;

                // Offset table: https://github.com/torvalds/linux/blob/master/drivers/hwmon/k10temp.c#L78
                if (string.IsNullOrWhiteSpace(cpuId.Name))
                    offset = 0;
                else if (cpuId.Name.Contains("1600X") || cpuId.Name.Contains("1700X") || cpuId.Name.Contains("1800X"))
                    offset = -20.0f;
                else if (cpuId.Name.Contains("Threadripper 19") || cpuId.Name.Contains("Threadripper 29"))
                    offset = -27.0f;
                else if (cpuId.Name.Contains("2700X"))
                    offset = -10.0f;

                float t = temperature * 0.001f;
                if (tempOffsetFlag)
                    t += -49.0f;

                if (offset < 0)
                {
                    _coreTemperatureTctl.Value = t;
                    _coreTemperatureTdie.Value = t + offset;

                    _cpu.ActivateSensor(_coreTemperatureTctl);
                    _cpu.ActivateSensor(_coreTemperatureTdie);
                }
                else
                {
                    // Zen 2 doesn't have an offset so Tdie and Tctl are the same.
                    _coreTemperatureTctlTdie.Value = t;
                    _cpu.ActivateSensor(_coreTemperatureTctlTdie);
                }

                // Tested only on R5 3600 & Threadripper 3960X, 5900X, 7900X
                if (supportsPerCcdTemperatures)
                {
                    for (uint i = 0; i < _ccdTemperatures.Length; i++)
                    {
                        if (cpuId.Model == 0x61)
                            Ring0.WritePciConfig(0x00, FAMILY_17H_PCI_CONTROL_REGISTER, F17H_M61H_CCD1_TEMP + (i * 0x4));
                        else
                            Ring0.WritePciConfig(0x00, FAMILY_17H_PCI_CONTROL_REGISTER, F17H_M70H_CCD1_TEMP + (i * 0x4));
                        Ring0.ReadPciConfig(0x00, FAMILY_17H_PCI_CONTROL_REGISTER + 4, out uint ccdRawTemp);

                        ccdRawTemp &= 0xFFF;
                        float ccdTemp = ((ccdRawTemp * 125) - 305000) * 0.001f;
                        if (ccdRawTemp > 0 && ccdTemp < 125) // Zen 2 reports 95 degrees C max, but it might exceed that.
                        {
                            if (_ccdTemperatures[i] == null)
                            {
                                _cpu.ActivateSensor(_ccdTemperatures[i] = new Sensor($"CCD{i + 1} (Tdie)",
                                                                                     _cpu._sensorTypeIndex[SensorType.Temperature]++,
                                                                                     SensorType.Temperature,
                                                                                     _cpu,
                                                                                     _cpu._settings));
                            }

                            _ccdTemperatures[i].Value = ccdTemp;
                        }
                    }

                    Sensor[] activeCcds = _ccdTemperatures.Where(x => x != null).ToArray();
                    if (activeCcds.Length > 1)
                    {
                        // No need to get the max / average ccds temp if there is only one CCD.

                        if (_ccdsMaxTemperature == null)
                        {
                            _cpu.ActivateSensor(_ccdsMaxTemperature = new Sensor("CCDs Max (Tdie)",
                                                                                 _cpu._sensorTypeIndex[SensorType.Temperature]++,
                                                                                 SensorType.Temperature,
                                                                                 _cpu,
                                                                                 _cpu._settings));
                        }

                        if (_ccdsAverageTemperature == null)
                        {
                            _cpu.ActivateSensor(_ccdsAverageTemperature = new Sensor("CCDs Average (Tdie)",
                                                                                     _cpu._sensorTypeIndex[SensorType.Temperature]++,
                                                                                     SensorType.Temperature,
                                                                                     _cpu,
                                                                                     _cpu._settings));
                        }

                        _ccdsMaxTemperature.Value = activeCcds.Max(x => x.Value);
                        _ccdsAverageTemperature.Value = activeCcds.Average(x => x.Value);
                    }
                }

                Ring0.ReleasePciBusMutex();
            }

            // voltage
            const double vidStep = 0.00625;
            double vcc;
            uint svi0PlaneXVddCor;

            if (cpuId.Model is 0x61) // Readout not working for Ryzen 7000.
                smuSvi0Tfn |= 0x01 | 0x02;

            // Core (0x01).
            if ((smuSvi0Tfn & 0x01) == 0)
            {
                svi0PlaneXVddCor = (smuSvi0TelPlane0 >> 16) & 0xff;
                vcc = 1.550 - (vidStep * svi0PlaneXVddCor);
                _coreVoltage.Value = (float)vcc;

                _cpu.ActivateSensor(_coreVoltage);
            }

            // SoC (0x02), not every Zen cpu has this voltage.
            if (cpuId.Model is 0x11 or 0x21 or 0x71 or 0x31 || (smuSvi0Tfn & 0x02) == 0)
            {
                svi0PlaneXVddCor = (smuSvi0TelPlane1 >> 16) & 0xff;
                vcc = 1.550 - (vidStep * svi0PlaneXVddCor);
                _socVoltage.Value = (float)vcc;

                _cpu.ActivateSensor(_socVoltage);
            }

            double timeStampCounterMultiplier = GetTimeStampCounterMultiplier();
            if (timeStampCounterMultiplier > 0)
            {
                _busClock.Value = (float)(_cpu.TimeStampCounterFrequency / timeStampCounterMultiplier);
                _cpu.ActivateSensor(_busClock);
            }

            if (_cpu._smu.IsPmTableLayoutDefined())
            {
                float[] smuData = _cpu._smu.GetPmTable();

                foreach (KeyValuePair<KeyValuePair<uint, RyzenSMU.SmuSensorType>, Sensor> sensor in _smuSensors)
                {
                    if (smuData.Length > sensor.Key.Key)
                    {
                        sensor.Value.Value = smuData[sensor.Key.Key] * sensor.Key.Value.Scale;
                        if (sensor.Value.Value != 0)
                            _cpu.ActivateSensor(sensor.Value);
                    }
                }
            }
        }

        private double GetTimeStampCounterMultiplier()
        {
            Ring0.ReadMsr(MSR_PSTATE_0, out uint eax, out _);
            uint cpuDfsId = (eax >> 8) & 0x3f;
            uint cpuFid = eax & 0xff;
            return 2.0 * cpuFid / cpuDfsId;
        }

        public void AppendThread(CpuId thread, int numaId, int coreId)
        {
            NumaNode node = null;
            foreach (NumaNode n in Nodes)
            {
                if (n.NodeId == numaId)
                {
                    node = n;
                    break;
                }
            }

            if (node == null)
            {
                node = new NumaNode(_cpu, numaId);
                Nodes.Add(node);
            }

            if (thread != null)
                node.AppendThread(thread, coreId);
        }
    }

    private class NumaNode
    {
        private readonly Amd17Cpu _cpu;

        public NumaNode(Amd17Cpu cpu, int id)
        {
            Cores = new List<Core>();
            NodeId = id;
            _cpu = cpu;
        }

        public List<Core> Cores { get; }

        public int NodeId { get; }

        public void AppendThread(CpuId thread, int coreId)
        {
            Core core = null;
            foreach (Core c in Cores)
            {
                if (c.CoreId == coreId)
                    core = c;
            }

            if (core == null)
            {
                core = new Core(_cpu, coreId);
                Cores.Add(core);
            }

            if (thread != null)
                core.Threads.Add(thread);
        }

        public static void UpdateSensors()
        { }
    }

    private class Core
    {
        private readonly Sensor _clock;
        private readonly Amd17Cpu _cpu;
        private readonly Sensor _multiplier;
        private readonly Sensor _power;
        private readonly Sensor _vcore;
        private ISensor _busSpeed;
        private DateTime _lastPwrTime = new(0);
        private uint _lastPwrValue;

        public Core(Amd17Cpu cpu, int id)
        {
            _cpu = cpu;
            Threads = new List<CpuId>();
            CoreId = id;
            _clock = new Sensor("Core #" + CoreId, _cpu._sensorTypeIndex[SensorType.Clock]++, SensorType.Clock, cpu, cpu._settings);
            _multiplier = new Sensor("Core #" + CoreId, cpu._sensorTypeIndex[SensorType.Factor]++, SensorType.Factor, cpu, cpu._settings);
            _power = new Sensor("Core #" + CoreId + " (SMU)", cpu._sensorTypeIndex[SensorType.Power]++, SensorType.Power, cpu, cpu._settings);
            _vcore = new Sensor("Core #" + CoreId + " VID", cpu._sensorTypeIndex[SensorType.Voltage]++, SensorType.Voltage, cpu, cpu._settings);

            cpu.ActivateSensor(_clock);
            cpu.ActivateSensor(_multiplier);
            cpu.ActivateSensor(_power);
            cpu.ActivateSensor(_vcore);
        }

        public int CoreId { get; }

        public List<CpuId> Threads { get; }

        public void UpdateSensors()
        {
            // CPUID cpu = threads.FirstOrDefault();
            CpuId cpu = Threads[0];
            if (cpu == null)
                return;

            GroupAffinity previousAffinity = ThreadAffinity.Set(cpu.Affinity);

            // MSRC001_0299
            // TU [19:16]
            // ESU [12:8] -> Unit 15.3 micro Joule per increment
            // PU [3:0]
            Ring0.ReadMsr(MSR_PWR_UNIT, out _, out _);

            // MSRC001_029A
            // total_energy [31:0]
            DateTime sampleTime = DateTime.Now;
            Ring0.ReadMsr(MSR_CORE_ENERGY_STAT, out uint eax, out _);
            uint totalEnergy = eax;

            // MSRC001_0293
            // CurHwPstate [24:22]
            // CurCpuVid [21:14]
            // CurCpuDfsId [13:8]
            // CurCpuFid [7:0]
            Ring0.ReadMsr(MSR_HARDWARE_PSTATE_STATUS, out eax, out _);
            int curCpuVid = (int)((eax >> 14) & 0xff);
            int curCpuDfsId = (int)((eax >> 8) & 0x3f);
            int curCpuFid = (int)(eax & 0xff);

            // MSRC001_0064 + x
            // IddDiv [31:30]
            // IddValue [29:22]
            // CpuVid [21:14]
            // CpuDfsId [13:8]
            // CpuFid [7:0]
            // Ring0.ReadMsr(MSR_PSTATE_0 + (uint)CurHwPstate, out eax, out edx);
            // int IddDiv = (int)((eax >> 30) & 0x03);
            // int IddValue = (int)((eax >> 22) & 0xff);
            // int CpuVid = (int)((eax >> 14) & 0xff);
            ThreadAffinity.Set(previousAffinity);

            // clock
            // CoreCOF is (Core::X86::Msr::PStateDef[CpuFid[7:0]] / Core::X86::Msr::PStateDef[CpuDfsId]) * 200
            double clock = 200.0;
            _busSpeed ??= _cpu.Sensors.FirstOrDefault(x => x.Name == "Bus Speed");
            if (_busSpeed?.Value.HasValue == true && _busSpeed.Value > 0)
                clock = (double)(_busSpeed.Value * 2);

            _clock.Value = (float)(curCpuFid / (double)curCpuDfsId * clock);

            // multiplier
            _multiplier.Value = (float)(curCpuFid / (double)curCpuDfsId * 2.0);

            // Voltage
            const double vidStep = 0.00625;
            double vcc = 1.550 - (vidStep * curCpuVid);
            _vcore.Value = (float)vcc;

            // power consumption
            // power.Value = (float) ((double)pu * 0.125);
            // esu = 15.3 micro Joule per increment
            if (_lastPwrTime.Ticks == 0)
            {
                _lastPwrTime = sampleTime;
                _lastPwrValue = totalEnergy;
            }

            // ticks diff
            TimeSpan time = sampleTime - _lastPwrTime;
            long pwr;
            if (_lastPwrValue <= totalEnergy)
                pwr = totalEnergy - _lastPwrValue;
            else
                pwr = (0xffffffff - _lastPwrValue) + totalEnergy;

            // update for next sample
            _lastPwrTime = sampleTime;
            _lastPwrValue = totalEnergy;

            double energy = 15.3e-6 * pwr;
            energy /= time.TotalSeconds;

            if (!double.IsNaN(energy))
                _power.Value = (float)energy;
        }
    }

    // ReSharper disable InconsistentNaming
    private const uint COFVID_STATUS = 0xC0010071;
    private const uint F17H_M01H_SVI = 0x0005A000;
    private const uint F17H_M01H_THM_TCON_CUR_TMP = 0x00059800;
    private const uint F17H_M70H_CCD1_TEMP = 0x00059954;
    private const uint F17H_M61H_CCD1_TEMP = 0x00059b08;
    private const uint F17H_TEMP_OFFSET_FLAG = 0x80000;
    private const uint FAMILY_17H_PCI_CONTROL_REGISTER = 0x60;
    private const uint HWCR = 0xC0010015;
    private const uint MSR_CORE_ENERGY_STAT = 0xC001029A;
    private const uint MSR_HARDWARE_PSTATE_STATUS = 0xC0010293;
    private const uint MSR_PKG_ENERGY_STAT = 0xC001029B;
    private const uint MSR_PSTATE_0 = 0xC0010064;
    private const uint MSR_PWR_UNIT = 0xC0010299;
    private const uint PERF_CTL_0 = 0xC0010000;
    private const uint PERF_CTR_0 = 0xC0010004;
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/AmdCpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.CPU;

internal abstract class AmdCpu : GenericCpu
{
    protected AmdCpu(int processorIndex, CpuId[][] cpuId, ISettings settings) : base(processorIndex, cpuId, settings)
    { }

    protected uint GetPciAddress(byte function, ushort deviceId)
    {
        // assemble the pci address
        uint address = Ring0.GetPciAddress(PCI_BUS, (byte)(PCI_BASE_DEVICE + Index), function);

        // verify that we have the correct bus, device and function
        if (!Ring0.ReadPciConfig(address, DEVICE_VENDOR_ID_REGISTER, out uint deviceVendor))
            return Interop.Ring0.INVALID_PCI_ADDRESS;

        if (deviceVendor != (deviceId << 16 | AMD_VENDOR_ID))
            return Interop.Ring0.INVALID_PCI_ADDRESS;

        return address;
    }

    // ReSharper disable InconsistentNaming
    private const ushort AMD_VENDOR_ID = 0x1022;
    private const byte DEVICE_VENDOR_ID_REGISTER = 0;
    private const byte PCI_BASE_DEVICE = 0x18;

    private const byte PCI_BUS = 0;
    // ReSharper restore InconsistentNaming
}
```

`LibreHardwareMonitorLib/Hardware/Cpu/CpuGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace LibreHardwareMonitor.Hardware.CPU;

internal class CpuGroup : IGroup
{
    private readonly List<GenericCpu> _hardware = new();
    private readonly CpuId[][][] _threads;

    public CpuGroup(ISettings settings)
    {
        CpuId[][] processorThreads = GetProcessorThreads();
        _threads = new CpuId[processorThreads.Length][][];

        int index = 0;
        foreach (CpuId[] threads in processorThreads)
        {
            if (threads.Length == 0)
                continue;

            CpuId[][] coreThreads = GroupThreadsByCore(threads);
            _threads[index] = coreThreads;

            switch (threads[0].Vendor)
            {
                case Vendor.Intel:
                    _hardware.Add(new IntelCpu(index, coreThreads, settings));
                    break;
                case Vendor.AMD:
                    switch (threads[0].Family)
                    {
                        case 0x0F:
                            _hardware.Add(new Amd0FCpu(index, coreThreads, settings));
                            break;
                        case 0x10:
                        case 0x11:
                        case 0x12:
                        case 0x14:
                        case 0x15:
                        case 0x16:
                            _hardware.Add(new Amd10Cpu(index, coreThreads, settings));
                            break;
                        case 0x17:
                        case 0x19:
                            _hardware.Add(new Amd17Cpu(index, coreThreads, settings));
                            break;
                        default:
                            _hardware.Add(new GenericCpu(index, coreThreads, settings));
                            break;
                    }

                    break;
                default:
                    _hardware.Add(new GenericCpu(index, coreThreads, settings));
                    break;
            }

            index++;
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        if (_threads == null)
            return null;

        StringBuilder r = new();
        r.AppendLine("CPUID");
        r.AppendLine();
        for (int i = 0; i < _threads.Length; i++)
        {
            r.AppendLine("Processor " + i);
            r.AppendLine();
            r.AppendFormat("Processor Vendor: {0}{1}", _threads[i][0][0].Vendor, Environment.NewLine);
            r.AppendFormat("Processor Brand: {0}{1}", _threads[i][0][0].BrandString, Environment.NewLine);
            r.AppendFormat("Family: 0x{0}{1}", _threads[i][0][0].Family.ToString("X", CultureInfo.InvariantCulture), Environment.NewLine);
            r.AppendFormat("Model: 0x{0}{1}", _threads[i][0][0].Model.ToString("X", CultureInfo.InvariantCulture), Environment.NewLine);
            r.AppendFormat("Stepping: 0x{0}{1}", _threads[i][0][0].Stepping.ToString("X", CultureInfo.InvariantCulture), Environment.NewLine);
            r.AppendLine();

            r.AppendLine("CPUID Return Values");
            r.AppendLine();
            for (int j = 0; j < _threads[i].Length; j++)
            {
                for (int k = 0; k < _threads[i][j].Length; k++)
                {
                    r.AppendLine(" CPU Group: " + _threads[i][j][k].Group);
                    r.AppendLine(" CPU Thread: " + _threads[i][j][k].Thread);
                    r.AppendLine(" APIC ID: " + _threads[i][j][k].ApicId);
                    r.AppendLine(" Processor ID: " + _threads[i][j][k].ProcessorId);
                    r.AppendLine(" Core ID: " + _threads[i][j][k].CoreId);
                    r.AppendLine(" Thread ID: " + _threads[i][j][k].ThreadId);
                    r.AppendLine();
                    r.AppendLine(" Function  EAX       EBX       ECX       EDX");
                    AppendCpuidData(r, _threads[i][j][k].Data, CpuId.CPUID_0);
                    AppendCpuidData(r, _threads[i][j][k].ExtData, CpuId.CPUID_EXT);
                    r.AppendLine();
                }
            }
        }

        return r.ToString();
    }

    public void Close()
    {
        foreach (GenericCpu cpu in _hardware)
        {
            cpu.Close();
        }
    }

    private static CpuId[][] GetProcessorThreads()
    {
        List<CpuId> threads = new();

        for (int i = 0; i < ThreadAffinity.ProcessorGroupCount; i++)
        {
            for (int j = 0; j < 64; j++)
            {
                try
                {
                    if (!ThreadAffinity.IsValid(GroupAffinity.Single((ushort)i, j)))
                        continue;

                    var cpuid = CpuId.Get(i, j);
                    if (cpuid != null)
                        threads.Add(cpuid);
                }
                catch (ArgumentOutOfRangeException)
                {
                    // All cores found.
                    break;
                }
            }
        }

        SortedDictionary<uint, List<CpuId>> processors = new();
        foreach (CpuId thread in threads)
        {
            processors.TryGetValue(thread.ProcessorId, out List<CpuId> list);
            if (list == null)
            {
                list = new List<CpuId>();
                processors.Add(thread.ProcessorId, list);
            }

            list.Add(thread);
        }

        CpuId[][] processorThreads = new CpuId[processors.Count][];
        int index = 0;
        foreach (List<CpuId> list in processors.Values)
        {
            processorThreads[index] = list.ToArray();
            index++;
        }

        return processorThreads;
    }

    private static CpuId[][] GroupThreadsByCore(IEnumerable<CpuId> threads)
    {
        SortedDictionary<uint, List<CpuId>> cores = new();
        foreach (CpuId thread in threads)
        {
            cores.TryGetValue(thread.CoreId, out List<CpuId> coreList);
            if (coreList == null)
            {
                coreList = new List<CpuId>();
                cores.Add(thread.CoreId, coreList);
            }

            coreList.Add(thread);
        }

        CpuId[][] coreThreads = new CpuId[cores.Count][];
        int index = 0;
        foreach (List<CpuId> list in cores.Values)
        {
            coreThreads[index] = list.ToArray();
            index++;
        }

        return coreThreads;
    }

    private static void AppendCpuidData(StringBuilder r, uint[,] data, uint offset)
    {
        for (int i = 0; i < data.GetLength(0); i++)
        {
            r.Append(" ");
            r.Append((i + offset).ToString("X8", CultureInfo.InvariantCulture));
            for (int j = 0; j < 4; j++)
            {
                r.Append("  ");
                r.Append(data[i, j].ToString("X8", CultureInfo.InvariantCulture));
            }

            r.AppendLine();
        }
    }
}
```

`LibreHardwareMonitorLib/Hardware/Cpu/CpuId.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Text;

namespace LibreHardwareMonitor.Hardware.CPU;

public enum Vendor
{
    Unknown,
    Intel,
    AMD
}

public class CpuId
{
    /// <summary>
    /// Initializes a new instance of the <see cref="CpuId" /> class.
    /// </summary>
    /// <param name="group">The group.</param>
    /// <param name="thread">The thread.</param>
    /// <param name="affinity">The affinity.</param>
    private CpuId(int group, int thread, GroupAffinity affinity)
    {
        Thread = thread;
        Group = group;
        Affinity = affinity;

        uint threadMaskWith;
        uint coreMaskWith;
        uint maxCpuidExt;

        if (thread >= 64)
            throw new ArgumentOutOfRangeException(nameof(thread));

        uint maxCpuid;
        if (OpCode.CpuId(CPUID_0, 0, out uint eax, out uint ebx, out uint ecx, out uint edx))
        {
            if (eax > 0)
                maxCpuid = eax;
            else
                return;

            StringBuilder vendorBuilder = new();
            AppendRegister(vendorBuilder, ebx);
            AppendRegister(vendorBuilder, edx);
            AppendRegister(vendorBuilder, ecx);
            Vendor = vendorBuilder.ToString() switch
            {
                "GenuineIntel" => Vendor.Intel,
                "AuthenticAMD" => Vendor.AMD,
                _ => Vendor.Unknown
            };

            if (OpCode.CpuId(CPUID_EXT, 0, out eax, out _, out _, out _))
            {
                if (eax > CPUID_EXT)
                    maxCpuidExt = eax - CPUID_EXT;
                else
                    return;
            }
            else
            {
                throw new ArgumentOutOfRangeException(nameof(thread));
            }
        }
        else
        {
            throw new ArgumentOutOfRangeException(nameof(thread));
        }

        maxCpuid = Math.Min(maxCpuid, 1024);
        maxCpuidExt = Math.Min(maxCpuidExt, 1024);

        Data = new uint[maxCpuid + 1, 4];
        for (uint i = 0; i < maxCpuid + 1; i++)
        {
            OpCode.CpuId(CPUID_0 + i, 0, out Data[i, 0], out Data[i, 1], out Data[i, 2], out Data[i, 3]);
        }

        ExtData = new uint[maxCpuidExt + 1, 4];
        for (uint i = 0; i < maxCpuidExt + 1; i++)
        {
            OpCode.CpuId(CPUID_EXT + i, 0, out ExtData[i, 0], out ExtData[i, 1], out ExtData[i, 2], out ExtData[i, 3]);
        }

        StringBuilder nameBuilder = new();
        for (uint i = 2; i <= 4; i++)
        {
            if (OpCode.CpuId(CPUID_EXT + i, 0, out eax, out ebx, out ecx, out edx))
            {
                AppendRegister(nameBuilder, eax);
                AppendRegister(nameBuilder, ebx);
                AppendRegister(nameBuilder, ecx);
                AppendRegister(nameBuilder, edx);
            }
        }

        nameBuilder.Replace('\0', ' ');
        BrandString = nameBuilder.ToString().Trim();
        nameBuilder.Replace("(R)", string.Empty);
        nameBuilder.Replace("(TM)", string.Empty);
        nameBuilder.Replace("(tm)", string.Empty);
        nameBuilder.Replace("CPU", string.Empty);
        nameBuilder.Replace("Dual-Core Processor", string.Empty);
        nameBuilder.Replace("Triple-Core Processor", string.Empty);
        nameBuilder.Replace("Quad-Core Processor", string.Empty);
        nameBuilder.Replace("Six-Core Processor", string.Empty);
        nameBuilder.Replace("Eight-Core Processor", string.Empty);
        nameBuilder.Replace("6-Core Processor", string.Empty);
        nameBuilder.Replace("8-Core Processor", string.Empty);
        nameBuilder.Replace("12-Core Processor", string.Empty);
        nameBuilder.Replace("16-Core Processor", string.Empty);
        nameBuilder.Replace("24-Core Processor", string.Empty);
        nameBuilder.Replace("32-Core Processor", string.Empty);
        nameBuilder.Replace("64-Core Processor", string.Empty);

        for (int i = 0; i < 10; i++)
            nameBuilder.Replace("  ", " ");

        Name = nameBuilder.ToString();
        if (Name.Contains("@"))
            Name = Name.Remove(Name.LastIndexOf('@'));

        Name = Name.Trim();
        Family = ((Data[1, 0] & 0x0FF00000) >> 20) + ((Data[1, 0] & 0x0F00) >> 8);
        Model = ((Data[1, 0] & 0x0F0000) >> 12) + ((Data[1, 0] & 0xF0) >> 4);
        Stepping = Data[1, 0] & 0x0F;
        ApicId = (Data[1, 1] >> 24) & 0xFF;
        PkgType = (ExtData[1, 1] >> 28) & 0xFF;

        switch (Vendor)
        {
            case Vendor.Intel:
                uint maxCoreAndThreadIdPerPackage = (Data[1, 1] >> 16) & 0xFF;
                uint maxCoreIdPerPackage;
                if (maxCpuid >= 4)
                    maxCoreIdPerPackage = ((Data[4, 0] >> 26) & 0x3F) + 1;
                else
                    maxCoreIdPerPackage = 1;

                threadMaskWith = NextLog2(maxCoreAndThreadIdPerPackage / maxCoreIdPerPackage);
                coreMaskWith = NextLog2(maxCoreIdPerPackage);
                break;

            case Vendor.AMD:
                uint corePerPackage;
                if (maxCpuidExt >= 8)
                    corePerPackage = (ExtData[8, 2] & 0xFF) + 1;
                else
                    corePerPackage = 1;

                threadMaskWith = 0;
                coreMaskWith = NextLog2(corePerPackage);

                if (Family is 0x17 or 0x19)
                {
                    // ApicIdCoreIdSize: APIC ID size.
                    // cores per DIE
                    // we need this for Ryzen 5 (4 cores, 8 threads) ans Ryzen 6 (6 cores, 12 threads)
                    // Ryzen 5: [core0][core1][dummy][dummy][core2][core3] (Core0 EBX = 00080800, Core2 EBX = 08080800)
                    coreMaskWith = ((ExtData[8, 2] >> 12) & 0xF) switch
                    {
                        0x04 => NextLog2(16), // Ryzen
                        0x05 => NextLog2(32), // Threadripper
                        0x06 => NextLog2(64), // Epic
                        _ => coreMaskWith
                    };
                }

                break;

            default:
                threadMaskWith = 0;
                coreMaskWith = 0;
                break;
        }

        ProcessorId = ApicId >> (int)(coreMaskWith + threadMaskWith);
        CoreId = (ApicId >> (int)threadMaskWith) - (ProcessorId << (int)coreMaskWith);
        ThreadId = ApicId - (ProcessorId << (int)(coreMaskWith + threadMaskWith)) - (CoreId << (int)threadMaskWith);
    }

    public GroupAffinity Affinity { get; }

    public uint ApicId { get; }

    public string BrandString { get; } = string.Empty;

    public uint CoreId { get; }

    public uint[,] Data { get; } = new uint[0, 0];

    public uint[,] ExtData { get; } = new uint[0, 0];

    public uint Family { get; }

    public int Group { get; }

    public uint Model { get; }

    public string Name { get; } = string.Empty;

    public uint PkgType { get; }

    public uint ProcessorId { get; }

    public uint Stepping { get; }

    public int Thread { get; }

    public uint ThreadId { get; }

    public Vendor Vendor { get; } = Vendor.Unknown;

    /// <summary>
    /// Gets the specified <see cref="CpuId" />.
    /// </summary>
    /// <param name="group">The group.</param>
    /// <param name="thread">The thread.</param>
    /// <returns><see cref="CpuId" />.</returns>
    public static CpuId Get(int group, int thread)
    {
        if (thread >= 64)
            return null;

        var affinity = GroupAffinity.Single((ushort)group, thread);

        GroupAffinity previousAffinity = ThreadAffinity.Set(affinity);
        if (previousAffinity == GroupAffinity.Undefined)
            return null;

        try
        {
            return new CpuId(group, thread, affinity);
        }
        finally
        {
            ThreadAffinity.Set(previousAffinity);
        }
    }

    private static void AppendRegister(StringBuilder b, uint value)
    {
        b.Append((char)(value & 0xff));
        b.Append((char)((value >> 8) & 0xff));
        b.Append((char)((value >> 16) & 0xff));
        b.Append((char)((value >> 24) & 0xff));
    }

    private static uint NextLog2(long x)
    {
        if (x <= 0)
            return 0;

        x--;
        uint count = 0;
        while (x > 0)
        {
            x >>= 1;
            count++;
        }

        return count;
    }

    // ReSharper disable InconsistentNaming
    public const uint CPUID_0 = 0;
    public const uint CPUID_EXT = 0x80000000;
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/CpuLoad.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Linq;
using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Hardware.CPU;

internal class CpuLoad
{
    private long[] _idleTimes;
    private readonly float[] _threadLoads;
    private float _totalLoad;
    private long[] _totalTimes;

    public CpuLoad(CpuId[][] cpuid)
    {
        _threadLoads = new float[cpuid.Sum(x => x.Length)];
        _totalLoad = 0;
        try
        {
            GetTimes(out _idleTimes, out _totalTimes);
        }
        catch (Exception)
        {
            _idleTimes = null;
            _totalTimes = null;
        }

        if (_idleTimes != null)
            IsAvailable = true;
    }

    public bool IsAvailable { get; }

    private static bool GetTimes(out long[] idle, out long[] total)
    {
        idle = null;
        total = null;

        //Query processor idle information
        Interop.NtDll.SYSTEM_PROCESSOR_IDLE_INFORMATION[] idleInformation = new Interop.NtDll.SYSTEM_PROCESSOR_IDLE_INFORMATION[64];
        int idleSize = Marshal.SizeOf(typeof(Interop.NtDll.SYSTEM_PROCESSOR_IDLE_INFORMATION));
        if (Interop.NtDll.NtQuerySystemInformation(Interop.NtDll.SYSTEM_INFORMATION_CLASS.SystemProcessorIdleInformation, idleInformation, idleInformation.Length * idleSize, out int idleReturn) != 0)
        {
            return false;
        }

        //Query processor performance information
        Interop.NtDll.SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION[] perfInformation = new Interop.NtDll.SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION[64];
        int perfSize = Marshal.SizeOf(typeof(Interop.NtDll.SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION));
        if (Interop.NtDll.NtQuerySystemInformation(Interop.NtDll.SYSTEM_INFORMATION_CLASS.SystemProcessorPerformanceInformation, perfInformation, perfInformation.Length * perfSize, out int perfReturn) != 0)
        {
            return false;
        }

        idle = new long[idleReturn / idleSize];
        for (int i = 0; i < idle.Length; i++)
        {
            idle[i] = idleInformation[i].IdleTime;
        }

        total = new long[perfReturn / perfSize];
        for (int i = 0; i < total.Length; i++)
        {
            total[i] = perfInformation[i].KernelTime + perfInformation[i].UserTime;
        }

        return true;
    }

    public float GetTotalLoad()
    {
        return _totalLoad;
    }

    public float GetThreadLoad(int thread)
    {
        return _threadLoads[thread];
    }

    public void Update()
    {
        if (_idleTimes == null)
            return;

        if (!GetTimes(out long[] newIdleTimes, out long[] newTotalTimes))
            return;

        for (int i = 0; i < Math.Min(newTotalTimes.Length, _totalTimes.Length); i++)
        {
            if (newTotalTimes[i] - _totalTimes[i] < 100000)
                return;
        }

        if (newIdleTimes == null)
            return;

        float total = 0;
        int count = 0;
        for (int i = 0; i < _threadLoads.Length && i < _idleTimes.Length && i < newIdleTimes.Length; i++)
        {
            float idle = (newIdleTimes[i] - _idleTimes[i]) / (float)(newTotalTimes[i] - _totalTimes[i]);
            _threadLoads[i] = 100f * (1.0f - Math.Min(idle, 1.0f));
            total += idle;
            count++;
        }

        if (count > 0)
        {
            total = 1.0f - (total / count);
            total = total < 0 ? 0 : total;
        }
        else
        {
            total = 0;
        }

        _totalLoad = total * 100;
        _totalTimes = newTotalTimes;
        _idleTimes = newIdleTimes;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/GenericCpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;

namespace LibreHardwareMonitor.Hardware.CPU;

public class GenericCpu : Hardware
{
    protected readonly int _coreCount;
    protected readonly CpuId[][] _cpuId;
    protected readonly uint _family;
    protected readonly uint _model;
    protected readonly uint _packageType;
    protected readonly uint _stepping;
    protected readonly int _threadCount;

    private readonly CpuLoad _cpuLoad;
    private readonly double _estimatedTimeStampCounterFrequency;
    private readonly double _estimatedTimeStampCounterFrequencyError;
    private readonly bool _isInvariantTimeStampCounter;
    private readonly Sensor[] _threadLoads;

    private readonly Sensor _totalLoad;
    private readonly Vendor _vendor;
    private long _lastTime;
    private ulong _lastTimeStampCount;

    public GenericCpu(int processorIndex, CpuId[][] cpuId, ISettings settings) : base(cpuId[0][0].Name, CreateIdentifier(cpuId[0][0].Vendor, processorIndex), settings)
    {
        _cpuId = cpuId;
        _vendor = cpuId[0][0].Vendor;
        _family = cpuId[0][0].Family;
        _model = cpuId[0][0].Model;
        _stepping = cpuId[0][0].Stepping;
        _packageType = cpuId[0][0].PkgType;

        Index = processorIndex;
        _coreCount = cpuId.Length;
        _threadCount = cpuId.Sum(x => x.Length);

        // Check if processor has MSRs.
        HasModelSpecificRegisters = cpuId[0][0].Data.GetLength(0) > 1 && (cpuId[0][0].Data[1, 3] & 0x20) != 0;

        // Check if processor has a TSC.
        HasTimeStampCounter = cpuId[0][0].Data.GetLength(0) > 1 && (cpuId[0][0].Data[1, 3] & 0x10) != 0;

        // Check if processor supports an invariant TSC.
        _isInvariantTimeStampCounter = cpuId[0][0].ExtData.GetLength(0) > 7 && (cpuId[0][0].ExtData[7, 3] & 0x100) != 0;

        _totalLoad = _coreCount > 1 ? new Sensor("CPU Total", 0, SensorType.Load, this, settings) : null;

        _cpuLoad = new CpuLoad(cpuId);
        if (_cpuLoad.IsAvailable)
        {
            _threadLoads = new Sensor[_threadCount];
            for (int coreIdx = 0; coreIdx < cpuId.Length; coreIdx++)
            {
                for (int threadIdx = 0; threadIdx < cpuId[coreIdx].Length; threadIdx++)
                {
                    int thread = cpuId[coreIdx][threadIdx].Thread;
                    if (thread < _threadLoads.Length)
                    {
                        // Some cores may have 2 threads while others have only one (e.g. P-cores vs E-cores on Intel 12th gen).
                        string sensorName = CoreString(coreIdx) + (cpuId[coreIdx].Length > 1 ? $" Thread #{threadIdx + 1}" : string.Empty);
                        _threadLoads[thread] = new Sensor(sensorName, thread + 1, SensorType.Load, this, settings);

                        ActivateSensor(_threadLoads[thread]);
                    }
                }
            }

            if (_totalLoad != null)
            {
                ActivateSensor(_totalLoad);
            }
        }

        if (HasTimeStampCounter)
        {
            GroupAffinity previousAffinity = ThreadAffinity.Set(cpuId[0][0].Affinity);
            EstimateTimeStampCounterFrequency(out _estimatedTimeStampCounterFrequency, out _estimatedTimeStampCounterFrequencyError);
            ThreadAffinity.Set(previousAffinity);
        }
        else
        {
            _estimatedTimeStampCounterFrequency = 0;
        }

        TimeStampCounterFrequency = _estimatedTimeStampCounterFrequency;
    }

    /// <summary>
    /// Gets the CPUID.
    /// </summary>
    public CpuId[][] CpuId => _cpuId;

    public override HardwareType HardwareType => HardwareType.Cpu;

    public bool HasModelSpecificRegisters { get; }

    public bool HasTimeStampCounter { get; }

    /// <summary>
    /// Gets the CPU index.
    /// </summary>
    public int Index { get; }

    public double TimeStampCounterFrequency { get; private set; }

    protected string CoreString(int i)
    {
        if (_coreCount == 1)
            return "CPU Core";

        return "CPU Core #" + (i + 1);
    }

    private static Identifier CreateIdentifier(Vendor vendor, int processorIndex)
    {
        string s = vendor switch
        {
            Vendor.AMD => "amdcpu",
            Vendor.Intel => "intelcpu",
            _ => "genericcpu"
        };

        return new Identifier(s, processorIndex.ToString(CultureInfo.InvariantCulture));
    }

    private static void EstimateTimeStampCounterFrequency(out double frequency, out double error)
    {
        // preload the function
        EstimateTimeStampCounterFrequency(0, out double f, out double e);
        EstimateTimeStampCounterFrequency(0, out f, out e);

        // estimate the frequency
        error = double.MaxValue;
        frequency = 0;
        for (int i = 0; i < 5; i++)
        {
            EstimateTimeStampCounterFrequency(0.025, out f, out e);
            if (e < error)
            {
                error = e;
                frequency = f;
            }

            if (error < 1e-4)
                break;
        }
    }

    private static void EstimateTimeStampCounterFrequency(double timeWindow, out double frequency, out double error)
    {
        long ticks = (long)(timeWindow * Stopwatch.Frequency);

        long timeBegin = Stopwatch.GetTimestamp() + (long)Math.Ceiling(0.001 * ticks);
        long timeEnd = timeBegin + ticks;

        while (Stopwatch.GetTimestamp() < timeBegin)
        { }

        ulong countBegin = OpCode.Rdtsc();
        long afterBegin = Stopwatch.GetTimestamp();

        while (Stopwatch.GetTimestamp() < timeEnd)
        { }

        ulong countEnd = OpCode.Rdtsc();
        long afterEnd = Stopwatch.GetTimestamp();

        double delta = timeEnd - timeBegin;
        frequency = 1e-6 * ((double)(countEnd - countBegin) * Stopwatch.Frequency) / delta;

        double beginError = (afterBegin - timeBegin) / delta;
        double endError = (afterEnd - timeEnd) / delta;
        error = beginError + endError;
    }

    private static void AppendMsrData(StringBuilder r, uint msr, GroupAffinity affinity)
    {
        if (Ring0.ReadMsr(msr, out uint eax, out uint edx, affinity))
        {
            r.Append(" ");
            r.Append(msr.ToString("X8", CultureInfo.InvariantCulture));
            r.Append("  ");
            r.Append(edx.ToString("X8", CultureInfo.InvariantCulture));
            r.Append("  ");
            r.Append(eax.ToString("X8", CultureInfo.InvariantCulture));
            r.AppendLine();
        }
    }

    protected virtual uint[] GetMsrs()
    {
        return null;
    }

    public override string GetReport()
    {
        StringBuilder r = new();

        switch (_vendor)
        {
            case Vendor.AMD:
                r.AppendLine("AMD CPU");
                break;
            case Vendor.Intel:
                r.AppendLine("Intel CPU");
                break;
            default:
                r.AppendLine("Generic CPU");
                break;
        }

        r.AppendLine();
        r.AppendFormat("Name: {0}{1}", _name, Environment.NewLine);
        r.AppendFormat("Number of Cores: {0}{1}", _coreCount, Environment.NewLine);
        r.AppendFormat("Threads per Core: {0}{1}", _cpuId[0].Length, Environment.NewLine);
        r.AppendLine(string.Format(CultureInfo.InvariantCulture, "Timer Frequency: {0} MHz", Stopwatch.Frequency * 1e-6));
        r.AppendLine("Time Stamp Counter: " + (HasTimeStampCounter ? _isInvariantTimeStampCounter ? "Invariant" : "Not Invariant" : "None"));
        r.AppendLine(string.Format(CultureInfo.InvariantCulture, "Estimated Time Stamp Counter Frequency: {0} MHz", Math.Round(_estimatedTimeStampCounterFrequency * 100) * 0.01));
        r.AppendLine(string.Format(CultureInfo.InvariantCulture,
                                   "Estimated Time Stamp Counter Frequency Error: {0} Mhz",
                                   Math.Round(_estimatedTimeStampCounterFrequency * _estimatedTimeStampCounterFrequencyError * 1e5) * 1e-5));

        r.AppendLine(string.Format(CultureInfo.InvariantCulture, "Time Stamp Counter Frequency: {0} MHz", Math.Round(TimeStampCounterFrequency * 100) * 0.01));
        r.AppendLine();

        uint[] msrArray = GetMsrs();
        if (msrArray is { Length: > 0 })
        {
            for (int i = 0; i < _cpuId.Length; i++)
            {
                r.AppendLine("MSR Core #" + (i + 1));
                r.AppendLine();
                r.AppendLine(" MSR       EDX       EAX");
                foreach (uint msr in msrArray)
                    AppendMsrData(r, msr, _cpuId[i][0].Affinity);

                r.AppendLine();
            }
        }

        return r.ToString();
    }

    public override void Update()
    {
        if (HasTimeStampCounter && _isInvariantTimeStampCounter)
        {
            // make sure always the same thread is used
            GroupAffinity previousAffinity = ThreadAffinity.Set(_cpuId[0][0].Affinity);

            // read time before and after getting the TSC to estimate the error
            long firstTime = Stopwatch.GetTimestamp();
            ulong timeStampCount = OpCode.Rdtsc();
            long time = Stopwatch.GetTimestamp();

            // restore the thread affinity mask
            ThreadAffinity.Set(previousAffinity);

            double delta = (double)(time - _lastTime) / Stopwatch.Frequency;
            double error = (double)(time - firstTime) / Stopwatch.Frequency;

            // only use data if they are measured accurate enough (max 0.1ms delay)
            if (error < 0.0001)
            {
                // ignore the first reading because there are no initial values
                // ignore readings with too large or too small time window
                if (_lastTime != 0 && delta is > 0.5 and < 2)
                {
                    // update the TSC frequency with the new value
                    TimeStampCounterFrequency = (timeStampCount - _lastTimeStampCount) / (1e6 * delta);
                }

                _lastTimeStampCount = timeStampCount;
                _lastTime = time;
            }
        }

        if (_cpuLoad.IsAvailable)
        {
            _cpuLoad.Update();

            if (_threadLoads != null)
            {
                for (int i = 0; i < _threadLoads.Length; i++)
                {
                    if (_threadLoads[i] != null)
                    {
                        _threadLoads[i].Value = _cpuLoad.GetThreadLoad(i);
                    }
                }
            }

            if (_totalLoad != null)
                _totalLoad.Value = _cpuLoad.GetTotalLoad();
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/IntelCpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text;

namespace LibreHardwareMonitor.Hardware.CPU;

internal sealed class IntelCpu : GenericCpu
{
    private readonly Sensor _busClock;
    private readonly Sensor _coreAvg;
    private readonly Sensor[] _coreClocks;
    private readonly Sensor _coreMax;
    private readonly Sensor[] _coreTemperatures;
    private readonly Sensor[] _coreVIDs;
    private readonly Sensor _coreVoltage;
    private readonly Sensor[] _distToTjMaxTemperatures;

    private readonly uint[] _energyStatusMsrs = { MSR_PKG_ENERGY_STATUS, MSR_PP0_ENERGY_STATUS, MSR_PP1_ENERGY_STATUS, MSR_DRAM_ENERGY_STATUS };
    private readonly uint[] _lastEnergyConsumed;
    private readonly DateTime[] _lastEnergyTime;

    private readonly MicroArchitecture _microArchitecture;
    private readonly Sensor _packageTemperature;
    private readonly Sensor[] _powerSensors;
    private readonly double _timeStampCounterMultiplier;

    public IntelCpu(int processorIndex, CpuId[][] cpuId, ISettings settings) : base(processorIndex, cpuId, settings)
    {
        uint eax;

        // set tjMax
        float[] tjMax;
        switch (_family)
        {
            case 0x06:
                {
                    switch (_model)
                    {
                        case 0x0F: // Intel Core 2 (65nm)
                            _microArchitecture = MicroArchitecture.Core;
                            tjMax = _stepping switch
                            {
                                // B2
                                0x06 => _coreCount switch
                                {
                                    2 => Floats(80 + 10),
                                    4 => Floats(90 + 10),
                                    _ => Floats(85 + 10)
                                },
                                // G0
                                0x0B => Floats(90 + 10),
                                // M0
                                0x0D => Floats(85 + 10),
                                _ => Floats(85 + 10)
                            };
                            break;

                        case 0x17: // Intel Core 2 (45nm)
                            _microArchitecture = MicroArchitecture.Core;
                            tjMax = Floats(100);
                            break;

                        case 0x1C: // Intel Atom (45nm)
                            _microArchitecture = MicroArchitecture.Atom;
                            tjMax = _stepping switch
                            {
                                // C0
                                0x02 => Floats(90),
                                // A0, B0
                                0x0A => Floats(100),
                                _ => Floats(90)
                            };
                            break;

                        case 0x1A: // Intel Core i7 LGA1366 (45nm)
                        case 0x1E: // Intel Core i5, i7 LGA1156 (45nm)
                        case 0x1F: // Intel Core i5, i7
                        case 0x25: // Intel Core i3, i5, i7 LGA1156 (32nm)
                        case 0x2C: // Intel Core i7 LGA1366 (32nm) 6 Core
                        case 0x2E: // Intel Xeon Processor 7500 series (45nm)
                        case 0x2F: // Intel Xeon Processor (32nm)
                            _microArchitecture = MicroArchitecture.Nehalem;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x2A: // Intel Core i5, i7 2xxx LGA1155 (32nm)
                        case 0x2D: // Next Generation Intel Xeon, i7 3xxx LGA2011 (32nm)
                            _microArchitecture = MicroArchitecture.SandyBridge;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x3A: // Intel Core i5, i7 3xxx LGA1155 (22nm)
                        case 0x3E: // Intel Core i7 4xxx LGA2011 (22nm)
                            _microArchitecture = MicroArchitecture.IvyBridge;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x3C: // Intel Core i5, i7 4xxx LGA1150 (22nm)
                        case 0x3F: // Intel Xeon E5-2600/1600 v3, Core i7-59xx
                        // LGA2011-v3, Haswell-E (22nm)
                        case 0x45: // Intel Core i5, i7 4xxxU (22nm)
                        case 0x46:
                            _microArchitecture = MicroArchitecture.Haswell;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x3D: // Intel Core M-5xxx (14nm)
                        case 0x47: // Intel i5, i7 5xxx, Xeon E3-1200 v4 (14nm)
                        case 0x4F: // Intel Xeon E5-26xx v4
                        case 0x56: // Intel Xeon D-15xx
                            _microArchitecture = MicroArchitecture.Broadwell;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x36: // Intel Atom S1xxx, D2xxx, N2xxx (32nm)
                            _microArchitecture = MicroArchitecture.Atom;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x37: // Intel Atom E3xxx, Z3xxx (22nm)
                        case 0x4A:
                        case 0x4D: // Intel Atom C2xxx (22nm)
                        case 0x5A:
                        case 0x5D:
                            _microArchitecture = MicroArchitecture.Silvermont;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x4E:
                        case 0x5E: // Intel Core i5, i7 6xxxx LGA1151 (14nm)
                        case 0x55: // Intel Core X i7, i9 7xxx LGA2066 (14nm)
                            _microArchitecture = MicroArchitecture.Skylake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x4C: // Intel Airmont (Cherry Trail, Braswell)
                            _microArchitecture = MicroArchitecture.Airmont;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x8E: // Intel Core i5, i7 7xxxx (14nm) (Kaby Lake) and 8xxxx (14nm++) (Coffee Lake)
                        case 0x9E:
                            _microArchitecture = MicroArchitecture.KabyLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x5C: // Goldmont (Apollo Lake)
                        case 0x5F: // (Denverton)
                            _microArchitecture = MicroArchitecture.Goldmont;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x7A: // Goldmont plus (Gemini Lake)
                            _microArchitecture = MicroArchitecture.GoldmontPlus;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x66: // Intel Core i3 8xxx (10nm) (Cannon Lake)
                            _microArchitecture = MicroArchitecture.CannonLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x7D: // Intel Core i3, i5, i7 10xxx (10nm) (Ice Lake)
                        case 0x7E:
                        case 0x6A: // Ice Lake server
                        case 0x6C:
                            _microArchitecture = MicroArchitecture.IceLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0xA5:
                        case 0xA6: // Intel Core i3, i5, i7 10xxxU (14nm)
                            _microArchitecture = MicroArchitecture.CometLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x86: // Tremont (10nm) (Elkhart Lake, Skyhawk Lake)
                            _microArchitecture = MicroArchitecture.Tremont;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x8C: // Tiger Lake (10nm)
                        case 0x8D:
                            _microArchitecture = MicroArchitecture.TigerLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x97: // Alder Lake (7/10nm)
                        case 0x9A: // Alder Lake-L (7/10nm)
                        case 0xBE: // Alder Lake-N (7/10nm)
                            _microArchitecture = MicroArchitecture.AlderLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0xB7: // Raptor Lake (7nm)
                        case 0xBA: // Raptor Lake-P (7nm)
                        case 0xBF: // Raptor Lake-N (7nm)
                            _microArchitecture = MicroArchitecture.RaptorLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x9C: // Jasper Lake (10nm)
                            _microArchitecture = MicroArchitecture.JasperLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0xA7: // Intel Core i5, i6, i7 11xxx (14nm) (Rocket Lake)
                            _microArchitecture = MicroArchitecture.RocketLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        default:
                            _microArchitecture = MicroArchitecture.Unknown;
                            tjMax = Floats(100);
                            break;
                    }
                }

                break;
            case 0x0F:
                switch (_model)
                {
                    case 0x00: // Pentium 4 (180nm)
                    case 0x01: // Pentium 4 (130nm)
                    case 0x02: // Pentium 4 (130nm)
                    case 0x03: // Pentium 4, Celeron D (90nm)
                    case 0x04: // Pentium 4, Pentium D, Celeron D (90nm)
                    case 0x06: // Pentium 4, Pentium D, Celeron D (65nm)
                        _microArchitecture = MicroArchitecture.NetBurst;
                        tjMax = Floats(100);
                        break;

                    default:
                        _microArchitecture = MicroArchitecture.Unknown;
                        tjMax = Floats(100);
                        break;
                }

                break;
            default:
                _microArchitecture = MicroArchitecture.Unknown;
                tjMax = Floats(100);
                break;
        }

        // set timeStampCounterMultiplier
        switch (_microArchitecture)
        {
            case MicroArchitecture.Atom:
            case MicroArchitecture.Core:
            case MicroArchitecture.NetBurst:
                if (Ring0.ReadMsr(IA32_PERF_STATUS, out uint _, out uint edx))
                    _timeStampCounterMultiplier = ((edx >> 8) & 0x1f) + (0.5 * ((edx >> 14) & 1));

                break;
            case MicroArchitecture.Airmont:
            case MicroArchitecture.AlderLake:
            case MicroArchitecture.Broadwell:
            case MicroArchitecture.CannonLake:
            case MicroArchitecture.CometLake:
            case MicroArchitecture.Goldmont:
            case MicroArchitecture.GoldmontPlus:
            case MicroArchitecture.Haswell:
            case MicroArchitecture.IceLake:
            case MicroArchitecture.IvyBridge:
            case MicroArchitecture.JasperLake:
            case MicroArchitecture.KabyLake:
            case MicroArchitecture.Nehalem:
            case MicroArchitecture.RaptorLake:
            case MicroArchitecture.RocketLake:
            case MicroArchitecture.SandyBridge:
            case MicroArchitecture.Silvermont:
            case MicroArchitecture.Skylake:
            case MicroArchitecture.TigerLake:
            case MicroArchitecture.Tremont:
                if (Ring0.ReadMsr(MSR_PLATFORM_INFO, out eax, out uint _))
                    _timeStampCounterMultiplier = (eax >> 8) & 0xff;

                break;
            default:
                _timeStampCounterMultiplier = 0;
                break;
        }

        int coreSensorId = 0;

        // check if processor supports a digital thermal sensor at core level
        if (cpuId[0][0].Data.GetLength(0) > 6 && (cpuId[0][0].Data[6, 0] & 1) != 0 && _microArchitecture != MicroArchitecture.Unknown)
        {
            _coreTemperatures = new Sensor[_coreCount];
            for (int i = 0; i < _coreTemperatures.Length; i++)
            {
                _coreTemperatures[i] = new Sensor(CoreString(i),
                                                  coreSensorId,
                                                  SensorType.Temperature,
                                                  this,
                                                  new[]
                                                  {
                                                      new ParameterDescription("TjMax [°C]", "TjMax temperature of the core sensor.\n" + "Temperature = TjMax - TSlope * Value.", tjMax[i]),
                                                      new ParameterDescription("TSlope [°C]", "Temperature slope of the digital thermal sensor.\n" + "Temperature = TjMax - TSlope * Value.", 1)
                                                  },
                                                  settings);

                ActivateSensor(_coreTemperatures[i]);
                coreSensorId++;
            }
        }
        else
            _coreTemperatures = Array.Empty<Sensor>();

        // check if processor supports a digital thermal sensor at package level
        if (cpuId[0][0].Data.GetLength(0) > 6 && (cpuId[0][0].Data[6, 0] & 0x40) != 0 && _microArchitecture != MicroArchitecture.Unknown)
        {
            _packageTemperature = new Sensor("CPU Package",
                                             coreSensorId,
                                             SensorType.Temperature,
                                             this,
                                             new[]
                                             {
                                                 new ParameterDescription("TjMax [°C]", "TjMax temperature of the package sensor.\n" + "Temperature = TjMax - TSlope * Value.", tjMax[0]),
                                                 new ParameterDescription("TSlope [°C]", "Temperature slope of the digital thermal sensor.\n" + "Temperature = TjMax - TSlope * Value.", 1)
                                             },
                                             settings);

            ActivateSensor(_packageTemperature);
            coreSensorId++;
        }

        // dist to tjmax sensor
        if (cpuId[0][0].Data.GetLength(0) > 6 && (cpuId[0][0].Data[6, 0] & 1) != 0 && _microArchitecture != MicroArchitecture.Unknown)
        {
            _distToTjMaxTemperatures = new Sensor[_coreCount];
            for (int i = 0; i < _distToTjMaxTemperatures.Length; i++)
            {
                _distToTjMaxTemperatures[i] = new Sensor(CoreString(i) + " Distance to TjMax", coreSensorId, SensorType.Temperature, this, settings);
                ActivateSensor(_distToTjMaxTemperatures[i]);
                coreSensorId++;
            }
        }
        else
            _distToTjMaxTemperatures = Array.Empty<Sensor>();

        //core temp avg and max value
        //is only available when the cpu has more than 1 core
        if (cpuId[0][0].Data.GetLength(0) > 6 && (cpuId[0][0].Data[6, 0] & 0x40) != 0 && _microArchitecture != MicroArchitecture.Unknown && _coreCount > 1)
        {
            _coreMax = new Sensor("Core Max", coreSensorId, SensorType.Temperature, this, settings);
            ActivateSensor(_coreMax);
            coreSensorId++;

            _coreAvg = new Sensor("Core Average", coreSensorId, SensorType.Temperature, this, settings);
            ActivateSensor(_coreAvg);
        }
        else
        {
            _coreMax = null;
            _coreAvg = null;
        }

        _busClock = new Sensor("Bus Speed", 0, SensorType.Clock, this, settings);
        _coreClocks = new Sensor[_coreCount];
        for (int i = 0; i < _coreClocks.Length; i++)
        {
            _coreClocks[i] = new Sensor(CoreString(i), i + 1, SensorType.Clock, this, settings);
            if (HasTimeStampCounter && _microArchitecture != MicroArchitecture.Unknown)
                ActivateSensor(_coreClocks[i]);
        }

        if (_microArchitecture is MicroArchitecture.Airmont or
            MicroArchitecture.AlderLake or
            MicroArchitecture.Broadwell or
            MicroArchitecture.CannonLake or
            MicroArchitecture.CometLake or
            MicroArchitecture.Goldmont or
            MicroArchitecture.GoldmontPlus or
            MicroArchitecture.Haswell or
            MicroArchitecture.IceLake or
            MicroArchitecture.IvyBridge or
            MicroArchitecture.JasperLake or
            MicroArchitecture.KabyLake or
            MicroArchitecture.RaptorLake or
            MicroArchitecture.RocketLake or
            MicroArchitecture.SandyBridge or
            MicroArchitecture.Silvermont or
            MicroArchitecture.Skylake or
            MicroArchitecture.TigerLake or
            MicroArchitecture.Tremont)
        {
            _powerSensors = new Sensor[_energyStatusMsrs.Length];
            _lastEnergyTime = new DateTime[_energyStatusMsrs.Length];
            _lastEnergyConsumed = new uint[_energyStatusMsrs.Length];

            if (Ring0.ReadMsr(MSR_RAPL_POWER_UNIT, out eax, out uint _))
            {
                EnergyUnitsMultiplier = _microArchitecture switch
                {
                    MicroArchitecture.Silvermont or MicroArchitecture.Airmont => 1.0e-6f * (1 << (int)((eax >> 8) & 0x1F)),
                    _ => 1.0f / (1 << (int)((eax >> 8) & 0x1F))
                };
            }

            if (EnergyUnitsMultiplier != 0)
            {
                string[] powerSensorLabels = { "CPU Package", "CPU Cores", "CPU Graphics", "CPU Memory" };

                for (int i = 0; i < _energyStatusMsrs.Length; i++)
                {
                    if (!Ring0.ReadMsr(_energyStatusMsrs[i], out eax, out uint _))
                        continue;

                    // Don't show the "GPU Graphics" sensor on windows, it will show up under the GPU instead.
                    if (i == 2 && !Software.OperatingSystem.IsUnix)
                        continue;

                    _lastEnergyTime[i] = DateTime.UtcNow;
                    _lastEnergyConsumed[i] = eax;
                    _powerSensors[i] = new Sensor(powerSensorLabels[i],
                                                  i,
                                                  SensorType.Power,
                                                  this,
                                                  settings);

                    ActivateSensor(_powerSensors[i]);
                }
            }
        }

        if (Ring0.ReadMsr(IA32_PERF_STATUS, out eax, out uint _) && ((eax >> 32) & 0xFFFF) > 0)
        {
            _coreVoltage = new Sensor("CPU Core", 0, SensorType.Voltage, this, settings);
            ActivateSensor(_coreVoltage);
        }

        _coreVIDs = new Sensor[_coreCount];
        for (int i = 0; i < _coreVIDs.Length; i++)
        {
            _coreVIDs[i] = new Sensor(CoreString(i), i + 1, SensorType.Voltage, this, settings);
            ActivateSensor(_coreVIDs[i]);
        }

        Update();
    }

    public float EnergyUnitsMultiplier { get; }

    private float[] Floats(float f)
    {
        float[] result = new float[_coreCount];
        for (int i = 0; i < _coreCount; i++)
            result[i] = f;

        return result;
    }

    private float[] GetTjMaxFromMsr()
    {
        float[] result = new float[_coreCount];
        for (int i = 0; i < _coreCount; i++)
        {
            if (Ring0.ReadMsr(IA32_TEMPERATURE_TARGET, out uint eax, out uint _, _cpuId[i][0].Affinity))
                result[i] = (eax >> 16) & 0xFF;
            else
                result[i] = 100;
        }

        return result;
    }

    protected override uint[] GetMsrs()
    {
        return new[]
        {
            MSR_PLATFORM_INFO,
            IA32_PERF_STATUS,
            IA32_THERM_STATUS_MSR,
            IA32_TEMPERATURE_TARGET,
            IA32_PACKAGE_THERM_STATUS,
            MSR_RAPL_POWER_UNIT,
            MSR_PKG_ENERGY_STATUS,
            MSR_DRAM_ENERGY_STATUS,
            MSR_PP0_ENERGY_STATUS,
            MSR_PP1_ENERGY_STATUS
        };
    }

    public override string GetReport()
    {
        StringBuilder r = new();
        r.Append(base.GetReport());
        r.Append("MicroArchitecture: ");
        r.AppendLine(_microArchitecture.ToString());
        r.Append("Time Stamp Counter Multiplier: ");
        r.AppendLine(_timeStampCounterMultiplier.ToString(CultureInfo.InvariantCulture));
        r.AppendLine();
        return r.ToString();
    }

    public override void Update()
    {
        base.Update();

        float coreMax = float.MinValue;
        float coreAvg = 0;
        uint eax;

        for (int i = 0; i < _coreTemperatures.Length; i++)
        {
            // if reading is valid
            if (Ring0.ReadMsr(IA32_THERM_STATUS_MSR, out eax, out _, _cpuId[i][0].Affinity) && (eax & 0x80000000) != 0)
            {
                // get the dist from tjMax from bits 22:16
                float deltaT = (eax & 0x007F0000) >> 16;
                float tjMax = _coreTemperatures[i].Parameters[0].Value;
                float tSlope = _coreTemperatures[i].Parameters[1].Value;
                _coreTemperatures[i].Value = tjMax - (tSlope * deltaT);

                coreAvg += (float)_coreTemperatures[i].Value;
                if (coreMax < _coreTemperatures[i].Value)
                    coreMax = (float)_coreTemperatures[i].Value;

                _distToTjMaxTemperatures[i].Value = deltaT;
            }
            else
            {
                _coreTemperatures[i].Value = null;
                _distToTjMaxTemperatures[i].Value = null;
            }
        }

        //calculate average cpu temperature over all cores
        if (_coreMax != null && coreMax != float.MinValue)
        {
            _coreMax.Value = coreMax;
            coreAvg /= _coreTemperatures.Length;
            _coreAvg.Value = coreAvg;
        }

        if (_packageTemperature != null)
        {
            // if reading is valid
            if (Ring0.ReadMsr(IA32_PACKAGE_THERM_STATUS, out eax, out _, _cpuId[0][0].Affinity) && (eax & 0x80000000) != 0)
            {
                // get the dist from tjMax from bits 22:16
                float deltaT = (eax & 0x007F0000) >> 16;
                float tjMax = _packageTemperature.Parameters[0].Value;
                float tSlope = _packageTemperature.Parameters[1].Value;
                _packageTemperature.Value = tjMax - (tSlope * deltaT);
            }
            else
            {
                _packageTemperature.Value = null;
            }
        }

        if (HasTimeStampCounter && _timeStampCounterMultiplier > 0)
        {
            double newBusClock = 0;
            for (int i = 0; i < _coreClocks.Length; i++)
            {
                System.Threading.Thread.Sleep(1);
                if (Ring0.ReadMsr(IA32_PERF_STATUS, out eax, out _, _cpuId[i][0].Affinity))
                {
                    newBusClock = TimeStampCounterFrequency / _timeStampCounterMultiplier;
                    switch (_microArchitecture)
                    {
                        case MicroArchitecture.Nehalem:
                            _coreClocks[i].Value = (float)((eax & 0xff) * newBusClock);
                            break;
                        case MicroArchitecture.Airmont:
                        case MicroArchitecture.AlderLake:
                        case MicroArchitecture.Broadwell:
                        case MicroArchitecture.CannonLake:
                        case MicroArchitecture.CometLake:
                        case MicroArchitecture.Goldmont:
                        case MicroArchitecture.GoldmontPlus:
                        case MicroArchitecture.Haswell:
                        case MicroArchitecture.IceLake:
                        case MicroArchitecture.IvyBridge:
                        case MicroArchitecture.JasperLake:
                        case MicroArchitecture.KabyLake:
                        case MicroArchitecture.RaptorLake:
                        case MicroArchitecture.RocketLake:
                        case MicroArchitecture.SandyBridge:
                        case MicroArchitecture.Silvermont:
                        case MicroArchitecture.Skylake:
                        case MicroArchitecture.TigerLake:
                        case MicroArchitecture.Tremont:
                            _coreClocks[i].Value = (float)(((eax >> 8) & 0xff) * newBusClock);
                            break;
                        default:
                            _coreClocks[i].Value = (float)((((eax >> 8) & 0x1f) + (0.5 * ((eax >> 14) & 1))) * newBusClock);
                            break;
                    }
                }
                else
                {
                    // if IA32_PERF_STATUS is not available, assume TSC frequency
                    _coreClocks[i].Value = (float)TimeStampCounterFrequency;
                }
            }

            if (newBusClock > 0)
            {
                _busClock.Value = (float)newBusClock;
                ActivateSensor(_busClock);
            }
        }

        if (_powerSensors != null)
        {
            foreach (Sensor sensor in _powerSensors)
            {
                if (sensor == null)
                    continue;

                if (!Ring0.ReadMsr(_energyStatusMsrs[sensor.Index], out eax, out _))
                    continue;

                DateTime time = DateTime.UtcNow;
                uint energyConsumed = eax;
                float deltaTime = (float)(time - _lastEnergyTime[sensor.Index]).TotalSeconds;
                if (deltaTime < 0.01)
                    continue;

                sensor.Value = EnergyUnitsMultiplier * unchecked(energyConsumed - _lastEnergyConsumed[sensor.Index]) / deltaTime;
                _lastEnergyTime[sensor.Index] = time;
                _lastEnergyConsumed[sensor.Index] = energyConsumed;
            }
        }

        if (_coreVoltage != null && Ring0.ReadMsr(IA32_PERF_STATUS, out _, out uint edx))
        {
            _coreVoltage.Value = ((edx >> 32) & 0xFFFF) / (float)(1 << 13);
        }

        for (int i = 0; i < _coreVIDs.Length; i++)
        {
            if (Ring0.ReadMsr(IA32_PERF_STATUS, out _, out edx, _cpuId[i][0].Affinity) && ((edx >> 32) & 0xFFFF) > 0)
            {
                _coreVIDs[i].Value = ((edx >> 32) & 0xFFFF) / (float)(1 << 13);
                ActivateSensor(_coreVIDs[i]);
            }
            else
            {
                DeactivateSensor(_coreVIDs[i]);
            }
        }
    }

    [SuppressMessage("ReSharper", "IdentifierTypo")]
    private enum MicroArchitecture
    {
        Airmont,
        AlderLake,
        Atom,
        Broadwell,
        CannonLake,
        CometLake,
        Core,
        Goldmont,
        GoldmontPlus,
        Haswell,
        IceLake,
        IvyBridge,
        JasperLake,
        KabyLake,
        Nehalem,
        NetBurst,
        RocketLake,
        SandyBridge,
        Silvermont,
        Skylake,
        TigerLake,
        Tremont,
        RaptorLake,
        Unknown
    }

    // ReSharper disable InconsistentNaming
    private const uint IA32_PACKAGE_THERM_STATUS = 0x1B1;
    private const uint IA32_PERF_STATUS = 0x0198;
    private const uint IA32_TEMPERATURE_TARGET = 0x01A2;
    private const uint IA32_THERM_STATUS_MSR = 0x019C;

    private const uint MSR_DRAM_ENERGY_STATUS = 0x619;
    private const uint MSR_PKG_ENERGY_STATUS = 0x611;
    private const uint MSR_PLATFORM_INFO = 0xCE;
    private const uint MSR_PP0_ENERGY_STATUS = 0x639;
    private const uint MSR_PP1_ENERGY_STATUS = 0x641;

    private const uint MSR_RAPL_POWER_UNIT = 0x606;
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/D3DDisplayDevice.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.
// Ported from: https://github.com/processhacker/processhacker/blob/master/plugins/ExtendedTools/gpumon.c

using System;
using System.Linq;
using System.Runtime.InteropServices;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware;

internal static class D3DDisplayDevice
{
    public static string[] GetDeviceIdentifiers()
    {
        if (CfgMgr32.CM_Get_Device_Interface_List_Size(out uint size, ref CfgMgr32.GUID_DISPLAY_DEVICE_ARRIVAL, null, CfgMgr32.CM_GET_DEVICE_INTERFACE_LIST_PRESENT) != CfgMgr32.CR_SUCCESS)
            return null;

        char[] data = new char[size];
        if (CfgMgr32.CM_Get_Device_Interface_List(ref CfgMgr32.GUID_DISPLAY_DEVICE_ARRIVAL, null, data, (uint)data.Length, CfgMgr32.CM_GET_DEVICE_INTERFACE_LIST_PRESENT) == CfgMgr32.CR_SUCCESS)
            return new string(data).Split('\0').Where(m => !string.IsNullOrEmpty(m)).ToArray();

        return null;
    }

    public static string GetActualDeviceIdentifier(string deviceIdentifier)
    {
        if (string.IsNullOrEmpty(deviceIdentifier))
            return deviceIdentifier;

        // For example:
        // \\?\ROOT#BasicRender#0000#{1ca05180-a699-450a-9a0c-de4fbe3ddd89}  -->  ROOT\BasicRender\0000
        // \\?\PCI#VEN_1002&DEV_731F&SUBSYS_57051682&REV_C4#6&e539058&0&00000019#{1ca05180-a699-450a-9a0c-de4fbe3ddd89}  -->  PCI\VEN_1002&DEV_731F&SUBSYS_57051682&REV_C4\6&e539058&0&00000019

        if (deviceIdentifier.StartsWith(@"\\?\"))
            deviceIdentifier = deviceIdentifier.Substring(4);

        if (deviceIdentifier.Length > 0 && deviceIdentifier[deviceIdentifier.Length - 1] == '}')
        {
            int lastIndex = deviceIdentifier.LastIndexOf('{');
            if (lastIndex > 0)
                deviceIdentifier = deviceIdentifier.Substring(0, lastIndex - 1);
        }

        return deviceIdentifier.Replace('#', '\\');
    }

    public static bool GetDeviceInfoByIdentifier(string deviceIdentifier, out D3DDeviceInfo deviceInfo)
    {
        deviceInfo = new D3DDeviceInfo();

        OpenAdapterFromDeviceName(out uint status, deviceIdentifier, out D3dkmth.D3DKMT_OPENADAPTERFROMDEVICENAME adapter);
        if (status != WinNt.STATUS_SUCCESS)
            return false;

        GetAdapterType(out status, adapter, out D3dkmth.D3DKMT_ADAPTERTYPE adapterType);
        if (status != WinNt.STATUS_SUCCESS)
            return false;

        if (!adapterType.Value.HasFlag(D3dkmth.D3DKMT_ADAPTERTYPE_FLAGS.SoftwareDevice))
            return false;

        deviceInfo.Integrated = !adapterType.Value.HasFlag(D3dkmth.D3DKMT_ADAPTERTYPE_FLAGS.HybridIntegrated);

        GetQueryStatisticsAdapterInformation(out status, adapter, out D3dkmth.D3DKMT_QUERYSTATISTICS_ADAPTER_INFORMATION adapterInformation);
        if (status != WinNt.STATUS_SUCCESS)
            return false;

        uint segmentCount = adapterInformation.NbSegments;
        uint nodeCount = adapterInformation.NodeCount;

        deviceInfo.Nodes = new D3DDeviceNodeInfo[nodeCount];

        DateTime queryTime = DateTime.Now;

        for (uint nodeId = 0; nodeId < nodeCount; nodeId++)
        {
            GetNodeMetaData(out status, adapter, nodeId, out D3dkmth.D3DKMT_NODEMETADATA nodeMetaData);
            if (status != WinNt.STATUS_SUCCESS)
                return false;

            GetQueryStatisticsNode(out status, adapter, nodeId, out D3dkmth.D3DKMT_QUERYSTATISTICS_NODE_INFORMATION nodeInformation);
            if (status != WinNt.STATUS_SUCCESS)
                return false;

            deviceInfo.Nodes[nodeId] = new D3DDeviceNodeInfo
            {
                Id = nodeId,
                Name = GetNodeEngineTypeString(nodeMetaData),
                RunningTime = nodeInformation.GlobalInformation.RunningTime.QuadPart,
                QueryTime = queryTime
            };
        }

        GetSegmentSize(out status, adapter, out D3dkmth.D3DKMT_SEGMENTSIZEINFO segmentSizeInfo);
        if (status != WinNt.STATUS_SUCCESS)
            return false;

        deviceInfo.GpuSharedLimit = segmentSizeInfo.SharedSystemMemorySize;
        deviceInfo.GpuDedicatedLimit = segmentSizeInfo.DedicatedSystemMemorySize;

        for (uint segmentId = 0; segmentId < segmentCount; segmentId++)
        {
            GetQueryStatisticsSegment(out status, adapter, segmentId, out D3dkmth.D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION segmentInformation);
            if (status != WinNt.STATUS_SUCCESS)
                return false;

            ulong bytesResident = segmentInformation.BytesResident;
            ulong bytesCommitted = segmentInformation.BytesCommitted;

            uint aperture = segmentInformation.Aperture;

            if (aperture == 1)
            {
                deviceInfo.GpuSharedUsed += bytesResident;
                deviceInfo.GpuSharedMax += bytesCommitted;
            }
            else
            {
                deviceInfo.GpuDedicatedUsed += bytesResident;
                deviceInfo.GpuDedicatedMax += bytesCommitted;
            }
        }

        CloseAdapter(out status, adapter);
        return status == WinNt.STATUS_SUCCESS;
    }

    private static string GetNodeEngineTypeString(D3dkmth.D3DKMT_NODEMETADATA nodeMetaData)
    {
        return nodeMetaData.NodeData.EngineType switch
        {
            D3dkmdt.DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_OTHER => "D3D " + (!string.IsNullOrWhiteSpace(nodeMetaData.NodeData.FriendlyName) ? nodeMetaData.NodeData.FriendlyName : "Other"),
            D3dkmdt.DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_3D => "D3D 3D",
            D3dkmdt.DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_VIDEO_DECODE => "D3D Video Decode",
            D3dkmdt.DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_VIDEO_ENCODE => "D3D Video Encode",
            D3dkmdt.DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_VIDEO_PROCESSING => "D3D Video Processing",
            D3dkmdt.DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_SCENE_ASSEMBLY => "D3D Scene Assembly",
            D3dkmdt.DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_COPY => "D3D Copy",
            D3dkmdt.DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_OVERLAY => "D3D Overlay",
            D3dkmdt.DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_CRYPTO => "D3D Crypto",
            _ => "D3D Unknown"
        };
    }

    private static void GetSegmentSize
    (
        out uint status,
        D3dkmth.D3DKMT_OPENADAPTERFROMDEVICENAME adapter,
        out D3dkmth.D3DKMT_SEGMENTSIZEINFO sizeInformation)
    {
        IntPtr segmentSizePtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(D3dkmth.D3DKMT_SEGMENTSIZEINFO)));
        sizeInformation = new D3dkmth.D3DKMT_SEGMENTSIZEINFO();
        Marshal.StructureToPtr(sizeInformation, segmentSizePtr, true);

        var queryAdapterInfo = new D3dkmth.D3DKMT_QUERYADAPTERINFO
        {
            hAdapter = adapter.hAdapter,
            Type = D3dkmth.KMTQUERYADAPTERINFOTYPE.KMTQAITYPE_GETSEGMENTSIZE,
            pPrivateDriverData = segmentSizePtr,
            PrivateDriverDataSize = Marshal.SizeOf(typeof(D3dkmth.D3DKMT_SEGMENTSIZEINFO))
        };

        status = Gdi32.D3DKMTQueryAdapterInfo(ref queryAdapterInfo);
        sizeInformation = Marshal.PtrToStructure<D3dkmth.D3DKMT_SEGMENTSIZEINFO>(segmentSizePtr);
        Marshal.FreeHGlobal(segmentSizePtr);
    }

    private static void GetNodeMetaData(out uint status, D3dkmth.D3DKMT_OPENADAPTERFROMDEVICENAME adapter, uint nodeId, out D3dkmth.D3DKMT_NODEMETADATA nodeMetaDataResult)
    {
        IntPtr nodeMetaDataPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(D3dkmth.D3DKMT_NODEMETADATA)));
        nodeMetaDataResult = new D3dkmth.D3DKMT_NODEMETADATA { NodeOrdinalAndAdapterIndex = nodeId };
        Marshal.StructureToPtr(nodeMetaDataResult, nodeMetaDataPtr, true);

        var queryAdapterInfo = new D3dkmth.D3DKMT_QUERYADAPTERINFO
        {
            hAdapter = adapter.hAdapter,
            Type = D3dkmth.KMTQUERYADAPTERINFOTYPE.KMTQAITYPE_NODEMETADATA,
            pPrivateDriverData = nodeMetaDataPtr,
            PrivateDriverDataSize = Marshal.SizeOf(typeof(D3dkmth.D3DKMT_NODEMETADATA))
        };

        status = Gdi32.D3DKMTQueryAdapterInfo(ref queryAdapterInfo);
        nodeMetaDataResult = Marshal.PtrToStructure<D3dkmth.D3DKMT_NODEMETADATA>(nodeMetaDataPtr);
        Marshal.FreeHGlobal(nodeMetaDataPtr);
    }

    private static void GetQueryStatisticsNode(out uint status, D3dkmth.D3DKMT_OPENADAPTERFROMDEVICENAME adapter, uint nodeId, out D3dkmth.D3DKMT_QUERYSTATISTICS_NODE_INFORMATION nodeInformation)
    {
        var queryElement = new D3dkmth.D3DKMT_QUERYSTATISTICS_QUERY_ELEMENT { QueryNode = { NodeId = nodeId } };

        var queryStatistics = new D3dkmth.D3DKMT_QUERYSTATISTICS
        {
            AdapterLuid = adapter.AdapterLuid, Type = D3dkmth.D3DKMT_QUERYSTATISTICS_TYPE.D3DKMT_QUERYSTATISTICS_NODE, QueryElement = queryElement
        };

        status = Gdi32.D3DKMTQueryStatistics(ref queryStatistics);

        nodeInformation = queryStatistics.QueryResult.NodeInformation;
    }

    private static void GetQueryStatisticsSegment
    (
        out uint status,
        D3dkmth.D3DKMT_OPENADAPTERFROMDEVICENAME adapter,
        uint segmentId,
        out D3dkmth.D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION segmentInformation)
    {
        var queryElement = new D3dkmth.D3DKMT_QUERYSTATISTICS_QUERY_ELEMENT { QuerySegment = { SegmentId = segmentId } };

        var queryStatistics = new D3dkmth.D3DKMT_QUERYSTATISTICS
        {
            AdapterLuid = adapter.AdapterLuid, Type = D3dkmth.D3DKMT_QUERYSTATISTICS_TYPE.D3DKMT_QUERYSTATISTICS_SEGMENT, QueryElement = queryElement
        };

        status = Gdi32.D3DKMTQueryStatistics(ref queryStatistics);

        segmentInformation = queryStatistics.QueryResult.SegmentInformation;
    }

    private static void GetQueryStatisticsAdapterInformation
    (
        out uint status,
        D3dkmth.D3DKMT_OPENADAPTERFROMDEVICENAME adapter,
        out D3dkmth.D3DKMT_QUERYSTATISTICS_ADAPTER_INFORMATION adapterInformation)
    {
        var queryStatistics = new D3dkmth.D3DKMT_QUERYSTATISTICS { AdapterLuid = adapter.AdapterLuid, Type = D3dkmth.D3DKMT_QUERYSTATISTICS_TYPE.D3DKMT_QUERYSTATISTICS_ADAPTER };

        status = Gdi32.D3DKMTQueryStatistics(ref queryStatistics);

        adapterInformation = queryStatistics.QueryResult.AdapterInformation;
    }

    private static void GetAdapterType(out uint status, D3dkmth.D3DKMT_OPENADAPTERFROMDEVICENAME adapter, out D3dkmth.D3DKMT_ADAPTERTYPE adapterTypeResult)
    {
        IntPtr adapterTypePtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(D3dkmth.D3DKMT_ADAPTERTYPE)));
        var queryAdapterInfo = new D3dkmth.D3DKMT_QUERYADAPTERINFO
        {
            hAdapter = adapter.hAdapter,
            Type = D3dkmth.KMTQUERYADAPTERINFOTYPE.KMTQAITYPE_ADAPTERTYPE,
            pPrivateDriverData = adapterTypePtr,
            PrivateDriverDataSize = Marshal.SizeOf(typeof(D3dkmth.D3DKMT_ADAPTERTYPE))
        };

        status = Gdi32.D3DKMTQueryAdapterInfo(ref queryAdapterInfo);
        adapterTypeResult = Marshal.PtrToStructure<D3dkmth.D3DKMT_ADAPTERTYPE>(adapterTypePtr);
        Marshal.FreeHGlobal(adapterTypePtr);
    }

    private static void OpenAdapterFromDeviceName(out uint status, string displayDeviceName, out D3dkmth.D3DKMT_OPENADAPTERFROMDEVICENAME adapter)
    {
        adapter = new D3dkmth.D3DKMT_OPENADAPTERFROMDEVICENAME { pDeviceName = displayDeviceName };
        status = Gdi32.D3DKMTOpenAdapterFromDeviceName(ref adapter);
    }

    private static void CloseAdapter(out uint status, D3dkmth.D3DKMT_OPENADAPTERFROMDEVICENAME adapter)
    {
        var closeAdapter = new D3dkmth.D3DKMT_CLOSEADAPTER { hAdapter = adapter.hAdapter };
        status = Gdi32.D3DKMTCloseAdapter(ref closeAdapter);
    }

    public struct D3DDeviceNodeInfo
    {
        public ulong Id;
        public string Name;
        public long RunningTime;
        public DateTime QueryTime;
    }

    public struct D3DDeviceInfo
    {
        public ulong GpuSharedLimit;
        public ulong GpuDedicatedLimit;

        public ulong GpuSharedUsed;
        public ulong GpuDedicatedUsed;

        public ulong GpuSharedMax;
        public ulong GpuDedicatedMax;

        public D3DDeviceNodeInfo[] Nodes;
        public bool Integrated;
    }
}

```

`LibreHardwareMonitorLib/Hardware/FirmwareTable.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace LibreHardwareMonitor.Hardware;

internal static class FirmwareTable
{
    public static byte[] GetTable(Interop.Kernel32.Provider provider, string table)
    {
        int id = table[3] << 24 | table[2] << 16 | table[1] << 8 | table[0];
        return GetTable(provider, id);
    }

    public static byte[] GetTable(Interop.Kernel32.Provider provider, int table)
    {
        int size;

        try
        {
            size = Interop.Kernel32.GetSystemFirmwareTable(provider, table, IntPtr.Zero, 0);
        }
        catch (Exception e) when (e is DllNotFoundException or EntryPointNotFoundException)
        {
            return null;
        }

        if (size <= 0)
            return null;

        IntPtr allocatedBuffer = IntPtr.Zero;

        try
        {
            allocatedBuffer = Marshal.AllocHGlobal(size);

            Interop.Kernel32.GetSystemFirmwareTable(provider, table, allocatedBuffer, size);
            if (Marshal.GetLastWin32Error() != 0)
                return null;

            byte[] buffer = new byte[size];
            Marshal.Copy(allocatedBuffer, buffer, 0, size);
            return buffer;
        }
        finally
        {
            if (allocatedBuffer != IntPtr.Zero)
                Marshal.FreeHGlobal(allocatedBuffer);
        }
    }

    public static string[] EnumerateTables(Interop.Kernel32.Provider provider)
    {
        int size;

        try
        {
            size = Interop.Kernel32.EnumSystemFirmwareTables(provider, IntPtr.Zero, 0);
        }
        catch (Exception e) when (e is DllNotFoundException or EntryPointNotFoundException)
        {
            return null;
        }

        IntPtr allocatedBuffer = IntPtr.Zero;

        try
        {
            allocatedBuffer = Marshal.AllocHGlobal(size);

            Interop.Kernel32.EnumSystemFirmwareTables(provider, allocatedBuffer, size);

            byte[] buffer = new byte[size];
            Marshal.Copy(allocatedBuffer, buffer, 0, size);

            string[] result = new string[size / 4];

            for (int i = 0; i < result.Length; i++)
                result[i] = Encoding.ASCII.GetString(buffer, 4 * i, 4);

            return result;
        }
        finally
        {
            if (allocatedBuffer != IntPtr.Zero)
                Marshal.FreeHGlobal(allocatedBuffer);
        }
    }
}
```

`LibreHardwareMonitorLib/Hardware/Gpu/AmdGpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;
using System.Linq;
using System.Text;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal sealed class AmdGpu : GenericGpu
{
    private readonly AtiAdlxx.ADLAdapterInfo _adapterInfo;
    private readonly IntPtr _context = IntPtr.Zero;
    private readonly Sensor _controlSensor;
    private readonly Sensor _coreClock;
    private readonly Sensor _coreLoad;
    private readonly Sensor _coreVoltage;
    private readonly int _currentOverdriveApiLevel;
    private readonly string _d3dDeviceId;
    private readonly Sensor _fan;
    private readonly Control _fanControl;
    private readonly bool _frameMetricsStarted;
    private readonly Sensor _fullscreenFps;
    private readonly Sensor _gpuDedicatedMemoryUsage;
    private readonly Sensor[] _gpuNodeUsage;
    private readonly DateTime[] _gpuNodeUsagePrevTick;
    private readonly long[] _gpuNodeUsagePrevValue;
    private readonly Sensor _gpuSharedMemoryUsage;
    private readonly Sensor _memoryClock;
    private readonly Sensor _memoryLoad;
    private readonly Sensor _memoryVoltage;
    private readonly bool _overdriveApiSupported;
    private readonly Sensor _powerCore;
    private readonly Sensor _powerPpt;
    private readonly Sensor _powerSoC;
    private readonly Sensor _powerTotal;
    private readonly Sensor _socClock;
    private readonly Sensor _socVoltage;
    private readonly Sensor _temperatureCore;
    private readonly Sensor _temperatureHotSpot;
    private readonly Sensor _temperatureLiquid;
    private readonly Sensor _temperatureMemory;
    private readonly Sensor _temperatureMvdd;
    private readonly Sensor _temperaturePlx;
    private readonly Sensor _temperatureSoC;
    private readonly Sensor _temperatureVddc;

    private bool? _newQueryPmLogDataGetExists;

    public AmdGpu(AtiAdlxx.ADLAdapterInfo adapterInfo, ISettings settings)
        : base(adapterInfo.AdapterName.Trim(), new Identifier("gpu-amd", adapterInfo.AdapterIndex.ToString(CultureInfo.InvariantCulture)), settings)
    {
        _adapterInfo = adapterInfo;
        BusNumber = adapterInfo.BusNumber;
        DeviceNumber = adapterInfo.DeviceNumber;

        _temperatureCore = new Sensor("GPU Core", 0, SensorType.Temperature, this, settings);
        _temperatureMemory = new Sensor("GPU Memory", 1, SensorType.Temperature, this, settings);
        _temperatureVddc = new Sensor("GPU VR VDDC", 2, SensorType.Temperature, this, settings);
        _temperatureMvdd = new Sensor("GPU VR MVDD", 3, SensorType.Temperature, this, settings);
        _temperatureSoC = new Sensor("GPU VR SoC", 4, SensorType.Temperature, this, settings);
        _temperatureLiquid = new Sensor("GPU Liquid", 5, SensorType.Temperature, this, settings);
        _temperaturePlx = new Sensor("GPU PLX", 6, SensorType.Temperature, this, settings);
        _temperatureHotSpot = new Sensor("GPU Hot Spot", 7, SensorType.Temperature, this, settings);

        _coreClock = new Sensor("GPU Core", 0, SensorType.Clock, this, settings);
        _socClock = new Sensor("GPU SoC", 1, SensorType.Clock, this, settings);
        _memoryClock = new Sensor("GPU Memory", 2, SensorType.Clock, this, settings);

        _fan = new Sensor("GPU Fan", 0, SensorType.Fan, this, settings);

        _coreVoltage = new Sensor("GPU Core", 0, SensorType.Voltage, this, settings);
        _memoryVoltage = new Sensor("GPU Memory", 1, SensorType.Voltage, this, settings);
        _socVoltage = new Sensor("GPU SoC", 2, SensorType.Voltage, this, settings);

        _coreLoad = new Sensor("GPU Core", 0, SensorType.Load, this, settings);
        _memoryLoad = new Sensor("GPU Memory", 1, SensorType.Load, this, settings);

        _controlSensor = new Sensor("GPU Fan", 0, SensorType.Control, this, settings);

        _powerCore = new Sensor("GPU Core", 0, SensorType.Power, this, settings);
        _powerPpt = new Sensor("GPU PPT", 1, SensorType.Power, this, settings);
        _powerSoC = new Sensor("GPU SoC", 2, SensorType.Power, this, settings);
        _powerTotal = new Sensor("GPU Package", 3, SensorType.Power, this, settings);

        _fullscreenFps = new Sensor("Fullscreen FPS", 0, SensorType.Factor, this, settings);

        if (!Software.OperatingSystem.IsUnix)
        {
            string[] deviceIds = D3DDisplayDevice.GetDeviceIdentifiers();
            if (deviceIds != null)
            {
                foreach (string deviceId in deviceIds)
                {
                    string actualDeviceId = D3DDisplayDevice.GetActualDeviceIdentifier(deviceId);

                    if ((actualDeviceId.IndexOf(adapterInfo.PNPString, StringComparison.OrdinalIgnoreCase) != -1 ||
                         adapterInfo.PNPString.IndexOf(actualDeviceId, StringComparison.OrdinalIgnoreCase) != -1) &&
                        D3DDisplayDevice.GetDeviceInfoByIdentifier(deviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
                    {
                        _d3dDeviceId = deviceId;

                        int nodeSensorIndex = 2;
                        int memorySensorIndex = 0;

                        _gpuDedicatedMemoryUsage = new Sensor("D3D Dedicated Memory Used", memorySensorIndex++, SensorType.SmallData, this, settings);
                        _gpuSharedMemoryUsage = new Sensor("D3D Shared Memory Used", memorySensorIndex, SensorType.SmallData, this, settings);

                        _gpuNodeUsage = new Sensor[deviceInfo.Nodes.Length];
                        _gpuNodeUsagePrevValue = new long[deviceInfo.Nodes.Length];
                        _gpuNodeUsagePrevTick = new DateTime[deviceInfo.Nodes.Length];

                        foreach (D3DDisplayDevice.D3DDeviceNodeInfo node in deviceInfo.Nodes.OrderBy(x => x.Name))
                        {
                            _gpuNodeUsage[node.Id] = new Sensor(node.Name, nodeSensorIndex++, SensorType.Load, this, settings);
                            _gpuNodeUsagePrevValue[node.Id] = node.RunningTime;
                            _gpuNodeUsagePrevTick[node.Id] = node.QueryTime;
                        }

                        break;
                    }
                }
            }
        }

        int supported = 0;
        int enabled = 0;
        int version = 0;

        if (AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Adapter_FrameMetrics_Caps)) &&
            AtiAdlxx.ADL2_Adapter_FrameMetrics_Caps(_context, _adapterInfo.AdapterIndex, ref supported) == AtiAdlxx.ADLStatus.ADL_OK && supported == AtiAdlxx.ADL_TRUE && AtiAdlxx.ADL2_Adapter_FrameMetrics_Start(_context, _adapterInfo.AdapterIndex, 0) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            _frameMetricsStarted = true;
            _fullscreenFps.Value = -1;
            ActivateSensor(_fullscreenFps);
        }

        if (AtiAdlxx.ADL_Overdrive_Caps(_adapterInfo.AdapterIndex, ref supported, ref enabled, ref version) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            _overdriveApiSupported = supported == AtiAdlxx.ADL_TRUE;
            _currentOverdriveApiLevel = version;
        }
        else
        {
            _currentOverdriveApiLevel = -1;
        }

        if (_currentOverdriveApiLevel >= 5 &&
            AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Main_Control_Create)) &&
            AtiAdlxx.ADL2_Main_Control_Create(AtiAdlxx.Main_Memory_Alloc, _adapterInfo.AdapterIndex, ref _context) != AtiAdlxx.ADLStatus.ADL_OK)
        {
            _context = IntPtr.Zero;
        }

        AtiAdlxx.ADLFanSpeedInfo fanSpeedInfo = new();
        if (AtiAdlxx.ADL_Overdrive5_FanSpeedInfo_Get(_adapterInfo.AdapterIndex, 0, ref fanSpeedInfo) != AtiAdlxx.ADLStatus.ADL_OK)
        {
            fanSpeedInfo.MaxPercent = 100;
            fanSpeedInfo.MinPercent = 0;
        }

        _fanControl = new Control(_controlSensor, settings, fanSpeedInfo.MinPercent, fanSpeedInfo.MaxPercent);
        _fanControl.ControlModeChanged += ControlModeChanged;
        _fanControl.SoftwareControlValueChanged += SoftwareControlValueChanged;
        ControlModeChanged(_fanControl);
        _controlSensor.Control = _fanControl;

        Update();
    }

    public int BusNumber { get; }

    /// <inheritdoc />
    public override string DeviceId => _adapterInfo.PNPString;

    public int DeviceNumber { get; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.GpuAmd; }
    }

    private void SoftwareControlValueChanged(IControl control)
    {
        if (control.ControlMode == ControlMode.Software)
        {
            AtiAdlxx.ADLFanSpeedValue fanSpeedValue = new()
            {
                SpeedType = AtiAdlxx.ADL_DL_FANCTRL_SPEED_TYPE_PERCENT, Flags = AtiAdlxx.ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED, FanSpeed = (int)control.SoftwareValue
            };

            AtiAdlxx.ADL_Overdrive5_FanSpeed_Set(_adapterInfo.AdapterIndex, 0, ref fanSpeedValue);
        }
    }

    private void ControlModeChanged(IControl control)
    {
        switch (control.ControlMode)
        {
            case ControlMode.Undefined:
                return;
            case ControlMode.Default:
                SetDefaultFanSpeed();
                break;
            case ControlMode.Software:
                SoftwareControlValueChanged(control);
                break;
            default:
                return;
        }
    }

    /// <summary>
    /// Sets the default fan speed.
    /// </summary>
    private void SetDefaultFanSpeed()
    {
        AtiAdlxx.ADL_Overdrive5_FanSpeedToDefault_Set(_adapterInfo.AdapterIndex, 0);
    }

    public override void Update()
    {
        if (_d3dDeviceId != null && D3DDisplayDevice.GetDeviceInfoByIdentifier(_d3dDeviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
        {
            _gpuDedicatedMemoryUsage.Value = 1f * deviceInfo.GpuDedicatedUsed / 1024 / 1024;
            _gpuSharedMemoryUsage.Value = 1f * deviceInfo.GpuSharedUsed / 1024 / 1024;
            ActivateSensor(_gpuDedicatedMemoryUsage);
            ActivateSensor(_gpuSharedMemoryUsage);

            foreach (D3DDisplayDevice.D3DDeviceNodeInfo node in deviceInfo.Nodes)
            {
                long runningTimeDiff = node.RunningTime - _gpuNodeUsagePrevValue[node.Id];
                long timeDiff = node.QueryTime.Ticks - _gpuNodeUsagePrevTick[node.Id].Ticks;

                _gpuNodeUsage[node.Id].Value = 100f * runningTimeDiff / timeDiff;
                _gpuNodeUsagePrevValue[node.Id] = node.RunningTime;
                _gpuNodeUsagePrevTick[node.Id] = node.QueryTime;
                ActivateSensor(_gpuNodeUsage[node.Id]);
            }
        }

        if (_frameMetricsStarted)
        {
            float framesPerSecond = 0;
            if (AtiAdlxx.ADL2_Adapter_FrameMetrics_Get(_context, _adapterInfo.AdapterIndex, 0, ref framesPerSecond) == AtiAdlxx.ADLStatus.ADL_OK)
            {
                _fullscreenFps.Value = framesPerSecond;
            }
        }

        if (_overdriveApiSupported)
        {
            GetOD5Temperature(_temperatureCore);
            GetOD5FanSpeed(AtiAdlxx.ADL_DL_FANCTRL_SPEED_TYPE_RPM, _fan);
            GetOD5FanSpeed(AtiAdlxx.ADL_DL_FANCTRL_SPEED_TYPE_PERCENT, _controlSensor);
            GetOD5CurrentActivity();

            if (_currentOverdriveApiLevel >= 6)
            {
                GetOD6Power(AtiAdlxx.ADLODNCurrentPowerType.ODN_GPU_TOTAL_POWER, _powerTotal);
                GetOD6Power(AtiAdlxx.ADLODNCurrentPowerType.ODN_GPU_PPT_POWER, _powerPpt);
                GetOD6Power(AtiAdlxx.ADLODNCurrentPowerType.ODN_GPU_SOCKET_POWER, _powerSoC);
                GetOD6Power(AtiAdlxx.ADLODNCurrentPowerType.ODN_GPU_CHIP_POWER, _powerCore);
            }

            if (_currentOverdriveApiLevel >= 7)
            {
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.EDGE, _temperatureCore, -256, 0.001, false);
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.MEM, _temperatureMemory);
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.VRVDDC, _temperatureVddc);
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.VRMVDD, _temperatureMvdd);
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.LIQUID, _temperatureLiquid);
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.PLX, _temperaturePlx);
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.HOTSPOT, _temperatureHotSpot);
            }
        }

        if (_currentOverdriveApiLevel >= 8 || !_overdriveApiSupported)
        {
            AtiAdlxx.ADLPMLogDataOutput logDataOutput = new();

            _newQueryPmLogDataGetExists ??= AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_New_QueryPMLogData_Get));

            if (_newQueryPmLogDataGetExists == true && AtiAdlxx.ADL2_New_QueryPMLogData_Get(_context, _adapterInfo.AdapterIndex, ref logDataOutput) == AtiAdlxx.ADLStatus.ADL_OK)
            {
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_TEMPERATURE_EDGE, _temperatureCore, reset: false);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_TEMPERATURE_MEM, _temperatureMemory, reset: false);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_TEMPERATURE_VRVDDC, _temperatureVddc, reset: false);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_TEMPERATURE_VRMVDD, _temperatureMvdd, reset: false);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_TEMPERATURE_LIQUID, _temperatureLiquid, reset: false);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_TEMPERATURE_PLX, _temperaturePlx, reset: false);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_TEMPERATURE_HOTSPOT, _temperatureHotSpot, reset: false);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_TEMPERATURE_SOC, _temperatureSoC);

                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_CLK_GFXCLK, _coreClock, reset: false);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_CLK_SOCCLK, _socClock);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_CLK_MEMCLK, _memoryClock, reset: false);

                const int fanRpmIndex = (int)AtiAdlxx.ADLSensorType.PMLOG_FAN_RPM;
                const int fanPercentageIndex = (int)AtiAdlxx.ADLSensorType.PMLOG_FAN_PERCENTAGE;

                if (logDataOutput.sensors.Length is > fanRpmIndex and > fanPercentageIndex &&
                    logDataOutput.sensors[fanRpmIndex].value != ushort.MaxValue &&
                    logDataOutput.sensors[fanRpmIndex].supported != 0)
                {
                    _fan.Value = logDataOutput.sensors[fanRpmIndex].value;
                    _controlSensor.Value = logDataOutput.sensors[fanPercentageIndex].value;

                    ActivateSensor(_fan);
                    ActivateSensor(_controlSensor);
                }

                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_GFX_VOLTAGE, _coreVoltage, 0.001f, false);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_SOC_VOLTAGE, _socVoltage, 0.001f);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_MEM_VOLTAGE, _memoryVoltage, 0.001f);

                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_INFO_ACTIVITY_GFX, _coreLoad, reset: false);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_INFO_ACTIVITY_MEM, _memoryLoad);

                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_ASIC_POWER, _powerTotal, reset: false);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_GFX_POWER, _powerCore, reset: false);
                GetPMLog(logDataOutput, AtiAdlxx.ADLSensorType.PMLOG_SOC_POWER, _powerSoC, reset: false);
            }
        }
    }

    private void GetOD5CurrentActivity()
    {
        AtiAdlxx.ADLPMActivity adlpmActivity = new();
        if (AtiAdlxx.ADL_Overdrive5_CurrentActivity_Get(_adapterInfo.AdapterIndex, ref adlpmActivity) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            if (adlpmActivity.EngineClock > 0)
            {
                _coreClock.Value = 0.01f * adlpmActivity.EngineClock;
                ActivateSensor(_coreClock);
            }
            else
            {
                _coreClock.Value = null;
            }

            if (adlpmActivity.MemoryClock > 0)
            {
                _memoryClock.Value = 0.01f * adlpmActivity.MemoryClock;
                ActivateSensor(_memoryClock);
            }
            else
            {
                _memoryClock.Value = null;
            }

            if (adlpmActivity.Vddc > 0)
            {
                _coreVoltage.Value = 0.001f * adlpmActivity.Vddc;
                ActivateSensor(_coreVoltage);
            }
            else
            {
                _coreVoltage.Value = null;
            }

            _coreLoad.Value = Math.Min(adlpmActivity.ActivityPercent, 100);
            ActivateSensor(_coreLoad);
        }
        else
        {
            _coreClock.Value = null;
            _memoryClock.Value = null;
            _coreVoltage.Value = null;
            _coreLoad.Value = null;
        }
    }

    private void GetOD5FanSpeed(int speedType, Sensor sensor)
    {
        AtiAdlxx.ADLFanSpeedValue fanSpeedValue = new() { SpeedType = speedType };
        if (AtiAdlxx.ADL_Overdrive5_FanSpeed_Get(_adapterInfo.AdapterIndex, 0, ref fanSpeedValue) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            sensor.Value = fanSpeedValue.FanSpeed;
            ActivateSensor(sensor);
        }
        else
        {
            sensor.Value = null;
        }
    }

    private void GetOD5Temperature(Sensor temperatureCore)
    {
        AtiAdlxx.ADLTemperature temperature = new();
        if (AtiAdlxx.ADL_Overdrive5_Temperature_Get(_adapterInfo.AdapterIndex, 0, ref temperature) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            temperatureCore.Value = 0.001f * temperature.Temperature;
            ActivateSensor(temperatureCore);
        }
        else
        {
            temperatureCore.Value = null;
        }
    }

    /// <summary>
    /// Gets the OverdriveN temperature.
    /// </summary>
    /// <param name="type">The type.</param>
    /// <param name="sensor">The sensor.</param>
    /// <param name="minTemperature">The minimum temperature.</param>
    /// <param name="scale">The scale.</param>
    /// <param name="reset">If set to <c>true</c>, resets the sensor value to <c>null</c>.</param>
    private void GetODNTemperature(AtiAdlxx.ADLODNTemperatureType type, Sensor sensor, double minTemperature = -256, double scale = 1, bool reset = true)
    {
        // If a sensor isn't available, some cards report 54000 degrees C.
        // 110C is expected for Navi, so 256C should be enough to use as a maximum.

        int maxTemperature = (int)(256 / scale);
        minTemperature = (int)(minTemperature / scale);

        int temperature = 0;
        if (AtiAdlxx.ADL2_OverdriveN_Temperature_Get(_context, _adapterInfo.AdapterIndex, type, ref temperature) == AtiAdlxx.ADLStatus.ADL_OK &&
            temperature >= minTemperature &&
            temperature <= maxTemperature)
        {
            sensor.Value = (float)(scale * temperature);
            ActivateSensor(sensor);
        }
        else if (reset)
        {
            sensor.Value = null;
        }
    }

    /// <summary>
    /// Gets a PMLog sensor value.
    /// </summary>
    /// <param name="data">The data.</param>
    /// <param name="sensorType">Type of the sensor.</param>
    /// <param name="sensor">The sensor.</param>
    /// <param name="factor">The factor.</param>
    private void GetPMLog(AtiAdlxx.ADLPMLogDataOutput data, AtiAdlxx.ADLSensorType sensorType, Sensor sensor, float factor = 1.0f, bool reset = true)
    {
        int i = (int)sensorType;
        if (i < data.sensors.Length && data.sensors[i].supported != 0)
        {
            sensor.Value = data.sensors[i].value * factor;
            ActivateSensor(sensor);
        }
        else if (reset)
        {
            sensor.Value = null;
        }
    }

    /// <summary>
    /// Gets the Overdrive6 power.
    /// </summary>
    /// <param name="type">The type.</param>
    /// <param name="sensor">The sensor.</param>
    private void GetOD6Power(AtiAdlxx.ADLODNCurrentPowerType type, Sensor sensor)
    {
        int powerOf8 = 0;
        if (AtiAdlxx.ADL2_Overdrive6_CurrentPower_Get(_context, _adapterInfo.AdapterIndex, type, ref powerOf8) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            sensor.Value = powerOf8 >> 8;
            ActivateSensor(sensor);
        }
        else
        {
            sensor.Value = null;
        }
    }

    public override void Close()
    {
        _fanControl.ControlModeChanged -= ControlModeChanged;
        _fanControl.SoftwareControlValueChanged -= SoftwareControlValueChanged;

        if (_fanControl.ControlMode != ControlMode.Undefined)
            SetDefaultFanSpeed();

        if (_frameMetricsStarted)
            AtiAdlxx.ADL2_Adapter_FrameMetrics_Stop(_context, _adapterInfo.AdapterIndex, 0);

        if (_context != IntPtr.Zero)
            AtiAdlxx.ADL2_Main_Control_Destroy(_context);

        base.Close();
    }

    public override string GetReport()
    {
        var r = new StringBuilder();

        r.AppendLine("AMD GPU");
        r.AppendLine();

        r.Append("AdapterIndex: ");
        r.AppendLine(_adapterInfo.AdapterIndex.ToString(CultureInfo.InvariantCulture));
        r.AppendLine();

        r.AppendLine("Overdrive Caps");
        r.AppendLine();

        try
        {
            int supported = 0;
            int enabled = 0;
            int version = 0;
            AtiAdlxx.ADLStatus status = AtiAdlxx.ADL_Overdrive_Caps(_adapterInfo.AdapterIndex, ref supported, ref enabled, ref version);

            r.Append(" Status: ");
            r.AppendLine(status.ToString());
            r.Append(" Supported: ");
            r.AppendLine(supported.ToString(CultureInfo.InvariantCulture));
            r.Append(" Enabled: ");
            r.AppendLine(enabled.ToString(CultureInfo.InvariantCulture));
            r.Append(" Version: ");
            r.AppendLine(version.ToString(CultureInfo.InvariantCulture));
        }
        catch (Exception e)
        {
            r.AppendLine(" Status: " + e.Message);
        }

        r.AppendLine();

        r.AppendLine("Overdrive5 Parameters");
        r.AppendLine();
        try
        {
            AtiAdlxx.ADLStatus status = AtiAdlxx.ADL_Overdrive5_ODParameters_Get(_adapterInfo.AdapterIndex, out AtiAdlxx.ADLODParameters p);

            r.Append(" Status: ");
            r.AppendLine(status.ToString());
            r.AppendFormat(" NumberOfPerformanceLevels: {0}{1}", p.NumberOfPerformanceLevels, Environment.NewLine);
            r.AppendFormat(" ActivityReportingSupported: {0}{1}", p.ActivityReportingSupported, Environment.NewLine);
            r.AppendFormat(" DiscretePerformanceLevels: {0}{1}", p.DiscretePerformanceLevels, Environment.NewLine);
            r.AppendFormat(" EngineClock.Min: {0}{1}", p.EngineClock.Min, Environment.NewLine);
            r.AppendFormat(" EngineClock.Max: {0}{1}", p.EngineClock.Max, Environment.NewLine);
            r.AppendFormat(" EngineClock.Step: {0}{1}", p.EngineClock.Step, Environment.NewLine);
            r.AppendFormat(" MemoryClock.Min: {0}{1}", p.MemoryClock.Min, Environment.NewLine);
            r.AppendFormat(" MemoryClock.Max: {0}{1}", p.MemoryClock.Max, Environment.NewLine);
            r.AppendFormat(" MemoryClock.Step: {0}{1}", p.MemoryClock.Step, Environment.NewLine);
            r.AppendFormat(" Vddc.Min: {0}{1}", p.Vddc.Min, Environment.NewLine);
            r.AppendFormat(" Vddc.Max: {0}{1}", p.Vddc.Max, Environment.NewLine);
            r.AppendFormat(" Vddc.Step: {0}{1}", p.Vddc.Step, Environment.NewLine);
        }
        catch (Exception e)
        {
            r.AppendLine(" Status: " + e.Message);
        }

        r.AppendLine();

        r.AppendLine("Overdrive5 Temperature");
        r.AppendLine();
        try
        {
            var adlt = new AtiAdlxx.ADLTemperature();
            AtiAdlxx.ADLStatus status = AtiAdlxx.ADL_Overdrive5_Temperature_Get(_adapterInfo.AdapterIndex, 0, ref adlt);
            r.Append(" Status: ");
            r.AppendLine(status.ToString());
            r.AppendFormat(" Value: {0}{1}", 0.001f * adlt.Temperature, Environment.NewLine);
        }
        catch (Exception e)
        {
            r.AppendLine(" Status: " + e.Message);
        }

        r.AppendLine();

        r.AppendLine("Overdrive5 FanSpeed");
        r.AppendLine();
        try
        {
            var adlf = new AtiAdlxx.ADLFanSpeedValue { SpeedType = AtiAdlxx.ADL_DL_FANCTRL_SPEED_TYPE_RPM };
            AtiAdlxx.ADLStatus status = AtiAdlxx.ADL_Overdrive5_FanSpeed_Get(_adapterInfo.AdapterIndex, 0, ref adlf);
            r.Append(" Status RPM: ");
            r.AppendLine(status.ToString());
            r.AppendFormat(" Value RPM: {0}{1}", adlf.FanSpeed, Environment.NewLine);

            adlf.SpeedType = AtiAdlxx.ADL_DL_FANCTRL_SPEED_TYPE_PERCENT;
            status = AtiAdlxx.ADL_Overdrive5_FanSpeed_Get(_adapterInfo.AdapterIndex, 0, ref adlf);
            r.Append(" Status Percent: ");
            r.AppendLine(status.ToString());
            r.AppendFormat(" Value Percent: {0}{1}", adlf.FanSpeed, Environment.NewLine);
        }
        catch (Exception e)
        {
            r.AppendLine(" Status: " + e.Message);
        }

        r.AppendLine();

        r.AppendLine("Overdrive5 CurrentActivity");
        r.AppendLine();
        try
        {
            var adlp = new AtiAdlxx.ADLPMActivity();
            AtiAdlxx.ADLStatus status = AtiAdlxx.ADL_Overdrive5_CurrentActivity_Get(_adapterInfo.AdapterIndex, ref adlp);

            r.Append(" Status: ");
            r.AppendLine(status.ToString());
            r.AppendFormat(" EngineClock: {0}{1}", 0.01f * adlp.EngineClock, Environment.NewLine);
            r.AppendFormat(" MemoryClock: {0}{1}", 0.01f * adlp.MemoryClock, Environment.NewLine);
            r.AppendFormat(" Vddc: {0}{1}", 0.001f * adlp.Vddc, Environment.NewLine);
            r.AppendFormat(" ActivityPercent: {0}{1}", adlp.ActivityPercent, Environment.NewLine);
            r.AppendFormat(" CurrentPerformanceLevel: {0}{1}", adlp.CurrentPerformanceLevel, Environment.NewLine);
            r.AppendFormat(" CurrentBusSpeed: {0}{1}", adlp.CurrentBusSpeed, Environment.NewLine);
            r.AppendFormat(" CurrentBusLanes: {0}{1}", adlp.CurrentBusLanes, Environment.NewLine);
            r.AppendFormat(" MaximumBusLanes: {0}{1}", adlp.MaximumBusLanes, Environment.NewLine);
        }
        catch (Exception e)
        {
            r.AppendLine(" Status: " + e.Message);
        }

        r.AppendLine();

        if (_context != IntPtr.Zero)
        {
            r.AppendLine("Overdrive6 CurrentPower");
            r.AppendLine();
            try
            {
                int power = 0;
                for (int i = 0; i < 4; i++)
                {
                    string pt = ((AtiAdlxx.ADLODNCurrentPowerType)i).ToString();
                    AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_Overdrive6_CurrentPower_Get(_context, _adapterInfo.AdapterIndex, (AtiAdlxx.ADLODNCurrentPowerType)i, ref power);

                    r.AppendFormat(" Power[{0}].Status: {1}{2}", pt, status.ToString(), Environment.NewLine);
                    r.AppendFormat(" Power[{0}].Value: {1}{2}", pt, power * (1.0f / 0xFF), Environment.NewLine);
                }
            }
            catch (EntryPointNotFoundException)
            {
                r.AppendLine(" Status: Entry point not found");
            }
            catch (Exception e)
            {
                r.AppendLine(" Status: " + e.Message);
            }

            r.AppendLine();
        }

        if (_context != IntPtr.Zero)
        {
            r.AppendLine("OverdriveN Temperature");
            r.AppendLine();
            try
            {
                for (int i = 1; i < 8; i++)
                {
                    int temperature = 0;
                    string tt = ((AtiAdlxx.ADLODNTemperatureType)i).ToString();
                    AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_OverdriveN_Temperature_Get(_context, _adapterInfo.AdapterIndex, (AtiAdlxx.ADLODNTemperatureType)i, ref temperature);

                    r.AppendFormat(" Temperature[{0}].Status: {1}{2}", tt, status.ToString(), Environment.NewLine);
                    r.AppendFormat(" Temperature[{0}].Value: {1}{2}", tt, 0.001f * temperature, Environment.NewLine);
                }
            }
            catch (EntryPointNotFoundException)
            {
                r.AppendLine(" Status: Entry point not found");
            }
            catch (Exception e)
            {
                r.AppendLine(" Status: " + e.Message);
            }

            r.AppendLine();
        }

        if (_context != IntPtr.Zero)
        {
            r.AppendLine("OverdriveN Performance Status");
            r.AppendLine();
            try
            {
                AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_OverdriveN_PerformanceStatus_Get(_context, _adapterInfo.AdapterIndex, out AtiAdlxx.ADLODNPerformanceStatus ps);

                r.Append(" Status: ");
                r.AppendLine(status.ToString());
                r.AppendFormat(" CoreClock: {0}{1}", ps.CoreClock, Environment.NewLine);
                r.AppendFormat(" MemoryClock: {0}{1}", ps.MemoryClock, Environment.NewLine);
                r.AppendFormat(" DCEFClock: {0}{1}", ps.DCEFClock, Environment.NewLine);
                r.AppendFormat(" GFXClock: {0}{1}", ps.GFXClock, Environment.NewLine);
                r.AppendFormat(" UVDClock: {0}{1}", ps.UVDClock, Environment.NewLine);
                r.AppendFormat(" VCEClock: {0}{1}", ps.VCEClock, Environment.NewLine);
                r.AppendFormat(" GPUActivityPercent: {0}{1}", ps.GPUActivityPercent, Environment.NewLine);
                r.AppendFormat(" CurrentCorePerformanceLevel: {0}{1}", ps.CurrentCorePerformanceLevel, Environment.NewLine);
                r.AppendFormat(" CurrentMemoryPerformanceLevel: {0}{1}", ps.CurrentMemoryPerformanceLevel, Environment.NewLine);
                r.AppendFormat(" CurrentDCEFPerformanceLevel: {0}{1}", ps.CurrentDCEFPerformanceLevel, Environment.NewLine);
                r.AppendFormat(" CurrentGFXPerformanceLevel: {0}{1}", ps.CurrentGFXPerformanceLevel, Environment.NewLine);
                r.AppendFormat(" UVDPerformanceLevel: {0}{1}", ps.UVDPerformanceLevel, Environment.NewLine);
                r.AppendFormat(" VCEPerformanceLevel: {0}{1}", ps.VCEPerformanceLevel, Environment.NewLine);
                r.AppendFormat(" CurrentBusSpeed: {0}{1}", ps.CurrentBusSpeed, Environment.NewLine);
                r.AppendFormat(" CurrentBusLanes: {0}{1}", ps.CurrentBusLanes, Environment.NewLine);
                r.AppendFormat(" MaximumBusLanes: {0}{1}", ps.MaximumBusLanes, Environment.NewLine);
                r.AppendFormat(" VDDC: {0}{1}", ps.VDDC, Environment.NewLine);
                r.AppendFormat(" VDDCI: {0}{1}", ps.VDDCI, Environment.NewLine);
            }
            catch (EntryPointNotFoundException)
            {
                r.AppendLine(" Status: Entry point not found");
            }
            catch (Exception e)
            {
                r.AppendLine(" Status: " + e.Message);
            }

            r.AppendLine();
        }

        if (_context != IntPtr.Zero)
        {
            r.AppendLine("Performance Metrics");
            r.AppendLine();
            try
            {
                var data = new AtiAdlxx.ADLPMLogDataOutput();
                AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_New_QueryPMLogData_Get(_context, _adapterInfo.AdapterIndex, ref data);

                r.Append(" Status: ");
                r.AppendLine(status.ToString());

                for (int i = 0; i < data.sensors.Length; i++)
                {
                    string st = ((AtiAdlxx.ADLSensorType)i).ToString();

                    r.AppendFormat(" Sensor[{0}].Supported: {1}{2}", st, data.sensors[i].supported, Environment.NewLine);
                    r.AppendFormat(" Sensor[{0}].Value: {1}{2}", st, data.sensors[i].value, Environment.NewLine);
                }
            }
            catch (EntryPointNotFoundException)
            {
                r.AppendLine(" Status: Entry point not found");
            }
            catch (Exception e)
            {
                r.AppendLine(" Status: " + e.Message);
            }

            r.AppendLine();
        }

        if (_d3dDeviceId != null)
        {
            r.AppendLine("D3D");
            r.AppendLine();
            r.AppendLine(" Id: " + _d3dDeviceId);
        }

        return r.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Gpu/AmdGpuGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal class AmdGpuGroup : IGroup
{
    private readonly List<AmdGpu> _hardware = new();
    private readonly StringBuilder _report = new();
    private readonly AtiAdlxx.ADLStatus _status;

    public AmdGpuGroup(ISettings settings)
    {
        try
        {
            _status = AtiAdlxx.ADL_Main_Control_Create(1);

            _report.AppendLine("AMD Display Library");
            _report.AppendLine();
            _report.Append("Status: ");
            _report.AppendLine(_status == AtiAdlxx.ADLStatus.ADL_OK ? "OK" : _status.ToString());
            _report.AppendLine();

            if (_status == AtiAdlxx.ADLStatus.ADL_OK)
            {
                int numberOfAdapters = 0;
                AtiAdlxx.ADL_Adapter_NumberOfAdapters_Get(ref numberOfAdapters);

                _report.Append("Number of adapters: ");
                _report.AppendLine(numberOfAdapters.ToString(CultureInfo.InvariantCulture));
                _report.AppendLine();

                if (numberOfAdapters > 0)
                {
                    List<AmdGpu> potentialHardware = new();

                    AtiAdlxx.ADLAdapterInfo[] adapterInfo = new AtiAdlxx.ADLAdapterInfo[numberOfAdapters];
                    if (AtiAdlxx.ADL_Adapter_AdapterInfo_Get(adapterInfo) == AtiAdlxx.ADLStatus.ADL_OK)
                    {
                        for (int i = 0; i < numberOfAdapters; i++)
                        {
                            AtiAdlxx.ADL_Adapter_Active_Get(adapterInfo[i].AdapterIndex, out int isActive);

                            int adapterId = -1;
                            if (AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL_Adapter_ID_Get)))
                                AtiAdlxx.ADL_Adapter_ID_Get(adapterInfo[i].AdapterIndex, out adapterId);

                            _report.Append("AdapterIndex: ");
                            _report.AppendLine(i.ToString(CultureInfo.InvariantCulture));
                            _report.Append("isActive: ");
                            _report.AppendLine(isActive.ToString(CultureInfo.InvariantCulture));
                            _report.Append("AdapterName: ");
                            _report.AppendLine(adapterInfo[i].AdapterName);
                            _report.Append("UDID: ");
                            _report.AppendLine(adapterInfo[i].UDID);
                            _report.Append("PNPString: ");
                            _report.AppendLine(adapterInfo[i].PNPString);
                            _report.Append("Present: ");
                            _report.AppendLine(adapterInfo[i].Present.ToString(CultureInfo.InvariantCulture));
                            _report.Append("VendorID: 0x");
                            _report.AppendLine(adapterInfo[i].VendorID.ToString("X", CultureInfo.InvariantCulture));
                            _report.Append("BusNumber: ");
                            _report.AppendLine(adapterInfo[i].BusNumber.ToString(CultureInfo.InvariantCulture));
                            _report.Append("DeviceNumber: ");
                            _report.AppendLine(adapterInfo[i].DeviceNumber.ToString(CultureInfo.InvariantCulture));
                            _report.Append("FunctionNumber: ");
                            _report.AppendLine(adapterInfo[i].FunctionNumber.ToString(CultureInfo.InvariantCulture));
                            _report.Append("AdapterID: 0x");
                            _report.AppendLine(adapterId.ToString("X", CultureInfo.InvariantCulture));

                            if (!string.IsNullOrEmpty(adapterInfo[i].UDID) && adapterInfo[i].VendorID == AtiAdlxx.ATI_VENDOR_ID)
                                potentialHardware.Add(new AmdGpu(adapterInfo[i], settings));

                            _report.AppendLine();
                        }
                    }

                    foreach (IGrouping<string, AmdGpu> amdGpus in potentialHardware.GroupBy(x => $"{x.BusNumber}-{x.DeviceNumber}"))
                    {
                        AmdGpu amdGpu = amdGpus.OrderByDescending(x => x.Sensors.Length).FirstOrDefault();
                        if (amdGpu != null)
                            _hardware.Add(amdGpu);
                    }
                }
            }
        }
        catch (DllNotFoundException)
        { }
        catch (EntryPointNotFoundException e)
        {
            _report.AppendLine();
            _report.AppendLine(e.ToString());
            _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        return _report.ToString();
    }

    public void Close()
    {
        try
        {
            foreach (AmdGpu gpu in _hardware)
                gpu.Close();

            if (_status == AtiAdlxx.ADLStatus.ADL_OK)
                AtiAdlxx.ADL_Main_Control_Destroy();
        }
        catch (Exception)
        { }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Gpu/GenericGpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Gpu;

public abstract class GenericGpu : Hardware
{
    /// <summary>
    /// Initializes a new instance of the <see cref="GenericGpu" /> class.
    /// </summary>
    /// <param name="name">Component name.</param>
    /// <param name="identifier">Identifier that will be assigned to the device. Based on <see cref="Identifier" /></param>
    /// <param name="settings">Additional settings passed by the <see cref="IComputer" />.</param>
    protected GenericGpu(string name, Identifier identifier, ISettings settings) : base(name, identifier, settings)
    { }

    /// <summary>
    /// Gets the device identifier.
    /// </summary>
    public abstract string DeviceId { get; }
}
```

`LibreHardwareMonitorLib/Hardware/Gpu/IntelGpuGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using LibreHardwareMonitor.Hardware.CPU;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal class IntelGpuGroup : IGroup
{
    private readonly List<Hardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public IntelGpuGroup(List<IntelCpu> intelCpus, ISettings settings)
    {
        if (!Software.OperatingSystem.IsUnix && intelCpus?.Count > 0)
        {
            _report.AppendLine("Intel GPU (D3D)");
            _report.AppendLine();

            string[] ids = D3DDisplayDevice.GetDeviceIdentifiers();

            _report.Append("Number of adapters: ");
            _report.AppendLine(ids.Length.ToString(CultureInfo.InvariantCulture));
            _report.AppendLine();

            for (int i = 0; i < ids.Length; i++)
            {
                string deviceId = ids[i];
                bool isIntel = deviceId.IndexOf("VEN_8086", StringComparison.Ordinal) != -1;

                _report.Append("AdapterIndex: ");
                _report.AppendLine(i.ToString(CultureInfo.InvariantCulture));
                _report.Append("DeviceId: ");
                _report.AppendLine(deviceId);
                _report.Append("IsIntel: ");
                _report.AppendLine(isIntel.ToString(CultureInfo.InvariantCulture));

                if (isIntel && D3DDisplayDevice.GetDeviceInfoByIdentifier(deviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
                {
                    _report.Append("GpuSharedLimit: ");
                    _report.AppendLine(deviceInfo.GpuSharedLimit.ToString(CultureInfo.InvariantCulture));
                    _report.Append("GpuSharedUsed: ");
                    _report.AppendLine(deviceInfo.GpuSharedUsed.ToString(CultureInfo.InvariantCulture));
                    _report.Append("GpuSharedMax: ");
                    _report.AppendLine(deviceInfo.GpuSharedMax.ToString(CultureInfo.InvariantCulture));
                    _report.Append("GpuDedicatedLimit: ");
                    _report.AppendLine(deviceInfo.GpuDedicatedLimit.ToString(CultureInfo.InvariantCulture));
                    _report.Append("GpuDedicatedUsed: ");
                    _report.AppendLine(deviceInfo.GpuDedicatedUsed.ToString(CultureInfo.InvariantCulture));
                    _report.Append("GpuDedicatedMax: ");
                    _report.AppendLine(deviceInfo.GpuDedicatedMax.ToString(CultureInfo.InvariantCulture));
                    _report.Append("Integrated: ");
                    _report.AppendLine(deviceInfo.Integrated.ToString(CultureInfo.InvariantCulture));

                    if (deviceInfo.Integrated)
                    {
                        // It may seem strange to only use the first cpu here, but in-case we have a multi cpu system with integrated graphics (does that exist?),
                        // we would pick up the multiple device identifiers above and would add one instance for each CPU.
                        _hardware.Add(new IntelIntegratedGpu(intelCpus[0], deviceId, deviceInfo, settings));
                    }
                }

                _report.AppendLine();
            }
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        return _report.ToString();
    }

    public void Close()
    {
        foreach (Hardware gpu in _hardware)
            gpu.Close();
    }
}
```

`LibreHardwareMonitorLib/Hardware/Gpu/IntelIntegratedGpu.cs`:

```cs
using System;
using System.Globalization;
using System.Linq;
using Microsoft.Win32;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal class IntelIntegratedGpu : GenericGpu
{
    private const uint MSR_PP1_ENERGY_STATUS = 0x641;
    private const uint MSR_RAPL_POWER_UNIT = 0x606;

    private readonly Sensor _dedicatedMemoryUsage;
    private readonly string _deviceId;
    private readonly float _energyUnitMultiplier;
    private readonly Sensor[] _nodeUsage;
    private readonly DateTime[] _nodeUsagePrevTick;
    private readonly long[] _nodeUsagePrevValue;
    private readonly Sensor _powerSensor;
    private readonly Sensor _sharedMemoryUsage;

    private uint _lastEnergyConsumed;
    private DateTime _lastEnergyTime;

    public IntelIntegratedGpu(CPU.IntelCpu intelCpu, string deviceId, D3DDisplayDevice.D3DDeviceInfo deviceInfo, ISettings settings)
        : base(GetName(deviceId),
               new Identifier("gpu-intel-integrated", deviceId.ToString(CultureInfo.InvariantCulture)),
               settings)
    {
        _deviceId = deviceId;

        int memorySensorIndex = 0;

        if (deviceInfo.GpuDedicatedLimit > 0)
        {
            _dedicatedMemoryUsage = new Sensor("D3D Dedicated Memory Used", memorySensorIndex++, SensorType.SmallData, this, settings);
        }

        _sharedMemoryUsage = new Sensor("D3D Shared Memory Used", memorySensorIndex++, SensorType.SmallData, this, settings);

        if (Ring0.ReadMsr(MSR_RAPL_POWER_UNIT, out uint eax, out uint _))
        {
            _energyUnitMultiplier = intelCpu.EnergyUnitsMultiplier;
            if (_energyUnitMultiplier != 0)
            {
                _lastEnergyTime = DateTime.UtcNow;
                _lastEnergyConsumed = eax;
                _powerSensor = new Sensor("GPU Power", 0, SensorType.Power, this, settings);
                ActivateSensor(_powerSensor);
            }
        }

        _nodeUsage = new Sensor[deviceInfo.Nodes.Length];
        _nodeUsagePrevValue = new long[deviceInfo.Nodes.Length];
        _nodeUsagePrevTick = new DateTime[deviceInfo.Nodes.Length];

        int nodeSensorIndex = 0;
        foreach (D3DDisplayDevice.D3DDeviceNodeInfo node in deviceInfo.Nodes.OrderBy(x => x.Name))
        {
            _nodeUsage[node.Id] = new Sensor(node.Name, nodeSensorIndex++, SensorType.Load, this, settings);
            _nodeUsagePrevValue[node.Id] = node.RunningTime;
            _nodeUsagePrevTick[node.Id] = node.QueryTime;
        }
    }

    /// <inheritdoc />
    public override string DeviceId => D3DDisplayDevice.GetActualDeviceIdentifier(_deviceId);

    public override HardwareType HardwareType => HardwareType.GpuIntel;

    public override void Update()
    {
        if (D3DDisplayDevice.GetDeviceInfoByIdentifier(_deviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
        {
            if (_dedicatedMemoryUsage != null)
            {
                _dedicatedMemoryUsage.Value = 1f * deviceInfo.GpuDedicatedUsed / 1024 / 1024;
                ActivateSensor(_dedicatedMemoryUsage);
            }

            _sharedMemoryUsage.Value = 1f * deviceInfo.GpuSharedUsed / 1024 / 1024;
            ActivateSensor(_sharedMemoryUsage);

            if (_powerSensor != null && Ring0.ReadMsr(MSR_PP1_ENERGY_STATUS, out uint eax, out uint _))
            {
                DateTime time = DateTime.UtcNow;
                uint energyConsumed = eax;
                float deltaTime = (float)(time - _lastEnergyTime).TotalSeconds;
                if (deltaTime >= 0.01)
                {
                    _powerSensor.Value = _energyUnitMultiplier * unchecked(energyConsumed - _lastEnergyConsumed) / deltaTime;
                    _lastEnergyTime = time;
                    _lastEnergyConsumed = energyConsumed;
                }
            }

            foreach (D3DDisplayDevice.D3DDeviceNodeInfo node in deviceInfo.Nodes)
            {
                long runningTimeDiff = node.RunningTime - _nodeUsagePrevValue[node.Id];
                long timeDiff = node.QueryTime.Ticks - _nodeUsagePrevTick[node.Id].Ticks;

                _nodeUsage[node.Id].Value = 100f * runningTimeDiff / timeDiff;
                _nodeUsagePrevValue[node.Id] = node.RunningTime;
                _nodeUsagePrevTick[node.Id] = node.QueryTime;
                ActivateSensor(_nodeUsage[node.Id]);
            }
        }
    }

    private static string GetName(string deviceId)
    {
        string path = @"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\" + D3DDisplayDevice.GetActualDeviceIdentifier(deviceId);

        if (Registry.GetValue(path, "DeviceDesc", null) is string deviceDesc)
        {
            return deviceDesc.Split(';').Last();
        }

        return "Intel Integrated Graphics";
    }
}
```

`LibreHardwareMonitorLib/Hardware/Gpu/NvidiaGpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using LibreHardwareMonitor.Interop;
using Microsoft.Win32;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal sealed class NvidiaGpu : GenericGpu
{
    private readonly int _adapterIndex;
    private readonly Sensor[] _clocks;
    private readonly int _clockVersion;
    private readonly Sensor[] _controls;
    private readonly string _d3dDeviceId;
    private readonly NvApi.NvDisplayHandle? _displayHandle;
    private readonly Control[] _fanControls;
    private readonly Sensor[] _fans;
    private readonly Sensor _gpuDedicatedMemoryUsage;
    private readonly Sensor[] _gpuNodeUsage;
    private readonly DateTime[] _gpuNodeUsagePrevTick;
    private readonly long[] _gpuNodeUsagePrevValue;
    private readonly Sensor _gpuSharedMemoryUsage;
    private readonly NvApi.NvPhysicalGpuHandle _handle;
    private readonly Sensor _hotSpotTemperature;
    private readonly Sensor[] _loads;
    private readonly Sensor _memoryFree;
    private readonly Sensor _memoryJunctionTemperature;
    private readonly Sensor _memoryTotal;
    private readonly Sensor _memoryUsed;
    private readonly Sensor _memoryLoad;
    private readonly NvidiaML.NvmlDevice? _nvmlDevice;
    private readonly Sensor _pcieThroughputRx;
    private readonly Sensor _pcieThroughputTx;
    private readonly Sensor[] _powers;
    private readonly Sensor _powerUsage;
    private readonly Sensor[] _temperatures;
    private readonly uint _thermalSensorsMask;

    public NvidiaGpu(int adapterIndex, NvApi.NvPhysicalGpuHandle handle, NvApi.NvDisplayHandle? displayHandle, ISettings settings)
        : base(GetName(handle),
               new Identifier("gpu-nvidia", adapterIndex.ToString(CultureInfo.InvariantCulture)),
               settings)
    {
        _adapterIndex = adapterIndex;
        _handle = handle;
        _displayHandle = displayHandle;

        bool hasBusId = NvApi.NvAPI_GPU_GetBusId(handle, out uint busId) == NvApi.NvStatus.OK;

        // Thermal settings.
        NvApi.NvThermalSettings thermalSettings = GetThermalSettings(out NvApi.NvStatus status);
        if (status == NvApi.NvStatus.OK && thermalSettings.Count > 0)
        {
            _temperatures = new Sensor[thermalSettings.Count];

            for (int i = 0; i < thermalSettings.Count; i++)
            {
                NvApi.NvSensor sensor = thermalSettings.Sensor[i];

                string name = sensor.Target switch
                {
                    NvApi.NvThermalTarget.Gpu => "GPU Core",
                    NvApi.NvThermalTarget.Memory => "GPU Memory",
                    NvApi.NvThermalTarget.PowerSupply => "GPU Power Supply",
                    NvApi.NvThermalTarget.Board => "GPU Board",
                    NvApi.NvThermalTarget.VisualComputingBoard => "GPU Visual Computing Board",
                    NvApi.NvThermalTarget.VisualComputingInlet => "GPU Visual Computing Inlet",
                    NvApi.NvThermalTarget.VisualComputingOutlet => "GPU Visual Computing Outlet",
                    _ => "GPU"
                };

                _temperatures[i] = new Sensor(name, i, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_temperatures[i]);
            }
        }

        // Thermal sensors.
        _hotSpotTemperature = new Sensor("GPU Hot Spot", (int)thermalSettings.Count + 1, SensorType.Temperature, this, settings);
        _memoryJunctionTemperature = new Sensor("GPU Memory Junction", (int)thermalSettings.Count + 2, SensorType.Temperature, this, settings);
        bool hasAnyThermalSensor = false;

        for (int thermalSensorsMaxBit = 0; thermalSensorsMaxBit < 32; thermalSensorsMaxBit++)
        {
            // Find the maximum thermal sensor mask value.
            _thermalSensorsMask = 1u << thermalSensorsMaxBit;

            GetThermalSensors(_thermalSensorsMask, out NvApi.NvStatus thermalSensorsStatus);
            if (thermalSensorsStatus == NvApi.NvStatus.OK)
            {
                hasAnyThermalSensor = true;
                continue;
            }

            _thermalSensorsMask--;
            break;
        }

        if (!hasAnyThermalSensor)
        {
            _thermalSensorsMask = 0;
        }

        // Clock frequencies.
        for (int clockVersion = 1; clockVersion <= 3; clockVersion++)
        {
            _clockVersion = clockVersion;

            NvApi.NvGpuClockFrequencies clockFrequencies = GetClockFrequencies(out status);
            if (status == NvApi.NvStatus.OK)
            {
                var clocks = new List<Sensor>();
                for (int i = 0; i < clockFrequencies.Clocks.Length; i++)
                {
                    NvApi.NvGpuClockFrequenciesDomain clock = clockFrequencies.Clocks[i];
                    if (clock.IsPresent && Enum.IsDefined(typeof(NvApi.NvGpuPublicClockId), i))
                    {
                        var clockId = (NvApi.NvGpuPublicClockId)i;
                        string name = clockId switch
                        {
                            NvApi.NvGpuPublicClockId.Graphics => "GPU Core",
                            NvApi.NvGpuPublicClockId.Memory => "GPU Memory",
                            NvApi.NvGpuPublicClockId.Processor => "GPU Shader",
                            NvApi.NvGpuPublicClockId.Video => "GPU Video",
                            _ => null
                        };

                        if (name != null)
                            clocks.Add(new Sensor(name, i, SensorType.Clock, this, settings));
                    }
                }

                if (clocks.Count > 0)
                {
                    _clocks = clocks.ToArray();

                    foreach (Sensor sensor in clocks)
                        ActivateSensor(sensor);

                    break;
                }
            }
        }

        // Fans + controllers.
        NvApi.NvFanCoolersStatus fanCoolers = GetFanCoolersStatus(out status);
        if (status == NvApi.NvStatus.OK && fanCoolers.Count > 0)
        {
            _fans = new Sensor[fanCoolers.Count];

            for (int i = 0; i < fanCoolers.Count; i++)
            {
                NvApi.NvFanCoolersStatusItem item = fanCoolers.Items[i];

                string name = "GPU Fan" + (fanCoolers.Count > 1 ? " " + (i + 1) : string.Empty);

                _fans[i] = new Sensor(name, (int)item.CoolerId, SensorType.Fan, this, settings);
                ActivateSensor(_fans[i]);
            }
        }
        else
        {
            GetTachReading(out status);
            if (status == NvApi.NvStatus.OK)
            {
                _fans = new[] { new Sensor("GPU", 1, SensorType.Fan, this, settings) };
                ActivateSensor(_fans[0]);
            }
        }

        NvApi.NvFanCoolerControl fanControllers = GetFanCoolersControllers(out status);
        if (status == NvApi.NvStatus.OK && fanControllers.Count > 0 && fanCoolers.Count > 0)
        {
            _controls = new Sensor[fanControllers.Count];
            _fanControls = new Control[fanControllers.Count];

            for (int i = 0; i < fanControllers.Count; i++)
            {
                NvApi.NvFanCoolerControlItem item = fanControllers.Items[i];

                string name = "GPU Fan" + (fanControllers.Count > 1 ? " " + (i + 1) : string.Empty);

                NvApi.NvFanCoolersStatusItem fanItem = Array.Find(fanCoolers.Items, x => x.CoolerId == item.CoolerId);
                if (!fanItem.Equals(default(NvApi.NvFanCoolersStatusItem)))
                {
                    _controls[i] = new Sensor(name, (int)item.CoolerId, SensorType.Control, this, settings);
                    ActivateSensor(_controls[i]);

                    _fanControls[i] = new Control(_controls[i], settings, fanItem.CurrentMinLevel, fanItem.CurrentMaxLevel);
                    _fanControls[i].ControlModeChanged += ControlModeChanged;
                    _fanControls[i].SoftwareControlValueChanged += SoftwareControlValueChanged;
                    _controls[i].Control = _fanControls[i];

                    ControlModeChanged(_fanControls[i]);
                }
            }
        }
        else
        {
            NvApi.NvCoolerSettings coolerSettings = GetCoolerSettings(out status);
            if (status == NvApi.NvStatus.OK && coolerSettings.Count > 0)
            {
                _controls = new Sensor[coolerSettings.Count];
                _fanControls = new Control[coolerSettings.Count];

                for (int i = 0; i < coolerSettings.Count; i++)
                {
                    NvApi.NvCooler cooler = coolerSettings.Cooler[i];
                    string name = "GPU Fan" + (coolerSettings.Count > 1 ? " " + cooler.Controller : string.Empty);

                    _controls[i] = new Sensor(name, i, SensorType.Control, this, settings);
                    ActivateSensor(_controls[i]);

                    _fanControls[i] = new Control(_controls[i], settings, cooler.DefaultMin, cooler.DefaultMax);
                    _fanControls[i].ControlModeChanged += ControlModeChanged;
                    _fanControls[i].SoftwareControlValueChanged += SoftwareControlValueChanged;
                    _controls[i].Control = _fanControls[i];

                    ControlModeChanged(_fanControls[i]);
                }
            }
        }

        // Load usages.
        NvApi.NvDynamicPStatesInfo pStatesInfo = GetDynamicPstatesInfoEx(out status);
        if (status == NvApi.NvStatus.OK)
        {
            var loads = new List<Sensor>();
            for (int index = 0; index < pStatesInfo.Utilizations.Length; index++)
            {
                NvApi.NvDynamicPState load = pStatesInfo.Utilizations[index];
                if (load.IsPresent && Enum.IsDefined(typeof(NvApi.NvUtilizationDomain), index))
                {
                    var utilizationDomain = (NvApi.NvUtilizationDomain)index;
                    string name = GetUtilizationDomainName(utilizationDomain);

                    if (name != null)
                        loads.Add(new Sensor(name, index, SensorType.Load, this, settings));
                }
            }

            if (loads.Count > 0)
            {
                _loads = loads.ToArray();

                foreach (Sensor sensor in loads)
                    ActivateSensor(sensor);
            }
        }
        else
        {
            NvApi.NvUsages usages = GetUsages(out status);
            if (status == NvApi.NvStatus.OK)
            {
                var loads = new List<Sensor>();
                for (int index = 0; index < usages.Entries.Length; index++)
                {
                    NvApi.NvUsagesEntry load = usages.Entries[index];
                    if (load.IsPresent > 0 && Enum.IsDefined(typeof(NvApi.NvUtilizationDomain), index))
                    {
                        var utilizationDomain = (NvApi.NvUtilizationDomain)index;
                        string name = GetUtilizationDomainName(utilizationDomain);

                        if (name != null)
                            loads.Add(new Sensor(name, index, SensorType.Load, this, settings));
                    }
                }

                if (loads.Count > 0)
                {
                    _loads = loads.ToArray();

                    foreach (Sensor sensor in loads)
                        ActivateSensor(sensor);
                }
            }
        }

        // Power.
        NvApi.NvPowerTopology powerTopology = GetPowerTopology(out NvApi.NvStatus powerStatus);
        if (powerStatus == NvApi.NvStatus.OK && powerTopology.Count > 0)
        {
            _powers = new Sensor[powerTopology.Count];
            for (int i = 0; i < powerTopology.Count; i++)
            {
                NvApi.NvPowerTopologyEntry entry = powerTopology.Entries[i];
                string name = entry.Domain switch
                {
                    NvApi.NvPowerTopologyDomain.Gpu => "GPU Power",
                    NvApi.NvPowerTopologyDomain.Board => "GPU Board Power",
                    _ => null
                };

                if (name != null)
                {
                    _powers[i] = new Sensor(name, i + (_loads?.Length ?? 0), SensorType.Load, this, settings);
                    ActivateSensor(_powers[i]);
                }
            }
        }

        if (NvidiaML.IsAvailable || NvidiaML.Initialize())
        {
            if (hasBusId)
                _nvmlDevice = NvidiaML.NvmlDeviceGetHandleByPciBusId($" 0000:{busId:X2}:00.0") ?? NvidiaML.NvmlDeviceGetHandleByIndex(_adapterIndex);
            else
                _nvmlDevice = NvidiaML.NvmlDeviceGetHandleByIndex(_adapterIndex);

            if (_nvmlDevice.HasValue)
            {
                _powerUsage = new Sensor("GPU Package", 0, SensorType.Power, this, settings);

                _pcieThroughputRx = new Sensor("GPU PCIe Rx", 0, SensorType.Throughput, this, settings);
                _pcieThroughputTx = new Sensor("GPU PCIe Tx", 1, SensorType.Throughput, this, settings);

                if (!Software.OperatingSystem.IsUnix)
                {
                    NvidiaML.NvmlPciInfo? pciInfo = NvidiaML.NvmlDeviceGetPciInfo(_nvmlDevice.Value);

                    if (pciInfo is { } pci)
                    {
                        string[] deviceIds = D3DDisplayDevice.GetDeviceIdentifiers();
                        if (deviceIds != null)
                        {
                            foreach (string deviceId in deviceIds)
                            {
                                if (deviceId.IndexOf("VEN_" + pci.pciVendorId.ToString("X"), StringComparison.OrdinalIgnoreCase) != -1 &&
                                    deviceId.IndexOf("DEV_" + pci.pciDeviceId.ToString("X"), StringComparison.OrdinalIgnoreCase) != -1 &&
                                    deviceId.IndexOf("SUBSYS_" + pci.pciSubSystemId.ToString("X"), StringComparison.OrdinalIgnoreCase) != -1)
                                {
                                    bool isMatch = false;

                                    string actualDeviceId = D3DDisplayDevice.GetActualDeviceIdentifier(deviceId);

                                    try
                                    {
                                        if (Registry.GetValue(@"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\nvlddmkm\Enum", adapterIndex.ToString(), null) is string adapterPnpId)
                                        {
                                            if (actualDeviceId.IndexOf(adapterPnpId, StringComparison.OrdinalIgnoreCase) != -1 ||
                                                adapterPnpId.IndexOf(actualDeviceId, StringComparison.OrdinalIgnoreCase) != -1)
                                            {
                                                isMatch = true;
                                            }
                                        }
                                    }
                                    catch
                                    {
                                        // Ignored.
                                    }

                                    if (!isMatch)
                                    {
                                        try
                                        {
                                            string path = actualDeviceId;
                                            path = @"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\" + path;

                                            if (Registry.GetValue(path, "LocationInformation", null) is string locationInformation)
                                            {
                                                // For example:
                                                // @System32\drivers\pci.sys,#65536;PCI bus %1, device %2, function %3;(38,0,0)

                                                int index = locationInformation.IndexOf('(');
                                                if (index != -1)
                                                {
                                                    index++;
                                                    int secondIndex = locationInformation.IndexOf(',', index);
                                                    if (secondIndex != -1)
                                                    {
                                                        string bus = locationInformation.Substring(index, secondIndex - index);

                                                        if (pci.bus.ToString() == bus)
                                                            isMatch = true;
                                                    }
                                                }
                                            }
                                        }
                                        catch
                                        {
                                            // Ignored.
                                        }
                                    }

                                    if (isMatch && D3DDisplayDevice.GetDeviceInfoByIdentifier(deviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
                                    {
                                        int nodeSensorIndex = (_loads?.Length ?? 0) + (_powers?.Length ?? 0);
                                        int memorySensorIndex = 3; // There are three normal GPU memory sensors.

                                        _d3dDeviceId = deviceId;

                                        _gpuDedicatedMemoryUsage = new Sensor("D3D Dedicated Memory Used", memorySensorIndex++, SensorType.SmallData, this, settings);
                                        _gpuSharedMemoryUsage = new Sensor("D3D Shared Memory Used", memorySensorIndex, SensorType.SmallData, this, settings);

                                        _gpuNodeUsage = new Sensor[deviceInfo.Nodes.Length];
                                        _gpuNodeUsagePrevValue = new long[deviceInfo.Nodes.Length];
                                        _gpuNodeUsagePrevTick = new DateTime[deviceInfo.Nodes.Length];

                                        foreach (D3DDisplayDevice.D3DDeviceNodeInfo node in deviceInfo.Nodes.OrderBy(x => x.Name))
                                        {
                                            _gpuNodeUsage[node.Id] = new Sensor(node.Name, nodeSensorIndex++, SensorType.Load, this, settings);
                                            _gpuNodeUsagePrevValue[node.Id] = node.RunningTime;
                                            _gpuNodeUsagePrevTick[node.Id] = node.QueryTime;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        _memoryFree = new Sensor("GPU Memory Free", 0, SensorType.SmallData, this, settings);
        _memoryUsed = new Sensor("GPU Memory Used", 1, SensorType.SmallData, this, settings);
        _memoryTotal = new Sensor("GPU Memory Total", 2, SensorType.SmallData, this, settings);
        _memoryLoad = new Sensor("GPU Memory", 3, SensorType.Load, this, settings);

        Update();
    }

    /// <inheritdoc />
    public override string DeviceId
    {
        get
        {
            return _d3dDeviceId != null ? D3DDisplayDevice.GetActualDeviceIdentifier(_d3dDeviceId) : null;
        }
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.GpuNvidia; }
    }

    public override void Update()
    {
        if (_d3dDeviceId != null && D3DDisplayDevice.GetDeviceInfoByIdentifier(_d3dDeviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
        {
            _gpuDedicatedMemoryUsage.Value = 1f * deviceInfo.GpuDedicatedUsed / 1024 / 1024;
            _gpuSharedMemoryUsage.Value = 1f * deviceInfo.GpuSharedUsed / 1024 / 1024;
            ActivateSensor(_gpuDedicatedMemoryUsage);
            ActivateSensor(_gpuSharedMemoryUsage);

            foreach (D3DDisplayDevice.D3DDeviceNodeInfo node in deviceInfo.Nodes)
            {
                long runningTimeDiff = node.RunningTime - _gpuNodeUsagePrevValue[node.Id];
                long timeDiff = node.QueryTime.Ticks - _gpuNodeUsagePrevTick[node.Id].Ticks;

                _gpuNodeUsage[node.Id].Value = 100f * runningTimeDiff / timeDiff;
                _gpuNodeUsagePrevValue[node.Id] = node.RunningTime;
                _gpuNodeUsagePrevTick[node.Id] = node.QueryTime;
                ActivateSensor(_gpuNodeUsage[node.Id]);
            }
        }

        NvApi.NvStatus status;

        if (_temperatures is { Length: > 0 })
        {
            NvApi.NvThermalSettings settings = GetThermalSettings(out status);
            // settings.Count is 0 when no valid data available, this happens when you try to read out this value with a high polling interval.
            if (status == NvApi.NvStatus.OK && settings.Count > 0)
            {
                foreach (Sensor sensor in _temperatures)
                    sensor.Value = settings.Sensor[sensor.Index].CurrentTemp;
            }
        }

        if (_thermalSensorsMask > 0)
        {
            NvApi.NvThermalSensors thermalSensors = GetThermalSensors(_thermalSensorsMask, out status);

            if (status == NvApi.NvStatus.OK)
            {
                _hotSpotTemperature.Value = thermalSensors.Temperatures[1] / 256.0f;
                _memoryJunctionTemperature.Value = thermalSensors.Temperatures[9] / 256.0f;
            }

            if (_hotSpotTemperature.Value != 0)
                ActivateSensor(_hotSpotTemperature);

            if (_memoryJunctionTemperature.Value != 0)
                ActivateSensor(_memoryJunctionTemperature);
        }
        else
        {
            _hotSpotTemperature.Value = null;
            _memoryJunctionTemperature.Value = null;
        }

        if (_clocks is { Length: > 0 })
        {
            NvApi.NvGpuClockFrequencies clockFrequencies = GetClockFrequencies(out status);
            if (status == NvApi.NvStatus.OK)
            {
                int current = 0;
                for (int i = 0; i < clockFrequencies.Clocks.Length; i++)
                {
                    NvApi.NvGpuClockFrequenciesDomain clock = clockFrequencies.Clocks[i];
                    if (clock.IsPresent && Enum.IsDefined(typeof(NvApi.NvGpuPublicClockId), i))
                        _clocks[current++].Value = clock.Frequency / 1000f;
                }
            }
        }

        if (_fans is { Length: > 0 })
        {
            NvApi.NvFanCoolersStatus fanCoolers = GetFanCoolersStatus(out status);
            if (status == NvApi.NvStatus.OK && fanCoolers.Count > 0)
            {
                for (int i = 0; i < fanCoolers.Count; i++)
                {
                    NvApi.NvFanCoolersStatusItem item = fanCoolers.Items[i];
                    _fans[i].Value = item.CurrentRpm;
                }
            }
            else
            {
                int tachReading = GetTachReading(out status);
                if (status == NvApi.NvStatus.OK)
                    _fans[0].Value = tachReading;
            }
        }

        if (_controls is { Length: > 0 })
        {
            NvApi.NvFanCoolersStatus fanCoolers = GetFanCoolersStatus(out status);
            if (status == NvApi.NvStatus.OK && fanCoolers.Count > 0 && fanCoolers.Count == _controls.Length)
            {
                for (int i = 0; i < fanCoolers.Count; i++)
                {
                    NvApi.NvFanCoolersStatusItem item = fanCoolers.Items[i];

                    if (Array.Find(_controls, c => c.Index == item.CoolerId) is { } control)
                        control.Value = item.CurrentLevel;
                }
            }
            else
            {
                NvApi.NvCoolerSettings coolerSettings = GetCoolerSettings(out status);
                if (status == NvApi.NvStatus.OK && coolerSettings.Count > 0)
                {
                    for (int i = 0; i < coolerSettings.Count; i++)
                    {
                        NvApi.NvCooler cooler = coolerSettings.Cooler[i];
                        _controls[i].Value = cooler.CurrentLevel;
                    }
                }
            }
        }

        if (_loads is { Length: > 0 })
        {
            NvApi.NvDynamicPStatesInfo pStatesInfo = GetDynamicPstatesInfoEx(out status);
            if (status == NvApi.NvStatus.OK)
            {
                for (int index = 0; index < pStatesInfo.Utilizations.Length; index++)
                {
                    NvApi.NvDynamicPState load = pStatesInfo.Utilizations[index];
                    if (load.IsPresent && Enum.IsDefined(typeof(NvApi.NvUtilizationDomain), index))
                        _loads[index].Value = load.Percentage;
                }
            }
            else
            {
                NvApi.NvUsages usages = GetUsages(out status);
                if (status == NvApi.NvStatus.OK)
                {
                    for (int index = 0; index < usages.Entries.Length; index++)
                    {
                        NvApi.NvUsagesEntry load = usages.Entries[index];
                        if (load.IsPresent > 0 && Enum.IsDefined(typeof(NvApi.NvUtilizationDomain), index))
                            _loads[index].Value = load.Percentage;
                    }
                }
            }
        }

        if (_powers is { Length: > 0 })
        {
            NvApi.NvPowerTopology powerTopology = GetPowerTopology(out status);
            if (status == NvApi.NvStatus.OK && powerTopology.Count > 0)
            {
                for (int i = 0; i < powerTopology.Count; i++)
                {
                    NvApi.NvPowerTopologyEntry entry = powerTopology.Entries[i];
                    _powers[i].Value = entry.PowerUsage / 1000f;
                }
            }
        }

        if (_displayHandle != null)
        {
            NvApi.NvMemoryInfo memoryInfo = GetMemoryInfo(out status);
            if (status == NvApi.NvStatus.OK)
            {
                uint free = memoryInfo.CurrentAvailableDedicatedVideoMemory;
                uint total = memoryInfo.DedicatedVideoMemory;

                _memoryTotal.Value = total / 1024;
                ActivateSensor(_memoryTotal);

                _memoryFree.Value = free / 1024;
                ActivateSensor(_memoryFree);

                _memoryUsed.Value = (total - free) / 1024;
                ActivateSensor(_memoryUsed);

                _memoryLoad.Value = ((float)(total - free) / total) * 100;
                ActivateSensor(_memoryLoad);
            }
        }

        if (NvidiaML.IsAvailable && _nvmlDevice.HasValue)
        {
            int? result = NvidiaML.NvmlDeviceGetPowerUsage(_nvmlDevice.Value);
            if (result.HasValue)
            {
                _powerUsage.Value = result.Value / 1000f;
                ActivateSensor(_powerUsage);
            }

            // In MB/s, throughput sensors are passed as in KB/s.
            uint? rx = NvidiaML.NvmlDeviceGetPcieThroughput(_nvmlDevice.Value, NvidiaML.NvmlPcieUtilCounter.RxBytes);
            if (rx.HasValue)
            {
                _pcieThroughputRx.Value = rx * 1024;
                ActivateSensor(_pcieThroughputRx);
            }

            uint? tx = NvidiaML.NvmlDeviceGetPcieThroughput(_nvmlDevice.Value, NvidiaML.NvmlPcieUtilCounter.TxBytes);
            if (tx.HasValue)
            {
                _pcieThroughputTx.Value = tx * 1024;
                ActivateSensor(_pcieThroughputTx);
            }
        }
    }

    public override string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("Nvidia GPU");
        r.AppendLine();
        r.AppendFormat("Name: {0}{1}", _name, Environment.NewLine);
        r.AppendFormat("Index: {0}{1}", _adapterIndex, Environment.NewLine);

        if (_displayHandle.HasValue && NvApi.NvAPI_GetDisplayDriverVersion != null)
        {
            NvApi.NvDisplayDriverVersion driverVersion = new() { Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvDisplayDriverVersion>(1) };
            if (NvApi.NvAPI_GetDisplayDriverVersion(_displayHandle.Value, ref driverVersion) == NvApi.NvStatus.OK)
            {
                r.Append("Driver Version: ");
                r.Append(driverVersion.DriverVersion / 100);
                r.Append(".");
                r.Append((driverVersion.DriverVersion % 100).ToString("00", CultureInfo.InvariantCulture));
                r.AppendLine();
                r.Append("Driver Branch: ");
                r.AppendLine(driverVersion.BuildBranch);
            }
        }

        if (NvApi.NvAPI_GPU_GetPCIIdentifiers != null)
        {
            NvApi.NvStatus status = NvApi.NvAPI_GPU_GetPCIIdentifiers(_handle, out uint deviceId, out uint subSystemId, out uint revisionId, out uint extDeviceId);
            if (status == NvApi.NvStatus.OK)
            {
                r.Append("DeviceID: 0x");
                r.AppendLine(deviceId.ToString("X", CultureInfo.InvariantCulture));
                r.Append("SubSystemID: 0x");
                r.AppendLine(subSystemId.ToString("X", CultureInfo.InvariantCulture));
                r.Append("RevisionID: 0x");
                r.AppendLine(revisionId.ToString("X", CultureInfo.InvariantCulture));
                r.Append("ExtDeviceID: 0x");
                r.AppendLine(extDeviceId.ToString("X", CultureInfo.InvariantCulture));
                r.AppendLine();
            }
        }

        if (NvApi.NvAPI_GPU_GetThermalSettings != null)
        {
            NvApi.NvThermalSettings thermalSettings = GetThermalSettings(out NvApi.NvStatus status);

            r.AppendLine("Thermal Settings");
            r.AppendLine();

            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < thermalSettings.Count; i++)
                {
                    r.AppendFormat(" Sensor[{0}].Controller: {1}{2}", i, thermalSettings.Sensor[i].Controller, Environment.NewLine);
                    r.AppendFormat(" Sensor[{0}].DefaultMinTemp: {1}{2}", i, thermalSettings.Sensor[i].DefaultMinTemp, Environment.NewLine);
                    r.AppendFormat(" Sensor[{0}].DefaultMaxTemp: {1}{2}", i, thermalSettings.Sensor[i].DefaultMaxTemp, Environment.NewLine);
                    r.AppendFormat(" Sensor[{0}].CurrentTemp: {1}{2}", i, thermalSettings.Sensor[i].CurrentTemp, Environment.NewLine);
                    r.AppendFormat(" Sensor[{0}].Target: {1}{2}", i, thermalSettings.Sensor[i].Target, Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_GetAllClocks != null)
        {
            NvApi.NvGpuClockFrequencies clocks = GetClockFrequencies(out NvApi.NvStatus status);

            r.AppendLine("Clocks");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < clocks.Clocks.Length; i++)
                {
                    if (clocks.Clocks[i].IsPresent)
                        r.AppendFormat(" Clock[{0}]: {1}{2}", i, clocks.Clocks[i].Frequency, Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_GetTachReading != null)
        {
            NvApi.NvStatus status = NvApi.NvAPI_GPU_GetTachReading(_handle, out int tachValue);

            r.AppendLine("Tachometer");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                r.AppendFormat(" Value: {0}{1}", tachValue, Environment.NewLine);
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_GetDynamicPstatesInfoEx != null)
        {
            NvApi.NvDynamicPStatesInfo pStatesInfo = GetDynamicPstatesInfoEx(out NvApi.NvStatus status);

            r.AppendLine("P-States");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < pStatesInfo.Utilizations.Length; i++)
                {
                    if (pStatesInfo.Utilizations[i].IsPresent)
                        r.AppendFormat(" Percentage[{0}]: {1}{2}", i, pStatesInfo.Utilizations[i].Percentage, Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_GetUsages != null)
        {
            NvApi.NvUsages usages = GetUsages(out NvApi.NvStatus status);

            r.AppendLine("Usages");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < usages.Entries.Length; i++)
                {
                    if (usages.Entries[i].IsPresent > 0)
                        r.AppendFormat(" Usage[{0}]: {1}{2}", i, usages.Entries[i].Percentage, Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_GetCoolerSettings != null)
        {
            NvApi.NvCoolerSettings coolerSettings = GetCoolerSettings(out NvApi.NvStatus status);
            r.AppendLine("Cooler Settings");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < coolerSettings.Count; i++)
                {
                    r.AppendFormat(" Cooler[{0}].Type: {1}{2}", i, coolerSettings.Cooler[i].Type, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].Controller: {1}{2}", i, coolerSettings.Cooler[i].Controller, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].DefaultMin: {1}{2}", i, coolerSettings.Cooler[i].DefaultMin, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].DefaultMax: {1}{2}", i, coolerSettings.Cooler[i].DefaultMax, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].CurrentMin: {1}{2}", i, coolerSettings.Cooler[i].CurrentMin, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].CurrentMax: {1}{2}", i, coolerSettings.Cooler[i].CurrentMax, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].CurrentLevel: {1}{2}", i, coolerSettings.Cooler[i].CurrentLevel, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].DefaultPolicy: {1}{2}", i, coolerSettings.Cooler[i].DefaultPolicy, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].CurrentPolicy: {1}{2}", i, coolerSettings.Cooler[i].CurrentPolicy, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].Target: {1}{2}", i, coolerSettings.Cooler[i].Target, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].ControlType: {1}{2}", i, coolerSettings.Cooler[i].ControlType, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].Active: {1}{2}", i, coolerSettings.Cooler[i].Active, Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_ClientFanCoolersGetStatus != null)
        {
            NvApi.NvFanCoolersStatus coolers = GetFanCoolersStatus(out NvApi.NvStatus status);

            r.AppendLine("Fan Coolers Status");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < coolers.Count; i++)
                {
                    r.AppendFormat(" Items[{0}].CoolerId: {1}{2}",
                                   i,
                                   coolers.Items[i].CoolerId,
                                   Environment.NewLine);

                    r.AppendFormat(" Items[{0}].CurrentRpm: {1}{2}",
                                   i,
                                   coolers.Items[i].CurrentRpm,
                                   Environment.NewLine);

                    r.AppendFormat(" Items[{0}].CurrentMinLevel: {1}{2}",
                                   i,
                                   coolers.Items[i].CurrentMinLevel,
                                   Environment.NewLine);

                    r.AppendFormat(" Items[{0}].CurrentMaxLevel: {1}{2}",
                                   i,
                                   coolers.Items[i].CurrentMaxLevel,
                                   Environment.NewLine);

                    r.AppendFormat(" Items[{0}].CurrentLevel: {1}{2}",
                                   i,
                                   coolers.Items[i].CurrentLevel,
                                   Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_ClientPowerTopologyGetStatus != null)
        {
            NvApi.NvPowerTopology powerTopology = GetPowerTopology(out NvApi.NvStatus status);

            r.AppendLine("Power Topology");
            r.AppendLine();

            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < powerTopology.Count; i++)
                {
                    NvApi.NvPowerTopologyEntry entry = powerTopology.Entries[i];
                    _powers[i].Value = entry.PowerUsage / 1000f;

                    r.AppendFormat(" Entries[{0}].Domain: {1}{2}", i, entry.Domain, Environment.NewLine);
                    r.AppendFormat(" Entries[{0}].PowerUsage: {1}{2}", i, entry.PowerUsage, Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_GetMemoryInfo != null)
        {
            NvApi.NvMemoryInfo memoryInfo = GetMemoryInfo(out NvApi.NvStatus status);

            r.AppendLine("Memory Info");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                r.AppendFormat(" AvailableDedicatedVideoMemory: {0}{1}", memoryInfo.AvailableDedicatedVideoMemory, Environment.NewLine);
                r.AppendFormat(" DedicatedVideoMemory: {0}{1}", memoryInfo.DedicatedVideoMemory, Environment.NewLine);
                r.AppendFormat(" CurrentAvailableDedicatedVideoMemory: {0}{1}", memoryInfo.CurrentAvailableDedicatedVideoMemory, Environment.NewLine);
                r.AppendFormat(" SharedSystemMemory: {0}{1}", memoryInfo.SharedSystemMemory, Environment.NewLine);
                r.AppendFormat(" SystemVideoMemory: {0}{1}", memoryInfo.SystemVideoMemory, Environment.NewLine);
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (_d3dDeviceId != null)
        {
            r.AppendLine("D3D");
            r.AppendLine();
            r.AppendLine(" Id: " + _d3dDeviceId);

            r.AppendLine();
        }

        return r.ToString();
    }

    private static string GetName(NvApi.NvPhysicalGpuHandle handle)
    {
        if (NvApi.NvAPI_GPU_GetFullName(handle, out string gpuName) == NvApi.NvStatus.OK)
        {
            string name = gpuName.Trim();
            return name.StartsWith("NVIDIA", StringComparison.OrdinalIgnoreCase) ? name : "NVIDIA " + name;
        }

        return "NVIDIA";
    }

    private NvApi.NvMemoryInfo GetMemoryInfo(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetMemoryInfo == null || _displayHandle == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvMemoryInfo memoryInfo = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvMemoryInfo>(2)
        };

        status = NvApi.NvAPI_GPU_GetMemoryInfo(_displayHandle.Value, ref memoryInfo);
        return status == NvApi.NvStatus.OK ? memoryInfo : default;
    }

    private NvApi.NvGpuClockFrequencies GetClockFrequencies(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetAllClockFrequencies == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvGpuClockFrequencies clockFrequencies = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvGpuClockFrequencies>(_clockVersion)
        };

        status = NvApi.NvAPI_GPU_GetAllClockFrequencies(_handle, ref clockFrequencies);
        return status == NvApi.NvStatus.OK ? clockFrequencies : default;
    }

    private NvApi.NvThermalSettings GetThermalSettings(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetThermalSettings == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvThermalSettings settings = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvThermalSettings>(1),
            Count = NvApi.MAX_THERMAL_SENSORS_PER_GPU
        };

        status = NvApi.NvAPI_GPU_GetThermalSettings(_handle, (int)NvApi.NvThermalTarget.All, ref settings);
        return status == NvApi.NvStatus.OK ? settings : default;
    }

    private NvApi.NvThermalSensors GetThermalSensors(uint mask, out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_ThermalGetSensors == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        var thermalSensors = new NvApi.NvThermalSensors
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvThermalSensors>(2),
            Mask = mask
        };

        status = NvApi.NvAPI_GPU_ThermalGetSensors(_handle, ref thermalSensors);
        return status == NvApi.NvStatus.OK ? thermalSensors : default;
    }

    private NvApi.NvFanCoolersStatus GetFanCoolersStatus(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_ClientFanCoolersGetStatus == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        var coolers = new NvApi.NvFanCoolersStatus
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvFanCoolersStatus>(1),
            Items = new NvApi.NvFanCoolersStatusItem[NvApi.MAX_FAN_COOLERS_STATUS_ITEMS]
        };

        status = NvApi.NvAPI_GPU_ClientFanCoolersGetStatus(_handle, ref coolers);
        return status == NvApi.NvStatus.OK ? coolers : default;
    }

    private NvApi.NvFanCoolerControl GetFanCoolersControllers(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_ClientFanCoolersGetControl == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        var controllers = new NvApi.NvFanCoolerControl
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvFanCoolerControl>(1)
        };

        status = NvApi.NvAPI_GPU_ClientFanCoolersGetControl(_handle, ref controllers);
        return status == NvApi.NvStatus.OK ? controllers : default;
    }

    private NvApi.NvCoolerSettings GetCoolerSettings(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetCoolerSettings == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvCoolerSettings settings = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvCoolerSettings>(2),
            Cooler = new NvApi.NvCooler[NvApi.MAX_COOLERS_PER_GPU]
        };

        status = NvApi.NvAPI_GPU_GetCoolerSettings(_handle, NvApi.NvCoolerTarget.All, ref settings);
        return status == NvApi.NvStatus.OK ? settings : default;
    }

    private NvApi.NvDynamicPStatesInfo GetDynamicPstatesInfoEx(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetDynamicPstatesInfoEx == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvDynamicPStatesInfo pStatesInfo = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvDynamicPStatesInfo>(1),
            Utilizations = new NvApi.NvDynamicPState[NvApi.MAX_GPU_UTILIZATIONS]
        };

        status = NvApi.NvAPI_GPU_GetDynamicPstatesInfoEx(_handle, ref pStatesInfo);
        return status == NvApi.NvStatus.OK ? pStatesInfo : default;
    }

    private NvApi.NvUsages GetUsages(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetUsages == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvUsages usages = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvUsages>(1)
        };

        status = NvApi.NvAPI_GPU_GetUsages(_handle, ref usages);
        return status == NvApi.NvStatus.OK ? usages : default;
    }

    private NvApi.NvPowerTopology GetPowerTopology(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_ClientPowerTopologyGetStatus == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvPowerTopology powerTopology = new()
        {
            Version = NvApi.MAKE_NVAPI_VERSION<NvApi.NvPowerTopology>(1)
        };

        status = NvApi.NvAPI_GPU_ClientPowerTopologyGetStatus(_handle, ref powerTopology);
        return status == NvApi.NvStatus.OK ? powerTopology : default;
    }

    private int GetTachReading(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetTachReading == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        status = NvApi.NvAPI_GPU_GetTachReading(_handle, out int value);
        return value;
    }

    private static string GetUtilizationDomainName(NvApi.NvUtilizationDomain utilizationDomain) => utilizationDomain switch
    {
        NvApi.NvUtilizationDomain.Gpu => "GPU Core",
        NvApi.NvUtilizationDomain.FrameBuffer => "GPU Memory Controller",
        NvApi.NvUtilizationDomain.VideoEngine => "GPU Video Engine",
        NvApi.NvUtilizationDomain.BusInterface => "GPU Bus",
        _ => null
    };

    private void ControlModeChanged(IControl control)
    {
        switch (control.ControlMode)
        {
            case ControlMode.Default:
                RestoreDefaultFanBehavior(control.Sensor.Index);
                break;
            case ControlMode.Software:
                SoftwareControlValueChanged(control);
                break;
        }
    }

    private void SoftwareControlValueChanged(IControl control)
    {
        int index = control.Sensor?.Index ?? 0;

        NvApi.NvCoolerLevels coolerLevels = new() { Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvCoolerLevels>(1), Levels = new NvApi.NvLevel[NvApi.MAX_COOLERS_PER_GPU] };
        coolerLevels.Levels[0].Level = (int)control.SoftwareValue;
        coolerLevels.Levels[0].Policy = NvApi.NvLevelPolicy.Manual;
        if (NvApi.NvAPI_GPU_SetCoolerLevels(_handle, index, ref coolerLevels) == NvApi.NvStatus.OK)
            return;

        NvApi.NvFanCoolerControl fanCoolersControllers = GetFanCoolersControllers(out _);

        for (int i = 0; i < fanCoolersControllers.Count; i++)
        {
            NvApi.NvFanCoolerControlItem nvFanCoolerControlItem = fanCoolersControllers.Items[i];
            if (nvFanCoolerControlItem.CoolerId == index)
            {
                nvFanCoolerControlItem.ControlMode = NvApi.NvFanControlMode.Manual;
                nvFanCoolerControlItem.Level = (uint)control.SoftwareValue;

                fanCoolersControllers.Items[i] = nvFanCoolerControlItem;
            }
        }

        NvApi.NvAPI_GPU_ClientFanCoolersSetControl(_handle, ref fanCoolersControllers);
    }

    private void RestoreDefaultFanBehavior(int index)
    {
        NvApi.NvCoolerLevels coolerLevels = new() { Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvCoolerLevels>(1), Levels = new NvApi.NvLevel[NvApi.MAX_COOLERS_PER_GPU] };
        coolerLevels.Levels[0].Policy = NvApi.NvLevelPolicy.Auto;
        if (NvApi.NvAPI_GPU_SetCoolerLevels(_handle, index, ref coolerLevels) == NvApi.NvStatus.OK)
            return;

        NvApi.NvFanCoolerControl fanCoolersControllers = GetFanCoolersControllers(out _);

        for (int i = 0; i < fanCoolersControllers.Count; i++)
        {
            NvApi.NvFanCoolerControlItem nvFanCoolerControlItem = fanCoolersControllers.Items[i];
            if (nvFanCoolerControlItem.CoolerId == index)
            {
                nvFanCoolerControlItem.ControlMode = NvApi.NvFanControlMode.Auto;
                nvFanCoolerControlItem.Level = 0;

                fanCoolersControllers.Items[i] = nvFanCoolerControlItem;
            }
        }

        NvApi.NvAPI_GPU_ClientFanCoolersSetControl(_handle, ref fanCoolersControllers);
    }

    public override void Close()
    {
        if (_fanControls != null)
        {
            for (int i = 0; i < _fanControls.Length; i++)
            {
                _fanControls[i].ControlModeChanged -= ControlModeChanged;
                _fanControls[i].SoftwareControlValueChanged -= SoftwareControlValueChanged;

                if (_fanControls[i].ControlMode != ControlMode.Undefined)
                    RestoreDefaultFanBehavior(i);
            }
        }

        base.Close();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Gpu/NvidiaGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Globalization;
using System.Text;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal class NvidiaGroup : IGroup
{
    private readonly List<Hardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public NvidiaGroup(ISettings settings)
    {
        if (!NvApi.IsAvailable)
            return;

        _report.AppendLine("NvApi");
        _report.AppendLine();

        if (NvApi.NvAPI_GetInterfaceVersionString(out string version) == NvApi.NvStatus.OK)
        {
            _report.Append("Version: ");
            _report.AppendLine(version);
        }

        NvApi.NvPhysicalGpuHandle[] handles = new NvApi.NvPhysicalGpuHandle[NvApi.MAX_PHYSICAL_GPUS];
        if (NvApi.NvAPI_EnumPhysicalGPUs == null)
        {
            _report.AppendLine("Error: NvAPI_EnumPhysicalGPUs not available");
            _report.AppendLine();
            return;
        }

        NvApi.NvStatus status = NvApi.NvAPI_EnumPhysicalGPUs(handles, out int count);
        if (status != NvApi.NvStatus.OK)
        {
            _report.AppendLine("Status: " + status);
            _report.AppendLine();
            return;
        }

        IDictionary<NvApi.NvPhysicalGpuHandle, NvApi.NvDisplayHandle> displayHandles = new Dictionary<NvApi.NvPhysicalGpuHandle, NvApi.NvDisplayHandle>();
        if (NvApi.NvAPI_EnumNvidiaDisplayHandle != null && NvApi.NvAPI_GetPhysicalGPUsFromDisplay != null)
        {
            status = NvApi.NvStatus.OK;
            int i = 0;
            while (status == NvApi.NvStatus.OK)
            {
                NvApi.NvDisplayHandle displayHandle = new();
                status = NvApi.NvAPI_EnumNvidiaDisplayHandle(i, ref displayHandle);
                i++;

                if (status == NvApi.NvStatus.OK)
                {
                    NvApi.NvPhysicalGpuHandle[] handlesFromDisplay = new NvApi.NvPhysicalGpuHandle[NvApi.MAX_PHYSICAL_GPUS];
                    if (NvApi.NvAPI_GetPhysicalGPUsFromDisplay(displayHandle, handlesFromDisplay, out uint countFromDisplay) == NvApi.NvStatus.OK)
                    {
                        for (int j = 0; j < countFromDisplay; j++)
                        {
                            if (!displayHandles.ContainsKey(handlesFromDisplay[j]))
                                displayHandles.Add(handlesFromDisplay[j], displayHandle);
                        }
                    }
                }
            }
        }

        _report.Append("Number of GPUs: ");
        _report.AppendLine(count.ToString(CultureInfo.InvariantCulture));

        for (int i = 0; i < count; i++)
        {
            displayHandles.TryGetValue(handles[i], out NvApi.NvDisplayHandle displayHandle);
            _hardware.Add(new NvidiaGpu(i, handles[i], displayHandle, settings));
        }

        _report.AppendLine();
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        return _report.ToString();
    }

    public void Close()
    {
        foreach (Hardware gpu in _hardware)
            gpu.Close();

        NvidiaML.Close();
    }
}
```

`LibreHardwareMonitorLib/Hardware/GroupAffinity.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// This structure describes a group-specific affinity.
/// </summary>
public readonly struct GroupAffinity
{
    public static GroupAffinity Undefined = new(ushort.MaxValue, 0);

    /// <summary>
    /// Initializes a new instance of the <see cref="GroupAffinity" /> struct.
    /// </summary>
    /// <param name="group">The group.</param>
    /// <param name="mask">The mask.</param>
    public GroupAffinity(ushort group, ulong mask)
    {
        Group = group;
        Mask = mask;
    }

    /// <summary>
    /// Gets a single group affinity.
    /// </summary>
    /// <param name="group">The group.</param>
    /// <param name="index">The index.</param>
    /// <returns><see cref="GroupAffinity" />.</returns>
    public static GroupAffinity Single(ushort group, int index)
    {
        return new GroupAffinity(group, 1UL << index);
    }

    /// <summary>
    /// Gets the group.
    /// </summary>
    public ushort Group { get; }

    /// <summary>
    /// Gets the mask.
    /// </summary>
    public ulong Mask { get; }

    /// <summary>
    /// Determines whether the specified <see cref="System.Object" /> is equal to this instance.
    /// </summary>
    /// <param name="o">The <see cref="System.Object" /> to compare with this instance.</param>
    /// <returns><c>true</c> if the specified <see cref="System.Object" /> is equal to this instance; otherwise, <c>false</c>.</returns>
    public override bool Equals(object o)
    {
        if (o == null || GetType() != o.GetType())
            return false;

        GroupAffinity a = (GroupAffinity)o;
        return (Group == a.Group) && (Mask == a.Mask);
    }

    /// <summary>
    /// Returns a hash code for this instance.
    /// </summary>
    /// <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
    public override int GetHashCode()
    {
        return Group.GetHashCode() ^ Mask.GetHashCode();
    }

    /// <summary>
    /// Implements the == operator.
    /// </summary>
    /// <param name="a1">The a1.</param>
    /// <param name="a2">The a2.</param>
    /// <returns>The result of the operator.</returns>
    public static bool operator ==(GroupAffinity a1, GroupAffinity a2)
    {
        return (a1.Group == a2.Group) && (a1.Mask == a2.Mask);
    }

    /// <summary>
    /// Implements the != operator.
    /// </summary>
    /// <param name="a1">The a1.</param>
    /// <param name="a2">The a2.</param>
    /// <returns>The result of the operator.</returns>
    public static bool operator !=(GroupAffinity a1, GroupAffinity a2)
    {
        return (a1.Group != a2.Group) || (a1.Mask != a2.Mask);
    }
}
```

`LibreHardwareMonitorLib/Hardware/Hardware.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Linq;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Object representing a component of the computer.
/// <para>
/// Individual information can be read from the <see cref="Sensors"/>.
/// </para>
/// </summary>
public abstract class Hardware : IHardware
{
    protected readonly HashSet<ISensor> _active = new();
    protected readonly string _name;
    protected readonly ISettings _settings;
    private string _customName;

    /// <summary>
    /// Creates a new <see cref="Hardware"/> instance based on the data provided.
    /// </summary>
    /// <param name="name">Component name.</param>
    /// <param name="identifier">Identifier that will be assigned to the device. Based on <see cref="Identifier"/></param>
    /// <param name="settings">Additional settings passed by the <see cref="IComputer"/>.</param>
    protected Hardware(string name, Identifier identifier, ISettings settings)
    {
        _settings = settings;
        _name = name;
        Identifier = identifier;
        _customName = settings.GetValue(new Identifier(Identifier, "name").ToString(), name);
    }

    /// <summary>
    /// Event triggered when <see cref="Hardware"/> is closing.
    /// </summary>
    public event HardwareEventHandler Closing;

    /// <inheritdoc />
    public abstract HardwareType HardwareType { get; }

    /// <inheritdoc />
    public Identifier Identifier { get; }

    /// <inheritdoc />
    public string Name
    {
        get { return _customName; }
        set
        {
            _customName = !string.IsNullOrEmpty(value) ? value : _name;

            _settings.SetValue(new Identifier(Identifier, "name").ToString(), _customName);
        }
    }

    /// <inheritdoc />
    public virtual IHardware Parent
    {
        get { return null; }
    }

    /// <inheritdoc />
    public virtual IDictionary<string, string> Properties => new SortedDictionary<string, string>();

    /// <inheritdoc />
    public virtual ISensor[] Sensors
    {
        get { return _active.ToArray(); }
    }

    /// <inheritdoc />
    public IHardware[] SubHardware
    {
        get { return Array.Empty<IHardware>(); }
    }

    /// <inheritdoc />
    public virtual string GetReport()
    {
        return null;
    }

    /// <inheritdoc />
    public abstract void Update();

    /// <inheritdoc />
    public void Accept(IVisitor visitor)
    {
        if (visitor == null)
            throw new ArgumentNullException(nameof(visitor));

        visitor.VisitHardware(this);
    }

    /// <inheritdoc />
    public virtual void Traverse(IVisitor visitor)
    {
        foreach (ISensor sensor in _active)
            sensor.Accept(visitor);
    }

    /// <inheritdoc />
    protected virtual void ActivateSensor(ISensor sensor)
    {
        if (_active.Add(sensor))
            SensorAdded?.Invoke(sensor);
    }

    /// <inheritdoc />
    protected virtual void DeactivateSensor(ISensor sensor)
    {
        if (_active.Remove(sensor))
            SensorRemoved?.Invoke(sensor);
    }

    /// <inheritdoc />
    public virtual void Close()
    {
        Closing?.Invoke(this);
    }

#pragma warning disable 67
    public event SensorEventHandler SensorAdded;

    public event SensorEventHandler SensorRemoved;
#pragma warning restore 67
}
```

`LibreHardwareMonitorLib/Hardware/HardwareType.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Collection of identifiers representing the purpose of the hardware.
/// </summary>
public enum HardwareType
{
    Motherboard,
    SuperIO,
    Cpu,
    Memory,
    GpuNvidia,
    GpuAmd,
    GpuIntel,
    Storage,
    Network,
    Cooler,
    EmbeddedController,
    Psu,
    Battery
}
```

`LibreHardwareMonitorLib/Hardware/IComputer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Handler that will trigger the actions assigned to it when the event occurs.
/// </summary>
/// <param name="hardware">Component returned to the assigned action(s).</param>
public delegate void HardwareEventHandler(IHardware hardware);

/// <summary>
/// Basic abstract with methods for the class which can store all hardware and decides which devices are to be checked and updated.
/// </summary>
public interface IComputer : IElement
{
    /// <summary>
    /// Triggered when a new <see cref="IHardware" /> is registered.
    /// </summary>
    event HardwareEventHandler HardwareAdded;

    /// <summary>
    /// Triggered when a <see cref="IHardware" /> is removed.
    /// </summary>
    event HardwareEventHandler HardwareRemoved;

    /// <summary>
    /// Gets a list of all known <see cref="IHardware" />.
    /// <para>Can be updated by <see cref="IVisitor" />.</para>
    /// </summary>
    /// <returns>List of all enabled devices.</returns>
    IList<IHardware> Hardware { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Battery" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsBatteryEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about:
    /// <list>
    ///     <item>
    ///         <see cref="Controller.TBalancer.TBalancerGroup" />
    ///     </item>
    ///     <item>
    ///         <see cref="Controller.Heatmaster.HeatmasterGroup" />
    ///     </item>
    ///     <item>
    ///         <see cref="Controller.AquaComputer.AquaComputerGroup" />
    ///     </item>
    ///     <item>
    ///         <see cref="Controller.AeroCool.AeroCoolGroup" />
    ///     </item>
    ///     <item>
    ///         <see cref="Controller.Nzxt.NzxtGroup" />
    ///     </item>
    /// </list>
    /// devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsControllerEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Cpu" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsCpuEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.GpuAmd" /> or <see cref="HardwareType.GpuNvidia" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsGpuEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Memory" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsMemoryEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Motherboard" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsMotherboardEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Network" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsNetworkEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Psu" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsPsuEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Storage" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsStorageEnabled { get; }

    /// <summary>
    /// Generates full LibreHardwareMonitor report for devices that have been enabled.
    /// </summary>
    /// <returns>A formatted text string with library, OS and hardware information.</returns>
    string GetReport();
}
```

`LibreHardwareMonitorLib/Hardware/IControl.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

public enum ControlMode
{
    Undefined,
    Software,
    Default
}

public interface IControl
{
    ControlMode ControlMode { get; }

    Identifier Identifier { get; }

    float MaxSoftwareValue { get; }

    float MinSoftwareValue { get; }

    ISensor Sensor { get; }

    float SoftwareValue { get; }

    void SetDefault();

    void SetSoftware(float value);
}
```

`LibreHardwareMonitorLib/Hardware/IElement.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Abstract parent with logic for the abstract class that stores data.
/// </summary>
public interface IElement
{
    /// <summary>
    /// Accepts the observer for this instance.
    /// </summary>
    /// <param name="visitor">Computer observer making the calls.</param>
    void Accept(IVisitor visitor);

    /// <summary>
    /// Call the <see cref="Accept"/> method for all child instances <c>(called only from visitors).</c>
    /// </summary>
    /// <param name="visitor">Computer observer making the calls.</param>
    void Traverse(IVisitor visitor);
}
```

`LibreHardwareMonitorLib/Hardware/IGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// A group of devices from one category in one list.
/// </summary>
internal interface IGroup
{
    /// <summary>
    /// Gets a list that stores information about <see cref="IHardware"/> in a given group.
    /// </summary>
    IReadOnlyList<IHardware> Hardware { get; }

    /// <summary>
    /// Report containing most of the known information about all <see cref="IHardware"/> in this <see cref="IGroup"/>.
    /// </summary>
    /// <returns>A formatted text string with hardware information.</returns>
    string GetReport();

    /// <summary>
    /// Stop updating this group in the future.
    /// </summary>
    void Close();
}
```

`LibreHardwareMonitorLib/Hardware/IHardware.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Handler that will trigger the actions assigned to it when the event occurs.
/// </summary>
/// <param name="sensor">Component returned to the assigned action(s).</param>
public delegate void SensorEventHandler(ISensor sensor);

/// <summary>
/// Abstract object that stores information about a device. All sensors are available as an array of <see cref="Sensors"/>.
/// <para>
/// Can contain <see cref="SubHardware"/>.
/// Type specified in <see cref="HardwareType"/>.
/// </para>
/// </summary>
public interface IHardware : IElement
{
    /// <summary>
    /// <inheritdoc cref="LibreHardwareMonitor.Hardware.HardwareType"/>
    /// </summary>
    HardwareType HardwareType { get; }

    /// <summary>
    /// Gets a unique hardware ID that represents its location.
    /// </summary>
    Identifier Identifier { get; }

    /// <summary>
    /// Gets or sets device name.
    /// </summary>
    string Name { get; set; }

    /// <summary>
    /// Gets the device that is the parent of the current hardware. For example, the motherboard is the parent of SuperIO.
    /// </summary>
    IHardware Parent { get; }

    /// <summary>
    /// Gets an array of all sensors such as <see cref="SensorType.Temperature"/>, <see cref="SensorType.Clock"/>, <see cref="SensorType.Load"/> etc.
    /// </summary>
    ISensor[] Sensors { get; }

    /// <summary>
    /// Gets child devices, e.g. <see cref="LibreHardwareMonitor.Hardware.Motherboard.Lpc.LpcIO"/> of the <see cref="LibreHardwareMonitor.Hardware.Motherboard.Motherboard"/>.
    /// </summary>
    IHardware[] SubHardware { get; }

    /// <summary>
    /// Report containing most of the known information about the current device.
    /// </summary>
    /// <returns>A formatted text string with hardware information.</returns>
    string GetReport();

    /// <summary>
    /// Refreshes the information stored in <see cref="Sensors"/> array.
    /// </summary>
    void Update();

    /// <summary>
    /// An <see langword="event"/> that will be triggered when a new sensor appears.
    /// </summary>
    event SensorEventHandler SensorAdded;

    /// <summary>
    /// An <see langword="event"/> that will be triggered when one of the sensors is removed.
    /// </summary>
    event SensorEventHandler SensorRemoved;

    /// <summary>
    /// Gets rarely changed hardware properties that can't be represented as sensors.
    /// </summary>
    IDictionary<string, string> Properties { get; }
}
```

`LibreHardwareMonitorLib/Hardware/IHardwareChanged.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

internal interface IHardwareChanged
{
    event HardwareEventHandler HardwareAdded;
    event HardwareEventHandler HardwareRemoved;
}
```

`LibreHardwareMonitorLib/Hardware/IParameter.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Abstract object that represents additional parameters included in <see cref="ISensor"/>.
/// </summary>
public interface IParameter : IElement
{
    /// <summary>
    /// Gets a parameter default value defined by library.
    /// </summary>
    float DefaultValue { get; }

    /// <summary>
    /// Gets a parameter description defined by library.
    /// </summary>
    string Description { get; }

    /// <summary>
    /// Gets a unique parameter ID that represents its location.
    /// </summary>
    Identifier Identifier { get; }

    /// <summary>
    /// Gets or sets information whether the given <see cref="IParameter"/> is the default for <see cref="ISensor"/>.
    /// </summary>
    bool IsDefault { get; set; }

    /// <summary>
    /// Gets a parameter name defined by library.
    /// </summary>
    string Name { get; }

    /// <summary>
    /// Gets the sensor that is the data container for the given parameter.
    /// </summary>
    ISensor Sensor { get; }

    /// <summary>
    /// Gets or sets the current value.
    /// </summary>
    float Value { get; set; }
}
```

`LibreHardwareMonitorLib/Hardware/ISensor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Category of what type the selected sensor is.
/// </summary>
public enum SensorType
{
    Voltage, // V
    Current, // A
    Power, // W
    Clock, // MHz
    Temperature, // °C
    Load, // %
    Frequency, // Hz
    Fan, // RPM
    Flow, // L/h
    Control, // %
    Level, // %
    Factor, // 1
    Data, // GB = 2^30 Bytes
    SmallData, // MB = 2^20 Bytes
    Throughput, // B/s
    TimeSpan, // Seconds 
    Energy, // milliwatt-hour (mWh)
    Noise // dBA
}

/// <summary>
/// Stores the readed value and the time in which it was recorded.
/// </summary>
public struct SensorValue
{
    /// <param name="value"><see cref="Value"/> of the sensor.</param>
    /// <param name="time">The time code during which the <see cref="Value"/> was recorded.</param>
    public SensorValue(float value, DateTime time)
    {
        Value = value;
        Time = time;
    }

    /// <summary>
    /// Gets the value of the sensor
    /// </summary>
    public float Value { get; }

    /// <summary>
    /// Gets the time code during which the <see cref="Value"/> was recorded.
    /// </summary>
    public DateTime Time { get; }
}

/// <summary>
/// Stores information about the readed values and the time in which they were collected.
/// </summary>
public interface ISensor : IElement
{
    IControl Control { get; }

    /// <summary>
    /// <inheritdoc cref="IHardware"/>
    /// </summary>
    IHardware Hardware { get; }

    Identifier Identifier { get; }

    /// <summary>
    /// Gets the unique identifier of this sensor for a given <see cref="IHardware"/>.
    /// </summary>
    int Index { get; }

    bool IsDefaultHidden { get; }

    /// <summary>
    /// Gets a maximum value recorded for the given sensor.
    /// </summary>
    float? Max { get; }

    /// <summary>
    /// Gets a minimum value recorded for the given sensor.
    /// </summary>
    float? Min { get; }

    /// <summary>
    /// Gets or sets a sensor name.
    /// <para>By default determined by the library.</para>
    /// </summary>
    string Name { get; set; }

    IReadOnlyList<IParameter> Parameters { get; }

    /// <summary>
    /// <inheritdoc cref="LibreHardwareMonitor.Hardware.SensorType"/>
    /// </summary>
    SensorType SensorType { get; }

    /// <summary>
    /// Gets the last recorded value for the given sensor.
    /// </summary>
    float? Value { get; }

    /// <summary>
    /// Gets a list of recorded values for the given sensor.
    /// </summary>
    IEnumerable<SensorValue> Values { get; }

    TimeSpan ValuesTimeWindow { get; set; }

    /// <summary>
    /// Resets a value stored in <see cref="Min"/>.
    /// </summary>
    void ResetMin();

    /// <summary>
    /// Resets a value stored in <see cref="Max"/>.
    /// </summary>
    void ResetMax();

    /// <summary>
    /// Clears the values stored in <see cref="Values"/>.
    /// </summary>
    void ClearValues();
}

```

`LibreHardwareMonitorLib/Hardware/ISensorLimits.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Abstract object that stores information about the limits of <see cref="ISensor"/>.
/// </summary>
public interface ISensorLimits
{
    /// <summary>
    /// Upper limit of <see cref="ISensor"/> value.
    /// </summary>
    float? HighLimit { get; }

    /// <summary>
    /// Lower limit of <see cref="ISensor"/> value.
    /// </summary>
    float? LowLimit { get; }
}

/// <summary>
/// Abstract object that stores information about the critical limits of <see cref="ISensor"/>.
/// </summary>
public interface ICriticalSensorLimits
{
    /// <summary>
    /// Critical upper limit of <see cref="ISensor"/> value.
    /// </summary>
    float? CriticalHighLimit { get; }

    /// <summary>
    /// Critical lower limit of <see cref="ISensor"/> value.
    /// </summary>
    float? CriticalLowLimit { get; }
}
```

`LibreHardwareMonitorLib/Hardware/ISettings.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Abstract object that stores settings passed to <see cref="IComputer"/>, <see cref="IHardware"/> and <see cref="ISensor"/>.
/// </summary>
public interface ISettings
{
    /// <summary>
    /// Returns information whether the given collection of settings contains a value assigned to the given key.
    /// </summary>
    /// <param name="name">Key to which the setting value is assigned.</param>
    bool Contains(string name);

    /// <summary>
    /// Assigns a setting option to a given key.
    /// </summary>
    /// <param name="name">Key to which the setting value is assigned.</param>
    /// <param name="value">Text setting value.</param>
    void SetValue(string name, string value);

    /// <summary>
    /// Gets a setting option assigned to the given key.
    /// </summary>
    /// <param name="name">Key to which the setting value is assigned.</param>
    /// <param name="value">Default value.</param>
    string GetValue(string name, string value);

    /// <summary>
    /// Removes a setting with the specified key from the settings collection.
    /// </summary>
    /// <param name="name">Key to which the setting value is assigned.</param>
    void Remove(string name);
}
```

`LibreHardwareMonitorLib/Hardware/IVisitor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Base interface for creating observers who call to devices.
/// </summary>
public interface IVisitor
{
    /// <summary>
    /// Refreshes the values of all <see cref="ISensor"/> in all <see cref="IHardware"/> on selected <see cref="IComputer"/>.
    /// </summary>
    /// <param name="computer">Instance of the computer to be revisited.</param>
    void VisitComputer(IComputer computer);

    /// <summary>
    /// Refreshes the values of all <see cref="ISensor"/> on selected <see cref="IHardware"/>.
    /// </summary>
    /// <param name="hardware">Instance of the hardware to be revisited.</param>
    void VisitHardware(IHardware hardware);

    /// <summary>
    /// Refreshes the values on selected <see cref="ISensor"/>.
    /// </summary>
    /// <param name="sensor">Instance of the sensor to be revisited.</param>
    void VisitSensor(ISensor sensor);

    /// <summary>
    /// Refreshes the values on selected <see cref="IParameter"/>.
    /// </summary>
    /// <param name="parameter">Instance of the parameter to be revisited.</param>
    void VisitParameter(IParameter parameter);
}
```

`LibreHardwareMonitorLib/Hardware/Identifier.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Text;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Represents a unique <see cref="ISensor" />/<see cref="IHardware" /> identifier in text format with a / separator.
/// </summary>
public class Identifier : IComparable<Identifier>
{
    private const char Separator = '/';
    private readonly string _identifier;

    public Identifier(params string[] identifiers)
    {
        CheckIdentifiers(identifiers);
        StringBuilder s = new();
        for (int i = 0; i < identifiers.Length; i++)
        {
            s.Append(Separator);
            s.Append(identifiers[i]);
        }

        _identifier = s.ToString();
    }

    /// <summary>
    /// Creates a new identifier instance based on the base <see cref="Identifier" /> and additional elements.
    /// </summary>
    /// <param name="identifier">Base identifier being the beginning of the new one.</param>
    /// <param name="extensions">Additional parts by which the base <see cref="Identifier" /> will be extended.</param>
    public Identifier(Identifier identifier, params string[] extensions)
    {
        CheckIdentifiers(extensions);
        StringBuilder s = new();
        s.Append(identifier);
        for (int i = 0; i < extensions.Length; i++)
        {
            s.Append(Separator);
            s.Append(extensions[i]);
        }

        _identifier = s.ToString();
    }

    /// <inheritdoc />
    public int CompareTo(Identifier other)
    {
        if (other == null)
            return 1;

        return string.Compare(_identifier,
                              other._identifier,
                              StringComparison.Ordinal);
    }

    private static void CheckIdentifiers(IEnumerable<string> identifiers)
    {
        foreach (string s in identifiers)
        {
            if (s.Contains(" ") || s.Contains(Separator.ToString()))
                throw new ArgumentException("Invalid identifier");
        }
    }

    /// <inheritdoc />
    public override string ToString()
    {
        return _identifier;
    }

    /// <inheritdoc />
    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;

        Identifier id = obj as Identifier;
        if (id == null)
            return false;

        return _identifier == id._identifier;
    }

    /// <inheritdoc />
    public override int GetHashCode()
    {
        return _identifier.GetHashCode();
    }

    public static bool operator ==(Identifier id1, Identifier id2)
    {
        if (id1 is null && id2 is null)
            return true;

        return id1 is not null && id1.Equals(id2);
    }

    public static bool operator !=(Identifier id1, Identifier id2)
    {
        return !(id1 == id2);
    }

    public static bool operator <(Identifier id1, Identifier id2)
    {
        if (id1 == null)
            return id2 != null;

        return id1.CompareTo(id2) < 0;
    }

    public static bool operator >(Identifier id1, Identifier id2)
    {
        if (id1 == null)
            return false;

        return id1.CompareTo(id2) > 0;
    }
}
```

`LibreHardwareMonitorLib/Hardware/InpOut.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware;

internal static class InpOut
{
    private static string _filePath;
    private static IntPtr _libraryHandle;
    private static Interop.InpOut.MapPhysToLinDelegate _mapPhysToLin;
    private static Interop.InpOut.UnmapPhysicalMemoryDelegate _unmapPhysicalMemory;

    public static bool IsOpen { get; private set; }

    public static bool Open()
    {
        if (Software.OperatingSystem.IsUnix)
            return false;

        if (IsOpen)
            return true;

        _filePath = GetFilePath();
        if (_filePath != null && (File.Exists(_filePath) || Extract(_filePath)))
        {
            _libraryHandle = Kernel32.LoadLibrary(_filePath);
            if (_libraryHandle != IntPtr.Zero)
            {
                IntPtr mapPhysToLinAddress = Kernel32.GetProcAddress(_libraryHandle, "MapPhysToLin");
                IntPtr unmapPhysicalMemoryAddress = Kernel32.GetProcAddress(_libraryHandle, "UnmapPhysicalMemory");

                if (mapPhysToLinAddress != IntPtr.Zero)
                    _mapPhysToLin = Marshal.GetDelegateForFunctionPointer<Interop.InpOut.MapPhysToLinDelegate>(mapPhysToLinAddress);

                if (unmapPhysicalMemoryAddress != IntPtr.Zero)
                    _unmapPhysicalMemory = Marshal.GetDelegateForFunctionPointer<Interop.InpOut.UnmapPhysicalMemoryDelegate>(unmapPhysicalMemoryAddress);

                IsOpen = true;
            }
        }

        if (!IsOpen)
            Delete();

        return IsOpen;
    }

    public static void Close()
    {
        if (_libraryHandle != IntPtr.Zero)
        {
            Kernel32.FreeLibrary(_libraryHandle);
            Delete();

            _libraryHandle = IntPtr.Zero;
        }

        IsOpen = false;
    }

    public static byte[] ReadMemory(IntPtr baseAddress, uint size)
    {
        if (_mapPhysToLin != null && _unmapPhysicalMemory != null)
        {
            IntPtr pdwLinAddr = _mapPhysToLin(baseAddress, size, out IntPtr pPhysicalMemoryHandle);
            if (pdwLinAddr != IntPtr.Zero)
            {
                byte[] bytes = new byte[size];
                Marshal.Copy(pdwLinAddr, bytes, 0, bytes.Length);
                _unmapPhysicalMemory(pPhysicalMemoryHandle, pdwLinAddr);

                return bytes;
            }
        }

        return null;
    }

    private static void Delete()
    {
        try
        {
            // try to delete the DLL
            if (_filePath != null && File.Exists(_filePath))
                File.Delete(_filePath);

            _filePath = null;
        }
        catch
        { }
    }

    private static string GetFilePath()
    {
        string filePath;

        try
        {
            filePath = Path.GetTempFileName();
            if (!string.IsNullOrEmpty(filePath))
                return Path.ChangeExtension(filePath, ".dll");
        }
        catch (IOException)
        { }

        const string fileName = "inpout.dll";

        try
        {
            ProcessModule processModule = Process.GetCurrentProcess().MainModule;
            if (!string.IsNullOrEmpty(processModule?.FileName))
                return Path.Combine(Path.GetDirectoryName(processModule.FileName) ?? string.Empty, fileName);
        }
        catch
        {
            // Continue with the other options.
        }

        filePath = GetPathFromAssembly(Assembly.GetExecutingAssembly());
        if (!string.IsNullOrEmpty(filePath))
            return Path.Combine(Path.GetDirectoryName(filePath) ?? string.Empty, fileName);

        filePath = GetPathFromAssembly(typeof(InpOut).Assembly);
        if (!string.IsNullOrEmpty(filePath))
            return Path.Combine(Path.GetDirectoryName(filePath) ?? string.Empty, fileName);

        return null;

        static string GetPathFromAssembly(Assembly assembly)
        {
            try
            {
                string location = assembly?.Location;
                return !string.IsNullOrEmpty(location) ? location : null;
            }
            catch
            {
                return null;
            }
        }
    }

    private static bool Extract(string filePath)
    {
        string resourceName = $"{nameof(LibreHardwareMonitor)}.Resources.{(Software.OperatingSystem.Is64Bit ? "inpoutx64.gz" : "inpout32.gz")}";

        Assembly assembly = typeof(InpOut).Assembly;
        long requiredLength = 0;

        try
        {
            using Stream stream = assembly.GetManifestResourceStream(resourceName);

            if (stream != null)
            {
                using FileStream target = new(filePath, FileMode.Create);

                stream.Position = 1; // Skip first byte.

                using var gzipStream = new GZipStream(stream, CompressionMode.Decompress);

                gzipStream.CopyTo(target);

                requiredLength = target.Length;
            }
        }
        catch
        {
            return false;
        }

        if (HasValidFile())
            return true;

        // Ensure the file is actually written to the file system.
        var stopwatch = new Stopwatch();
        stopwatch.Start();

        while (stopwatch.ElapsedMilliseconds < 2000)
        {
            if (HasValidFile())
                return true;

            Thread.Yield();
        }

        return false;

        bool HasValidFile()
        {
            try
            {
                return File.Exists(filePath) && new FileInfo(filePath).Length == requiredLength;
            }
            catch
            {
                return false;
            }
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/KernelDriver.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.AccessControl;
using LibreHardwareMonitor.Interop;
using Microsoft.Win32.SafeHandles;

namespace LibreHardwareMonitor.Hardware;

internal class KernelDriver
{
    private readonly string _driverId;
    private readonly string _serviceName;
    private SafeFileHandle _device;

    public KernelDriver(string serviceName, string driverId)
    {
        _serviceName = serviceName;
        _driverId = driverId;
    }

    public bool IsOpen
    {
        get { return _device != null; }
    }

    public bool Install(string path, out string errorMessage)
    {
        IntPtr manager = AdvApi32.OpenSCManager(null, null, AdvApi32.SC_MANAGER_ACCESS_MASK.SC_MANAGER_ALL_ACCESS);
        if (manager == IntPtr.Zero)
        {
            errorMessage = "OpenSCManager returned zero.";
            return false;
        }

        IntPtr service = AdvApi32.CreateService(manager,
                                                _serviceName,
                                                _serviceName,
                                                AdvApi32.SERVICE_ACCESS_MASK.SERVICE_ALL_ACCESS,
                                                AdvApi32.SERVICE_TYPE.SERVICE_KERNEL_DRIVER,
                                                AdvApi32.SERVICE_START.SERVICE_DEMAND_START,
                                                AdvApi32.SERVICE_ERROR.SERVICE_ERROR_NORMAL,
                                                path,
                                                null,
                                                null,
                                                null,
                                                null,
                                                null);

        if (service == IntPtr.Zero)
        {
            int error = Marshal.GetHRForLastWin32Error();
            if (error == Kernel32.ERROR_SERVICE_EXISTS)
            {
                errorMessage = "Service already exists";
                return false;
            }

            errorMessage = "CreateService returned the error: " + Marshal.GetExceptionForHR(error).Message;
            AdvApi32.CloseServiceHandle(manager);
            return false;
        }

        if (!AdvApi32.StartService(service, 0, null))
        {
            int error = Marshal.GetHRForLastWin32Error();
            if (error != Kernel32.ERROR_SERVICE_ALREADY_RUNNING)
            {
                errorMessage = "StartService returned the error: " + Marshal.GetExceptionForHR(error).Message;
                AdvApi32.CloseServiceHandle(service);
                AdvApi32.CloseServiceHandle(manager);
                return false;
            }
        }

        AdvApi32.CloseServiceHandle(service);
        AdvApi32.CloseServiceHandle(manager);

        try
        {
            // restrict the driver access to system (SY) and builtin admins (BA)
            // TODO: replace with a call to IoCreateDeviceSecure in the driver
            FileInfo fileInfo = new(@"\\.\" + _driverId);
            FileSecurity fileSecurity = fileInfo.GetAccessControl();
            fileSecurity.SetSecurityDescriptorSddlForm("O:BAG:SYD:(A;;FA;;;SY)(A;;FA;;;BA)");
            fileInfo.SetAccessControl(fileSecurity);
        }
        catch
        { }

        errorMessage = null;
        return true;
    }

    public bool Open()
    {
        IntPtr fileHandle = Kernel32.CreateFile(@"\\.\" + _driverId, 0xC0000000, FileShare.None, IntPtr.Zero, FileMode.Open, FileAttributes.Normal, IntPtr.Zero);
        _device = new SafeFileHandle(fileHandle, true);
        if (_device.IsInvalid)
        {
            _device.Close();
            _device.Dispose();
            _device = null;
        }

        return _device != null;
    }

    public bool DeviceIOControl(Kernel32.IOControlCode ioControlCode, object inBuffer)
    {
        if (_device == null)
            return false;

        return Kernel32.DeviceIoControl(_device, ioControlCode, inBuffer, inBuffer == null ? 0 : (uint)Marshal.SizeOf(inBuffer), null, 0, out uint _, IntPtr.Zero);
    }

    public bool DeviceIOControl<T>(Kernel32.IOControlCode ioControlCode, object inBuffer, ref T outBuffer)
    {
        if (_device == null)
            return false;

        object boxedOutBuffer = outBuffer;
        bool b = Kernel32.DeviceIoControl(_device,
                                          ioControlCode,
                                          inBuffer,
                                          inBuffer == null ? 0 : (uint)Marshal.SizeOf(inBuffer),
                                          boxedOutBuffer,
                                          (uint)Marshal.SizeOf(boxedOutBuffer),
                                          out uint _,
                                          IntPtr.Zero);

        outBuffer = (T)boxedOutBuffer;
        return b;
    }

    public bool DeviceIOControl<T>(Kernel32.IOControlCode ioControlCode, object inBuffer, ref T[] outBuffer)
    {
        if (_device == null)
            return false;

        object boxedOutBuffer = outBuffer;
        bool b = Kernel32.DeviceIoControl(_device,
                                          ioControlCode,
                                          inBuffer,
                                          inBuffer == null ? 0 : (uint)Marshal.SizeOf(inBuffer),
                                          boxedOutBuffer,
                                          (uint)(Marshal.SizeOf(typeof(T)) * outBuffer.Length),
                                          out uint _,
                                          IntPtr.Zero);

        outBuffer = (T[])boxedOutBuffer;
        return b;
    }

    public void Close()
    {
        if (_device != null)
        {
            _device.Close();
            _device.Dispose();
            _device = null;
        }
    }

    public bool Delete()
    {
        IntPtr manager = AdvApi32.OpenSCManager(null, null, AdvApi32.SC_MANAGER_ACCESS_MASK.SC_MANAGER_ALL_ACCESS);
        if (manager == IntPtr.Zero)
            return false;

        IntPtr service = AdvApi32.OpenService(manager, _serviceName, AdvApi32.SERVICE_ACCESS_MASK.SERVICE_ALL_ACCESS);
        if (service == IntPtr.Zero)
        {
            AdvApi32.CloseServiceHandle(manager);
            return true;
        }

        AdvApi32.SERVICE_STATUS status = new();
        AdvApi32.ControlService(service, AdvApi32.SERVICE_CONTROL.SERVICE_CONTROL_STOP, ref status);
        AdvApi32.DeleteService(service);
        AdvApi32.CloseServiceHandle(service);
        AdvApi32.CloseServiceHandle(manager);

        return true;
    }
}
```

`LibreHardwareMonitorLib/Hardware/Memory/GenericLinuxMemory.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.IO;
using System.Linq;

namespace LibreHardwareMonitor.Hardware.Memory;

internal sealed class GenericLinuxMemory : Hardware
{
    private readonly Sensor _physicalMemoryAvailable;
    private readonly Sensor _physicalMemoryLoad;
    private readonly Sensor _physicalMemoryUsed;
    private readonly Sensor _virtualMemoryAvailable;
    private readonly Sensor _virtualMemoryLoad;
    private readonly Sensor _virtualMemoryUsed;

    public override HardwareType HardwareType => HardwareType.Memory;

    public GenericLinuxMemory(string name, ISettings settings) : base(name, new Identifier("ram"), settings)
    {
        _physicalMemoryUsed = new Sensor("Memory Used", 0, SensorType.Data, this, settings);
        ActivateSensor(_physicalMemoryUsed);

        _physicalMemoryAvailable = new Sensor("Memory Available", 1, SensorType.Data, this, settings);
        ActivateSensor(_physicalMemoryAvailable);

        _physicalMemoryLoad = new Sensor("Memory", 0, SensorType.Load, this, settings);
        ActivateSensor(_physicalMemoryLoad);

        _virtualMemoryUsed = new Sensor("Virtual Memory Used", 2, SensorType.Data, this, settings);
        ActivateSensor(_virtualMemoryUsed);

        _virtualMemoryAvailable = new Sensor("Virtual Memory Available", 3, SensorType.Data, this, settings);
        ActivateSensor(_virtualMemoryAvailable);

        _virtualMemoryLoad = new Sensor("Virtual Memory", 1, SensorType.Load, this, settings);
        ActivateSensor(_virtualMemoryLoad);
    }

    public override void Update()
    {
        try
        {
            string[] memoryInfo = File.ReadAllLines("/proc/meminfo");

            {
                float totalMemory_GB = GetMemInfoValue(memoryInfo.First(entry => entry.StartsWith("MemTotal:"))) / 1024.0f / 1024.0f;
                float freeMemory_GB = GetMemInfoValue(memoryInfo.First(entry => entry.StartsWith("MemFree:"))) / 1024.0f / 1024.0f;
                float cachedMemory_GB = GetMemInfoValue(memoryInfo.First(entry => entry.StartsWith("Cached:"))) / 1024.0f / 1024.0f;

                float usedMemory_GB = totalMemory_GB - freeMemory_GB - cachedMemory_GB;

                _physicalMemoryUsed.Value = usedMemory_GB;
                _physicalMemoryAvailable.Value = totalMemory_GB;
                _physicalMemoryLoad.Value = 100.0f * (usedMemory_GB / totalMemory_GB);
            }
            {
                float totalSwapMemory_GB = GetMemInfoValue(memoryInfo.First(entry => entry.StartsWith("SwapTotal"))) / 1024.0f / 1024.0f;
                float freeSwapMemory_GB = GetMemInfoValue(memoryInfo.First(entry => entry.StartsWith("SwapFree"))) / 1024.0f / 1024.0f;
                float usedSwapMemory_GB = totalSwapMemory_GB - freeSwapMemory_GB;

                _virtualMemoryUsed.Value = usedSwapMemory_GB;
                _virtualMemoryAvailable.Value = totalSwapMemory_GB;
                _virtualMemoryLoad.Value = 100.0f * (usedSwapMemory_GB / totalSwapMemory_GB);
            }
        }
        catch
        {
            _physicalMemoryUsed.Value = null;
            _physicalMemoryAvailable.Value = null;
            _physicalMemoryLoad.Value = null;

            _virtualMemoryUsed.Value = null;
            _virtualMemoryAvailable.Value = null;
            _virtualMemoryLoad.Value = null;
        }
    }

    private static long GetMemInfoValue(string line)
    {
        // Example: "MemTotal:       32849676 kB"

        string valueWithUnit = line.Split(':').Skip(1).First().Trim();
        string valueAsString = valueWithUnit.Split(' ').First();

        return long.Parse(valueAsString);
    }
}

```

`LibreHardwareMonitorLib/Hardware/Memory/GenericWindowsMemory.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Runtime.InteropServices;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Memory;

internal sealed class GenericWindowsMemory : Hardware
{
    private readonly Sensor _physicalMemoryAvailable;
    private readonly Sensor _physicalMemoryLoad;
    private readonly Sensor _physicalMemoryUsed;
    private readonly Sensor _virtualMemoryAvailable;
    private readonly Sensor _virtualMemoryLoad;
    private readonly Sensor _virtualMemoryUsed;

    public GenericWindowsMemory(string name, ISettings settings) : base(name, new Identifier("ram"), settings)
    {
        _physicalMemoryUsed = new Sensor("Memory Used", 0, SensorType.Data, this, settings);
        ActivateSensor(_physicalMemoryUsed);

        _physicalMemoryAvailable = new Sensor("Memory Available", 1, SensorType.Data, this, settings);
        ActivateSensor(_physicalMemoryAvailable);

        _physicalMemoryLoad = new Sensor("Memory", 0, SensorType.Load, this, settings);
        ActivateSensor(_physicalMemoryLoad);

        _virtualMemoryUsed = new Sensor("Virtual Memory Used", 2, SensorType.Data, this, settings);
        ActivateSensor(_virtualMemoryUsed);

        _virtualMemoryAvailable = new Sensor("Virtual Memory Available", 3, SensorType.Data, this, settings);
        ActivateSensor(_virtualMemoryAvailable);

        _virtualMemoryLoad = new Sensor("Virtual Memory", 1, SensorType.Load, this, settings);
        ActivateSensor(_virtualMemoryLoad);
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Memory; }
    }

    public override void Update()
    {
        Kernel32.MEMORYSTATUSEX status = new() { dwLength = (uint)Marshal.SizeOf<Kernel32.MEMORYSTATUSEX>() };

        if (!Kernel32.GlobalMemoryStatusEx(ref status))
            return;

        _physicalMemoryUsed.Value = (float)(status.ullTotalPhys - status.ullAvailPhys) / (1024 * 1024 * 1024);
        _physicalMemoryAvailable.Value = (float)status.ullAvailPhys / (1024 * 1024 * 1024);
        _physicalMemoryLoad.Value = 100.0f - ((100.0f * status.ullAvailPhys) / status.ullTotalPhys);

        _virtualMemoryUsed.Value = (float)(status.ullTotalPageFile - status.ullAvailPageFile) / (1024 * 1024 * 1024);
        _virtualMemoryAvailable.Value = (float)status.ullAvailPageFile / (1024 * 1024 * 1024);
        _virtualMemoryLoad.Value = 100.0f - ((100.0f * status.ullAvailPageFile) / status.ullTotalPageFile);
    }
}
```

`LibreHardwareMonitorLib/Hardware/Memory/MemoryGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Memory;

internal class MemoryGroup : IGroup
{
    private readonly Hardware[] _hardware;

    public MemoryGroup(ISettings settings)
    {
        _hardware = new Hardware[] { Software.OperatingSystem.IsUnix ? new GenericLinuxMemory("Generic Memory", settings) : new GenericWindowsMemory("Generic Memory", settings) };
    }

    public string GetReport()
    {
        return null;
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (Hardware ram in _hardware)
            ram.Close();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Identification.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;

namespace LibreHardwareMonitor.Hardware.Motherboard;

internal class Identification
{
    public static Manufacturer GetManufacturer(string name)
    {
        switch (name)
        {
            case var _ when name.IndexOf("abit.com.tw", StringComparison.OrdinalIgnoreCase) > -1:
                return Manufacturer.Acer;
            case var _ when name.StartsWith("Acer", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Acer;
            case var _ when name.StartsWith("AMD", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.AMD;
            case var _ when name.Equals("Alienware", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Alienware;
            case var _ when name.StartsWith("AOpen", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.AOpen;
            case var _ when name.StartsWith("Apple", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Apple;
            case var _ when name.Equals("ASRock", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.ASRock;
            case var _ when name.StartsWith("ASUSTeK", StringComparison.OrdinalIgnoreCase):
            case var _ when name.StartsWith("ASUS ", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.ASUS;
            case var _ when name.StartsWith("Biostar", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Biostar;
            case var _ when name.StartsWith("Clevo", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Clevo;
            case var _ when name.StartsWith("Dell", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Dell;
            case var _ when name.Equals("DFI", StringComparison.OrdinalIgnoreCase):
            case var _ when name.StartsWith("DFI Inc", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.DFI;
            case var _ when name.Equals("ECS", StringComparison.OrdinalIgnoreCase):
            case var _ when name.StartsWith("ELITEGROUP", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.ECS;
            case var _ when name.Equals("EPoX COMPUTER CO., LTD", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.EPoX;
            case var _ when name.StartsWith("EVGA", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.EVGA;
            case var _ when name.Equals("FIC", StringComparison.OrdinalIgnoreCase):
            case var _ when name.StartsWith("First International Computer", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.FIC;
            case var _ when name.Equals("Foxconn", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Foxconn;
            case var _ when name.StartsWith("Fujitsu", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Fujitsu;
            case var _ when name.StartsWith("Gigabyte", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Gigabyte;
            case var _ when name.StartsWith("Hewlett-Packard", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("HP", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.HP;
            case var _ when name.Equals("IBM", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.IBM;
            case var _ when name.Equals("Intel", StringComparison.OrdinalIgnoreCase):
            case var _ when name.StartsWith("Intel Corp", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Intel;
            case var _ when name.StartsWith("Jetway", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Jetway;
            case var _ when name.StartsWith("Lenovo", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Lenovo;
            case var _ when name.Equals("LattePanda", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.LattePanda;
            case var _ when name.StartsWith("Medion", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Medion;
            case var _ when name.StartsWith("Microsoft", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Microsoft;
            case var _ when name.StartsWith("Micro-Star International", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("MSI", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.MSI;
            case var _ when name.StartsWith("NEC ", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("NEC", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.NEC;
            case var _ when name.StartsWith("Pegatron", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Pegatron;
            case var _ when name.StartsWith("Samsung", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Samsung;
            case var _ when name.StartsWith("Sapphire", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Sapphire;
            case var _ when name.StartsWith("Shuttle", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Shuttle;
            case var _ when name.StartsWith("Sony", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Sony;
            case var _ when name.StartsWith("Supermicro", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Supermicro;
            case var _ when name.StartsWith("Toshiba", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Toshiba;
            case var _ when name.Equals("XFX", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.XFX;
            case var _ when name.StartsWith("Zotac", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Zotac;
            case var _ when name.Equals("To be filled by O.E.M.", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Unknown;
            default:
                return Manufacturer.Unknown;
        }
    }

    public static Model GetModel(string name)
    {
        switch (name)
        {
            case var _ when name.Equals("880GMH/USB3", StringComparison.OrdinalIgnoreCase):
                return Model._880GMH_USB3;
            case var _ when name.Equals("B85M-DGS", StringComparison.OrdinalIgnoreCase):
                return Model.B85M_DGS;
            case var _ when name.Equals("ASRock AOD790GX/128M", StringComparison.OrdinalIgnoreCase):
                return Model.AOD790GX_128M;
            case var _ when name.Equals("AB350 Pro4", StringComparison.OrdinalIgnoreCase):
                return Model.AB350_Pro4;
            case var _ when name.Equals("AB350M Pro4", StringComparison.OrdinalIgnoreCase):
                return Model.AB350M_Pro4;
            case var _ when name.Equals("AB350M", StringComparison.OrdinalIgnoreCase):
                return Model.AB350M;
            case var _ when name.Equals("B450 Steel Legend", StringComparison.OrdinalIgnoreCase):
                return Model.B450_Steel_Legend;
            case var _ when name.Equals("B450M Steel Legend", StringComparison.OrdinalIgnoreCase):
                return Model.B450M_Steel_Legend;
            case var _ when name.Equals("B450 Pro4", StringComparison.OrdinalIgnoreCase):
                return Model.B450_Pro4;
            case var _ when name.Equals("B450M Pro4", StringComparison.OrdinalIgnoreCase):
                return Model.B450M_Pro4;
            case var _ when name.Equals("Fatal1ty AB350 Gaming K4", StringComparison.OrdinalIgnoreCase):
                return Model.Fatal1ty_AB350_Gaming_K4;
            case var _ when name.Equals("AB350M-HDV", StringComparison.OrdinalIgnoreCase):
                return Model.AB350M_HDV;
            case var _ when name.Equals("X399 Phantom Gaming 6", StringComparison.OrdinalIgnoreCase):
                return Model.X399_Phantom_Gaming_6;
            case var _ when name.Equals("A320M-HDV", StringComparison.OrdinalIgnoreCase):
                return Model.A320M_HDV;
            case var _ when name.Equals("P55 Deluxe", StringComparison.OrdinalIgnoreCase):
                return Model.P55_Deluxe;
            case var _ when name.Equals("Crosshair III Formula", StringComparison.OrdinalIgnoreCase):
                return Model.CROSSHAIR_III_FORMULA;
            case var _ when name.Equals("ROG CROSSHAIR VIII HERO", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_VIII_HERO;
            case var _ when name.Equals("ROG CROSSHAIR VIII HERO (WI-FI)", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_VIII_HERO_WIFI;
            case var _ when name.Equals("ROG CROSSHAIR VIII DARK HERO", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_VIII_DARK_HERO;
            case var _ when name.Equals("ROG CROSSHAIR VIII FORMULA", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_VIII_FORMULA;
            case var _ when name.Equals("ROG CROSSHAIR VIII IMPACT", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_VIII_IMPACT;
            case var _ when name.Equals("M2N-SLI DELUXE", StringComparison.OrdinalIgnoreCase):
                return Model.M2N_SLI_Deluxe;
            case var _ when name.Equals("M4A79XTD EVO", StringComparison.OrdinalIgnoreCase):
                return Model.M4A79XTD_EVO;
            case var _ when name.Equals("P5W DH Deluxe", StringComparison.OrdinalIgnoreCase):
                return Model.P5W_DH_Deluxe;
            case var _ when name.Equals("P6T", StringComparison.OrdinalIgnoreCase):
                return Model.P6T;
            case var _ when name.Equals("P6X58D-E", StringComparison.OrdinalIgnoreCase):
                return Model.P6X58D_E;
            case var _ when name.Equals("P8P67", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("P8P67 REV 3.1", StringComparison.OrdinalIgnoreCase):
                return Model.P8P67;
            case var _ when name.Equals("P8P67 EVO", StringComparison.OrdinalIgnoreCase):
                return Model.P8P67_EVO;
            case var _ when name.Equals("P8P67 PRO", StringComparison.OrdinalIgnoreCase):
                return Model.P8P67_PRO;
            case var _ when name.Equals("P8P67-M PRO", StringComparison.OrdinalIgnoreCase):
                return Model.P8P67_M_PRO;
            case var _ when name.Equals("P8Z77-V", StringComparison.OrdinalIgnoreCase):
                return Model.P8Z77_V;
            case var _ when name.Equals("P9X79", StringComparison.OrdinalIgnoreCase):
                return Model.P9X79;
            case var _ when name.Equals("Rampage Extreme", StringComparison.OrdinalIgnoreCase):
                return Model.RAMPAGE_EXTREME;
            case var _ when name.Equals("Rampage II GENE", StringComparison.OrdinalIgnoreCase):
                return Model.RAMPAGE_II_GENE;
            case var _ when name.Equals("LP BI P45-T2RS Elite", StringComparison.OrdinalIgnoreCase):
                return Model.LP_BI_P45_T2RS_Elite;
            case var _ when name.Equals("ROG STRIX B550-F GAMING (WI-FI)", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_B550_F_GAMING_WIFI;
            case var _ when name.Equals("ROG STRIX X470-I GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X470_I;
            case var _ when name.Equals("ROG STRIX B550-E GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_B550_E_GAMING;
            case var _ when name.Equals("ROG STRIX B550-I GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_B550_I_GAMING;
            case var _ when name.Equals("ROG STRIX X570-E GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X570_E_GAMING;
            case var _ when name.Equals("ROG STRIX X570-I GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X570_I_GAMING;
            case var _ when name.Equals("ROG STRIX X570-F GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X570_F_GAMING;
            case var _ when name.Equals("LP DK P55-T3eH9", StringComparison.OrdinalIgnoreCase):
                return Model.LP_DK_P55_T3EH9;
            case var _ when name.Equals("A890GXM-A", StringComparison.OrdinalIgnoreCase):
                return Model.A890GXM_A;
            case var _ when name.Equals("X58 SLI Classified", StringComparison.OrdinalIgnoreCase):
                return Model.X58_SLI_Classified;
            case var _ when name.Equals("965P-S3", StringComparison.OrdinalIgnoreCase):
                return Model._965P_S3;
            case var _ when name.Equals("EP45-DS3R", StringComparison.OrdinalIgnoreCase):
                return Model.EP45_DS3R;
            case var _ when name.Equals("EP45-UD3R", StringComparison.OrdinalIgnoreCase):
                return Model.EP45_UD3R;
            case var _ when name.Equals("EX58-EXTREME", StringComparison.OrdinalIgnoreCase):
                return Model.EX58_EXTREME;
            case var _ when name.Equals("EX58-UD3R", StringComparison.OrdinalIgnoreCase):
                return Model.EX58_UD3R;
            case var _ when name.Equals("G41M-Combo", StringComparison.OrdinalIgnoreCase):
                return Model.G41M_COMBO;
            case var _ when name.Equals("G41MT-S2", StringComparison.OrdinalIgnoreCase):
                return Model.G41MT_S2;
            case var _ when name.Equals("G41MT-S2P", StringComparison.OrdinalIgnoreCase):
                return Model.G41MT_S2P;
            case var _ when name.Equals("GA-970A-UD3", StringComparison.OrdinalIgnoreCase):
                return Model._970A_UD3;
            case var _ when name.Equals("GA-MA770T-UD3", StringComparison.OrdinalIgnoreCase):
                return Model.MA770T_UD3;
            case var _ when name.Equals("GA-MA770T-UD3P", StringComparison.OrdinalIgnoreCase):
                return Model.MA770T_UD3P;
            case var _ when name.Equals("GA-MA785GM-US2H", StringComparison.OrdinalIgnoreCase):
                return Model.MA785GM_US2H;
            case var _ when name.Equals("GA-MA785GMT-UD2H", StringComparison.OrdinalIgnoreCase):
                return Model.MA785GMT_UD2H;
            case var _ when name.Equals("GA-MA78LM-S2H", StringComparison.OrdinalIgnoreCase):
                return Model.MA78LM_S2H;
            case var _ when name.Equals("GA-MA790X-UD3P", StringComparison.OrdinalIgnoreCase):
                return Model.MA790X_UD3P;
            case var _ when name.Equals("H55-USB3", StringComparison.OrdinalIgnoreCase):
                return Model.H55_USB3;
            case var _ when name.Equals("H55N-USB3", StringComparison.OrdinalIgnoreCase):
                return Model.H55N_USB3;
            case var _ when name.Equals("H61M-DS2 REV 1.2", StringComparison.OrdinalIgnoreCase):
                return Model.H61M_DS2_REV_1_2;
            case var _ when name.Equals("H61M-USB3-B3 REV 2.0", StringComparison.OrdinalIgnoreCase):
                return Model.H61M_USB3_B3_REV_2_0;
            case var _ when name.Equals("H67A-UD3H-B3", StringComparison.OrdinalIgnoreCase):
                return Model.H67A_UD3H_B3;
            case var _ when name.Equals("H67A-USB3-B3", StringComparison.OrdinalIgnoreCase):
                return Model.H67A_USB3_B3;
            case var _ when name.Equals("H81M-HD3", StringComparison.OrdinalIgnoreCase):
                return Model.H81M_HD3;
            case var _ when name.Equals("P35-DS3", StringComparison.OrdinalIgnoreCase):
                return Model.P35_DS3;
            case var _ when name.Equals("P35-DS3L", StringComparison.OrdinalIgnoreCase):
                return Model.P35_DS3L;
            case var _ when name.Equals("P55-UD4", StringComparison.OrdinalIgnoreCase):
                return Model.P55_UD4;
            case var _ when name.Equals("P55A-UD3", StringComparison.OrdinalIgnoreCase):
                return Model.P55A_UD3;
            case var _ when name.Equals("P55M-UD4", StringComparison.OrdinalIgnoreCase):
                return Model.P55M_UD4;
            case var _ when name.Equals("P67A-UD3-B3", StringComparison.OrdinalIgnoreCase):
                return Model.P67A_UD3_B3;
            case var _ when name.Equals("P67A-UD3R-B3", StringComparison.OrdinalIgnoreCase):
                return Model.P67A_UD3R_B3;
            case var _ when name.Equals("P67A-UD4-B3", StringComparison.OrdinalIgnoreCase):
                return Model.P67A_UD4_B3;
            case var _ when name.Equals("P8Z68-V PRO", StringComparison.OrdinalIgnoreCase):
                return Model.P8Z68_V_PRO;
            case var _ when name.Equals("X38-DS5", StringComparison.OrdinalIgnoreCase):
                return Model.X38_DS5;
            case var _ when name.Equals("X58A-UD3R", StringComparison.OrdinalIgnoreCase):
                return Model.X58A_UD3R;
            case var _ when name.Equals("Z270 PC MATE", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z270 PC MATE (MS-7A72)", StringComparison.OrdinalIgnoreCase):
                return Model.Z270_PC_MATE;
            case var _ when name.Equals("X79-UD3", StringComparison.OrdinalIgnoreCase):
                return Model.X79_UD3;
            case var _ when name.Equals("Z68A-D3H-B3", StringComparison.OrdinalIgnoreCase):
                return Model.Z68A_D3H_B3;
            case var _ when name.Equals("Z68AP-D3", StringComparison.OrdinalIgnoreCase):
                return Model.Z68AP_D3;
            case var _ when name.Equals("Z68X-UD3H-B3", StringComparison.OrdinalIgnoreCase):
                return Model.Z68X_UD3H_B3;
            case var _ when name.Equals("Z68X-UD7-B3", StringComparison.OrdinalIgnoreCase):
                return Model.Z68X_UD7_B3;
            case var _ when name.Equals("Z68XP-UD3R", StringComparison.OrdinalIgnoreCase):
                return Model.Z68XP_UD3R;
            case var _ when name.Equals("Z170N-WIFI-CF", StringComparison.OrdinalIgnoreCase):
                return Model.Z170N_WIFI;
            case var _ when name.Equals("Z390 M GAMING-CF", StringComparison.OrdinalIgnoreCase):
                return Model.Z390_M_GAMING;
            case var _ when name.Equals("Z390 AORUS ULTRA", StringComparison.OrdinalIgnoreCase):
                return Model.Z390_AORUS_ULTRA;
            case var _ when name.Equals("Z390 AORUS PRO-CF", StringComparison.OrdinalIgnoreCase):
                return Model.Z390_AORUS_PRO;
            case var _ when name.Equals("Z390 UD", StringComparison.OrdinalIgnoreCase):
                return Model.Z390_UD;
            case var _ when name.Equals("Z690 AORUS PRO", StringComparison.OrdinalIgnoreCase):
                return Model.Z690_AORUS_PRO;
            case var _ when name.Equals("Z690 GAMING X DDR4", StringComparison.OrdinalIgnoreCase):
                return Model.Z690_GAMING_X_DDR4;
            case var _ when name.Equals("FH67", StringComparison.OrdinalIgnoreCase):
                return Model.FH67;
            case var _ when name.Equals("AX370-Gaming K7", StringComparison.OrdinalIgnoreCase):
                return Model.AX370_Gaming_K7;
            case var _ when name.Equals("PRIME X370-PRO", StringComparison.OrdinalIgnoreCase):
                return Model.PRIME_X370_PRO;
            case var _ when name.Equals("PRIME X470-PRO", StringComparison.OrdinalIgnoreCase):
                return Model.PRIME_X470_PRO;
            case var _ when name.Equals("PRIME X570-PRO", StringComparison.OrdinalIgnoreCase):
                return Model.PRIME_X570_PRO;
            case var _ when name.Equals("ProArt X570-CREATOR WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.PROART_X570_CREATOR_WIFI;
            case var _ when name.Equals("Pro WS X570-ACE", StringComparison.OrdinalIgnoreCase):
                return Model.PRO_WS_X570_ACE;
            case var _ when name.Equals("ROG MAXIMUS X APEX", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_X_APEX;
            case var _ when name.Equals("AB350-Gaming 3-CF", StringComparison.OrdinalIgnoreCase):
                return Model.AB350_Gaming_3;
            case var _ when name.Equals("X399 AORUS Gaming 7", StringComparison.OrdinalIgnoreCase):
                return Model.X399_AORUS_Gaming_7;
            case var _ when name.Equals("ROG ZENITH EXTREME", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_ZENITH_EXTREME;
            case var _ when name.Equals("ROG ZENITH II EXTREME", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_ZENITH_II_EXTREME;
            case var _ when name.Equals("Z170-A", StringComparison.OrdinalIgnoreCase):
                return Model.Z170_A;
            case var _ when name.Equals("Z77 Pro4-M", StringComparison.OrdinalIgnoreCase):
                return Model.Z77Pro4M;
            case var _ when name.Equals("X570 Pro4", StringComparison.OrdinalIgnoreCase):
                return Model.X570_Pro4;
            case var _ when name.Equals("X570 Taichi", StringComparison.OrdinalIgnoreCase):
                return Model.X570_Taichi;
            case var _ when name.Equals("X570 Phantom Gaming-ITX/TB3", StringComparison.OrdinalIgnoreCase):
                return Model.X570_Phantom_Gaming_ITX;
            case var _ when name.Equals("AX370-Gaming 5", StringComparison.OrdinalIgnoreCase):
                return Model.AX370_Gaming_5;
            case var _ when name.Equals("TUF X470-PLUS GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.TUF_X470_PLUS_GAMING;
            case var _ when name.Equals("B360M PRO-VDH (MS-7B24)", StringComparison.OrdinalIgnoreCase):
                return Model.B360M_PRO_VDH;
            case var _ when name.Equals("B450-A PRO (MS-7B86)", StringComparison.OrdinalIgnoreCase):
                return Model.B450A_PRO;
            case var _ when name.Equals("B350 GAMING PLUS (MS-7A34)", StringComparison.OrdinalIgnoreCase):
                return Model.B350_Gaming_Plus;
            case var _ when name.Equals("X470 AORUS GAMING 7 WIFI-CF", StringComparison.OrdinalIgnoreCase):
                return Model.X470_AORUS_GAMING_7_WIFI;
            case var _ when name.Equals("X570 AORUS MASTER", StringComparison.OrdinalIgnoreCase):
                return Model.X570_AORUS_MASTER;
            case var _ when name.Equals("X570 AORUS ULTRA", StringComparison.OrdinalIgnoreCase):
                return Model.X570_AORUS_ULTRA;
            case var _ when name.Equals("X570 GAMING X", StringComparison.OrdinalIgnoreCase):
                return Model.X570_GAMING_X;
            case var _ when name.Equals("TUF GAMING B550M-PLUS (WI-FI)", StringComparison.OrdinalIgnoreCase):
                return Model.TUF_GAMING_B550M_PLUS_WIFI;
            case var _ when name.Equals("B360 AORUS GAMING 3 WIFI-CF", StringComparison.OrdinalIgnoreCase):
                return Model.B360_AORUS_GAMING_3_WIFI_CF;
            case var _ when name.Equals("B560M AORUS ELITE", StringComparison.OrdinalIgnoreCase):
                return Model.B560M_AORUS_ELITE;
            case var _ when name.Equals("B560M AORUS PRO", StringComparison.OrdinalIgnoreCase):
                return Model.B560M_AORUS_PRO;
            case var _ when name.Equals("B560M AORUS PRO AX", StringComparison.OrdinalIgnoreCase):
                return Model.B560M_AORUS_PRO_AX;
            case var _ when name.Equals("ROG STRIX Z690-A GAMING WIFI D4", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_Z690_A_GAMING_WIFI_D4;
            case var _ when name.Equals("ROG MAXIMUS Z690 EXTREME GLACIAL", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_Z690_EXTREME_GLACIAL;
            case var _ when name.Equals("B660GTN", StringComparison.OrdinalIgnoreCase):
                return Model.B660GTN;
            case var _ when name.Equals("ROG MAXIMUS Z790 HERO", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_Z790_HERO;
            case var _ when name.Equals("PRIME Z690-A", StringComparison.OrdinalIgnoreCase):
                return Model.PRIME_Z690_A;
            case var _ when name.Equals("Base Board Product Name", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("To be filled by O.E.M.", StringComparison.OrdinalIgnoreCase):
                return Model.Unknown;
            default:
                return Model.Unknown;
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/Chip.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Diagnostics.CodeAnalysis;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

[SuppressMessage("ReSharper", "InconsistentNaming")]
internal enum Chip : ushort
{
    Unknown = 0,

    ATK0110 = 0x0110,

    F71808E = 0x0901,
    F71811 = 0x1007,
    F71858 = 0x0507,
    F71862 = 0x0601,
    F71869 = 0x0814,
    F71869A = 0x1007,
    F71878AD = 0x1106,
    F71882 = 0x0541,
    F71889AD = 0x1005,
    F71889ED = 0x0909,
    F71889F = 0x0723,

    IT8613E = 0x8613,
    IT8620E = 0x8620,
    IT8628E = 0x8628,
    IT8631E = 0x8631,
    IT8655E = 0x8655,
    IT8665E = 0x8665,
    IT8686E = 0x8686,
    IT8688E = 0x8688,
    IT8689E = 0x8689,
    IT8695E = 0x8695,
    IT8705F = 0x8705,
    IT8712F = 0x8712,
    IT8716F = 0x8716,
    IT8718F = 0x8718,
    IT8720F = 0x8720,
    IT8721F = 0x8721,
    IT8726F = 0x8726,
    IT8728F = 0x8728,
    IT8771E = 0x8771,
    IT8772E = 0x8772,
    IT879XE = 0x8733,

    NCT610XD = 0xC452,
    NCT6771F = 0xB470,
    NCT6776F = 0xC330,
    NCT6779D = 0xC560,
    NCT6791D = 0xC803,
    NCT6792D = 0xC911,
    NCT6792DA = 0xC913,
    NCT6793D = 0xD121,
    NCT6795D = 0xD352,
    NCT6796D = 0xD423,
    NCT6796DR = 0xD42A,
    NCT6797D = 0xD451,
    NCT6798D = 0xD42B,
    NCT6686D = 0xD440,
    NCT6687D = 0xD592,
    NCT6683D = 0xC732,
    NCT6799D = 0xD802,

    W83627DHG = 0xA020,
    W83627DHGP = 0xB070,
    W83627EHF = 0x8800,
    W83627HF = 0x5200,
    W83627THF = 0x8280,
    W83667HG = 0xA510,
    W83667HGB = 0xB350,
    W83687THF = 0x8541
}

internal class ChipName
{
    public static string GetName(Chip chip)
    {
        switch (chip)
        {
            case Chip.ATK0110: return "Asus ATK0110";

            case Chip.F71858: return "Fintek F71858";
            case Chip.F71862: return "Fintek F71862";
            case Chip.F71869: return "Fintek F71869";
            case Chip.F71878AD: return "Fintek F71878AD";
            case Chip.F71869A: return "Fintek F71869A/F71811";
            case Chip.F71882: return "Fintek F71882";
            case Chip.F71889AD: return "Fintek F71889AD";
            case Chip.F71889ED: return "Fintek F71889ED";
            case Chip.F71889F: return "Fintek F71889F";
            case Chip.F71808E: return "Fintek F71808E";
            case Chip.IT8613E: return "ITE IT8613E";
            case Chip.IT8620E: return "ITE IT8620E";
            case Chip.IT8628E: return "ITE IT8628E";
            case Chip.IT8631E: return "ITE IT8631E";
            case Chip.IT8655E: return "ITE IT8655E";
            case Chip.IT8665E: return "ITE IT8665E";
            case Chip.IT8686E: return "ITE IT8686E";
            case Chip.IT8688E: return "ITE IT8688E";
            case Chip.IT8689E: return "ITE IT8689E";
            case Chip.IT8695E: return "ITE IT8695E";
            case Chip.IT8705F: return "ITE IT8705F";
            case Chip.IT8712F: return "ITE IT8712F";
            case Chip.IT8716F: return "ITE IT8716F";
            case Chip.IT8718F: return "ITE IT8718F";
            case Chip.IT8720F: return "ITE IT8720F";
            case Chip.IT8721F: return "ITE IT8721F";
            case Chip.IT8726F: return "ITE IT8726F";
            case Chip.IT8728F: return "ITE IT8728F";
            case Chip.IT8771E: return "ITE IT8771E";
            case Chip.IT8772E: return "ITE IT8772E";
            case Chip.IT879XE: return "ITE IT8792E/IT8795E";

            case Chip.NCT610XD: return "Nuvoton NCT6102D/NCT6104D/NCT6106D";
            case Chip.NCT6771F: return "Nuvoton NCT6771F";
            case Chip.NCT6776F: return "Nuvoton NCT6776F";
            case Chip.NCT6779D: return "Nuvoton NCT6779D";
            case Chip.NCT6791D: return "Nuvoton NCT6791D";
            case Chip.NCT6792D: return "Nuvoton NCT6792D";
            case Chip.NCT6792DA: return "Nuvoton NCT6792D-A";
            case Chip.NCT6793D: return "Nuvoton NCT6793D";
            case Chip.NCT6795D: return "Nuvoton NCT6795D";
            case Chip.NCT6796D: return "Nuvoton NCT6796D";
            case Chip.NCT6796DR: return "Nuvoton NCT6796D-R";
            case Chip.NCT6797D: return "Nuvoton NCT6797D";
            case Chip.NCT6798D: return "Nuvoton NCT6798D";
            case Chip.NCT6799D: return "Nuvoton NCT6799D";
            case Chip.NCT6686D: return "Nuvoton NCT6686D";
            case Chip.NCT6687D: return "Nuvoton NCT6687D";
            case Chip.NCT6683D: return "Nuvoton NCT6683D";

            case Chip.W83627DHG: return "Winbond W83627DHG";
            case Chip.W83627DHGP: return "Winbond W83627DHG-P";
            case Chip.W83627EHF: return "Winbond W83627EHF";
            case Chip.W83627HF: return "Winbond W83627HF";
            case Chip.W83627THF: return "Winbond W83627THF";
            case Chip.W83667HG: return "Winbond W83667HG";
            case Chip.W83667HGB: return "Winbond W83667HG-B";
            case Chip.W83687THF: return "Winbond W83687THF";

            default: return "Unknown";
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/EmbeddedController.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

public abstract class EmbeddedController : Hardware
{
    // If you are updating board information, please consider sharing your changes with the corresponding Linux driver.
    // You can do that at https://github.com/zeule/asus-ec-sensors or contribute directly to Linux HWMON.
    // If you are adding a new board, please share DSDT table for the board at https://github.com/zeule/asus-ec-sensors.
    // https://dortania.github.io/Getting-Started-With-ACPI/Manual/dump.html
    private static readonly BoardInfo[] _boards =
    {
        new(Model.PRIME_X470_PRO,
            BoardFamily.Amd400,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempVrm,
            ECSensor.TempVrm,
            ECSensor.FanCPUOpt,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.PRIME_X570_PRO,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempVrm,
            ECSensor.TempTSensor,
            ECSensor.FanChipset),
        new(Model.PROART_X570_CREATOR_WIFI,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempVrm,
            ECSensor.TempTSensor,
            ECSensor.FanCPUOpt,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.PRO_WS_X570_ACE,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempVrm,
            ECSensor.FanChipset,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(new[] { Model.ROG_CROSSHAIR_VIII_HERO, Model.ROG_CROSSHAIR_VIII_HERO_WIFI, Model.ROG_CROSSHAIR_VIII_FORMULA },
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanCPUOpt,
            ECSensor.FanChipset,
            ECSensor.FanWaterFlow,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.ROG_CROSSHAIR_VIII_DARK_HERO,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanCPUOpt,
            ECSensor.FanWaterFlow,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.ROG_CROSSHAIR_VIII_IMPACT,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.FanChipset,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.ROG_STRIX_B550_E_GAMING,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.FanCPUOpt),
        new(Model.ROG_STRIX_B550_I_GAMING,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.FanVrmHS,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.ROG_STRIX_X570_E_GAMING,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.FanChipset,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.ROG_STRIX_X570_F_GAMING,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.FanChipset),
        new(Model.ROG_STRIX_X570_I_GAMING,
            BoardFamily.Amd500,
            ECSensor.TempTSensor,
            ECSensor.FanVrmHS,
            ECSensor.FanChipset,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU,
            ECSensor.TempChipset,
            ECSensor.TempVrm),
        new(Model.ROG_STRIX_Z690_A_GAMING_WIFI_D4,
            BoardFamily.Intel600,
            ECSensor.TempTSensor,
            ECSensor.TempVrm),
        new(Model.ROG_MAXIMUS_Z690_EXTREME_GLACIAL,
            BoardFamily.Intel600,
            ECSensor.TempVrm,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.TempWaterBlockIn,
            ECSensor.FanWaterFlow),
        new(Model.ROG_MAXIMUS_Z790_HERO,
            BoardFamily.Intel700,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanWaterFlow),
        new(Model.Z170_A,
            BoardFamily.Intel100,
            ECSensor.TempTSensor,
            ECSensor.TempChipset,
            ECSensor.FanWaterPump,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.PRIME_Z690_A,
            BoardFamily.Intel600,
            ECSensor.TempTSensor,
            ECSensor.TempVrm)
    };

    private static readonly Dictionary<BoardFamily, Dictionary<ECSensor, EmbeddedControllerSource>> _knownSensors = new()
    {
        {
            BoardFamily.Amd400, new Dictionary<ECSensor, EmbeddedControllerSource>() // no chipset fans in this generation
            {
                { ECSensor.TempChipset, new EmbeddedControllerSource("Chipset", SensorType.Temperature, 0x003a) },
                { ECSensor.TempCPU, new EmbeddedControllerSource("CPU", SensorType.Temperature, 0x003b) },
                { ECSensor.TempMB, new EmbeddedControllerSource("Motherboard", SensorType.Temperature, 0x003c) },
                { ECSensor.TempTSensor, new EmbeddedControllerSource("T Sensor", SensorType.Temperature, 0x003d, blank: -40) },
                { ECSensor.TempVrm, new EmbeddedControllerSource("VRM", SensorType.Temperature, 0x003e) },
                { ECSensor.VoltageCPU, new EmbeddedControllerSource("CPU Core", SensorType.Voltage, 0x00a2, 2, factor: 1e-3f) },
                { ECSensor.FanCPUOpt, new EmbeddedControllerSource("CPU Optional Fan", SensorType.Fan, 0x00bc, 2) },
                { ECSensor.FanVrmHS, new EmbeddedControllerSource("VRM Heat Sink Fan", SensorType.Fan, 0x00b2, 2) },
                { ECSensor.FanWaterFlow, new EmbeddedControllerSource("Water flow", SensorType.Flow, 0x00b4, 2, factor: 1.0f / 42f * 60f) },
                { ECSensor.CurrCPU, new EmbeddedControllerSource("CPU", SensorType.Current, 0x00f4) },
                { ECSensor.TempWaterIn, new EmbeddedControllerSource("Water In", SensorType.Temperature, 0x010d, blank: -40) },
                { ECSensor.TempWaterOut, new EmbeddedControllerSource("Water Out", SensorType.Temperature, 0x010b, blank: -40) }
            }
        },
        {
            BoardFamily.Amd500, new Dictionary<ECSensor, EmbeddedControllerSource>
            {
                { ECSensor.TempChipset, new EmbeddedControllerSource("Chipset", SensorType.Temperature, 0x003a) },
                { ECSensor.TempCPU, new EmbeddedControllerSource("CPU", SensorType.Temperature, 0x003b) },
                { ECSensor.TempMB, new EmbeddedControllerSource("Motherboard", SensorType.Temperature, 0x003c) },
                { ECSensor.TempTSensor, new EmbeddedControllerSource("T Sensor", SensorType.Temperature, 0x003d, blank: -40) },
                { ECSensor.TempVrm, new EmbeddedControllerSource("VRM", SensorType.Temperature, 0x003e) },
                { ECSensor.VoltageCPU, new EmbeddedControllerSource("CPU Core", SensorType.Voltage, 0x00a2, 2, factor: 1e-3f) },
                { ECSensor.FanCPUOpt, new EmbeddedControllerSource("CPU Optional Fan", SensorType.Fan, 0x00b0, 2) },
                { ECSensor.FanVrmHS, new EmbeddedControllerSource("VRM Heat Sink Fan", SensorType.Fan, 0x00b2, 2) },
                { ECSensor.FanChipset, new EmbeddedControllerSource("Chipset Fan", SensorType.Fan, 0x00b4, 2) },
                // TODO: "why 42?" is a silly question, I know, but still, why? On the serious side, it might be 41.6(6)
                { ECSensor.FanWaterFlow, new EmbeddedControllerSource("Water flow", SensorType.Flow, 0x00bc, 2, factor: 1.0f / 42f * 60f) },
                { ECSensor.CurrCPU, new EmbeddedControllerSource("CPU", SensorType.Current, 0x00f4) },
                { ECSensor.TempWaterIn, new EmbeddedControllerSource("Water In", SensorType.Temperature, 0x0100, blank: -40) },
                { ECSensor.TempWaterOut, new EmbeddedControllerSource("Water Out", SensorType.Temperature, 0x0101, blank: -40) }
            }
        },
        {
            BoardFamily.Intel100, new Dictionary<ECSensor, EmbeddedControllerSource>
            {
                { ECSensor.TempChipset, new EmbeddedControllerSource("Chipset", SensorType.Temperature, 0x003a) },
                { ECSensor.TempTSensor, new EmbeddedControllerSource("T Sensor", SensorType.Temperature, 0x003d, blank: -40) },
                { ECSensor.FanWaterPump, new EmbeddedControllerSource("Water Pump", SensorType.Fan, 0x00bc, 2) },
                { ECSensor.CurrCPU, new EmbeddedControllerSource("CPU", SensorType.Current, 0x00f4) },
                { ECSensor.VoltageCPU, new EmbeddedControllerSource("CPU Core", SensorType.Voltage, 0x00a2, 2, factor: 1e-3f) }
            }
        },
        {
            BoardFamily.Intel600, new Dictionary<ECSensor, EmbeddedControllerSource>
            {
                { ECSensor.TempTSensor, new EmbeddedControllerSource("T Sensor", SensorType.Temperature, 0x003d, blank: -40) },
                { ECSensor.TempVrm, new EmbeddedControllerSource("VRM", SensorType.Temperature, 0x003e) },
                { ECSensor.TempWaterIn, new EmbeddedControllerSource("Water In", SensorType.Temperature, 0x0100, blank: -40) },
                { ECSensor.TempWaterOut, new EmbeddedControllerSource("Water Out", SensorType.Temperature, 0x0101, blank: -40) },
                { ECSensor.TempWaterBlockIn, new EmbeddedControllerSource("Water Block In", SensorType.Temperature, 0x0102, blank: -40) },
                { ECSensor.FanWaterFlow, new EmbeddedControllerSource("Water Flow", SensorType.Flow, 0x00be, 2, factor: 1.0f / 42f * 60f) } // todo: need validation for this calculation
            }
        },
        {
            BoardFamily.Intel700, new Dictionary<ECSensor, EmbeddedControllerSource>
            {
                { ECSensor.TempWaterIn, new EmbeddedControllerSource("Water In", SensorType.Temperature, 0x0100, blank: -40) },
                { ECSensor.TempWaterOut, new EmbeddedControllerSource("Water Out", SensorType.Temperature, 0x0101, blank: -40) },
                { ECSensor.FanWaterFlow, new EmbeddedControllerSource("Water Flow", SensorType.Flow, 0x00be, 2, factor: 1.0f / 42f * 60f) } // todo: need validation for this calculation
            }
        }
    };

    private readonly byte[] _data;
    private readonly ushort[] _registers;
    private readonly List<Sensor> _sensors;

    private readonly IReadOnlyList<EmbeddedControllerSource> _sources;

    protected EmbeddedController(IEnumerable<EmbeddedControllerSource> sources, ISettings settings) : base("Embedded Controller", new Identifier("lpc", "ec"), settings)
    {
        // sorting by address, which implies sorting by bank, for optimized EC access
        var sourcesList = sources.ToList();
        sourcesList.Sort((left, right) => left.Register.CompareTo(right.Register));
        _sources = sourcesList;
        var indices = new Dictionary<SensorType, int>();
        foreach (SensorType t in Enum.GetValues(typeof(SensorType)))
        {
            indices.Add(t, 0);
        }

        _sensors = new List<Sensor>();
        List<ushort> registers = new();
        foreach (EmbeddedControllerSource s in _sources)
        {
            int index = indices[s.Type];
            indices[s.Type] = index + 1;
            _sensors.Add(new Sensor(s.Name, index, s.Type, this, settings));
            for (int i = 0; i < s.Size; ++i)
            {
                registers.Add((ushort)(s.Register + i));
            }

            ActivateSensor(_sensors[_sensors.Count - 1]);
        }

        _registers = registers.ToArray();
        _data = new byte[_registers.Length];
    }

    public override HardwareType HardwareType => HardwareType.EmbeddedController;

    internal static EmbeddedController Create(Model model, ISettings settings)
    {
        var boards = _boards.Where(b => b.Models.Contains(model)).ToList();
        switch (boards.Count)
        {
            case 0:
                return null;
            case > 1:
                throw new MultipleBoardRecordsFoundException(model.ToString());
        }

        BoardInfo board = boards[0];
        IEnumerable<EmbeddedControllerSource> sources = board.Sensors.Select(ecs => _knownSensors[board.Family][ecs]);

        return Environment.OSVersion.Platform switch
        {
            PlatformID.Win32NT => new WindowsEmbeddedController(sources, settings),
            _ => null
        };
    }

    public override void Update()
    {
        if (!TryUpdateData())
        {
            // just skip this update cycle?
            return;
        }

        int readRegister = 0;
        for (int si = 0; si < _sensors.Count; ++si)
        {
            int val = _sources[si].Size switch
            {
                1 => unchecked((sbyte)_data[readRegister]),
                2 => unchecked((short)((_data[readRegister] << 8) + _data[readRegister + 1])),
                _ => 0
            };

            readRegister += _sources[si].Size;

            _sensors[si].Value = val != _sources[si].Blank ? val * _sources[si].Factor : null;
        }
    }

    public override string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("EC " + GetType().Name);
        r.AppendLine("Embedded Controller Registers");
        r.AppendLine();
        r.AppendLine("      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
        r.AppendLine();

        try
        {
            using IEmbeddedControllerIO embeddedControllerIO = AcquireIOInterface();
            ushort[] src = new ushort[0x100];
            byte[] data = new byte[0x100];
            for (ushort i = 0; i < src.Length; ++i)
            {
                src[i] = i;
            }

            embeddedControllerIO.Read(src, data);
            for (int i = 0; i <= 0xF; ++i)
            {
                r.Append(" ");
                r.Append((i << 4).ToString("X2", CultureInfo.InvariantCulture));
                r.Append("  ");
                for (int j = 0; j <= 0xF; ++j)
                {
                    byte address = (byte)(i << 4 | j);
                    r.Append(" ");
                    r.Append(data[address].ToString("X2", CultureInfo.InvariantCulture));
                }

                r.AppendLine();
            }
        }
        catch (IOException e)
        {
            r.AppendLine(e.Message);
        }

        return r.ToString();
    }

    protected abstract IEmbeddedControllerIO AcquireIOInterface();

    private bool TryUpdateData()
    {
        try
        {
            using IEmbeddedControllerIO embeddedControllerIO = AcquireIOInterface();
            embeddedControllerIO.Read(_registers, _data);
            return true;
        }
        catch (IOException)
        {
            return false;
        }
    }

    private enum ECSensor
    {
        /// <summary>Chipset temperature [℃]</summary>
        TempChipset,

        /// <summary>CPU temperature [℃]</summary>
        TempCPU,

        /// <summary>motherboard temperature [℃]</summary>
        TempMB,

        /// <summary>"T_Sensor" temperature sensor reading [℃]</summary>
        TempTSensor,

        /// <summary>VRM temperature [℃]</summary>
        TempVrm,

        /// <summary>CPU Core voltage [mV]</summary>
        VoltageCPU,

        /// <summary>CPU_Opt fan [RPM]</summary>
        FanCPUOpt,

        /// <summary>VRM heat sink fan [RPM]</summary>
        FanVrmHS,

        /// <summary>Chipset fan [RPM]</summary>
        FanChipset,

        /// <summary>Water Pump [RPM]</summary>
        FanWaterPump,

        /// <summary>Water flow sensor reading [RPM]</summary>
        FanWaterFlow,

        /// <summary>CPU current [A]</summary>
        CurrCPU,

        /// <summary>"Water_In" temperature sensor reading [℃]</summary>
        TempWaterIn,

        /// <summary>"Water_Out" temperature sensor reading [℃]</summary>
        TempWaterOut,

        /// <summary>Water block temperature sensor reading [℃]</summary>
        TempWaterBlockIn,
        Max
    }

    private enum BoardFamily
    {
        Amd400,
        Amd500,
        Intel100,
        Intel600,
        Intel700
    }

    private struct BoardInfo
    {
        public BoardInfo(Model[] models, BoardFamily family, params ECSensor[] sensors)
        {
            Models = models;
            Family = family;
            Sensors = sensors;
        }

        public BoardInfo(Model model, BoardFamily family, params ECSensor[] sensors)
        {
            Models = new[] { model };
            Family = family;
            Sensors = sensors;
        }

        public Model[] Models { get; }

        public BoardFamily Family { get; }

        public ECSensor[] Sensors { get; }
    }

    public class IOException : System.IO.IOException
    {
        public IOException(string message) : base($"ACPI embedded controller I/O error: {message}")
        { }
    }

    public class BadConfigurationException : Exception
    {
        public BadConfigurationException(string message) : base(message)
        { }
    }

    public class MultipleBoardRecordsFoundException : BadConfigurationException
    {
        public MultipleBoardRecordsFoundException(string model) : base($"Multiple board records refer to the same model '{model}'")
        { }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/EmbeddedControllerReader.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

public delegate float EmbeddedControllerReader(IEmbeddedControllerIO ecIO, ushort register);
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/EmbeddedControllerSource.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

public class EmbeddedControllerSource
{
    public EmbeddedControllerSource(string name, SensorType type, ushort register, byte size = 1, float factor = 1.0f, int blank = int.MaxValue)
    {
        Name = name;

        Register = register;
        Size = size;
        Type = type;
        Factor = factor;
        Blank = blank;
    }

    public string Name { get; }
    public ushort Register { get; }
    public byte Size { get; }
    public float Factor { get; }

    public int Blank { get; }

    public EmbeddedControllerReader Reader { get; }

    public SensorType Type { get; }
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/IEmbeddedControllerIO.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

public interface IEmbeddedControllerIO : IDisposable
{
    void Read(ushort[] registers, byte[] data);
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/WindowsEmbeddedController.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

public class WindowsEmbeddedController : EmbeddedController
{
    public WindowsEmbeddedController(IEnumerable<EmbeddedControllerSource> sources, ISettings settings) : base(sources, settings)
    { }

    protected override IEmbeddedControllerIO AcquireIOInterface()
    {
        return new WindowsEmbeddedControllerIO();
    }
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/WindowsEmbeddedControllerIO.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Diagnostics;
using System.Threading;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

/// <summary>
/// An unsafe but universal implementation for the ACPI Embedded Controller IO interface for Windows
/// </summary>
/// <remarks>
/// It is unsafe because of possible race condition between this application and the PC firmware when
/// writing to the EC registers. For a safe approach ACPI/WMI methods have to be used, but those are
/// different for each motherboard model.
/// </remarks>
public class WindowsEmbeddedControllerIO : IEmbeddedControllerIO
{
    private const int FailuresBeforeSkip = 20;
    private const int MaxRetries = 5;

    // implementation 
    private const int WaitSpins = 50;
    private bool _disposed;

    private int _waitReadFailures;

    public WindowsEmbeddedControllerIO()
    {
        if (!Ring0.WaitEcMutex(10))
        {
            throw new BusMutexLockingFailedException();
        }
    }

    public void Read(ushort[] registers, byte[] data)
    {
        Trace.Assert(registers.Length <= data.Length, 
                     "data buffer length has to be greater or equal to the registers array length");

        byte bank = 0;
        byte prevBank = SwitchBank(bank);

        // oops... somebody else is working with the EC too
        Trace.WriteLineIf(prevBank != 0, "Concurrent access to the ACPI EC detected.\nRace condition possible.");

        // read registers minimizing bank switches.
        for (int i = 0; i < registers.Length; i++)
        {
            byte regBank = (byte)(registers[i] >> 8);
            byte regIndex = (byte)(registers[i] & 0xFF);
            // registers are sorted by bank
            if (regBank > bank)
            {
                bank = SwitchBank(regBank);
            }
            data[i] = ReadByte(regIndex);
        }

        SwitchBank(prevBank);
    }

    private byte ReadByte(byte register)
    {
        return ReadLoop<byte>(register, ReadByteOp);
    }

    private void WriteByte(byte register, byte value)
    {
        WriteLoop(register, value, WriteByteOp);
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;
            Ring0.ReleaseEcMutex();
        }
    }

    private byte SwitchBank(byte bank)
    {
        byte previous = ReadByte(0xFF);
        WriteByte(0xFF, bank);
        return previous;
    }

    private TResult ReadLoop<TResult>(byte register, ReadOp<TResult> op) where TResult : new()
    {
        TResult result = new();

        for (int i = 0; i < MaxRetries; i++)
        {
            if (op(register, out result))
            {
                return result;
            }
        }

        return result;
    }

    private void WriteLoop<TValue>(byte register, TValue value, WriteOp<TValue> op)
    {
        for (int i = 0; i < MaxRetries; i++)
        {
            if (op(register, value))
            {
                return;
            }
        }
    }

    private bool WaitForStatus(Status status, bool isSet)
    {
        for (int i = 0; i < WaitSpins; i++)
        {
            byte value = ReadIOPort(Port.Command);

            if (((byte)status & (!isSet ? value : (byte)~value)) == 0)
            {
                return true;
            }

            Thread.Sleep(1);
        }

        return false;
    }

    private bool WaitRead()
    {
        if (_waitReadFailures > FailuresBeforeSkip)
        {
            return true;
        }

        if (WaitForStatus(Status.OutputBufferFull, true))
        {
            _waitReadFailures = 0;
            return true;
        }

        _waitReadFailures++;
        return false;
    }

    private bool WaitWrite()
    {
        return WaitForStatus(Status.InputBufferFull, false);
    }

    private byte ReadIOPort(Port port)
    {
        return Ring0.ReadIoPort((uint)port);
    }

    private void WriteIOPort(Port port, byte datum)
    {
        Ring0.WriteIoPort((uint)port, datum);
    }

    public class BusMutexLockingFailedException : EmbeddedController.IOException
    {
        public BusMutexLockingFailedException()
            : base("could not lock ISA bus mutex")
        { }
    }

    private delegate bool ReadOp<TParam>(byte register, out TParam p);

    private delegate bool WriteOp<in TParam>(byte register, TParam p);

    // see the ACPI specification chapter 12
    private enum Port : byte
    {
        Command = 0x66,
        Data = 0x62
    }

    private enum Command : byte
    {
        Read = 0x80, // RD_EC
        Write = 0x81, // WR_EC
        BurstEnable = 0x82, // BE_EC
        BurstDisable = 0x83, // BD_EC
        Query = 0x84 // QR_EC
    }

    private enum Status : byte
    {
        OutputBufferFull = 0x01, // EC_OBF
        InputBufferFull = 0x02, // EC_IBF
        Command = 0x08, // CMD
        BurstMode = 0x10, // BURST
        SciEventPending = 0x20, // SCI_EVT
        SmiEventPending = 0x40 // SMI_EVT
    }

    #region Read/Write ops

    protected bool ReadByteOp(byte register, out byte value)
    {
        if (WaitWrite())
        {
            WriteIOPort(Port.Command, (byte)Command.Read);

            if (WaitWrite())
            {
                WriteIOPort(Port.Data, register);

                if (WaitWrite() && WaitRead())
                {
                    value = ReadIOPort(Port.Data);
                    return true;
                }
            }
        }

        value = 0;
        return false;
    }

    protected bool WriteByteOp(byte register, byte value)
    {
        if (WaitWrite())
        {
            WriteIOPort(Port.Command, (byte)Command.Write);
            if (WaitWrite())
            {
                WriteIOPort(Port.Data, register);
                if (WaitWrite())
                {
                    WriteIOPort(Port.Data, value);
                    return true;
                }
            }
        }

        return false;
    }

    #endregion
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/F718XX.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;
using System.Text;

// ReSharper disable once InconsistentNaming

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class F718XX : ISuperIO
{
    private readonly ushort _address;
    private readonly byte[] _initialFanPwmControl = new byte[4];
    private readonly bool[] _restoreDefaultFanPwmControlRequired = new bool[4];

    public F718XX(Chip chip, ushort address)
    {
        _address = address;
        Chip = chip;

        Voltages = new float?[chip == Chip.F71858 ? 3 : 9];
        Temperatures = new float?[chip == Chip.F71808E ? 2 : 3];
        Fans = new float?[chip is Chip.F71882 or Chip.F71858 ? 4 : 3];
        Controls = new float?[chip == Chip.F71878AD ? 3 : 0];
    }

    public Chip Chip { get; }

    public float?[] Controls { get; }

    public float?[] Fans { get; }

    public float?[] Temperatures { get; }

    public float?[] Voltages { get; }

    public byte? ReadGpio(int index)
    {
        return null;
    }

    public void WriteGpio(int index, byte value)
    { }

    public void SetControl(int index, byte? value)
    {
        if (index < 0 || index >= Controls.Length)
            throw new ArgumentOutOfRangeException(nameof(index));

        if (!Ring0.WaitIsaBusMutex(10))
            return;

        if (value.HasValue)
        {
            SaveDefaultFanPwmControl(index);

            WriteByte(FAN_PWM_REG[index], value.Value);
        }
        else
        {
            RestoreDefaultFanPwmControl(index);
        }

        Ring0.ReleaseIsaBusMutex();
    }

    public string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("LPC " + GetType().Name);
        r.AppendLine();
        r.Append("Base Address: 0x");
        r.AppendLine(_address.ToString("X4", CultureInfo.InvariantCulture));
        r.AppendLine();

        if (!Ring0.WaitIsaBusMutex(100))
            return r.ToString();

        r.AppendLine("Hardware Monitor Registers");
        r.AppendLine();
        r.AppendLine("      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
        r.AppendLine();
        for (int i = 0; i <= 0xF; i++)
        {
            r.Append(" ");
            r.Append((i << 4).ToString("X2", CultureInfo.InvariantCulture));
            r.Append("  ");
            for (int j = 0; j <= 0xF; j++)
            {
                r.Append(" ");
                r.Append(ReadByte((byte)((i << 4) | j)).ToString("X2",
                                                                 CultureInfo.InvariantCulture));
            }

            r.AppendLine();
        }

        r.AppendLine();

        Ring0.ReleaseIsaBusMutex();
        return r.ToString();
    }

    public void Update()
    {
        if (!Ring0.WaitIsaBusMutex(10))
            return;

        for (int i = 0; i < Voltages.Length; i++)
        {
            if (Chip == Chip.F71808E && i == 6)
            {
                // 0x26 is reserved on F71808E
                Voltages[i] = 0;
            }
            else
            {
                int value = ReadByte((byte)(VOLTAGE_BASE_REG + i));
                Voltages[i] = 0.008f * value;
            }
        }

        for (int i = 0; i < Temperatures.Length; i++)
        {
            switch (Chip)
            {
                case Chip.F71858:
                    {
                        int tableMode = 0x3 & ReadByte(TEMPERATURE_CONFIG_REG);
                        int high = ReadByte((byte)(TEMPERATURE_BASE_REG + (2 * i)));
                        int low = ReadByte((byte)(TEMPERATURE_BASE_REG + (2 * i) + 1));
                        if (high is not 0xbb and not 0xcc)
                        {
                            int bits = 0;
                            switch (tableMode)
                            {
                                case 0:
                                    break;
                                case 1:
                                    bits = 0;
                                    break;
                                case 2:
                                    bits = (high & 0x80) << 8;
                                    break;
                                case 3:
                                    bits = (low & 0x01) << 15;
                                    break;
                            }

                            bits |= high << 7;
                            bits |= (low & 0xe0) >> 1;
                            short value = (short)(bits & 0xfff0);
                            Temperatures[i] = value / 128.0f;
                        }
                        else
                        {
                            Temperatures[i] = null;
                        }
                    }

                    break;
                default:
                    {
                        sbyte value = (sbyte)ReadByte((byte)(TEMPERATURE_BASE_REG + (2 * (i + 1))));
                        if (value is < sbyte.MaxValue and > 0)
                            Temperatures[i] = value;
                        else
                            Temperatures[i] = null;
                    }

                    break;
            }
        }

        for (int i = 0; i < Fans.Length; i++)
        {
            int value = ReadByte(FAN_TACHOMETER_REG[i]) << 8;
            value |= ReadByte((byte)(FAN_TACHOMETER_REG[i] + 1));

            if (value > 0)
                Fans[i] = value < 0x0fff ? 1.5e6f / value : 0;
            else
                Fans[i] = null;
        }

        for (int i = 0; i < Controls.Length; i++)
        {
            Controls[i] = ReadByte((byte)(PWM_VALUES_OFFSET + i)) * 100.0f / 0xFF;
        }

        Ring0.ReleaseIsaBusMutex();
    }

    private void SaveDefaultFanPwmControl(int index)
    {
        if (!_restoreDefaultFanPwmControlRequired[index])
        {
            _initialFanPwmControl[index] = ReadByte(FAN_PWM_REG[index]);
            _restoreDefaultFanPwmControlRequired[index] = true;
        }
    }

    private void RestoreDefaultFanPwmControl(int index)
    {
        if (_restoreDefaultFanPwmControlRequired[index])
        {
            WriteByte(FAN_PWM_REG[index], _initialFanPwmControl[index]);
            _restoreDefaultFanPwmControlRequired[index] = false;
        }
    }

    private byte ReadByte(byte register)
    {
        Ring0.WriteIoPort((ushort)(_address + ADDRESS_REGISTER_OFFSET), register);
        return Ring0.ReadIoPort((ushort)(_address + DATA_REGISTER_OFFSET));
    }

    private void WriteByte(byte register, byte value)
    {
        Ring0.WriteIoPort((ushort)(_address + ADDRESS_REGISTER_OFFSET), register);
        Ring0.WriteIoPort((ushort)(_address + DATA_REGISTER_OFFSET), value);
    }

    // ReSharper disable InconsistentNaming
#pragma warning disable IDE1006 // Naming Styles

    private const byte ADDRESS_REGISTER_OFFSET = 0x05;
    private const byte DATA_REGISTER_OFFSET = 0x06;
    private const byte PWM_VALUES_OFFSET = 0x2D;
    private const byte TEMPERATURE_BASE_REG = 0x70;
    private const byte TEMPERATURE_CONFIG_REG = 0x69;

    private const byte VOLTAGE_BASE_REG = 0x20;
    private readonly byte[] FAN_PWM_REG = { 0xA3, 0xB3, 0xC3, 0xD3 };
    private readonly byte[] FAN_TACHOMETER_REG = { 0xA0, 0xB0, 0xC0, 0xD0 };

    // ReSharper restore InconsistentNaming
#pragma warning restore IDE1006 // Naming Styles
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/ISuperIO.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal interface ISuperIO
{
    Chip Chip { get; }

    float?[] Controls { get; }

    float?[] Fans { get; }

    float?[] Temperatures { get; }

    // get voltage, temperature, fan and control channel values
    float?[] Voltages { get; }

    // set control value, null = auto
    void SetControl(int index, byte? value);

    // read and write GPIO
    byte? ReadGpio(int index);

    void WriteGpio(int index, byte value);

    string GetReport();

    void Update();
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/IT87XX.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;
using System.Text;

// ReSharper disable once InconsistentNaming

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class IT87XX : ISuperIO
{
    private const int MaxFanHeaders = 6;
    private readonly ushort _address;
    private readonly ushort _addressReg;
    private readonly int _bankCount;
    private readonly ushort _dataReg;
    private readonly bool[] _fansDisabled = Array.Empty<bool>();
    private readonly ushort _gpioAddress;
    private readonly int _gpioCount;
    private readonly bool _has16BitFanCounter;
    private readonly bool _hasExtReg;
    private readonly bool[] _initialFanOutputModeEnabled = new bool[3]; // Initial Fan Controller Main Control Register value. 
    private readonly byte[] _initialFanPwmControl = new byte[MaxFanHeaders]; // This will also store the 2nd control register value.
    private readonly byte[] _initialFanPwmControlExt = new byte[MaxFanHeaders];
    private readonly bool[] _restoreDefaultFanPwmControlRequired = new bool[MaxFanHeaders];
    private readonly byte _version;
    private readonly float _voltageGain;

    private bool SupportsMultipleBanks => _bankCount > 1;

    public IT87XX(Chip chip, ushort address, ushort gpioAddress, byte version)
    {
        _address = address;
        _version = version;
        _addressReg = (ushort)(address + ADDRESS_REGISTER_OFFSET);
        _dataReg = (ushort)(address + DATA_REGISTER_OFFSET);
        _gpioAddress = gpioAddress;

        Chip = chip;

        // Check vendor id
        byte vendorId = ReadByte(VENDOR_ID_REGISTER, out bool valid);
        if (!valid)
            return;

        bool hasMatchingVendorId = false;
        foreach (byte iteVendorId in ITE_VENDOR_IDS)
        {
            if (iteVendorId == vendorId)
            {
                hasMatchingVendorId = true;
                break;
            }
        }

        if (!hasMatchingVendorId)
            return;

        // Bit 0x10 of the configuration register should always be 1
        byte configuration = ReadByte(CONFIGURATION_REGISTER, out valid);
        if (!valid || ((configuration & 0x10) == 0 && chip != Chip.IT8655E && chip != Chip.IT8665E))
            return;

        FAN_PWM_CTRL_REG = chip == Chip.IT8665E
            ? new byte[] { 0x15, 0x16, 0x17, 0x1e, 0x1f }
            : new byte[] { 0x15, 0x16, 0x17, 0x7f, 0xa7, 0xaf };

        _bankCount = chip switch
        {
            Chip.IT8689E => 4,
            _ => 1
        };

        _hasExtReg = chip is Chip.IT8721F or
            Chip.IT8728F or
            Chip.IT8665E or
            Chip.IT8686E or
            Chip.IT8688E or
            Chip.IT8689E or
            Chip.IT8695E or
            Chip.IT8628E or
            Chip.IT8620E or
            Chip.IT8613E or
            Chip.IT879XE or
            Chip.IT8655E or
            Chip.IT8631E;

        switch (chip)
        {
            case Chip.IT8613E:
                Voltages = new float?[10];
                Temperatures = new float?[4];
                Fans = new float?[5];
                Controls = new float?[4];
                break;

            case Chip.IT8628E:
                Voltages = new float?[10];
                Temperatures = new float?[6];
                Fans = new float?[6];
                Controls = new float?[6];
                break;

            case Chip.IT8631E:
                Voltages = new float?[9];
                Temperatures = new float?[2];
                Fans = new float?[2];
                Controls = new float?[2];
                break;

            case Chip.IT8665E:
            case Chip.IT8686E:
                Voltages = new float?[10];
                Temperatures = new float?[6];
                Fans = new float?[6];
                Controls = new float?[5];
                break;

            case Chip.IT8688E:
                Voltages = new float?[11];
                Temperatures = new float?[6];
                Fans = new float?[6];
                Controls = new float?[5];
                break;

            case Chip.IT8689E:
                Voltages = new float?[10];
                Temperatures = new float?[6];
                Fans = new float?[6];
                Controls = new float?[6];
                break;

            case Chip.IT8695E:
                Voltages = new float?[6];
                Temperatures = new float?[3];
                Fans = new float?[3];
                Controls = new float?[3];
                break;

            case Chip.IT8655E:
                Voltages = new float?[9];
                Temperatures = new float?[6];
                Fans = new float?[3];
                Controls = new float?[3];
                break;

            case Chip.IT879XE:
                Voltages = new float?[9];
                Temperatures = new float?[3];
                Fans = new float?[3];
                Controls = new float?[3];
                break;

            case Chip.IT8705F:
                Voltages = new float?[9];
                Temperatures = new float?[3];
                Fans = new float?[3];
                Controls = new float?[3];
                break;

            default:
                Voltages = new float?[9];
                Temperatures = new float?[3];
                Fans = new float?[5];
                Controls = new float?[3];
                break;
        }

        _fansDisabled = new bool[Fans.Length];

        // IT8620E, IT8628E, IT8721F, IT8728F, IT8772E and IT8686E use a 12mV resolution.
        // All others 16mV.
        _voltageGain = chip switch
        {
            Chip.IT8613E or Chip.IT8620E or Chip.IT8628E or Chip.IT8631E or Chip.IT8721F or Chip.IT8728F or Chip.IT8771E or Chip.IT8772E or Chip.IT8686E or Chip.IT8688E or Chip.IT8689E => 0.012f,
            Chip.IT8695E => 11f / 1000f,
            Chip.IT8655E or Chip.IT8665E or Chip.IT879XE => 0.0109f,
            _ => 0.016f
        };

        // Older IT8705F and IT8721F revisions do not have 16-bit fan counters.
        _has16BitFanCounter = (chip != Chip.IT8705F || version >= 3) && (chip != Chip.IT8712F || version >= 8);

        // Disable any fans that aren't set with 16-bit fan counters
        if (_has16BitFanCounter)
        {
            int modes = ReadByte(FAN_TACHOMETER_16BIT_REGISTER, out valid);

            if (!valid)
                return;

            if (Fans.Length >= 5)
            {
                _fansDisabled[3] = (modes & (1 << 4)) == 0;
                _fansDisabled[4] = (modes & (1 << 5)) == 0;
            }

            if (Fans.Length >= 6)
                _fansDisabled[5] = (modes & (1 << 2)) == 0;
        }

        // Set the number of GPIO sets
        _gpioCount = chip switch
        {
            Chip.IT8712F or Chip.IT8716F or Chip.IT8718F or Chip.IT8726F => 5,
            Chip.IT8720F or Chip.IT8721F => 8,
            _ => 0
        };
    }

    public Chip Chip { get; }

    public float?[] Controls { get; } = Array.Empty<float?>();

    public float?[] Fans { get; } = Array.Empty<float?>();

    public float?[] Temperatures { get; } = Array.Empty<float?>();

    public float?[] Voltages { get; } = Array.Empty<float?>();

    public byte? ReadGpio(int index)
    {
        if (index >= _gpioCount)
            return null;

        return Ring0.ReadIoPort((ushort)(_gpioAddress + index));
    }

    public void WriteGpio(int index, byte value)
    {
        if (index >= _gpioCount)
            return;

        Ring0.WriteIoPort((ushort)(_gpioAddress + index), value);
    }

    public void SetControl(int index, byte? value)
    {
        if (index < 0 || index >= Controls.Length)
            throw new ArgumentOutOfRangeException(nameof(index));

        if (!Ring0.WaitIsaBusMutex(10))
            return;

        if (value.HasValue)
        {
            SaveDefaultFanPwmControl(index);

            if (index < 3 && !_initialFanOutputModeEnabled[index])
                WriteByte(FAN_MAIN_CTRL_REG, (byte)(ReadByte(FAN_MAIN_CTRL_REG, out _) | (1 << index)));

            if (_hasExtReg)
            {
                if (Chip == Chip.IT8689E)
                {
                    WriteByte(FAN_PWM_CTRL_REG[index], 0x7F);
                }
                else
                {
                    WriteByte(FAN_PWM_CTRL_REG[index], (byte)(_initialFanPwmControl[index] & 0x7F));
                }
                WriteByte(FAN_PWM_CTRL_EXT_REG[index], value.Value);
            }
            else
            {
                WriteByte(FAN_PWM_CTRL_REG[index], (byte)(value.Value >> 1));
            }
        }
        else
        {
            RestoreDefaultFanPwmControl(index);
        }

        Ring0.ReleaseIsaBusMutex();
    }

    public string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("LPC " + GetType().Name);
        r.AppendLine();
        r.Append("Chip ID: 0x");
        r.AppendLine(Chip.ToString("X"));
        r.Append("Chip Version: 0x");
        r.AppendLine(_version.ToString("X", CultureInfo.InvariantCulture));
        r.Append("Base Address: 0x");
        r.AppendLine(_address.ToString("X4", CultureInfo.InvariantCulture));
        r.Append("GPIO Address: 0x");
        r.AppendLine(_gpioAddress.ToString("X4", CultureInfo.InvariantCulture));
        r.AppendLine();

        if (!Ring0.WaitIsaBusMutex(100))
            return r.ToString();

        // dump memory of all banks if supported by chip
        for (byte b = 0; b < _bankCount; b++)
        {
            if (SupportsMultipleBanks && b > 0)
            {
                SelectBank(b);
            }
            r.AppendLine($"Environment Controller Registers Bank {b}");
            r.AppendLine();
            r.AppendLine("      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
            r.AppendLine();
            for (int i = 0; i <= 0xA; i++)
            {
                r.Append(" ");
                r.Append((i << 4).ToString("X2", CultureInfo.InvariantCulture));
                r.Append("  ");
                for (int j = 0; j <= 0xF; j++)
                {
                    r.Append(" ");
                    byte value = ReadByte((byte)((i << 4) | j), out bool valid);
                    r.Append(valid ? value.ToString("X2", CultureInfo.InvariantCulture) : "??");
                }

                r.AppendLine();
            }

            r.AppendLine();
        }

        if (SupportsMultipleBanks)
        {
            SelectBank(0);
        }

        r.AppendLine();

        r.AppendLine("GPIO Registers");
        r.AppendLine();
        for (int i = 0; i < _gpioCount; i++)
        {
            r.Append(" ");
            r.Append(ReadGpio(i)?.ToString("X2", CultureInfo.InvariantCulture));
        }

        r.AppendLine();
        r.AppendLine();
        Ring0.ReleaseIsaBusMutex();
        return r.ToString();
    }

    /// <summary>
    /// Selects another bank. Memory from 0x10-0xAF swaps to data from new bank.
    /// Beware to select the default bank 0 after changing.
    /// Bank selection is reset after power cycle.
    /// </summary>
    /// <param name="bankIndex">New bank index. Can be a value of 0-3.</param>
    private void SelectBank(byte bankIndex)
    {
        if (bankIndex >= _bankCount)
            return; // current chip does not support that many banks

        // hard cap SelectBank to 2 bit values. If we ever have chips with more bank bits rewrite this method.
        bankIndex &= 0x3;

        byte value = ReadByte(BANK_REGISTER, out bool valid);
        if (valid)
        {
            value &= 0x9F;
            value |= (byte)(bankIndex << 5);
            WriteByte(BANK_REGISTER, value);
        }
    }

    public void Update()
    {
        if (!Ring0.WaitIsaBusMutex(10))
            return;

        for (int i = 0; i < Voltages.Length; i++)
        {
            float value = _voltageGain * ReadByte((byte)(VOLTAGE_BASE_REG + i), out bool valid);

            if (!valid)
                continue;

            if (value > 0)
                Voltages[i] = value;
            else
                Voltages[i] = null;
        }

        for (int i = 0; i < Temperatures.Length; i++)
        {
            sbyte value = (sbyte)ReadByte((byte)(TEMPERATURE_BASE_REG + i), out bool valid);
            if (!valid)
                continue;

            if (value is < sbyte.MaxValue and > 0)
                Temperatures[i] = value;
            else
                Temperatures[i] = null;
        }

        if (_has16BitFanCounter)
        {
            for (int i = 0; i < Fans.Length; i++)
            {
                if (_fansDisabled[i])
                    continue;

                int value = ReadByte(FAN_TACHOMETER_REG[i], out bool valid);
                if (!valid)
                    continue;

                value |= ReadByte(FAN_TACHOMETER_EXT_REG[i], out valid) << 8;
                if (!valid)
                    continue;

                if (value > 0x3f)
                    Fans[i] = value < 0xffff ? 1.35e6f / (value * 2) : 0;
                else
                    Fans[i] = null;
            }
        }
        else
        {
            for (int i = 0; i < Fans.Length; i++)
            {
                int value = ReadByte(FAN_TACHOMETER_REG[i], out bool valid);
                if (!valid)
                    continue;

                int divisor = 2;
                if (i < 2)
                {
                    int divisors = ReadByte(FAN_TACHOMETER_DIVISOR_REGISTER, out valid);
                    if (!valid)
                        continue;

                    divisor = 1 << ((divisors >> (3 * i)) & 0x7);
                }

                if (value > 0)
                    Fans[i] = value < 0xff ? 1.35e6f / (value * divisor) : 0;
                else
                    Fans[i] = null;
            }
        }

        for (int i = 0; i < Controls.Length; i++)
        {
            byte value = ReadByte(FAN_PWM_CTRL_REG[i], out bool valid);
            if (!valid)
                continue;

            if ((value & 0x80) > 0)
            {
                // Automatic operation (value can't be read).
                Controls[i] = null;
            }
            else
            {
                // Software operation.
                if (_hasExtReg)
                {
                    value = ReadByte(FAN_PWM_CTRL_EXT_REG[i], out valid);
                    if (valid)
                        Controls[i] = (float)Math.Round(value * 100.0f / 0xFF);
                }
                else
                {
                    Controls[i] = (float)Math.Round((value & 0x7F) * 100.0f / 0x7F);
                }
            }
        }

        Ring0.ReleaseIsaBusMutex();
    }

    private byte ReadByte(byte register, out bool valid)
    {
        Ring0.WriteIoPort(_addressReg, register);
        byte value = Ring0.ReadIoPort(_dataReg);
        valid = register == Ring0.ReadIoPort(_addressReg) || Chip == Chip.IT8688E;
        // IT8688E doesn't return the value we wrote to
        // addressReg when we read it back.

        return value;
    }

    private void WriteByte(byte register, byte value)
    {
        Ring0.WriteIoPort(_addressReg, register);
        Ring0.WriteIoPort(_dataReg, value);
        Ring0.ReadIoPort(_addressReg);
    }

    private void SaveDefaultFanPwmControl(int index)
    {
        if (!_restoreDefaultFanPwmControlRequired[index])
        {
            _initialFanPwmControl[index] = ReadByte(FAN_PWM_CTRL_REG[index], out bool _);

            if (index < 3)
                _initialFanOutputModeEnabled[index] = ReadByte(FAN_MAIN_CTRL_REG, out bool _) != 0; // Save default control reg value.

            if (_hasExtReg)
                _initialFanPwmControlExt[index] = ReadByte(FAN_PWM_CTRL_EXT_REG[index], out _);
        }

        _restoreDefaultFanPwmControlRequired[index] = true;
    }

    private void RestoreDefaultFanPwmControl(int index)
    {
        if (_restoreDefaultFanPwmControlRequired[index])
        {
            WriteByte(FAN_PWM_CTRL_REG[index], _initialFanPwmControl[index]);

            if (index < 3)
            {
                byte value = ReadByte(FAN_MAIN_CTRL_REG, out _);

                bool isEnabled = (value & (1 << index)) != 0;
                if (isEnabled != _initialFanOutputModeEnabled[index])
                    WriteByte(FAN_MAIN_CTRL_REG, (byte)(value ^ (1 << index)));
            }

            if (_hasExtReg)
                WriteByte(FAN_PWM_CTRL_EXT_REG[index], _initialFanPwmControlExt[index]);

            _restoreDefaultFanPwmControlRequired[index] = false;
        }
    }

    // ReSharper disable InconsistentNaming
#pragma warning disable IDE1006 // Naming Styles

    private const byte ADDRESS_REGISTER_OFFSET = 0x05;

    private const byte CONFIGURATION_REGISTER = 0x00;
    private const byte DATA_REGISTER_OFFSET = 0x06;
    private const byte BANK_REGISTER = 0x06; // bit 5-6 define selected bank
    private const byte FAN_TACHOMETER_16BIT_REGISTER = 0x0C;
    private const byte FAN_TACHOMETER_DIVISOR_REGISTER = 0x0B;

    private readonly byte[] ITE_VENDOR_IDS = { 0x90, 0x7F };

    private const byte TEMPERATURE_BASE_REG = 0x29;
    private const byte VENDOR_ID_REGISTER = 0x58;
    private const byte VOLTAGE_BASE_REG = 0x20;

    private readonly byte[] FAN_PWM_CTRL_REG;
    private readonly byte[] FAN_PWM_CTRL_EXT_REG = { 0x63, 0x6b, 0x73, 0x7b, 0xa3, 0xab };
    private readonly byte[] FAN_TACHOMETER_EXT_REG = { 0x18, 0x19, 0x1a, 0x81, 0x83, 0x4d };
    private readonly byte[] FAN_TACHOMETER_REG = { 0x0d, 0x0e, 0x0f, 0x80, 0x82, 0x4c };

    // Address of the Fan Controller Main Control Register.
    // No need for the 2nd control register (bit 7 of 0x15 0x16 0x17),
    // as PWM value will set it to manual mode when new value is set.
    private const byte FAN_MAIN_CTRL_REG = 0x13;

#pragma warning restore IDE1006 // Naming Styles
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/LMSensors.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;

// ReSharper disable once InconsistentNaming

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class LMSensors
{
    private readonly List<ISuperIO> _superIOs = new();

    public LMSensors()
    {
        foreach (string basePath in Directory.GetDirectories("/sys/class/hwmon/"))
        {
            foreach (string devicePath in new[] { "/device", string.Empty })
            {
                string path = basePath + devicePath;

                string name = null;
                try
                {
                    using StreamReader reader = new(path + "/name");
                    name = reader.ReadLine();
                }
                catch (IOException)
                { }

                switch (name)
                {
                    case "atk0110":
                        _superIOs.Add(new LMChip(Chip.ATK0110, path));
                        break;

                    case "f71858fg":
                        _superIOs.Add(new LMChip(Chip.F71858, path));
                        break;
                    case "f71862fg":
                        _superIOs.Add(new LMChip(Chip.F71862, path));
                        break;
                    case "f71869":
                        _superIOs.Add(new LMChip(Chip.F71869, path));
                        break;
                    case "f71869a":
                        _superIOs.Add(new LMChip(Chip.F71869A, path));
                        break;
                    case "f71882fg":
                        _superIOs.Add(new LMChip(Chip.F71882, path));
                        break;
                    case "f71889a":
                        _superIOs.Add(new LMChip(Chip.F71889AD, path));
                        break;
                    case "f71878ad":
                        _superIOs.Add(new LMChip(Chip.F71878AD, path));
                        break;
                    case "f71889ed":
                        _superIOs.Add(new LMChip(Chip.F71889ED, path));
                        break;
                    case "f71889fg":
                        _superIOs.Add(new LMChip(Chip.F71889F, path));
                        break;
                    case "f71808e":
                        _superIOs.Add(new LMChip(Chip.F71808E, path));
                        break;

                    case "it8705":
                        _superIOs.Add(new LMChip(Chip.IT8705F, path));
                        break;
                    case "it8712":
                        _superIOs.Add(new LMChip(Chip.IT8712F, path));
                        break;
                    case "it8716":
                        _superIOs.Add(new LMChip(Chip.IT8716F, path));
                        break;
                    case "it8718":
                        _superIOs.Add(new LMChip(Chip.IT8718F, path));
                        break;
                    case "it8720":
                        _superIOs.Add(new LMChip(Chip.IT8720F, path));
                        break;

                    case "nct6775":
                        _superIOs.Add(new LMChip(Chip.NCT6771F, path));
                        break;
                    case "nct6776":
                        _superIOs.Add(new LMChip(Chip.NCT6776F, path));
                        break;
                    case "nct6779":
                        _superIOs.Add(new LMChip(Chip.NCT6779D, path));
                        break;
                    case "nct6791":
                        _superIOs.Add(new LMChip(Chip.NCT6791D, path));
                        break;
                    case "nct6792":
                        _superIOs.Add(new LMChip(Chip.NCT6792D, path));
                        break;
                    case "nct6793":
                        _superIOs.Add(new LMChip(Chip.NCT6793D, path));
                        break;
                    case "nct6795":
                        _superIOs.Add(new LMChip(Chip.NCT6795D, path));
                        break;
                    case "nct6796":
                        _superIOs.Add(new LMChip(Chip.NCT6796D, path));
                        break;
                    case "nct6797":
                        _superIOs.Add(new LMChip(Chip.NCT6797D, path));
                        break;
                    case "nct6798":
                        _superIOs.Add(new LMChip(Chip.NCT6798D, path));
                        break;
                    case "nct6799":
                        _superIOs.Add(new LMChip(Chip.NCT6799D, path));
                        break;

                    case "w83627ehf":
                        _superIOs.Add(new LMChip(Chip.W83627EHF, path));
                        break;
                    case "w83627dhg":
                        _superIOs.Add(new LMChip(Chip.W83627DHG, path));
                        break;
                    case "w83667hg":
                        _superIOs.Add(new LMChip(Chip.W83667HG, path));
                        break;
                    case "w83627hf":
                        _superIOs.Add(new LMChip(Chip.W83627HF, path));
                        break;
                    case "w83627thf":
                        _superIOs.Add(new LMChip(Chip.W83627THF, path));
                        break;
                    case "w83687thf":
                        _superIOs.Add(new LMChip(Chip.W83687THF, path));
                        break;
                }
            }
        }
    }

    public IReadOnlyList<ISuperIO> SuperIO
    {
        get { return _superIOs; }
    }

    public void Close()
    {
        foreach (ISuperIO superIO in _superIOs)
        {
            if (superIO is LMChip lmChip)
                lmChip.Close();
        }
    }

    private class LMChip : ISuperIO
    {
        private readonly FileStream[] _fanStreams;
        private readonly FileStream[] _temperatureStreams;

        private readonly FileStream[] _voltageStreams;
        private string _path;

        public LMChip(Chip chip, string path)
        {
            _path = path;
            Chip = chip;

            string[] voltagePaths = Directory.GetFiles(path, "in*_input");
            Voltages = new float?[voltagePaths.Length];
            _voltageStreams = new FileStream[voltagePaths.Length];
            for (int i = 0; i < voltagePaths.Length; i++)
                _voltageStreams[i] = new FileStream(voltagePaths[i], FileMode.Open, FileAccess.Read, FileShare.ReadWrite);

            string[] temperaturePaths = Directory.GetFiles(path, "temp*_input");
            Temperatures = new float?[temperaturePaths.Length];
            _temperatureStreams = new FileStream[temperaturePaths.Length];
            for (int i = 0; i < temperaturePaths.Length; i++)
                _temperatureStreams[i] = new FileStream(temperaturePaths[i], FileMode.Open, FileAccess.Read, FileShare.ReadWrite);

            string[] fanPaths = Directory.GetFiles(path, "fan*_input");
            Fans = new float?[fanPaths.Length];
            _fanStreams = new FileStream[fanPaths.Length];
            for (int i = 0; i < fanPaths.Length; i++)
                _fanStreams[i] = new FileStream(fanPaths[i], FileMode.Open, FileAccess.Read, FileShare.ReadWrite);

            Controls = Array.Empty<float?>();
        }

        public Chip Chip { get; }

        public float?[] Controls { get; }

        public float?[] Fans { get; }

        public float?[] Temperatures { get; }

        public float?[] Voltages { get; }

        public byte? ReadGpio(int index)
        {
            return null;
        }

        public void WriteGpio(int index, byte value)
        { }

        public string GetReport()
        {
            return null;
        }

        public void SetControl(int index, byte? value)
        { }

        public void Update()
        {
            for (int i = 0; i < Voltages.Length; i++)
            {
                string s = ReadFirstLine(_voltageStreams[i]);
                try
                {
                    Voltages[i] = 0.001f *
                                  long.Parse(s, CultureInfo.InvariantCulture);
                }
                catch
                {
                    Voltages[i] = null;
                }
            }

            for (int i = 0; i < Temperatures.Length; i++)
            {
                string s = ReadFirstLine(_temperatureStreams[i]);
                try
                {
                    Temperatures[i] = 0.001f *
                                      long.Parse(s, CultureInfo.InvariantCulture);
                }
                catch
                {
                    Temperatures[i] = null;
                }
            }

            for (int i = 0; i < Fans.Length; i++)
            {
                string s = ReadFirstLine(_fanStreams[i]);
                try
                {
                    Fans[i] = long.Parse(s, CultureInfo.InvariantCulture);
                }
                catch
                {
                    Fans[i] = null;
                }
            }
        }

        private static string ReadFirstLine(Stream stream)
        {
            StringBuilder sb = new();
            try
            {
                stream.Seek(0, SeekOrigin.Begin);
                int b = stream.ReadByte();
                while (b is not -1 and not 10)
                {
                    sb.Append((char)b);
                    b = stream.ReadByte();
                }
            }
            catch
            { }

            return sb.ToString();
        }

        public void Close()
        {
            foreach (FileStream stream in _voltageStreams)
                stream.Close();

            foreach (FileStream stream in _temperatureStreams)
                stream.Close();

            foreach (FileStream stream in _fanStreams)
                stream.Close();
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/LPcPort.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class LpcPort
{
    public LpcPort(ushort registerPort, ushort valuePort)
    {
        RegisterPort = registerPort;
        ValuePort = valuePort;
    }

    public ushort RegisterPort { get; }

    public ushort ValuePort { get; }

    public byte ReadByte(byte register)
    {
        Ring0.WriteIoPort(RegisterPort, register);
        return Ring0.ReadIoPort(ValuePort);
    }

    public void WriteByte(byte register, byte value)
    {
        Ring0.WriteIoPort(RegisterPort, register);
        Ring0.WriteIoPort(ValuePort, value);
    }

    public ushort ReadWord(byte register)
    {
        return (ushort)((ReadByte(register) << 8) | ReadByte((byte)(register + 1)));
    }

    public void Select(byte logicalDeviceNumber)
    {
        Ring0.WriteIoPort(RegisterPort, DEVICE_SELECT_REGISTER);
        Ring0.WriteIoPort(ValuePort, logicalDeviceNumber);
    }

    public void WinbondNuvotonFintekEnter()
    {
        Ring0.WriteIoPort(RegisterPort, 0x87);
        Ring0.WriteIoPort(RegisterPort, 0x87);
    }

    public void WinbondNuvotonFintekExit()
    {
        Ring0.WriteIoPort(RegisterPort, 0xAA);
    }

    public void NuvotonDisableIOSpaceLock()
    {
        byte options = ReadByte(NUVOTON_HARDWARE_MONITOR_IO_SPACE_LOCK);
        // if the i/o space lock is enabled
        if ((options & 0x10) > 0)
        {
            // disable the i/o space lock
            WriteByte(NUVOTON_HARDWARE_MONITOR_IO_SPACE_LOCK, (byte)(options & ~0x10));
        }
    }

    public void IT87Enter()
    {
        Ring0.WriteIoPort(RegisterPort, 0x87);
        Ring0.WriteIoPort(RegisterPort, 0x01);
        Ring0.WriteIoPort(RegisterPort, 0x55);
        Ring0.WriteIoPort(RegisterPort, RegisterPort == 0x4E ? (byte)0xAA : (byte)0x55);
    }

    public void IT87Exit()
    {
        // Do not exit config mode for secondary super IO.
        if (RegisterPort != 0x4E)
        {
            Ring0.WriteIoPort(RegisterPort, CONFIGURATION_CONTROL_REGISTER);
            Ring0.WriteIoPort(ValuePort, 0x02);
        }
    }

    public void SmscEnter()
    {
        Ring0.WriteIoPort(RegisterPort, 0x55);
    }

    public void SmscExit()
    {
        Ring0.WriteIoPort(RegisterPort, 0xAA);
    }

    // ReSharper disable InconsistentNaming
    private const byte CONFIGURATION_CONTROL_REGISTER = 0x02;
    private const byte DEVICE_SELECT_REGISTER = 0x07;
    private const byte NUVOTON_HARDWARE_MONITOR_IO_SPACE_LOCK = 0x28;
    // ReSharper restore InconsistentNaming
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/LpcIO.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Threading;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class LpcIO
{
    private readonly StringBuilder _report = new();
    private readonly List<ISuperIO> _superIOs = new();

    public LpcIO()
    {
        if (!Ring0.IsOpen)
            return;

        if (!Ring0.WaitIsaBusMutex(100))
            return;

        Detect();

        Ring0.ReleaseIsaBusMutex();
    }

    public ISuperIO[] SuperIO => _superIOs.ToArray();

    private void ReportUnknownChip(LpcPort port, string type, int chip)
    {
        _report.Append("Chip ID: Unknown ");
        _report.Append(type);
        _report.Append(" with ID 0x");
        _report.Append(chip.ToString("X", CultureInfo.InvariantCulture));
        _report.Append(" at 0x");
        _report.Append(port.RegisterPort.ToString("X", CultureInfo.InvariantCulture));
        _report.Append("/0x");
        _report.AppendLine(port.ValuePort.ToString("X", CultureInfo.InvariantCulture));
        _report.AppendLine();
    }

    private bool DetectSmsc(LpcPort port)
    {
        port.SmscEnter();

        ushort chipId = port.ReadWord(CHIP_ID_REGISTER);

        if (chipId is not 0 and not 0xffff)
        {
            port.SmscExit();
            ReportUnknownChip(port, "SMSC", chipId);
        }

        return false;
    }

    private void Detect()
    {
        for (int i = 0; i < REGISTER_PORTS.Length; i++)
        {
            var port = new LpcPort(REGISTER_PORTS[i], VALUE_PORTS[i]);

            if (DetectWinbondFintek(port)) continue;

            if (DetectIT87(port)) continue;

            if (DetectSmsc(port)) continue;
        }
    }

    public string GetReport()
    {
        if (_report.Length > 0)
        {
            return "LpcIO" + Environment.NewLine + Environment.NewLine + _report;
        }

        return null;
    }

    private bool DetectWinbondFintek(LpcPort port)
    {
        port.WinbondNuvotonFintekEnter();

        byte logicalDeviceNumber = 0;
        byte id = port.ReadByte(CHIP_ID_REGISTER);
        byte revision = port.ReadByte(CHIP_REVISION_REGISTER);
        Chip chip = Chip.Unknown;

        switch (id)
        {
            case 0x05:
                switch (revision)
                {
                    case 0x07:
                        chip = Chip.F71858;
                        logicalDeviceNumber = F71858_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x41:
                        chip = Chip.F71882;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x06:
                switch (revision)
                {
                    case 0x01:
                        chip = Chip.F71862;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x07:
                switch (revision)
                {
                    case 0x23:
                        chip = Chip.F71889F;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x08:
                switch (revision)
                {
                    case 0x14:
                        chip = Chip.F71869;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x09:
                switch (revision)
                {
                    case 0x01:
                        chip = Chip.F71808E;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x09:
                        chip = Chip.F71889ED;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x10:
                switch (revision)
                {
                    case 0x05:
                        chip = Chip.F71889AD;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x07:
                        chip = Chip.F71869A;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x11:
                switch (revision)
                {
                    case 0x06:
                        chip = Chip.F71878AD;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x18:
                        chip = Chip.F71811;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x52:
                switch (revision)
                {
                    case 0x17:
                    case 0x3A:
                    case 0x41:
                        chip = Chip.W83627HF;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x82:
                switch (revision & 0xF0)
                {
                    case 0x80:
                        chip = Chip.W83627THF;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x85:
                switch (revision)
                {
                    case 0x41:
                        chip = Chip.W83687THF;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x88:
                switch (revision & 0xF0)
                {
                    case 0x50:
                    case 0x60:
                        chip = Chip.W83627EHF;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xA0:
                switch (revision & 0xF0)
                {
                    case 0x20:
                        chip = Chip.W83627DHG;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xA5:
                switch (revision & 0xF0)
                {
                    case 0x10:
                        chip = Chip.W83667HG;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xB0:
                switch (revision & 0xF0)
                {
                    case 0x70:
                        chip = Chip.W83627DHGP;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xB3:
                switch (revision & 0xF0)
                {
                    case 0x50:
                        chip = Chip.W83667HGB;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xB4:
                switch (revision & 0xF0)
                {
                    case 0x70:
                        chip = Chip.NCT6771F;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xC3:
                switch (revision & 0xF0)
                {
                    case 0x30:
                        chip = Chip.NCT6776F;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xC4:
                switch (revision & 0xF0)
                {
                    case 0x50:
                        chip = Chip.NCT610XD;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xC5:
                switch (revision & 0xF0)
                {
                    case 0x60:
                        chip = Chip.NCT6779D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xC7:
                switch (revision)
                {
                    case 0x32:
                        chip = Chip.NCT6683D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xC8:
                switch (revision)
                {
                    case 0x03:
                        chip = Chip.NCT6791D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xC9:
                switch (revision)
                {
                    case 0x11:
                        chip = Chip.NCT6792D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x13:
                        chip = Chip.NCT6792DA;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xD1:
                switch (revision)
                {
                    case 0x21:
                        chip = Chip.NCT6793D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xD3:
                switch (revision)
                {
                    case 0x52:
                        chip = Chip.NCT6795D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xD4:
                switch (revision)
                {
                    case 0x23:
                        chip = Chip.NCT6796D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x2A:
                        chip = Chip.NCT6796DR;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x51:
                        chip = Chip.NCT6797D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x2B:
                        chip = Chip.NCT6798D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x40:
                    case 0x41:
                        chip = Chip.NCT6686D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xD5:
                switch (revision)
                {
                    case 0x92:
                        chip = Chip.NCT6687D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xD8:
                switch (revision)
                {
                    case 0x02:
                        chip = Chip.NCT6799D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
        }

        if (chip == Chip.Unknown)
        {
            if (id is not 0 and not 0xff)
            {
                port.WinbondNuvotonFintekExit();
                ReportUnknownChip(port, "Winbond / Nuvoton / Fintek", (id << 8) | revision);
            }
        }
        else
        {
            port.Select(logicalDeviceNumber);
            ushort address = port.ReadWord(BASE_ADDRESS_REGISTER);
            Thread.Sleep(1);
            ushort verify = port.ReadWord(BASE_ADDRESS_REGISTER);

            ushort vendorId = port.ReadWord(FINTEK_VENDOR_ID_REGISTER);

            // disable the hardware monitor i/o space lock on NCT679XD chips
            if (address == verify &&
                chip is Chip.NCT6791D or Chip.NCT6792D or Chip.NCT6792DA or Chip.NCT6793D or Chip.NCT6795D or Chip.NCT6796D or Chip.NCT6796DR or Chip.NCT6798D or Chip.NCT6797D or Chip.NCT6799D)
            {
                port.NuvotonDisableIOSpaceLock();
            }

            port.WinbondNuvotonFintekExit();

            if (address != verify)
            {
                _report.Append("Chip ID: 0x");
                _report.AppendLine(chip.ToString("X"));
                _report.Append("Chip revision: 0x");
                _report.AppendLine(revision.ToString("X", CultureInfo.InvariantCulture));
                _report.AppendLine("Error: Address verification failed");
                _report.AppendLine();

                return false;
            }

            // some Fintek chips have address register offset 0x05 added already
            if ((address & 0x07) == 0x05)
                address &= 0xFFF8;

            if (address < 0x100 || (address & 0xF007) != 0)
            {
                _report.Append("Chip ID: 0x");
                _report.AppendLine(chip.ToString("X"));
                _report.Append("Chip revision: 0x");
                _report.AppendLine(revision.ToString("X", CultureInfo.InvariantCulture));
                _report.Append("Error: Invalid address 0x");
                _report.AppendLine(address.ToString("X", CultureInfo.InvariantCulture));
                _report.AppendLine();

                return false;
            }

            switch (chip)
            {
                case Chip.W83627DHG:
                case Chip.W83627DHGP:
                case Chip.W83627EHF:
                case Chip.W83627HF:
                case Chip.W83627THF:
                case Chip.W83667HG:
                case Chip.W83667HGB:
                case Chip.W83687THF:
                    _superIOs.Add(new W836XX(chip, revision, address));
                    break;

                case Chip.NCT610XD:
                case Chip.NCT6771F:
                case Chip.NCT6776F:
                case Chip.NCT6779D:
                case Chip.NCT6791D:
                case Chip.NCT6792D:
                case Chip.NCT6792DA:
                case Chip.NCT6793D:
                case Chip.NCT6795D:
                case Chip.NCT6796D:
                case Chip.NCT6796DR:
                case Chip.NCT6797D:
                case Chip.NCT6798D:
                case Chip.NCT6799D:
                case Chip.NCT6686D:
                case Chip.NCT6687D:
                case Chip.NCT6683D:
                    _superIOs.Add(new Nct677X(chip, revision, address, port));
                    break;

                case Chip.F71858:
                case Chip.F71862:
                case Chip.F71869:
                case Chip.F71878AD:
                case Chip.F71869A:
                case Chip.F71882:
                case Chip.F71889AD:
                case Chip.F71889ED:
                case Chip.F71889F:
                case Chip.F71808E:
                    if (vendorId != FINTEK_VENDOR_ID)
                    {
                        _report.Append("Chip ID: 0x");
                        _report.AppendLine(chip.ToString("X"));
                        _report.Append("Chip revision: 0x");
                        _report.AppendLine(revision.ToString("X", CultureInfo.InvariantCulture));
                        _report.Append("Error: Invalid vendor ID 0x");
                        _report.AppendLine(vendorId.ToString("X", CultureInfo.InvariantCulture));
                        _report.AppendLine();

                        return false;
                    }

                    _superIOs.Add(new F718XX(chip, address));
                    break;
            }

            return true;
        }

        return false;
    }

    private bool DetectIT87(LpcPort port)
    {
        // IT87XX can enter only on port 0x2E
        // IT8792 using 0x4E
        if (port.RegisterPort is not 0x2E and not 0x4E)
            return false;

        port.IT87Enter();

        ushort chipId = port.ReadWord(CHIP_ID_REGISTER);
        Chip chip = chipId switch
        {
            0x8613 => Chip.IT8613E,
            0x8620 => Chip.IT8620E,
            0x8628 => Chip.IT8628E,
            0x8631 => Chip.IT8631E,
            0x8665 => Chip.IT8665E,
            0x8655 => Chip.IT8655E,
            0x8686 => Chip.IT8686E,
            0x8688 => Chip.IT8688E,
            0x8689 => Chip.IT8689E,
            0x8695 => Chip.IT8695E,
            0x8705 => Chip.IT8705F,
            0x8712 => Chip.IT8712F,
            0x8716 => Chip.IT8716F,
            0x8718 => Chip.IT8718F,
            0x8720 => Chip.IT8720F,
            0x8721 => Chip.IT8721F,
            0x8726 => Chip.IT8726F,
            0x8728 => Chip.IT8728F,
            0x8771 => Chip.IT8771E,
            0x8772 => Chip.IT8772E,
            0x8733 => Chip.IT879XE,
            _ => Chip.Unknown
        };

        if (chip == Chip.Unknown)
        {
            if (chipId is not 0 and not 0xffff)
            {
                port.IT87Exit();

                ReportUnknownChip(port, "ITE", chipId);
            }
        }
        else
        {
            port.Select(IT87_ENVIRONMENT_CONTROLLER_LDN);

            ushort address = port.ReadWord(BASE_ADDRESS_REGISTER);
            Thread.Sleep(1);
            ushort verify = port.ReadWord(BASE_ADDRESS_REGISTER);

            byte version = (byte)(port.ReadByte(IT87_CHIP_VERSION_REGISTER) & 0x0F);

            ushort gpioAddress;
            ushort gpioVerify;

            if (chip == Chip.IT8705F)
            {
                port.Select(IT8705_GPIO_LDN);
                gpioAddress = port.ReadWord(BASE_ADDRESS_REGISTER);
                Thread.Sleep(1);
                gpioVerify = port.ReadWord(BASE_ADDRESS_REGISTER);
            }
            else
            {
                port.Select(IT87XX_GPIO_LDN);
                gpioAddress = port.ReadWord(BASE_ADDRESS_REGISTER + 2);
                Thread.Sleep(1);
                gpioVerify = port.ReadWord(BASE_ADDRESS_REGISTER + 2);
            }

            port.IT87Exit();

            if (address != verify || address < 0x100 || (address & 0xF007) != 0)
            {
                _report.Append("Chip ID: 0x");
                _report.AppendLine(chip.ToString("X"));
                _report.Append("Error: Invalid address 0x");
                _report.AppendLine(address.ToString("X", CultureInfo.InvariantCulture));
                _report.AppendLine();

                return false;
            }

            if (gpioAddress != gpioVerify || gpioAddress < 0x100 || (gpioAddress & 0xF007) != 0)
            {
                _report.Append("Chip ID: 0x");
                _report.AppendLine(chip.ToString("X"));
                _report.Append("Error: Invalid GPIO address 0x");
                _report.AppendLine(gpioAddress.ToString("X", CultureInfo.InvariantCulture));
                _report.AppendLine();

                return false;
            }

            _superIOs.Add(new IT87XX(chip, address, gpioAddress, version));
            return true;
        }

        return false;
    }

    // ReSharper disable InconsistentNaming
    private const byte BASE_ADDRESS_REGISTER = 0x60;
    private const byte CHIP_ID_REGISTER = 0x20;
    private const byte CHIP_REVISION_REGISTER = 0x21;

    private const byte F71858_HARDWARE_MONITOR_LDN = 0x02;
    private const byte FINTEK_HARDWARE_MONITOR_LDN = 0x04;
    private const byte IT87_ENVIRONMENT_CONTROLLER_LDN = 0x04;
    private const byte IT8705_GPIO_LDN = 0x05;
    private const byte IT87XX_GPIO_LDN = 0x07;
    private const byte WINBOND_NUVOTON_HARDWARE_MONITOR_LDN = 0x0B;

    private const ushort FINTEK_VENDOR_ID = 0x1934;

    private const byte FINTEK_VENDOR_ID_REGISTER = 0x23;
    private const byte IT87_CHIP_VERSION_REGISTER = 0x22;

    private readonly ushort[] REGISTER_PORTS = { 0x2E, 0x4E };
    private readonly ushort[] VALUE_PORTS = { 0x2F, 0x4F };
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/Nct677X.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text;
using System.Threading;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class Nct677X : ISuperIO
{
    private readonly struct TemperatureSourceData
    {
        public TemperatureSourceData(Enum source, ushort register, ushort halfRegister = 0, int halfBit = -1, ushort sourceRegister = 0, ushort? alternateRegister = null)
        {
            Source = source;
            Register = register;
            HalfRegister = halfRegister;
            HalfBit = halfBit;
            SourceRegister = sourceRegister;
            AlternateRegister = alternateRegister;
        }
        public readonly Enum Source;
        public readonly ushort Register;
        public readonly ushort HalfRegister;
        public readonly int HalfBit;
        public readonly ushort SourceRegister;
        public readonly ushort? AlternateRegister;
    }

    private readonly ushort[] _fanCountRegister;
    private readonly ushort[] _fanRpmRegister;
    private readonly byte[] _initialFanControlMode = new byte[7];
    private readonly byte[] _initialFanPwmCommand = new byte[7];
    private readonly bool _isNuvotonVendor;
    private readonly LpcPort _lpcPort;
    private readonly int _maxFanCount;
    private readonly int _minFanCount;
    private readonly int _minFanRpm;
    private readonly ushort _port;
    private readonly bool[] _restoreDefaultFanControlRequired = new bool[7];
    private readonly byte _revision;
    private readonly TemperatureSourceData[] _temperaturesSource;
    private readonly ushort _vBatMonitorControlRegister;
    private readonly ushort[] _voltageRegisters;
    private readonly ushort _voltageVBatRegister;

    public Nct677X(Chip chip, byte revision, ushort port, LpcPort lpcPort)
    {
        Chip = chip;
        _revision = revision;
        _port = port;
        _lpcPort = lpcPort;

        if (chip == Chip.NCT610XD)
        {
            VENDOR_ID_HIGH_REGISTER = 0x80FE;
            VENDOR_ID_LOW_REGISTER = 0x00FE;

            FAN_PWM_OUT_REG = new ushort[] { 0x04A, 0x04B, 0x04C };
            FAN_PWM_COMMAND_REG = new ushort[] { 0x119, 0x129, 0x139 };
            FAN_CONTROL_MODE_REG = new ushort[] { 0x113, 0x123, 0x133 };

            _vBatMonitorControlRegister = 0x0318;
        }
        else if (chip is Chip.NCT6683D or Chip.NCT6686D or Chip.NCT6687D)
        {
            FAN_PWM_OUT_REG = new ushort[] { 0x160, 0x161, 0x162, 0x163, 0x164, 0x165, 0x166, 0x167 };
            FAN_PWM_COMMAND_REG = new ushort[] { 0xA28, 0xA29, 0xA2A, 0xA2B, 0xA2C, 0xA2D, 0xA2E, 0xA2F };
            FAN_CONTROL_MODE_REG = new ushort[] { 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00 };
            FAN_PWM_REQUEST_REG = new ushort[] { 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01 };
        }
        else
        {
            VENDOR_ID_HIGH_REGISTER = 0x804F;
            VENDOR_ID_LOW_REGISTER = 0x004F;

            FAN_PWM_OUT_REG = chip is Chip.NCT6797D or Chip.NCT6798D or Chip.NCT6799D
                ? new ushort[] { 0x001, 0x003, 0x011, 0x013, 0x015, 0xA09, 0xB09 }
                : new ushort[] { 0x001, 0x003, 0x011, 0x013, 0x015, 0x017, 0x029 };

            FAN_PWM_COMMAND_REG = new ushort[] { 0x109, 0x209, 0x309, 0x809, 0x909, 0xA09, 0xB09 };
            FAN_CONTROL_MODE_REG = new ushort[] { 0x102, 0x202, 0x302, 0x802, 0x902, 0xA02, 0xB02 };

            _vBatMonitorControlRegister = 0x005D;
        }

        _isNuvotonVendor = IsNuvotonVendor();

        if (!_isNuvotonVendor)
            return;

        switch (chip)
        {
            case Chip.NCT6771F:
            case Chip.NCT6776F:
                if (chip == Chip.NCT6771F)
                {
                    Fans = new float?[4];

                    // min value RPM value with 16-bit fan counter
                    _minFanRpm = (int)(1.35e6 / 0xFFFF);
                }
                else
                {
                    Fans = new float?[5];

                    // min value RPM value with 13-bit fan counter
                    _minFanRpm = (int)(1.35e6 / 0x1FFF);
                }

                _fanRpmRegister = new ushort[5];
                for (int i = 0; i < _fanRpmRegister.Length; i++)
                    _fanRpmRegister[i] = (ushort)(0x656 + (i << 1));

                Controls = new float?[3];

                Voltages = new float?[9];
                _voltageRegisters = new ushort[] { 0x020, 0x021, 0x022, 0x023, 0x024, 0x025, 0x026, 0x550, 0x551 };
                _voltageVBatRegister = 0x551;
                _temperaturesSource = new TemperatureSourceData[]
                {
                    new(chip == Chip.NCT6771F ?  SourceNct6771F.PECI_0 : SourceNct6776F.PECI_0, 0x027, 0, -1, 0x621),
                    new(chip == Chip.NCT6771F ?  SourceNct6771F.CPUTIN : SourceNct6776F.CPUTIN, 0x073, 0x074, 7, 0x100),
                    new(chip == Chip.NCT6771F ?  SourceNct6771F.AUXTIN : SourceNct6776F.AUXTIN, 0x075, 0x076, 7, 0x200),
                    new(chip == Chip.NCT6771F ?  SourceNct6771F.SYSTIN : SourceNct6776F.SYSTIN, 0x077, 0x078, 7, 0x300),
                    new(null, 0x150, 0x151, 7, 0x622),
                    new(null, 0x250, 0x251, 7, 0x623),
                    new(null, 0x62B, 0x62E, 0, 0x624),
                    new(null, 0x62C, 0x62E, 1, 0x625),
                    new(null, 0x62D, 0x62E, 2, 0x626)
                };

                Temperatures = new float?[4];
                break;

            case Chip.NCT6779D:
            case Chip.NCT6791D:
            case Chip.NCT6792D:
            case Chip.NCT6792DA:
            case Chip.NCT6793D:
            case Chip.NCT6795D:
            case Chip.NCT6796D:
            case Chip.NCT6796DR:
            case Chip.NCT6797D:
            case Chip.NCT6798D:
            case Chip.NCT6799D:
                switch (chip)
                {
                    case Chip.NCT6779D:
                        Fans = new float?[5];
                        Controls = new float?[5];
                        break;

                    case Chip.NCT6796DR:
                    case Chip.NCT6797D:
                    case Chip.NCT6798D:
                    case Chip.NCT6799D:
                        Fans = new float?[7];
                        Controls = new float?[7];
                        break;

                    default:
                        Fans = new float?[6];
                        Controls = new float?[6];
                        break;
                }

                _fanCountRegister = new ushort[] { 0x4B0, 0x4B2, 0x4B4, 0x4B6, 0x4B8, 0x4BA, 0x4CC };

                // max value for 13-bit fan counter
                _maxFanCount = 0x1FFF;

                // min value that could be transferred to 16-bit RPM registers
                _minFanCount = 0x15;

                Voltages = new float?[15];
                _voltageRegisters = new ushort[] { 0x480, 0x481, 0x482, 0x483, 0x484, 0x485, 0x486, 0x487, 0x488, 0x489, 0x48A, 0x48B, 0x48C, 0x48D, 0x48E };
                _voltageVBatRegister = 0x488;
                var temperaturesSources = new List<TemperatureSourceData>();

                switch (chip)
                {
                    case Chip.NCT6796D:
                    case Chip.NCT6796DR:
                    case Chip.NCT6797D:
                    case Chip.NCT6798D:
                    case Chip.NCT6799D:
                        temperaturesSources.AddRange(new TemperatureSourceData[]
                        {
                            new(SourceNct67Xxd.PECI_0, 0x073, 0x074, 7, 0x100),
                            new(SourceNct67Xxd.CPUTIN, 0x075, 0x076, 7, 0x200, 0x491),
                            new(SourceNct67Xxd.SYSTIN, 0x077, 0x078, 7, 0x300, 0x490),
                            new(SourceNct67Xxd.AUXTIN0, 0x079, 0x07A, 7, 0x800, 0x492),
                            new(SourceNct67Xxd.AUXTIN1, 0x07B, 0x07C, 7, 0x900, 0x493),
                            new(SourceNct67Xxd.AUXTIN2, 0x07D, 0x07E, 7, 0xA00, 0x494),
                            new(SourceNct67Xxd.AUXTIN3, 0x4A0, 0x49E, 6, 0xB00, 0x495),
                            new(SourceNct67Xxd.AUXTIN4, 0x027, 0, -1, 0x621),
                            new(SourceNct67Xxd.SMBUSMASTER0, 0x150, 0x151, 7, 0x622),
                            new(SourceNct67Xxd.SMBUSMASTER1, 0x670, 0, -1, 0xC26),
                            new(SourceNct67Xxd.PECI_1, 0x672, 0, -1, 0xC27),
                            new(SourceNct67Xxd.PCH_CHIP_CPU_MAX_TEMP, 0x674, 0, -1, 0xC28, 0x400),
                            new(SourceNct67Xxd.PCH_CHIP_TEMP, 0x676, 0, -1, 0xC29, 0x401),
                            new(SourceNct67Xxd.PCH_CPU_TEMP,  0x678, 0, -1, 0xC2A, 0x402),
                            new(SourceNct67Xxd.PCH_MCH_TEMP, 0x67A, 0, -1, 0xC2B, 0x404),
                            new(SourceNct67Xxd.AGENT0_DIMM0, 0),
                            new(SourceNct67Xxd.AGENT0_DIMM1, 0),
                            new(SourceNct67Xxd.AGENT1_DIMM0, 0),
                            new(SourceNct67Xxd.AGENT1_DIMM1, 0),
                            new(SourceNct67Xxd.BYTE_TEMP0, 0),
                            new(SourceNct67Xxd.BYTE_TEMP1, 0),
                            new(SourceNct67Xxd.PECI_0_CAL, 0),
                            new(SourceNct67Xxd.PECI_1_CAL, 0),
                            new(SourceNct67Xxd.VIRTUAL_TEMP, 0)
                        });
                        break;

                    default:
                        temperaturesSources.AddRange(new TemperatureSourceData[]
                        {
                            new(SourceNct67Xxd.PECI_0, 0x027, 0, -1, 0x621),
                            new(SourceNct67Xxd.CPUTIN, 0x073, 0x074, 7, 0x100, 0x491),
                            new(SourceNct67Xxd.SYSTIN, 0x075, 0x076, 7, 0x200, 0x490),
                            new(SourceNct67Xxd.AUXTIN0, 0x077, 0x078, 7, 0x300, 0x492),
                            new(SourceNct67Xxd.AUXTIN1, 0x079, 0x07A, 7, 0x800, 0x493),
                            new(SourceNct67Xxd.AUXTIN2, 0x07B, 0x07C, 7, 0x900, 0x494),
                            new(SourceNct67Xxd.AUXTIN3, 0x150, 0x151, 7, 0x622, 0x495)
                        });
                        break;
                }

                _temperaturesSource = temperaturesSources.ToArray();
                Temperatures = new float?[_temperaturesSource.Length];
                break;

            case Chip.NCT610XD:
                Fans = new float?[3];
                Controls = new float?[3];

                _fanRpmRegister = new ushort[3];
                for (int i = 0; i < _fanRpmRegister.Length; i++)
                    _fanRpmRegister[i] = (ushort)(0x030 + (i << 1));

                // min value RPM value with 13-bit fan counter
                _minFanRpm = (int)(1.35e6 / 0x1FFF);

                Voltages = new float?[9];
                _voltageRegisters = new ushort[] { 0x300, 0x301, 0x302, 0x303, 0x304, 0x305, 0x307, 0x308, 0x309 };
                _voltageVBatRegister = 0x308;
                Temperatures = new float?[4];
                _temperaturesSource = new TemperatureSourceData[] {
                    new(SourceNct610X.PECI_0, 0x027, 0, -1, 0x621),
                    new(SourceNct610X.SYSTIN, 0x018, 0x01B, 7, 0x100, 0x018),
                    new(SourceNct610X.CPUTIN, 0x019, 0x11B, 7, 0x200, 0x019),
                    new(SourceNct610X.AUXTIN, 0x01A, 0x21B, 7, 0x300, 0x01A)
                };
                break;

            case Chip.NCT6683D:
            case Chip.NCT6686D:
            case Chip.NCT6687D:
                Fans = new float?[8];
                Controls = new float?[8];
                Voltages = new float?[14];
                Temperatures = new float?[7];

                // CPU
                // System
                // MOS
                // PCH
                // CPU Socket
                // PCIE_1
                // M2_1
                _temperaturesSource = new TemperatureSourceData[] {
                    new(null, 0x100),
                    new(null, 0x102),
                    new(null, 0x104),
                    new(null, 0x106),
                    new(null, 0x108),
                    new(null, 0x10A),
                    new(null, 0x10C)
                };

                // VIN0 +12V
                // VIN1 +5V
                // VIN2 VCore
                // VIN3 SIO
                // VIN4 DRAM
                // VIN5 CPU IO
                // VIN6 CPU SA
                // VIN7 SIO
                // 3VCC I/O +3.3
                // SIO VTT
                // SIO VREF
                // SIO VSB
                // SIO AVSB
                // SIO VBAT
                _voltageRegisters = new ushort[] { 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x13A, 0x13E, 0x136, 0x138, 0x13C };

                // CPU Fan
                // PUMP Fan
                // SYS Fan 1
                // SYS Fan 2
                // SYS Fan 3
                // SYS Fan 4
                // SYS Fan 5
                // SYS Fan 6
                _fanRpmRegister = new ushort[] { 0x140, 0x142, 0x144, 0x146, 0x148, 0x14A, 0x14C, 0x14E };

                _restoreDefaultFanControlRequired = new bool[_fanRpmRegister.Length];
                _initialFanControlMode = new byte[_fanRpmRegister.Length];
                _initialFanPwmCommand = new byte[_fanRpmRegister.Length];

                // initialize
                const ushort initRegister = 0x180;
                byte data = ReadByte(initRegister);
                if ((data & 0x80) == 0)
                {
                    WriteByte(initRegister, (byte)(data | 0x80));
                }

                // enable SIO voltage
                WriteByte(0x1BB, 0x61);
                WriteByte(0x1BC, 0x62);
                WriteByte(0x1BD, 0x63);
                WriteByte(0x1BE, 0x64);
                WriteByte(0x1BF, 0x65);
                break;
        }
    }

    public Chip Chip { get; }

    public float?[] Controls { get; } = Array.Empty<float?>();

    public float?[] Fans { get; } = Array.Empty<float?>();

    public float?[] Temperatures { get; } = Array.Empty<float?>();

    public float?[] Voltages { get; } = Array.Empty<float?>();

    public byte? ReadGpio(int index)
    {
        return null;
    }

    public void WriteGpio(int index, byte value)
    { }

    public void SetControl(int index, byte? value)
    {
        if (!_isNuvotonVendor)
            return;

        if (index < 0 || index >= Controls.Length)
            throw new ArgumentOutOfRangeException(nameof(index));

        if (!Ring0.WaitIsaBusMutex(10))
            return;

        if (value.HasValue)
        {
            SaveDefaultFanControl(index);

            if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D)
            {
                // set manual mode
                WriteByte(FAN_CONTROL_MODE_REG[index], 0);

                // set output value
                WriteByte(FAN_PWM_COMMAND_REG[index], value.Value);
            }
            else
            {
                // Manual mode, bit(1 : set, 0 : unset)
                // bit 0 : CPU Fan
                // bit 1 : PUMP Fan
                // bit 2 : SYS Fan 1
                // bit 3 : SYS Fan 2
                // bit 4 : SYS Fan 3
                // bit 5 : SYS Fan 4
                // bit 6 : SYS Fan 5
                // bit 7 : SYS Fan 6

                byte mode = ReadByte(FAN_CONTROL_MODE_REG[index]);
                byte bitMask = (byte)(0x01 << index);
                mode = (byte)(mode | bitMask);
                WriteByte(FAN_CONTROL_MODE_REG[index], mode);

                WriteByte(FAN_PWM_REQUEST_REG[index], 0x80);
                Thread.Sleep(50);

                WriteByte(FAN_PWM_COMMAND_REG[index], value.Value);
                WriteByte(FAN_PWM_REQUEST_REG[index], 0x40);
                Thread.Sleep(50);
            }
        }
        else
        {
            RestoreDefaultFanControl(index);
        }

        Ring0.ReleaseIsaBusMutex();
    }

    public void Update()
    {
        if (!_isNuvotonVendor)
            return;

        if (!Ring0.WaitIsaBusMutex(10))
            return;

        DisableIOSpaceLock();

        for (int i = 0; i < Voltages.Length; i++)
        {
            if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D)
            {
                float value = 0.008f * ReadByte(_voltageRegisters[i]);
                bool valid = value > 0;

                // check if battery voltage monitor is enabled
                if (valid && _voltageRegisters[i] == _voltageVBatRegister)
                    valid = (ReadByte(_vBatMonitorControlRegister) & 0x01) > 0;

                Voltages[i] = valid ? value : null;
            }
            else
            {
                float value = 0.001f * ((16 * ReadByte(_voltageRegisters[i])) + (ReadByte((ushort)(_voltageRegisters[i] + 1)) >> 4));

                Voltages[i] = i switch
                {
                    // 12V
                    0 => value * 12.0f,
                    // 5V
                    1 => value * 5.0f,
                    // DRAM
                    4 => value * 2.0f,
                    _ => value
                };
            }
        }

        System.Diagnostics.Debug.WriteLine("Updating temperatures.");
        long temperatureSourceMask = 0;
        for (int i = 0; i < _temperaturesSource.Length; i++)
        {
            TemperatureSourceData ts = _temperaturesSource[i];
            int value;
            SourceNct67Xxd source;
            float? temperature;

            switch (Chip)
            {
                case Chip.NCT6687D:
                case Chip.NCT6686D:
                case Chip.NCT6683D:
                    value = (sbyte)ReadByte(ts.Register);
                    int half = (ReadByte((ushort)(ts.Register + 1)) >> 7) & 0x1;
                    Temperatures[i] = value + (0.5f * half);
                    break;

                case Chip.NCT6796D:
                case Chip.NCT6796DR:
                case Chip.NCT6797D:
                case Chip.NCT6798D:
                case Chip.NCT6799D:
                    if (_temperaturesSource[i].Register == 0)
                    {
                        System.Diagnostics.Debug.WriteLine("Temperature register {0} skipped, address 0.", i);
                        continue;
                    }

                    value = (sbyte)ReadByte(_temperaturesSource[i].Register) << 1;
                    System.Diagnostics.Debug.WriteLine("Temperature register {0} at 0x{1:X3} value (integer): {2}/2", i, ts.Register, value);
                    if (_temperaturesSource[i].HalfBit > 0)
                    {
                        value |= (ReadByte(_temperaturesSource[i].HalfRegister) >> ts.HalfBit) & 0x1;
                        System.Diagnostics.Debug.WriteLine("Temperature register {0} value updated from 0x{1:X3} (fractional): {2}/2", i, ts.HalfRegister, value);
                    }

                    if (ts.SourceRegister > 0)
                    {
                        source = (SourceNct67Xxd)(ReadByte(ts.SourceRegister) & 0x1F);
                        System.Diagnostics.Debug.WriteLine("Temperature register {0} source at 0x{1:X3}: {2:G} ({2:D})", i, ts.SourceRegister, source);
                    }
                    else
                    {
                        source = (SourceNct67Xxd)ts.Source;
                        System.Diagnostics.Debug.WriteLine("Temperature register {0} source register is 0, source set to: {1:G} ({1:D})", i, source);
                    }

                    // Skip reading when already filled, because later values are without fractional
                    if ((temperatureSourceMask & (1L << (byte)source)) > 0)
                    {
                        System.Diagnostics.Debug.WriteLine("Temperature register {0} discarded, because source seen before.", i);
                        continue;
                    }

                    temperature = 0.5f * value;
                    System.Diagnostics.Debug.WriteLine("Temperature register {0} final temperature: {1}.", i, temperature);
                    if (temperature is > 125 or < -55)
                    {
                        temperature = null;
                        System.Diagnostics.Debug.WriteLine("Temperature register {0} discarded: Out of range.", i);
                    }
                    else
                    {
                        temperatureSourceMask |= 1L << (byte)source;
                        System.Diagnostics.Debug.WriteLine("Temperature register {0} accepted.", i);
                    }

                    for (int j = 0; j < Temperatures.Length; j++)
                    {
                        if ((SourceNct67Xxd)_temperaturesSource[j].Source == source)
                        {
                            Temperatures[j] = temperature;
                            System.Diagnostics.Debug.WriteLine("Temperature register {0}, value from source {1:G} ({1:D}), written at position {2}.", i, _temperaturesSource[j].Source, j);
                        }
                    }
                    break;

                default:
                    value = (sbyte)ReadByte(ts.Register) << 1;
                    if (ts.HalfBit > 0)
                    {
                        value |= (ReadByte(ts.HalfRegister) >> ts.HalfBit) & 0x1;
                    }

                    source = (SourceNct67Xxd)ReadByte(ts.SourceRegister);
                    temperatureSourceMask |= 1L << (byte)source;

                    temperature = 0.5f * value;
                    if (temperature is > 125 or < -55)
                        temperature = null;

                    for (int j = 0; j < Temperatures.Length; j++)
                    {
                        if ((SourceNct67Xxd)_temperaturesSource[j].Source == source)
                            Temperatures[j] = temperature;
                    }
                    break;
            }
        }

        for (int i = 0; i < _temperaturesSource.Length; i++)
        {
            TemperatureSourceData ts = _temperaturesSource[i];
            if (!ts.AlternateRegister.HasValue)
            {
                System.Diagnostics.Debug.WriteLine("Alternate temperature register for temperature {0}, {1:G} ({1:D}), skipped, because address is null.", i, ts.Source);
                continue;
            }

            if ((temperatureSourceMask & (1L << (byte)(SourceNct67Xxd)ts.Source)) > 0)
            {
                System.Diagnostics.Debug.WriteLine("Alternate temperature register for temperature {0}, {1:G} ({1:D}), at 0x{2:X3} skipped, because value already set.", i, ts.Source, ts.AlternateRegister.Value);
                continue;
            }

            float? temperature = (sbyte)ReadByte(ts.AlternateRegister.Value);
            System.Diagnostics.Debug.WriteLine("Alternate temperature register for temperature {0}, {1:G} ({1:D}), at 0x{2:X3} final temperature: {3}.", i, ts.Source, ts.AlternateRegister.Value, temperature);

            if (temperature is > 125 or <= 0)
            {
                temperature = null;
                System.Diagnostics.Debug.WriteLine("Alternate Temperature register for temperature {0}, {1:G} ({1:D}), discarded: Out of range.", i, ts.Source);
            }

            Temperatures[i] = temperature;
        }

        for (int i = 0; i < Fans.Length; i++)
        {
            if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D)
            {
                if (_fanCountRegister != null)
                {
                    byte high = ReadByte(_fanCountRegister[i]);
                    byte low = ReadByte((ushort)(_fanCountRegister[i] + 1));

                    int count = (high << 5) | (low & 0x1F);
                    if (count < _maxFanCount)
                    {
                        if (count >= _minFanCount)
                        {
                            Fans[i] = 1.35e6f / count;
                        }
                        else
                        {
                            Fans[i] = null;
                        }
                    }
                    else
                    {
                        Fans[i] = 0;
                    }
                }
                else
                {
                    byte high = ReadByte(_fanRpmRegister[i]);
                    byte low = ReadByte((ushort)(_fanRpmRegister[i] + 1));
                    int value = (high << 8) | low;

                    Fans[i] = value > _minFanRpm ? value : 0;
                }
            }
            else
            {
                Fans[i] = (ReadByte(_fanRpmRegister[i]) << 8) | ReadByte((ushort)(_fanRpmRegister[i] + 1));
            }
        }

        for (int i = 0; i < Controls.Length; i++)
        {
            if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D)
            {
                int value = ReadByte(FAN_PWM_OUT_REG[i]);
                Controls[i] = value / 2.55f;
            }
            else
            {
                int value = ReadByte(FAN_PWM_OUT_REG[i]);
                Controls[i] = (float)Math.Round(value / 2.55f);
            }
        }

        Ring0.ReleaseIsaBusMutex();
    }

    public string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("LPC " + GetType().Name);
        r.AppendLine();
        r.Append("Chip Id: 0x");
        r.AppendLine(Chip.ToString("X"));
        r.Append("Chip Revision: 0x");
        r.AppendLine(_revision.ToString("X", CultureInfo.InvariantCulture));
        r.Append("Base Address: 0x");
        r.AppendLine(_port.ToString("X4", CultureInfo.InvariantCulture));
        r.AppendLine();

        if (!Ring0.WaitIsaBusMutex(100))
            return r.ToString();

        ushort[] addresses =
        {
            0x000,
            0x010,
            0x020,
            0x030,
            0x040,
            0x050,
            0x060,
            0x070,
            0x0F0,
            0x100,
            0x110,
            0x120,
            0x130,
            0x140,
            0x150,
            0x200,
            0x210,
            0x220,
            0x230,
            0x240,
            0x250,
            0x260,
            0x300,
            0x320,
            0x330,
            0x340,
            0x360,
            0x400,
            0x410,
            0x420,
            0x440,
            0x450,
            0x460,
            0x480,
            0x490,
            0x4B0,
            0x4C0,
            0x4F0,
            0x500,
            0x550,
            0x560,
            0x600,
            0x610,
            0x620,
            0x630,
            0x640,
            0x650,
            0x660,
            0x670,
            0x700,
            0x710,
            0x720,
            0x730,
            0x800,
            0x820,
            0x830,
            0x840,
            0x900,
            0x920,
            0x930,
            0x940,
            0x960,
            0xA00,
            0xA10,
            0xA20,
            0xA30,
            0xA40,
            0xA50,
            0xA60,
            0xA70,
            0xB00,
            0xB10,
            0xB20,
            0xB30,
            0xB50,
            0xB60,
            0xB70,
            0xC00,
            0xC10,
            0xC20,
            0xC30,
            0xC50,
            0xC60,
            0xC70,
            0xD00,
            0xD10,
            0xD20,
            0xD30,
            0xD50,
            0xD60,
            0xE00,
            0xE10,
            0xE20,
            0xE30,
            0xF00,
            0xF10,
            0xF20,
            0xF30,
            0x8040,
            0x80F0
        };

        r.AppendLine("Hardware Monitor Registers");
        r.AppendLine();
        r.AppendLine("        00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
        r.AppendLine();

        if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D)
        {
            foreach (ushort address in addresses)
            {
                r.Append(" ");
                r.Append(address.ToString("X4", CultureInfo.InvariantCulture));
                r.Append("  ");
                for (ushort j = 0; j <= 0xF; j++)
                {
                    r.Append(" ");
                    r.Append(ReadByte((ushort)(address | j)).ToString("X2", CultureInfo.InvariantCulture));
                }

                r.AppendLine();
            }
        }
        else
        {
            for (int i = 0; i <= 0xFF; i++)
            {
                r.Append(" ");
                r.Append((i << 4).ToString("X4", CultureInfo.InvariantCulture));
                r.Append("  ");
                for (int j = 0; j <= 0xF; j++)
                {
                    ushort address = (ushort)(i << 4 | j);
                    r.Append(" ");
                    r.Append(ReadByte(address).ToString("X2", CultureInfo.InvariantCulture));
                }

                r.AppendLine();
            }
        }

        r.AppendLine();

        Ring0.ReleaseIsaBusMutex();

        return r.ToString();
    }

    private byte ReadByte(ushort address)
    {
        if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D)
        {
            byte bank = (byte)(address >> 8);
            byte register = (byte)(address & 0xFF);
            Ring0.WriteIoPort(_port + ADDRESS_REGISTER_OFFSET, BANK_SELECT_REGISTER);
            Ring0.WriteIoPort(_port + DATA_REGISTER_OFFSET, bank);
            Ring0.WriteIoPort(_port + ADDRESS_REGISTER_OFFSET, register);
            return Ring0.ReadIoPort(_port + DATA_REGISTER_OFFSET);
        }

        byte page = (byte)(address >> 8);
        byte index = (byte)(address & 0xFF);
        Ring0.WriteIoPort(_port + EC_SPACE_PAGE_REGISTER_OFFSET, EC_SPACE_PAGE_SELECT);
        Ring0.WriteIoPort(_port + EC_SPACE_PAGE_REGISTER_OFFSET, page);
        Ring0.WriteIoPort(_port + EC_SPACE_INDEX_REGISTER_OFFSET, index);
        return Ring0.ReadIoPort(_port + EC_SPACE_DATA_REGISTER_OFFSET);
    }

    private void WriteByte(ushort address, byte value)
    {
        if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D)
        {
            byte bank = (byte)(address >> 8);
            byte register = (byte)(address & 0xFF);
            Ring0.WriteIoPort(_port + ADDRESS_REGISTER_OFFSET, BANK_SELECT_REGISTER);
            Ring0.WriteIoPort(_port + DATA_REGISTER_OFFSET, bank);
            Ring0.WriteIoPort(_port + ADDRESS_REGISTER_OFFSET, register);
            Ring0.WriteIoPort(_port + DATA_REGISTER_OFFSET, value);
        }
        else
        {
            byte page = (byte)(address >> 8);
            byte index = (byte)(address & 0xFF);
            Ring0.WriteIoPort(_port + EC_SPACE_PAGE_REGISTER_OFFSET, EC_SPACE_PAGE_SELECT);
            Ring0.WriteIoPort(_port + EC_SPACE_PAGE_REGISTER_OFFSET, page);
            Ring0.WriteIoPort(_port + EC_SPACE_INDEX_REGISTER_OFFSET, index);
            Ring0.WriteIoPort(_port + EC_SPACE_DATA_REGISTER_OFFSET, value);
        }
    }

    private bool IsNuvotonVendor()
    {
        return Chip is Chip.NCT6683D or Chip.NCT6686D or Chip.NCT6687D || ((ReadByte(VENDOR_ID_HIGH_REGISTER) << 8) | ReadByte(VENDOR_ID_LOW_REGISTER)) == NUVOTON_VENDOR_ID;
    }

    private void SaveDefaultFanControl(int index)
    {
        if (!_restoreDefaultFanControlRequired[index])
        {
            if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D)
            {
                _initialFanControlMode[index] = ReadByte(FAN_CONTROL_MODE_REG[index]);
            }
            else
            {
                byte mode = ReadByte(FAN_CONTROL_MODE_REG[index]);
                byte bitMask = (byte)(0x01 << index);
                _initialFanControlMode[index] = (byte)(mode & bitMask);
            }

            _initialFanPwmCommand[index] = ReadByte(FAN_PWM_COMMAND_REG[index]);
            _restoreDefaultFanControlRequired[index] = true;
        }
    }

    private void RestoreDefaultFanControl(int index)
    {
        if (_restoreDefaultFanControlRequired[index])
        {
            if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D)
            {
                WriteByte(FAN_CONTROL_MODE_REG[index], _initialFanControlMode[index]);
                WriteByte(FAN_PWM_COMMAND_REG[index], _initialFanPwmCommand[index]);
            }
            else
            {
                byte mode = ReadByte(FAN_CONTROL_MODE_REG[index]);
                mode = (byte)(mode & ~_initialFanControlMode[index]);
                WriteByte(FAN_CONTROL_MODE_REG[index], mode);

                WriteByte(FAN_PWM_REQUEST_REG[index], 0x80);
                Thread.Sleep(50);

                WriteByte(FAN_PWM_COMMAND_REG[index], _initialFanPwmCommand[index]);
                WriteByte(FAN_PWM_REQUEST_REG[index], 0x40);
                Thread.Sleep(50);
            }

            _restoreDefaultFanControlRequired[index] = false;
        }
    }

    private void DisableIOSpaceLock()
    {
        if (Chip is not Chip.NCT6791D and
            not Chip.NCT6792D and
            not Chip.NCT6792DA and
            not Chip.NCT6793D and
            not Chip.NCT6795D and
            not Chip.NCT6796D and
            not Chip.NCT6796DR and
            not Chip.NCT6797D and
            not Chip.NCT6798D and
            not Chip.NCT6799D)
        {
            return;
        }

        // the lock is disabled already if the vendor ID can be read
        if (IsNuvotonVendor())
            return;

        _lpcPort.WinbondNuvotonFintekEnter();
        _lpcPort.NuvotonDisableIOSpaceLock();
        _lpcPort.WinbondNuvotonFintekExit();
    }

    [SuppressMessage("ReSharper", "InconsistentNaming")]
    private enum SourceNct6771F : byte
    {
        SYSTIN = 1,
        CPUTIN = 2,
        AUXTIN = 3,
        PECI_0 = 5
    }

    [SuppressMessage("ReSharper", "InconsistentNaming")]
    private enum SourceNct6776F : byte
    {
        SYSTIN = 1,
        CPUTIN = 2,
        AUXTIN = 3,
        PECI_0 = 12
    }

    [SuppressMessage("ReSharper", "InconsistentNaming")]
    private enum SourceNct67Xxd : byte
    {
        SYSTIN = 1,
        CPUTIN = 2,
        AUXTIN0 = 3,
        AUXTIN1 = 4,
        AUXTIN2 = 5,
        AUXTIN3 = 6,
        AUXTIN4 = 7,
        SMBUSMASTER0 = 8,
        SMBUSMASTER1 = 9,
        PECI_0 = 16,
        PECI_1 = 17,
        PCH_CHIP_CPU_MAX_TEMP = 18,
        PCH_CHIP_TEMP = 19,
        PCH_CPU_TEMP = 20,
        PCH_MCH_TEMP = 21,
        AGENT0_DIMM0 = 22,
        AGENT0_DIMM1 = 23,
        AGENT1_DIMM0 = 24,
        AGENT1_DIMM1 = 25,
        BYTE_TEMP0 = 26,
        BYTE_TEMP1 = 27,
        PECI_0_CAL = 28,
        PECI_1_CAL = 29,
        VIRTUAL_TEMP = 31
    }

    [SuppressMessage("ReSharper", "InconsistentNaming")]
    private enum SourceNct610X : byte
    {
        SYSTIN = 1,
        CPUTIN = 2,
        AUXTIN = 3,
        PECI_0 = 12
    }

    // ReSharper disable InconsistentNaming
    private const uint ADDRESS_REGISTER_OFFSET = 0x05;
    private const byte BANK_SELECT_REGISTER = 0x4E;
    private const uint DATA_REGISTER_OFFSET = 0x06;

    // NCT668X
    private const uint EC_SPACE_PAGE_REGISTER_OFFSET = 0x04;
    private const uint EC_SPACE_INDEX_REGISTER_OFFSET = 0x05;
    private const uint EC_SPACE_DATA_REGISTER_OFFSET = 0x06;
    private const byte EC_SPACE_PAGE_SELECT = 0xFF;

    private const ushort NUVOTON_VENDOR_ID = 0x5CA3;

    private readonly ushort[] FAN_CONTROL_MODE_REG;
    private readonly ushort[] FAN_PWM_COMMAND_REG;
    private readonly ushort[] FAN_PWM_OUT_REG;
    private readonly ushort[] FAN_PWM_REQUEST_REG;

    private readonly ushort VENDOR_ID_HIGH_REGISTER;
    private readonly ushort VENDOR_ID_LOW_REGISTER;

    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/W836XX.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;
using System.Text;

// ReSharper disable once InconsistentNaming

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class W836XX : ISuperIO
{
    private readonly ushort _address;
    private readonly byte _revision;
    private readonly bool[] _peciTemperature = Array.Empty<bool>();
    private readonly byte[] _voltageBank = Array.Empty<byte>();
    private readonly float _voltageGain = 0.008f;
    private readonly byte[] _voltageRegister = Array.Empty<byte>();

    // Added to control fans. 
    private readonly byte[] _fanPwmRegister = Array.Empty<byte>();
    private readonly byte[] _fanPrimaryControlModeRegister = Array.Empty<byte>();
    private readonly byte[] _fanPrimaryControlValue = Array.Empty<byte>();
    private readonly byte[] _fanSecondaryControlModeRegister = Array.Empty<byte>();
    private readonly byte[] _fanSecondaryControlValue = Array.Empty<byte>();
    private readonly byte[] _fanTertiaryControlModeRegister = Array.Empty<byte>();
    private readonly byte[] _fanTertiaryControlValue = Array.Empty<byte>();

    private readonly byte[] _initialFanControlValue = Array.Empty<byte>();
    private readonly byte[] _initialFanSecondaryControlValue = Array.Empty<byte>();
    private readonly byte[] _initialFanTertiaryControlValue = Array.Empty<byte>();
    private readonly bool[] _restoreDefaultFanPwmControlRequired = Array.Empty<bool>();

    public W836XX(Chip chip, byte revision, ushort address)
    {
        _address = address;
        _revision = revision;
        Chip = chip;

        if (!IsWinbondVendor())
            return;

        Temperatures = new float?[3];
        _peciTemperature = new bool[3];
        switch (chip)
        {
            case Chip.W83667HG:
            case Chip.W83667HGB:
                // note temperature sensor registers that read PECI
                byte flag = ReadByte(0, TEMPERATURE_SOURCE_SELECT_REG);
                _peciTemperature[0] = (flag & 0x04) != 0;
                _peciTemperature[1] = (flag & 0x40) != 0;
                _peciTemperature[2] = false;
                break;

            case Chip.W83627DHG:
            case Chip.W83627DHGP:
                // note temperature sensor registers that read PECI
                byte sel = ReadByte(0, TEMPERATURE_SOURCE_SELECT_REG);
                _peciTemperature[0] = (sel & 0x07) != 0;
                _peciTemperature[1] = (sel & 0x70) != 0;
                _peciTemperature[2] = false;
                break;

            default:
                // no PECI support
                _peciTemperature[0] = false;
                _peciTemperature[1] = false;
                _peciTemperature[2] = false;
                break;
        }

        switch (chip)
        {
            case Chip.W83627EHF:
                Voltages = new float?[10];
                _voltageRegister = new byte[] { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x50, 0x51, 0x52 };
                _voltageBank = new byte[] { 0, 0, 0, 0, 0, 0, 0, 5, 5, 5 };
                _voltageGain = 0.008f;

                Fans = new float?[5];
                _fanPwmRegister = new byte[] { 0x01, 0x03, 0x11 }; // Fan PWM values.
                _fanPrimaryControlModeRegister = new byte[] { 0x04, 0x04, 0x12 }; // Primary control register.
                _fanPrimaryControlValue = new byte[] { 0b11110011, 0b11001111, 0b11111001 }; // Values to gain control of fans.
                _initialFanControlValue = new byte[3]; // To store primary default value.
                _initialFanSecondaryControlValue = new byte[3]; // To store secondary default value.

                Controls = new float?[3];
                break;

            case Chip.W83627DHG:
            case Chip.W83627DHGP:
                Voltages = new float?[9];
                _voltageRegister = new byte[] { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x50, 0x51 };
                _voltageBank = new byte[] { 0, 0, 0, 0, 0, 0, 0, 5, 5 };

                _voltageGain = 0.008f;
                Fans = new float?[5];
                _fanPwmRegister = new byte[] { 0x01, 0x03, 0x11 }; // Fan PWM values
                _fanPrimaryControlModeRegister = new byte[] { 0x04, 0x04, 0x12 }; // added. Primary control register
                _fanPrimaryControlValue = new byte[] { 0b11110011, 0b11001111, 0b11111001 }; // Values to gain control of fans
                _initialFanControlValue = new byte[3]; // To store primary default value
                _initialFanSecondaryControlValue = new byte[3]; // To store secondary default value.

                Controls = new float?[3];
                break;

            case Chip.W83667HG:
            case Chip.W83667HGB:
                Voltages = new float?[9];
                _voltageRegister = new byte[] { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x50, 0x51 };
                _voltageBank = new byte[] { 0, 0, 0, 0, 0, 0, 0, 5, 5 };
                _voltageGain = 0.008f;

                Fans = new float?[5];
                _fanPwmRegister = new byte[] { 0x01, 0x03, 0x11 }; // Fan PWM values.
                _fanPrimaryControlModeRegister = new byte[] { 0x04, 0x04, 0x12 }; // Primary control register.
                _fanPrimaryControlValue = new byte[] { 0b11110011, 0b11001111, 0b11111001 }; // Values to gain control of fans.
                _fanSecondaryControlModeRegister = new byte[] { 0x7c, 0x7c, 0x7c }; // Secondary control register for SmartFan4.
                _fanSecondaryControlValue = new byte[] { 0b11101111, 0b11011111, 0b10111111 }; // Values for secondary register to gain control of fans.
                _fanTertiaryControlModeRegister = new byte[] { 0x62, 0x7c, 0x62 }; // Tertiary control register. 2nd fan doesn't have Tertiary control, same as secondary to avoid change.
                _fanTertiaryControlValue = new byte[] { 0b11101111, 0b11011111, 0b11011111 }; // Values for tertiary register to gain control of fans. 2nd fan doesn't have Tertiary control, same as secondary to avoid change.

                _initialFanControlValue = new byte[3]; // To store primary default value.
                _initialFanSecondaryControlValue = new byte[3]; // To store secondary default value.
                _initialFanTertiaryControlValue = new byte[3]; // To store tertiary default value.
                Controls = new float?[3];
                break;

            case Chip.W83627HF:
                Voltages = new float?[7];
                _voltageRegister = new byte[] { 0x20, 0x21, 0x22, 0x23, 0x24, 0x50, 0x51 };
                _voltageBank = new byte[] { 0, 0, 0, 0, 0, 5, 5 };
                _voltageGain = 0.016f;

                Fans = new float?[3];
                _fanPwmRegister = new byte[] { 0x5A, 0x5B }; // Fan PWM values.

                Controls = new float?[2];
                break;

            case Chip.W83627THF:
                Voltages = new float?[7];
                _voltageRegister = new byte[] { 0x20, 0x21, 0x22, 0x23, 0x24, 0x50, 0x51 };
                _voltageBank = new byte[] { 0, 0, 0, 0, 0, 5, 5 };
                _voltageGain = 0.016f;

                Fans = new float?[3];
                _fanPwmRegister = new byte[] { 0x01, 0x03, 0x11 }; // Fan PWM values.
                _fanPrimaryControlModeRegister = new byte[] { 0x04, 0x04, 0x12 }; // Primary control register.
                _fanPrimaryControlValue = new byte[] { 0b11110011, 0b11001111, 0b11111001 }; // Values to gain control of fans.
                _initialFanControlValue = new byte[3]; // To store primary default value.

                Controls = new float?[3];
                break;

            case Chip.W83687THF:
                Voltages = new float?[7];
                _voltageRegister = new byte[] { 0x20, 0x21, 0x22, 0x23, 0x24, 0x50, 0x51 };
                _voltageBank = new byte[] { 0, 0, 0, 0, 0, 5, 5 };
                _voltageGain = 0.016f;

                Fans = new float?[3];
                break;
        }
    }

    public Chip Chip { get; }

    public float?[] Controls { get; } = Array.Empty<float?>();

    public float?[] Fans { get; } = Array.Empty<float?>();

    public float?[] Temperatures { get; } = Array.Empty<float?>();

    public float?[] Voltages { get; } = Array.Empty<float?>();

    public byte? ReadGpio(int index)
    {
        return null;
    }

    public void WriteGpio(int index, byte value)
    { }

    public void SetControl(int index, byte? value)
    {
        if (index < 0 || index >= Controls.Length)
            throw new ArgumentOutOfRangeException(nameof(index));

        if (!Ring0.WaitIsaBusMutex(10))
            return;

        if (value.HasValue)
        {
            SaveDefaultFanPwmControl(index);
            if (_fanPrimaryControlModeRegister.Length > 0)
            {
                WriteByte(0, _fanPrimaryControlModeRegister[index], (byte)(_fanPrimaryControlValue[index] & ReadByte(0, _fanPrimaryControlModeRegister[index])));
                if (_fanSecondaryControlModeRegister.Length > 0)
                {
                    if (_fanSecondaryControlModeRegister[index] != _fanPrimaryControlModeRegister[index])
                    {
                        WriteByte(0, _fanSecondaryControlModeRegister[index], (byte)(_fanSecondaryControlValue[index] & ReadByte(0, _fanSecondaryControlModeRegister[index])));
                    }

                    if (_fanTertiaryControlModeRegister.Length > 0 && _fanTertiaryControlModeRegister[index] != _fanSecondaryControlModeRegister[index])
                    {
                        WriteByte(0, _fanTertiaryControlModeRegister[index], (byte)(_fanTertiaryControlValue[index] & ReadByte(0, _fanTertiaryControlModeRegister[index])));
                    }
                }
            }

            // set output value
            WriteByte(0, _fanPwmRegister[index], value.Value);
        }
        else
        {
            RestoreDefaultFanPwmControl(index);
        }

        Ring0.ReleaseIsaBusMutex();
    }

    private void SaveDefaultFanPwmControl(int index) //added to save initial control values
    {
        if (_fanPrimaryControlModeRegister.Length > 0 &&
            _initialFanControlValue.Length > 0 &&
            _fanPrimaryControlValue.Length > 0 &&
            _restoreDefaultFanPwmControlRequired.Length > 0 &&
            !_restoreDefaultFanPwmControlRequired[index])
        {
            _initialFanControlValue[index] = ReadByte(0, _fanPrimaryControlModeRegister[index]);
            if (_fanSecondaryControlModeRegister.Length > 0 && _initialFanSecondaryControlValue.Length > 0 && _fanSecondaryControlValue.Length > 0)
            {
                if (_fanSecondaryControlModeRegister[index] != _fanPrimaryControlModeRegister[index])
                {
                    _initialFanSecondaryControlValue[index] = ReadByte(0, _fanSecondaryControlModeRegister[index]);
                }

                if (_fanTertiaryControlModeRegister.Length > 0 &&
                    _initialFanTertiaryControlValue.Length > 0 &&
                    _fanTertiaryControlValue.Length > 0 &&
                    _fanTertiaryControlModeRegister[index] != _fanSecondaryControlModeRegister[index])
                {
                    _initialFanTertiaryControlValue[index] = ReadByte(0, _fanTertiaryControlModeRegister[index]);
                }
            }

            _restoreDefaultFanPwmControlRequired[index] = true;
        }
    }

    private void RestoreDefaultFanPwmControl(int index) //added to restore initial control values
    {
        if (_fanPrimaryControlModeRegister.Length > 0 &&
            _initialFanControlValue.Length > 0 &&
            _fanPrimaryControlValue.Length > 0 &&
            _restoreDefaultFanPwmControlRequired.Length > 0 &&
            _restoreDefaultFanPwmControlRequired[index])
        {
            WriteByte(0,
                      _fanPrimaryControlModeRegister[index],
                      (byte)((_initialFanControlValue[index] & ~_fanPrimaryControlValue[index]) |
                             ReadByte(0, _fanPrimaryControlModeRegister[index]))); //bitwise operands to change only desired bits

            if (_fanSecondaryControlModeRegister.Length > 0 && _initialFanSecondaryControlValue.Length > 0 && _fanSecondaryControlValue.Length > 0)
            {
                if (_fanSecondaryControlModeRegister[index] != _fanPrimaryControlModeRegister[index])
                {
                    WriteByte(0,
                              _fanSecondaryControlModeRegister[index],
                              (byte)((_initialFanSecondaryControlValue[index] & ~_fanSecondaryControlValue[index]) |
                                     ReadByte(0, _fanSecondaryControlModeRegister[index]))); //bitwise operands to change only desired bits
                }

                if (_fanTertiaryControlModeRegister.Length > 0 &&
                    _initialFanTertiaryControlValue.Length > 0 &&
                    _fanTertiaryControlValue.Length > 0 &&
                    _fanTertiaryControlModeRegister[index] != _fanSecondaryControlModeRegister[index])
                {
                    WriteByte(0,
                              _fanTertiaryControlModeRegister[index],
                              (byte)((_initialFanTertiaryControlValue[index] & ~_fanTertiaryControlValue[index]) | ReadByte(0, _fanTertiaryControlModeRegister[index]))); //bitwise operands to change only desired bits
                }
            }

            _restoreDefaultFanPwmControlRequired[index] = false;
        }
    }

    public void Update()
    {
        if (!Ring0.WaitIsaBusMutex(10))
            return;

        for (int i = 0; i < Voltages.Length; i++)
        {
            if (_voltageRegister[i] != VOLTAGE_VBAT_REG)
            {
                // two special VCore measurement modes for W83627THF
                float fValue;
                if ((Chip == Chip.W83627HF || Chip == Chip.W83627THF || Chip == Chip.W83687THF) && i == 0)
                {
                    byte vrmConfiguration = ReadByte(0, 0x18);
                    int value = ReadByte(_voltageBank[i], _voltageRegister[i]);
                    if ((vrmConfiguration & 0x01) == 0)
                        fValue = 0.016f * value; // VRM8 formula
                    else
                        fValue = (0.00488f * value) + 0.69f; // VRM9 formula
                }
                else
                {
                    int value = ReadByte(_voltageBank[i], _voltageRegister[i]);
                    fValue = _voltageGain * value;
                }

                if (fValue > 0)
                    Voltages[i] = fValue;
                else
                    Voltages[i] = null;
            }
            else
            {
                // Battery voltage
                bool valid = (ReadByte(0, 0x5D) & 0x01) > 0;
                if (valid)
                {
                    Voltages[i] = _voltageGain * ReadByte(5, VOLTAGE_VBAT_REG);
                }
                else
                {
                    Voltages[i] = null;
                }
            }
        }

        for (int i = 0; i < Temperatures.Length; i++)
        {
            int value = (sbyte)ReadByte(TEMPERATURE_BANK[i], TEMPERATURE_REG[i]) << 1;
            if (TEMPERATURE_BANK[i] > 0)
                value |= ReadByte(TEMPERATURE_BANK[i], (byte)(TEMPERATURE_REG[i] + 1)) >> 7;

            float temperature = value / 2.0f;
            if (temperature is <= 125 and >= -55 && !_peciTemperature[i])
            {
                Temperatures[i] = temperature;
            }
            else
            {
                Temperatures[i] = null;
            }
        }

        ulong bits = 0;
        foreach (byte t in FAN_BIT_REG)
            bits = (bits << 8) | ReadByte(0, t);

        ulong newBits = bits;
        for (int i = 0; i < Fans.Length; i++)
        {
            int count = ReadByte(FAN_TACHO_BANK[i], FAN_TACHO_REG[i]);

            // assemble fan divisor
            int divisorBits = (int)(
                (((bits >> FAN_DIV_BIT2[i]) & 1) << 2) |
                (((bits >> FAN_DIV_BIT1[i]) & 1) << 1) |
                ((bits >> FAN_DIV_BIT0[i]) & 1));

            int divisor = 1 << divisorBits;

            Fans[i] = count < 0xff ? 1.35e6f / (count * divisor) : 0;

            switch (count)
            {
                // update fan divisor
                case > 192 when divisorBits < 7:
                    divisorBits++;
                    break;
                case < 96 when divisorBits > 0:
                    divisorBits--;
                    break;
            }

            newBits = SetBit(newBits, FAN_DIV_BIT2[i], (divisorBits >> 2) & 1);
            newBits = SetBit(newBits, FAN_DIV_BIT1[i], (divisorBits >> 1) & 1);
            newBits = SetBit(newBits, FAN_DIV_BIT0[i], divisorBits & 1);
        }

        for (int i = 0; i < Controls.Length; i++)
        {
            byte value = ReadByte(0, _fanPwmRegister[i]);
            Controls[i] = (float)Math.Round(value * 100.0f / 0xFF);
        }

        Ring0.ReleaseIsaBusMutex();
    }

    public string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("LPC " + GetType().Name);
        r.AppendLine();
        r.Append("Chip Id: 0x");
        r.AppendLine(Chip.ToString("X"));
        r.Append("Chip Revision: 0x");
        r.AppendLine(_revision.ToString("X", CultureInfo.InvariantCulture));
        r.Append("Base Address: 0x");
        r.AppendLine(_address.ToString("X4", CultureInfo.InvariantCulture));
        r.AppendLine();

        if (!Ring0.WaitIsaBusMutex(100))
            return r.ToString();

        r.AppendLine("Hardware Monitor Registers");
        r.AppendLine();
        r.AppendLine("      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
        r.AppendLine();
        for (int i = 0; i <= 0x7; i++)
        {
            r.Append(" ");
            r.Append((i << 4).ToString("X2", CultureInfo.InvariantCulture));
            r.Append("  ");
            for (int j = 0; j <= 0xF; j++)
            {
                r.Append(" ");
                r.Append(ReadByte(0, (byte)((i << 4) | j)).ToString("X2", CultureInfo.InvariantCulture));
            }

            r.AppendLine();
        }

        for (int k = 1; k <= 15; k++)
        {
            r.AppendLine("Bank " + k);
            for (int i = 0x5; i < 0x6; i++)
            {
                r.Append(" ");
                r.Append((i << 4).ToString("X2", CultureInfo.InvariantCulture));
                r.Append("  ");
                for (int j = 0; j <= 0xF; j++)
                {
                    r.Append(" ");
                    r.Append(ReadByte((byte)k, (byte)((i << 4) | j)).ToString("X2", CultureInfo.InvariantCulture));
                }

                r.AppendLine();
            }
        }

        r.AppendLine();
        Ring0.ReleaseIsaBusMutex();
        return r.ToString();
    }

    private byte ReadByte(byte bank, byte register)
    {
        Ring0.WriteIoPort((ushort)(_address + ADDRESS_REGISTER_OFFSET), BANK_SELECT_REGISTER);
        Ring0.WriteIoPort((ushort)(_address + DATA_REGISTER_OFFSET), bank);
        Ring0.WriteIoPort((ushort)(_address + ADDRESS_REGISTER_OFFSET), register);
        return Ring0.ReadIoPort((ushort)(_address + DATA_REGISTER_OFFSET));
    }

    private void WriteByte(byte bank, byte register, byte value)
    {
        Ring0.WriteIoPort((ushort)(_address + ADDRESS_REGISTER_OFFSET), BANK_SELECT_REGISTER);
        Ring0.WriteIoPort((ushort)(_address + DATA_REGISTER_OFFSET), bank);
        Ring0.WriteIoPort((ushort)(_address + ADDRESS_REGISTER_OFFSET), register);
        Ring0.WriteIoPort((ushort)(_address + DATA_REGISTER_OFFSET), value);
    }

    private bool IsWinbondVendor()
    {
        ushort vendorId = (ushort)((ReadByte(HIGH_BYTE, VENDOR_ID_REGISTER) << 8) | ReadByte(0, VENDOR_ID_REGISTER));
        return vendorId == WINBOND_VENDOR_ID;
    }

    private static ulong SetBit(ulong target, int bit, int value)
    {
        if ((value & 1) != value)
            throw new ArgumentException("Value must be one bit only.");

        if (bit is < 0 or > 63)
            throw new ArgumentException("Bit out of range.");

        ulong mask = (ulong)1 << bit;
        return value > 0 ? target | mask : target & ~mask;
    }
    // ReSharper disable InconsistentNaming

    private const byte ADDRESS_REGISTER_OFFSET = 0x05;
    private const byte BANK_SELECT_REGISTER = 0x4E;
    private const byte DATA_REGISTER_OFFSET = 0x06;
    private const byte HIGH_BYTE = 0x80;
    private const byte TEMPERATURE_SOURCE_SELECT_REG = 0x49;
    private const byte VENDOR_ID_REGISTER = 0x4F;
    private const byte VOLTAGE_VBAT_REG = 0x51;

    private const ushort WINBOND_VENDOR_ID = 0x5CA3;

    private readonly byte[] FAN_BIT_REG = { 0x47, 0x4B, 0x4C, 0x59, 0x5D };
    private readonly byte[] FAN_DIV_BIT0 = { 36, 38, 30, 8, 10 };
    private readonly byte[] FAN_DIV_BIT1 = { 37, 39, 31, 9, 11 };
    private readonly byte[] FAN_DIV_BIT2 = { 5, 6, 7, 23, 15 };
    private readonly byte[] FAN_TACHO_BANK = { 0, 0, 0, 0, 5 };
    private readonly byte[] FAN_TACHO_REG = { 0x28, 0x29, 0x2A, 0x3F, 0x53 };
    private readonly byte[] TEMPERATURE_BANK = { 1, 2, 0 };
    private readonly byte[] TEMPERATURE_REG = { 0x50, 0x50, 0x27 };

    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Manufacturer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Diagnostics.CodeAnalysis;

namespace LibreHardwareMonitor.Hardware.Motherboard;

[SuppressMessage("ReSharper", "IdentifierTypo")]
[SuppressMessage("ReSharper", "CommentTypo")]
[SuppressMessage("ReSharper", "InconsistentNaming")]
internal enum Manufacturer
{
    Abit,
    Acer,
    Alienware,
    AMD,
    AOpen,
    Apple,
    ASRock,
    ASUS,
    Biostar,
    Clevo,
    Dell,
    DFI,
    ECS,
    EPoX,
    EVGA,
    FIC,
    Foxconn,
    Fujitsu,
    Gateway,
    Gigabyte,
    HP,
    IBM,
    Intel,
    Jetway,
    LattePanda,
    Lenovo,
    Medion,
    Microsoft,
    MSI,
    NEC,
    Pegatron,
    Samsung,
    Sapphire,
    Shuttle,
    Sony,
    Supermicro,
    Toshiba,
    XFX,
    Zotac,
    Unknown
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Model.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

// ReSharper disable InconsistentNaming

using System.Diagnostics.CodeAnalysis;

namespace LibreHardwareMonitor.Hardware.Motherboard;

[SuppressMessage("ReSharper", "IdentifierTypo")]
[SuppressMessage("ReSharper", "CommentTypo")]
internal enum Model
{
    // ASRock
    _880GMH_USB3,
    A320M_HDV,
    AB350_Pro4,
    AB350M,
    AB350M_HDV,
    AB350M_Pro4,
    AOD790GX_128M,
    B450_Pro4,
    B450_Steel_Legend,
    B450M_Pro4,
    B450M_Steel_Legend,
    B85M_DGS,
    Fatal1ty_AB350_Gaming_K4,
    P55_Deluxe,
    X399_Phantom_Gaming_6,
    Z77Pro4M,
    X570_Pro4,
    X570_Taichi,
    X570_Phantom_Gaming_ITX,

    // ASUS
    CROSSHAIR_III_FORMULA,
    ROG_CROSSHAIR_VIII_HERO,
    ROG_CROSSHAIR_VIII_HERO_WIFI,
    ROG_CROSSHAIR_VIII_DARK_HERO,
    ROG_CROSSHAIR_VIII_FORMULA,
    ROG_CROSSHAIR_VIII_IMPACT,
    ROG_STRIX_X470_I,
    ROG_STRIX_X570_E_GAMING,
    ROG_STRIX_X570_F_GAMING,
    ROG_STRIX_X570_I_GAMING,
    ROG_STRIX_B550_E_GAMING,
    ROG_STRIX_B550_F_GAMING_WIFI,
    ROG_STRIX_B550_I_GAMING,
    ROG_STRIX_Z690_A_GAMING_WIFI_D4,
    ROG_MAXIMUS_Z690_EXTREME_GLACIAL,
    M2N_SLI_Deluxe,
    M4A79XTD_EVO,
    P5W_DH_Deluxe,
    P6T,
    P6X58D_E,
    P8P67,
    P8P67_EVO,
    P8P67_M_PRO,
    P8P67_PRO,
    P8Z77_V,
    P9X79,
    PRIME_X370_PRO,
    PRIME_X470_PRO,
    PRIME_X570_PRO,
    PROART_X570_CREATOR_WIFI,
    PRO_WS_X570_ACE,
    RAMPAGE_EXTREME,
    RAMPAGE_II_GENE,
    ROG_MAXIMUS_X_APEX,
    ROG_ZENITH_EXTREME,
    ROG_ZENITH_II_EXTREME,
    TUF_X470_PLUS_GAMING,
    Z170_A,
    TUF_GAMING_B550M_PLUS_WIFI,
    ROG_MAXIMUS_Z790_HERO,
    PRIME_Z690_A,

    //BIOSTAR
    B660GTN,

    // DFI
    LP_BI_P45_T2RS_Elite,
    LP_DK_P55_T3EH9,

    // ECS
    A890GXM_A,

    // MSI
    B350_Gaming_Plus,
    B360M_PRO_VDH,
    B450A_PRO,
    Z270_PC_MATE,

    // EVGA
    X58_SLI_Classified,

    // Gigabyte
    _965P_S3,
    _970A_UD3,
    AB350_Gaming_3,
    AX370_Gaming_5,
    AX370_Gaming_K7,
    B360_AORUS_GAMING_3_WIFI_CF,
    B560M_AORUS_ELITE,
    B560M_AORUS_PRO,
    B560M_AORUS_PRO_AX,
    EP45_DS3R,
    EP45_UD3R,
    EX58_EXTREME,
    EX58_UD3R,
    G41M_COMBO,
    G41MT_S2,
    G41MT_S2P,
    H55_USB3,
    H55N_USB3,
    H61M_DS2_REV_1_2,
    H61M_USB3_B3_REV_2_0,
    H67A_UD3H_B3,
    H67A_USB3_B3,
    H81M_HD3,
    MA770T_UD3,
    MA770T_UD3P,
    MA785GM_US2H,
    MA785GMT_UD2H,
    MA78LM_S2H,
    MA790X_UD3P,
    P35_DS3,
    P35_DS3L,
    P55_UD4,
    P55A_UD3,
    P55M_UD4,
    P67A_UD3_B3,
    P67A_UD3R_B3,
    P67A_UD4_B3,
    P8Z68_V_PRO,
    X38_DS5,
    X399_AORUS_Gaming_7,
    X58A_UD3R,
    X79_UD3,
    Z390_AORUS_ULTRA,
    Z390_AORUS_PRO,
    Z390_M_GAMING,
    Z390_UD,
    Z68A_D3H_B3,
    Z68AP_D3,
    Z68X_UD3H_B3,
    Z68X_UD7_B3,
    Z68XP_UD3R,
    Z690_AORUS_PRO,
    Z690_GAMING_X_DDR4,
    Z170N_WIFI,
    X470_AORUS_GAMING_7_WIFI,
    X570_AORUS_MASTER,
    X570_GAMING_X,
    X570_AORUS_ULTRA,

    // Shuttle
    FH67,

    // Unknown
    Unknown
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Motherboard.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Text;
using LibreHardwareMonitor.Hardware.Motherboard.Lpc;
using LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;
using OperatingSystem = LibreHardwareMonitor.Software.OperatingSystem;

namespace LibreHardwareMonitor.Hardware.Motherboard;

/// <summary>
/// Represents the motherboard of a computer with its <see cref="LpcIO"/> and <see cref="EmbeddedController"/> as <see cref="SubHardware"/>.
/// </summary>
public class Motherboard : IHardware
{
    private readonly LMSensors _lmSensors;
    private readonly LpcIO _lpcIO;
    private readonly string _name;
    private readonly ISettings _settings;
    private string _customName;

    /// <summary>
    /// Creates motherboard instance by retrieving information from <see cref="LibreHardwareMonitor.Hardware.SMBios"/> and creates a new <see cref="SubHardware"/> based on data from <see cref="LpcIO"/> and <see cref="EmbeddedController"/>.
    /// </summary>
    /// <param name="smBios"><see cref="LibreHardwareMonitor.Hardware.SMBios"/> table containing motherboard data.</param>
    /// <param name="settings">Additional settings passed by <see cref="IComputer"/>.</param>
    public Motherboard(SMBios smBios, ISettings settings)
    {
        IReadOnlyList<ISuperIO> superIO;
        _settings = settings;
        SMBios = smBios;

        Manufacturer manufacturer = smBios.Board == null ? Manufacturer.Unknown : Identification.GetManufacturer(smBios.Board.ManufacturerName);
        Model model = smBios.Board == null ? Model.Unknown : Identification.GetModel(smBios.Board.ProductName);

        if (smBios.Board != null)
        {
            if (!string.IsNullOrEmpty(smBios.Board.ProductName))
            {
                if (manufacturer == Manufacturer.Unknown)
                    _name = smBios.Board.ProductName;
                else
                    _name = manufacturer + " " + smBios.Board.ProductName;
            }
            else
            {
                _name = manufacturer.ToString();
            }
        }
        else
        {
            _name = nameof(Manufacturer.Unknown);
        }

        _customName = settings.GetValue(new Identifier(Identifier, "name").ToString(), _name);

        if (OperatingSystem.IsUnix)
        {
            _lmSensors = new LMSensors();
            superIO = _lmSensors.SuperIO;
        }
        else
        {
            _lpcIO = new LpcIO();
            superIO = _lpcIO.SuperIO;
        }

        EmbeddedController embeddedController = EmbeddedController.Create(model, settings);

        SubHardware = new IHardware[superIO.Count + (embeddedController != null ? 1 : 0)];
        for (int i = 0; i < superIO.Count; i++)
            SubHardware[i] = new SuperIOHardware(this, superIO[i], manufacturer, model, settings);

        if (embeddedController != null)
            SubHardware[superIO.Count] = embeddedController;
    }

    /// <inheritdoc/>
    public event SensorEventHandler SensorAdded;

    /// <inheritdoc/>
    public event SensorEventHandler SensorRemoved;

    /// <returns><see cref="HardwareType.Motherboard"/></returns>
    public HardwareType HardwareType
    {
        get { return HardwareType.Motherboard; }
    }

    /// <inheritdoc/>
    public Identifier Identifier
    {
        get { return new Identifier("motherboard"); }
    }

    /// <summary>
    /// Gets the name obtained from <see cref="LibreHardwareMonitor.Hardware.SMBios"/>.
    /// </summary>
    public string Name
    {
        get { return _customName; }
        set
        {
            _customName = !string.IsNullOrEmpty(value) ? value : _name;

            _settings.SetValue(new Identifier(Identifier, "name").ToString(), _customName);
        }
    }

    /// <inheritdoc/>
    /// <returns>Always <see langword="null"/></returns>
    public virtual IHardware Parent
    {
        get { return null; }
    }

    /// <inheritdoc/>
    public virtual IDictionary<string, string> Properties => new SortedDictionary<string, string>();

    /// <inheritdoc/>
    public ISensor[] Sensors
    {
        get { return Array.Empty<ISensor>(); }
    }

    /// <summary>
    /// Gets the <see cref="LibreHardwareMonitor.Hardware.SMBios"/> information.
    /// </summary>
    public SMBios SMBios { get; }

    /// <inheritdoc/>
    public IHardware[] SubHardware { get; }

    /// <inheritdoc/>
    public string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("Motherboard");
        r.AppendLine();
        r.Append(SMBios.GetReport());

        if (_lpcIO != null)
            r.Append(_lpcIO.GetReport());

        return r.ToString();
    }

    /// <summary>
    /// Motherboard itself cannot be updated. Update <see cref="SubHardware"/> instead.
    /// </summary>
    public void Update()
    {}

    /// <inheritdoc/>
    public void Accept(IVisitor visitor)
    {
        if (visitor == null)
            throw new ArgumentNullException(nameof(visitor));

        visitor.VisitHardware(this);
    }

    /// <inheritdoc/>
    public void Traverse(IVisitor visitor)
    {
        foreach (IHardware hardware in SubHardware)
            hardware.Accept(visitor);
    }

    /// <summary>
    /// Closes <see cref="SubHardware"/> using <see cref="Hardware.Close"/>.
    /// </summary>
    public void Close()
    {
        _lmSensors?.Close();
        foreach (IHardware iHardware in SubHardware)
        {
            if (iHardware is Hardware hardware)
                hardware.Close();
        }
    }
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/MotherboardGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Motherboard;

internal class MotherboardGroup : IGroup
{
    private readonly Motherboard[] _motherboards;

    public MotherboardGroup(SMBios smbios, ISettings settings)
    {
        _motherboards = new Motherboard[1];
        _motherboards[0] = new Motherboard(smbios, settings);
    }

    public IReadOnlyList<IHardware> Hardware => _motherboards;

    public void Close()
    {
        foreach (Motherboard mainboard in _motherboards)
            mainboard.Close();
    }

    public string GetReport()
    {
        return null;
    }
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/SuperIOHardware.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Threading;
using LibreHardwareMonitor.Hardware.Motherboard.Lpc;

namespace LibreHardwareMonitor.Hardware.Motherboard;

internal sealed class SuperIOHardware : Hardware
{
    private readonly List<Sensor> _controls = new();
    private readonly List<Sensor> _fans = new();
    private readonly Motherboard _motherboard;

    private readonly UpdateDelegate _postUpdate;
    private readonly ReadValueDelegate _readControl;
    private readonly ReadValueDelegate _readFan;
    private readonly ReadValueDelegate _readTemperature;
    private readonly ReadValueDelegate _readVoltage;

    private readonly ISuperIO _superIO;
    private readonly List<Sensor> _temperatures = new();
    private readonly List<Sensor> _voltages = new();

    public SuperIOHardware(Motherboard motherboard, ISuperIO superIO, Manufacturer manufacturer, Model model, ISettings settings)
        : base(ChipName.GetName(superIO.Chip), new Identifier("lpc", superIO.Chip.ToString().ToLowerInvariant()), settings)
    {
        _motherboard = motherboard;
        _superIO = superIO;

        GetBoardSpecificConfiguration(superIO,
                                      manufacturer,
                                      model,
                                      out IList<Voltage> v,
                                      out IList<Temperature> t,
                                      out IList<Fan> f,
                                      out IList<Ctrl> c,
                                      out _readVoltage,
                                      out _readTemperature,
                                      out _readFan,
                                      out _readControl,
                                      out _postUpdate,
                                      out _);

        CreateVoltageSensors(superIO, settings, v);
        CreateTemperatureSensors(superIO, settings, t);
        CreateFanSensors(superIO, settings, f);
        CreateControlSensors(superIO, settings, c);
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.SuperIO; }
    }

    public override IHardware Parent
    {
        get { return _motherboard; }
    }

    private void CreateControlSensors(ISuperIO superIO, ISettings settings, IList<Ctrl> c)
    {
        foreach (Ctrl ctrl in c)
        {
            int index = ctrl.Index;
            if (index < superIO.Controls.Length)
            {
                Sensor sensor = new(ctrl.Name, index, SensorType.Control, this, settings);
                Control control = new(sensor, settings, 0, 100);
                control.ControlModeChanged += cc =>
                {
                    switch (cc.ControlMode)
                    {
                        case ControlMode.Undefined:
                            return;
                        case ControlMode.Default:
                            superIO.SetControl(index, null);
                            break;
                        case ControlMode.Software:
                            superIO.SetControl(index, GetSoftwareValueAsByte(cc));
                            break;
                        default:
                            return;
                    }
                };

                control.SoftwareControlValueChanged += cc =>
                {
                    if (cc.ControlMode == ControlMode.Software)
                        superIO.SetControl(index, GetSoftwareValueAsByte(cc));
                };

                switch (control.ControlMode)
                {
                    case ControlMode.Undefined:
                        break;
                    case ControlMode.Default:
                        superIO.SetControl(index, null);
                        break;
                    case ControlMode.Software:
                        superIO.SetControl(index, GetSoftwareValueAsByte(control));
                        break;
                }

                sensor.Control = control;
                _controls.Add(sensor);
                ActivateSensor(sensor);
            }
        }
    }

    private static byte GetSoftwareValueAsByte(Control control)
    {
        const float percentToByteRatio = 2.55f;
        float value = control.SoftwareValue * percentToByteRatio;
        return (byte)value;
    }

    private void CreateFanSensors(ISuperIO superIO, ISettings settings, IList<Fan> f)
    {
        foreach (Fan fan in f)
        {
            if (fan.Index < superIO.Fans.Length)
            {
                Sensor sensor = new(fan.Name, fan.Index, SensorType.Fan, this, settings);
                _fans.Add(sensor);
            }
        }
    }

    private void CreateTemperatureSensors(ISuperIO superIO, ISettings settings, IList<Temperature> t)
    {
        foreach (Temperature temperature in t)
        {
            if (temperature.Index < superIO.Temperatures.Length)
            {
                Sensor sensor = new(temperature.Name,
                                    temperature.Index,
                                    SensorType.Temperature,
                                    this,
                                    new[] { new ParameterDescription("Offset [°C]", "Temperature offset.", 0) },
                                    settings);

                _temperatures.Add(sensor);
            }
        }
    }

    private void CreateVoltageSensors(ISuperIO superIO, ISettings settings, IList<Voltage> v)
    {
        const string formula = "Voltage = value + (value - Vf) * Ri / Rf.";
        foreach (Voltage voltage in v)
        {
            if (voltage.Index < superIO.Voltages.Length)
            {
                Sensor sensor = new(voltage.Name,
                                    voltage.Index,
                                    voltage.Hidden,
                                    SensorType.Voltage,
                                    this,
                                    new[]
                                    {
                                        new ParameterDescription("Ri [kΩ]", "Input resistance.\n" + formula, voltage.Ri),
                                        new ParameterDescription("Rf [kΩ]", "Reference resistance.\n" + formula, voltage.Rf),
                                        new ParameterDescription("Vf [V]", "Reference voltage.\n" + formula, voltage.Vf)
                                    },
                                    settings);

                _voltages.Add(sensor);
            }
        }
    }

    private static void GetBoardSpecificConfiguration
    (
        ISuperIO superIO,
        Manufacturer manufacturer,
        Model model,
        out IList<Voltage> v,
        out IList<Temperature> t,
        out IList<Fan> f,
        out IList<Ctrl> c,
        out ReadValueDelegate readVoltage,
        out ReadValueDelegate readTemperature,
        out ReadValueDelegate readFan,
        out ReadValueDelegate readControl,
        out UpdateDelegate postUpdate,
        out Mutex mutex)
    {
        readVoltage = index => superIO.Voltages[index];
        readTemperature = index => superIO.Temperatures[index];
        readFan = index => superIO.Fans[index];
        readControl = index => superIO.Controls[index];

        postUpdate = () => { };
        mutex = null;

        v = new List<Voltage>();
        t = new List<Temperature>();
        f = new List<Fan>();
        c = new List<Ctrl>();

        switch (superIO.Chip)
        {
            case Chip.IT8705F:
            case Chip.IT8712F:
            case Chip.IT8716F:
            case Chip.IT8718F:
            case Chip.IT8720F:
            case Chip.IT8726F:
                GetIteConfigurationsA(superIO, manufacturer, model, v, t, f, c, ref readFan, ref postUpdate, ref mutex);
                break;

            case Chip.IT8613E:
            case Chip.IT8620E:
            case Chip.IT8628E:
            case Chip.IT8631E:
            case Chip.IT8655E:
            case Chip.IT8665E:
            case Chip.IT8686E:
            case Chip.IT8688E:
            case Chip.IT8689E:
            case Chip.IT8721F:
            case Chip.IT8728F:
            case Chip.IT8771E:
            case Chip.IT8772E:
                GetIteConfigurationsB(superIO, manufacturer, model, v, t, f, c);
                break;

            case Chip.IT8695E:
            case Chip.IT879XE:
                GetIteConfigurationsC(superIO, manufacturer, model, v, t, f, c);
                break;

            case Chip.F71858:
                v.Add(new Voltage("VCC3V", 0, 150, 150));
                v.Add(new Voltage("VSB3V", 1, 150, 150));
                v.Add(new Voltage("Battery", 2, 150, 150));

                for (int i = 0; i < superIO.Temperatures.Length; i++)
                    t.Add(new Temperature("Temperature #" + (i + 1), i));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                break;

            case Chip.F71808E:
            case Chip.F71862:
            case Chip.F71869:
            case Chip.F71869A:
            case Chip.F71882:
            case Chip.F71889AD:
            case Chip.F71889ED:
            case Chip.F71889F:
                GetFintekConfiguration(superIO, manufacturer, model, v, t, f, c);
                break;

            case Chip.W83627EHF:
                GetWinbondConfigurationEhf(manufacturer, model, v, t, f, c);
                break;

            case Chip.W83627DHG:
            case Chip.W83627DHGP:
            case Chip.W83667HG:
            case Chip.W83667HGB:
                GetWinbondConfigurationHg(manufacturer, model, v, t, f, c);
                break;

            case Chip.W83627HF:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("Voltage #3", 2, true));
                v.Add(new Voltage("AVCC", 3, 34, 51));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("+5VSB", 5, 34, 51));
                v.Add(new Voltage("VBat", 6));
                t.Add(new Temperature("CPU", 0));
                t.Add(new Temperature("Auxiliary", 1));
                t.Add(new Temperature("System", 2));
                f.Add(new Fan("System Fan", 0));
                f.Add(new Fan("CPU Fan", 1));
                f.Add(new Fan("Auxiliary Fan", 2));
                c.Add(new Ctrl("Fan 1", 0));
                c.Add(new Ctrl("Fan 2", 1));
                break;

            case Chip.W83627THF:
            case Chip.W83687THF:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("Voltage #3", 2, true));
                v.Add(new Voltage("AVCC", 3, 34, 51));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("+5VSB", 5, 34, 51));
                v.Add(new Voltage("VBat", 6));
                t.Add(new Temperature("CPU", 0));
                t.Add(new Temperature("Auxiliary", 1));
                t.Add(new Temperature("System", 2));
                f.Add(new Fan("System Fan", 0));
                f.Add(new Fan("CPU Fan", 1));
                f.Add(new Fan("Auxiliary Fan", 2));
                c.Add(new Ctrl("System Fan", 0));
                c.Add(new Ctrl("CPU Fan", 1));
                c.Add(new Ctrl("Auxiliary Fan", 2));
                break;

            case Chip.NCT6771F:
            case Chip.NCT6776F:
                GetNuvotonConfigurationF(superIO, manufacturer, model, v, t, f, c);
                break;

            case Chip.NCT610XD:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #0", 1, true));
                v.Add(new Voltage("AVCC", 2, 34, 34));
                v.Add(new Voltage("+3.3V", 3, 34, 34));
                v.Add(new Voltage("Voltage #1", 4, true));
                v.Add(new Voltage("Voltage #2", 5, true));
                v.Add(new Voltage("Reserved", 6, true));
                v.Add(new Voltage("3VSB", 7, 34, 34));
                v.Add(new Voltage("VBat", 8, 34, 34));
                v.Add(new Voltage("Voltage #10", 9, true));
                t.Add(new Temperature("System", 1));
                t.Add(new Temperature("CPU Core", 2));
                t.Add(new Temperature("Auxiliary", 3));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Ctrl("Fan #" + (i + 1), i));

                break;

            case Chip.NCT6779D:
            case Chip.NCT6791D:
            case Chip.NCT6792D:
            case Chip.NCT6792DA:
            case Chip.NCT6793D:
            case Chip.NCT6795D:
            case Chip.NCT6796D:
            case Chip.NCT6796DR:
            case Chip.NCT6797D:
            case Chip.NCT6798D:
            case Chip.NCT6799D:
            case Chip.NCT6683D:
                GetNuvotonConfigurationD(superIO, manufacturer, model, v, t, f, c);
                break;

            case Chip.NCT6686D:
            case Chip.NCT6687D:
                v.Add(new Voltage("+12V", 0));
                v.Add(new Voltage("+5V", 1));
                v.Add(new Voltage("Vcore", 2));
                v.Add(new Voltage("Voltage #1", 3));
                v.Add(new Voltage("DIMM", 4));
                v.Add(new Voltage("CPU I/O", 5));
                v.Add(new Voltage("CPU SA", 6));
                v.Add(new Voltage("Voltage #2", 7));
                v.Add(new Voltage("AVCC3", 8));
                v.Add(new Voltage("VTT", 9));
                v.Add(new Voltage("VRef", 10));
                v.Add(new Voltage("VSB", 11));
                v.Add(new Voltage("AVSB", 12));
                v.Add(new Voltage("VBat", 13));

                t.Add(new Temperature("CPU", 0));
                t.Add(new Temperature("System", 1));
                t.Add(new Temperature("VRM MOS", 2));
                t.Add(new Temperature("PCH", 3));
                t.Add(new Temperature("CPU Socket", 4));
                t.Add(new Temperature("PCIe x1", 5));
                t.Add(new Temperature("M2_1", 6));

                f.Add(new Fan("CPU Fan", 0));
                f.Add(new Fan("Pump Fan", 1));
                f.Add(new Fan("System Fan #1", 2));
                f.Add(new Fan("System Fan #2", 3));
                f.Add(new Fan("System Fan #3", 4));
                f.Add(new Fan("System Fan #4", 5));
                f.Add(new Fan("System Fan #5", 6));
                f.Add(new Fan("System Fan #6", 7));

                c.Add(new Ctrl("CPU Fan", 0));
                c.Add(new Ctrl("Pump Fan", 1));
                c.Add(new Ctrl("System Fan #1", 2));
                c.Add(new Ctrl("System Fan #2", 3));
                c.Add(new Ctrl("System Fan #3", 4));
                c.Add(new Ctrl("System Fan #4", 5));
                c.Add(new Ctrl("System Fan #5", 6));
                c.Add(new Ctrl("System Fan #6", 7));

                break;

            default:
                GetDefaultConfiguration(superIO, v, t, f, c);
                break;
        }
    }

    private static void GetDefaultConfiguration(ISuperIO superIO, ICollection<Voltage> v, ICollection<Temperature> t, ICollection<Fan> f, ICollection<Ctrl> c)
    {
        for (int i = 0; i < superIO.Voltages.Length; i++)
            v.Add(new Voltage("Voltage #" + (i + 1), i, true));

        for (int i = 0; i < superIO.Temperatures.Length; i++)
            t.Add(new Temperature("Temperature #" + (i + 1), i));

        for (int i = 0; i < superIO.Fans.Length; i++)
            f.Add(new Fan("Fan #" + (i + 1), i));

        for (int i = 0; i < superIO.Controls.Length; i++)
            c.Add(new Ctrl("Fan #" + (i + 1), i));
    }

    private static void GetIteConfigurationsA
    (
        ISuperIO superIO,
        Manufacturer manufacturer,
        Model model,
        IList<Voltage> v,
        IList<Temperature> t,
        IList<Fan> f,
        ICollection<Ctrl> c,
        ref ReadValueDelegate readFan,
        ref UpdateDelegate postUpdate,
        ref Mutex mutex)
    {
        switch (manufacturer)
        {
            case Manufacturer.ASUS:
                switch (model)
                {
                    case Model.CROSSHAIR_III_FORMULA: // IT8720F
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("CPU", 0));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        break;

                    case Model.M2N_SLI_Deluxe:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 30, 10));
                        v.Add(new Voltage("+5VSB", 7, 6.8f, 10));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Chassis Fan #1", 1));
                        f.Add(new Fan("Power Fan", 2));

                        break;

                    case Model.M4A79XTD_EVO: // IT8720F
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Chassis Fan #1", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));

                        break;

                    case Model.PRIME_X370_PRO: // IT8665E
                    case Model.TUF_X470_PLUS_GAMING:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("SB 2.5V", 1));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("Voltage #4", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3.3V", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        v.Add(new Voltage("Voltage #10", 9, true));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        t.Add(new Temperature("PCH", 2));

                        for (int i = 3; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        f.Add(new Fan("CPU Fan", 0));

                        for (int i = 1; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        break;

                    case Model.ROG_ZENITH_EXTREME: // IT8665E
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("DIMM AB", 1, 10, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("SB 1.05V", 4, 10, 10));
                        v.Add(new Voltage("DIMM CD", 5, 10, 10));
                        v.Add(new Voltage("1.8V PLL", 6, 10, 10));
                        v.Add(new Voltage("+3.3V", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        t.Add(new Temperature("CPU Socket", 2));
                        t.Add(new Temperature("Temperature #4", 3));
                        t.Add(new Temperature("Temperature #5", 4));
                        t.Add(new Temperature("VRM", 5));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Chassis Fan #1", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("High Amp Fan", 3));
                        f.Add(new Fan("Fan 5", 4));
                        f.Add(new Fan("Fan 6", 5));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("Voltage #8", 7, true));
                        v.Add(new Voltage("VBat", 8));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.ASRock:
                switch (model)
                {
                    case Model.P55_Deluxe: // IT8720F
                        GetASRockConfiguration(superIO,
                                               v,
                                               t,
                                               f,
                                               ref readFan,
                                               ref postUpdate,
                                               out mutex);

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("Voltage #8", 7, true));
                        v.Add(new Voltage("VBat", 8));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.DFI:
                switch (model)
                {
                    case Model.LP_BI_P45_T2RS_Elite: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("VTT", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 30, 10));
                        v.Add(new Voltage("NB Core", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+5VSB", 7, 6.8f, 10));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("System", 1));
                        t.Add(new Temperature("Chipset", 2));
                        f.Add(new Fan("Fan #1", 0));
                        f.Add(new Fan("Fan #2", 1));
                        f.Add(new Fan("Fan #3", 2));

                        break;

                    case Model.LP_DK_P55_T3EH9: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("VTT", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 30, 10));
                        v.Add(new Voltage("CPU PLL", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+5VSB", 7, 6.8f, 10));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("Chipset", 0));
                        t.Add(new Temperature("CPU PWM", 1));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("Fan #1", 0));
                        f.Add(new Fan("Fan #2", 1));
                        f.Add(new Fan("Fan #3", 2));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("VTT", 1, true));
                        v.Add(new Voltage("+3.3V", 2, true));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10, 0, true));
                        v.Add(new Voltage("+12V", 4, 30, 10, 0, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("DIMM", 6, true));
                        v.Add(new Voltage("+5VSB", 7, 6.8f, 10, 0, true));
                        v.Add(new Voltage("VBat", 8));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.Gigabyte:
                switch (model)
                {
                    case Model._965P_S3: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 7, 24.3f, 8.2f));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));

                        break;

                    case Model.EP45_DS3R: // IT8718F
                    case Model.EP45_UD3R:
                    case Model.X38_DS5:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 7, 24.3f, 8.2f));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #2", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #1", 3));

                        break;

                    case Model.EX58_EXTREME: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Northbridge", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #2", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #1", 3));

                        break;

                    case Model.P35_DS3: // IT8718F
                    case Model.P35_DS3L: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 7, 24.3f, 8.2f));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("Power Fan", 3));

                        break;

                    case Model.P55_UD4: // IT8720F
                    case Model.P55A_UD3: // IT8720F
                    case Model.P55M_UD4: // IT8720F
                    case Model.H55_USB3: // IT8720F
                    case Model.EX58_UD3R: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 5, 24.3f, 8.2f));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #2", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #1", 3));

                        break;

                    case Model.H55N_USB3: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 5, 24.3f, 8.2f));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));

                        break;

                    case Model.G41M_COMBO: // IT8718F
                    case Model.G41MT_S2: // IT8718F
                    case Model.G41MT_S2P: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 7, 24.3f, 8.2f));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));

                        break;

                    case Model._970A_UD3: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 24.3f, 8.2f));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("Power Fan", 4));
                        c.Add(new Ctrl("PWM #1", 0));
                        c.Add(new Ctrl("PWM #2", 1));
                        c.Add(new Ctrl("PWM #3", 2));

                        break;

                    case Model.MA770T_UD3: // IT8720F
                    case Model.MA770T_UD3P: // IT8720F
                    case Model.MA790X_UD3P: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 24.3f, 8.2f));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("Power Fan", 3));

                        break;

                    case Model.MA78LM_S2H: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 24.3f, 8.2f));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("VRM", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("Power Fan", 3));

                        break;

                    case Model.MA785GM_US2H: // IT8718F
                    case Model.MA785GMT_UD2H: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 24.3f, 8.2f));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));
                        f.Add(new Fan("NB Fan", 2));

                        break;

                    case Model.X58A_UD3R: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 5, 24.3f, 8.2f));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Northbridge", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #2", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #1", 3));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1, true));
                        v.Add(new Voltage("+3.3V", 2, true));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10, 0, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("Voltage #8", 7, true));
                        v.Add(new Voltage("VBat", 8));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("Voltage #3", 2, true));
                v.Add(new Voltage("Voltage #4", 3, true));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("Voltage #8", 7, true));
                v.Add(new Voltage("VBat", 8));

                for (int i = 0; i < superIO.Temperatures.Length; i++)
                    t.Add(new Temperature("Temperature #" + (i + 1), i));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Ctrl("Fan #" + (i + 1), i));

                break;
        }
    }

    private static void GetASRockConfiguration
    (
        ISuperIO superIO,
        IList<Voltage> v,
        IList<Temperature> t,
        IList<Fan> f,
        ref ReadValueDelegate readFan,
        ref UpdateDelegate postUpdate,
        out Mutex mutex)
    {
        v.Add(new Voltage("Vcore", 0));
        v.Add(new Voltage("+3.3V", 2));
        v.Add(new Voltage("+12V", 4, 30, 10));
        v.Add(new Voltage("+5V", 5, 6.8f, 10));
        v.Add(new Voltage("VBat", 8));
        t.Add(new Temperature("CPU", 0));
        t.Add(new Temperature("Motherboard", 1));
        f.Add(new Fan("CPU Fan", 0));
        f.Add(new Fan("Chassis Fan #1", 1));

        // this mutex is also used by the official ASRock tool
        mutex = new Mutex(false, "ASRockOCMark");

        bool exclusiveAccess = false;
        try
        {
            exclusiveAccess = mutex.WaitOne(10, false);
        }
        catch (AbandonedMutexException)
        { }
        catch (InvalidOperationException)
        { }

        // only read additional fans if we get exclusive access
        if (exclusiveAccess)
        {
            f.Add(new Fan("Chassis Fan #2", 2));
            f.Add(new Fan("Chassis Fan #3", 3));
            f.Add(new Fan("Power Fan", 4));

            readFan = index =>
            {
                if (index < 2)
                {
                    return superIO.Fans[index];
                }

                // get GPIO 80-87
                byte? gpio = superIO.ReadGpio(7);
                if (!gpio.HasValue)
                    return null;

                // read the last 3 fans based on GPIO 83-85
                int[] masks = { 0x05, 0x03, 0x06 };
                return ((gpio.Value >> 3) & 0x07) == masks[index - 2] ? superIO.Fans[2] : null;
            };

            int fanIndex = 0;

            postUpdate = () =>
            {
                // get GPIO 80-87
                byte? gpio = superIO.ReadGpio(7);
                if (!gpio.HasValue)
                    return;

                // prepare the GPIO 83-85 for the next update
                int[] masks = { 0x05, 0x03, 0x06 };
                superIO.WriteGpio(7, (byte)((gpio.Value & 0xC7) | (masks[fanIndex] << 3)));
                fanIndex = (fanIndex + 1) % 3;
            };
        }
    }

    private static void GetIteConfigurationsB(ISuperIO superIO, Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Ctrl> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.ASUS:
                switch (model)
                {
                    case Model.ROG_STRIX_X470_I: // IT8665E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("SB 2.5V", 1));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("+3.3V", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        t.Add(new Temperature("T_Sensor", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM", 4));
                        t.Add(new Temperature("Temperature #6", 5));

                        f.Add(new Fan("CPU Fan", 0));

                        //Does not work when in AIO pump mode (shows 0). I don't know how to fix it.
                        f.Add(new Fan("Chassis Fan #1", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));

                        //offset: 2, because the first two always show zero
                        for (int i = 2; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i - 1), i));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("Voltage #8", 7, true));
                        v.Add(new Voltage("VBat", 8));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.ECS:
                switch (model)
                {
                    case Model.A890GXM_A: // IT8721F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("NB Voltage", 2));
                        v.Add(new Voltage("AVCC", 3, 10, 10));
                        // v.Add(new Voltage("DIMM", 6, true));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("System", 1));
                        t.Add(new Temperature("Northbridge", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));
                        f.Add(new Fan("Power Fan", 2));

                        break;

                    default:
                        v.Add(new Voltage("Voltage #1", 0, true));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("AVCC", 3, 10, 10, 0, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 10, 10, 0, true));
                        v.Add(new Voltage("VBat", 8, 10, 10));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.Gigabyte:
                switch (model)
                {
                    case Model.H61M_DS2_REV_1_2: // IT8728F
                    case Model.H61M_USB3_B3_REV_2_0: // IT8728F
                        v.Add(new Voltage("VTT", 0));
                        v.Add(new Voltage("+12V", 2, 30.9f, 10));
                        v.Add(new Voltage("Vcore", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));

                        break;

                    case Model.H67A_UD3H_B3: // IT8728F
                    case Model.H67A_USB3_B3: // IT8728F
                        v.Add(new Voltage("VTT", 0));
                        v.Add(new Voltage("+5V", 1, 15, 10));
                        v.Add(new Voltage("+12V", 2, 30.9f, 10));
                        v.Add(new Voltage("Vcore", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #2", 3));

                        break;

                    case Model.H81M_HD3: //IT8620E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("iGPU", 4));
                        v.Add(new Voltage("CPU VRIN", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("System", 0));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));
                        c.Add(new Ctrl("CPU Fan", 0));
                        c.Add(new Ctrl("System Fan", 1));

                        break;

                    case Model.Z170N_WIFI: // ITE IT8628E
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        // NO DIMM CD channels on this motherboard; gives a very tiny voltage reading
                        // v.Add(new Voltage("DIMM CD", 4, 0, 1));
                        v.Add(new Voltage("iGPU VAXG", 5, 0, 1));
                        v.Add(new Voltage("DIMM AB", 6, 0, 1));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        v.Add(new Voltage("AVCC3", 9, 54, 10));

                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM", 4));
                        t.Add(new Temperature("System #2", 5));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));

                        c.Add(new Ctrl("CPU Fan", 0));
                        c.Add(new Ctrl("System Fan", 1));

                        break;

                    case Model.AX370_Gaming_K7: // IT8686E
                    case Model.AX370_Gaming_5:
                    case Model.AB350_Gaming_3: // IT8686E
                        // Note: v3.3, v12, v5, and AVCC3 might be slightly off.
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 0.65f, 1));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("VSOC", 4));
                        v.Add(new Voltage("VDDP", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        v.Add(new Voltage("AVCC3", 9, 7.53f, 1));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        break;

                    case Model.X399_AORUS_Gaming_7: // ITE IT8686E
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("DIMM CD", 4, 0, 1));
                        v.Add(new Voltage("Vcore SoC", 5, 0, 1));
                        v.Add(new Voltage("DIMM AB", 6, 0, 1));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        v.Add(new Voltage("AVCC3", 9, 54, 10));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM", 4));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    case Model.X470_AORUS_GAMING_7_WIFI: // ITE IT8686E
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("Vcore SoC", 4, 0, 1));
                        v.Add(new Voltage("VDDP", 5, 0, 1));
                        v.Add(new Voltage("DIMM AB", 6, 0, 1));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        v.Add(new Voltage("AVCC3", 9, 54, 10));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM", 4));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    case Model.B560M_AORUS_ELITE: // IT8689E
                    case Model.B560M_AORUS_PRO:
                    case Model.B560M_AORUS_PRO_AX:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("iGPU VAGX", 4));
                        v.Add(new Voltage("VCCSA", 5));
                        v.Add(new Voltage("DRAM", 6));
                        v.Add(new Voltage("3VSB", 7, 10f, 10f));
                        v.Add(new Voltage("VBat", 8, 10f, 10f));
                        v.Add(new Voltage("AVCC3", 9, 59.9f, 9.8f));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("System #2", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Ctrl("CPU Fan", 0));
                        c.Add(new Ctrl("System Fan #1", 1));
                        c.Add(new Ctrl("System Fan #2", 2));
                        c.Add(new Ctrl("System Fan #3", 3));
                        c.Add(new Ctrl("CPU Optional Fan", 4));

                        break;

                    case Model.B360_AORUS_GAMING_3_WIFI_CF: // IT8688E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("CPU Vcore", 4, 0, 1));
                        v.Add(new Voltage("CPU VCCSA", 5, 0, 1));
                        v.Add(new Voltage("DIMM AB", 6, 0, 1));
                        v.Add(new Voltage("3VSB", 7, 1, 1));
                        v.Add(new Voltage("VBat", 8, 1, 1));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("EC_TEMP1", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("PCH", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("PCH Fan", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Ctrl("CPU Fan", 0));
                        c.Add(new Ctrl("System Fan #1", 1));
                        c.Add(new Ctrl("System Fan #2", 2));
                        c.Add(new Ctrl("PCH Fan", 3));
                        c.Add(new Ctrl("CPU Optional Fan", 4));

                        break;

                    case Model.X570_AORUS_MASTER: // IT8688E
                    case Model.X570_AORUS_ULTRA:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("Vcore SoC", 4));
                        v.Add(new Voltage("VDDP", 5));
                        v.Add(new Voltage("DIMM AB", 6));
                        v.Add(new Voltage("3VSB", 7, 1f, 10f));
                        v.Add(new Voltage("VBat", 8, 1f, 10f));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("EC_TEMP1", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("PCH", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("PCH Fan", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Ctrl("CPU Fan", 0));
                        c.Add(new Ctrl("System Fan #1", 1));
                        c.Add(new Ctrl("System Fan #2", 2));
                        c.Add(new Ctrl("PCH Fan", 3));
                        c.Add(new Ctrl("CPU Optional Fan", 4));

                        break;

                    case Model.X570_GAMING_X: // IT8688E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("Vcore SoC", 4));
                        v.Add(new Voltage("VDDP", 5));
                        v.Add(new Voltage("DIMM AB", 6));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("System #2", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("PCH", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("PCH Fan", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Ctrl("CPU Fan", 0));
                        c.Add(new Ctrl("System Fan #1", 1));
                        c.Add(new Ctrl("System Fan #2", 2));
                        c.Add(new Ctrl("PCH Fan", 3));
                        c.Add(new Ctrl("CPU Optional Fan", 4));

                        break;

                    case Model.Z390_M_GAMING: // IT8688E
                    case Model.Z390_AORUS_ULTRA:
                    case Model.Z390_UD:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 5f, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("CPU VCCGT", 4));
                        v.Add(new Voltage("CPU VCCSA", 5));
                        v.Add(new Voltage("VDDQ", 6));
                        v.Add(new Voltage("DDRVTT", 7));
                        v.Add(new Voltage("PCHCore", 8));
                        v.Add(new Voltage("CPU VCCIO", 9));
                        v.Add(new Voltage("DDRVPP", 10));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("System #2", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        c.Add(new Ctrl("CPU Fan", 0));
                        c.Add(new Ctrl("System Fan #1", 1));
                        c.Add(new Ctrl("System Fan #2", 2));
                        c.Add(new Ctrl("System Fan #3", 3));

                        break;

                    case Model.Z390_AORUS_PRO:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 5f, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("CPU VCCGT", 4));
                        v.Add(new Voltage("CPU VCCSA", 5));
                        v.Add(new Voltage("DDR", 6));
                        v.Add(new Voltage("Voltage #7", 7, true));
                        v.Add(new Voltage("3VSB", 8, 1f, 1f, -0.312f));
                        v.Add(new Voltage("VBat", 9, 6f, 1f, 0.01f));
                        v.Add(new Voltage("AVCC3", 10, 6f, 1f, 0.048f));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("EC_TEMP1/System #2", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Ctrl("CPU Fan", 0));
                        c.Add(new Ctrl("System Fan #1", 1));
                        c.Add(new Ctrl("System Fan #2", 2));
                        c.Add(new Ctrl("System Fan #3", 3));
                        c.Add(new Ctrl("CPU Optional Fan", 4));

                        break;

                    case Model.Z690_AORUS_PRO:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 5f, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("iGPU VAXG", 4));
                        v.Add(new Voltage("CPU VCCIN_AUX", 5));
                        v.Add(new Voltage("Voltage #6", 6, true));
                        v.Add(new Voltage("3VSB", 7, 1f, 1f));
                        v.Add(new Voltage("VBat", 8, 1f, 1f));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("EC_TEMP1", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Ctrl("CPU Fan", 0));
                        c.Add(new Ctrl("System Fan #1", 1));
                        c.Add(new Ctrl("System Fan #2", 2));
                        c.Add(new Ctrl("System Fan #3", 3));
                        c.Add(new Ctrl("CPU Optional Fan", 4));
                        break;

                    case Model.Z690_GAMING_X_DDR4:
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("System #2", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        f.Add(new Fan("System Fan #4 / Pump", 5));
                        c.Add(new Ctrl("CPU Fan", 0));
                        c.Add(new Ctrl("System Fan #1", 1));
                        c.Add(new Ctrl("System Fan #2", 2));
                        c.Add(new Ctrl("System Fan #3", 3));
                        c.Add(new Ctrl("CPU Optional Fan", 4));
                        c.Add(new Ctrl("System Fan #4 / Pump", 5));
                        break;

                    case Model.Z68A_D3H_B3: // IT8728F
                        v.Add(new Voltage("VTT", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 30.9f, 10));
                        v.Add(new Voltage("+5V", 3, 7.15f, 10));
                        v.Add(new Voltage("Vcore", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #2", 3));

                        break;

                    case Model.P67A_UD3_B3: // IT8728F
                    case Model.P67A_UD3R_B3: // IT8728F
                    case Model.P67A_UD4_B3: // IT8728F
                    case Model.Z68AP_D3: // IT8728F
                    case Model.Z68X_UD3H_B3: // IT8728F
                    case Model.Z68XP_UD3R: // IT8728F
                        v.Add(new Voltage("VTT", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 30.9f, 10));
                        v.Add(new Voltage("+5V", 3, 7.15f, 10));
                        v.Add(new Voltage("Vcore", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #2", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #1", 3));

                        break;

                    case Model.Z68X_UD7_B3: // IT8728F
                        v.Add(new Voltage("VTT", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 30.9f, 10));
                        v.Add(new Voltage("+5V", 3, 7.15f, 10));
                        v.Add(new Voltage("Vcore", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("System #3", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Power Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));

                        break;

                    case Model.X79_UD3: // IT8728F
                        v.Add(new Voltage("VTT", 0));
                        v.Add(new Voltage("DIMM AB", 1));
                        v.Add(new Voltage("+12V", 2, 10, 2));
                        v.Add(new Voltage("+5V", 3, 15, 10));
                        v.Add(new Voltage("VIN4", 4));
                        v.Add(new Voltage("VCore", 5));
                        v.Add(new Voltage("DIMM CD", 6));
                        v.Add(new Voltage("+3V Standby", 7, 1, 1));
                        v.Add(new Voltage("VBat", 8, 1, 1));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Northbridge", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));

                        break;

                    default:
                        v.Add(new Voltage("Voltage #1", 0, true));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 10, 10, 0, true));
                        v.Add(new Voltage("VBat", 8, 10, 10));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.Biostar:
                switch (model)
                {
                    case Model.B660GTN: //IT8613E
                        // This board has some problems with their app controlling fans that I was able to replicate here so I guess is a BIOS problem with the pins.
                        // Biostar is aware so expect changes in the control pins with new bios.
                        // In the meantime, it's possible to control CPUFAN and CPUOPT1m but not SYSFAN1.
                        // The parameters are extracted from the Biostar app config file.
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("DIMM", 1, 0, 1));
                        v.Add(new Voltage("+12V", 2, 5, 1)); // Reads higher than it should.
                        v.Add(new Voltage("+5V", 3, 147, 100));  // Reads higher than it should.
                        // Commented because I don't know if it makes sense.
                        //v.Add(new Voltage("VCC ST", 4)); // Reads 4.2V.
                        //v.Add(new Voltage("VCCIN AUX", 5)); // Reads 2.2V.
                        //v.Add(new Voltage("CPU GT", 6)); // Reads 2.6V.
                        //v.Add(new Voltage("3VSB", 7, 10, 10)); // Reads 5.8V ?
                        v.Add(new Voltage("VBat", 8, 10, 10)); // Reads higher than it should at 3.4V.
                        t.Add(new Temperature("System 1", 0));
                        t.Add(new Temperature("System 2", 1));  // Not sure what sensor is this.
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("CPU Optional fan", 2));
                        f.Add(new Fan("System Fan", 4));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("CPU Optional Fan", 2));
                        c.Add(new Ctrl("System Fan", 4));

                        break;

                    default:
                        v.Add(new Voltage("Voltage #1", 0, true));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 10, 10, 0, true));
                        v.Add(new Voltage("VBat", 8, 10, 10));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.Shuttle:
                switch (model)
                {
                    case Model.FH67: // IT8772E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("PCH VCCIO", 2));
                        v.Add(new Voltage("CPU VCCIO", 3));
                        v.Add(new Voltage("Graphic Voltage", 4));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));

                        break;

                    default:
                        v.Add(new Voltage("Voltage #1", 0, true));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 10, 10, 0, true));
                        v.Add(new Voltage("VBat", 8, 10, 10));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Voltage #1", 0, true));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("Voltage #3", 2, true));
                v.Add(new Voltage("Voltage #4", 3, true));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("3VSB", 7, 10, 10, 0, true));
                v.Add(new Voltage("VBat", 8, 10, 10));

                for (int i = 0; i < superIO.Temperatures.Length; i++)
                    t.Add(new Temperature("Temperature #" + (i + 1), i));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Ctrl("Fan #" + (i + 1), i));

                break;
        }
    }

    private static void GetIteConfigurationsC(ISuperIO superIO, Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Ctrl> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.Gigabyte:
                switch (model)
                {
                    case Model.X570_AORUS_MASTER: // IT879XE
                    case Model.X570_AORUS_ULTRA:
                        v.Add(new Voltage("CPU VDD18", 0));
                        v.Add(new Voltage("DDRVTT AB", 1));
                        v.Add(new Voltage("Chipset Core", 2));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("CPU VDD18", 4));
                        v.Add(new Voltage("PM_CLDO12", 5));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 1f, 1f));
                        v.Add(new Voltage("VBat", 8, 1f, 1f));
                        t.Add(new Temperature("PCIe x8", 0));
                        t.Add(new Temperature("EC_TEMP2", 1));
                        t.Add(new Temperature("System #2", 2));
                        f.Add(new Fan("System Fan #5 Pump", 0));
                        f.Add(new Fan("System Fan #6 Pump", 1));
                        f.Add(new Fan("System Fan #4", 2));

                        break;

                    case Model.X470_AORUS_GAMING_7_WIFI: // ITE IT8792
                        v.Add(new Voltage("VIN0", 0, 0, 1));
                        v.Add(new Voltage("DDR VTT", 1, 0, 1));
                        v.Add(new Voltage("Chipset Core", 2, 0, 1));
                        v.Add(new Voltage("VIN3", 3, 0, 1));
                        v.Add(new Voltage("CPU VDD18", 4, 0, 1));
                        v.Add(new Voltage("Chipset Core +2.5V", 5, 0.5F, 1));
                        v.Add(new Voltage("3VSB", 6, 1, 10));
                        v.Add(new Voltage("VBat", 7, 0.7F, 1));
                        t.Add(new Temperature("PCIe x8", 0));
                        t.Add(new Temperature("System #2", 2));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    case Model.Z390_AORUS_PRO: // IT879XE
                        v.Add(new Voltage("VCore", 0));
                        v.Add(new Voltage("DDRVTT AB", 1));
                        v.Add(new Voltage("Chipset Core", 2));
                        v.Add(new Voltage("VIN3", 3, true));
                        v.Add(new Voltage("VCCIO", 4));
                        v.Add(new Voltage("Voltage #7", 5, true));
                        v.Add(new Voltage("DDR VPP", 6));
                        v.Add(new Voltage("3VSB", 7, 1f, 1f));
                        v.Add(new Voltage("VBat", 8, 1f, 1f));
                        t.Add(new Temperature("PCIe x8", 0));
                        t.Add(new Temperature("EC_TEMP2", 1));
                        t.Add(new Temperature("System #2", 2));
                        f.Add(new Fan("System Fan #5 Pump", 0));
                        f.Add(new Fan("System Fan #6 Pump", 1));
                        f.Add(new Fan("System Fan #4", 2));
                        c.Add(new Ctrl("Fan #5", 0));
                        c.Add(new Ctrl("Fan #6", 1));
                        c.Add(new Ctrl("Fan #4", 2));

                        break;

                    case Model.Z690_AORUS_PRO:
                        t.Add(new Temperature("PCIe x4", 0));
                        t.Add(new Temperature("EC_TEMP2", 1));
                        t.Add(new Temperature("System #2", 2));
                        f.Add(new Fan("System Fan #5 Pump", 0));
                        f.Add(new Fan("System Fan #6 Pump", 1));
                        f.Add(new Fan("System Fan #4", 2));
                        c.Add(new Ctrl("System Fan #5 Pump", 0));
                        c.Add(new Ctrl("System Fan #6 Pump", 1));
                        c.Add(new Ctrl("System Fan #4", 2));
                        break;

                    default:
                        v.Add(new Voltage("Voltage #1", 0, true));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 10, 10, 0, true));
                        v.Add(new Voltage("VBat", 8, 10, 10));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Voltage #1", 0, true));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("Voltage #3", 2, true));
                v.Add(new Voltage("Voltage #4", 3, true));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("3VSB", 7, 10, 10, 0, true));
                v.Add(new Voltage("VBat", 8, 10, 10));

                for (int i = 0; i < superIO.Temperatures.Length; i++)
                    t.Add(new Temperature("Temperature #" + (i + 1), i));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Ctrl("Fan #" + (i + 1), i));

                break;
        }
    }

    private static void GetFintekConfiguration(ISuperIO superIO, Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Ctrl> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.EVGA:
                switch (model)
                {
                    case Model.X58_SLI_Classified: // F71882
                        v.Add(new Voltage("VCC3V", 0, 150, 150));
                        v.Add(new Voltage("Vcore", 1, 47, 100));
                        v.Add(new Voltage("DIMM", 2, 47, 100));
                        v.Add(new Voltage("CPU VTT", 3, 24, 100));
                        v.Add(new Voltage("IOH Vcore", 4, 24, 100));
                        v.Add(new Voltage("+5V", 5, 51, 12));
                        v.Add(new Voltage("+12V", 6, 56, 6.8f));
                        v.Add(new Voltage("3VSB", 7, 150, 150));
                        v.Add(new Voltage("VBat", 8, 150, 150));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("VREG", 1));
                        t.Add(new Temperature("System", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Power Fan", 1));
                        f.Add(new Fan("Chassis Fan", 2));

                        break;

                    default:
                        v.Add(new Voltage("VCC3V", 0, 150, 150));
                        v.Add(new Voltage("Vcore", 1));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("VSB3V", 7, 150, 150));
                        v.Add(new Voltage("VBat", 8, 150, 150));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("VCC3V", 0, 150, 150));
                v.Add(new Voltage("Vcore", 1));
                v.Add(new Voltage("Voltage #3", 2, true));
                v.Add(new Voltage("Voltage #4", 3, true));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                if (superIO.Chip != Chip.F71808E)
                    v.Add(new Voltage("Voltage #7", 6, true));

                v.Add(new Voltage("VSB3V", 7, 150, 150));
                v.Add(new Voltage("VBat", 8, 150, 150));

                for (int i = 0; i < superIO.Temperatures.Length; i++)
                    t.Add(new Temperature("Temperature #" + (i + 1), i));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Ctrl("Fan #" + (i + 1), i));

                break;
        }
    }

    private static void GetNuvotonConfigurationF(ISuperIO superIO, Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Ctrl> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.ASUS:
                switch (model)
                {
                    case Model.P8P67: // NCT6776F
                    case Model.P8P67_EVO: // NCT6776F
                    case Model.P8P67_PRO: // NCT6776F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 11, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 12, 3));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 2));
                        t.Add(new Temperature("Motherboard", 3));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("Chassis Fan #2", 3));
                        c.Add(new Ctrl("Chassis Fan #2", 0));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("Chassis Fan #1", 2));

                        break;

                    case Model.P8P67_M_PRO: // NCT6776F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 11, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 12, 3));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 3));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("Power Fan", 3));
                        f.Add(new Fan("Auxiliary Fan", 4));

                        break;

                    case Model.P8Z68_V_PRO: // NCT6776F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 11, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 12, 3));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 2));
                        t.Add(new Temperature("Motherboard", 3));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    case Model.P9X79: // NCT6776F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 11, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 12, 3));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 3));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Temperature #1", 1));
                        t.Add(new Temperature("Temperature #2", 2));
                        t.Add(new Temperature("Temperature #3", 3));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.ASRock:
                switch (model)
                {
                    case Model.B85M_DGS:
                        {
                            v.Add(new Voltage("Vcore", 0, 1, 1));
                            v.Add(new Voltage("+12V", 1, 56, 10));
                            v.Add(new Voltage("AVCC", 2, 34, 34));
                            v.Add(new Voltage("+3.3V", 3, 34, 34));
                            v.Add(new Voltage("VIN1", 4, true));
                            v.Add(new Voltage("+5V", 5, 12, 3));
                            v.Add(new Voltage("VIN3", 6, true));
                            v.Add(new Voltage("3VSB", 7, 34, 34));
                            t.Add(new Temperature("CPU", 0));
                            t.Add(new Temperature("Auxiliary", 2));
                            t.Add(new Temperature("Motherboard", 3));
                            f.Add(new Fan("Chassis Fan #1", 0));
                            f.Add(new Fan("CPU Fan", 1));
                            f.Add(new Fan("Power Fan", 2));
                            f.Add(new Fan("Chassis Fan #2", 3));
                            c.Add(new Ctrl("Chassis Fan #2", 0));
                            c.Add(new Ctrl("CPU Fan", 1));
                            c.Add(new Ctrl("Chassis Fan #1", 2));
                        }

                        break;
                    case Model.Z77Pro4M: //NCT6776F
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+12V", 1, 56, 10));
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 10, 10));
                        //v.Add(new Voltage("#Unused #4", 4, 0, 1, 0, true));
                        v.Add(new Voltage("+5V", 5, 20, 10));
                        //v.Add(new Voltage("#Unused #6", 6, 0, 1, 0, true));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Auxiliary", 2));
                        t.Add(new Temperature("Motherboard", 3));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Temperature #1", 1));
                        t.Add(new Temperature("Temperature #2", 2));
                        t.Add(new Temperature("Temperature #3", 3));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("AVCC", 2, 34, 34));
                v.Add(new Voltage("+3.3V", 3, 34, 34));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("3VSB", 7, 34, 34));
                v.Add(new Voltage("VBat", 8, 34, 34));
                t.Add(new Temperature("CPU Core", 0));
                t.Add(new Temperature("Temperature #1", 1));
                t.Add(new Temperature("Temperature #2", 2));
                t.Add(new Temperature("Temperature #3", 3));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Ctrl("Fan #" + (i + 1), i));

                break;
        }
    }

    private static void GetNuvotonConfigurationD(ISuperIO superIO, Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Ctrl> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.ASRock:
                switch (model)
                {
                    case Model.A320M_HDV: //NCT6779D
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("Chipset 1.05V", 1, 0, 1));
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 10, 10));
                        v.Add(new Voltage("+12V", 4, 56, 10));
                        v.Add(new Voltage("VcoreRef", 5, 0, 1));
                        v.Add(new Voltage("DIMM", 6, 0, 1));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        //v.Add(new Voltage("#Unused #9", 9, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #10", 10, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #11", 11, 34, 34, 0, true));
                        v.Add(new Voltage("+5V", 12, 20, 10));
                        //v.Add(new Voltage("#Unused #13", 13, 10, 10, 0, true));
                        //v.Add(new Voltage("#Unused #14", 14, 0, 1, 0, true));

                        //t.Add(new Temperature("#Unused #0", 0));
                        //t.Add(new Temperature("#Unused #1", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        //t.Add(new Temperature("#Unused #3", 3));
                        //t.Add(new Temperature("#Unused #4", 4));
                        t.Add(new Temperature("Auxiliary", 5));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    case Model.AB350_Pro4: //NCT6779D
                    case Model.AB350M_Pro4:
                    case Model.AB350M:
                    case Model.Fatal1ty_AB350_Gaming_K4:
                    case Model.AB350M_HDV:
                    case Model.B450_Steel_Legend:
                    case Model.B450M_Steel_Legend:
                    case Model.B450_Pro4:
                    case Model.B450M_Pro4:
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        //v.Add(new Voltage("#Unused", 1, 0, 1, 0, true));
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 10, 10));
                        v.Add(new Voltage("+12V", 4, 28, 5));
                        v.Add(new Voltage("Vcore Refin", 5, 0, 1));
                        //v.Add(new Voltage("#Unused #6", 6, 0, 1, 0, true));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        //v.Add(new Voltage("#Unused #9", 9, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #10", 10, 0, 1, 0, true));
                        v.Add(new Voltage("Chipset 1.05V", 11, 0, 1));
                        v.Add(new Voltage("+5V", 12, 20, 10));
                        //v.Add(new Voltage("#Unused #13", 13, 0, 1, 0, true));
                        v.Add(new Voltage("+1.8V", 14, 0, 1));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Auxiliary", 3));
                        t.Add(new Temperature("VRM", 4));
                        t.Add(new Temperature("AUXTIN2", 5));
                        //t.Add(new Temperature("Temperature #6", 6));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    case Model.X399_Phantom_Gaming_6: //NCT6779D
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("Chipset 1.05V", 1, 0, 1));
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 10, 10));
                        v.Add(new Voltage("+12V", 4, 56, 10));
                        v.Add(new Voltage("VDDCR_SOC", 5, 0, 1));
                        v.Add(new Voltage("DIMM", 6, 0, 1));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        //v.Add(new Voltage("#Unused", 9, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused", 10, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused", 11, 0, 1, 0, true));
                        v.Add(new Voltage("+5V", 12, 20, 10));
                        v.Add(new Voltage("+1.8V", 13, 10, 10));
                        //v.Add(new Voltage("unused", 14, 34, 34, 0, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        t.Add(new Temperature("Auxiliary", 2));
                        t.Add(new Temperature("Chipset", 3));
                        t.Add(new Temperature("Core VRM", 4));
                        t.Add(new Temperature("Core SoC", 5));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    case Model.X570_Taichi:
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));

                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("CPU", 8));
                        t.Add(new Temperature("SB (Chipset)", 9));

                        f.Add(new Fan("Chassis #3", 0));
                        f.Add(new Fan("CPU #1", 1));
                        f.Add(new Fan("CPU #2", 2));
                        f.Add(new Fan("Chassis #1", 3));
                        f.Add(new Fan("Chassis #2", 4));
                        f.Add(new Fan("SB Fan", 5));
                        f.Add(new Fan("Chassis #4", 6));

                        c.Add(new Ctrl("Chassis #3", 0));
                        c.Add(new Ctrl("CPU #1", 1));
                        c.Add(new Ctrl("CPU #2", 2));
                        c.Add(new Ctrl("Chassis #1", 3));
                        c.Add(new Ctrl("Chassis #2", 4));
                        c.Add(new Ctrl("SB Fan", 5));
                        c.Add(new Ctrl("Chassis #4", 6));

                        break;

                    case Model.X570_Phantom_Gaming_ITX:
                        v.Add(new Voltage("+12V", 0));
                        v.Add(new Voltage("+5V", 1));
                        v.Add(new Voltage("Vcore", 2));
                        v.Add(new Voltage("Voltage #1", 3));
                        v.Add(new Voltage("DIMM", 4));
                        v.Add(new Voltage("CPU I/O", 5));
                        v.Add(new Voltage("CPU SA", 6));
                        v.Add(new Voltage("Voltage #2", 7));
                        v.Add(new Voltage("AVCC3", 8));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("VRef", 10));
                        v.Add(new Voltage("VSB", 11));
                        v.Add(new Voltage("AVSB", 12));
                        v.Add(new Voltage("VBat", 13));

                        t.Add(new Temperature("Motherboard", 0));
                        //t.Add(new Temperature("System", 1)); //Unused
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("SB (Chipset)", 3));
                        f.Add(new Fan("CPU Fan #1", 0)); //CPU_FAN1
                        f.Add(new Fan("Chassis Fan #1", 1)); //CHA_FAN1/WP
                        f.Add(new Fan("CPU Fan #2", 2)); //CPU_FAN2 (WP)
                        f.Add(new Fan("Chipset Fan", 3));

                        c.Add(new Ctrl("CPU Fan #1", 0));
                        c.Add(new Ctrl("Chassis Fan", 1));
                        c.Add(new Ctrl("CPU Fan #2", 2));
                        c.Add(new Ctrl("Chipset Fan", 3));
                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Temperature #1", 1));
                        t.Add(new Temperature("Temperature #2", 2));
                        t.Add(new Temperature("Temperature #3", 3));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.ASUS:
                string[] fanControlNames;
                switch (model)
                {
                    case Model.P8Z77_V: // NCT6779D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #3", 3));
                        c.Add(new Ctrl("Chassis Fan #1", 0));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("Chassis Fan #2", 2));
                        c.Add(new Ctrl("Chassis Fan #3", 3));

                        break;

                    case Model.ROG_MAXIMUS_X_APEX: // NCT6793D
                        v.Add(new Voltage("Vcore", 0, 2, 2));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("CPU GFX", 6, 2, 2));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("DIMM", 10, 1, 1));
                        v.Add(new Voltage("VCCSA", 11));
                        v.Add(new Voltage("PCH Core", 12));
                        v.Add(new Voltage("CPU PLLs", 13));
                        v.Add(new Voltage("CPU VCCIO/IMC", 14));
                        t.Add(new Temperature("CPU (PECI)", 0));
                        t.Add(new Temperature("T2", 1));
                        t.Add(new Temperature("T1", 2));
                        t.Add(new Temperature("CPU", 3));
                        t.Add(new Temperature("PCH", 4));
                        t.Add(new Temperature("Temperature #4", 5));
                        t.Add(new Temperature("Temperature #5", 6));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #3", 3));
                        f.Add(new Fan("AIO Pump", 4));
                        c.Add(new Ctrl("Chassis Fan #1", 0));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("Chassis Fan #2", 2));
                        c.Add(new Ctrl("Chassis Fan #3", 3));
                        c.Add(new Ctrl("AIO Pump", 4));

                        break;

                    case Model.Z170_A: //NCT6793D
                        v.Add(new Voltage("Vcore", 0, 2, 2));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, 0, 1, 0, true));
                        v.Add(new Voltage("CPU GFX", 6, 2, 2));
                        v.Add(new Voltage("3VSB_ATX", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("DIMM", 10, 1, 1));
                        v.Add(new Voltage("VCCSA", 11));
                        v.Add(new Voltage("PCH Core", 12));
                        v.Add(new Voltage("CPU PLLs", 13));
                        v.Add(new Voltage("CPU VCCIO/IMC", 14));
                        t.Add(new Temperature("CPU (PECI)", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("CPU", 3));
                        t.Add(new Temperature("PCH", 4));
                        t.Add(new Temperature("Temperature #4", 5));
                        t.Add(new Temperature("Temperature #5", 6));

                        // CPU Fan Optional uses the same fancontrol as CPU Fan.
                        // Water Pump speed can only be read from the EC.
                        string[] fanNames = { "Chassis Fan 1", "CPU Fan", "Chassis Fan 2", "Chassis Fan 3", "Chassis Fan 4", "CPU Fan Optional" };
                        fanControlNames = new[] { "Chassis Fan 1", "CPU Fan", "Chassis Fan 2", "Chassis Fan 3", "Chassis Fan 4", "Water Pump" };

                        for (int i = 0; i < fanNames.Length; i++)
                            f.Add(new Fan(fanNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Ctrl(fanControlNames[i], i));

                        break;

                    case Model.TUF_GAMING_B550M_PLUS_WIFI: //NCT6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("PECI 0", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("System", 2));
                        t.Add(new Temperature("AUX 0", 3));
                        t.Add(new Temperature("AUX 1", 4));
                        t.Add(new Temperature("AUX 2", 5));
                        t.Add(new Temperature("AUX 3", 6));
                        t.Add(new Temperature("AUX 4", 7));
                        t.Add(new Temperature("SMBus 0", 8));
                        t.Add(new Temperature("SMBus 1", 9));
                        t.Add(new Temperature("PECI 1", 10));
                        t.Add(new Temperature("PCH Chip CPU Max", 11));
                        t.Add(new Temperature("PCH Chip", 12));
                        t.Add(new Temperature("PCH CPU", 13));
                        t.Add(new Temperature("PCH MCH", 14));
                        t.Add(new Temperature("Agent 0 DIMM 0", 15));
                        t.Add(new Temperature("Agent 0 DIMM 1", 16));
                        t.Add(new Temperature("Agent 1 DIMM 0", 17));
                        t.Add(new Temperature("Agent 1 DIMM 1", 18));
                        t.Add(new Temperature("Device 0", 19));
                        t.Add(new Temperature("Device 1", 20));
                        t.Add(new Temperature("PECI 0 Calibrated", 21));
                        t.Add(new Temperature("PECI 1 Calibrated", 22));
                        t.Add(new Temperature("Virtual", 23));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    case Model.ROG_CROSSHAIR_VIII_HERO: // NCT6798D
                    case Model.ROG_CROSSHAIR_VIII_HERO_WIFI: // NCT6798D
                    case Model.ROG_CROSSHAIR_VIII_DARK_HERO: // NCT6798D
                    case Model.ROG_CROSSHAIR_VIII_FORMULA: // NCT6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("CPU SoC", 6));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("DRAM", 13));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("PECI 0", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("AUX 0", 3));
                        t.Add(new Temperature("AUX 1", 4));
                        t.Add(new Temperature("AUX 2", 5));
                        t.Add(new Temperature("AUX 3", 6));
                        t.Add(new Temperature("AUX 4", 7));
                        t.Add(new Temperature("SMBus 0", 8));
                        t.Add(new Temperature("SMBus 1", 9));
                        t.Add(new Temperature("PECI 1", 10));
                        t.Add(new Temperature("PCH Chip CPU Max", 11));
                        t.Add(new Temperature("PCH Chip", 12));
                        t.Add(new Temperature("PCH CPU", 13));
                        t.Add(new Temperature("PCH MCH", 14));
                        t.Add(new Temperature("Agent 0 DIMM 0", 15));
                        t.Add(new Temperature("Agent 0 DIMM 1", 16));
                        t.Add(new Temperature("Agent 1 DIMM 0", 17));
                        t.Add(new Temperature("Agent 1 DIMM 1", 18));
                        t.Add(new Temperature("Device 0", 19));
                        t.Add(new Temperature("Device 1", 20));
                        t.Add(new Temperature("PECI 0 Calibrated", 21));
                        t.Add(new Temperature("PECI 1 Calibrated", 22));
                        t.Add(new Temperature("Virtual", 23));

                        fanControlNames = new[] {"Chassis Fan 1", "CPU Fan", "Chassis Fan 2",
                            "Chassis Fan 3", "High Amp Fan", "W_PUMP+", "AIO Pump"};
                        System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length,
                                                        $"Expected {fanControlNames.Length} fan register in the SuperIO chip");
                        System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length,
                                                        "Expected counts of cans controls and fan speed registers to be equal");

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Ctrl(fanControlNames[i], i));

                        break;

                    case Model.ROG_MAXIMUS_Z690_EXTREME_GLACIAL: //NCT6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("3VCC", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("IVR Atom L2 Cluster #1", 5));
                        v.Add(new Voltage("Voltage #7", 6));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9, 1, 1));
                        v.Add(new Voltage("Voltage #11", 10));
                        v.Add(new Voltage("IVR Atom L2 Cluster #0", 11, 1, 1));
                        v.Add(new Voltage("PCH", 12));
                        v.Add(new Voltage("Voltage #14", 13));
                        v.Add(new Voltage("Voltage #15", 14));

                        t.Add(new Temperature("Temperature #1", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        //t.Add(new Temperature("Temperature 03", 3));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));
                        t.Add(new Temperature("Temperature #7", 7));
                        //t.Add(new Temperature("Temperature 08", 8));
                        //t.Add(new Temperature("Temperature 09", 9));
                        //t.Add(new Temperature("Temperature 10", 10));
                        //t.Add(new Temperature("Temperature 11", 11));
                        t.Add(new Temperature("PCH", 12));
                        //t.Add(new Temperature("Temperature 13", 13));
                        //t.Add(new Temperature("Temperature 14", 14));
                        //t.Add(new Temperature("Temperature 15", 15));
                        //t.Add(new Temperature("Temperature 16", 16));
                        //t.Add(new Temperature("Temperature 17", 17));
                        //t.Add(new Temperature("Temperature 18", 18));
                        //t.Add(new Temperature("Temperature 19", 19));
                        //t.Add(new Temperature("Temperature 20", 20));
                        t.Add(new Temperature("Temperature #9", 21));

                        fanControlNames = new[] { "Chassis Fan 1", "CPU Fan", "Radiator Fan 1", "Radiator Fan 2", "Chassis Fan 2", "Water Pump 1", "Water Pump 2" };
                        System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length,
                                                        $"Expected {fanControlNames.Length} fan register in the SuperIO chip");
                        System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length,
                                                        "Expected counts of fan controls and fan speed registers to be equal");

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Ctrl(fanControlNames[i], i));

                        break;

                    case Model.ROG_MAXIMUS_Z790_HERO: //NCT6798D
                        t.Add(new Temperature("CPU Package", 0));
                        t.Add(new Temperature("VRM", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        //t.Add(new Temperature("Temperature #3", 3));
                        //t.Add(new Temperature("Temperature #4", 4));
                        //t.Add(new Temperature("Temperature #5", 5));
                        //t.Add(new Temperature("Temperature #6", 6));
                        //t.Add(new Temperature("Temperature #7", 7));
                        t.Add(new Temperature("Temperature #8", 8));
                        t.Add(new Temperature("Temperature #9", 9));
                        t.Add(new Temperature("Temperature #10", 10));
                        t.Add(new Temperature("Temperature #11", 11));
                        t.Add(new Temperature("Chipset", 12));
                        t.Add(new Temperature("Temperature #13", 13));
                        t.Add(new Temperature("Temperature #14", 14));
                        t.Add(new Temperature("Temperature #15", 15));
                        t.Add(new Temperature("Temperature #16", 16));
                        t.Add(new Temperature("Temperature #17", 17));
                        t.Add(new Temperature("Temperature #18", 18));
                        t.Add(new Temperature("Temperature #19", 19));
                        t.Add(new Temperature("Temperature #20", 20));
                        t.Add(new Temperature("CPU", 21));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    case Model.ROG_STRIX_B550_I_GAMING: //NCT6798D
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("+5V", 1, 4, 1)); //Probably not updating properly
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1)); //Probably not updating properly
                        //v.Add(new Voltage("#Unused #5", 5, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #6", 6, 0, 1, 0, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        //v.Add(new Voltage("#Unused #9", 9, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #10", 10, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #11", 11, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #12", 12, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #13", 13, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #14", 14, 0, 1, 0, true));

                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        //t.Add(new Temperature("AUX 0", 3)); //No software from Asus reports this temperature ~82C
                        //t.Add(new Temperature("#Unused 4", 4));
                        //t.Add(new Temperature("#Unused 5", 5));
                        //t.Add(new Temperature("#Unused 6", 6));
                        //t.Add(new Temperature("#Unused 7", 7));
                        //t.Add(new Temperature("#Unused 8", 8));
                        //t.Add(new Temperature("#Unused 9", 9));
                        //t.Add(new Temperature("#Unused 10", 10));
                        t.Add(new Temperature("PCH Chip CPU Max", 11));
                        t.Add(new Temperature("PCH Chip", 12));
                        t.Add(new Temperature("PCH CPU", 13));
                        t.Add(new Temperature("PCH MCH", 14));
                        t.Add(new Temperature("Agent 0 DIMM 0", 15));
                        //t.Add(new Temperature("Agent 0 DIMM 1", 16));
                        t.Add(new Temperature("Agent 1 DIMM 0", 17));
                        //t.Add(new Temperature("Agent 1 DIMM 1", 18));
                        t.Add(new Temperature("Device 0", 19));
                        t.Add(new Temperature("Device 1", 20));
                        t.Add(new Temperature("PECI 0 Calibrated", 21));
                        t.Add(new Temperature("PECI 1 Calibrated", 22));
                        t.Add(new Temperature("Virtual", 23));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                        {
                            switch (i)
                            {
                                case 0:
                                    f.Add(new Fan("Chassis Fan", 0));
                                    break;
                                case 1:
                                    f.Add(new Fan("CPU Fan", 1));
                                    break;
                                case 4:
                                    f.Add(new Fan("AIO Pump", 4));
                                    break;
                            }
                        }

                        for (int i = 0; i < superIO.Controls.Length; i++)
                        {
                            switch (i)
                            {
                                case 0:
                                    c.Add(new Ctrl("Chassis Fan", 0));
                                    break;
                                case 1:
                                    c.Add(new Ctrl("CPU Fan", 1));
                                    break;
                                case 4:
                                    c.Add(new Ctrl("AIO Pump", 4));
                                    break;
                            }
                        }

                        break;

                    case Model.ROG_ZENITH_II_EXTREME: // NCT6798D
                        // Voltage = value + (value - Vf) * Ri / Rf.
                        v.Add(new Voltage("Vcore",            0));
                        v.Add(new Voltage("+5V",              1,  4,  1));
                        v.Add(new Voltage("+3.3V",            3,  34, 34));
                        v.Add(new Voltage("+12V",             4,  6,  1));
                        v.Add(new Voltage("DIMM Voltage CD",  11, 10, 10));
                        v.Add(new Voltage("DIMM Voltage AB",  13));
                        v.Add(new Voltage("1.8V PPL Voltage", 14));

                        t.Add(new Temperature("CPU",             1));
                        t.Add(new Temperature("Motherboard",     2));
                        t.Add(new Temperature("Temperature #3",  3));
                        t.Add(new Temperature("Temperature #4",  4));
                        t.Add(new Temperature("Temperature #5",  5));
                        t.Add(new Temperature("Temperature #6",  6));
                        t.Add(new Temperature("Temperature #7",  7));
                        t.Add(new Temperature("Temperature #21", 21));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                        {
                            switch (i)
                            {
                                case 0: f.Add(new Fan("Chassis Fan", 0)); break;
                                case 1: f.Add(new Fan("CPU Fan",     1)); break;
                                case 2: f.Add(new Fan("CPU Optional Fan", 2)); break;
                                case 4: f.Add(new Fan("AIO Pump",    4)); break;
                            }
                        }

                        for (int i = 0; i < superIO.Controls.Length; i++)
                        {
                            switch (i)
                            {
                                case 0: c.Add(new Ctrl("Chassis Fan", 0)); break;
                                case 1: c.Add(new Ctrl("CPU Fan",     1)); break;
                                case 2: c.Add(new Ctrl("CPU Optional Fan", 2)); break;
                                case 4: c.Add(new Ctrl("AIO Pump",    4)); break;
                            }
                        }

                        break;

                    case Model.ROG_STRIX_X570_I_GAMING: //NCT6798D
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("+5V", 1, 4, 1)); //Probably not updating properly
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1)); //Probably not updating properly
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Temperature #3", 3));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));
                        t.Add(new Temperature("Temperature #7", 7));
                        t.Add(new Temperature("Temperature #21", 21));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                        {
                            switch (i)
                            {
                                case 0:
                                    f.Add(new Fan("Chassis Fan", 0));
                                    break;
                                case 1:
                                    f.Add(new Fan("CPU Fan", 1));
                                    break;
                                case 4:
                                    f.Add(new Fan("AIO Pump", 4));
                                    break;
                            }
                        }

                        for (int i = 0; i < superIO.Controls.Length; i++)
                        {
                            switch (i)
                            {
                                case 0:
                                    c.Add(new Ctrl("Chassis Fan", 0));
                                    break;
                                case 1:
                                    c.Add(new Ctrl("CPU Fan", 1));
                                    break;
                                case 4:
                                    c.Add(new Ctrl("AIO Pump", 4));
                                    break;
                            }
                        }
                        break;

                    case Model.ROG_STRIX_B550_F_GAMING_WIFI: // NCT6798D-R
                        v.Add(new Voltage("Vcore", 0, 2, 2));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU Core", 0));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Temperature #1", 1));
                        t.Add(new Temperature("Temperature #2", 2));
                        t.Add(new Temperature("Temperature #3", 3));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.MSI:
                switch (model)
                {
                    case Model.B360M_PRO_VDH: // NCT6797D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        //v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("CPU I/O", 6));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("CPU SA", 10));
                        //v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("NB/SoC", 12));
                        v.Add(new Voltage("DIMM", 13, 1, 1));
                        //v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Temperature #1", 5));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("System Fan #1", 2));
                        c.Add(new Ctrl("System Fan #2", 3));

                        break;

                    case Model.B450A_PRO: // NCT6797D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        //v.Add(new Voltage("Voltage #6", 5, false));
                        //v.Add(new Voltage("CPU I/O", 6));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("CPU SA", 10));
                        //v.Add(new Voltage("Voltage #12", 11, false));
                        v.Add(new Voltage("NB/SoC", 12));
                        v.Add(new Voltage("DIMM", 13, 1, 1));
                        //v.Add(new Voltage("Voltage #15", 14, false));
                        //t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("System", 2));
                        t.Add(new Temperature("VRM MOS", 3));
                        t.Add(new Temperature("PCH", 5));
                        t.Add(new Temperature("SMBus 0", 8));
                        f.Add(new Fan("Pump Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));
                        f.Add(new Fan("System Fan #4", 5));
                        c.Add(new Ctrl("Pump Fan", 0));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("System Fan #1", 2));
                        c.Add(new Ctrl("System Fan #2", 3));
                        c.Add(new Ctrl("System Fan #3", 4));
                        c.Add(new Ctrl("System Fan #4", 5));

                        break;

                    case Model.Z270_PC_MATE: // NCT6795D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("CPU I/O", 6));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("CPU SA", 10));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("PCH", 12));
                        v.Add(new Voltage("DIMM", 13, 1, 1));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        f.Add(new Fan("Pump Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));
                        f.Add(new Fan("System Fan #4", 5));
                        c.Add(new Ctrl("Pump Fan", 0));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("System Fan #1", 2));
                        c.Add(new Ctrl("System Fan #2", 3));
                        c.Add(new Ctrl("System Fan #3", 4));
                        c.Add(new Ctrl("System Fan #4", 5));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Temperature #1", 1));
                        t.Add(new Temperature("Temperature #2", 2));
                        t.Add(new Temperature("Temperature #3", 3));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Ctrl("Fan #" + (i + 1), i));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("AVCC", 2, 34, 34));
                v.Add(new Voltage("+3.3V", 3, 34, 34));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("3VSB", 7, 34, 34));
                v.Add(new Voltage("VBat", 8, 34, 34));
                v.Add(new Voltage("VTT", 9));
                v.Add(new Voltage("Voltage #11", 10, true));
                v.Add(new Voltage("Voltage #12", 11, true));
                v.Add(new Voltage("Voltage #13", 12, true));
                v.Add(new Voltage("Voltage #14", 13, true));
                v.Add(new Voltage("Voltage #15", 14, true));
                t.Add(new Temperature("CPU Core", 0));
                t.Add(new Temperature("Temperature #1", 1));
                t.Add(new Temperature("Temperature #2", 2));
                t.Add(new Temperature("Temperature #3", 3));
                t.Add(new Temperature("Temperature #4", 4));
                t.Add(new Temperature("Temperature #5", 5));
                t.Add(new Temperature("Temperature #6", 6));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Ctrl("Fan #" + (i + 1), i));

                break;
        }
    }

    private static void GetWinbondConfigurationEhf(Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Ctrl> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.ASRock:
                switch (model)
                {
                    case Model.AOD790GX_128M: // W83627EHF
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 4, 10, 10));
                        v.Add(new Voltage("+5V", 5, 20, 10));
                        v.Add(new Voltage("+12V", 6, 28, 5));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Chassis Fan", 1));
                        c.Add(new Ctrl("System Fan", 0));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("Auxiliary Fan", 2));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("Voltage #10", 9, true));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("System", 2));
                        f.Add(new Fan("System Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Auxiliary Fan", 2));
                        f.Add(new Fan("CPU Fan #2", 3));
                        f.Add(new Fan("Auxiliary Fan #2", 4));
                        c.Add(new Ctrl("System Fan", 0));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("Auxiliary Fan", 2));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("AVCC", 2, 34, 34));
                v.Add(new Voltage("+3.3V", 3, 34, 34));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("3VSB", 7, 34, 34));
                v.Add(new Voltage("VBat", 8, 34, 34));
                v.Add(new Voltage("Voltage #10", 9, true));
                t.Add(new Temperature("CPU", 0));
                t.Add(new Temperature("Auxiliary", 1));
                t.Add(new Temperature("System", 2));
                f.Add(new Fan("System Fan", 0));
                f.Add(new Fan("CPU Fan", 1));
                f.Add(new Fan("Auxiliary Fan", 2));
                f.Add(new Fan("CPU Fan #2", 3));
                f.Add(new Fan("Auxiliary Fan #2", 4));
                c.Add(new Ctrl("System Fan", 0));
                c.Add(new Ctrl("CPU Fan", 1));
                c.Add(new Ctrl("Auxiliary Fan", 2));

                break;
        }
    }

    private static void GetWinbondConfigurationHg(Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Ctrl> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.ASRock:
                switch (model)
                {
                    case Model._880GMH_USB3: // W83627DHG-P
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 5, 15, 7.5f));
                        v.Add(new Voltage("+12V", 6, 56, 10));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        f.Add(new Fan("Chassis Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Power Fan", 2));
                        c.Add(new Ctrl("System Fan", 0));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("Auxiliary Fan", 2));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("System", 2));
                        f.Add(new Fan("System Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Auxiliary Fan", 2));
                        f.Add(new Fan("CPU Fan #2", 3));
                        f.Add(new Fan("Auxiliary Fan #2", 4));
                        c.Add(new Ctrl("System Fan", 0));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("Auxiliary Fan", 2));

                        break;
                }

                break;
            case Manufacturer.ASUS:
                switch (model)
                {
                    case Model.P6T: // W83667HG
                    case Model.P6X58D_E: // W83667HG
                    case Model.RAMPAGE_II_GENE: // W83667HG
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 11.5f, 1.91f));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 15, 7.5f));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("Chassis Fan #2", 3));
                        f.Add(new Fan("Chassis Fan #3", 4));
                        c.Add(new Ctrl("System Fan", 0));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("Auxiliary Fan", 2));

                        break;

                    case Model.RAMPAGE_EXTREME: // W83667HG
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 12, 2));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 15, 7.5f));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("Chassis Fan #2", 3));
                        f.Add(new Fan("Chassis Fan #3", 4));
                        c.Add(new Ctrl("System Fan", 0));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("Auxiliary Fan", 2));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("System", 2));
                        f.Add(new Fan("System Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Auxiliary Fan", 2));
                        f.Add(new Fan("CPU Fan #2", 3));
                        f.Add(new Fan("Auxiliary Fan #2", 4));
                        c.Add(new Ctrl("System Fan", 0));
                        c.Add(new Ctrl("CPU Fan", 1));
                        c.Add(new Ctrl("Auxiliary Fan", 2));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("AVCC", 2, 34, 34));
                v.Add(new Voltage("+3.3V", 3, 34, 34));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("3VSB", 7, 34, 34));
                v.Add(new Voltage("VBat", 8, 34, 34));
                t.Add(new Temperature("CPU", 0));
                t.Add(new Temperature("Auxiliary", 1));
                t.Add(new Temperature("System", 2));
                f.Add(new Fan("System Fan", 0));
                f.Add(new Fan("CPU Fan", 1));
                f.Add(new Fan("Auxiliary Fan", 2));
                f.Add(new Fan("CPU Fan #2", 3));
                f.Add(new Fan("Auxiliary Fan #2", 4));
                c.Add(new Ctrl("System Fan", 0));
                c.Add(new Ctrl("CPU Fan", 1));
                c.Add(new Ctrl("Auxiliary Fan", 2));

                break;
        }
    }

    public override string GetReport()
    {
        return _superIO.GetReport();
    }

    public override void Update()
    {
        _superIO.Update();

        foreach (Sensor sensor in _voltages)
        {
            float? value = _readVoltage(sensor.Index);
            if (value.HasValue)
            {
                sensor.Value = value + ((value - sensor.Parameters[2].Value) * sensor.Parameters[0].Value / sensor.Parameters[1].Value);
                ActivateSensor(sensor);
            }
        }

        foreach (Sensor sensor in _temperatures)
        {
            float? value = _readTemperature(sensor.Index);
            if (value.HasValue)
            {
                sensor.Value = value + sensor.Parameters[0].Value;
                ActivateSensor(sensor);
            }
        }

        foreach (Sensor sensor in _fans)
        {
            float? value = _readFan(sensor.Index);
            if (value.HasValue)
            {
                sensor.Value = value;
                ActivateSensor(sensor);
            }
        }

        foreach (Sensor sensor in _controls)
        {
            sensor.Value = _readControl(sensor.Index);
        }

        _postUpdate();
    }

    public override void Close()
    {
        foreach (Sensor sensor in _controls)
        {
            // restore all controls back to default
            _superIO.SetControl(sensor.Index, null);
        }

        base.Close();
    }

    private delegate float? ReadValueDelegate(int index);

    private delegate void UpdateDelegate();

    private class Voltage
    {
        public readonly bool Hidden;
        public readonly int Index;
        public readonly string Name;
        public readonly float Rf;
        public readonly float Ri;
        public readonly float Vf;

        public Voltage(string name, int index, bool hidden = false) : this(name, index, 0, 1, 0, hidden)
        { }

        public Voltage(string name, int index, float ri, float rf, float vf = 0, bool hidden = false)
        {
            Name = name;
            Index = index;
            Ri = ri;
            Rf = rf;
            Vf = vf;
            Hidden = hidden;
        }
    }

    private class Temperature
    {
        public readonly int Index;
        public readonly string Name;

        public Temperature(string name, int index)
        {
            Name = name;
            Index = index;
        }
    }

    private class Fan
    {
        public readonly int Index;
        public readonly string Name;

        public Fan(string name, int index)
        {
            Name = name;
            Index = index;
        }
    }

    private class Ctrl
    {
        public readonly int Index;
        public readonly string Name;

        public Ctrl(string name, int index)
        {
            Name = name;
            Index = index;
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Network/Network.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Diagnostics;
using System.Net.NetworkInformation;

namespace LibreHardwareMonitor.Hardware.Network;

internal sealed class Network : Hardware
{
    private readonly Sensor _dataDownloaded;
    private readonly Sensor _dataUploaded;
    private readonly Sensor _downloadSpeed;
    private readonly Sensor _networkUtilization;
    private readonly Sensor _uploadSpeed;
    private long _bytesDownloaded;
    private long _bytesUploaded;
    private long _lastTick;

    public Network(NetworkInterface networkInterface, ISettings settings)
        : base(networkInterface.Name, new Identifier("nic", networkInterface.Id), settings)
    {
        NetworkInterface = networkInterface;
        _dataUploaded = new Sensor("Data Uploaded", 2, SensorType.Data, this, settings);
        ActivateSensor(_dataUploaded);
        _dataDownloaded = new Sensor("Data Downloaded", 3, SensorType.Data, this, settings);
        ActivateSensor(_dataDownloaded);
        _uploadSpeed = new Sensor("Upload Speed", 7, SensorType.Throughput, this, settings);
        ActivateSensor(_uploadSpeed);
        _downloadSpeed = new Sensor("Download Speed", 8, SensorType.Throughput, this, settings);
        ActivateSensor(_downloadSpeed);
        _networkUtilization = new Sensor("Network Utilization", 1, SensorType.Load, this, settings);
        ActivateSensor(_networkUtilization);
        _bytesUploaded = NetworkInterface.GetIPStatistics().BytesSent;
        _bytesDownloaded = NetworkInterface.GetIPStatistics().BytesReceived;
        _lastTick = Stopwatch.GetTimestamp();
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Network; }
    }

    internal NetworkInterface NetworkInterface { get; private set; }

    public override void Update()
    {
        try
        {
            if (NetworkInterface == null)
                return;

            long newTick = Stopwatch.GetTimestamp();
            double dt = new TimeSpan(newTick - _lastTick).TotalSeconds;

            IPv4InterfaceStatistics interfaceStats = NetworkInterface.GetIPv4Statistics();

            // Report out the number of GB (2^30 Bytes) that this interface has up/downloaded. Note
            // that these values can reset back at zero (eg: after waking from sleep).
            _dataUploaded.Value = (float)(interfaceStats.BytesSent / (double)0x40000000);
            _dataDownloaded.Value = (float)(interfaceStats.BytesReceived / (double)0x40000000);

            // Detect a reset in interface stats if the new total is less than what was previously
            // seen. While setting the previous values to zero doesn't encapsulate the value the
            // instant before the reset, it is the best approximation we have.
            if (interfaceStats.BytesSent < _bytesUploaded || interfaceStats.BytesReceived < _bytesDownloaded)
            {
                _bytesUploaded = 0;
                _bytesDownloaded = 0;
            }

            long dBytesUploaded = interfaceStats.BytesSent - _bytesUploaded;
            long dBytesDownloaded = interfaceStats.BytesReceived - _bytesDownloaded;

            // Upload and download speeds are reported as the number of bytes transfered over the
            // time difference since the last report. In this way, the values represent the average
            // number of bytes up/downloaded in a second.
            _uploadSpeed.Value = (float)(dBytesUploaded / dt);
            _downloadSpeed.Value = (float)(dBytesDownloaded / dt);

            // Network speed is in bits per second, so when calculating the load on the NIC we first
            // grab the total number of bits up/downloaded
            long dbits = (dBytesUploaded + dBytesDownloaded) * 8;

            // Converts the ratio of total bits transferred over time over theoretical max bits
            // transfer rate into a percentage load
            double load = (dbits / dt / NetworkInterface.Speed) * 100;

            // Finally clamp the value between 0% and 100% to avoid reporting nonsensical numbers
            _networkUtilization.Value = (float)Math.Min(Math.Max(load, 0), 100);

            // Store the recorded values and time, so they can be used in the next update
            _bytesUploaded = interfaceStats.BytesSent;
            _bytesDownloaded = interfaceStats.BytesReceived;
            _lastTick = newTick;
        }
        catch (NetworkInformationException networkInformationException) when (unchecked(networkInformationException.HResult == (int)0x80004005))
        {
            foreach (NetworkInterface networkInterface in NetworkInterface.GetAllNetworkInterfaces())
            {
                if (networkInterface.Id.Equals(NetworkInterface?.Id))
                {
                    NetworkInterface = networkInterface;
                    break;
                }
            }
        }
    }
}
```

`LibreHardwareMonitorLib/Hardware/Network/NetworkGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.NetworkInformation;
using System.Text;

namespace LibreHardwareMonitor.Hardware.Network;

internal class NetworkGroup : IGroup, IHardwareChanged
{
    public event HardwareEventHandler HardwareAdded;
    public event HardwareEventHandler HardwareRemoved;

    private readonly Dictionary<string, Network> _networks = new();
    private readonly object _scanLock = new();
    private readonly ISettings _settings;
    private readonly List<Network> _hardware = new();

    public NetworkGroup(ISettings settings)
    {
        _settings = settings;
        UpdateNetworkInterfaces(settings);

        NetworkChange.NetworkAddressChanged += NetworkChange_NetworkAddressChanged;
        NetworkChange.NetworkAvailabilityChanged += NetworkChange_NetworkAddressChanged;
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        var report = new StringBuilder();

        foreach (Network network in _hardware)
        {
            report.AppendLine(network.NetworkInterface.Description);
            report.AppendLine(network.NetworkInterface.OperationalStatus.ToString());
            report.AppendLine();

            foreach (ISensor sensor in network.Sensors)
            {
                report.AppendLine(sensor.Name);
                report.AppendLine(sensor.Value.ToString());
                report.AppendLine();
            }
        }

        return report.ToString();
    }

    public void Close()
    {
        NetworkChange.NetworkAddressChanged -= NetworkChange_NetworkAddressChanged;
        NetworkChange.NetworkAvailabilityChanged -= NetworkChange_NetworkAddressChanged;

        foreach (Network network in _hardware)
            network.Close();
    }

    private void UpdateNetworkInterfaces(ISettings settings)
    {
        // When multiple events fire concurrently, we don't want threads interfering
        // with others as they manipulate non-thread safe state.
        lock (_scanLock)
        {
            IOrderedEnumerable<NetworkInterface> networkInterfaces = GetNetworkInterfaces();
            if (networkInterfaces == null)
                return;

            var foundNetworkInterfaces = networkInterfaces.ToDictionary(x => x.Id, x => x);

            // Remove network interfaces that no longer exist.
            List<string> removeKeys = new();
            foreach (KeyValuePair<string, Network> networkInterfacePair in _networks)
            {
                if (foundNetworkInterfaces.ContainsKey(networkInterfacePair.Key))
                    continue;

                removeKeys.Add(networkInterfacePair.Key);
            }

            foreach (string key in removeKeys)
            {
                Network network = _networks[key];
                network.Close();
                _networks.Remove(key);

                _hardware.Remove(network);
                HardwareRemoved?.Invoke(network);
            }

            // Add new network interfaces.
            foreach (KeyValuePair<string, NetworkInterface> networkInterfacePair in foundNetworkInterfaces)
            {
                if (!_networks.ContainsKey(networkInterfacePair.Key))
                {
                    _networks.Add(networkInterfacePair.Key, new Network(networkInterfacePair.Value, settings));
                    _hardware.Add(_networks[networkInterfacePair.Key]);
                    HardwareAdded?.Invoke(_networks[networkInterfacePair.Key]);
                }
            }
        }
    }

    private static IOrderedEnumerable<NetworkInterface> GetNetworkInterfaces()
    {
        int retry = 0;

        while (retry++ < 5)
        {
            try
            {
                return NetworkInterface.GetAllNetworkInterfaces()
                                       .Where(DesiredNetworkType)
                                       .OrderBy(x => x.Name);
            }
            catch (NetworkInformationException)
            {
                // Disabling IPv4 while running can cause a NetworkInformationException: The pipe is being closed.
                // This can be retried.
            }
        }

        return null;
    }

    private void NetworkChange_NetworkAddressChanged(object sender, EventArgs e)
    {
        UpdateNetworkInterfaces(_settings);
    }

    private static bool DesiredNetworkType(NetworkInterface nic)
    {
        switch (nic.NetworkInterfaceType)
        {
            case NetworkInterfaceType.Loopback:
            case NetworkInterfaceType.Tunnel:
            case NetworkInterfaceType.Unknown:
                return false;
            default:
                return true;
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/OpCode.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Hardware;

internal static class OpCode
{
    public static CpuidDelegate CpuId;
    public static RdtscDelegate Rdtsc;

    private static IntPtr _codeBuffer;
    private static ulong _size;

    // void __stdcall cpuidex(unsigned int index, unsigned int ecxValue,
    //   unsigned int* eax, unsigned int* ebx, unsigned int* ecx,
    //   unsigned int* edx)
    // {
    //   int info[4];
    //   __cpuidex(info, index, ecxValue);
    //   *eax = info[0];
    //   *ebx = info[1];
    //   *ecx = info[2];
    //   *edx = info[3];
    // }

    private static readonly byte[] CpuId32 =
    {
        0x55, // push ebp
        0x8B,
        0xEC, // mov ebp, esp
        0x83,
        0xEC,
        0x10, // sub esp, 10h
        0x8B,
        0x45,
        0x08, // mov eax, dword ptr [ebp+8]
        0x8B,
        0x4D,
        0x0C, // mov ecx, dword ptr [ebp+0Ch]
        0x53, // push ebx
        0x0F,
        0xA2, // cpuid
        0x56, // push esi
        0x8D,
        0x75,
        0xF0, // lea esi, [info]
        0x89,
        0x06, // mov dword ptr [esi],eax
        0x8B,
        0x45,
        0x10, // mov eax, dword ptr [eax]
        0x89,
        0x5E,
        0x04, // mov dword ptr [esi+4], ebx
        0x89,
        0x4E,
        0x08, // mov dword ptr [esi+8], ecx
        0x89,
        0x56,
        0x0C, // mov dword ptr [esi+0Ch], edx
        0x8B,
        0x4D,
        0xF0, // mov ecx, dword ptr [info]
        0x89,
        0x08, // mov dword ptr [eax], ecx
        0x8B,
        0x45,
        0x14, // mov eax, dword ptr [ebx]
        0x8B,
        0x4D,
        0xF4, // mov ecx, dword ptr [ebp-0Ch]
        0x89,
        0x08, // mov dword ptr [eax], ecx
        0x8B,
        0x45,
        0x18, // mov eax, dword ptr [ecx]
        0x8B,
        0x4D,
        0xF8, // mov ecx, dword ptr [ebp-8]
        0x89,
        0x08, // mov dword ptr [eax], ecx
        0x8B,
        0x45,
        0x1C, // mov eax, dword ptr [edx]
        0x8B,
        0x4D,
        0xFC, // mov ecx, dword ptr [ebp-4]
        0x5E, // pop esi
        0x89,
        0x08, // mov dword ptr [eax], ecx
        0x5B, // pop ebx
        0xC9, // leave
        0xC2,
        0x18,
        0x00 // ret 18h
    };

    private static readonly byte[] CpuId64Linux =
    {
        0x49,
        0x89,
        0xD2, // mov r10, rdx
        0x49,
        0x89,
        0xCB, // mov r11, rcx
        0x53, // push rbx
        0x89,
        0xF8, // mov eax, edi
        0x89,
        0xF1, // mov ecx, esi
        0x0F,
        0xA2, // cpuid
        0x41,
        0x89,
        0x02, // mov dword ptr [r10], eax
        0x41,
        0x89,
        0x1B, // mov dword ptr [r11], ebx
        0x41,
        0x89,
        0x08, // mov dword ptr [r8], ecx
        0x41,
        0x89,
        0x11, // mov dword ptr [r9], edx
        0x5B, // pop rbx
        0xC3 // ret
    };

    private static readonly byte[] CpuId64Windows =
    {
        0x48,
        0x89,
        0x5C,
        0x24,
        0x08, // mov qword ptr [rsp+8], rbx
        0x8B,
        0xC1, // mov eax, ecx
        0x8B,
        0xCA, // mov ecx, edx
        0x0F,
        0xA2, // cpuid
        0x41,
        0x89,
        0x00, // mov dword ptr [r8], eax
        0x48,
        0x8B,
        0x44,
        0x24,
        0x28, // mov rax, qword ptr [rsp+28h]
        0x41,
        0x89,
        0x19, // mov dword ptr [r9], ebx
        0x48,
        0x8B,
        0x5C,
        0x24,
        0x08, // mov rbx, qword ptr [rsp+8]
        0x89,
        0x08, // mov dword ptr [rax], ecx
        0x48,
        0x8B,
        0x44,
        0x24,
        0x30, // mov rax, qword ptr [rsp+30h]
        0x89,
        0x10, // mov dword ptr [rax], edx
        0xC3 // ret
    };

    // unsigned __int64 __stdcall rdtsc() {
    //   return __rdtsc();
    // }

    private static readonly byte[] Rdtsc32 =
    {
        0x0F,
        0x31, // rdtsc
        0xC3 // ret
    };

    private static readonly byte[] Rdtsc64 =
    {
        0x0F,
        0x31, // rdtsc
        0x48,
        0xC1,
        0xE2,
        0x20, // shl rdx, 20h
        0x48,
        0x0B,
        0xC2, // or rax, rdx
        0xC3 // ret
    };

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    public delegate bool CpuidDelegate(uint index, uint ecxValue, out uint eax, out uint ebx, out uint ecx, out uint edx);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    public delegate ulong RdtscDelegate();

    public static void Open()
    {
        byte[] rdTscCode;
        byte[] cpuidCode;
        if (IntPtr.Size == 4)
        {
            rdTscCode = Rdtsc32;
            cpuidCode = CpuId32;
        }
        else
        {
            rdTscCode = Rdtsc64;

            cpuidCode = Software.OperatingSystem.IsUnix ? CpuId64Linux : CpuId64Windows;
        }

        _size = (ulong)(rdTscCode.Length + cpuidCode.Length);

        if (Software.OperatingSystem.IsUnix)
        {
#if NETFRAMEWORK
            Assembly assembly = Assembly.Load("Mono.Posix, Version=2.0.0.0, Culture=neutral, " + "PublicKeyToken=0738eb9f132ed756");
#else
                Assembly assembly = Assembly.Load("Mono.Posix.NETStandard, Version=1.0.0.0, Culture=neutral");
#endif

            Type sysCall = assembly.GetType("Mono.Unix.Native.Syscall");
            MethodInfo mmap = sysCall.GetMethod("mmap");

            Type mmapProts = assembly.GetType("Mono.Unix.Native.MmapProts");
            object mmapProtsParam = Enum.ToObject(mmapProts,
                                                  (int)mmapProts.GetField("PROT_READ").GetValue(null) |
                                                  (int)mmapProts.GetField("PROT_WRITE").GetValue(null) |
                                                  (int)mmapProts.GetField("PROT_EXEC").GetValue(null));

            Type mmapFlags = assembly.GetType("Mono.Unix.Native.MmapFlags");
            object mmapFlagsParam = Enum.ToObject(mmapFlags,
                                                  (int)mmapFlags.GetField("MAP_ANONYMOUS").GetValue(null) |
                                                  (int)mmapFlags.GetField("MAP_PRIVATE").GetValue(null));

            if (mmap != null)
                _codeBuffer = (IntPtr)mmap.Invoke(null, new[] { IntPtr.Zero, _size, mmapProtsParam, mmapFlagsParam, -1, 0 });
        }
        else
        {
            _codeBuffer = Interop.Kernel32.VirtualAlloc(IntPtr.Zero,
                                                        (UIntPtr)_size,
                                                        Interop.Kernel32.MEM.MEM_COMMIT | Interop.Kernel32.MEM.MEM_RESERVE,
                                                        Interop.Kernel32.PAGE.PAGE_EXECUTE_READWRITE);
        }

        Marshal.Copy(rdTscCode, 0, _codeBuffer, rdTscCode.Length);
        Rdtsc = Marshal.GetDelegateForFunctionPointer(_codeBuffer, typeof(RdtscDelegate)) as RdtscDelegate;
        IntPtr cpuidAddress = (IntPtr)((long)_codeBuffer + rdTscCode.Length);
        Marshal.Copy(cpuidCode, 0, cpuidAddress, cpuidCode.Length);
        CpuId = Marshal.GetDelegateForFunctionPointer(cpuidAddress, typeof(CpuidDelegate)) as CpuidDelegate;
    }

    public static void Close()
    {
        Rdtsc = null;
        CpuId = null;

        if (Software.OperatingSystem.IsUnix)
        {
#if NETFRAMEWORK
            Assembly assembly = Assembly.Load("Mono.Posix, Version=2.0.0.0, Culture=neutral, " + "PublicKeyToken=0738eb9f132ed756");
#else
                Assembly assembly = Assembly.Load("Mono.Posix.NETStandard, Version=1.0.0.0, Culture=neutral");
#endif

            Type sysCall = assembly.GetType("Mono.Unix.Native.Syscall");
            MethodInfo method = sysCall.GetMethod("munmap");
            method?.Invoke(null, new object[] { _codeBuffer, _size });
        }
        else
        {
            Interop.Kernel32.VirtualFree(_codeBuffer, UIntPtr.Zero, Interop.Kernel32.MEM.MEM_RELEASE);
        }
    }

    public static bool CpuIdTx(uint index, uint ecxValue, out uint eax, out uint ebx, out uint ecx, out uint edx, GroupAffinity affinity)
    {
        GroupAffinity previousAffinity = ThreadAffinity.Set(affinity);
        if (previousAffinity == GroupAffinity.Undefined)
        {
            eax = ebx = ecx = edx = 0;
            return false;
        }

        CpuId(index, ecxValue, out eax, out ebx, out ecx, out edx);
        ThreadAffinity.Set(previousAffinity);
        return true;
    }
}
```

`LibreHardwareMonitorLib/Hardware/Parameter.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;

namespace LibreHardwareMonitor.Hardware;

internal class Parameter : IParameter
{
    private readonly ISettings _settings;
    private readonly ParameterDescription _description;
    private bool _isDefault;
    private float _value;

    public Parameter(ParameterDescription description, ISensor sensor, ISettings settings)
    {
        Sensor = sensor;
        _description = description;
        _settings = settings;
        _isDefault = !settings.Contains(Identifier.ToString());
        _value = description.DefaultValue;
        if (!_isDefault && !float.TryParse(settings.GetValue(Identifier.ToString(), "0"), NumberStyles.Float, CultureInfo.InvariantCulture, out _value))
        {
            _value = description.DefaultValue;
        }
    }

    public float DefaultValue
    {
        get { return _description.DefaultValue; }
    }

    public string Description
    {
        get { return _description.Description; }
    }

    public Identifier Identifier
    {
        get { return new Identifier(Sensor.Identifier, "parameter", Name.Replace(" ", string.Empty).ToLowerInvariant()); }
    }

    public bool IsDefault
    {
        get { return _isDefault; }
        set
        {
            _isDefault = value;
            if (value)
            {
                _value = _description.DefaultValue;
                _settings.Remove(Identifier.ToString());
            }
        }
    }

    public string Name
    {
        get { return _description.Name; }
    }

    public ISensor Sensor { get; }

    public float Value
    {
        get { return _value; }
        set
        {
            _isDefault = false;
            _value = value;
            _settings.SetValue(Identifier.ToString(), value.ToString(CultureInfo.InvariantCulture));
        }
    }

    public void Accept(IVisitor visitor)
    {
        if (visitor == null)
            throw new ArgumentNullException(nameof(visitor));

        visitor.VisitParameter(this);
    }

    public void Traverse(IVisitor visitor)
    { }
}
```

`LibreHardwareMonitorLib/Hardware/ParameterDescription.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Composite class containing information about the selected <see cref="ISensor"/>.
/// </summary>
public struct ParameterDescription
{
    /// <summary>
    /// Creates a new instance and assigns values.
    /// </summary>
    /// <param name="name">Name of the selected component.</param>
    /// <param name="description">Description of the selected component.</param>
    /// <param name="defaultValue">Default value of the selected component.</param>
    public ParameterDescription(string name, string description, float defaultValue)
    {
        Name = name;
        Description = description;
        DefaultValue = defaultValue;
    }

    /// <summary>
    /// Gets a name of the parent <see cref="ISensor"/>.
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// Gets a description of the parent <see cref="ISensor"/>.
    /// </summary>
    public string Description { get; }

    /// <summary>
    /// Gets a default value of the parent <see cref="ISensor"/>.
    /// </summary>
    public float DefaultValue { get; }
}
```

`LibreHardwareMonitorLib/Hardware/Psu/Corsair/CorsairPsu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) 2020 Wilken Gottwalt<wilken.gottwalt@posteo.net>
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.
// Implemented after the Linuix kernel driver corsair_psu by Wilken Gottwalt and contributers

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Psu.Corsair;

internal class SensorIndices
{
    private readonly Dictionary<SensorType, int> _lastIndices = new();

    public int NextIndex(SensorType type)
    {
        if (!_lastIndices.ContainsKey(type))
        {
            _lastIndices.Add(type, 0);
            return 0;
        }

        int res = _lastIndices[type] + 1;
        _lastIndices[type] = res;
        return res;
    }
}

// might need refactoring into two classes if AXi series API differs significantly
internal sealed class CorsairPsu : Hardware
{
    private readonly List<CompositeSensor> _compositeSensors = new();
    private readonly HidDevice _device;
    private readonly List<PsuSensor> _sensors = new();

    public CorsairPsu(HidDevice device, ISettings settings, int index)
        : base("Corsair PSU", new Identifier("psu", "corsair", index.ToString()), settings)
    {
        _device = device;
        using HidStream stream = device.Open();

        UsbApi.Init(stream);
        UsbApi.FirmwareInfo fwInfo = UsbApi.FwInfo(stream);
        Name = $"{CultureInfo.InvariantCulture.TextInfo.ToTitleCase(fwInfo.Vendor.ToLowerInvariant())} {fwInfo.Product}";

        AddSensors(UsbApi.GetOptionalCommands(stream), UsbApi.GetCriticals(stream), settings);
    }

    public override HardwareType HardwareType => HardwareType.Psu;

    public override IDictionary<string, string> Properties
    {
        get
        {
            SortedDictionary<string, string> properties = new();

            using HidStream stream = _device.Open();

            float? mode = UsbApi.GetValue(stream, UsbApi.Command.OCPMODE, 0);
            if (mode.HasValue)
                properties.Add("Over-current protection", mode > 1.0 ? "multi-rail" : "single-rail");

            return properties;
        }
    }

    public override void Update()
    {
        using HidStream stream = _device.Open();
        _sensors.ForEach(s => s.Update(stream));
    }

    private void AddSensors(UsbApi.OptionalCommands optionalCommands, UsbApi.Criticals criticals, ISettings settings)
    {
        SensorIndices indices = new();
        _sensors.Add(new PsuSensorWithLimits("VRM",
                                             indices,
                                             SensorType.Temperature,
                                             this,
                                             settings,
                                             UsbApi.Command.TEMP0,
                                             null,
                                             criticals.TempMax[0]));

        _sensors.Add(new PsuSensorWithLimits("Case",
                                             indices,
                                             SensorType.Temperature,
                                             this,
                                             settings,
                                             UsbApi.Command.TEMP1,
                                             null,
                                             criticals.TempMax[1]));

        _sensors.Add(new PsuSensor("Case", indices, SensorType.Fan, this, settings, UsbApi.Command.FAN_RPM));

        _sensors.Add(new PsuSensor("Input", indices, SensorType.Voltage, this, settings, UsbApi.Command.IN_VOLTS));
        _sensors.Add(new PsuSensorWithLimits("+12V",
                                             indices,
                                             SensorType.Voltage,
                                             this,
                                             settings,
                                             UsbApi.Command.RAIL_VOLTS,
                                             criticals.VoltageMin[(byte)Rail._12V],
                                             criticals.VoltageMax[(byte)Rail._12V]));

        _sensors.Add(new PsuSensorWithLimits("+5V",
                                             indices,
                                             SensorType.Voltage,
                                             this,
                                             settings,
                                             UsbApi.Command.RAIL_VOLTS,
                                             criticals.VoltageMin[(byte)Rail._5V],
                                             criticals.VoltageMax[(byte)Rail._5V],
                                             Rail._5V));

        _sensors.Add(new PsuSensorWithLimits("+3.3V",
                                             indices,
                                             SensorType.Voltage,
                                             this,
                                             settings,
                                             UsbApi.Command.RAIL_VOLTS,
                                             criticals.VoltageMin[(byte)Rail._3V],
                                             criticals.VoltageMax[(byte)Rail._3V],
                                             Rail._3V));

        if (optionalCommands.HasFlag(UsbApi.OptionalCommands.InputCurrent))
        {
            _sensors.Add(new PsuSensor("Input", indices, SensorType.Current, this, settings, UsbApi.Command.IN_AMPS));
        }

        _sensors.Add(new PsuSensorWithLimits("+12V",
                                             indices,
                                             SensorType.Current,
                                             this,
                                             settings,
                                             UsbApi.Command.RAIL_AMPS,
                                             null,
                                             criticals.CurrentMax[(byte)Rail._12V]));

        _sensors.Add(new PsuSensorWithLimits("+5V",
                                             indices,
                                             SensorType.Current,
                                             this,
                                             settings,
                                             UsbApi.Command.RAIL_AMPS,
                                             null,
                                             criticals.CurrentMax[(byte)Rail._5V],
                                             Rail._5V));

        _sensors.Add(new PsuSensorWithLimits("+3.3V",
                                             indices,
                                             SensorType.Current,
                                             this,
                                             settings,
                                             UsbApi.Command.RAIL_AMPS,
                                             null,
                                             criticals.CurrentMax[(byte)Rail._3V],
                                             Rail._3V));

        PsuSensor[] powerRails =
        {
            new("+12V", indices, SensorType.Power, this, settings, UsbApi.Command.RAIL_WATTS),
            new("+5V", indices, SensorType.Power, this, settings, UsbApi.Command.RAIL_WATTS, Rail._5V),
            new("+3.3V", indices, SensorType.Power, this, settings, UsbApi.Command.RAIL_WATTS, Rail._3V)
        };

        _sensors.AddRange(powerRails);
        _sensors.Add(new PsuSensor("Total watts", indices, SensorType.Power, this, settings, UsbApi.Command.TOTAL_WATTS));
        _compositeSensors.Add(new CompositeSensor("Total Output",
                                                  indices.NextIndex(SensorType.Power),
                                                  SensorType.Power,
                                                  this,
                                                  settings,
                                                  powerRails,
                                                  (acc, sensor) => acc + sensor.Value ?? 0f));

        ActivateSensor(_compositeSensors[_compositeSensors.Count - 1]);

        _sensors.Add(new PsuSensor("Uptime", indices, SensorType.TimeSpan, this, settings, UsbApi.Command.UPTIME, Rail._12V, true));
        _sensors.Add(new PsuSensor("Total uptime", indices, SensorType.TimeSpan, this, settings, UsbApi.Command.TOTAL_UPTIME, Rail._12V, true));
    }

    private class PsuSensor : Sensor
    {
        private readonly UsbApi.Command _cmd;
        private readonly byte _rail;

        public PsuSensor(string name, SensorIndices indices, SensorType type, CorsairPsu hardware, ISettings settings, UsbApi.Command cmd, Rail rail = Rail._12V, bool noHistory = false)
            : base(name, indices.NextIndex(type), false, type, hardware, null, settings, noHistory)
        {
            _cmd = cmd;
            _rail = (byte)rail;

            hardware.ActivateSensor(this);
        }

        public void Update(HidStream stream)
        {
            Value = UsbApi.GetValue(stream, _cmd, _rail);
        }
    }

    private class PsuSensorWithLimits : PsuSensor, ICriticalSensorLimits
    {
        public PsuSensorWithLimits
        (
            string name,
            SensorIndices indices,
            SensorType type,
            CorsairPsu hardware,
            ISettings settings,
            UsbApi.Command cmd,
            float? lowCritical,
            float? highCritical,
            Rail rail = Rail._12V)
            : base(name, indices, type, hardware, settings, cmd, rail)
        {
            CriticalLowLimit = lowCritical;
            CriticalHighLimit = highCritical;
        }

        public float? CriticalHighLimit { get; }

        public float? CriticalLowLimit { get; }
    }

    private enum Rail : byte
    {
        _12V = 0,
        _5V = 1,
        _3V = 2
    }
}

#region Exception classes

public class CommunicationProtocolError : ApplicationException
{
    public CommunicationProtocolError(HidDevice device, string message)
        : base($"Error communicating with the PSU controller at {device.DevicePath}: {message}")
    { }
}

#endregion

#region PSU USB communication protocol implementation

internal static class UsbApi
{
    /* some values are SMBus LINEAR11 data which need a conversion */
#if false
        static int Linear11ToInt(ushort val, int scale)
        {
            int exp = ((short)val) >> 11;
            int mant = (((short)(val & 0x7ff)) << 5) >> 5;
            int result = mant * scale;

            return (exp >= 0) ? (result << exp) : (result >> -exp);
        }
#endif
    static float Linear11ToFloat32(ushort val)
    {
        int exp = (short)val >> 11;
        int mant = ((short)(val & 0x7ff) << 5) >> 5;
        return mant * (float)Math.Pow(2, exp);
    }

    static bool SendCommand(HidStream stream, byte length, Command cmd, byte arg, out byte[] replyData)
    {
        /*
         * Corsair protocol for PSUs
         *
         * message size = 64 bytes (request and response, little endian)
         * request:
         *	[length][command][param0][param1][paramX]...
         * reply:
         *	[echo of length][echo of command][data0][data1][dataX]...
         *
         *	- commands are byte sized opcodes
         *	- length is the sum of all bytes of the commands/params
         *	- the micro-controller of most of these PSUs support concatenation in the request and reply,
         *	  but it is better to not rely on this (it is also hard to parse)
         *	- the driver uses raw events to be accessible from userspace (though this is not really
         *	  supported, it is just there for convenience, may be removed in the future)
         *	- a reply always start with the length and command in the same order the request used it
         *	- length of the reply data is specific to the command used
         *	- some of the commands work on a rail and can be switched to a specific rail (0 = 12v,
         *	  1 = 5v, 2 = 3.3v)
         *	- the format of the init command 0xFE is swapped length/command bytes
         *	- parameter bytes amount and values are specific to the command (rail setting is the only
         *	  for now that uses non-zero values)
         *	- there are much more commands, especially for configuring the device, but they are not
         *	  supported because a wrong command/length can lockup the micro-controller
         *	- the driver supports debugfs for values not fitting into the hwmon class
         *	- not every device class (HXi, RMi or AXi) supports all commands
         *	- it is a pure sensors reading driver (will not support configuring)
        */

        const int cmdBufferSize = 64;
        const int replySize = 16;

        byte[] cmdBuffer = new byte[cmdBufferSize + 1];
        cmdBuffer[0] = 0; // report id
        cmdBuffer[1] = length;
        cmdBuffer[2] = (byte)cmd;
        cmdBuffer[3] = arg;

        stream.Write(cmdBuffer);
        byte[] reply = stream.Read();
        replyData = new byte[replySize];
        Array.Copy(reply, 3, replyData, 0, replySize);

        return reply[1] == cmdBuffer[1] && reply[2] == cmdBuffer[2];
    }

    public static void Init(HidStream stream)
    {
        /*
         * PSU_CMD_INIT uses swapped length/command and expects 2 parameter bytes, this command
         * actually generates a reply, but we don't need it
         */
        SendCommand(stream, (byte)Command.INIT, (Command)3, 0, out _);
    }

    public struct FirmwareInfo
    {
        public string Vendor;
        public string Product;
    }

    public static FirmwareInfo FwInfo(HidStream stream)
    {
        if (!SendCommand(stream, 3, Command.VEND_STR, 0, out byte[] vendorArr))
            throw new CommunicationProtocolError(stream.Device, "Can't read vendor string");

        if (!SendCommand(stream, 3, Command.PROD_STR, 0, out byte[] productArr))
            throw new CommunicationProtocolError(stream.Device, "Can't read product");

        string ArrayToString(byte[] ar)
        {
            return Encoding.ASCII.GetString(ar.TakeWhile(x => x != 0).ToArray());
        }

        return new FirmwareInfo { Vendor = ArrayToString(vendorArr), Product = ArrayToString(productArr) };
    }

    static bool Request(HidStream stream, Command cmd, byte rail, out byte[] data)
    {
        //mutex_lock(&priv->lock) ;
        switch (cmd)
        {
            case Command.RAIL_VOLTS_HCRIT:
            case Command.RAIL_VOLTS_LCRIT:
            case Command.RAIL_AMPS_HCRIT:
            case Command.RAIL_VOLTS:
            case Command.RAIL_AMPS:
            case Command.RAIL_WATTS:
                if (!SendCommand(stream, 2, Command.SELECT_RAIL, rail, out _))
                {
                    data = null;
                    return false;
                }

                break;
        }

        return SendCommand(stream, 3, cmd, 0, out data);

        //  mutex_unlock(&priv->lock) ;
        //  return ret;
    }

    public static float? GetValue(HidStream stream, Command cmd, byte rail)
    {
        if (!Request(stream, cmd, rail, out byte[] data))
        {
            return null;
        }

        /*
         * the biggest value here comes from the uptime command and to exceed MAXINT total uptime
         * needs to be about 68 years, the rest are u16 values and the biggest value coming out of
         * the LINEAR11 conversion are the watts values which are about 1200 for the strongest psu
         * supported (HX1200i)
         */
        int tmp = BitConverter.ToInt32(data, 0); // ((int)data[3] << 24) + (data[2] << 16) + (data[1] << 8) + data[0];
        return cmd switch
        {
            Command.RAIL_VOLTS_HCRIT or Command.RAIL_VOLTS_LCRIT or Command.RAIL_AMPS_HCRIT or Command.TEMP_HCRIT or Command.IN_VOLTS or Command.IN_AMPS or Command.RAIL_VOLTS or Command.RAIL_AMPS
                or Command.TEMP0 or Command.TEMP1 or Command.FAN_RPM or Command.RAIL_WATTS or Command.TOTAL_WATTS => Linear11ToFloat32((ushort)tmp), // Linear11ToInt((ushort)tmp, 1000000);
            Command.TOTAL_UPTIME or Command.UPTIME or Command.OCPMODE => tmp,
            _ => null
        };
    }

    public struct Criticals
    {
        public float?[] TempMax;

        public float?[] VoltageMin;
        public float?[] VoltageMax;

        public float?[] CurrentMax;
    }

    public static Criticals GetCriticals(HidStream stream)
    {
        Criticals res = new();
        const byte tempCount = 2;
        res.TempMax = new float?[tempCount];

        for (byte rail = 0; rail < tempCount; rail++)
        {
            res.TempMax[rail] = GetValue(stream, Command.TEMP_HCRIT, rail);
        }

        const byte railCount = 3; /* 3v + 5v + 12v */
        res.VoltageMin = new float?[railCount];
        res.VoltageMax = new float?[railCount];
        res.CurrentMax = new float?[railCount];

        for (byte rail = 0; rail < railCount; rail++)
        {
            res.VoltageMax[rail] = GetValue(stream, Command.RAIL_VOLTS_HCRIT, rail);
            res.VoltageMin[rail] = GetValue(stream, Command.RAIL_VOLTS_LCRIT, rail);
            res.CurrentMax[rail] = GetValue(stream, Command.RAIL_AMPS_HCRIT, rail);
        }

        return res;
    }

    [Flags]
    public enum OptionalCommands
    {
        None = 0x0,
        InputCurrent = 0x1
    }

    public static OptionalCommands GetOptionalCommands(HidStream stream)
    {
        OptionalCommands res = OptionalCommands.None;
        if (GetValue(stream, Command.IN_AMPS, 0).HasValue)
        {
            res |= OptionalCommands.InputCurrent;
        }

        return res;
    }

    public enum Command : byte
    {
        SELECT_RAIL = 0x00, /* expects length 2 */
        RAIL_VOLTS_HCRIT = 0x40, /* the rest of the commands expect length 3 */
        RAIL_VOLTS_LCRIT = 0x44,
        RAIL_AMPS_HCRIT = 0x46,
        TEMP_HCRIT = 0x4F,
        IN_VOLTS = 0x88,
        IN_AMPS = 0x89,
        RAIL_VOLTS = 0x8B,
        RAIL_AMPS = 0x8C,
        TEMP0 = 0x8D,
        TEMP1 = 0x8E,
        FAN_RPM = 0x90,
        RAIL_WATTS = 0x96,
        VEND_STR = 0x99,
        PROD_STR = 0x9A,
        TOTAL_UPTIME = 0xD1,
        UPTIME = 0xD2,
        OCPMODE = 0xD8,
        TOTAL_WATTS = 0xEE,
        INIT = 0xFE
    }
}

#endregion

```

`LibreHardwareMonitorLib/Hardware/Psu/Corsair/CorsairPsuGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the GNU Public License, v. 2.0.
// Copyright(C) 2020 Wilken Gottwalt<wilken.gottwalt@posteo.net>
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.
// Implemented after the Linuix kernel driver corsair_psu by Wilken Gottwalt and contributers

using System.Collections.Generic;
using System.Linq;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Psu.Corsair;

public class CorsairPsuGroup : IGroup
{
    private static readonly int[] _productIds =
    {
        0x1c03, // HX550i
        0x1c04, // HX650i
        0x1c05, // HX750i
        0x1c06, // HX850i
        0x1c07, // HX1000i
        0x1c1e, // HX1000i REV2
        0x1c08, // HX1200i
        0x1c1f, // HX1500i

        0x1c09, // RM550i
        0x1c0a, // RM650i
        0x1c0b, // RM750i
        0x1c0c, // RM850i
        0x1c0d, // RM1000i

        // 0x1c11, // AX1600i
    };

    private static readonly ushort _vendorId = 0x1b1c;
    private readonly List<IHardware> _hardware;
    private readonly StringBuilder _report;

    public CorsairPsuGroup(ISettings settings)
    {
        _report = new StringBuilder();
        _report.AppendLine("Corsair HXi/RMi series PSU Hardware");
        _report.AppendLine();

        _hardware = new List<IHardware>();
        foreach (HidDevice dev in DeviceList.Local.GetHidDevices(_vendorId))
        {
            if (_productIds.Contains(dev.ProductID))
            {
                var device = new CorsairPsu(dev, settings, _hardware.Count);
                _hardware.Add(device);
                _report.AppendLine($"Device name: {device.Name}");
                _report.AppendLine();
            }
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (IHardware iHardware in _hardware)
        {
            if (iHardware is Hardware hardware)
                hardware.Close();
        }
    }

    public string GetReport()
    {
        return _report.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Ring0.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

namespace LibreHardwareMonitor.Hardware;

internal static class Ring0
{
    private static KernelDriver _driver;
    private static Mutex _ecMutex;
    private static string _filePath;
    private static Mutex _isaBusMutex;
    private static Mutex _pciBusMutex;

    private static readonly StringBuilder _report = new();

    public static bool IsOpen => _driver != null;

    public static void Open()
    {
        // no implementation for unix systems
        if (Software.OperatingSystem.IsUnix)
            return;

        if (_driver != null)
            return;

        // clear the current report
        _report.Length = 0;

        _driver = new KernelDriver(GetServiceName(), "WinRing0_1_2_0");
        _driver.Open();

        if (!_driver.IsOpen)
        {
            // driver is not loaded, try to install and open
            _filePath = GetFilePath();
            if (_filePath != null && Extract(_filePath))
            {
                if (_driver.Install(_filePath, out string installError))
                {
                    _driver.Open();

                    if (!_driver.IsOpen)
                        _report.AppendLine("Status: Opening driver failed after install");
                }
                else
                {
                    // install failed, try to delete and reinstall
                    _driver.Delete();

                    // wait a short moment to give the OS a chance to remove the driver
                    Thread.Sleep(2000);

                    if (_driver.Install(_filePath, out string secondError))
                    {
                        _driver.Open();

                        if (!_driver.IsOpen)
                            _report.AppendLine("Status: Opening driver failed after reinstall");
                    }
                    else
                    {
                        _report.Append("Status: Installing driver \"").Append(_filePath).Append("\" failed").AppendLine(File.Exists(_filePath) ? " and file exists" : string.Empty);
                        _report.Append("First Exception: ").AppendLine(installError);
                        _report.Append("Second Exception: ").AppendLine(secondError);
                    }
                }

                if (!_driver.IsOpen)
                {
                    _driver.Delete();
                    Delete();
                }
            }
            else
            {
                _report.AppendLine("Status: Extracting driver failed");
            }
        }

        if (!_driver.IsOpen)
            _driver = null;

        const string isaMutexName = "Global\\Access_ISABUS.HTP.Method";
        if (!TryCreateOrOpenExistingMutex(isaMutexName, out _isaBusMutex))
        {
            // Mutex could not be created or opened.
        }

        const string pciMutexName = "Global\\Access_PCI";
        if (!TryCreateOrOpenExistingMutex(pciMutexName, out _pciBusMutex))
        {
            // Mutex could not be created or opened.
        }

        const string ecMutexName = "Global\\Access_EC";
        if (!TryCreateOrOpenExistingMutex(ecMutexName, out _ecMutex))
        {
            // Mutex could not be created or opened.
        }
    }

    private static bool Extract(string filePath)
    {
        string resourceName = $"{nameof(LibreHardwareMonitor)}.Resources.{(Software.OperatingSystem.Is64Bit ? "WinRing0x64.gz" : "WinRing0.gz")}";

        Assembly assembly = typeof(Ring0).Assembly;
        long requiredLength = 0;

        try
        {
            using Stream stream = assembly.GetManifestResourceStream(resourceName);

            if (stream != null)
            {
                using FileStream target = new(filePath, FileMode.Create);

                stream.Position = 1; // Skip first byte.

                using var gzipStream = new GZipStream(stream, CompressionMode.Decompress);

                gzipStream.CopyTo(target);

                requiredLength = target.Length;
            }
        }
        catch
        {
            return false;
        }

        if (HasValidFile())
            return true;

        // Ensure the file is actually written to the file system.
        var stopwatch = new Stopwatch();
        stopwatch.Start();

        while (stopwatch.ElapsedMilliseconds < 2000)
        {
            if (HasValidFile())
                return true;

            Thread.Yield();
        }

        return false;

        bool HasValidFile()
        {
            try
            {
                return File.Exists(filePath) && new FileInfo(filePath).Length == requiredLength;
            }
            catch
            {
                return false;
            }
        }
    }

    private static bool TryCreateOrOpenExistingMutex(string name, out Mutex mutex)
    {
        try
        {
            mutex = new Mutex(false, name);
            return true;
        }
        catch (UnauthorizedAccessException)
        {
            try
            {
                mutex = Mutex.OpenExisting(name);
                return true;
            }
            catch
            {
                mutex = null;
            }
        }

        return false;
    }

    private static void Delete()
    {
        try
        {
            // Try to delete the driver file
            if (_filePath != null && File.Exists(_filePath))
                File.Delete(_filePath);

            _filePath = null;
        }
        catch
        { }
    }

    private static string GetServiceName()
    {
        string name;

        try
        {
            ProcessModule processModule = Process.GetCurrentProcess().MainModule;
            if (!string.IsNullOrEmpty(processModule?.FileName))
            {
                name = Path.GetFileNameWithoutExtension(processModule.FileName);
                if (!string.IsNullOrEmpty(name))
                    return GetName(name);
            }
        }
        catch
        {
            // Continue with the other options.
        }

        name = GetNameFromAssembly(Assembly.GetExecutingAssembly());
        if (!string.IsNullOrEmpty(name))
            return GetName(name);

        name = GetNameFromAssembly(typeof(Ring0).Assembly);
        if (!string.IsNullOrEmpty(name))
            return GetName(name);

        name = nameof(LibreHardwareMonitor);
        return GetName(name);

        static string GetNameFromAssembly(Assembly assembly)
        {
            return assembly?.GetName().Name;
        }

        static string GetName(string name)
        {
            return $"R0{name}".Replace(" ", string.Empty).Replace(".", "_");
        }
    }

    private static string GetFilePath()
    {
        string filePath;

        try
        {
            ProcessModule processModule = Process.GetCurrentProcess().MainModule;
            if (!string.IsNullOrEmpty(processModule?.FileName))
            {
                filePath = Path.ChangeExtension(processModule.FileName, ".sys");
                if (TryCreate(filePath))
                    return filePath;
            }
        }
        catch
        {
            // Continue with the other options.
        }

        filePath = GetPathFromAssembly(Assembly.GetExecutingAssembly());
        if (!string.IsNullOrEmpty(filePath) && TryCreate(filePath))
            return filePath;

        filePath = GetPathFromAssembly(typeof(Ring0).Assembly);
        if (!string.IsNullOrEmpty(filePath) && TryCreate(filePath))
            return filePath;

        try
        {
            filePath = Path.GetTempFileName();
            if (!string.IsNullOrEmpty(filePath))
            {
                filePath = Path.ChangeExtension(filePath, ".sys");
                if (TryCreate(filePath))
                    return filePath;
            }
        }
        catch
        {
            return null;
        }

        return null;

        static string GetPathFromAssembly(Assembly assembly)
        {
            try
            {
                string location = assembly?.Location;
                return !string.IsNullOrEmpty(location) ? Path.ChangeExtension(location, ".sys") : null;
            }
            catch
            {
                return null;
            }
        }

        static bool TryCreate(string path)
        {
            try
            {
                using (File.Create(path))
                    return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public static void Close()
    {
        if (_driver != null)
        {
            uint refCount = 0;
            _driver.DeviceIOControl(Interop.Ring0.IOCTL_OLS_GET_REFCOUNT, null, ref refCount);
            _driver.Close();

            if (refCount <= 1)
                _driver.Delete();

            _driver = null;
        }

        if (_isaBusMutex != null)
        {
            _isaBusMutex.Close();
            _isaBusMutex = null;
        }

        if (_pciBusMutex != null)
        {
            _pciBusMutex.Close();
            _pciBusMutex = null;
        }

        if (_ecMutex != null)
        {
            _ecMutex.Close();
            _ecMutex = null;
        }

        // try to delete temporary driver file again if failed during open
        Delete();
    }

    public static string GetReport()
    {
        if (_report.Length > 0)
        {
            StringBuilder r = new();
            r.AppendLine("Ring0");
            r.AppendLine();
            r.Append(_report);
            r.AppendLine();
            return r.ToString();
        }

        return null;
    }

    public static bool WaitIsaBusMutex(int millisecondsTimeout)
    {
        if (_isaBusMutex == null)
            return true;

        try
        {
            return _isaBusMutex.WaitOne(millisecondsTimeout, false);
        }
        catch (AbandonedMutexException)
        {
            return true;
        }
        catch (InvalidOperationException)
        {
            return false;
        }
    }

    public static void ReleaseIsaBusMutex()
    {
        _isaBusMutex?.ReleaseMutex();
    }

    public static bool WaitPciBusMutex(int millisecondsTimeout)
    {
        if (_pciBusMutex == null)
            return true;

        try
        {
            return _pciBusMutex.WaitOne(millisecondsTimeout, false);
        }
        catch (AbandonedMutexException)
        {
            return true;
        }
        catch (InvalidOperationException)
        {
            return false;
        }
    }

    public static void ReleasePciBusMutex()
    {
        _pciBusMutex?.ReleaseMutex();
    }

    public static bool WaitEcMutex(int millisecondsTimeout)
    {
        if (_ecMutex == null)
            return true;

        try
        {
            return _ecMutex.WaitOne(millisecondsTimeout, false);
        }
        catch (AbandonedMutexException)
        {
            return true;
        }
        catch (InvalidOperationException)
        {
            return false;
        }
    }

    public static void ReleaseEcMutex()
    {
        _ecMutex?.ReleaseMutex();
    }

    public static bool ReadMsr(uint index, out uint eax, out uint edx)
    {
        if (_driver == null)
        {
            eax = 0;
            edx = 0;
            return false;
        }

        ulong buffer = 0;
        bool result = _driver.DeviceIOControl(Interop.Ring0.IOCTL_OLS_READ_MSR, index, ref buffer);
        edx = (uint)((buffer >> 32) & 0xFFFFFFFF);
        eax = (uint)(buffer & 0xFFFFFFFF);
        return result;
    }

    public static bool ReadMsr(uint index, out uint eax, out uint edx, GroupAffinity affinity)
    {
        GroupAffinity previousAffinity = ThreadAffinity.Set(affinity);
        bool result = ReadMsr(index, out eax, out edx);
        ThreadAffinity.Set(previousAffinity);
        return result;
    }

    public static bool WriteMsr(uint index, uint eax, uint edx)
    {
        if (_driver == null)
            return false;

        WriteMsrInput input = new() { Register = index, Value = ((ulong)edx << 32) | eax };
        return _driver.DeviceIOControl(Interop.Ring0.IOCTL_OLS_WRITE_MSR, input);
    }

    public static byte ReadIoPort(uint port)
    {
        if (_driver == null)
            return 0;

        uint value = 0;
        _driver.DeviceIOControl(Interop.Ring0.IOCTL_OLS_READ_IO_PORT_BYTE, port, ref value);
        return (byte)(value & 0xFF);
    }

    public static void WriteIoPort(uint port, byte value)
    {
        if (_driver == null)
            return;

        WriteIoPortInput input = new() { PortNumber = port, Value = value };
        _driver.DeviceIOControl(Interop.Ring0.IOCTL_OLS_WRITE_IO_PORT_BYTE, input);
    }

    public static uint GetPciAddress(byte bus, byte device, byte function)
    {
        return (uint)(((bus & 0xFF) << 8) | ((device & 0x1F) << 3) | (function & 7));
    }

    public static bool ReadPciConfig(uint pciAddress, uint regAddress, out uint value)
    {
        if (_driver == null || (regAddress & 3) != 0)
        {
            value = 0;
            return false;
        }

        ReadPciConfigInput input = new() { PciAddress = pciAddress, RegAddress = regAddress };

        value = 0;
        return _driver.DeviceIOControl(Interop.Ring0.IOCTL_OLS_READ_PCI_CONFIG, input, ref value);
    }

    public static bool WritePciConfig(uint pciAddress, uint regAddress, uint value)
    {
        if (_driver == null || (regAddress & 3) != 0)
            return false;

        WritePciConfigInput input = new() { PciAddress = pciAddress, RegAddress = regAddress, Value = value };
        return _driver.DeviceIOControl(Interop.Ring0.IOCTL_OLS_WRITE_PCI_CONFIG, input);
    }

    public static bool ReadMemory<T>(ulong address, ref T buffer)
    {
        if (_driver == null)
            return false;

        ReadMemoryInput input = new() { Address = address, UnitSize = 1, Count = (uint)Marshal.SizeOf(buffer) };
        return _driver.DeviceIOControl(Interop.Ring0.IOCTL_OLS_READ_MEMORY, input, ref buffer);
    }

    public static bool ReadMemory<T>(ulong address, ref T[] buffer)
    {
        if (_driver == null)
            return false;

        ReadMemoryInput input = new() { Address = address, UnitSize = (uint)Marshal.SizeOf(typeof(T)), Count = (uint)buffer.Length };
        return _driver.DeviceIOControl(Interop.Ring0.IOCTL_OLS_READ_MEMORY, input, ref buffer);
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    private struct WriteMsrInput
    {
        public uint Register;
        public ulong Value;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    private struct WriteIoPortInput
    {
        public uint PortNumber;
        public byte Value;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    private struct ReadPciConfigInput
    {
        public uint PciAddress;
        public uint RegAddress;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    private struct WritePciConfigInput
    {
        public uint PciAddress;
        public uint RegAddress;
        public uint Value;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    private struct ReadMemoryInput
    {
        public ulong Address;
        public uint UnitSize;
        public uint Count;
    }
}

```

`LibreHardwareMonitorLib/Hardware/RyzenSMU.cs`:

```cs
// ported from: https://gitlab.com/leogx9r/ryzen_smu
// and: https://github.com/irusanov/SMUDebugTool

using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Hardware;

internal class RyzenSMU
{
    private const byte SMU_PCI_ADDR_REG = 0xC4;
    private const byte SMU_PCI_DATA_REG = 0xC8;
    private const uint SMU_REQ_MAX_ARGS = 6;
    private const uint SMU_RETRIES_MAX = 8096;

    private readonly CpuCodeName _cpuCodeName;
    private readonly Mutex _mutex = new();
    private readonly bool _supportedCPU;

    private readonly Dictionary<uint, Dictionary<uint, SmuSensorType>> _supportedPmTableVersions = new()
    {
        {
            // Zen Raven Ridge APU.
            0x001E0004, new Dictionary<uint, SmuSensorType>
            {
                { 7, new SmuSensorType { Name = "TDC", Type = SensorType.Current, Scale = 1 } },
                { 11, new SmuSensorType { Name = "EDC", Type = SensorType.Current, Scale = 1 } },
                //{ 61, new SmuSensorType { Name = "Core", Type = SensorType.Voltage } },
                //{ 62, new SmuSensorType { Name = "Core", Type = SensorType.Current, Scale = 1} },
                //{ 63, new SmuSensorType { Name = "Core", Type = SensorType.Power, Scale = 1 } },
                //{ 65, new SmuSensorType { Name = "SoC", Type = SensorType.Voltage } },
                { 66, new SmuSensorType { Name = "SoC", Type = SensorType.Current, Scale = 1 } },
                { 67, new SmuSensorType { Name = "SoC", Type = SensorType.Power, Scale = 1 } },
                //{ 96, new SmuSensorType { Name = "Core #1", Type = SensorType.Power } },
                //{ 97, new SmuSensorType { Name = "Core #2", Type = SensorType.Power } },
                //{ 98, new SmuSensorType { Name = "Core #3", Type = SensorType.Power } },
                //{ 99, new SmuSensorType { Name = "Core #4", Type = SensorType.Power } },
                { 108, new SmuSensorType { Name = "Core #1", Type = SensorType.Temperature, Scale = 1 } },
                { 109, new SmuSensorType { Name = "Core #2", Type = SensorType.Temperature, Scale = 1 } },
                { 110, new SmuSensorType { Name = "Core #3", Type = SensorType.Temperature, Scale = 1 } },
                { 111, new SmuSensorType { Name = "Core #4", Type = SensorType.Temperature, Scale = 1 } },
                { 150, new SmuSensorType { Name = "GFX", Type = SensorType.Voltage, Scale = 1 } },
                { 151, new SmuSensorType { Name = "GFX", Type = SensorType.Temperature, Scale = 1 } },
                { 154, new SmuSensorType { Name = "GFX", Type = SensorType.Clock, Scale = 1 } },
                { 156, new SmuSensorType { Name = "GFX", Type = SensorType.Load, Scale = 1 } },
                { 166, new SmuSensorType { Name = "Fabric", Type = SensorType.Clock, Scale = 1 } },
                { 177, new SmuSensorType { Name = "Uncore", Type = SensorType.Clock, Scale = 1 } },
                { 178, new SmuSensorType { Name = "Memory", Type = SensorType.Clock, Scale = 1 } },
                { 342, new SmuSensorType { Name = "Displays", Type = SensorType.Factor, Scale = 1 } }
            }
        },
        {
            // Zen 2.
            0x00240903, new Dictionary<uint, SmuSensorType>
            {
                { 15, new SmuSensorType { Name = "TDC", Type = SensorType.Current, Scale = 1 } },
                { 21, new SmuSensorType { Name = "EDC", Type = SensorType.Current, Scale = 1 } },
                { 48, new SmuSensorType { Name = "Fabric", Type = SensorType.Clock, Scale = 1 } },
                { 50, new SmuSensorType { Name = "Uncore", Type = SensorType.Clock, Scale = 1 } },
                { 51, new SmuSensorType { Name = "Memory", Type = SensorType.Clock, Scale = 1 } },
                { 115, new SmuSensorType { Name = "SoC", Type = SensorType.Temperature, Scale = 1 } }
                //{ 66, new SmuSensorType { Name = "Bus Speed", Type = SensorType.Clock, Scale = 1 } },
                //{ 188, new SmuSensorType { Name = "Core #1", Type = SensorType.Clock, Scale = 1000 } },
                //{ 189, new SmuSensorType { Name = "Core #2", Type = SensorType.Clock, Scale = 1000 } },
                //{ 190, new SmuSensorType { Name = "Core #3", Type = SensorType.Clock, Scale = 1000 } },
                //{ 191, new SmuSensorType { Name = "Core #4", Type = SensorType.Clock, Scale = 1000 } },
                //{ 192, new SmuSensorType { Name = "Core #5", Type = SensorType.Clock, Scale = 1000 } },
                //{ 193, new SmuSensorType { Name = "Core #6", Type = SensorType.Clock, Scale = 1000 } },
            }
        },
        {
            // Zen 3.
            0x00380805, new Dictionary<uint, SmuSensorType>
            {
                { 3, new SmuSensorType { Name = "TDC", Type = SensorType.Current, Scale = 1 } },
                // TODO: requires some post-processing
                // see: https://gitlab.com/leogx9r/ryzen_smu/-/blob/master/userspace/monitor_cpu.c#L577
                // { 9, new SmuSensorType { Name = "EDC", Type = SensorType.Current, Scale = 1 } },
                { 48, new SmuSensorType { Name = "Fabric", Type = SensorType.Clock, Scale = 1 } },
                { 50, new SmuSensorType { Name = "Uncore", Type = SensorType.Clock, Scale = 1 } },
                { 51, new SmuSensorType { Name = "Memory", Type = SensorType.Clock, Scale = 1 } },
                { 127, new SmuSensorType { Name = "SoC", Type = SensorType.Temperature, Scale = 1 } },
                { 268, new SmuSensorType { Name = "Core #1 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 269, new SmuSensorType { Name = "Core #2 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 270, new SmuSensorType { Name = "Core #3 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 271, new SmuSensorType { Name = "Core #4 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 272, new SmuSensorType { Name = "Core #5 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 273, new SmuSensorType { Name = "Core #6 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 274, new SmuSensorType { Name = "Core #7 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 275, new SmuSensorType { Name = "Core #8 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 276, new SmuSensorType { Name = "Core #9 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 277, new SmuSensorType { Name = "Core #10 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 278, new SmuSensorType { Name = "Core #11 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 279, new SmuSensorType { Name = "Core #12 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 280, new SmuSensorType { Name = "Core #13 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 281, new SmuSensorType { Name = "Core #14 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 282, new SmuSensorType { Name = "Core #15 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                { 283, new SmuSensorType { Name = "Core #16 (Effective)", Type = SensorType.Clock, Scale = 1000 } }
            }
        },
        {
            // Zen 4.
            0x00540004, new Dictionary<uint, SmuSensorType>
            {
                { 3, new SmuSensorType { Name = "CPU PPT", Type = SensorType.Power, Scale = 1 } },
                { 11, new SmuSensorType { Name = "Package", Type = SensorType.Temperature, Scale = 1 } },
                { 20, new SmuSensorType { Name = "Core Power", Type = SensorType.Power, Scale = 1 } },
                { 21, new SmuSensorType { Name = "SOC Power", Type = SensorType.Power, Scale = 1 } },
                { 22, new SmuSensorType { Name = "Misc Power", Type = SensorType.Power, Scale = 1 } },
                { 26, new SmuSensorType { Name = "Total Power", Type = SensorType.Power, Scale = 1 } },
                { 47, new SmuSensorType { Name = "VDDCR", Type = SensorType.Voltage, Scale = 1 } },
                { 48, new SmuSensorType { Name = "TDC", Type = SensorType.Current, Scale = 1 } },
                { 49, new SmuSensorType { Name = "EDC", Type = SensorType.Current, Scale = 1 } },
                { 52, new SmuSensorType { Name = "VDDCR SoC", Type = SensorType.Voltage, Scale = 1 } },
                { 57, new SmuSensorType { Name = "VDD Misc", Type = SensorType.Voltage, Scale = 1 } },
                { 70, new SmuSensorType { Name = "Fabric", Type = SensorType.Clock, Scale = 1 } },
                { 74, new SmuSensorType { Name = "Uncore", Type = SensorType.Clock, Scale = 1 } },
                { 78, new SmuSensorType { Name = "Memory", Type = SensorType.Clock, Scale = 1 } },
                { 211, new SmuSensorType { Name = "IOD Hotspot", Type = SensorType.Temperature, Scale = 1 } },
                { 539, new SmuSensorType { Name = "L3 (CCD1)", Type = SensorType.Temperature, Scale = 1 } },
                { 540, new SmuSensorType { Name = "L3 (CCD2)", Type = SensorType.Temperature, Scale = 1 } },
                { 268, new SmuSensorType { Name = "LDO VDD", Type = SensorType.Voltage, Scale = 1 } },

                // This is not working, some cores can be deactivated with the core disabled map.
                // When Core 2 is disabled and Core 3 is enabled, the name of Core 3 == "Core 2".
                //{ 357, new SmuSensorType { Name = "Core #1 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 358, new SmuSensorType { Name = "Core #2 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 359, new SmuSensorType { Name = "Core #3 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 360, new SmuSensorType { Name = "Core #4 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 361, new SmuSensorType { Name = "Core #5 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 362, new SmuSensorType { Name = "Core #6 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 363, new SmuSensorType { Name = "Core #7 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 364, new SmuSensorType { Name = "Core #8 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 365, new SmuSensorType { Name = "Core #9 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 366, new SmuSensorType { Name = "Core #10 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 367, new SmuSensorType { Name = "Core #11 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 368, new SmuSensorType { Name = "Core #12 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 369, new SmuSensorType { Name = "Core #13 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 370, new SmuSensorType { Name = "Core #14 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 371, new SmuSensorType { Name = "Core #15 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 372, new SmuSensorType { Name = "Core #16 (Effective)", Type = SensorType.Clock, Scale = 1000 } }
            }
        }
    };

    private uint _argsAddr;
    private uint _cmdAddr;
    private uint _dramAddrHi;
    private uint _dramBaseAddr;
    private uint _pmTableSize;
    private uint _pmTableSizeAlt;
    private uint _pmTableVersion;
    private uint _rspAddr;

    public RyzenSMU(uint family, uint model, uint packageType)
    {
        _cpuCodeName = GetCpuCodeName(family, model, packageType);

        _supportedCPU = Environment.Is64BitOperatingSystem == Environment.Is64BitProcess && SetAddresses(_cpuCodeName);

        if (_supportedCPU)
        {
            InpOut.Open();
            SetupPmTableAddrAndSize();
        }
    }

    private static CpuCodeName GetCpuCodeName(uint family, uint model, uint packageType)
    {
        return family switch
        {
            0x17 => model switch
            {
                0x01 => packageType == 7 ? CpuCodeName.Threadripper : CpuCodeName.SummitRidge,
                0x08 => packageType == 7 ? CpuCodeName.Colfax : CpuCodeName.PinnacleRidge,
                0x11 => CpuCodeName.RavenRidge,
                0x18 => packageType == 2 ? CpuCodeName.RavenRidge2 : CpuCodeName.Picasso,
                0x20 => CpuCodeName.Dali,
                0x31 => CpuCodeName.CastlePeak,
                0x60 => CpuCodeName.Renoir,
                0x71 => CpuCodeName.Matisse,
                0x90 => CpuCodeName.Vangogh,
                _ => CpuCodeName.Undefined
            },
            0x19 => model switch
            {
                0x00 => CpuCodeName.Milan,
                0x20 or 0x21 => CpuCodeName.Vermeer,
                0x40 => CpuCodeName.Rembrandt,
                0x50 => CpuCodeName.Cezanne,
                0x61 => CpuCodeName.Raphael,
                _ => CpuCodeName.Undefined
            },
            _ => CpuCodeName.Undefined
        };
    }

    public string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("Ryzen SMU");
        r.AppendLine();
        r.AppendLine($" PM table version: 0x{_pmTableVersion:X8}");
        r.AppendLine($" PM table supported: {_supportedCPU}");
        r.AppendLine($" PM table layout defined: {IsPmTableLayoutDefined()}");

        if (_supportedCPU)
        {
            r.AppendLine($" PM table size: 0x{_pmTableSize:X3}");
            r.AppendLine($" PM table start address: 0x{_dramBaseAddr:X8}");
            r.AppendLine();
            r.AppendLine(" PM table dump:");
            r.AppendLine("  Idx    Offset   Value");
            r.AppendLine(" ------------------------");

            float[] pm_values = GetPmTable();
            for (int i = 0; i < pm_values.Length; i++)
            {
                r.AppendLine($" {i,4}    0x{i * 4:X3}    {pm_values[i]}");
            }
        }

        return r.ToString();
    }

    private bool SetAddresses(CpuCodeName codeName)
    {
        switch (codeName)
        {
            case CpuCodeName.CastlePeak:
            case CpuCodeName.Matisse:
            case CpuCodeName.Vermeer:
            case CpuCodeName.Raphael:
                _cmdAddr = 0x3B10524;
                _rspAddr = 0x3B10570;
                _argsAddr = 0x3B10A40;
                return true;

            case CpuCodeName.Colfax:
            case CpuCodeName.SummitRidge:
            case CpuCodeName.Threadripper:
            case CpuCodeName.PinnacleRidge:
                _cmdAddr = 0x3B1051C;
                _rspAddr = 0x3B10568;
                _argsAddr = 0x3B10590;
                return true;

            case CpuCodeName.Renoir:
            case CpuCodeName.Picasso:
            case CpuCodeName.RavenRidge:
            case CpuCodeName.RavenRidge2:
            case CpuCodeName.Dali:
                _cmdAddr = 0x3B10A20;
                _rspAddr = 0x3B10A80;
                _argsAddr = 0x3B10A88;
                return true;

            default:
                return false;
        }
    }

    public uint GetSmuVersion()
    {
        uint[] args = { 1 };

        if (SendCommand(0x02, ref args))
            return args[0];

        return 0;
    }

    public Dictionary<uint, SmuSensorType> GetPmTableStructure()
    {
        if (!IsPmTableLayoutDefined())
            return new Dictionary<uint, SmuSensorType>();

        return _supportedPmTableVersions[_pmTableVersion];
    }

    public bool IsPmTableLayoutDefined()
    {
        return _supportedPmTableVersions.ContainsKey(_pmTableVersion);
    }

    public float[] GetPmTable()
    {
        if (!_supportedCPU || !TransferTableToDram())
            return new float[] { 0 };

        float[] table = ReadDramToArray();

        // Fix for Zen+ empty values on first call.
        if (table.Length == 0 || table[0] == 0)
        {
            Thread.Sleep(10);
            TransferTableToDram();
            table = ReadDramToArray();
        }

        return table;
    }

    private float[] ReadDramToArray()
    {
        float[] table = new float[_pmTableSize / 4];

        IntPtr pMemory = Environment.Is64BitProcess ? new IntPtr(_dramBaseAddr | (long)_dramAddrHi << 32) : new IntPtr(_dramBaseAddr);

        byte[] bytes = InpOut.ReadMemory(pMemory, _pmTableSize);
        if (bytes != null)
            Buffer.BlockCopy(bytes, 0, table, 0, bytes.Length);

        return table;
    }

    private bool SetupPmTableAddrAndSize()
    {
        if (_pmTableSize == 0)
            SetupPmTableSize();

        if (_dramBaseAddr == 0)
            SetupDramBaseAddr();

        return _dramBaseAddr != 0 && _pmTableSize != 0;
    }

    private void SetupPmTableSize()
    {
        if (!GetPmTableVersion(ref _pmTableVersion))
            return;

        switch (_cpuCodeName)
        {
            case CpuCodeName.Matisse:
                switch (_pmTableVersion)
                {
                    case 0x240902:
                        _pmTableSize = 0x514;
                        break;
                    case 0x240903:
                        _pmTableSize = 0x518;
                        break;
                    case 0x240802:
                        _pmTableSize = 0x7E0;
                        break;
                    case 0x240803:
                        _pmTableSize = 0x7E4;
                        break;
                    default:
                        return;
                }

                break;

            case CpuCodeName.Vermeer:
                switch (_pmTableVersion)
                {
                    case 0x2D0903:
                        _pmTableSize = 0x594;
                        break;
                    case 0x380904:
                        _pmTableSize = 0x5A4;
                        break;
                    case 0x380905:
                        _pmTableSize = 0x5D0;
                        break;
                    case 0x2D0803:
                        _pmTableSize = 0x894;
                        break;
                    case 0x380804:
                        _pmTableSize = 0x8A4;
                        break;
                    case 0x380805:
                        _pmTableSize = 0x8F0;
                        break;
                    default:
                        return;
                }

                break;

            case CpuCodeName.Renoir:
                switch (_pmTableVersion)
                {
                    case 0x370000:
                        _pmTableSize = 0x794;
                        break;
                    case 0x370001:
                        _pmTableSize = 0x884;
                        break;
                    case 0x370002:
                    case 0x370003:
                        _pmTableSize = 0x88C;
                        break;
                    case 0x370004:
                        _pmTableSize = 0x8AC;
                        break;
                    case 0x370005:
                        _pmTableSize = 0x8C8;
                        break;
                    default:
                        return;
                }

                break;

            case CpuCodeName.Cezanne:
                switch (_pmTableVersion)
                {
                    case 0x400005:
                        _pmTableSize = 0x944;
                        break;

                    default:
                        return;
                }

                break;

            case CpuCodeName.Picasso:
            case CpuCodeName.RavenRidge:
            case CpuCodeName.RavenRidge2:
                _pmTableSizeAlt = 0xA4;
                _pmTableSize = 0x608 + _pmTableSizeAlt;
                break;

            case CpuCodeName.Raphael:
                switch (_pmTableVersion)
                {
                    case 0x00540004:
                        _pmTableSize = 0x948;
                        break;

                    default:
                        return;
                }

                break;

            default:
                return;
        }
    }

    private bool GetPmTableVersion(ref uint version)
    {
        uint[] args = { 0 };
        uint fn;

        switch (_cpuCodeName)
        {
            case CpuCodeName.RavenRidge:
            case CpuCodeName.Picasso:
                fn = 0x0c;
                break;
            case CpuCodeName.Matisse:
            case CpuCodeName.Vermeer:
                fn = 0x08;
                break;
            case CpuCodeName.Renoir:
                fn = 0x06;
                break;
            case CpuCodeName.Raphael:
                fn = 0x05;
                break;
            default:
                return false;
        }

        bool ret = SendCommand(fn, ref args);
        version = args[0];

        return ret;
    }

    private void SetupAddrClass1(uint[] fn)
    {
        uint[] args = { 1, 1 };

        bool command = SendCommand(fn[0], ref args);
        if (!command)
            return;

        _dramBaseAddr = args[0];
        _dramAddrHi = args[1];
    }

    private void SetupAddrClass2(uint[] fn)
    {
        uint[] args = { 0, 0, 0, 0, 0, 0 };

        bool command = SendCommand(fn[0], ref args);
        if (!command)
            return;

        args = new uint[] { 0 };
        command = SendCommand(fn[1], ref args);
        if (!command)
            return;

        _dramBaseAddr = args[0];
    }

    private void SetupAddrClass3(uint[] fn)
    {
        uint[] parts = { 0, 0 };

        // == Part 1 ==
        uint[] args = { 3 };
        bool command = SendCommand(fn[0], ref args);
        if (!command)
            return;

        args = new uint[] { 3 };
        command = SendCommand(fn[2], ref args);
        if (!command)
            return;

        // 1st Base.
        parts[0] = args[0];
        // == Part 1 End ==

        // == Part 2 ==
        args = new uint[] { 3 };
        command = SendCommand(fn[1], ref args);
        if (!command)
            return;

        args = new uint[] { 5 };
        command = SendCommand(fn[0], ref args);
        if (!command)
            return;

        args = new uint[] { 5 };
        command = SendCommand(fn[2], ref args);
        if (!command)
            return;

        // 2nd base.
        parts[1] = args[0];
        // == Part 2 End ==

        _dramBaseAddr = parts[0] & 0xFFFFFFFF;
    }

    private void SetupDramBaseAddr()
    {
        uint[] fn = { 0, 0, 0 };

        switch (_cpuCodeName)
        {
            case CpuCodeName.Raphael:
                fn[0] = 0x04;
                SetupAddrClass1(fn);
                return;
            case CpuCodeName.Vermeer:
            case CpuCodeName.Matisse:
            case CpuCodeName.CastlePeak:
                fn[0] = 0x06;
                SetupAddrClass1(fn);
                return;
            case CpuCodeName.Renoir:
                fn[0] = 0x66;
                SetupAddrClass1(fn);
                return;
            case CpuCodeName.Colfax:
            case CpuCodeName.PinnacleRidge:
                fn[0] = 0x0b;
                fn[1] = 0x0c;
                SetupAddrClass2(fn);
                return;
            case CpuCodeName.Dali:
            case CpuCodeName.Picasso:
            case CpuCodeName.RavenRidge:
            case CpuCodeName.RavenRidge2:
                fn[0] = 0x0a;
                fn[1] = 0x3d;
                fn[2] = 0x0b;
                SetupAddrClass3(fn);
                return;
            default:
                return;
        }
    }

    public bool TransferTableToDram()
    {
        uint[] args = { 0 };
        uint fn;

        switch (_cpuCodeName)
        {
            case CpuCodeName.Raphael:
                fn = 0x03;
                break;
            case CpuCodeName.Matisse:
            case CpuCodeName.Vermeer:
                fn = 0x05;
                break;
            case CpuCodeName.Renoir:
                args[0] = 3;
                fn = 0x65;
                break;
            case CpuCodeName.Picasso:
            case CpuCodeName.RavenRidge:
            case CpuCodeName.RavenRidge2:
                args[0] = 3;
                fn = 0x3d;
                break;
            default:
                return false;
        }

        return SendCommand(fn, ref args);
    }

    private bool SendCommand(uint msg, ref uint[] args)
    {
        uint[] cmdArgs = new uint[SMU_REQ_MAX_ARGS];
        int argsLength = Math.Min(args.Length, cmdArgs.Length);

        for (int i = 0; i < argsLength; ++i)
            cmdArgs[i] = args[i];

        uint tmp = 0;
        if (_mutex.WaitOne(5000))
        {
            // Step 1: Wait until the RSP register is non-zero.

            tmp = 0;
            uint retries = SMU_RETRIES_MAX;
            do
            {
                if (!ReadReg(_rspAddr, ref tmp))
                {
                    _mutex.ReleaseMutex();
                    return false;
                }
            }
            while (tmp == 0 && 0 != retries--);

            // Step 1.b: A command is still being processed meaning a new command cannot be issued.

            if (retries == 0 && tmp == 0)
            {
                _mutex.ReleaseMutex();
                return false;
            }

            // Step 2: Write zero (0) to the RSP register
            WriteReg(_rspAddr, 0);

            // Step 3: Write the argument(s) into the argument register(s)
            for (int i = 0; i < cmdArgs.Length; ++i)
                WriteReg(_argsAddr + (uint)(i * 4), cmdArgs[i]);

            // Step 4: Write the message Id into the Message ID register
            WriteReg(_cmdAddr, msg);

            // Step 5: Wait until the Response register is non-zero.
            tmp = 0;
            retries = SMU_RETRIES_MAX;
            do
            {
                if (!ReadReg(_rspAddr, ref tmp))
                {
                    _mutex.ReleaseMutex();
                    return false;
                }
            }
            while (tmp == 0 && retries-- != 0);

            if (retries == 0 && tmp != (uint)Status.OK)
            {
                _mutex.ReleaseMutex();
                return false;
            }

            // Step 6: If the Response register contains OK, then SMU has finished processing  the message.

            args = new uint[SMU_REQ_MAX_ARGS];
            for (byte i = 0; i < SMU_REQ_MAX_ARGS; i++)
            {
                if (!ReadReg(_argsAddr + (uint)(i * 4), ref args[i]))
                {
                    _mutex.ReleaseMutex();
                    return false;
                }
            }

            ReadReg(_rspAddr, ref tmp);
            _mutex.ReleaseMutex();
        }

        return tmp == (uint)Status.OK;
    }

    private static void WriteReg(uint addr, uint data)
    {
        if (Ring0.WaitPciBusMutex(10))
        {
            if (Ring0.WritePciConfig(0x00, SMU_PCI_ADDR_REG, addr))
            {
                Ring0.WritePciConfig(0x00, SMU_PCI_DATA_REG, data);
            }

            Ring0.ReleasePciBusMutex();
        }
    }

    private static bool ReadReg(uint addr, ref uint data)
    {
        bool read = false;

        if (Ring0.WaitPciBusMutex(10))
        {
            if (Ring0.WritePciConfig(0x00, SMU_PCI_ADDR_REG, addr))
            {
                read = Ring0.ReadPciConfig(0x00, SMU_PCI_DATA_REG, out data);
            }

            Ring0.ReleasePciBusMutex();
        }

        return read;
    }

    public struct SmuSensorType
    {
        public string Name;
        public SensorType Type;
        public float Scale;
    }

    private enum Status : uint
    {
        OK = 0x01,
        CmdRejectedBusy = 0xFC,
        CmdRejectedPrereq = 0xFD,
        UnknownCmd = 0xFE,
        Failed = 0xFF
    }

    private enum CpuCodeName
    {
        Undefined,
        Colfax,
        Renoir,
        Picasso,
        Matisse,
        Threadripper,
        CastlePeak,
        RavenRidge,
        RavenRidge2,
        SummitRidge,
        PinnacleRidge,
        Rembrandt,
        Vermeer,
        Vangogh,
        Cezanne,
        Milan,
        Dali,
        Raphael
    }
}

```

`LibreHardwareMonitorLib/Hardware/SMBios.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using LibreHardwareMonitor.Interop;

// ReSharper disable CommentTypo
// ReSharper disable IdentifierTypo
// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// System enclosure security status based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.4.3</see>.
/// </summary>
public enum SystemEnclosureSecurityStatus
{
    Other = 1,
    Unknown,
    None,
    ExternalInterfaceLockedOut,
    ExternalInterfaceEnabled
}

/// <summary>
/// System enclosure state based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.4.2</see>.
/// </summary>
public enum SystemEnclosureState
{
    Other = 1,
    Unknown,
    Safe,
    Warning,
    Critical,
    NonRecoverable
}

/// <summary>
/// System enclosure type based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.4.1</see>.
/// </summary>
public enum SystemEnclosureType
{
    Other = 1,
    Unknown,
    Desktop,
    LowProfileDesktop,
    PizzaBox,
    MiniTower,
    Tower,
    Portable,
    Laptop,
    Notebook,
    HandHeld,
    DockingStation,
    AllInOne,
    SubNotebook,
    SpaceSaving,
    LunchBox,
    MainServerChassis,
    ExpansionChassis,
    SubChassis,
    BusExpansionChassis,
    PeripheralChassis,
    RaidChassis,
    RackMountChassis,
    SealedCasePc,
    MultiSystemChassis,
    CompactPci,
    AdvancedTca,
    Blade,
    BladeEnclosure,
    Tablet,
    Convertible,
    Detachable,
    IoTGateway,
    EmbeddedPc,
    MiniPc,
    StickPc
}

/// <summary>
/// Processor family based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.5.2</see>.
/// </summary>
public enum ProcessorFamily
{
    Other = 1,
    Intel8086 = 3,
    Intel80286 = 4,
    Intel386,
    Intel486,
    Intel8087,
    Intel80287,
    Intel80387,
    Intel80487,
    IntelPentium,
    IntelPentiumPro,
    IntelPentiumII,
    IntelPentiumMMX,
    IntelCeleron,
    IntelPentiumIIXeon,
    IntelPentiumIII,
    M1,
    M2,
    IntelCeleronM,
    IntelPentium4HT,
    AmdDuron = 24,
    AmdK5,
    AmdK6,
    AmdK62,
    AmdK63,
    AmdAthlon,
    Amd2900,
    AmdK62Plus,
    PowerPc,
    PowerPc601,
    PowerPc603,
    PowerPc603Plus,
    PowerPc604,
    PowerPc620,
    PowerPcx704,
    PowerPc750,
    IntelCoreDuo,
    IntelCoreDuoMobile,
    IntelCoreSoloMobile,
    IntelAtom,
    IntelCoreM,
    IntelCoreM3,
    IntelCoreM5,
    IntelCoreM7,
    Alpha,
    Alpha21064,
    Alpha21066,
    Alpha21164,
    Alpha21164Pc,
    Alpha21164a,
    Alpha21264,
    Alpha21364,
    AmdTurionIIUltraDualCoreMobileM,
    AmdTurionDualCoreMobileM,
    AmdAthlonIIDualCoreM,
    AmdOpteron6100Series,
    AmdOpteron4100Series,
    AmdOpteron6200Series,
    AmdOpteron4200Series,
    AmdFxSeries,
    Mips,
    MipsR4000,
    MipsR4200,
    MipsR4400,
    MipsR4600,
    MipsR10000,
    AmdCSeries,
    AmdESeries,
    AmdASeries,
    AmdGSeries,
    AmdZSeries,
    AmdRSeries,
    AmdOpteron4300Series,
    AmdOpteron6300Series,
    AmdOpteron3300Series,
    AmdFireProSeries,
    Sparc,
    SuperSparc,
    MicroSparcII,
    MicroSparcIIep,
    UltraSparc,
    UltraSparcII,
    UltraSparcIIi,
    UltraSparcIII,
    UltraSparcIIIi,
    Motorola68040 = 96,
    Motorola68xxx,
    Motorola68000,
    Motorola68010,
    Motorola68020,
    Motorola68030,
    AmdAthlonX4QuadCore,
    AmdOpteronX1000Series,
    AmdOpteronX2000Series,
    AmdOpteronASeries,
    AmdOpteronX3000Series,
    AmdZen,
    Hobbit = 112,
    CrusoeTm5000 = 120,
    CrusoeTm3000,
    EfficeonTm8000,
    Weitek = 128,
    IntelItanium = 130,
    AmdAthlon64,
    AmdOpteron,
    AmdSempron,
    AmdTurio64Mobile,
    AmdOpteronDualCore,
    AmdAthlon64X2DualCore,
    AmdTurion64X2Mobile,
    AmdOpteronQuadCore,
    AmdOpteronThirdGen,
    AmdPhenomFXQuadCore,
    AmdPhenomX4QuadCore,
    AmdPhenomX2DualCore,
    AmdAthlonX2DualCore,
    PaRisc,
    PaRisc8500,
    PaRisc8000,
    PaRisc7300LC,
    PaRisc7200,
    PaRisc7100LC,
    PaRisc7100,
    V30 = 160,
    IntelXeon3200QuadCoreSeries,
    IntelXeon3000DualCoreSeries,
    IntelXeon5300QuadCoreSeries,
    IntelXeon5100DualCoreSeries,
    IntelXeon5000DualCoreSeries,
    IntelXeonLVDualCore,
    IntelXeonULVDualCore,
    IntelXeon7100Series,
    IntelXeon5400Series,
    IntelXeonQuadCore,
    IntelXeon5200DualCoreSeries,
    IntelXeon7200DualCoreSeries,
    IntelXeon7300QuadCoreSeries,
    IntelXeon7400QuadCoreSeries,
    IntelXeon7400MultiCoreSeries,
    IntelPentiumIIIXeon,
    IntelPentiumIIISpeedStep,
    IntelPentium4,
    IntelXeon,
    As400,
    IntelXeonMP,
    AmdAthlonXP,
    AmdAthlonMP,
    IntelItanium2,
    IntelPentiumM,
    IntelCeleronD,
    IntelPentiumD,
    IntelPentiumExtreme,
    IntelCoreSolo,
    IntelCore2Duo = 191,
    IntelCore2Solo,
    IntelCore2Extreme,
    IntelCore2Quad,
    IntelCore2ExtremeMobile,
    IntelCore2DuoMobile,
    IntelCore2SoloMobile,
    IntelCoreI7,
    IntelCeleronDualCore,
    Ibm390,
    PowerPcG4,
    PowerPcG5,
    Esa390G6,
    ZArchitecture,
    IntelCoreI5,
    IntelCoreI3,
    IntelCoreI9,
    ViaC7M = 210,
    ViaC7D,
    ViaC7,
    ViaEden,
    IntelXeonMultiCore,
    IntelXeon3xxxDualCoreSeries,
    IntelXeon3xxxQuadCoreSeries,
    ViaNano,
    IntelXeon5xxxDualCoreSeries,
    IntelXeon5xxxQuadCoreSeries,
    IntelXeon7xxxDualCoreSeries = 221,
    IntelXeon7xxxQuadCoreSeries,
    IntelXeon7xxxMultiCoreSeries,
    IntelXeon3400MultiCoreSeries,
    AmdOpteron3000Series = 228,
    AmdSempronII,
    AmdOpteronQuadCoreEmbedded,
    AmdPhenomTripleCore,
    AmdTurionUltraDualCoreMobile,
    AmdTurionDualCoreMobile,
    AmdTurionDualCore,
    AmdAthlonDualCore,
    AmdSempronSI,
    AmdPhenomII,
    AmdAthlonII,
    AmdOpteronSixCore,
    AmdSempronM,
    IntelI860 = 250,
    IntelI960,
    ArmV7 = 256,
    ArmV8,
    HitachiSh3,
    HitachiSh4,
    Arm,
    StrongArm,
    _686,
    MediaGX,
    MII,
    WinChip,
    Dsp,
    VideoProcessor
}

/// <summary>
/// Processor characteristics based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.5.9</see>.
/// </summary>
[Flags]
public enum ProcessorCharacteristics
{
    None = 0,
    _64BitCapable = 1,
    MultiCore = 2,
    HardwareThread = 4,
    ExecuteProtection = 8,
    EnhancedVirtualization = 16,
    PowerPerformanceControl = 32,
    _128BitCapable = 64
}

/// <summary>
/// Processor type based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.5.1</see>.
/// </summary>
public enum ProcessorType
{
    Other = 1,
    Unknown,
    CentralProcessor,
    MathProcessor,
    DspProcessor,
    VideoProcessor
}

/// <summary>
/// Processor socket based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.5.5</see>.
/// </summary>
public enum ProcessorSocket
{
    Other = 1,
    Unknown,
    DaughterBoard,
    ZifSocket,
    PiggyBack,
    None,
    LifSocket,
    Zif423 = 13,
    A,
    Zif478,
    Zif754,
    Zif940,
    Zif939,
    MPga604,
    Lga771,
    Lga775,
    S1,
    AM2,
    F,
    Lga1366,
    G34,
    AM3,
    C32,
    Lga1156,
    Lga1567,
    Pga988A,
    Bga1288,
    RPga088B,
    Bga1023,
    Bga1224,
    Lga1155,
    Lga1356,
    Lga2011,
    FS1,
    FS2,
    FM1,
    FM2,
    Lga20113,
    Lga13563,
    Lga1150,
    Bga1168,
    Bga1234,
    Bga1364,
    AM4,
    Lga1151,
    Bga1356,
    Bga1440,
    Bga1515,
    Lga36471,
    SP3,
    SP3R2,
    Lga2066,
    Bga1510,
    Bga1528,
    Lga4189
}

/// <summary>
/// System wake-up type based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.2.2</see>.
/// </summary>
public enum SystemWakeUp
{
    Reserved,
    Other,
    Unknown,
    ApmTimer,
    ModemRing,
    LanRemote,
    PowerSwitch,
    PciPme,
    AcPowerRestored
}

/// <summary>
/// Cache associativity based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.8.5</see>.
/// </summary>
public enum CacheAssociativity
{
    Other = 1,
    Unknown,
    DirectMapped,
    _2Way,
    _4Way,
    FullyAssociative,
    _8Way,
    _16Way,
    _12Way,
    _24Way,
    _32Way,
    _48Way,
    _64Way,
    _20Way
}

/// <summary>
/// Processor cache level.
/// </summary>
public enum CacheDesignation
{
    Other,
    L1,
    L2,
    L3
}

/// <summary>
/// Memory type.
/// </summary>
public enum MemoryType
{
    Other = 0x01,
    Unknown = 0x02,
    DRAM = 0x03,
    EDRAM = 0x04,
    VRAM = 0x05,
    SRAM = 0x06,
    RAM = 0x07,
    ROM = 0x08,
    FLASH = 0x09,
    EEPROM = 0x0a,
    FEPROM = 0x0b,
    EPROM = 0x0c,
    CDRAM = 0x0d,
    _3DRAM = 0x0e,
    SDRAM = 0x0f,
    SGRAM = 0x10,
    RDRAM = 0x11,
    DDR = 0x12,
    DDR2 = 0x13,
    DDR2_FBDIMM = 0x14,
    DDR3 = 0x18,
    FBD2 = 0x19,
    DDR4 = 0x1a,
    LPDDR = 0x1b,
    LPDDR2 = 0x1c,
    LPDDR3 = 0x1d,
    LPDDR4 = 0x1e,
    LogicalNonVolatileDevice = 0x1f,
    HBM = 0x20,
    HBM2 = 0x21,
    DDR5 = 0x22,
    LPDDR5 = 0x23
}

public class InformationBase
{
    private readonly byte[] _data;
    private readonly IList<string> _strings;

    /// <summary>
    /// Initializes a new instance of the <see cref="InformationBase" /> class.
    /// </summary>
    /// <param name="data">The data.</param>
    /// <param name="strings">The strings.</param>
    protected InformationBase(byte[] data, IList<string> strings)
    {
        _data = data;
        _strings = strings;
    }

    /// <summary>
    /// Gets the byte.
    /// </summary>
    /// <param name="offset">The offset.</param>
    /// <returns><see cref="byte" />.</returns>
    protected byte GetByte(int offset)
    {
        if (offset < _data.Length && offset >= 0)
            return _data[offset];

        return 0;
    }

    /// <summary>
    /// Gets the word.
    /// </summary>
    /// <param name="offset">The offset.</param>
    /// <returns><see cref="ushort" />.</returns>
    protected ushort GetWord(int offset)
    {
        if (offset + 1 < _data.Length && offset >= 0)
        {
            return BitConverter.ToUInt16(_data, offset);
        }

        return 0;
    }

    /// <summary>
    /// Gets the dword.
    /// </summary>
    /// <param name="offset">The offset.</param>
    /// <returns><see cref="ushort" />.</returns>
    protected uint GetDword(int offset)
    {
        if (offset + 3 < _data.Length && offset >= 0)
        {
            return BitConverter.ToUInt32(_data, offset);
        }

        return 0;
    }

    /// <summary>
    /// Gets the qword.
    /// </summary>
    /// <param name="offset">The offset.</param>
    /// <returns><see cref="ulong" />.</returns>
    protected ulong GetQword(int offset)
    {
        if (offset + 7 < _data.Length && offset >= 0)
        {
            return BitConverter.ToUInt64(_data, offset);
        }

        return 0;
    }

    /// <summary>
    /// Gets the string.
    /// </summary>
    /// <param name="offset">The offset.</param>
    /// <returns><see cref="string" />.</returns>
    protected string GetString(int offset)
    {
        if (offset < _data.Length && _data[offset] > 0 && _data[offset] <= _strings.Count)
            return _strings[_data[offset] - 1];

        return string.Empty;
    }
}

/// <summary>
/// Motherboard BIOS information obtained from the SMBIOS table.
/// </summary>
public class BiosInformation : InformationBase
{
    internal BiosInformation(string vendor, string version, string date = null, ulong? size = null) : base(null, null)
    {
        Vendor = vendor;
        Version = version;
        Date = GetDate(date);
        Size = size;
    }

    internal BiosInformation(byte[] data, IList<string> strings) : base(data, strings)
    {
        Vendor = GetString(0x04);
        Version = GetString(0x05);
        Date = GetDate(GetString(0x08));
        Size = GetSize();
    }

    /// <summary>
    /// Gets the BIOS release date.
    /// </summary>
    public DateTime? Date { get; }

    /// <summary>
    /// Gets the size of the physical device containing the BIOS.
    /// </summary>
    public ulong? Size { get; }

    /// <summary>
    /// Gets the string number of the BIOS Vendor’s Name.
    /// </summary>
    public string Vendor { get; }

    /// <summary>
    /// Gets the string number of the BIOS Version. This value is a free-form string that may contain Core and OEM version information.
    /// </summary>
    public string Version { get; }

    /// <summary>
    /// Gets the size.
    /// </summary>
    /// <returns><see cref="Nullable{Int64}" />.</returns>
    private ulong? GetSize()
    {
        int biosRomSize = GetByte(0x09);
        ushort extendedBiosRomSize = GetWord(0x18);

        bool isExtendedBiosRomSize = biosRomSize == 0xFF && extendedBiosRomSize != 0;
        if (!isExtendedBiosRomSize)
            return 65536 * (ulong)(biosRomSize + 1);

        int unit = (extendedBiosRomSize & 0xC000) >> 14;
        ulong extendedSize = (ulong)(extendedBiosRomSize & ~0xC000) * 1024 * 1024;

        switch (unit)
        {
            case 0x00: return extendedSize; // Megabytes
            case 0x01: return extendedSize * 1024; // Gigabytes - might overflow in the future
        }

        return null; // Other patterns not defined in DMI 3.2.0
    }

    /// <summary>
    /// Gets the date.
    /// </summary>
    /// <param name="date">The bios date.</param>
    /// <returns><see cref="Nullable{DateTime}" />.</returns>
    private static DateTime? GetDate(string date)
    {
        string[] parts = (date ?? string.Empty).Split('/');

        if (parts.Length == 3 &&
            int.TryParse(parts[0], out int month) &&
            int.TryParse(parts[1], out int day) &&
            int.TryParse(parts[2], out int year))
        {
            if (day > 31)
            {
                (year, day) = (day, year);
            }

            if (month > 12)
            {
                (month, day) = (day, month);
            }

            return new DateTime(year < 100 ? 1900 + year : year, month, day);
        }

        return null;
    }
}

/// <summary>
/// System information obtained from the SMBIOS table.
/// </summary>
public class SystemInformation : InformationBase
{
    internal SystemInformation
    (
        string manufacturerName,
        string productName,
        string version,
        string serialNumber,
        string family,
        SystemWakeUp wakeUp = SystemWakeUp.Unknown) : base(null, null)
    {
        ManufacturerName = manufacturerName;
        ProductName = productName;
        Version = version;
        SerialNumber = serialNumber;
        Family = family;
        WakeUp = wakeUp;
    }

    internal SystemInformation(byte[] data, IList<string> strings) : base(data, strings)
    {
        ManufacturerName = GetString(0x04);
        ProductName = GetString(0x05);
        Version = GetString(0x06);
        SerialNumber = GetString(0x07);
        Family = GetString(0x1A);
        WakeUp = (SystemWakeUp)GetByte(0x18);
    }

    /// <summary>
    /// Gets the family associated with system.
    /// <para>
    /// This text string identifies the family to which a particular computer belongs. A family refers to a set of computers that are similar but not identical from a hardware or software point of
    /// view. Typically, a family is composed of different computer models, which have different configurations and pricing points. Computers in the same family often have similar branding and cosmetic
    /// features.
    /// </para>
    /// </summary>
    public string Family { get; }

    /// <summary>
    /// Gets the manufacturer name associated with system.
    /// </summary>
    public string ManufacturerName { get; }

    /// <summary>
    /// Gets the product name associated with system.
    /// </summary>
    public string ProductName { get; }

    /// <summary>
    /// Gets the serial number string associated with system.
    /// </summary>
    public string SerialNumber { get; }

    /// <summary>
    /// Gets the version string associated with system.
    /// </summary>
    public string Version { get; }

    /// <summary>
    /// Gets <inheritdoc cref="SystemWakeUp" />
    /// </summary>
    public SystemWakeUp WakeUp { get; }
}

/// <summary>
/// System enclosure obtained from the SMBIOS table.
/// </summary>
public class SystemEnclosure : InformationBase
{
    internal SystemEnclosure(byte[] data, IList<string> strings) : base(data, strings)
    {
        ManufacturerName = GetString(0x04).Trim();
        Version = GetString(0x06).Trim();
        SerialNumber = GetString(0x07).Trim();
        AssetTag = GetString(0x08).Trim();
        RackHeight = GetByte(0x11);
        PowerCords = GetByte(0x12);
        SKU = GetString(0x15).Trim();
        LockDetected = (GetByte(0x05) & 128) == 128;
        Type = (SystemEnclosureType)(GetByte(0x05) & 127);
        BootUpState = (SystemEnclosureState)GetByte(0x09);
        PowerSupplyState = (SystemEnclosureState)GetByte(0x0A);
        ThermalState = (SystemEnclosureState)GetByte(0x0B);
        SecurityStatus = (SystemEnclosureSecurityStatus)GetByte(0x0C);
    }

    /// <summary>
    /// Gets the asset tag associated with the enclosure or chassis.
    /// </summary>
    public string AssetTag { get; }

    /// <summary>
    /// Gets <inheritdoc cref="SystemEnclosureState" />
    /// </summary>
    public SystemEnclosureState BootUpState { get; }

    /// <summary>
    /// Gets or sets the system enclosure lock.
    /// </summary>
    /// <returns>System enclosure lock is present if <see langword="true" />. Otherwise, either a lock is not present or it is unknown if the enclosure has a lock.</returns>
    public bool LockDetected { get; set; }

    /// <summary>
    /// Gets the string describing the chassis or enclosure manufacturer name.
    /// </summary>
    public string ManufacturerName { get; }

    /// <summary>
    /// Gets the number of power cords associated with the enclosure or chassis.
    /// </summary>
    public byte PowerCords { get; }

    /// <summary>
    /// Gets the state of the enclosure’s power supply (or supplies) when last booted.
    /// </summary>
    public SystemEnclosureState PowerSupplyState { get; }

    /// <summary>
    /// Gets the height of the enclosure, in 'U's. A U is a standard unit of measure for the height of a rack or rack-mountable component and is equal to 1.75 inches or 4.445 cm. A value of <c>0</c>
    /// indicates that the enclosure height is unspecified.
    /// </summary>
    public byte RackHeight { get; }

    /// <summary>
    /// Gets the physical security status of the enclosure when last booted.
    /// </summary>
    public SystemEnclosureSecurityStatus SecurityStatus { get; set; }

    /// <summary>
    /// Gets the string describing the chassis or enclosure serial number.
    /// </summary>
    public string SerialNumber { get; }

    /// <summary>
    /// Gets the string describing the chassis or enclosure SKU number.
    /// </summary>
    public string SKU { get; }

    /// <summary>
    /// Gets the thermal state of the enclosure when last booted.
    /// </summary>
    public SystemEnclosureState ThermalState { get; }

    /// <summary>
    /// Gets <inheritdoc cref="Type" />
    /// </summary>
    public SystemEnclosureType Type { get; }

    /// <summary>
    /// Gets the number of null-terminated string representing the chassis or enclosure version.
    /// </summary>
    public string Version { get; }
}

/// <summary>
/// Motherboard information obtained from the SMBIOS table.
/// </summary>
public class BaseBoardInformation : InformationBase
{
    internal BaseBoardInformation(string manufacturerName, string productName, string version, string serialNumber) : base(null, null)
    {
        ManufacturerName = manufacturerName;
        ProductName = productName;
        Version = version;
        SerialNumber = serialNumber;
    }

    internal BaseBoardInformation(byte[] data, IList<string> strings) : base(data, strings)
    {
        ManufacturerName = GetString(0x04).Trim();
        ProductName = GetString(0x05).Trim();
        Version = GetString(0x06).Trim();
        SerialNumber = GetString(0x07).Trim();
    }

    /// <summary>
    /// Gets the value that represents the manufacturer's name.
    /// </summary>
    public string ManufacturerName { get; }

    /// <summary>
    /// Gets the value that represents the motherboard's name.
    /// </summary>
    public string ProductName { get; }

    /// <summary>
    /// Gets the value that represents the motherboard's serial number.
    /// </summary>
    public string SerialNumber { get; }

    /// <summary>
    /// Gets the value that represents the motherboard's revision number.
    /// </summary>
    public string Version { get; }
}

/// <summary>
/// Processor information obtained from the SMBIOS table.
/// </summary>
public class ProcessorInformation : InformationBase
{
    internal ProcessorInformation(byte[] data, IList<string> strings) : base(data, strings)
    {
        SocketDesignation = GetString(0x04).Trim();
        ManufacturerName = GetString(0x07).Trim();
        Version = GetString(0x10).Trim();
        CoreCount = GetByte(0x23) != 255 ? GetByte(0x23) : GetWord(0x2A);
        CoreEnabled = GetByte(0x24) != 255 ? GetByte(0x24) : GetWord(0x2C);
        ThreadCount = GetByte(0x25) != 255 ? GetByte(0x25) : GetWord(0x2E);
        ExternalClock = GetWord(0x12);
        MaxSpeed = GetWord(0x14);
        CurrentSpeed = GetWord(0x16);
        Serial = GetString(0x20).Trim();
        Id = GetQword(0x08);
        Handle = GetWord(0x02);

        byte characteristics1 = GetByte(0x26);
        byte characteristics2 = GetByte(0x27);

        Characteristics = ProcessorCharacteristics.None;
        if (IsBitSet(characteristics1, 2))
            Characteristics |= ProcessorCharacteristics._64BitCapable;

        if (IsBitSet(characteristics1, 3))
            Characteristics |= ProcessorCharacteristics.MultiCore;

        if (IsBitSet(characteristics1, 4))
            Characteristics |= ProcessorCharacteristics.HardwareThread;

        if (IsBitSet(characteristics1, 5))
            Characteristics |= ProcessorCharacteristics.ExecuteProtection;

        if (IsBitSet(characteristics1, 6))
            Characteristics |= ProcessorCharacteristics.EnhancedVirtualization;

        if (IsBitSet(characteristics1, 7))
            Characteristics |= ProcessorCharacteristics.PowerPerformanceControl;

        if (IsBitSet(characteristics2, 0))
            Characteristics |= ProcessorCharacteristics._128BitCapable;

        ProcessorType = (ProcessorType)GetByte(0x05);
        Socket = (ProcessorSocket)GetByte(0x19);

        int family = GetByte(0x06);
        Family = (ProcessorFamily)(family == 254 ? GetWord(0x28) : family);

        L1CacheHandle = GetWord(0x1A);
        L2CacheHandle = GetWord(0x1C);
        L3CacheHandle = GetWord(0x1E);

        bool IsBitSet(byte b, int pos)
        {
            return (b & (1 << pos)) != 0;
        }
    }

    /// <summary>
    /// Gets the characteristics of the processor.
    /// </summary>
    public ProcessorCharacteristics Characteristics { get; }

    /// <summary>
    /// Gets the value that represents the number of cores per processor socket.
    /// </summary>
    public ushort CoreCount { get; }

    /// <summary>
    /// Gets the value that represents the number of enabled cores per processor socket.
    /// </summary>
    public ushort CoreEnabled { get; }

    /// <summary>
    /// Gets the value that represents the current processor speed (in MHz).
    /// </summary>
    public ushort CurrentSpeed { get; }

    /// <summary>
    /// Gets the external Clock Frequency, in MHz. If the value is unknown, the field is set to 0.
    /// </summary>
    public ushort ExternalClock { get; }

    /// <summary>
    /// Gets <inheritdoc cref="ProcessorFamily" />
    /// </summary>
    public ProcessorFamily Family { get; }

    /// <summary>
    /// Gets the handle.
    /// </summary>
    /// <value>The handle.</value>
    public ushort Handle { get; }

    /// <summary>
    /// Gets the identifier.
    /// </summary>
    public ulong Id { get; }

    /// <summary>
    /// Gets the L1 cache handle.
    /// </summary>
    public ushort L1CacheHandle { get; }

    /// <summary>
    /// Gets the L2 cache handle.
    /// </summary>
    public ushort L2CacheHandle { get; }

    /// <summary>
    /// Gets the L3 cache handle.
    /// </summary>
    public ushort L3CacheHandle { get; }

    /// <summary>
    /// Gets the string number of Processor Manufacturer.
    /// </summary>
    public string ManufacturerName { get; }

    /// <summary>
    /// Gets the value that represents the maximum processor speed (in MHz) supported by the system for this processor socket.
    /// </summary>
    public ushort MaxSpeed { get; }

    /// <summary>
    /// Gets <inheritdoc cref="LibreHardwareMonitor.Hardware.ProcessorType" />
    /// </summary>
    public ProcessorType ProcessorType { get; }

    /// <summary>
    /// Gets the value that represents the string number for the serial number of this processor.
    /// <para>This value is set by the manufacturer and normally not changeable.</para>
    /// </summary>
    public string Serial { get; }

    /// <summary>
    /// Gets <inheritdoc cref="ProcessorSocket" />
    /// </summary>
    public ProcessorSocket Socket { get; }

    /// <summary>
    /// Gets the string number for Reference Designation.
    /// </summary>
    public string SocketDesignation { get; }

    /// <summary>
    /// Gets the value that represents the number of threads per processor socket.
    /// </summary>
    public ushort ThreadCount { get; }

    /// <summary>
    /// Gets the value that represents the string number describing the Processor.
    /// </summary>
    public string Version { get; }
}

/// <summary>
/// Cache information obtained from the SMBIOS table.
/// </summary>
public class CacheInformation : InformationBase
{
    internal CacheInformation(byte[] data, IList<string> strings) : base(data, strings)
    {
        Handle = GetWord(0x02);
        Designation = GetCacheDesignation();
        Associativity = (CacheAssociativity)GetByte(0x12);
        Size = GetWord(0x09);
    }

    /// <summary>
    /// Gets <inheritdoc cref="CacheAssociativity" />
    /// </summary>
    public CacheAssociativity Associativity { get; }

    /// <summary>
    /// Gets <inheritdoc cref="CacheDesignation" />
    /// </summary>
    public CacheDesignation Designation { get; }

    /// <summary>
    /// Gets the handle.
    /// </summary>
    public ushort Handle { get; }

    /// <summary>
    /// Gets the value that represents the installed cache size.
    /// </summary>
    public ushort Size { get; }

    /// <summary>
    /// Gets the cache designation.
    /// </summary>
    /// <returns><see cref="CacheDesignation" />.</returns>
    private CacheDesignation GetCacheDesignation()
    {
        string rawCacheType = GetString(0x04);

        if (rawCacheType.Contains("L1"))
            return CacheDesignation.L1;

        if (rawCacheType.Contains("L2"))
            return CacheDesignation.L2;

        if (rawCacheType.Contains("L3"))
            return CacheDesignation.L3;

        return CacheDesignation.Other;
    }
}

/// <summary>
/// Memory information obtained from the SMBIOS table.
/// </summary>
public class MemoryDevice : InformationBase
{
    internal MemoryDevice(byte[] data, IList<string> strings) : base(data, strings)
    {
        DeviceLocator = GetString(0x10).Trim();
        BankLocator = GetString(0x11).Trim();
        ManufacturerName = GetString(0x17).Trim();
        SerialNumber = GetString(0x18).Trim();
        PartNumber = GetString(0x1A).Trim();
        Speed = GetWord(0x15);
        ConfiguredSpeed = GetWord(0x20);
        ConfiguredVoltage = GetWord(0x26);
        Size = GetWord(0x0C);
        Type = (MemoryType)GetByte(0x12);

        if (GetWord(0x1C) > 0)
            Size += GetWord(0x1C);
    }

    /// <summary>
    /// Gets the string number of the string that identifies the physically labeled bank where the memory device is located.
    /// </summary>
    public string BankLocator { get; }

    /// <summary>
    /// Gets the string number of the string that identifies the physically-labeled socket or board position where the memory device is located.
    /// </summary>
    public string DeviceLocator { get; }

    /// <summary>
    /// Gets the string number for the manufacturer of this memory device.
    /// </summary>
    public string ManufacturerName { get; }

    /// <summary>
    /// Gets the string number for the part number of this memory device.
    /// </summary>
    public string PartNumber { get; }

    /// <summary>
    /// Gets the string number for the serial number of this memory device.
    /// </summary>
    public string SerialNumber { get; }

    /// <summary>
    /// Gets the size of the memory device. If the value is 0, no memory device is installed in the socket.
    /// </summary>
    public ushort Size { get; }

    /// <summary>
    /// Gets the value that identifies the maximum capable speed of the device, in mega transfers per second (MT/s).
    /// </summary>
    public ushort Speed { get; }

    /// <summary>
    /// Gets the configured speed of the device, in mega transfers per second (MT/s).
    /// </summary>
    public ushort ConfiguredSpeed { get; }

    /// <summary>
    /// Gets the configured voltage of this memory device, in millivolts (mV).
    /// </summary>
    public ushort ConfiguredVoltage { get; }

    /// <summary>
    /// Gets the type of this memory device.
    /// </summary>
    /// <value>The type.</value>
    public MemoryType Type { get; }
}

/// <summary>
/// Reads and processes information encoded in an SMBIOS table.
/// </summary>
public class SMBios
{
    private readonly byte[] _raw;
    private readonly Version _version;

    /// <summary>
    /// Initializes a new instance of the <see cref="SMBios" /> class.
    /// </summary>
    public SMBios()
    {
        if (Software.OperatingSystem.IsUnix)
        {
            _raw = null;

            string boardVendor = ReadSysFs("/sys/class/dmi/id/board_vendor");
            string boardName = ReadSysFs("/sys/class/dmi/id/board_name");
            string boardVersion = ReadSysFs("/sys/class/dmi/id/board_version");
            Board = new BaseBoardInformation(boardVendor, boardName, boardVersion, null);

            string systemVendor = ReadSysFs("/sys/class/dmi/id/sys_vendor");
            string productName = ReadSysFs("/sys/class/dmi/id/product_name");
            string productVersion = ReadSysFs("/sys/class/dmi/id/product_version");
            System = new SystemInformation(systemVendor, productName, productVersion, null, null);

            string biosVendor = ReadSysFs("/sys/class/dmi/id/bios_vendor");
            string biosVersion = ReadSysFs("/sys/class/dmi/id/bios_version");
            string biosDate = ReadSysFs("/sys/class/dmi/id/bios_date");
            Bios = new BiosInformation(biosVendor, biosVersion, biosDate);

            MemoryDevices = Array.Empty<MemoryDevice>();
        }
        else
        {
            List<MemoryDevice> memoryDeviceList = new();
            List<CacheInformation> processorCacheList = new();
            List<ProcessorInformation> processorInformationList = new();

            string[] tables = FirmwareTable.EnumerateTables(Kernel32.Provider.RSMB);
            if (tables is { Length: > 0 })
            {
                _raw = FirmwareTable.GetTable(Kernel32.Provider.RSMB, tables[0]);
                if (_raw == null || _raw.Length == 0)
                    return;

                byte majorVersion = _raw[1];
                byte minorVersion = _raw[2];

                if (majorVersion > 0 || minorVersion > 0)
                    _version = new Version(majorVersion, minorVersion);

                if (_raw is { Length: > 0 })
                {
                    int offset = 8;
                    byte type = _raw[offset];

                    while (offset + 4 < _raw.Length && type != 127)
                    {
                        type = _raw[offset];
                        int length = _raw[offset + 1];

                        if (offset + length > _raw.Length)
                            break;

                        byte[] data = new byte[length];
                        Array.Copy(_raw, offset, data, 0, length);
                        offset += length;

                        List<string> strings = new();
                        if (offset < _raw.Length && _raw[offset] == 0)
                            offset++;

                        while (offset < _raw.Length && _raw[offset] != 0)
                        {
                            StringBuilder stringBuilder = new();

                            while (offset < _raw.Length && _raw[offset] != 0)
                            {
                                stringBuilder.Append((char)_raw[offset]);
                                offset++;
                            }

                            offset++;

                            strings.Add(stringBuilder.ToString());
                        }

                        offset++;
                        switch (type)
                        {
                            case 0x00:
                                Bios = new BiosInformation(data, strings);
                                break;
                            case 0x01:
                                System = new SystemInformation(data, strings);
                                break;
                            case 0x02:
                                Board = new BaseBoardInformation(data, strings);
                                break;
                            case 0x03:
                                SystemEnclosure = new SystemEnclosure(data, strings);
                                break;
                            case 0x04:
                                processorInformationList.Add(new ProcessorInformation(data, strings));
                                break;
                            case 0x07:
                                processorCacheList.Add(new CacheInformation(data, strings));
                                break;
                            case 0x11:
                                memoryDeviceList.Add(new MemoryDevice(data, strings));
                                break;
                        }
                    }
                }
            }

            MemoryDevices = memoryDeviceList.ToArray();
            ProcessorCaches = processorCacheList.ToArray();
            Processors = processorInformationList.ToArray();
        }
    }

    /// <summary>
    /// Gets <inheritdoc cref="BiosInformation" />
    /// </summary>
    public BiosInformation Bios { get; }

    /// <summary>
    /// Gets <inheritdoc cref="BaseBoardInformation" />
    /// </summary>
    public BaseBoardInformation Board { get; }

    /// <summary>
    /// Gets <inheritdoc cref="MemoryDevice" />
    /// </summary>
    public MemoryDevice[] MemoryDevices { get; }

    /// <summary>
    /// Gets <inheritdoc cref="CacheInformation" />
    /// </summary>
    public CacheInformation[] ProcessorCaches { get; }

    /// <summary>
    /// Gets <inheritdoc cref="ProcessorInformation" />
    /// </summary>
    public ProcessorInformation[] Processors { get; }

    /// <summary>
    /// Gets <inheritdoc cref="SystemInformation" />
    /// </summary>
    public SystemInformation System { get; }

    /// <summary>
    /// Gets <inheritdoc cref="LibreHardwareMonitor.Hardware.SystemEnclosure" />
    /// </summary>
    public SystemEnclosure SystemEnclosure { get; }

    private static string ReadSysFs(string path)
    {
        try
        {
            if (File.Exists(path))
            {
                using StreamReader reader = new(path);

                return reader.ReadLine();
            }

            return null;
        }
        catch
        {
            return null;
        }
    }

    /// <summary>
    /// Report containing most of the information that could be read from the SMBIOS table.
    /// </summary>
    /// <returns>A formatted text string with computer information and the entire SMBIOS table.</returns>
    public string GetReport()
    {
        StringBuilder r = new();

        if (_version != null)
        {
            r.Append("SMBios Version: ");
            r.AppendLine(_version.ToString(2));
            r.AppendLine();
        }

        if (Bios != null)
        {
            r.Append("BIOS Vendor: ");
            r.AppendLine(Bios.Vendor);
            r.Append("BIOS Version: ");
            r.AppendLine(Bios.Version);
            if (Bios.Date != null)
            {
                r.Append("BIOS Date: ");
                r.AppendLine(Bios.Date.Value.ToShortDateString());
            }

            if (Bios.Size != null)
            {
                const int megabyte = 1024 * 1024;
                r.Append("BIOS Size: ");
                if (Bios.Size > megabyte)
                    r.AppendLine((Bios.Size.Value / megabyte) + " MB");
                else
                    r.AppendLine((Bios.Size.Value / 1024) + " KB");
            }

            r.AppendLine();
        }

        if (System != null)
        {
            r.Append("System Manufacturer: ");
            r.AppendLine(System.ManufacturerName);
            r.Append("System Name: ");
            r.AppendLine(System.ProductName);
            r.Append("System Version: ");
            r.AppendLine(System.Version);
            r.Append("System Wakeup: ");
            r.AppendLine(System.WakeUp.ToString());
            r.AppendLine();
        }

        if (Board != null)
        {
            r.Append("Motherboard Manufacturer: ");
            r.AppendLine(Board.ManufacturerName);
            r.Append("Motherboard Name: ");
            r.AppendLine(Board.ProductName);
            r.Append("Motherboard Version: ");
            r.AppendLine(Board.Version);
            r.Append("Motherboard Serial: ");
            r.AppendLine(Board.SerialNumber);
            r.AppendLine();
        }

        if (SystemEnclosure != null)
        {
            r.Append("System Enclosure Type: ");
            r.AppendLine(SystemEnclosure.Type.ToString());
            r.Append("System Enclosure Manufacturer: ");
            r.AppendLine(SystemEnclosure.ManufacturerName);
            r.Append("System Enclosure Version: ");
            r.AppendLine(SystemEnclosure.Version);
            r.Append("System Enclosure Serial: ");
            r.AppendLine(SystemEnclosure.SerialNumber);
            r.Append("System Enclosure Asset Tag: ");
            r.AppendLine(SystemEnclosure.AssetTag);
            if (!string.IsNullOrEmpty(SystemEnclosure.SKU))
            {
                r.Append("System Enclosure SKU: ");
                r.AppendLine(SystemEnclosure.SKU);
            }

            r.Append("System Enclosure Boot Up State: ");
            r.AppendLine(SystemEnclosure.BootUpState.ToString());
            r.Append("System Enclosure Power Supply State: ");
            r.AppendLine(SystemEnclosure.PowerSupplyState.ToString());
            r.Append("System Enclosure Thermal State: ");
            r.AppendLine(SystemEnclosure.ThermalState.ToString());
            r.Append("System Enclosure Power Cords: ");
            r.AppendLine(SystemEnclosure.PowerCords.ToString());
            if (SystemEnclosure.RackHeight > 0)
            {
                r.Append("System Enclosure Rack Height: ");
                r.AppendLine(SystemEnclosure.RackHeight.ToString());
            }

            r.Append("System Enclosure Lock Detected: ");
            r.AppendLine(SystemEnclosure.LockDetected ? "Yes" : "No");
            r.Append("System Enclosure Security Status: ");
            r.AppendLine(SystemEnclosure.SecurityStatus.ToString());
            r.AppendLine();
        }

        if (Processors != null)
        {
            foreach (ProcessorInformation processor in Processors)
            {
                r.Append("Processor Manufacturer: ");
                r.AppendLine(processor.ManufacturerName);
                r.Append("Processor Type: ");
                r.AppendLine(processor.ProcessorType.ToString());
                r.Append("Processor Version: ");
                r.AppendLine(processor.Version);
                r.Append("Processor Serial: ");
                r.AppendLine(processor.Serial);
                r.Append("Processor Socket Destignation: ");
                r.AppendLine(processor.SocketDesignation);
                r.Append("Processor Socket: ");
                r.AppendLine(processor.Socket.ToString());
                r.Append("Processor Version: ");
                r.AppendLine(processor.Version);
                r.Append("Processor Family: ");
                r.AppendLine(processor.Family.ToString());
                r.Append("Processor Core Count: ");
                r.AppendLine(processor.CoreCount.ToString());
                r.Append("Processor Core Enabled: ");
                r.AppendLine(processor.CoreEnabled.ToString());
                r.Append("Processor Thread Count: ");
                r.AppendLine(processor.ThreadCount.ToString());
                r.Append("Processor External Clock: ");
                r.Append(processor.ExternalClock);
                r.AppendLine(" Mhz");
                r.Append("Processor Max Speed: ");
                r.Append(processor.MaxSpeed);
                r.AppendLine(" Mhz");
                r.Append("Processor Current Speed: ");
                r.Append(processor.CurrentSpeed);
                r.AppendLine(" Mhz");
                r.AppendLine();
            }
        }

        for (int i = 0; i < ProcessorCaches.Length; i++)
        {
            r.Append("Cache [" + ProcessorCaches[i].Designation + "] Size: ");
            r.AppendLine(ProcessorCaches[i].Size.ToString());
            r.Append("Cache [" + ProcessorCaches[i].Designation + "] Associativity: ");
            r.AppendLine(ProcessorCaches[i].Associativity.ToString().Replace("_", string.Empty));
            r.AppendLine();
        }

        for (int i = 0; i < MemoryDevices.Length; i++)
        {
            r.Append("Memory Device [" + i + "] Manufacturer: ");
            r.AppendLine(MemoryDevices[i].ManufacturerName);
            r.Append("Memory Device [" + i + "] Part Number: ");
            r.AppendLine(MemoryDevices[i].PartNumber);
            r.Append("Memory Device [" + i + "] Device Locator: ");
            r.AppendLine(MemoryDevices[i].DeviceLocator);
            r.Append("Memory Device [" + i + "] Bank Locator: ");
            r.AppendLine(MemoryDevices[i].BankLocator);
            r.Append("Memory Device [" + i + "] Speed: ");
            r.AppendLine(MemoryDevices[i].Speed.ToString());
            r.Append("Memory Device [" + i + "] Configured Speed: ");
            r.AppendLine(MemoryDevices[i].ConfiguredSpeed.ToString());
            r.Append("Memory Device [" + i + "] Configured Voltage: ");
            r.AppendLine(MemoryDevices[i].ConfiguredVoltage.ToString());
            r.Append("Memory Device [" + i + "] Size: ");
            r.Append(MemoryDevices[i].Size.ToString());
            r.AppendLine(" MB");
            r.AppendLine();
        }

        if (_raw != null)
        {
            string base64 = Convert.ToBase64String(_raw);
            r.AppendLine("SMBios Table");
            r.AppendLine();

            for (int i = 0; i < Math.Ceiling(base64.Length / 64.0); i++)
            {
                r.Append(" ");
                for (int j = 0; j < 0x40; j++)
                {
                    int index = (i << 6) | j;
                    if (index < base64.Length)
                    {
                        r.Append(base64[index]);
                    }
                }

                r.AppendLine();
            }

            r.AppendLine();
        }

        return r.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Sensor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.IO.Compression;

namespace LibreHardwareMonitor.Hardware;

internal class Sensor : ISensor
{
    private readonly string _defaultName;
    private readonly Hardware _hardware;
    private readonly ISettings _settings;
    private readonly bool _trackMinMax;
    private readonly List<SensorValue> _values = new();
    private int _count;
    private float? _currentValue;
    private string _name;
    private float _sum;
    private TimeSpan _valuesTimeWindow = TimeSpan.FromDays(1.0);

    public Sensor(string name, int index, SensorType sensorType, Hardware hardware, ISettings settings) :
        this(name, index, sensorType, hardware, null, settings)
    { }

    public Sensor(string name, int index, SensorType sensorType, Hardware hardware, ParameterDescription[] parameterDescriptions, ISettings settings) :
        this(name, index, false, sensorType, hardware, parameterDescriptions, settings)
    { }

    public Sensor
    (
        string name,
        int index,
        bool defaultHidden,
        SensorType sensorType,
        Hardware hardware,
        ParameterDescription[] parameterDescriptions,
        ISettings settings,
        bool disableHistory = false)
    {
        Index = index;
        IsDefaultHidden = defaultHidden;
        SensorType = sensorType;
        _hardware = hardware;

        Parameter[] parameters = new Parameter[parameterDescriptions?.Length ?? 0];
        for (int i = 0; i < parameters.Length; i++)
        {
            if (parameterDescriptions != null)
                parameters[i] = new Parameter(parameterDescriptions[i], this, settings);
        }

        Parameters = parameters;

        _settings = settings;
        _defaultName = name;
        _name = settings.GetValue(new Identifier(Identifier, "name").ToString(), name);
        _trackMinMax = !disableHistory;
        if (disableHistory)
        {
            _valuesTimeWindow = TimeSpan.Zero;
        }

        GetSensorValuesFromSettings();

        hardware.Closing += delegate { SetSensorValuesToSettings(); };
    }

    public IControl Control { get; internal set; }

    public IHardware Hardware
    {
        get { return _hardware; }
    }

    public Identifier Identifier
    {
        get { return new Identifier(_hardware.Identifier, SensorType.ToString().ToLowerInvariant(), Index.ToString(CultureInfo.InvariantCulture)); }
    }

    public int Index { get; }

    public bool IsDefaultHidden { get; }

    public float? Max { get; private set; }

    public float? Min { get; private set; }

    public string Name
    {
        get { return _name; }
        set
        {
            _name = !string.IsNullOrEmpty(value) ? value : _defaultName;

            _settings.SetValue(new Identifier(Identifier, "name").ToString(), _name);
        }
    }

    public IReadOnlyList<IParameter> Parameters { get; }

    public SensorType SensorType { get; }

    public virtual float? Value
    {
        get { return _currentValue; }
        set
        {
            if (_valuesTimeWindow != TimeSpan.Zero)
            {
                DateTime now = DateTime.UtcNow;
                while (_values.Count > 0 && now - _values[0].Time > _valuesTimeWindow)
                    _values.RemoveAt(0);

                if (value.HasValue)
                {
                    _sum += value.Value;
                    _count++;
                    if (_count == 4)
                    {
                        AppendValue(_sum / _count, now);
                        _sum = 0;
                        _count = 0;
                    }
                }
            }

            _currentValue = value;
            if (_trackMinMax)
            {
                if (!Min.HasValue || Min > value)
                    Min = value;

                if (!Max.HasValue || Max < value)
                    Max = value;
            }
        }
    }

    public IEnumerable<SensorValue> Values
    {
        get { return _values; }
    }

    public TimeSpan ValuesTimeWindow
    {
        get { return _valuesTimeWindow; }
        set
        {
            _valuesTimeWindow = value;
            if (value == TimeSpan.Zero)
                _values.Clear();
        }
    }

    public void ResetMin()
    {
        Min = null;
    }

    public void ResetMax()
    {
        Max = null;
    }

    public void ClearValues()
    {
        _values.Clear();
    }

    public void Accept(IVisitor visitor)
    {
        if (visitor == null)
            throw new ArgumentNullException(nameof(visitor));

        visitor.VisitSensor(this);
    }

    public void Traverse(IVisitor visitor)
    {
        foreach (IParameter parameter in Parameters)
            parameter.Accept(visitor);
    }

    private void SetSensorValuesToSettings()
    {
        using MemoryStream memoryStream = new();
        using GZipStream gZipStream = new(memoryStream, CompressionMode.Compress);
        using BufferedStream outputStream = new(gZipStream, 65536);
        using (BinaryWriter binaryWriter = new(outputStream))
        {
            long t = 0;

            foreach (SensorValue sensorValue in _values)
            {
                long v = sensorValue.Time.ToBinary();
                binaryWriter.Write(v - t);
                t = v;
                binaryWriter.Write(sensorValue.Value);
            }

            binaryWriter.Flush();
        }

        _settings.SetValue(new Identifier(Identifier, "values").ToString(), Convert.ToBase64String(memoryStream.ToArray()));
    }

    private void GetSensorValuesFromSettings()
    {
        string name = new Identifier(Identifier, "values").ToString();
        string s = _settings.GetValue(name, null);

        if (!string.IsNullOrEmpty(s))
        {
            try
            {
                byte[] array = Convert.FromBase64String(s);
                DateTime now = DateTime.UtcNow;

                using MemoryStream memoryStream = new(array);
                using GZipStream gZipStream = new(memoryStream, CompressionMode.Decompress);
                using MemoryStream destination = new();

                gZipStream.CopyTo(destination);
                destination.Seek(0, SeekOrigin.Begin);

                using BinaryReader reader = new(destination);
                try
                {
                    long t = 0;
                    long readLen = reader.BaseStream.Length - reader.BaseStream.Position;
                    while (readLen > 0)
                    {
                        t += reader.ReadInt64();
                        DateTime time = DateTime.FromBinary(t);
                        if (time > now)
                            break;

                        float value = reader.ReadSingle();
                        AppendValue(value, time);
                        readLen = reader.BaseStream.Length - reader.BaseStream.Position;
                    }
                }
                catch (EndOfStreamException)
                { }
            }
            catch
            {
                // Ignored.
            }
        }

        if (_values.Count > 0)
            AppendValue(float.NaN, DateTime.UtcNow);

        //remove the value string from the settings to reduce memory usage
        _settings.Remove(name);
    }

    private void AppendValue(float value, DateTime time)
    {
        if (_values.Count >= 2 && _values[_values.Count - 1].Value == value && _values[_values.Count - 2].Value == value)
        {
            _values[_values.Count - 1] = new SensorValue(value, time);
            return;
        }

        _values.Add(new SensorValue(value, time));
    }
}
```

`LibreHardwareMonitorLib/Hardware/SensorVisitor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Observer making calls to selected component <see cref="ISensor"/>'s.
/// </summary>
public class SensorVisitor : IVisitor
{
    private readonly SensorEventHandler _handler;

    /// <summary>
    /// Creates a new observer instance.
    /// </summary>
    /// <param name="handler">Instance of the <see cref="SensorEventHandler"/> that triggers events during visiting the <see cref="ISensor"/>.</param>
    public SensorVisitor(SensorEventHandler handler)
    {
        _handler = handler ?? throw new ArgumentNullException(nameof(handler));
    }

    /// <summary>
    /// Goes through all the components of the specified <see cref="IComputer"/> with its <see cref="IElement.Traverse(IVisitor)"/>.
    /// </summary>
    /// <param name="computer">Computer class instance that is derived from the <see cref="IComputer"/> interface.</param>
    public void VisitComputer(IComputer computer)
    {
        if (computer == null)
            throw new ArgumentNullException(nameof(computer));

        computer.Traverse(this);
    }

    /// <summary>
    /// Goes through all the components of the specified <see cref="IHardware"/> with its <see cref="IElement.Traverse(IVisitor)"/>.
    /// </summary>
    /// <param name="hardware">Hardware class instance that is derived from the <see cref="IHardware"/> interface.</param>
    public void VisitHardware(IHardware hardware)
    {
        if (hardware == null)
            throw new ArgumentNullException(nameof(hardware));

        hardware.Traverse(this);
    }

    /// <summary>
    /// Goes through all the components of the specified <see cref="ISensor"/> using <see cref="SensorEventHandler"/>.
    /// </summary>
    /// <param name="sensor">Sensor class instance that is derived from the <see cref="ISensor"/> interface.</param>
    public void VisitSensor(ISensor sensor)
    {
        _handler(sensor);
    }

    /// <summary>
    /// Goes through all the components of the specified <see cref="IParameter"/>.
    /// <para>
    /// <see cref="NotImplementedException"/>
    /// </para>
    /// </summary>
    /// <param name="parameter">Parameter class instance that is derived from the <see cref="IParameter"/> interface.</param>
    public void VisitParameter(IParameter parameter)
    { }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/ATAStorage.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

public abstract class AtaStorage : AbstractStorage
{
    // array of all hard drive types, matching type is searched in this order
    private static readonly Type[] _hddTypes = { typeof(SsdPlextor), typeof(SsdIntel), typeof(SsdSandforce), typeof(SsdIndilinx), typeof(SsdSamsung), typeof(SsdMicron), typeof(GenericHardDisk) };

    private IDictionary<SmartAttribute, Sensor> _sensors;

    /// <summary>
    /// Gets the SMART data.
    /// </summary>
    public ISmart Smart { get; }

    /// <summary>
    /// Gets the SMART attributes.
    /// </summary>
    public IReadOnlyList<SmartAttribute> SmartAttributes { get; }

    internal AtaStorage(StorageInfo storageInfo, ISmart smart, string name, string firmwareRevision, string id, int index, IReadOnlyList<SmartAttribute> smartAttributes, ISettings settings)
        : base(storageInfo, name, firmwareRevision, id, index, settings)
    {
        Smart = smart;
        if (smart.IsValid)
            smart.EnableSmart();
            
        SmartAttributes = smartAttributes;
        CreateSensors();
    }

    internal static AbstractStorage CreateInstance(StorageInfo storageInfo, ISettings settings)
    {
        ISmart smart = new WindowsSmart(storageInfo.Index);
        string name = null;
        string firmwareRevision = null;
        Kernel32.SMART_ATTRIBUTE[] smartAttributes = { };

        if (smart.IsValid)
        {
            bool nameValid = smart.ReadNameAndFirmwareRevision(out name, out firmwareRevision);
            bool smartEnabled = smart.EnableSmart();

            if (smartEnabled)
                smartAttributes = smart.ReadSmartData();
                
            if (!nameValid)
            {
                name = null;
                firmwareRevision = null;
            }
        }
        else
        {
            string[] logicalDrives = WindowsStorage.GetLogicalDrives(storageInfo.Index);
            if (logicalDrives == null || logicalDrives.Length == 0)
            {
                smart.Close();
                return null;
            }

            bool hasNonZeroSizeDrive = false;
            foreach (string logicalDrive in logicalDrives)
            {
                try
                {
                    var driveInfo = new DriveInfo(logicalDrive);
                    if (driveInfo.TotalSize > 0)
                    {
                        hasNonZeroSizeDrive = true;
                        break;
                    }
                }
                catch (ArgumentException) { }
                catch (IOException) { }
                catch (UnauthorizedAccessException) { }
            }

            if (!hasNonZeroSizeDrive)
            {
                smart.Close();
                return null;
            }
        }

        if (string.IsNullOrEmpty(name))
            name = string.IsNullOrEmpty(storageInfo.Name) ? "Generic Hard Disk" : storageInfo.Name;

        if (string.IsNullOrEmpty(firmwareRevision))
            firmwareRevision = string.IsNullOrEmpty(storageInfo.Revision) ? "Unknown" : storageInfo.Revision;

        foreach (Type type in _hddTypes)
        {
            // get the array of the required SMART attributes for the current type

            // check if all required attributes are present
            bool allAttributesFound = true;

            if (type.GetCustomAttributes(typeof(RequireSmartAttribute), true) is RequireSmartAttribute[] requiredAttributes)
            {
                foreach (RequireSmartAttribute requireAttribute in requiredAttributes)
                {
                    bool attributeFound = false;

                    foreach (Kernel32.SMART_ATTRIBUTE value in smartAttributes)
                    {
                        if (value.Id == requireAttribute.AttributeId)
                        {
                            attributeFound = true;
                            break;
                        }
                    }

                    if (!attributeFound)
                    {
                        allAttributesFound = false;
                        break;
                    }
                }
            }

            // if an attribute is missing, then try the next type
            if (!allAttributesFound)
                continue;

            // check if there is a matching name prefix for this type
            if (type.GetCustomAttributes(typeof(NamePrefixAttribute), true) is NamePrefixAttribute[] namePrefixes)
            {
                foreach (NamePrefixAttribute prefix in namePrefixes)
                {
                    if (name.StartsWith(prefix.Prefix, StringComparison.InvariantCulture))
                    {
                        const BindingFlags flags = BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance;

                        return Activator.CreateInstance(type, flags, null, new object[] { storageInfo, smart, name, firmwareRevision, storageInfo.Index, settings }, null) as AtaStorage;
                    }
                }
            }
        }

        // no matching type has been found
        smart.Close();
        return null;
    }

    protected sealed override void CreateSensors()
    {
        _sensors = new Dictionary<SmartAttribute, Sensor>();

        if (Smart.IsValid)
        {
            byte[] smartIds = Smart.ReadSmartData().Select(x => x.Id).ToArray();

            // unique attributes by SensorType and SensorChannel.
            IEnumerable<SmartAttribute> smartAttributes = SmartAttributes
                                                         .Where(x => x.SensorType.HasValue && smartIds.Contains(x.Id))
                                                         .GroupBy(x => new { x.SensorType.Value, x.SensorChannel })
                                                         .Select(x => x.First());

            _sensors = smartAttributes.ToDictionary(attribute => attribute,
                                                    attribute => new Sensor(attribute.SensorName,
                                                                            attribute.SensorChannel,
                                                                            attribute.DefaultHiddenSensor,
                                                                            attribute.SensorType.GetValueOrDefault(),
                                                                            this,
                                                                            attribute.ParameterDescriptions,
                                                                            _settings));

            foreach (KeyValuePair<SmartAttribute, Sensor> sensor in _sensors)
                ActivateSensor(sensor.Value);
        }

        base.CreateSensors();
    }

    protected virtual void UpdateAdditionalSensors(Kernel32.SMART_ATTRIBUTE[] values) { }

    protected override void UpdateSensors()
    {
        if (Smart.IsValid)
        {
            Kernel32.SMART_ATTRIBUTE[] smartAttributes = Smart.ReadSmartData();

            foreach (KeyValuePair<SmartAttribute, Sensor> keyValuePair in _sensors)
            {
                SmartAttribute attribute = keyValuePair.Key;
                foreach (Kernel32.SMART_ATTRIBUTE value in smartAttributes)
                {
                    if (value.Id == attribute.Id)
                    {
                        Sensor sensor = keyValuePair.Value;
                        sensor.Value = attribute.ConvertValue(value, sensor.Parameters);
                    }
                }
            }

            UpdateAdditionalSensors(smartAttributes);
        }
    }

    protected override void GetReport(StringBuilder r)
    {
        if (Smart.IsValid)
        {
            Kernel32.SMART_ATTRIBUTE[] values = Smart.ReadSmartData();
            Kernel32.SMART_THRESHOLD[] thresholds = Smart.ReadSmartThresholds();
            if (values.Length > 0)
            {
                r.AppendFormat(CultureInfo.InvariantCulture,
                               " {0}{1}{2}{3}{4}{5}{6}{7}",
                               "Id".PadRight(3),
                               "Description".PadRight(35),
                               "Raw Value".PadRight(13),
                               "Worst".PadRight(6),
                               "Value".PadRight(6),
                               "Threshold".PadRight(6),
                               "Physical".PadRight(8),
                               Environment.NewLine);

                foreach (Kernel32.SMART_ATTRIBUTE value in values)
                {
                    if (value.Id == 0x00)
                        break;

                    byte? threshold = null;
                    foreach (Kernel32.SMART_THRESHOLD t in thresholds)
                    {
                        if (t.Id == value.Id)
                        {
                            threshold = t.Threshold;
                        }
                    }

                    string description = "Unknown";
                    float? physical = null;
                    foreach (SmartAttribute a in SmartAttributes)
                    {
                        if (a.Id == value.Id)
                        {
                            description = a.Name;
                            if (a.HasRawValueConversion | a.SensorType.HasValue)
                                physical = a.ConvertValue(value, null);
                            else
                                physical = null;
                        }
                    }

                    string raw = BitConverter.ToString(value.RawValue);
                    r.AppendFormat(CultureInfo.InvariantCulture,
                                   " {0}{1}{2}{3}{4}{5}{6}{7}",
                                   value.Id.ToString("X2").PadRight(3),
                                   description.PadRight(35),
                                   raw.Replace("-", string.Empty).PadRight(13),
                                   value.WorstValue.ToString(CultureInfo.InvariantCulture).PadRight(6),
                                   value.CurrentValue.ToString(CultureInfo.InvariantCulture).PadRight(6),
                                   (threshold.HasValue
                                       ? threshold.Value.ToString(CultureInfo.InvariantCulture)
                                       : "-").PadRight(6),
                                   (physical.HasValue ? physical.Value.ToString(CultureInfo.InvariantCulture) : "-").PadRight(8),
                                   Environment.NewLine);
                }

                r.AppendLine();
            }
        }
    }

    protected static float RawToInt(byte[] raw, byte value, IReadOnlyList<IParameter> parameters)
    {
        return (raw[3] << 24) | (raw[2] << 16) | (raw[1] << 8) | raw[0];
    }

    public override void Close()
    {
        Smart.Close();
        base.Close();
    }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/AbstractStorage.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Management;
using System.Text;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

public abstract class AbstractStorage : Hardware
{
    private readonly PerformanceValue _perfTotal = new();
    private readonly PerformanceValue _perfWrite = new();
    private readonly StorageInfo _storageInfo;
    private readonly TimeSpan _updateInterval = TimeSpan.FromSeconds(60);

    private ulong _lastReadRateCounter;
    private double _lastTime;
    private DateTime _lastUpdate = DateTime.MinValue;
    private ulong _lastWriteRateCounter;
    private Sensor _sensorDiskReadRate;
    private Sensor _sensorDiskTotalActivity;
    private Sensor _sensorDiskWriteActivity;
    private Sensor _sensorDiskWriteRate;
    private Sensor _usageSensor;
    private int _wmiFailureCount;

    internal AbstractStorage(StorageInfo storageInfo, string name, string firmwareRevision, string id, int index, ISettings settings)
        : base(name, new Identifier(id, index.ToString(CultureInfo.InvariantCulture)), settings)
    {
        _storageInfo = storageInfo;
        FirmwareRevision = firmwareRevision;
        Index = index;

        string[] logicalDrives = WindowsStorage.GetLogicalDrives(index);
        var driveInfoList = new List<DriveInfo>(logicalDrives.Length);

        foreach (string logicalDrive in logicalDrives)
        {
            try
            {
                var di = new DriveInfo(logicalDrive);
                if (di.TotalSize > 0)
                    driveInfoList.Add(new DriveInfo(logicalDrive));
            }
            catch (ArgumentException)
            { }
            catch (IOException)
            { }
            catch (UnauthorizedAccessException)
            { }
        }

        DriveInfos = driveInfoList.ToArray();
    }

    public DriveInfo[] DriveInfos { get; }

    public string FirmwareRevision { get; }

    public override HardwareType HardwareType => HardwareType.Storage;

    public int Index { get; }

    public static AbstractStorage CreateInstance(string deviceId, uint driveNumber, ulong diskSize, int scsiPort, ISettings settings)
    {
        StorageInfo info = WindowsStorage.GetStorageInfo(deviceId, driveNumber);
        if (info == null)
            return null;

        info.DiskSize = diskSize;
        info.DeviceId = deviceId;
        info.Scsi = $@"\\.\SCSI{scsiPort}:";

        if (info.Removable || info.BusType is Kernel32.STORAGE_BUS_TYPE.BusTypeVirtual or Kernel32.STORAGE_BUS_TYPE.BusTypeFileBackedVirtual)
            return null;

        //fallback, when it is not possible to read out with the nvme implementation,
        //try it with the sata smart implementation
        if (info.BusType == Kernel32.STORAGE_BUS_TYPE.BusTypeNvme)
        {
            AbstractStorage x = NVMeGeneric.CreateInstance(info, settings);
            if (x != null)
                return x;
        }

        return info.BusType is Kernel32.STORAGE_BUS_TYPE.BusTypeAta or Kernel32.STORAGE_BUS_TYPE.BusTypeSata or Kernel32.STORAGE_BUS_TYPE.BusTypeNvme
            ? AtaStorage.CreateInstance(info, settings)
            : StorageGeneric.CreateInstance(info, settings);
    }

    protected virtual void CreateSensors()
    {
        if (DriveInfos.Length > 0)
        {
            _usageSensor = new Sensor("Used Space", 0, SensorType.Load, this, _settings);
            ActivateSensor(_usageSensor);
        }

        _sensorDiskWriteActivity = new Sensor("Write Activity", 32, SensorType.Load, this, _settings);
        ActivateSensor(_sensorDiskWriteActivity);

        _sensorDiskTotalActivity = new Sensor("Total Activity", 33, SensorType.Load, this, _settings);
        ActivateSensor(_sensorDiskTotalActivity);

        _sensorDiskReadRate = new Sensor("Read Rate", 34, SensorType.Throughput, this, _settings);
        ActivateSensor(_sensorDiskReadRate);

        _sensorDiskWriteRate = new Sensor("Write Rate", 35, SensorType.Throughput, this, _settings);
        ActivateSensor(_sensorDiskWriteRate);
    }

    protected abstract void UpdateSensors();

    private void UpdateStatisticsFromWmi(int driveIndex)
    {
        string query = $"SELECT * FROM Win32_PerfRawData_PerfDisk_PhysicalDisk Where Name LIKE \"{driveIndex}%\"";

        using var perfData = new ManagementObjectSearcher(query) { Options = { Timeout = TimeSpan.FromSeconds(7.5) } };
        using ManagementObjectCollection collection = perfData.Get();
        using ManagementObject data = collection.OfType<ManagementObject>().FirstOrDefault();

        if (data == null)
            return;

        ulong value = (ulong)data.Properties["PercentDiskWriteTime"].Value;
        ulong valueBase = (ulong)data.Properties["PercentDiskWriteTime_Base"].Value;
        _perfWrite.Update(value, valueBase);
        _sensorDiskWriteActivity.Value = (float)_perfWrite.Result;

        value = (ulong)data.Properties["PercentIdleTime"].Value;
        valueBase = (ulong)data.Properties["PercentIdleTime_Base"].Value;
        _perfTotal.Update(value, valueBase);
        _sensorDiskTotalActivity.Value = (float)(100.0 - _perfTotal.Result);

        ulong readRateCounter = (ulong)data.Properties["DiskReadBytesPerSec"].Value;
        ulong readRate = readRateCounter - _lastReadRateCounter;
        _lastReadRateCounter = readRateCounter;

        ulong writeRateCounter = (ulong)data.Properties["DiskWriteBytesPerSec"].Value;
        ulong writeRate = writeRateCounter - _lastWriteRateCounter;
        _lastWriteRateCounter = writeRateCounter;

        ulong timestampPerfTime = (ulong)data.Properties["Timestamp_PerfTime"].Value;
        ulong frequencyPerfTime = (ulong)data.Properties["Frequency_Perftime"].Value;
        double currentTime = (double)timestampPerfTime / frequencyPerfTime;

        double timeDeltaSeconds = currentTime - _lastTime;
        if (_lastTime == 0 || timeDeltaSeconds > 0.2)
        {
            double writeSpeed = writeRate * (1 / timeDeltaSeconds);
            _sensorDiskWriteRate.Value = (float)writeSpeed;

            double readSpeed = readRate * (1 / timeDeltaSeconds);
            _sensorDiskReadRate.Value = (float)readSpeed;
        }

        if (_lastTime == 0 || timeDeltaSeconds > 0.2)
            _lastTime = currentTime;
    }

    public override void Update()
    {
        const int wmiRetries = 10;

        //update statistics from WMI on every update
        if (_storageInfo != null && _wmiFailureCount <= wmiRetries)
        {
            try
            {
                UpdateStatisticsFromWmi(_storageInfo.Index);
                _wmiFailureCount = 0;
            }
            catch
            {
                if (++_wmiFailureCount == wmiRetries)
                {
                    DeactivateSensor(_sensorDiskTotalActivity);
                    DeactivateSensor(_sensorDiskWriteActivity);
                    DeactivateSensor(_sensorDiskReadRate);
                    DeactivateSensor(_sensorDiskWriteRate);
                }
            }
        }

        //read out with updateInterval
        TimeSpan tDiff = DateTime.UtcNow - _lastUpdate;
        if (tDiff > _updateInterval)
        {
            _lastUpdate = DateTime.UtcNow;

            UpdateSensors();

            if (_usageSensor != null)
            {
                long totalSize = 0;
                long totalFreeSpace = 0;

                for (int i = 0; i < DriveInfos.Length; i++)
                {
                    if (!DriveInfos[i].IsReady)
                        continue;

                    try
                    {
                        totalSize += DriveInfos[i].TotalSize;
                        totalFreeSpace += DriveInfos[i].TotalFreeSpace;
                    }
                    catch (IOException)
                    { }
                    catch (UnauthorizedAccessException)
                    { }
                }

                if (totalSize > 0)
                    _usageSensor.Value = 100.0f - ((100.0f * totalFreeSpace) / totalSize);
                else
                    _usageSensor.Value = null;
            }
        }
    }

    protected abstract void GetReport(StringBuilder r);

    public override string GetReport()
    {
        var r = new StringBuilder();
        r.AppendLine("Storage");
        r.AppendLine();
        r.AppendLine("Drive Name: " + _name);
        r.AppendLine("Firmware Version: " + FirmwareRevision);
        r.AppendLine();
        GetReport(r);

        foreach (DriveInfo di in DriveInfos)
        {
            if (!di.IsReady)
                continue;

            try
            {
                r.AppendLine("Logical Drive Name: " + di.Name);
                r.AppendLine("Format: " + di.DriveFormat);
                r.AppendLine("Total Size: " + di.TotalSize);
                r.AppendLine("Total Free Space: " + di.TotalFreeSpace);
                r.AppendLine();
            }
            catch (IOException)
            { }
            catch (UnauthorizedAccessException)
            { }
        }

        return r.ToString();
    }

    public override void Traverse(IVisitor visitor)
    {
        foreach (ISensor sensor in Sensors)
            sensor.Accept(visitor);
    }

    /// <summary>
    /// Helper to calculate the disk performance with base timestamps
    /// https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-perfrawdata
    /// </summary>
    private class PerformanceValue
    {
        public double Result { get; private set; }

        private ulong Time { get; set; }

        private ulong Value { get; set; }

        public void Update(ulong val, ulong valBase)
        {
            ulong diffValue = val - Value;
            ulong diffTime = valBase - Time;

            Value = val;
            Time = valBase;
            Result = 100.0 / diffTime * diffValue;

            //sometimes it is possible that diff_value > diff_timebase
            //limit result to 100%, this is because timing issues during read from pcie controller an latency between IO operation
            if (Result > 100)
                Result = 100;
        }
    }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/DebugSmart.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

#if DEBUG

using System;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage
{
    internal class DebugSmart : ISmart
    {
        private readonly Drive[] _drives = {
            new("KINGSTON SNV425S264GB", null, 16,
                @" 01 000000000000 100 100      
                02 000000000000 100 100      
                03 000000000000 100 100      
                05 000000000000 100 100      
                07 000000000000 100 100      
                08 000000000000 100 100      
                09 821E00000000 100 100      
                0A 000000000000 100 100      
                0C 950200000000 100 100      
                A8 000000000000 100 100      
                AF 000000000000 100 100      
                C0 000000000000 100 100      
                C2 290014002B00 100 41       
                C5 000000000000 100 100      
                F0 000000000000 100 100      
                AA 07007B000000 100 100      
                AD 0E1E71304919 100 100"),
            new("PLEXTOR  PX-128M2S", "1.03", 16,
                @" 01 000000000000 100 100 0   
                03 000000000000 100 100 0   
                04 000000000000 100 100 0   
                05 000000000000 100 100 0   
                09 250100000000 100 100 0   
                0A 000000000000 100 100 0   
                0C D10000000000 100 100 0   
                B2 000000000000 100 100 0   
                BB 000000000000 100 100 0   
                BE 000000000000 100 100 0   
                C0 000000000000 100 100 0   
                C1 000000000000 100 100 0   
                C2 000000000000 100 100 0   
                C3 000000000000 100 100 0   
                C5 000000000000 100 100 0   
                C6 000000000000 100 100 0   
                C7 000000000000 100 100 0"),
            new("OCZ-VERTEX2", "1.25", 16,
                @" 01 DADAD5000000 100 106 50
                05 000000000000 100 100 3 
                09 DF0900004A2F 100 100 0 
                0C FC0100000000 100 100 0 
                AB 000000000000 0   0   0 
                AC 000000000000 0   0   0 
                AE 1F0000000000 0   0   0 
                B1 000000000000 0   0   0 
                B5 000000000000 0   0   0 
                B6 000000000000 0   0   0 
                BB 000000000000 100 100 0 
                C2 010081007F00 129 1   0 
                C3 DADAD5000000 100 106 0 
                C4 000000000000 100 100 0 
                E7 000000000000 100 100 10
                E9 800400000000 0   0   0 
                EA 000600000000 0   0   0 
                F1 000600000000 0   0   0 
                F2 801200000000 0   0   0"),
            new("WDC WD5000AADS-00S9B0", null, 10,
                @" 1   000000000000 200 200         
                3   820D00000000 149 150         
                4   610800000000 98  98          
                5   000000000000 200 200         
                7   000000000000 253 100         
                9   0F1F00000000 90  90          
                10  000000000000 100 100         
                11  000000000000 100 100         
                12  880200000000 100 100         
                192 6B0000000000 200 200         
                193 E9CB03000000 118 118         
                194 280000000000 94  103         
                196 000000000000 200 200         
                197 000000000000 200 200         
                198 000000000000 200 200         
                199 000000000000 200 200         
                200 000000000000 200 200         
                130 7B0300010002 1   41          
                5   000000000000 0   0           
                1   000000000000 0   0"),
            new("INTEL SSDSA2M080G2GC", null, 10,
                @" 3   000000000000 100 100         
                4   000000000000 100 100         
                5   010000000000 100 100         
                9   B10B00000000 100 100         
                12  DD0300000000 100 100         
                192 480000000000 100 100         
                225 89DB00000000 200 200         
                226 3D1B00000000 100 100         
                227 030000000000 100 100         
                228 7F85703C0000 100 100         
                232 000000000000 99  99          
                233 000000000000 98  98          
                184 000000000000 100 100         
                1   000000000000 0   0"),
            new("OCZ-VERTEX", null, 10,
                @" 1   000000000000 0   8   
                9   000000000000 30  99  
                12  000000000000 0   15  
                184 000000000000 0   7   
                195 000000000000 0   0   
                196 000000000000 0   2   
                197 000000000000 0   0   
                198 B9ED00000000 214 176 
                199 352701000000 143 185 
                200 B10500000000 105 55  
                201 F40A00000000 238 194 
                202 020000000000 137 35  
                203 020000000000 125 63  
                204 000000000000 0   0   
                205 000000000000 19  136 
                206 000000000000 22  54  
                207 010000000000 113 226 
                208 000000000000 49  232 
                209 000000000000 0   98  
                211 000000000000 0   0   
                212 000000000000 0   0   
                213 000000000000 0   0"),
            new("INTEL SSDSA2CW120G3", null, 16,
                @"03 000000000000 100 100 0
                04 000000000000 100 100 0
                05 000000000000 100 100 0
                09 830200000000 100 100 0
                0C 900100000000 100 100 0
                AA 000000000000 100 100 0
                AB 000000000000 100 100 0
                AC 000000000000 100 100 0
                B8 000000000000 100 100 0
                BB 000000000000 100 100 0
                C0 040000000000 100 100 0
                E1 FF4300000000 100 100 0
                E2 E57D14000000 100 100 0
                E3 000000000000 100 100 0
                E4 E39600000000 100 100 0
                E8 000000000000 100 100 0
                E9 000000000000 100 100 0
                F1 FF4300000000 100 100 0
                F2 264F00000000 100 100 0"),
            new("CORSAIR CMFSSD-128GBG2D", "VBM19C1Q", 16,
                @"09 100900000000 99  99  0 
                0C 560200000000 99  99  0 
                AF 000000000000 100 100 10
                B0 000000000000 100 100 10
                B1 2A0000000000 99  99  17
                B2 180000000000 60  60  10
                B3 4B0000000000 98  98  10
                B4 B50E00000000 98  98  10
                B5 000000000000 100 100 10
                B6 000000000000 100 100 10
                B7 000000000000 100 100 10
                BB 000000000000 100 100 0 
                C3 000000000000 200 200 0 
                C6 000000000000 100 100 0 
                C7 810100000000 253 253 0 
                E8 240000000000 60  60  10
                E9 630594120000 92  92  0"),
            new("Maxtor 6L300R0", null, 10,
                @"3   9E5500000000 183 193         
                4   0A0D00000000 252 252         
                5   010000000000 253 253         
                6   000000000000 253 253         
                7   000000000000 252 253         
                8   DFA700000000 224 245         
                9   CE5700000000 155 155         
                10  000000000000 252 253         
                11  000000000000 252 253         
                12  BA0400000000 250 250         
                192 000000000000 253 253         
                193 000000000000 253 253         
                194 3D0000000000 253 42          
                195 5D1F00000000 252 253         
                196 000000000000 253 253         
                197 010000000000 253 253         
                198 000000000000 253 253         
                199 030000000000 196 199         
                200 000000000000 252 253         
                201 000000000000 252 253         
                202 000000000000 252 253         
                203 000000000000 252 253         
                204 000000000000 252 253         
                205 000000000000 252 253         
                207 000000000000 252 253         
                208 000000000000 252 253         
                209 EA0000000000 234 234         
                210 000000000000 252 253         
                211 000000000000 252 253         
                212 000000000000 252 253         
                130 5B0300010002 1   9           
                59  FC3203030100 205 0           
                1   000000000000 0   0           
                144 000000000000 0   34 "),
            new("M4-CT256M4SSD2", "0309", 16,
                @"01 000000000000 100 100 50     
                05 000000000000 100 100 10     
                09 AB0100000000 100 100 1      
                0C 6E0000000000 100 100 1      
                AA 000000000000 100 100 10     
                AB 000000000000 100 100 1      
                AC 000000000000 100 100 1      
                AD 060000000000 100 100 10     
                AE 000000000000 100 100 1      
                B5 79003D00B700 100 100 1      
                B7 000000000000 100 100 1      
                B8 000000000000 100 100 50     
                BB 000000000000 100 100 1      
                BC 000000000000 100 100 1      
                BD 5B0000000000 100 100 1      
                C2 000000000000 100 100 0      
                C3 000000000000 100 100 1      
                C4 000000000000 100 100 1      
                C5 000000000000 100 100 1      
                C6 000000000000 100 100 1      
                C7 000000000000 100 100 1      
                CA 000000000000 100 100 1      
                CE 000000000000 100 100 1 "),
            new("C300-CTFDDAC256MAG", "0007", 16,
                @"01 000000000000 100 100 0  
                05 000000000000 100 100 0  
                09 4C0A00000000 100 100 0  
                0C 0F0100000000 100 100 0  
                AA 000000000000 100 100 0  
                AB 000000000000 100 100 0  
                AC 000000000000 100 100 0  
                AD 1B0000000000 100 100 0  
                AE 000000000000 100 100 0  
                B5 D30357012B05 100 100 0  
                B7 000000000000 100 100 0  
                B8 000000000000 100 100 0  
                BB 000000000000 100 100 0  
                BC 000000000000 100 100 0  
                BD C60100000000 100 100 0  
                C3 000000000000 100 100 0  
                C4 000000000000 100 100 0  
                C5 000000000000 100 100 0  
                C6 000000000000 100 100 0  
                C7 000000000000 100 100 0  
                CA 000000000000 100 100 0  
                CE 000000000000 100 100 0"),
            new("M4-CT064M4SSD2", "0009", 16,
                @"01 000000000000 100 100 50
                05 000000000000 100 100 10
                09 260000000000 100 100 1 
                0C 5A0000000000 100 100 1 
                AA 000000000000 100 100 10
                AB 000000000000 100 100 1 
                AC 000000000000 100 100 1 
                AD 010000000000 100 100 10
                AE 000000000000 100 100 1 
                B5 2B000E003A00 100 100 1 
                B7 000000000000 100 100 1 
                B8 000000000000 100 100 50
                BB 000000000000 100 100 1 
                BC 000000000000 100 100 1 
                BD 310000000000 100 100 1 
                C2 000000000000 100 100 0 
                C3 000000000000 100 100 1 
                C4 000000000000 100 100 1 
                C5 000000000000 100 100 1 
                C6 000000000000 100 100 1 
                C7 000000000000 100 100 1 
                CA 000000000000 100 100 1 
                CE 000000000000 100 100 1"),
            new("M4-CT128M4SSD2", "000F", 16,
                @"01 000000000000 100 100 50 
                05 000000000000 100 100 10 
                09 CA1400000000 100 100 1  
                0C A30200000000 100 100 1  
                AA 000000000000 100 100 10 
                AB 000000000000 100 100 1  
                AC 000000000000 100 100 1  
                AD 1F0000000000 99  99  10 
                AE 140000000000 100 100 1  
                B5 12037C028E05 100 100 1  
                B7 000000000000 100 100 1  
                B8 000000000000 100 100 50 
                BB 000000000000 100 100 1  
                BC 000000000000 100 100 1  
                BD 510000000000 100 100 1  
                C2 000000000000 100 100 0  
                C3 000000000000 100 100 1  
                C4 000000000000 100 100 1  
                C5 000000000000 100 100 1  
                C6 000000000000 100 100 1  
                C7 000000000000 100 100 1  
                CA 010000000000 99  99  1  
                CE 000000000000 100 100 1 "),
            new("Samsung SSD 840 PRO Series", "DXM05B0Q", 16,
                @"05 000000000000 100 100 10 
                09 541200000000 99  99  0  
                0C 820500000000 98  98  0  
                B1 B90200000000 80  80  0  
                B3 000000000000 100 100 10 
                B5 000000000000 100 100 10 
                B6 000000000000 100 100 10 
                B7 000000000000 100 100 10 
                BB 000000000000 100 100 0  
                BE 1C0000000000 48  72  0  
                C3 000000000000 200 200 0  
                C7 020000000000 99  99  0  
                EB 690000000000 99  99  0  
                F1 A56AA1F60200 99  99  0")
        };

        private int _driveNumber;

        public DebugSmart(int driveNumber)
        {
            _driveNumber = driveNumber;
        }

        public bool IsValid => true;

        public void Close()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        public bool EnableSmart()
        {
            if (_driveNumber < 0)
                throw new ObjectDisposedException(nameof(DebugSmart));
            return true;
        }

        public Kernel32.SMART_ATTRIBUTE[] ReadSmartData()
        {
            if (_driveNumber < 0)
                throw new ObjectDisposedException(nameof(DebugSmart));
            return _drives[_driveNumber].DriveAttributeValues;
        }

        public Kernel32.SMART_THRESHOLD[] ReadSmartThresholds()
        {
            if (_driveNumber < 0)
                throw new ObjectDisposedException(nameof(DebugSmart));
            return _drives[_driveNumber].DriveThresholdValues;
        }

        public bool ReadNameAndFirmwareRevision(out string name, out string firmwareRevision)
        {
            if (_driveNumber < 0)
                throw new ObjectDisposedException(nameof(DebugSmart));
            name = _drives[_driveNumber].Name;
            firmwareRevision = _drives[_driveNumber].FirmwareVersion;
            return true;
        }

        public void Dispose()
        {
            Close();
        }

        protected void Dispose(bool disposing)
        {
            if (disposing)
                _driveNumber = -1;
        }

        private class Drive
        {
            public Drive(string name, string firmware, int idBase, string value)
            {
                Name = name;
                FirmwareVersion = firmware;

                string[] lines = value.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
                DriveAttributeValues = new Kernel32.SMART_ATTRIBUTE[lines.Length];
                var thresholds = new System.Collections.Generic.List<Kernel32.SMART_THRESHOLD>();

                for (int i = 0; i < lines.Length; i++)
                {
                    string[] array = lines[i].Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

                    if (array.Length is not 4 and not 5)
                        throw new Exception();

                    var v = new Kernel32.SMART_ATTRIBUTE { Id = Convert.ToByte(array[0], idBase), RawValue = new byte[6] };

                    for (int j = 0; j < 6; j++)
                    {
                        v.RawValue[j] = Convert.ToByte(array[1].Substring(2 * j, 2), 16);
                    }

                    v.WorstValue = Convert.ToByte(array[2], 10);
                    v.CurrentValue = Convert.ToByte(array[3], 10);

                    DriveAttributeValues[i] = v;

                    if (array.Length == 5)
                    {
                        var t = new Kernel32.SMART_THRESHOLD { Id = v.Id, Threshold = Convert.ToByte(array[4], 10) };
                        thresholds.Add(t);
                    }
                }

                DriveThresholdValues = thresholds.ToArray();
            }

            public Kernel32.SMART_ATTRIBUTE[] DriveAttributeValues { get; }

            public Kernel32.SMART_THRESHOLD[] DriveThresholdValues { get; }

            public string FirmwareVersion { get; }

            public string Name { get; }
        }
    }
}

#endif

```

`LibreHardwareMonitorLib/Hardware/Storage/GenericHardDisk.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Storage;

[NamePrefix("")]
public class GenericHardDisk : AtaStorage
{
    private static readonly List<SmartAttribute> _smartAttributes = new()
    {
        new SmartAttribute(0x01, SmartNames.ReadErrorRate),
        new SmartAttribute(0x02, SmartNames.ThroughputPerformance),
        new SmartAttribute(0x03, SmartNames.SpinUpTime),
        new SmartAttribute(0x04, SmartNames.StartStopCount, RawToInt),
        new SmartAttribute(0x05, SmartNames.ReallocatedSectorsCount),
        new SmartAttribute(0x06, SmartNames.ReadChannelMargin),
        new SmartAttribute(0x07, SmartNames.SeekErrorRate),
        new SmartAttribute(0x08, SmartNames.SeekTimePerformance),
        new SmartAttribute(0x09, SmartNames.PowerOnHours, RawToInt),
        new SmartAttribute(0x0A, SmartNames.SpinRetryCount),
        new SmartAttribute(0x0B, SmartNames.RecalibrationRetries),
        new SmartAttribute(0x0C, SmartNames.PowerCycleCount, RawToInt),
        new SmartAttribute(0x0D, SmartNames.SoftReadErrorRate),
        new SmartAttribute(0xAA, SmartNames.Unknown),
        new SmartAttribute(0xAB, SmartNames.Unknown),
        new SmartAttribute(0xAC, SmartNames.Unknown),
        new SmartAttribute(0xB7, SmartNames.SataDownshiftErrorCount, RawToInt),
        new SmartAttribute(0xB8, SmartNames.EndToEndError),
        new SmartAttribute(0xB9, SmartNames.HeadStability),
        new SmartAttribute(0xBA, SmartNames.InducedOpVibrationDetection),
        new SmartAttribute(0xBB, SmartNames.ReportedUncorrectableErrors, RawToInt),
        new SmartAttribute(0xBC, SmartNames.CommandTimeout, RawToInt),
        new SmartAttribute(0xBD, SmartNames.HighFlyWrites),
        new SmartAttribute(0xBF, SmartNames.GSenseErrorRate),
        new SmartAttribute(0xC0, SmartNames.EmergencyRetractCycleCount),
        new SmartAttribute(0xC1, SmartNames.LoadCycleCount),
        new SmartAttribute(0xC3, SmartNames.HardwareEccRecovered),
        new SmartAttribute(0xC4, SmartNames.ReallocationEventCount),
        new SmartAttribute(0xC5, SmartNames.CurrentPendingSectorCount),
        new SmartAttribute(0xC6, SmartNames.UncorrectableSectorCount),
        new SmartAttribute(0xC7, SmartNames.UltraDmaCrcErrorCount),
        new SmartAttribute(0xC8, SmartNames.WriteErrorRate),
        new SmartAttribute(0xCA, SmartNames.DataAddressMarkErrors),
        new SmartAttribute(0xCB, SmartNames.RunOutCancel),
        new SmartAttribute(0xCC, SmartNames.SoftEccCorrection),
        new SmartAttribute(0xCD, SmartNames.ThermalAsperityRate),
        new SmartAttribute(0xCE, SmartNames.FlyingHeight),
        new SmartAttribute(0xCF, SmartNames.SpinHighCurrent),
        new SmartAttribute(0xD0, SmartNames.SpinBuzz),
        new SmartAttribute(0xD1, SmartNames.OfflineSeekPerformance),
        new SmartAttribute(0xD3, SmartNames.VibrationDuringWrite),
        new SmartAttribute(0xD4, SmartNames.ShockDuringWrite),
        new SmartAttribute(0xDC, SmartNames.DiskShift),
        new SmartAttribute(0xDD, SmartNames.AlternativeGSenseErrorRate),
        new SmartAttribute(0xDE, SmartNames.LoadedHours),
        new SmartAttribute(0xDF, SmartNames.LoadUnloadRetryCount),
        new SmartAttribute(0xE0, SmartNames.LoadFriction),
        new SmartAttribute(0xE1, SmartNames.LoadUnloadCycleCount),
        new SmartAttribute(0xE2, SmartNames.LoadInTime),
        new SmartAttribute(0xE3, SmartNames.TorqueAmplificationCount),
        new SmartAttribute(0xE4, SmartNames.PowerOffRetractCycle),
        new SmartAttribute(0xE6, SmartNames.GmrHeadAmplitude),
        new SmartAttribute(0xE8, SmartNames.EnduranceRemaining),
        new SmartAttribute(0xE9, SmartNames.PowerOnHours),
        new SmartAttribute(0xF0, SmartNames.HeadFlyingHours),
        new SmartAttribute(0xF1, SmartNames.TotalLbasWritten),
        new SmartAttribute(0xF2, SmartNames.TotalLbasRead),
        new SmartAttribute(0xFA, SmartNames.ReadErrorRetryRate),
        new SmartAttribute(0xFE, SmartNames.FreeFallProtection),
        new SmartAttribute(0xC2, SmartNames.Temperature, (r, _, p) => r[0] + (p?[0].Value ?? 0),
                           SensorType.Temperature, 0, SmartNames.Temperature, false,
                           new[] { new ParameterDescription("Offset [°C]", "Temperature offset of the thermal sensor.\n" + "Temperature = Value + Offset.", 0) }),
        new SmartAttribute(0xE7, SmartNames.Temperature, (r, _, p) => r[0] + (p?[0].Value ?? 0),
                           SensorType.Temperature, 0, SmartNames.Temperature, false,
                           new[] { new ParameterDescription("Offset [°C]", "Temperature offset of the thermal sensor.\n" + "Temperature = Value + Offset.", 0) }),
        new SmartAttribute(0xBE, SmartNames.TemperatureDifferenceFrom100, (r, _, p) => r[0] + (p?[0].Value ?? 0),
                           SensorType.Temperature, 0, "Temperature", false,
                           new[] { new ParameterDescription("Offset [°C]", "Temperature offset of the thermal sensor.\n" + "Temperature = Value + Offset.", 0) })
    };

    internal GenericHardDisk(StorageInfo storageInfo, ISmart smart, string name, string firmwareRevision, int index, ISettings settings)
        : base(storageInfo, smart, name, firmwareRevision, "hdd", index, _smartAttributes, settings) { }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/INVMeDrive.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Runtime.InteropServices;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

internal interface INVMeDrive
{
    SafeHandle Identify(StorageInfo storageInfo);

    bool IdentifyController(SafeHandle hDevice, out Kernel32.NVME_IDENTIFY_CONTROLLER_DATA data);

    bool HealthInfoLog(SafeHandle hDevice, out Kernel32.NVME_HEALTH_INFO_LOG data);
}
```

`LibreHardwareMonitorLib/Hardware/Storage/ISmart.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

public interface ISmart : IDisposable
{
    bool IsValid { get; }

    void Close();

    bool EnableSmart();

    Kernel32.SMART_ATTRIBUTE[] ReadSmartData();

    Kernel32.SMART_THRESHOLD[] ReadSmartThresholds();

    bool ReadNameAndFirmwareRevision(out string name, out string firmwareRevision);
}
```

`LibreHardwareMonitorLib/Hardware/Storage/NVMeGeneric.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Text;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

public sealed class NVMeGeneric : AbstractStorage
{
    private const ulong Scale = 1000000;
    private const ulong Units = 512;
    private readonly NVMeInfo _info;
    private readonly List<NVMeSensor> _sensors = new();

    /// <summary>
    /// Gets the SMART data.
    /// </summary>
    public NVMeSmart Smart { get; }

    private NVMeGeneric(StorageInfo storageInfo, NVMeInfo info, int index, ISettings settings)
        : base(storageInfo, info.Model, info.Revision, "nvme", index, settings)
    {
        Smart = new NVMeSmart(storageInfo);
        _info = info;
        CreateSensors();
    }

    private static NVMeInfo GetDeviceInfo(StorageInfo storageInfo)
    {
        var smart = new NVMeSmart(storageInfo);
        return smart.GetInfo();
    }

    internal static AbstractStorage CreateInstance(StorageInfo storageInfo, ISettings settings)
    {
        NVMeInfo nvmeInfo = GetDeviceInfo(storageInfo);
        return nvmeInfo == null ? null : new NVMeGeneric(storageInfo, nvmeInfo, storageInfo.Index, settings);
    }

    protected override void CreateSensors()
    {
        NVMeHealthInfo log = Smart.GetHealthInfo();
        if (log != null)
        {
            AddSensor("Temperature", 0, false, SensorType.Temperature, health => health.Temperature);
            AddSensor("Available Spare", 1, false, SensorType.Level, health => health.AvailableSpare);
            AddSensor("Available Spare Threshold", 2, false, SensorType.Level, health => health.AvailableSpareThreshold);
            AddSensor("Percentage Used", 3, false, SensorType.Level, health => health.PercentageUsed);
            AddSensor("Data Read", 4, false, SensorType.Data, health => UnitsToData(health.DataUnitRead));
            AddSensor("Data Written", 5, false, SensorType.Data, health => UnitsToData(health.DataUnitWritten));

            int sensorIdx = 6;
            for (int i = 0; i < log.TemperatureSensors.Length; i++)
            {
                int idx = i;
                if (log.TemperatureSensors[idx] > short.MinValue)
                {
                    AddSensor("Temperature " + (idx + 1), sensorIdx, false, SensorType.Temperature, health => health.TemperatureSensors[idx]);
                    sensorIdx++;
                }
            }
        }

        base.CreateSensors();
    }

    private void AddSensor(string name, int index, bool defaultHidden, SensorType sensorType, GetSensorValue getValue)
    {
        var sensor = new NVMeSensor(name, index, defaultHidden, sensorType, this, _settings, getValue)
        {
            Value = 0
        };
        ActivateSensor(sensor);
        _sensors.Add(sensor);
    }

    private static float UnitsToData(ulong u)
    {
        // one unit is 512 * 1000 bytes, return in GB (not GiB)
        return Units * u / Scale;
    }

    protected override void UpdateSensors()
    {
        NVMeHealthInfo health = Smart.GetHealthInfo();
        if (health == null)
            return;

        foreach (NVMeSensor sensor in _sensors)
            sensor.Update(health);
    }

    protected override void GetReport(StringBuilder r)
    {
        if (_info == null)
            return;

        r.AppendLine("PCI Vendor ID: 0x" + _info.VID.ToString("x04"));
        if (_info.VID != _info.SSVID)
            r.AppendLine("PCI Subsystem Vendor ID: 0x" + _info.VID.ToString("x04"));

        r.AppendLine("IEEE OUI Identifier: 0x" + _info.IEEE[2].ToString("x02") + _info.IEEE[1].ToString("x02") + _info.IEEE[0].ToString("x02"));
        r.AppendLine("Total NVM Capacity: " + _info.TotalCapacity);
        r.AppendLine("Unallocated NVM Capacity: " + _info.UnallocatedCapacity);
        r.AppendLine("Controller ID: " + _info.ControllerId);
        r.AppendLine("Number of Namespaces: " + _info.NumberNamespaces);

        NVMeHealthInfo health = Smart.GetHealthInfo();
        if (health == null)
            return;

        if (health.CriticalWarning == Kernel32.NVME_CRITICAL_WARNING.None)
            r.AppendLine("Critical Warning: -");
        else
        {
            if ((health.CriticalWarning & Kernel32.NVME_CRITICAL_WARNING.AvailableSpaceLow) != 0)
                r.AppendLine("Critical Warning: the available spare space has fallen below the threshold.");

            if ((health.CriticalWarning & Kernel32.NVME_CRITICAL_WARNING.TemperatureThreshold) != 0)
                r.AppendLine("Critical Warning: a temperature is above an over temperature threshold or below an under temperature threshold.");

            if ((health.CriticalWarning & Kernel32.NVME_CRITICAL_WARNING.ReliabilityDegraded) != 0)
                r.AppendLine("Critical Warning: the device reliability has been degraded due to significant media related errors or any internal error that degrades device reliability.");

            if ((health.CriticalWarning & Kernel32.NVME_CRITICAL_WARNING.ReadOnly) != 0)
                r.AppendLine("Critical Warning: the media has been placed in read only mode.");

            if ((health.CriticalWarning & Kernel32.NVME_CRITICAL_WARNING.VolatileMemoryBackupDeviceFailed) != 0)
                r.AppendLine("Critical Warning: the volatile memory backup device has failed.");
        }

        r.AppendLine("Temperature: " + health.Temperature + " Celsius");
        r.AppendLine("Available Spare: " + health.AvailableSpare + "%");
        r.AppendLine("Available Spare Threshold: " + health.AvailableSpareThreshold + "%");
        r.AppendLine("Percentage Used: " + health.PercentageUsed + "%");
        r.AppendLine("Data Units Read: " + health.DataUnitRead);
        r.AppendLine("Data Units Written: " + health.DataUnitWritten);
        r.AppendLine("Host Read Commands: " + health.HostReadCommands);
        r.AppendLine("Host Write Commands: " + health.HostWriteCommands);
        r.AppendLine("Controller Busy Time: " + health.ControllerBusyTime);
        r.AppendLine("Power Cycles: " + health.PowerCycle);
        r.AppendLine("Power On Hours: " + health.PowerOnHours);
        r.AppendLine("Unsafe Shutdowns: " + health.UnsafeShutdowns);
        r.AppendLine("Media Errors: " + health.MediaErrors);
        r.AppendLine("Number of Error Information Log Entries: " + health.ErrorInfoLogEntryCount);
        r.AppendLine("Warning Composite Temperature Time: " + health.WarningCompositeTemperatureTime);
        r.AppendLine("Critical Composite Temperature Time: " + health.CriticalCompositeTemperatureTime);
        for (int i = 0; i < health.TemperatureSensors.Length; i++)
        {
            if (health.TemperatureSensors[i] > short.MinValue)
                r.AppendLine("Temperature Sensor " + (i + 1) + ": " + health.TemperatureSensors[i] + " Celsius");
        }
    }

    public override void Close()
    {
        Smart?.Close();

        base.Close();
    }

    private delegate float GetSensorValue(NVMeHealthInfo health);

    private class NVMeSensor : Sensor
    {
        private readonly GetSensorValue _getValue;

        public NVMeSensor(string name, int index, bool defaultHidden, SensorType sensorType, Hardware hardware, ISettings settings, GetSensorValue getValue)
            : base(name, index, defaultHidden, sensorType, hardware, null, settings)
        {
            _getValue = getValue;
        }

        public void Update(NVMeHealthInfo health)
        {
            float v = _getValue(health);
            if (SensorType == SensorType.Temperature && v is < -1000 or > 1000)
                return;

            Value = v;
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/NVMeHealthInfo.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

public abstract class NVMeHealthInfo
{
    public byte AvailableSpare { get; protected set; }

    public byte AvailableSpareThreshold { get; protected set; }

    public ulong ControllerBusyTime { get; protected set; }

    public uint CriticalCompositeTemperatureTime { get; protected set; }

    public Kernel32.NVME_CRITICAL_WARNING CriticalWarning { get; protected set; }

    public ulong DataUnitRead { get; protected set; }

    public ulong DataUnitWritten { get; protected set; }

    public ulong ErrorInfoLogEntryCount { get; protected set; }

    public ulong HostReadCommands { get; protected set; }

    public ulong HostWriteCommands { get; protected set; }

    public ulong MediaErrors { get; protected set; }

    public byte PercentageUsed { get; protected set; }

    public ulong PowerCycle { get; protected set; }

    public ulong PowerOnHours { get; protected set; }

    public short Temperature { get; protected set; }

    public short[] TemperatureSensors { get; protected set; }

    public ulong UnsafeShutdowns { get; protected set; }

    public uint WarningCompositeTemperatureTime { get; protected set; }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/NVMeInfo.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Storage;

public abstract class NVMeInfo
{
    public ushort ControllerId { get; protected set; }

    public byte[] IEEE { get; protected set; }

    public int Index { get; protected set; }

    public string Model { get; protected set; }

    public uint NumberNamespaces { get; protected set; }

    public string Revision { get; protected set; }

    public string Serial { get; protected set; }

    public ushort SSVID { get; protected set; }

    public ulong TotalCapacity { get; protected set; }

    public ulong UnallocatedCapacity { get; protected set; }

    public ushort VID { get; protected set; }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/NVMeIntel.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;
using System.Text;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

internal class NVMeIntel : INVMeDrive
{
    //intel nvme access

    public SafeHandle Identify(StorageInfo storageInfo)
    {
        return NVMeWindows.IdentifyDevice(storageInfo);
    }

    public bool IdentifyController(SafeHandle hDevice, out Kernel32.NVME_IDENTIFY_CONTROLLER_DATA data)
    {
        data = Kernel32.CreateStruct<Kernel32.NVME_IDENTIFY_CONTROLLER_DATA>();
        if (hDevice?.IsInvalid != false)
            return false;

        bool result = false;

        Kernel32.NVME_PASS_THROUGH_IOCTL passThrough = Kernel32.CreateStruct<Kernel32.NVME_PASS_THROUGH_IOCTL>();
        passThrough.srb.HeaderLenght = (uint)Marshal.SizeOf<Kernel32.SRB_IO_CONTROL>();
        passThrough.srb.Signature = Encoding.ASCII.GetBytes(Kernel32.IntelNVMeMiniPortSignature1);
        passThrough.srb.Timeout = 10;
        passThrough.srb.ControlCode = Kernel32.NVME_PASS_THROUGH_SRB_IO_CODE;
        passThrough.srb.ReturnCode = 0;
        passThrough.srb.Length = (uint)Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>() - (uint)Marshal.SizeOf<Kernel32.SRB_IO_CONTROL>();
        passThrough.NVMeCmd = new uint[16];
        passThrough.NVMeCmd[0] = 6; //identify
        passThrough.NVMeCmd[10] = 1; //return to host
        passThrough.Direction = Kernel32.NVME_DIRECTION.NVME_FROM_DEV_TO_HOST;
        passThrough.QueueId = 0;
        passThrough.DataBufferLen = (uint)passThrough.DataBuffer.Length;
        passThrough.MetaDataLen = 0;
        passThrough.ReturnBufferLen = (uint)Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>();

        int length = Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>();
        IntPtr buffer = Marshal.AllocHGlobal(length);
        Marshal.StructureToPtr(passThrough, buffer, false);

        bool validTransfer = Kernel32.DeviceIoControl(hDevice, Kernel32.IOCTL.IOCTL_SCSI_MINIPORT, buffer, length, buffer, length, out _, IntPtr.Zero);
        if (validTransfer)
        {
            IntPtr offset = Marshal.OffsetOf<Kernel32.NVME_PASS_THROUGH_IOCTL>(nameof(Kernel32.NVME_PASS_THROUGH_IOCTL.DataBuffer));
            var newPtr = IntPtr.Add(buffer, offset.ToInt32());
            int finalSize = Marshal.SizeOf<Kernel32.NVME_IDENTIFY_CONTROLLER_DATA>();
            IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf<Kernel32.NVME_IDENTIFY_CONTROLLER_DATA>());
            Kernel32.RtlZeroMemory(ptr, finalSize);
            int len = Math.Min(finalSize, passThrough.DataBuffer.Length);
            Kernel32.RtlCopyMemory(ptr, newPtr, (uint)len);
            Marshal.FreeHGlobal(buffer);

            data = Marshal.PtrToStructure<Kernel32.NVME_IDENTIFY_CONTROLLER_DATA>(ptr);
            Marshal.FreeHGlobal(ptr);
            result = true;
        }
        else
        {
            Marshal.FreeHGlobal(buffer);
        }

        return result;
    }

    public bool HealthInfoLog(SafeHandle hDevice, out Kernel32.NVME_HEALTH_INFO_LOG data)
    {
        data = Kernel32.CreateStruct<Kernel32.NVME_HEALTH_INFO_LOG>();
        if (hDevice?.IsInvalid != false)
            return false;

        bool result = false;

        Kernel32.NVME_PASS_THROUGH_IOCTL passThrough = Kernel32.CreateStruct<Kernel32.NVME_PASS_THROUGH_IOCTL>();
        passThrough.srb.HeaderLenght = (uint)Marshal.SizeOf<Kernel32.SRB_IO_CONTROL>();
        passThrough.srb.Signature = Encoding.ASCII.GetBytes(Kernel32.IntelNVMeMiniPortSignature1);
        passThrough.srb.Timeout = 10;
        passThrough.srb.ControlCode = Kernel32.NVME_PASS_THROUGH_SRB_IO_CODE;
        passThrough.srb.ReturnCode = 0;
        passThrough.srb.Length = (uint)Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>() - (uint)Marshal.SizeOf<Kernel32.SRB_IO_CONTROL>();
        passThrough.NVMeCmd[0] = (uint)Kernel32.STORAGE_PROTOCOL_NVME_DATA_TYPE.NVMeDataTypeLogPage; // GetLogPage
        passThrough.NVMeCmd[1] = 0xFFFFFFFF; // address
        passThrough.NVMeCmd[10] = 0x007f0002; // uint cdw10 = 0x000000002 | (((size / 4) - 1) << 16);
        passThrough.Direction = Kernel32.NVME_DIRECTION.NVME_FROM_DEV_TO_HOST;
        passThrough.QueueId = 0;
        passThrough.DataBufferLen = (uint)passThrough.DataBuffer.Length;
        passThrough.MetaDataLen = 0;
        passThrough.ReturnBufferLen = (uint)Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>();

        int length = Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>();
        IntPtr buffer = Marshal.AllocHGlobal(length);
        Marshal.StructureToPtr(passThrough, buffer, false);

        bool validTransfer = Kernel32.DeviceIoControl(hDevice, Kernel32.IOCTL.IOCTL_SCSI_MINIPORT, buffer, length, buffer, length, out _, IntPtr.Zero);
        if (validTransfer)
        {
            IntPtr offset = Marshal.OffsetOf<Kernel32.NVME_PASS_THROUGH_IOCTL>(nameof(Kernel32.NVME_PASS_THROUGH_IOCTL.DataBuffer));
            var newPtr = IntPtr.Add(buffer, offset.ToInt32());
            data = Marshal.PtrToStructure<Kernel32.NVME_HEALTH_INFO_LOG>(newPtr);
            Marshal.FreeHGlobal(buffer);
            result = true;
        }
        else
        {
            Marshal.FreeHGlobal(buffer);
        }
        return result;
    }

    public static SafeHandle IdentifyDevice(StorageInfo storageInfo)
    {
        SafeHandle handle = Kernel32.OpenDevice(storageInfo.Scsi);
        if (handle?.IsInvalid != false)
            return null;

        Kernel32.NVME_PASS_THROUGH_IOCTL passThrough = Kernel32.CreateStruct<Kernel32.NVME_PASS_THROUGH_IOCTL>();
        passThrough.srb.HeaderLenght = (uint)Marshal.SizeOf<Kernel32.SRB_IO_CONTROL>();
        passThrough.srb.Signature = Encoding.ASCII.GetBytes(Kernel32.IntelNVMeMiniPortSignature1);
        passThrough.srb.Timeout = 10;
        passThrough.srb.ControlCode = Kernel32.NVME_PASS_THROUGH_SRB_IO_CODE;
        passThrough.srb.ReturnCode = 0;
        passThrough.srb.Length = (uint)Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>() - (uint)Marshal.SizeOf<Kernel32.SRB_IO_CONTROL>();
        passThrough.NVMeCmd = new uint[16];
        passThrough.NVMeCmd[0] = 6; //identify
        passThrough.NVMeCmd[10] = 1; //return to host
        passThrough.Direction = Kernel32.NVME_DIRECTION.NVME_FROM_DEV_TO_HOST;
        passThrough.QueueId = 0;
        passThrough.DataBufferLen = (uint)passThrough.DataBuffer.Length;
        passThrough.MetaDataLen = 0;
        passThrough.ReturnBufferLen = (uint)Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>();

        int length = Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>();
        IntPtr buffer = Marshal.AllocHGlobal(length);
        Marshal.StructureToPtr(passThrough, buffer, false);

        bool validTransfer = Kernel32.DeviceIoControl(handle, Kernel32.IOCTL.IOCTL_SCSI_MINIPORT, buffer, length, buffer, length, out _, IntPtr.Zero);
        Marshal.FreeHGlobal(buffer);

        if (validTransfer) { }
        else
        {
            handle.Close();
            handle = null;
        }
        return handle;
    }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/NVMeIntelRst.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;
using System.Text;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

internal class NVMeIntelRst : INVMeDrive
{
    //intel RST (raid) nvme access

    public SafeHandle Identify(StorageInfo storageInfo)
    {
        return NVMeWindows.IdentifyDevice(storageInfo);
    }

    public bool IdentifyController(SafeHandle hDevice, out Kernel32.NVME_IDENTIFY_CONTROLLER_DATA data)
    {
        data = Kernel32.CreateStruct<Kernel32.NVME_IDENTIFY_CONTROLLER_DATA>();
        if (hDevice?.IsInvalid != false)
            return false;

        bool result = false;

        Kernel32.NVME_PASS_THROUGH_IOCTL passThrough = Kernel32.CreateStruct<Kernel32.NVME_PASS_THROUGH_IOCTL>();
        passThrough.srb.HeaderLenght = (uint)Marshal.SizeOf<Kernel32.SRB_IO_CONTROL>();
        passThrough.srb.Signature = Encoding.ASCII.GetBytes(Kernel32.IntelNVMeMiniPortSignature2);
        passThrough.srb.Timeout = 10;
        passThrough.srb.ControlCode = Kernel32.NVME_PASS_THROUGH_SRB_IO_CODE;
        passThrough.srb.ReturnCode = 0;
        passThrough.srb.Length = (uint)Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>() - (uint)Marshal.SizeOf<Kernel32.SRB_IO_CONTROL>();
        passThrough.NVMeCmd = new uint[16];
        passThrough.NVMeCmd[0] = 6; //identify
        passThrough.NVMeCmd[10] = 1; //return to host
        passThrough.Direction = Kernel32.NVME_DIRECTION.NVME_FROM_DEV_TO_HOST;
        passThrough.QueueId = 0;
        passThrough.DataBufferLen = (uint)passThrough.DataBuffer.Length;
        passThrough.MetaDataLen = 0;
        passThrough.ReturnBufferLen = (uint)Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>();

        int length = Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>();
        IntPtr buffer = Marshal.AllocHGlobal(length);
        Marshal.StructureToPtr(passThrough, buffer, false);

        bool validTransfer = Kernel32.DeviceIoControl(hDevice, Kernel32.IOCTL.IOCTL_SCSI_MINIPORT, buffer, length, buffer, length, out _, IntPtr.Zero);
        if (validTransfer)
        {
            IntPtr offset = Marshal.OffsetOf<Kernel32.NVME_PASS_THROUGH_IOCTL>(nameof(Kernel32.NVME_PASS_THROUGH_IOCTL.DataBuffer));
            IntPtr newPtr = IntPtr.Add(buffer, offset.ToInt32());
            int finalSize = Marshal.SizeOf<Kernel32.NVME_IDENTIFY_CONTROLLER_DATA>();
            IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf<Kernel32.NVME_IDENTIFY_CONTROLLER_DATA>());
            Kernel32.RtlZeroMemory(ptr, finalSize);
            int len = Math.Min(finalSize, passThrough.DataBuffer.Length);
            Kernel32.RtlCopyMemory(ptr, newPtr, (uint)len);
            Marshal.FreeHGlobal(buffer);

            data = Marshal.PtrToStructure<Kernel32.NVME_IDENTIFY_CONTROLLER_DATA>(ptr);
            Marshal.FreeHGlobal(ptr);
            result = true;
        }
        else
        {
            Marshal.FreeHGlobal(buffer);
        }

        return result;
    }

    public bool HealthInfoLog(SafeHandle hDevice, out Kernel32.NVME_HEALTH_INFO_LOG data)
    {
        data = Kernel32.CreateStruct<Kernel32.NVME_HEALTH_INFO_LOG>();
        if (hDevice?.IsInvalid != false)
            return false;

        bool result = false;

        Kernel32.NVME_PASS_THROUGH_IOCTL passThrough = Kernel32.CreateStruct<Kernel32.NVME_PASS_THROUGH_IOCTL>();
        passThrough.srb.HeaderLenght = (uint)Marshal.SizeOf<Kernel32.SRB_IO_CONTROL>();
        passThrough.srb.Signature = Encoding.ASCII.GetBytes(Kernel32.IntelNVMeMiniPortSignature2);
        passThrough.srb.Timeout = 10;
        passThrough.srb.ControlCode = Kernel32.NVME_PASS_THROUGH_SRB_IO_CODE;
        passThrough.srb.ReturnCode = 0;
        passThrough.srb.Length = (uint)Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>() - (uint)Marshal.SizeOf<Kernel32.SRB_IO_CONTROL>();
        passThrough.NVMeCmd[0] = (uint)Kernel32.STORAGE_PROTOCOL_NVME_DATA_TYPE.NVMeDataTypeLogPage; // GetLogPage
        passThrough.NVMeCmd[1] = 0xFFFFFFFF; // address
        passThrough.NVMeCmd[10] = 0x007f0002; // uint cdw10 = 0x000000002 | (((size / 4) - 1) << 16);
        passThrough.Direction = Kernel32.NVME_DIRECTION.NVME_FROM_DEV_TO_HOST;
        passThrough.QueueId = 0;
        passThrough.DataBufferLen = (uint)passThrough.DataBuffer.Length;
        passThrough.MetaDataLen = 0;
        passThrough.ReturnBufferLen = (uint)Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>();

        int length = Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>();
        IntPtr buffer = Marshal.AllocHGlobal(length);
        Marshal.StructureToPtr(passThrough, buffer, false);

        bool validTransfer = Kernel32.DeviceIoControl(hDevice, Kernel32.IOCTL.IOCTL_SCSI_MINIPORT, buffer, length, buffer, length, out _, IntPtr.Zero);
        if (validTransfer)
        {
            IntPtr offset = Marshal.OffsetOf<Kernel32.NVME_PASS_THROUGH_IOCTL>(nameof(Kernel32.NVME_PASS_THROUGH_IOCTL.DataBuffer));
            IntPtr newPtr = IntPtr.Add(buffer, offset.ToInt32());
            data = Marshal.PtrToStructure<Kernel32.NVME_HEALTH_INFO_LOG>(newPtr);
            Marshal.FreeHGlobal(buffer);
            result = true;
        }
        else
        {
            Marshal.FreeHGlobal(buffer);
        }

        return result;
    }

    public static SafeHandle IdentifyDevice(StorageInfo storageInfo)
    {
        SafeHandle handle = Kernel32.OpenDevice(storageInfo.Scsi);
        if (handle?.IsInvalid != false)
            return null;

        Kernel32.NVME_PASS_THROUGH_IOCTL passThrough = Kernel32.CreateStruct<Kernel32.NVME_PASS_THROUGH_IOCTL>();
        passThrough.srb.HeaderLenght = (uint)Marshal.SizeOf<Kernel32.SRB_IO_CONTROL>();
        passThrough.srb.Signature = Encoding.ASCII.GetBytes(Kernel32.IntelNVMeMiniPortSignature2);
        passThrough.srb.Timeout = 10;
        passThrough.srb.ControlCode = Kernel32.NVME_PASS_THROUGH_SRB_IO_CODE;
        passThrough.srb.ReturnCode = 0;
        passThrough.srb.Length = (uint)Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>() - (uint)Marshal.SizeOf<Kernel32.SRB_IO_CONTROL>();
        passThrough.NVMeCmd = new uint[16];
        passThrough.NVMeCmd[0] = 6; //identify
        passThrough.NVMeCmd[10] = 1; //return to host
        passThrough.Direction = Kernel32.NVME_DIRECTION.NVME_FROM_DEV_TO_HOST;
        passThrough.QueueId = 0;
        passThrough.DataBufferLen = (uint)passThrough.DataBuffer.Length;
        passThrough.MetaDataLen = 0;
        passThrough.ReturnBufferLen = (uint)Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>();

        int length = Marshal.SizeOf<Kernel32.NVME_PASS_THROUGH_IOCTL>();
        IntPtr buffer = Marshal.AllocHGlobal(length);
        Marshal.StructureToPtr(passThrough, buffer, false);

        bool validTransfer = Kernel32.DeviceIoControl(handle, Kernel32.IOCTL.IOCTL_SCSI_MINIPORT, buffer, length, buffer, length, out _, IntPtr.Zero);
        Marshal.FreeHGlobal(buffer);

        if (validTransfer) { }
        else
        {
            handle.Close();
            handle = null;
        }
        return handle;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/NVMeSamsung.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Linq;
using System.Runtime.InteropServices;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

internal class NVMeSamsung : INVMeDrive
{
    //samsung nvme access
    //https://github.com/hiyohiyo/CrystalDiskInfo
    //https://github.com/hiyohiyo/CrystalDiskInfo/blob/master/AtaSmart.cpp

    public SafeHandle Identify(StorageInfo storageInfo)
    {
        return NVMeWindows.IdentifyDevice(storageInfo);
    }

    public bool IdentifyController(SafeHandle hDevice, out Kernel32.NVME_IDENTIFY_CONTROLLER_DATA data)
    {
        data = Kernel32.CreateStruct<Kernel32.NVME_IDENTIFY_CONTROLLER_DATA>();
        if (hDevice?.IsInvalid != false)
            return false;

        bool result = false;
        Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS buffers = Kernel32.CreateStruct<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>();

        buffers.Spt.Length = (ushort)Marshal.SizeOf<Kernel32.SCSI_PASS_THROUGH>();
        buffers.Spt.PathId = 0;
        buffers.Spt.TargetId = 0;
        buffers.Spt.Lun = 0;
        buffers.Spt.SenseInfoLength = 24;
        buffers.Spt.DataTransferLength = (uint)buffers.DataBuf.Length;
        buffers.Spt.TimeOutValue = 2;
        buffers.Spt.DataBufferOffset = Marshal.OffsetOf(typeof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS), nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.DataBuf));
        buffers.Spt.SenseInfoOffset = (uint)Marshal.OffsetOf(typeof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS), nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.SenseBuf));
        buffers.Spt.CdbLength = 16;
        buffers.Spt.Cdb[0] = 0xB5; // SECURITY PROTOCOL IN
        buffers.Spt.Cdb[1] = 0xFE; // Samsung Protocol
        buffers.Spt.Cdb[3] = 5; // Identify
        buffers.Spt.Cdb[8] = 0; // Transfer Length
        buffers.Spt.Cdb[9] = 0x40; // Transfer Length
        buffers.Spt.DataIn = (byte)Kernel32.SCSI_IOCTL_DATA.SCSI_IOCTL_DATA_OUT;
        buffers.DataBuf[0] = 1;

        int length = Marshal.SizeOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>();
        IntPtr buffer = Marshal.AllocHGlobal(length);
        Marshal.StructureToPtr(buffers, buffer, false);
        bool validTransfer = Kernel32.DeviceIoControl(hDevice, Kernel32.IOCTL.IOCTL_SCSI_PASS_THROUGH, buffer, length, buffer, length, out _, IntPtr.Zero);
        Marshal.FreeHGlobal(buffer);

        if (validTransfer)
        {
            //read data from samsung SSD
            buffers = Kernel32.CreateStruct<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>();
            buffers.Spt.Length = (ushort)Marshal.SizeOf<Kernel32.SCSI_PASS_THROUGH>();
            buffers.Spt.PathId = 0;
            buffers.Spt.TargetId = 0;
            buffers.Spt.Lun = 0;
            buffers.Spt.SenseInfoLength = 24;
            buffers.Spt.DataTransferLength = (uint)buffers.DataBuf.Length;
            buffers.Spt.TimeOutValue = 2;
            buffers.Spt.DataBufferOffset = Marshal.OffsetOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>(nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.DataBuf));
            buffers.Spt.SenseInfoOffset = (uint)Marshal.OffsetOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>(nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.SenseBuf));
            buffers.Spt.CdbLength = 16;
            buffers.Spt.Cdb[0] = 0xA2; // SECURITY PROTOCOL IN
            buffers.Spt.Cdb[1] = 0xFE; // Samsung Protocol
            buffers.Spt.Cdb[3] = 5; // Identify
            buffers.Spt.Cdb[8] = 2; // Transfer Length (high)
            buffers.Spt.Cdb[9] = 0; // Transfer Length (low)
            buffers.Spt.DataIn = (byte)Kernel32.SCSI_IOCTL_DATA.SCSI_IOCTL_DATA_IN;

            length = Marshal.SizeOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>();
            buffer = Marshal.AllocHGlobal(length);
            Marshal.StructureToPtr(buffers, buffer, false);

            validTransfer = Kernel32.DeviceIoControl(hDevice, Kernel32.IOCTL.IOCTL_SCSI_PASS_THROUGH, buffer, length, buffer, length, out _, IntPtr.Zero);
            if (validTransfer && buffers.DataBuf.Any(x => x != 0))
            {
                IntPtr offset = Marshal.OffsetOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>(nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.DataBuf));
                IntPtr newPtr = IntPtr.Add(buffer, offset.ToInt32());
                data = Marshal.PtrToStructure<Kernel32.NVME_IDENTIFY_CONTROLLER_DATA>(newPtr);
                Marshal.FreeHGlobal(buffer);
                result = true;
            }
            else
            {
                Marshal.FreeHGlobal(buffer);
            }
        }

        return result;
    }

    public bool HealthInfoLog(SafeHandle hDevice, out Kernel32.NVME_HEALTH_INFO_LOG data)
    {
        data = Kernel32.CreateStruct<Kernel32.NVME_HEALTH_INFO_LOG>();
        if (hDevice?.IsInvalid != false)
            return false;

        bool result = false;
        Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS buffers = Kernel32.CreateStruct<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>();

        buffers.Spt.Length = (ushort)Marshal.SizeOf<Kernel32.SCSI_PASS_THROUGH>();
        buffers.Spt.PathId = 0;
        buffers.Spt.TargetId = 0;
        buffers.Spt.Lun = 0;
        buffers.Spt.SenseInfoLength = 24;
        buffers.Spt.DataTransferLength = (uint)buffers.DataBuf.Length;
        buffers.Spt.TimeOutValue = 2;
        buffers.Spt.DataBufferOffset = Marshal.OffsetOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>(nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.DataBuf));
        buffers.Spt.SenseInfoOffset = (uint)Marshal.OffsetOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>(nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.SenseBuf));
        buffers.Spt.CdbLength = 16;
        buffers.Spt.Cdb[0] = 0xB5; // SECURITY PROTOCOL IN
        buffers.Spt.Cdb[1] = 0xFE; // Samsung Protocol
        buffers.Spt.Cdb[3] = 6; // Log Data
        buffers.Spt.Cdb[8] = 0; // Transfer Length
        buffers.Spt.Cdb[9] = 0x40; // Transfer Length
        buffers.Spt.DataIn = (byte)Kernel32.SCSI_IOCTL_DATA.SCSI_IOCTL_DATA_OUT;
        buffers.DataBuf[0] = 2;
        buffers.DataBuf[4] = 0xff;
        buffers.DataBuf[5] = 0xff;
        buffers.DataBuf[6] = 0xff;
        buffers.DataBuf[7] = 0xff;

        int length = Marshal.SizeOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>();
        IntPtr buffer = Marshal.AllocHGlobal(length);
        Marshal.StructureToPtr(buffers, buffer, false);
        bool validTransfer = Kernel32.DeviceIoControl(hDevice, Kernel32.IOCTL.IOCTL_SCSI_PASS_THROUGH, buffer, length, buffer, length, out _, IntPtr.Zero);
        Marshal.FreeHGlobal(buffer);

        if (validTransfer)
        {
            //read data from samsung SSD
            buffers = Kernel32.CreateStruct<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>();
            buffers.Spt.Length = (ushort)Marshal.SizeOf<Kernel32.SCSI_PASS_THROUGH>();
            buffers.Spt.PathId = 0;
            buffers.Spt.TargetId = 0;
            buffers.Spt.Lun = 0;
            buffers.Spt.SenseInfoLength = 24;
            buffers.Spt.DataTransferLength = (uint)buffers.DataBuf.Length;
            buffers.Spt.TimeOutValue = 2;
            buffers.Spt.DataBufferOffset = Marshal.OffsetOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>(nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.DataBuf));
            buffers.Spt.SenseInfoOffset = (uint)Marshal.OffsetOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>(nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.SenseBuf));
            buffers.Spt.CdbLength = 16;
            buffers.Spt.Cdb[0] = 0xA2; // SECURITY PROTOCOL IN
            buffers.Spt.Cdb[1] = 0xFE; // Samsung Protocol
            buffers.Spt.Cdb[3] = 6; // Log Data
            buffers.Spt.Cdb[8] = 2; // Transfer Length (high)
            buffers.Spt.Cdb[9] = 0; // Transfer Length (low)
            buffers.Spt.DataIn = (byte)Kernel32.SCSI_IOCTL_DATA.SCSI_IOCTL_DATA_IN;

            length = Marshal.SizeOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>();
            buffer = Marshal.AllocHGlobal(length);
            Marshal.StructureToPtr(buffers, buffer, false);

            validTransfer = Kernel32.DeviceIoControl(hDevice, Kernel32.IOCTL.IOCTL_SCSI_PASS_THROUGH, buffer, length, buffer, length, out _, IntPtr.Zero);
            if (validTransfer)
            {
                IntPtr offset = Marshal.OffsetOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>(nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.DataBuf));
                IntPtr newPtr = IntPtr.Add(buffer, offset.ToInt32());
                data = Marshal.PtrToStructure<Kernel32.NVME_HEALTH_INFO_LOG>(newPtr);
                Marshal.FreeHGlobal(buffer);
                result = true;
            }
            else
            {
                Marshal.FreeHGlobal(buffer);
            }
        }

        return result;
    }

    public static SafeHandle IdentifyDevice(StorageInfo storageInfo)
    {
        SafeHandle handle = Kernel32.OpenDevice(storageInfo.DeviceId);
        if (handle?.IsInvalid != false)
            return null;

        Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS buffers = Kernel32.CreateStruct<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>();

        buffers.Spt.Length = (ushort)Marshal.SizeOf<Kernel32.SCSI_PASS_THROUGH>();
        buffers.Spt.PathId = 0;
        buffers.Spt.TargetId = 0;
        buffers.Spt.Lun = 0;
        buffers.Spt.SenseInfoLength = 24;
        buffers.Spt.DataTransferLength = (uint)buffers.DataBuf.Length;
        buffers.Spt.TimeOutValue = 2;
        buffers.Spt.DataBufferOffset = Marshal.OffsetOf(typeof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS), nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.DataBuf));
        buffers.Spt.SenseInfoOffset = (uint)Marshal.OffsetOf(typeof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS), nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.SenseBuf));
        buffers.Spt.CdbLength = 16;
        buffers.Spt.Cdb[0] = 0xB5; // SECURITY PROTOCOL IN
        buffers.Spt.Cdb[1] = 0xFE; // Samsung Protocol
        buffers.Spt.Cdb[3] = 5; // Identify
        buffers.Spt.Cdb[8] = 0; // Transfer Length
        buffers.Spt.Cdb[9] = 0x40;
        buffers.Spt.DataIn = (byte)Kernel32.SCSI_IOCTL_DATA.SCSI_IOCTL_DATA_OUT;
        buffers.DataBuf[0] = 1;

        int length = Marshal.SizeOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>();
        IntPtr buffer = Marshal.AllocHGlobal(length);
        Marshal.StructureToPtr(buffers, buffer, false);
        bool validTransfer = Kernel32.DeviceIoControl(handle, Kernel32.IOCTL.IOCTL_SCSI_PASS_THROUGH, buffer, length, buffer, length, out _, IntPtr.Zero);
        Marshal.FreeHGlobal(buffer);

        if (validTransfer)
        {
            //read data from samsung SSD
            buffers = Kernel32.CreateStruct<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>();
            buffers.Spt.Length = (ushort)Marshal.SizeOf<Kernel32.SCSI_PASS_THROUGH>();
            buffers.Spt.PathId = 0;
            buffers.Spt.TargetId = 0;
            buffers.Spt.Lun = 0;
            buffers.Spt.SenseInfoLength = 24;
            buffers.Spt.DataTransferLength = (uint)buffers.DataBuf.Length;
            buffers.Spt.TimeOutValue = 2;
            buffers.Spt.DataBufferOffset = Marshal.OffsetOf(typeof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS), nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.DataBuf));
            buffers.Spt.SenseInfoOffset = (uint)Marshal.OffsetOf(typeof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS), nameof(Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS.SenseBuf));
            buffers.Spt.CdbLength = 16;
            buffers.Spt.Cdb[0] = 0xA2; // SECURITY PROTOCOL IN
            buffers.Spt.Cdb[1] = 0xFE; // Samsung Protocol
            buffers.Spt.Cdb[3] = 5; // Identify
            buffers.Spt.Cdb[8] = 2; // Transfer Length
            buffers.Spt.Cdb[9] = 0;
            buffers.Spt.DataIn = (byte)Kernel32.SCSI_IOCTL_DATA.SCSI_IOCTL_DATA_IN;

            length = Marshal.SizeOf<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>();
            buffer = Marshal.AllocHGlobal(length);
            Marshal.StructureToPtr(buffers, buffer, false);

            validTransfer = Kernel32.DeviceIoControl(handle, Kernel32.IOCTL.IOCTL_SCSI_PASS_THROUGH, buffer, length, buffer, length, out _, IntPtr.Zero);
            if (validTransfer)
            {
                Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS result = Marshal.PtrToStructure<Kernel32.SCSI_PASS_THROUGH_WITH_BUFFERS>(buffer);

                if (result.DataBuf.All(x => x == 0))
                {
                    handle.Close();
                    handle = null;
                }
            }
            else
            {
                handle.Close();
                handle = null;
            }

            Marshal.FreeHGlobal(buffer);
        }

        return handle;
    }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/NVMeSmart.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;
using System.Text;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

public class NVMeSmart : IDisposable
{
    private readonly int _driveNumber;
    private readonly SafeHandle _handle;

    internal NVMeSmart(StorageInfo storageInfo)
    {
        _driveNumber = storageInfo.Index;
        NVMeDrive = null;
        string name = storageInfo.Name;

        // Test Samsung protocol.
        if (NVMeDrive == null && name.IndexOf("Samsung", StringComparison.OrdinalIgnoreCase) > -1)
        {
            _handle = NVMeSamsung.IdentifyDevice(storageInfo);
            if (_handle != null)
            {
                NVMeDrive = new NVMeSamsung();
                if (!NVMeDrive.IdentifyController(_handle, out _))
                {
                    NVMeDrive = null;
                }
            }
        }

        // Test Intel protocol.
        if (NVMeDrive == null && name.IndexOf("Intel", StringComparison.OrdinalIgnoreCase) > -1)
        {
            _handle = NVMeIntel.IdentifyDevice(storageInfo);
            if (_handle != null)
            {
                NVMeDrive = new NVMeIntel();
            }
        }

        // Test Intel raid protocol.
        if (NVMeDrive == null && name.IndexOf("Intel", StringComparison.OrdinalIgnoreCase) > -1)
        {
            _handle = NVMeIntelRst.IdentifyDevice(storageInfo);
            if (_handle != null)
            {
                NVMeDrive = new NVMeIntelRst();
            }
        }

        // Test Windows generic driver protocol.
        if (NVMeDrive == null)
        {
            _handle = NVMeWindows.IdentifyDevice(storageInfo);
            if (_handle != null)
            {
                NVMeDrive = new NVMeWindows();
            }
        }
    }

    public bool IsValid
    {
        get
        {
            return _handle is { IsInvalid: false };
        }
    }

    internal INVMeDrive NVMeDrive { get; }

    public void Dispose()
    {
        Close();
    }

    private static string GetString(byte[] s)
    {
        return Encoding.ASCII.GetString(s).Trim('\t', '\n', '\r', ' ', '\0');
    }

    private static short KelvinToCelsius(ushort k)
    {
        return (short)(k > 0 ? k - 273 : short.MinValue);
    }

    private static short KelvinToCelsius(byte[] k)
    {
        return KelvinToCelsius(BitConverter.ToUInt16(k, 0));
    }

    public void Close()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected void Dispose(bool disposing)
    {
        if (disposing && _handle is { IsClosed: false })
        {
            _handle.Close();
        }
    }

    public Storage.NVMeInfo GetInfo()
    {
        if (_handle?.IsClosed != false)
            return null;

        bool valid = false;
        var data = new Kernel32.NVME_IDENTIFY_CONTROLLER_DATA();
        if (NVMeDrive != null)
            valid = NVMeDrive.IdentifyController(_handle, out data);

        if (!valid)
            return null;

        return new NVMeInfo(_driveNumber, data);
    }

    public Storage.NVMeHealthInfo GetHealthInfo()
    {
        if (_handle?.IsClosed != false)
            return null;

        bool valid = false;
        var data = new Kernel32.NVME_HEALTH_INFO_LOG();
        if (NVMeDrive != null)
            valid = NVMeDrive.HealthInfoLog(_handle, out data);

        if (!valid)
            return null;

        return new NVMeHealthInfo(data);
    }

    private class NVMeInfo : Storage.NVMeInfo
    {
        public NVMeInfo(int index, Kernel32.NVME_IDENTIFY_CONTROLLER_DATA data)
        {
            Index = index;
            VID = data.VID;
            SSVID = data.SSVID;
            Serial = GetString(data.SN);
            Model = GetString(data.MN);
            Revision = GetString(data.FR);
            IEEE = data.IEEE;
            TotalCapacity = BitConverter.ToUInt64(data.TNVMCAP, 0); // 128bit little endian
            UnallocatedCapacity = BitConverter.ToUInt64(data.UNVMCAP, 0);
            ControllerId = data.CNTLID;
            NumberNamespaces = data.NN;
        }
    }

    private class NVMeHealthInfo : Storage.NVMeHealthInfo
    {
        public NVMeHealthInfo(Kernel32.NVME_HEALTH_INFO_LOG log)
        {
            CriticalWarning = (Kernel32.NVME_CRITICAL_WARNING)log.CriticalWarning;
            Temperature = KelvinToCelsius(log.CompositeTemp);
            AvailableSpare = log.AvailableSpare;
            AvailableSpareThreshold = log.AvailableSpareThreshold;
            PercentageUsed = log.PercentageUsed;
            DataUnitRead = BitConverter.ToUInt64(log.DataUnitRead, 0);
            DataUnitWritten = BitConverter.ToUInt64(log.DataUnitWritten, 0);
            HostReadCommands = BitConverter.ToUInt64(log.HostReadCommands, 0);
            HostWriteCommands = BitConverter.ToUInt64(log.HostWriteCommands, 0);
            ControllerBusyTime = BitConverter.ToUInt64(log.ControllerBusyTime, 0);
            PowerCycle = BitConverter.ToUInt64(log.PowerCycles, 0);
            PowerOnHours = BitConverter.ToUInt64(log.PowerOnHours, 0);
            UnsafeShutdowns = BitConverter.ToUInt64(log.UnsafeShutdowns, 0);
            MediaErrors = BitConverter.ToUInt64(log.MediaAndDataIntegrityErrors, 0);
            ErrorInfoLogEntryCount = BitConverter.ToUInt64(log.NumberErrorInformationLogEntries, 0);
            WarningCompositeTemperatureTime = log.WarningCompositeTemperatureTime;
            CriticalCompositeTemperatureTime = log.CriticalCompositeTemperatureTime;

            TemperatureSensors = new short[log.TemperatureSensor.Length];
            for (int i = 0; i < TemperatureSensors.Length; i++)
                TemperatureSensors[i] = KelvinToCelsius(log.TemperatureSensor[i]);
        }
    }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/NVMeWindows.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

internal class NVMeWindows : INVMeDrive
{
    //windows generic driver nvme access

    public SafeHandle Identify(StorageInfo storageInfo)
    {
        return IdentifyDevice(storageInfo);
    }

    public bool IdentifyController(SafeHandle hDevice, out Kernel32.NVME_IDENTIFY_CONTROLLER_DATA data)
    {
        data = Kernel32.CreateStruct<Kernel32.NVME_IDENTIFY_CONTROLLER_DATA>();
        if (hDevice?.IsInvalid != false)
            return false;

        bool result = false;
        Kernel32.STORAGE_QUERY_BUFFER nptwb = Kernel32.CreateStruct<Kernel32.STORAGE_QUERY_BUFFER>();
        nptwb.ProtocolSpecific.ProtocolType = Kernel32.STORAGE_PROTOCOL_TYPE.ProtocolTypeNvme;
        nptwb.ProtocolSpecific.DataType = (uint)Kernel32.STORAGE_PROTOCOL_NVME_DATA_TYPE.NVMeDataTypeIdentify;
        nptwb.ProtocolSpecific.ProtocolDataRequestValue = (uint)Kernel32.STORAGE_PROTOCOL_NVME_PROTOCOL_DATA_REQUEST_VALUE.NVMeIdentifyCnsController;
        nptwb.ProtocolSpecific.ProtocolDataOffset = (uint)Marshal.SizeOf<Kernel32.STORAGE_PROTOCOL_SPECIFIC_DATA>();
        nptwb.ProtocolSpecific.ProtocolDataLength = (uint)nptwb.Buffer.Length;
        nptwb.PropertyId = Kernel32.STORAGE_PROPERTY_ID.StorageAdapterProtocolSpecificProperty;
        nptwb.QueryType = Kernel32.STORAGE_QUERY_TYPE.PropertyStandardQuery;

        int length = Marshal.SizeOf<Kernel32.STORAGE_QUERY_BUFFER>();
        IntPtr buffer = Marshal.AllocHGlobal(length);
        Marshal.StructureToPtr(nptwb, buffer, false);
        bool validTransfer = Kernel32.DeviceIoControl(hDevice, Kernel32.IOCTL.IOCTL_STORAGE_QUERY_PROPERTY, buffer, length, buffer, length, out _, IntPtr.Zero);
        if (validTransfer)
        {
            //map NVME_IDENTIFY_CONTROLLER_DATA to nptwb.Buffer
            IntPtr offset = Marshal.OffsetOf<Kernel32.STORAGE_QUERY_BUFFER>(nameof(Kernel32.STORAGE_QUERY_BUFFER.Buffer));
            var newPtr = IntPtr.Add(buffer, offset.ToInt32());
            data = Marshal.PtrToStructure<Kernel32.NVME_IDENTIFY_CONTROLLER_DATA>(newPtr);
            Marshal.FreeHGlobal(buffer);
            result = true;
        }
        else
        {
            Marshal.FreeHGlobal(buffer);
        }

        return result;
    }

    public bool HealthInfoLog(SafeHandle hDevice, out Kernel32.NVME_HEALTH_INFO_LOG data)
    {
        data = Kernel32.CreateStruct<Kernel32.NVME_HEALTH_INFO_LOG>();
        if (hDevice?.IsInvalid != false)
            return false;

        bool result = false;
        Kernel32.STORAGE_QUERY_BUFFER nptwb = Kernel32.CreateStruct<Kernel32.STORAGE_QUERY_BUFFER>();
        nptwb.ProtocolSpecific.ProtocolType = Kernel32.STORAGE_PROTOCOL_TYPE.ProtocolTypeNvme;
        nptwb.ProtocolSpecific.DataType = (uint)Kernel32.STORAGE_PROTOCOL_NVME_DATA_TYPE.NVMeDataTypeLogPage;
        nptwb.ProtocolSpecific.ProtocolDataRequestValue = (uint)Kernel32.NVME_LOG_PAGES.NVME_LOG_PAGE_HEALTH_INFO;
        nptwb.ProtocolSpecific.ProtocolDataOffset = (uint)Marshal.SizeOf<Kernel32.STORAGE_PROTOCOL_SPECIFIC_DATA>();
        nptwb.ProtocolSpecific.ProtocolDataLength = (uint)nptwb.Buffer.Length;
        nptwb.PropertyId = Kernel32.STORAGE_PROPERTY_ID.StorageAdapterProtocolSpecificProperty;
        nptwb.QueryType = Kernel32.STORAGE_QUERY_TYPE.PropertyStandardQuery;

        int length = Marshal.SizeOf<Kernel32.STORAGE_QUERY_BUFFER>();
        IntPtr buffer = Marshal.AllocHGlobal(length);
        Marshal.StructureToPtr(nptwb, buffer, false);
        bool validTransfer = Kernel32.DeviceIoControl(hDevice, Kernel32.IOCTL.IOCTL_STORAGE_QUERY_PROPERTY, buffer, length, buffer, length, out _, IntPtr.Zero);
        if (validTransfer)
        {
            //map NVME_HEALTH_INFO_LOG to nptwb.Buffer
            IntPtr offset = Marshal.OffsetOf<Kernel32.STORAGE_QUERY_BUFFER>(nameof(Kernel32.STORAGE_QUERY_BUFFER.Buffer));
            var newPtr = IntPtr.Add(buffer, offset.ToInt32());
            data = Marshal.PtrToStructure<Kernel32.NVME_HEALTH_INFO_LOG>(newPtr);
            Marshal.FreeHGlobal(buffer);
            result = true;
        }
        else
        {
            Marshal.FreeHGlobal(buffer);
        }

        return result;
    }

    public static SafeHandle IdentifyDevice(StorageInfo storageInfo)
    {
        SafeHandle handle = Kernel32.OpenDevice(storageInfo.DeviceId);
        if (handle?.IsInvalid != false)
            return null;

        Kernel32.STORAGE_QUERY_BUFFER nptwb = Kernel32.CreateStruct<Kernel32.STORAGE_QUERY_BUFFER>();
        nptwb.ProtocolSpecific.ProtocolType = Kernel32.STORAGE_PROTOCOL_TYPE.ProtocolTypeNvme;
        nptwb.ProtocolSpecific.DataType = (uint)Kernel32.STORAGE_PROTOCOL_NVME_DATA_TYPE.NVMeDataTypeIdentify;
        nptwb.ProtocolSpecific.ProtocolDataRequestValue = (uint)Kernel32.STORAGE_PROTOCOL_NVME_PROTOCOL_DATA_REQUEST_VALUE.NVMeIdentifyCnsController;
        nptwb.ProtocolSpecific.ProtocolDataOffset = (uint)Marshal.SizeOf<Kernel32.STORAGE_PROTOCOL_SPECIFIC_DATA>();
        nptwb.ProtocolSpecific.ProtocolDataLength = (uint)nptwb.Buffer.Length;
        nptwb.PropertyId = Kernel32.STORAGE_PROPERTY_ID.StorageAdapterProtocolSpecificProperty;
        nptwb.QueryType = Kernel32.STORAGE_QUERY_TYPE.PropertyStandardQuery;

        int length = Marshal.SizeOf<Kernel32.STORAGE_QUERY_BUFFER>();
        IntPtr buffer = Marshal.AllocHGlobal(length);
        Marshal.StructureToPtr(nptwb, buffer, false);
        bool validTransfer = Kernel32.DeviceIoControl(handle, Kernel32.IOCTL.IOCTL_STORAGE_QUERY_PROPERTY, buffer, length, buffer, length, out _, IntPtr.Zero);
        if (validTransfer)
        {
            Marshal.FreeHGlobal(buffer);
        }
        else
        {
            Marshal.FreeHGlobal(buffer);
            handle.Close();
            handle = null;
        }

        return handle;
    }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/NamePrefixAttribute.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;

namespace LibreHardwareMonitor.Hardware.Storage;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
internal class NamePrefixAttribute : Attribute
{
    public NamePrefixAttribute(string namePrefix)
    {
        Prefix = namePrefix;
    }

    public string Prefix { get; }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/RequireSmartAttribute.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;

namespace LibreHardwareMonitor.Hardware.Storage;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
internal class RequireSmartAttribute : Attribute
{
    public RequireSmartAttribute(byte attributeId)
    {
        AttributeId = attributeId;
    }

    public byte AttributeId { get; }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/SmartAttribute.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

public class SmartAttribute
{
    private readonly RawValueConversion _rawValueConversion;

    public delegate float RawValueConversion(byte[] rawValue, byte value, IReadOnlyList<IParameter> parameters);

    /// <summary>
    /// Initializes a new instance of the <see cref="SmartAttribute" /> class.
    /// </summary>
    /// <param name="id">The SMART id of the attribute.</param>
    /// <param name="name">The name of the attribute.</param>
    public SmartAttribute(byte id, string name) : this(id, name, null, null, 0, null)
    { }

    /// <summary>
    /// Initializes a new instance of the <see cref="SmartAttribute" /> class.
    /// </summary>
    /// <param name="id">The SMART id of the attribute.</param>
    /// <param name="name">The name of the attribute.</param>
    /// <param name="rawValueConversion">
    /// A delegate for converting the raw byte
    /// array into a value (or null to use the attribute value).
    /// </param>
    public SmartAttribute(byte id, string name, RawValueConversion rawValueConversion) : this(id, name, rawValueConversion, null, 0, null)
    { }

    /// <summary>
    /// Initializes a new instance of the <see cref="SmartAttribute" /> class.
    /// </summary>
    /// <param name="id">The SMART id of the attribute.</param>
    /// <param name="name">The name of the attribute.</param>
    /// <param name="rawValueConversion">
    /// A delegate for converting the raw byte
    /// array into a value (or null to use the attribute value).
    /// </param>
    /// <param name="sensorType">
    /// Type of the sensor or null if no sensor is to
    /// be created.
    /// </param>
    /// <param name="sensorChannel">
    /// If there exists more than one attribute with
    /// the same sensor channel and type, then a sensor is created only for the
    /// first attribute.
    /// </param>
    /// <param name="sensorName">
    /// The name to be used for the sensor, or null if
    /// no sensor is created.
    /// </param>
    /// <param name="defaultHiddenSensor">True to hide the sensor initially.</param>
    /// <param name="parameterDescriptions">
    /// Description for the parameters of the sensor
    /// (or null).
    /// </param>
    public SmartAttribute(byte id, string name, RawValueConversion rawValueConversion, SensorType? sensorType, int sensorChannel, string sensorName, bool defaultHiddenSensor = false, ParameterDescription[] parameterDescriptions = null)
    {
        Id = id;
        Name = name;
        _rawValueConversion = rawValueConversion;
        SensorType = sensorType;
        SensorChannel = sensorChannel;
        SensorName = sensorName;
        DefaultHiddenSensor = defaultHiddenSensor;
        ParameterDescriptions = parameterDescriptions;
    }

    public bool DefaultHiddenSensor { get; }

    public bool HasRawValueConversion => _rawValueConversion != null;

    /// <summary>
    /// Gets the SMART identifier.
    /// </summary>
    public byte Id { get; }

    public string Name { get; }

    public ParameterDescription[] ParameterDescriptions { get; }

    public int SensorChannel { get; }

    public string SensorName { get; }

    public SensorType? SensorType { get; }

    internal float ConvertValue(Kernel32.SMART_ATTRIBUTE value, IReadOnlyList<IParameter> parameters)
    {
        if (_rawValueConversion == null)
            return value.CurrentValue;
        return _rawValueConversion(value.RawValue, value.CurrentValue, parameters);
    }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/SmartNames.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Storage;

/// <summary>
/// Localization class for SMART attribute names.
/// </summary>
public static class SmartNames
{
    public static string AirflowTemperature => "Airflow Temperature";

    public static string AlternativeEraseFailCount => "Alternative Erase Fail Count";

    public static string AlternativeGSenseErrorRate => "Alternative G-Sense Error Rate";

    public static string AlternativeProgramFailCount => "Alternative Program Fail Count";

    public static string AvailableReservedSpace => "Available Reserved Space";

    public static string AverageEraseCount => "Average Erase Count";

    public static string BadBlockFullFlag => "Bad Block Full Flag";

    public static string BitErrors => "Bit Errors";

    public static string CalibrationRetryCount => "Calibration Retry Count";

    public static string CommandTimeout => "Command Timeout";

    public static string ControllerWritesToNand => "Controller Writes to NAND";

    public static string CorrectedErrors => "Corrected Errors";

    public static string CrcErrorCount => "CRC Error Count";

    public static string CurrentPendingSectorCount => "Current Pending Sector Count";

    public static string DataAddressMarkErrors => "Data Address Mark errors";

    public static string DiskShift => "Disk Shift";

    public static string DriveTemperature => "Drive Temperature";

    public static string EccRate => "ECC Rate";

    public static string EmergencyRetractCycleCount => "Emergency Retract Cycle Count";

    public static string EndToEndError => "End-to-End error";

    public static string EnduranceRemaining => "Endurance Remaining";

    public static string EraseFailCount => "Erase Fail Count";

    public static string EraseFailCountChip => "Erase Fail Count (Chip)";

    public static string EraseFailCountTotal => "Erase Fail Count (Total)";

    public static string EraseFailure => "Erase Failure";

    public static string ErrorCorrectionCount => "Error Correction Count";

    public static string ExceptionModeStatus => "Exception Mode Status";

    public static string FactoryBadBlockCount => "Factory Bad Block Count";

    public static string FlyingHeight => "Flying Height";

    public static string FreeFallProtection => "Free Fall Protection";

    public static string FTLProgramNANDPagesCount => "FTL Program NAND Pages Count";

    public static string GmrHeadAmplitude => "GMR Head Amplitude";

    public static string GSenseErrorRate => "G-sense Error Rate";

    public static string HardwareEccRecovered => "Hardware ECC Recovered";

    public static string HeadFlyingHours => "Head Flying Hours";

    public static string HeadStability => "Head Stability";

    public static string HighFlyWrites => "High Fly Writes";

    public static string HostProgramNANDPagesCount => "Host Program NAND Pages Count";

    public static string HostReads => "Host Reads";

    public static string HostWrites => "Host Writes";

    public static string HostWritesToController => "Host Writes to Controller";

    public static string InducedOpVibrationDetection => "Induced Op-Vibration Detection";

    public static string InitialBadBlockCount => "Initial Bad Block Count";

    public static string LoadCycleCount => "Load Cycle Count";

    public static string LoadedHours => "Loaded Hours";

    public static string LoadFriction => "Load Friction";

    public static string LoadInTime => "Load 'In'-time";

    public static string LoadUnloadCycleCount => "Load/Unload Cycle Count";

    public static string LoadUnloadCycleCountFujitsu => "Load/Unload Cycle Count (Fujitus)";

    public static string LoadUnloadRetryCount => "Load/Unload Retry Count";

    public static string MaxCellCycles => "Max Cell Cycles";

    public static string MaxErase => "Max Erase";

    public static string MediaWearOutIndicator => "Media Wear Out Indicator";

    public static string MinErase => "Min Erase";

    public static string MultiZoneErrorRate => "Multi-Zone Error Rate";

    public static string NewFailingBlockCount => "New Failing Block Count";

    public static string Non4KAlignedAccess => "Non-4k Aligned Access";

    public static string OfflineSeekPerformance => "Offline Seek Performance";

    public static string OffLineUncorrectableErrorCount => "Off-Line Uncorrectable Error Count";

    public static string PowerCycleCount => "Power Cycle Count";

    public static string PowerOffRetractCycle => "Power-Off Retract Cycle";

    public static string PowerOnHours => "Power-On Hours (POH)";

    public static string PowerRecoveryCount => "Power Recovery Count";

    public static string ProgramFailCount => "Program Fail Count";

    public static string ProgramFailCountChip => "Program Fail Count (Chip)";

    public static string ProgramFailCountTotal => "Program Fail Count (Total)";

    public static string ProgramFailure => "Program Failure";

    public static string RawReadErrorRate => "Raw Read Error Rate";

    public static string ReadChannelMargin => "Read Channel Margin";

    public static string ReadCommands => "Read Commands";

    public static string ReadErrorRate => "Read Error Rate";

    public static string ReadErrorRetryRate => "Read Error Retry Rate";

    public static string ReadFailure => "Read Failure";

    public static string ReallocatedNANDBlockCount => "Reallocated NAND Block Count";

    public static string ReallocatedSectorsCount => "Reallocated Sectors Count";

    public static string ReallocationEventCount => "Reallocation Event Count";

    public static string RecalibrationRetries => "Recalibration Retries";

    public static string RemainingLife => "Remaining Life";

    public static string ReportedUncorrectableErrors => "Reported Uncorrectable Errors";

    public static string RetiredBlockCount => "Retired Block Count";

    public static string RunOutCancel => "Run Out Cancel";

    public static string RuntimeBadBlockTotal => "Runtime Bad Block Total";

    public static string SataDownshiftErrorCount => "SATA Downshift Error Count";

    public static string SataErrorCountCrc => "SATA Error Count CRC";

    public static string SataErrorCountHandshake => "SATA Error Count Handshake";

    public static string SectorsRead => "Sectors Read";

    public static string SectorsWritten => "Sectors Written";

    public static string SeekErrorRate => "Seek Error Rate";

    public static string SeekTimePerformance => "Seek Time Performance";

    public static string ShockDuringWrite => "Shock During Write";

    public static string SoftEccCorrection => "Soft ECC Correction";

    public static string SoftReadErrorRate => "Soft Read Error Rate";

    public static string SpinBuzz => "Spin Buzz";

    public static string SpinHighCurrent => "Spin High Current";

    public static string SpinRetryCount => "Spin Retry Count";

    public static string SpinUpTime => "Spin-Up Time";

    public static string StartStopCount => "Start/Stop Count";

    public static string SuccessfulRAINRecoveryCount => "Successful RAIN Recovery Count";

    public static string SupercapStatus => "Supercap Status";

    public static string TaCounterDetected => "TA Counter Detected";

    public static string Temperature => "Temperature";

    public static string TemperatureDifferenceFrom100 => "Temperature Difference from 100";

    public static string TemperatureExceedCount => "Temperature Exceed Count";

    public static string ThermalAsperityRate => "Thermal Asperity Rate (TAR)";

    public static string ThroughputPerformance => "Throughput Performance";

    public static string TorqueAmplificationCount => "Torque Amplification Count";

    public static string TotalLbasRead => "Total LBAs Read";

    public static string TotalLbasWritten => "Total LBAs Written";

    public static string TransferErrorRate => "Transfer Error Rate";

    public static string UltraDmaCrcErrorCount => "UltraDMA CRC Error Count";

    public static string UncorrectableErrorCount => "Uncorrectable Error Count";

    public static string UncorrectableSectorCount => "Uncorrectable Sector Count";

    public static string UnexpectedPowerLossCount => "Unexpected Power Loss Count";

    public static string Unknown => "Unknown";

    public static string UnknownUnique => "Unknown Unique";

    public static string UnrecoverableEcc => "Unrecoverable ECC";

    public static string UnsafeShutdownCount => "Unsafe Shutdown Count";

    public static string UnusedReserveNANDBlocks => "Unused Reserve NAND Blocks";

    public static string UsedReservedBlockCountChip => "Used Reserved Block Count (Chip)";

    public static string UsedReservedBlockCountTotal => "Used Reserved Block Count (Total)";

    public static string VibrationDuringWrite => "Vibration During Write";

    public static string WearLevelingCount => "Wear Leveling Count";

    public static string WearRangeDelta => "Wear Range Delta";

    public static string WriteCommands => "Write Commands";

    public static string WriteErrorRate => "Write Error Rate";
}
```

`LibreHardwareMonitorLib/Hardware/Storage/SsdIndilinx.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Storage;

[NamePrefix(""), RequireSmart(0x01), RequireSmart(0x09), RequireSmart(0x0C), RequireSmart(0xD1), RequireSmart(0xCE), RequireSmart(0xCF)]
internal class SsdIndilinx : AtaStorage
{
    private static readonly IReadOnlyList<SmartAttribute> _smartAttributes = new List<SmartAttribute>
    {
        new(0x01, SmartNames.ReadErrorRate),
        new(0x09, SmartNames.PowerOnHours),
        new(0x0C, SmartNames.PowerCycleCount),
        new(0xB8, SmartNames.InitialBadBlockCount),
        new(0xC3, SmartNames.ProgramFailure),
        new(0xC4, SmartNames.EraseFailure),
        new(0xC5, SmartNames.ReadFailure),
        new(0xC6, SmartNames.SectorsRead),
        new(0xC7, SmartNames.SectorsWritten),
        new(0xC8, SmartNames.ReadCommands),
        new(0xC9, SmartNames.WriteCommands),
        new(0xCA, SmartNames.BitErrors),
        new(0xCB, SmartNames.CorrectedErrors),
        new(0xCC, SmartNames.BadBlockFullFlag),
        new(0xCD, SmartNames.MaxCellCycles),
        new(0xCE, SmartNames.MinErase),
        new(0xCF, SmartNames.MaxErase),
        new(0xD0, SmartNames.AverageEraseCount),
        new(0xD1, SmartNames.RemainingLife, null, SensorType.Level, 0, SmartNames.RemainingLife),
        new(0xD2, SmartNames.UnknownUnique),
        new(0xD3, SmartNames.SataErrorCountCrc),
        new(0xD4, SmartNames.SataErrorCountHandshake)
    };

    public SsdIndilinx(StorageInfo storageInfo, ISmart smart, string name, string firmwareRevision, int index, ISettings settings)
        : base(storageInfo, smart, name, firmwareRevision, "ssd", index, _smartAttributes, settings)
    { }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/SsdIntel.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Storage;

[NamePrefix("INTEL SSD"), RequireSmart(0xE1), RequireSmart(0xE8), RequireSmart(0xE9)]
internal class SsdIntel : AtaStorage
{
    private static readonly IReadOnlyList<SmartAttribute> _smartAttributes = new List<SmartAttribute>
    {
        new(0x01, SmartNames.ReadErrorRate),
        new(0x03, SmartNames.SpinUpTime),
        new(0x04, SmartNames.StartStopCount, RawToInt),
        new(0x05, SmartNames.ReallocatedSectorsCount),
        new(0x09, SmartNames.PowerOnHours, RawToInt),
        new(0x0C, SmartNames.PowerCycleCount, RawToInt),
        new(0xAA, SmartNames.AvailableReservedSpace),
        new(0xAB, SmartNames.ProgramFailCount),
        new(0xAC, SmartNames.EraseFailCount),
        new(0xAE, SmartNames.UnexpectedPowerLossCount, RawToInt),
        new(0xB7, SmartNames.SataDownshiftErrorCount, RawToInt),
        new(0xB8, SmartNames.EndToEndError),
        new(0xBB, SmartNames.UncorrectableErrorCount, RawToInt),
        new(0xBE,
            SmartNames.Temperature,
            (r, _, p) => r[0] + (p?[0].Value ?? 0),
            SensorType.Temperature,
            0,
            SmartNames.AirflowTemperature,
            false,
            new[] { new ParameterDescription("Offset [°C]", "Temperature offset of the thermal sensor.\nTemperature = Value + Offset.", 0) }),
        new(0xC0, SmartNames.UnsafeShutdownCount),
        new(0xC7, SmartNames.CrcErrorCount, RawToInt),
        new(0xE1, SmartNames.HostWrites, (r, v, p) => RawToInt(r, v, p) / 0x20, SensorType.Data, 0, SmartNames.HostWrites),
        new(0xE8, SmartNames.RemainingLife, null, SensorType.Level, 0, SmartNames.RemainingLife),
        new(0xE9, SmartNames.MediaWearOutIndicator),
        new(0xF1, SmartNames.HostWrites, (r, v, p) => RawToInt(r, v, p) / 0x20, SensorType.Data, 0, SmartNames.HostWrites),
        new(0xF2, SmartNames.HostReads, (r, v, p) => RawToInt(r, v, p) / 0x20, SensorType.Data, 1, SmartNames.HostReads)
    };

    public SsdIntel(StorageInfo storageInfo, ISmart smart, string name, string firmwareRevision, int index, ISettings settings)
        : base(storageInfo, smart, name, firmwareRevision, "ssd", index, _smartAttributes, settings)
    { }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/SsdMicron.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

[NamePrefix(""), RequireSmart(0xAB), RequireSmart(0xAC), RequireSmart(0xAD), RequireSmart(0xAE), RequireSmart(0xC4), RequireSmart(0xCA), RequireSmart(0xCE)]
internal class SsdMicron : AtaStorage
{
    private static readonly IReadOnlyList<SmartAttribute> _smartAttributes = new List<SmartAttribute>
    {
        new(0x01, SmartNames.ReadErrorRate, RawToInt),
        new(0x05, SmartNames.ReallocatedNANDBlockCount, RawToInt),
        new(0x09, SmartNames.PowerOnHours, RawToInt),
        new(0x0C, SmartNames.PowerCycleCount, RawToInt),
        new(0xAA, SmartNames.NewFailingBlockCount, RawToInt),
        new(0xAB, SmartNames.ProgramFailCount, RawToInt),
        new(0xAC, SmartNames.EraseFailCount, RawToInt),
        new(0xAD, SmartNames.WearLevelingCount, RawToInt),
        new(0xAE, SmartNames.UnexpectedPowerLossCount, RawToInt),
        new(0xB4, SmartNames.UnusedReserveNANDBlocks, RawToInt),
        new(0xB5, SmartNames.Non4KAlignedAccess, (raw, _, _) => 6e4f * ((raw[5] << 8) | raw[4])),
        new(0xB7, SmartNames.SataDownshiftErrorCount, RawToInt),
        new(0xB8, SmartNames.ErrorCorrectionCount, RawToInt),
        new(0xBB, SmartNames.ReportedUncorrectableErrors, RawToInt),
        new(0xBC, SmartNames.CommandTimeout, RawToInt),
        new(0xBD, SmartNames.FactoryBadBlockCount, RawToInt),
        new(0xC2, SmartNames.Temperature, RawToInt),
        new(0xC4, SmartNames.ReallocationEventCount, RawToInt),
        new(0xC5, SmartNames.CurrentPendingSectorCount),
        new(0xC6, SmartNames.OffLineUncorrectableErrorCount, RawToInt),
        new(0xC7, SmartNames.UltraDmaCrcErrorCount, RawToInt),
        new(0xCA, SmartNames.RemainingLife, (raw, value, p) => 100 - RawToInt(raw, value, p), SensorType.Level, 0, SmartNames.RemainingLife),
        new(0xCE, SmartNames.WriteErrorRate, (raw, _, _) => 6e4f * ((raw[1] << 8) | raw[0])),
        new(0xD2, SmartNames.SuccessfulRAINRecoveryCount, RawToInt),
        new(0xF6,
            SmartNames.TotalLbasWritten,
            (r, _, _) => (((long)r[5] << 40) |
                          ((long)r[4] << 32) |
                          ((long)r[3] << 24) |
                          ((long)r[2] << 16) |
                          ((long)r[1] << 8) |
                          r[0]) *
                         (512.0f / 1024 / 1024 / 1024),
            SensorType.Data,
            0,
            "Total Bytes Written"),
        new(0xF7, SmartNames.HostProgramNANDPagesCount, RawToInt),
        new(0xF8, SmartNames.FTLProgramNANDPagesCount, RawToInt)
    };

    private readonly Sensor _temperature;
    private readonly Sensor _writeAmplification;

    public SsdMicron(StorageInfo storageInfo, ISmart smart, string name, string firmwareRevision, int index, ISettings settings)
        : base(storageInfo, smart, name, firmwareRevision, "ssd", index, _smartAttributes, settings)
    {
        _temperature = new Sensor("Temperature",
                                  0,
                                  false,
                                  SensorType.Temperature,
                                  this,
                                  new[]
                                  {
                                      new ParameterDescription("Offset [°C]",
                                                               "Temperature offset of the thermal sensor.\n" +
                                                               "Temperature = Value + Offset.",
                                                               0)
                                  },
                                  settings);

        _writeAmplification = new Sensor("Write Amplification",
                                         0,
                                         SensorType.Factor,
                                         this,
                                         settings);
    }

    /// <inheritdoc />
    protected override void UpdateAdditionalSensors(Kernel32.SMART_ATTRIBUTE[] values)
    {
        float? hostProgramPagesCount = null;
        float? ftlProgramPagesCount = null;

        foreach (Kernel32.SMART_ATTRIBUTE value in values)
        {
            if (value.Id == 0xF7)
                hostProgramPagesCount = RawToInt(value.RawValue, value.CurrentValue, null);

            if (value.Id == 0xF8)
                ftlProgramPagesCount = RawToInt(value.RawValue, value.CurrentValue, null);

            if (value.Id == 0xC2)
            {
                _temperature.Value = value.RawValue[0] + _temperature.Parameters[0].Value;

                if (value.RawValue[0] != 0)
                    ActivateSensor(_temperature);
            }
        }

        if (hostProgramPagesCount.HasValue && ftlProgramPagesCount.HasValue)
        {
            _writeAmplification.Value = hostProgramPagesCount.Value > 0 ? (hostProgramPagesCount.Value + ftlProgramPagesCount) / hostProgramPagesCount.Value : 0;

            ActivateSensor(_writeAmplification);
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/SsdPlextor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Storage;

[NamePrefix("PLEXTOR")]
internal class SsdPlextor : AtaStorage
{
    private static readonly IReadOnlyList<SmartAttribute> _smartAttributes = new List<SmartAttribute>
    {
        new(0x09, SmartNames.PowerOnHours, RawToInt),
        new(0x0C, SmartNames.PowerCycleCount, RawToInt),
        new(0xF1, SmartNames.HostWrites, RawToGb, SensorType.Data, 0, SmartNames.HostWrites),
        new(0xF2, SmartNames.HostReads, RawToGb, SensorType.Data, 1, SmartNames.HostReads)
    };

    public SsdPlextor(StorageInfo storageInfo, ISmart smart, string name, string firmwareRevision, int index, ISettings settings)
        : base(storageInfo, smart, name, firmwareRevision, "ssd", index, _smartAttributes, settings)
    { }

    private static float RawToGb(byte[] rawValue, byte value, IReadOnlyList<IParameter> parameters)
    {
        return RawToInt(rawValue, value, parameters) / 32;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/SsdSamsung.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Storage;

[NamePrefix(""), RequireSmart(0xB1), RequireSmart(0xB3), RequireSmart(0xB5), RequireSmart(0xB6), RequireSmart(0xB7), RequireSmart(0xBB), RequireSmart(0xC3), RequireSmart(0xC7)]
internal class SsdSamsung : AtaStorage
{
    private static readonly IReadOnlyList<SmartAttribute> _smartAttributes = new List<SmartAttribute>
    {
        new(0x05, SmartNames.ReallocatedSectorsCount),
        new(0x09, SmartNames.PowerOnHours, RawToInt),
        new(0x0C, SmartNames.PowerCycleCount, RawToInt),
        new(0xAF, SmartNames.ProgramFailCountChip, RawToInt),
        new(0xB0, SmartNames.EraseFailCountChip, RawToInt),
        new(0xB1, SmartNames.WearLevelingCount, RawToInt),
        new(0xB2, SmartNames.UsedReservedBlockCountChip, RawToInt),
        new(0xB3, SmartNames.UsedReservedBlockCountTotal, RawToInt),

        // Unused Reserved Block Count (Total)
        new(0xB4, SmartNames.RemainingLife, null, SensorType.Level, 0, SmartNames.RemainingLife),
        new(0xB5, SmartNames.ProgramFailCountTotal, RawToInt),
        new(0xB6, SmartNames.EraseFailCountTotal, RawToInt),
        new(0xB7, SmartNames.RuntimeBadBlockTotal, RawToInt),
        new(0xBB, SmartNames.UncorrectableErrorCount, RawToInt),
        new(0xBE,
            SmartNames.Temperature,
            (r, _, p) => r[0] + (p?[0].Value ?? 0),
            SensorType.Temperature,
            0,
            SmartNames.Temperature,
            false,
            new[] { new ParameterDescription("Offset [°C]", "Temperature offset of the thermal sensor.\nTemperature = Value + Offset.", 0) }),
        new(0xC2, SmartNames.AirflowTemperature),
        new(0xC3, SmartNames.EccRate),
        new(0xC6, SmartNames.OffLineUncorrectableErrorCount, RawToInt),
        new(0xC7, SmartNames.CrcErrorCount, RawToInt),
        new(0xC9, SmartNames.SupercapStatus),
        new(0xCA, SmartNames.ExceptionModeStatus),
        new(0xEB, SmartNames.PowerRecoveryCount),
        new(0xF1,
            SmartNames.TotalLbasWritten,
            (r, _, _) => (((long)r[5] << 40) | ((long)r[4] << 32) | ((long)r[3] << 24) | ((long)r[2] << 16) | ((long)r[1] << 8) | r[0]) * (512.0f / 1024 / 1024 / 1024),
            SensorType.Data,
            0,
            "Total Bytes Written")
    };

    public SsdSamsung(StorageInfo storageInfo, ISmart smart, string name, string firmwareRevision, int index, ISettings settings)
        : base(storageInfo, smart, name, firmwareRevision, "ssd", index, _smartAttributes, settings)
    { }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/SsdSandforce.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

[NamePrefix(""), RequireSmart(0xAB), RequireSmart(0xB1)]
internal class SsdSandforce : AtaStorage
{
    private static readonly IReadOnlyList<SmartAttribute> _smartAttributes = new List<SmartAttribute>
    {
        new(0x01, SmartNames.RawReadErrorRate),
        new(0x05, SmartNames.RetiredBlockCount, RawToInt),
        new(0x09, SmartNames.PowerOnHours, RawToInt),
        new(0x0C, SmartNames.PowerCycleCount, RawToInt),
        new(0xAB, SmartNames.ProgramFailCount, RawToInt),
        new(0xAC, SmartNames.EraseFailCount, RawToInt),
        new(0xAE, SmartNames.UnexpectedPowerLossCount, RawToInt),
        new(0xB1, SmartNames.WearRangeDelta, RawToInt),
        new(0xB5, SmartNames.AlternativeProgramFailCount, RawToInt),
        new(0xB6, SmartNames.AlternativeEraseFailCount, RawToInt),
        new(0xBB, SmartNames.UncorrectableErrorCount, RawToInt),
        new(0xC2,
            SmartNames.Temperature,
            (_, value, p) => value + (p?[0].Value ?? 0),
            SensorType.Temperature,
            0,
            SmartNames.Temperature,
            true,
            new[] { new ParameterDescription("Offset [°C]", "Temperature offset of the thermal sensor.\nTemperature = Value + Offset.", 0) }),
        new(0xC3, SmartNames.UnrecoverableEcc),
        new(0xC4, SmartNames.ReallocationEventCount, RawToInt),
        new(0xE7, SmartNames.RemainingLife, null, SensorType.Level, 0, SmartNames.RemainingLife),
        new(0xE9, SmartNames.ControllerWritesToNand, RawToInt, SensorType.Data, 0, SmartNames.ControllerWritesToNand),
        new(0xEA, SmartNames.HostWritesToController, RawToInt, SensorType.Data, 1, SmartNames.HostWritesToController),
        new(0xF1, SmartNames.HostWrites, RawToInt, SensorType.Data, 1, SmartNames.HostWrites),
        new(0xF2, SmartNames.HostReads, RawToInt, SensorType.Data, 2, SmartNames.HostReads)
    };

    private readonly Sensor _writeAmplification;

    public SsdSandforce(StorageInfo storageInfo, ISmart smart, string name, string firmwareRevision, int index, ISettings settings)
        : base(storageInfo, smart, name, firmwareRevision, "ssd", index, _smartAttributes, settings)
    {
        _writeAmplification = new Sensor("Write Amplification", 1, SensorType.Factor, this, settings);
    }

    protected override void UpdateAdditionalSensors(Kernel32.SMART_ATTRIBUTE[] values)
    {
        float? controllerWritesToNand = null;
        float? hostWritesToController = null;
        foreach (Kernel32.SMART_ATTRIBUTE value in values)
        {
            if (value.Id == 0xE9)
                controllerWritesToNand = RawToInt(value.RawValue, value.CurrentValue, null);

            if (value.Id == 0xEA)
                hostWritesToController = RawToInt(value.RawValue, value.CurrentValue, null);
        }

        if (controllerWritesToNand.HasValue && hostWritesToController.HasValue)
        {
            if (hostWritesToController.Value > 0)
                _writeAmplification.Value = controllerWritesToNand.Value / hostWritesToController.Value;
            else
                _writeAmplification.Value = 0;

            ActivateSensor(_writeAmplification);
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/StorageGeneric.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Text;

namespace LibreHardwareMonitor.Hardware.Storage;

internal sealed class StorageGeneric : AbstractStorage
{
    private StorageGeneric(StorageInfo storageInfo, string name, string firmwareRevision, int index, ISettings settings)
        : base(storageInfo, name, firmwareRevision, "hdd", index, settings)
    {
        CreateSensors();
    }

    public static AbstractStorage CreateInstance(StorageInfo info, ISettings settings)
    {
        string name = string.IsNullOrEmpty(info.Name) ? "Generic Hard Disk" : info.Name;
        string firmwareRevision = string.IsNullOrEmpty(info.Revision) ? "Unknown" : info.Revision;
        return new StorageGeneric(info, name, firmwareRevision, info.Index, settings);
    }

    protected override void UpdateSensors() { }

    protected override void GetReport(StringBuilder r) { }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/StorageGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Management;

namespace LibreHardwareMonitor.Hardware.Storage;

#pragma warning disable CA1416 // Validate platform compatibility

internal class StorageGroup : IGroup
{
    private readonly List<AbstractStorage> _hardware = new();

    public StorageGroup(ISettings settings)
    {
        if (Software.OperatingSystem.IsUnix)
            return;

        Dictionary<uint, List<(uint, ulong)>> storageSpaceDiskToPhysicalDiskMap = GetStorageSpaceDiskToPhysicalDiskMap();
        AddHardware(settings, storageSpaceDiskToPhysicalDiskMap);
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    /// <summary>
    /// Adds the hardware.
    /// </summary>
    /// <param name="settings">The settings.</param>
    /// <param name="storageSpaceDiskToPhysicalDiskMap">The storage space disk to physical disk map.</param>
    private void AddHardware(ISettings settings, Dictionary<uint, List<(uint, ulong)>> storageSpaceDiskToPhysicalDiskMap)
    {
        try
        {
            // https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-diskdrive
            using var diskDriveSearcher = new ManagementObjectSearcher("SELECT * FROM Win32_DiskDrive") { Options = { Timeout = TimeSpan.FromSeconds(10) } };

            foreach (ManagementBaseObject diskDrive in diskDriveSearcher.Get())
            {
                string deviceId = (string)diskDrive.Properties["DeviceId"].Value; // is \\.\PhysicalDrive0..n
                uint index = Convert.ToUInt32(diskDrive.Properties["Index"].Value);
                ulong diskSize = Convert.ToUInt64(diskDrive.Properties["Size"].Value);
                int scsi = Convert.ToInt32(diskDrive.Properties["SCSIPort"].Value);

                if (deviceId != null)
                {
                    var instance = AbstractStorage.CreateInstance(deviceId, index, diskSize, scsi, settings);
                    if (instance != null)
                        _hardware.Add(instance);

                    if (storageSpaceDiskToPhysicalDiskMap.ContainsKey(index))
                    {
                        foreach ((uint, ulong) physicalDisk in storageSpaceDiskToPhysicalDiskMap[index])
                        {
                            var physicalDiskInstance = AbstractStorage.CreateInstance(@$"\\.\PHYSICALDRIVE{physicalDisk.Item1}", physicalDisk.Item1, physicalDisk.Item2, scsi, settings);
                            if (physicalDiskInstance != null)
                                _hardware.Add(physicalDiskInstance);
                        }
                    }
                }
            }
        }
        catch
        {
            // Ignored.
        }
    }

    /// <summary>
    /// Maps each StorageSpace to the PhysicalDisks it is composed of.
    /// </summary>
    private static Dictionary<uint, List<(uint, ulong)>> GetStorageSpaceDiskToPhysicalDiskMap()
    {
        var diskToPhysicalDisk = new Dictionary<uint, List<(uint, ulong)>>();

        if (!Software.OperatingSystem.IsWindows8OrGreater)
            return diskToPhysicalDisk;

        try
        {
            ManagementScope scope = new(@"\root\Microsoft\Windows\Storage");

            // https://learn.microsoft.com/en-us/previous-versions/windows/desktop/stormgmt/msft-disk
            // Lists all the disks visible to your system, the output is the same as Win32_DiskDrive.
            // If you're using a storage Space, the "hidden" disks which compose your storage space will not be listed.
            using var diskSearcher = new ManagementObjectSearcher(scope, new ObjectQuery("SELECT * FROM MSFT_Disk"));

            foreach (ManagementBaseObject disk in diskSearcher.Get())
            {
                try
                {
                    List<(uint, ulong)> map = MapDiskToPhysicalDisk(disk, scope);
                    if (map.Count > 0)
                        diskToPhysicalDisk[(uint)disk["Number"]] = map;
                }
                catch
                {
                    // Ignored.
                }
            }
        }
        catch
        {
            // Ignored.
        }

        return diskToPhysicalDisk;
    }

    /// <summary>
    /// Maps a disk to a physical disk.
    /// </summary>
    /// <param name="disk">The disk.</param>
    /// <param name="scope">The scope.</param>
    private static List<(uint, ulong)> MapDiskToPhysicalDisk(ManagementBaseObject disk, ManagementScope scope)
    {
        var map = new List<(uint, ulong)>();

        // https://learn.microsoft.com/en-us/previous-versions/windows/desktop/stormgmt/msft-virtualdisk
        // Maps the current Disk to its corresponding VirtualDisk. If the current Disk is not a storage space, it does not have a corresponding VirtualDisk.
        // Each Disk maps to one or zero VirtualDisk.
        using var toVirtualDisk = new ManagementObjectSearcher(scope, new ObjectQuery(FollowAssociationQuery("MSFT_Disk", (string)disk["ObjectId"], "MSFT_VirtualDiskToDisk")));

        foreach (ManagementBaseObject virtualDisk in toVirtualDisk.Get())
        {
            // https://learn.microsoft.com/en-us/previous-versions/windows/desktop/stormgmt/msft-physicaldisk
            // Maps the current VirtualDisk to the PhysicalDisk it is composed of.
            // Each VirtualDisk maps to one or more PhysicalDisk.

            using var toPhysicalDisk = new ManagementObjectSearcher(scope,
                                                                    new ObjectQuery(FollowAssociationQuery("MSFT_VirtualDisk",
                                                                                                           (string)virtualDisk["ObjectId"],
                                                                                                           "MSFT_VirtualDiskToPhysicalDisk")));

            foreach (ManagementBaseObject physicalDisk in toPhysicalDisk.Get())
            {
                ulong physicalDiskSize = (ulong)physicalDisk["Size"];

                if (uint.TryParse((string)physicalDisk["DeviceId"], out uint physicalDiskId))
                    map.Add((physicalDiskId, physicalDiskSize));
            }
        }

        return map;
    }

    private static string FollowAssociationQuery(string source, string objectId, string associationClass)
    {
        return @$"ASSOCIATORS OF {{{source}.ObjectId=""{objectId.Replace(@"\", @"\\").Replace(@"""", @"\""")}""}} WHERE AssocClass = {associationClass}";
    }

    public string GetReport()
    {
        return null;
    }

    public void Close()
    {
        foreach (AbstractStorage storage in _hardware)
            storage.Close();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/StorageInfo.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

internal abstract class StorageInfo
{
    public Kernel32.STORAGE_BUS_TYPE BusType { get; protected set; }

    public string DeviceId { get; set; }

    public ulong DiskSize { get; set; }

    public int Index { get; protected set; }

    public string Name => (Vendor + " " + Product).Trim();

    public string Product { get; protected set; }

    public byte[] RawData { get; protected set; }

    public bool Removable { get; protected set; }

    public string Revision { get; protected set; }

    public string Scsi { get; set; }

    public string Serial { get; protected set; }

    public string Vendor { get; protected set; }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/WindowsSmart.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

internal class WindowsSmart : ISmart
{
    private readonly int _driveNumber;
    private readonly SafeHandle _handle;

    public WindowsSmart(int driveNumber)
    {
        _driveNumber = driveNumber;
        _handle = Kernel32.CreateFile(@"\\.\PhysicalDrive" + driveNumber, FileAccess.ReadWrite, FileShare.ReadWrite, IntPtr.Zero, FileMode.Open, FileAttributes.Normal, IntPtr.Zero);
    }

    public bool IsValid => !_handle.IsInvalid && !_handle.IsClosed;

    public void Dispose()
    {
        Close();
    }

    public void Close()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    public bool EnableSmart()
    {
        if (_handle.IsClosed)
            throw new ObjectDisposedException(nameof(WindowsSmart));

        var parameter = new Kernel32.SENDCMDINPARAMS
        {
            bDriveNumber = (byte)_driveNumber,
            irDriveRegs = { bFeaturesReg = Kernel32.SMART_FEATURES.ENABLE_SMART, bCylLowReg = Kernel32.SMART_LBA_MID, bCylHighReg = Kernel32.SMART_LBA_HI, bCommandReg = Kernel32.ATA_COMMAND.ATA_SMART}
        };

        return Kernel32.DeviceIoControl(_handle, Kernel32.DFP.DFP_SEND_DRIVE_COMMAND, ref parameter, Marshal.SizeOf(parameter),
                                        out Kernel32.SENDCMDOUTPARAMS _, Marshal.SizeOf<Kernel32.SENDCMDOUTPARAMS>(), out _, IntPtr.Zero);
    }

    public Kernel32.SMART_ATTRIBUTE[] ReadSmartData()
    {
        if (_handle.IsClosed)
            throw new ObjectDisposedException(nameof(WindowsSmart));

        var parameter = new Kernel32.SENDCMDINPARAMS
        {
            bDriveNumber = (byte)_driveNumber, irDriveRegs = {
                bFeaturesReg = Kernel32.SMART_FEATURES.SMART_READ_DATA,
                bCylLowReg = Kernel32.SMART_LBA_MID,
                bCylHighReg = Kernel32.SMART_LBA_HI,
                bCommandReg = Kernel32.ATA_COMMAND.ATA_SMART
            }
        };

        bool isValid = Kernel32.DeviceIoControl(_handle, Kernel32.DFP.DFP_RECEIVE_DRIVE_DATA, ref parameter, Marshal.SizeOf(parameter),
                                                out Kernel32.ATTRIBUTECMDOUTPARAMS result, Marshal.SizeOf<Kernel32.ATTRIBUTECMDOUTPARAMS>(), out _, IntPtr.Zero);

        return isValid ? result.Attributes : Array.Empty<Kernel32.SMART_ATTRIBUTE>();
    }

    public Kernel32.SMART_THRESHOLD[] ReadSmartThresholds()
    {
        if (_handle.IsClosed)
            throw new ObjectDisposedException(nameof(WindowsSmart));

        var parameter = new Kernel32.SENDCMDINPARAMS
        {
            bDriveNumber = (byte)_driveNumber, irDriveRegs = {
                bFeaturesReg = Kernel32.SMART_FEATURES.READ_THRESHOLDS,
                bCylLowReg = Kernel32.SMART_LBA_MID,
                bCylHighReg = Kernel32.SMART_LBA_HI,
                bCommandReg = Kernel32.ATA_COMMAND.ATA_SMART
            }
        };

        bool isValid = Kernel32.DeviceIoControl(_handle, Kernel32.DFP.DFP_RECEIVE_DRIVE_DATA, ref parameter, Marshal.SizeOf(parameter),
                                                out Kernel32.THRESHOLDCMDOUTPARAMS result, Marshal.SizeOf<Kernel32.THRESHOLDCMDOUTPARAMS>(), out _, IntPtr.Zero);

        return isValid ? result.Thresholds : Array.Empty<Kernel32.SMART_THRESHOLD>();
    }

    public bool ReadNameAndFirmwareRevision(out string name, out string firmwareRevision)
    {
        if (_handle.IsClosed)
            throw new ObjectDisposedException(nameof(WindowsSmart));

        var parameter = new Kernel32.SENDCMDINPARAMS
        {
            bDriveNumber = (byte)_driveNumber,
            irDriveRegs = { bCommandReg = Kernel32.ATA_COMMAND.ATA_IDENTIFY_DEVICE }
        };

        bool valid = Kernel32.DeviceIoControl(_handle, Kernel32.DFP.DFP_RECEIVE_DRIVE_DATA, ref parameter, Marshal.SizeOf(parameter),
                                              out Kernel32.IDENTIFYCMDOUTPARAMS result, Marshal.SizeOf<Kernel32.IDENTIFYCMDOUTPARAMS>(), out _, IntPtr.Zero);

        if (!valid)
        {
            name = null;
            firmwareRevision = null;
            return false;
        }

        name = GetString(result.Identify.ModelNumber);
        firmwareRevision = GetString(result.Identify.FirmwareRevision);
        return true;
    }

    /// <summary>
    /// Reads Smart health status of the drive
    /// </summary>
    /// <returns>True, if drive is healthy; False, if unhealthy; Null, if it cannot be read</returns>
    public bool? ReadSmartHealth()
    {
        if (_handle.IsClosed)
            throw new ObjectDisposedException(nameof(WindowsSmart));

        var parameter = new Kernel32.SENDCMDINPARAMS
        {
            bDriveNumber = (byte)_driveNumber,
            irDriveRegs = {
                bFeaturesReg = Kernel32.SMART_FEATURES.RETURN_SMART_STATUS,
                bCylLowReg = Kernel32.SMART_LBA_MID,
                bCylHighReg = Kernel32.SMART_LBA_HI,
                bCommandReg = Kernel32.ATA_COMMAND.ATA_SMART
            }
        };

        bool isValid = Kernel32.DeviceIoControl(_handle, Kernel32.DFP.DFP_SEND_DRIVE_COMMAND, ref parameter, Marshal.SizeOf(parameter),
                                                out Kernel32.STATUSCMDOUTPARAMS result, Marshal.SizeOf<Kernel32.STATUSCMDOUTPARAMS>(), out _, IntPtr.Zero);

        if (!isValid)
        {
            return null;
        }

        // reference: https://github.com/smartmontools/smartmontools/blob/master/smartmontools/atacmds.cpp
        if (Kernel32.SMART_LBA_HI == result.irDriveRegs.bCylHighReg && Kernel32.SMART_LBA_MID == result.irDriveRegs.bCylLowReg)
        {
            // high and mid registers are unchanged, which means that the drive is healthy
            return true;
        }

        if (Kernel32.SMART_LBA_HI_EXCEEDED == result.irDriveRegs.bCylHighReg && Kernel32.SMART_LBA_MID_EXCEEDED == result.irDriveRegs.bCylLowReg)
        {
            // high and mid registers are exceeded, which means that the drive is unhealthy
            return false;
        }
        // response is not clear
        return null;
    }

    protected void Dispose(bool disposing)
    {
        if (disposing && !_handle.IsClosed)
        {
            _handle.Close();
        }
    }

    private static string GetString(IReadOnlyList<byte> bytes)
    {
        char[] chars = new char[bytes.Count];
        for (int i = 0; i < bytes.Count; i += 2)
        {
            chars[i] = (char)bytes[i + 1];
            chars[i + 1] = (char)bytes[i];
        }
        return new string(chars).Trim(' ', '\0');
    }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/WindowsStorage.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Management;
using System.Runtime.InteropServices;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Storage;

internal static class WindowsStorage
{
    public static Storage.StorageInfo GetStorageInfo(string deviceId, uint driveIndex)
    {
        using SafeHandle handle = Kernel32.OpenDevice(deviceId);

        if (handle?.IsInvalid != false)
            return null;

        var query = new Kernel32.STORAGE_PROPERTY_QUERY { PropertyId = Kernel32.STORAGE_PROPERTY_ID.StorageDeviceProperty, QueryType = Kernel32.STORAGE_QUERY_TYPE.PropertyStandardQuery };

        if (!Kernel32.DeviceIoControl(handle,
                                      Kernel32.IOCTL.IOCTL_STORAGE_QUERY_PROPERTY,
                                      ref query,
                                      Marshal.SizeOf(query),
                                      out Kernel32.STORAGE_DEVICE_DESCRIPTOR_HEADER header,
                                      Marshal.SizeOf<Kernel32.STORAGE_DEVICE_DESCRIPTOR_HEADER>(),
                                      out _,
                                      IntPtr.Zero))
        {
            return null;
        }

        IntPtr descriptorPtr = Marshal.AllocHGlobal((int)header.Size);

        try
        {
            return Kernel32.DeviceIoControl(handle, Kernel32.IOCTL.IOCTL_STORAGE_QUERY_PROPERTY, ref query, Marshal.SizeOf(query), descriptorPtr, header.Size, out uint bytesReturned, IntPtr.Zero)
                ? new StorageInfo((int)driveIndex, descriptorPtr)
                : null;
        }
        finally
        {
            Marshal.FreeHGlobal(descriptorPtr);
        }
    }

    public static string[] GetLogicalDrives(int driveIndex)
    {
        var list = new List<string>();

        try
        {
            using var s = new ManagementObjectSearcher("root\\CIMV2", "SELECT * FROM Win32_DiskPartition " + "WHERE DiskIndex = " + driveIndex);

            foreach (ManagementBaseObject o in s.Get())
            {
                if (o is ManagementObject dp)
                {
                    foreach (ManagementBaseObject ld in dp.GetRelated("Win32_LogicalDisk"))
                        list.Add(((string)ld["Name"]).TrimEnd(':'));
                }
            }
        }
        catch
        {
            // Ignored.
        }

        return list.ToArray();
    }

    private class StorageInfo : Storage.StorageInfo
    {
        public StorageInfo(int index, IntPtr descriptorPtr)
        {
            Kernel32.STORAGE_DEVICE_DESCRIPTOR descriptor = Marshal.PtrToStructure<Kernel32.STORAGE_DEVICE_DESCRIPTOR>(descriptorPtr);
            Index = index;
            Vendor = GetString(descriptorPtr, descriptor.VendorIdOffset);
            Product = GetString(descriptorPtr, descriptor.ProductIdOffset);
            Revision = GetString(descriptorPtr, descriptor.ProductRevisionOffset);
            Serial = GetString(descriptorPtr, descriptor.SerialNumberOffset);
            BusType = descriptor.BusType;
            Removable = descriptor.RemovableMedia;
            RawData = new byte[descriptor.Size];
            Marshal.Copy(descriptorPtr, RawData, 0, RawData.Length);
        }

        private static string GetString(IntPtr descriptorPtr, uint offset)
        {
            return offset > 0 ? Marshal.PtrToStringAnsi(IntPtr.Add(descriptorPtr, (int)offset))?.Trim() : string.Empty;
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/ThreadAffinity.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware;

internal static class ThreadAffinity
{
    /// <summary>
    /// Initializes static members of the <see cref="ThreadAffinity" /> class.
    /// </summary>
    static ThreadAffinity()
    {
        ProcessorGroupCount = Software.OperatingSystem.IsUnix ? 1 : Kernel32.GetActiveProcessorGroupCount();

        if (ProcessorGroupCount < 1)
            ProcessorGroupCount = 1;
    }

    /// <summary>
    /// Gets the processor group count.
    /// </summary>
    public static int ProcessorGroupCount { get; }

    /// <summary>
    /// Returns true if the <paramref name="affinity"/> is valid.
    /// </summary>
    /// <param name="affinity">The affinity.</param>
    /// <returns><c>true</c> if the specified affinity is valid; otherwise, <c>false</c>.</returns>
    public static bool IsValid(GroupAffinity affinity)
    {
        if (Software.OperatingSystem.IsUnix)
        {
            if (affinity.Group > 0)
                return false;

            return true;
        }

        UIntPtr uIntPtrMask;
        try
        {
            uIntPtrMask = (UIntPtr)affinity.Mask;
        }
        catch (OverflowException)
        {
            return false;
        }

        return true;
    }

    /// <summary>
    /// Sets the processor group affinity for the current thread.
    /// </summary>
    /// <param name="affinity">The processor group affinity.</param>
    /// <returns>The previous processor group affinity.</returns>
    public static GroupAffinity Set(GroupAffinity affinity)
    {
        if (affinity == GroupAffinity.Undefined)
            return GroupAffinity.Undefined;

        if (Software.OperatingSystem.IsUnix)
        {
            if (affinity.Group > 0)
                throw new ArgumentOutOfRangeException(nameof(affinity));

            ulong result = 0;
            if (LibC.sched_getaffinity(0, (IntPtr)8, ref result) != 0)
                return GroupAffinity.Undefined;

            ulong mask = affinity.Mask;
            if (LibC.sched_setaffinity(0, (IntPtr)8, ref mask) != 0)
                return GroupAffinity.Undefined;

            return new GroupAffinity(0, result);
        }

        UIntPtr uIntPtrMask;
        try
        {
            uIntPtrMask = (UIntPtr)affinity.Mask;
        }
        catch (OverflowException)
        {
            throw new ArgumentOutOfRangeException(nameof(affinity));
        }

        var groupAffinity = new Kernel32.GROUP_AFFINITY { Group = affinity.Group, Mask = uIntPtrMask };

        IntPtr currentThread = Kernel32.GetCurrentThread();

        if (Kernel32.SetThreadGroupAffinity(currentThread,
                                            ref groupAffinity,
                                            out Kernel32.GROUP_AFFINITY previousGroupAffinity))
        {
            return new GroupAffinity(previousGroupAffinity.Group, (ulong)previousGroupAffinity.Mask);
        }

        return GroupAffinity.Undefined;
    }
}
```

`LibreHardwareMonitorLib/Interop/AdvApi32.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Interop;

internal class AdvApi32
{
    private const string DllName = "advapi32.dll";

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern IntPtr OpenSCManager(string lpMachineName, string lpDatabaseName, SC_MANAGER_ACCESS_MASK dwDesiredAccess);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool CloseServiceHandle(IntPtr hSCObject);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern IntPtr CreateService
    (
        IntPtr hSCManager,
        string lpServiceName,
        string lpDisplayName,
        SERVICE_ACCESS_MASK dwDesiredAccess,
        SERVICE_TYPE dwServiceType,
        SERVICE_START dwStartType,
        SERVICE_ERROR dwErrorControl,
        string lpBinaryPathName,
        string lpLoadOrderGroup,
        string lpdwTagId,
        string lpDependencies,
        string lpServiceStartName,
        string lpPassword);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern IntPtr OpenService(IntPtr hSCManager, string lpServiceName, SERVICE_ACCESS_MASK dwDesiredAccess);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeleteService(IntPtr hService);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool StartService(IntPtr hService, uint dwNumServiceArgs, string[] lpServiceArgVectors);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool ControlService(IntPtr hService, SERVICE_CONTROL dwControl, ref SERVICE_STATUS lpServiceStatus);

    [Flags]
    internal enum SC_MANAGER_ACCESS_MASK : uint
    {
        SC_MANAGER_CONNECT = 0x00001,
        SC_MANAGER_CREATE_SERVICE = 0x00002,
        SC_MANAGER_ENUMERATE_SERVICE = 0x00004,
        SC_MANAGER_LOCK = 0x00008,
        SC_MANAGER_QUERY_LOCK_STATUS = 0x00010,
        SC_MANAGER_MODIFY_BOOT_CONFIG = 0x00020,
        SC_MANAGER_ALL_ACCESS = 0xF003F
    }

    internal enum SERVICE_ACCESS_MASK : uint
    {
        SERVICE_QUERY_CONFIG = 0x00001,
        SERVICE_CHANGE_CONFIG = 0x00002,
        SERVICE_QUERY_STATUS = 0x00004,
        SERVICE_ENUMERATE_DEPENDENTS = 0x00008,
        SERVICE_START = 0x00010,
        SERVICE_STOP = 0x00020,
        SERVICE_PAUSE_CONTINUE = 0x00040,
        SERVICE_INTERROGATE = 0x00080,
        SERVICE_USER_DEFINED_CONTROL = 0x00100,
        SERVICE_ALL_ACCESS = 0xF01FF
    }

    internal enum SERVICE_TYPE : uint
    {
        SERVICE_DRIVER = 0x0000000B,
        SERVICE_WIN32 = 0x00000030,
        SERVICE_ADAPTER = 0x00000004,
        SERVICE_FILE_SYSTEM_DRIVER = 0x00000002,
        SERVICE_KERNEL_DRIVER = 0x00000001,
        SERVICE_RECOGNIZER_DRIVER = 0x00000008,
        SERVICE_WIN32_OWN_PROCESS = 0x00000010,
        SERVICE_WIN32_SHARE_PROCESS = 0x00000020,
        SERVICE_USER_OWN_PROCESS = 0x00000050,
        SERVICE_USER_SHARE_PROCESS = 0x00000060,
        SERVICE_INTERACTIVE_PROCESS = 0x00000100
    }

    internal enum SERVICE_START : uint
    {
        SERVICE_BOOT_START = 0,
        SERVICE_SYSTEM_START = 1,
        SERVICE_AUTO_START = 2,
        SERVICE_DEMAND_START = 3,
        SERVICE_DISABLED = 4
    }

    internal enum SERVICE_ERROR : uint
    {
        SERVICE_ERROR_IGNORE = 0,
        SERVICE_ERROR_NORMAL = 1,
        SERVICE_ERROR_SEVERE = 2,
        SERVICE_ERROR_CRITICAL = 3
    }

    internal enum SERVICE_CONTROL : uint
    {
        SERVICE_CONTROL_STOP = 1,
        SERVICE_CONTROL_PAUSE = 2,
        SERVICE_CONTROL_CONTINUE = 3,
        SERVICE_CONTROL_INTERROGATE = 4,
        SERVICE_CONTROL_SHUTDOWN = 5,
        SERVICE_CONTROL_PARAMCHANGE = 6,
        SERVICE_CONTROL_NETBINDADD = 7,
        SERVICE_CONTROL_NETBINDREMOVE = 8,
        SERVICE_CONTROL_NETBINDENABLE = 9,
        SERVICE_CONTROL_NETBINDDISABLE = 10,
        SERVICE_CONTROL_DEVICEEVENT = 11,
        SERVICE_CONTROL_HARDWAREPROFILECHANGE = 12,
        SERVICE_CONTROL_POWEREVENT = 13,
        SERVICE_CONTROL_SESSIONCHANGE = 14
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct SERVICE_STATUS
    {
        public uint dwServiceType;
        public uint dwCurrentState;
        public uint dwControlsAccepted;
        public uint dwWin32ExitCode;
        public uint dwServiceSpecificExitCode;
        public uint dwCheckPoint;
        public uint dwWaitHint;
    }
}
```

`LibreHardwareMonitorLib/Interop/AtiAdlxx.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Interop;

internal static class AtiAdlxx
{
    public const int ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED = 1;

    public const int ADL_DL_FANCTRL_SPEED_TYPE_PERCENT = 1;
    public const int ADL_DL_FANCTRL_SPEED_TYPE_RPM = 2;

    public const int ADL_DL_FANCTRL_SUPPORTS_PERCENT_READ = 1;
    public const int ADL_DL_FANCTRL_SUPPORTS_PERCENT_WRITE = 2;
    public const int ADL_DL_FANCTRL_SUPPORTS_RPM_READ = 4;
    public const int ADL_DL_FANCTRL_SUPPORTS_RPM_WRITE = 8;

    public const int ADL_DRIVER_OK = 0;

    public const int ADL_FALSE = 0;

    public const int ADL_MAX_ADAPTERS = 40;
    public const int ADL_MAX_DEVICENAME = 32;
    public const int ADL_MAX_DISPLAYS = 40;
    public const int ADL_MAX_GLSYNC_PORT_LEDS = 8;
    public const int ADL_MAX_GLSYNC_PORTS = 8;
    public const int ADL_MAX_NUM_DISPLAYMODES = 1024;
    public const int ADL_MAX_PATH = 256;
    public const int ADL_TRUE = 1;

    public const int ATI_VENDOR_ID = 0x1002;

    internal const int ADL_PMLOG_MAX_SENSORS = 256;

    internal const string DllName = "atiadlxx.dll";

    public static Context Context_Alloc = Marshal.AllocHGlobal;

    // create a Main_Memory_Alloc delegate and keep it alive
    public static ADL_Main_Memory_AllocDelegate Main_Memory_Alloc = Marshal.AllocHGlobal;

    public delegate IntPtr ADL_Main_Memory_AllocDelegate(int size);

    public delegate IntPtr Context(int size);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Main_Control_Create(ADL_Main_Memory_AllocDelegate callback, int enumConnectedAdapters);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Main_Control_Destroy();

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Adapter_AdapterInfo_Get(IntPtr info, int size);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Adapter_NumberOfAdapters_Get();

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Adapter_NumberOfAdapters_Get(ref int numAdapters);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Adapter_ID_Get(int adapterIndex, out int adapterId);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Display_AdapterID_Get(int adapterIndex, out int adapterId);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Adapter_Active_Get(int adapterIndex, out int status);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Overdrive5_ODParameters_Get(int adapterIndex, out ADLODParameters parameters);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Overdrive5_CurrentActivity_Get(int iAdapterIndex, ref ADLPMActivity activity);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Overdrive5_Temperature_Get(int adapterIndex, int thermalControllerIndex, ref ADLTemperature temperature);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_OverdriveN_Temperature_Get(IntPtr context, int adapterIndex, ADLODNTemperatureType iTemperatureType, ref int temp);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Overdrive5_FanSpeed_Get(int adapterIndex, int thermalControllerIndex, ref ADLFanSpeedValue fanSpeedValue);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Overdrive5_FanSpeedInfo_Get(int adapterIndex, int thermalControllerIndex, ref ADLFanSpeedInfo fanSpeedInfo);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Overdrive5_FanSpeedToDefault_Set(int adapterIndex, int thermalControllerIndex);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Overdrive5_FanSpeed_Set(int adapterIndex, int thermalControllerIndex, ref ADLFanSpeedValue fanSpeedValue);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_OverdriveN_PerformanceStatus_Get(IntPtr context, int adapterIndex, out ADLODNPerformanceStatus performanceStatus);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Overdrive_Caps(int adapterIndex, ref int supported, ref int enabled, ref int version);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Overdrive6_CurrentPower_Get(IntPtr context, int adapterIndex, ADLODNCurrentPowerType powerType, ref int currentValue);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Main_Control_Create(ADL_Main_Memory_AllocDelegate callback, int connectedAdapters, ref IntPtr context);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Main_Control_Destroy(IntPtr context);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_New_QueryPMLogData_Get(IntPtr context, int adapterIndex, ref ADLPMLogDataOutput aDLPMLogDataOutput);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL_Graphics_Versions_Get(out ADLVersionsInfo versionInfo);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_FrameMetrics_Caps(IntPtr context, int adapterIndex, ref int supported);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_FrameMetrics_Get(IntPtr context, int adapterIndex, int displayIndex, ref float fps);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_FrameMetrics_Start(IntPtr context, int adapterIndex, int displayIndex);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_FrameMetrics_Stop(IntPtr context, int adapterIndex, int displayIndex);

    public static bool ADL_Method_Exists(string ADL_Method)
    {
        IntPtr module = Kernel32.LoadLibrary(DllName);
        if (module != IntPtr.Zero)
        {
            bool result = Kernel32.GetProcAddress(module, ADL_Method) != IntPtr.Zero;
            Kernel32.FreeLibrary(module);
            return result;
        }

        return false;
    }

    public static ADLStatus ADL_Main_Control_Create(int enumConnectedAdapters)
    {
        try
        {
            return ADL_Method_Exists(nameof(ADL_Main_Control_Create)) ? ADL_Main_Control_Create(Main_Memory_Alloc, enumConnectedAdapters) : ADLStatus.ADL_ERR;
        }
        catch
        {
            return ADLStatus.ADL_ERR;
        }
    }

    public static ADLStatus ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo[] info)
    {
        int elementSize = Marshal.SizeOf(typeof(ADLAdapterInfo));
        int size = info.Length * elementSize;
        IntPtr ptr = Marshal.AllocHGlobal(size);
        ADLStatus result = ADL_Adapter_AdapterInfo_Get(ptr, size);
        for (int i = 0; i < info.Length; i++)
            info[i] = (ADLAdapterInfo)Marshal.PtrToStructure((IntPtr)((long)ptr + (i * elementSize)), typeof(ADLAdapterInfo));

        Marshal.FreeHGlobal(ptr);

        // the ADLAdapterInfo.VendorID field reported by ADL is wrong on
        // Windows systems (parse error), so we fix this here
        for (int i = 0; i < info.Length; i++)
        {
            // try Windows UDID format
            Match m = Regex.Match(info[i].UDID, "PCI_VEN_([A-Fa-f0-9]{1,4})&.*");
            if (m.Success && m.Groups.Count == 2)
            {
                info[i].VendorID = Convert.ToInt32(m.Groups[1].Value, 16);
                continue;
            }

            // if above failed, try Unix UDID format
            m = Regex.Match(info[i].UDID, "[0-9]+:[0-9]+:([0-9]+):[0-9]+:[0-9]+");
            if (m.Success && m.Groups.Count == 2)
            {
                info[i].VendorID = Convert.ToInt32(m.Groups[1].Value, 10);
            }
        }

        return result;
    }

    public static void Main_Memory_Free(IntPtr buffer)
    {
        if (IntPtr.Zero != buffer)
            Marshal.FreeHGlobal(buffer);
    }

    internal enum ADLStatus
    {
        /// <summary>
        /// All OK, but need to wait.
        /// </summary>
        ADL_OK_WAIT = 4,

        /// <summary>
        /// All OK, but need restart.
        /// </summary>
        ADL_OK_RESTART = 3,

        /// <summary>
        /// All OK but need mode change.
        /// </summary>
        ADL_OK_MODE_CHANGE = 2,

        /// <summary>
        /// All OK, but with warning.
        /// </summary>
        ADL_OK_WARNING = 1,

        /// <summary>
        /// ADL function completed successfully.
        /// </summary>
        ADL_OK = 0,

        /// <summary>
        /// Generic Error. Most likely one or more of the Escape calls to the driver
        /// failed!
        /// </summary>
        ADL_ERR = -1,

        /// <summary>
        /// ADL not initialized.
        /// </summary>
        ADL_ERR_NOT_INIT = -2,

        /// <summary>
        /// One of the parameter passed is invalid.
        /// </summary>
        ADL_ERR_INVALID_PARAM = -3,

        /// <summary>
        /// One of the parameter size is invalid.
        /// </summary>
        ADL_ERR_INVALID_PARAM_SIZE = -4,

        /// <summary>
        /// Invalid ADL index passed.
        /// </summary>
        ADL_ERR_INVALID_ADL_IDX = -5,

        /// <summary>
        /// Invalid controller index passed.
        /// </summary>
        ADL_ERR_INVALID_CONTROLLER_IDX = -6,

        /// <summary>
        /// Invalid display index passed.
        /// </summary>
        ADL_ERR_INVALID_DIPLAY_IDX = -7,

        /// <summary>
        /// Function not supported by the driver.
        /// </summary>
        ADL_ERR_NOT_SUPPORTED = -8,

        /// <summary>
        /// Null Pointer error.
        /// </summary>
        ADL_ERR_NULL_POINTER = -9,

        /// <summary>
        /// Call can't be made due to disabled adapter.
        /// </summary>
        ADL_ERR_DISABLED_ADAPTER = -10,

        /// <summary>
        /// Invalid Callback.
        /// </summary>
        ADL_ERR_INVALID_CALLBACK = -11,

        /// <summary>
        /// Display Resource conflict.
        /// </summary>
        ADL_ERR_RESOURCE_CONFLICT = -12,

        /// <summary>
        /// Failed to update some of the values. Can be returned by set request that
        /// include multiple values if not all values were successfully committed.
        /// </summary>
        ADL_ERR_SET_INCOMPLETE = -20,

        /// <summary>
        /// There's no Linux XDisplay in Linux Console environment.
        /// </summary>
        ADL_ERR_NO_XDISPLAY = -21
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLAdapterInfo
    {
        public int Size;
        public int AdapterIndex;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string UDID;

        public int BusNumber;
        public int DeviceNumber;
        public int FunctionNumber;
        public int VendorID;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string AdapterName;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string DisplayName;

        public int Present;
        public int Exist;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string DriverPath;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string DriverPathExt;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string PNPString;

        public int OSDisplayIndex;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLODParameterRange
    {
        public int Min;
        public int Max;
        public int Step;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLODParameters
    {
        public int Size;
        public int NumberOfPerformanceLevels;
        public int ActivityReportingSupported;
        public int DiscretePerformanceLevels;
        public int Reserved;
        public ADLODParameterRange EngineClock;
        public ADLODParameterRange MemoryClock;
        public ADLODParameterRange Vddc;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLPMActivity
    {
        public int Size;
        public int EngineClock;
        public int MemoryClock;
        public int Vddc;
        public int ActivityPercent;
        public int CurrentPerformanceLevel;
        public int CurrentBusSpeed;
        public int CurrentBusLanes;
        public int MaximumBusLanes;
        public int Reserved;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLTemperature
    {
        public int Size;
        public int Temperature;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLFanSpeedValue
    {
        public int Size;
        public int SpeedType;
        public int FanSpeed;
        public int Flags;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLFanSpeedInfo
    {
        public int Size;
        public int Flags;
        public int MinPercent;
        public int MaxPercent;
        public int MinRPM;
        public int MaxRPM;
    }

    internal enum ADLODNCurrentPowerType
    {
        ODN_GPU_TOTAL_POWER = 0,
        ODN_GPU_PPT_POWER,
        ODN_GPU_SOCKET_POWER,
        ODN_GPU_CHIP_POWER
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLVersionsInfo
    {
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
        public string DriverVer;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
        public string CatalystVersion;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
        public string CatalystWebLink;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLODNPerformanceStatus
    {
        public int CoreClock;
        public int MemoryClock;
        public int DCEFClock;
        public int GFXClock;
        public int UVDClock;
        public int VCEClock;
        public int GPUActivityPercent;
        public int CurrentCorePerformanceLevel;
        public int CurrentMemoryPerformanceLevel;
        public int CurrentDCEFPerformanceLevel;
        public int CurrentGFXPerformanceLevel;
        public int UVDPerformanceLevel;
        public int VCEPerformanceLevel;
        public int CurrentBusSpeed;
        public int CurrentBusLanes;
        public int MaximumBusLanes;
        public int VDDC;
        public int VDDCI;
    }

    internal enum ADLODNTemperatureType
    {
        // This typed is named like this in the documentation but for some reason AMD failed to include it...
        // Yet it seems these correspond with ADL_PMLOG_TEMPERATURE_xxx.
        EDGE = 1,
        MEM = 2,
        VRVDDC = 3,
        VRMVDD = 4,
        LIQUID = 5,
        PLX = 6,
        HOTSPOT = 7
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLSingleSensorData
    {
        public int supported;
        public int value;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLPMLogDataOutput
    {
        public int size;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = ADL_PMLOG_MAX_SENSORS)]
        public ADLSingleSensorData[] sensors;
    }

    internal enum ADLSensorType
    {
        SENSOR_MAXTYPES = 0,
        PMLOG_CLK_GFXCLK = 1,
        PMLOG_CLK_MEMCLK = 2,
        PMLOG_CLK_SOCCLK = 3,
        PMLOG_CLK_UVDCLK1 = 4,
        PMLOG_CLK_UVDCLK2 = 5,
        PMLOG_CLK_VCECLK = 6,
        PMLOG_CLK_VCNCLK = 7,
        PMLOG_TEMPERATURE_EDGE = 8,
        PMLOG_TEMPERATURE_MEM = 9,
        PMLOG_TEMPERATURE_VRVDDC = 10,
        PMLOG_TEMPERATURE_VRMVDD = 11,
        PMLOG_TEMPERATURE_LIQUID = 12,
        PMLOG_TEMPERATURE_PLX = 13,
        PMLOG_FAN_RPM = 14,
        PMLOG_FAN_PERCENTAGE = 15,
        PMLOG_SOC_VOLTAGE = 16,
        PMLOG_SOC_POWER = 17,
        PMLOG_SOC_CURRENT = 18,
        PMLOG_INFO_ACTIVITY_GFX = 19,
        PMLOG_INFO_ACTIVITY_MEM = 20,
        PMLOG_GFX_VOLTAGE = 21,
        PMLOG_MEM_VOLTAGE = 22,
        PMLOG_ASIC_POWER = 23,
        PMLOG_TEMPERATURE_VRSOC = 24,
        PMLOG_TEMPERATURE_VRMVDD0 = 25,
        PMLOG_TEMPERATURE_VRMVDD1 = 26,
        PMLOG_TEMPERATURE_HOTSPOT = 27,
        PMLOG_TEMPERATURE_GFX = 28,
        PMLOG_TEMPERATURE_SOC = 29,
        PMLOG_GFX_POWER = 30,
        PMLOG_GFX_CURRENT = 31,
        PMLOG_TEMPERATURE_CPU = 32,
        PMLOG_CPU_POWER = 33,
        PMLOG_CLK_CPUCLK = 34,
        PMLOG_THROTTLER_STATUS = 35,
        PMLOG_CLK_VCN1CLK1 = 36,
        PMLOG_CLK_VCN1CLK2 = 37,
        PMLOG_SMART_POWERSHIFT_CPU = 38,
        PMLOG_SMART_POWERSHIFT_DGPU = 39,
        PMLOG_MAX_SENSORS_REAL
    }
}
```

`LibreHardwareMonitorLib/Interop/CfgMgr32.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

// ReSharper disable IdentifierTypo
// ReSharper disable InconsistentNaming

using System;
using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Interop;

internal static class CfgMgr32
{
    internal const uint CM_GET_DEVICE_INTERFACE_LIST_PRESENT = 0;
    internal const int CR_SUCCESS = 0;

    internal const string DllName = "CfgMgr32.dll";
    internal static Guid GUID_DISPLAY_DEVICE_ARRIVAL = new("1CA05180-A699-450A-9A0C-DE4FBE3DDD89");

    [DllImport(DllName, CharSet = CharSet.Unicode)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern uint CM_Get_Device_Interface_List_Size(out uint size, ref Guid interfaceClassGuid, string deviceID, uint flags);

    [DllImport(DllName, CharSet = CharSet.Unicode)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern uint CM_Get_Device_Interface_List(ref Guid interfaceClassGuid, string deviceID, char[] buffer, uint bufferLength, uint flags);
}
```

`LibreHardwareMonitorLib/Interop/D3dkmdt.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

// ReSharper disable IdentifierTypo
// ReSharper disable InconsistentNaming

using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Interop;

internal static class D3dkmdt
{
    internal enum DXGK_ENGINE_TYPE
    {
        DXGK_ENGINE_TYPE_OTHER = 0,
        DXGK_ENGINE_TYPE_3D = 1,
        DXGK_ENGINE_TYPE_VIDEO_DECODE = 2,
        DXGK_ENGINE_TYPE_VIDEO_ENCODE = 3,
        DXGK_ENGINE_TYPE_VIDEO_PROCESSING = 4,
        DXGK_ENGINE_TYPE_SCENE_ASSEMBLY = 5,
        DXGK_ENGINE_TYPE_COPY = 6,
        DXGK_ENGINE_TYPE_OVERLAY = 7,
        DXGK_ENGINE_TYPE_CRYPTO,
        DXGK_ENGINE_TYPE_MAX
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct DXGK_NODEMETADATA_FLAGS
    {
        public uint Value;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Unicode)]
    internal struct DXGK_NODEMETADATA
    {
        public DXGK_ENGINE_TYPE EngineType;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
        public string FriendlyName;

        public DXGK_NODEMETADATA_FLAGS Flags;
        public byte GpuMmuSupported;
        public byte IoMmuSupported;
    }
}
```

`LibreHardwareMonitorLib/Interop/D3dkmth.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

// ReSharper disable IdentifierTypo
// ReSharper disable InconsistentNaming

using System;
using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Interop;

internal static class D3dkmth
{
    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_CLOSEADAPTER
    {
        public uint hAdapter;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYADAPTERINFO
    {
        public uint hAdapter;
        public KMTQUERYADAPTERINFOTYPE Type;
        public IntPtr pPrivateDriverData;
        public int PrivateDriverDataSize;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_OPENADAPTERFROMDEVICENAME
    {
        [MarshalAs(UnmanagedType.LPWStr)]
        public string pDeviceName;

        public uint hAdapter;
        public WinNt.LUID AdapterLuid;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_ADAPTERTYPE
    {
        public D3DKMT_ADAPTERTYPE_FLAGS Value;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_QUERY_SEGMENT
    {
        public uint SegmentId;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_QUERY_NODE
    {
        public uint NodeId;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_QUERY_VIDPNSOURCE
    {
        public uint VidPnSourceId;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_REFERENCE_DMA_BUFFER
    {
        public uint NbCall;
        public uint NbAllocationsReferenced;
        public uint MaxNbAllocationsReferenced;
        public uint NbNULLReference;
        public uint NbWriteReference;
        public uint NbRenamedAllocationsReferenced;
        public uint NbIterationSearchingRenamedAllocation;
        public uint NbLockedAllocationReferenced;
        public uint NbAllocationWithValidPrepatchingInfoReferenced;
        public uint NbAllocationWithInvalidPrepatchingInfoReferenced;
        public uint NbDMABufferSuccessfullyPrePatched;
        public uint NbPrimariesReferencesOverflow;
        public uint NbAllocationWithNonPreferredResources;
        public uint NbAllocationInsertedInMigrationTable;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_SEGMENTSIZEINFO
    {
        public ulong DedicatedVideoMemorySize;
        public ulong DedicatedSystemMemorySize;
        public ulong SharedSystemMemorySize;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_RENAMING
    {
        public uint NbAllocationsRenamed;
        public uint NbAllocationsShrinked;
        public uint NbRenamedBuffer;
        public uint MaxRenamingListLength;
        public uint NbFailuresDueToRenamingLimit;
        public uint NbFailuresDueToCreateAllocation;
        public uint NbFailuresDueToOpenAllocation;
        public uint NbFailuresDueToLowResource;
        public uint NbFailuresDueToNonRetiredLimit;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_COUNTER
    {
        public uint Count;
        public ulong Bytes;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_PREPRATION
    {
        public uint BroadcastStall;
        public uint NbDMAPrepared;
        public uint NbDMAPreparedLongPath;
        public uint ImmediateHighestPreparationPass;
        public D3DKMT_QUERYSTATISTICS_COUNTER AllocationsTrimmed;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_PAGING_FAULT
    {
        public D3DKMT_QUERYSTATISTICS_COUNTER Faults;
        public D3DKMT_QUERYSTATISTICS_COUNTER FaultsFirstTimeAccess;
        public D3DKMT_QUERYSTATISTICS_COUNTER FaultsReclaimed;
        public D3DKMT_QUERYSTATISTICS_COUNTER FaultsMigration;
        public D3DKMT_QUERYSTATISTICS_COUNTER FaultsIncorrectResource;
        public D3DKMT_QUERYSTATISTICS_COUNTER FaultsLostContent;
        public D3DKMT_QUERYSTATISTICS_COUNTER FaultsEvicted;
        public D3DKMT_QUERYSTATISTICS_COUNTER AllocationsMEM_RESET;
        public D3DKMT_QUERYSTATISTICS_COUNTER AllocationsUnresetSuccess;
        public D3DKMT_QUERYSTATISTICS_COUNTER AllocationsUnresetFail;

        public uint AllocationsUnresetSuccessRead;
        public uint AllocationsUnresetFailRead;

        public D3DKMT_QUERYSTATISTICS_COUNTER Evictions;
        public D3DKMT_QUERYSTATISTICS_COUNTER EvictionsDueToPreparation;
        public D3DKMT_QUERYSTATISTICS_COUNTER EvictionsDueToLock;
        public D3DKMT_QUERYSTATISTICS_COUNTER EvictionsDueToClose;
        public D3DKMT_QUERYSTATISTICS_COUNTER EvictionsDueToPurge;
        public D3DKMT_QUERYSTATISTICS_COUNTER EvictionsDueToSuspendCPUAccess;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_PAGING_TRANSFER
    {
        public ulong BytesFilled;
        public ulong BytesDiscarded;
        public ulong BytesMappedIntoAperture;
        public ulong BytesUnmappedFromAperture;
        public ulong BytesTransferredFromMdlToMemory;
        public ulong BytesTransferredFromMemoryToMdl;
        public ulong BytesTransferredFromApertureToMemory;
        public ulong BytesTransferredFromMemoryToAperture;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_SWIZZLING_RANGE
    {
        public uint NbRangesAcquired;
        public uint NbRangesReleased;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_LOCKS
    {
        public uint NbLocks;
        public uint NbLocksWaitFlag;
        public uint NbLocksDiscardFlag;
        public uint NbLocksNoOverwrite;
        public uint NbLocksNoReadSync;
        public uint NbLocksLinearization;
        public uint NbComplexLocks;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_ALLOCATIONS
    {
        public D3DKMT_QUERYSTATISTICS_COUNTER Created;
        public D3DKMT_QUERYSTATISTICS_COUNTER Destroyed;
        public D3DKMT_QUERYSTATISTICS_COUNTER Opened;
        public D3DKMT_QUERYSTATISTICS_COUNTER Closed;
        public D3DKMT_QUERYSTATISTICS_COUNTER MigratedSuccess;
        public D3DKMT_QUERYSTATISTICS_COUNTER MigratedFail;
        public D3DKMT_QUERYSTATISTICS_COUNTER MigratedAbandoned;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_TERMINATIONS
    {
        public D3DKMT_QUERYSTATISTICS_COUNTER TerminatedShared;
        public D3DKMT_QUERYSTATISTICS_COUNTER TerminatedNonShared;
        public D3DKMT_QUERYSTATISTICS_COUNTER DestroyedShared;
        public D3DKMT_QUERYSTATISTICS_COUNTER DestroyedNonShared;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_ADAPTER_INFORMATION
    {
        public uint NbSegments;
        public uint NodeCount;
        public uint VidPnSourceCount;

        public uint VSyncEnabled;
        public uint TdrDetectedCount;

        public long ZeroLengthDmaBuffers;
        public ulong RestartedPeriod;

        public D3DKMT_QUERYSTATISTICS_REFERENCE_DMA_BUFFER ReferenceDmaBuffer;
        public D3DKMT_QUERYSTATISTICS_RENAMING Renaming;
        public D3DKMT_QUERYSTATISTICS_PREPRATION Preparation;
        public D3DKMT_QUERYSTATISTICS_PAGING_FAULT PagingFault;
        public D3DKMT_QUERYSTATISTICS_PAGING_TRANSFER PagingTransfer;
        public D3DKMT_QUERYSTATISTICS_SWIZZLING_RANGE SwizzlingRange;
        public D3DKMT_QUERYSTATISTICS_LOCKS Locks;
        public D3DKMT_QUERYSTATISTICS_ALLOCATIONS Allocations;
        public D3DKMT_QUERYSTATISTICS_TERMINATIONS Terminations;

        private readonly ulong Reserved;
        private readonly ulong Reserved1;
        private readonly ulong Reserved2;
        private readonly ulong Reserved3;
        private readonly ulong Reserved4;
        private readonly ulong Reserved5;
        private readonly ulong Reserved6;
        private readonly ulong Reserved7;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_MEMORY
    {
        public ulong TotalBytesEvicted;
        public uint AllocsCommitted;
        public uint AllocsResident;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION
    {
        public ulong CommitLimit;
        public ulong BytesCommitted;
        public ulong BytesResident;
        public D3DKMT_QUERYSTATISTICS_MEMORY Memory;
        public uint Aperture; // boolean
        public fixed ulong TotalBytesEvictedByPriority[5]; // D3DKMT_QUERYSTATISTICS_SEGMENT_PREFERENCE_MAX
        public ulong SystemMemoryEndAddress;
        public D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION_POWER_FLAGS PowerFlags;
        public fixed ulong Reserved[6];
    }

    [StructLayout(LayoutKind.Explicit)]
    internal struct D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION_POWER_FLAGS
    {
        [FieldOffset(0)]
        public ulong PreservedDuringStandby;

        [FieldOffset(1)]
        public ulong PreservedDuringHibernate;

        [FieldOffset(2)]
        public ulong PartiallyPreservedDuringHibernate;

        [FieldOffset(3)]
        public ulong Reserved;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_VIDEO_MEMORY
    {
        public uint AllocsCommitted;
        public D3DKMT_QUERYSTATISTICS_COUNTER AllocsResidentIn0;
        public D3DKMT_QUERYSTATISTICS_COUNTER AllocsResidentIn1;
        public D3DKMT_QUERYSTATISTICS_COUNTER AllocsResidentIn2;
        public D3DKMT_QUERYSTATISTICS_COUNTER AllocsResidentIn3;
        public D3DKMT_QUERYSTATISTICS_COUNTER AllocsResidentIn4;
        public D3DKMT_QUERYSTATISTICS_COUNTER AllocsResidentInNonPreferred;
        public ulong TotalBytesEvictedDueToPreparation;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_POLICY
    {
        public ulong UseMRU;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_INFORMATION
    {
        public ulong BytesCommitted;
        public ulong MaximumWorkingSet;
        public ulong MinimumWorkingSet;

        public uint NbReferencedAllocationEvictedInPeriod;

        public D3DKMT_QUERYSTATISTICS_VIDEO_MEMORY VideoMemory;
        public D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_POLICY _Policy;

        public fixed ulong Reserved[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_PREEMPTION_INFORMATION
    {
        public uint PreemptionCounter;
        public uint PreemptionCounter1;
        public uint PreemptionCounter2;
        public uint PreemptionCounter3;
        public uint PreemptionCounter4;
        public uint PreemptionCounter5;
        public uint PreemptionCounter6;
        public uint PreemptionCounter7;
        public uint PreemptionCounter8;
        public uint PreemptionCounter9;
        public uint PreemptionCounter10;
        public uint PreemptionCounter11;
        public uint PreemptionCounter12;
        public uint PreemptionCounter13;
        public uint PreemptionCounter14;
        public uint PreemptionCounter15;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct D3DKMT_QUERYSTATISTICS_PROCESS_NODE_INFORMATION
    {
        public WinNt.LARGE_INTEGER RunningTime; // 100ns
        public uint ContextSwitch;
        private readonly D3DKMT_QUERYSTATISTICS_PREEMPTION_INFORMATION PreemptionStatistics;
        private readonly D3DKMT_QUERYSTATISTICS_PACKET_INFORMATION PacketStatistics;
        private fixed ulong Reserved[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct D3DKMT_QUERYSTATISTICS_NODE_INFORMATION
    {
        public D3DKMT_QUERYSTATISTICS_PROCESS_NODE_INFORMATION GlobalInformation; // global

        public D3DKMT_QUERYSTATISTICS_PROCESS_NODE_INFORMATION SystemInformation; // system thread

        //public UInt32 NodeId; // Win10
        public fixed ulong Reserved[8];
    }

    internal struct D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE_INFORMATION
    {
        public uint PacketSubmitted;
        public uint PacketCompleted;
        public uint PacketPreempted;
        public uint PacketFaulted;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE_INFORMATION
    {
        public uint PacketSubmited;
        public uint PacketCompleted;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS_PACKET_INFORMATION
    {
        public D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE_INFORMATION QueuePacket;
        public D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE_INFORMATION QueuePacket1;
        public D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE_INFORMATION QueuePacket2;
        public D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE_INFORMATION QueuePacket3;
        public D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE_INFORMATION QueuePacket4;
        public D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE_INFORMATION QueuePacket5;
        public D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE_INFORMATION QueuePacket6;
        public D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE_INFORMATION QueuePacket7;

        public D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE_INFORMATION DmaPacket;
        public D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE_INFORMATION DmaPacket1;
        public D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE_INFORMATION DmaPacket2;
        public D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE_INFORMATION DmaPacket3;
    }

    [StructLayout(LayoutKind.Explicit)]
    internal struct D3DKMT_QUERYSTATISTICS_RESULT
    {
        [FieldOffset(8)]
        public D3DKMT_QUERYSTATISTICS_ADAPTER_INFORMATION AdapterInformation;

        [FieldOffset(8)]
        public D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION SegmentInformation;

        [FieldOffset(8)]
        public D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_INFORMATION ProcessSegmentInformation;

        [FieldOffset(8)]
        public D3DKMT_QUERYSTATISTICS_NODE_INFORMATION NodeInformation;

        // D3DKMT_QUERYSTATISTICS_PROCESS_INFORMATION ProcessInformation;
        // D3DKMT_QUERYSTATISTICS_PROCESS_NODE_INFORMATION ProcessNodeInformation;
        // D3DKMT_QUERYSTATISTICS_PHYSICAL_ADAPTER_INFORMATION PhysAdapterInformation;
        // D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION_V1 SegmentInformationV1; // WIN7
        // D3DKMT_QUERYSTATISTICS_VIDPNSOURCE_INFORMATION VidPnSourceInformation;
        // D3DKMT_QUERYSTATISTICS_PROCESS_ADAPTER_INFORMATION ProcessAdapterInformation;
        // D3DKMT_QUERYSTATISTICS_PROCESS_VIDPNSOURCE_INFORMATION ProcessVidPnSourceInformation;
        // D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_GROUP_INFORMATION ProcessSegmentGroupInformation;
    }

    [StructLayout(LayoutKind.Explicit)]
    internal struct D3DKMT_QUERYSTATISTICS_QUERY_ELEMENT
    {
        [FieldOffset(0)]
        public D3DKMT_QUERYSTATISTICS_QUERY_SEGMENT QuerySegment;

        [FieldOffset(0)]
        public D3DKMT_QUERYSTATISTICS_QUERY_SEGMENT QueryProcessSegment;

        [FieldOffset(0)]
        public D3DKMT_QUERYSTATISTICS_QUERY_NODE QueryNode;

        [FieldOffset(0)]
        public D3DKMT_QUERYSTATISTICS_QUERY_NODE QueryProcessNode;

        [FieldOffset(0)]
        public D3DKMT_QUERYSTATISTICS_QUERY_VIDPNSOURCE QueryVidPnSource;

        [FieldOffset(0)]
        public D3DKMT_QUERYSTATISTICS_QUERY_VIDPNSOURCE QueryProcessVidPnSource;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct D3DKMT_QUERYSTATISTICS
    {
        public D3DKMT_QUERYSTATISTICS_TYPE Type;
        public WinNt.LUID AdapterLuid;
        public uint ProcessHandle;
        public D3DKMT_QUERYSTATISTICS_RESULT QueryResult;
        public D3DKMT_QUERYSTATISTICS_QUERY_ELEMENT QueryElement;
    }
        
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct D3DKMT_NODEMETADATA
    {
        public uint NodeOrdinalAndAdapterIndex;
        public D3dkmdt.DXGK_NODEMETADATA NodeData;
    }

    [Flags]
    internal enum D3DKMT_ADAPTERTYPE_FLAGS : uint
    {
        RenderSupported = 0,
        DisplaySupported = 1,
        SoftwareDevice = 2,
        PostDevice = 4,
        HybridDiscrete = 8,
        HybridIntegrated = 16,
        IndirectDisplayDevice = 32,
        Paravirtualized = 64,
        ACGSupported = 128,
        SupportSetTimingsFromVidPn = 256,
        Detachable = 512,
        ComputeOnly = 1024,
        Prototype = 2045
    }

    internal enum D3DKMT_QUERYSTATISTICS_TYPE
    {
        D3DKMT_QUERYSTATISTICS_ADAPTER,
        D3DKMT_QUERYSTATISTICS_PROCESS,
        D3DKMT_QUERYSTATISTICS_PROCESS_ADAPTER,
        D3DKMT_QUERYSTATISTICS_SEGMENT,
        D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT,
        D3DKMT_QUERYSTATISTICS_NODE,
        D3DKMT_QUERYSTATISTICS_PROCESS_NODE,
        D3DKMT_QUERYSTATISTICS_VIDPNSOURCE,
        D3DKMT_QUERYSTATISTICS_PROCESS_VIDPNSOURCE,
        D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_GROUP,
        D3DKMT_QUERYSTATISTICS_PHYSICAL_ADAPTER
    }

    internal enum D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE
    {
        D3DKMT_ClientRenderBuffer = 0,
        D3DKMT_ClientPagingBuffer = 1,
        D3DKMT_SystemPagingBuffer = 2,
        D3DKMT_SystemPreemptionBuffer = 3,
        D3DKMT_DmaPacketTypeMax
    }

    internal enum KMTQUERYADAPTERINFOTYPE
    {
        KMTQAITYPE_UMDRIVERPRIVATE = 0,
        KMTQAITYPE_UMDRIVERNAME = 1,
        KMTQAITYPE_UMOPENGLINFO = 2,
        KMTQAITYPE_GETSEGMENTSIZE = 3,
        KMTQAITYPE_ADAPTERGUID = 4,
        KMTQAITYPE_FLIPQUEUEINFO = 5,
        KMTQAITYPE_ADAPTERADDRESS = 6,
        KMTQAITYPE_SETWORKINGSETINFO = 7,
        KMTQAITYPE_ADAPTERREGISTRYINFO = 8,
        KMTQAITYPE_CURRENTDISPLAYMODE = 9,
        KMTQAITYPE_MODELIST = 10,
        KMTQAITYPE_CHECKDRIVERUPDATESTATUS = 11,
        KMTQAITYPE_VIRTUALADDRESSINFO = 12,
        KMTQAITYPE_DRIVERVERSION = 13,
        KMTQAITYPE_ADAPTERTYPE = 15,
        KMTQAITYPE_OUTPUTDUPLCONTEXTSCOUNT = 16,
        KMTQAITYPE_WDDM_1_2_CAPS = 17,
        KMTQAITYPE_UMD_DRIVER_VERSION = 18,
        KMTQAITYPE_DIRECTFLIP_SUPPORT = 19,
        KMTQAITYPE_MULTIPLANEOVERLAY_SUPPORT = 20,
        KMTQAITYPE_DLIST_DRIVER_NAME = 21,
        KMTQAITYPE_WDDM_1_3_CAPS = 22,
        KMTQAITYPE_MULTIPLANEOVERLAY_HUD_SUPPORT = 23,
        KMTQAITYPE_WDDM_2_0_CAPS = 24,
        KMTQAITYPE_NODEMETADATA = 25,
        KMTQAITYPE_CPDRIVERNAME = 26,
        KMTQAITYPE_XBOX = 27,
        KMTQAITYPE_INDEPENDENTFLIP_SUPPORT = 28,
        KMTQAITYPE_MIRACASTCOMPANIONDRIVERNAME = 29,
        KMTQAITYPE_PHYSICALADAPTERCOUNT = 30,
        KMTQAITYPE_PHYSICALADAPTERDEVICEIDS = 31,
        KMTQAITYPE_DRIVERCAPS_EXT = 32,
        KMTQAITYPE_QUERY_MIRACAST_DRIVER_TYPE = 33,
        KMTQAITYPE_QUERY_GPUMMU_CAPS = 34,
        KMTQAITYPE_QUERY_MULTIPLANEOVERLAY_DECODE_SUPPORT = 35,
        KMTQAITYPE_QUERY_HW_PROTECTION_TEARDOWN_COUNT = 36,
        KMTQAITYPE_QUERY_ISBADDRIVERFORHWPROTECTIONDISABLED = 37,
        KMTQAITYPE_MULTIPLANEOVERLAY_SECONDARY_SUPPORT = 38,
        KMTQAITYPE_INDEPENDENTFLIP_SECONDARY_SUPPORT = 39,
        KMTQAITYPE_PANELFITTER_SUPPORT = 40,
        KMTQAITYPE_PHYSICALADAPTERPNPKEY = 41,
        KMTQAITYPE_GETSEGMENTGROUPSIZE = 42,
        KMTQAITYPE_MPO3DDI_SUPPORT = 43,
        KMTQAITYPE_HWDRM_SUPPORT = 44,
        KMTQAITYPE_MPOKERNELCAPS_SUPPORT = 45,
        KMTQAITYPE_MULTIPLANEOVERLAY_STRETCH_SUPPORT = 46,
        KMTQAITYPE_GET_DEVICE_VIDPN_OWNERSHIP_INFO = 47,
        KMTQAITYPE_QUERYREGISTRY = 48,
        KMTQAITYPE_KMD_DRIVER_VERSION = 49,
        KMTQAITYPE_BLOCKLIST_KERNEL = 50,
        KMTQAITYPE_BLOCKLIST_RUNTIME = 51,
        KMTQAITYPE_ADAPTERGUID_RENDER = 52,
        KMTQAITYPE_ADAPTERADDRESS_RENDER = 53,
        KMTQAITYPE_ADAPTERREGISTRYINFO_RENDER = 54,
        KMTQAITYPE_CHECKDRIVERUPDATESTATUS_RENDER = 55,
        KMTQAITYPE_DRIVERVERSION_RENDER = 56,
        KMTQAITYPE_ADAPTERTYPE_RENDER = 57,
        KMTQAITYPE_WDDM_1_2_CAPS_RENDER = 58,
        KMTQAITYPE_WDDM_1_3_CAPS_RENDER = 59,
        KMTQAITYPE_QUERY_ADAPTER_UNIQUE_GUID = 60,
        KMTQAITYPE_NODEPERFDATA = 61,
        KMTQAITYPE_ADAPTERPERFDATA = 62,
        KMTQAITYPE_ADAPTERPERFDATA_CAPS = 63,
        KMTQUITYPE_GPUVERSION = 64,
        KMTQAITYPE_DRIVER_DESCRIPTION = 65,
        KMTQAITYPE_DRIVER_DESCRIPTION_RENDER = 66,
        KMTQAITYPE_SCANOUT_CAPS = 67,
        KMTQAITYPE_DISPLAY_UMDRIVERNAME = 71,
        KMTQAITYPE_PARAVIRTUALIZATION_RENDER = 68,
        KMTQAITYPE_SERVICENAME = 69,
        KMTQAITYPE_WDDM_2_7_CAPS = 70,
        KMTQAITYPE_TRACKEDWORKLOAD_SUPPORT = 72
    }
}

```

`LibreHardwareMonitorLib/Interop/Ftd2xx.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Interop;

internal static class Ftd2xx
{
    private const string DllName = "Ftd2xx.dll";

    public static bool DllExists()
    {
        IntPtr module = Kernel32.LoadLibrary(DllName);
        if (module == IntPtr.Zero)
            return false;

        Kernel32.FreeLibrary(module);
        return true;
    }

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_CreateDeviceInfoList(out uint numDevices);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_GetDeviceInfoList([Out] FT_DEVICE_INFO_NODE[] deviceInfoNodes, ref uint length);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_Open(int device, out FT_HANDLE handle);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_Close(FT_HANDLE handle);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_SetBaudRate(FT_HANDLE handle, uint baudRate);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_SetDataCharacteristics(FT_HANDLE handle, byte wordLength, byte stopBits, byte parity);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_SetFlowControl(FT_HANDLE handle, FT_FLOW_CONTROL flowControl, byte xon, byte xoff);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_SetTimeouts(FT_HANDLE handle, uint readTimeout, uint writeTimeout);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_Write(FT_HANDLE handle, byte[] buffer, uint bytesToWrite, out uint bytesWritten);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_Purge(FT_HANDLE handle, FT_PURGE mask);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_GetStatus(FT_HANDLE handle, out uint amountInRxQueue, out uint amountInTxQueue, out uint eventStatus);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_Read(FT_HANDLE handle, [Out] byte[] buffer, uint bytesToRead, out uint bytesReturned);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_ReadByte(FT_HANDLE handle, out byte buffer, uint bytesToRead, out uint bytesReturned);

    public static FT_STATUS Write(FT_HANDLE handle, byte[] buffer)
    {
        FT_STATUS status = FT_Write(handle, buffer, (uint)buffer.Length, out uint bytesWritten);
        if (bytesWritten != buffer.Length)
            return FT_STATUS.FT_FAILED_TO_WRITE_DEVICE;

        return status;
    }

    public static int BytesToRead(FT_HANDLE handle)
    {
        if (FT_GetStatus(handle, out uint amountInRxQueue, out uint _, out uint _) == FT_STATUS.FT_OK)
            return (int)amountInRxQueue;

        return 0;
    }

    public static byte ReadByte(FT_HANDLE handle)
    {
        FT_STATUS status = FT_ReadByte(handle, out byte buffer, 1, out uint bytesReturned);
        if (status != FT_STATUS.FT_OK || bytesReturned != 1)
            throw new InvalidOperationException();

        return buffer;
    }

    public static void Read(FT_HANDLE handle, byte[] buffer)
    {
        FT_STATUS status = FT_Read(handle, buffer, (uint)buffer.Length, out uint bytesReturned);
        if (status != FT_STATUS.FT_OK || bytesReturned != buffer.Length)
            throw new InvalidOperationException();
    }

    internal enum FT_DEVICE : uint
    {
        FT_DEVICE_232BM,
        FT_DEVICE_232AM,
        FT_DEVICE_100AX,
        FT_DEVICE_UNKNOWN,
        FT_DEVICE_2232C,
        FT_DEVICE_232R,
        FT_DEVICE_2232H,
        FT_DEVICE_4232H
    }

    internal enum FT_STATUS
    {
        FT_OK,
        FT_INVALID_HANDLE,
        FT_DEVICE_NOT_FOUND,
        FT_DEVICE_NOT_OPENED,
        FT_IO_ERROR,
        FT_INSUFFICIENT_RESOURCES,
        FT_INVALID_PARAMETER,
        FT_INVALID_BAUD_RATE,
        FT_DEVICE_NOT_OPENED_FOR_ERASE,
        FT_DEVICE_NOT_OPENED_FOR_WRITE,
        FT_FAILED_TO_WRITE_DEVICE,
        FT_EEPROM_READ_FAILED,
        FT_EEPROM_WRITE_FAILED,
        FT_EEPROM_ERASE_FAILED,
        FT_EEPROM_NOT_PRESENT,
        FT_EEPROM_NOT_PROGRAMMED,
        FT_INVALID_ARGS,
        FT_OTHER_ERROR
    }

    internal enum FT_FLOW_CONTROL : ushort
    {
        FT_FLOW_DTR_DSR = 512,
        FT_FLOW_NONE = 0,
        FT_FLOW_RTS_CTS = 256,
        FT_FLOW_XON_XOFF = 1024
    }

    internal enum FT_PURGE : uint
    {
        FT_PURGE_RX = 1,
        FT_PURGE_TX = 2,
        FT_PURGE_ALL = 3
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct FT_HANDLE
    {
        private readonly uint _handle;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct FT_DEVICE_INFO_NODE
    {
        public uint Flags;
        public FT_DEVICE Type;
        public uint ID;
        public uint LocId;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]
        public string SerialNumber;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
        public string Description;

        public FT_HANDLE Handle;
    }
}
```

`LibreHardwareMonitorLib/Interop/Gdi32.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

// ReSharper disable IdentifierTypo
// ReSharper disable InconsistentNaming

using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Interop;

internal static class Gdi32
{
    internal const string DllName = "Gdi32.dll";

    [DllImport(DllName, ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern uint D3DKMTCloseAdapter(ref D3dkmth.D3DKMT_CLOSEADAPTER closeAdapter);

    [DllImport(DllName, ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern uint D3DKMTOpenAdapterFromDeviceName(ref D3dkmth.D3DKMT_OPENADAPTERFROMDEVICENAME openAdapterFromDeviceName);

    [DllImport(DllName, ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern uint D3DKMTQueryAdapterInfo(ref D3dkmth.D3DKMT_QUERYADAPTERINFO queryAdapterInfo);

    [DllImport(DllName, ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern uint D3DKMTQueryStatistics(ref D3dkmth.D3DKMT_QUERYSTATISTICS queryStatistics);
}
```

`LibreHardwareMonitorLib/Interop/InpOut.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Interop;

internal class InpOut
{
    public delegate IntPtr MapPhysToLinDelegate(IntPtr pbPhysAddr, uint dwPhysSize, out IntPtr pPhysicalMemoryHandle);

    public delegate bool UnmapPhysicalMemoryDelegate(IntPtr PhysicalMemoryHandle, IntPtr pbLinAddr);

    [DllImport("inpout.dll", EntryPoint = "MapPhysToLin", CallingConvention = CallingConvention.StdCall)]
    public static extern IntPtr MapPhysToLin(IntPtr pbPhysAddr, uint dwPhysSize, out IntPtr pPhysicalMemoryHandle);

    [DllImport("inpout.dll", EntryPoint = "UnmapPhysicalMemory", CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool UnmapPhysicalMemory(IntPtr PhysicalMemoryHandle, IntPtr pbLinAddr);
}
```

`LibreHardwareMonitorLib/Interop/Kernel32.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.IO;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Interop;

public class Kernel32
{
    public const int ERROR_SERVICE_ALREADY_RUNNING = unchecked((int)0x80070420);

    public const int ERROR_SERVICE_EXISTS = unchecked((int)0x80070431);

    internal const uint BATTERY_UNKNOWN_TIME = 0xFFFFFFFF;
    internal const string IntelNVMeMiniPortSignature1 = "NvmeMini";
    internal const string IntelNVMeMiniPortSignature2 = "IntelNvm";

    internal const uint LPTR = 0x0000 | 0x0040;

    internal const int MAX_DRIVE_ATTRIBUTES = 512;
    internal const uint NVME_PASS_THROUGH_SRB_IO_CODE = 0xe0002000;
    internal const byte SMART_LBA_HI = 0xC2;
    internal const byte SMART_LBA_HI_EXCEEDED = 0x2C;
    internal const byte SMART_LBA_MID = 0x4F;
    internal const byte SMART_LBA_MID_EXCEEDED = 0xF4;

    private const string DllName = "kernel32.dll";

    [Flags]
    public enum NVME_CRITICAL_WARNING
    {
        None = 0x00,

        /// <summary>
        /// If set to 1, then the available spare space has fallen below the threshold.
        /// </summary>
        AvailableSpaceLow = 0x01,

        /// <summary>
        /// If set to 1, then a temperature is above an over temperature threshold or below an under temperature threshold.
        /// </summary>
        TemperatureThreshold = 0x02,

        /// <summary>
        /// If set to 1, then the device reliability has been degraded due to significant media related errors or any internal error that degrades device reliability.
        /// </summary>
        ReliabilityDegraded = 0x04,

        /// <summary>
        /// If set to 1, then the media has been placed in read only mode
        /// </summary>
        ReadOnly = 0x08,

        /// <summary>
        /// If set to 1, then the volatile memory backup device has failed. This field is only valid if the controller has a volatile memory backup solution.
        /// </summary>
        VolatileMemoryBackupDeviceFailed = 0x10
    }

    /// <summary>
    /// Create a instance from a struct with zero initialized memory arrays
    /// no need to init every inner array with the correct sizes
    /// </summary>
    /// <typeparam name="T">type of struct that is needed</typeparam>
    /// <returns></returns>
    internal static T CreateStruct<T>()
    {
        int size = Marshal.SizeOf<T>();
        IntPtr ptr = Marshal.AllocHGlobal(size);
        RtlZeroMemory(ptr, size);
        T result = Marshal.PtrToStructure<T>(ptr);
        Marshal.FreeHGlobal(ptr);
        return result;
    }

    internal static SafeHandle OpenDevice(string devicePath)
    {
        SafeHandle hDevice = CreateFile(devicePath, FileAccess.ReadWrite, FileShare.ReadWrite, IntPtr.Zero, FileMode.Open, FileAttributes.Normal, IntPtr.Zero);
        if (hDevice.IsInvalid || hDevice.IsClosed)
            hDevice = null;

        return hDevice;
    }

    [DllImport(DllName, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool GlobalMemoryStatusEx(ref MEMORYSTATUSEX lpBuffer);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern SafeFileHandle CreateFile
    (
        [MarshalAs(UnmanagedType.LPTStr)] string lpFileName,
        [MarshalAs(UnmanagedType.U4)] FileAccess dwDesiredAccess,
        [MarshalAs(UnmanagedType.U4)] FileShare dwShareMode,
        IntPtr lpSecurityAttributes,
        [MarshalAs(UnmanagedType.U4)] FileMode dwCreationDisposition,
        [MarshalAs(UnmanagedType.U4)] FileAttributes dwFlagsAndAttributes,
        IntPtr hTemplateFile);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeHandle hDevice,
        DFP dwIoControlCode,
        ref SENDCMDINPARAMS lpInBuffer,
        int nInBufferSize,
        out ATTRIBUTECMDOUTPARAMS lpOutBuffer,
        int nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeHandle hDevice,
        DFP dwIoControlCode,
        ref SENDCMDINPARAMS lpInBuffer,
        int nInBufferSize,
        out THRESHOLDCMDOUTPARAMS lpOutBuffer,
        int nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeHandle hDevice,
        DFP dwIoControlCode,
        ref SENDCMDINPARAMS lpInBuffer,
        int nInBufferSize,
        out SENDCMDOUTPARAMS lpOutBuffer,
        int nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeHandle hDevice,
        DFP dwIoControlCode,
        ref SENDCMDINPARAMS lpInBuffer,
        int nInBufferSize,
        out IDENTIFYCMDOUTPARAMS lpOutBuffer,
        int nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeHandle hDevice,
        DFP dwIoControlCode,
        ref SENDCMDINPARAMS lpInBuffer,
        int nInBufferSize,
        out STATUSCMDOUTPARAMS lpOutBuffer,
        int nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeHandle hDevice,
        IOCTL dwIoControlCode,
        ref STORAGE_PROPERTY_QUERY lpInBuffer,
        int nInBufferSize,
        out STORAGE_DEVICE_DESCRIPTOR_HEADER lpOutBuffer,
        int nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeHandle hDevice,
        IOCTL dwIoControlCode,
        ref STORAGE_PROPERTY_QUERY lpInBuffer,
        int nInBufferSize,
        IntPtr lpOutBuffer,
        uint nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeHandle hDevice,
        IOCTL dwIoControlCode,
        IntPtr lpInBuffer,
        int nInBufferSize,
        IntPtr lpOutBuffer,
        int nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeFileHandle hDevice,
        IOCTL dwIoControlCode,
        ref BATTERY_QUERY_INFORMATION lpInBuffer,
        int nInBufferSize,
        ref BATTERY_INFORMATION lpOutBuffer,
        int nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeFileHandle hDevice,
        IOCTL dwIoControlCode,
        ref uint lpInBuffer,
        int nInBufferSize,
        ref uint lpOutBuffer,
        int nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeFileHandle hDevice,
        IOCTL dwIoControlCode,
        ref BATTERY_WAIT_STATUS lpInBuffer,
        int nInBufferSize,
        ref BATTERY_STATUS lpOutBuffer,
        int nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeFileHandle hDevice,
        IOCTL dwIoControlCode,
        ref BATTERY_QUERY_INFORMATION lpInBuffer,
        int nInBufferSize,
        IntPtr lpOutBuffer,
        int nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool DeviceIoControl
    (
        SafeFileHandle hDevice,
        IOCTL dwIoControlCode,
        ref BATTERY_QUERY_INFORMATION lpInBuffer,
        int nInBufferSize,
        ref uint lpOutBuffer,
        int nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern IntPtr LocalAlloc(uint uFlags, ulong uBytes);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern IntPtr LocalFree(IntPtr hMem);

    [DllImport(DllName, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern void RtlZeroMemory(IntPtr Destination, int Length);

    [DllImport(DllName, SetLastError = false)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern void RtlCopyMemory(IntPtr Destination, IntPtr Source, uint Length);

    [DllImport(DllName, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern IntPtr LoadLibrary(string lpFileName);

    [DllImport(DllName, ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern IntPtr GetProcAddress(IntPtr module, string methodName);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool FreeLibrary(IntPtr module);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern IntPtr GetCurrentThread();

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern ushort GetActiveProcessorGroupCount();

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern bool SetThreadGroupAffinity(IntPtr thread, ref GROUP_AFFINITY groupAffinity, out GROUP_AFFINITY previousGroupAffinity);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern IntPtr VirtualAlloc(IntPtr lpAddress, UIntPtr dwSize, MEM flAllocationType, PAGE flProtect);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern bool VirtualFree(IntPtr lpAddress, UIntPtr dwSize, MEM dwFreeType);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern bool DeviceIoControl
    (
        SafeFileHandle device,
        IOControlCode ioControlCode,
        [MarshalAs(UnmanagedType.AsAny)] [In] object inBuffer,
        uint inBufferSize,
        [MarshalAs(UnmanagedType.AsAny)] [Out] object outBuffer,
        uint nOutBufferSize,
        out uint bytesReturned,
        IntPtr overlapped);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern IntPtr CreateFile
    (
        string lpFileName,
        uint dwDesiredAccess,
        FileShare dwShareMode,
        IntPtr lpSecurityAttributes,
        FileMode dwCreationDisposition,
        FileAttributes dwFlagsAndAttributes,
        IntPtr hTemplateFile);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern int EnumSystemFirmwareTables(Provider firmwareTableProviderSignature, IntPtr firmwareTableBuffer, int bufferSize);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern int GetSystemFirmwareTable(Provider firmwareTableProviderSignature, int firmwareTableID, IntPtr firmwareTableBuffer, int bufferSize);

    [StructLayout(LayoutKind.Sequential, Pack = 4)]
    public struct GROUP_AFFINITY
    {
        public UIntPtr Mask;

        [MarshalAs(UnmanagedType.U2)]
        public ushort Group;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.U2)]
        public ushort[] Reserved;
    }

    internal enum DFP : uint
    {
        DFP_GET_VERSION = 0x00074080,
        DFP_SEND_DRIVE_COMMAND = 0x0007c084,
        DFP_RECEIVE_DRIVE_DATA = 0x0007c088
    }

    internal enum IOCTL : uint
    {
        IOCTL_SCSI_PASS_THROUGH = 0x04d004,
        IOCTL_SCSI_MINIPORT = 0x04d008,
        IOCTL_SCSI_PASS_THROUGH_DIRECT = 0x04d014,
        IOCTL_SCSI_GET_ADDRESS = 0x41018,
        IOCTL_STORAGE_QUERY_PROPERTY = 0x2D1400,
        IOCTL_BATTERY_QUERY_TAG = 0x294040,
        IOCTL_BATTERY_QUERY_INFORMATION = 0x294044,
        IOCTL_BATTERY_QUERY_STATUS = 0x29404C
    }

    [Flags]
    internal enum BatteryCapabilities : uint
    {
        BATTERY_CAPACITY_RELATIVE = 0x40000000,
        BATTERY_IS_SHORT_TERM = 0x20000000,
        BATTERY_SET_CHARGE_SUPPORTED = 0x00000001,
        BATTERY_SET_DISCHARGE_SUPPORTED = 0x00000002,
        BATTERY_SYSTEM_BATTERY = 0x80000000
    }

    internal enum BATTERY_QUERY_INFORMATION_LEVEL
    {
        BatteryInformation,
        BatteryGranularityInformation,
        BatteryTemperature,
        BatteryEstimatedTime,
        BatteryDeviceName,
        BatteryManufactureDate,
        BatteryManufactureName,
        BatteryUniqueID,
        BatterySerialNumber
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct BATTERY_QUERY_INFORMATION
    {
        public uint BatteryTag;
        public BATTERY_QUERY_INFORMATION_LEVEL InformationLevel;
        public uint AtRate;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct BATTERY_INFORMATION
    {
        public BatteryCapabilities Capabilities;
        public byte Technology;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
        public byte[] Reserved;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
        public char[] Chemistry;

        public uint DesignedCapacity;
        public uint FullChargedCapacity;
        public uint DefaultAlert1;
        public uint DefaultAlert2;
        public uint CriticalBias;
        public uint CycleCount;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct BATTERY_WAIT_STATUS
    {
        public uint BatteryTag;
        public uint Timeout;
        public uint PowerState;
        public uint LowCapacity;
        public uint HighCapacity;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct BATTERY_STATUS
    {
        public uint PowerState;
        public uint Capacity;
        public uint Voltage;
        public int Rate;
    }

    [Flags]
    internal enum NVME_DIRECTION : uint
    {
        NVME_FROM_HOST_TO_DEV = 1,
        NVME_FROM_DEV_TO_HOST = 2,
        NVME_BI_DIRECTION = NVME_FROM_DEV_TO_HOST | NVME_FROM_HOST_TO_DEV
    }

    internal enum NVME_LOG_PAGES
    {
        NVME_LOG_PAGE_ERROR_INFO = 0x01,
        NVME_LOG_PAGE_HEALTH_INFO = 0x02,
        NVME_LOG_PAGE_FIRMWARE_SLOT_INFO = 0x03,
        NVME_LOG_PAGE_CHANGED_NAMESPACE_LIST = 0x04,
        NVME_LOG_PAGE_COMMAND_EFFECTS = 0x05,
        NVME_LOG_PAGE_DEVICE_SELF_TEST = 0x06,
        NVME_LOG_PAGE_TELEMETRY_HOST_INITIATED = 0x07,
        NVME_LOG_PAGE_TELEMETRY_CTLR_INITIATED = 0x08,
        NVME_LOG_PAGE_RESERVATION_NOTIFICATION = 0x80,
        NVME_LOG_PAGE_SANITIZE_STATUS = 0x81
    }

    internal enum ATA_COMMAND : byte
    {
        /// <summary>
        /// SMART data requested.
        /// </summary>
        ATA_SMART = 0xB0,

        /// <summary>
        /// Identify data is requested.
        /// </summary>
        ATA_IDENTIFY_DEVICE = 0xEC
    }

    internal enum SCSI_IOCTL_DATA
    {
        SCSI_IOCTL_DATA_OUT = 0,
        SCSI_IOCTL_DATA_IN = 1,
        SCSI_IOCTL_DATA_UNSPECIFIED = 2
    }

    internal enum SMART_FEATURES : byte
    {
        /// <summary>
        /// Read SMART data.
        /// </summary>
        SMART_READ_DATA = 0xD0,

        /// <summary>
        /// Read SMART thresholds.
        /// obsolete
        /// </summary>
        READ_THRESHOLDS = 0xD1,

        /// <summary>
        /// Autosave SMART data.
        /// </summary>
        ENABLE_DISABLE_AUTOSAVE = 0xD2,

        /// <summary>
        /// Save SMART attributes.
        /// </summary>
        SAVE_ATTRIBUTE_VALUES = 0xD3,

        /// <summary>
        /// Set SMART to offline immediately.
        /// </summary>
        EXECUTE_OFFLINE_DIAGS = 0xD4,

        /// <summary>
        /// Read SMART log.
        /// </summary>
        SMART_READ_LOG = 0xD5,

        /// <summary>
        /// Write SMART log.
        /// </summary>
        SMART_WRITE_LOG = 0xD6,

        /// <summary>
        /// Write SMART thresholds.
        /// obsolete
        /// </summary>
        WRITE_THRESHOLDS = 0xD7,

        /// <summary>
        /// Enable SMART.
        /// </summary>
        ENABLE_SMART = 0xD8,

        /// <summary>
        /// Disable SMART.
        /// </summary>
        DISABLE_SMART = 0xD9,

        /// <summary>
        /// Get SMART status.
        /// </summary>
        RETURN_SMART_STATUS = 0xDA,

        /// <summary>
        /// Set SMART to offline automatically.
        /// </summary>
        ENABLE_DISABLE_AUTO_OFFLINE = 0xDB /* obsolete */
    }

    internal enum STORAGE_BUS_TYPE
    {
        BusTypeUnknown = 0x00,
        BusTypeScsi,
        BusTypeAtapi,
        BusTypeAta,
        BusType1394,
        BusTypeSsa,
        BusTypeFibre,
        BusTypeUsb,
        BusTypeRAID,
        BusTypeiScsi,
        BusTypeSas,
        BusTypeSata,
        BusTypeSd,
        BusTypeMmc,
        BusTypeVirtual,
        BusTypeFileBackedVirtual,
        BusTypeSpaces,
        BusTypeNvme,
        BusTypeSCM,
        BusTypeMax,
        BusTypeMaxReserved = 0x7F
    }

    internal enum STORAGE_PROPERTY_ID
    {
        StorageDeviceProperty = 0,
        StorageAdapterProperty,
        StorageDeviceIdProperty,
        StorageDeviceUniqueIdProperty,
        StorageDeviceWriteCacheProperty,
        StorageMiniportProperty,
        StorageAccessAlignmentProperty,
        StorageDeviceSeekPenaltyProperty,
        StorageDeviceTrimProperty,
        StorageDeviceWriteAggregationProperty,
        StorageDeviceDeviceTelemetryProperty,
        StorageDeviceLBProvisioningProperty,
        StorageDevicePowerProperty,
        StorageDeviceCopyOffloadProperty,
        StorageDeviceResiliencyProperty,
        StorageDeviceMediumProductType,
        StorageAdapterRpmbProperty,
        StorageDeviceIoCapabilityProperty = 48,
        StorageAdapterProtocolSpecificProperty,
        StorageDeviceProtocolSpecificProperty,
        StorageAdapterTemperatureProperty,
        StorageDeviceTemperatureProperty,
        StorageAdapterPhysicalTopologyProperty,
        StorageDevicePhysicalTopologyProperty,
        StorageDeviceAttributesProperty,
        StorageDeviceManagementStatus,
        StorageAdapterSerialNumberProperty,
        StorageDeviceLocationProperty
    }

    internal enum STORAGE_PROTOCOL_NVME_DATA_TYPE
    {
        NVMeDataTypeUnknown = 0,
        NVMeDataTypeIdentify,
        NVMeDataTypeLogPage,
        NVMeDataTypeFeature
    }

    internal enum STORAGE_PROTOCOL_NVME_PROTOCOL_DATA_REQUEST_VALUE
    {
        NVMeIdentifyCnsSpecificNamespace = 0,
        NVMeIdentifyCnsController = 1,
        NVMeIdentifyCnsActiveNamespaces = 2
    }

    internal enum STORAGE_PROTOCOL_TYPE
    {
        ProtocolTypeUnknown = 0x00,
        ProtocolTypeScsi,
        ProtocolTypeAta,
        ProtocolTypeNvme,
        ProtocolTypeSd,
        ProtocolTypeProprietary = 0x7E,
        ProtocolTypeMaxReserved = 0x7F
    }

    internal enum STORAGE_QUERY_TYPE
    {
        PropertyStandardQuery = 0,
        PropertyExistsQuery,
        PropertyMaskQuery,
        PropertyQueryMaxDefined
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct MEMORYSTATUSEX
    {
        public uint dwLength;
        public uint dwMemoryLoad;
        public ulong ullTotalPhys;
        public ulong ullAvailPhys;
        public ulong ullTotalPageFile;
        public ulong ullAvailPageFile;
        public ulong ullTotalVirtual;
        public ulong ullAvailVirtual;
        public ulong ullAvailExtendedVirtual;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct SMART_ATTRIBUTE
    {
        public byte Id;
        public short Flags;
        public byte CurrentValue;
        public byte WorstValue;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)]
        public byte[] RawValue;

        public byte Reserved;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct SMART_THRESHOLD
    {
        public byte Id;
        public byte Threshold;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
        public byte[] Reserved;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct SENDCMDINPARAMS
    {
        public uint cBufferSize;
        public IDEREGS irDriveRegs;
        public byte bDriveNumber;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
        public byte[] bReserved;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
        public uint[] dwReserved;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
        public byte[] bBuffer;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct IDEREGS
    {
        public SMART_FEATURES bFeaturesReg;
        public byte bSectorCountReg;
        public byte bSectorNumberReg;
        public byte bCylLowReg;
        public byte bCylHighReg;
        public byte bDriveHeadReg;
        public ATA_COMMAND bCommandReg;
        public byte bReserved;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct DRIVERSTATUS
    {
        public byte bDriverError;
        public byte bIDEError;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
        public byte[] Reserved;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct SENDCMDOUTPARAMS
    {
        public uint cBufferSize;
        public DRIVERSTATUS DriverStatus;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
        public byte[] bBuffer;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct ATTRIBUTECMDOUTPARAMS
    {
        public uint cBufferSize;
        public DRIVERSTATUS DriverStatus;
        public byte Version;
        public byte Reserved;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_DRIVE_ATTRIBUTES)]
        public SMART_ATTRIBUTE[] Attributes;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct THRESHOLDCMDOUTPARAMS
    {
        public uint cBufferSize;
        public DRIVERSTATUS DriverStatus;
        public byte Version;
        public byte Reserved;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_DRIVE_ATTRIBUTES)]
        public SMART_THRESHOLD[] Thresholds;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct STATUSCMDOUTPARAMS
    {
        public uint cBufferSize;
        public DRIVERSTATUS DriverStatus;
        public IDEREGS irDriveRegs;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct IDENTIFY_DATA
    {
        public ushort GeneralConfiguration;
        public ushort NumberOfCylinders;
        public ushort Reserved1;
        public ushort NumberOfHeads;
        public ushort UnformattedBytesPerTrack;
        public ushort UnformattedBytesPerSector;
        public ushort SectorsPerTrack;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
        public ushort[] VendorUnique;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 20)]
        public byte[] SerialNumber;

        public ushort BufferType;
        public ushort BufferSectorSize;
        public ushort NumberOfEccBytes;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public byte[] FirmwareRevision;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 40)]
        public byte[] ModelNumber;

        public byte MaximumBlockTransfer;
        public byte VendorUnique2;
        public ushort DoubleWordIo;
        public ushort Capabilities;
        public ushort Reserved2;
        public byte VendorUnique3;
        public byte PioCycleTimingMode;
        public byte VendorUnique4;
        public byte DmaCycleTimingMode;
        public ushort TranslationFieldsValid;
        public ushort NumberOfCurrentCylinders;
        public ushort NumberOfCurrentHeads;
        public ushort CurrentSectorsPerTrack;
        public uint CurrentSectorCapacity;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 197)]
        public ushort[] Reserved3;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct IDENTIFYCMDOUTPARAMS
    {
        public uint cBufferSize;
        public DRIVERSTATUS DriverStatus;
        public IDENTIFY_DATA Identify;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct STORAGE_PROPERTY_QUERY
    {
        public STORAGE_PROPERTY_ID PropertyId;
        public STORAGE_QUERY_TYPE QueryType;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
        public byte[] AdditionalParameters;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct STORAGE_DEVICE_DESCRIPTOR_HEADER
    {
        public uint Version;
        public uint Size;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct STORAGE_DEVICE_DESCRIPTOR
    {
        public uint Version;
        public uint Size;
        public byte DeviceType;
        public byte DeviceTypeModifier;

        [MarshalAs(UnmanagedType.U1)]
        public bool RemovableMedia;

        [MarshalAs(UnmanagedType.U1)]
        public bool CommandQueueing;

        public uint VendorIdOffset;
        public uint ProductIdOffset;
        public uint ProductRevisionOffset;
        public uint SerialNumberOffset;
        public STORAGE_BUS_TYPE BusType;
        public uint RawPropertiesLength;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct SRB_IO_CONTROL
    {
        public uint HeaderLenght;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public byte[] Signature;

        public uint Timeout;
        public uint ControlCode;
        public uint ReturnCode;
        public uint Length;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NVME_PASS_THROUGH_IOCTL
    {
        public SRB_IO_CONTROL srb;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)]
        public uint[] VendorSpecific;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public uint[] NVMeCmd;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
        public uint[] CplEntry;

        public NVME_DIRECTION Direction;
        public uint QueueId;
        public uint DataBufferLen;
        public uint MetaDataLen;
        public uint ReturnBufferLen;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4096)]
        public byte[] DataBuffer;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct SCSI_PASS_THROUGH
    {
        [MarshalAs(UnmanagedType.U2)]
        public ushort Length;

        public byte ScsiStatus;
        public byte PathId;
        public byte TargetId;
        public byte Lun;
        public byte CdbLength;
        public byte SenseInfoLength;
        public byte DataIn;
        public uint DataTransferLength;
        public uint TimeOutValue;
        public IntPtr DataBufferOffset;
        public uint SenseInfoOffset;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] Cdb;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct SCSI_PASS_THROUGH_WITH_BUFFERS
    {
        public SCSI_PASS_THROUGH Spt;

        public uint Filler;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
        public byte[] SenseBuf;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4096)]
        public byte[] DataBuf;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NVME_POWER_STATE_DESC
    {
        /// <summary>
        /// bit 0:15 Maximum  Power (MP) in centiwatts
        /// </summary>
        public ushort MP;

        /// <summary>
        /// bit 16:23
        /// </summary>
        public byte Reserved0;

        /// <summary>
        /// bit 24 Max Power Scale (MPS), bit 25 Non-Operational State (NOPS)
        /// </summary>
        public byte MPS_NOPS;

        /// <summary>
        /// bit 32:63 Entry Latency (ENLAT) in microseconds
        /// </summary>
        public uint ENLAT;

        /// <summary>
        /// bit 64:95 Exit Latency (EXLAT) in microseconds
        /// </summary>
        public uint EXLAT;

        /// <summary>
        /// bit 96:100 Relative Read Throughput (RRT)
        /// </summary>
        public byte RRT;

        /// <summary>
        /// bit 104:108 Relative Read Latency (RRL)
        /// </summary>
        public byte RRL;

        /// <summary>
        /// bit 112:116 Relative Write Throughput (RWT)
        /// </summary>
        public byte RWT;

        /// <summary>
        /// bit 120:124 Relative Write Latency (RWL)
        /// </summary>
        public byte RWL;

        /// <summary>
        /// bit 128:143 Idle Power (IDLP)
        /// </summary>
        public ushort IDLP;

        /// <summary>
        /// bit 150:151 Idle Power Scale (IPS)
        /// </summary>
        public byte IPS;

        /// <summary>
        /// bit 152:159
        /// </summary>
        public byte Reserved7;

        /// <summary>
        /// bit 160:175 Active Power (ACTP)
        /// </summary>
        public ushort ACTP;

        /// <summary>
        /// bit 176:178 Active Power Workload (APW), bit 182:183  Active Power Scale (APS)
        /// </summary>
        public byte APW_APS;

        /// <summary>
        /// bit 184:255.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 9)]
        public byte[] Reserved9;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NVME_IDENTIFY_CONTROLLER_DATA
    {
        /// <summary>
        /// byte 0:1 M - PCI Vendor ID (VID)
        /// </summary>
        public ushort VID;

        /// <summary>
        /// byte 2:3 M - PCI Subsystem Vendor ID (SSVID)
        /// </summary>
        public ushort SSVID;

        /// <summary>
        /// byte 4: 23 M - Serial Number (SN)
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 20)]
        public byte[] SN;

        /// <summary>
        /// byte 24:63 M - Model Number (MN)
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 40)]
        public byte[] MN;

        /// <summary>
        /// byte 64:71 M - Firmware Revision (FR)
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public byte[] FR;

        /// <summary>
        /// byte 72 M - Recommended Arbitration Burst (RAB)
        /// </summary>
        public byte RAB;

        /// <summary>
        /// byte 73:75 M - IEEE OUI Identifier (IEEE). Controller Vendor code.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
        public byte[] IEEE;

        /// <summary>
        /// byte 76 O - Controller Multi-Path I/O and Namespace Sharing Capabilities (CMIC)
        /// </summary>
        public byte CMIC;

        /// <summary>
        /// byte 77 M - Maximum Data Transfer Size (MDTS)
        /// </summary>
        public byte MDTS;

        /// <summary>
        /// byte 78:79 M - Controller ID (CNTLID)
        /// </summary>
        public ushort CNTLID;

        /// <summary>
        /// byte 80:83 M - Version (VER)
        /// </summary>
        public uint VER;

        /// <summary>
        /// byte 84:87 M - RTD3 Resume Latency (RTD3R)
        /// </summary>
        public uint RTD3R;

        /// <summary>
        /// byte 88:91 M - RTD3 Entry Latency (RTD3E)
        /// </summary>
        public uint RTD3E;

        /// <summary>
        /// byte 92:95 M - Optional Asynchronous Events Supported (OAES)
        /// </summary>
        public uint OAES;

        /// <summary>
        /// byte 96:239.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 144)]
        public byte[] Reserved0;

        /// <summary>
        /// byte 240:255.  Refer to the NVMe Management Interface Specification for definition.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] ReservedForManagement;

        /// <summary>
        /// byte 256:257 M - Optional Admin Command Support (OACS)
        /// </summary>
        public ushort OACS;

        /// <summary>
        /// byte 258 M - Abort Command Limit (ACL)
        /// </summary>
        public byte ACL;

        /// <summary>
        /// byte 259 M - Asynchronous Event Request Limit (AERL)
        /// </summary>
        public byte AERL;

        /// <summary>
        /// byte 260 M - Firmware Updates (FRMW)
        /// </summary>
        public byte FRMW;

        /// <summary>
        /// byte 261 M - Log Page Attributes (LPA)
        /// </summary>
        public byte LPA;

        /// <summary>
        /// byte 262 M - Error Log Page Entries (ELPE)
        /// </summary>
        public byte ELPE;

        /// <summary>
        /// byte 263 M - Number of Power States Support (NPSS)
        /// </summary>
        public byte NPSS;

        /// <summary>
        /// byte 264 M - Admin Vendor Specific Command Configuration (AVSCC)
        /// </summary>
        public byte AVSCC;

        /// <summary>
        /// byte 265 O - Autonomous Power State Transition Attributes (APSTA)
        /// </summary>
        public byte APSTA;

        /// <summary>
        /// byte 266:267 M - Warning Composite Temperature Threshold (WCTEMP)
        /// </summary>
        public ushort WCTEMP;

        /// <summary>
        /// byte 268:269 M - Critical Composite Temperature Threshold (CCTEMP)
        /// </summary>
        public ushort CCTEMP;

        /// <summary>
        /// byte 270:271 O - Maximum Time for Firmware Activation (MTFA)
        /// </summary>
        public ushort MTFA;

        /// <summary>
        /// byte 272:275 O - Host Memory Buffer Preferred Size (HMPRE)
        /// </summary>
        public uint HMPRE;

        /// <summary>
        /// byte 276:279 O - Host Memory Buffer Minimum Size (HMMIN)
        /// </summary>
        public uint HMMIN;

        /// <summary>
        /// byte 280:295 O - Total NVM Capacity (TNVMCAP)
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] TNVMCAP;

        /// <summary>
        /// byte 296:311 O - Unallocated NVM Capacity (UNVMCAP)
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] UNVMCAP;

        /// <summary>
        /// byte 312:315 O - Replay Protected Memory Block Support (RPMBS)
        /// </summary>
        public uint RPMBS;

        /// <summary>
        /// byte 316:511
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 196)]
        public byte[] Reserved1;

        /// <summary>
        /// byte 512 M - Submission Queue Entry Size (SQES)
        /// </summary>
        public byte SQES;

        /// <summary>
        /// byte 513 M - Completion Queue Entry Size (CQES)
        /// </summary>
        public byte CQES;

        /// <summary>
        /// byte 514:515
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
        public byte[] Reserved2;

        /// <summary>
        /// byte 516:519 M - Number of Namespaces (NN)
        /// </summary>
        public uint NN;

        /// <summary>
        /// byte 520:521 M - Optional NVM Command Support (ONCS)
        /// </summary>
        public ushort ONCS;

        /// <summary>
        /// byte 522:523 M - Fused Operation Support (FUSES)
        /// </summary>
        public ushort FUSES;

        /// <summary>
        /// byte 524 M - Format NVM Attributes (FNA)
        /// </summary>
        public byte FNA;

        /// <summary>
        /// byte 525 M - Volatile Write Cache (VWC)
        /// </summary>
        public byte VWC;

        /// <summary>
        /// byte 526:527 M - Atomic Write Unit Normal (AWUN)
        /// </summary>
        public ushort AWUN;

        /// <summary>
        /// byte 528:529 M - Atomic Write Unit Power Fail (AWUPF)
        /// </summary>
        public ushort AWUPF;

        /// <summary>
        /// byte 530 M - NVM Vendor Specific Command Configuration (NVSCC)
        /// </summary>
        public byte NVSCC;

        /// <summary>
        /// byte 531
        /// </summary>
        public byte Reserved3;

        /// <summary>
        /// byte 532:533 O - Atomic Compare and Write Unit (ACWU)
        /// </summary>
        public ushort ACWU;

        /// <summary>
        /// byte 534:535
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
        public byte[] Reserved4;

        /// <summary>
        /// byte 536:539 O - SGL Support (SGLS)
        /// </summary>
        public uint SGLS;

        /// <summary>
        /// byte 540:703
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 164)]
        public byte[] Reserved5;

        /// <summary>
        /// byte 704:2047
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1344)]
        public byte[] Reserved6;

        /// <summary>
        /// byte 2048:3071 Power State Descriptors
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
        public NVME_POWER_STATE_DESC[] PDS;

        /// <summary>
        /// byte 3072:4095 Vendor Specific
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1024)]
        public byte[] VS;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NVME_HEALTH_INFO_LOG
    {
        /// <summary>
        /// This field indicates critical warnings for the state of the  controller.
        /// Each bit corresponds to a critical warning type; multiple bits may be set.
        /// </summary>
        public byte CriticalWarning;

        /// <summary>
        /// Composite Temperature:  Contains the temperature of the overall device (controller and NVM included) in units of Kelvin.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
        public byte[] CompositeTemp;

        /// <summary>
        /// Available Spare:  Contains a normalized percentage (0 to 100%) of the remaining spare capacity available
        /// </summary>
        public byte AvailableSpare;

        /// <summary>
        /// Available Spare Threshold:  When the Available Spare falls below the threshold indicated in this field,
        /// an asynchronous event completion may occur. The value is indicated as a normalized percentage (0 to 100%).
        /// </summary>
        public byte AvailableSpareThreshold;

        /// <summary>
        /// Percentage Used:  Contains a vendor specific estimate of the percentage of NVM subsystem life used based on
        /// the actual usage and the manufacturer’s prediction of NVM life. A value of 100 indicates that the estimated endurance of
        /// the NVM in the NVM subsystem has been consumed, but may not indicate an NVM subsystem failure. The value is allowed to exceed 100.
        /// </summary>
        public byte PercentageUsed;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 26)]
        public byte[] Reserved1;

        /// <summary>
        /// Data Units Read:  Contains the number of 512 byte data units the host has read from the controller;
        /// this value does not include metadata. This value is reported in thousands
        /// (i.e., a value of 1 corresponds to 1000 units of 512 bytes read) and is rounded up.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] DataUnitRead;

        /// <summary>
        /// Data Units Written:  Contains the number of 512 byte data units the host has written to the controller;
        /// this value does not include metadata. This value is reported in thousands
        /// (i.e., a value of 1 corresponds to 1000 units of 512 bytes written) and is rounded up.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] DataUnitWritten;

        /// <summary>
        /// Host Read Commands:  Contains the number of read commands completed by the controller.
        /// For the NVM command set, this is the number of Compare and Read commands.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] HostReadCommands;

        /// <summary>
        /// Host Write Commands:  Contains the number of write commands completed by the controller.
        /// For the NVM command set, this is the number of Write commands.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] HostWriteCommands;

        /// <summary>
        /// Controller Busy Time:  Contains the amount of time the controller is busy with I/O commands.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] ControllerBusyTime;

        /// <summary>
        /// Power Cycles:  Contains the number of power cycles.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] PowerCycles;

        /// <summary>
        /// Power On Hours:  Contains the number of power-on hours.
        /// This does not include time that the controller was powered and in a low power state condition.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] PowerOnHours;

        /// <summary>
        /// Unsafe Shutdowns:  Contains the number of unsafe shutdowns.
        /// This count is incremented when a shutdown notification is not received prior to loss of power.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] UnsafeShutdowns;

        /// <summary>
        /// Media Errors:  Contains the number of occurrences where the controller detected an unrecoverable data integrity error.
        /// Errors such as uncorrectable ECC, CRC checksum failure, or LBA tag mismatch are included in this field.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] MediaAndDataIntegrityErrors;

        /// <summary>
        /// Number of Error Information Log Entries:  Contains the number of Error Information log entries over the life of the controller
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] NumberErrorInformationLogEntries;

        /// <summary>
        /// Warning Composite Temperature Time:  Contains the amount of time in minutes that the controller is operational and the Composite Temperature is greater than or equal to the Warning Composite
        /// Temperature Threshold.
        /// </summary>
        public uint WarningCompositeTemperatureTime;

        /// <summary>
        /// Critical Composite Temperature Time:  Contains the amount of time in minutes that the controller is operational and the Composite Temperature is greater than the Critical Composite Temperature
        /// Threshold.
        /// </summary>
        public uint CriticalCompositeTemperatureTime;

        /// <summary>
        /// Contains the current temperature reported by temperature sensor 1-8.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public ushort[] TemperatureSensor;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 296)]
        internal byte[] Reserved2;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct STORAGE_PROTOCOL_SPECIFIC_DATA
    {
        public STORAGE_PROTOCOL_TYPE ProtocolType;
        public uint DataType;
        public uint ProtocolDataRequestValue;
        public uint ProtocolDataRequestSubValue;
        public uint ProtocolDataOffset;
        public uint ProtocolDataLength;
        public uint FixedProtocolReturnData;
        public uint ProtocolDataRequestSubValue2;
        public uint ProtocolDataRequestSubValue3;
        public uint Reserved;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct STORAGE_QUERY_BUFFER
    {
        public STORAGE_PROPERTY_ID PropertyId;
        public STORAGE_QUERY_TYPE QueryType;
        public STORAGE_PROTOCOL_SPECIFIC_DATA ProtocolSpecific;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4096)]
        internal byte[] Buffer;
    }

    [Flags]
    internal enum MEM : uint
    {
        MEM_COMMIT = 0x1000,
        MEM_RESERVE = 0x2000,
        MEM_DECOMMIT = 0x4000,
        MEM_RELEASE = 0x8000,
        MEM_RESET = 0x80000,
        MEM_LARGE_PAGES = 0x20000000,
        MEM_PHYSICAL = 0x400000,
        MEM_TOP_DOWN = 0x100000,
        MEM_WRITE_WATCH = 0x200000
    }

    [Flags]
    internal enum PAGE : uint
    {
        PAGE_EXECUTE = 0x10,
        PAGE_EXECUTE_READ = 0x20,
        PAGE_EXECUTE_READWRITE = 0x40,
        PAGE_EXECUTE_WRITECOPY = 0x80,
        PAGE_NOACCESS = 0x01,
        PAGE_READONLY = 0x02,
        PAGE_READWRITE = 0x04,
        PAGE_WRITECOPY = 0x08,
        PAGE_GUARD = 0x100,
        PAGE_NOCACHE = 0x200,
        PAGE_WRITECOMBINE = 0x400
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct IOControlCode
    {
        /// <summary>
        /// Gets the resulting IO control code.
        /// </summary>
        public uint Code { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="IOControlCode" /> struct.
        /// </summary>
        /// <param name="deviceType">Type of the device.</param>
        /// <param name="function">The function.</param>
        /// <param name="access">The access.</param>
        public IOControlCode(uint deviceType, uint function, Access access) : this(deviceType, function, Method.Buffered, access)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="IOControlCode" /> struct.
        /// </summary>
        /// <param name="deviceType">Type of the device.</param>
        /// <param name="function">The function.</param>
        /// <param name="method">The method.</param>
        /// <param name="access">The access.</param>
        public IOControlCode(uint deviceType, uint function, Method method, Access access)
        {
            Code = (deviceType << 16) | ((uint)access << 14) | (function << 2) | (uint)method;
        }

        public enum Method : uint
        {
            Buffered = 0,
            InDirect = 1,
            OutDirect = 2,
            Neither = 3
        }

        public enum Access : uint
        {
            Any = 0,
            Read = 1,
            Write = 2
        }
    }

    internal enum Provider
    {
        ACPI = (byte)'A' << 24 | (byte)'C' << 16 | (byte)'P' << 8 | (byte)'I',
        FIRM = (byte)'F' << 24 | (byte)'I' << 16 | (byte)'R' << 8 | (byte)'M',
        RSMB = (byte)'R' << 24 | (byte)'S' << 16 | (byte)'M' << 8 | (byte)'B'
    }
}

```

`LibreHardwareMonitorLib/Interop/LibC.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Interop;

internal class LibC
{
    private const string DllName = "libc";

    [DllImport(DllName)]
    internal static extern int sched_getaffinity(int pid, IntPtr maskSize, ref ulong mask);

    [DllImport(DllName)]
    internal static extern int sched_setaffinity(int pid, IntPtr maskSize, ref ulong mask);
}
```

`LibreHardwareMonitorLib/Interop/NtDll.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Runtime.InteropServices;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Interop;

internal class NtDll
{
    private const string DllName = "ntdll.dll";

    [StructLayout(LayoutKind.Sequential)]
    internal struct SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
    {
        public long IdleTime;
        public long KernelTime;
        public long UserTime;
        public long DpcTime;
        public long InterruptTime;
        public uint InterruptCount;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct SYSTEM_PROCESSOR_IDLE_INFORMATION
    {
        public long IdleTime;
        public long C1Time;
        public long C2Time;
        public long C3Time;
        public uint C1Transitions;
        public uint C2Transitions;
        public uint C3Transitions;
        public uint Padding;
    }

    internal enum SYSTEM_INFORMATION_CLASS
    {
        SystemProcessorPerformanceInformation = 8,
        SystemProcessorIdleInformation = 42
    }

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern int NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, [Out] SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION[] SystemInformation, int SystemInformationLength, out int ReturnLength);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern int NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, [Out] SYSTEM_PROCESSOR_IDLE_INFORMATION[] SystemInformation, int SystemInformationLength, out int ReturnLength);
}

```

`LibreHardwareMonitorLib/Interop/NvApi.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace LibreHardwareMonitor.Interop;

internal static class NvApi
{
    public const int MAX_CLOCKS_PER_GPU = 0x120;
    public const int MAX_COOLERS_PER_GPU = 20;
    public const int MAX_FAN_CONTROLLER_ITEMS = 32;
    public const int MAX_FAN_COOLERS_STATUS_ITEMS = 32;
    public const int MAX_GPU_PUBLIC_CLOCKS = 32;
    public const int MAX_GPU_UTILIZATIONS = 8;
    public const int MAX_MEMORY_VALUES_PER_GPU = 5;
    public const int MAX_PHYSICAL_GPUS = 64;
    public const int MAX_POWER_TOPOLOGIES = 4;
    public const int MAX_THERMAL_SENSORS_PER_GPU = 3;
    public const int MAX_USAGES_PER_GPU = 8;

    public const int SHORT_STRING_MAX = 64;
    public const int THERMAL_SENSOR_RESERVED_COUNT = 8;
    public const int THERMAL_SENSOR_TEMPERATURE_COUNT = 32;

    private const string DllName = "nvapi.dll";
    private const string DllName64 = "nvapi64.dll";

    public static readonly NvAPI_EnumNvidiaDisplayHandleDelegate NvAPI_EnumNvidiaDisplayHandle;
    public static readonly NvAPI_EnumPhysicalGPUsDelegate NvAPI_EnumPhysicalGPUs;
    public static readonly NvAPI_GetDisplayDriverVersionDelegate NvAPI_GetDisplayDriverVersion;
    public static readonly NvAPI_GetPhysicalGPUsFromDisplayDelegate NvAPI_GetPhysicalGPUsFromDisplay;
    public static readonly NvAPI_GPU_ClientFanCoolersGetControlDelegate NvAPI_GPU_ClientFanCoolersGetControl;
    public static readonly NvAPI_GPU_ClientFanCoolersGetStatusDelegate NvAPI_GPU_ClientFanCoolersGetStatus;
    public static readonly NvAPI_GPU_ClientFanCoolersSetControlDelegate NvAPI_GPU_ClientFanCoolersSetControl;
    public static readonly NvAPI_GPU_ClientPowerTopologyGetStatusDelegate NvAPI_GPU_ClientPowerTopologyGetStatus;
    public static readonly NvAPI_GPU_GetAllClockFrequenciesDelegate NvAPI_GPU_GetAllClockFrequencies;
    public static readonly NvAPI_GPU_GetAllClocksDelegate NvAPI_GPU_GetAllClocks;
    public static readonly NvAPI_GPU_GetBusIdDelegate NvAPI_GPU_GetBusId;
    public static readonly NvAPI_GPU_GetCoolerSettingsDelegate NvAPI_GPU_GetCoolerSettings;
    public static readonly NvAPI_GPU_GetDynamicPstatesInfoExDelegate NvAPI_GPU_GetDynamicPstatesInfoEx;
    public static readonly NvAPI_GPU_GetMemoryInfoDelegate NvAPI_GPU_GetMemoryInfo;
    public static readonly NvAPI_GPU_GetPCIIdentifiersDelegate NvAPI_GPU_GetPCIIdentifiers;
    public static readonly NvAPI_GPU_GetTachReadingDelegate NvAPI_GPU_GetTachReading;
    public static readonly NvAPI_GPU_GetThermalSettingsDelegate NvAPI_GPU_GetThermalSettings;
    public static readonly NvAPI_GPU_GetUsagesDelegate NvAPI_GPU_GetUsages;
    public static readonly NvAPI_GPU_SetCoolerLevelsDelegate NvAPI_GPU_SetCoolerLevels;
    public static readonly NvAPI_GPU_GetThermalSensorsDelegate NvAPI_GPU_ThermalGetSensors;

    private static readonly NvAPI_GetInterfaceVersionStringDelegate _nvAPI_GetInterfaceVersionString;
    private static readonly NvAPI_GPU_GetFullNameDelegate _nvAPI_GPU_GetFullName;

    static NvApi()
    {
        NvAPI_InitializeDelegate nvApiInitialize;

        try
        {
            if (!DllExists())
                return;

            GetDelegate(0x0150E828, out nvApiInitialize);
        }
        catch (Exception e) when (e is DllNotFoundException or ArgumentNullException or EntryPointNotFoundException or BadImageFormatException)
        {
            return;
        }

        if (nvApiInitialize() == NvStatus.OK)
        {
            GetDelegate(0xE3640A56, out NvAPI_GPU_GetThermalSettings);
            GetDelegate(0xCEEE8E9F, out _nvAPI_GPU_GetFullName);
            GetDelegate(0x9ABDD40D, out NvAPI_EnumNvidiaDisplayHandle);
            GetDelegate(0x34EF9506, out NvAPI_GetPhysicalGPUsFromDisplay);
            GetDelegate(0xE5AC921F, out NvAPI_EnumPhysicalGPUs);
            GetDelegate(0x5F608315, out NvAPI_GPU_GetTachReading);
            GetDelegate(0x1BD69F49, out NvAPI_GPU_GetAllClocks);
            GetDelegate(0x60DED2ED, out NvAPI_GPU_GetDynamicPstatesInfoEx);
            GetDelegate(0x189A1FDF, out NvAPI_GPU_GetUsages);
            GetDelegate(0xDA141340, out NvAPI_GPU_GetCoolerSettings);
            GetDelegate(0x891FA0AE, out NvAPI_GPU_SetCoolerLevels);
            GetDelegate(0x774AA982, out NvAPI_GPU_GetMemoryInfo);
            GetDelegate(0xF951A4D1, out NvAPI_GetDisplayDriverVersion);
            GetDelegate(0x01053FA5, out _nvAPI_GetInterfaceVersionString);
            GetDelegate(0x2DDFB66E, out NvAPI_GPU_GetPCIIdentifiers);
            GetDelegate(0x1BE0B8E5, out NvAPI_GPU_GetBusId);
            GetDelegate(0x35AED5E8, out NvAPI_GPU_ClientFanCoolersGetStatus);
            GetDelegate(0xDCB616C3, out NvAPI_GPU_GetAllClockFrequencies);
            GetDelegate(0x814B209F, out NvAPI_GPU_ClientFanCoolersGetControl);
            GetDelegate(0xA58971A5, out NvAPI_GPU_ClientFanCoolersSetControl);
            GetDelegate(0x0EDCF624E, out NvAPI_GPU_ClientPowerTopologyGetStatus);
            GetDelegate(0x65FE3AAD, out NvAPI_GPU_ThermalGetSensors);

            IsAvailable = true;
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_EnumNvidiaDisplayHandleDelegate(int thisEnum, ref NvDisplayHandle displayHandle);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_EnumPhysicalGPUsDelegate([Out] NvPhysicalGpuHandle[] gpuHandles, out int gpuCount);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GetDisplayDriverVersionDelegate(NvDisplayHandle displayHandle, [In, Out] ref NvDisplayDriverVersion nvDisplayDriverVersion);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GetInterfaceVersionStringDelegate(StringBuilder version);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GetPhysicalGPUsFromDisplayDelegate(NvDisplayHandle displayHandle, [Out] NvPhysicalGpuHandle[] gpuHandles, out uint gpuCount);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_ClientFanCoolersGetControlDelegate(NvPhysicalGpuHandle gpuHandle, ref NvFanCoolerControl control);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_ClientFanCoolersGetStatusDelegate(NvPhysicalGpuHandle gpuHandle, ref NvFanCoolersStatus fanCoolersStatus);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_ClientFanCoolersSetControlDelegate(NvPhysicalGpuHandle gpuHandle, ref NvFanCoolerControl control);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_ClientPowerTopologyGetStatusDelegate(NvPhysicalGpuHandle gpuHandle, ref NvPowerTopology powerTopology);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetAllClockFrequenciesDelegate(NvPhysicalGpuHandle gpuHandle, ref NvGpuClockFrequencies clockFrequencies);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetAllClocksDelegate(NvPhysicalGpuHandle gpuHandle, ref NvClocks nvClocks);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetBusIdDelegate(NvPhysicalGpuHandle gpuHandle, out uint busId);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetCoolerSettingsDelegate(NvPhysicalGpuHandle gpuHandle, NvCoolerTarget coolerTarget, ref NvCoolerSettings NvCoolerSettings);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetDynamicPstatesInfoExDelegate(NvPhysicalGpuHandle gpuHandle, ref NvDynamicPStatesInfo nvPStates);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetMemoryInfoDelegate(NvDisplayHandle displayHandle, ref NvMemoryInfo nvMemoryInfo);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetPCIIdentifiersDelegate(NvPhysicalGpuHandle gpuHandle, out uint deviceId, out uint subSystemId, out uint revisionId, out uint extDeviceId);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetTachReadingDelegate(NvPhysicalGpuHandle gpuHandle, out int value);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetThermalSensorsDelegate(NvPhysicalGpuHandle gpuHandle, ref NvThermalSensors nvThermalSensors);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetThermalSettingsDelegate(NvPhysicalGpuHandle gpuHandle, int sensorIndex, ref NvThermalSettings NvThermalSettings);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetUsagesDelegate(NvPhysicalGpuHandle gpuHandle, ref NvUsages nvUsages);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_SetCoolerLevelsDelegate(NvPhysicalGpuHandle gpuHandle, int coolerIndex, ref NvCoolerLevels NvCoolerLevels);

    public enum NvFanControlMode : uint
    {
        Auto = 0,
        Manual = 1
    }

    public enum NvLevelPolicy : uint
    {
        None = 0,
        Manual = 1,
        Performance = 2,
        TemperatureDiscrete = 4,
        TemperatureContinuous = 8,
        Silent = 16,
        Auto = 32
    }

    public enum NvPowerTopologyDomain : uint
    {
        Gpu = 0,
        Board
    }

    public enum NvUtilizationDomain
    {
        Gpu, // Core
        FrameBuffer, // Memory Controller
        VideoEngine, // Video Engine
        BusInterface // Bus
    }

    public static bool IsAvailable { get; }

    [DllImport(DllName, EntryPoint = "nvapi_QueryInterface", CallingConvention = CallingConvention.Cdecl, PreserveSig = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    private static extern IntPtr NvAPI32_QueryInterface(uint interfaceId);

    [DllImport(DllName64, EntryPoint = "nvapi_QueryInterface", CallingConvention = CallingConvention.Cdecl, PreserveSig = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    private static extern IntPtr NvAPI64_QueryInterface(uint interfaceId);

    public static NvStatus NvAPI_GPU_GetFullName(NvPhysicalGpuHandle gpuHandle, out string name)
    {
        StringBuilder builder = new(SHORT_STRING_MAX);
        NvStatus status = _nvAPI_GPU_GetFullName?.Invoke(gpuHandle, builder) ?? NvStatus.FunctionNotFound;

        name = builder.ToString();
        return status;
    }

    public static NvStatus NvAPI_GetInterfaceVersionString(out string version)
    {
        StringBuilder builder = new(SHORT_STRING_MAX);
        NvStatus status = _nvAPI_GetInterfaceVersionString?.Invoke(builder) ?? NvStatus.FunctionNotFound;

        version = builder.ToString();
        return status;
    }

    private static void GetDelegate<T>(uint id, out T newDelegate) where T : class
    {
        IntPtr ptr = Environment.Is64BitOperatingSystem ? NvAPI64_QueryInterface(id) : NvAPI32_QueryInterface(id);

        if (ptr != IntPtr.Zero)
            newDelegate = Marshal.GetDelegateForFunctionPointer(ptr, typeof(T)) as T;
        else
            newDelegate = null;
    }

    public static bool DllExists()
    {
        IntPtr module = Kernel32.LoadLibrary(Environment.Is64BitOperatingSystem ? DllName64 : DllName);
        if (module == IntPtr.Zero)
            return false;

        Kernel32.FreeLibrary(module);
        return true;
    }

    internal static int MAKE_NVAPI_VERSION<T>(int ver)
    {
        return Marshal.SizeOf<T>() | (ver << 16);
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvFanCoolerControl
    {
        public uint Version;
        private readonly uint _reserved;
        public uint Count;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.U4)]
        private readonly uint[] _reserved2;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_FAN_CONTROLLER_ITEMS)]
        public NvFanCoolerControlItem[] Items;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvFanCoolerControlItem
    {
        public uint CoolerId;
        public uint Level;
        public NvFanControlMode ControlMode;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.U4)]
        private readonly uint[] _reserved;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvPowerTopology
    {
        public int Version;
        public uint Count;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_POWER_TOPOLOGIES, ArraySubType = UnmanagedType.Struct)]
        public NvPowerTopologyEntry[] Entries;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvPowerTopologyEntry
    {
        public NvPowerTopologyDomain Domain;
        private readonly uint _reserved;
        public uint PowerUsage;
        private readonly uint _reserved1;
    }

    internal enum NvStatus
    {
        OK = 0,
        Error = -1,
        LibraryNotFound = -2,
        NoImplementation = -3,
        ApiNotInitialized = -4,
        InvalidArgument = -5,
        NvidiaDeviceNotFound = -6,
        EndEnumeration = -7,
        InvalidHandle = -8,
        IncompatibleStructVersion = -9,
        HandleInvalidated = -10,
        OpenGlContextNotCurrent = -11,
        NoGlExpert = -12,
        InstrumentationDisabled = -13,
        ExpectedLogicalGpuHandle = -100,
        ExpectedPhysicalGpuHandle = -101,
        ExpectedDisplayHandle = -102,
        InvalidCombination = -103,
        NotSupported = -104,
        PortIdNotFound = -105,
        ExpectedUnattachedDisplayHandle = -106,
        InvalidPerfLevel = -107,
        DeviceBusy = -108,
        NvPersistFileNotFound = -109,
        PersistDataNotFound = -110,
        ExpectedTvDisplay = -111,
        ExpectedTvDisplayOnConnector = -112,
        NoActiveSliTopology = -113,
        SliRenderingModeNotAllowed = -114,
        ExpectedDigitalFlatPanel = -115,
        ArgumentExceedMaxSize = -116,
        DeviceSwitchingNotAllowed = -117,
        TestingClocksNotSupported = -118,
        UnknownUnderscanConfig = -119,
        TimeoutReconfiguringGpuTopo = -120,
        DataNotFound = -121,
        ExpectedAnalogDisplay = -122,
        NoVidLink = -123,
        RequiresReboot = -124,
        InvalidHybridMode = -125,
        MixedTargetTypes = -126,
        Syswow64NotSupported = -127,
        ImplicitSetGpuTopologyChangeNotAllowed = -128,
        RequestUserToCloseNonMigratableApps = -129,
        OutOfMemory = -130,
        WasStillDrawing = -131,
        FileNotFound = -132,
        TooManyUniqueStateObjects = -133,
        InvalidCall = -134,
        D3D101LibraryNotFound = -135,
        FunctionNotFound = -136
    }

    internal enum NvThermalController
    {
        None = 0,
        GpuInternal,
        Adm1032,
        Max6649,
        Max1617,
        Lm99,
        Lm89,
        Lm64,
        Adt7473,
        SbMax6649,
        VBiosEvt,
        OS,
        Unknown = -1
    }

    internal enum NvThermalTarget
    {
        None = 0,
        Gpu = 1,
        Memory = 2,
        PowerSupply = 4,
        Board = 8,
        VisualComputingBoard = 9,
        VisualComputingInlet = 10,
        VisualComputingOutlet = 11,
        All = 15,
        Unknown = -1
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvSensor
    {
        public NvThermalController Controller;
        public uint DefaultMinTemp;
        public uint DefaultMaxTemp;
        public uint CurrentTemp;
        public NvThermalTarget Target;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvThermalSettings
    {
        public uint Version;
        public uint Count;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_THERMAL_SENSORS_PER_GPU)]
        public NvSensor[] Sensor;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NvDisplayHandle
    {
        private readonly IntPtr ptr;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NvPhysicalGpuHandle
    {
        private readonly IntPtr ptr;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvClocks
    {
        public uint Version;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_CLOCKS_PER_GPU)]
        public uint[] Clock;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvDynamicPStatesInfo
    {
        public uint Version;
        public uint Flags;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_GPU_UTILIZATIONS)]
        public NvDynamicPState[] Utilizations;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvDynamicPState
    {
        public bool IsPresent;
        public int Percentage;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvUsages
    {
        public uint Version;
        private readonly uint _reserved;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public NvUsagesEntry[] Entries;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvUsagesEntry
    {
        public uint IsPresent;
        public uint Percentage;
        private readonly uint _reserved1;
        private readonly uint _reserved2;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvCooler
    {
        public int Type;
        public int Controller;
        public int DefaultMin;
        public int DefaultMax;
        public int CurrentMin;
        public int CurrentMax;
        public int CurrentLevel;
        public int DefaultPolicy;
        public int CurrentPolicy;
        public int Target;
        public int ControlType;
        public int Active;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvFanCoolersStatus
    {
        public uint Version;
        public uint Count;

        public ulong Reserved1;
        public ulong Reserved2;
        public ulong Reserved3;
        public ulong Reserved4;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_FAN_COOLERS_STATUS_ITEMS)]
        internal NvFanCoolersStatusItem[] Items;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvFanCoolersStatusItem
    {
        public uint CoolerId;
        public uint CurrentRpm;
        public uint CurrentMinLevel;
        public uint CurrentMaxLevel;
        public uint CurrentLevel;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.U4)]
        private readonly uint[] _reserved;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvCoolerSettings
    {
        public uint Version;
        public uint Count;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_COOLERS_PER_GPU)]
        public NvCooler[] Cooler;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvLevel
    {
        public int Level;
        public NvLevelPolicy Policy;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvCoolerLevels
    {
        public uint Version;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_COOLERS_PER_GPU)]
        public NvLevel[] Levels;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NvThermalSensors
    {
        internal uint Version;
        internal uint Mask;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = THERMAL_SENSOR_RESERVED_COUNT)]
        internal int[] Reserved;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = THERMAL_SENSOR_TEMPERATURE_COUNT)]
        internal int[] Temperatures;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvMemoryInfo
    {
        public uint Version;

        public uint DedicatedVideoMemory;

        public uint AvailableDedicatedVideoMemory;

        public uint SystemVideoMemory;

        public uint SharedSystemMemory;

        public uint CurrentAvailableDedicatedVideoMemory;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvDisplayDriverVersion
    {
        public uint Version;
        public uint DriverVersion;
        public uint BldChangeListNum;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = SHORT_STRING_MAX)]
        public string BuildBranch;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = SHORT_STRING_MAX)]
        public string Adapter;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvGpuClockFrequencies
    {
        public uint Version;
        private readonly uint _reserved;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_GPU_PUBLIC_CLOCKS)]
        public NvGpuClockFrequenciesDomain[] Clocks;
    }

    internal enum NvGpuPublicClockId
    {
        Graphics = 0,
        Memory = 4,
        Processor = 7,
        Video = 8,
        Undefined = MAX_CLOCKS_PER_GPU
    }

    internal enum NvGpuClockFrequenciesClockType
    {
        CurrentFrequency,
        BaseClock,
        BoostClock,
        ClockTypeNumber
    }

    internal enum NvCoolerTarget
    {
        None = 0,
        Gpu,
        Memory,
        PowerSupply = 4,
        All = 7 // This cooler cools all of the components related to its target gpu.
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvGpuClockFrequenciesDomain
    {
        private readonly uint _isPresent;
        public uint Frequency;

        public bool IsPresent => (_isPresent & 1) != 0;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate NvStatus NvAPI_InitializeDelegate();

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate NvStatus NvAPI_GPU_GetFullNameDelegate(NvPhysicalGpuHandle gpuHandle, StringBuilder name);
}

```

`LibreHardwareMonitorLib/Interop/NvidiaML.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.IO;
using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Interop;

internal static class NvidiaML
{
    private const string LinuxDllName = "nvidia-ml";
    private const string WindowsDllName = "nvml.dll";

    private static readonly object _syncRoot = new();

    private static IntPtr _windowsDll;

    private static WindowsNvmlGetHandleDelegate _windowsNvmlDeviceGetHandleByIndex;
    private static WindowsNvmlGetHandleByPciBusIdDelegate _windowsNvmlDeviceGetHandleByPciBusId;
    private static WindowsNvmlDeviceGetPcieThroughputDelegate _windowsNvmlDeviceGetPcieThroughputDelegate;
    private static WindowsNvmlDeviceGetPciInfo _windowsNvmlDeviceGetPciInfo;
    private static WindowsNvmlGetPowerUsageDelegate _windowsNvmlDeviceGetPowerUsage;
    private static WindowsNvmlDelegate _windowsNvmlInit;
    private static WindowsNvmlDelegate _windowsNvmlShutdown;

    public enum NvmlPcieUtilCounter
    {
        TxBytes = 0,
        RxBytes = 1
    }

    public enum NvmlReturn
    {
        /// <summary>
        /// The operation was successful
        /// </summary>
        Success = 0,

        /// <summary>
        /// NvidiaML was not first initialized with nvmlInit()
        /// </summary>
        Uninitialized = 1,

        /// <summary>
        /// A supplied argument is invalid
        /// </summary>
        InvalidArgument = 2,

        /// <summary>
        /// The requested operation is not available on target device
        /// </summary>
        NotSupported = 3,

        /// <summary>
        /// The current user does not have permission for operation
        /// </summary>
        NoPermission = 4,

        /// <summary>
        /// A query to find an object was unsuccessful
        /// </summary>
        NotFound = 6,

        /// <summary>
        /// An input argument is not large enough
        /// </summary>
        InsufficientSize = 7,

        /// <summary>
        /// A device's external power cables are not properly attached
        /// </summary>
        InsufficientPower = 8,

        /// <summary>
        /// NVIDIA driver is not loaded
        /// </summary>
        DriverNotLoaded = 9,

        /// <summary>
        /// User provided timeout passed
        /// </summary>
        TimeOut = 10,

        /// <summary>
        /// NVIDIA Kernel detected an interrupt issue with a GPU
        /// </summary>
        IRQIssue = 11,

        /// <summary>
        /// NvidiaML Shared Library couldn't be found or loaded
        /// </summary>
        LibraryNotFound = 12,

        /// <summary>
        /// Local version of NvidiaML doesn't implement this function
        /// </summary>
        FunctionNotFound = 13,

        /// <summary>
        /// infoROM is corrupted
        /// </summary>
        CorruptedInfoRom = 14,

        /// <summary>
        /// The GPU has fallen off the bus or has otherwise become inaccessible
        /// </summary>
        GpuIsLost = 15,

        /// <summary>
        /// The GPU requires a reset before it can be used again
        /// </summary>
        ResetRequired = 16,

        /// <summary>
        /// The GPU control device has been blocked by the operating system/cgroups
        /// </summary>
        OperatingSystem = 17,

        /// <summary>
        /// RM detects a driver/library version mismatch
        /// </summary>
        LibRmVersionMismatch = 18,

        /// <summary>
        /// An operation cannot be performed because the GPU is currently in use
        /// </summary>
        InUse = 19,

        /// <summary>
        /// An public driver error occurred
        /// </summary>
        Unknown = 999
    }

    public static bool IsAvailable { get; private set; }

    public static bool Initialize()
    {
        lock (_syncRoot)
        {
            if (IsAvailable)
            {
                return true;
            }

            if (Software.OperatingSystem.IsUnix)
            {
                try
                {
                    IsAvailable = nvmlInit() == NvmlReturn.Success;
                }
                catch (DllNotFoundException)
                { }
                catch (EntryPointNotFoundException)
                {
                    try
                    {
                        IsAvailable = nvmlInitLegacy() == NvmlReturn.Success;
                    }
                    catch (EntryPointNotFoundException)
                    { }
                }
            }
            else if (IsNvmlCompatibleWindowsVersion())
            {
                // Attempt to load the Nvidia Management Library from the
                // windows standard search order for applications. This will
                // help installations that either have the library in
                // %windir%/system32 or provide their own library
                _windowsDll = Kernel32.LoadLibrary(WindowsDllName);

                // If there is no dll in the path, then attempt to load it
                // from program files
                if (_windowsDll == IntPtr.Zero)
                {
                    string programFilesDirectory = Environment.ExpandEnvironmentVariables("%ProgramW6432%");
                    string dllPath = Path.Combine(programFilesDirectory, @"NVIDIA Corporation\NVSMI", WindowsDllName);

                    _windowsDll = Kernel32.LoadLibrary(dllPath);
                }

                IsAvailable = (_windowsDll != IntPtr.Zero) && InitialiseDelegates() && (_windowsNvmlInit() == NvmlReturn.Success);
            }

            return IsAvailable;
        }
    }

    private static bool IsNvmlCompatibleWindowsVersion()
    {
        return Software.OperatingSystem.Is64Bit && ((Environment.OSVersion.Version.Major > 6) || (Environment.OSVersion.Version.Major == 6 && Environment.OSVersion.Version.Minor >= 1));
    }

    private static bool InitialiseDelegates()
    {
        IntPtr nvmlInit = Kernel32.GetProcAddress(_windowsDll, "nvmlInit_v2");

        if (nvmlInit != IntPtr.Zero)
        {
            _windowsNvmlInit = (WindowsNvmlDelegate)Marshal.GetDelegateForFunctionPointer(nvmlInit, typeof(WindowsNvmlDelegate));
        }
        else
        {
            nvmlInit = Kernel32.GetProcAddress(_windowsDll, "nvmlInit");
            if (nvmlInit != IntPtr.Zero)
                _windowsNvmlInit = (WindowsNvmlDelegate)Marshal.GetDelegateForFunctionPointer(nvmlInit, typeof(WindowsNvmlDelegate));
            else
                return false;
        }

        IntPtr nvmlShutdown = Kernel32.GetProcAddress(_windowsDll, "nvmlShutdown");
        if (nvmlShutdown != IntPtr.Zero)
            _windowsNvmlShutdown = (WindowsNvmlDelegate)Marshal.GetDelegateForFunctionPointer(nvmlShutdown, typeof(WindowsNvmlDelegate));
        else
            return false;

        IntPtr nvmlGetHandle = Kernel32.GetProcAddress(_windowsDll, "nvmlDeviceGetHandleByIndex_v2");
        if (nvmlGetHandle != IntPtr.Zero)
            _windowsNvmlDeviceGetHandleByIndex = (WindowsNvmlGetHandleDelegate)Marshal.GetDelegateForFunctionPointer(nvmlGetHandle, typeof(WindowsNvmlGetHandleDelegate));
        else
        {
            nvmlGetHandle = Kernel32.GetProcAddress(_windowsDll, "nvmlDeviceGetHandleByIndex");
            if (nvmlGetHandle != IntPtr.Zero)
                _windowsNvmlDeviceGetHandleByIndex = (WindowsNvmlGetHandleDelegate)Marshal.GetDelegateForFunctionPointer(nvmlGetHandle, typeof(WindowsNvmlGetHandleDelegate));
            else
                return false;
        }

        IntPtr nvmlGetPowerUsage = Kernel32.GetProcAddress(_windowsDll, "nvmlDeviceGetPowerUsage");
        if (nvmlGetPowerUsage != IntPtr.Zero)
            _windowsNvmlDeviceGetPowerUsage = (WindowsNvmlGetPowerUsageDelegate)Marshal.GetDelegateForFunctionPointer(nvmlGetPowerUsage, typeof(WindowsNvmlGetPowerUsageDelegate));
        else
            return false;

        IntPtr nvmlGetPcieThroughput = Kernel32.GetProcAddress(_windowsDll, "nvmlDeviceGetPcieThroughput");
        if (nvmlGetPcieThroughput != IntPtr.Zero)
            _windowsNvmlDeviceGetPcieThroughputDelegate = (WindowsNvmlDeviceGetPcieThroughputDelegate)Marshal.GetDelegateForFunctionPointer(nvmlGetPcieThroughput, typeof(WindowsNvmlDeviceGetPcieThroughputDelegate));
        else
            return false;

        IntPtr nvmlGetHandlePciBus = Kernel32.GetProcAddress(_windowsDll, "nvmlDeviceGetHandleByPciBusId_v2");
        if (nvmlGetHandlePciBus != IntPtr.Zero)
            _windowsNvmlDeviceGetHandleByPciBusId = (WindowsNvmlGetHandleByPciBusIdDelegate)Marshal.GetDelegateForFunctionPointer(nvmlGetHandlePciBus, typeof(WindowsNvmlGetHandleByPciBusIdDelegate));
        else
            return false;

        IntPtr nvmlDeviceGetPciInfo = Kernel32.GetProcAddress(_windowsDll, "nvmlDeviceGetPciInfo_v2");
        if (nvmlDeviceGetPciInfo != IntPtr.Zero)
            _windowsNvmlDeviceGetPciInfo = (WindowsNvmlDeviceGetPciInfo)Marshal.GetDelegateForFunctionPointer(nvmlDeviceGetPciInfo, typeof(WindowsNvmlDeviceGetPciInfo));
        else
            return false;

        return true;
    }

    public static void Close()
    {
        lock (_syncRoot)
        {
            if (IsAvailable)
            {
                if (Software.OperatingSystem.IsUnix)
                {
                    nvmlShutdown();
                }
                else if (_windowsDll != IntPtr.Zero)
                {
                    _windowsNvmlShutdown();
                    Kernel32.FreeLibrary(_windowsDll);
                }

                IsAvailable = false;
            }
        }
    }

    public static NvmlDevice? NvmlDeviceGetHandleByIndex(int index)
    {
        if (IsAvailable)
        {
            NvmlDevice nvmlDevice;
            if (Software.OperatingSystem.IsUnix)
            {
                try
                {
                    if (nvmlDeviceGetHandleByIndex(index, out nvmlDevice) == NvmlReturn.Success)
                        return nvmlDevice;
                }
                catch (EntryPointNotFoundException)
                {
                    if (nvmlDeviceGetHandleByIndexLegacy(index, out nvmlDevice) == NvmlReturn.Success)
                        return nvmlDevice;
                }
            }
            else if (_windowsNvmlDeviceGetHandleByIndex(index, out nvmlDevice) == NvmlReturn.Success)
                return nvmlDevice;
        }

        return null;
    }

    public static NvmlDevice? NvmlDeviceGetHandleByPciBusId(string pciBusId)
    {
        if (IsAvailable)
        {
            NvmlDevice nvmlDevice;
            if (Software.OperatingSystem.IsUnix)
            {
                if (nvmlDeviceGetHandleByPciBusId(pciBusId, out nvmlDevice) == NvmlReturn.Success)
                    return nvmlDevice;
            }
            else if (_windowsNvmlDeviceGetHandleByPciBusId(pciBusId, out nvmlDevice) == NvmlReturn.Success)
                return nvmlDevice;
        }

        return null;
    }

    public static int? NvmlDeviceGetPowerUsage(NvmlDevice nvmlDevice)
    {
        if (IsAvailable)
        {
            int powerUsage;
            if (Software.OperatingSystem.IsUnix)
            {
                if (nvmlDeviceGetPowerUsage(nvmlDevice, out powerUsage) == NvmlReturn.Success)
                    return powerUsage;
            }
            else if (_windowsNvmlDeviceGetPowerUsage(nvmlDevice, out powerUsage) == NvmlReturn.Success)
                return powerUsage;
        }

        return null;
    }

    public static uint? NvmlDeviceGetPcieThroughput(NvmlDevice nvmlDevice, NvmlPcieUtilCounter counter)
    {
        if (IsAvailable)
        {
            uint pcieThroughput;
            if (Software.OperatingSystem.IsUnix)
            {
                if (nvmlDeviceGetPcieThroughput(nvmlDevice, counter, out pcieThroughput) == NvmlReturn.Success)
                    return pcieThroughput;
            }
            else if (_windowsNvmlDeviceGetPcieThroughputDelegate(nvmlDevice, counter, out pcieThroughput) == NvmlReturn.Success)
                return pcieThroughput;
        }

        return null;
    }

    public static NvmlPciInfo? NvmlDeviceGetPciInfo(NvmlDevice nvmlDevice)
    {
        if (IsAvailable)
        {
            var pci = new NvmlPciInfo();

            if (Software.OperatingSystem.IsUnix)
            {
                if (nvmlDeviceGetPciInfo(nvmlDevice, ref pci) == NvmlReturn.Success)
                    return pci;
            }
            else if (_windowsNvmlDeviceGetPciInfo(nvmlDevice, ref pci) == NvmlReturn.Success)
                return pci;
        }

        return null;
    }

    [DllImport(LinuxDllName, EntryPoint = "nvmlInit_v2", ExactSpelling = true)]
    private static extern NvmlReturn nvmlInit();

    [DllImport(LinuxDllName, EntryPoint = "nvmlInit", ExactSpelling = true)]
    private static extern NvmlReturn nvmlInitLegacy();

    [DllImport(LinuxDllName, EntryPoint = "nvmlShutdown", ExactSpelling = true)]
    private static extern NvmlReturn nvmlShutdown();

    [DllImport(LinuxDllName, EntryPoint = "nvmlDeviceGetHandleByIndex_v2", ExactSpelling = true)]
    private static extern NvmlReturn nvmlDeviceGetHandleByIndex(int index, out NvmlDevice device);

    [DllImport(LinuxDllName, EntryPoint = "nvmlDeviceGetHandleByPciBusId_v2", ExactSpelling = true)]
    private static extern NvmlReturn nvmlDeviceGetHandleByPciBusId([MarshalAs(UnmanagedType.LPStr)] string pciBusId, out NvmlDevice device);

    [DllImport(LinuxDllName, EntryPoint = "nvmlDeviceGetHandleByIndex", ExactSpelling = true)]
    private static extern NvmlReturn nvmlDeviceGetHandleByIndexLegacy(int index, out NvmlDevice device);

    [DllImport(LinuxDllName, EntryPoint = "nvmlDeviceGetPowerUsage", ExactSpelling = true)]
    private static extern NvmlReturn nvmlDeviceGetPowerUsage(NvmlDevice device, out int power);

    [DllImport(LinuxDllName, EntryPoint = "nvmlDeviceGetPcieThroughput", ExactSpelling = true)]
    private static extern NvmlReturn nvmlDeviceGetPcieThroughput(NvmlDevice device, NvmlPcieUtilCounter counter, out uint value);

    [DllImport(LinuxDllName, EntryPoint = "nvmlDeviceGetPciInfo_v2")]
    private static extern NvmlReturn nvmlDeviceGetPciInfo(NvmlDevice device, ref NvmlPciInfo pci);

    private delegate NvmlReturn WindowsNvmlDelegate();

    private delegate NvmlReturn WindowsNvmlGetHandleDelegate(int index, out NvmlDevice device);

    private delegate NvmlReturn WindowsNvmlGetHandleByPciBusIdDelegate([MarshalAs(UnmanagedType.LPStr)] string pciBusId, out NvmlDevice device);

    private delegate NvmlReturn WindowsNvmlGetPowerUsageDelegate(NvmlDevice device, out int power);

    private delegate NvmlReturn WindowsNvmlDeviceGetPcieThroughputDelegate(NvmlDevice device, NvmlPcieUtilCounter counter, out uint value);

    private delegate NvmlReturn WindowsNvmlDeviceGetPciInfo(NvmlDevice device, ref NvmlPciInfo pci);

    [StructLayout(LayoutKind.Sequential)]
    public struct NvmlDevice
    {
        public IntPtr Handle;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct NvmlPciInfo
    {
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]
        public string busId;

        public uint domain;

        public uint bus;

        public uint device;

        public ushort pciVendorId;

        public ushort pciDeviceId;

        public uint pciSubSystemId;

        public uint reserved0;
        public uint reserved1;
        public uint reserved2;
        public uint reserved3;
    }
}
```

`LibreHardwareMonitorLib/Interop/Ring0.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

// ReSharper disable InconsistentNaming
// ReSharper disable IdentifierTypo

namespace LibreHardwareMonitor.Interop;

/// <summary>
/// Driver with access at kernel level.
/// </summary>
internal static class Ring0
{
    public const uint INVALID_PCI_ADDRESS = 0xFFFFFFFF;

    private const uint OLS_TYPE = 40000;

    public static readonly Kernel32.IOControlCode IOCTL_OLS_GET_REFCOUNT = new(OLS_TYPE, 0x801, Kernel32.IOControlCode.Access.Any);
    public static readonly Kernel32.IOControlCode IOCTL_OLS_READ_MSR = new(OLS_TYPE, 0x821, Kernel32.IOControlCode.Access.Any);
    public static readonly Kernel32.IOControlCode IOCTL_OLS_WRITE_MSR = new(OLS_TYPE, 0x822, Kernel32.IOControlCode.Access.Any);
    public static readonly Kernel32.IOControlCode IOCTL_OLS_READ_IO_PORT_BYTE = new(OLS_TYPE, 0x833, Kernel32.IOControlCode.Access.Read);
    public static readonly Kernel32.IOControlCode IOCTL_OLS_WRITE_IO_PORT_BYTE = new(OLS_TYPE, 0x836, Kernel32.IOControlCode.Access.Write);
    public static readonly Kernel32.IOControlCode IOCTL_OLS_READ_PCI_CONFIG = new(OLS_TYPE, 0x851, Kernel32.IOControlCode.Access.Read);
    public static readonly Kernel32.IOControlCode IOCTL_OLS_WRITE_PCI_CONFIG = new(OLS_TYPE, 0x852, Kernel32.IOControlCode.Access.Write);
    public static readonly Kernel32.IOControlCode IOCTL_OLS_READ_MEMORY = new(OLS_TYPE, 0x841, Kernel32.IOControlCode.Access.Read);
}
```

`LibreHardwareMonitorLib/Interop/SetupApi.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Interop;

internal class SetupApi
{
    internal const int DIGCF_DEVICEINTERFACE = 0x00000010;
    internal const int DIGCF_PRESENT = 0x00000002;
    internal const int ERROR_INSUFFICIENT_BUFFER = 122;
    internal const int ERROR_NO_MORE_ITEMS = 259;

    private const string DllName = "SetupAPI.dll";
    internal static Guid GUID_DEVICE_BATTERY = new(0x72631e54, 0x78A4, 0x11d0, 0xbc, 0xf7, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a);
    internal static readonly IntPtr INVALID_HANDLE_VALUE = new(-1);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    internal static extern IntPtr SetupDiGetClassDevs(ref Guid ClassGuid, IntPtr Enumerator, IntPtr hwndParent, uint Flags);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool SetupDiEnumDeviceInterfaces
        (IntPtr DeviceInfoSet, IntPtr DeviceInfoData, ref Guid InterfaceClassGuid, uint MemberIndex, ref SP_DEVICE_INTERFACE_DATA DeviceInterfaceData);

    [DllImport(DllName, SetLastError = true, EntryPoint = "SetupDiGetDeviceInterfaceDetailW", CharSet = CharSet.Unicode)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool SetupDiGetDeviceInterfaceDetail
    (
        IntPtr DeviceInfoSet,
        in SP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
        [Out, Optional] IntPtr DeviceInterfaceDetailData,
        uint DeviceInterfaceDetailDataSize,
        out uint RequiredSize,
        IntPtr DeviceInfoData = default);

    [DllImport(DllName, CallingConvention = CallingConvention.Winapi, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool SetupDiDestroyDeviceInfoList(IntPtr DeviceInfoSet);

    [StructLayout(LayoutKind.Sequential)]
    internal struct SP_DEVICE_INTERFACE_DATA
    {
        public uint cbSize;
        public Guid InterfaceClassGuid;
        public uint Flags;
        public IntPtr Reserved;
    }
}
```

`LibreHardwareMonitorLib/Interop/WinNt.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

// ReSharper disable IdentifierTypo
// ReSharper disable InconsistentNaming

using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Interop;

/// <summary>
/// Contains Win32 definitions for Windows NT.
/// </summary>
internal static class WinNt
{
    internal const int STATUS_SUCCESS = 0;

    /// <summary>
    /// Describes a local identifier for an adapter.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LUID
    {
        public readonly uint LowPart;
        public readonly int HighPart;
    }

    /// <summary>
    /// Represents a 64-bit signed integer value.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    internal struct LARGE_INTEGER
    {
        [FieldOffset(0)]
        public long QuadPart;

        [FieldOffset(0)]
        public uint LowPart;

        [FieldOffset(4)]
        public int HighPart;
    }
}
```

`LibreHardwareMonitorLib/LibreHardwareMonitorLib.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>net472;netstandard2.0;net6.0;net7.0</TargetFrameworks>
    <AssemblyName>LibreHardwareMonitorLib</AssemblyName>
    <RootNamespace>LibreHardwareMonitor</RootNamespace>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
    <PackageRequireLicenseAcceptance>false</PackageRequireLicenseAcceptance>
    <PackageId>$(AssemblyName)</PackageId>
    <Description>Monitor the temperature sensors, fan speeds, voltages, load and clock speeds of your computer.</Description>
    <PackageLicense>https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/blob/master/Licenses/LICENSE</PackageLicense>
    <PackageLicenseExpression>MPL-2.0</PackageLicenseExpression>
    <PackageProjectUrl>https://github.com/LibreHardwareMonitor/LibreHardwareMonitor</PackageProjectUrl>
    <PackageTags>libre open hardware monitor monitoring system logging cpu gpu</PackageTags>
    <PackageVersion>$(Version)</PackageVersion>
    <Pack>true</Pack>
    <RepositoryUrl>https://github.com/LibreHardwareMonitor/LibreHardwareMonitor</RepositoryUrl>
    <LangVersion>latest</LangVersion>
    <PackageIcon>packageicon.png</PackageIcon>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)'=='Debug'">
    <OutputPath>..\bin\Debug\</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)'=='Release'">
    <OutputPath>..\bin\Release\</OutputPath>
  </PropertyGroup>
  <PropertyGroup>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
  </PropertyGroup>
  <ItemGroup>
    <EmbeddedResource Include="Resources\inpout32.gz" />
    <EmbeddedResource Include="Resources\inpoutx64.gz" />
    <EmbeddedResource Include="Resources\WinRing0.gz" />
    <EmbeddedResource Include="Resources\WinRing0x64.gz" />
  </ItemGroup>
  <ItemGroup Condition="'$(TargetFramework)' != 'net472'">
    <PackageReference Include="Microsoft.Win32.Registry" Version="5.0.0" />
    <PackageReference Include="System.IO.Ports" Version="7.0.0" />
    <PackageReference Include="System.IO.FileSystem.AccessControl" Version="5.0.0" />
    <PackageReference Include="Mono.Posix.NETStandard" Version="1.0.0" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="HidSharp" Version="2.1.0" />
    <PackageReference Include="System.Management" Version="7.0.0" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\packageicon.png" PackagePath="">
      <Pack>True</Pack>
    </None>
  </ItemGroup>
</Project>

```

`LibreHardwareMonitorLib/Software/OperatingSystem.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;

namespace LibreHardwareMonitor.Software;

/// <summary>
/// Contains basic information about the operating system.
/// </summary>
public static class OperatingSystem
{
    /// <summary>
    /// Statically checks if the current system <see cref="Is64Bit"/> and <see cref="IsUnix"/>.
    /// </summary>
    static OperatingSystem()
    {
        // The operating system doesn't change during execution so let's query it just one time.
        PlatformID platform = Environment.OSVersion.Platform;
        Version version = Environment.OSVersion.Version;
        IsUnix = platform is PlatformID.Unix or PlatformID.MacOSX;

        if (Environment.Is64BitOperatingSystem)
            Is64Bit = true;

        IsWindows8OrGreater = !IsUnix && ((version.Major == 6 && version.Minor >= 2) || version.Major > 6);
    }

    /// <summary>
    /// Gets information about whether the current system is 64 bit.
    /// </summary>
    public static bool Is64Bit { get; }

    /// <summary>
    /// Gets information about whether the current system is Unix based.
    /// </summary>
    public static bool IsUnix { get; }

    /// <summary>
    /// Returns true if the current system is Windows 8 or a more recent Windows version
    /// </summary>
    public static bool IsWindows8OrGreater { get; }
}

```

`Licenses/License.html`:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/.  -->

<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Libre Hardware Monitor - License</title>
<style type="text/css" media="screen">

body {
	font: message-box;
	color: #333333;
	background: #f2f2f2;
	padding: 5px;
}
     
dt {
	font-weight: bold;
}   

#page  {
	clear: both;
	max-width: 950px;	
	margin:10px auto;
	background: #ffffff;
	box-shadow: 0px 0px 5px #777;
	-moz-box-shadow: 0px 0px 5px #777;
	-webkit-box-shadow: 0px 0px 5px #777;
}

#content {
	clear: both;
	min-height: 600px; 
	min-width: 700px;
	padding-top: 20px;	
	padding-bottom: 20px;	
	padding-left: 30px;
	padding-right: 30px;
}

</style>
</head>

<body>

<div id="page">
<div id="content">

<h1>Libre Hardware Monitor License</h1>

<p> 
The <b>binaries</b> of the Libre Hardware Monitor have been made available by the <a href="http://openhardwaremonitor.org">Libre Hardware Monitor Project</a> under the Mozilla Public License 2.0 (MPL).
</p>

<p>
The <b>source code</b> of the Libre Hardware Monitor is <a href="http://code.google.com/p/open-hardware-monitor/source/">available</a> under licenses which are both <a href="http://www.gnu.org/philosophy/free-sw.html">free</a> and <a href="http://www.opensource.org/docs/definition.php">open source</a>. Most of it is available under the Mozilla Public License 2.0 (MPL).
</p>

<ul>
<li><a href="#mozilla-public-license-version-2.0">Mozilla Public License 2.0</a></li>
</ul>
    
<p>
The remainder of the software which is not under the Mozilla Public License 2.0 (MPL) is available under one of a variety of other licenses which are given below. 
</p>
    
<ul>
<li><a href="#Aga.Controls">Aga.Controls License</a></li>
<li><a href="#WinRing0">WinRing0 License</a></li>
<li><a href="#InpOut">InpOut License</a></li>
</ul>

<br/>
<hr/>

<h1 id="mozilla-public-license-version-2.0">Mozilla Public License 2.0</h1>
<h2 id="definitions">1. Definitions</h2>
<dl>
<dt>1.1. “Contributor”</dt>
<dd><p>means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software.</p>
</dd>
<dt>1.2. “Contributor Version”</dt>
<dd><p>means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor’s Contribution.</p>
</dd>
<dt>1.3. “Contribution”</dt>
<dd><p>means Covered Software of a particular Contributor.</p>
</dd>
<dt>1.4. “Covered Software”</dt>
<dd><p>means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof.</p>
</dd>
<dt>1.5. “Incompatible With Secondary Licenses”</dt>
<dd><p>means</p>
<ol type="a">
<li><p>that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or</p></li>
<li><p>that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License.</p></li>
</ol>
</dd>
<dt>1.6. “Executable Form”</dt>
<dd><p>means any form of the work other than Source Code Form.</p>
</dd>
<dt>1.7. “Larger Work”</dt>
<dd><p>means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software.</p>
</dd>
<dt>1.8. “License”</dt>
<dd><p>means this document.</p>
</dd>
<dt>1.9. “Licensable”</dt>
<dd><p>means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License.</p>
</dd>
<dt>1.10. “Modifications”</dt>
<dd><p>means any of the following:</p>
<ol type="a">
<li><p>any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or</p></li>
<li><p>any new file in Source Code Form that contains any Covered Software.</p></li>
</ol>
</dd>
<dt>1.11. “Patent Claims” of a Contributor</dt>
<dd><p>means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version.</p>
</dd>
<dt>1.12. “Secondary License”</dt>
<dd><p>means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses.</p>
</dd>
<dt>1.13. “Source Code Form”</dt>
<dd><p>means the form of the work preferred for making modifications.</p>
</dd>
<dt>1.14. “You” (or “Your”)</dt>
<dd><p>means an individual or a legal entity exercising rights under this License. For legal entities, “You” includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, “control” means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity.</p>
</dd>
</dl>
<h2 id="license-grants-and-conditions">2. License Grants and Conditions</h2>
<h3 id="grants">2.1. Grants</h3>
<p>Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license:</p>
<ol type="a">
<li><p>under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and</p></li>
<li><p>under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version.</p></li>
</ol>
<h3 id="effective-date">2.2. Effective Date</h3>
<p>The licenses granted in Section&nbsp;2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution.</p>
<h3 id="limitations-on-grant-scope">2.3. Limitations on Grant Scope</h3>
<p>The licenses granted in this Section&nbsp;2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section&nbsp;2.1(b) above, no patent license is granted by a Contributor:</p>
<ol type="a">
<li><p>for any code that a Contributor has removed from Covered Software; or</p></li>
<li><p>for infringements caused by: (i) Your and any other third party’s modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or</p></li>
<li><p>under Patent Claims infringed by Covered Software in the absence of its Contributions.</p></li>
</ol>
<p>This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section&nbsp;3.4).</p>
<h3 id="subsequent-licenses">2.4. Subsequent Licenses</h3>
<p>No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section&nbsp;10.2) or under the terms of a Secondary License (if permitted under the terms of Section&nbsp;3.3).</p>
<h3 id="representation">2.5. Representation</h3>
<p>Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License.</p>
<h3 id="fair-use">2.6. Fair Use</h3>
<p>This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents.</p>
<h3 id="conditions">2.7. Conditions</h3>
<p>Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section&nbsp;2.1.</p>
<h2 id="responsibilities">3. Responsibilities</h2>
<h3 id="distribution-of-source-form">3.1. Distribution of Source Form</h3>
<p>All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients’ rights in the Source Code Form.</p>
<h3 id="distribution-of-executable-form">3.2. Distribution of Executable Form</h3>
<p>If You distribute Covered Software in Executable Form then:</p>
<ol type="a">
<li><p>such Covered Software must also be made available in Source Code Form, as described in Section&nbsp;3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and</p></li>
<li><p>You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients’ rights in the Source Code Form under this License.</p></li>
</ol>
<h3 id="distribution-of-a-larger-work">3.3. Distribution of a Larger Work</h3>
<p>You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s).</p>
<h3 id="notices">3.4. Notices</h3>
<p>You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies.</p>
<h3 id="application-of-additional-terms">3.5. Application of Additional Terms</h3>
<p>You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction.</p>
<h2 id="inability-to-comply-due-to-statute-or-regulation">4. Inability to Comply Due to Statute or Regulation</h2>
<p>If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it.</p>
<h2 id="termination">5. Termination</h2>
<p>5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice.</p>
<p>5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section&nbsp;2.1 of this License shall terminate.</p>
<p>5.3. In the event of termination under Sections&nbsp;5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination.</p>
<h2 id="disclaimer-of-warranty">6. Disclaimer of Warranty</h2>
<p><em>Covered Software is provided under this License on an “as is” basis, without warranty of any kind, either expressed, implied, or statutory, including, without limitation, warranties that the Covered Software is free of defects, merchantable, fit for a particular purpose or non-infringing. The entire risk as to the quality and performance of the Covered Software is with You. Should any Covered Software prove defective in any respect, You (not any Contributor) assume the cost of any necessary servicing, repair, or correction. This disclaimer of warranty constitutes an essential part of this License. No use of any Covered Software is authorized under this License except under this disclaimer.</em></p>
<h2 id="limitation-of-liability">7. Limitation of Liability</h2>
<p><em>Under no circumstances and under no legal theory, whether tort (including negligence), contract, or otherwise, shall any Contributor, or anyone who distributes Covered Software as permitted above, be liable to You for any direct, indirect, special, incidental, or consequential damages of any character including, without limitation, damages for lost profits, loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses, even if such party shall have been informed of the possibility of such damages. This limitation of liability shall not apply to liability for death or personal injury resulting from such party’s negligence to the extent applicable law prohibits such limitation. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so this exclusion and limitation may not apply to You.</em></p>
<h2 id="litigation">8. Litigation</h2>
<p>Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party’s ability to bring cross-claims or counter-claims.</p>
<h2 id="miscellaneous">9. Miscellaneous</h2>
<p>This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor.</p>
<h2 id="versions-of-the-license">10. Versions of the License</h2>
<h3 id="new-versions">10.1. New Versions</h3>
<p>Mozilla Foundation is the license steward. Except as provided in Section&nbsp;10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number.</p>
<h3 id="effect-of-new-versions">10.2. Effect of New Versions</h3>
<p>You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward.</p>
<h3 id="modified-versions">10.3. Modified Versions</h3>
<p>If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License).</p>
<h3 id="distributing-source-code-form-that-is-incompatible-with-secondary-licenses">10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses</h3>
<p>If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached.</p>
<h2 id="exhibit-a---source-code-form-license-notice">Exhibit A - Source Code Form License Notice</h2>
<blockquote>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.</p>
</blockquote>
<p>If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice.</p>
<p>You may add additional accurate notices of copyright ownership.</p>
<h2 id="exhibit-b---incompatible-with-secondary-licenses-notice">Exhibit B - “Incompatible With Secondary Licenses” Notice</h2>
<blockquote>
<p>This Source Code Form is “Incompatible With Secondary Licenses”, as defined by the Mozilla Public License, v. 2.0.</p>
</blockquote>

<hr/>

<h1 id="Aga.Controls">Aga.Controls License</h1>
<p>
This license applies to the Aga.Controls assembly (TreeViewAdv component).
</p>
<pre>
Copyright (c) 2009, Andrey Gliznetsov (a.gliznetsov@gmail.com)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met

- Redistributions of source code must retain the above copyright notice, this list
of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation andor other
materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre>

<hr/>

<h1 id="WinRing0">WinRing0 License</h1>
<p>
This license applies to the WinRing0 device drivers.
</p>
<pre>
Copyright (c) 2007-2009 OpenLibSys.org. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre>

<hr/>

<h1 id="InpOut">InpOut License</h1>
<p>
This license applies to the InpOut library.
</p>
<pre>
Copyright (c) <2003-2015> Phil Gibbons <www.highrez.co.uk>
Portions Copyright (c) <2000> <logix4u.net>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
</pre>

</div>
</div>

</body>

</html>
```

`README.md`:

```md
# LibreHardwareMonitor
[![GitHub license](https://img.shields.io/github/license/LibreHardwareMonitor/LibreHardwareMonitor)](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/blob/master/LICENSE) [![Nuget](https://img.shields.io/nuget/v/LibreHardwareMonitorLib)](https://www.nuget.org/packages/LibreHardwareMonitorLib/) [![Nuget (with prereleases)](https://img.shields.io/nuget/vpre/LibreHardwareMonitorLib?label=nuget-pre)](https://www.nuget.org/packages/LibreHardwareMonitorLib/) [![Nuget](https://img.shields.io/nuget/dt/LibreHardwareMonitorLib?label=nuget-downloads)](https://www.nuget.org/packages/LibreHardwareMonitorLib/)

Libre Hardware Monitor, a fork of Open Hardware Monitor, is free software that can monitor the temperature sensors, fan speeds, voltages, load and clock speeds of your computer. 

## What's included?
| Name| .NET | Build Status |
| --- | --- | --- | 
| **LibreHardwareMonitor** <br /> Windows Forms based application that presents all data in a graphical interface | .NET Framework 4.7.2 | [![Build status](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/workflows/CI/badge.svg)](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/actions) | 
| **LibreHardwareMonitorLib** <br /> Library that allows you to use all features in your own application | .NET Framework 4.7.2, .NET 6.0, and .NET 7.0 | [![Build status](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/workflows/CI/badge.svg)](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/actions) | 

## What can it do?
You can read information from devices such as:
- Motherboards
- Intel and AMD processors
- NVIDIA and AMD graphics cards
- HDD, SSD and NVMe hard drives
- Network cards

## Where can I download it?
You can download the latest release [here](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/releases).

### Nightly builds
If you have a **GitHub** account, you can download nightly builds [here](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/actions). Otherwise, you can download the *latest* nightly build [here](https://nightly.link/LibreHardwareMonitor/LibreHardwareMonitor/workflows/master/master/LibreHardwareMonitor-net472.zip).

## How can I help improve it?
The LibreHardwareMonitor team welcomes feedback and contributions!<br/>
You can check if it works properly on your motherboard. For many manufacturers, the way of reading data differs a bit, so if you notice any inaccuracies, please send us a pull request. If you have any suggestions or improvements, don't hesitate to create an issue.

## Developer information
**Integrate the library in own application**
1. Add the [LibreHardwareMonitorLib](https://www.nuget.org/packages/LibreHardwareMonitorLib/) NuGet package to your application.
2. Use the sample code below.


**Sample code**
```c#
public class UpdateVisitor : IVisitor
{
    public void VisitComputer(IComputer computer)
    {
        computer.Traverse(this);
    }
    public void VisitHardware(IHardware hardware)
    {
        hardware.Update();
        foreach (IHardware subHardware in hardware.SubHardware) subHardware.Accept(this);
    }
    public void VisitSensor(ISensor sensor) { }
    public void VisitParameter(IParameter parameter) { }
}

public void Monitor()
{
    Computer computer = new Computer
    {
        IsCpuEnabled = true,
        IsGpuEnabled = true,
        IsMemoryEnabled = true,
        IsMotherboardEnabled = true,
        IsControllerEnabled = true,
        IsNetworkEnabled = true,
        IsStorageEnabled = true
    };

    computer.Open();
    computer.Accept(new UpdateVisitor());

    foreach (IHardware hardware in computer.Hardware)
    {
        Console.WriteLine("Hardware: {0}", hardware.Name);
        
        foreach (IHardware subhardware in hardware.SubHardware)
        {
            Console.WriteLine("\tSubhardware: {0}", subhardware.Name);
            
            foreach (ISensor sensor in subhardware.Sensors)
            {
                Console.WriteLine("\t\tSensor: {0}, value: {1}", sensor.Name, sensor.Value);
            }
        }

        foreach (ISensor sensor in hardware.Sensors)
        {
            Console.WriteLine("\tSensor: {0}, value: {1}", sensor.Name, sensor.Value);
        }
    }
    
    computer.Close();
}
```

## License
LibreHardwareMonitor is free and open source software licensed under MPL 2.0. You can use it in private and commercial projects. Keep in mind that you must include a copy of the license in your project.

```

`WinRing0/COPYRIGHT.txt`:

```txt
Copyright (c) 2007-2009 OpenLibSys.org. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`WinRing0/MAKEFILE`:

```
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the driver components of the Windows NT DDK
#

!INCLUDE $(NTMAKEENV)\makefile.def

```

`WinRing0/OlsIoctl.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2008 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//
// The Device type codes form 32768 to 65535 are for customer use.
//
//-----------------------------------------------------------------------------

#define OLS_TYPE 40000

//-----------------------------------------------------------------------------
//
// Version Information
//
//-----------------------------------------------------------------------------

#define OLS_DRIVER_ID							_T("WinRing0_1_2_0")

#define OLS_DRIVER_MAJOR_VERSION				1
#define OLS_DRIVER_MINOR_VERSION				2
#define OLS_DRIVER_REVISION						0
#define OLS_DRIVER_RELESE						5

#define OLS_DRIVER_VERSION \
	((OLS_DRIVER_MAJOR_VERSION << 24) | (OLS_DRIVER_MINOR_VERSION << 16) \
	| (OLS_DRIVER_REVISION << 8) | OLS_DRIVER_RELESE) 

//-----------------------------------------------------------------------------
//
// The IOCTL function codes from 0x800 to 0xFFF are for customer use.
//
//-----------------------------------------------------------------------------
#define IOCTL_OLS_GET_DRIVER_VERSION \
	CTL_CODE(OLS_TYPE, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_GET_REFCOUNT \
	CTL_CODE(OLS_TYPE, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_READ_MSR \
	CTL_CODE(OLS_TYPE, 0x821, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_WRITE_MSR \
	CTL_CODE(OLS_TYPE, 0x822, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_READ_PMC \
	CTL_CODE(OLS_TYPE, 0x823, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_HALT \
	CTL_CODE(OLS_TYPE, 0x824, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_READ_IO_PORT \
	CTL_CODE(OLS_TYPE, 0x831, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_IO_PORT \
	CTL_CODE(OLS_TYPE, 0x832, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_READ_IO_PORT_BYTE \
	CTL_CODE(OLS_TYPE, 0x833, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_READ_IO_PORT_WORD \
	CTL_CODE(OLS_TYPE, 0x834, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_READ_IO_PORT_DWORD \
	CTL_CODE(OLS_TYPE, 0x835, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_IO_PORT_BYTE \
	CTL_CODE(OLS_TYPE, 0x836, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_WRITE_IO_PORT_WORD \
	CTL_CODE(OLS_TYPE, 0x837, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_WRITE_IO_PORT_DWORD \
	CTL_CODE(OLS_TYPE, 0x838, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_READ_MEMORY \
	CTL_CODE(OLS_TYPE, 0x841, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_MEMORY \
	CTL_CODE(OLS_TYPE, 0x842, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_READ_PCI_CONFIG \
	CTL_CODE(OLS_TYPE, 0x851, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_PCI_CONFIG \
	CTL_CODE(OLS_TYPE, 0x852, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//-----------------------------------------------------------------------------
//
// PCI Error Code
//
//-----------------------------------------------------------------------------

#define OLS_ERROR_PCI_BUS_NOT_EXIST		(0xE0000001L)
#define OLS_ERROR_PCI_NO_DEVICE			(0xE0000002L)
#define OLS_ERROR_PCI_WRITE_CONFIG		(0xE0000003L)
#define OLS_ERROR_PCI_READ_CONFIG		(0xE0000004L)

//-----------------------------------------------------------------------------
//
// Support Macros
//
//-----------------------------------------------------------------------------

// Bus Number, Device Number and Function Number to PCI Device Address
#define PciBusDevFunc(Bus, Dev, Func)	((Bus&0xFF)<<8) | ((Dev&0x1F)<<3) | (Func&7)
// PCI Device Address to Bus Number
#define PciGetBus(address)				((address>>8) & 0xFF)
// PCI Device Address to Device Number
#define PciGetDev(address)				((address>>3) & 0x1F)
// PCI Device Address to Function Number
#define PciGetFunc(address)				(address&7)

//-----------------------------------------------------------------------------
//
// Typedef Struct
//
//-----------------------------------------------------------------------------

#pragma pack(push,4)

typedef struct  _OLS_WRITE_MSR_INPUT {
	ULONG		Register;
	ULARGE_INTEGER	Value;
}   OLS_WRITE_MSR_INPUT;

typedef struct  _OLS_WRITE_IO_PORT_INPUT {
	ULONG	PortNumber; 
	union {
		ULONG   LongData;
		USHORT  ShortData;
		UCHAR   CharData;
	};
}   OLS_WRITE_IO_PORT_INPUT;

typedef struct  _OLS_READ_PCI_CONFIG_INPUT {
	ULONG PciAddress;
	ULONG PciOffset;
}   OLS_READ_PCI_CONFIG_INPUT;

typedef struct  _OLS_WRITE_PCI_CONFIG_INPUT {
	ULONG PciAddress;
	ULONG PciOffset;
	UCHAR Data[1];
}   OLS_WRITE_PCI_CONFIG_INPUT;

typedef LARGE_INTEGER PHYSICAL_ADDRESS;

typedef struct  _OLS_READ_MEMORY_INPUT {
	PHYSICAL_ADDRESS Address;
	ULONG UnitSize;
	ULONG Count;
}   OLS_READ_MEMORY_INPUT;

typedef struct  _OLS_WRITE_MEMORY_INPUT {
	PHYSICAL_ADDRESS Address;	 
	ULONG UnitSize;
	ULONG Count;
	UCHAR Data[1];
}   OLS_WRITE_MEMORY_INPUT;

#pragma pack(pop)

```

`WinRing0/OpenLibSys.c`:

```c
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2008 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#include <ntddk.h>
#include <stddef.h>
#include "OpenLibSys.h"

//-----------------------------------------------------------------------------
//
// Global
//
//-----------------------------------------------------------------------------

static ULONG refCount;

//-----------------------------------------------------------------------------
//
// Classic NT driver
// DriverEntry / OlsDispatch / Unload
//
//-----------------------------------------------------------------------------

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT  DriverObject,
	IN PUNICODE_STRING RegistryPath
	)

/*

Return Value:

	STATUS_SUCCESS if the driver initialized correctly, otherwise an erroror
	indicating the reason for failure.
*/

{
	NTSTATUS		status;
	UNICODE_STRING  ntDeviceName;
	UNICODE_STRING  win32DeviceName;
	PDEVICE_OBJECT  deviceObject = NULL;

	RtlInitUnicodeString(&ntDeviceName, NT_DEVICE_NAME);

	status = IoCreateDevice(
		DriverObject,					// Our Driver Object
		0,								// We don't use a device extension
		&ntDeviceName,					// Device name 
		OLS_TYPE,						// Device type
		FILE_DEVICE_SECURE_OPEN,		// Device characteristics
		FALSE,							// Not an exclusive device
		&deviceObject );				// Returned ptr to Device Object

	if(!NT_SUCCESS(status))
	{
		refCount = (ULONG)-1;
		return status;
	}
	else
	{
		refCount = 0;
	}

	// Initialize the driver object with this driver's entry points.
	DriverObject->MajorFunction[IRP_MJ_CREATE] = OlsDispatch;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = OlsDispatch;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = OlsDispatch;
	DriverObject->DriverUnload = Unload;

	// Initialize a Unicode String containing the Win32 name for our device.
	RtlInitUnicodeString(&win32DeviceName, DOS_DEVICE_NAME);

	// Create a symbolic link between our device name  and the Win32 name
	status = IoCreateSymbolicLink(&win32DeviceName, &ntDeviceName);

	if (!NT_SUCCESS(status))
	{
		// Delete everything that this routine has allocated.
		IoDeleteDevice( deviceObject );
	}

	return status;
}

NTSTATUS
OlsDispatch(
	IN	PDEVICE_OBJECT pDO,
	IN	PIRP pIrp
	)

/*++

Routine Description:
	This routine is the dispatch handler for the driver.  It is responsible
	for processing the IRPs.

Arguments:
	
	pDO - Pointer to device object.

	pIrp - Pointer to the current IRP.

Return Value:

	STATUS_SUCCESS if the IRP was processed successfully, otherwise an erroror
	indicating the reason for failure.

--*/

{
	PIO_STACK_LOCATION pIrpStack;
	NTSTATUS status;
	int index;

	//  Initialize the irp info field.
	//	  This is used to return the number of bytes transfered.
	pIrp->IoStatus.Information = 0;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	//  Set default return status
	status = STATUS_NOT_IMPLEMENTED;

	// Dispatch based on major fcn code.
	switch(pIrpStack->MajorFunction)
	{
		case IRP_MJ_CREATE:
			if(refCount != (ULONG)-1){refCount++;}
			status = STATUS_SUCCESS;
			break;
		case IRP_MJ_CLOSE:
			if(refCount != (ULONG)-1){refCount--;}
			status = STATUS_SUCCESS;
			break;

		case IRP_MJ_DEVICE_CONTROL:
			//  Dispatch on IOCTL
			switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode)
			{
			case IOCTL_OLS_GET_DRIVER_VERSION:
				*(PULONG)pIrp->AssociatedIrp.SystemBuffer = OLS_DRIVER_VERSION;
				pIrp->IoStatus.Information = 4;
				status = STATUS_SUCCESS;
				break;

			case IOCTL_OLS_GET_REFCOUNT:
				*(PULONG)pIrp->AssociatedIrp.SystemBuffer = refCount;
				pIrp->IoStatus.Information = sizeof(refCount);
				status = STATUS_SUCCESS;
				break;

			case IOCTL_OLS_READ_MSR:
				status = ReadMsr(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;
			case IOCTL_OLS_WRITE_MSR:
				status = WriteMsr(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;
			case IOCTL_OLS_READ_PMC:
				status = ReadPmc(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;
			case IOCTL_OLS_HALT:
				__halt();
				status = STATUS_SUCCESS;
				break;

			case IOCTL_OLS_READ_IO_PORT:
			case IOCTL_OLS_READ_IO_PORT_BYTE:
			case IOCTL_OLS_READ_IO_PORT_WORD:
			case IOCTL_OLS_READ_IO_PORT_DWORD:
				status = ReadIoPort(
					pIrpStack->Parameters.DeviceIoControl.IoControlCode,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;
			case IOCTL_OLS_WRITE_IO_PORT:
			case IOCTL_OLS_WRITE_IO_PORT_BYTE:
			case IOCTL_OLS_WRITE_IO_PORT_WORD:
			case IOCTL_OLS_WRITE_IO_PORT_DWORD:
				status = WriteIoPort(
					pIrpStack->Parameters.DeviceIoControl.IoControlCode,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;

			case IOCTL_OLS_READ_PCI_CONFIG:
				status = ReadPciConfig(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;
			case IOCTL_OLS_WRITE_PCI_CONFIG:
				status = WritePciConfig(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;

			case IOCTL_OLS_READ_MEMORY:
				status = ReadMemory(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;
			case IOCTL_OLS_WRITE_MEMORY:
				status = WriteMemory(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;


			}
			break;
	}

	// We're done with I/O request.  Record the status of the I/O action.
	pIrp->IoStatus.Status = status;

	// Don't boost priority when returning since this took little time.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	return status;
}

VOID
Unload(
	PDRIVER_OBJECT DriverObject
	)
/*++

Routine Description:

	This routine is called by the I/O system to unload the driver.

	Any resources previously allocated must be freed.

Arguments:

	DriverObject - a pointer to the object that represents our driver.

Return Value:

	None
--*/

{
	PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
	UNICODE_STRING win32NameString;

	PAGED_CODE();

	// Create counted string version of our Win32 device name.
	RtlInitUnicodeString(&win32NameString, DOS_DEVICE_NAME);

	// Delete the link from our device name to a name in the Win32 namespace.
	IoDeleteSymbolicLink(&win32NameString);

	if(deviceObject != NULL)
	{
		IoDeleteDevice(deviceObject);
	}
}

//-----------------------------------------------------------------------------
//
// CPU
//
//-----------------------------------------------------------------------------

NTSTATUS
ReadMsr(	void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	__try
	{
		ULONGLONG data = __readmsr(*(ULONG*)lpInBuffer);
		memcpy((PULONG)lpOutBuffer, &data, 8);
		*lpBytesReturned = 8;
		return STATUS_SUCCESS;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		*lpBytesReturned = 0;
		return STATUS_UNSUCCESSFUL;
	}
}

NTSTATUS
WriteMsr(	void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	__try
	{
		OLS_WRITE_MSR_INPUT* param;
		param = (OLS_WRITE_MSR_INPUT*)lpInBuffer;

		__writemsr(param->Register, param->Value.QuadPart);
		*lpBytesReturned = 0;
		return STATUS_SUCCESS;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		*lpBytesReturned = 0;
		return STATUS_UNSUCCESSFUL;
	}
}

NTSTATUS
ReadPmc(	void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	__try
	{
		ULONGLONG data = __readpmc(*(ULONG*)lpInBuffer);
		memcpy((PULONG)lpOutBuffer, &data, 8);
		*lpBytesReturned = 8;
		return STATUS_SUCCESS;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		*lpBytesReturned = 0;
		return STATUS_UNSUCCESSFUL;
	}
}

//-----------------------------------------------------------------------------
//
// IO Port
//
//-----------------------------------------------------------------------------

NTSTATUS
ReadIoPort( ULONG	ioControlCode,
			void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	ULONG nPort = *(ULONG*)lpInBuffer;

	switch(ioControlCode)
	{
		case IOCTL_OLS_READ_IO_PORT_BYTE:
			*(PUCHAR)lpOutBuffer = READ_PORT_UCHAR((PUCHAR)(ULONG_PTR)nPort);
			break;
		case IOCTL_OLS_READ_IO_PORT_WORD:
			*(PUSHORT)lpOutBuffer = READ_PORT_USHORT((PUSHORT)(ULONG_PTR)nPort);
			break;
		case IOCTL_OLS_READ_IO_PORT_DWORD:
			*(PULONG)lpOutBuffer = READ_PORT_ULONG((PULONG)(ULONG_PTR)nPort);
			break;
		default:
			*lpBytesReturned = 0;
			return STATUS_INVALID_PARAMETER;
			break;
	}
	
	*lpBytesReturned = nInBufferSize;
	return STATUS_SUCCESS;
}

NTSTATUS
WriteIoPort(ULONG	ioControlCode,
			void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	ULONG nPort;
	OLS_WRITE_IO_PORT_INPUT* param;
	
	param = (OLS_WRITE_IO_PORT_INPUT*)lpInBuffer;
	nPort = param->PortNumber;

	switch(ioControlCode)
	{

		case IOCTL_OLS_WRITE_IO_PORT_BYTE:
			WRITE_PORT_UCHAR((PUCHAR)(ULONG_PTR)nPort, param->CharData);
			break;
		case IOCTL_OLS_WRITE_IO_PORT_WORD:
			WRITE_PORT_USHORT((PUSHORT)(ULONG_PTR)nPort, param->ShortData);
			break;
		case IOCTL_OLS_WRITE_IO_PORT_DWORD:
			WRITE_PORT_ULONG((PULONG)(ULONG_PTR)nPort, param->LongData);
			break;
		default:
			return STATUS_INVALID_PARAMETER;
			break;
	}

	return STATUS_SUCCESS;
}

//-----------------------------------------------------------------------------
//
// PCI
//
//-----------------------------------------------------------------------------

NTSTATUS
ReadPciConfig(	void	*lpInBuffer, 
				ULONG	nInBufferSize, 
				void	*lpOutBuffer, 
				ULONG	nOutBufferSize, 
				ULONG	*lpBytesReturned)
{
	OLS_READ_PCI_CONFIG_INPUT *param;
	NTSTATUS status;

	if(nInBufferSize != sizeof(OLS_READ_PCI_CONFIG_INPUT))
	{
		return STATUS_INVALID_PARAMETER;
	}
	param = (OLS_READ_PCI_CONFIG_INPUT *)lpInBuffer;

	status = pciConfigRead(param->PciAddress, param->PciOffset,
						lpOutBuffer, nOutBufferSize);

	if(status == STATUS_SUCCESS)
	{
		*lpBytesReturned = nOutBufferSize;
	}
	else
	{
		*lpBytesReturned = 0;
	}

	return status;
}

NTSTATUS
WritePciConfig(	void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned)

{
	OLS_WRITE_PCI_CONFIG_INPUT *param;
	ULONG writeSize;
	NTSTATUS status;

	if(nInBufferSize < offsetof(OLS_WRITE_PCI_CONFIG_INPUT, Data))
	{
		return STATUS_INVALID_PARAMETER;
	}

	param = (OLS_WRITE_PCI_CONFIG_INPUT *)lpInBuffer;
	writeSize = nInBufferSize - offsetof(OLS_WRITE_PCI_CONFIG_INPUT, Data);
	
	*lpBytesReturned = 0;

	return pciConfigWrite(param->PciAddress, param->PciOffset,
							&param->Data, writeSize);

}

//-----------------------------------------------------------------------------
//
// Support Function
//
//-----------------------------------------------------------------------------

NTSTATUS pciConfigRead(ULONG pciAddress, ULONG offset, void *data, int length)
{
	PCI_SLOT_NUMBER slot;
	int error;
	ULONG busNumber;

	busNumber = PciGetBus(pciAddress);
	slot.u.AsULONG = 0;
	slot.u.bits.DeviceNumber = PciGetDev(pciAddress);
	slot.u.bits.FunctionNumber = PciGetFunc(pciAddress);
	error =	HalGetBusDataByOffset(PCIConfiguration, busNumber, slot.u.AsULONG,
									data, offset, length);

	if(error == 0)
	{
		return OLS_ERROR_PCI_BUS_NOT_EXIST;
	}
	else if(length != 2 && error == 2)
	{
		return OLS_ERROR_PCI_NO_DEVICE;
	}
	else if(length != error)
	{
		return OLS_ERROR_PCI_READ_CONFIG;
	}

	return STATUS_SUCCESS;
}

NTSTATUS pciConfigWrite(ULONG pciAddress, ULONG offset, void *data, int length)
{
	PCI_SLOT_NUMBER slot;
	int error;
	ULONG busNumber;

	busNumber = PciGetBus(pciAddress);

	slot.u.AsULONG = 0;
	slot.u.bits.DeviceNumber = PciGetDev(pciAddress);
	slot.u.bits.FunctionNumber = PciGetFunc(pciAddress);
	error = HalSetBusDataByOffset(PCIConfiguration, busNumber, slot.u.AsULONG,
									data, offset, length);

	if(error != length)
	{
		return OLS_ERROR_PCI_WRITE_CONFIG;
	}

	return STATUS_SUCCESS;
}


//-----------------------------------------------------------------------------
//
// Physical Memory
//
//-----------------------------------------------------------------------------

NTSTATUS
ReadMemory(	void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	OLS_READ_MEMORY_INPUT *param;
	ULONG	size;
	PHYSICAL_ADDRESS address;
	PVOID	maped;
	BOOLEAN	error;

	if(nInBufferSize != sizeof(OLS_READ_MEMORY_INPUT))
	{
		return STATUS_INVALID_PARAMETER;
	}

	param = (OLS_READ_MEMORY_INPUT *)lpInBuffer;
	size = param->UnitSize * param->Count;

	if(nOutBufferSize < size)
	{
		return STATUS_INVALID_PARAMETER;
	}

	address.QuadPart = param->Address.QuadPart;

#ifndef _PHYSICAL_MEMORY_SUPPORT

	if(0x000C0000 > address.QuadPart 
	|| (address.QuadPart + size - 1) > 0x000FFFFF)
	{
		return STATUS_INVALID_PARAMETER;
	}

#endif

	maped = MmMapIoSpace(address, size, FALSE);

	error = FALSE;
	switch(param->UnitSize){
		case 1:
			READ_REGISTER_BUFFER_UCHAR(maped, lpOutBuffer, param->Count);
			break;
		case 2:
			READ_REGISTER_BUFFER_USHORT(maped, lpOutBuffer, param->Count);
			break;
		case 4:
			READ_REGISTER_BUFFER_ULONG(maped, lpOutBuffer, param->Count);
			break;
		default:
			error = TRUE;
			break;
	}

	MmUnmapIoSpace(maped, size);

	if(error)
	{
		return STATUS_INVALID_PARAMETER;
	}

	*lpBytesReturned = nOutBufferSize;

	return STATUS_SUCCESS;
}

NTSTATUS
WriteMemory(void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
#ifdef _PHYSICAL_MEMORY_SUPPORT

	OLS_WRITE_MEMORY_INPUT *param;
	ULONG size;
	PHYSICAL_ADDRESS address;
	PVOID	maped;
	BOOLEAN	error;

	if(nInBufferSize < offsetof(OLS_WRITE_MEMORY_INPUT, Data))
	{
		return STATUS_INVALID_PARAMETER;
	}

	param = (OLS_WRITE_MEMORY_INPUT *)lpInBuffer;

	size = param->UnitSize * param->Count;
	if (nInBufferSize < size + offsetof(OLS_WRITE_MEMORY_INPUT, Data))
	{
		return STATUS_INVALID_PARAMETER;
	}

	address.QuadPart = param->Address.QuadPart;

	maped = MmMapIoSpace(address, size, FALSE);

	error = FALSE;
	switch(param->UnitSize){
		case 1:
			WRITE_REGISTER_BUFFER_UCHAR(maped, 
										(UCHAR*)&param->Data, param->Count);
			break;
		case 2:
			WRITE_REGISTER_BUFFER_USHORT(maped,
										(USHORT*)&param->Data, param->Count);
			break;
		case 4:
			WRITE_REGISTER_BUFFER_ULONG(maped,
										(ULONG*)&param->Data, param->Count);
			break;
		default:
			error = TRUE;
			break;
	}

	MmUnmapIoSpace(maped, size);

	if(error)
	{
		return STATUS_INVALID_PARAMETER;
	}

	*lpBytesReturned = 0;

	return STATUS_SUCCESS;

#else

	*lpBytesReturned = 0;
	
	return STATUS_INVALID_PARAMETER;

#endif
}

```

`WinRing0/OpenLibSys.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2008 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#include <ntddk.h>
#include <devioctl.h>
#include "OlsIoctl.h"

//-----------------------------------------------------------------------------
//
// Device Name
//
//-----------------------------------------------------------------------------

#define NT_DEVICE_NAME	L"\\Device\\WinRing0_1_2_0"
#define DOS_DEVICE_NAME	L"\\DosDevices\\WinRing0_1_2_0"

//-----------------------------------------------------------------------------
//
// Function Prototypes
//
//-----------------------------------------------------------------------------

NTSTATUS	DriverEntry(
				IN PDRIVER_OBJECT DriverObject,
				IN PUNICODE_STRING RegistryPath
			);

NTSTATUS	OlsDispatch(
				IN PDEVICE_OBJECT pDO,
				IN PIRP pIrp
			);

VOID		Unload(
				IN PDRIVER_OBJECT DriverObject
			);

//-----------------------------------------------------------------------------
//
// Function Prototypes for Control Code
//
//-----------------------------------------------------------------------------

NTSTATUS	ReadMsr(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	WriteMsr(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);
			
NTSTATUS	ReadPmc(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	ReadIoPort(
				ULONG ioControlCode,
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	WriteIoPort(
				ULONG ioControlCode,
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	ReadPciConfig(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	WritePciConfig(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);
			
NTSTATUS	ReadMemory(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	WriteMemory(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);


//-----------------------------------------------------------------------------
//
// Support Function Prototypes
//
//-----------------------------------------------------------------------------

NTSTATUS pciConfigRead(ULONG pciAddress, ULONG offset, void *data, int length);
NTSTATUS pciConfigWrite(ULONG pciAddress, ULONG offset, void *data, int length);

```

`WinRing0/OpenLibSys.rc`:

```rc
#include <windows.h>
#include <ntverp.h>

#define VER_FILETYPE                VFT_DRV
#define VER_FILESUBTYPE             VFT2_DRV_SYSTEM

#define VER_FILEDESCRIPTION_STR     "WinRing0"
#define VER_INTERNALNAME_STR        "WinRing0.sys"

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1, 2, 0, 5
 PRODUCTVERSION 1, 2, 0, 5
 FILEFLAGSMASK 0x3fL
 FILEFLAGS 0x0L
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "041104b0"
        BEGIN
            VALUE "Comments", "The modified BSD license\0"
            VALUE "CompanyName", "OpenLibSys.org\0"
            VALUE "FileDescription", "WinRing0\0"
            VALUE "FileVersion", "1.2.0.5\0"
            VALUE "InternalName", "WinRing0.sys\0"
            VALUE "LegalCopyright", "Copyright (C) 2007-2008 OpenLibSys.org. All rights reserved.\0"
            VALUE "OriginalFilename", "WinRing0.sys\0"
            VALUE "ProductName", "WinRing0\0"
            VALUE "ProductVersion", "1.2.0.5\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x411, 1200
    END
END

```

`WinRing0/SOURCES`:

```
TARGETNAME=WinRing0
TARGETPATH=lib
TARGETTYPE=DRIVER

INCLUDES=..\

SOURCES=OpenLibSys.c OpenLibSys.rc

```