Project Path: arc_gmh5225_ice9_hi1wkqyk

Source Tree:

```txt
arc_gmh5225_ice9_hi1wkqyk
├── LICENSE
├── ice9
│   ├── dllmain.cpp
│   ├── ice9.cpp
│   ├── ice9.h
│   ├── ice9.vcxproj
│   ├── ice9.vcxproj.filters
│   ├── ice9_antidebug.h
│   ├── ice9_internal.h
│   ├── ice9_message_monitor.h
│   ├── ice9_modules_monitor.h
│   ├── ice9_process_monitor.h
│   ├── ice9_thread_monitor.h
│   ├── ice9_window_hook.h
│   ├── ice9_window_hook_experimental.h
│   ├── ice9_window_raw_hook.h
│   ├── stdafx.cpp
│   └── stdafx.h
├── ice9.sln
└── readme.md

```

`LICENSE`:

```
                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.
```

`ice9.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ice9", "ice9\ice9.vcxproj", "{E5F90BF4-F235-41C8-880B-15C74274828B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E5F90BF4-F235-41C8-880B-15C74274828B}.Debug|x64.ActiveCfg = Debug|x64
		{E5F90BF4-F235-41C8-880B-15C74274828B}.Debug|x64.Build.0 = Debug|x64
		{E5F90BF4-F235-41C8-880B-15C74274828B}.Debug|x86.ActiveCfg = Debug|Win32
		{E5F90BF4-F235-41C8-880B-15C74274828B}.Debug|x86.Build.0 = Debug|Win32
		{E5F90BF4-F235-41C8-880B-15C74274828B}.Release|x64.ActiveCfg = Release|x64
		{E5F90BF4-F235-41C8-880B-15C74274828B}.Release|x64.Build.0 = Release|x64
		{E5F90BF4-F235-41C8-880B-15C74274828B}.Release|x86.ActiveCfg = Release|Win32
		{E5F90BF4-F235-41C8-880B-15C74274828B}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`ice9/dllmain.cpp`:

```cpp
#include "stdafx.h"

BOOL APIENTRY DllMain( HMODULE hModule,DWORD  ul_reason_for_call,LPVOID lpReserved){

	switch (ul_reason_for_call){

    case DLL_PROCESS_ATTACH: {
        ice9().instance().on_thread_attach(hModule, ul_reason_for_call, lpReserved);
        break;
    }
    case DLL_THREAD_ATTACH: {
        ice9().instance().on_thread_attach(hModule, ul_reason_for_call, lpReserved);
        break;
    }
    case DLL_THREAD_DETACH: {
        ice9().instance().on_thread_detach(hModule, ul_reason_for_call, lpReserved);
        break;
    }
    case DLL_PROCESS_DETACH: {
        ice9().instance().on_thread_detach(hModule, ul_reason_for_call, lpReserved);
        break;
    }
                        
    default:break;
	}
	return TRUE;
}


```

`ice9/ice9.cpp`:

```cpp
#include "stdafx.h"
#include "ice9.h"

bool is_initiated = false;
ice9 * g_ice9 = 0;

ice9::ice9(){
    if (!is_initiated) {
        is_initiated = true;
        g_ice9 = new ice9();
       
#ifdef ICE9_DEBUG  
        if (AllocConsole()) { freopen("CONOUT$", "w", stdout); setlocale(LC_ALL, "RUS"); }
        Sleep(500);
#endif

        g_ice9->do_init_ice9();
        return;
    }
}


ice9::~ice9(){
    //not used
}

void ice9::do_init_ice9() {
    main_module = GetModuleHandle(0);


#ifdef _M_IX86
    IsWow64Process(GetCurrentProcess(), &is_64);
#else
    is_64 = true;
#endif

    funcs.push_back((BYTE*)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryInformationThread"));
    funcs.push_back((BYTE*)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation"));
    funcs.push_back((BYTE*)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryObject"));

    HMODULE kernel32 = GetModuleHandleA("kernel32.dll");
    HMODULE kernelbase = GetModuleHandleA("kernelbase.dll");

    suspected_funcs.push_back((BYTE*)GetProcAddress(kernel32, "LoadLibraryA"));
    suspected_funcs.push_back((BYTE*)GetProcAddress(kernel32, "LoadLibraryW"));
    suspected_funcs.push_back((BYTE*)GetProcAddress(kernel32, "FreeLibrary"));

    if (kernelbase) {
        suspected_funcs.push_back((BYTE*)GetProcAddress(kernelbase, "LoadLibraryA"));
        suspected_funcs.push_back((BYTE*)GetProcAddress(kernelbase, "LoadLibraryW"));
        suspected_funcs.push_back((BYTE*)GetProcAddress(kernelbase, "FreeLibrary"));
    }

#ifdef ICE9_WINDOW_HOOK_EXPERIMENTAL_ENABLED
    set_window_hook_exp();
#endif
    set_dll_hook();

}


ice9 &ice9::instance() {
    return *g_ice9;
}

BYTE * ice9::get_dispatch_client_message_a() {
    return o_DispatchClientMessage_A;
}
BYTE * ice9::get_dispatch_client_message_w() {
    return o_DispatchClientMessage_W;
}
BYTE * ice9::get_client_load_library() {
    return o_ClientLoadLibrary;
}

std::vector<msg_manager>& ice9::get_windows() {
    return windows;
}
std::vector<unsigned int>& ice9::get_threads() {
    return threads;
}

void ice9::on_event(ice9_event_code code) {



}

#include "ice9_internal.h"
#include "ice9_process_monitor.h"
#include "ice9_thread_monitor.h"
#include "ice9_modules_monitor.h"
#include "ice9_message_monitor.h"
#include "ice9_antidebug.h"
```

`ice9/ice9.h`:

```h
#pragma once


#define ICE9_DEBUG

#define ICE9_THREAD_ENABLED
#define ICE9_WINDOW_HOOK_ENABLED
#define ICE9_WINDOW_RAW_HOOK_ENABLED
#define ICE9_WINDOW_HOOK_EXPERIMENTAL_ENABLED
#define ICE9_ANTI_DEBUG_ENABLED
#define ICE9_PREVENT_WINDOW_HOOK_DLL_ENABLED
#define ICE9_DLL_MONITOR_ENABLED

enum ice9_event_code {
    ice9_ok,
    ice9_thread_remote,
    ice9_thread_unbase,
    ice9_thread_suspected_address,
    ice9_thread_detach_isnt_pool,

    ice9_bad_dll_loaded,

    ice9_message_emulated,
    ice9_input_emulated,
    ice9_window_not_found,
};

struct msg_manager {
    HWND    hwnd;
    WNDPROC proc;
    HHOOK   hook;
    
    struct {
        int up;
        int down;
        unsigned int blocked;
    }key_press[256];

    BYTE mouse_press[3];
};


class ice9{
    HMODULE main_module;
    std::vector<BYTE *> funcs;
    std::vector<BYTE *> suspected_funcs;
    std::vector<unsigned int> threads;
    std::vector<msg_manager>  windows;

    BOOL is_64 = false;
    
    BYTE obj_type_thread = 0xFF;
    BYTE obj_type_process = 0xFF;

    void * vtbl_pDispatchA = 0;
    void * vtbl_pDispatchW = 0;
    BYTE * o_DispatchClientMessage_A = 0;
    BYTE * o_DispatchClientMessage_W = 0;

    BYTE * dll_notify_cookie = 0;
    BYTE * o_ClientLoadLibrary = 0;

    PVOID ice9::get_thread_start_address(HANDLE hthread);
    bool  ice9::is_remote_thread(DWORD id);
    ice9_event_code ice9::check_current_thread();

    void ice9::set_window_hook(msg_manager& mgr);   
    void ice9::unset_window_hook(msg_manager& mgr);

    void ice9::unset_window_hook_exp();
    void ice9::set_window_hook_exp();

    void ice9::set_raw_window_hook(msg_manager& mgr);
    void ice9::unset_raw_window_hook(msg_manager& mgr);

    void ice9::set_dll_hook();
    void ice9::unset_dll_hook();

    void ice9::antidebug_on_thread();
public:
    ice9::ice9();
    ice9::~ice9();

    void ice9::do_init_ice9();

    void ice9::on_event(ice9_event_code code);

    void ice9::on_thread_attach(HMODULE hmodule, DWORD reason, LPVOID reserved);
    void ice9::on_thread_detach(HMODULE hmodule, DWORD reason, LPVOID reserved);

    void ice9::on_window_attach(HWND hwnd);
    void ice9::on_window_detach(HWND hwnd);

    void ice9::on_dll_attach(std::wstring dll_path);
    void ice9::on_dll_detach(std::wstring dll_path);
public:
    ice9& ice9::instance();

    BYTE * ice9::get_dispatch_client_message_a();
    BYTE * ice9::get_dispatch_client_message_w();
    BYTE * ice9::get_client_load_library();

    std::vector<msg_manager>& ice9::get_windows();
    std::vector<unsigned int>& ice9::get_threads();
};


```

`ice9/ice9.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E5F90BF4-F235-41C8-880B-15C74274828B}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ice9</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;ICE9_EXPORTS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USRDLL;ICE9_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;ICE9_EXPORTS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;ICE9_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="ice9.h" />
    <ClInclude Include="ice9_antidebug.h" />
    <ClInclude Include="ice9_internal.h" />
    <ClInclude Include="ice9_message_monitor.h" />
    <ClInclude Include="ice9_modules_monitor.h" />
    <ClInclude Include="ice9_process_monitor.h" />
    <ClInclude Include="ice9_thread_monitor.h" />
    <ClInclude Include="ice9_window_hook.h" />
    <ClInclude Include="ice9_window_hook_experimental.h" />
    <ClInclude Include="ice9_window_raw_hook.h" />
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </PrecompiledHeader>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      </PrecompiledHeader>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </PrecompiledHeader>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
      </PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="ice9.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\LICENSE" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ice9/ice9.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Файлы исходного кода">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Заголовочные файлы">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Заголовочные файлы\ice9">
      <UniqueIdentifier>{d9ad4a9d-55c1-455e-8c68-0b5dcc5eb30e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\ice9\external_detect">
      <UniqueIdentifier>{6630f914-5161-4b17-8aa4-c59fc838dd93}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\ice9\internal_detect">
      <UniqueIdentifier>{eed01213-7dd8-497d-a6c2-726c8faba22f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\ice9\internal_detect\thread_monitor">
      <UniqueIdentifier>{0650500b-4585-421a-80ec-e10dda55e278}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\ice9\internal_detect\modules_monitor">
      <UniqueIdentifier>{82a84a1d-5ae8-44c0-99b4-ee82bb4aa432}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\ice9\internal_detect\msg_monitor">
      <UniqueIdentifier>{40c4cd64-fff6-4c01-8fbc-cc932092c82e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\ice9\external_detect\process_monitor">
      <UniqueIdentifier>{185c77f5-389c-40e5-ba27-a2d1e799dc6e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\ice9\internal_detect\msg_monitor\handers">
      <UniqueIdentifier>{fcdffede-3d1f-4305-934a-0f1f82c75912}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\ice9\internal_detect\antidebug">
      <UniqueIdentifier>{4278660a-9c5d-439d-9461-1aa6423af758}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Заголовочные файлы</Filter>
    </ClInclude>
    <ClInclude Include="ice9.h">
      <Filter>Заголовочные файлы\ice9</Filter>
    </ClInclude>
    <ClInclude Include="ice9_modules_monitor.h">
      <Filter>Заголовочные файлы\ice9\internal_detect\modules_monitor</Filter>
    </ClInclude>
    <ClInclude Include="ice9_message_monitor.h">
      <Filter>Заголовочные файлы\ice9\internal_detect\msg_monitor</Filter>
    </ClInclude>
    <ClInclude Include="ice9_thread_monitor.h">
      <Filter>Заголовочные файлы\ice9\internal_detect\thread_monitor</Filter>
    </ClInclude>
    <ClInclude Include="ice9_process_monitor.h">
      <Filter>Заголовочные файлы\ice9\external_detect\process_monitor</Filter>
    </ClInclude>
    <ClInclude Include="ice9_internal.h">
      <Filter>Заголовочные файлы\ice9</Filter>
    </ClInclude>
    <ClInclude Include="ice9_window_hook.h">
      <Filter>Заголовочные файлы\ice9\internal_detect\msg_monitor\handers</Filter>
    </ClInclude>
    <ClInclude Include="ice9_window_raw_hook.h">
      <Filter>Заголовочные файлы\ice9\internal_detect\msg_monitor\handers</Filter>
    </ClInclude>
    <ClInclude Include="ice9_antidebug.h">
      <Filter>Заголовочные файлы\ice9\internal_detect\antidebug</Filter>
    </ClInclude>
    <ClInclude Include="ice9_window_hook_experimental.h">
      <Filter>Заголовочные файлы\ice9\internal_detect\msg_monitor\handers</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Файлы исходного кода</Filter>
    </ClCompile>
    <ClCompile Include="dllmain.cpp">
      <Filter>Файлы исходного кода</Filter>
    </ClCompile>
    <ClCompile Include="ice9.cpp">
      <Filter>Заголовочные файлы\ice9</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\LICENSE" />
  </ItemGroup>
</Project>
```

`ice9/ice9_antidebug.h`:

```h
#pragma once


void ice9::antidebug_on_thread() {
    bool set_hide = true;
    SetThreadInformation(GetCurrentThread(), (THREAD_INFORMATION_CLASS)ThreadHideFromDebugger, &set_hide, 1);
}
```

`ice9/ice9_internal.h`:

```h
#pragma once

#ifdef _M_IX86
#define POINTER_TYPE DWORD
#else
#define POINTER_TYPE DWORD64
#endif

#define STATUS_SUCCESS  ((NTSTATUS)0x0)
#define STATUS_INFO_LENGTH_MISMATCH 0xc0000004

#define ThreadHideFromDebugger 0x00000004

#define ObjectBasicInformation 0
#define ObjectNameInformation 1
#define ObjectTypeInformation 2
#define SystemHandleInformation 16

#define LDR_DLL_NOTIFICATION_REASON_LOADED   1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

#define ThreadQuerySetWin32StartAddress 9

#define __ClientLoadLibrary_idx 74

#define _DispatchClientMessage_idx 21

#define DLLEXPORT extern "C" __declspec(dllexport)

struct SWH_DATA {
    DWORD unk_0;
    DWORD unk_4;
    DWORD unk_8;
    DWORD unk_c;
    DWORD unk_10;
    DWORD unk_14;
    UNICODE_STRING lpDllPath;
    DWORD unk_20;
};

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, *PLDR_DLL_UNLOADED_NOTIFICATION_DATA;


typedef union _LDR_DLL_NOTIFICATION_DATA {
    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
    LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;

typedef VOID(CALLBACK* PLDR_DLL_NOTIFICATION_FUNCTION)(ULONG NotificationReason,
    _In_     PLDR_DLL_NOTIFICATION_DATA NotificationData,
    _In_opt_ PVOID Context
    );

typedef int (WINAPI * _ClientLoadLibrary)(SWH_DATA * data);

typedef struct _SYSTEM_HANDLE
{
    ULONG ProcessId;
    BYTE ObjectTypeNumber;
    BYTE Flags;
    USHORT Handle;
    PVOID Object;
    ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG HandleCount;
    SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef enum _POOL_TYPE
{
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS
} POOL_TYPE, *PPOOL_TYPE;

typedef struct _OBJECT_TYPE_INFORMATION
{
    UNICODE_STRING Name;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccess;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    USHORT MaintainTypeList;
    POOL_TYPE PoolType;
    ULONG PagedPoolUsage;
    ULONG NonPagedPoolUsage;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _fnClient {
    struct pfnelement {
        void * pFunc;
#ifdef _M_IX86
        DWORD aling_x32;
#endif
    }element[40];
}fnClient, *pfnClient;

typedef struct _fnClient32 {
    struct pfnelement {
        void * pFunc;
    }element[40];
}fnClient32, *pfnClient32;


typedef int (WINAPI * _RtlRetrieveNtUserPfn)(void** clientA, void** clientW, void** Unk);

typedef int (WINAPI * _DispatchClientMessagex64)(HWND *hwnd,
#ifdef _M_IX86 
    DWORD aling_32,
#endif
    DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc);

typedef int (WINAPI * _DispatchClientMessagex32)(HWND *hwnd, DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc);


typedef NTSTATUS(WINAPI* _NtQueryInformationThread)(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);
typedef NTSTATUS(WINAPI* _NtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
typedef NTSTATUS(WINAPI* _NtQueryObject)(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);


typedef NTSTATUS(WINAPI* _LdrRegisterDllNotification)(ULONG Flags, PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction, PVOID Context, PVOID *Cookie);
typedef NTSTATUS(WINAPI* _LdrUnregisterDllNotification)(PVOID Cookie);
```

`ice9/ice9_message_monitor.h`:

```h
#pragma once
#pragma comment(linker, "/EXPORT:CreateWindowExA=_imp_CreateWindowExA@48")
#pragma comment(linker, "/EXPORT:CreateWindowExW=_imp_CreateWindowExW@48")
#pragma comment(linker, "/EXPORT:DestroyWindow=_imp_DestroyWindow@4")

LRESULT CALLBACK raw_proc_filter(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

#include "ice9_window_hook.h"
#include "ice9_window_hook_experimental.h"
#include "ice9_window_raw_hook.h"

typedef HWND (WINAPI* j_CreateWindowExA)(DWORD dwExStyle,LPCSTR lpClassName,LPCSTR lpWindowName,
    DWORD dwStyle,int X,int Y,int nWidth,int nHeight,HWND hWndParent,HMENU hMenu,HINSTANCE hInstance,LPVOID lpParam);

typedef HWND(WINAPI* j_CreateWindowExW)(DWORD dwExStyle,LPCWSTR lpClassName,LPCWSTR lpWindowName,
    DWORD dwStyle,int X,int Y,int nWidth,int nHeight,HWND hWndParent,HMENU hMenu,HINSTANCE hInstance,LPVOID lpParam);

typedef BOOL(WINAPI* j_DestroyWindow)(HWND hWnd);

DLLEXPORT HWND WINAPI imp_CreateWindowExA(
    _In_ DWORD dwExStyle,
    _In_opt_ LPCSTR lpClassName,
    _In_opt_ LPCSTR lpWindowName,
    _In_ DWORD dwStyle,
    _In_ int X,
    _In_ int Y,
    _In_ int nWidth,
    _In_ int nHeight,
    _In_opt_ HWND hWndParent,
    _In_opt_ HMENU hMenu,
    _In_opt_ HINSTANCE hInstance,
    _In_opt_ LPVOID lpParam) {

    HWND ret_hwnd = j_CreateWindowExA(GetProcAddress(GetModuleHandleA("user32.dll"), "CreateWindowExA"))(
        dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam
        );

    if (ret_hwnd) {
        ice9().instance().on_window_attach(ret_hwnd);
    }

    return ret_hwnd;
}

DLLEXPORT HWND WINAPI imp_CreateWindowExW(
    _In_ DWORD dwExStyle,
    _In_opt_ LPCWSTR lpClassName,
    _In_opt_ LPCWSTR lpWindowName,
    _In_ DWORD dwStyle,
    _In_ int X,
    _In_ int Y,
    _In_ int nWidth,
    _In_ int nHeight,
    _In_opt_ HWND hWndParent,
    _In_opt_ HMENU hMenu,
    _In_opt_ HINSTANCE hInstance,
    _In_opt_ LPVOID lpParam) {

    HWND ret_hwnd = j_CreateWindowExW(GetProcAddress(GetModuleHandleA("user32.dll"), "CreateWindowExW"))(
        dwExStyle, lpClassName, lpWindowName, dwStyle,X,Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam
        );

    if (ret_hwnd) {
        ice9().instance().on_window_attach(ret_hwnd);
    } 

    return ret_hwnd;
}


DLLEXPORT BOOL WINAPI imp_DestroyWindow(HWND hWnd) {

    BOOL ret = j_DestroyWindow(GetProcAddress(GetModuleHandleA("user32.dll"), "DestroyWindow"))(hWnd);

    if (ret) {
        ice9().instance().on_window_detach(hWnd);
    }

    return ret;
}

void ice9::on_window_attach(HWND hwnd) {
#ifdef ICE9_DEBUG
    printf("window attached [%x]\n", hwnd);
#endif
    msg_manager win_mgr;
    ZeroMemory(&win_mgr, sizeof(msg_manager));
    win_mgr.hwnd = hwnd;
    
#ifdef ICE9_WINDOW_HOOK_ENABLED
    set_window_hook(win_mgr);
#endif 
#ifdef ICE9_WINDOW_RAW_HOOK_ENABLED
    set_raw_window_hook(win_mgr);
#endif
    windows.push_back(win_mgr);
}

void ice9::on_window_detach(HWND hwnd) {
#ifdef ICE9_DEBUG
    printf("window detached [%x]\n", hwnd);
#endif

    for (unsigned int item_mgr_idx = 0; item_mgr_idx < windows.size(); item_mgr_idx++) {
        if (windows[item_mgr_idx].hwnd == hwnd) {
#ifdef ICE9_WINDOW_HOOK_ENABLED
            unset_window_hook(windows[item_mgr_idx]); 
#endif
#ifdef ICE9_WINDOW_RAW_HOOK_ENABLED
            unset_raw_window_hook(windows[item_mgr_idx]);
#endif
            windows.erase(windows.begin() + item_mgr_idx);
        }
    }
}

LRESULT CALLBACK raw_proc_filter(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {

    for (auto& win_mgr : ice9().instance().get_windows()) {
        if (win_mgr.hwnd == hWnd) {

           switch (message) {
            case WM_LBUTTONDOWN: {
                if (!win_mgr.mouse_press[0]) {
                    ice9().instance().on_event(ice9_message_emulated);
#ifdef ICE9_DEBUG
                    printf("Device Emulation [SendMessage]\n");
#endif
                    return 0;
                }
                break;
            }
            case WM_MBUTTONDOWN: {
                if (!win_mgr.mouse_press[1]) {
                    ice9().instance().on_event(ice9_message_emulated);
#ifdef ICE9_DEBUG
                    printf("Device Emulation [SendMessage]\n");
#endif
                    return 0;
                }
                break;
            }
            case WM_RBUTTONDOWN: {
                if (!win_mgr.mouse_press[2]) {
                    ice9().instance().on_event(ice9_message_emulated);
#ifdef ICE9_DEBUG
                    printf("Device Emulation [SendMessage]\n");
#endif
                    return 0;
                }
                break;
            }

            //KeyBoard
            case WM_KEYDOWN: {
                if (!win_mgr.key_press[wParam].down) {   
                    ice9().instance().on_event(ice9_message_emulated);
#ifdef ICE9_DEBUG
                    printf("Device Emulation [SendMessage]\n");
#endif
                    return 0;
                }
                else {
                    win_mgr.key_press[wParam].down--;
                }
                break;
            }
            case WM_KEYUP: {
                if (!win_mgr.key_press[wParam].up) {
                    ice9().instance().on_event(ice9_message_emulated);
#ifdef ICE9_DEBUG
                    printf("Device Emulation [SendMessage]\n");
#endif
                    return 0;
                }
                else {
                    win_mgr.key_press[wParam].up--;
                }
                break;
            }


            case WM_INPUT: {


                if (GET_RAWINPUT_CODE_WPARAM(wParam) == RIM_INPUT) {
                    BYTE *lpb = NULL;
                    UINT dwSize = sizeof(RAWINPUT);

                    GetRawInputData((HRAWINPUT)lParam, RID_INPUT, NULL, &dwSize, sizeof(RAWINPUTHEADER));
                    lpb = new BYTE[dwSize];


                    if (GetRawInputData((HRAWINPUT)lParam, RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER)) != dwSize) {
                        return 0;
                    }

                    if (((RAWINPUT*)(lpb))->header.hDevice) {
                        if (((RAWINPUT*)(lpb))->data.keyboard.Message == WM_KEYDOWN) {
                            win_mgr.key_press[(BYTE)((RAWINPUT*)(lpb))->data.keyboard.VKey].down++;
                        }
                        if (((RAWINPUT*)(lpb))->data.keyboard.Message == WM_KEYUP) {
                            win_mgr.key_press[(BYTE)((RAWINPUT*)(lpb))->data.keyboard.VKey].up++;
                        }
                        delete[] lpb;
                    }
                    else {
                        ice9().instance().on_event(ice9_input_emulated);
#ifdef ICE9_DEBUG
                        printf("Device Emulation [SendInput]\n");
#endif
                        delete[] lpb;
                        return 0;
                    }
                }
                break;
            }

            default: break;
            }

            return win_mgr.proc(hWnd, message, wParam, lParam);
        }
    }

#ifdef ICE9_DEBUG
    printf("window not found hwnd[%s] msg[%x]\n", hWnd, message);
#endif

    ice9().instance().on_event(ice9_window_not_found);
    return 0;
}
```

`ice9/ice9_modules_monitor.h`:

```h
#pragma once




int WINAPI client_load_library_handler(SWH_DATA * data) {

#ifdef ICE9_DEBUG
    if (data->lpDllPath.Buffer) {
    //    wprintf(L"client_load_library_handler [%s]\n", data->lpDllPath.Buffer);
    }
#endif
    return 1;

    /*
    you can add logic there 
    */

    if (data->lpDllPath.Buffer) {
        ice9().instance().on_dll_attach(data->lpDllPath.Buffer);
    }
    return _ClientLoadLibrary(ice9().instance().get_client_load_library())(data);
}

VOID WINAPI dll_notify_handler(ULONG NotificationReason,PLDR_DLL_NOTIFICATION_DATA NotificationData,PVOID Context) {

    switch (NotificationReason) {
        case LDR_DLL_NOTIFICATION_REASON_LOADED: {
            ice9().instance().on_dll_attach(NotificationData->Loaded.FullDllName->Buffer);
            break;
        }

        case LDR_DLL_NOTIFICATION_REASON_UNLOADED: {
            ice9().instance().on_dll_detach(NotificationData->Loaded.FullDllName->Buffer);
            break;
        }
    }
}


inline LPVOID * get_apfn_dispatch() {
#ifdef _M_IX86 
    return (LPVOID *)*(DWORD *)(__readfsdword(0x30) + 0x2C);
#else
    return (LPVOID *)*(DWORD64 *)(__readgsqword(0x60) + 0x58);
#endif
}


void ice9::set_dll_hook() {
#ifdef ICE9_DLL_MONITOR_ENABLED
    _LdrRegisterDllNotification LdrRegisterDllNotification = (_LdrRegisterDllNotification)GetProcAddress(
        GetModuleHandleA("ntdll.dll"), "LdrRegisterDllNotification"
    );

    if (LdrRegisterDllNotification) {
        LdrRegisterDllNotification(0, dll_notify_handler, 0, (void**)&dll_notify_cookie);
    }
#endif

#ifdef ICE9_PREVENT_WINDOW_HOOK_DLL_ENABLED
    DWORD oldprot;
    LPVOID * apfnDispatch = get_apfn_dispatch();
    if (apfnDispatch) {
        o_ClientLoadLibrary = (BYTE*)apfnDispatch[__ClientLoadLibrary_idx];

        VirtualProtect(apfnDispatch, 117 * sizeof(LPVOID), PAGE_EXECUTE_READWRITE, &oldprot);
        apfnDispatch[__ClientLoadLibrary_idx] = client_load_library_handler;
        VirtualProtect(apfnDispatch, 117 * sizeof(LPVOID), oldprot, &oldprot);
    }
#endif
}

void ice9::unset_dll_hook() {
#ifdef ICE9_DLL_MONITOR_ENABLED
    _LdrUnregisterDllNotification LdrUnregisterDllNotification = (_LdrUnregisterDllNotification)GetProcAddress(
        GetModuleHandleA("ntdll.dll"), "LdrUnregisterDllNotification"
    );

    if (LdrUnregisterDllNotification) {
        LdrUnregisterDllNotification(this->dll_notify_cookie);
    }
#endif

#ifdef ICE9_PREVENT_WINDOW_HOOK_DLL_ENABLED
    DWORD oldprot;
    LPVOID * apfnDispatch = get_apfn_dispatch();
    if (apfnDispatch && o_ClientLoadLibrary) {
        VirtualProtect(apfnDispatch, 117 * sizeof(LPVOID), PAGE_EXECUTE_READWRITE, &oldprot);
        apfnDispatch[__ClientLoadLibrary_idx] = o_ClientLoadLibrary;
        VirtualProtect(apfnDispatch, 117 * sizeof(LPVOID), oldprot, &oldprot);
    }
#endif
}

void ice9::on_dll_attach(std::wstring dll_path) {
#ifdef ICE9_DEBUG
    wprintf(L"dll attached [%s]\n", dll_path.c_str());
#endif

}


void ice9::on_dll_detach(std::wstring dll_path) {
#ifdef ICE9_DEBUG
    wprintf(L"dll detached [%s]\n", dll_path.c_str());
#endif

}
```

`ice9/ice9_process_monitor.h`:

```h
#pragma once

```

`ice9/ice9_thread_monitor.h`:

```h
#pragma once



PVOID ice9::get_thread_start_address(HANDLE hthread) {
    NTSTATUS ntStatus;
    PVOID dwStartAddress;

    ntStatus = _NtQueryInformationThread(funcs[0])(
        GetCurrentThread(), (THREADINFOCLASS)ThreadQuerySetWin32StartAddress, &dwStartAddress, sizeof(dwStartAddress), NULL
        );

    if (ntStatus != STATUS_SUCCESS) return 0;
    return dwStartAddress;
}


bool  ice9::is_remote_thread(DWORD id) {
    ULONG retlen = 0;
    ULONG table_length = 0;
    PSYSTEM_HANDLE_INFORMATION p_handle_table = 0;
    bool ret_status = true;

    while (1) {
        NTSTATUS status = _NtQuerySystemInformation(funcs[1])((SYSTEM_INFORMATION_CLASS)SystemHandleInformation,
            p_handle_table, table_length, &retlen
            );

        if (status == STATUS_SUCCESS) {
            break;
        }

        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            table_length += retlen;
            if (p_handle_table) { delete[]p_handle_table; }
            p_handle_table = (PSYSTEM_HANDLE_INFORMATION)new BYTE[table_length];
        }
    }

    if (this->obj_type_thread == 0xFF) {
        POBJECT_TYPE_INFORMATION objInfo = (POBJECT_TYPE_INFORMATION)new BYTE[0x1000];
        for (int i = 0; i < p_handle_table->HandleCount; i++) {
            if (p_handle_table->Handles[i].ProcessId == GetCurrentProcessId()) {
                if (_NtQueryObject(funcs[2])((HANDLE)p_handle_table->Handles[i].Handle, (OBJECT_INFORMATION_CLASS)ObjectTypeInformation, objInfo, 0x1000, NULL) == STATUS_SUCCESS) {
                    if (!lstrcmpW(objInfo->Name.Buffer, L"Thread")) {
                        this->obj_type_thread = p_handle_table->Handles[i].ObjectTypeNumber;
                    }
                }
            }
        }
        delete[]objInfo;
    }

    if (this->obj_type_thread != 0xFF) {
        for (int i = 0; i < p_handle_table->HandleCount; i++) {
            if (p_handle_table->Handles[i].ProcessId == GetCurrentProcessId() && p_handle_table->Handles[i].ObjectTypeNumber == this->obj_type_thread) {
                if (GetThreadId((HANDLE)p_handle_table->Handles[i].Handle) == id) {
                    ret_status = false;
                }
            }
        }
    }
    else {
        ret_status = false;
    }

    delete[]p_handle_table;

    return ret_status;
}


ice9_event_code ice9::check_current_thread() {

    if (!is_remote_thread(GetCurrentThreadId())) {
        PVOID StartAddress = get_thread_start_address(GetCurrentThread());
        if (StartAddress) {

#ifdef _M_IX86
            MEMORY_BASIC_INFORMATION32 MBI;
#else
            MEMORY_BASIC_INFORMATION64 MBI;
#endif
            DWORD mbi_size = sizeof(MBI);

            if (VirtualQuery(StartAddress, (MEMORY_BASIC_INFORMATION*)&MBI, mbi_size)) {

                if (MBI.Type&MEM_IMAGE) { 

                    for (auto& func : suspected_funcs) {
                        if (func == StartAddress) {
                            return ice9_event_code::ice9_thread_suspected_address;
                        }
                    }

                    return ice9_event_code::ice9_ok;
                }
            }
        }
        return ice9_event_code::ice9_thread_unbase;
    }

    return ice9_event_code::ice9_thread_remote;
}


void ice9::on_thread_attach(HMODULE hmodule, DWORD reason, LPVOID reserved) {
#ifdef ICE9_ANTI_DEBUG_ENABLED
    antidebug_on_thread();
#endif

#ifndef ICE9_THREAD_ENABLED
    return;
#endif

    ice9_event_code thread_code = check_current_thread();

    if (thread_code) {
#ifdef ICE9_DEBUG  
        switch (thread_code) {
        case ice9_event_code::ice9_thread_remote: {
            printf("thread [%x] was closed reason : [Remoted thread]\n", GetCurrentThreadId());
            break;
        }
        case ice9_event_code::ice9_thread_unbase: {
            printf("thread [%x] was closed reason : [Base address not IMAGE]\n", GetCurrentThreadId());
            break;
        }
        case ice9_event_code::ice9_thread_suspected_address: {
            printf("thread [%x] was closed reason : [Suspected base address]\n", GetCurrentThreadId());
            break;
        }
        }
#endif
        
        on_event(thread_code);
        TerminateThread(GetCurrentThread(), 0);
    }
    else {
#ifdef ICE9_DEBUG
        printf("attached new thread [%x]\n", GetCurrentThreadId());
#endif
        for (auto& thread_id : threads) {
            if (thread_id == GetCurrentThreadId()) { return; }
        }
        
        threads.push_back(GetCurrentThreadId());
    }
}

void ice9::on_thread_detach(HMODULE hmodule, DWORD reason, LPVOID reserved) {


    for (unsigned int thread_idx = 0; thread_idx < threads.size();thread_idx++) {
        if (thread_idx == GetCurrentThreadId()) {

#ifdef ICE9_DEBUG
            printf("detached thread [%x]\n", GetCurrentThreadId());
#endif
            threads.erase(threads.begin() + thread_idx);
            return;
        }
    }

#ifdef ICE9_DEBUG   
    printf("detached thread [%x] wasnt in thread pool!", GetCurrentThreadId());
#endif

    on_event(ice9_thread_detach_isnt_pool);
}
```

`ice9/ice9_window_hook.h`:

```h
#pragma once
LRESULT CALLBACK window_hook_handler(int code, WPARAM wParam, LPARAM lParam);

void ice9::set_window_hook(msg_manager& mgr) {
    mgr.hook = SetWindowsHookExA(WH_GETMESSAGE, window_hook_handler,0,GetWindowThreadProcessId(mgr.hwnd,0));
}
void ice9::unset_window_hook(msg_manager& mgr) {
    UnhookWindowsHookEx(mgr.hook);
}


LRESULT CALLBACK window_hook_handler(int code, WPARAM wParam, LPARAM lParam) {

    MSG * message = (MSG*)lParam;

    for (auto& win_mgr : ice9().instance().get_windows()) {
        if (win_mgr.hwnd == message->hwnd) {

            switch (message->message) {
            case WM_LBUTTONDOWN: {
                win_mgr.mouse_press[0] = true;
                break;
            }
            case WM_LBUTTONUP: {
                win_mgr.mouse_press[0] = false;
                break;
            }
            case WM_MBUTTONDOWN: {
                win_mgr.mouse_press[1] = true;
                break;
            }
            case WM_MBUTTONUP: {
                win_mgr.mouse_press[1] = false;
                break;
            }
            case WM_RBUTTONDOWN: {
                win_mgr.mouse_press[2] = true;
                break;
            }
            case WM_RBUTTONUP: {
                win_mgr.mouse_press[2] = false;
                break;
            }

            default:break;
            }

            return CallNextHookEx(0, code, wParam, lParam);
        }
    }
 
    return 1;
}
```

`ice9/ice9_window_hook_experimental.h`:

```h
#pragma once

int WINAPI h_DispatchClientMessage_A_win32(HWND* hwnd, DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc);
int WINAPI h_DispatchClientMessage_W_win32(HWND* hwnd, DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc);

int WINAPI h_DispatchClientMessage_A_win64(HWND* hwnd,
#ifdef _M_IX86
    DWORD aling_32,
#endif	
    DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc);

int WINAPI h_DispatchClientMessage_W_win64(HWND* hwnd,
#ifdef _M_IX86
    DWORD aling_32,
#endif	
    DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc);


void ice9::set_window_hook_exp() {
    void * fnClientA, *fnClientW, *fnClientWorker;
    _RtlRetrieveNtUserPfn RtlRetrieveNtUserPfn = (_RtlRetrieveNtUserPfn)GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlRetrieveNtUserPfn");
#ifdef ICE9_DEBUG
    printf("RtlRetrieveNtUserPfn[%p] \n", RtlRetrieveNtUserPfn);
#endif
    if (RtlRetrieveNtUserPfn && RtlRetrieveNtUserPfn(&fnClientA, &fnClientW, &fnClientWorker) == STATUS_SUCCESS ) {
#ifdef ICE9_DEBUG
        printf("fnClientA[%p] fnClientW[%p] fnClientWorker[%p]\n", fnClientA, fnClientW, fnClientWorker);
#endif
        if (fnClientA && fnClientW) {
            /*
              pfnClient->
              0x0 pFunc  ----->[ jmp [ntdll_vtbl[1]] ]->_user32_func1
              0x8 pFunc  ----->[ jmp [ntdll_vtbl[2]] ]->_user32_func2
              0x10 pFunc ----->[ jmp [ntdll_vtbl[3]] ]->_user32_func3
              0x18 pFunc ----->[ jmp [ntdll_vtbl[4]] ]->_user32_func4
              ...
              ...
              */

            if (is_64) {
#ifdef _M_IX86
                vtbl_pDispatchA = (void*)*(DWORD*)((DWORD)((pfnClient)fnClientA)->element[_DispatchClientMessage_idx].pFunc + 2);
                vtbl_pDispatchW = (void*)*(DWORD*)((DWORD)((pfnClient)fnClientW)->element[_DispatchClientMessage_idx].pFunc + 2);
#else
                vtbl_pDispatchA = (void*)(*(DWORD*)((DWORD64)((pfnClient)fnClientA)->element[_DispatchClientMessage_idx].pFunc + 2) +
                    (DWORD64)((pfnClient)fnClientA)->element[_DispatchClientMessage_idx].pFunc + 6);
                vtbl_pDispatchW = (void*)(*(DWORD*)((DWORD64)((pfnClient)fnClientA)->element[_DispatchClientMessage_idx].pFunc + 2) +
                    (DWORD64)((pfnClient)fnClientA)->element[_DispatchClientMessage_idx].pFunc + 6);
#endif
            }
            else {
                vtbl_pDispatchA = (void*)*(DWORD*)((DWORD)((pfnClient32)fnClientA)->element[_DispatchClientMessage_idx].pFunc + 2);
                vtbl_pDispatchW = (void*)*(DWORD*)((DWORD)((pfnClient32)fnClientW)->element[_DispatchClientMessage_idx].pFunc + 2);
            }


            o_DispatchClientMessage_A = (BYTE*)*(DWORD*)vtbl_pDispatchA;
            o_DispatchClientMessage_W = (BYTE*)*(DWORD*)vtbl_pDispatchW;
#ifdef ICE9_DEBUG
            printf("vtbl_pDispatchA[%p] vtbl_pDispatchW[%p] \n", vtbl_pDispatchA, vtbl_pDispatchW);
            printf("o_DispatchClientMessage_A[%p] o_DispatchClientMessage_W[%p] \n", o_DispatchClientMessage_A, o_DispatchClientMessage_W);
#endif
            DWORD lastProt_a;
            DWORD lastProt_w;

            VirtualProtect((void*)vtbl_pDispatchA, 0xB8, PAGE_EXECUTE_READWRITE, &lastProt_a);
            VirtualProtect((void*)vtbl_pDispatchW, 0xB8, PAGE_EXECUTE_READWRITE, &lastProt_w);

            if (is_64) {
#ifdef _M_IX86
                *(DWORD*)vtbl_pDispatchA = (DWORD)h_DispatchClientMessage_A_win64;
                *(DWORD*)vtbl_pDispatchW = (DWORD)h_DispatchClientMessage_W_win64;
#else
                *(DWORD64*)vtbl_pDispatchA = (DWORD64)h_DispatchClientMessage_A_win64;
                *(DWORD64*)vtbl_pDispatchW = (DWORD64)h_DispatchClientMessage_W_win64;
#endif
            }
            else {
                *(DWORD*)vtbl_pDispatchA = (DWORD)h_DispatchClientMessage_A_win32;
                *(DWORD*)vtbl_pDispatchW = (DWORD)h_DispatchClientMessage_W_win32;
            }

            VirtualProtect((void*)vtbl_pDispatchA, 0xB8, lastProt_a, &lastProt_a);
            VirtualProtect((void*)vtbl_pDispatchW, 0xB8, lastProt_w, &lastProt_w);
        }
    }
}

void ice9::unset_window_hook_exp() {

    if (vtbl_pDispatchA && vtbl_pDispatchW) {

        DWORD lastProt_a;
        DWORD lastProt_w;

        VirtualProtect((void*)vtbl_pDispatchA, 0xB8, PAGE_EXECUTE_READWRITE, &lastProt_a);
        VirtualProtect((void*)vtbl_pDispatchW, 0xB8, PAGE_EXECUTE_READWRITE, &lastProt_w);

        if (is_64) {
            *(DWORD64*)vtbl_pDispatchA = (DWORD64)o_DispatchClientMessage_A;
            *(DWORD64*)vtbl_pDispatchW = (DWORD64)o_DispatchClientMessage_W;
        }
        else {
            *(DWORD*)vtbl_pDispatchA = (DWORD)o_DispatchClientMessage_A;
            *(DWORD*)vtbl_pDispatchW = (DWORD)o_DispatchClientMessage_W;
        }

        VirtualProtect((void*)vtbl_pDispatchA, 0xB8, lastProt_a, &lastProt_a);
        VirtualProtect((void*)vtbl_pDispatchW, 0xB8, lastProt_w, &lastProt_w);

    }
}


inline bool dispatched_check_msg(DWORD msg) {
    switch (msg) {
        //keyborad
    case WM_KEYDOWN:case WM_KEYUP:
        //mouse
    case WM_RBUTTONDOWN:case WM_LBUTTONDOWN:case WM_LBUTTONDBLCLK:
    case WM_LBUTTONUP:case WM_RBUTTONUP:case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN: case WM_MBUTTONUP: case WM_MBUTTONDBLCLK:
    case WM_MOUSEWHEEL: case WM_MOUSEHWHEEL:{
#ifdef ICE9_DEBUG
        printf("[DispatchClient] Device Emulation [SendMessage]\n");
#endif
        return false;
    }
    default:
        return true;
    }
}



int WINAPI h_DispatchClientMessage_A_win64(HWND* hwnd,
#ifdef _M_IX86
    DWORD aling_32,
#endif	
    DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc) {

    switch (msg) {
        if (!dispatched_check_msg(msg)) {
            ice9().instance().on_event(ice9_message_emulated);
            return 0;
        }
    }

    return  ((_DispatchClientMessagex64)ice9().instance().get_dispatch_client_message_a())(hwnd,
#ifdef _M_IX86
        aling_32,
#endif
        msg, wparam, lparam, proc);
}

int WINAPI h_DispatchClientMessage_W_win64(HWND* hwnd,
#ifdef _M_IX86
    DWORD aling_32,
#endif	
    DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc) {

    if (hwnd) {
        if (!dispatched_check_msg(msg)) {
            ice9().instance().on_event(ice9_message_emulated);
            return 0;
        }
    }

    return ((_DispatchClientMessagex64)ice9().instance().get_dispatch_client_message_w())(hwnd,
#ifdef _M_IX86
        aling_32,
#endif
        msg, wparam, lparam, proc);
}

int WINAPI h_DispatchClientMessage_A_win32(HWND* hwnd, DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc) {

    switch (msg) {
        if (!dispatched_check_msg(msg)) {
            ice9().instance().on_event(ice9_message_emulated);
            return 0;
        }
    }

    return ((_DispatchClientMessagex32)ice9().instance().get_dispatch_client_message_a())(hwnd, msg, wparam, lparam, proc);
}

int WINAPI h_DispatchClientMessage_W_win32(HWND* hwnd, DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc) {

    if (hwnd) {
        if (!dispatched_check_msg(msg)) {
            ice9().instance().on_event(ice9_message_emulated);
            return 0;
        }
    }

    return ((_DispatchClientMessagex32)ice9().instance().get_dispatch_client_message_w())(hwnd, msg, wparam, lparam, proc);
}
```

`ice9/ice9_window_raw_hook.h`:

```h
#pragma once

void ice9::set_raw_window_hook(msg_manager& mgr) {

    if (IsWindowUnicode(mgr.hwnd)) {
        mgr.proc = (WNDPROC)SetWindowLongPtrW(mgr.hwnd, GWLP_WNDPROC, (LONG_PTR)raw_proc_filter);
    }
    else {
        mgr.proc = (WNDPROC)SetWindowLongPtrA(mgr.hwnd, GWLP_WNDPROC, (LONG_PTR)raw_proc_filter);
    }

    if (mgr.proc) {
        RAWINPUTDEVICE rid;
        rid.usUsagePage = 0x01;
        rid.usUsage     = 0x06;
        rid.dwFlags = RIDEV_INPUTSINK;
        rid.hwndTarget = mgr.hwnd;

        if (!RegisterRawInputDevices(&rid, 1, sizeof(RAWINPUTDEVICE))) {
            if (IsWindowUnicode(mgr.hwnd)) {
                SetWindowLongPtrW(mgr.hwnd, GWLP_WNDPROC, (LONG_PTR)mgr.proc);
            }
            else {
                SetWindowLongPtrA(mgr.hwnd, GWLP_WNDPROC, (LONG_PTR)mgr.proc);
            }
        }
    }
}

void ice9::unset_raw_window_hook(msg_manager& mgr) {
    if (IsWindowUnicode(mgr.hwnd)) {
        SetWindowLongPtrW(mgr.hwnd, GWLP_WNDPROC, (LONG_PTR)mgr.proc);
    }
    else {
        SetWindowLongPtrA(mgr.hwnd, GWLP_WNDPROC, (LONG_PTR)mgr.proc);
    }
}



```

`ice9/stdafx.cpp`:

```cpp
#include "stdafx.h"
```

`ice9/stdafx.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN 

#include <stdio.h>
#include <tchar.h>
#include <Windows.h>
#include <winternl.h>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <map>
#include <set>
#include <time.h>
#include <stdio.h>
#include <sstream>
#include <iostream>
#include <iostream>

#include "ice9.h"
```

`readme.md`:

```md
Ice9 anti-cheat

```
--------------------------------------------------------------------------------
Name....: Ice9
Author..: JNA
Date....: 2018
e.mail..: jnastarot@yandex.ru
--------------------------------------------------------------------------------
```

[Ice9 anti-cheat https://www.youtube.com/watch?v=LFD_3pioZdA](https://www.youtube.com/watch?v=LFD_3pioZdA)

```