Project Path: arc_gmh5225_abyss_jqifyw2z

Source Tree:

```txt
arc_gmh5225_abyss_jqifyw2z
├── README.md
├── app
│   ├── build.gradle
│   ├── proguard-rules.pro
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── java
│           │   └── com
│           │       └── iofomo
│           │           └── opensrc
│           │               └── abyss
│           │                   ├── AbyssApplication.java
│           │                   └── MainActivity.java
│           ├── jni
│           │   ├── Android.mk
│           │   ├── Application.mk
│           │   ├── arch.h
│           │   ├── attribute.h
│           │   ├── build.h
│           │   ├── cmn
│           │   │   ├── cmn_back_call_stack.c
│           │   │   ├── cmn_back_call_stack.h
│           │   │   ├── cmn_proc.c
│           │   │   ├── cmn_proc.h
│           │   │   ├── cmn_pthread_cond.c
│           │   │   ├── cmn_pthread_cond.h
│           │   │   ├── cmn_utils.c
│           │   │   ├── cmn_utils.h
│           │   │   ├── cmn_vlarray.c
│           │   │   └── cmn_vlarray.h
│           │   ├── compat.h
│           │   ├── constant.h
│           │   ├── loader
│           │   │   ├── assembly-arm.h
│           │   │   ├── assembly-arm64.h
│           │   │   ├── assembly-x86.h
│           │   │   ├── assembly-x86_64.h
│           │   │   ├── assembly.S
│           │   │   ├── loader.c
│           │   │   └── script.h
│           │   ├── path
│           │   │   ├── binding.c
│           │   │   ├── binding.h
│           │   │   ├── canon.c
│           │   │   ├── canon.h
│           │   │   ├── glue.c
│           │   │   ├── glue.h
│           │   │   ├── path.c
│           │   │   ├── path.h
│           │   │   ├── proc.c
│           │   │   ├── proc.h
│           │   │   ├── temp.c
│           │   │   └── temp.h
│           │   └── test
│           │       └── ptrace
│           │           ├── inject.cpp
│           │           ├── inject.h
│           │           └── ptracedemo.cpp
│           └── res
│               ├── drawable
│               │   ├── ic_launcher_background.xml
│               │   ├── list_item_bg_single_selected.xml
│               │   ├── list_item_bg_single_selector.xml
│               │   └── list_item_bg_single_unselected.xml
│               ├── drawable-v24
│               │   └── ic_launcher_foreground.xml
│               ├── layout
│               │   └── activity_main.xml
│               ├── mipmap-anydpi-v26
│               │   ├── ic_launcher.xml
│               │   └── ic_launcher_round.xml
│               ├── mipmap-hdpi
│               │   ├── ic_launcher.webp
│               │   └── ic_launcher_round.webp
│               ├── mipmap-mdpi
│               │   ├── ic_launcher.webp
│               │   └── ic_launcher_round.webp
│               ├── mipmap-xhdpi
│               │   ├── ic_launcher.webp
│               │   └── ic_launcher_round.webp
│               ├── mipmap-xxhdpi
│               │   ├── ic_launcher.webp
│               │   └── ic_launcher_round.webp
│               ├── mipmap-xxxhdpi
│               │   ├── ic_launcher.webp
│               │   └── ic_launcher_round.webp
│               ├── values
│               │   ├── colors.xml
│               │   ├── strings.xml
│               │   └── styles.xml
│               └── xml
│                   ├── backup_rules.xml
│                   └── data_extraction_rules.xml
├── build.gradle
├── build.sh
├── config.gradle
├── doc
│   └── README.assets
│       └── thanks.png
├── files
│   └── fireyer.keystore
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── library
│   ├── build.gradle
│   ├── proguard-rules.pro
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── java
│           │   └── com
│           │       └── iofomo
│           │           └── opensrc
│           │               └── abyss
│           │                   └── sdk
│           │                       ├── Logger.java
│           │                       ├── Native.java
│           │                       ├── Nativee.java
│           │                       └── component
│           │                           ├── MTSTCProvider.java
│           │                           └── MTSTCService.java
│           └── jni
│               ├── Android.mk
│               ├── Application.mk
│               ├── CMakeLists.txt
│               ├── arch.h
│               ├── attribute.h
│               ├── build.h
│               ├── cmn
│               │   ├── cmn_back_call_stack.c
│               │   ├── cmn_back_call_stack.h
│               │   ├── cmn_proc.c
│               │   ├── cmn_proc.h
│               │   ├── cmn_pthread_cond.c
│               │   ├── cmn_pthread_cond.h
│               │   ├── cmn_utils.c
│               │   ├── cmn_utils.h
│               │   ├── cmn_vlarray.c
│               │   └── cmn_vlarray.h
│               ├── compat.h
│               ├── constant.h
│               ├── execve
│               │   ├── aoxp.c
│               │   ├── aoxp.h
│               │   ├── auxv.c
│               │   ├── auxv.h
│               │   ├── elf.c
│               │   ├── elf.h
│               │   ├── enter.c
│               │   ├── execve.h
│               │   ├── exit.c
│               │   ├── ldso.c
│               │   ├── ldso.h
│               │   ├── shebang.c
│               │   └── shebang.h
│               ├── library.c
│               ├── library.h
│               ├── loader
│               │   ├── assembly-arm.h
│               │   ├── assembly-arm64.h
│               │   ├── assembly-x86.h
│               │   ├── assembly-x86_64.h
│               │   ├── assembly.S
│               │   ├── loader.c
│               │   └── script.h
│               ├── note.c
│               ├── note.h
│               ├── path
│               │   ├── binding.c
│               │   ├── binding.h
│               │   ├── canon.c
│               │   ├── canon.h
│               │   ├── glue.c
│               │   ├── glue.h
│               │   ├── path.c
│               │   ├── path.h
│               │   ├── proc.c
│               │   ├── proc.h
│               │   ├── temp.c
│               │   └── temp.h
│               ├── ptrace
│               │   ├── ptrace.c
│               │   ├── ptrace.h
│               │   ├── user.c
│               │   ├── user.h
│               │   ├── wait.c
│               │   └── wait.h
│               ├── syscall
│               │   ├── chain.c
│               │   ├── chain.h
│               │   ├── enter.c
│               │   ├── exit.c
│               │   ├── heap.c
│               │   ├── heap.h
│               │   ├── rlimit.c
│               │   ├── rlimit.h
│               │   ├── seccomp.c
│               │   ├── seccomp.h
│               │   ├── socket.c
│               │   ├── socket.h
│               │   ├── syscall.c
│               │   ├── syscall.h
│               │   ├── sysnum.c
│               │   ├── sysnum.h
│               │   ├── sysnums-arm.h
│               │   ├── sysnums-arm64.h
│               │   ├── sysnums-i386.h
│               │   ├── sysnums-sh4.h
│               │   ├── sysnums-x32.h
│               │   ├── sysnums-x86_64.h
│               │   └── sysnums.list
│               ├── test
│               │   ├── crashdemo.c
│               │   ├── execvedemo.c
│               │   ├── fopen_demo.c
│               │   ├── main.c
│               │   ├── multithreaddemo.c
│               │   ├── myecho.c
│               │   ├── ptrace
│               │   │   ├── inject.cpp
│               │   │   ├── inject.h
│               │   │   └── ptracedemo.cpp
│               │   ├── ptraceemudemo.c
│               │   ├── test.c
│               │   ├── test2.c
│               │   ├── test3.c
│               │   └── usedemo.c
│               └── tracee
│                   ├── abi.h
│                   ├── event.c
│                   ├── event.h
│                   ├── mem.c
│                   ├── mem.h
│                   ├── reg.c
│                   ├── reg.h
│                   ├── tracee.c
│                   └── tracee.h
└── settings.gradle

```

`README.md`:

```md
# Abyss

## 说明

`Abyss`是`Android`平台下应用级系统调用拦截框架。

详细的文档可参考：

[【Abyss】Android平台应用级系统调用拦截框架](https://www.iofomo.com/blog/opensrcabyss)

## 快速开始

本项目在以下开发环境中编译通过：

-   Android Studio：4.2
-   Gradle：6.9.2
-   CMakeLists：3.6.0
-   NDK：21.4.7075529

```shell
$ ./gradlew build
```

## 感谢小伙伴们

![](doc/README.assets/thanks.png)

## 许可协议

本项目基于`MIT`许可协议，详情查看 [许可协议](doc/LICENSE) 文档。

>   本项目和所有的工具都是MIT许可证下的开源工具，这意味着你可以完全访问源代码，并可以根据自己的需求进行修改。

## 参考

[https://github.com/proot-me/proot](https://github.com/proot-me/proot)

[https://github.com/termux/proot](https://github.com/termux/proot)

```

`app/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    buildToolsVersion "30.0.3"
    compileSdkVersion 30

    defaultConfig {
        applicationId 'com.iofomo.opensrc.abyss'
        minSdkVersion 29
        targetSdkVersion 30
        versionCode 1
        versionName "1.0"

        ndk {
            abiFilters 'armeabi-v7a', 'arm64-v8a'
        }
    }

    signingConfigs {
        debug {
            storeFile file('../files/fireyer.keystore')
            storePassword 'e99c85dc41111f82f7c3290fc87c42bd'
            keyAlias 'ifmafireyer'
            keyPassword 'e99c85dc41111f82f7c3290fc87c42bd'
        }
        release {
            storeFile file('../files/fireyer.keystore')
            storePassword 'e99c85dc41111f82f7c3290fc87c42bd'
            keyAlias 'ifmafireyer'
            keyPassword 'e99c85dc41111f82f7c3290fc87c42bd'
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
        debug {
            jniDebuggable true
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

//    buildFeatures {
//        viewBinding true
//    }
}

dependencies {
    api project(path: ':library')
}
```

`app/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
```

`app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="com.iofomo.opensrc.abyss"
    >

    <application
        android:allowBackup="true"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppBaseTheme"
        android:name=".AbyssApplication"
        tools:targetApi="31">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

        </activity>
    </application>

</manifest>
```

`app/src/main/java/com/iofomo/opensrc/abyss/AbyssApplication.java`:

```java
package com.iofomo.opensrc.abyss;

import android.app.ActivityManager;
import android.app.Application;
import android.content.Context;

import com.iofomo.opensrc.abyss.sdk.Logger;
import com.iofomo.opensrc.abyss.sdk.Nativee;

import java.util.List;

public class AbyssApplication extends Application {

    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        Logger.setDefTag("INTERCEPT");
        Logger.e("build Type:" + BuildConfig.BUILD_TYPE);

        /**
         * ------------------ 拦截集成逻辑 START----
         */
        initSvcSdk();
        /**
         * ------------------ 拦截集成逻辑 END----
         */
    }

    public void initSvcSdk() {
        if (isTraceeProcess()) {
            int ret = Nativee.attachMe(this);
            Logger.d("attachMe ret:" + ret);
            if (ret != 0) {
                Logger.e("attach error");
                return;
            }
            Nativee.tracee_init();
            test();
        } else {
            Logger.d("not tracee process,ignore");
        }
    }

    private void test() {
//        String content = FileIOUtils.readFile2String(new File("/proc/self/status"));
//        Logger.d("status:"+content);
    }

    /**
     *  是否是tracee进程(被ptrace控制的进程)
     */
    boolean isTraceeProcess() {
        //demo中,非MyContentProvider所在的:process进程
       String name = getCurrentProcessName();
       Logger.d("cur process:"+name);
       if (name == null || !name.endsWith(":MTSTCProc")) {
           return true;
       }
       return false;
    }

    String getCurrentProcessName() {
        ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
        List<ActivityManager.RunningAppProcessInfo> runningProcesses = am.getRunningAppProcesses();
        for (ActivityManager.RunningAppProcessInfo info : runningProcesses) {
            if (info.pid == android.os.Process.myPid()) {
                String processName = info.processName;
                return processName;
            }
        }
        return "unknown";
    }
}

```

`app/src/main/java/com/iofomo/opensrc/abyss/MainActivity.java`:

```java
package com.iofomo.opensrc.abyss;

import android.app.Activity;
import android.os.Bundle;

public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

}
```

`app/src/main/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := loader

LOCAL_C_INCLUDES :=  $(LOCAL_PATH)/.
LOCAL_SRC_FILES := loader/loader.c
LOCAL_CFLAGS :=  -fPIC -ffreestanding -mregparm=3
ifeq ($(TARGET_ARCH_ABI), armeabi-v7a)
    LOCAL_LDFLAGS := -static -nostdlib -Wl,-Ttext=0x10000000,-z,noexecstack
else ifeq ($(TARGET_ARCH_ABI), arm64-v8a)
    LOCAL_LDFLAGS := -static -nostdlib -Wl,-Ttext=0x2000000000,-z,noexecstack
else
endif
include $(BUILD_EXECUTABLE)
```

`app/src/main/jni/Application.mk`:

```mk
APP_ABI := arm64-v8a armeabi-v7a
APP_PLATFORM := android-14

```

`app/src/main/jni/arch.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef ARCH_H
#define ARCH_H

#ifndef NO_LIBC_HEADER
#include <sys/ptrace.h>    /* linux.git:c0a3a20b  */
#include <linux/audit.h>   /* AUDIT_ARCH_*,  */
#endif

typedef unsigned long word_t;
typedef unsigned char byte_t;

#define SYSCALL_AVOIDER ((word_t) -1)
#define SYSTRAP_NUM SYSARG_NUM
#define STACK_ALIGNMENT 16

#define OFFSETOF_STATX_UID 20
#define OFFSETOF_STATX_GID 24

#if !defined(ARCH_X86_64) && !defined(ARCH_ARM_EABI) && !defined(ARCH_X86) && !defined(ARCH_SH4)
#    if defined(__x86_64__)
#        define ARCH_X86_64 1
#    elif defined(__ARM_EABI__)
#        define ARCH_ARM_EABI 1
#    elif defined(__aarch64__)
#        define ARCH_ARM64 1
#    elif defined(__arm__)
#        error "Only EABI is currently supported for ARM"
#    elif defined(__i386__)
#        define ARCH_X86 1
#    elif defined(__SH4__)
#        define ARCH_SH4 1
#    else
#        error "Unsupported architecture"
#    endif
#endif

/* Architecture specific definitions. */
#if defined(ARCH_X86_64)

    #define SYSNUMS_HEADER1 "syscall/sysnums-x86_64.h"
    #define SYSNUMS_HEADER2 "syscall/sysnums-i386.h"
    #define SYSNUMS_HEADER3 "syscall/sysnums-x32.h"

    #define SYSNUMS_ABI1 sysnums_x86_64
    #define SYSNUMS_ABI2 sysnums_i386
    #define SYSNUMS_ABI3 sysnums_x32

    #undef  SYSTRAP_NUM
    #define SYSTRAP_NUM SYSARG_RESULT
    #define SYSTRAP_SIZE 2

    #define SECCOMP_ARCHS {									\
		{ .value = AUDIT_ARCH_X86_64, .nb_abis = 2, .abis = { ABI_DEFAULT, ABI_3 } },	\
		{ .value = AUDIT_ARCH_I386,   .nb_abis = 1, .abis = { ABI_2 } }, 		\
	}

    #define HOST_ELF_MACHINE {62, 3, 6, 0}
    #define RED_ZONE_SIZE 128
    #define OFFSETOF_STAT_UID_32 24
    #define OFFSETOF_STAT_GID_32 28

    #define LOADER_ADDRESS 0x600000000000
    #define HAS_LOADER_32BIT true

    #define EXEC_PIC_ADDRESS   0x500000000000
    #define INTERP_PIC_ADDRESS 0x6f0000000000
    #define EXEC_PIC_ADDRESS_32   0x0f000000
    #define INTERP_PIC_ADDRESS_32 0xaf000000

#elif defined(ARCH_ARM_EABI)

#define SYSNUMS_HEADER1 "syscall/sysnums-arm.h"
    #define SYSNUMS_ABI1    sysnums_arm

    #define SYSTRAP_SIZE 4

    #define SECCOMP_ARCHS { { .value = AUDIT_ARCH_ARM, .nb_abis = 1, .abis = { ABI_DEFAULT } } }

    #define user_regs_struct user_regs
    #define HOST_ELF_MACHINE {40, 0};
    #define RED_ZONE_SIZE 0
    #define OFFSETOF_STAT_UID_32 0
    #define OFFSETOF_STAT_GID_32 0
    #define EM_ARM 40

    #define LOADER_ADDRESS 0x10000000

    #define EXEC_PIC_ADDRESS   0x0f000000
    #define INTERP_PIC_ADDRESS 0x1f000000

#elif defined(ARCH_ARM64)

    #define SYSNUMS_HEADER1 "syscall/sysnums-arm64.h"
    #define SYSNUMS_HEADER2 "syscall/sysnums-arm.h"

    #define SYSNUMS_ABI1    sysnums_arm64
    #define SYSNUMS_ABI2 sysnums_arm

    #define SYSTRAP_SIZE 4

    #ifndef AUDIT_ARCH_AARCH64
        #define AUDIT_ARCH_AARCH64 (EM_AARCH64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
    #endif

    #define SECCOMP_ARCHS { \
        { .value = AUDIT_ARCH_AARCH64, .nb_abis = 1, .abis = { ABI_DEFAULT } }, \
        { .value = AUDIT_ARCH_ARM, .nb_abis = 1, .abis = { ABI_2 } }                    \
    }

    #define HOST_ELF_MACHINE {183, 0};
    #define RED_ZONE_SIZE 0
    #define OFFSETOF_STAT_UID_32 24
    #define OFFSETOF_STAT_GID_32 28

    #define LOADER_ADDRESS     0x2000000000
    #define EXEC_PIC_ADDRESS   0x3000000000
    #define INTERP_PIC_ADDRESS 0x3f00000000
    #define HAS_POKEDATA_WORKAROUND true

#elif defined(ARCH_X86)

#define SYSNUMS_HEADER1 "syscall/sysnums-i386.h"
    #define SYSNUMS_ABI1    sysnums_i386

    #undef  SYSTRAP_NUM
    #define SYSTRAP_NUM SYSARG_RESULT
    #define SYSTRAP_SIZE 2

    #define SECCOMP_ARCHS { { .value = AUDIT_ARCH_I386, .nb_abis = 1, .abis = { ABI_DEFAULT } } }

    #define HOST_ELF_MACHINE {3, 6, 0};
    #define RED_ZONE_SIZE 0
    #define OFFSETOF_STAT_UID_32 0
    #define OFFSETOF_STAT_GID_32 0

    #define LOADER_ADDRESS 0xa0000000
    #define LOADER_ARCH_CFLAGS -mregparm=3

    #define EXEC_PIC_ADDRESS   0x0f000000
    #define INTERP_PIC_ADDRESS 0xaf000000

#elif defined(ARCH_SH4)

#define SYSNUMS_HEADER1 "syscall/sysnums-sh4.h"
    #define SYSNUMS_ABI1    sysnums_sh4

    #define SYSTRAP_SIZE 2

    #define SECCOMP_ARCHS { }

    #define user_regs_struct pt_regs
    #define HOST_ELF_MACHINE {42, 0};
    #define RED_ZONE_SIZE 0
    #define OFFSETOF_STAT_UID_32 0
    #define OFFSETOF_STAT_GID_32 0
    #define NO_MISALIGNED_ACCESS 1

#else

#error "Unsupported architecture"

#endif

#endif /* ARCH_H */

```

`app/src/main/jni/attribute.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef ATTRIBUTE_H
#define ATTRIBUTE_H

#define UNUSED __attribute__((unused))
#define FORMAT(a, b, c) __attribute__ ((format (a, b, c)))
#define DONT_INSTRUMENT __attribute__((no_instrument_function))
#define PACKED __attribute__((packed))
#define WEAK   __attribute__((weak))

#endif /* ATTRIBUTE_H */

```

`app/src/main/jni/build.h`:

```h
/* This file is auto-generated, edit at your own risk.  */
#ifndef BUILD_H
#define BUILD_H
#undef VERSION
#define VERSION "v5.4.0-5f780cba"
//新的linux api,__ANDROID_API__ >= 23时可以
#define HAVE_PROCESS_VM
#define HAVE_SECCOMP_FILTER

//是否使用模版的loader程序来载入exe
//#define USE_LOADER_EXE

//是否处理系统调用
#define HANDLE_SYSCALL

//仅仅为了方便调试的代码(为了排查问题,可能会拖慢效率)
#define DEBUG_ONLY

//是否启用日志
#define ENABLE_LOG
//使用printf代替android_log_print
//#define LOG_PRINTF

#endif /* BUILD_H */

```

`app/src/main/jni/cmn/cmn_back_call_stack.c`:

```c
//
// Created by mac on 2023/12/15.
//

#include <string.h>
#include <android/log.h>
#include <time.h>
#include <stdio.h>
#include <unistd.h>
#include <malloc.h>
#include <dlfcn.h>
#include "cmn_back_call_stack.h"
#include "constant.h"
#include "mem.h"

#define LOG(...) { __android_log_print(ANDROID_LOG_ERROR,"Native_Stack",__VA_ARGS__);}

typedef struct TraceBuff {
    int depth;
    char* buffer[100];
} TraceBuffInfo;


void print_register_info(const ucontext_t *ucontext) {
#if defined(__aarch64__)
    for (int i = 0; i < 30; ++i) {
        if (i % 4 == 0) {
            LOG("%s", "     ");
        }
        char info[64] = {0};
        sprintf(info, "x%d %016lx ", i, ucontext->uc_mcontext.regs[i]);
        LOG(  "%s", info);
        if ((i + 1) % 4 == 0) {
            LOG( "%s", "\r\n");
        }
    }
    LOG(  "%s", "\r\n");

    char spInfo[64] = {0};
    sprintf(spInfo, "sp %016lx ", ucontext->uc_mcontext.sp);

    char lrInfo[64] = {0};
    sprintf(lrInfo, "lr %016lx ", ucontext->uc_mcontext.regs[30]);

    char pcInfo[64] = {0};
    sprintf(pcInfo, "pc %016lx ", ucontext->uc_mcontext.pc);

    LOG(  "%s%s%s%s\r\n", "     ",spInfo,lrInfo,pcInfo);
#elif defined(__arm__)
    char x0Info[64] = {0};
    sprintf(x0Info, "x0 %08lx ", ucontext->uc_mcontext.arm_r0);
    char x1Info[64] = {0};
    sprintf(x1Info, "x1 %08lx ", ucontext->uc_mcontext.arm_r1);
    char x2Info[64] = {0};
    sprintf(x2Info, "x2 %08lx ", ucontext->uc_mcontext.arm_r2);
    char x3Info[64] = {0};
    sprintf(x3Info, "x3 %08lx ", ucontext->uc_mcontext.arm_r3);
    char x4Info[64] = {0};
    sprintf(x4Info, "x4 %08lx ", ucontext->uc_mcontext.arm_r4);
    char x5Info[64] = {0};
    sprintf(x5Info, "x5 %08lx ", ucontext->uc_mcontext.arm_r5);
    char x6Info[64] = {0};
    sprintf(x6Info, "x6 %08lx ", ucontext->uc_mcontext.arm_r6);
    char x7Info[64] = {0};
    sprintf(x7Info, "x7 %08lx ", ucontext->uc_mcontext.arm_r7);
    char x8Info[64] = {0};
    sprintf(x8Info, "x8 %08lx ", ucontext->uc_mcontext.arm_r8);
    char x9Info[64] = {0};
    sprintf(x9Info, "x9 %08lx ", ucontext->uc_mcontext.arm_r9);
    char x10Info[64] = {0};
    sprintf(x10Info, "x10 %08lx ", ucontext->uc_mcontext.arm_r10);

    char ipInfo[64] = {0};
    sprintf(ipInfo, "ip %08lx ", ucontext->uc_mcontext.arm_ip);
    char spInfo[64] = {0};
    sprintf(spInfo, "sp %08lx ", ucontext->uc_mcontext.arm_sp);
    char lrInfo[64] = {0};
    sprintf(lrInfo, "lr %08lx ", ucontext->uc_mcontext.arm_lr);
    char pcInfo[64] = {0};
    sprintf(pcInfo, "pc %08lx ", ucontext->uc_mcontext.arm_pc);

    LOG("%s%s%s%s%s%s", "     ",x0Info, x1Info, x2Info, x3Info,
                    "\r\n");
            LOG("%s%s%s%s%s%s", "     ", x4Info, x5Info, x6Info, x7Info,
                    "\r\n");
            LOG("%s%s%s%s%s", "     ", x8Info, x9Info, x10Info, "\r\n");
            LOG("%s%s%s%s%s\r\n", "     ", ipInfo, spInfo, lrInfo, pcInfo);
#endif
    return ;
}


_Unwind_Reason_Code my_trace_back_stack(struct _Unwind_Context *context, void *hnd) {
    TraceBuffInfo *traceHandle = (TraceBuffInfo *) hnd;

    _Unwind_Word ip = _Unwind_GetIP(context);
    Dl_info info;
    int res = dladdr((void *) ip, &info);

    if (res == 0) {
        return _URC_END_OF_STACK;
    }

    char *desc = (char *) malloc(1024);
    memset(desc, 0, 1024);
    if (info.dli_fname != NULL) {
        char *symbol = (char *) malloc(256);

        if (info.dli_sname == NULL) {
            strcpy(symbol, "unknown");
        } else {
            sprintf(symbol, "%s+%ld", info.dli_sname,
                    ip - (_Unwind_Word) info.dli_saddr);
        }

#if defined(__arm__)
        sprintf(desc, "     #%02d pc %08lx  %s (%s) \r\n", traceHandle->depth,
                ip - (_Unwind_Word) info.dli_fbase,
                info.dli_fname, symbol);
#elif defined(__aarch64__)
        sprintf(desc, "     #%02d pc %016lx  %s (%s) \r\n", traceHandle->depth,
                ip - (_Unwind_Word) info.dli_fbase,
                info.dli_fname, symbol);
#endif
        free(symbol);
    }

    traceHandle->buffer[traceHandle->depth] = desc;
    ++traceHandle->depth;
    // FIXME: crash if call stack is over 5 on ARM32, unknown reason
#if !defined(__aarch64__) && defined(__arm__)
    if (traceHandle->depth == 5) {
        return _URC_END_OF_STACK;
    }
#endif
    if (traceHandle->depth == 99) {
        return _URC_END_OF_STACK;
    }

    return _URC_NO_REASON;
}

void sig_handler_call_stack(int sig, siginfo_t *info, void *context){
    TraceBuffInfo traceInfo;
    memset(&traceInfo, 0 , sizeof(traceInfo));
    _Unwind_Backtrace(my_trace_back_stack, &traceInfo);


    time_t timep;
    time(&timep);
    char tmp[64];
    char tmp_path[256];
    strftime(tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S%z", localtime(&timep));

    strftime(tmp_path, sizeof(tmp_path), "%Y-%m-%d-%H-%M-%S.txt", localtime(&timep));
//    snprintf(path, sizeof(path), "%s/%s_%s", tombstone_file_path, __PRINTSTR(g_pkg_name), tmp_path);

//    if (elfFile) {
        char processName[256] = {0};
        char cmd[64] = {0};
        sprintf(cmd, "/proc/%d/cmdline", getpid());
        FILE *f = fopen(cmd, "r");
        if (f) {
            size_t size;
            size = fread(processName, sizeof(char), 256, f);
            if (size > 0 && '\n' == processName[size - 1]) {
                processName[size - 1] = '\0';
            }
            fclose(f);
        }

        LOG( "*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\r\n");

        LOG( "Timestamp: %s\r\n", tmp);
        LOG("pid: %d", getpid());
        LOG( ", uid: %d", getuid());
        LOG( ", tid: %d", gettid());
        LOG( ", process: >>> %s <<<\r\n", processName);
        LOG( "signal %d, code %d , fault addr %p\r\n",sig,  info->si_code, info->si_addr);

    print_register_info((const ucontext_t *) context);

        int i = 0;
        while(traceInfo.depth > i){
            LOG("%s", traceInfo.buffer[i]);
            free(traceInfo.buffer[i++]);
        }


        LOG("sig handler print success")
//    }
//    else {
//        __LOGI__("sigHandler_test write fail: %s", strerror(errno))
//    }
//    unregister_sig_handler();
    raise(sig);

    LOG("sig handler end")

}

#if defined(__aarch64__)
void print_remote_call_stack_arm64(const Tracee *tracee){
    struct user_regs_struct regs = tracee->_regs[CURRENT];
    uint64_t* fp = regs.regs[29]; //x29
    LOGD("exception pc:0x%lx,%p,x29:%lx",regs.pc,fp,regs.regs[29])

     while (fp != NULL)
    {
        word_t remote_data =peek_word(tracee,fp + 1);
        //  printf("stack:,fp:%p,lr_addr:%p lr:%lx\n",fp,(fp + 1),*((uint64_t *)(fp + 1)));
        LOGD("bt:0x%lx\n",remote_data);
        fp = peek_word(tracee,fp);
    }
    LOGD("exception print end--------");
}
#endif
```

`app/src/main/jni/cmn/cmn_back_call_stack.h`:

```h
//
// Created by mac on 2023/12/15.
//

#ifndef CMN_BACK_CALL_STACK_H
#define CMN_BACK_CALL_STACK_H
#include <sys/ucontext.h>
#include <unwind.h>
#include <sys/user.h>
#include "tracee/tracee.h"


/**
 * 打印native异常栈
 */
void sig_handler_call_stack(int sig, siginfo_t *info, void *context);

#if defined(__aarch64__)
/**
 *  tracer打印tracee的堆栈
 */
void print_remote_call_stack_arm64(const Tracee *tracee);
#endif

#endif //CMN_BACK_CALL_STACK_H

```

`app/src/main/jni/cmn/cmn_proc.c`:

```c
//
// Created by mac on 2023/12/19.
//

#include <unistd.h>
#include <string.h>
#include "cmn_proc.h"
#include "../constant.h"

void print_maps(char *filter){
    FILE * fp = fopen("/proc/self/maps","r");
    if (!fp){
        LOGE("fp is null")
        return;
    }
    LOGD("start print %d maps,filter:%s",getpid(),filter);
    size_t len = 0;
    ssize_t nread;
    char * line = NULL;

    while ((nread = getline(&line, &len, fp)) != -1) {
//        printf("Retrieved line of length %zu:\n", nread);
        line[nread] = '\0';
        if (filter != NULL && strlen(filter) > 0){
            if (strstr(line,filter) != NULL){
                LOGD("proc_maps:%s",line)
            }
        }else{
            LOGD("proc_maps:%s",line)
        }
    }
    fclose(fp);
    LOGD("end print %d maps",getpid());
}
```

`app/src/main/jni/cmn/cmn_proc.h`:

```h
//
// Created by mac on 2023/12/19.
//

#ifndef  CMN_PROC_H
#define CMN_PROC_H
/**
 * 打印maps
 */
void print_maps(char *filter);
#endif //CMN_PROC_H

```

`app/src/main/jni/cmn/cmn_pthread_cond.c`:

```c
//
// Created by mac on 2023/12/14.
//


#include "cmn_pthread_cond.h"


/**
 * 初始化
 */
void cmn_pt_context_init(struct PCond_Context* ctx){
    pthread_mutex_init(&ctx->mutex, NULL);
    pthread_cond_init(&ctx->cond, NULL);
}

/**
 * 等待事件发生
 */
void cmn_pt_wait(struct  PCond_Context* ctx){
    pthread_mutex_lock(&ctx->mutex);
    pthread_cond_wait(&ctx->cond, &ctx->mutex);
    pthread_mutex_unlock(&ctx->mutex);
}

void cmn_pt_wait2(struct  PCond_Context* ctx,bool (*check)()){
    pthread_mutex_lock(&ctx->mutex);
    if (check()){
        pthread_cond_wait(&ctx->cond, &ctx->mutex);
    }
    pthread_mutex_unlock(&ctx->mutex);
}

/**
 * 通知所有等待线程
 */
int cmn_pt_broadcast(struct PCond_Context* ctx){
    return pthread_cond_broadcast(&ctx->cond);
}

/**
 * 通知第一个等待的线程
 */
int cmn_pt_signal(struct  PCond_Context* ctx){
    return pthread_cond_signal(&ctx->cond);
}

int cmn_pt_signal2(struct  PCond_Context* ctx,bool (*check)()){
    pthread_mutex_lock(&ctx->mutex);
    int ret = 0;
    if (check()){
        ret  =  pthread_cond_signal(&ctx->cond);
    }
    pthread_mutex_unlock(&ctx->mutex);
    return ret;
}


/**
 * 清除资源
 */
int cmn_pt_destroy(struct PCond_Context* ctx){
    return pthread_cond_destroy(&ctx->cond);
}
```

`app/src/main/jni/cmn/cmn_pthread_cond.h`:

```h
//
// Created by mac on 2023/12/14.
//

#ifndef CMN_PTHREAD_COND_H
#define CMN_PTHREAD_COND_H
#include <pthread.h>
#include <stdbool.h>

struct PCond_Context{
    pthread_mutex_t mutex;
    pthread_cond_t cond;
};

/**
 * 初始化
 */
void cmn_pt_context_init(struct PCond_Context* ctx);

/**
 * 等待事件发生
 */
void cmn_pt_wait(struct  PCond_Context* ctx);

void cmn_pt_wait2(struct  PCond_Context* ctx,bool (*check)());

/**
 * 通知所有等待线程
 */
int cmn_pt_broadcast(struct PCond_Context* ctx);

/**
 * 通知第一个等待的线程
 */
int cmn_pt_signal(struct  PCond_Context* ctx);

int cmn_pt_signal2(struct  PCond_Context* ctx,bool (*check)());


 /**
  * 清除资源
  */
 int cmn_pt_destroy(struct PCond_Context* ctx);


#endif //CMN_PTHREAD_COND_H

```

`app/src/main/jni/cmn/cmn_utils.c`:

```c
//
// Created by mac on 2024/1/15.
//

#include "cmn_utils.h"
#include <string.h>
#include <malloc.h>
#include <unistd.h>
#include <fcntl.h> //AT_*

bool cmn_utils_string_starts_With(const char* str,const char* sub_str){
    if (!str) return !sub_str;
    if(!sub_str) return false;
    size_t str_len = strlen(str);
    size_t sub_str_len = strlen(sub_str);
    if (!str_len) return !sub_str_len;
    return strstr(str,sub_str) == str;
}

bool cmn_utils_string_ends_With(const char* str,const char* sub_str){
    if (!str) return !sub_str;
    if(!sub_str) return false;
    size_t str_len = strlen(str);
    size_t sub_str_len = strlen(sub_str);
    if (!str_len) return !sub_str_len;
    if (str_len < sub_str_len) return false;
    return !strncmp(&str[str_len - sub_str_len],sub_str,str_len - sub_str_len);
}


char* cmn_utils_string_replace_With(const char* str,const char* sub_str,const char* rep_str){
    //不支持NULL的替换
    if (!sub_str || !rep_str) return NULL;
    size_t sub_str_len = strlen(sub_str);
    size_t rep_str_len = strlen(rep_str);
    size_t str_len = strlen(str);

    const char* find = strstr(str,sub_str);
    char *ret = NULL;
    if (!find){
        ret = malloc(sizeof(char)*sizeof(str_len + 1));
        strcpy(ret,str);
        return ret;
    }
    ret = malloc(sizeof(char)*sizeof(str_len + rep_str_len - sub_str_len));
    strncpy(ret,str,find - str);
    strncpy(&ret[find - str],rep_str,rep_str_len);
    strcpy(&ret[find - str + rep_str_len],&find[sub_str_len]);
    return ret;
}




ssize_t cmn_utils_readlink(pid_t pid,int fd, char* buf,size_t max_size) {
    int ret = 0;
    sprintf(buf, "/proc/%d/fd/%d",pid,fd);
    ret = readlinkat(AT_FDCWD, buf, buf, max_size);
    if (0 <= ret) {
        buf[ret] = '\0';
    }
    return ret;
}

int cmn_utils_string_split(char* src, char ch, char* items[], int items_len) {
    if (!src || !items) return 0;

    int i = 0, cnt = 0;
    memset(items, 0, items_len*sizeof(char*));
    while (i < items_len && *src) {
        if (!items[i]) {
            ++ cnt;
            items[i] = src;
        }
        if (*src == ch) {
            ++ i;
            *src = '\0';
        }
        ++ src;
    }
    return cnt;
}
//字符串hash函数
uint32_t cmn_utils_str_hash(const char* str){
    uint32_t h = 0, g;
    const char* ptr = str;
    while (*ptr) {
    h = (h << 4) + *ptr++;
    g = h & 0xf0000000;
    h ^= g;
    h ^= g >> 24;
    }
    return h;
}
```

`app/src/main/jni/cmn/cmn_utils.h`:

```h
//
// Created by mac on 2024/1/15.
//

#ifndef  CMN_UTILS_H
#define CMN_UTILS_H
#include <stdbool.h>
#include <stddef.h>
#include <sys/types.h>

bool cmn_utils_string_starts_With(const char* str,const char* sub_str);
bool cmn_utils_string_ends_With(const char* str,const char* sub_str);
char* cmn_utils_string_replace_With(const char* str,const char* sub_str,const char* rep_str);
ssize_t cmn_utils_readlink(pid_t pid,int fd, char* buf,size_t max_size);
int cmn_utils_string_split(char* src, char ch, char* items[], int items_len);
uint32_t cmn_utils_str_hash(const char* str);

#endif //CMN_UTILS_H

```

`app/src/main/jni/cmn/cmn_vlarray.c`:

```c
//
// Created by mac on 2023/12/13.
//

#include "cmn_vlarray.h"
#include <stdlib.h>

static int head_size(){
    return sizeof(int);
}

static void* org_ptr(void * ctx){
    return ctx - head_size();
}

static void* arr_ptr(void* org_ptr){
    return org_ptr + head_size();
}
static void set_arr_length(void* org_ptr,int size){
    int* size_ptr = org_ptr;
    *size_ptr = size;
}

void * vl_new_array(int ele_size,int count){
    int cap = ele_size * count + head_size();
    void * ptr = malloc(cap);
    if (!ptr) return NULL;
    set_arr_length(ptr,count);
    return arr_ptr(ptr);
}

//获取数组长度
int vl_array_length(void * ctx){
    int * ptr = org_ptr(ctx);
    return *ptr;
}

//改变数组长度
void * vl_array_realloc(void * ctx,int ele_size,int count){
    int except = ele_size * count + head_size();
    void *  ptr = realloc(org_ptr(ctx),except);
    if (!ptr) return NULL;
    set_arr_length(ptr,count);
    return arr_ptr(ptr);
}

void vl_array_free(void * ctx){
    free(org_ptr(ctx));
}

```

`app/src/main/jni/cmn/cmn_vlarray.h`:

```h
//
// Created by mac on 2023/12/13.
//

#ifndef CMN_VLARRAY_H
#define CMN_VLARRAY_H
/**
 * 内存结构"size(int) + [e1,e2...en]"
 eg.
     struct AAA{
        int a;
        int b;
    };
     void * ctx = vl_new_array(sizeof(struct AAA),0);
    printf("数组长度:%d\n", vl_array_length(ctx));
    ctx = vl_array_realloc(ctx, sizeof(struct AAA),5);
    printf("数组长度:%d\n", vl_array_length(ctx));
    struct AAA * arr = ctx;
    printf("数组3,a=%d,b=%d\n",arr[3].a,arr[3].b);
    for (int i = 0; i < vl_array_length(ctx); ++i) {
        arr[i].a = arr[i].b = i;
    }
    printf("数组3,a=%d,b=%d\n",arr[3].a,arr[3].b);
    vl_array_free(ctx);
 */

void * vl_new_array(int ele_size,int count);

int vl_array_length(void * ctx);


void * vl_array_realloc(void * ctx,int ele_size,int count);

void vl_array_free(void * ctx);

#endif //CMN_VLARRAY_H

```

`app/src/main/jni/compat.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef COMPAT_H
#define COMPAT_H

/* Local definitions for compatibility with old and/or broken distros... */
#    ifndef AT_NULL
#        define AT_NULL			0
#    endif
#    ifndef AT_PHDR
#        define AT_PHDR			3
#    endif
#    ifndef AT_PHENT
#        define AT_PHENT		4
#    endif
#    ifndef AT_PHNUM
#        define AT_PHNUM		5
#    endif
#    ifndef AT_BASE
#        define AT_BASE			7
#    endif
#    ifndef AT_ENTRY
#        define AT_ENTRY		9
#    endif
#    ifndef AT_RANDOM
#        define AT_RANDOM		25
#    endif
#    ifndef AT_EXECFN
#        define AT_EXECFN		31
#    endif
#    ifndef AT_SYSINFO
#        define AT_SYSINFO		32
#    endif
#    ifndef AT_SYSINFO_EHDR
#        define AT_SYSINFO_EHDR		33
#    endif
#    ifndef AT_FDCWD
#        define AT_FDCWD		-100
#    endif
#    ifndef AT_SYMLINK_FOLLOW
#        define AT_SYMLINK_FOLLOW	0x400
#    endif
#    ifndef AT_REMOVEDIR
#        define AT_REMOVEDIR		0x200
#    endif
#    ifndef AT_SYMLINK_NOFOLLOW
#        define AT_SYMLINK_NOFOLLOW	0x100
#    endif
#    ifndef IN_DONT_FOLLOW
#        define IN_DONT_FOLLOW		0x02000000
#    endif
#    ifndef WIFCONTINUED
#        define WIFCONTINUED(status)	((status) == 0xffff)
#    endif
#    ifndef PTRACE_GETREGS
#        define PTRACE_GETREGS		12
#    endif
#    ifndef PTRACE_SETREGS
#        define PTRACE_SETREGS		13
#    endif
#    ifndef PTRACE_GETFPREGS
#        define PTRACE_GETFPREGS	14
#    endif
#    ifndef PTRACE_SETFPREGS
#        define PTRACE_SETFPREGS	15
#    endif
#    ifndef PTRACE_GETFPXREGS
#        define PTRACE_GETFPXREGS	18
#    endif
#    ifndef PTRACE_SETFPXREGS
#        define PTRACE_SETFPXREGS	19
#    endif
#    ifndef PTRACE_SETOPTIONS
#        define PTRACE_SETOPTIONS	0x4200
#    endif
#    ifndef PTRACE_GETEVENTMSG
#        define PTRACE_GETEVENTMSG	0x4201
#    endif
#    ifndef PTRACE_GETREGSET
#        define PTRACE_GETREGSET	0x4204
#    endif
#    ifndef PTRACE_SETREGSET
#        define PTRACE_SETREGSET	0x4205
#    endif
#    ifndef PTRACE_SEIZE
#        define PTRACE_SEIZE		0x4206
#    endif
#    ifndef PTRACE_INTERRUPT
#        define PTRACE_INTERRUPT	0x4207
#    endif
#    ifndef PTRACE_LISTEN
#        define PTRACE_LISTEN		0x4208
#    endif
#    ifndef PTRACE_O_TRACESYSGOOD
#        define PTRACE_O_TRACESYSGOOD	0x00000001
#    endif
#    ifndef PTRACE_O_TRACEFORK
#        define PTRACE_O_TRACEFORK	0x00000002
#    endif
#    ifndef PTRACE_O_TRACEVFORK
#        define PTRACE_O_TRACEVFORK	0x00000004
#    endif
#    ifndef PTRACE_O_TRACECLONE
#        define PTRACE_O_TRACECLONE	0x00000008
#    endif
#    ifndef PTRACE_O_TRACEEXEC
#        define PTRACE_O_TRACEEXEC	0x00000010
#    endif
#    ifndef PTRACE_O_TRACEVFORKDONE
#        define PTRACE_O_TRACEVFORKDONE	0x00000020
#    endif
#    ifndef PTRACE_O_TRACEEXIT
#        define PTRACE_O_TRACEEXIT	0x00000040
#    endif
#    ifndef PTRACE_O_TRACESECCOMP
#        define PTRACE_O_TRACESECCOMP	0x00000080
#    endif
#    ifndef PTRACE_EVENT_FORK
#        define PTRACE_EVENT_FORK	1
#    endif
#    ifndef PTRACE_EVENT_VFORK
#        define PTRACE_EVENT_VFORK	2
#    endif
#    ifndef PTRACE_EVENT_CLONE
#        define PTRACE_EVENT_CLONE	3
#    endif
#    ifndef PTRACE_EVENT_EXEC
#        define PTRACE_EVENT_EXEC	4
#    endif
#    ifndef PTRACE_EVENT_VFORK_DONE
#        define PTRACE_EVENT_VFORK_DONE	5
#    endif
#    ifndef PTRACE_EVENT_EXIT
#        define PTRACE_EVENT_EXIT	6
#    endif
#    ifndef PTRACE_EVENT_SECCOMP
#        define PTRACE_EVENT_SECCOMP	7
#    endif
#    ifndef PTRACE_EVENT_SECCOMP2
#        if PTRACE_EVENT_SECCOMP == 7
#            define PTRACE_EVENT_SECCOMP2	8
#        elif PTRACE_EVENT_SECCOMP == 8
#            define PTRACE_EVENT_SECCOMP2	7
#        else
#            error "unknown PTRACE_EVENT_SECCOMP value"
#        endif
#    endif
#    ifndef PTRACE_SET_SYSCALL
#        define PTRACE_SET_SYSCALL	23
#    endif
#    ifndef PTRACE_GET_THREAD_AREA
#        define PTRACE_GET_THREAD_AREA	25
#    endif
#    ifndef PTRACE_SET_THREAD_AREA
#        define PTRACE_SET_THREAD_AREA	26
#    endif
#    ifndef PTRACE_GETVFPREGS
#        define PTRACE_GETVFPREGS	27
#    endif
#    ifndef PTRACE_ARCH_PRCTL
#        define PTRACE_ARCH_PRCTL	30
#    endif
#    ifndef ARCH_SET_GS
#        define ARCH_SET_GS	0x1001
#    endif
#    ifndef ARCH_SET_FS
#        define ARCH_SET_FS	0x1002
#    endif
#    ifndef ARCH_GET_GS
#        define ARCH_GET_FS	0x1003
#    endif
#    ifndef ARCH_GET_FS
#        define ARCH_GET_GS	0x1004
#    endif
#    ifndef PTRACE_SINGLEBLOCK
#        define PTRACE_SINGLEBLOCK	33
#    endif
#    ifndef ADDR_NO_RANDOMIZE
#        define ADDR_NO_RANDOMIZE	0x0040000
#    endif
#    ifndef SYS_ACCEPT4
#        define SYS_ACCEPT4		18
#    endif
#    ifndef TALLOC_FREE
#        define TALLOC_FREE(ctx) do { talloc_free(ctx); ctx = NULL; } while(0)
#    endif
#    ifndef PR_SET_NAME
#        define PR_SET_NAME		15
#    endif
#    ifndef PR_SET_NO_NEW_PRIVS
#        define PR_SET_NO_NEW_PRIVS	38
#    endif
#    ifndef PR_SET_SECCOMP
#        define PR_SET_SECCOMP		22
#    endif
#    ifndef SECCOMP_MODE_FILTER
#        define SECCOMP_MODE_FILTER	2
#    endif
#    ifndef talloc_get_type_abort
#        define talloc_get_type_abort talloc_get_type
#    endif
#    ifndef FUTEX_PRIVATE_FLAG
#        define FUTEX_PRIVATE_FLAG	128
#    endif
#    ifndef EFD_SEMAPHORE
#        define EFD_SEMAPHORE		1
#    endif
#    ifndef F_DUPFD_CLOEXEC
#        define F_DUPFD_CLOEXEC		1030
#    endif
#    ifndef O_RDONLY
#        define O_RDONLY		00000000
#    endif
#    ifndef O_CLOEXEC
#        define O_CLOEXEC		02000000
#    endif
#    ifndef MAP_PRIVATE
#        define MAP_PRIVATE			0x02
#    endif
#    ifndef MAP_FIXED
#        define MAP_FIXED			0x10
#    endif
#    ifndef MAP_ANONYMOUS
#        define MAP_ANONYMOUS			0x20
#    endif
#    ifndef PROT_READ
#        define PROT_READ		0x1
#    endif
#    ifndef PROT_WRITE
#        define PROT_WRITE		0x2
#    endif
#    ifndef PROT_EXEC
#        define PROT_EXEC		0x4
#    endif
#    ifndef PROT_GROWSDOWN
#        define PROT_GROWSDOWN		0x01000000
#    endif
#    ifndef NT_ARM_SYSTEM_CALL
#        define NT_ARM_SYSTEM_CALL		0x404
#    endif

#endif /* COMPAT_H */

```

`app/src/main/jni/constant.h`:

```h
//
// Created by mac on 2023/12/11.
//

#ifndef INTERCEPTSYSCALL_CONSTANT_H
#define INTERCEPTSYSCALL_CONSTANT_H
#include "build.h"
#include "library.h"

#include <android/log.h>
#include <stdio.h>

#define TAG "INTERCEPT"
#define TAG_SYS "INTERCEPT/SYS"
#define TAG_SYSW "INTERCEPT/SYSW"
#define TAG_SYSE "INTERCEPT/SYSE"

#if defined(ENABLE_LOG)

#if defined(LOG_PRINTF)

//set_seccomp_filters信息
#define LOGSECOMP(...) { printf(__VA_ARGS__);printf("\n");}
//#define LOGSECOMP(...) {}

#define LOGD(...) { printf(__VA_ARGS__);printf("\n");}
#define LOGI(...) { printf(__VA_ARGS__);printf("\n");}
#define LOGW(...) { printf(__VA_ARGS__);printf("\n");}
#define LOGE(...) { printf(__VA_ARGS__);printf("\n");}


#define LOGSYS(...) { printf(__VA_ARGS__);printf("\n");}
#define LOGSYSW(...) { printf(__VA_ARGS__);printf("\n");}
#define LOGSYSE(...) { printf(__VA_ARGS__);printf("\n");}
#else

//set_seccomp_filters信息
#define LOGSECOMP(...) { __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__);}
//#define LOGSECOMP(...) {}

#define LOGD(...) { __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__);}
#define LOGI(...) { __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__);}
#define LOGW(...) { __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__);}
#define LOGE(...) { __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__);}


#define LOGSYS(...) { __android_log_print(ANDROID_LOG_ERROR,TAG_SYS,__VA_ARGS__);}
#define LOGSYSW(...) { __android_log_print(ANDROID_LOG_ERROR,TAG_SYSW,__VA_ARGS__);}
#define LOGSYSE(...) { __android_log_print(ANDROID_LOG_ERROR,TAG_SYSE,__VA_ARGS__);}
#endif
#else

//set_seccomp_filters信息
#define LOGSECOMP(...) {}

#define LOGD(...) {}
#define LOGI(...) {}
#define LOGW(...) {}
#define LOGE(...) {}

#define LOGSYS(...) {}
#define LOGSYSW(...) {}
#define LOGSYSE(...) {}

#endif


#define __LIKELY(x)       __builtin_expect(!!(x), true)
#define __UNLIKELY(x)     __builtin_expect(!!(x), false)


typedef enum readlink_type{
    BUSINESS, //业务逻辑数据
    NORMAL, //常规的tracee调用
}readlink_type;

typedef struct readlink_context{
    readlink_type type;
    void* data;
}readlink_context;


typedef void (*on_sys_event_t)(syscall_data* data);

extern on_sys_event_t global_on_sysenter;
extern on_sys_event_t global_on_sysexit;

extern pthread_t work_tid; //工作线程pid
extern pid_t snew_attach_pid;
extern struct PCond_Context spctx;

#endif //INTERCEPTSYSCALL_CONSTANT_H

```

`app/src/main/jni/loader/assembly-arm.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

/* According to the ARM EABI, all registers have undefined values at
 * program startup except:
 *
 * - the instruction pointer (r15)
 * - the stack pointer (r13)
 * - the rtld_fini pointer (r0)
 */
#define BRANCH(stack_pointer, destination) do {			\
	asm volatile (						\
		"// Restore initial stack pointer.	\n\t"	\
		"mov sp, %0				\n\t"	\
		"					\n\t"	\
		"// Clear rtld_fini.			\n\t"	\
		"mov r0, #0				\n\t"	\
		"					\n\t"	\
		"// Start the program.			\n\t"	\
		"mov pc, %1				\n"	\
		: /* no output */				\
		: "r" (stack_pointer), "r" (destination)	\
		: "memory", "sp", "r0", "pc");			\
	__builtin_unreachable();				\
	} while (0)

#define PREPARE_ARGS_1(arg1_)				\
	register word_t arg1 asm("r0") = arg1_;		\

#define PREPARE_ARGS_3(arg1_, arg2_, arg3_)		\
	PREPARE_ARGS_1(arg1_)				\
	register word_t arg2 asm("r1") = arg2_;		\
	register word_t arg3 asm("r2") = arg3_;		\

#define PREPARE_ARGS_6(arg1_, arg2_, arg3_, arg4_, arg5_, arg6_)	\
	PREPARE_ARGS_3(arg1_, arg2_, arg3_)				\
	register word_t arg4 asm("r3") = arg4_;				\
	register word_t arg5 asm("r4") = arg5_;				\
	register word_t arg6 asm("r5") = arg6_;

#define OUTPUT_CONTRAINTS_1			\
	"r" (arg1)

#define OUTPUT_CONTRAINTS_3			\
	OUTPUT_CONTRAINTS_1,			\
	"r" (arg2), "r" (arg3)

#define OUTPUT_CONTRAINTS_6				\
	OUTPUT_CONTRAINTS_3,				\
	"r" (arg4), "r" (arg5), "r" (arg6)

#define SYSCALL(number_, nb_args, args...)			\
	({							\
		register word_t number asm("r7") = number_;	\
		register word_t result asm("r0");		\
		PREPARE_ARGS_##nb_args(args)			\
			asm volatile (				\
				"svc #0x00000000	\n\t"	\
				: "=r" (result)			\
				: "r" (number),			\
				OUTPUT_CONTRAINTS_##nb_args	\
				: "memory");			\
			result;					\
	})

#define OPEN	5
#define CLOSE	6
#define MMAP	192
#define MMAP_OFFSET_SHIFT 12
#define EXECVE	11
#define EXIT	1
#define PRCTL	172
#define MPROTECT 125


```

`app/src/main/jni/loader/assembly-arm64.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

/* According to the ARM64 EABI, all registers have undefined values at
 * program startup except:
 *
 * - the instruction pointer (pc)
 * - the stack pointer (sp)
 * - the rtld_fini pointer (x0)
 */
#define BRANCH(stack_pointer, destination) do {			\
	asm volatile (						\
		"// Restore initial stack pointer.	\n\t"	\
		"mov sp, %0				\n\t"	\
		"					\n\t"	\
		"// Clear rtld_fini.			\n\t"	\
		"mov x0, #0				\n\t"	\
		"					\n\t"	\
		"// Start the program.			\n\t"	\
		"br %1				\n"		\
		: /* no output */				\
		: "r" (stack_pointer), "r" (destination)	\
		: "memory", "sp", "x0");			\
	__builtin_unreachable();				\
	} while (0)

#define PREPARE_ARGS_1(arg1_)				\
	register word_t arg1 asm("x0") = arg1_;		\

#define PREPARE_ARGS_3(arg1_, arg2_, arg3_)		\
	PREPARE_ARGS_1(arg1_)				\
	register word_t arg2 asm("x1") = arg2_;		\
	register word_t arg3 asm("x2") = arg3_;		\

#define PREPARE_ARGS_4(arg1_, arg2_, arg3_, arg4_)	\
	PREPARE_ARGS_3(arg1_, arg2_, arg3_)		\
	register word_t arg4 asm("x3") = arg4_;		\

#define PREPARE_ARGS_6(arg1_, arg2_, arg3_, arg4_, arg5_, arg6_)	\
	PREPARE_ARGS_4(arg1_, arg2_, arg3_, arg4_)			\
	register word_t arg5 asm("x4") = arg5_;				\
	register word_t arg6 asm("x5") = arg6_;

#define OUTPUT_CONTRAINTS_1			\
	"r" (arg1)

#define OUTPUT_CONTRAINTS_3			\
	OUTPUT_CONTRAINTS_1,			\
	"r" (arg2), "r" (arg3)

#define OUTPUT_CONTRAINTS_4			\
	OUTPUT_CONTRAINTS_3,			\
	"r" (arg4)

#define OUTPUT_CONTRAINTS_6				\
	OUTPUT_CONTRAINTS_4,				\
	"r" (arg5), "r" (arg6)

#define SYSCALL(number_, nb_args, args...)				\
	({								\
		register word_t number asm("x8") = number_;		\
		register word_t result asm("x0");			\
		PREPARE_ARGS_##nb_args(args)				\
			asm volatile (					\
				"svc #0x00000000		\n\t"	\
				: "=r" (result)				\
				: "r" (number),				\
				OUTPUT_CONTRAINTS_##nb_args		\
				: "memory");				\
			result;						\
	})

#define OPENAT	56
#define CLOSE	57
#define MMAP	222
#define EXECVE	221
#define EXIT	93
#define PRCTL   167
#define MPROTECT 226

```

`app/src/main/jni/loader/assembly-x86.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

/* According to the x86 ABI, all registers have undefined values at
 * program startup except:
 *
 * - the instruction pointer (rip)
 * - the stack pointer (rsp)
 * - the rtld_fini pointer (rdx)
 * - the system flags (eflags)
 */
#define BRANCH(stack_pointer, destination) do {			\
	asm volatile (						\
		"// Restore initial stack pointer.	\n\t"	\
		"movl %0, %%esp				\n\t"	\
		"                      			\n\t"	\
		"// Clear state flags.			\n\t"	\
		"pushl $0				\n\t"	\
		"popfl					\n\t"	\
		"                      			\n\t"	\
		"// Clear rtld_fini.			\n\t"	\
		"movl $0, %%edx				\n\t"	\
		"                      			\n\t"	\
		"// Start the program.			\n\t"	\
		"jmpl *%%eax				\n"	\
		: /* no output */				\
		: "irm" (stack_pointer), "a" (destination)	\
		: "memory", "cc", "esp", "edx");		\
	__builtin_unreachable();				\
	} while (0)

extern word_t syscall_6(word_t number,
			word_t arg1, word_t arg2, word_t arg3,
			word_t arg4, word_t arg5, word_t arg6);

extern word_t syscall_3(word_t number, word_t arg1, word_t arg2, word_t arg3);

extern word_t syscall_1(word_t number, word_t arg1);

#define SYSCALL(number, nb_args, args...) syscall_##nb_args(number, args)

#define OPEN	5
#define CLOSE	6
#define MMAP	192
#define MMAP_OFFSET_SHIFT 12
#define EXECVE	11
#define EXIT	1
#define PRCTL	172
#define MPROTECT 125

```

`app/src/main/jni/loader/assembly-x86_64.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

/* According to the x86_64 ABI, all registers have undefined values at
 * program startup except:
 *
 * - the instruction pointer (rip)
 * - the stack pointer (rsp)
 * - the rtld_fini pointer (rdx)
 * - the system flags (rflags)
 */
#define BRANCH(stack_pointer, destination) do {			\
	asm volatile (						\
		"// Restore initial stack pointer.	\n\t"	\
		"movq %0, %%rsp				\n\t"	\
		"					\n\t"	\
		"// Clear state flags.			\n\t"	\
		"pushq $0				\n\t"	\
		"popfq					\n\t"	\
		"					\n\t"	\
		"// Clear rtld_fini.			\n\t"	\
		"movq $0, %%rdx				\n\t"	\
		"					\n\t"	\
		"// Start the program.			\n\t"	\
		"jmpq *%%rax				\n"	\
		: /* no output */				\
		: "irm" (stack_pointer), "a" (destination)	\
		: "memory", "cc", "rsp", "rdx");		\
	__builtin_unreachable();				\
	} while (0)

#define PREPARE_ARGS_1(arg1_)				\
	register word_t arg1 asm("rdi") = arg1_;	\

#define PREPARE_ARGS_3(arg1_, arg2_, arg3_)		\
	PREPARE_ARGS_1(arg1_)				\
	register word_t arg2 asm("rsi") = arg2_;	\
	register word_t arg3 asm("rdx") = arg3_;	\

#define PREPARE_ARGS_6(arg1_, arg2_, arg3_, arg4_, arg5_, arg6_)	\
	PREPARE_ARGS_3(arg1_, arg2_, arg3_)				\
	register word_t arg4 asm("r10") = arg4_;			\
	register word_t arg5 asm("r8")  = arg5_;			\
	register word_t arg6 asm("r9")  = arg6_;

#define OUTPUT_CONTRAINTS_1			\
	"r" (arg1)

#define OUTPUT_CONTRAINTS_3			\
	OUTPUT_CONTRAINTS_1,			\
	"r" (arg2), "r" (arg3)

#define OUTPUT_CONTRAINTS_6			\
	OUTPUT_CONTRAINTS_3,			\
	"r" (arg4), "r" (arg5), "r" (arg6)

#define SYSCALL(number_, nb_args, args...)				\
	({								\
		register word_t number asm("rax") = number_;		\
		register word_t result asm("rax");			\
		PREPARE_ARGS_##nb_args(args)				\
			asm volatile (					\
				"syscall		\n\t"		\
				: "=r" (result)				\
				: "r" (number),				\
				OUTPUT_CONTRAINTS_##nb_args		\
				: "memory", "cc", "rcx", "r11");	\
			result;						\
	})

#define OPEN	2
#define CLOSE	3
#define MMAP	9
#define EXECVE	59
#define EXIT	60
#define PRCTL	157
#define MPROTECT 10

```

`app/src/main/jni/loader/assembly.S`:

```S
#if defined(__i386__)
	.text

/*
	ABI	user-land  kernel-land
	======  =========  ===========
	number	%eax	   %eax
	arg1	%edx	   %ebx
	arg2	%ecx	   %ecx
	arg3	16(%esp)   %edx
	arg4	12(%esp)   %esi
	arg5	8(%esp)	   %edi
	arg6	4(%esp)    %ebp
	result	N/A	   %eax
*/
.globl	syscall_6
.type	syscall_6, @function
syscall_6:
	/* Callee-saved registers.  */
	pushl	%ebp	// %esp -= 0x04
	pushl	%edi	// %esp -= 0x08
	pushl	%esi	// %esp -= 0x0c
	pushl	%ebx	// %esp -= 0x10

//	mov	%eax, %eax		// number
	mov	%edx, %ebx		// arg1
//	mov	%ecx, %ecx		// arg2
	mov	0x14(%esp), %edx	// arg3
	mov	0x18(%esp), %esi	// arg4
	mov	0x1c(%esp), %edi	// arg5
	mov	0x20(%esp), %ebp	// arg6

	int	$0x80

	popl	%ebx
	popl	%esi
	popl	%edi
	popl	%ebp

//	mov	%eax, %eax		// result
	ret

.globl	syscall_3
.type	syscall_3, @function
syscall_3:
	pushl	%ebx
	mov	%edx, %ebx
	mov	0x8(%esp), %edx
	int	$0x80
	popl	%ebx
	ret

.globl	syscall_1
.type	syscall_1, @function
syscall_1:
	pushl	%ebx
	mov	%edx, %ebx
	int	$0x80
	popl	%ebx
	ret

#endif /* defined(__i386__) */

```

`app/src/main/jni/loader/loader.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <stdbool.h>     /* bool, true, false,  */

#define NO_LIBC_HEADER
#include "loader/script.h"
#include "compat.h"
#include "arch.h"

#define GCC_VERSION (__GNUC__ * 10000			\
			+ __GNUC_MINOR__ * 100		\
			+ __GNUC_PATCHLEVEL__)

#if GCC_VERSION < 40500
#define __builtin_unreachable()
#endif

#if defined(ARCH_X86_64)
#    include "loader/assembly-x86_64.h"
#elif defined(ARCH_ARM_EABI)
#    include "loader/assembly-arm.h"
#elif defined(ARCH_X86)
#    include "loader/assembly-x86.h"
#elif defined(ARCH_ARM64)
#    include "loader/assembly-arm64.h"
#else
#    error "Unsupported architecture"
#endif

#if !defined(MMAP_OFFSET_SHIFT)
#    define MMAP_OFFSET_SHIFT 0
#endif

#define FATAL() do {						\
		SYSCALL(EXIT, 1, 182);				\
		__builtin_unreachable();			\
	} while (0)

#define unlikely(expr) __builtin_expect(!!(expr), 0)

/**
 * Clear the memory from @start (inclusive) to @end (exclusive).
 */
static inline void clear(word_t start, word_t end)
{
	byte_t *start_misaligned;
	byte_t *end_misaligned;

	word_t *start_aligned;
	word_t *end_aligned;

	/* Compute the number of mis-aligned bytes.  */
	word_t start_bytes = start % sizeof(word_t);
	word_t end_bytes   = end % sizeof(word_t);

	/* Compute aligned addresses.  */
	start_aligned = (word_t *) (start_bytes ? start + sizeof(word_t) - start_bytes : start);
	end_aligned   = (word_t *) (end - end_bytes);

	/* Clear leading mis-aligned bytes.  */
	start_misaligned = (byte_t *) start;
	while (start_misaligned < (byte_t *) start_aligned)
		*start_misaligned++ = 0;

	/* Clear aligned bytes.  */
	while (start_aligned < end_aligned)
		*start_aligned++ = 0;

	/* Clear trailing mis-aligned bytes.  */
	end_misaligned = (byte_t *) end_aligned;
	while (end_misaligned < (byte_t *) end)
		*end_misaligned++ = 0;
}

/**
 * Return the address of the last path component of @string_.  Note
 * that @string_ is not modified.
 */
static inline word_t basename(word_t string_)
{
	byte_t *string = (byte_t *) string_;
	byte_t *cursor;

	for (cursor = string; *cursor != 0; cursor++)
		;

	for (; *cursor != (byte_t) '/' && cursor > string; cursor--)
		;

	if (cursor != string)
		cursor++;

	return (word_t) cursor;
}

/**
 * Interpret the load script pointed to by @cursor.
 */
void _start(void *cursor)
{
	bool traced = false;
	bool reset_at_base = true;
	word_t at_base = 0;

	word_t fd = -1;
	word_t status;

	while(1) {
		LoadStatement *stmt = cursor;

		switch (stmt->action) {
		case LOAD_ACTION_OPEN_NEXT:
			status = SYSCALL(CLOSE, 1, fd);
			if (unlikely((int) status < 0))
				FATAL();
			/* Fall through.  */

		case LOAD_ACTION_OPEN:
#if defined(OPEN)
			fd = SYSCALL(OPEN, 3, stmt->open.string_address, O_RDONLY, 0);
#else
			fd = SYSCALL(OPENAT, 4, AT_FDCWD, stmt->open.string_address, O_RDONLY, 0);
#endif
			if (unlikely((int) fd < 0))
				FATAL();

			reset_at_base = true;

			cursor += LOAD_STATEMENT_SIZE(*stmt, open);
			break;

		case LOAD_ACTION_MMAP_FILE:
			status = SYSCALL(MMAP, 6, stmt->mmap.addr, stmt->mmap.length,
					stmt->mmap.prot, MAP_PRIVATE | MAP_FIXED, fd,
					stmt->mmap.offset >> MMAP_OFFSET_SHIFT);
			if (unlikely(status != stmt->mmap.addr))
				FATAL();

			if (stmt->mmap.clear_length != 0)
				clear(stmt->mmap.addr + stmt->mmap.length - stmt->mmap.clear_length,
					stmt->mmap.addr + stmt->mmap.length);

			if (reset_at_base) {
				at_base = stmt->mmap.addr;
				reset_at_base = false;
			}

			cursor += LOAD_STATEMENT_SIZE(*stmt, mmap);
			break;

		case LOAD_ACTION_MMAP_ANON:
			status = SYSCALL(MMAP, 6, stmt->mmap.addr, stmt->mmap.length,
					stmt->mmap.prot, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
			if (unlikely(status != stmt->mmap.addr))
				FATAL();

			cursor += LOAD_STATEMENT_SIZE(*stmt, mmap);
			break;

		case LOAD_ACTION_MAKE_STACK_EXEC:
			SYSCALL(MPROTECT, 3,
				stmt->make_stack_exec.start, 1,
				PROT_READ | PROT_WRITE | PROT_EXEC | PROT_GROWSDOWN);

			cursor += LOAD_STATEMENT_SIZE(*stmt, make_stack_exec);
			break;

		case LOAD_ACTION_START_TRACED:
			traced = true;
			/* Fall through.  */

		case LOAD_ACTION_START: {
			word_t *cursor2 = (word_t *) stmt->start.stack_pointer;
			const word_t argc = cursor2[0];
			const word_t at_execfn = cursor2[1];
			word_t name;

			status = SYSCALL(CLOSE, 1, fd);
			if (unlikely((int) status < 0))
				FATAL();

			/* Right after execve, the stack content is as follow:
			 *
			 *   +------+--------+--------+--------+
			 *   | argc | argv[] | envp[] | auxv[] |
			 *   +------+--------+--------+--------+
			 */

			/* Skip argv[].  */
			cursor2 += argc + 1;

			/* Skip envp[].  */
			do cursor2++; while (cursor2[0] != 0);
			cursor2++;

			/* Adjust auxv[].  */
			do {
				switch (cursor2[0]) {
				case AT_PHDR:
					cursor2[1] = stmt->start.at_phdr;
					break;

				case AT_PHENT:
					cursor2[1] = stmt->start.at_phent;
					break;

				case AT_PHNUM:
					cursor2[1] = stmt->start.at_phnum;
					break;

				case AT_ENTRY:
					cursor2[1] = stmt->start.at_entry;
					break;

				case AT_BASE:
					cursor2[1] = at_base;
					break;

				case AT_EXECFN:
					/* stmt->start.at_execfn can't be used for now since it is
					 * currently stored in a location that will be scratched
					 * by the process (below the final stack pointer).  */
					cursor2[1] = at_execfn;
					break;

				default:
					break;
				}
				cursor2 += 2;
			} while (cursor2[0] != AT_NULL);

			/* Note that only 2 arguments are actually necessary... */
			name = basename(stmt->start.at_execfn);
			SYSCALL(PRCTL, 3, PR_SET_NAME, name, 0);

			if (unlikely(traced))
				SYSCALL(EXECVE, 6, 1,
					stmt->start.stack_pointer,
					stmt->start.entry_point, 2, 3, 4);
			else
				BRANCH(stmt->start.stack_pointer, stmt->start.entry_point);
			FATAL();
		}

		default:
			FATAL();
		}
	}

	FATAL();
}

```

`app/src/main/jni/loader/script.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef SCRIPT
#define SCRIPT

#include "arch.h"
#include "attribute.h"

struct load_statement {
	word_t action;

	union {
		struct {
			word_t string_address;
		} open;

		struct {
			word_t addr;
			word_t length;
			word_t prot;
			word_t offset;
			word_t clear_length;
		} mmap;

		struct {
			word_t start;
		} make_stack_exec;

		struct {
			word_t stack_pointer;
			word_t entry_point;
			word_t at_phdr;
			word_t at_phent;
			word_t at_phnum;
			word_t at_entry;
			word_t at_execfn;
		} start;
	};
} PACKED;

typedef struct load_statement LoadStatement;

#define LOAD_STATEMENT_SIZE(statement, type) \
	(sizeof((statement).action) + sizeof((statement).type))

/* Don't use enum, since sizeof(enum) doesn't have to be equal to
 * sizeof(word_t).  Keep values in the same order as their respective
 * actions appear in loader.c to get a change GCC produces a jump
 * table.  */
#define LOAD_ACTION_OPEN_NEXT		0
#define LOAD_ACTION_OPEN		1
#define LOAD_ACTION_MMAP_FILE		2
#define LOAD_ACTION_MMAP_ANON		3
#define LOAD_ACTION_MAKE_STACK_EXEC	4
#define LOAD_ACTION_START_TRACED	5
#define LOAD_ACTION_START		6

#endif /* SCRIPT */

```

`app/src/main/jni/path/binding.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sys/stat.h> /* lstat(2), */
#include <unistd.h>   /* getcwd(2), lstat(2), */
#include <string.h>   /* string(3),  */
#include <strings.h>  /* bzero(3), */
#include <assert.h>   /* assert(3), */
#include <limits.h>   /* PATH_MAX, */
#include <errno.h>    /* E* */
#include <sys/queue.h> /* CIRCLEQ_*, */
#include <talloc.h>   /* talloc_*, */

#include "path/binding.h"
#include "path/path.h"
#include "path/canon.h"
#include "cli/note.h"

#include "compat.h"

#define HEAD(tracee, side)						\
	(side == GUEST							\
		? (tracee)->fs->bindings.guest				\
		: (side == HOST						\
			? (tracee)->fs->bindings.host			\
			: (tracee)->fs->bindings.pending))

#define NEXT(binding, side)						\
	(side == GUEST							\
		? CIRCLEQ_NEXT(binding, link.guest)			\
		: (side == HOST						\
			? CIRCLEQ_NEXT(binding, link.host)		\
			: CIRCLEQ_NEXT(binding, link.pending)))

#define CIRCLEQ_FOREACH_(tracee, binding, side)				\
	for (binding = CIRCLEQ_FIRST(HEAD(tracee, side));		\
	     binding != (void *) HEAD(tracee, side);			\
	     binding = NEXT(binding, side))

#define CIRCLEQ_INSERT_AFTER_(tracee, previous, binding, side) do {	\
	switch (side) {							\
	case GUEST: CIRCLEQ_INSERT_AFTER(HEAD(tracee, side), previous, binding, link.guest);   break; \
	case HOST:  CIRCLEQ_INSERT_AFTER(HEAD(tracee, side), previous, binding, link.host);    break; \
	default:    CIRCLEQ_INSERT_AFTER(HEAD(tracee, side), previous, binding, link.pending); break; \
	}								\
	(void) talloc_reference(HEAD(tracee, side), binding);		\
} while (0)

#define CIRCLEQ_INSERT_BEFORE_(tracee, next, binding, side) do {	\
	switch (side) {							\
	case GUEST: CIRCLEQ_INSERT_BEFORE(HEAD(tracee, side), next, binding, link.guest);   break; \
	case HOST:  CIRCLEQ_INSERT_BEFORE(HEAD(tracee, side), next, binding, link.host);    break; \
	default:    CIRCLEQ_INSERT_BEFORE(HEAD(tracee, side), next, binding, link.pending); break; \
	}								\
	(void) talloc_reference(HEAD(tracee, side), binding);		\
} while (0)

#define CIRCLEQ_INSERT_HEAD_(tracee, binding, side) do {		\
	switch (side) {							\
	case GUEST: CIRCLEQ_INSERT_HEAD(HEAD(tracee, side), binding, link.guest);   break; \
	case HOST:  CIRCLEQ_INSERT_HEAD(HEAD(tracee, side), binding, link.host);    break; \
	default:    CIRCLEQ_INSERT_HEAD(HEAD(tracee, side), binding, link.pending); break; \
	}								\
	(void) talloc_reference(HEAD(tracee, side), binding);		\
} while (0)

#define IS_LINKED(binding, link)					\
	((binding)->link.cqe_next != NULL && (binding)->link.cqe_prev != NULL)

#define CIRCLEQ_REMOVE_(tracee, binding, name) do {			\
	CIRCLEQ_REMOVE((tracee)->fs->bindings.name, binding, link.name);\
	(binding)->link.name.cqe_next = NULL;				\
	(binding)->link.name.cqe_prev = NULL;				\
	talloc_unlink((tracee)->fs->bindings.name, binding);		\
} while (0)


/**
 * Print all bindings (verbose purpose).
 */
static void print_bindings(const Tracee *tracee)
{
	const Binding *binding;

	if (tracee->fs->bindings.guest == NULL)
		return;

	CIRCLEQ_FOREACH_(tracee, binding, GUEST) {
		if (compare_paths(binding->host.path, binding->guest.path) == PATHS_ARE_EQUAL)
			note(tracee, INFO, USER, "binding = %s", binding->host.path);
		else
			note(tracee, INFO, USER, "binding = %s:%s",
				binding->host.path, binding->guest.path);
	}
}

/**
 * Get the binding for the given @path (relatively to the given
 * binding @side).
 */
Binding *get_binding(const Tracee *tracee, Side side, const char path[PATH_MAX])
{
	Binding *binding;
	size_t path_length = strlen(path);

	/* Sanity checks.  */
	assert(path != NULL && path[0] == '/');

	CIRCLEQ_FOREACH_(tracee, binding, side) {
		Comparison comparison;
		const Path *ref;

		switch (side) {
		case GUEST:
			ref = &binding->guest;
			break;

		case HOST:
			ref = &binding->host;
			break;

		default:
			assert(0);
			return NULL;
		}

		comparison = compare_paths2(ref->path, ref->length, path, path_length);
		if (   comparison != PATHS_ARE_EQUAL
		    && comparison != PATH1_IS_PREFIX)
			continue;

		/* Avoid false positive when a prefix of the rootfs is
		 * used as an asymmetric binding, ex.:
		 *
		 *     proot -m /usr:/location /usr/local/slackware
		 */
		if (   side == HOST
		    && compare_paths(get_root(tracee), "/") != PATHS_ARE_EQUAL
		    && belongs_to_guestfs(tracee, path))
				continue;

		return binding;
	}

	return NULL;
}

/**
 * Get the binding path for the given @path (relatively to the given
 * binding @side).
 */
const char *get_path_binding(const Tracee *tracee, Side side, const char path[PATH_MAX])
{
	const Binding *binding;

	binding = get_binding(tracee, side, path);
	if (!binding)
		return NULL;

	switch (side) {
	case GUEST:
		return binding->guest.path;

	case HOST:
		return binding->host.path;

	default:
		assert(0);
		return NULL;
	}
}

/**
 * Return the path to the guest rootfs for the given @tracee, from the
 * host point-of-view obviously.  Depending on whether
 * initialize_bindings() was called or not, the path is retrieved from
 * the "bindings.guest" list or from the "bindings.pending" list,
 * respectively.
 */
const char *get_root(const Tracee* tracee)
{
	const Binding *binding;

	if (tracee == NULL || tracee->fs == NULL)
		return NULL;

	if (tracee->fs->bindings.guest == NULL) {
		if (tracee->fs->bindings.pending == NULL
		    || CIRCLEQ_EMPTY(tracee->fs->bindings.pending))
			return NULL;

		binding = CIRCLEQ_LAST(tracee->fs->bindings.pending);
		if (compare_paths(binding->guest.path, "/") != PATHS_ARE_EQUAL)
			return NULL;

		return binding->host.path;
	}

	assert(!CIRCLEQ_EMPTY(tracee->fs->bindings.guest));

	binding = CIRCLEQ_LAST(tracee->fs->bindings.guest);

	assert(strcmp(binding->guest.path, "/") == 0);

	return binding->host.path;
}

/**
 * Substitute the guest path (if any) with the host path in @path.
 * This function returns:
 *
 *     * -errno if an error occured
 *
 *     * 0 if it is a binding location but no substitution is needed
 *       ("symetric" binding)
 *
 *     * 1 if it is a binding location and a substitution was performed
 *       ("asymmetric" binding)
 */
int substitute_binding(const Tracee *tracee, Side side, char path[PATH_MAX])
{
	const Path *reverse_ref;
	const Path *ref;
	const Binding *binding;

	binding = get_binding(tracee, side, path);
	if (!binding)
		return -ENOENT;

	/* Is it a "symetric" binding?  */
	if (!binding->need_substitution)
		return 0;

	switch (side) {
	case GUEST:
		ref = &binding->guest;
		reverse_ref = &binding->host;
		break;

	case HOST:
		ref = &binding->host;
		reverse_ref = &binding->guest;
		break;

	default:
		assert(0);
		return -EACCES;
	}

	substitute_path_prefix(path, ref->length, reverse_ref->path, reverse_ref->length);

	return 1;
}

/**
 * Remove @binding from all the @tracee's lists of bindings it belongs to.
 */
void remove_binding_from_all_lists(const Tracee *tracee, Binding *binding)
{
       if (IS_LINKED(binding, link.pending))
	       CIRCLEQ_REMOVE_(tracee, binding, pending);

       if (IS_LINKED(binding, link.guest))
	       CIRCLEQ_REMOVE_(tracee, binding, guest);

       if (IS_LINKED(binding, link.host))
	       CIRCLEQ_REMOVE_(tracee, binding, host);
}

/**
 * Insert @binding into the list of @bindings, in a sorted manner so
 * as to make the substitution of nested bindings determistic, ex.:
 *
 *     -b /bin:/foo/bin -b /usr/bin/more:/foo/bin/more
 *
 * Note: "nested" from the @side point-of-view.
 */
static void insort_binding(const Tracee *tracee, Side side, Binding *binding)
{
	Binding *iterator;
	Binding *previous = NULL;
	Binding *next = CIRCLEQ_FIRST(HEAD(tracee, side));

	/* Find where it should be added in the list.  */
	CIRCLEQ_FOREACH_(tracee, iterator, side) {
		Comparison comparison;
		const Path *binding_path;
		const Path *iterator_path;

		switch (side) {
		case PENDING:
		case GUEST:
			binding_path = &binding->guest;
			iterator_path = &iterator->guest;
			break;

		case HOST:
			binding_path = &binding->host;
			iterator_path = &iterator->host;
			break;

		default:
			assert(0);
			return;
		}

		comparison = compare_paths2(binding_path->path, binding_path->length,
					    iterator_path->path, iterator_path->length);
		switch (comparison) {
		case PATHS_ARE_EQUAL:
			if (side == HOST) {
				previous = iterator;
				break;
			}

			if (tracee->verbose > 0 && getenv("PROOT_IGNORE_MISSING_BINDINGS") == NULL) {
				note(tracee, WARNING, USER,
					"both '%s' and '%s' are bound to '%s', "
					"only the last binding is active.",
					iterator->host.path, binding->host.path,
					binding->guest.path);
			}

			/* Replace this iterator with the new binding.  */
			CIRCLEQ_INSERT_AFTER_(tracee, iterator, binding, side);
			remove_binding_from_all_lists(tracee, iterator);
			return;

		case PATH1_IS_PREFIX:
			/* The new binding contains the iterator.  */
			previous = iterator;
			break;

		case PATH2_IS_PREFIX:
			/* The iterator contains the new binding.
			 * Use the deepest container.  */
			if (next == (void *) HEAD(tracee, side))
				next = iterator;
			break;

		case PATHS_ARE_NOT_COMPARABLE:
			break;

		default:
			assert(0);
			return;
		}
	}

	/* Insert this binding in the list.  */
	if (previous != NULL)
		CIRCLEQ_INSERT_AFTER_(tracee, previous, binding, side);
	else if (next != (void *) HEAD(tracee, side))
		CIRCLEQ_INSERT_BEFORE_(tracee, next, binding, side);
	else
		CIRCLEQ_INSERT_HEAD_(tracee, binding, side);
}

/**
 * c.f. function above.
 */
static void insort_binding2(const Tracee *tracee, Binding *binding)
{
	binding->need_substitution =
		compare_paths(binding->host.path, binding->guest.path) != PATHS_ARE_EQUAL;

	insort_binding(tracee, GUEST, binding);
	insort_binding(tracee, HOST, binding);
}

/**
 * Create and insert a new binding (@host_path:@guest_path) into the
 * list of @tracee's bindings.  The Talloc parent of this new binding
 * is @context.  This function returns NULL if an error occurred,
 * otherwise a pointer to the newly created binding.
 */
Binding *insort_binding3(const Tracee *tracee, const TALLOC_CTX *context,
			const char host_path[PATH_MAX],
			const char guest_path[PATH_MAX])
{
	Binding *binding;

	binding = talloc_zero(context, Binding);
	if (binding == NULL)
		return NULL;

	strcpy(binding->host.path, host_path);
	strcpy(binding->guest.path, guest_path);

	binding->host.length = strlen(binding->host.path);
	binding->guest.length = strlen(binding->guest.path);

	insort_binding2(tracee, binding);

	return binding;
}

/**
 * Free all bindings from @bindings.
 *
 * Note: this is a Talloc destructor.
 */
static int remove_bindings(Bindings *bindings)
{
	Binding *binding;
	Tracee *tracee;

	/* Unlink all bindings from the @link list.  */
#define CIRCLEQ_REMOVE_ALL(name) do {				\
	binding = CIRCLEQ_FIRST(bindings);			\
	while (binding != (void *) bindings) {			\
		Binding *next = CIRCLEQ_NEXT(binding, link.name);\
		CIRCLEQ_REMOVE_(tracee, binding, name);		\
		binding = next;					\
	}							\
} while (0)

	/* Search which link is used by this list.  */
	tracee = TRACEE(bindings);
	if (bindings == tracee->fs->bindings.pending)
		CIRCLEQ_REMOVE_ALL(pending);
	else if (bindings == tracee->fs->bindings.guest)
		CIRCLEQ_REMOVE_ALL(guest);
	else if (bindings == tracee->fs->bindings.host)
		CIRCLEQ_REMOVE_ALL(host);

	bzero(bindings, sizeof(Bindings));

	return 0;
}

/**
 * Allocate a new binding "@host:@guest" and attach it to
 * @tracee->fs->bindings.pending.  This function complains about
 * missing @host path only if @must_exist is true.  This function
 * returns the allocated binding on success, NULL on error.
 */
Binding *new_binding(Tracee *tracee, const char *host, const char *guest, bool must_exist)
{
	Binding *binding;
	char base[PATH_MAX];
	int status;

	/* Lasy allocation of the list of bindings specified by the
	 * user.  This list will be used by initialize_bindings().  */
	if (tracee->fs->bindings.pending == NULL) {
		tracee->fs->bindings.pending = talloc_zero(tracee->fs, Bindings);
		if (tracee->fs->bindings.pending == NULL)
			return NULL;
		CIRCLEQ_INIT(tracee->fs->bindings.pending);
		talloc_set_destructor(tracee->fs->bindings.pending, remove_bindings);
	}

	/* Allocate an empty binding.  */
	binding = talloc_zero(tracee->ctx, Binding);
	if (binding == NULL)
		return NULL;

	/* Canonicalize the host part of the binding, as expected by
	 * get_binding().  */
	status = realpath2(tracee->reconf.tracee, binding->host.path, host, true);
	if (status < 0) {
		if (must_exist && getenv("PROOT_IGNORE_MISSING_BINDINGS") == NULL)
			note(tracee, WARNING, INTERNAL, "can't sanitize binding \"%s\": %s",
				host, strerror(-status));
		goto error;
	}
	binding->host.length = strlen(binding->host.path);

	/* Symetric binding?  */
	guest = guest ?: host;

	/* When not absolute, assume the guest path is relative to the
	 * current working directory, as with ``-b .`` for instance.  */
	if (guest[0] != '/') {
		status = getcwd2(tracee->reconf.tracee, base);
		if (status < 0) {
			note(tracee, WARNING, INTERNAL, "can't sanitize binding \"%s\": %s",
				binding->guest.path, strerror(-status));
			goto error;
		}
	}
	else
		strcpy(base, "/");

	status = join_paths(2, binding->guest.path, base, guest);
	if (status < 0) {
		note(tracee, WARNING, SYSTEM, "can't sanitize binding \"%s\"",
			binding->guest.path);
		goto error;
	}
	binding->guest.length = strlen(binding->guest.path);

	/* Keep the list of bindings specified by the user ordered,
	 * for the sake of consistency.  For instance binding to "/"
	 * has to be the last in the list.  */
	insort_binding(tracee, PENDING, binding);

	return binding;

error:
	TALLOC_FREE(binding);
	return NULL;
}

/**
 * Canonicalize the guest part of the given @binding, insert it into
 * @tracee->fs->bindings.guest and @tracee->fs->bindings.host.  This
 * function returns -1 if an error occured, 0 otherwise.
 */
static void initialize_binding(Tracee *tracee, Binding *binding)
{
	char path[PATH_MAX];
	struct stat statl;
	int status;

	/* All bindings but "/" must be canonicalized.  The exception
	 * for "/" is required to bootstrap the canonicalization.  */
	if (compare_paths(binding->guest.path, "/") != PATHS_ARE_EQUAL) {
		bool dereference;
		size_t length;

		strcpy(path, binding->guest.path);
		length = strlen(path);
		assert(length > 0);

		/* Does the user explicitly tell not to dereference
		 * guest path?  */
		dereference = (path[length - 1] != '!');
		if (!dereference)
			path[length - 1] = '\0';

		/* Initial state before canonicalization.  */
		strcpy(binding->guest.path, "/");

		/* Remember the type of the final component, it will
		 * be used in build_glue() later.  */
		status = lstat(binding->host.path, &statl);
		tracee->glue_type = (status < 0 || S_ISBLK(statl.st_mode) || S_ISCHR(statl.st_mode)
				? S_IFREG : statl.st_mode & S_IFMT);

		/* Sanitize the guest path of the binding within the
		   alternate rootfs since it is assumed by
		   substitute_binding().  */
		status = canonicalize(tracee, path, dereference, binding->guest.path, 0);
		if (status < 0) {
			note(tracee, WARNING, INTERNAL,
				"sanitizing the guest path (binding) \"%s\": %s",
				path, strerror(-status));
			return;
		}

		/* Remove the trailing "/" or "/." as expected by
		 * substitute_binding().  */
		chop_finality(binding->guest.path);

		/* Disable definitively the creation of the glue for
		 * this binding.  */
		tracee->glue_type = 0;
	}

	binding->guest.length = strlen(binding->guest.path);

	insort_binding2(tracee, binding);
}

/**
 * Add bindings induced by @new_binding when @tracee is being sub-reconfigured.
 * For example, if the previous configuration ("-r /rootfs1") contains this
 * binding:
 *
 *      -b /home/ced:/usr/local/ced
 *
 * and if the current configuration ("-r /rootfs2") introduces such a new
 * binding:
 *
 *      -b /usr:/media
 *
 * then the following binding is induced:
 *
 *      -b /home/ced:/media/local/ced
 */
static void add_induced_bindings(Tracee *tracee, const Binding *new_binding)
{
	Binding *old_binding;
	char path[PATH_MAX];
	int status;

	/* Only for reconfiguration.  */
	if (tracee->reconf.tracee == NULL)
		return;

	/* From the example, PRoot has already converted "-b /usr:/media" into
	 * "-b /rootfs1/usr:/media" in order to ensure the host part is really a
	 * host path.  Here, the host part is converted back to "/usr" since the
	 * comparison can't be made on "/rootfs1/usr".
	 */
	strcpy(path, new_binding->host.path);
	status = detranslate_path(tracee->reconf.tracee, path, NULL);
	if (status < 0)
		return;

	CIRCLEQ_FOREACH_(tracee->reconf.tracee, old_binding, GUEST) {
		Binding *induced_binding;
		Comparison comparison;
		char path2[PATH_MAX];
		size_t prefix_length;

		/* Check if there's an induced binding by searching a common
		 * path prefix in between new/old bindings:
		 *
		 *   -b /home/ced:[/usr]/local/ced
		 *   -b [/usr]:/media
		 */
		comparison = compare_paths(path, old_binding->guest.path);
		if (comparison != PATH1_IS_PREFIX)
			continue;

		/* Convert the path of this induced binding to the new
		 * filesystem namespace.  From the example, "/usr/local/ced" is
		 * converted into "/media/local/ced".  Note: substitute_binding
		 * can't be used in this case since it would expect
		 * "/rootfs1/usr/local/ced instead".
		 */
		prefix_length = strlen(path);
		if (prefix_length == 1)
			prefix_length = 0;

		status = join_paths(2, path2, new_binding->guest.path, old_binding->guest.path + prefix_length);
		if (status < 0)
			continue;

		/* Install the induced binding.  From the example:
		 *
		 *     -b /home/ced:/media/local/ced
		 */
		induced_binding = talloc_zero(tracee->ctx, Binding);
		if (induced_binding == NULL)
			continue;

		strcpy(induced_binding->host.path, old_binding->host.path);
		strcpy(induced_binding->guest.path, path2);

		induced_binding->host.length = strlen(induced_binding->host.path);
		induced_binding->guest.length = strlen(induced_binding->guest.path);

		VERBOSE(tracee, 2, "induced binding: %s:%s (old) & %s:%s (new) -> %s:%s (induced)",
			old_binding->host.path, old_binding->guest.path, path, new_binding->guest.path,
			induced_binding->host.path, induced_binding->guest.path);

		insort_binding2(tracee, induced_binding);
	}
}

/**
 * Allocate @tracee->fs->bindings.guest and
 * @tracee->fs->bindings.host, then call initialize_binding() on each
 * binding listed in @tracee->fs->bindings.pending.
 */
int initialize_bindings(Tracee *tracee)
{
	Binding *binding;

	/* Sanity checks.  */
	assert(get_root(tracee) != NULL);
	assert(tracee->fs->bindings.pending != NULL);
	assert(tracee->fs->bindings.guest == NULL);
	assert(tracee->fs->bindings.host == NULL);

	/* Allocate @tracee->fs->bindings.guest and
	 * @tracee->fs->bindings.host.  */
	tracee->fs->bindings.guest = talloc_zero(tracee->fs, Bindings);
	tracee->fs->bindings.host  = talloc_zero(tracee->fs, Bindings);
	if (tracee->fs->bindings.guest == NULL || tracee->fs->bindings.host == NULL) {
		note(tracee, ERROR, INTERNAL, "can't allocate enough memory");
		TALLOC_FREE(tracee->fs->bindings.guest);
		TALLOC_FREE(tracee->fs->bindings.host);
		return -1;
	}

	CIRCLEQ_INIT(tracee->fs->bindings.guest);
	CIRCLEQ_INIT(tracee->fs->bindings.host);

	talloc_set_destructor(tracee->fs->bindings.guest, remove_bindings);
	talloc_set_destructor(tracee->fs->bindings.host, remove_bindings);

	/* The binding to "/" has to be installed before other
	 * bindings since this former is required to canonicalize
	 * these latters.  */
	binding = CIRCLEQ_LAST(tracee->fs->bindings.pending);
	assert(compare_paths(binding->guest.path, "/") == PATHS_ARE_EQUAL);

	/* Call initialize_binding() on each pending binding in
	 * reverse order: the last binding "/" is used to bootstrap
	 * the canonicalization.  */
	while (binding != (void *) tracee->fs->bindings.pending) {
		Binding *previous;
		previous = CIRCLEQ_PREV(binding, link.pending);

		/* Canonicalize then insert this binding into
		 * tracee->fs->bindings.guest/host.  */
		initialize_binding(tracee, binding);

		/* Add induced bindings on sub-reconfiguration.  */
		add_induced_bindings(tracee, binding);

		binding = previous;
	}

	TALLOC_FREE(tracee->fs->bindings.pending);

	if (tracee->verbose > 0)
		print_bindings(tracee);

	return 0;
}

```

`app/src/main/jni/path/binding.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef BINDING_H
#define BINDING_H

#include <limits.h> /* PATH_MAX, */
#include <stdbool.h>

#include "tracee/tracee.h"
#include "path.h"

typedef struct binding {
	Path host;
	Path guest;

	bool need_substitution;
	bool must_exist;

	struct {
		CIRCLEQ_ENTRY(binding) pending;
		CIRCLEQ_ENTRY(binding) guest;
		CIRCLEQ_ENTRY(binding) host;
	} link;
} Binding;

typedef CIRCLEQ_HEAD(bindings, binding) Bindings;

extern Binding *insort_binding3(const Tracee *tracee, const void *context,
				const char host_path[PATH_MAX], const char guest_path[PATH_MAX]);
extern Binding *new_binding(Tracee *tracee, const char *host, const char *guest, bool must_exist);
extern int initialize_bindings(Tracee *tracee);
extern const char *get_path_binding(const Tracee* tracee, Side side, const char path[PATH_MAX]);
extern Binding *get_binding(const Tracee *tracee, Side side, const char path[PATH_MAX]);
extern const char *get_root(const Tracee* tracee);
extern int substitute_binding(const Tracee* tracee, Side side, char path[PATH_MAX]);
extern void remove_binding_from_all_lists(const Tracee *tracee, Binding *binding);

#endif /* BINDING_H */

```

`app/src/main/jni/path/canon.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sys/types.h> /* pid_t */
#include <limits.h>    /* PATH_MAX, */
#include <sys/param.h> /* MAXSYMLINKS, */
#include <errno.h>     /* E*, */
#include <sys/stat.h>  /* lstat(2), S_ISREG(), */
#include <unistd.h>    /* access(2), lstat(2), */
#include <string.h>    /* string(3), */
#include <assert.h>    /* assert(3), */
#include <stdio.h>     /* sscanf(3), */

#include "path/canon.h"
#include "path/path.h"
#include "path/binding.h"
#include "path/glue.h"
#include "path/proc.h"
#include "extension/extension.h"

/**
 * Put an end-of-string ('\0') right before the last component of @path.
 */
static inline void pop_component(char *path)
{
	int offset;

	/* Sanity checks. */
	assert(path != NULL);

	offset = strlen(path) - 1;
	assert(offset >= 0);

	/* Don't pop over "/", it doesn't mean anything. */
	if (offset == 0) {
		assert(path[0] == '/' && path[1] == '\0');
		return;
	}

	/* Skip trailing path separators. */
	while (offset > 1 && path[offset] == '/')
		offset--;

	/* Search for the previous path separator. */
	while (offset > 1 && path[offset] != '/')
		offset--;

	/* Cut the end of the string before the last component. */
	path[offset] = '\0';
	assert(path[0] == '/');
}

/**
 * Copy in @component the first path component pointed to by @cursor,
 * this later is updated to point to the next component for a further
 * call. This function returns:
 *
 *     - -errno if an error occured.
 *
 *     - FINAL_SLASH if it the last component of the path but we
 *       really expect a directory.
 *
 *     - FINAL_NORMAL if it the last component of the path.
 *
 *     - 0 otherwise.
 */
static inline Finality next_component(char component[NAME_MAX], const char **cursor)
{
	const char *start;
	ptrdiff_t length;
	bool want_dir;

	/* Sanity checks. */
	assert(component != NULL);
	assert(cursor    != NULL);

	/* Skip leading path separators. */
	while (**cursor != '\0' && **cursor == '/')
		(*cursor)++;

	/* Find the next component. */
	start = *cursor;
	while (**cursor != '\0' && **cursor != '/')
		(*cursor)++;
	length = *cursor - start;

	if (length >= NAME_MAX)
		return -ENAMETOOLONG;

	/* Extract the component. */
	strncpy(component, start, length);
	component[length] = '\0';

	/* Check if a [link to a] directory is expected. */
	want_dir = (**cursor == '/');

	/* Skip trailing path separators. */
	while (**cursor != '\0' && **cursor == '/')
		(*cursor)++;

	if (**cursor == '\0')
		return (want_dir
			? FINAL_SLASH
			: FINAL_NORMAL);

	return NOT_FINAL;
}

/**
 * Resolve bindings (if any) in @guest_path and copy the translated
 * path into @host_path.  Also, this function checks that a non-final
 * component is either a directory (returned value is 0) or a symlink
 * (returned value is 1), otherwise it returns -errno or -ENOTDIR.
 */
static inline int substitute_binding_stat(Tracee *tracee, Finality finality, unsigned int recursion_level,
					const char guest_path[PATH_MAX], char host_path[PATH_MAX])
{
	struct stat statl;
	int status;

	strcpy(host_path, guest_path);
	status = substitute_binding(tracee, GUEST, host_path);
	if (status < 0)
		return status;

	/* Don't notify extensions during the initialization of a binding.  */
	if (tracee->glue_type == 0) {
		status = notify_extensions(tracee, HOST_PATH, (intptr_t)host_path,
					IS_FINAL(finality) && recursion_level == 0);
		if (status < 0)
			return status;
	}

	statl.st_mode = 0;
	status = lstat(host_path, &statl);

	/* Build the glue between the hostfs and the guestfs during
	 * the initialization of a binding.  */
	if (status < 0 && tracee->glue_type != 0) {
		statl.st_mode = build_glue(tracee, guest_path, host_path, finality);
		if (statl.st_mode == 0)
			status = -1;
	}

	/* Return an error if a non-final component isn't a directory
	 * nor a symlink.  The error depends on why the component
	 * could not be accessed (ENOENT, EACCES, ...), otherwise the
	 * error is "Not a directory".  */
	if (!IS_FINAL(finality) && !S_ISDIR(statl.st_mode) && !S_ISLNK(statl.st_mode))
		return (status < 0 ? -errno : -ENOTDIR);

	return (S_ISLNK(statl.st_mode) ? 1 : 0);
}

/**
 * Copy in @guest_path the canonicalization (see `man 3 realpath`) of
 * @user_path regarding to @tracee->root.  The path to canonicalize
 * could be either absolute or relative to @guest_path. When the last
 * component of @user_path is a link, it is dereferenced only if
 * @deref_final is true -- it is useful for syscalls like lstat(2).
 * The parameter @recursion_level should be set to 0 unless you know
 * what you are doing. This function returns -errno if an error
 * occured, otherwise it returns 0.
 */
int canonicalize(Tracee *tracee, const char *user_path, bool deref_final,
		 char guest_path[PATH_MAX], unsigned int recursion_level)
{
	char scratch_path[PATH_MAX];
	char host_path[PATH_MAX];
	Finality finality;
	const char *cursor;
	int status;

	/* Avoid infinite loop on circular links.  */
	if (recursion_level > MAXSYMLINKS)
		return -ELOOP;

	/* Sanity checks.  */
	assert(user_path != NULL);
	assert(guest_path != NULL);
	assert(user_path != guest_path);

	if (strnlen(guest_path, PATH_MAX) >= PATH_MAX)
		return -ENAMETOOLONG;

	if (user_path[0] != '/') {
		/* Ensure 'guest_path' contains an absolute base of
		 * the relative `user_path`.  */
		if (guest_path[0] != '/')
			return -EINVAL;
	}
	else
		strcpy(guest_path, "/");


	/* Resolve bindings for the initial '/' component or user_path,
	 * which is not handled in the loop below.
	 * In particular HOST_PATH extensions are called from there.  */
//	status = substitute_binding_stat(tracee, NOT_FINAL, recursion_level, guest_path, host_path);
//	if (status < 0)
//		return status;
	strcpy(host_path,guest_path);

	/* Canonicalize recursely 'user_path' into 'guest_path'.  */
	cursor = user_path;
	finality = NOT_FINAL;
	while (!IS_FINAL(finality)) {
		Comparison comparison;
		char component[NAME_MAX];

		finality = next_component(component, &cursor);
		status = (int) finality;
		if (status < 0)
			return status;

		if (strcmp(component, ".") == 0) {
			if (IS_FINAL(finality))
				finality = FINAL_DOT;
			continue;
		}

		if (strcmp(component, "..") == 0) {
			pop_component(guest_path);
			if (IS_FINAL(finality))
				finality = FINAL_SLASH;
			continue;
		}

		status = join_paths(2, scratch_path, guest_path, component);
		if (status < 0)
			return status;

		/* Resolve bindings and check that a non-final
		 * component exists and either is a directory or is a
		 * symlink.  For this latter case, we check that the
		 * symlink points to a directory once it is
		 * canonicalized, at the end of this loop.  */
//		status = substitute_binding_stat(tracee, finality, recursion_level, scratch_path, host_path);
//		if (status < 0)
//			return status;
		strcpy(host_path, scratch_path);

		/* Nothing special to do if it's not a link or if we
		 * explicitly ask to not dereference 'user_path', as
		 * required by syscalls like lstat(2). Obviously, this
		 * later condition does not apply to intermediate path
		 * components.  Errors are explicitly ignored since
		 * they should be handled by the caller. */
		if (status <= 0 || (finality == FINAL_NORMAL && !deref_final)) {
			strcpy(scratch_path, guest_path);
			status = join_paths(2, guest_path, scratch_path, component);
			if (status < 0)
				return status;
			continue;
		}

		/* It's a link, so we have to dereference *and*
		 * canonicalize to ensure we are not going outside the
		 * new root.  */
		comparison = compare_paths("/proc", guest_path);
		switch (comparison) {
		case PATHS_ARE_EQUAL:
		case PATH1_IS_PREFIX:
			/* Some links in "/proc" are generated
			 * dynamically by the kernel.  PRoot has to
			 * emulate some of them.  */
			status = readlink_proc(tracee, scratch_path,
					       guest_path, component, comparison);
			switch (status) {
			case CANONICALIZE:
				/* The symlink is already dereferenced,
				 * now canonicalize it.  */
				goto canon;

			case DONT_CANONICALIZE:
				/* If and only very final, this symlink
				 * shouldn't be dereferenced nor canonicalized.  */
				if (finality == FINAL_NORMAL) {
					strcpy(guest_path, scratch_path);
					return 0;
				}
				break;

			default:
				if (status < 0)
					return status;
			}

		default:
			break;
		}

		status = readlink(host_path, scratch_path, sizeof(scratch_path));
		if (status < 0)
			return status;
		else if (status == sizeof(scratch_path))
			return -ENAMETOOLONG;
		scratch_path[status] = '\0';

		/* Remove the leading "root" part if needed, it's
		 * useful for "/proc/self/cwd/" for instance.  */
		status = detranslate_path(tracee, scratch_path, host_path);
		if (status < 0)
			return status;

	canon:
		/* Canonicalize recursively the referee in case it
		 * is/contains a link, moreover if it is not an
		 * absolute link then it is relative to
		 * 'guest_path'. */
		status = canonicalize(tracee, scratch_path, true, guest_path, recursion_level + 1);
		if (status < 0)
			return status;

		/* Check that a non-final canonicalized/dereferenced
		 * symlink exists and is a directory.  */
		status = substitute_binding_stat(tracee, finality, recursion_level, guest_path, host_path);
		if (status < 0)
			return status;

		/* Here, 'guest_path' shouldn't be a symlink anymore,
		 * unless it is a named file descriptor.  */
		assert(status != 1 || sscanf(guest_path, "/proc/%*d/fd/%d", &status) == 1);
	}

	/* At the exit stage of the first level of recursion,
	 * `guest_path` is fully canonicalized but a terminating '/'
	 * or a terminating '.' may be required to keep the initial
	 * semantic of `user_path`.  */
	if (recursion_level == 0) {
		switch (finality) {
		case FINAL_NORMAL:
			break;

		case FINAL_SLASH:
			strcpy(scratch_path, guest_path);
			status = join_paths(2, guest_path, scratch_path, "");
			if (status < 0)
				return status;
			break;

		case FINAL_DOT:
			strcpy(scratch_path, guest_path);
			status = join_paths(2, guest_path, scratch_path, ".");
			if (status < 0)
				return status;
			break;

		default:
			assert(0);
		}
	}

	return 0;
}

```

`app/src/main/jni/path/canon.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef CANON_H
#define CANON_H

#include <stdbool.h>
#include <limits.h>

#include "tracee/tracee.h"

extern int canonicalize(Tracee *tracee, const char *user_path, bool deref_final,
			char guest_path[PATH_MAX], unsigned int nb_recursion);

#endif /* CANON_H */

```

`app/src/main/jni/path/glue.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sys/types.h> /* mkdir(2), lstat(2), */
#include <sys/stat.h> /* mkdir(2), lstat(2), */
#include <fcntl.h>    /* mknod(2), */
#include <unistd.h>   /* mknod(2), lstat(2), unlink(2), rmdir(2), */
#include <string.h>   /* string(3),  */
#include <assert.h>   /* assert(3), */
#include <limits.h>   /* PATH_MAX, */
#include <errno.h>    /* errno, E* */
#include <talloc.h>   /* talloc_*, */

#include "path/binding.h"
#include "path/path.h"
#include "path/temp.h"
#include "cli/note.h"

#include "compat.h"

/**
 * Remove @path if it is empty only.
 *
 * Note: this is a Talloc destructor.
 */
static int remove_placeholder(char *path)
{
	struct stat statl;
	int status;

	status = lstat(path, &statl);
	if (status)
		return 0; /* Not fatal.  */

	if (!S_ISDIR(statl.st_mode)) {
		if (statl.st_size != 0)
			return 0; /* Not fatal.  */
		status = unlink(path);
	}
	else
		status = rmdir(path);
	if (status)
		return 0; /* Not fatal.  */

	return 0;
}

/**
 * Attach a copy of @path to the autofree context, and set its
 * destructor to remove_placeholder().
 */
static void set_placeholder_destructor(const char *path)
{
	TALLOC_CTX *autofreed;
	char *placeholder;

	autofreed = talloc_autofree_context();
	if (autofreed == NULL)
		return;

	placeholder = talloc_strdup(autofreed, path);
	if (placeholder == NULL)
		return;

	talloc_set_destructor(placeholder, remove_placeholder);
}

/**
 * Build in a temporary filesystem the glue between the guest part and
 * the host part of the @binding_path.  This function returns the type
 * of the bound path, otherwise 0 if an error occured.
 *
 * For example, assuming the host path "/opt" is mounted/bound to the
 * guest path "/black/holes/and/revelations", and assuming this path
 * can't be created in the guest rootfs (eg. permission denied), then
 * it is created in a temporary rootfs and all these paths are glued
 * that way:
 *
 *   $GUEST/black/ --> $GLUE/black/
 *                               ./holes
 *                               ./holes/and
 *                               ./holes/and/revelations --> $HOST/opt/
 *
 * This glue allows operations on paths that do not exist in the guest
 * rootfs but that were specified as the guest part of a binding.
 */
mode_t build_glue(Tracee *tracee, const char *guest_path, char host_path[PATH_MAX],
		Finality finality)
{
	bool belongs_to_gluefs;
	Comparison comparison;
	Binding *binding;
	mode_t type;
	mode_t mode;
	int status;

	assert(tracee->glue_type != 0);

	/* Create the temporary directory where the "glue" rootfs will
	 * lie.  */
	if (tracee->glue == NULL) {
		tracee->glue = create_temp_directory(NULL, tracee->tool_name);
		if (tracee->glue == NULL) {
			note(tracee, ERROR, INTERNAL, "can't create glue rootfs");
			return 0;
		}
		talloc_set_name_const(tracee->glue, "$glue");
	}

	comparison = compare_paths(tracee->glue, host_path);
	belongs_to_gluefs = (comparison == PATHS_ARE_EQUAL || comparison == PATH1_IS_PREFIX);

	/* If it's not a final component then it is a directory.  I definitely
	 * hate how the potential type of the final component is propagated
	 * from initialize_binding() down to here, sadly there's no elegant way
	 * to know its type at this stage.  */
	if (IS_FINAL(finality)) {
		type = tracee->glue_type;
		mode = (belongs_to_gluefs ? 0777 : 0);
	}
	else {
		type = S_IFDIR;
		mode = 0777;
	}

	if (getenv("PROOT_DONT_POLLUTE_ROOTFS") != NULL && !belongs_to_gluefs)
		goto create_binding;

	/* Try to create this component into the "guest" or "glue"
	 * rootfs (depending if there were a glue previously).  */
	if (S_ISDIR(type))
		status = mkdir(host_path, mode);
	else /* S_IFREG, S_IFCHR, S_IFBLK, S_IFIFO or S_IFSOCK.  */
		status = mknod(host_path, mode | type, 0);

	/* Remove placeholders from the guest rootfs once PRoot is
	 * terminated.  */
	if (status >= 0 && !belongs_to_gluefs)
		set_placeholder_destructor(host_path);

	/* Nothing else to do if the path already exists or if it is
	 * the final component since it will be pointed to by the
	 * binding being initialized (from the example,
	 * "$GUEST/black/holes/and/revelations" -> "$HOST/opt").  */
	if (status >= 0 || errno == EEXIST || IS_FINAL(finality))
		return type;

	/* mkdir/mknod are supposed to always succeed in
	 * tracee->glue.  */
	if (belongs_to_gluefs) {
		note(tracee, WARNING, SYSTEM, "mkdir/mknod");
		return 0;
	}

create_binding:
	/* Sanity checks.  */
	if (   strnlen(tracee->glue, PATH_MAX) >= PATH_MAX
	    || strnlen(guest_path, PATH_MAX) >= PATH_MAX) {
		note(tracee, WARNING, INTERNAL, "installing the binding: guest path too long");
		return 0;
	}

	/* From the example, create the binding "/black" ->
	 * "$GLUE/black".  */
	binding = insort_binding3(tracee, tracee->glue, tracee->glue, guest_path);
	if (binding == NULL)
		return 0;

	/* TODO: emulation of getdents(parent(guest_path)) to finalize
	 * the glue, "black" in getdents("/") from the example.  */

	return type;
}

```

`app/src/main/jni/path/glue.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef GLUE_H
#define GLUE_H

#include <limits.h> /* PATH_MAX, */

#include "tracee/tracee.h"
#include "path.h"

extern mode_t build_glue(Tracee *tracee, const char *guest_path, char host_path[PATH_MAX],
			Finality finality);

#endif /* GLUE_H */

```

`app/src/main/jni/path/path.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <string.h>    /* string(3), */
#include <stdarg.h>    /* va_*(3), */
#include <assert.h>    /* assert(3), */
#include <fcntl.h>     /* AT_*,  */
#include <unistd.h>    /* readlink*(2), *stat(2), getpid(2), */
#include <sys/types.h> /* pid_t, */
#include <sys/stat.h>  /* S_ISDIR, */
#include <dirent.h>    /* opendir(3), readdir(3), */
#include <stdio.h>     /* snprintf(3), */
#include <errno.h>     /* E*, */
#include <stddef.h>    /* ptrdiff_t, */
#include <inttypes.h>  /* PRI*, */
#include <stdlib.h>

#include "path/path.h"
//#include "path/binding.h"
#include "path/canon.h"
#include "path/proc.h"
//#include "extension/extension.h"
//#include "cli/note.h"
#include "build.h"

#include "compat.h"
#include "constant.h"
#include "note.h"

/**
 * Copy in @result the concatenation of several paths (@number_paths)
 * and adds a path separator ('/') in between when needed. This
 * function returns -errno if an error occured, otherwise it returns 0.
 */
int join_paths(int number_paths, char result[PATH_MAX], ...)
{
	va_list paths;
	size_t length;
	int status;
	int i;

	result[0] = '\0';
	length = 0;
	status = 0;

	/* Parse the list of variadic arguments. */
	va_start(paths, result);
	for (i = 0; i < number_paths; i++) {
		const char *path;
		size_t path_length;
		size_t new_length;

		path = va_arg(paths, const char *);
		if (path == NULL)
			continue;
		path_length = strlen(path);

		/* A new path separator is needed.  */
		if (length > 0 && result[length - 1] != '/' && path[0] != '/') {
			new_length = length + path_length + 1;
			if (new_length + 1 >= PATH_MAX) {
				status = -ENAMETOOLONG;
				break;
			}
			strcat(result + length, "/");
			strcat(result + length, path);
			length = new_length;
		}
		/* There are already two path separators.  */
		else if (length > 0 && result[length - 1] == '/' && path[0] == '/') {
			new_length = length + path_length - 1;
			if (new_length + 1 >= PATH_MAX) {
				status = -ENAMETOOLONG;
				break;
			}
			strcat(result + length, path + 1);
			length += path_length - 1;
		}
		/* There's already one path separator or result[] is empty.  */
		else {
			new_length = length + path_length;
			if (new_length + 1 >= PATH_MAX) {
				status = -ENAMETOOLONG;
				break;
			}
			strcat(result + length, path);
			length += path_length;
		}

		status = 0;
	}
	va_end(paths);

	return status;
}

/**
 * Put in @host_path the full path to the given shell @command.  The
 * @command is searched in @paths if not null, otherwise in $PATH
 * (relatively to the @tracee's file-system name-space).  This
 * function always returns -1 on error, otherwise 0.
 */
int which(Tracee *tracee, const char *paths, char host_path[PATH_MAX], const char *command)
{
	char path[PATH_MAX];
	const char *cursor;
	struct stat statr;
	int status;

	bool is_explicit;
	bool found;

	assert(command != NULL);
	is_explicit = (strchr(command, '/') != NULL);

	/* Is the command available without any $PATH look-up?  */
	status = realpath2(tracee, host_path, command, true);
	if (status == 0 && stat(host_path, &statr) == 0) {
		if (is_explicit && !S_ISREG(statr.st_mode)) {
//			note(tracee, ERROR, USER, "'%s' is not a regular file", command);
			LOGE("'%s' is not a regular file", command)
			return -EACCES;
		}

		if (is_explicit && (statr.st_mode & S_IXUSR) == 0) {
//			note(tracee, ERROR, USER, "'%s' is not executable", command);
			LOGE("'%s' is not executable", command)
			return -EACCES;
		}

		found = true;

		/* Don't dereference the final component to preserve
		 * argv0 in case it is a symlink to script.  */
		(void) realpath2(tracee, host_path, command, false);
	}
	else
		found = false;

	/* Is the the explicit command was found?  */
	if (is_explicit) {
		if (found)
			return 0;
		else
			goto not_found;
	}

	/* Otherwise search the command in $PATH.  */
	paths = paths ?: getenv("PATH");
	if (paths == NULL || strcmp(paths, "") == 0)
		goto not_found;

	cursor = paths;
	do {
		size_t length;

		length = strcspn(cursor, ":");
		cursor += length + 1;

		if (length >= PATH_MAX)
			continue;
		else if (length == 0)
			strcpy(path, ".");
		else {
			strncpy(path, cursor - length - 1, length);
			path[length] = '\0';
		}

		/* Avoid buffer-overflow.  */
		if (length + strlen(command) + 2 >= PATH_MAX)
			continue;

		strcat(path, "/");
		strcat(path, command);

		status = realpath2(tracee, host_path, path, true);
		if (status == 0
		    && stat(host_path, &statr) == 0
		    && S_ISREG(statr.st_mode)
		    && (statr.st_mode & S_IXUSR) != 0) {
			/* Don't dereference the final component to preserve
			 * argv0 in case it is a symlink to script.  */
			(void) realpath2(tracee, host_path, path, false);
			return 0;
		}
	} while (*(cursor - 1) != '\0');

not_found:
//	status = getcwd2(tracee, path);
//	if (status < 0)
//		strcpy(path, "<unknown>");
    if (getcwd(path,PATH_MAX) == NULL){
        strcpy(path, "<unknown>");
    }

//	note(tracee, ERROR, USER, "'%s' not found (root = %s, cwd = %s, $PATH=%s)",
//		command, get_root(tracee), path, paths);
//	LOGE("'%s' not found (root = %s, cwd = %s, $PATH=%s)",
//		 command, get_root(tracee), path, paths);

	/* Check if the command was found without any $PATH look-up
	 * but it didn't contain "/".  */
	if (found && !is_explicit)
//		note(tracee, ERROR, USER,
//			"to execute a local program, use the './' prefix, for example: ./%s", command);
	LOGE("to execute a local program, use the './' prefix, for example: ./%s", command);

	return -1;
}

/**
 * Put in @host_path the canonicalized form of @path.  In the nominal
 * case (@tracee == NULL), this function is barely equivalent to
 * realpath(), but when doing sub-reconfiguration, the path is
 * canonicalized relatively to the current @tracee's file-system
 * name-space.  This function returns -errno on error, otherwise 0.
 */
int realpath2(Tracee *tracee, char host_path[PATH_MAX], const char *path, bool deref_final)
{
	int status;

	if (tracee == NULL)
		status = (realpath(path, host_path) == NULL ? -errno : 0);
	else
		status = translate_path(tracee, host_path, AT_FDCWD, path, deref_final);
	return status;
}

/**
 * Put in @guest_path the canonicalized current working directory.  In
 * the nominal case (@tracee == NULL), this function is barely
 * equivalent to realpath(), but when doing sub-reconfiguration, the
 * path is canonicalized relatively to the current @tracee's
 * file-system name-space.  This function returns -errno on error,
 * otherwise 0.
 */
int getcwd2(Tracee *tracee, char guest_path[PATH_MAX])
{
	if (tracee == NULL) {
		if (getcwd(guest_path, PATH_MAX) == NULL)
			return -errno;
	}
	else {
		//TODO 是否需要fake一下?
//		if (strlen(tracee->fs->cwd) >= PATH_MAX)
//			return -ENAMETOOLONG;
//
//		strcpy(guest_path, tracee->fs->cwd);
	}

	return 0;
}

/**
 * Remove the trailing "/" or "/.".
 */
void chop_finality(char *path)
{
	size_t length = strlen(path);

	if (path[length - 1] == '.') {
		assert(length >= 2);
		/* Special case for "/." */
		if (length == 2)
			path[length - 1] = '\0';
		else
			path[length - 2] = '\0';
	}
	else if (path[length - 1] == '/') {
		/* Special case for "/" */
		if (length > 1)
			path[length - 1] = '\0';
	}
}

/**
 * Put in @path the result of readlink(/proc/@pid/fd/@fd).  This
 * function returns -errno if an error occured, otherwise 0.
 */
int readlink_proc_pid_fd(pid_t pid, int fd, char path[PATH_MAX])
{
	char link[32]; /* 32 > sizeof("/proc//cwd") + sizeof(#ULONG_MAX) */
	int status;

	/* Format the path to the "virtual" link. */
	status = snprintf(link, sizeof(link), "/proc/%d/fd/%d",	pid, fd);
	if (status < 0)
		return -EBADF;
	if ((size_t) status >= sizeof(link))
		return -EBADF;

	/* Read the value of this "virtual" link. */
	status = readlink(link, path, PATH_MAX);
	if (status < 0)
		return -EBADF;
	if (status >= PATH_MAX)
		return -ENAMETOOLONG;
	path[status] = '\0';

	return 0;
}

/**
 * Copy in @result the equivalent of "@tracee->root + canon(@dir_fd +
 * @user_path)".  If @user_path is not absolute then it is relative to
 * the directory referred by the descriptor @dir_fd (AT_FDCWD is for
 * the current working directory).  See the documentation of
 * canonicalize() for the meaning of @deref_final.  This function
 * returns -errno if an error occured, otherwise 0.
 */
int translate_path(Tracee *tracee, char result[PATH_MAX], int dir_fd,
		const char *user_path, bool deref_final)
{

	char guest_path[PATH_MAX];
	int status;

	/* Use "/" as the base if it is an absolute guest path. */
	if (user_path[0] == '/') { //绝对路径
		strcpy(result, "/");
	}
		/* It is relative to a directory referred by a descriptor, see
         * openat(2) for details. */
	else if (dir_fd != AT_FDCWD) { //相对一个目录
		/* /proc/@tracee->pid/fd/@dir_fd -> result.  */
		status = readlink_proc_pid_fd(tracee->pid, dir_fd, result);
		if (status < 0)
			return status;

		/* Named file descriptors may reference special
		 * objects like pipes, sockets, inodes, ...  Such
		 * objects do not belong to the file-system.  */
		if (result[0] != '/')
			return -ENOTDIR;

		/* Remove the leading "root" part of the base
		 * (required!). */
//		status = detranslate_path(tracee, result, NULL);
//		if (status < 0)
//			return status;
	}
		/* It is relative to the current working directory.  */
	else { //相对工作目录
//		status = getcwd2(tracee, result);
//		if (status < 0)
//			return status;
        if (getcwd(result,PATH_MAX) == NULL)
            return -errno;
	}

	VERBOSE(tracee, 2, "vpid %" PRIu64 ": translate(\"%s\" + \"%s\")",
			tracee != NULL ? tracee->vpid : 0, result, user_path);

//	status = notify_extensions(tracee, GUEST_PATH, (intptr_t) result, (intptr_t) user_path);
//	if (status < 0)
//		return status;
//	if (status > 0)
//		goto skip;

	/* So far "result" was used as a base path, it's time to join
	 * it to the user path.  */
	assert(result[0] == '/');
	status = join_paths(2, guest_path, result, user_path);
	if (status < 0)
		return status;
//	strcpy(result, "/");
	strcpy(result,guest_path);
	LOGSYS("translate_path guest_path %s",guest_path)
	/* Canonicalize regarding the new root. */
//	status = canonicalize(tracee, guest_path, deref_final, result, 0);
//	if (status < 0)
//		return status;


	/* Final binding substitution to convert "result" into a host
	 * path, since canonicalize() works from the guest
	 * point-of-view.  */
//	status = substitute_binding(tracee, GUEST, result);
//	if (status < 0)
//		return status;

//	skip:
	VERBOSE(tracee, 2, "vpid %" PRIu64 ":          -> \"%s\"",
			tracee != NULL ? tracee->vpid : 0, result);

//	status = notify_extensions(tracee, TRANSLATED_PATH, (intptr_t) result, 0);
//	if (status < 0)
//		return status;

	return 0;
}

/**
 * Remove/substitute the leading part of a "translated" @path.  It
 * returns 0 if no transformation is required (ie. symmetric binding),
 * otherwise it returns the size in bytes of the updated @path,
 * including the end-of-string terminator.  On error it returns
 * -errno.
 */
int detranslate_path(Tracee *tracee, char path[PATH_MAX], const char t_referrer[PATH_MAX])
{
    //路径变换(移除/添加前缀)
    return 0;
//	size_t prefix_length;
//	ssize_t new_length;
//
//	bool sanity_check;
//	bool follow_binding;
//
//	/* Sanity check.  */
//	if (strnlen(path, PATH_MAX) >= PATH_MAX)
//		return -ENAMETOOLONG;
//
//	/* Don't try to detranslate relative paths (typically the
//	 * target of a relative symbolic link). */
//	if (path[0] != '/')
//		return 0;
//
//	/* Is it a symlink?  */
//	if (t_referrer != NULL) {
//		Comparison comparison;
//
//		sanity_check = false;
//		follow_binding = false;
//
//		/* In some cases bindings have to be resolved.  */
//		comparison = compare_paths("/proc", t_referrer);
//		if (comparison == PATH1_IS_PREFIX) {
//			/* Some links in "/proc" are generated
//			 * dynamically by the kernel.  PRoot has to
//			 * emulate some of them.  */
//			char proc_path[PATH_MAX];
//			strcpy(proc_path, path);
//			new_length = readlink_proc2(tracee, proc_path, t_referrer);
//			if (new_length < 0)
//				return new_length;
//			if (new_length != 0) {
//				strcpy(path, proc_path);
//				return new_length + 1;
//			}
//
//			/* Always resolve bindings for symlinks in
//			 * "/proc", they always point to the emulated
//			 * file-system namespace by design. */
//			follow_binding = true;
//		}
//		else if (!belongs_to_guestfs(tracee, t_referrer)) {
//			const char *binding_referree;
//			const char *binding_referrer;
//
//			binding_referree = get_path_binding(tracee, HOST, path);
//			binding_referrer = get_path_binding(tracee, HOST, t_referrer);
//			assert(binding_referrer != NULL);
//
//			/* Resolve bindings for symlinks that belong
//			 * to a binding and point to the same binding.
//			 * For example, if "-b /lib:/foo" is specified
//			 * and the symlink "/lib/a -> /lib/b" exists
//			 * in the host rootfs namespace, then it
//			 * should appear as "/foo/a -> /foo/b" in the
//			 * guest rootfs namespace for consistency
//			 * reasons.  */
//			if (binding_referree != NULL) {
//				comparison = compare_paths(binding_referree, binding_referrer);
//				follow_binding = (comparison == PATHS_ARE_EQUAL);
//			}
//		}
//	}
//	else {
//		sanity_check = true;
//		follow_binding = true;
//	}
//
//	if (follow_binding) {
//		switch (substitute_binding(tracee, HOST, path)) {
//		case 0:
//			return 0;
//		case 1:
//			return strlen(path) + 1;
//		default:
//			break;
//		}
//	}
//
//	switch (compare_paths(get_root(tracee), path)) {
//	case PATH1_IS_PREFIX:
//		/* Remove the leading part, that is, the "root".  */
//		prefix_length = strlen(get_root(tracee));
//
//		/* Special case when path to the guest rootfs == "/". */
//		if (prefix_length == 1)
//			prefix_length = 0;
//
//		new_length = strlen(path) - prefix_length;
//		memmove(path, path + prefix_length, new_length);
//
//		path[new_length] = '\0';
//		break;
//
//	case PATHS_ARE_EQUAL:
//		/* Special case when path == root. */
//		new_length = 1;
//		strcpy(path, "/");
//		break;
//
//	default:
//		/* Ensure the path is within the new root.  */
//		if (sanity_check)
//			return -EPERM;
//		else
//			return 0;
//	}
//
//	return new_length + 1;
}

/**
 * Check if the translated @host_path belongs to the guest rootfs,
 * that is, isn't from a binding.
 */
bool belongs_to_guestfs(const Tracee *tracee, const char *host_path)
{
    return true;
//	Comparison comparison;
//
//	comparison = compare_paths(get_root(tracee), host_path);
//	return (comparison == PATHS_ARE_EQUAL || comparison == PATH1_IS_PREFIX);
}

/**
 * Compare @path1 with @path2, which are respectively @length1 and
 * @length2 long.
 *
 * This function works only with paths canonicalized in the same
 * namespace (host/guest)!
 */
Comparison compare_paths2(const char *path1, size_t length1, const char *path2, size_t length2)
{
	size_t length_min;
	bool is_prefix;
	char sentinel;

#if defined DEBUG_OPATH
	assert(length(path1) == length1);
	assert(length(path2) == length2);
#endif
	assert(length1 > 0);
	assert(length2 > 0);

	if (!length1 || !length2) {
		return PATHS_ARE_NOT_COMPARABLE;
	}

	/* Remove potential trailing '/' for the comparison.  */
	if (path1[length1 - 1] == '/')
		length1--;

	if (path2[length2 - 1] == '/')
		length2--;

	if (length1 < length2) {
		length_min = length1;
		sentinel = path2[length_min];
	}
	else {
		length_min = length2;
		sentinel = path1[length_min];
	}

	/* Optimize obvious cases.  */
	if (sentinel != '/' && sentinel != '\0')
		return PATHS_ARE_NOT_COMPARABLE;

	is_prefix = (strncmp(path1, path2, length_min) == 0);

	if (!is_prefix)
		return PATHS_ARE_NOT_COMPARABLE;

	if (length1 == length2)
		return PATHS_ARE_EQUAL;
	else if (length1 < length2)
		return PATH1_IS_PREFIX;
	else if (length1 > length2)
		return PATH2_IS_PREFIX;

	assert(0);
	return PATHS_ARE_NOT_COMPARABLE;
}

Comparison compare_paths(const char *path1, const char *path2)
{
	return compare_paths2(path1, strlen(path1), path2, strlen(path2));
}

typedef int (*foreach_fd_t)(const Tracee *tracee, int fd, char path[PATH_MAX]);

/**
 * Call @callback on each open file descriptors of @pid. It returns
 * the status of the first failure, that is, if @callback returned
 * seomthing lesser than 0, otherwise 0.
 */
static int foreach_fd(const Tracee *tracee, foreach_fd_t callback)
{
	struct dirent *dirent;
	char path[PATH_MAX];
	char proc_fd[32]; /* 32 > sizeof("/proc//fd") + sizeof(#ULONG_MAX) */
	int status;
	DIR *dirp;

	/* Format the path to the "virtual" directory. */
	status = snprintf(proc_fd, sizeof(proc_fd), "/proc/%d/fd", tracee->pid);
	if (status < 0 || (size_t) status >= sizeof(proc_fd))
		return 0;

	/* Open the virtual directory "/proc/$pid/fd". */
	dirp = opendir(proc_fd);
	if (dirp == NULL)
		return 0;

	while ((dirent = readdir(dirp)) != NULL) {
		/* Read the value of this "virtual" link.  Don't use
		 * readlinkat(2) here since it would require Linux >=
		 * 2.6.16 and Glibc >= 2.4, whereas PRoot is supposed
		 * to work on any Linux 2.6 systems.  */

		char tmp[PATH_MAX];
		if (strlen(proc_fd) + strlen(dirent->d_name) + 1 >= PATH_MAX)
			continue;

		strcpy(tmp, proc_fd);
		strcat(tmp, "/");
		strcat(tmp, dirent->d_name);

		status = readlink(tmp, path, PATH_MAX);
		if (status < 0 || status >= PATH_MAX)
			continue;
		path[status] = '\0';

		/* Ensure it points to a path (not a socket or somethink like that). */
		if (path[0] != '/')
			continue;

		status = callback(tracee, atoi(dirent->d_name), path);
		if (status < 0)
			goto end;
	}
	status = 0;

end:
	closedir(dirp);
	return status;
}

/**
 * Helper for list_open_fd().
 */
//static int list_open_fd_callback(const Tracee *tracee, int fd, char path[PATH_MAX])
//{
//	VERBOSE(tracee, 1, "pid %d: access to \"%s\" (fd %d) won't be translated until closed",
//		tracee->pid, path, fd);
//	notify_extensions((Tracee*)tracee, ALREADY_OPENED_FD, (intptr_t)path, (intptr_t)fd);
//	return 0;
//}

/**
 * Warn for files that are open. It is useful right after PRoot has
 * attached a process.
 */
//int list_open_fd(const Tracee *tracee)
//{
//	return foreach_fd(tracee, list_open_fd_callback);
//}

/**
 * Substitute the first @old_prefix_length bytes of @path with
 * @new_prefix (the caller has to provides a correct
 * @new_prefix_length).  This function returns the new length of
 * @path.  Note: this function takes care about special cases (like
 * "/").
 */
size_t substitute_path_prefix(char path[PATH_MAX], size_t old_prefix_length,
			const char *new_prefix, size_t new_prefix_length)
{
	size_t path_length;
	size_t new_length;

	path_length = strlen(path);

	assert(old_prefix_length < PATH_MAX);
	assert(new_prefix_length < PATH_MAX);

	if (new_prefix_length == 1) {
		/* Special case: "/foo" -> "/".  Substitute "/foo/bin"
		 * with "/bin" not "//bin".  */

		new_length = path_length - old_prefix_length;
		if (new_length != 0)
			memmove(path, path + old_prefix_length, new_length);
		else {
			/* Special case: "/".  */
			path[0] = '/';
			new_length = 1;
		}
	}
	else if (old_prefix_length == 1) {
		/* Special case: "/" -> "/foo". Substitute "/bin" with
		 * "/foo/bin" not "/foobin".  */

		new_length = new_prefix_length + path_length;
		if (new_length >= PATH_MAX)
			return -ENAMETOOLONG;

		if (path_length > 1) {
			memmove(path + new_prefix_length, path, path_length);
			memcpy(path, new_prefix, new_prefix_length);
		}
		else {
			/* Special case: "/".  */
			memcpy(path, new_prefix, new_prefix_length);
			new_length = new_prefix_length;
		}
	}
	else {
		/* Generic case.  */

		new_length = path_length - old_prefix_length + new_prefix_length;
		if (new_length >= PATH_MAX)
			return -ENAMETOOLONG;

		memmove(path + new_prefix_length,
			path + old_prefix_length,
			path_length - old_prefix_length);
		memcpy(path, new_prefix, new_prefix_length);
	}

	assert(new_length < PATH_MAX);
	path[new_length] = '\0';

	return new_length;
}

```

`app/src/main/jni/path/path.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef PATH_H
#define PATH_H

#include <sys/types.h> /* pid_t, */
#include <fcntl.h> /* AT_FDCWD, */
#include <limits.h> /* PATH_MAX, */
#include <stdbool.h>

#include "tracee/tracee.h"

/* File type.  */
typedef enum {
	REGULAR,
	SYMLINK,
} Type;

/* Path point-of-view.  */
typedef enum {
	GUEST,
	HOST,

	/* Used for bindings as specified by the user but not
	 * canonicalized yet (new_binding, initialize_binding).  */
	PENDING,
} Side;

/* Path with cached attributes.  */
typedef struct {
	char path[PATH_MAX];
	size_t length;
	Side side;
} Path;

/* Path ending type.  */
typedef enum {
	NOT_FINAL,
	FINAL_NORMAL,
	FINAL_SLASH,
	FINAL_DOT
} Finality;

#define IS_FINAL(a) ((a) != NOT_FINAL)

/* Comparison between two paths.  */
typedef enum Comparison {
	PATHS_ARE_EQUAL,
	PATH1_IS_PREFIX,
	PATH2_IS_PREFIX,
	PATHS_ARE_NOT_COMPARABLE,
} Comparison;

extern int which(Tracee *tracee, const char *paths, char host_path[PATH_MAX], const char *command);
extern int realpath2(Tracee *tracee, char host_path[PATH_MAX], const char *path, bool deref_final);
extern int getcwd2(Tracee *tracee, char guest_path[PATH_MAX]);
extern void chop_finality(char *path);

extern int translate_path(Tracee *tracee, char host_path[PATH_MAX],
			int dir_fd, const char *guest_path, bool deref_final);

extern int detranslate_path(Tracee *tracee, char path[PATH_MAX], const char t_referrer[PATH_MAX]);
extern bool belongs_to_guestfs(const Tracee *tracee, const char *path);

extern int join_paths(int number_paths, char result[PATH_MAX], ...);
extern int list_open_fd(const Tracee *tracee);

extern Comparison compare_paths(const char *path1, const char *path2);
extern Comparison compare_paths2(const char *path1, size_t length1, const char *path2, size_t length2);

extern size_t substitute_path_prefix(char path[PATH_MAX], size_t old_prefix_length,
				const char *new_prefix, size_t new_prefix_length);

extern int readlink_proc_pid_fd(pid_t pid, int fd, char path[PATH_MAX]);

/* Check if path interpretable relatively to dirfd, see openat(2) for details. */
#define AT_FD(dirfd, path) ((dirfd) != AT_FDCWD && ((path) != NULL && (path)[0] != '/'))

#endif /* PATH_H */

```

`app/src/main/jni/path/proc.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <stdio.h>   /* snprintf(3), */
#include <string.h>  /* strcmp(3), */
#include <stdlib.h>  /* atoi(3), strtol(3), */
#include <errno.h>   /* E*, */
#include <assert.h>  /* assert(3), */

#include "path/proc.h"
#include "tracee/tracee.h"
#include "path/path.h"
#include "path/binding.h"

/**
 * This function emulates the @result of readlink("@base/@component")
 * with respect to @tracee, where @base belongs to "/proc" (according
 * to @comparison).  This function returns -errno on error, an enum
 * @action otherwise (c.f. above).
 *
 * Unlike readlink(), this function includes the nul terminating byte
 * to @result.
 */
Action readlink_proc(const Tracee *tracee, char result[PATH_MAX],
			const char base[PATH_MAX], const char component[NAME_MAX],
			Comparison comparison)
{
	const Tracee *known_tracee;
	char proc_path[64]; /* 64 > sizeof("/proc//fd/") + 2 * sizeof(#ULONG_MAX) */
	int status;
	pid_t pid;

	assert(comparison == compare_paths("/proc", base));

	/* Remember: comparison = compare_paths("/proc", base)  */
	switch (comparison) {
	case PATHS_ARE_EQUAL:
		/* Substitute "/proc/self" with "/proc/<PID>".  */
		if (strcmp(component, "self") != 0)
			return DEFAULT;

		status = snprintf(result, PATH_MAX, "/proc/%d", tracee->pid);
		if (status < 0 || status >= PATH_MAX)
			return -EPERM;

		return CANONICALIZE;

	case PATH1_IS_PREFIX:
		/* Handle "/proc/<PID>" below, where <PID> is process
		 * monitored by PRoot.  */
		break;

	default:
		return DEFAULT;
	}

	pid = atoi(base + strlen("/proc/"));
	if (pid == 0)
		return DEFAULT;

	/* Handle links in "/proc/<PID>/".  */
	status = snprintf(proc_path, sizeof(proc_path), "/proc/%d", pid);
	if (status < 0 || (size_t) status >= sizeof(proc_path))
		return -EPERM;

	comparison = compare_paths(proc_path, base);
	switch (comparison) {
	case PATHS_ARE_EQUAL:
		known_tracee = get_tracee(tracee, pid, false);
		if (known_tracee == NULL)
			return DEFAULT;

#define SUBSTITUTE(name, string)				\
		do {						\
			if (strcmp(component, #name) != 0)	\
				break;				\
								\
			status = strlen(string);		\
			if (status >= PATH_MAX)			\
				return -EPERM;			\
								\
			strncpy(result, string, status + 1);	\
			return CANONICALIZE;			\
		} while (0)

		/* Substitute link "/proc/<PID>/???" with the content
		 * of tracee->???.  */
		SUBSTITUTE(exe, known_tracee->exe);
		SUBSTITUTE(cwd, known_tracee->fs->cwd);
		SUBSTITUTE(root, get_root(known_tracee));
#undef SUBSTITUTE
		return DEFAULT;

	case PATH1_IS_PREFIX:
		/* Handle "/proc/<PID>/???" below.  */
		break;

	default:
		return DEFAULT;
	}

	/* Handle links in "/proc/<PID>/fd/".  */
	status = snprintf(proc_path, sizeof(proc_path), "/proc/%d/fd", pid);
	if (status < 0 || (size_t) status >= sizeof(proc_path))
		return -EPERM;

	comparison = compare_paths(proc_path, base);
	switch (comparison) {
		char *end_ptr;

	case PATHS_ARE_EQUAL:
		/* Sanity check: a number is expected.  */
		errno = 0;
		(void) strtol(component, &end_ptr, 10);
		if (errno != 0 || end_ptr == component)
			return -EPERM;

		/* Don't dereference "/proc/<PID>/fd/???" now: they
		 * can point to anonymous pipe, socket, ...  otherwise
		 * they point to a path already canonicalized by the
		 * kernel.
		 *
		 * Note they are still correctly detranslated in
		 * syscall/exit.c if a monitored process uses
		 * readlink() against any of them.  */
		status = snprintf(result, PATH_MAX, "%s/%s", base, component);
		if (status < 0 || status >= PATH_MAX)
			return -EPERM;

		return DONT_CANONICALIZE;

	default:
		break;
	}

	return DEFAULT;
}

/**
 * This function emulates the @result of readlink("@referer") with
 * respect to @tracee, where @referer is a strict subpath of "/proc".
 * This function returns -errno if an error occured, the length of
 * @result if the readlink was emulated, 0 otherwise.
 *
 * Unlike readlink(), this function includes the nul terminating byte
 * to @result (but this byte is not counted in the returned value).
 */
ssize_t readlink_proc2(const Tracee *tracee, char result[PATH_MAX], const char referer[PATH_MAX])
{
	Action action;
	char base[PATH_MAX];
	char *component;

	/* Sanity check.  */
	if (strnlen(referer, PATH_MAX) >= PATH_MAX)
		return -ENAMETOOLONG;

	assert(compare_paths("/proc", referer) == PATH1_IS_PREFIX);

	/* It's safe to use strrchr() here since @referer was
	 * previously canonicalized.  */
	strcpy(base, referer);
	component = strrchr(base, '/');

	/* These cases are not possible: @referer is supposed to be a
	 * canonicalized subpath of "/proc".  */
	assert(component != NULL && component != base);

	component[0] = '\0';
	component++;
	if (component[0] == '\0')
		return 0;

	action = readlink_proc(tracee, result, base, component, PATH1_IS_PREFIX);
	return (action == CANONICALIZE ? strlen(result) : 0);
}

```

`app/src/main/jni/path/proc.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef PROC_H
#define PROC_H

#include <limits.h>

#include "tracee/tracee.h"
#include "path/path.h"

/* Action to do after a call to readlink_proc().  */
typedef enum {
	DEFAULT,           /* Nothing special to do, treat it as a regular link.  */
	CANONICALIZE,      /* The symlink was dereferenced, now canonicalize it.  */
	DONT_CANONICALIZE, /* The symlink shouldn't be dereferenced nor canonicalized.  */
} Action;


extern Action readlink_proc(const Tracee *tracee, char result[PATH_MAX], const char path[PATH_MAX],
			const char component[NAME_MAX],	Comparison comparison);

extern ssize_t readlink_proc2(const Tracee *tracee, char result[PATH_MAX], const char path[PATH_MAX]);

#endif /* PROC_H */

```

`app/src/main/jni/path/temp.c`:

```c
#include <sys/types.h>  /* stat(2), opendir(3), */
#include <sys/stat.h>   /* stat(2), chmod(2), */
#include <unistd.h>     /* stat(2), rmdir(2), unlink(2), readlink(2), */
#include <errno.h>      /* errno(2), */
#include <dirent.h>     /* readdir(3), opendir(3), */
#include <string.h>     /* strcmp(3), */
#include <stdlib.h>     /* free(3), getenv(3), */
#include <stdio.h>      /* P_tmpdir, */
//#include <talloc.h>     /* talloc(3), */

//#include "cli/note.h"
#include "constant.h"

/**
 * Return the path to a directory where temporary files should be
 * created.
 */
const char *get_temp_directory()
{
	//TODO android下临时目录肯定不一样
    LOGE("get_temp_directory");
	return "get_temp_directory";
//	static const char *temp_directory = NULL;
//	char *tmp;
//
//	if (temp_directory != NULL)
//		return temp_directory;
//
//	temp_directory = getenv("PROOT_TMP_DIR");
//	if (temp_directory == NULL) {
//		temp_directory = P_tmpdir;
//		return temp_directory;
//	}
//
//	tmp = realpath(temp_directory, NULL);
//	if (tmp == NULL) {
//		note(NULL, WARNING, SYSTEM,
//			"can't canonicalize %s, using %s instead of PROOT_TMP_DIR",
//			temp_directory, P_tmpdir);
//
//		temp_directory = P_tmpdir;
//		return temp_directory;
//	}
//
//	temp_directory = talloc_strdup(talloc_autofree_context(), tmp);
//	if (temp_directory == NULL)
//		temp_directory = tmp;
//	else
//		free(tmp);
//
//	return temp_directory;
}

/**
 * Handle the return of d_type = DT_UNKNOWN by readdir(3)
 * Not all filesystems support returning d_type in readdir(3)
 */
static int get_dtype(struct dirent *de)
{
	int dtype = de ? de->d_type : DT_UNKNOWN;
	struct stat st;

	if (dtype != DT_UNKNOWN)
		return dtype;
	if (lstat(de->d_name, &st))
		return dtype;
	if (S_ISREG(st.st_mode))
		return DT_REG;
	if (S_ISDIR(st.st_mode))
		return DT_DIR;
	if (S_ISLNK(st.st_mode))
		return DT_LNK;
	return dtype;
}

/**
 * Remove recursively the content of the current working directory.
 * This latter has to lie in temp_directory (ie. "/tmp" on most
 * systems).  This function returns -1 if a fatal error occured
 * (ie. the recursion must be stopped), the number of non-fatal errors
 * otherwise.
 *
 * WARNING: this function changes the current working directory for
 * the calling process.
 */
static int clean_temp_cwd()
{
    LOGE("clean_temp_cwd")
    return 0;
//	const char *temp_directory = get_temp_directory();
//	const size_t length_temp_directory = strlen(temp_directory);
//	char *prefix = NULL;
//	int nb_errors = 0;
//	DIR *dir = NULL;
//	int status;
//
//	prefix = talloc_size(NULL, length_temp_directory + 1);
//	if (prefix == NULL) {
//		note(NULL, WARNING, INTERNAL, "can't allocate memory");
//		nb_errors++;
//		goto end;
//	}
//
//	/* Sanity check: ensure the current directory lies in
//	 * "/tmp".  */
//	status = readlink("/proc/self/cwd", prefix, length_temp_directory);
//	if (status < 0) {
//		note(NULL, WARNING, SYSTEM, "can't readlink '/proc/self/cwd'");
//		nb_errors++;
//		goto end;
//	}
//	prefix[status] = '\0';
//
//	if (strncmp(prefix, temp_directory, length_temp_directory) != 0) {
//		note(NULL, ERROR, INTERNAL,
//			"trying to remove a directory outside of '%s', "
//			"please report this error.\n", temp_directory);
//		nb_errors++;
//		goto end;
//	}
//
//	dir = opendir(".");
//	if (dir == NULL) {
//		note(NULL, WARNING, SYSTEM, "can't open '.'");
//		nb_errors++;
//		goto end;
//	}
//
//	while (1) {
//		struct dirent *entry;
//
//		errno = 0;
//		entry = readdir(dir);
//		if (entry == NULL)
//			break;
//
//		if (   strcmp(entry->d_name, ".")  == 0
//		    || strcmp(entry->d_name, "..") == 0)
//			continue;
//
//		status = chmod(entry->d_name, 0700);
//		if (status < 0) {
//			note(NULL, WARNING, SYSTEM, "cant chmod '%s'", entry->d_name);
//			nb_errors++;
//			continue;
//		}
//
//		if (get_dtype(entry) == DT_DIR) {
//			status = chdir(entry->d_name);
//			if (status < 0) {
//				note(NULL, WARNING, SYSTEM, "can't chdir '%s'", entry->d_name);
//				nb_errors++;
//				continue;
//			}
//
//			/* Recurse.  */
//			status = clean_temp_cwd();
//			if (status < 0) {
//				nb_errors = -1;
//				goto end;
//			}
//			nb_errors += status;
//
//			status = chdir("..");
//			if (status < 0) {
//				note(NULL, ERROR, SYSTEM, "can't chdir to '..'");
//				nb_errors = -1;
//				goto end;
//			}
//
//			status = rmdir(entry->d_name);
//		}
//		else {
//			status = unlink(entry->d_name);
//		}
//		if (status < 0) {
//			note(NULL, WARNING, SYSTEM, "can't remove '%s'", entry->d_name);
//			nb_errors++;
//			continue;
//		}
//	}
//	if (errno != 0) {
//		note(NULL, WARNING, SYSTEM, "can't readdir '.'");
//		nb_errors++;
//	}
//
//end:
//	TALLOC_FREE(prefix);
//
//	if (dir != NULL)
//		(void) closedir(dir);

//	return nb_errors;
}

/**
 * Remove recursively @path.  This latter has to be a directory lying
 * in temp_directory (ie. "/tmp" on most systems).  This function
 * returns -1 on error, otherwise 0.
 */
static int remove_temp_directory2(const char *path)
{
    LOGE("remove_temp_directory2")
    return 0;
//	int result;
//	int status;
//	char *cwd;
//
//#ifdef __ANDROID__
//	cwd = malloc(PATH_MAX);
//	getcwd(cwd, PATH_MAX);
//#else
//	cwd = get_current_dir_name();
//#endif
//
//	status = chmod(path, 0700);
//	if (status < 0) {
//		note(NULL, ERROR, SYSTEM, "can't chmod '%s'", path);
//		result = -1;
//		goto end;
//	}
//
//	status = chdir(path);
//	if (status < 0) {
//		note(NULL, ERROR, SYSTEM, "can't chdir to '%s'", path);
//		result = -1;
//		goto end;
//	}
//
//	status = clean_temp_cwd();
//	result = (status == 0 ? 0 : -1);
//
//	/* Try to remove path even if something went wrong.  */
//	status = chdir("..");
//	if (status < 0) {
//		note(NULL, ERROR, SYSTEM, "can't chdir to '..'");
//		result = -1;
//		goto end;
//	}
//
//	status = rmdir(path);
//	if (status < 0) {
//		note(NULL, ERROR, SYSTEM, "cant remove '%s'", path);
//		result = -1;
//		goto end;
//	}
//
//end:
//	if (cwd != NULL) {
//		status = chdir(cwd);
//		if (status < 0) {
//			result = -1;
//			note(NULL, ERROR, SYSTEM, "can't chdir to '%s'", cwd);
//		}
//		free(cwd);
//	}
//
//	return result;
}

/**
 * Like remove_temp_directory2() but always return 0.
 *
 * Note: this is a talloc destructor.
 */
static int remove_temp_directory(char *path)
{
	(void) remove_temp_directory2(path);
	return 0;
}

/**
 * Remove the file @path.  This function always returns 0.
 *
 * Note: this is a talloc destructor.
 */
static int remove_temp_file(char *path)
{
	int status;

	status = unlink(path);
	if (status < 0)
//		note(NULL, ERROR, SYSTEM, "can't remove '%s'", path);
    LOGE( "can't remove '%s'", path)

	return 0;
}

/**
 * Create a path name with the following format:
 * "/tmp/@prefix-$PID-XXXXXX".  The returned C string is either
 * auto-freed if @context is NULL.  This function returns NULL if an
 * error occurred.
 */
char *create_temp_name(void *context, const char *prefix)
{
    LOGE("create_temp_name ----")
    return "create_temp_name";
//	const char *temp_directory = get_temp_directory();
//	char *name;
//
//	if (context == NULL)
//		context = talloc_autofree_context();
//
//	name = talloc_asprintf(context, "%s/%s-%d-XXXXXX", temp_directory, prefix, getpid());
//	if (name == NULL) {
//		note(NULL, ERROR, INTERNAL, "can't allocate memory");
//		return NULL;
//	}
//
//	return name;
}

/**
 * Create a directory that will be automatically removed either on
 * PRoot termination if @context is NULL, or once its path name
 * (attached to @context) is freed.  This function returns NULL on
 * error, otherwise the absolute path name to the created directory
 * (@prefix-ed).
 */
const char *create_temp_directory(void *context, const char *prefix)
{
    LOGE("create_temp_directory");
    return "create_temp_directory";
//	char *name;
//
//	name = create_temp_name(context, prefix);
//	if (name == NULL)
//		return NULL;
//
//	name = mkdtemp(name);
//	if (name == NULL) {
//		note(NULL, ERROR, SYSTEM, "can't create temporary directory");
//		note(NULL, INFO, USER, "Please set PROOT_TMP_DIR env. variable "
//			"to an alternate location (with write permission).");
//		return NULL;
//	}
//
//	talloc_set_destructor(name, remove_temp_directory);
//
//	return name;
}

/**
 * Create a file that will be automatically removed either on PRoot
 * termination if @context is NULL, or once its path name (attached to
 * @context) is freed.  This function returns NULL on error,
 * otherwise the absolute path name to the created file (@prefix-ed).
 */
const char *create_temp_file(void *context, const char *prefix)
{
    LOGE("create_temp_file")
    return "create_temp_file";
//	char *name;
//	int fd;
//
//	name = create_temp_name(context, prefix);
//	if (name == NULL)
//		return NULL;
//
//	fd = mkstemp(name);
//	if (fd < 0) {
//		note(NULL, ERROR, SYSTEM, "can't create temporary file");
//		note(NULL, INFO, USER, "Please set PROOT_TMP_DIR env. variable "
//			"to an alternate location (with write permission).");
//		return NULL;
//	}
//	close(fd);
//
//	talloc_set_destructor(name, remove_temp_file);
//
//	return name;
}

/**
 * Like create_temp_file() but returns an open file stream to the
 * created file.  It's up to the caller to close returned stream.
 */
FILE* open_temp_file(void *context, const char *prefix)
{
    LOGE("open_temp_file")
    return NULL;
//	char *name;
//	FILE *file;
//	int fd;
//
//	name = create_temp_name(context, prefix);
//	if (name == NULL)
//		return NULL;
//
//	fd = mkstemp(name);
//	if (fd < 0)
//		goto error;
//
//	talloc_set_destructor(name, remove_temp_file);
//
//	file = fdopen(fd, "w");
//	if (file == NULL)
//		goto error;
//
//	return file;
//
//error:
//	if (fd >= 0)
//		close(fd);
//	note(NULL, ERROR, SYSTEM, "can't create temporary file");
//	note(NULL, INFO, USER, "Please set PROOT_TMP_DIR env. variable "
//		"to an alternate location (with write permission).");
//	return NULL;
}

```

`app/src/main/jni/path/temp.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef TEMP_H
#define TEMP_H

//#include <talloc.h>

extern char *create_temp_name(void *context, const char *prefix);
extern const char *create_temp_directory(void *context, const char *prefix);
extern const char *create_temp_file(void *context, const char *prefix);
extern FILE* open_temp_file(void *context, const char *prefix);
extern const char *get_temp_directory();

#endif /* TEMP_H */

```

`app/src/main/jni/test/ptrace/inject.cpp`:

```cpp
/* Copyright (c) 2015, Simone 'evilsocket' Margaritelli
   Copyright (c) 2015-2019, Jorrit 'Chainfire' Jongma
   See LICENSE file for details */

// interesting info re:debug http://stackoverflow.com/questions/18577956/how-to-use-ptrace-to-get-a-consistent-view-of-multiple-threads

#include <asm/ptrace.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/uio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <assert.h>
#include <string.h>
#include <dlfcn.h>
#include <stdarg.h>
#include <dirent.h>
#include <elf.h>
#include <stdbool.h>
#include <time.h>

#include "inject.h"
#include <elf.h>

//const char* _libinject_log_tag = "InjectVM/Injector";
//int _libinject_log = 1;

//void libinject_log(const char* log_tag) {
//    _libinject_log_tag = log_tag;
//    _libinject_log = log_tag == NULL ? 0 : 1;
//}

pid_t _pid;
void *_dlopen;
void *_dlerror;
void *_calloc;
void *_free;

typedef void (*remote_stop_t)();
remote_stop_t remote_stop_ptr = NULL;

// ptrace wrapper with some error checking.
static long trace(const char* debug, int request, void *addr = NULL, size_t data = 0) {
    errno = 0;
    long ret = 0;
    for (int i = 0; i < 10; i++) {
        INJECTLOG("_PID:%d",_pid);
        ret = ptrace(request, _pid, (caddr_t) addr, (void *) data);
        if (ret == -1 && (errno == EBUSY || errno == EFAULT || errno == ESRCH)) {
            char eb[16];
            char rb[16];

            const char* e = NULL;
            const char* r = NULL;

            switch (errno) {
            case ESRCH: e = "ESRCH"; break;
            default: snprintf(eb, sizeof(eb), "%d", errno); e = eb;
            }

            switch (request) {
            case PTRACE_PEEKTEXT: r = "PTRACE_PEEKTEXT"; break;
            case PTRACE_PEEKDATA: r = "PTRACE_PEEKDATA"; break;
            case PTRACE_POKETEXT: r = "PTRACE_POKETEXT"; break;
            case PTRACE_POKEDATA: r = "PTRACE_POKEDATA"; break;
            case PTRACE_CONT: r = "PTRACE_CONT"; break;
            case PTRACE_KILL: r = "PTRACE_KILL"; break;
            case PTRACE_SINGLESTEP: r = "PTRACE_SINGLESTEP"; break;
#if defined(PTRACE_GETREGS)
            case PTRACE_GETREGS: r = "PTRACE_GETREGS"; break;
#endif
#if defined(PTRACE_SETREGS)
            case PTRACE_SETREGS: r = "PTRACE_SETREGS"; break;
#endif
#if defined(PTRACE_GETFPREGS)
            case PTRACE_GETFPREGS: r = "PTRACE_GETFPREGS"; break;
#endif
#if defined(PTRACE_SETFPREGS)
            case PTRACE_SETFPREGS: r = "PTRACE_SETFPREGS"; break;
#endif
            case PTRACE_ATTACH: r = "PTRACE_ATTACH"; break;
            case PTRACE_DETACH: r = "PTRACE_DETACH"; break;
            case PTRACE_SYSCALL: r = "PTRACE_SYSCALL"; break;
            case PTRACE_SETOPTIONS: r = "PTRACE_SETOPTIONS"; break;
            case PTRACE_GETEVENTMSG: r = "PTRACE_GETEVENTMSG"; break;
            case PTRACE_GETSIGINFO: r = "PTRACE_GETSIGINFO"; break;
            case PTRACE_SETSIGINFO: r = "PTRACE_SETSIGINFO"; break;
#if defined(PTRACE_GETREGSET)
            case PTRACE_GETREGSET: r = "PTRACE_GETREGSET"; break;
#endif
#if defined(PTRACE_SETREGSET)
            case PTRACE_SETREGSET: r = "PTRACE_SETREGSET"; break;
#endif
            default: snprintf(rb, sizeof(rb), "%d", request); r = rb;
            }

            INJECTLOG("ptrace [%s] error [%s] on request [%s]", debug, e, r);
        }
        if (ret == -1 && (errno == ESRCH)) {
            INJECTLOG("ptrace remote_stop/retry");
            if (remote_stop_ptr != NULL) {
                remote_stop_ptr();
            }
        } else {
            break;
        }
    }
    return ret;
}

/*
 * This method will open /proc/<pid>/maps and search for the specified
 * library base address.
 */
static uintptr_t findLibrary(const char *library, pid_t pid) {
    char filename[0xFF] = { 0 }, buffer[1024] = { 0 };
    FILE *fp = NULL;
    uintptr_t address = 0;

    sprintf(filename, "/proc/%d/maps", pid == -1 ? _pid : pid);

    fp = fopen(filename, "rt");
    if (fp == NULL) {
        INJECTLOG("fopen error");
        goto done;
    }

    while (fgets(buffer, sizeof(buffer), fp)) {
        if (strstr(buffer, library)) {
            address = (uintptr_t) strtoul(buffer, NULL, 16);
            goto done;
        }
    }

    done:

    if (fp) {
        fclose(fp);
    }

    return address;
}

/*
 * Compute the delta of the local and the remote modules and apply it to
 * the local address of the symbol ... BOOM, remote symbol address!
 */
static void* remote_findFunction(const char* library, void* local_addr) {
    uintptr_t local_handle = findLibrary( library, getpid() );
    uintptr_t remote_handle = findLibrary( library, -1 );
    uintptr_t remote_addr = (uintptr_t)local_addr + remote_handle - local_handle;
    return (void*)remote_addr;
}

static uint64_t ms() {
    struct timespec spec;
    clock_gettime(CLOCK_MONOTONIC, &spec);
    return (spec.tv_sec * 1000) + (spec.tv_nsec / 1.0e6);
}

/*
 * Make sure the remote process is stopped, or we get ESRCH errors
 */
static void remote_stop() {
    INJECTLOG( "remote_stop" );
    kill( _pid, SIGSTOP );

    int status;
    int ret;
    uint64_t start = ms();
    while ( (ret = waitpid( _pid, &status, WUNTRACED || WNOHANG )) != -1 ) {
        if (ret == _pid) {
            if (WIFSIGNALED(status)) {
                trace ( "remote_stop", PTRACE_CONT, NULL, WTERMSIG(status));
            } else if (WIFSTOPPED(status)) {
                break;
            } else if (WIFEXITED(status)) {
                break;
            }
        } else if (ms() - start > 128) {
            // assume stopped before remote_stop() was called, 128ms is long
            break;
        }
        usleep(1);
    }
    INJECTLOG( "/remote_stop" );
}

/*
* Read 'blen' bytes from the remote process at 'addr' address.
*/
static bool remote_read(const char* debug, size_t addr, unsigned char *buf, size_t blen){
    remote_stop();

    size_t i = 0;
    long ret = 0;

    for( i = 0; i < blen; i += sizeof(size_t) ){
       ret = trace( debug, PTRACE_PEEKTEXT, (void *)(addr + i) );
       if( ret == -1 ) {
           return false;
       }

       memcpy( &buf[i], &ret, sizeof(ret) );
    }

    return true;
}

/*
 * Write 'blen' bytes to the remote process at 'addr' address.
 */
static bool remote_write(const char* debug, size_t addr, unsigned char *buf, size_t blen) {
    remote_stop();

    size_t i = 0;
    long ret;

    // make sure the buffer is word aligned
    char *ptr = (char *) malloc(blen + blen % sizeof(size_t));
    memcpy(ptr, buf, blen);

    for (i = 0; i < blen; i += sizeof(size_t)) {
        ret = trace( debug, PTRACE_POKETEXT, (void *) (addr + i), *(size_t *) &ptr[i] );
        if (ret == -1) {
            free(ptr);
            return false;
        }
    }

    free(ptr);

    return true;
}

// Get remote registers
void trace_getregs(const char* debug, struct pt_regs * regs) {
#if defined (__aarch64__) || defined(__x86_64__)
    uintptr_t regset = NT_PRSTATUS;
    struct iovec ioVec;

    ioVec.iov_base = regs;
    ioVec.iov_len = sizeof(*regs);
    trace( debug, PTRACE_GETREGSET, (void*)regset, (size_t)&ioVec );
#else
    trace( debug, PTRACE_GETREGS, 0, (size_t)regs );
#endif
}

// Set remote registers
static void trace_setregs(const char* debug, struct pt_regs * regs) {
#if defined (__aarch64__) || defined(__x86_64__)
    uintptr_t regset = NT_PRSTATUS;
    struct iovec ioVec;

    ioVec.iov_base = regs;
    ioVec.iov_len = sizeof(*regs);
    trace( debug, PTRACE_SETREGSET, (void*)regset, (size_t)&ioVec );
#else
    trace( debug, PTRACE_SETREGS, 0, (size_t)regs );
#endif
}

/*
 * Remotely call the remote function given its address, the number of
 * arguments and the arguments themselves.
 */
static uintptr_t remote_call(void *function, int nargs, ...) {
#if defined(__arm__) || defined(__aarch64__) || defined(__i386__) || defined(__x86_64__)
    remote_stop();

    struct pt_regs regs, rbackup;

    // get registers and backup them
    trace_getregs( "backup", &regs );
    memcpy( &rbackup, &regs, sizeof(struct pt_regs) );

    // start copying parameters
    va_list vl;
    va_start(vl,nargs);

    // push parameters into registers and stacks, setup registers to perform the call

#if defined(__arm__) || defined(__aarch64__)
    // fill R0-Rx with the first 4 (32-bit) or 8 (64-bit) parameters
    for ( int i = 0; ( i < nargs ) && ( i < PARAMS_IN_REGS ); ++i ) {
        regs.uregs[i] = va_arg( vl, uintptr_t );
    }

    // push remaining parameters onto stack
    if (nargs > PARAMS_IN_REGS) {
        regs.ARM_sp -= sizeof(uintptr_t) * (nargs - PARAMS_IN_REGS);
        uintptr_t stack = regs.ARM_sp;
        for ( int i = PARAMS_IN_REGS; i < nargs; ++i ) {
            uintptr_t arg = va_arg( vl, uintptr_t );
            remote_write( "params", (size_t)stack, (uint8_t *)&arg, sizeof(uintptr_t) );
            stack += sizeof(uintptr_t);
        }
    }

    // return address to catch
    regs.ARM_lr = 0;

    // function address to call
    regs.ARM_pc = (uintptr_t)function;

    // setup the current processor status register
    if ( regs.ARM_pc & 1 ) {
        // thumb
        regs.ARM_pc &= (~1u);
        regs.ARM_cpsr |= CPSR_T_MASK;
    } else {
        // arm
        regs.ARM_cpsr &= ~CPSR_T_MASK;
    }
#elif defined(__i386__)
    // push all params onto stack
    regs.esp -= sizeof(uintptr_t) * nargs;
    uintptr_t stack = regs.esp;
    for( int i = 0; i < nargs; ++i ) {
        uintptr_t arg = va_arg( vl, uintptr_t );
        remote_write( "params", (size_t)stack, (uint8_t *)&arg, sizeof(uintptr_t) );
        stack += sizeof(uintptr_t);
    }

    // return address to catch
    uintptr_t tmp_addr = 0;
    regs.esp -= sizeof(uintptr_t);
    remote_write( "return", (size_t)regs.esp, (uint8_t *)&tmp_addr, sizeof(uintptr_t) );

    // function address to call
    regs.eip = (uintptr_t)function;
#elif defined(__x86_64__)
    // align, rsp - 8 must be a multiple of 16 at function entry point
    {
        uintptr_t space = sizeof(uintptr_t);
        if (nargs > 6) space += sizeof(uintptr_t) * (nargs - 6);
        while (((regs.rsp - space - 8) & 0xF) != 0) regs.rsp--;
    }

    // fill [RDI, RSI, RDX, RCX, R8, R9] with the first 6 parameters
    for ( int i = 0; ( i < nargs ) && ( i < 6 ); ++i ) {
        uintptr_t arg = va_arg( vl, uintptr_t );
        switch (i) {
        case 0: regs.rdi = arg; break;
        case 1: regs.rsi = arg; break;
        case 2: regs.rdx = arg; break;
        case 3: regs.rcx = arg; break;
        case 4: regs.r8 = arg; break;
        case 5: regs.r9 = arg; break;
        }
    }

    // push remaining parameters onto stack
    if (nargs > 6) {
        regs.rsp -= sizeof(uintptr_t) * (nargs - 6);
        uintptr_t stack = regs.rsp;
        for( int i = 6; i < nargs; ++i ) {
            uintptr_t arg = va_arg( vl, uintptr_t );
            remote_write( "params", (size_t)stack, (uint8_t *)&arg, sizeof(uintptr_t) );
            stack += sizeof(uintptr_t);
        }
    }

    // return address to catch
    uintptr_t tmp_addr = 0;
    regs.rsp -= sizeof(uintptr_t);
    remote_write( "return", (size_t)regs.rsp, (uint8_t *)&tmp_addr, sizeof(uintptr_t) );

    // function address to call
    regs.rip = (uintptr_t)function;

    // may be needed
    regs.rax = 0;
    regs.orig_rax = 0;
#endif

    // end of parameters
    va_end(vl);

    // do the call
    trace_setregs( "call", &regs );
    trace( "call", PTRACE_CONT );

    // catch the SIGSEGV caused by the 0 return address
    int status;
    while ( waitpid( _pid, &status, WUNTRACED ) == _pid ) {
        if ( WIFSTOPPED(status) && (WSTOPSIG(status) == SIGSEGV) ) {
            break;
        }
        trace( "waitpid", PTRACE_CONT );
    }

    // get registers again for return value
    trace_getregs( "return", &regs );

    // restore original registers state
    trace_setregs( "restore", &rbackup );

    // continue execution
    trace( "continue", PTRACE_CONT );

#if defined(__arm__) || defined(__aarch64__)
    return regs.ARM_r0;
#elif defined(__i386__)
    return regs.eax;
#elif defined(__x86_64__)
    return regs.rax;
#endif
    return 0;
#else
#error ARCHITECTURE NOT SUPPORTED
#endif
}

// Allocate memory in remote process
static uintptr_t remote_calloc(size_t nmemb, size_t size) {
    return remote_call(_calloc, 2, nmemb, size);
}

// Free remotely allocated memory.
static void remote_free(uintptr_t p) {
    remote_call(_free, 1, p);
}

// Copy a given string into the remote process memory.
static uintptr_t remote_string(const char *s) {
    uintptr_t mem = remote_calloc(strlen(s) + 1, 1);

    remote_write( "string", mem, (unsigned char *) s, strlen(s) + 1);

    return mem;
}

// Remotely force the target process to dlopen a library.
static uintptr_t remote_dlopen(const char *libname) {
    uintptr_t pmem = remote_string(libname);

    uintptr_t plib = remote_call(_dlopen, 2, pmem, 0);

    remote_free(pmem);

    return plib;
}

// Get remote dlerror
static void remote_dlerror(char* error, int size) {
    uintptr_t e = remote_call(_dlerror, 0);
    remote_read("dlerror", e, (unsigned char*)error, size - 1);
}

// Find pid for process
//pid_t libinject_find_pid_of(const char* process) {
//    int id;
//    pid_t pid = -1;
//    DIR* dir;
//    FILE *fp;
//    char filename[32];
//    char cmdline[256];
//
//    struct dirent * entry;
//
//    if (process == NULL)
//        return -1;
//
//    dir = opendir("/proc");
//    if (dir == NULL)
//        return -1;
//
//    while ((entry = readdir(dir)) != NULL) {
//        id = atoi(entry->d_name);
//        if (id != 0) {
//            sprintf(filename, "/proc/%d/cmdline", id);
//            fp = fopen(filename, "r");
//            if (fp) {
//                fgets(cmdline, sizeof(cmdline), fp);
//                fclose(fp);
//
//                if (strcmp(process, cmdline) == 0) {
//                    /* process found */
//                    pid = id;
//                    break;
//                }
//            }
//        }
//    }
//
//    closedir(dir);
//    return pid;
//}

// Load library in process pid, resolves JavaVM and passes it and param to loaded library, returns 0 on success
//int libinject_injectvm(pid_t pid, char* library, char* param) {
//    remote_stop_ptr = remote_stop;
//    __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm");
//    int ret = 1;
//    _pid = pid;
//
//    // attach to target process
//    if ( trace( "attach", PTRACE_ATTACH ) != -1) {
//        __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm 1");
//        // stop entire process, including non-main threads
//        kill( _pid, SIGSTOP);
//
//        // wait until we're stopped
//        remote_stop();
//
//        /* First thing first, we need to search these functions into the target
//         * process address space.
//         */
//
//        /* We can resolve the references to LIBC easily, but dl* is tricky. On older Android
//         * versions, libdl.so is commonly not loaded by the linker, and our dl* functions
//         * come directly from the linker.
//         *
//         * On newer Android versions, libdl.so is directly loaded and dl* come from there.
//         *
//         * On even newer Android versions, the linker/libc/libdl have moved from /system to /bionic
//         */
//        const char* libc = access( PATH_LIBC_BIONIC, R_OK ) == 0 ? PATH_LIBC_BIONIC : PATH_LIBC;
//        const char* libdl = access( PATH_LIBDL_BIONIC, R_OK ) == 0 ? PATH_LIBDL_BIONIC : PATH_LIBDL;
//        const char* linker = access( PATH_LINKER_BIONIC, R_OK ) == 0 ? PATH_LINKER_BIONIC : PATH_LINKER;
//
//        _calloc = remote_findFunction( libc, (void *) calloc );
//        _free = remote_findFunction( libc, (void *) free );
//        if ((findLibrary( libdl, -1 ) != 0) && (findLibrary( libdl, _pid ) != 0)) {
//            void* handle = dlopen( libdl, RTLD_LAZY );
//            _dlopen = remote_findFunction( libdl, dlsym( handle, "dlopen" ) );
//            _dlerror = remote_findFunction( libdl, dlsym( handle, "dlerror" ) );
//            dlclose( handle );
//        } else {
//            _dlopen = remote_findFunction( linker, (void *) dlopen );
//            _dlerror = remote_findFunction( linker, (void *) dlerror );
//        }
//        __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm 2");
//        // Resolve android::AndroidRuntime::mJavaVM, this is tricky from the payload because
//        // of linker namespaces (you can't load the lib, dlsym doesn't work right, and the location
//        // of the variable in memory is different between Android versions), but no such issue
//        // exists from this injector.
//        void* runtime = dlopen( PATH_LIBANDROID_RUNTIME, RTLD_LAZY );
//        //android8.0.0/xref/frameworks/base/core/jni/include/android_runtime/AndroidRuntime.h?r=71044fe7#142 JavaVM的指针
//        //android::AndroidRuntime::mJavaVM
//        void* javavm = dlsym( runtime, "_ZN7android14AndroidRuntime7mJavaVME" );
//        void* _javavm = remote_findFunction( PATH_LIBANDROID_RUNTIME, javavm );
//        dlclose(runtime);
//        __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm 3");
//        INJECTLOG( "calloc:%p free:%p dlopen:%p dlerror:%p javavm:%p", _calloc, _free, _dlopen, _dlerror, _javavm );
//
//        // once we have the addresses, we can proceed to inject
//        if ( remote_dlopen(library) != 0 ) {
//
//            // call OnInject(_javavm, param)
//            void* payload = dlopen( library, RTLD_LAZY );
//            void* oninject = dlsym( payload, "OnInject" );
//            void* _oninject = remote_findFunction( library, oninject );
//            INJECTLOG( "oninject:%p", _oninject );
//
//            if ((oninject != NULL) && (_oninject != NULL)) {
//                uintptr_t pmem = remote_string(param);
//                remote_call(_oninject, 2, _javavm, pmem);
//                remote_free(pmem);
//                ret = 0;
//            }
//        } else {
//            char error[1024] = { 0 };
//            remote_dlerror(error, 1024);
//            INJECTLOG( "dlopen failed: %s", error );
//        }
//        __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm 4");
//        // detach from target process
//        remote_stop();
//        //https://man7.org/linux/man-pages/man2/ptrace.2.html
//        //执行detach之前,需要tracee是ptrace_stop的状态(参见man文档)
//        trace( "detach", PTRACE_DETACH );
//        __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm 5");
//        // let all threads in the target process continue
//        kill( _pid, SIGCONT );
//    } else {
//        INJECTLOG( "Failed to attach to process %d", _pid);
//    }
//    __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm 6");
//    return ret;
//}

```

`app/src/main/jni/test/ptrace/inject.h`:

```h
/* Copyright (c) 2015, Simone 'evilsocket' Margaritelli
   Copyright (c) 2015-2019, Jorrit 'Chainfire' Jongma
   See LICENSE file for details */

#ifndef INJECT_H
#define INJECT_H

#include <unistd.h>
#include <android/log.h>
#include <stdio.h>


#if defined(__arm__)
#define CPSR_T_MASK ( 1u << 5 )
#define PARAMS_IN_REGS 4
#elif defined(__aarch64__)
#define CPSR_T_MASK ( 1u << 5 )
#define PARAMS_IN_REGS 8
#define pt_regs user_pt_regs
#define uregs regs
#define ARM_pc pc
#define ARM_sp sp
#define ARM_cpsr pstate
#define ARM_lr regs[30]
#define ARM_r0 regs[0]
#endif

#if defined(__LP64__)
#define PATH_LINKER_BIONIC "/bionic/bin/linker64"
#define PATH_LIBDL_BIONIC "/bionic/lib64/libdl.so"
#define PATH_LIBC_BIONIC "/bionic/lib64/libc.so"
#define PATH_LINKER "/system/bin/linker64"
#define PATH_LIBDL "/system/lib64/libdl.so"
#define PATH_LIBC "/system/lib64/libc.so"
#define PATH_LIBANDROID_RUNTIME "/system/lib64/libandroid_runtime.so"
#else
#define PATH_LINKER_BIONIC "/bionic/bin/linker"
#define PATH_LIBDL_BIONIC "/bionic/lib/libdl.so"
#define PATH_LIBC_BIONIC "/bionic/lib/libc.so"
#define PATH_LINKER "/system/bin/linker"
#define PATH_LIBDL "/system/lib/libdl.so"
#define PATH_LIBC "/system/lib/libc.so"
#define PATH_LIBANDROID_RUNTIME "/system/lib/libandroid_runtime.so"
#endif


// No need to reference manually, use HOOKLOG
//extern const char* _libinject_log_tag;
//extern int _libinject_log;

// Pass NULL to disable logging
//void libinject_log(const char* log_tag);


#define INJECTLOG(F,...)   { printf(F,##__VA_ARGS__);printf("\n");}
//#define INJECTLOG(F,...) {}

// Find pid for process
//pid_t libinject_find_pid_of(const char* process);

extern pid_t _pid;

// Load library in process pid, returns 0 on success
int libinject_injectvm(pid_t pid, char* library, char* param);

void trace_getregs(const char* debug, struct pt_regs * regs);

#endif

```

`app/src/main/jni/test/ptrace/ptracedemo.cpp`:

```cpp
//
// Created by mac on 2023/12/29.
//


//TODO 后面考虑 改成直接用印象笔记的那个demo
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/ptrace.h>

#include <sys/wait.h>
#include <linux/uio.h>
#include <linux/elf.h>
#include "inject.h"

#define LOGD(...) { printf(__VA_ARGS__);printf("\n");}

static bool ignore_sigstop = false;
static pid_t child_pid = -1;

int syscall_status = 0;

#define IS_IN_SYSENTER() (syscall_status == 0)
#define IS_IN_SYSEXIT() (!IS_IN_SYSENTER())

void translate_syscall(int* restart_how){
    struct pt_regs regs;
    bool is_enter_stage = IS_IN_SYSENTER();
    long long sysnum = 0;
//    trace_getregs( "getregs", &regs );
#if defined(__arm__)
    //not impl!!!!
    sysnum = regs.uregs[7];
#elif  defined(__aarch64__)
    struct iovec ioVec;
    ioVec.iov_base = &regs;
    ioVec.iov_len = sizeof(regs);
    long status = ptrace(PTRACE_GETREGSET,child_pid,NT_PRSTATUS,&ioVec);
    if (status < 0){
        LOGD("PTRACE_GETREGSET,%d,%s",errno, strerror(errno))
    }
    sysnum = regs.uregs[8];
#endif

    LOGD("regs,r0:%llu,r1:%llu,r2:%llu,r3:%llu,sysnum:%llu",regs.uregs[1],regs.uregs[1],regs.uregs[2],regs.uregs[3],sysnum)
    if (is_enter_stage){
        syscall_status = 1;
        *restart_how = PTRACE_SYSCALL;
    }else {
        syscall_status = 0;
    }
}


void event_loop(){
    int status;
    while (1){
        pid_t pid;
        int signal;
        int tracee_status;
        pid = waitpid(-1, &tracee_status, __WALL);
        if (WIFSIGNALED(tracee_status)) { //Returns true if the process was terminated by a signal.
            LOGD("WIFSIGNALED")
            break;
        } else if (WIFSTOPPED(tracee_status)) { //tracee产生了一个一个信号 Returns true if the process was stopped by a signal.
            signal = (tracee_status & 0xfff00) >> 8;
            LOGD("WIFSTOPPED,%d",signal)
            int restart_how = PTRACE_CONT;
            switch (signal) {
                case SIGTRAP: {
                    static bool deliver_sigtrap = false;

                    const unsigned long default_ptrace_options = (
                            PTRACE_O_TRACESYSGOOD	|
                            PTRACE_O_TRACEFORK	|
                            PTRACE_O_TRACEVFORK	|
                            PTRACE_O_TRACEVFORKDONE	|
                            PTRACE_O_TRACEEXEC	|
                            PTRACE_O_TRACECLONE	|
                            PTRACE_O_TRACEEXIT);
                    if (deliver_sigtrap)
                        break;  /* Deliver this signal as-is.  */
                    deliver_sigtrap = true;
                    //TODO 启用seccomp mode 2
                    status = ptrace(PTRACE_SETOPTIONS, pid, NULL,
                                    default_ptrace_options);
                    if (status < 0) {
                        LOGD("ptrace(PTRACE_SETOPTIONS)")
                        exit(EXIT_FAILURE);
                    }
                }
                case SIGTRAP |0x80:
                    signal = 0;
                    translate_syscall(&restart_how);
                    break;
                case SIGSTOP:
                    if (!ignore_sigstop){
                        LOGD("ignore sigstop -----------------")
                        ignore_sigstop = true;
                        signal = 0;
                    }
                    break;
            }
            status =  ptrace(restart_how,pid,NULL,signal);
            //获取寄存器的值
            if (status < 0){
                LOGD("PTRACE_SYSCALL error,%d,%s",errno, strerror(errno))
                break;
            }
        } else if (WIFEXITED(status)) { //Returns true if the process exited normally.
            LOGD("WIFEXITED,%d",pid)
            break;
        }else{
//            LOGD("not support ----------------,%d",status)
        }
    }
}

int main(){
    LOGD("in ptracedemo,%d",getpid());
    int status;
    int ret;
    pid_t child = fork();
    if (child == 0){
        //child
        status = ptrace(PTRACE_TRACEME,0,NULL,NULL);
        if (status < 0){
            LOGD("ptrace error,%d,%s",errno, strerror(errno));
            return 0;
        }
        LOGD("before sigstop----")
        kill(getpid(),SIGSTOP);
        LOGD("after sigstop----")
        char *newargv[] = { NULL, "hello", "world", NULL };
        char *newenviron[] = { NULL };

        newargv[0] = "./myecho";

        execve("./myecho", newargv, newenviron);
        perror("execve");   /* execve() returns only on error */
        exit(EXIT_FAILURE);
    }else if (child > 0){
        LOGD("child pid:%d",child)
        //parent
        //waitpid 、wait
        //记录子进程的pid,方便inject.cpp使用
        _pid = child;
        child_pid = child;
        event_loop();
    }else{
        //error
        LOGD("fork error,%d,%s",errno,strerror(errno));
    }
    return 0;
}

```

`app/src/main/res/drawable-v24/ic_launcher_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>
```

`app/src/main/res/drawable/ic_launcher_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#3DDC84"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
</vector>

```

`app/src/main/res/drawable/list_item_bg_single_selected.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape android:shape="rectangle"
  xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/window_bg" />
</shape>


  
```

`app/src/main/res/drawable/list_item_bg_single_selector.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector
  xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="false" android:state_pressed="false" android:drawable="@drawable/list_item_bg_single_unselected" />
    <item android:state_pressed="true" android:drawable="@drawable/list_item_bg_single_selected" />
    <item android:state_focused="true" android:drawable="@drawable/list_item_bg_single_selected" />
    <item android:drawable="@drawable/list_item_bg_single_unselected" />
</selector>

```

`app/src/main/res/drawable/list_item_bg_single_unselected.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape android:shape="rectangle"
  xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/background_gray" />
</shape>

```

`app/src/main/res/layout/activity_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:background="@color/window_bg"
    android:orientation="vertical"
    >

    <ScrollView
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:focusable="true"
        android:focusableInTouchMode="true"
        android:visibility="visible"
        >

        <LinearLayout
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            >

            <LinearLayout style="@style/list_item_bg_single_label_layout">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginLeft="12.0dip"
                    android:layout_weight="1.0"
                    android:text="@string/app_name"
                    android:textColor="@color/title_text_gray"
                    android:textSize="18sp"/>

                <TextView
                    android:id="@+id/main_version"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="12.0dip"
                    android:text="v1.0"
                    android:textColor="@color/text_gray"
                    android:textSize="12.0dip"/>
            </LinearLayout>

            <LinearLayout android:id="@+id/item_unittest_source" style="@style/list_item_bg_single_layout">
                <TextView style="@style/founction_item_text" android:text="@string/title_unittest_source" />
                <ImageView style="@style/founction_item_image" />
            </LinearLayout>

        </LinearLayout>
    </ScrollView>
</LinearLayout>

```

`app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="window_bg">#ffffffff</color>
    <color name="window_bg_dark">#77000000</color>
    <color name="console_bg">#66000000</color>
    <color name="text_gray">#66000000</color>
    <color name="title_text_gray">#ff000000</color>
    <color name="title_text_gray2">#99000000</color>
    <color name="divider_gray">#66ffffff</color>
    <color name="white">#ffffffff</color>
    <color name="red">#ffff0000</color>
    <color name="shape_line">#ffcccccc</color>
    <color name="background_gray">#ffc4c4c4</color>
</resources>

```

`app/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="app_name">Abyss</string>
    <string name="title_unittest_source">UnitTest</string>
</resources>
```

`app/src/main/res/values/styles.xml`:

```xml
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme">
        <item name="android:windowActionBar">false</item>
        <item name="android:windowNoTitle">true</item>
        <item name="android:colorPrimary">@color/window_bg</item>
        <item name="android:colorPrimaryDark">@color/window_bg</item>
        <item name="android:colorAccent">@color/window_bg</item>
    </style>

    <style name="AppDarkTheme">
        <item name="android:windowActionBar">false</item>
        <item name="android:windowNoTitle">true</item>
        <item name="android:colorPrimary">@color/window_bg_dark</item>
        <item name="android:colorPrimaryDark">@color/window_bg_dark</item>
        <item name="android:colorAccent">@color/window_bg_dark</item>
    </style>

    <!--
    Base application theme, dependent on API level. This theme is replaced
    by AppBaseTheme from res/values-vXX/styles.xml on newer devices.
    -->
    <style name="AppBaseTheme" parent="android:Theme.Light.NoTitleBar">
        <!--
            Theme customizations available in newer API levels can go in
            res/values-vXX/styles.xml, while customizations related to
            backward-compatibility can go here.
        -->
        <item name="android:colorPrimary">@color/window_bg</item>
        <item name="android:colorPrimaryDark">@color/window_bg</item>
        <item name="android:colorAccent">@color/window_bg</item>
    </style>

    <style name="tv_label">
        <item name="android:layout_width">80dp</item>
        <item name="android:layout_height">30dp</item>
        <item name="android:ems">7</item>
        <item name="android:layout_marginTop">2dp</item>
        <item name="android:padding">2dp</item>
    </style>

    <style name="match_parent">
        <item name="android:layout_width">match_parent</item>
        <item name="android:layout_height">wrap_content</item>
    </style>

    <style name="list_item_bg_layout">
        <item name="android:orientation">vertical</item>
        <item name="android:layout_width">fill_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_marginLeft">8.0dip</item>
        <item name="android:layout_marginTop">6.0dip</item>
        <item name="android:layout_marginRight">8.0dip</item>
        <item name="android:layout_marginBottom">6.0dip</item>
    </style>

    <style name="list_item_bg_label_layout">
        <item name="android:orientation">vertical</item>
        <item name="android:layout_width">fill_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_marginLeft">8.0dip</item>
        <item name="android:layout_marginTop">6.0dip</item>
        <item name="android:layout_marginRight">8.0dip</item>
        <item name="android:layout_marginBottom">6.0dip</item>
    </style>

    <style name="list_item_bg_base_layout">
        <item name="android:orientation">horizontal</item>
        <item name="android:layout_width">fill_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:gravity">center_vertical</item>
        <item name="android:layout_margin">4.0dip</item>
        <item name="android:focusable">true</item>
        <item name="android:clickable">true</item>
    </style>

    <style name="founction_item_text" >
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:paddingTop">16dp</item>
        <item name="android:paddingBottom">16dp</item>
        <item name="android:paddingRight">8dp</item>
        <item name="android:paddingLeft">8dp</item>
        <item name="android:layout_weight">1.0</item>
        <item name="android:textColor">@color/title_text_gray</item>
        <item name="android:textSize">16sp</item>
    </style>
    <style name="founction_item_image" >
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_marginRight">12dp</item>
    </style>

    <style name="list_item_bg_single_label_layout">
        <item name="android:orientation">horizontal</item>
        <item name="android:layout_width">fill_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:gravity">center_vertical</item>
        <item name="android:paddingTop">16.0dip</item>
        <item name="android:paddingBottom">16.0dip</item>
        <item name="android:focusable">false</item>
        <item name="android:clickable">false</item>
    </style>

    <style name="list_item_bg_single_layout" parent="@style/list_item_bg_base_layout">
        <item name="android:background">@drawable/list_item_bg_single_selector</item>
    </style>

    <style name="bottom_button_label_layout">
        <item name="android:orientation">vertical</item>
        <item name="android:layout_width">fill_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:focusable">false</item>
        <item name="android:clickable">false</item>
    </style>

    <style name="CheckListDialog" parent="android:style/Theme.Dialog">
        <item name="android:background">@android:color/transparent</item>
        <item name="android:windowBackground">@android:color/transparent</item>
        <item name="android:windowNoTitle">true</item>
    </style>

    <style name="CheckListDialogItem">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
    </style>

    <style name="TitleText">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:textSize">16sp</item>
        <item name="android:textColor">@color/title_text_gray</item>
        <item name="android:textStyle">bold</item>
        <item name="android:padding">5dp</item>
    </style>

    <style name="ItemText">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:textSize">14sp</item>
        <item name="android:textColor">@color/title_text_gray</item>
        <item name="android:textStyle">bold</item>
        <item name="android:padding">5dp</item>
    </style>

    <style name="ItemLayout">
        <item name="android:layout_width">fill_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:orientation">horizontal</item>
        <item name="android:gravity">center_vertical</item>
        <item name="android:padding">5dp</item>
    </style>

    <style name="ItemLayoutSub">
        <item name="android:layout_width">fill_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:orientation">horizontal</item>
        <item name="android:gravity">center_vertical</item>
        <item name="android:paddingLeft">5dp</item>
    </style>

    <style name="SubTitleText">
        <item name="android:layout_width">0dp</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_weight">2</item>
        <item name="android:textSize">14sp</item>
        <item name="android:textColor">@color/title_text_gray</item>
        <item name="android:paddingTop">2dp</item>
        <item name="android:paddingBottom">2dp</item>
    </style>

    <style name="VersionText">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_weight">2</item>
        <item name="android:textSize">14sp</item>
        <item name="android:padding">5dp</item>
    </style>

    <style name="ContentText">
        <item name="android:layout_width">0dp</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_weight">3</item>
        <item name="android:textSize">14sp</item>
        <item name="android:textColor">@color/text_gray</item>
        <item name="android:paddingTop">2dp</item>
        <item name="android:paddingBottom">2dp</item>
    </style>

    <style name="Divider">
        <item name="android:layout_width">match_parent</item>
        <item name="android:layout_height">1dp</item>
        <item name="android:layout_margin">5dp</item>
        <item name="android:background">@color/divider_gray</item>
    </style>

    <style name="mySwitch">
        <item name="android:layout_width">0dp</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_weight">3</item>
        <item name="android:textColor">@color/text_gray</item>
        <item name="android:paddingTop">5dp</item>
        <item name="android:paddingBottom">5dp</item>
        <item name="android:checked">true</item>
    </style>

</resources>

```

`app/src/main/res/xml/backup_rules.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older that API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>
```

`app/src/main/res/xml/data_extraction_rules.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>
```

`build.gradle`:

```gradle
buildscript {
    repositories {
        maven { url 'https://maven.aliyun.com/repository/public' }
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url 'https://www.jitpack.io' }
        maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }
    }

    dependencies {
//        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.6"
        classpath 'com.android.tools.build:gradle:4.2.0'
    }
}

allprojects {
    repositories {
        maven { url 'https://maven.aliyun.com/repository/public' }
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url 'https://www.jitpack.io' }
        maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
```

`build.sh`:

```sh
#/bin/bash
set -e
#brew install cmake
#cd out/
#make clean
#ABI=arm64-v8a  #armeabi-v7a
#MINSDKVERSION=23
#NDK=/Users/mac/Library/Android/sdk/ndk/25.2.9519653
#
#CMAKE_ROOT=/Users/mac/Library/Android/sdk/cmake/3.6.0
#CMAKE_ROOT=/Users/mac/Library/Android/sdk/cmake/3.6.0

#使用android下的cmake，不要使用系统的cmake
#DCMAKE_LIBRARY_OUTPUT_DIRECTORY DCMAKE_RUNTIME_OUTPUT_DIRECTORY 输出目录
#DCMAKE_MAKE_PROGRAM make程序
#https://developer.android.com/ndk/guides/cmake?hl=zh-cn#command-line_1
#$CMAKE_ROOT/bin/cmake \
#    -DCMAKE_TOOLCHAIN_FILE=$NDK/build/cmake/android.toolchain.cmake \
#    -DANDROID_ABI=$ABI \
#    -DANDROID_PLATFORM=android-$MINSDKVERSION \
#    -DCMAKE_BUILD_TYPE=Debug \
#    -DCMAKE_ANDROID_NDK=$NDK \
#    -DCMAKE_ANDROID_ARCH_ABI=$ABI \
#    -DCMAKE_SYSTEM_NAME=Android \
#    -DCMAKE_LIBRARY_OUTPUT_DIRECTORY=bin\
#    -DCMAKE_RUNTIME_OUTPUT_DIRECTORY=bin\
#    -DCMAKE_MAKE_PROGRAM=$CMAKE_ROOT/bin/ninja \
#    -DCMAKE_SYSTEM_VERSION=$MINSDKVERSION  ../app/src/main/jni/
#
#make
#adb push bin/testsvc /data/local/tmp

#构建loader
#ndk 14
#cd app/src/main/jni
#ndk-build
#cd ..
#adb push ./libs/arm64-v8a/loader /data/local/tmp/loader_arm64
#adb push ./libs/armeabi-v7a/loader /data/local/tmp/loader_arm32
#adb push ./libs/arm64-v8a/loader /sdcard/loader_arm64
#adb push ./libs/armeabi-v7a/loader /sdcard/loader_arm32
#rm -rf ./libs
#rm -rf ./obj
#cd ../../../

#会同时编译arm32和arm64
./gradlew build
adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/testsvc /data/local/tmp

#推送源码
adb shell rm -rf /data/local/tmp/source
adb push ./app/src/main/jni/ /data/local/tmp/source
#set substitute-path  /Users/mac/dev/code/InterceptSysCall/app/src/main/jni /data/local/tmp/source


#adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/crashdemo /data/local/tmp
#adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/test1 /data/local/tmp
#adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/test2 /data/local/tmp
adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/usedemo /data/local/tmp

adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/myecho /data/local/tmp
adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/execvedemo /data/local/tmp
adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/execvedemo /sdcard/

#adb push ./app/build/intermediates/cmake/debug/obj/armeabi-v7a/myecho /data/local/tmp
#adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/execvedemo /data/local/tmp

adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/ptracedemo /data/local/tmp
adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/ptraceemudemo /data/local/tmp
adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/ptraceemudemo /sdcard/
#adb push ./app/build/intermediates/cmake/debug/obj/armeabi-v7a/ptraceemudemo /data/local/tmp

adb push ./app/build/intermediates/cmake/debug/obj/arm64-v8a/multithreaddemo /data/local/tmp

#adb shell kill -9  `adb shell ps -ef|grep testsvc$ | awk '{print $2}' | head -1`
#find . -name liblibrary_static.a
#./app/.cxx/Debug/5b471h49/armeabi-v7a/liblibrary_static.a
#./app/.cxx/Debug/5b471h49/arm64-v8a/liblibrary_static.a
# set substitute-path  /Users/mac/dev/code/InterceptSysCall/app/src/main/jni /data/local/tmp/source
```

`config.gradle`:

```gradle
ext {

    // 安装包版本配置
    compileSdk = 32
//    minSdk = 28 //9.0
    minSdk = 23
    targetSdk = 32
    javaVersion = JavaVersion.VERSION_1_8
    applicationId = 'com.iofomo.intercept_syscall'
    versionCode = 1
    versionName = '1.0.0'

    // 第三方库配置
    dependencies = [
            'appcompat': 'androidx.appcompat:appcompat:1.4.1',
            'material': 'com.google.android.material:material:1.5.0',
            'constraintlayout': 'androidx.constraintlayout:constraintlayout:2.1.3',
            //工具库
            'utilcodex':'com.blankj:utilcodex:1.31.1'
    ]
}
```

`gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true
```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
#Mon Dec 11 23:11:12 CST 2023
distributionBase=GRADLE_USER_HOME
distributionUrl=https\://services.gradle.org/distributions/gradle-6.9.2-all.zip
distributionPath=wrapper/dists
zipStorePath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME

```

`gradlew`:

```
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`library/build.gradle`:

```gradle
apply plugin: 'com.android.library'

android {
    buildToolsVersion "30.0.3"
    compileSdkVersion 30

    defaultConfig {
        minSdkVersion 29
        targetSdkVersion 30

        externalNativeBuild {
            cmake {
                cppFlags ''
            }
        }
        ndk {
            abiFilters 'armeabi-v7a', 'arm64-v8a'
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            jniDebuggable true
            debuggable true
        }
        debug {
            jniDebuggable true
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    externalNativeBuild {
        cmake {
            path file('src/main/jni/CMakeLists.txt')
            version '3.6.0'
        }
    }
}

dependencies {
}
```

`library/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
```

`library/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.iofomo.opensrc.abyss.sdk">

    <application>
        <service
            android:process=":MTSTCProc"
            android:name="com.iofomo.opensrc.abyss.sdk.component.MTSTCService"
            android:enabled="true"
            android:exported="false"/>

        <provider
            android:name="com.iofomo.opensrc.abyss.sdk.component.MTSTCProvider"
            android:authorities="${applicationId}.component.MTSTCProvider"
            android:enabled="true"
            android:exported="false"
            android:process=":MTSTCProc"
            />
    </application>

</manifest>
```

`library/src/main/java/com/iofomo/opensrc/abyss/sdk/Logger.java`:

```java
package com.iofomo.opensrc.abyss.sdk;

import android.util.Log;

public class Logger {
    private static  String sDefTag = "undefine";

    public static final void setDefTag(String defTag){
        sDefTag = defTag;
    }


    public static void d(String TAG,String message){
        Log.e(TAG,message);
    }

    public static void e(String TAG,String message){
        Log.e(TAG,message);
    }

    public static void d(String message){
        Log.e(sDefTag,message);
    }

    public static void e(String message){
        Log.e(sDefTag,message);
    }
}

```

`library/src/main/java/com/iofomo/opensrc/abyss/sdk/Native.java`:

```java
package com.iofomo.opensrc.abyss.sdk;

/**
 * tracer(ptrace所在进程)
 */
public class Native {
    static {
        System.loadLibrary("abyss");
    }
    public static native void init();
    public static native int trace_pid(int pid);
}

```

`library/src/main/java/com/iofomo/opensrc/abyss/sdk/Nativee.java`:

```java
package com.iofomo.opensrc.abyss.sdk;

import android.content.Context;
import android.net.Uri;
import android.os.Bundle;
import android.os.Process;
import android.util.Log;

import com.iofomo.opensrc.abyss.sdk.component.MTSTCProvider;

/**
 * tracee (应用业务所在进程)
 */
public class Nativee {
    private static final int ERRNO_MAX = 133;

    private static final int FILTERED_FUNC_OPEN = 0x1;
    private static final int FILTERED_FUNC_CLOSE = 0x2;

    static {
        System.loadLibrary("abyss");
    }

    /**
     *  初始化
     */
    private static native boolean before_attach();
    private static native boolean tracee_init_native(int flags);


    public static  void tracee_init(){
        tracee_init_native(FILTERED_FUNC_OPEN|FILTERED_FUNC_CLOSE);
    }

    public static  void tracee_init(int flags){
        tracee_init_native(flags);
    }

    /**
     *
     * @param appCtx
     * @return 0 成功,非0 失败
     */
    public static int attachMe(Context appCtx){
        Nativee.before_attach();
        Bundle extras = new Bundle();
        extras.putInt(MTSTCProvider.PARAMS_NEW_COMPONENT_PID, Process.myPid());
        int code = 0;
        Log.e("zzz","attachMe:" + "content://"+appCtx.getPackageName()+".component.MTSTCProvider/");
        Bundle ret = appCtx.getContentResolver().call(Uri.parse("content://"+appCtx.getPackageName()+".component.MTSTCProvider/"), MTSTCProvider.METHOD_ATTACH_NEW_COMPONENT,null,extras);
        if (ret != null){
            code = ret.getInt(MTSTCProvider.RET_PARAMS_CODE,-1);
            if (code == 0){
                Logger.d("trace success,pid:"+Process.myPid());
            }else{
                Logger.e("trace error,pid:"+Process.myPid()+",code:"+code);
            }
        }else {
            Logger.e("trace error bundle is null,pid:"+Process.myPid());
            return ERRNO_MAX + 1;
        }
        Logger.d("tracee init");
        return code;
    }

}

```

`library/src/main/java/com/iofomo/opensrc/abyss/sdk/component/MTSTCProvider.java`:

```java
package com.iofomo.opensrc.abyss.sdk.component;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;

import com.iofomo.opensrc.abyss.sdk.Logger;
import com.iofomo.opensrc.abyss.sdk.Native;

public class MTSTCProvider extends ContentProvider {
    private static final String TAG = MTSTCProvider.class.getSimpleName();


    public static final String METHOD_ATTACH_NEW_COMPONENT = "1";
    public static final String PARAMS_NEW_COMPONENT_PID = "params_pid";
    public static final String RET_PARAMS_CODE = "ret_params_code";
    public MTSTCProvider() {

    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        // Implement this to handle requests to delete one or more rows.
        throw new UnsupportedOperationException("Not yet implemented");
    }

    @Override
    public String getType(Uri uri) {
        // at the given URI.
        throw new UnsupportedOperationException("Not yet implemented");
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        throw new UnsupportedOperationException("Not yet implemented");
    }

    @Override
    public boolean onCreate() {
        MTSTCService.start(getContext());
        Native.init();
        return true;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection,
                        String[] selectionArgs, String sortOrder) {
        throw new UnsupportedOperationException("Not yet implemented");
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection,
                      String[] selectionArgs) {
        throw new UnsupportedOperationException("Not yet implemented");
    }

    @Override
    public Bundle call(String method, String arg, Bundle extras) {
        if (METHOD_ATTACH_NEW_COMPONENT.equals(method)){
            int pid = extras.getInt(PARAMS_NEW_COMPONENT_PID,-1);
            if (pid == -1) return null;
//            Logger.d(TAG,"waitForDebugger --------------------");
//            Debug.waitForDebugger();
            Logger.e(TAG,"pid:"+pid);

            int retCode = Native.trace_pid(pid);
            Logger.d(TAG,"retCode:"+retCode);
            Bundle ret = new Bundle();
            ret.putInt(RET_PARAMS_CODE,retCode);
            return ret;
        }
        return super.call(method, arg, extras);
    }


}
```

`library/src/main/java/com/iofomo/opensrc/abyss/sdk/component/MTSTCService.java`:

```java
package com.iofomo.opensrc.abyss.sdk.component;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.IBinder;

import com.iofomo.opensrc.abyss.sdk.Logger;

public class MTSTCService extends Service {
    private static final String TAG = "PtService";

    public static void start(Context ctx){
        Intent intent = new Intent(ctx, MTSTCService.class);
        if (ctx.startService(intent) == null){
            Logger.e("startService error---");
        }
    }

    public MTSTCService() {
    }

    @Override
    public void onCreate() {
        super.onCreate();
        Logger.d(TAG,"onCreate----");
    }

    @Override
    public IBinder onBind(Intent intent) {
        Logger.d(TAG,"onBind----");
        return null;
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Logger.d(TAG,"onStartCommand----");
        return START_STICKY;
    }
}
```

`library/src/main/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := loader

LOCAL_C_INCLUDES :=  $(LOCAL_PATH)/.
LOCAL_SRC_FILES := loader/loader.c
LOCAL_CFLAGS :=  -fPIC -ffreestanding -mregparm=3
ifeq ($(TARGET_ARCH_ABI), armeabi-v7a)
    LOCAL_LDFLAGS := -static -nostdlib -Wl,-Ttext=0x10000000,-z,noexecstack
else ifeq ($(TARGET_ARCH_ABI), arm64-v8a)
    LOCAL_LDFLAGS := -static -nostdlib -Wl,-Ttext=0x2000000000,-z,noexecstack
else
endif
include $(BUILD_EXECUTABLE)
```

`library/src/main/jni/Application.mk`:

```mk
APP_ABI := arm64-v8a armeabi-v7a
APP_PLATFORM := android-14

```

`library/src/main/jni/CMakeLists.txt`:

```txt

# For more information about using CMake with Android Studio, read the
# documentation: https://d.android.com/studio/projects/add-native-code.html

# Sets the minimum version of CMake required to build the native library.

cmake_minimum_required(VERSION 3.6.0)

# Declares and names the project.

project("library")

set(CMAKE_ANDROID_ARCH_ABI "armeabi-v7a")
set(CMAKE_ANDROID_ARCH_ABI "arm64-v8a")
# Creates and names a library, sets it as either STATIC
# or SHARED, and provides the relative paths to its source code.
# You can define multiple libraries, and CMake builds them for you.
# Gradle automatically packages shared libraries with your APK.

file(GLOB SOURCE_FILES
        cmn/cmn_vlarray.c
        cmn/cmn_pthread_cond.c
        cmn/cmn_back_call_stack.c
        cmn/cmn_proc.c
        cmn/cmn_utils.c
        ptrace/wait.c
        ptrace/ptrace.c
        syscall/sysnum.c
        syscall/seccomp.c
        syscall/syscall.c
        syscall/enter.c
        syscall/exit.c
        syscall/chain.c
        execve/elf.c
        execve/enter.c
        execve/exit.c
        execve/auxv.c
        execve/shebang.c
        #            execve/aoxp.c
        path/path.c
        path/temp.c
        tracee/mem.c
        tracee/tracee.c
        tracee/reg.c
        tracee/event.c
        library.c
        note.c)





include_directories(.)
include_directories(./tracee)

# Searches for a specified prebuilt library and stores the path as a
# variable. Because CMake includes system libraries in the search path by
# default, you only need to specify the name of the public NDK library
# you want to add. CMake verifies that the library exists before
# completing its build.

find_library( # Sets the name of the path variable.
        log-lib

        # Specifies the name of the NDK library that
        # you want CMake to locate.
        log )

# Specifies libraries CMake should link to your target library. You
# can link multiple libraries, such as libraries you define in this
# build script, prebuilt third-party libraries, or system libraries.



add_library( # Sets the name of the library.
        abyss
        SHARED
        # Provides a relative path to your source file(s).
        ${SOURCE_FILES}
        )

target_link_libraries( # Specifies the target library.
        abyss
        # Links the target library to the log library
        # included in the NDK.
        ${log-lib} )

#----结束生成lirary 库

add_executable(
        testsvc
        test/main.c
        ${SOURCE_FILES}
)

target_link_libraries( # Specifies the target library.
        testsvc

        # Links the target library to the log library
        # included in the NDK.
        ${log-lib} )

#add_executable(
#        crashdemo
#        test/crashdemo.c
#)
#
#add_executable(
#        test1
#        test/test.c
#)
#
#add_executable(
#        test2
#        test/test2.c
#        cmn/cmn_pthread_cond.c
#)
#


add_executable(
        multithreaddemo
        test/multithreaddemo.c
        ${SOURCE_FILES}
)
target_link_libraries( # Specifies the target library.
        multithreaddemo

        # Links the target library to the log library
        # included in the NDK.
        ${log-lib} )

add_executable(
        myecho
        test/myecho.c
)

add_executable(
        fopen_demo
        test/fopen_demo.c
)

add_executable(
        execvedemo
        test/execvedemo.c
        ${SOURCE_FILES}
)
target_link_libraries( # Specifies the target library.
        execvedemo
        # Links the target library to the log library
        # included in the NDK.
        ${log-lib} )


add_executable(
        ptraceemudemo
        test/ptraceemudemo.c
        ${SOURCE_FILES}
)
target_link_libraries( # Specifies the target library.
        ptraceemudemo
        # Links the target library to the log library
        # included in the NDK.
        ${log-lib} )

add_executable(
        ptracedemo
        test/ptrace/ptracedemo.cpp
        test/ptrace/inject.cpp
)
target_link_libraries( # Specifies the target library.
        ptracedemo
        # Links the target library to the log library
        # included in the NDK.
        ${log-lib} )
```

`library/src/main/jni/arch.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef ARCH_H
#define ARCH_H

#ifndef NO_LIBC_HEADER
#include <sys/ptrace.h>    /* linux.git:c0a3a20b  */
#include <linux/audit.h>   /* AUDIT_ARCH_*,  */
#endif

typedef unsigned long word_t;
typedef unsigned char byte_t;

#define SYSCALL_AVOIDER ((word_t) -1)
#define SYSTRAP_NUM SYSARG_NUM
#define STACK_ALIGNMENT 16

#define OFFSETOF_STATX_UID 20
#define OFFSETOF_STATX_GID 24

#if !defined(ARCH_X86_64) && !defined(ARCH_ARM_EABI) && !defined(ARCH_X86) && !defined(ARCH_SH4)
#    if defined(__x86_64__)
#        define ARCH_X86_64 1
#    elif defined(__ARM_EABI__)
#        define ARCH_ARM_EABI 1
#    elif defined(__aarch64__)
#        define ARCH_ARM64 1
#    elif defined(__arm__)
#        error "Only EABI is currently supported for ARM"
#    elif defined(__i386__)
#        define ARCH_X86 1
#    elif defined(__SH4__)
#        define ARCH_SH4 1
#    else
#        error "Unsupported architecture"
#    endif
#endif

/* Architecture specific definitions. */
#if defined(ARCH_X86_64)

    #define SYSNUMS_HEADER1 "syscall/sysnums-x86_64.h"
    #define SYSNUMS_HEADER2 "syscall/sysnums-i386.h"
    #define SYSNUMS_HEADER3 "syscall/sysnums-x32.h"

    #define SYSNUMS_ABI1 sysnums_x86_64
    #define SYSNUMS_ABI2 sysnums_i386
    #define SYSNUMS_ABI3 sysnums_x32

    #undef  SYSTRAP_NUM
    #define SYSTRAP_NUM SYSARG_RESULT
    #define SYSTRAP_SIZE 2

    #define SECCOMP_ARCHS {									\
		{ .value = AUDIT_ARCH_X86_64, .nb_abis = 2, .abis = { ABI_DEFAULT, ABI_3 } },	\
		{ .value = AUDIT_ARCH_I386,   .nb_abis = 1, .abis = { ABI_2 } }, 		\
	}

    #define HOST_ELF_MACHINE {62, 3, 6, 0}
    #define RED_ZONE_SIZE 128
    #define OFFSETOF_STAT_UID_32 24
    #define OFFSETOF_STAT_GID_32 28

    #define LOADER_ADDRESS 0x600000000000
    #define HAS_LOADER_32BIT true

    #define EXEC_PIC_ADDRESS   0x500000000000
    #define INTERP_PIC_ADDRESS 0x6f0000000000
    #define EXEC_PIC_ADDRESS_32   0x0f000000
    #define INTERP_PIC_ADDRESS_32 0xaf000000

#elif defined(ARCH_ARM_EABI)

#define SYSNUMS_HEADER1 "syscall/sysnums-arm.h"
    #define SYSNUMS_ABI1    sysnums_arm

    #define SYSTRAP_SIZE 4

    #define SECCOMP_ARCHS { { .value = AUDIT_ARCH_ARM, .nb_abis = 1, .abis = { ABI_DEFAULT } } }

    #define user_regs_struct user_regs
    #define HOST_ELF_MACHINE {40, 0};
    #define RED_ZONE_SIZE 0
    #define OFFSETOF_STAT_UID_32 0
    #define OFFSETOF_STAT_GID_32 0
    #define EM_ARM 40

    #define LOADER_ADDRESS 0x10000000

    #define EXEC_PIC_ADDRESS   0x0f000000
    #define INTERP_PIC_ADDRESS 0x1f000000

#elif defined(ARCH_ARM64)

    #define SYSNUMS_HEADER1 "syscall/sysnums-arm64.h"
    #define SYSNUMS_HEADER2 "syscall/sysnums-arm.h"

    #define SYSNUMS_ABI1    sysnums_arm64
    #define SYSNUMS_ABI2 sysnums_arm

    #define SYSTRAP_SIZE 4

    #ifndef AUDIT_ARCH_AARCH64
        #define AUDIT_ARCH_AARCH64 (EM_AARCH64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
    #endif

    #define SECCOMP_ARCHS { \
        { .value = AUDIT_ARCH_AARCH64, .nb_abis = 1, .abis = { ABI_DEFAULT } }, \
        { .value = AUDIT_ARCH_ARM, .nb_abis = 1, .abis = { ABI_2 } }                    \
    }

    #define HOST_ELF_MACHINE {183, 0};
    #define RED_ZONE_SIZE 0
    #define OFFSETOF_STAT_UID_32 24
    #define OFFSETOF_STAT_GID_32 28

    #define LOADER_ADDRESS     0x2000000000
    #define EXEC_PIC_ADDRESS   0x3000000000
    #define INTERP_PIC_ADDRESS 0x3f00000000
    #define HAS_POKEDATA_WORKAROUND true

#elif defined(ARCH_X86)

#define SYSNUMS_HEADER1 "syscall/sysnums-i386.h"
    #define SYSNUMS_ABI1    sysnums_i386

    #undef  SYSTRAP_NUM
    #define SYSTRAP_NUM SYSARG_RESULT
    #define SYSTRAP_SIZE 2

    #define SECCOMP_ARCHS { { .value = AUDIT_ARCH_I386, .nb_abis = 1, .abis = { ABI_DEFAULT } } }

    #define HOST_ELF_MACHINE {3, 6, 0};
    #define RED_ZONE_SIZE 0
    #define OFFSETOF_STAT_UID_32 0
    #define OFFSETOF_STAT_GID_32 0

    #define LOADER_ADDRESS 0xa0000000
    #define LOADER_ARCH_CFLAGS -mregparm=3

    #define EXEC_PIC_ADDRESS   0x0f000000
    #define INTERP_PIC_ADDRESS 0xaf000000

#elif defined(ARCH_SH4)

#define SYSNUMS_HEADER1 "syscall/sysnums-sh4.h"
    #define SYSNUMS_ABI1    sysnums_sh4

    #define SYSTRAP_SIZE 2

    #define SECCOMP_ARCHS { }

    #define user_regs_struct pt_regs
    #define HOST_ELF_MACHINE {42, 0};
    #define RED_ZONE_SIZE 0
    #define OFFSETOF_STAT_UID_32 0
    #define OFFSETOF_STAT_GID_32 0
    #define NO_MISALIGNED_ACCESS 1

#else

#error "Unsupported architecture"

#endif

#endif /* ARCH_H */

```

`library/src/main/jni/attribute.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef ATTRIBUTE_H
#define ATTRIBUTE_H

#define UNUSED __attribute__((unused))
#define FORMAT(a, b, c) __attribute__ ((format (a, b, c)))
#define DONT_INSTRUMENT __attribute__((no_instrument_function))
#define PACKED __attribute__((packed))
#define WEAK   __attribute__((weak))

#endif /* ATTRIBUTE_H */

```

`library/src/main/jni/build.h`:

```h
/* This file is auto-generated, edit at your own risk.  */
#ifndef BUILD_H
#define BUILD_H
#undef VERSION
#define VERSION "v5.4.0-5f780cba"
//新的linux api,__ANDROID_API__ >= 23时可以
#define HAVE_PROCESS_VM
#define HAVE_SECCOMP_FILTER

//是否使用模版的loader程序来载入exe
//#define USE_LOADER_EXE

//是否处理系统调用
#define HANDLE_SYSCALL

//仅仅为了方便调试的代码(为了排查问题,可能会拖慢效率)
#define DEBUG_ONLY

//是否启用日志
#define ENABLE_LOG
//使用printf代替android_log_print
//#define LOG_PRINTF

#endif /* BUILD_H */

```

`library/src/main/jni/cmn/cmn_back_call_stack.c`:

```c
//
// Created by mac on 2023/12/15.
//

#include <string.h>
#include <android/log.h>
#include <time.h>
#include <stdio.h>
#include <unistd.h>
#include <malloc.h>
#include <dlfcn.h>
#include "cmn_back_call_stack.h"
#include "constant.h"
#include "mem.h"

#define LOG(...) { __android_log_print(ANDROID_LOG_ERROR,"Native_Stack",__VA_ARGS__);}

typedef struct TraceBuff {
    int depth;
    char* buffer[100];
} TraceBuffInfo;


void print_register_info(const ucontext_t *ucontext) {
#if defined(__aarch64__)
    for (int i = 0; i < 30; ++i) {
        if (i % 4 == 0) {
            LOG("%s", "     ");
        }
        char info[64] = {0};
        sprintf(info, "x%d %016lx ", i, ucontext->uc_mcontext.regs[i]);
        LOG(  "%s", info);
        if ((i + 1) % 4 == 0) {
            LOG( "%s", "\r\n");
        }
    }
    LOG(  "%s", "\r\n");

    char spInfo[64] = {0};
    sprintf(spInfo, "sp %016lx ", ucontext->uc_mcontext.sp);

    char lrInfo[64] = {0};
    sprintf(lrInfo, "lr %016lx ", ucontext->uc_mcontext.regs[30]);

    char pcInfo[64] = {0};
    sprintf(pcInfo, "pc %016lx ", ucontext->uc_mcontext.pc);

    LOG(  "%s%s%s%s\r\n", "     ",spInfo,lrInfo,pcInfo);
#elif defined(__arm__)
    char x0Info[64] = {0};
    sprintf(x0Info, "x0 %08lx ", ucontext->uc_mcontext.arm_r0);
    char x1Info[64] = {0};
    sprintf(x1Info, "x1 %08lx ", ucontext->uc_mcontext.arm_r1);
    char x2Info[64] = {0};
    sprintf(x2Info, "x2 %08lx ", ucontext->uc_mcontext.arm_r2);
    char x3Info[64] = {0};
    sprintf(x3Info, "x3 %08lx ", ucontext->uc_mcontext.arm_r3);
    char x4Info[64] = {0};
    sprintf(x4Info, "x4 %08lx ", ucontext->uc_mcontext.arm_r4);
    char x5Info[64] = {0};
    sprintf(x5Info, "x5 %08lx ", ucontext->uc_mcontext.arm_r5);
    char x6Info[64] = {0};
    sprintf(x6Info, "x6 %08lx ", ucontext->uc_mcontext.arm_r6);
    char x7Info[64] = {0};
    sprintf(x7Info, "x7 %08lx ", ucontext->uc_mcontext.arm_r7);
    char x8Info[64] = {0};
    sprintf(x8Info, "x8 %08lx ", ucontext->uc_mcontext.arm_r8);
    char x9Info[64] = {0};
    sprintf(x9Info, "x9 %08lx ", ucontext->uc_mcontext.arm_r9);
    char x10Info[64] = {0};
    sprintf(x10Info, "x10 %08lx ", ucontext->uc_mcontext.arm_r10);

    char ipInfo[64] = {0};
    sprintf(ipInfo, "ip %08lx ", ucontext->uc_mcontext.arm_ip);
    char spInfo[64] = {0};
    sprintf(spInfo, "sp %08lx ", ucontext->uc_mcontext.arm_sp);
    char lrInfo[64] = {0};
    sprintf(lrInfo, "lr %08lx ", ucontext->uc_mcontext.arm_lr);
    char pcInfo[64] = {0};
    sprintf(pcInfo, "pc %08lx ", ucontext->uc_mcontext.arm_pc);

    LOG("%s%s%s%s%s%s", "     ",x0Info, x1Info, x2Info, x3Info,
                    "\r\n");
            LOG("%s%s%s%s%s%s", "     ", x4Info, x5Info, x6Info, x7Info,
                    "\r\n");
            LOG("%s%s%s%s%s", "     ", x8Info, x9Info, x10Info, "\r\n");
            LOG("%s%s%s%s%s\r\n", "     ", ipInfo, spInfo, lrInfo, pcInfo);
#endif
    return ;
}


_Unwind_Reason_Code my_trace_back_stack(struct _Unwind_Context *context, void *hnd) {
    TraceBuffInfo *traceHandle = (TraceBuffInfo *) hnd;

    _Unwind_Word ip = _Unwind_GetIP(context);
    Dl_info info;
    int res = dladdr((void *) ip, &info);

    if (res == 0) {
        return _URC_END_OF_STACK;
    }

    char *desc = (char *) malloc(1024);
    memset(desc, 0, 1024);
    if (info.dli_fname != NULL) {
        char *symbol = (char *) malloc(256);

        if (info.dli_sname == NULL) {
            strcpy(symbol, "unknown");
        } else {
            sprintf(symbol, "%s+%ld", info.dli_sname,
                    ip - (_Unwind_Word) info.dli_saddr);
        }

#if defined(__arm__)
        sprintf(desc, "     #%02d pc %08lx  %s (%s) \r\n", traceHandle->depth,
                ip - (_Unwind_Word) info.dli_fbase,
                info.dli_fname, symbol);
#elif defined(__aarch64__)
        sprintf(desc, "     #%02d pc %016lx  %s (%s) \r\n", traceHandle->depth,
                ip - (_Unwind_Word) info.dli_fbase,
                info.dli_fname, symbol);
#endif
        free(symbol);
    }

    traceHandle->buffer[traceHandle->depth] = desc;
    ++traceHandle->depth;
    // FIXME: crash if call stack is over 5 on ARM32, unknown reason
#if !defined(__aarch64__) && defined(__arm__)
    if (traceHandle->depth == 5) {
        return _URC_END_OF_STACK;
    }
#endif
    if (traceHandle->depth == 99) {
        return _URC_END_OF_STACK;
    }

    return _URC_NO_REASON;
}

void sig_handler_call_stack(int sig, siginfo_t *info, void *context){
    TraceBuffInfo traceInfo;
    memset(&traceInfo, 0 , sizeof(traceInfo));
    _Unwind_Backtrace(my_trace_back_stack, &traceInfo);


    time_t timep;
    time(&timep);
    char tmp[64];
    char tmp_path[256];
    strftime(tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S%z", localtime(&timep));

    strftime(tmp_path, sizeof(tmp_path), "%Y-%m-%d-%H-%M-%S.txt", localtime(&timep));
//    snprintf(path, sizeof(path), "%s/%s_%s", tombstone_file_path, __PRINTSTR(g_pkg_name), tmp_path);

//    if (elfFile) {
        char processName[256] = {0};
        char cmd[64] = {0};
        sprintf(cmd, "/proc/%d/cmdline", getpid());
        FILE *f = fopen(cmd, "r");
        if (f) {
            size_t size;
            size = fread(processName, sizeof(char), 256, f);
            if (size > 0 && '\n' == processName[size - 1]) {
                processName[size - 1] = '\0';
            }
            fclose(f);
        }

        LOG( "*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\r\n");

        LOG( "Timestamp: %s\r\n", tmp);
        LOG("pid: %d", getpid());
        LOG( ", uid: %d", getuid());
        LOG( ", tid: %d", gettid());
        LOG( ", process: >>> %s <<<\r\n", processName);
        LOG( "signal %d, code %d , fault addr %p\r\n",sig,  info->si_code, info->si_addr);

    print_register_info((const ucontext_t *) context);

        int i = 0;
        while(traceInfo.depth > i){
            LOG("%s", traceInfo.buffer[i]);
            free(traceInfo.buffer[i++]);
        }


        LOG("sig handler print success")
//    }
//    else {
//        __LOGI__("sigHandler_test write fail: %s", strerror(errno))
//    }
//    unregister_sig_handler();
    raise(sig);

    LOG("sig handler end")

}

#if defined(__aarch64__)
void print_remote_call_stack_arm64(const Tracee *tracee){
    struct user_regs_struct regs = tracee->_regs[CURRENT];
    uint64_t* fp = regs.regs[29]; //x29
    LOGD("exception pc:0x%lx,%p,x29:%lx",regs.pc,fp,regs.regs[29])

     while (fp != NULL)
    {
        word_t remote_data =peek_word(tracee,fp + 1);
        //  printf("stack:,fp:%p,lr_addr:%p lr:%lx\n",fp,(fp + 1),*((uint64_t *)(fp + 1)));
        LOGD("bt:0x%lx\n",remote_data);
        fp = peek_word(tracee,fp);
    }
    LOGD("exception print end--------");
}
#endif
```

`library/src/main/jni/cmn/cmn_back_call_stack.h`:

```h
//
// Created by mac on 2023/12/15.
//

#ifndef CMN_BACK_CALL_STACK_H
#define CMN_BACK_CALL_STACK_H
#include <sys/ucontext.h>
#include <unwind.h>
#include <sys/user.h>
#include "tracee/tracee.h"


/**
 * 打印native异常栈
 */
void sig_handler_call_stack(int sig, siginfo_t *info, void *context);

#if defined(__aarch64__)
/**
 *  tracer打印tracee的堆栈
 */
void print_remote_call_stack_arm64(const Tracee *tracee);
#endif

#endif //CMN_BACK_CALL_STACK_H

```

`library/src/main/jni/cmn/cmn_proc.c`:

```c
//
// Created by mac on 2023/12/19.
//

#include <unistd.h>
#include <string.h>
#include "cmn_proc.h"
#include "../constant.h"

void print_maps(char *filter){
    FILE * fp = fopen("/proc/self/maps","r");
    if (!fp){
        LOGE("fp is null")
        return;
    }
    LOGD("start print %d maps,filter:%s",getpid(),filter);
    size_t len = 0;
    ssize_t nread;
    char * line = NULL;

    while ((nread = getline(&line, &len, fp)) != -1) {
//        printf("Retrieved line of length %zu:\n", nread);
        line[nread] = '\0';
        if (filter != NULL && strlen(filter) > 0){
            if (strstr(line,filter) != NULL){
                LOGD("proc_maps:%s",line)
            }
        }else{
            LOGD("proc_maps:%s",line)
        }
    }
    fclose(fp);
    LOGD("end print %d maps",getpid());
}
```

`library/src/main/jni/cmn/cmn_proc.h`:

```h
//
// Created by mac on 2023/12/19.
//

#ifndef  CMN_PROC_H
#define CMN_PROC_H
/**
 * 打印maps
 */
void print_maps(char *filter);
#endif //CMN_PROC_H

```

`library/src/main/jni/cmn/cmn_pthread_cond.c`:

```c
//
// Created by mac on 2023/12/14.
//


#include "cmn_pthread_cond.h"


/**
 * 初始化
 */
void cmn_pt_context_init(struct PCond_Context* ctx){
    pthread_mutex_init(&ctx->mutex, NULL);
    pthread_cond_init(&ctx->cond, NULL);
}

/**
 * 等待事件发生
 */
void cmn_pt_wait(struct  PCond_Context* ctx){
    pthread_mutex_lock(&ctx->mutex);
    pthread_cond_wait(&ctx->cond, &ctx->mutex);
    pthread_mutex_unlock(&ctx->mutex);
}

void cmn_pt_wait2(struct  PCond_Context* ctx,bool (*check)()){
    pthread_mutex_lock(&ctx->mutex);
    if (check()){
        pthread_cond_wait(&ctx->cond, &ctx->mutex);
    }
    pthread_mutex_unlock(&ctx->mutex);
}

/**
 * 通知所有等待线程
 */
int cmn_pt_broadcast(struct PCond_Context* ctx){
    return pthread_cond_broadcast(&ctx->cond);
}

/**
 * 通知第一个等待的线程
 */
int cmn_pt_signal(struct  PCond_Context* ctx){
    return pthread_cond_signal(&ctx->cond);
}

int cmn_pt_signal2(struct  PCond_Context* ctx,bool (*check)()){
    pthread_mutex_lock(&ctx->mutex);
    int ret = 0;
    if (check()){
        ret  =  pthread_cond_signal(&ctx->cond);
    }
    pthread_mutex_unlock(&ctx->mutex);
    return ret;
}


/**
 * 清除资源
 */
int cmn_pt_destroy(struct PCond_Context* ctx){
    return pthread_cond_destroy(&ctx->cond);
}
```

`library/src/main/jni/cmn/cmn_pthread_cond.h`:

```h
//
// Created by mac on 2023/12/14.
//

#ifndef CMN_PTHREAD_COND_H
#define CMN_PTHREAD_COND_H
#include <pthread.h>
#include <stdbool.h>

struct PCond_Context{
    pthread_mutex_t mutex;
    pthread_cond_t cond;
};

/**
 * 初始化
 */
void cmn_pt_context_init(struct PCond_Context* ctx);

/**
 * 等待事件发生
 */
void cmn_pt_wait(struct  PCond_Context* ctx);

void cmn_pt_wait2(struct  PCond_Context* ctx,bool (*check)());

/**
 * 通知所有等待线程
 */
int cmn_pt_broadcast(struct PCond_Context* ctx);

/**
 * 通知第一个等待的线程
 */
int cmn_pt_signal(struct  PCond_Context* ctx);

int cmn_pt_signal2(struct  PCond_Context* ctx,bool (*check)());


 /**
  * 清除资源
  */
 int cmn_pt_destroy(struct PCond_Context* ctx);


#endif //CMN_PTHREAD_COND_H

```

`library/src/main/jni/cmn/cmn_utils.c`:

```c
//
// Created by mac on 2024/1/15.
//

#include "cmn_utils.h"
#include <string.h>
#include <malloc.h>
#include <unistd.h>
#include <fcntl.h> //AT_*

bool cmn_utils_string_starts_With(const char* str,const char* sub_str){
    if (!str) return !sub_str;
    if(!sub_str) return false;
    size_t str_len = strlen(str);
    size_t sub_str_len = strlen(sub_str);
    if (!str_len) return !sub_str_len;
    return strstr(str,sub_str) == str;
}

bool cmn_utils_string_ends_With(const char* str,const char* sub_str){
    if (!str) return !sub_str;
    if(!sub_str) return false;
    size_t str_len = strlen(str);
    size_t sub_str_len = strlen(sub_str);
    if (!str_len) return !sub_str_len;
    if (str_len < sub_str_len) return false;
    return !strncmp(&str[str_len - sub_str_len],sub_str,str_len - sub_str_len);
}


char* cmn_utils_string_replace_With(const char* str,const char* sub_str,const char* rep_str){
    //不支持NULL的替换
    if (!sub_str || !rep_str) return NULL;
    size_t sub_str_len = strlen(sub_str);
    size_t rep_str_len = strlen(rep_str);
    size_t str_len = strlen(str);

    const char* find = strstr(str,sub_str);
    char *ret = NULL;
    if (!find){
        ret = malloc(sizeof(char)*sizeof(str_len + 1));
        strcpy(ret,str);
        return ret;
    }
    ret = malloc(sizeof(char)*sizeof(str_len + rep_str_len - sub_str_len));
    strncpy(ret,str,find - str);
    strncpy(&ret[find - str],rep_str,rep_str_len);
    strcpy(&ret[find - str + rep_str_len],&find[sub_str_len]);
    return ret;
}




ssize_t cmn_utils_readlink(pid_t pid,int fd, char* buf,size_t max_size) {
    int ret = 0;
    sprintf(buf, "/proc/%d/fd/%d",pid,fd);
    ret = readlinkat(AT_FDCWD, buf, buf, max_size);
    if (0 <= ret) {
        buf[ret] = '\0';
    }
    return ret;
}

int cmn_utils_string_split(char* src, char ch, char* items[], int items_len) {
    if (!src || !items) return 0;

    int i = 0, cnt = 0;
    memset(items, 0, items_len*sizeof(char*));
    while (i < items_len && *src) {
        if (!items[i]) {
            ++ cnt;
            items[i] = src;
        }
        if (*src == ch) {
            ++ i;
            *src = '\0';
        }
        ++ src;
    }
    return cnt;
}
//字符串hash函数
uint32_t cmn_utils_str_hash(const char* str){
    uint32_t h = 0, g;
    const char* ptr = str;
    while (*ptr) {
    h = (h << 4) + *ptr++;
    g = h & 0xf0000000;
    h ^= g;
    h ^= g >> 24;
    }
    return h;
}
```

`library/src/main/jni/cmn/cmn_utils.h`:

```h
//
// Created by mac on 2024/1/15.
//

#ifndef  CMN_UTILS_H
#define CMN_UTILS_H
#include <stdbool.h>
#include <stddef.h>
#include <sys/types.h>

bool cmn_utils_string_starts_With(const char* str,const char* sub_str);
bool cmn_utils_string_ends_With(const char* str,const char* sub_str);
char* cmn_utils_string_replace_With(const char* str,const char* sub_str,const char* rep_str);
ssize_t cmn_utils_readlink(pid_t pid,int fd, char* buf,size_t max_size);
int cmn_utils_string_split(char* src, char ch, char* items[], int items_len);
uint32_t cmn_utils_str_hash(const char* str);

#endif //CMN_UTILS_H

```

`library/src/main/jni/cmn/cmn_vlarray.c`:

```c
//
// Created by mac on 2023/12/13.
//

#include "cmn_vlarray.h"
#include <stdlib.h>

static int head_size(){
    return sizeof(int);
}

static void* org_ptr(void * ctx){
    return ctx - head_size();
}

static void* arr_ptr(void* org_ptr){
    return org_ptr + head_size();
}
static void set_arr_length(void* org_ptr,int size){
    int* size_ptr = org_ptr;
    *size_ptr = size;
}

void * vl_new_array(int ele_size,int count){
    int cap = ele_size * count + head_size();
    void * ptr = malloc(cap);
    if (!ptr) return NULL;
    set_arr_length(ptr,count);
    return arr_ptr(ptr);
}

//获取数组长度
int vl_array_length(void * ctx){
    int * ptr = org_ptr(ctx);
    return *ptr;
}

//改变数组长度
void * vl_array_realloc(void * ctx,int ele_size,int count){
    int except = ele_size * count + head_size();
    void *  ptr = realloc(org_ptr(ctx),except);
    if (!ptr) return NULL;
    set_arr_length(ptr,count);
    return arr_ptr(ptr);
}

void vl_array_free(void * ctx){
    free(org_ptr(ctx));
}

```

`library/src/main/jni/cmn/cmn_vlarray.h`:

```h
//
// Created by mac on 2023/12/13.
//

#ifndef CMN_VLARRAY_H
#define CMN_VLARRAY_H
/**
 * 内存结构"size(int) + [e1,e2...en]"
 eg.
     struct AAA{
        int a;
        int b;
    };
     void * ctx = vl_new_array(sizeof(struct AAA),0);
    printf("数组长度:%d\n", vl_array_length(ctx));
    ctx = vl_array_realloc(ctx, sizeof(struct AAA),5);
    printf("数组长度:%d\n", vl_array_length(ctx));
    struct AAA * arr = ctx;
    printf("数组3,a=%d,b=%d\n",arr[3].a,arr[3].b);
    for (int i = 0; i < vl_array_length(ctx); ++i) {
        arr[i].a = arr[i].b = i;
    }
    printf("数组3,a=%d,b=%d\n",arr[3].a,arr[3].b);
    vl_array_free(ctx);
 */

void * vl_new_array(int ele_size,int count);

int vl_array_length(void * ctx);


void * vl_array_realloc(void * ctx,int ele_size,int count);

void vl_array_free(void * ctx);

#endif //CMN_VLARRAY_H

```

`library/src/main/jni/compat.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef COMPAT_H
#define COMPAT_H

/* Local definitions for compatibility with old and/or broken distros... */
#    ifndef AT_NULL
#        define AT_NULL			0
#    endif
#    ifndef AT_PHDR
#        define AT_PHDR			3
#    endif
#    ifndef AT_PHENT
#        define AT_PHENT		4
#    endif
#    ifndef AT_PHNUM
#        define AT_PHNUM		5
#    endif
#    ifndef AT_BASE
#        define AT_BASE			7
#    endif
#    ifndef AT_ENTRY
#        define AT_ENTRY		9
#    endif
#    ifndef AT_RANDOM
#        define AT_RANDOM		25
#    endif
#    ifndef AT_EXECFN
#        define AT_EXECFN		31
#    endif
#    ifndef AT_SYSINFO
#        define AT_SYSINFO		32
#    endif
#    ifndef AT_SYSINFO_EHDR
#        define AT_SYSINFO_EHDR		33
#    endif
#    ifndef AT_FDCWD
#        define AT_FDCWD		-100
#    endif
#    ifndef AT_SYMLINK_FOLLOW
#        define AT_SYMLINK_FOLLOW	0x400
#    endif
#    ifndef AT_REMOVEDIR
#        define AT_REMOVEDIR		0x200
#    endif
#    ifndef AT_SYMLINK_NOFOLLOW
#        define AT_SYMLINK_NOFOLLOW	0x100
#    endif
#    ifndef IN_DONT_FOLLOW
#        define IN_DONT_FOLLOW		0x02000000
#    endif
#    ifndef WIFCONTINUED
#        define WIFCONTINUED(status)	((status) == 0xffff)
#    endif
#    ifndef PTRACE_GETREGS
#        define PTRACE_GETREGS		12
#    endif
#    ifndef PTRACE_SETREGS
#        define PTRACE_SETREGS		13
#    endif
#    ifndef PTRACE_GETFPREGS
#        define PTRACE_GETFPREGS	14
#    endif
#    ifndef PTRACE_SETFPREGS
#        define PTRACE_SETFPREGS	15
#    endif
#    ifndef PTRACE_GETFPXREGS
#        define PTRACE_GETFPXREGS	18
#    endif
#    ifndef PTRACE_SETFPXREGS
#        define PTRACE_SETFPXREGS	19
#    endif
#    ifndef PTRACE_SETOPTIONS
#        define PTRACE_SETOPTIONS	0x4200
#    endif
#    ifndef PTRACE_GETEVENTMSG
#        define PTRACE_GETEVENTMSG	0x4201
#    endif
#    ifndef PTRACE_GETREGSET
#        define PTRACE_GETREGSET	0x4204
#    endif
#    ifndef PTRACE_SETREGSET
#        define PTRACE_SETREGSET	0x4205
#    endif
#    ifndef PTRACE_SEIZE
#        define PTRACE_SEIZE		0x4206
#    endif
#    ifndef PTRACE_INTERRUPT
#        define PTRACE_INTERRUPT	0x4207
#    endif
#    ifndef PTRACE_LISTEN
#        define PTRACE_LISTEN		0x4208
#    endif
#    ifndef PTRACE_O_TRACESYSGOOD
#        define PTRACE_O_TRACESYSGOOD	0x00000001
#    endif
#    ifndef PTRACE_O_TRACEFORK
#        define PTRACE_O_TRACEFORK	0x00000002
#    endif
#    ifndef PTRACE_O_TRACEVFORK
#        define PTRACE_O_TRACEVFORK	0x00000004
#    endif
#    ifndef PTRACE_O_TRACECLONE
#        define PTRACE_O_TRACECLONE	0x00000008
#    endif
#    ifndef PTRACE_O_TRACEEXEC
#        define PTRACE_O_TRACEEXEC	0x00000010
#    endif
#    ifndef PTRACE_O_TRACEVFORKDONE
#        define PTRACE_O_TRACEVFORKDONE	0x00000020
#    endif
#    ifndef PTRACE_O_TRACEEXIT
#        define PTRACE_O_TRACEEXIT	0x00000040
#    endif
#    ifndef PTRACE_O_TRACESECCOMP
#        define PTRACE_O_TRACESECCOMP	0x00000080
#    endif
#    ifndef PTRACE_EVENT_FORK
#        define PTRACE_EVENT_FORK	1
#    endif
#    ifndef PTRACE_EVENT_VFORK
#        define PTRACE_EVENT_VFORK	2
#    endif
#    ifndef PTRACE_EVENT_CLONE
#        define PTRACE_EVENT_CLONE	3
#    endif
#    ifndef PTRACE_EVENT_EXEC
#        define PTRACE_EVENT_EXEC	4
#    endif
#    ifndef PTRACE_EVENT_VFORK_DONE
#        define PTRACE_EVENT_VFORK_DONE	5
#    endif
#    ifndef PTRACE_EVENT_EXIT
#        define PTRACE_EVENT_EXIT	6
#    endif
#    ifndef PTRACE_EVENT_SECCOMP
#        define PTRACE_EVENT_SECCOMP	7
#    endif
#    ifndef PTRACE_EVENT_SECCOMP2
#        if PTRACE_EVENT_SECCOMP == 7
#            define PTRACE_EVENT_SECCOMP2	8
#        elif PTRACE_EVENT_SECCOMP == 8
#            define PTRACE_EVENT_SECCOMP2	7
#        else
#            error "unknown PTRACE_EVENT_SECCOMP value"
#        endif
#    endif
#    ifndef PTRACE_SET_SYSCALL
#        define PTRACE_SET_SYSCALL	23
#    endif
#    ifndef PTRACE_GET_THREAD_AREA
#        define PTRACE_GET_THREAD_AREA	25
#    endif
#    ifndef PTRACE_SET_THREAD_AREA
#        define PTRACE_SET_THREAD_AREA	26
#    endif
#    ifndef PTRACE_GETVFPREGS
#        define PTRACE_GETVFPREGS	27
#    endif
#    ifndef PTRACE_ARCH_PRCTL
#        define PTRACE_ARCH_PRCTL	30
#    endif
#    ifndef ARCH_SET_GS
#        define ARCH_SET_GS	0x1001
#    endif
#    ifndef ARCH_SET_FS
#        define ARCH_SET_FS	0x1002
#    endif
#    ifndef ARCH_GET_GS
#        define ARCH_GET_FS	0x1003
#    endif
#    ifndef ARCH_GET_FS
#        define ARCH_GET_GS	0x1004
#    endif
#    ifndef PTRACE_SINGLEBLOCK
#        define PTRACE_SINGLEBLOCK	33
#    endif
#    ifndef ADDR_NO_RANDOMIZE
#        define ADDR_NO_RANDOMIZE	0x0040000
#    endif
#    ifndef SYS_ACCEPT4
#        define SYS_ACCEPT4		18
#    endif
#    ifndef TALLOC_FREE
#        define TALLOC_FREE(ctx) do { talloc_free(ctx); ctx = NULL; } while(0)
#    endif
#    ifndef PR_SET_NAME
#        define PR_SET_NAME		15
#    endif
#    ifndef PR_SET_NO_NEW_PRIVS
#        define PR_SET_NO_NEW_PRIVS	38
#    endif
#    ifndef PR_SET_SECCOMP
#        define PR_SET_SECCOMP		22
#    endif
#    ifndef SECCOMP_MODE_FILTER
#        define SECCOMP_MODE_FILTER	2
#    endif
#    ifndef talloc_get_type_abort
#        define talloc_get_type_abort talloc_get_type
#    endif
#    ifndef FUTEX_PRIVATE_FLAG
#        define FUTEX_PRIVATE_FLAG	128
#    endif
#    ifndef EFD_SEMAPHORE
#        define EFD_SEMAPHORE		1
#    endif
#    ifndef F_DUPFD_CLOEXEC
#        define F_DUPFD_CLOEXEC		1030
#    endif
#    ifndef O_RDONLY
#        define O_RDONLY		00000000
#    endif
#    ifndef O_CLOEXEC
#        define O_CLOEXEC		02000000
#    endif
#    ifndef MAP_PRIVATE
#        define MAP_PRIVATE			0x02
#    endif
#    ifndef MAP_FIXED
#        define MAP_FIXED			0x10
#    endif
#    ifndef MAP_ANONYMOUS
#        define MAP_ANONYMOUS			0x20
#    endif
#    ifndef PROT_READ
#        define PROT_READ		0x1
#    endif
#    ifndef PROT_WRITE
#        define PROT_WRITE		0x2
#    endif
#    ifndef PROT_EXEC
#        define PROT_EXEC		0x4
#    endif
#    ifndef PROT_GROWSDOWN
#        define PROT_GROWSDOWN		0x01000000
#    endif
#    ifndef NT_ARM_SYSTEM_CALL
#        define NT_ARM_SYSTEM_CALL		0x404
#    endif

#endif /* COMPAT_H */

```

`library/src/main/jni/constant.h`:

```h
//
// Created by mac on 2023/12/11.
//

#ifndef INTERCEPTSYSCALL_CONSTANT_H
#define INTERCEPTSYSCALL_CONSTANT_H
#include "build.h"
#include "library.h"

#include <android/log.h>
#include <stdio.h>
#include <pthread.h>

#define TAG "INTERCEPT"
#define TAG_SYS "INTERCEPT/SYS"
#define TAG_SYSW "INTERCEPT/SYSW"
#define TAG_SYSE "INTERCEPT/SYSE"

#if defined(ENABLE_LOG)

#if defined(LOG_PRINTF)

//set_seccomp_filters信息
#define LOGSECOMP(...) { printf(__VA_ARGS__);printf("\n");}
//#define LOGSECOMP(...) {}

#define LOGD(...) { printf(__VA_ARGS__);printf("\n");}
#define LOGI(...) { printf(__VA_ARGS__);printf("\n");}
#define LOGW(...) { printf(__VA_ARGS__);printf("\n");}
#define LOGE(...) { printf(__VA_ARGS__);printf("\n");}


#define LOGSYS(...) { printf(__VA_ARGS__);printf("\n");}
#define LOGSYSW(...) { printf(__VA_ARGS__);printf("\n");}
#define LOGSYSE(...) { printf(__VA_ARGS__);printf("\n");}
#else

//set_seccomp_filters信息
#define LOGSECOMP(...) { __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__);}
//#define LOGSECOMP(...) {}

#define LOGD(...) { __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__);}
#define LOGI(...) { __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__);}
#define LOGW(...) { __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__);}
#define LOGE(...) { __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__);}


#define LOGSYS(...) { __android_log_print(ANDROID_LOG_ERROR,TAG_SYS,__VA_ARGS__);}
#define LOGSYSW(...) { __android_log_print(ANDROID_LOG_ERROR,TAG_SYSW,__VA_ARGS__);}
#define LOGSYSE(...) { __android_log_print(ANDROID_LOG_ERROR,TAG_SYSE,__VA_ARGS__);}
#endif
#else

//set_seccomp_filters信息
#define LOGSECOMP(...) {}

#define LOGD(...) {}
#define LOGI(...) {}
#define LOGW(...) {}
#define LOGE(...) {}

#define LOGSYS(...) {}
#define LOGSYSW(...) {}
#define LOGSYSE(...) {}

#endif


#define __LIKELY(x)       __builtin_expect(!!(x), true)
#define __UNLIKELY(x)     __builtin_expect(!!(x), false)


typedef enum readlink_type{
    BUSINESS, //业务逻辑数据
    NORMAL, //常规的tracee调用
}readlink_type;

typedef struct readlink_context{
    readlink_type type;
    void* data;
}readlink_context;


typedef void (*on_sys_event_t)(syscall_data* data);

extern on_sys_event_t global_on_sysenter;
extern on_sys_event_t global_on_sysexit;

extern pthread_t work_tid; //工作线程pid
extern pid_t snew_attach_pid;
extern struct PCond_Context spctx;

#endif //INTERCEPTSYSCALL_CONSTANT_H

```

`library/src/main/jni/execve/aoxp.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <linux/limits.h> /* ARG_MAX, */
#include <assert.h>   /* assert(3), */
#include <string.h>   /* strlen(3), memcmp(3), memcpy(3), */
#include <strings.h>  /* bzero(3), */
#include <stdbool.h>  /* bool, true, false, */
#include <errno.h>    /* E*,  */
#include <stdarg.h>   /* va_*, */
#include <stdint.h>   /* uint32_t, */
#include <talloc.h>   /* talloc_*, */

#include "arch.h"
#include "tracee/tracee.h"
#include "tracee/mem.h"
#include "tracee/abi.h"
#include "build.h"

struct mixed_pointer {
	/* Pointer -- in tracee's address space -- to the current
	 * object, if local == NULL.  */
	word_t remote;

	/* Pointer -- in tracer's address space -- to the current
	 * object, if local != NULL.  */
	void *local;
};

#include "execve/aoxp.h"

/**
 * Read object pointed to by @array[@index] from tracee's memory, then
 * make @local_pointer points to the locally *cached* version.  This
 * function returns -errno when an error occured, otherwise 0.
 */
int read_xpointee_as_object(ArrayOfXPointers *array, size_t index, void **local_pointer)
{
	int status;
	int size;

	assert(index < array->length);

	/* Already cached locally?  */
	if (array->_xpointers[index].local != NULL)
		goto end;

	/* Remote NULL is mapped to local NULL.  */
	if (array->_xpointers[index].remote == 0) {
		array->_xpointers[index].local = NULL;
		goto end;
	}

	size = sizeof_xpointee(array, index);
	if (size < 0)
		return size;

	array->_xpointers[index].local = talloc_size(array, size);
	if (array->_xpointers[index].local == NULL)
		return -ENOMEM;

	/* Copy locally the remote object.  */
	status = read_data(TRACEE(array), array->_xpointers[index].local,
			   array->_xpointers[index].remote, size);
	if (status < 0) {
		array->_xpointers[index].local = NULL;
		return status;
	}

end:
	*local_pointer = array->_xpointers[index].local;
	return 0;
}

/**
 * Read string pointed to by @array[@index] from tracee's memory, then
 * make @local_pointer points to the locally *cached* version.  This
 * function returns -errno when an error occured, otherwise 0.
 */
int read_xpointee_as_string(ArrayOfXPointers *array, size_t index, char **local_pointer)
{
	char tmp[ARG_MAX];
	int status;

	assert(index < array->length);

	/* Already cached locally?  */
	if (array->_xpointers[index].local != NULL)
		goto end;

	/* Remote NULL is mapped to local NULL.  */
	if (array->_xpointers[index].remote == 0) {
		array->_xpointers[index].local = NULL;
		goto end;
	}

	/* Copy locally the remote string into a temporary buffer.  */
	status = read_string(TRACEE(array), tmp, array->_xpointers[index].remote, ARG_MAX);
	if (status < 0)
		return status;
	if (status >= ARG_MAX)
		return -ENOMEM;

	/* Save the local string in a "persistent" buffer.  */
	array->_xpointers[index].local = talloc_strdup(array, tmp);
	if (array->_xpointers[index].local == NULL)
		return -ENOMEM;

end:
	*local_pointer = array->_xpointers[index].local;
	return 0;
}

/**
 * This function returns the number of bytes of the string pointed to
 * by @array[@index], otherwise -errno if an error occured.
 */
int sizeof_xpointee_as_string(ArrayOfXPointers *array, size_t index)
{
	char *string;
	int status;

	assert(index < array->length);

	status = read_xpointee_as_string(array, index, &string);
	if (status < 0)
		return status;

	if (string == NULL)
		return 0;

	return strlen(string) + 1;
}

/**
 * Compare object pointed to by @array[@index] with object pointed to
 * by @local_reference.  This function returns 1 if they are
 * equivalent, 0 otherwise.  On error, -errno is returned.
 */
int compare_xpointee_generic(ArrayOfXPointers *array, size_t index, const void *local_reference)
{
	void *object;
	int status;

	assert(index < array->length);

	status = read_xpointee(array, index, &object);
	if (status < 0)
		return status;

	if (object == NULL && local_reference == NULL)
		return 1;

	if (object == NULL && local_reference != NULL)
		return 0;

	if (object != NULL && local_reference == NULL)
		return 0;

	status = sizeof_xpointee(array, index);
	if (status < 0)
		return status;

	return (int) (memcmp(object, local_reference, status) == 0);
}

/**
 * This function returns the index in @array of the first pointee
 * equivalent to the @local_reference pointee, otherwise it returns
 * -errno if an error occured.
 */
int find_xpointee(ArrayOfXPointers *array, const void *local_reference)
{
	size_t i;

	for (i = 0; i < array->length; i++) {
		int status;

		status = compare_xpointee(array, i, local_reference);
		if (status < 0)
			return status;
		if (status != 0)
			break;
	}

	return i;
}

/**
 * Make @array[@index] points to a copy of the string pointed to by
 * @string.  This function returns -errno when an error occured,
 * otherwise 0.
 */
int write_xpointee_as_string(ArrayOfXPointers *array, size_t index, const char *string)
{
	assert(index < array->length);

	array->_xpointers[index].local = talloc_strdup(array, string);
	if (array->_xpointers[index].local == NULL)
		return -ENOMEM;

	return 0;
}

/**
 * Make @array[@index ... @index + @nb_xpointees] points to a copy of
 * the variadic arguments.  This function returns -errno when an error
 * occured, otherwise 0.
 */
int write_xpointees(ArrayOfXPointers *array, size_t index, size_t nb_xpointees, ...)
{
	va_list va_xpointees;
	int status;
	size_t i;

	va_start(va_xpointees, nb_xpointees);

	for (i = 0; i < nb_xpointees; i++) {
		void *object = va_arg(va_xpointees, void *);

		status = write_xpointee(array, index + i, object);
		if (status < 0)
			goto end;
	}
	status = 0;

end:
	va_end(va_xpointees);
	return status;
}


/**
 * Resize the @array at the given @index by the @delta_nb_entries.
 * This function returns -errno when an error occured, otherwise 0.
 */
int resize_array_of_xpointers(ArrayOfXPointers *array, size_t index, ssize_t delta_nb_entries)
{
	size_t nb_moved_entries;
	size_t new_length;
	void *tmp;

	assert(index < array->length);

	if (delta_nb_entries == 0)
		return 0;

	new_length = array->length + delta_nb_entries;
	nb_moved_entries = array->length - index;

	if (delta_nb_entries > 0) {
		tmp = talloc_realloc(array, array->_xpointers, XPointer, new_length);
		if (tmp == NULL)
			return -ENOMEM;
		array->_xpointers = tmp;

		memmove(array->_xpointers + index + delta_nb_entries, array->_xpointers + index,
			nb_moved_entries * sizeof(XPointer));

		bzero(array->_xpointers + index, delta_nb_entries * sizeof(XPointer));
	}
	else {
		assert(delta_nb_entries <= 0);
		assert(index >= (size_t) -delta_nb_entries);

		memmove(array->_xpointers + index + delta_nb_entries, array->_xpointers + index,
			nb_moved_entries * sizeof(XPointer));

		tmp = talloc_realloc(array, array->_xpointers, XPointer, new_length);
		if (tmp == NULL)
			return -ENOMEM;
		array->_xpointers = tmp;
	}

	array->length = new_length;
	return 0;
}

/**
 * Copy into *@array_ the pointer array pointed to by @reg from
 * @tracee's memory space.  Only the first @nb_entries are copied,
 * unless it is 0 then all the entries up to the NULL pointer are
 * copied.  This function returns -errno when an error occured,
 * otherwise 0.
 */
int fetch_array_of_xpointers(Tracee *tracee, ArrayOfXPointers **array_, Reg reg, size_t nb_entries)
{
	word_t pointer = 1; /* ie. != 0 */
	word_t address;
	ArrayOfXPointers *array;
	size_t i;

	assert(array_ != NULL);

	*array_ = talloc_zero(tracee->ctx, ArrayOfXPointers);
	if (*array_ == NULL)
		return -ENOMEM;
	array = *array_;

	address = peek_reg(tracee, CURRENT, reg);

	for (i = 0; nb_entries != 0 ? i < nb_entries : pointer != 0; i++) {
		void *tmp = talloc_realloc(array, array->_xpointers, XPointer, i + 1);
		if (tmp == NULL)
			return -ENOMEM;
		array->_xpointers = tmp;

		pointer = peek_word(tracee, address + i * sizeof_word(tracee));
		if (errno != 0)
			return -errno;

		array->_xpointers[i].remote = pointer;
		array->_xpointers[i].local = NULL;
	}
	array->length = i;

	/* By default, assume it is an array of string pointers.  */
	array->read_xpointee   = (read_xpointee_t) read_xpointee_as_string;
	array->sizeof_xpointee = sizeof_xpointee_as_string;
	array->write_xpointee  = (write_xpointee_t) write_xpointee_as_string;

	/* By default, use generic callbacks: they rely on
	 * array->read_xpointee() and array->sizeof_xpointee().  */
	array->compare_xpointee = compare_xpointee_generic;

	return 0;
}

/**
 * Copy @array into tracee's memory space, then put in @reg the
 * address where it was copied.  This function returns -errno if an
 * error occured, otherwise 0.
 */
int push_array_of_xpointers(ArrayOfXPointers *array, Reg reg)
{
	Tracee *tracee;
	struct iovec *local;
	size_t local_count;
	size_t total_size;
	word_t *pod_array;
	word_t tracee_ptr;
	int status;
	size_t i;

	/* Nothing to do, for sure.  */
	if (array == NULL)
		return 0;

	tracee = TRACEE(array);

	/* The pointer table is a POD array in the tracee's memory.  */
	pod_array = talloc_zero_size(tracee->ctx, array->length * sizeof_word(tracee));
	if (pod_array == NULL)
		return -ENOMEM;

	/* There's one vector per modified pointee + one vector for the
	 * pod array.  */
	local = talloc_zero_array(tracee->ctx, struct iovec, array->length + 1);
	if (local == NULL)
		return -ENOMEM;

	/* The pod array is expected to be at the beginning of the
	 * allocated memory by the caller.  */
	total_size = array->length * sizeof_word(tracee);
	local[0].iov_base = pod_array;
	local[0].iov_len  = total_size;
	local_count = 1;

	/* Create one vector for each modified pointee.  */
	for (i = 0; i < array->length; i++) {
		ssize_t size;

		if (array->_xpointers[i].local == NULL)
			continue;

		/* At this moment, we only know the offsets in the
		 * tracee's memory block. */
		array->_xpointers[i].remote = total_size;

		size = sizeof_xpointee(array, i);
		if (size < 0)
			return size;
		total_size += size;

		local[local_count].iov_base = array->_xpointers[i].local;
		local[local_count].iov_len  = size;
		local_count++;
	}

	/* Nothing has changed, don't update anything.  */
	if (local_count == 1)
		return 0;
	assert(local_count < array->length + 1);

	/* Modified pointees and the pod array are stored in a tracee's
	 * memory block.  */
	tracee_ptr = alloc_mem(tracee, total_size);
	if (tracee_ptr == 0)
		return -E2BIG;

	/* Now, we know the absolute addresses in the tracee's
	 * memory.  */
	for (i = 0; i < array->length; i++) {
		if (array->_xpointers[i].local != NULL)
			array->_xpointers[i].remote += tracee_ptr;

		if (is_32on64_mode(tracee))
			((uint32_t *) pod_array)[i] = array->_xpointers[i].remote;
		else
			pod_array[i] = array->_xpointers[i].remote;
	}

	/* Write all the modified pointees and the pod array at once.  */
	status = writev_data(tracee, tracee_ptr, local, local_count);
	if (status < 0)
		return status;

	poke_reg(tracee, reg, tracee_ptr);
	return 0;
}

```

`library/src/main/jni/execve/aoxp.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef AOXP_H
#define AOXP_H

#include <stdbool.h>

#include "tracee/reg.h"
#include "arch.h"

typedef struct array_of_xpointers ArrayOfXPointers;
typedef int (*read_xpointee_t)(ArrayOfXPointers *array, size_t index, void **object);
typedef int (*write_xpointee_t)(ArrayOfXPointers *array, size_t index, const void *object);
typedef int (*compare_xpointee_t)(ArrayOfXPointers *array, size_t index, const void *reference);
typedef int (*sizeof_xpointee_t)(ArrayOfXPointers *array, size_t index);

typedef struct mixed_pointer XPointer;
struct array_of_xpointers {
	XPointer *_xpointers;
	size_t length;

	read_xpointee_t    read_xpointee;
	write_xpointee_t   write_xpointee;
	compare_xpointee_t compare_xpointee;
	sizeof_xpointee_t  sizeof_xpointee;
};

static inline int read_xpointee(ArrayOfXPointers *array, size_t index, void **object)
{
	return array->read_xpointee(array, index, object);
}

static inline int write_xpointee(ArrayOfXPointers *array, size_t index, const void *object)
{
	return array->write_xpointee(array, index, object);
}

static inline int compare_xpointee(ArrayOfXPointers *array, size_t index, const void *reference)
{
	return array->compare_xpointee(array, index, reference);
}

static inline int sizeof_xpointee(ArrayOfXPointers *array, size_t index)
{
	return array->sizeof_xpointee(array, index);
}

extern int find_xpointee(ArrayOfXPointers *array, const void *reference);
extern int resize_array_of_xpointers(ArrayOfXPointers *array, size_t index, ssize_t nb_delta_entries);
extern int fetch_array_of_xpointers(Tracee *tracee, ArrayOfXPointers **array, Reg reg, size_t nb_entries);
extern int push_array_of_xpointers(ArrayOfXPointers *array, Reg reg);

extern int read_xpointee_as_object(ArrayOfXPointers *array, size_t index, void **object);
extern int read_xpointee_as_string(ArrayOfXPointers *array, size_t index, char **string);
extern int write_xpointee_as_string(ArrayOfXPointers *array, size_t index, const char *string);
extern int write_xpointees(ArrayOfXPointers *array, size_t index, size_t nb_xpointees, ...);
extern int compare_xpointee_generic(ArrayOfXPointers *array, size_t index, const void *reference);
extern int sizeof_xpointee_as_string(ArrayOfXPointers *array, size_t index);

#endif /* AOXP_H */

```

`library/src/main/jni/execve/auxv.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <linux/auxvec.h>  /* AT_*,  */
#include <assert.h>        /* assert(3),  */
#include <errno.h>         /* E*,  */
#include <unistd.h>        /* write(3), close(3), */
#include <sys/types.h>     /* open(2), */
#include <sys/stat.h>      /* open(2), */
#include <fcntl.h>         /* open(2), */

#include "execve/auxv.h"
#include "syscall/sysnum.h"
#include "tracee/tracee.h"
#include "tracee/mem.h"
#include "tracee/reg.h"
#include "tracee/abi.h"
#include "arch.h"
#include "cmn/cmn_vlarray.h"


/**
 * Add the given vector [@type, @value] to @vectors.  This function
 * returns -errno if an error occurred, otherwise 0.
 */
int add_elf_aux_vector(ElfAuxVector **vectors, word_t type, word_t value)
{
	ElfAuxVector *tmp;
	size_t nb_vectors;

	assert(*vectors != NULL);

	nb_vectors = vl_array_length(*vectors);

	/* Sanity checks.  */
	assert(nb_vectors > 0);
	assert((*vectors)[nb_vectors - 1].type == AT_NULL);

//	tmp = talloc_realloc(talloc_parent(*vectors), *vectors, ElfAuxVector, nb_vectors + 1);
	tmp = vl_array_realloc(*vectors, sizeof(ElfAuxVector), nb_vectors + 1);
	if (tmp == NULL)
		return -ENOMEM;
	*vectors = tmp;

	/* Replace the sentinel with the new vector.  */
	(*vectors)[nb_vectors - 1].type  = type;
	(*vectors)[nb_vectors - 1].value = value;

	/* Restore the sentinel.  */
	(*vectors)[nb_vectors].type  = AT_NULL;
	(*vectors)[nb_vectors].value = 0;

	return 0;
}

/**
 * Get the address of the the ELF auxiliary vectors table for the
 * given @tracee.  This function returns 0 if an error occurred.
 */
word_t get_elf_aux_vectors_address(const Tracee *tracee)
{
	word_t address;
	word_t data;

	/* Sanity check: this works only in execve sysexit.  */
	assert(IS_IN_SYSEXIT2(tracee, PR_execve));

	/* Right after execve, the stack layout is:
	 *
	 *     argc, argv[0], ..., 0, envp[0], ..., 0, auxv[0].type, auxv[0].value, ..., 0, 0
	 */
	address = peek_reg(tracee, CURRENT, STACK_POINTER);

	/* Read: argc */
	data = peek_word(tracee, address);
	if (errno != 0)
		return 0;

	/* Skip: argc, argv, 0 */
	address += (1 + data + 1) * sizeof_word(tracee);

	/* Skip: envp, 0 */
	do {
		data = peek_word(tracee, address);
		if (errno != 0)
			return 0;
		address += sizeof_word(tracee);
	} while (data != 0);

	return address;
}

/**
 * Fetch ELF auxiliary vectors stored at the given @address in
 * @tracee's memory.  This function returns NULL if an error occurred,
 * otherwise it returns a pointer to the new vectors, in an ABI
 * independent form (the Talloc parent of this pointer is
 * @tracee->ctx).
 */
ElfAuxVector *fetch_elf_aux_vectors(const Tracee *tracee, word_t address)
{
	ElfAuxVector *vectors = NULL;
	ElfAuxVector vector;
	int status;

	/* It is assumed the sentinel always exists.  */
//	vectors = talloc_array(tracee->ctx, ElfAuxVector, 1);
	vectors = vl_new_array(sizeof(ElfAuxVector),1);
	if (vectors == NULL)
		return NULL;
	vectors[0].type  = AT_NULL;
	vectors[0].value = 0;

	while (1) {
		vector.type = peek_word(tracee, address);
		if (errno != 0)
			return NULL;
		address += sizeof_word(tracee);

		if (vector.type == AT_NULL)
			break; /* Already added.  */

		vector.value = peek_word(tracee, address);
		if (errno != 0)
			return NULL;
		address += sizeof_word(tracee);

		status = add_elf_aux_vector(&vectors, vector.type, vector.value);
		if (status < 0)
			return NULL;
	}

	return vectors;
}

/**
 * Push ELF auxiliary @vectors to the given @address in @tracee's
 * memory.  This function returns -errno if an error occurred,
 * otherwise 0.
 */
int push_elf_aux_vectors(const Tracee* tracee, ElfAuxVector *vectors, word_t address)
{
	size_t i;

	for (i = 0; vectors[i].type != AT_NULL; i++) {
		poke_word(tracee, address, vectors[i].type);
		if (errno != 0)
			return -errno;
		address += sizeof_word(tracee);

		poke_word(tracee, address, vectors[i].value);
		if (errno != 0)
			return -errno;
		address += sizeof_word(tracee);
	}

	poke_word(tracee, address, AT_NULL);
	if (errno != 0)
		return -errno;
	address += sizeof_word(tracee);

	poke_word(tracee, address, 0);
	if (errno != 0)
		return -errno;
	address += sizeof_word(tracee);

	return 0;
}

```

`library/src/main/jni/execve/auxv.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef AUXV
#define AUXV

#include "tracee/tracee.h"
#include "arch.h"

typedef struct elf_aux_vector {
	word_t type;
	word_t value;
} ElfAuxVector;

extern word_t get_elf_aux_vectors_address(const Tracee *tracee);
extern ElfAuxVector *fetch_elf_aux_vectors(const Tracee *tracee, word_t address);
extern int add_elf_aux_vector(ElfAuxVector **vectors, word_t type, word_t value);
extern int push_elf_aux_vectors(const Tracee* tracee, ElfAuxVector *vectors, word_t address);

#endif /* AUXV */

```

`library/src/main/jni/execve/elf.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <fcntl.h>  /* open(2), */
#include <unistd.h> /* read(2), close(2), */
#include <errno.h>  /* EACCES, ENOTSUP, */
#include <stdint.h> /* UINT64_MAX, */
#include <limits.h> /* PATH_MAX, */
#include <string.h> /* str*(3), memcpy(3), */
#include <assert.h> /* assert(3), */
//#include <talloc.h> /* talloc_*, */
#include <stdbool.h> /* bool, true, false,  */
#include <stdlib.h>

#include "execve/elf.h"
#include "tracee/tracee.h"
//#include "cli/note.h"
#include "arch.h"

#include "compat.h"
#include "constant.h"

/**
 * Open the ELF file @t_path and extract its header into @elf_header.
 * This function returns -errno if an error occured, otherwise the
 * file descriptor for @t_path.
 */
int open_elf(const char *t_path, ElfHeader *elf_header)
{
    int fd;
    int status;

    /*
     * Read the ELF header.
     */

    fd = open(t_path, O_RDONLY);
    if (fd < 0)
        return -errno;

    /* Check if it is an ELF file.  */
    status = read(fd, elf_header, sizeof(ElfHeader));
    if (status < 0) {
        status = -errno;
        goto end;
    }
    if ((size_t) status < sizeof(ElfHeader)
        || ELF_IDENT(*elf_header, 0) != 0x7f
        || ELF_IDENT(*elf_header, 1) != 'E'
        || ELF_IDENT(*elf_header, 2) != 'L'
        || ELF_IDENT(*elf_header, 3) != 'F') {
        status = -ENOEXEC;
        goto end;
    }

    /* Check if it is a known class (32-bit or 64-bit).  */
    if (   !IS_CLASS32(*elf_header)
           && !IS_CLASS64(*elf_header)) {
        status = -ENOEXEC;
        goto end;
    }

    status = 0;
    end:
    /* Delayed error handling.  */
    if (status < 0) {
        close(fd);
        return status;
    }

    return fd;
}

/**
 * Invoke @callback(..., @data) for each program headers from the
 * specified ELF file (referenced by @fd, with the given @elf_header).
 * This function returns -errno if an error occured, or it returns
 * immediately the value != 0 returned by @callback, otherwise 0.
 */
int iterate_program_headers(const Tracee *tracee, int fd, const ElfHeader *elf_header,
                            program_headers_iterator_t callback, void *data)
{
    ProgramHeader program_header;

    uint64_t elf_phoff;
    uint16_t elf_phentsize;
    uint16_t elf_phnum;

    int status;
    int i;

    /* Get class-specific fields. */
    elf_phnum     = ELF_FIELD(*elf_header, phnum);
    elf_phentsize = ELF_FIELD(*elf_header, phentsize);
    elf_phoff     = ELF_FIELD(*elf_header, phoff);

    /*
     * Some sanity checks regarding the current
     * support of the ELF specification in PRoot.
     */

    if (elf_phnum >= 0xffff) {
//        note(tracee, WARNING, INTERNAL, "%d: big PH tables are not yet supported.", fd);
        LOGSYS("%d: big PH tables are not yet supported.", fd)
        return -ENOTSUP;
    }

    if (!KNOWN_PHENTSIZE(*elf_header, elf_phentsize)) {
//        note(tracee, WARNING, INTERNAL, "%d: unsupported size of program header.", fd);
        LOGSYSW("%d: unsupported size of program header.", fd)
        return -ENOTSUP;
    }

    status = (int) lseek(fd, elf_phoff, SEEK_SET);
    if (status < 0)
        return -errno;

    for (i = 0; i < elf_phnum; i++) {
        status = read(fd, &program_header, elf_phentsize);
        if (status != elf_phentsize)
            return (status < 0 ? -errno : -ENOTSUP);

        status = callback(elf_header, &program_header, data);
        if (status != 0)
            return status;
    }

    return 0;
}

/**
 * Check if @host_path is an ELF file for the host architecture.
 */
//bool is_host_elf(const Tracee *tracee, const char *host_path) //不存在不是主机架构的，不会qemu
//{
//    int host_elf_machine[] = HOST_ELF_MACHINE;
//    static int force_foreign = -1;
//    ElfHeader elf_header;
//    uint16_t elf_machine;
//    int fd;
//    int i;
//
//    if (force_foreign < 0)
//        //TODO 待修改
//        force_foreign = (getenv("PROOT_FORCE_FOREIGN_BINARY") != NULL);
//
//    if (force_foreign > 0 || !tracee->qemu)
//        return false;
//
//    fd = open_elf(host_path, &elf_header);
//    if (fd < 0)
//        return false;
//    close(fd);
//
//    elf_machine = ELF_FIELD(elf_header, machine);
//    for (i = 0; host_elf_machine[i] != 0; i++) {
//        if (host_elf_machine[i] == elf_machine) {
////            VERBOSE(tracee, 1, "'%s' is a host ELF", host_path);
//            LOGSYS("'%s' is a host ELF", host_path)
//            return true;
//        }
//    }
//
//    return false;
//}

```

`library/src/main/jni/execve/elf.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef ELF_H
#define ELF_H

#define EI_NIDENT 16

#include <stdint.h>
#include <stdbool.h>

typedef struct {
    unsigned char e_ident[EI_NIDENT];
    uint16_t      e_type;
    uint16_t      e_machine;
    uint32_t      e_version;
    uint32_t      e_entry;
    uint32_t      e_phoff;
    uint32_t      e_shoff;
    uint32_t      e_flags;
    uint16_t      e_ehsize;
    uint16_t      e_phentsize;
    uint16_t      e_phnum;
    uint16_t      e_shentsize;
    uint16_t      e_shnum;
    uint16_t      e_shstrndx;
} ElfHeader32;

typedef struct {
    unsigned char e_ident[EI_NIDENT];
    uint16_t      e_type;
    uint16_t      e_machine;
    uint32_t      e_version;
    uint64_t      e_entry;
    uint64_t      e_phoff;
    uint64_t      e_shoff;
    uint32_t      e_flags;
    uint16_t      e_ehsize;
    uint16_t      e_phentsize;
    uint16_t      e_phnum;
    uint16_t      e_shentsize;
    uint16_t      e_shnum;
    uint16_t      e_shstrndx;
} ElfHeader64;

typedef union {
    ElfHeader32 class32;
    ElfHeader64 class64;
} ElfHeader;

typedef struct {
    uint32_t   p_type;
    uint32_t   p_offset;
    uint32_t   p_vaddr;
    uint32_t   p_paddr;
    uint32_t   p_filesz;
    uint32_t   p_memsz;
    uint32_t   p_flags;
    uint32_t   p_align;
} ProgramHeader32;

typedef struct {
    uint32_t   p_type;
    uint32_t   p_flags;
    uint64_t   p_offset;
    uint64_t   p_vaddr;
    uint64_t   p_paddr;
    uint64_t   p_filesz;
    uint64_t   p_memsz;
    uint64_t   p_align;
} ProgramHeader64;

typedef union {
    ProgramHeader32 class32;
    ProgramHeader64 class64;
} ProgramHeader;

/* Object type:  */
#define ET_REL          1
#define ET_EXEC         2
#define ET_DYN          3
#define ET_CORE         4

/* Segment flags:  */
#define PF_X 1
#define PF_W 2
#define PF_R 4

typedef enum {
    PT_LOAD    = 1,
    PT_DYNAMIC = 2,
    PT_INTERP  = 3,
    PT_GNU_STACK = 0x6474e551,
} SegmentType;

typedef struct {
    int32_t d_tag;
    uint32_t d_val;
} DynamicEntry32;

typedef struct {
    int64_t d_tag;
    uint64_t d_val;
} DynamicEntry64;

typedef union {
    DynamicEntry32 class32;
    DynamicEntry64 class64;
} DynamicEntry;

typedef enum {
    DT_STRTAB  = 5,
    DT_RPATH   = 15,
    DT_RUNPATH = 29
} DynamicType;

/* The following macros are also compatible with ELF 64-bit. */
#define ELF_IDENT(header, index) (header).class32.e_ident[(index)]
#define ELF_CLASS(header) ELF_IDENT(header, 4)
#define IS_CLASS32(header) (ELF_CLASS(header) == 1)
#define IS_CLASS64(header) (ELF_CLASS(header) == 2)

/* Helper to access a @field of the structure ElfHeaderXX. */
#define ELF_FIELD(header, field)		\
	(IS_CLASS64(header)			\
	 ? (header).class64. e_ ## field	\
	 : (header).class32. e_ ## field)

/* Helper to access a @field of the structure ProgramHeaderXX */
#define PROGRAM_FIELD(ehdr, phdr, field)	\
	(IS_CLASS64(ehdr)			\
	 ? (phdr).class64. p_ ## field		\
	 : (phdr).class32. p_ ## field)

/* Helper to access a @field of the structure DynamicEntryXX */
#define DYNAMIC_FIELD(ehdr, dynent, field)	\
	(IS_CLASS64(ehdr)			\
	 ? (dynent).class64. d_ ## field	\
	 : (dynent).class32. d_ ## field)

#define KNOWN_PHENTSIZE(header, size)					\
	(   (IS_CLASS32(header) && (size) == sizeof(ProgramHeader32)) \
	 || (IS_CLASS64(header) && (size) == sizeof(ProgramHeader64)))

#define IS_POSITION_INDENPENDANT(elf_header)	\
	(ELF_FIELD((elf_header), type) == ET_DYN)

#include "tracee/tracee.h"

extern int open_elf(const char *t_path, ElfHeader *elf_header);

//extern bool is_host_elf(const Tracee *tracee, const char *t_path);

typedef int (* program_headers_iterator_t)(const ElfHeader *elf_header,
                                           const ProgramHeader *program_header, void *data);

extern int iterate_program_headers(const Tracee *tracee, int fd, const ElfHeader *elf_header,
                                   program_headers_iterator_t callback, void *data);

#endif /* ELF_H */

```

`library/src/main/jni/execve/enter.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sys/types.h>  /* lstat(2), lseek(2), */
#include <sys/stat.h>   /* lstat(2), lseek(2), fchmod(2), */
#include <unistd.h>     /* access(2), lstat(2), close(2), read(2), */
#include <errno.h>      /* E*, */
#include <assert.h>     /* assert(3), */
//#include <talloc.h>     /* talloc*, */
#include <sys/mman.h>   /* PROT_*, */
#include <string.h>     /* strlen(3), strcpy(3), */
#include <stdlib.h>     /* getenv(3), */
#include <stdio.h>      /* fwrite(3), */
#include <assert.h>     /* assert(3), */

#include "execve/execve.h"
#include "execve/shebang.h"
#include "execve/aoxp.h"
#include "execve/ldso.h"
#include "execve/elf.h"
#include "path/path.h"
#include "path/temp.h"
#include "path/binding.h"
#include "tracee/tracee.h"
#include "syscall/syscall.h"
#include "syscall/sysnum.h"
#include "arch.h"
#include "cmn/cmn_vlarray.h"
#include "constant.h"
#include "note.h"
//#include "cli/note.h"

#define P(a) PROGRAM_FIELD(load_info->elf_header, *program_header, a)

/**
 * Add @program_header (type PT_LOAD) to @load_info->mappings.  This
 * function returns -errno if an error occured, otherwise it returns
 * 0.
 */
static int add_mapping(const Tracee *tracee UNUSED, LoadInfo *load_info,
		const ProgramHeader *program_header)
{
	size_t index;
	word_t start_address;
	word_t end_address;
	static word_t page_size = 0;
	static word_t page_mask = 0;

	if (page_size == 0) {
		page_size = sysconf(_SC_PAGE_SIZE);
		if ((int) page_size <= 0)
			page_size = 0x1000;
		page_mask = ~(page_size - 1);
	}

	if (load_info->mappings == NULL){
        load_info->mappings = vl_new_array(sizeof(Mapping),0);
        index = 0;
    }
	else
//		index = talloc_array_length(load_info->mappings);
		index = vl_array_length(load_info->mappings);

//	load_info->mappings = talloc_realloc(load_info, load_info->mappings, Mapping, index + 1);
	load_info->mappings = vl_array_realloc(load_info->mappings, sizeof(Mapping), index + 1); //TODO error
	if (load_info->mappings == NULL)
		return -ENOMEM;

	start_address = P(vaddr) & page_mask;
	end_address   = (P(vaddr) + P(filesz) + page_size) & page_mask;

	load_info->mappings[index].fd     = -1; /* Unknown yet.  */
	load_info->mappings[index].offset = P(offset) & page_mask;
	load_info->mappings[index].addr   = start_address;
	load_info->mappings[index].length = end_address - start_address;
	load_info->mappings[index].flags  = MAP_PRIVATE | MAP_FIXED;
	load_info->mappings[index].prot   =  ( (P(flags) & PF_R ? PROT_READ  : 0)
					| (P(flags) & PF_W ? PROT_WRITE : 0)
					| (P(flags) & PF_X ? PROT_EXEC  : 0));

	/* "If the segment's memory size p_memsz is larger than the
	 * file size p_filesz, the "extra" bytes are defined to hold
	 * the value 0 and to follow the segment's initialized area."
	 * -- man 7 elf.  */
	if (P(memsz) > P(filesz)) {
		/* How many extra bytes in the current page?  */
		load_info->mappings[index].clear_length = end_address - P(vaddr) - P(filesz);

		/* Create new pages for the remaining extra bytes.  */
		start_address = end_address;
		end_address   = (P(vaddr) + P(memsz) + page_size) & page_mask;
		if (end_address > start_address) {
			index++;
//			load_info->mappings = talloc_realloc(load_info, load_info->mappings,
//							Mapping, index + 1);
			load_info->mappings = vl_array_realloc(load_info->mappings,
												   sizeof(Mapping), index + 1);
			if (load_info->mappings == NULL)
				return -ENOMEM;

			load_info->mappings[index].fd     = -1;  /* Anonymous.  */
			load_info->mappings[index].offset =  0;
			load_info->mappings[index].addr   = start_address;
			load_info->mappings[index].length = end_address - start_address;
			load_info->mappings[index].clear_length = 0;
			load_info->mappings[index].flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED;
			load_info->mappings[index].prot   = load_info->mappings[index - 1].prot;
		}
	}
	else
		load_info->mappings[index].clear_length = 0;

	return 0;
}

/**
 * Translate @user_path into @host_path and check if this latter exists, is
 * executable and is a regular file.  This function returns -errno if
 * an error occured, 0 otherwise.
 */
int translate_and_check_exec(Tracee *tracee, char host_path[PATH_MAX], const char *user_path)
{
	struct stat statl;
	int status;

	if (user_path[0] == '\0')
		return -ENOEXEC;

	status = translate_path(tracee, host_path, AT_FDCWD, user_path, true);
	if (status < 0)
		return status;

	status = access(host_path, F_OK);
	if (status < 0)
		return -ENOENT;

	status = access(host_path, X_OK);
	if (status < 0)
		return -EACCES;

	status = lstat(host_path, &statl);
	if (status < 0)
		return -EPERM;

	return 0;
}

/**
 * Add @program_header (type PT_INTERP) to @load_info->interp.  This
 * function returns -errno if an error occured, otherwise it returns
 * 0.
 */
static int add_interp(Tracee *tracee, int fd, LoadInfo *load_info,
		const ProgramHeader *program_header)
{
	char host_path[PATH_MAX];
	char *user_path;
	int status;

	/* Only one PT_INTERP segment is allowed.  */
	if (load_info->interp != NULL)
		return -EINVAL;

//	load_info->interp = talloc_zero(load_info, LoadInfo);
	load_info->interp = calloc(1, sizeof(LoadInfo));
	if (load_info->interp == NULL)
		return -ENOMEM;

//	user_path = talloc_size(tracee->ctx, P(filesz) + 1);
	user_path = malloc(P(filesz) + 1);
	if (user_path == NULL)
		return -ENOMEM;

	/* Remember pread(2) doesn't change the
	 * current position in the file.  */
	status = pread(fd, user_path, P(filesz), P(offset));
	if ((size_t) status != P(filesz)) /* Unexpected size.  */
		status = -EACCES;
	if (status < 0)
		return status;

	user_path[P(filesz)] = '\0';

	/* When a QEMU command was specified:
	 *
	 * - if it's a foreign binary we are reading the ELF
	 *   interpreter of QEMU instead.
	 *
	 * - if it's a host binary, we are reading its ELF
	 *   interpreter.
	 *
	 * In both case, it lies in "/host-rootfs" from a guest
	 * point-of-view.  */
//	if (tracee->qemu != NULL && user_path[0] == '/') {
////		user_path = talloc_asprintf(tracee->ctx, "%s%s", HOST_ROOTFS, user_path);
////		if (user_path == NULL)
////			return -ENOMEM;
//        if (asprintf(&user_path,"%s%s", HOST_ROOTFS, user_path) < 0){
//            return -ENOMEM;
//        }
//	}

	status = translate_and_check_exec(tracee, host_path, user_path);
	if (status < 0)
		return status;

//	load_info->interp->host_path = talloc_strdup(load_info->interp, host_path);
    load_info->interp->host_path = strdup(host_path);
	if (load_info->interp->host_path == NULL)
		return -ENOMEM;

//	load_info->interp->user_path = talloc_strdup(load_info->interp, user_path);
    load_info->interp->user_path = strdup( user_path);
	if (load_info->interp->user_path == NULL)
		return -ENOMEM;

	return 0;
}

#undef P

struct add_load_info_data {
	LoadInfo *load_info;
	Tracee *tracee;
	int fd;
};

/**
 * This function is a program header iterator.  It invokes
 * add_mapping() or add_interp(), according to the type of
 * @program_header.  This function returns -errno if an error
 * occurred, otherwise 0.
 */
static int add_load_info(const ElfHeader *elf_header,
			const ProgramHeader *program_header, void *data_)
{
	struct add_load_info_data *data = data_;
	int status;

	switch (PROGRAM_FIELD(*elf_header, *program_header, type)) {
	case PT_LOAD:
		status = add_mapping(data->tracee, data->load_info, program_header);
		if (status < 0)
			return status;
        //不需要这些map信息
//        LOGSYS("stub PT_LOAD------------")
		break;

	case PT_INTERP:
		status = add_interp(data->tracee, data->fd, data->load_info, program_header);
		if (status < 0)
			return status;
//        LOGSYS("stub PT_INTERP------------")
		break;

	case PT_GNU_STACK:
		data->load_info->needs_executable_stack |=
			((PROGRAM_FIELD(*elf_header, *program_header, flags) & PF_X) != 0);
		break;

	default:
		break;
	}

	return 0;
}

/**
 * Extract the load info from @load->host_path.  This function returns
 * -errno if an error occured, otherwise it returns 0.
 */
static int extract_load_info(Tracee *tracee, LoadInfo *load_info)
{
	struct add_load_info_data data;
	int fd = -1;
	int status;

	assert(load_info != NULL);
	assert(load_info->host_path != NULL);

	fd = open_elf(load_info->host_path, &load_info->elf_header);
	if (fd < 0)
		return fd;

	/* Sanity check.  */
	switch (ELF_FIELD(load_info->elf_header, type)) {
	case ET_EXEC:
	case ET_DYN:
		break;

	default:
		status = -EINVAL;
		goto end;
	}

	data.load_info = load_info;
	data.tracee    = tracee;
	data.fd        = fd;

	status = iterate_program_headers(tracee, fd, &load_info->elf_header, add_load_info, &data);
end:
	if (fd >= 0)
		close(fd);

	return status;
}

/**
 * Add @load_base to each adresses of @load_info.
 */
static void add_load_base(LoadInfo *load_info, word_t load_base)
{
	size_t nb_mappings;
	size_t i;

//	nb_mappings = talloc_array_length(load_info->mappings);
    nb_mappings = vl_array_length(load_info->mappings);
	for (i = 0; i < nb_mappings; i++)
		load_info->mappings[i].addr += load_base;

	if (IS_CLASS64(load_info->elf_header))
		load_info->elf_header.class64.e_entry += load_base;
	else
		load_info->elf_header.class32.e_entry += load_base;
}

/**
 * Compute the final load address for each position independant
 * objects of @tracee.
 *
 * TODO: support for ASLR.
 */
static void compute_load_addresses(Tracee *tracee)
{
	if (IS_POSITION_INDENPENDANT(tracee->load_info->elf_header)
	    && tracee->load_info->mappings[0].addr == 0) {
#if defined(HAS_LOADER_32BIT)
		if (IS_CLASS32(tracee->load_info->elf_header))
			add_load_base(tracee->load_info, EXEC_PIC_ADDRESS_32);
		else
#endif
		add_load_base(tracee->load_info, EXEC_PIC_ADDRESS);
	}

	/* Nothing more to do?  */
	if (tracee->load_info->interp == NULL)
		return;

	if (IS_POSITION_INDENPENDANT(tracee->load_info->interp->elf_header)
	    && tracee->load_info->interp->mappings[0].addr == 0) {
#if defined(HAS_LOADER_32BIT)
		if (IS_CLASS32(tracee->load_info->elf_header))
			add_load_base(tracee->load_info->interp, INTERP_PIC_ADDRESS_32);
		else
#endif
		add_load_base(tracee->load_info->interp, INTERP_PIC_ADDRESS);
	}
}

/**
 * Expand in argv[] and envp[] the runner for @user_path, if needed.
 * This function returns -errno if an error occurred, otherwise 0.  On
 * success, both @host_path and @user_path point to the program to
 * execute (respectively from host and guest point-of-views), and both
 * @tracee's argv[] (pointed to by SYSARG_2) @tracee's envp[] (pointed
 * to by SYSARG_3) are correctly updated.
 */
//static int expand_runner(Tracee* tracee, char host_path[PATH_MAX], char user_path[PATH_MAX])
//{
//	ArrayOfXPointers *envp;
//	char *argv0;
//	int status;
//
//	/* Execution of host programs when QEMU is in use relies on
//	 * LD_ environment variables.  */
//	status = fetch_array_of_xpointers(tracee, &envp, SYSARG_3, 0);
//	if (status < 0)
//		return status;
//
//	/* Environment variables should be compared with the "name"
//	 * part of the "name=value" string format.  */
//	envp->compare_xpointee = (compare_xpointee_t) compare_xpointee_env;
//
//	/* No need to adjust argv[] if it's a host binary (a.k.a
//	 * mixed-mode).  */
//	if (tracee->mixed_mode || !is_host_elf(tracee, host_path)) {
//		ArrayOfXPointers *argv;
//		size_t nb_qemu_args;
//		size_t i;
//
//		status = fetch_array_of_xpointers(tracee, &argv, SYSARG_2, 0);
//		if (status < 0)
//			return status;
//
//		status = read_xpointee_as_string(argv, 0, &argv0);
//		if (status < 0)
//			return status;
//
//		/* Assuming PRoot was invoked this way:
//		 *
//		 *     proot -q 'qemu-arm -cpu cortex-a9' ...
//		 *
//		 * a call to:
//		 *
//		 *     execve("/bin/true", { "true", NULL }, ...)
//		 *
//		 * becomes:
//		 *
//		 *     execve("/usr/bin/qemu",
//		 *           { "qemu", "-cpu", "cortex-a9", "-0", "true", "/bin/true", NULL }, ...)
//		 */
//
//		nb_qemu_args = vl_array_length(tracee->qemu) - 1;
//		status = resize_array_of_xpointers(argv, 1, nb_qemu_args + 2);
//		if (status < 0)
//			return status;
//
//		for (i = 0; i < nb_qemu_args; i++) {
//			status = write_xpointee(argv, i, tracee->qemu[i]);
//			if (status < 0)
//				return status;
//		}
//
//		status = write_xpointees(argv, i, 3, "-0", argv0, user_path);
//		if (status < 0)
//			return status;
//
//		/* Ensure LD_ features should not be applied to QEMU
//		 * iteself.  */
//		status = ldso_env_passthru(tracee, envp, argv, "-E", "-U", i);
//		if (status < 0)
//			return status;
//
//		status = push_array_of_xpointers(argv, SYSARG_2);
//		if (status < 0)
//			return status;
//
//		/* Launch the runner in lieu of the initial
//		 * program. */
//		assert(strlen(tracee->qemu[0]) + strlen(HOST_ROOTFS) < PATH_MAX);
//		assert(tracee->qemu[0][0] == '/');
//
//		strcpy(host_path, tracee->qemu[0]);
//
//		strcpy(user_path, HOST_ROOTFS);
//		strcat(user_path, host_path);
//	}
//
//	/* Provide information to the host dynamic linker to find host
//	 * libraries (remember the guest root file-system contains
//	 * libraries for the guest architecture only).  */
//	status = rebuild_host_ldso_paths(tracee, host_path, envp);
//	if (status < 0)
//		return status;
//
//	status = push_array_of_xpointers(envp, SYSARG_3);
//	if (status < 0)
//		return status;
//
//	return 0;
//}

//extern unsigned char _binary_loader_elf_start[];
//extern unsigned char _binary_loader_elf_end[];
//
//extern unsigned char WEAK _binary_loader_m32_elf_start[];
//extern unsigned char WEAK _binary_loader_m32_elf_end[];

/**
 * Extract the built-in loader.  This function returns NULL if an
 * error occurred, otherwise it returns the path to the extracted
 * loader.  Note: @tracee is only used for notification purpose.
 */
//static char *extract_loader(const Tracee *tracee, bool wants_32bit_version)
//{
//	char path[PATH_MAX];
//	size_t status2;
//	void *start;
//	size_t size;
//	int status;
//	int fd;
//
//	char *loader_path = NULL;
//	FILE *file = NULL;
//
//	file = open_temp_file(NULL, "prooted");
//	if (file == NULL)
//		goto end;
//	fd = fileno(file);
//
//	if (wants_32bit_version) {
//		start = (void *) _binary_loader_m32_elf_start;
//		size  = (size_t)(_binary_loader_m32_elf_end-_binary_loader_m32_elf_start);
//	}
//	else {
//		start = (void *) _binary_loader_elf_start;
//		size  = (size_t) (_binary_loader_elf_end-_binary_loader_elf_start);
//	}
//
//	status2 = write(fd, start, size);
//	if (status2 != size) {
////		note(tracee, ERROR, SYSTEM, "can't write the loader");
//        LOGSYSE("can't write the loader")
//		goto end;
//	}
//
//	status = fchmod(fd, S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH);
//	if (status < 0) {
////		note(tracee, ERROR, SYSTEM, "can't change loader permissions (u+rx)");
//        LOGSYSE("can't change loader permissions (u+rx)")
//		goto end;
//	}
//
//	status = readlink_proc_pid_fd(getpid(), fd, path);
//	if (status < 0) {
////		note(tracee, ERROR, INTERNAL, "can't retrieve loader path (/proc/self/fd/)");
//        LOGSYSE("can't retrieve loader path (/proc/self/fd/)")
//		goto end;
//	}
//
//	status = access(path, X_OK);
//	if (status < 0) {
////		note(tracee, ERROR, INTERNAL,
////			"it seems the current temporary directory (%s) "
////			"is mounted with no execution permission.",
////			get_temp_directory());
////		note(tracee, INFO, USER,
////			"Please set PROOT_TMP_DIR env. variable to an alternate "
////			"location ('%s/tmp' for example).", get_root(tracee));
//		LOGSYSE(
//			"it seems the current temporary directory (%s) "
//			"is mounted with no execution permission.",
//			get_temp_directory());
////        LOGSYS(
////			"Please set PROOT_TMP_DIR env. variable to an alternate "
////			"location ('%s/tmp' for example).", get_root(tracee));
//		goto end;
//	}
//
////	loader_path = talloc_strdup(talloc_autofree_context(), path);
//    loader_path = strdup(path);
//	if (loader_path == NULL) {
////		note(tracee, ERROR, INTERNAL, "can't allocate memory");
//        LOGSYSE("can't allocate memory")
//		goto end;
//	}
//
//	if (tracee->verbose >= 2)
////		note(tracee, INFO, INTERNAL, "loader: %s", loader_path);
//    LOGSYS("loader: %s", loader_path)
//
//end:
//	if (file != NULL) {
//		status = fclose(file);
//		if (status < 0)
////			note(tracee, WARNING, SYSTEM, "can't close loader file");
//        LOGSYSW( "can't close loader file")
//	}
//
//	return loader_path;
//}

/**
 * Get the path to the loader for the given @tracee.  This function
 * returns NULL if an error occurred.
 */
static inline const char *get_loader_path(const Tracee *tracee)
{

//    LOGE("get_loader_path")
//    return "get_loader_path";
	LOGSYS("vpid %d: get_loader_path start",tracee->vpid)
	//TODO 后面要改下(可能外部设置)，先设置为当前目录下的对应exe
    static char *loader_path = "./loader_arm64";



//#if defined(HAS_LOADER_32BIT)
	static char *loader32_path = "./loader_arm32";
	if (IS_CLASS32(tracee->load_info->elf_header)) {
//		loader32_path = loader32_path ?: getenv("PROOT_LOADER_32") ?: extract_loader(tracee, true);
        LOGSYS("vpid %d: get_loader_path loader32_path:%s",tracee->vpid,loader32_path)
		return loader32_path;
	}
	else
//#endif
	{
//		loader_path = loader_path ?: getenv("PROOT_LOADER") ?: extract_loader(tracee, false);
        LOGSYS("vpid %d: get_loader_path loader_path:%s",tracee->vpid,loader_path)
		return loader_path;
	}
}

/**
 * Extract all the information that will be required by
 * translate_load_*().  This function returns -errno if an error
 * occured, otherwise 0.
 */
int translate_execve_enter(Tracee *tracee)
{
	//文件路径
	char user_path[PATH_MAX];
	char host_path[PATH_MAX];
	char new_exe[PATH_MAX];
	char *raw_path;
	const char *loader_path;
	int status;

	if (IS_NOTIFICATION_PTRACED_LOAD_DONE(tracee)) {
		note(NULL,INFO,INTERNAL,"vpid %ld: translate_execve_enter ---- setvoid",tracee->vpid);
		/* Syscalls can now be reported to its ptracer.  */
		tracee->as_ptracee.ignore_loader_syscalls = false;

		/* Cancel this spurious execve, it was only used as a
		 * notification.  */
		set_sysnum(tracee, PR_void);
		return 0;
	}

	status = get_sysarg_path(tracee, user_path, SYSARG_1);
	if (status < 0)
		return status;

	/* Remember the user path before it is overwritten by
	 * expand_shebang().  This "raw" path is useful to fix the
	 * value of AT_EXECFN and /proc/{@tracee->pid}/comm.  */
//	raw_path = talloc_strdup(tracee->ctx, user_path);
    raw_path = strdup(user_path);
	if (raw_path == NULL)
		return -ENOMEM;

	//填充host_path和user_path这两个路径
	status = expand_shebang(tracee, host_path, user_path);
	if (status < 0)
		/* The Linux kernel actually returns -EACCES when
		 * trying to execute a directory.  */
		return status == -EISDIR ? -EACCES : status;
    LOGSYS("host path:%s,user_path:%s",host_path,user_path)
	/* user_path is modified only if there's an interpreter
	 * (ie. for a script or with qemu).  */
	if (status == 0)
//		TALLOC_FREE(raw_path);
        free(raw_path);

	/* Remember the new value for "/proc/self/exe".  It points to
	 * a canonicalized guest path, hence detranslate_path()
	 * instead of using user_path directly.  */
	strcpy(new_exe, host_path);
    //TODO 在这里没有路径变换的问题,实际就是new_exe
//	status = detranslate_path(tracee, new_exe, NULL);
//	if (status >= 0) {
//		talloc_unlink(tracee, tracee->new_exe);
//		tracee->new_exe = talloc_strdup(tracee, new_exe);
//	}
//	else
//		tracee->new_exe = NULL;
    tracee->new_exe = new_exe;

//	if (tracee->qemu != NULL) {
//		status = expand_runner(tracee, host_path, user_path);
//		if (status < 0)
//			return status;
//	}

//	TALLOC_FREE(tracee->load_info);
    free(tracee->load_info);

//	tracee->load_info = talloc_zero(tracee, LoadInfo);
    tracee->load_info = calloc(1, sizeof(LoadInfo));
	if (tracee->load_info == NULL)
		return -ENOMEM;

//	tracee->load_info->host_path = talloc_strdup(tracee->load_info, host_path);
    tracee->load_info->host_path = strdup(host_path);
	if (tracee->load_info->host_path == NULL)
		return -ENOMEM;

//	tracee->load_info->user_path = talloc_strdup(tracee->load_info, user_path);
    tracee->load_info->user_path = strdup(user_path);
	if (tracee->load_info->user_path == NULL)
		return -ENOMEM;

//	tracee->load_info->raw_path = (raw_path != NULL
//			? talloc_reparent(tracee->ctx, tracee->load_info, raw_path)
//			: talloc_reference(tracee->load_info, tracee->load_info->user_path));
    tracee->load_info->raw_path = (raw_path != NULL
                                   ? raw_path
                                   : tracee->load_info->user_path);
	if (tracee->load_info->raw_path == NULL)
		return -ENOMEM;
	//得到elf 头的信息
	status = extract_load_info(tracee, tracee->load_info);
	if (status < 0)
		return status;

	if (tracee->load_info->interp != NULL) {
		status = extract_load_info(tracee, tracee->load_info->interp);
		if (status < 0)
			return status;

		/* An ELF interpreter is supposed to be
		 * standalone.  */
		if (tracee->load_info->interp->interp != NULL)
			return -EINVAL;
	}

#if defined(USE_LOADER_EXE)
	compute_load_addresses(tracee);

	/* Execute the loader instead of the program.  */
	loader_path = get_loader_path(tracee);
	if (loader_path == NULL)
		return -ENOENT;
//
	status = set_sysarg_path(tracee, loader_path, SYSARG_1);
	if (status < 0)
		return status;

	/* Mask to its ptracer syscalls performed by the loader.  */
	tracee->as_ptracee.ignore_loader_syscalls = true;
#endif
	return 0;
}

```

`library/src/main/jni/execve/execve.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef EXECVE_H
#define EXECVE_H

#include <linux/limits.h>    /* PATH_MAX, */

#include "tracee/tracee.h"
#include "execve/elf.h"
#include "arch.h"

extern int translate_execve_enter(Tracee *tracee);
extern void translate_execve_exit(Tracee *tracee);
extern int translate_and_check_exec(Tracee *tracee, char host_path[PATH_MAX], const char *user_path);

typedef struct mapping {
	word_t addr;
	word_t length;
	word_t clear_length;
	word_t prot;
	word_t flags;
	word_t fd;
	word_t offset;
} Mapping;

typedef struct load_info {
	char *host_path;
	char *user_path;
	char *raw_path;
	Mapping *mappings;
	ElfHeader elf_header;
	bool needs_executable_stack;

	struct load_info *interp;
} LoadInfo;

#define IS_NOTIFICATION_PTRACED_LOAD_DONE(tracee) (			\
		(tracee)->as_ptracee.ptracer != NULL			\
		&& peek_reg((tracee), ORIGINAL, SYSARG_1) == (word_t) 1	\
		&& peek_reg((tracee), ORIGINAL, SYSARG_4) == (word_t) 2	\
		&& peek_reg((tracee), ORIGINAL, SYSARG_5) == (word_t) 3	\
		&& peek_reg((tracee), ORIGINAL, SYSARG_6) == (word_t) 4)

#endif /* EXECVE_H */

```

`library/src/main/jni/execve/exit.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <linux/auxvec.h>  /* AT_*,  */
//#include <talloc.h>     /* talloc*, */
#include <sys/mman.h>   /* MAP_*, */
#include <assert.h>     /* assert(3), */
#include <string.h>     /* strlen(3), strerror(3), */
#include <strings.h>    /* bzero(3), */
#include <signal.h>     /* kill(2), SIG*, */
#include <unistd.h>     /* write(2), */
#include <errno.h>      /* E*, */
#include <stdio.h>
#include <stdlib.h>

#include "execve/execve.h"
#include "execve/elf.h"
#include "loader/script.h"
#include "tracee/reg.h"
#include "tracee/abi.h"
#include "tracee/mem.h"
#include "syscall/sysnum.h"
#include "execve/auxv.h"
#include "path/binding.h"
#include "path/temp.h"
#include "constant.h"
#include "cmn/cmn_vlarray.h"
#include "note.h"
#include <inttypes.h>   /* PRI*, */
//#include "cli/note.h"


/**
 * Fill @path with the content of @vectors, formatted according to
 * @ptracee's current ABI.
 */
static int fill_file_with_auxv(const Tracee *ptracee, const char *path,
			const ElfAuxVector *vectors)
{
	const ssize_t current_sizeof_word = sizeof_word(ptracee);
	ssize_t status;
	int fd = -1;
	int i;

	fd = open(path, O_WRONLY);
	if (fd < 0)
		return -1;

	i = 0;
	do {
		status = write(fd, &vectors[i].type, current_sizeof_word);
		if (status < current_sizeof_word) {
			status = -1;
			goto end;
		}

		status = write(fd, &vectors[i].value, current_sizeof_word);
		if (status < current_sizeof_word) {
			status = -1;
			goto end;
		}
	} while (vectors[i++].type != AT_NULL);

	status = 0;
end:
	if (fd >= 0)
		(void) close(fd);

	return status;
}

/**
 * Bind content of @vectors over /proc/{@ptracee->pid}/auxv.  This
 * function returns -1 if an error occurred, otherwise 0.
 */
static int bind_proc_pid_auxv(const Tracee *ptracee) //触发时机？？？
{
	word_t vectors_address;
	ElfAuxVector *vectors;

	const char *guest_path;
	const char *host_path;
	Binding *binding;
	int status;

	vectors_address = get_elf_aux_vectors_address(ptracee);
	if (vectors_address == 0)
		return -1;

	vectors = fetch_elf_aux_vectors(ptracee, vectors_address);
	if (vectors == NULL)
		return -1;

	/* Path to these ELF auxiliary vectors.  */
//	guest_path = talloc_asprintf(ptracee->ctx, "/proc/%d/auxv", ptracee->pid);
//	if (guest_path == NULL)
//		return -1;
	if (asprintf(&guest_path,"/proc/%d/auxv", ptracee->pid) < 0){
		return -1;
	}

	/* Remove binding to this path, if any.  It contains ELF
	 * auxiliary vectors of the previous execve(2).  */
//	binding = get_binding(ptracee, GUEST, guest_path);
//	if (binding != NULL && compare_paths(binding->guest.path, guest_path) == PATHS_ARE_EQUAL) {
//		remove_binding_from_all_lists(ptracee, binding);
//		TALLOC_FREE(binding);
//	}

//TODO 这个位置考虑是否需要处理
//	host_path = create_temp_file(ptracee->ctx, "auxv");
//	if (host_path == NULL)
//		return -1;
//
//	status = fill_file_with_auxv(ptracee, host_path, vectors);
//	if (status < 0)
//		return -1;
//
//	/* Note: this binding will be removed once ptracee gets freed.  */
//	binding = insort_binding3(ptracee, ptracee->life_context, host_path, guest_path);
//	if (binding == NULL)
//		return -1;
//
//	/* This temporary file (host_path) will be removed once the
//	 * binding is freed.  */
//	talloc_reparent(ptracee->ctx, binding, host_path);

	return 0;
}

/**
 * Convert @mappings into load @script statements at the given @cursor
 * position.  This function returns the new cursor position.
 */
static void *transcript_mappings(void *cursor, const Mapping *mappings)
{
	size_t nb_mappings;
	size_t i;

	nb_mappings = vl_array_length(mappings);
	for (i = 0; i < nb_mappings; i++) {
		LoadStatement *statement = cursor;

		if ((mappings[i].flags & MAP_ANONYMOUS) != 0)
			statement->action = LOAD_ACTION_MMAP_ANON;
		else
			statement->action = LOAD_ACTION_MMAP_FILE;

		statement->mmap.addr   = mappings[i].addr;
		statement->mmap.length = mappings[i].length;
		statement->mmap.prot   = mappings[i].prot;
		statement->mmap.offset = mappings[i].offset;
		statement->mmap.clear_length = mappings[i].clear_length;

		cursor += LOAD_STATEMENT_SIZE(*statement, mmap);
	}

	return cursor;
}

/**
 * Convert @tracee->load_info into a load script, then transfer this
 * latter into @tracee's memory.
 */
static int transfer_load_script(Tracee *tracee)
{
	const word_t stack_pointer = peek_reg(tracee, CURRENT, STACK_POINTER);
	static word_t page_size = 0;
	static word_t page_mask = 0;

	word_t entry_point;

	size_t script_size;
	size_t strings_size;
	size_t string1_size;
	size_t string2_size;
	size_t string3_size;
	size_t padding_size;

	word_t string1_address;
	word_t string2_address;
	word_t string3_address;

	void *buffer;
	size_t buffer_size;

	bool needs_executable_stack;
	LoadStatement *statement;
	void *cursor;
	int status;

	if (page_size == 0) {
		page_size = sysconf(_SC_PAGE_SIZE);
		if ((int) page_size <= 0)
			page_size = 0x1000;
		page_mask = ~(page_size - 1);
	}

	needs_executable_stack = (tracee->load_info->needs_executable_stack
				|| (   tracee->load_info->interp != NULL
				    && tracee->load_info->interp->needs_executable_stack));

	/* Strings addresses are required to generate the load script,
	 * for "open" actions.  Since I want to generate it in one
	 * pass, these strings will be put right below the current
	 * stack pointer -- the only known adresses so far -- in the
	 * "strings area".  */
	string1_size = strlen(tracee->load_info->user_path) + 1;

	string2_size = (tracee->load_info->interp == NULL ? 0
			: strlen(tracee->load_info->interp->user_path) + 1);

	string3_size = (tracee->load_info->raw_path == tracee->load_info->user_path ? 0
			: strlen(tracee->load_info->raw_path) + 1);

	/* A padding will be appended at the end of the load script
	 * (a.k.a "strings area") to ensure this latter is aligned properly. */
	padding_size = (stack_pointer - string1_size - string2_size - string3_size)
			% STACK_ALIGNMENT;

	strings_size = string1_size + string2_size + string3_size + padding_size;
	string1_address = stack_pointer - strings_size;
	string2_address = stack_pointer - strings_size + string1_size;
	string3_address = (string3_size == 0
			? string1_address
			: stack_pointer - strings_size + string1_size + string2_size);

	/* Compute the size of the load script.  */
	script_size =
		LOAD_STATEMENT_SIZE(*statement, open)
		+ (LOAD_STATEMENT_SIZE(*statement, mmap)
			* vl_array_length(tracee->load_info->mappings))
		+ (tracee->load_info->interp == NULL ? 0
			: LOAD_STATEMENT_SIZE(*statement, open)
			+ (LOAD_STATEMENT_SIZE(*statement, mmap)
				* vl_array_length(tracee->load_info->interp->mappings)))
		+ (needs_executable_stack ? LOAD_STATEMENT_SIZE(*statement, make_stack_exec) : 0)
		+ LOAD_STATEMENT_SIZE(*statement, start);

	/* Allocate enough room for both the load script and the
	 * strings area.  */
	buffer_size = script_size + strings_size;
//	buffer = talloc_zero_size(tracee->ctx, buffer_size);
	buffer = calloc(1,buffer_size);
	if (buffer == NULL)
		return -ENOMEM;

	cursor = buffer;

	/* Load script statement: open.  */
	statement = cursor;
	statement->action = LOAD_ACTION_OPEN;
	statement->open.string_address = string1_address;

	cursor += LOAD_STATEMENT_SIZE(*statement, open);

	/* Load script statements: mmap.  */
	cursor = transcript_mappings(cursor, tracee->load_info->mappings);

	if (tracee->load_info->interp != NULL) {
		/* Load script statement: open.  */
		statement = cursor;
		statement->action = LOAD_ACTION_OPEN_NEXT;
		statement->open.string_address = string2_address;

		cursor += LOAD_STATEMENT_SIZE(*statement, open);

		/* Load script statements: mmap.  */
		cursor = transcript_mappings(cursor, tracee->load_info->interp->mappings);

		entry_point = ELF_FIELD(tracee->load_info->interp->elf_header, entry);
	}
	else
		entry_point = ELF_FIELD(tracee->load_info->elf_header, entry);

	if (needs_executable_stack) {
		/* Load script statement: stack_exec.  */
		statement = cursor;

		statement->action = LOAD_ACTION_MAKE_STACK_EXEC;
		statement->make_stack_exec.start = stack_pointer & page_mask;

		cursor += LOAD_STATEMENT_SIZE(*statement, make_stack_exec);
	}

	/* Load script statement: start.  */
	statement = cursor;

	/* Start of the program slightly differs when ptraced.  */
	if (tracee->as_ptracee.ptracer != NULL)
		statement->action = LOAD_ACTION_START_TRACED;
	else
		statement->action = LOAD_ACTION_START;

	statement->start.stack_pointer = stack_pointer;
	statement->start.entry_point   = entry_point;
	statement->start.at_phent = ELF_FIELD(tracee->load_info->elf_header, phentsize);
	statement->start.at_phnum = ELF_FIELD(tracee->load_info->elf_header, phnum);
	statement->start.at_entry = ELF_FIELD(tracee->load_info->elf_header, entry);
	statement->start.at_phdr  = ELF_FIELD(tracee->load_info->elf_header, phoff)
				  + tracee->load_info->mappings[0].addr;
	statement->start.at_execfn = string3_address;

	cursor += LOAD_STATEMENT_SIZE(*statement, start);

	/* Sanity check.  */
	assert((uintptr_t) cursor - (uintptr_t) buffer == script_size);

	/* Convert the load script to the expected format.  */
	if (is_32on64_mode(tracee)) {
		int i;
		for (i = 0; buffer + i * sizeof(uint64_t) < cursor; i++)
			((uint32_t *) buffer)[i] = ((uint64_t *) buffer)[i];
	}

	/* Concatenate the load script and the strings.  */
	memcpy(cursor, tracee->load_info->user_path, string1_size);
	cursor += string1_size;

	if (string2_size != 0) {
		memcpy(cursor, tracee->load_info->interp->user_path, string2_size);
		cursor += string2_size;
	}

	if (string3_size != 0) {
		memcpy(cursor, tracee->load_info->raw_path, string3_size);
		cursor += string3_size;
	}

	/* Sanity check.  */
	cursor += padding_size;
	assert((uintptr_t) cursor - (uintptr_t) buffer == buffer_size);

	/* Allocate enough room in tracee's memory for the load
	 * script, and make the first user argument points to this
	 * location.  Note that it is safe to update the stack pointer
	 * manually since we are in execve sysexit.  However it should
	 * be done before transfering data since the kernel might not
	 * allow page faults below the stack pointer.  */
	poke_reg(tracee, STACK_POINTER, stack_pointer - buffer_size);
	poke_reg(tracee, USERARG_1, stack_pointer - buffer_size);

	/* Copy everything in the tracee's memory at once.  */
	status = write_data(tracee, stack_pointer - buffer_size, buffer, buffer_size);
	if (status < 0)
		return status;

	/* Tracee's stack content is now as follow:
	 *
	 *   +------------+ <- initial stack pointer (higher address)
	 *   |  padding   |
	 *   +------------+
	 *   |  string3   |
	 *   +------------+
	 *   |  string2   |
	 *   +------------+
	 *   |  string1   |
	 *   +------------+
	 *   |   start    |
	 *   +------------+
	 *   | mmap anon  |
	 *   +------------+
	 *   | mmap file  |
	 *   +------------+
	 *   | open next  |
	 *   +------------+
	 *   | mmap anon. |
	 *   +------------+
	 *   | mmap file  |
	 *   +------------+
	 *   |   open     |
	 *   +------------+ <- stack pointer, userarg1 (word aligned)
	 */

	/* Remember we are in the sysexit stage, so be sure the
	 * current register values will be used as-is at the end.  */
	save_current_regs(tracee, ORIGINAL);
	tracee->_regs_were_changed = true;

	return 0;
}

/**
 * Start the loading of @tracee.  This function returns no error since
 * it's either too late to do anything useful (the calling process is
 * already replaced) or the error reported by the kernel
 * (syscall_result < 0) will be propagated as-is.
 */
void translate_execve_exit(Tracee *tracee)
{
	word_t syscall_result;
	int status;

    LOGSYS("translate_execve_exit -----------vpid: %lu,ptracer:%p",tracee->vpid,(tracee)->as_ptracee.ptracer)
	if (IS_NOTIFICATION_PTRACED_LOAD_DONE(tracee)) {
		VERBOSE(tracee, 6, "vpid %" PRIu64 ": translate_execve_exit, notify ptrace---------------------",
				tracee->vpid);
		/* Be sure not to confuse the ptracer with an
		 * unexpected syscall/returned value.  */
		poke_reg(tracee, SYSARG_RESULT, 0);
		set_sysnum(tracee, PR_execve);

		/* According to most ABIs, all registers have
		 * undefined values at program startup except:
		 *
		 * - the stack pointer
		 * - the instruction pointer
		 * - the rtld_fini pointer
		 * - the state flags
		 */
		poke_reg(tracee, STACK_POINTER, peek_reg(tracee, ORIGINAL, SYSARG_2));
		poke_reg(tracee, INSTR_POINTER, peek_reg(tracee, ORIGINAL, SYSARG_3));
		poke_reg(tracee, RTLD_FINI, 0);
		poke_reg(tracee, STATE_FLAGS, 0);

#if defined(ARCH_ARM_EABI) && defined(__thumb__)
		/* Leave ARM thumb mode */
		tracee->_regs[CURRENT].ARM_cpsr &= ~PSR_T_BIT;
#endif

		/* Restore registers to their current values.  */
		save_current_regs(tracee, ORIGINAL);
		tracee->_regs_were_changed = true;

		/* This is is required to make GDB work correctly
		 * under PRoot, however it deserves to be used
		 * unconditionally.  */
		(void) bind_proc_pid_auxv(tracee);

		/* If the PTRACE_O_TRACEEXEC option is *not* in effect
		 * for the execing tracee, the kernel delivers an
		 * extra SIGTRAP to the tracee after execve(2)
		 * *returns*.  This is an ordinary signal (similar to
		 * one which can be generated by "kill -TRAP"), not a
		 * special kind of ptrace-stop.  Employing
		 * PTRACE_GETSIGINFO for this signal returns si_code
		 * set to 0 (SI_USER).  This signal may be blocked by
		 * signal mask, and thus may be delivered (much)
		 * later. -- man 2 ptrace
		 *
		 * This signal is delayed so far since the program was
		 * not fully loaded yet; GDB would get "invalid
		 * adress" errors otherwise.  */
		if ((tracee->as_ptracee.options & PTRACE_O_TRACEEXEC) == 0)
			kill(tracee->pid, SIGTRAP);

		return;
	}
	//是不是在arm64里execve了一个arm32程序
#ifdef ARCH_ARM64
	tracee->is_aarch32 = IS_CLASS32(tracee->load_info->elf_header);
	LOGSYS("is_aarch32 1 %d--------------------",tracee->is_aarch32)
#endif
	syscall_result = peek_reg(tracee, CURRENT, SYSARG_RESULT);
	if ((int) syscall_result < 0)
		return;

	/* Execve happened; commit the new "/proc/self/exe".  */
	if (tracee->new_exe != NULL) {
//		(void) talloc_unlink(tracee, tracee->exe);
//		tracee->exe = talloc_reference(tracee, tracee->new_exe);
//		tracee->exe = tracee->new_exe;
//		talloc_set_name_const(tracee->exe, "$exe");
	}

	/* New processes have no heap. The process could've been cloned with
	 * CLONE_VM so it has been sharing the heap with its parent. execve()
	 * discards the VM so make sure to reallocate new heap. */
//	if (talloc_reference_count(tracee->heap) > 0) {
//		talloc_unlink(tracee, tracee->heap);
//		tracee->heap = talloc_zero(tracee, Heap);
//		if (!tracee->heap)
//			note(tracee, ERROR, INTERNAL, "can't allocate heap");
//	} else {
//		bzero(tracee->heap, sizeof(Heap));
//	}

#if defined(USE_LOADER_EXE)
	/* Transfer the load script to the loader.  */
	status = transfer_load_script(tracee);
	if (status < 0)
		note(tracee, ERROR, INTERNAL, "can't transfer load script: %s", strerror(-status));
#endif
	return;
}

```

`library/src/main/jni/execve/ldso.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <stdbool.h> /* bool, true, false, */
#include <string.h>  /* strlen(3), strcpy(3), strcat(3), strcmp(3), */
#include <stdlib.h>  /* getenv(3), */
#include <assert.h>  /* assert(3), */
#include <errno.h>   /* ENOMEM, */
#include <unistd.h>  /* close(2), */
#include <linux/limits.h>  /* PATH_MAX, ARG_MAX, */

#include "execve/ldso.h"
#include "execve/elf.h"
#include "execve/aoxp.h"
#include "tracee/tracee.h"
#include "cli/note.h"

/**
 * Check if the environment @variable has the given @name.
 */
bool is_env_name(const char *variable, const char *name)
{
	size_t length = strlen(name);

	return (variable[0] == name[0]
		&& length < strlen(variable)
		&& variable[length] == '='
		&& strncmp(variable, name, length) == 0);
}

/**
 * This function returns 1 or 0 depending on the equivalence of the
 * @reference environment variable and the one pointed to by the entry
 * in @envp at the given @index, otherwise it returns -errno when an
 * error occured.
 */
int compare_xpointee_env(ArrayOfXPointers *envp, size_t index, const char *reference)
{
	char *value;
	int status;

	assert(index < envp->length);

	status = read_xpointee_as_string(envp, index, &value);
	if (status < 0)
		return status;

	if (value == NULL)
		return 0;

	return (int)is_env_name(value, reference);
}

/**
 * This function ensures that environment variables related to the
 * dynamic linker are applied to the emulated program, not to QEMU
 * itself.  For instance, let's say the user has entered the
 * command-line below:
 *
 *     env LD_TRACE_LOADED_OBJECTS=1 /bin/ls
 *
 * It should be converted to:
 *
 *     qemu -E LD_TRACE_LOADED_OBJECTS=1 /bin/ls
 *
 * instead of:
 *
 *     env LD_TRACE_LOADED_OBJECTS=1 qemu /bin/ls
 *
 * Note that the LD_LIBRARY_PATH variable is always required to run
 * QEMU (a host binary):
 *
 *     env LD_LIBRARY_PATH=... qemu -U LD_LIBRARY_PATH /bin/ls
 *
 * or when LD_LIBRARY_PATH was also specified by the user:
 *
 *     env LD_LIBRARY_PATH=... qemu -E LD_LIBRARY_PATH=... /bin/ls
 *
 * This funtion returns -errno if an error occured, otherwise 0.
 */
int ldso_env_passthru(const Tracee *tracee, ArrayOfXPointers *envp, ArrayOfXPointers *argv,
		const char *define, const char *undefine, size_t offset)
{
	bool has_seen_library_path = false;
	int status;
	size_t i;

	for (i = 0; i < envp->length; i++) {
		bool is_known = false;
		char *env;

		status = read_xpointee_as_string(envp, i, &env);
		if (status < 0)
			return status;

		/* Skip variables that do not start with "LD_".  */
		if (env == NULL || strncmp(env, "LD_", sizeof("LD_") - 1) != 0)
			continue;

		/* When a host program executes a guest program, use
		 * the value of LD_LIBRARY_PATH as it was before being
		 * swapped by the mixed-mode support.  */
		if (   tracee->host_ldso_paths != NULL
		    && tracee->guest_ldso_paths != NULL
		    && is_env_name(env, "LD_LIBRARY_PATH")
		    && strcmp(env, tracee->host_ldso_paths) == 0)
			env = (char *) tracee->guest_ldso_paths;

#define PASSTHRU(check, name)						\
		if (is_env_name(env, name)) {				\
			check |= true;					\
			/* Errors are not fatal here.  */		\
			status = resize_array_of_xpointers(argv, offset, 2);	\
			if (status >= 0) {				\
				status = write_xpointees(argv, offset, 2, define, env); \
				if (status < 0)				\
					return status;			\
			}						\
			write_xpointee(envp, i, "");			\
			continue;					\
		}							\

		PASSTHRU(has_seen_library_path, "LD_LIBRARY_PATH");
		PASSTHRU(is_known, "LD_PRELOAD");
		PASSTHRU(is_known, "LD_BIND_NOW");
		PASSTHRU(is_known, "LD_TRACE_LOADED_OBJECTS");
		PASSTHRU(is_known, "LD_AOUT_LIBRARY_PATH");
		PASSTHRU(is_known, "LD_AOUT_PRELOAD");
		PASSTHRU(is_known, "LD_AUDIT");
		PASSTHRU(is_known, "LD_BIND_NOT");
		PASSTHRU(is_known, "LD_DEBUG");
		PASSTHRU(is_known, "LD_DEBUG_OUTPUT");
		PASSTHRU(is_known, "LD_DYNAMIC_WEAK");
		PASSTHRU(is_known, "LD_HWCAP_MASK");
		PASSTHRU(is_known, "LD_KEEPDIR");
		PASSTHRU(is_known, "LD_NOWARN");
		PASSTHRU(is_known, "LD_ORIGIN_PATH");
		PASSTHRU(is_known, "LD_POINTER_GUARD");
		PASSTHRU(is_known, "LD_PROFILE");
		PASSTHRU(is_known, "LD_PROFILE_OUTPUT");
		PASSTHRU(is_known, "LD_SHOW_AUXV");
		PASSTHRU(is_known, "LD_USE_LOAD_BIAS");
		PASSTHRU(is_known, "LD_VERBOSE");
		PASSTHRU(is_known, "LD_WARN");
	}

	if (!has_seen_library_path) {
		/* Errors are not fatal here.  */
		status = resize_array_of_xpointers(argv, offset, 2);
		if (status >= 0) {
			status = write_xpointees(argv, offset, 2, undefine, "LD_LIBRARY_PATH");
			if (status < 0)
				return status;
		}
	}

	return 0;
}

/**
 * Add to @host_ldso_paths the list of @paths prefixed with the path
 * to the host rootfs.
 */
static int add_host_ldso_paths(char host_ldso_paths[ARG_MAX], const char *paths)
{
	char *cursor1;
	const char *cursor2;

	cursor1 = host_ldso_paths + strlen(host_ldso_paths);
	cursor2 = paths;

	do {
		bool is_absolute;
		size_t length1;
		size_t length2 = strcspn(cursor2, ":");

		is_absolute = (*cursor2 == '/');

		length1 = 1 + length2;
		if (is_absolute)
			length1 += strlen(HOST_ROOTFS);

		/* Check there's enough room.  */
		if (cursor1 + length1 >= host_ldso_paths + ARG_MAX)
			return -ENOEXEC;

		if (cursor1 != host_ldso_paths) {
			strcpy(cursor1, ":");
			cursor1++;
		}

		/* Since we are executing a host binary under a
		 * QEMUlated environment, we have to access its
		 * library paths through the "host-rootfs" binding.
		 * Technically it means a path like "/lib" is accessed
		 * as "${HOST_ROOTFS}/lib" to avoid conflict with the
		 * guest "/lib".  */
		if (is_absolute) {
			strcpy(cursor1, HOST_ROOTFS);
			cursor1 += strlen(HOST_ROOTFS);
		}

		strncpy(cursor1, cursor2, length2);
		cursor1 += length2;

		cursor2 += length2 + 1;
	} while (*(cursor2 - 1) != '\0');

	*cursor1 = '\0';

	return 0;
}

struct find_program_header_data {
	ProgramHeader *program_header;
	SegmentType type;
	uint64_t address;
};

/**
 * This function is a program header iterator.  It stops the iteration
 * (by returning 1) once it has found a program header that matches
 * @data.  This function returns -errno if an error occurred,
 * otherwise 0 or 1.
 */
static int find_program_header(const ElfHeader *elf_header,
			const ProgramHeader *program_header, void *data_)
{
	struct find_program_header_data *data = data_;

	if (PROGRAM_FIELD(*elf_header, *program_header, type) == data->type) {
		uint64_t start;
		uint64_t end;

		memcpy(data->program_header, program_header, sizeof(ProgramHeader));

		if (data->address == (uint64_t) -1)
			return 1;

		start = PROGRAM_FIELD(*elf_header, *program_header, vaddr);
		end   = start + PROGRAM_FIELD(*elf_header, *program_header, memsz);

		if (start < end
			&& data->address >= start
			&& data->address <= end)
			return 1;
	}

	return 0;
}

/**
 * Add to @xpaths the paths (':'-separated list) from the file
 * referenced by @fd at the given @offset.  This function returns
 * -errno if an error occured, otherwise 0.
 */
static int add_xpaths(const Tracee *tracee, int fd, uint64_t offset, char **xpaths)
{
	char *paths = NULL;
	char *tmp;

	size_t length;
	size_t size;
	int status;

	status = (int) lseek(fd, offset, SEEK_SET);
	if (status < 0)
		return -errno;

	/* Read the complete list of paths.  */
	length = 0;
	paths = NULL;
	do {
		size = length + 1024;

		tmp = talloc_realloc(tracee->ctx, paths, char, size);
		if (!tmp)
			return -ENOMEM;
		paths = tmp;

		status = read(fd, paths + length, 1024);
		if (status < 0)
			return status;

		length += strnlen(paths + length, 1024);
	} while (length == size);

	/* Concatene this list of paths to xpaths.  */
	if (!*xpaths) {
		*xpaths = talloc_array(tracee->ctx, char, length + 1);
		if (!*xpaths)
			return -ENOMEM;

		strcpy(*xpaths, paths);
	}
	else {
		length += strlen(*xpaths);
		length++; /* ":" separator */

		tmp = talloc_realloc(tracee->ctx, *xpaths, char, length + 1);
		if (!tmp)
			return -ENOMEM;
		*xpaths = tmp;

		strcat(*xpaths, ":");
		strcat(*xpaths, paths);
	}

	/* I don't know if DT_R*PATH entries are unique.  In
	 * doubt I support multiple entries.  */
	return 0;
}

/**
 * Put the RPATH and RUNPATH dynamic entries from the file referenced
 * by @fd -- which has the provided @elf_header -- in @rpaths and
 * @runpaths respectively.  This function returns -errno if an error
 * occured, otherwise 0.
 */
static int read_ldso_rpaths(const Tracee* tracee, int fd, const ElfHeader *elf_header,
		char **rpaths, char **runpaths)
{
	ProgramHeader dynamic_segment;
	ProgramHeader strtab_segment;
	struct find_program_header_data data;
	uint64_t strtab_address = (uint64_t) -1;
	off_t strtab_offset;
	int status;
	size_t i;

	uint64_t offsetof_dynamic_segment;
	uint64_t sizeof_dynamic_segment;
	size_t sizeof_dynamic_entry;

	data.program_header = &dynamic_segment;
	data.type = PT_DYNAMIC;
	data.address = (uint64_t) -1;

	status = iterate_program_headers(tracee, fd, elf_header, find_program_header, &data);
	if (status <= 0)
		return status;

	offsetof_dynamic_segment = PROGRAM_FIELD(*elf_header, dynamic_segment, offset);
	sizeof_dynamic_segment   = PROGRAM_FIELD(*elf_header, dynamic_segment, filesz);

	if (IS_CLASS32(*elf_header))
		sizeof_dynamic_entry = sizeof(DynamicEntry32);
	else
		sizeof_dynamic_entry = sizeof(DynamicEntry64);

	if (sizeof_dynamic_segment % sizeof_dynamic_entry != 0)
		return -ENOEXEC;

/**
 * Invoke @embedded_code on each dynamic entry of the given @type.
 */
#define FOREACH_DYNAMIC_ENTRY(type, embedded_code)					\
	for (i = 0; i < sizeof_dynamic_segment / sizeof_dynamic_entry; i++) {		\
		DynamicEntry dynamic_entry;						\
		uint64_t value;								\
											\
		/* embedded_code may change the file offset.  */			\
		status = (int) lseek(fd, offsetof_dynamic_segment + i * sizeof_dynamic_entry, \
				SEEK_SET);						\
		if (status < 0)								\
			return -errno;							\
											\
		status = read(fd, &dynamic_entry, sizeof_dynamic_entry);		\
		if (status < 0)								\
			return status;							\
											\
		if (DYNAMIC_FIELD(*elf_header, dynamic_entry, tag) != type)		\
			continue;							\
											\
		value =	DYNAMIC_FIELD(*elf_header, dynamic_entry, val);			\
											\
		embedded_code								\
	}

	/* Get the address of the *first* string table.  The ELF
	 * specification doesn't mention if it may have several string
	 * table references.  */
	FOREACH_DYNAMIC_ENTRY(DT_STRTAB, {
		strtab_address = value;
		break;
	})

	if (strtab_address == (uint64_t) -1)
		return 0;

	data.program_header = &strtab_segment;
	data.type = PT_LOAD;
	data.address = strtab_address;

	/* Search the program header that contains the given string table.  */
	status = iterate_program_headers(tracee, fd, elf_header, find_program_header, &data);
	if (status < 0)
		return status;

	strtab_offset = PROGRAM_FIELD(*elf_header, strtab_segment, offset)
		+ (strtab_address - PROGRAM_FIELD(*elf_header, strtab_segment, vaddr));

	FOREACH_DYNAMIC_ENTRY(DT_RPATH,	{
		if (strtab_offset < 0 || (uint64_t) strtab_offset > UINT64_MAX - value)
			return -ENOEXEC;

		status = add_xpaths(tracee, fd, strtab_offset + value, rpaths);
		if (status < 0)
			return status;
	})

	FOREACH_DYNAMIC_ENTRY(DT_RUNPATH, {
		if (strtab_offset < 0 || (uint64_t) strtab_offset > UINT64_MAX - value)
			return -ENOEXEC;

		status = add_xpaths(tracee, fd, strtab_offset + value, runpaths);
		if (status < 0)
			return status;
	})

#undef FOREACH_DYNAMIC_ENTRY

	return 0;
}

/**
 * Rebuild the variable LD_LIBRARY_PATH in @envp for the program
 * @host_path according to its RPATH, RUNPATH, and the initial
 * LD_LIBRARY_PATH.  This function returns -errno if an error occured,
 * 1 if RPATH/RUNPATH entries were found, 0 otherwise.
 */
int rebuild_host_ldso_paths(Tracee *tracee, const char host_path[PATH_MAX], ArrayOfXPointers *envp)
{
	static char *initial_ldso_paths = NULL;
	ElfHeader elf_header;

	char host_ldso_paths[ARG_MAX] = "";
	bool rpath_found = false;

	char *rpaths   = NULL;
	char *runpaths = NULL;

	size_t length1;
	size_t length2;

	size_t index;
	int status;
	int fd;

	fd = open_elf(host_path, &elf_header);
	if (fd < 0)
		return fd;

	status = read_ldso_rpaths(tracee, fd, &elf_header, &rpaths, &runpaths);
	close(fd);
	if (status < 0)
		return status;

	/* 1. DT_RPATH  */
	if (rpaths && !runpaths) {
		status = add_host_ldso_paths(host_ldso_paths, rpaths);
		if (status < 0)
			return 0; /* Not fatal.  */
		rpath_found = true;
	}

	/* 2. LD_LIBRARY_PATH  */
	if (initial_ldso_paths == NULL)
		initial_ldso_paths = strdup(getenv("LD_LIBRARY_PATH") ?: "/");
	if (initial_ldso_paths != NULL && initial_ldso_paths[0] != '\0') {
		status = add_host_ldso_paths(host_ldso_paths, initial_ldso_paths);
		if (status < 0)
			return 0; /* Not fatal.  */
	}

	/* 3. DT_RUNPATH  */
	if (runpaths) {
		status = add_host_ldso_paths(host_ldso_paths, runpaths);
		if (status < 0)
			return 0; /* Not fatal.  */
		rpath_found = true;
	}

	/* 4. /etc/ld.so.cache NYI.  */

	/* 5. /lib[32|64], /usr/lib[32|64] + /usr/local/lib[32|64]  */
	/* 6. /lib, /usr/lib + /usr/local/lib  */
	if (IS_CLASS32(elf_header))
		status = add_host_ldso_paths(host_ldso_paths,
#if defined(ARCH_X86) || defined(ARCH_X86_64)
					"/lib/i386-linux-gnu:/usr/lib/i386-linux-gnu:"
#endif
					"/lib32:/usr/lib32:/usr/local/lib32"
					":/lib:/usr/lib:/usr/local/lib");
	else
		status = add_host_ldso_paths(host_ldso_paths,
#if defined(ARCH_X86_64)
					"/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:"
#elif defined(ARCH_ARM64)
					"/lib/aarch64-linux-gnu:/usr/lib/aarch64-linux-gnu:"
#endif
					"/lib64:/usr/lib64:/usr/local/lib64"
					":/lib:/usr/lib:/usr/local/lib");
	if (status < 0)
		return 0; /* Not fatal.  */

	status = find_xpointee(envp, "LD_LIBRARY_PATH");
	if (status < 0)
		return 0; /* Not fatal.  */
	index = (size_t) status;

	if (index == envp->length) {
		/* Allocate a new entry at the end of envp[] when
		 * LD_LIBRARY_PATH was not found.  */

		index = (envp->length > 0 ? envp->length - 1 : 0);
		status = resize_array_of_xpointers(envp, index, 1);
		if (status < 0)
			return 0; /* Not fatal.  */
	}
	else if (tracee->guest_ldso_paths == NULL) {
		/* Remember guest LD_LIBRARY_PATH in order to restore
		 * it when a host program will execute a guest
		 * program.  */
		char *env;

		/* Errors are not fatal here.  */
		status = read_xpointee_as_string(envp, index, &env);
		if (status >= 0)
			tracee->guest_ldso_paths = talloc_strdup(tracee, env);
	}

	/* Forge the new LD_LIBRARY_PATH variable from
	 * host_ldso_paths.  */
	length1 = strlen("LD_LIBRARY_PATH=");
	length2 = strlen(host_ldso_paths);
	if (ARG_MAX - length2 - 1 < length1)
		return 0; /* Not fatal.  */

	memmove(host_ldso_paths + length1, host_ldso_paths, length2 + 1);
	memcpy(host_ldso_paths, "LD_LIBRARY_PATH=" , length1);

	write_xpointee(envp, index, host_ldso_paths);

	/* The guest LD_LIBRARY_PATH will be restored only if the host
	 * program didn't change it explicitly, so remember its
	 * initial value.  */
	if (tracee->host_ldso_paths == NULL)
		tracee->host_ldso_paths = talloc_strdup(tracee, host_ldso_paths);

	return (int) rpath_found;
}

```

`library/src/main/jni/execve/ldso.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef LDSO_H
#define LDSO_H

#include <linux/limits.h>
#include <stdbool.h>

#include "execve/aoxp.h"
#include "execve/elf.h"

extern int ldso_env_passthru(const Tracee *tracee, ArrayOfXPointers *envp, ArrayOfXPointers *argv,
			const char *define, const char *undefine, size_t offset);

extern int rebuild_host_ldso_paths(Tracee *tracee, const char t_program[PATH_MAX],
				ArrayOfXPointers *envp);

extern int compare_xpointee_env(ArrayOfXPointers *envp, size_t index, const char *name);

extern bool is_env_name(const char *variable, const char *name);

#endif /* LDSO_H */

```

`library/src/main/jni/execve/shebang.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sys/types.h>     /* open(2), */
#include <sys/stat.h>      /* open(2), */
#include <fcntl.h>         /* open(2), */
#include <linux/limits.h>  /* PATH_MAX, */
#include <linux/binfmts.h> /* BINPRM_BUF_SIZE, */
#include <unistd.h>        /* read(2), close(2), */
#include <errno.h>         /* -E*, */
#include <sys/param.h>     /* MAXSYMLINKS, */
#include <stdbool.h>       /* bool, */
#include <assert.h>        /* assert(3), */
#include <string.h>

#include "execve/shebang.h"
#include "execve/execve.h"
#include "execve/aoxp.h"
#include "tracee/tracee.h"
#include "attribute.h"

/**
 * Extract into @user_path and @argument the shebang from @host_path.
 * This function returns -errno if an error occured, 1 if a shebang
 * was found and extracted, otherwise 0.
 *
 * Extract from "man 2 execve":
 *
 *     On Linux, the entire string following the interpreter name is
 *     passed as a *single* argument to the interpreter, and this
 *     string can include white space.
 */
static int extract_shebang(const Tracee *tracee UNUSED, const char *host_path,
		char user_path[PATH_MAX], char argument[BINPRM_BUF_SIZE])
{
	char tmp2[2];
	char tmp;

	size_t current_length;
	size_t i;

	int status;
	int fd;

	/* Assumption.  */
	assert(BINPRM_BUF_SIZE < PATH_MAX);

	argument[0] = '\0';

	/* Inspect the executable.  */
	fd = open(host_path, O_RDONLY);
	if (fd < 0)
		return -errno;

	status = read(fd, tmp2, 2 * sizeof(char));
	if (status < 0) {
		status = -errno;
		goto end;
	}
	if ((size_t) status < 2 * sizeof(char)) { /* EOF */
		status = 0;
		goto end;
	}

	/* Check if it really is a script text. */
	if (tmp2[0] != '#' || tmp2[1] != '!') {
		status = 0;
		goto end;
	}
	current_length = 2;
	user_path[0] = '\0';

	/* Skip leading spaces. */
	do {
		status = read(fd, &tmp, sizeof(char));
		if (status < 0) {
			status = -errno;
			goto end;
		}
		if ((size_t) status < sizeof(char)) { /* EOF */
			status = -ENOEXEC;
			goto end;
		}

		current_length++;
	} while ((tmp == ' ' || tmp == '\t') && current_length < BINPRM_BUF_SIZE);

	/* Slurp the interpreter path until the first space or end-of-line. */
	for (i = 0; current_length < BINPRM_BUF_SIZE; current_length++, i++) {
		switch (tmp) {
		case ' ':
		case '\t':
			/* Remove spaces in between the interpreter
			 * and the hypothetical argument. */
			user_path[i] = '\0';
			break;

		case '\n':
		case '\r':
			/* There is no argument. */
			user_path[i] = '\0';
			argument[0] = '\0';
			status = 1;
			goto end;

		default:
			/* There is an argument if the previous
			 * character in user_path[] is '\0'. */
			if (i > 1 && user_path[i - 1] == '\0')
				goto argument;
			else
				user_path[i] = tmp;
			break;
		}

		status = read(fd, &tmp, sizeof(char));
		if (status < 0) {
			status = -errno;
			goto end;
		}
		if ((size_t) status < sizeof(char)) { /* EOF */
			user_path[i] = '\0';
			argument[0] = '\0';
			status = 1;
			goto end;
		}
	}

	/* The interpreter path is too long, truncate it. */
	user_path[i] = '\0';
	argument[0] = '\0';
	status = 1;
	goto end;

argument:

	/* Slurp the argument until the end-of-line. */
	for (i = 0; current_length < BINPRM_BUF_SIZE; current_length++, i++) {
		switch (tmp) {
		case '\n':
		case '\r':
			argument[i] = '\0';

			/* Remove trailing spaces. */
			for (i--; i > 0 && (argument[i] == ' ' || argument[i] == '\t'); i--)
				argument[i] = '\0';

			status = 1;
			goto end;

		default:
			argument[i] = tmp;
			break;
		}

		status = read(fd, &tmp, sizeof(char));
		if (status < 0) {
			status = -errno;
			goto end;
		}
		if ((size_t) status < sizeof(char)) { /* EOF */
			argument[0] = '\0';
			status = 1;
			goto end;
		}
	}

	/* The argument is too long, truncate it. */
	argument[i] = '\0';
	status = 1;

end:
	close(fd);

	/* Did an error occur or isn't a script? */
	if (status <= 0)
		return status;

	return 1;
}

/**
 * Expand in argv[] the shebang of @user_path, if any.  This function
 * returns -errno if an error occurred, 1 if a shebang was found and
 * extracted, otherwise 0.  On success, both @host_path and @user_path
 * point to the program to execute (respectively from host
 * point-of-view and as-is), and @tracee's argv[] (pointed to by
 * SYSARG_2) is correctly updated.
 */
int expand_shebang(Tracee *tracee, char host_path[PATH_MAX], char user_path[PATH_MAX])
{
//	ArrayOfXPointers *argv = NULL;
	bool has_shebang = false;

	char argument[BINPRM_BUF_SIZE];
	int status;
	size_t i;

	/* "The interpreter must be a valid pathname for an executable
	 *  which is not itself a script [1].  If the filename
	 *  argument of execve() specifies an interpreter script, then
	 *  interpreter will be invoked with the following arguments:
	 *
	 *    interpreter [optional-arg] filename arg...
	 *
	 * where arg...  is the series of words pointed to by the argv
	 * argument of execve()." -- man 2 execve
	 *
	 * [1]: as of this writing (3.10.17) this is true only for the
	 *      ELF interpreter; ie. a script can use a script as
	 *      interpreter.
	 */
	for (i = 0; i < MAXSYMLINKS; i++) {
		char *old_user_path;

		/* Translate this path (user -> host), then check it is executable.  */
		status = translate_and_check_exec(tracee, host_path, user_path);
		if (status < 0)
			return status;

		/* Remember the initial user path.  */
//		old_user_path = talloc_strdup(tracee->ctx, user_path);
		old_user_path = strdup(user_path);
		if (old_user_path == NULL)
			return -ENOMEM;

		/* Extract into user_path and argument the shebang from host_path.  */
		status = extract_shebang(tracee, host_path, user_path, argument);
		if (status < 0)
			return status;

		/* No more shebang.  */
		if (status == 0)
			break;
		has_shebang = true;

		/* Translate new path (user -> host), then check it is executable.  */
		status = translate_and_check_exec(tracee, host_path, user_path);
		if (status < 0)
			return status;

		/* Fetch argv[] only on demand.  */
//		if (argv == NULL) {
//			status = fetch_array_of_xpointers(tracee, &argv, SYSARG_2, 0);
//			if (status < 0)
//				return status;
//		}

		/* Assuming the shebang of "script" is "#!/bin/sh -x",
		 * a call to:
		 *
		 *     execve("./script", { "script.sh", NULL }, ...)
		 *
		 * becomes:
		 *
		 *     execve("/bin/sh", { "/bin/sh", "-x", "./script", NULL }, ...)
		 *
		 * See commit 8c8fbe85 about "argv->length == 1".  */
		//我们没有变换argv的需求,注释掉
//		if (argument[0] != '\0') {
//			status = resize_array_of_xpointers(argv, 0, 2 + (argv->length == 1));
//			if (status < 0)
//				return status;
//
//			status = write_xpointees(argv, 0, 3, user_path, argument, old_user_path);
//			if (status < 0)
//				return status;
//		}
//		else {
//			status = resize_array_of_xpointers(argv, 0, 1 + (argv->length == 1));
//			if (status < 0)
//				return status;
//
//			status = write_xpointees(argv, 0, 2, user_path, old_user_path);
//			if (status < 0)
//				return status;
//		}
	}

	if (i == MAXSYMLINKS)
		return -ELOOP;

	/* Push argv[] only on demand.  */
	//不需要改这个寄存器
//	if (argv != NULL) {
//		status = push_array_of_xpointers(argv, SYSARG_2);
//		if (status < 0)
//			return status;
//	}

	return (has_shebang ? 1 : 0);
}

```

`library/src/main/jni/execve/shebang.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef SHEBANG_H
#define SHEBANG_H

#include <linux/limits.h>  /* PATH_MAX, ARG_MAX, */

#include "tracee/tracee.h"

extern int expand_shebang(Tracee *tracee, char host_path[PATH_MAX], char user_path[PATH_MAX]);

#endif /* SHEBANG_H */

```

`library/src/main/jni/library.c`:

```c
#include <jni.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <strings.h>
#include <fcntl.h>
#include <linux/prctl.h>
#include <sys/prctl.h>

#include "library.h"
#include "constant.h"
#include "tracee/tracee.h"
#include "syscall/seccomp.h"
#include "tracee/event.h"
#include "cmn/cmn_pthread_cond.h"
#include "note.h"
#include "cmn/cmn_back_call_stack.h"
#include "syscall/syscall.h"
#include "mem.h"

#define FILTERED_FUNC_OPEN      0x1
#define FILTERED_FUNC_CLOSE     0x2

/**
 * 增加自定义要拦截的系统调用
 */
static FilteredSysnum g_add_filtered_sysnums[3] = {};

pthread_t work_tid = 0L;
pid_t snew_attach_pid = -1;
struct PCond_Context spctx;
on_sys_event_t  global_on_sysenter = NULL;
on_sys_event_t  global_on_sysexit = NULL;


static void fill_filtered_sysnum(int cur_index, int sysnum){
    g_add_filtered_sysnums[cur_index].value = sysnum;
    g_add_filtered_sysnums[cur_index].flags = 0;
}

static void mark_filtered_sysnum_end(int cur_index){
    g_add_filtered_sysnums[cur_index].value = PR_void;
    g_add_filtered_sysnums[cur_index].flags = 0;
}

/**
 * -------------- tracee start  ---------------------
 */


void test_native(){
    errno = 0;
   int fd =  open("/proc/self/maps",O_RDONLY);
    LOGI("tracee open fd,%d,err:%d,%s",fd,errno, strerror(errno));
    close(fd);
}

//
JNIEXPORT jboolean JNICALL
Java_com_iofomo_opensrc_abyss_sdk_Nativee_before_1attach(JNIEnv *env, jclass clazz) {
    if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) == -1){
        LOGD("set dumpable error,%d,%s",errno, strerror(errno))
        return false;
    }
    return true;
}

JNIEXPORT jboolean JNICALL Java_com_iofomo_opensrc_abyss_sdk_Nativee_tracee_1init_1native
        (JNIEnv * env, jclass clazz, jint flags){
    int add_index = 0;
    mark_filtered_sysnum_end(add_index);
    if (0 != (flags & FILTERED_FUNC_OPEN)) {
        fill_filtered_sysnum(add_index,PR_openat);
        add_index++;
        mark_filtered_sysnum_end(add_index);
    }
    if (0 != (flags & FILTERED_FUNC_CLOSE)) {
        fill_filtered_sysnum(add_index,PR_close);
        add_index++;
        mark_filtered_sysnum_end(add_index);
    }
    return tracee_init(g_add_filtered_sysnums,false);
}

bool tracee_init(FilteredSysnum* add_filtered_sysnums,bool exclude_libc) {
    //Synchronize with the tracer's event loop.
    pid_t my_pid = getpid();
    Tracee* tracee = get_tracee_for_ee(my_pid);
    if (!tracee){
        LOGE("new tracee error");
        return false;
    }
    //关键操作、seccomp mode 2
    /* Improve performance by using seccomp mode 2, unless
 * this support is explicitly disabled.  */
    (void) enable_syscall_filtering(tracee,add_filtered_sysnums,exclude_libc);
    free(tracee);
    LOGI("tracee init finished")
//    test_native();
//    register_crash_handler();
    return true;
}

/**
 * -------------- tracee end  ---------------------
 */


/**
 * -------------- tracer start  ---------------------
 */
static struct PCond_Context s_work_launch_sync;
static bool s_work_thread_doing = false; //工作线程是否正在工作
struct trace_init_data{
    pid_t pid;
    struct PCond_Context* pctx;
};

static bool need_signal_launch(){
    s_work_thread_doing = true;
    return true;
}

static bool need_wait_work(){
    return !s_work_thread_doing;
}

void* work_main(void* data){
    LOGI("work_main start,cur_pid:%d",getpid())
    LOGD("handle_event called");
    cmn_pt_signal2(&s_work_launch_sync,need_signal_launch);
    LOGD("before event loop")
    int ret = event_loop();
    LOGE("event loop exit,ret:%d",ret);
    return NULL;
}

void tracer_init() {
    int code;
    cmn_pt_context_init(&s_work_launch_sync);
    cmn_pt_context_init(&spctx);
    if ((code = pthread_create(&work_tid,NULL, work_main,NULL)) != 0){
        LOGE("start work_main error,code:%d,%d,%s",code,errno,strerror(errno));
        return;
    }
}

void* trace_new_pid_internal(void* data){
    LOGD("trace_new_pid_internal,%d",getpid())
    pid_t child = fork();
    if (child == 0){ //要在work_main之后,否则这个child不能被waitpid到
        //child -- helper进程
        LOGD("enter helper进程--,%d",getpid())
       // LOGD("helper after stop")
        LOGD("exit helper进程--")
        _exit(255); //[0,255]
    }else if (child > 0){
        //parent
        LOGD("helper wait for trace pid:%d",snew_attach_pid)
        cmn_pt_wait(&spctx);
        LOGD("helper finish trace pid:%d",snew_attach_pid)
    }else{
        //error
        LOGE("trace error,%d",snew_attach_pid);
    }
    snew_attach_pid = -1;
//    int ret = 100;
    //TODO 定制返回值
    return NULL;
}


int trace_new_pid(int pid) {
    LOGD("start trace comp pid----------------%d", pid)
    if (!s_work_thread_doing){
        LOGD("wait for work thread") //!!!!
        cmn_pt_wait2(&s_work_launch_sync,need_wait_work);
        LOGD("after work thread working")
    }
    snew_attach_pid = pid;
    pthread_t tid;
    pthread_create(&tid,NULL,trace_new_pid_internal,NULL);
    if (pthread_join(tid,NULL) != 0){
        printf("failed to join,cur_pid:%d\n",getpid());
    }
    LOGD("end trace comp pid----------------%d", pid)
    return 0;
}



void JNICALL
Java_com_iofomo_opensrc_abyss_sdk_Native_init(JNIEnv *env, jclass clazz) {
    tracer_init();
}

jint JNICALL
Java_com_iofomo_opensrc_abyss_sdk_Native_trace_1pid(JNIEnv *env, jclass clazz, jint pid) {
    return trace_new_pid(pid);
}

void set_syscall_event_callback(void (*on_sysenter)(syscall_data* data),void (*on_sysexit)(syscall_data* data)){
    global_on_sysenter = on_sysenter;
    global_on_sysexit = on_sysexit;
}

word_t syscall_peek_reg(const syscall_data* sysdata,Reg reg){
    return peek_reg(sysdata->_internal,CURRENT,reg);
}

void syscall_poke_reg(const syscall_data* sysdata, Reg reg, word_t value){
    poke_reg(sysdata->_internal,reg,value);
}

int syscall_set_sysarg_data(const syscall_data* sysdata,const void *tracer_ptr, word_t data_size, Reg reg){
    return set_sysarg_data(sysdata->_internal,tracer_ptr,data_size,reg);
}


int syscall_set_sysarg_str(const syscall_data* sysdata,const char* tracer_ptr, Reg reg){
    return set_sysarg_data(sysdata->_internal, tracer_ptr, strlen(tracer_ptr) + 1, reg);
}

int syscall_get_sysarg_data(const syscall_data* sysdata, char* dest_tracer,word_t max_size, Reg reg){
    int size;
    word_t src;
    const Tracee *tracee = sysdata->_internal;
    src = peek_reg(tracee, CURRENT, reg);
    if (src == 0) {
        return 0;
    }
    /* Get the str from the tracee's memory space. */
    size = read_data(tracee,dest_tracer,src,max_size);
    return size;
}

int syscall_get_sysarg_str(const syscall_data* sysdata, char* dest_tracer,word_t max_size, Reg reg){
    int size;
    word_t src;
    const Tracee *tracee = sysdata->_internal;
    src = peek_reg(tracee, CURRENT, reg);
    if (src == 0) {
        dest_tracer[0] = '\0';
        return 0;
    }
    /* Get the str from the tracee's memory space. */
    size = read_string(tracee,dest_tracer,src,max_size);
    if (size < 0)
        return size;
    dest_tracer[size] = '\0';
    return size;
}

int syscall_write_data(const syscall_data* sysdata, word_t dest_tracee, const void *src_tracer, word_t size){
   return write_data(sysdata->_internal,dest_tracee,src_tracer,size);
}

//int syscall_syscall_read_data(const syscall_data sysdata, void *dest_tracer, word_t src_tracee, word_t size){
//    return read_data(sysdata._internal,dest_tracer,src_tracee,size);
//}

//int syscall_read_string(const syscall_data sysdata, char *dest_tracer, word_t src_tracee, word_t max_size){
//    return read_string(sysdata._internal,dest_tracer,src_tracee,max_size);
//}



/**
 * -------------- tracer end  ---------------------
 */
```

`library/src/main/jni/library.h`:

```h
//
// Created by mac on 2023/12/15.
//

#ifndef LIBRARY_H
#define LIBRARY_H

#include <unistd.h>
#include <stdbool.h>
#include "syscall/seccomp.h"



#define FILTERED_SYSNUM(SYSNUM) { PR_ ## SYSNUM, 0 }
#include "syscall/sysnum.h"
#include "syscall/seccomp.h"

typedef struct syscall_data {
    //tracee的进程id
    pid_t tracee_pid;
    //系统调用号
    Sysnum sysnum;
    //系统调用参数
//     unsigned long sysargs[6];
     //内部数据,请勿修改
     void* _internal;
     //上下文数据。使用者可以在系统调用进入前赋值,然后系统调用返回后自己使用
     void* user_context_data;
     //业务数据
}syscall_data;

//readlinkat传过来的业务数据
typedef struct business_data{
    //tracee的进程id
    pid_t tracee_pid;
    char data_in[PATH_MAX]; //传入的数据信息
    char result[PATH_MAX]; //响应结果
}business_data;

bool tracee_init(FilteredSysnum* add_filtered_sysnums,bool exclude_libc);

void tracer_init();
int trace_new_pid(int pid);
//系统调用进入时回调(在tracer进程)
void set_syscall_event_callback(void (*on_sysenter)(syscall_data* data),void (*on_sysexit)(syscall_data* data));
/**
 * 内存、寄存器操作
 */

word_t syscall_peek_reg(const syscall_data* sysdata,Reg reg);
void syscall_poke_reg(const syscall_data* sysdata,Reg reg, word_t value);
/**
 * 复制位于tracer中的tracer_ptr指向的data_size字节到tracee进程内。并让寄存器reg指向该buffer。
 */
int syscall_set_sysarg_data(const syscall_data* sysdata,const void *tracer_ptr, word_t data_size, Reg reg);

//赋值寄存器的值为c字符串
int syscall_set_sysarg_str(const syscall_data* sysdata,const char* tracer_ptr, Reg reg);
//从寄存器里获取数据缓冲区
int syscall_get_sysarg_data(const syscall_data* sysdata, char* dest_tracer,word_t max_size, Reg reg);
//从寄存器里获取c字符串值
int syscall_get_sysarg_str(const syscall_data* sysdata, char* dest_tracer,word_t max_size, Reg reg);

int syscall_write_data(const syscall_data* sysdata, word_t dest_tracee, const void *src_tracer, word_t size);

//int syscall_read_data(const syscall_data sysdata, void *dest_tracer, word_t src_tracee, word_t size);
//
//int syscall_read_string(const syscall_data sysdata, char *dest_tracer, word_t src_tracee, word_t max_size);

#endif //LIBRARY_H

```

`library/src/main/jni/loader/assembly-arm.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

/* According to the ARM EABI, all registers have undefined values at
 * program startup except:
 *
 * - the instruction pointer (r15)
 * - the stack pointer (r13)
 * - the rtld_fini pointer (r0)
 */
#define BRANCH(stack_pointer, destination) do {			\
	asm volatile (						\
		"// Restore initial stack pointer.	\n\t"	\
		"mov sp, %0				\n\t"	\
		"					\n\t"	\
		"// Clear rtld_fini.			\n\t"	\
		"mov r0, #0				\n\t"	\
		"					\n\t"	\
		"// Start the program.			\n\t"	\
		"mov pc, %1				\n"	\
		: /* no output */				\
		: "r" (stack_pointer), "r" (destination)	\
		: "memory", "sp", "r0", "pc");			\
	__builtin_unreachable();				\
	} while (0)

#define PREPARE_ARGS_1(arg1_)				\
	register word_t arg1 asm("r0") = arg1_;		\

#define PREPARE_ARGS_3(arg1_, arg2_, arg3_)		\
	PREPARE_ARGS_1(arg1_)				\
	register word_t arg2 asm("r1") = arg2_;		\
	register word_t arg3 asm("r2") = arg3_;		\

#define PREPARE_ARGS_6(arg1_, arg2_, arg3_, arg4_, arg5_, arg6_)	\
	PREPARE_ARGS_3(arg1_, arg2_, arg3_)				\
	register word_t arg4 asm("r3") = arg4_;				\
	register word_t arg5 asm("r4") = arg5_;				\
	register word_t arg6 asm("r5") = arg6_;

#define OUTPUT_CONTRAINTS_1			\
	"r" (arg1)

#define OUTPUT_CONTRAINTS_3			\
	OUTPUT_CONTRAINTS_1,			\
	"r" (arg2), "r" (arg3)

#define OUTPUT_CONTRAINTS_6				\
	OUTPUT_CONTRAINTS_3,				\
	"r" (arg4), "r" (arg5), "r" (arg6)

#define SYSCALL(number_, nb_args, args...)			\
	({							\
		register word_t number asm("r7") = number_;	\
		register word_t result asm("r0");		\
		PREPARE_ARGS_##nb_args(args)			\
			asm volatile (				\
				"svc #0x00000000	\n\t"	\
				: "=r" (result)			\
				: "r" (number),			\
				OUTPUT_CONTRAINTS_##nb_args	\
				: "memory");			\
			result;					\
	})

#define OPEN	5
#define CLOSE	6
#define MMAP	192
#define MMAP_OFFSET_SHIFT 12
#define EXECVE	11
#define EXIT	1
#define PRCTL	172
#define MPROTECT 125


```

`library/src/main/jni/loader/assembly-arm64.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

/* According to the ARM64 EABI, all registers have undefined values at
 * program startup except:
 *
 * - the instruction pointer (pc)
 * - the stack pointer (sp)
 * - the rtld_fini pointer (x0)
 */
#define BRANCH(stack_pointer, destination) do {			\
	asm volatile (						\
		"// Restore initial stack pointer.	\n\t"	\
		"mov sp, %0				\n\t"	\
		"					\n\t"	\
		"// Clear rtld_fini.			\n\t"	\
		"mov x0, #0				\n\t"	\
		"					\n\t"	\
		"// Start the program.			\n\t"	\
		"br %1				\n"		\
		: /* no output */				\
		: "r" (stack_pointer), "r" (destination)	\
		: "memory", "sp", "x0");			\
	__builtin_unreachable();				\
	} while (0)

#define PREPARE_ARGS_1(arg1_)				\
	register word_t arg1 asm("x0") = arg1_;		\

#define PREPARE_ARGS_3(arg1_, arg2_, arg3_)		\
	PREPARE_ARGS_1(arg1_)				\
	register word_t arg2 asm("x1") = arg2_;		\
	register word_t arg3 asm("x2") = arg3_;		\

#define PREPARE_ARGS_4(arg1_, arg2_, arg3_, arg4_)	\
	PREPARE_ARGS_3(arg1_, arg2_, arg3_)		\
	register word_t arg4 asm("x3") = arg4_;		\

#define PREPARE_ARGS_6(arg1_, arg2_, arg3_, arg4_, arg5_, arg6_)	\
	PREPARE_ARGS_4(arg1_, arg2_, arg3_, arg4_)			\
	register word_t arg5 asm("x4") = arg5_;				\
	register word_t arg6 asm("x5") = arg6_;

#define OUTPUT_CONTRAINTS_1			\
	"r" (arg1)

#define OUTPUT_CONTRAINTS_3			\
	OUTPUT_CONTRAINTS_1,			\
	"r" (arg2), "r" (arg3)

#define OUTPUT_CONTRAINTS_4			\
	OUTPUT_CONTRAINTS_3,			\
	"r" (arg4)

#define OUTPUT_CONTRAINTS_6				\
	OUTPUT_CONTRAINTS_4,				\
	"r" (arg5), "r" (arg6)

#define SYSCALL(number_, nb_args, args...)				\
	({								\
		register word_t number asm("x8") = number_;		\
		register word_t result asm("x0");			\
		PREPARE_ARGS_##nb_args(args)				\
			asm volatile (					\
				"svc #0x00000000		\n\t"	\
				: "=r" (result)				\
				: "r" (number),				\
				OUTPUT_CONTRAINTS_##nb_args		\
				: "memory");				\
			result;						\
	})

#define OPENAT	56
#define CLOSE	57
#define MMAP	222
#define EXECVE	221
#define EXIT	93
#define PRCTL   167
#define MPROTECT 226

```

`library/src/main/jni/loader/assembly-x86.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

/* According to the x86 ABI, all registers have undefined values at
 * program startup except:
 *
 * - the instruction pointer (rip)
 * - the stack pointer (rsp)
 * - the rtld_fini pointer (rdx)
 * - the system flags (eflags)
 */
#define BRANCH(stack_pointer, destination) do {			\
	asm volatile (						\
		"// Restore initial stack pointer.	\n\t"	\
		"movl %0, %%esp				\n\t"	\
		"                      			\n\t"	\
		"// Clear state flags.			\n\t"	\
		"pushl $0				\n\t"	\
		"popfl					\n\t"	\
		"                      			\n\t"	\
		"// Clear rtld_fini.			\n\t"	\
		"movl $0, %%edx				\n\t"	\
		"                      			\n\t"	\
		"// Start the program.			\n\t"	\
		"jmpl *%%eax				\n"	\
		: /* no output */				\
		: "irm" (stack_pointer), "a" (destination)	\
		: "memory", "cc", "esp", "edx");		\
	__builtin_unreachable();				\
	} while (0)

extern word_t syscall_6(word_t number,
			word_t arg1, word_t arg2, word_t arg3,
			word_t arg4, word_t arg5, word_t arg6);

extern word_t syscall_3(word_t number, word_t arg1, word_t arg2, word_t arg3);

extern word_t syscall_1(word_t number, word_t arg1);

#define SYSCALL(number, nb_args, args...) syscall_##nb_args(number, args)

#define OPEN	5
#define CLOSE	6
#define MMAP	192
#define MMAP_OFFSET_SHIFT 12
#define EXECVE	11
#define EXIT	1
#define PRCTL	172
#define MPROTECT 125

```

`library/src/main/jni/loader/assembly-x86_64.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

/* According to the x86_64 ABI, all registers have undefined values at
 * program startup except:
 *
 * - the instruction pointer (rip)
 * - the stack pointer (rsp)
 * - the rtld_fini pointer (rdx)
 * - the system flags (rflags)
 */
#define BRANCH(stack_pointer, destination) do {			\
	asm volatile (						\
		"// Restore initial stack pointer.	\n\t"	\
		"movq %0, %%rsp				\n\t"	\
		"					\n\t"	\
		"// Clear state flags.			\n\t"	\
		"pushq $0				\n\t"	\
		"popfq					\n\t"	\
		"					\n\t"	\
		"// Clear rtld_fini.			\n\t"	\
		"movq $0, %%rdx				\n\t"	\
		"					\n\t"	\
		"// Start the program.			\n\t"	\
		"jmpq *%%rax				\n"	\
		: /* no output */				\
		: "irm" (stack_pointer), "a" (destination)	\
		: "memory", "cc", "rsp", "rdx");		\
	__builtin_unreachable();				\
	} while (0)

#define PREPARE_ARGS_1(arg1_)				\
	register word_t arg1 asm("rdi") = arg1_;	\

#define PREPARE_ARGS_3(arg1_, arg2_, arg3_)		\
	PREPARE_ARGS_1(arg1_)				\
	register word_t arg2 asm("rsi") = arg2_;	\
	register word_t arg3 asm("rdx") = arg3_;	\

#define PREPARE_ARGS_6(arg1_, arg2_, arg3_, arg4_, arg5_, arg6_)	\
	PREPARE_ARGS_3(arg1_, arg2_, arg3_)				\
	register word_t arg4 asm("r10") = arg4_;			\
	register word_t arg5 asm("r8")  = arg5_;			\
	register word_t arg6 asm("r9")  = arg6_;

#define OUTPUT_CONTRAINTS_1			\
	"r" (arg1)

#define OUTPUT_CONTRAINTS_3			\
	OUTPUT_CONTRAINTS_1,			\
	"r" (arg2), "r" (arg3)

#define OUTPUT_CONTRAINTS_6			\
	OUTPUT_CONTRAINTS_3,			\
	"r" (arg4), "r" (arg5), "r" (arg6)

#define SYSCALL(number_, nb_args, args...)				\
	({								\
		register word_t number asm("rax") = number_;		\
		register word_t result asm("rax");			\
		PREPARE_ARGS_##nb_args(args)				\
			asm volatile (					\
				"syscall		\n\t"		\
				: "=r" (result)				\
				: "r" (number),				\
				OUTPUT_CONTRAINTS_##nb_args		\
				: "memory", "cc", "rcx", "r11");	\
			result;						\
	})

#define OPEN	2
#define CLOSE	3
#define MMAP	9
#define EXECVE	59
#define EXIT	60
#define PRCTL	157
#define MPROTECT 10

```

`library/src/main/jni/loader/assembly.S`:

```S
#if defined(__i386__)
	.text

/*
	ABI	user-land  kernel-land
	======  =========  ===========
	number	%eax	   %eax
	arg1	%edx	   %ebx
	arg2	%ecx	   %ecx
	arg3	16(%esp)   %edx
	arg4	12(%esp)   %esi
	arg5	8(%esp)	   %edi
	arg6	4(%esp)    %ebp
	result	N/A	   %eax
*/
.globl	syscall_6
.type	syscall_6, @function
syscall_6:
	/* Callee-saved registers.  */
	pushl	%ebp	// %esp -= 0x04
	pushl	%edi	// %esp -= 0x08
	pushl	%esi	// %esp -= 0x0c
	pushl	%ebx	// %esp -= 0x10

//	mov	%eax, %eax		// number
	mov	%edx, %ebx		// arg1
//	mov	%ecx, %ecx		// arg2
	mov	0x14(%esp), %edx	// arg3
	mov	0x18(%esp), %esi	// arg4
	mov	0x1c(%esp), %edi	// arg5
	mov	0x20(%esp), %ebp	// arg6

	int	$0x80

	popl	%ebx
	popl	%esi
	popl	%edi
	popl	%ebp

//	mov	%eax, %eax		// result
	ret

.globl	syscall_3
.type	syscall_3, @function
syscall_3:
	pushl	%ebx
	mov	%edx, %ebx
	mov	0x8(%esp), %edx
	int	$0x80
	popl	%ebx
	ret

.globl	syscall_1
.type	syscall_1, @function
syscall_1:
	pushl	%ebx
	mov	%edx, %ebx
	int	$0x80
	popl	%ebx
	ret

#endif /* defined(__i386__) */

```

`library/src/main/jni/loader/loader.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <stdbool.h>     /* bool, true, false,  */

#define NO_LIBC_HEADER
#include "loader/script.h"
#include "compat.h"
#include "arch.h"

#define GCC_VERSION (__GNUC__ * 10000			\
			+ __GNUC_MINOR__ * 100		\
			+ __GNUC_PATCHLEVEL__)

#if GCC_VERSION < 40500
#define __builtin_unreachable()
#endif

#if defined(ARCH_X86_64)
#    include "loader/assembly-x86_64.h"
#elif defined(ARCH_ARM_EABI)
#    include "loader/assembly-arm.h"
#elif defined(ARCH_X86)
#    include "loader/assembly-x86.h"
#elif defined(ARCH_ARM64)
#    include "loader/assembly-arm64.h"
#else
#    error "Unsupported architecture"
#endif

#if !defined(MMAP_OFFSET_SHIFT)
#    define MMAP_OFFSET_SHIFT 0
#endif

#define FATAL() do {						\
		SYSCALL(EXIT, 1, 182);				\
		__builtin_unreachable();			\
	} while (0)

#define unlikely(expr) __builtin_expect(!!(expr), 0)

/**
 * Clear the memory from @start (inclusive) to @end (exclusive).
 */
static inline void clear(word_t start, word_t end)
{
	byte_t *start_misaligned;
	byte_t *end_misaligned;

	word_t *start_aligned;
	word_t *end_aligned;

	/* Compute the number of mis-aligned bytes.  */
	word_t start_bytes = start % sizeof(word_t);
	word_t end_bytes   = end % sizeof(word_t);

	/* Compute aligned addresses.  */
	start_aligned = (word_t *) (start_bytes ? start + sizeof(word_t) - start_bytes : start);
	end_aligned   = (word_t *) (end - end_bytes);

	/* Clear leading mis-aligned bytes.  */
	start_misaligned = (byte_t *) start;
	while (start_misaligned < (byte_t *) start_aligned)
		*start_misaligned++ = 0;

	/* Clear aligned bytes.  */
	while (start_aligned < end_aligned)
		*start_aligned++ = 0;

	/* Clear trailing mis-aligned bytes.  */
	end_misaligned = (byte_t *) end_aligned;
	while (end_misaligned < (byte_t *) end)
		*end_misaligned++ = 0;
}

/**
 * Return the address of the last path component of @string_.  Note
 * that @string_ is not modified.
 */
static inline word_t basename(word_t string_)
{
	byte_t *string = (byte_t *) string_;
	byte_t *cursor;

	for (cursor = string; *cursor != 0; cursor++)
		;

	for (; *cursor != (byte_t) '/' && cursor > string; cursor--)
		;

	if (cursor != string)
		cursor++;

	return (word_t) cursor;
}

/**
 * Interpret the load script pointed to by @cursor.
 */
void _start(void *cursor)
{
	bool traced = false;
	bool reset_at_base = true;
	word_t at_base = 0;

	word_t fd = -1;
	word_t status;

	while(1) {
		LoadStatement *stmt = cursor;

		switch (stmt->action) {
		case LOAD_ACTION_OPEN_NEXT:
			status = SYSCALL(CLOSE, 1, fd);
			if (unlikely((int) status < 0))
				FATAL();
			/* Fall through.  */

		case LOAD_ACTION_OPEN:
#if defined(OPEN)
			fd = SYSCALL(OPEN, 3, stmt->open.string_address, O_RDONLY, 0);
#else
			fd = SYSCALL(OPENAT, 4, AT_FDCWD, stmt->open.string_address, O_RDONLY, 0);
#endif
			if (unlikely((int) fd < 0))
				FATAL();

			reset_at_base = true;

			cursor += LOAD_STATEMENT_SIZE(*stmt, open);
			break;

		case LOAD_ACTION_MMAP_FILE:
			status = SYSCALL(MMAP, 6, stmt->mmap.addr, stmt->mmap.length,
					stmt->mmap.prot, MAP_PRIVATE | MAP_FIXED, fd,
					stmt->mmap.offset >> MMAP_OFFSET_SHIFT);
			if (unlikely(status != stmt->mmap.addr))
				FATAL();

			if (stmt->mmap.clear_length != 0)
				clear(stmt->mmap.addr + stmt->mmap.length - stmt->mmap.clear_length,
					stmt->mmap.addr + stmt->mmap.length);

			if (reset_at_base) {
				at_base = stmt->mmap.addr;
				reset_at_base = false;
			}

			cursor += LOAD_STATEMENT_SIZE(*stmt, mmap);
			break;

		case LOAD_ACTION_MMAP_ANON:
			status = SYSCALL(MMAP, 6, stmt->mmap.addr, stmt->mmap.length,
					stmt->mmap.prot, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
			if (unlikely(status != stmt->mmap.addr))
				FATAL();

			cursor += LOAD_STATEMENT_SIZE(*stmt, mmap);
			break;

		case LOAD_ACTION_MAKE_STACK_EXEC:
			SYSCALL(MPROTECT, 3,
				stmt->make_stack_exec.start, 1,
				PROT_READ | PROT_WRITE | PROT_EXEC | PROT_GROWSDOWN);

			cursor += LOAD_STATEMENT_SIZE(*stmt, make_stack_exec);
			break;

		case LOAD_ACTION_START_TRACED:
			traced = true;
			/* Fall through.  */

		case LOAD_ACTION_START: {
			word_t *cursor2 = (word_t *) stmt->start.stack_pointer;
			const word_t argc = cursor2[0];
			const word_t at_execfn = cursor2[1];
			word_t name;

			status = SYSCALL(CLOSE, 1, fd);
			if (unlikely((int) status < 0))
				FATAL();

			/* Right after execve, the stack content is as follow:
			 *
			 *   +------+--------+--------+--------+
			 *   | argc | argv[] | envp[] | auxv[] |
			 *   +------+--------+--------+--------+
			 */

			/* Skip argv[].  */
			cursor2 += argc + 1;

			/* Skip envp[].  */
			do cursor2++; while (cursor2[0] != 0);
			cursor2++;

			/* Adjust auxv[].  */
			do {
				switch (cursor2[0]) {
				case AT_PHDR:
					cursor2[1] = stmt->start.at_phdr;
					break;

				case AT_PHENT:
					cursor2[1] = stmt->start.at_phent;
					break;

				case AT_PHNUM:
					cursor2[1] = stmt->start.at_phnum;
					break;

				case AT_ENTRY:
					cursor2[1] = stmt->start.at_entry;
					break;

				case AT_BASE:
					cursor2[1] = at_base;
					break;

				case AT_EXECFN:
					/* stmt->start.at_execfn can't be used for now since it is
					 * currently stored in a location that will be scratched
					 * by the process (below the final stack pointer).  */
					cursor2[1] = at_execfn;
					break;

				default:
					break;
				}
				cursor2 += 2;
			} while (cursor2[0] != AT_NULL);

			/* Note that only 2 arguments are actually necessary... */
			name = basename(stmt->start.at_execfn);
			SYSCALL(PRCTL, 3, PR_SET_NAME, name, 0);

			if (unlikely(traced))
				SYSCALL(EXECVE, 6, 1,
					stmt->start.stack_pointer,
					stmt->start.entry_point, 2, 3, 4);
			else
				BRANCH(stmt->start.stack_pointer, stmt->start.entry_point);
			FATAL();
		}

		default:
			FATAL();
		}
	}

	FATAL();
}

```

`library/src/main/jni/loader/script.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef SCRIPT
#define SCRIPT

#include "arch.h"
#include "attribute.h"

struct load_statement {
	word_t action;

	union {
		struct {
			word_t string_address;
		} open;

		struct {
			word_t addr;
			word_t length;
			word_t prot;
			word_t offset;
			word_t clear_length;
		} mmap;

		struct {
			word_t start;
		} make_stack_exec;

		struct {
			word_t stack_pointer;
			word_t entry_point;
			word_t at_phdr;
			word_t at_phent;
			word_t at_phnum;
			word_t at_entry;
			word_t at_execfn;
		} start;
	};
} PACKED;

typedef struct load_statement LoadStatement;

#define LOAD_STATEMENT_SIZE(statement, type) \
	(sizeof((statement).action) + sizeof((statement).type))

/* Don't use enum, since sizeof(enum) doesn't have to be equal to
 * sizeof(word_t).  Keep values in the same order as their respective
 * actions appear in loader.c to get a change GCC produces a jump
 * table.  */
#define LOAD_ACTION_OPEN_NEXT		0
#define LOAD_ACTION_OPEN		1
#define LOAD_ACTION_MMAP_FILE		2
#define LOAD_ACTION_MMAP_ANON		3
#define LOAD_ACTION_MAKE_STACK_EXEC	4
#define LOAD_ACTION_START_TRACED	5
#define LOAD_ACTION_START		6

#endif /* SCRIPT */

```

`library/src/main/jni/note.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <errno.h>  /* errno, */
#include <string.h> /* strerror(3), */
#include <stdarg.h> /* va_*, */
#include <stdio.h>  /* vfprintf(3), */
#include <limits.h> /* INT_MAX, */

#include "note.h"
#include "tracee/tracee.h"
#include "constant.h"

int global_verbose_level;
const char *global_tool_name;

/**
 * Print @message to the standard error stream according to its
 * @severity and @origin.
 */
void note(const Tracee *tracee, Severity severity, Origin origin, const char *message, ...)
{
    const char *tool_name;
    va_list extra_params;
    int verbose_level;
    char line[40] = {0};
    char extra_line[1024] = {0};

    if (tracee == NULL) {
        verbose_level = global_verbose_level;
        tool_name     = global_tool_name ?: "";
    }
    else {
        verbose_level = tracee->verbose;
        tool_name     = tracee->tool_name;
    }

    if (verbose_level < 0 && severity != ERROR)
        return;

    switch (severity) {
        case WARNING:
//            LOGW("%s warning: ", tool_name);
            snprintf(line, sizeof(line),"%s warning: ", tool_name);
            break;

        case ERROR:
//        LOGE( "%s error: ", tool_name);
            snprintf(line, sizeof(line),"%s error: ", tool_name);

            break;

        case INFO:
        default:
//        LOGD("%s info: ", tool_name);
            snprintf(line, sizeof(line),"%s info: ",tool_name);
            break;
    }

    if (origin == TALLOC){
        snprintf(line,sizeof(line),"talloc:");
    }
//        LOGE( "talloc: ");

    va_start(extra_params, message);
//    vfprintf(stderr, message, extra_params);
    vsprintf(extra_line, message, extra_params);
    va_end(extra_params);
//    char * log = strcat(line,extra_line);
    LOGSYS("%s%s",line,extra_line)
    switch (origin) {
        case SYSTEM:
            LOGSYS( ": ");
            perror(NULL);
            break;

        case TALLOC:
            break;

        case INTERNAL:
        case USER:
        default:
//            LOGSYS( "\n");
            break;
    }

    return;
}


```

`library/src/main/jni/note.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef NOTE_H
#define NOTE_H

#include "tracee/tracee.h"
#include "attribute.h"

/* Specify where a notice is coming from. */
typedef enum {
    SYSTEM,
    INTERNAL,
    USER,
    TALLOC,
} Origin;

/* Specify the severity of a notice. */
typedef enum {
    ERROR,
    WARNING,
    INFO,
} Severity;

#define VERBOSE(tracee, level, message, args...) do {			\
		if (tracee == NULL || tracee->verbose >= (level))	\
			note(tracee, INFO, INTERNAL, (message), ## args); \
	} while (0)

extern void note(const Tracee *tracee, Severity severity, Origin origin, const char *message, ...) FORMAT(printf, 4, 5);

extern int global_verbose_level;
extern const char *global_tool_name;

#endif /* NOTE_H */

```

`library/src/main/jni/path/binding.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sys/stat.h> /* lstat(2), */
#include <unistd.h>   /* getcwd(2), lstat(2), */
#include <string.h>   /* string(3),  */
#include <strings.h>  /* bzero(3), */
#include <assert.h>   /* assert(3), */
#include <limits.h>   /* PATH_MAX, */
#include <errno.h>    /* E* */
#include <sys/queue.h> /* CIRCLEQ_*, */
#include <talloc.h>   /* talloc_*, */

#include "path/binding.h"
#include "path/path.h"
#include "path/canon.h"
#include "cli/note.h"

#include "compat.h"

#define HEAD(tracee, side)						\
	(side == GUEST							\
		? (tracee)->fs->bindings.guest				\
		: (side == HOST						\
			? (tracee)->fs->bindings.host			\
			: (tracee)->fs->bindings.pending))

#define NEXT(binding, side)						\
	(side == GUEST							\
		? CIRCLEQ_NEXT(binding, link.guest)			\
		: (side == HOST						\
			? CIRCLEQ_NEXT(binding, link.host)		\
			: CIRCLEQ_NEXT(binding, link.pending)))

#define CIRCLEQ_FOREACH_(tracee, binding, side)				\
	for (binding = CIRCLEQ_FIRST(HEAD(tracee, side));		\
	     binding != (void *) HEAD(tracee, side);			\
	     binding = NEXT(binding, side))

#define CIRCLEQ_INSERT_AFTER_(tracee, previous, binding, side) do {	\
	switch (side) {							\
	case GUEST: CIRCLEQ_INSERT_AFTER(HEAD(tracee, side), previous, binding, link.guest);   break; \
	case HOST:  CIRCLEQ_INSERT_AFTER(HEAD(tracee, side), previous, binding, link.host);    break; \
	default:    CIRCLEQ_INSERT_AFTER(HEAD(tracee, side), previous, binding, link.pending); break; \
	}								\
	(void) talloc_reference(HEAD(tracee, side), binding);		\
} while (0)

#define CIRCLEQ_INSERT_BEFORE_(tracee, next, binding, side) do {	\
	switch (side) {							\
	case GUEST: CIRCLEQ_INSERT_BEFORE(HEAD(tracee, side), next, binding, link.guest);   break; \
	case HOST:  CIRCLEQ_INSERT_BEFORE(HEAD(tracee, side), next, binding, link.host);    break; \
	default:    CIRCLEQ_INSERT_BEFORE(HEAD(tracee, side), next, binding, link.pending); break; \
	}								\
	(void) talloc_reference(HEAD(tracee, side), binding);		\
} while (0)

#define CIRCLEQ_INSERT_HEAD_(tracee, binding, side) do {		\
	switch (side) {							\
	case GUEST: CIRCLEQ_INSERT_HEAD(HEAD(tracee, side), binding, link.guest);   break; \
	case HOST:  CIRCLEQ_INSERT_HEAD(HEAD(tracee, side), binding, link.host);    break; \
	default:    CIRCLEQ_INSERT_HEAD(HEAD(tracee, side), binding, link.pending); break; \
	}								\
	(void) talloc_reference(HEAD(tracee, side), binding);		\
} while (0)

#define IS_LINKED(binding, link)					\
	((binding)->link.cqe_next != NULL && (binding)->link.cqe_prev != NULL)

#define CIRCLEQ_REMOVE_(tracee, binding, name) do {			\
	CIRCLEQ_REMOVE((tracee)->fs->bindings.name, binding, link.name);\
	(binding)->link.name.cqe_next = NULL;				\
	(binding)->link.name.cqe_prev = NULL;				\
	talloc_unlink((tracee)->fs->bindings.name, binding);		\
} while (0)


/**
 * Print all bindings (verbose purpose).
 */
static void print_bindings(const Tracee *tracee)
{
	const Binding *binding;

	if (tracee->fs->bindings.guest == NULL)
		return;

	CIRCLEQ_FOREACH_(tracee, binding, GUEST) {
		if (compare_paths(binding->host.path, binding->guest.path) == PATHS_ARE_EQUAL)
			note(tracee, INFO, USER, "binding = %s", binding->host.path);
		else
			note(tracee, INFO, USER, "binding = %s:%s",
				binding->host.path, binding->guest.path);
	}
}

/**
 * Get the binding for the given @path (relatively to the given
 * binding @side).
 */
Binding *get_binding(const Tracee *tracee, Side side, const char path[PATH_MAX])
{
	Binding *binding;
	size_t path_length = strlen(path);

	/* Sanity checks.  */
	assert(path != NULL && path[0] == '/');

	CIRCLEQ_FOREACH_(tracee, binding, side) {
		Comparison comparison;
		const Path *ref;

		switch (side) {
		case GUEST:
			ref = &binding->guest;
			break;

		case HOST:
			ref = &binding->host;
			break;

		default:
			assert(0);
			return NULL;
		}

		comparison = compare_paths2(ref->path, ref->length, path, path_length);
		if (   comparison != PATHS_ARE_EQUAL
		    && comparison != PATH1_IS_PREFIX)
			continue;

		/* Avoid false positive when a prefix of the rootfs is
		 * used as an asymmetric binding, ex.:
		 *
		 *     proot -m /usr:/location /usr/local/slackware
		 */
		if (   side == HOST
		    && compare_paths(get_root(tracee), "/") != PATHS_ARE_EQUAL
		    && belongs_to_guestfs(tracee, path))
				continue;

		return binding;
	}

	return NULL;
}

/**
 * Get the binding path for the given @path (relatively to the given
 * binding @side).
 */
const char *get_path_binding(const Tracee *tracee, Side side, const char path[PATH_MAX])
{
	const Binding *binding;

	binding = get_binding(tracee, side, path);
	if (!binding)
		return NULL;

	switch (side) {
	case GUEST:
		return binding->guest.path;

	case HOST:
		return binding->host.path;

	default:
		assert(0);
		return NULL;
	}
}

/**
 * Return the path to the guest rootfs for the given @tracee, from the
 * host point-of-view obviously.  Depending on whether
 * initialize_bindings() was called or not, the path is retrieved from
 * the "bindings.guest" list or from the "bindings.pending" list,
 * respectively.
 */
const char *get_root(const Tracee* tracee)
{
	const Binding *binding;

	if (tracee == NULL || tracee->fs == NULL)
		return NULL;

	if (tracee->fs->bindings.guest == NULL) {
		if (tracee->fs->bindings.pending == NULL
		    || CIRCLEQ_EMPTY(tracee->fs->bindings.pending))
			return NULL;

		binding = CIRCLEQ_LAST(tracee->fs->bindings.pending);
		if (compare_paths(binding->guest.path, "/") != PATHS_ARE_EQUAL)
			return NULL;

		return binding->host.path;
	}

	assert(!CIRCLEQ_EMPTY(tracee->fs->bindings.guest));

	binding = CIRCLEQ_LAST(tracee->fs->bindings.guest);

	assert(strcmp(binding->guest.path, "/") == 0);

	return binding->host.path;
}

/**
 * Substitute the guest path (if any) with the host path in @path.
 * This function returns:
 *
 *     * -errno if an error occured
 *
 *     * 0 if it is a binding location but no substitution is needed
 *       ("symetric" binding)
 *
 *     * 1 if it is a binding location and a substitution was performed
 *       ("asymmetric" binding)
 */
int substitute_binding(const Tracee *tracee, Side side, char path[PATH_MAX])
{
	const Path *reverse_ref;
	const Path *ref;
	const Binding *binding;

	binding = get_binding(tracee, side, path);
	if (!binding)
		return -ENOENT;

	/* Is it a "symetric" binding?  */
	if (!binding->need_substitution)
		return 0;

	switch (side) {
	case GUEST:
		ref = &binding->guest;
		reverse_ref = &binding->host;
		break;

	case HOST:
		ref = &binding->host;
		reverse_ref = &binding->guest;
		break;

	default:
		assert(0);
		return -EACCES;
	}

	substitute_path_prefix(path, ref->length, reverse_ref->path, reverse_ref->length);

	return 1;
}

/**
 * Remove @binding from all the @tracee's lists of bindings it belongs to.
 */
void remove_binding_from_all_lists(const Tracee *tracee, Binding *binding)
{
       if (IS_LINKED(binding, link.pending))
	       CIRCLEQ_REMOVE_(tracee, binding, pending);

       if (IS_LINKED(binding, link.guest))
	       CIRCLEQ_REMOVE_(tracee, binding, guest);

       if (IS_LINKED(binding, link.host))
	       CIRCLEQ_REMOVE_(tracee, binding, host);
}

/**
 * Insert @binding into the list of @bindings, in a sorted manner so
 * as to make the substitution of nested bindings determistic, ex.:
 *
 *     -b /bin:/foo/bin -b /usr/bin/more:/foo/bin/more
 *
 * Note: "nested" from the @side point-of-view.
 */
static void insort_binding(const Tracee *tracee, Side side, Binding *binding)
{
	Binding *iterator;
	Binding *previous = NULL;
	Binding *next = CIRCLEQ_FIRST(HEAD(tracee, side));

	/* Find where it should be added in the list.  */
	CIRCLEQ_FOREACH_(tracee, iterator, side) {
		Comparison comparison;
		const Path *binding_path;
		const Path *iterator_path;

		switch (side) {
		case PENDING:
		case GUEST:
			binding_path = &binding->guest;
			iterator_path = &iterator->guest;
			break;

		case HOST:
			binding_path = &binding->host;
			iterator_path = &iterator->host;
			break;

		default:
			assert(0);
			return;
		}

		comparison = compare_paths2(binding_path->path, binding_path->length,
					    iterator_path->path, iterator_path->length);
		switch (comparison) {
		case PATHS_ARE_EQUAL:
			if (side == HOST) {
				previous = iterator;
				break;
			}

			if (tracee->verbose > 0 && getenv("PROOT_IGNORE_MISSING_BINDINGS") == NULL) {
				note(tracee, WARNING, USER,
					"both '%s' and '%s' are bound to '%s', "
					"only the last binding is active.",
					iterator->host.path, binding->host.path,
					binding->guest.path);
			}

			/* Replace this iterator with the new binding.  */
			CIRCLEQ_INSERT_AFTER_(tracee, iterator, binding, side);
			remove_binding_from_all_lists(tracee, iterator);
			return;

		case PATH1_IS_PREFIX:
			/* The new binding contains the iterator.  */
			previous = iterator;
			break;

		case PATH2_IS_PREFIX:
			/* The iterator contains the new binding.
			 * Use the deepest container.  */
			if (next == (void *) HEAD(tracee, side))
				next = iterator;
			break;

		case PATHS_ARE_NOT_COMPARABLE:
			break;

		default:
			assert(0);
			return;
		}
	}

	/* Insert this binding in the list.  */
	if (previous != NULL)
		CIRCLEQ_INSERT_AFTER_(tracee, previous, binding, side);
	else if (next != (void *) HEAD(tracee, side))
		CIRCLEQ_INSERT_BEFORE_(tracee, next, binding, side);
	else
		CIRCLEQ_INSERT_HEAD_(tracee, binding, side);
}

/**
 * c.f. function above.
 */
static void insort_binding2(const Tracee *tracee, Binding *binding)
{
	binding->need_substitution =
		compare_paths(binding->host.path, binding->guest.path) != PATHS_ARE_EQUAL;

	insort_binding(tracee, GUEST, binding);
	insort_binding(tracee, HOST, binding);
}

/**
 * Create and insert a new binding (@host_path:@guest_path) into the
 * list of @tracee's bindings.  The Talloc parent of this new binding
 * is @context.  This function returns NULL if an error occurred,
 * otherwise a pointer to the newly created binding.
 */
Binding *insort_binding3(const Tracee *tracee, const TALLOC_CTX *context,
			const char host_path[PATH_MAX],
			const char guest_path[PATH_MAX])
{
	Binding *binding;

	binding = talloc_zero(context, Binding);
	if (binding == NULL)
		return NULL;

	strcpy(binding->host.path, host_path);
	strcpy(binding->guest.path, guest_path);

	binding->host.length = strlen(binding->host.path);
	binding->guest.length = strlen(binding->guest.path);

	insort_binding2(tracee, binding);

	return binding;
}

/**
 * Free all bindings from @bindings.
 *
 * Note: this is a Talloc destructor.
 */
static int remove_bindings(Bindings *bindings)
{
	Binding *binding;
	Tracee *tracee;

	/* Unlink all bindings from the @link list.  */
#define CIRCLEQ_REMOVE_ALL(name) do {				\
	binding = CIRCLEQ_FIRST(bindings);			\
	while (binding != (void *) bindings) {			\
		Binding *next = CIRCLEQ_NEXT(binding, link.name);\
		CIRCLEQ_REMOVE_(tracee, binding, name);		\
		binding = next;					\
	}							\
} while (0)

	/* Search which link is used by this list.  */
	tracee = TRACEE(bindings);
	if (bindings == tracee->fs->bindings.pending)
		CIRCLEQ_REMOVE_ALL(pending);
	else if (bindings == tracee->fs->bindings.guest)
		CIRCLEQ_REMOVE_ALL(guest);
	else if (bindings == tracee->fs->bindings.host)
		CIRCLEQ_REMOVE_ALL(host);

	bzero(bindings, sizeof(Bindings));

	return 0;
}

/**
 * Allocate a new binding "@host:@guest" and attach it to
 * @tracee->fs->bindings.pending.  This function complains about
 * missing @host path only if @must_exist is true.  This function
 * returns the allocated binding on success, NULL on error.
 */
Binding *new_binding(Tracee *tracee, const char *host, const char *guest, bool must_exist)
{
	Binding *binding;
	char base[PATH_MAX];
	int status;

	/* Lasy allocation of the list of bindings specified by the
	 * user.  This list will be used by initialize_bindings().  */
	if (tracee->fs->bindings.pending == NULL) {
		tracee->fs->bindings.pending = talloc_zero(tracee->fs, Bindings);
		if (tracee->fs->bindings.pending == NULL)
			return NULL;
		CIRCLEQ_INIT(tracee->fs->bindings.pending);
		talloc_set_destructor(tracee->fs->bindings.pending, remove_bindings);
	}

	/* Allocate an empty binding.  */
	binding = talloc_zero(tracee->ctx, Binding);
	if (binding == NULL)
		return NULL;

	/* Canonicalize the host part of the binding, as expected by
	 * get_binding().  */
	status = realpath2(tracee->reconf.tracee, binding->host.path, host, true);
	if (status < 0) {
		if (must_exist && getenv("PROOT_IGNORE_MISSING_BINDINGS") == NULL)
			note(tracee, WARNING, INTERNAL, "can't sanitize binding \"%s\": %s",
				host, strerror(-status));
		goto error;
	}
	binding->host.length = strlen(binding->host.path);

	/* Symetric binding?  */
	guest = guest ?: host;

	/* When not absolute, assume the guest path is relative to the
	 * current working directory, as with ``-b .`` for instance.  */
	if (guest[0] != '/') {
		status = getcwd2(tracee->reconf.tracee, base);
		if (status < 0) {
			note(tracee, WARNING, INTERNAL, "can't sanitize binding \"%s\": %s",
				binding->guest.path, strerror(-status));
			goto error;
		}
	}
	else
		strcpy(base, "/");

	status = join_paths(2, binding->guest.path, base, guest);
	if (status < 0) {
		note(tracee, WARNING, SYSTEM, "can't sanitize binding \"%s\"",
			binding->guest.path);
		goto error;
	}
	binding->guest.length = strlen(binding->guest.path);

	/* Keep the list of bindings specified by the user ordered,
	 * for the sake of consistency.  For instance binding to "/"
	 * has to be the last in the list.  */
	insort_binding(tracee, PENDING, binding);

	return binding;

error:
	TALLOC_FREE(binding);
	return NULL;
}

/**
 * Canonicalize the guest part of the given @binding, insert it into
 * @tracee->fs->bindings.guest and @tracee->fs->bindings.host.  This
 * function returns -1 if an error occured, 0 otherwise.
 */
static void initialize_binding(Tracee *tracee, Binding *binding)
{
	char path[PATH_MAX];
	struct stat statl;
	int status;

	/* All bindings but "/" must be canonicalized.  The exception
	 * for "/" is required to bootstrap the canonicalization.  */
	if (compare_paths(binding->guest.path, "/") != PATHS_ARE_EQUAL) {
		bool dereference;
		size_t length;

		strcpy(path, binding->guest.path);
		length = strlen(path);
		assert(length > 0);

		/* Does the user explicitly tell not to dereference
		 * guest path?  */
		dereference = (path[length - 1] != '!');
		if (!dereference)
			path[length - 1] = '\0';

		/* Initial state before canonicalization.  */
		strcpy(binding->guest.path, "/");

		/* Remember the type of the final component, it will
		 * be used in build_glue() later.  */
		status = lstat(binding->host.path, &statl);
		tracee->glue_type = (status < 0 || S_ISBLK(statl.st_mode) || S_ISCHR(statl.st_mode)
				? S_IFREG : statl.st_mode & S_IFMT);

		/* Sanitize the guest path of the binding within the
		   alternate rootfs since it is assumed by
		   substitute_binding().  */
		status = canonicalize(tracee, path, dereference, binding->guest.path, 0);
		if (status < 0) {
			note(tracee, WARNING, INTERNAL,
				"sanitizing the guest path (binding) \"%s\": %s",
				path, strerror(-status));
			return;
		}

		/* Remove the trailing "/" or "/." as expected by
		 * substitute_binding().  */
		chop_finality(binding->guest.path);

		/* Disable definitively the creation of the glue for
		 * this binding.  */
		tracee->glue_type = 0;
	}

	binding->guest.length = strlen(binding->guest.path);

	insort_binding2(tracee, binding);
}

/**
 * Add bindings induced by @new_binding when @tracee is being sub-reconfigured.
 * For example, if the previous configuration ("-r /rootfs1") contains this
 * binding:
 *
 *      -b /home/ced:/usr/local/ced
 *
 * and if the current configuration ("-r /rootfs2") introduces such a new
 * binding:
 *
 *      -b /usr:/media
 *
 * then the following binding is induced:
 *
 *      -b /home/ced:/media/local/ced
 */
static void add_induced_bindings(Tracee *tracee, const Binding *new_binding)
{
	Binding *old_binding;
	char path[PATH_MAX];
	int status;

	/* Only for reconfiguration.  */
	if (tracee->reconf.tracee == NULL)
		return;

	/* From the example, PRoot has already converted "-b /usr:/media" into
	 * "-b /rootfs1/usr:/media" in order to ensure the host part is really a
	 * host path.  Here, the host part is converted back to "/usr" since the
	 * comparison can't be made on "/rootfs1/usr".
	 */
	strcpy(path, new_binding->host.path);
	status = detranslate_path(tracee->reconf.tracee, path, NULL);
	if (status < 0)
		return;

	CIRCLEQ_FOREACH_(tracee->reconf.tracee, old_binding, GUEST) {
		Binding *induced_binding;
		Comparison comparison;
		char path2[PATH_MAX];
		size_t prefix_length;

		/* Check if there's an induced binding by searching a common
		 * path prefix in between new/old bindings:
		 *
		 *   -b /home/ced:[/usr]/local/ced
		 *   -b [/usr]:/media
		 */
		comparison = compare_paths(path, old_binding->guest.path);
		if (comparison != PATH1_IS_PREFIX)
			continue;

		/* Convert the path of this induced binding to the new
		 * filesystem namespace.  From the example, "/usr/local/ced" is
		 * converted into "/media/local/ced".  Note: substitute_binding
		 * can't be used in this case since it would expect
		 * "/rootfs1/usr/local/ced instead".
		 */
		prefix_length = strlen(path);
		if (prefix_length == 1)
			prefix_length = 0;

		status = join_paths(2, path2, new_binding->guest.path, old_binding->guest.path + prefix_length);
		if (status < 0)
			continue;

		/* Install the induced binding.  From the example:
		 *
		 *     -b /home/ced:/media/local/ced
		 */
		induced_binding = talloc_zero(tracee->ctx, Binding);
		if (induced_binding == NULL)
			continue;

		strcpy(induced_binding->host.path, old_binding->host.path);
		strcpy(induced_binding->guest.path, path2);

		induced_binding->host.length = strlen(induced_binding->host.path);
		induced_binding->guest.length = strlen(induced_binding->guest.path);

		VERBOSE(tracee, 2, "induced binding: %s:%s (old) & %s:%s (new) -> %s:%s (induced)",
			old_binding->host.path, old_binding->guest.path, path, new_binding->guest.path,
			induced_binding->host.path, induced_binding->guest.path);

		insort_binding2(tracee, induced_binding);
	}
}

/**
 * Allocate @tracee->fs->bindings.guest and
 * @tracee->fs->bindings.host, then call initialize_binding() on each
 * binding listed in @tracee->fs->bindings.pending.
 */
int initialize_bindings(Tracee *tracee)
{
	Binding *binding;

	/* Sanity checks.  */
	assert(get_root(tracee) != NULL);
	assert(tracee->fs->bindings.pending != NULL);
	assert(tracee->fs->bindings.guest == NULL);
	assert(tracee->fs->bindings.host == NULL);

	/* Allocate @tracee->fs->bindings.guest and
	 * @tracee->fs->bindings.host.  */
	tracee->fs->bindings.guest = talloc_zero(tracee->fs, Bindings);
	tracee->fs->bindings.host  = talloc_zero(tracee->fs, Bindings);
	if (tracee->fs->bindings.guest == NULL || tracee->fs->bindings.host == NULL) {
		note(tracee, ERROR, INTERNAL, "can't allocate enough memory");
		TALLOC_FREE(tracee->fs->bindings.guest);
		TALLOC_FREE(tracee->fs->bindings.host);
		return -1;
	}

	CIRCLEQ_INIT(tracee->fs->bindings.guest);
	CIRCLEQ_INIT(tracee->fs->bindings.host);

	talloc_set_destructor(tracee->fs->bindings.guest, remove_bindings);
	talloc_set_destructor(tracee->fs->bindings.host, remove_bindings);

	/* The binding to "/" has to be installed before other
	 * bindings since this former is required to canonicalize
	 * these latters.  */
	binding = CIRCLEQ_LAST(tracee->fs->bindings.pending);
	assert(compare_paths(binding->guest.path, "/") == PATHS_ARE_EQUAL);

	/* Call initialize_binding() on each pending binding in
	 * reverse order: the last binding "/" is used to bootstrap
	 * the canonicalization.  */
	while (binding != (void *) tracee->fs->bindings.pending) {
		Binding *previous;
		previous = CIRCLEQ_PREV(binding, link.pending);

		/* Canonicalize then insert this binding into
		 * tracee->fs->bindings.guest/host.  */
		initialize_binding(tracee, binding);

		/* Add induced bindings on sub-reconfiguration.  */
		add_induced_bindings(tracee, binding);

		binding = previous;
	}

	TALLOC_FREE(tracee->fs->bindings.pending);

	if (tracee->verbose > 0)
		print_bindings(tracee);

	return 0;
}

```

`library/src/main/jni/path/binding.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef BINDING_H
#define BINDING_H

#include <limits.h> /* PATH_MAX, */
#include <stdbool.h>

#include "tracee/tracee.h"
#include "path.h"

typedef struct binding {
	Path host;
	Path guest;

	bool need_substitution;
	bool must_exist;

	struct {
		CIRCLEQ_ENTRY(binding) pending;
		CIRCLEQ_ENTRY(binding) guest;
		CIRCLEQ_ENTRY(binding) host;
	} link;
} Binding;

typedef CIRCLEQ_HEAD(bindings, binding) Bindings;

extern Binding *insort_binding3(const Tracee *tracee, const void *context,
				const char host_path[PATH_MAX], const char guest_path[PATH_MAX]);
extern Binding *new_binding(Tracee *tracee, const char *host, const char *guest, bool must_exist);
extern int initialize_bindings(Tracee *tracee);
extern const char *get_path_binding(const Tracee* tracee, Side side, const char path[PATH_MAX]);
extern Binding *get_binding(const Tracee *tracee, Side side, const char path[PATH_MAX]);
extern const char *get_root(const Tracee* tracee);
extern int substitute_binding(const Tracee* tracee, Side side, char path[PATH_MAX]);
extern void remove_binding_from_all_lists(const Tracee *tracee, Binding *binding);

#endif /* BINDING_H */

```

`library/src/main/jni/path/canon.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sys/types.h> /* pid_t */
#include <limits.h>    /* PATH_MAX, */
#include <sys/param.h> /* MAXSYMLINKS, */
#include <errno.h>     /* E*, */
#include <sys/stat.h>  /* lstat(2), S_ISREG(), */
#include <unistd.h>    /* access(2), lstat(2), */
#include <string.h>    /* string(3), */
#include <assert.h>    /* assert(3), */
#include <stdio.h>     /* sscanf(3), */

#include "path/canon.h"
#include "path/path.h"
#include "path/binding.h"
#include "path/glue.h"
#include "path/proc.h"
#include "extension/extension.h"

/**
 * Put an end-of-string ('\0') right before the last component of @path.
 */
static inline void pop_component(char *path)
{
	int offset;

	/* Sanity checks. */
	assert(path != NULL);

	offset = strlen(path) - 1;
	assert(offset >= 0);

	/* Don't pop over "/", it doesn't mean anything. */
	if (offset == 0) {
		assert(path[0] == '/' && path[1] == '\0');
		return;
	}

	/* Skip trailing path separators. */
	while (offset > 1 && path[offset] == '/')
		offset--;

	/* Search for the previous path separator. */
	while (offset > 1 && path[offset] != '/')
		offset--;

	/* Cut the end of the string before the last component. */
	path[offset] = '\0';
	assert(path[0] == '/');
}

/**
 * Copy in @component the first path component pointed to by @cursor,
 * this later is updated to point to the next component for a further
 * call. This function returns:
 *
 *     - -errno if an error occured.
 *
 *     - FINAL_SLASH if it the last component of the path but we
 *       really expect a directory.
 *
 *     - FINAL_NORMAL if it the last component of the path.
 *
 *     - 0 otherwise.
 */
static inline Finality next_component(char component[NAME_MAX], const char **cursor)
{
	const char *start;
	ptrdiff_t length;
	bool want_dir;

	/* Sanity checks. */
	assert(component != NULL);
	assert(cursor    != NULL);

	/* Skip leading path separators. */
	while (**cursor != '\0' && **cursor == '/')
		(*cursor)++;

	/* Find the next component. */
	start = *cursor;
	while (**cursor != '\0' && **cursor != '/')
		(*cursor)++;
	length = *cursor - start;

	if (length >= NAME_MAX)
		return -ENAMETOOLONG;

	/* Extract the component. */
	strncpy(component, start, length);
	component[length] = '\0';

	/* Check if a [link to a] directory is expected. */
	want_dir = (**cursor == '/');

	/* Skip trailing path separators. */
	while (**cursor != '\0' && **cursor == '/')
		(*cursor)++;

	if (**cursor == '\0')
		return (want_dir
			? FINAL_SLASH
			: FINAL_NORMAL);

	return NOT_FINAL;
}

/**
 * Resolve bindings (if any) in @guest_path and copy the translated
 * path into @host_path.  Also, this function checks that a non-final
 * component is either a directory (returned value is 0) or a symlink
 * (returned value is 1), otherwise it returns -errno or -ENOTDIR.
 */
static inline int substitute_binding_stat(Tracee *tracee, Finality finality, unsigned int recursion_level,
					const char guest_path[PATH_MAX], char host_path[PATH_MAX])
{
	struct stat statl;
	int status;

	strcpy(host_path, guest_path);
	status = substitute_binding(tracee, GUEST, host_path);
	if (status < 0)
		return status;

	/* Don't notify extensions during the initialization of a binding.  */
	if (tracee->glue_type == 0) {
		status = notify_extensions(tracee, HOST_PATH, (intptr_t)host_path,
					IS_FINAL(finality) && recursion_level == 0);
		if (status < 0)
			return status;
	}

	statl.st_mode = 0;
	status = lstat(host_path, &statl);

	/* Build the glue between the hostfs and the guestfs during
	 * the initialization of a binding.  */
	if (status < 0 && tracee->glue_type != 0) {
		statl.st_mode = build_glue(tracee, guest_path, host_path, finality);
		if (statl.st_mode == 0)
			status = -1;
	}

	/* Return an error if a non-final component isn't a directory
	 * nor a symlink.  The error depends on why the component
	 * could not be accessed (ENOENT, EACCES, ...), otherwise the
	 * error is "Not a directory".  */
	if (!IS_FINAL(finality) && !S_ISDIR(statl.st_mode) && !S_ISLNK(statl.st_mode))
		return (status < 0 ? -errno : -ENOTDIR);

	return (S_ISLNK(statl.st_mode) ? 1 : 0);
}

/**
 * Copy in @guest_path the canonicalization (see `man 3 realpath`) of
 * @user_path regarding to @tracee->root.  The path to canonicalize
 * could be either absolute or relative to @guest_path. When the last
 * component of @user_path is a link, it is dereferenced only if
 * @deref_final is true -- it is useful for syscalls like lstat(2).
 * The parameter @recursion_level should be set to 0 unless you know
 * what you are doing. This function returns -errno if an error
 * occured, otherwise it returns 0.
 */
int canonicalize(Tracee *tracee, const char *user_path, bool deref_final,
		 char guest_path[PATH_MAX], unsigned int recursion_level)
{
	char scratch_path[PATH_MAX];
	char host_path[PATH_MAX];
	Finality finality;
	const char *cursor;
	int status;

	/* Avoid infinite loop on circular links.  */
	if (recursion_level > MAXSYMLINKS)
		return -ELOOP;

	/* Sanity checks.  */
	assert(user_path != NULL);
	assert(guest_path != NULL);
	assert(user_path != guest_path);

	if (strnlen(guest_path, PATH_MAX) >= PATH_MAX)
		return -ENAMETOOLONG;

	if (user_path[0] != '/') {
		/* Ensure 'guest_path' contains an absolute base of
		 * the relative `user_path`.  */
		if (guest_path[0] != '/')
			return -EINVAL;
	}
	else
		strcpy(guest_path, "/");


	/* Resolve bindings for the initial '/' component or user_path,
	 * which is not handled in the loop below.
	 * In particular HOST_PATH extensions are called from there.  */
//	status = substitute_binding_stat(tracee, NOT_FINAL, recursion_level, guest_path, host_path);
//	if (status < 0)
//		return status;
	strcpy(host_path,guest_path);

	/* Canonicalize recursely 'user_path' into 'guest_path'.  */
	cursor = user_path;
	finality = NOT_FINAL;
	while (!IS_FINAL(finality)) {
		Comparison comparison;
		char component[NAME_MAX];

		finality = next_component(component, &cursor);
		status = (int) finality;
		if (status < 0)
			return status;

		if (strcmp(component, ".") == 0) {
			if (IS_FINAL(finality))
				finality = FINAL_DOT;
			continue;
		}

		if (strcmp(component, "..") == 0) {
			pop_component(guest_path);
			if (IS_FINAL(finality))
				finality = FINAL_SLASH;
			continue;
		}

		status = join_paths(2, scratch_path, guest_path, component);
		if (status < 0)
			return status;

		/* Resolve bindings and check that a non-final
		 * component exists and either is a directory or is a
		 * symlink.  For this latter case, we check that the
		 * symlink points to a directory once it is
		 * canonicalized, at the end of this loop.  */
//		status = substitute_binding_stat(tracee, finality, recursion_level, scratch_path, host_path);
//		if (status < 0)
//			return status;
		strcpy(host_path, scratch_path);

		/* Nothing special to do if it's not a link or if we
		 * explicitly ask to not dereference 'user_path', as
		 * required by syscalls like lstat(2). Obviously, this
		 * later condition does not apply to intermediate path
		 * components.  Errors are explicitly ignored since
		 * they should be handled by the caller. */
		if (status <= 0 || (finality == FINAL_NORMAL && !deref_final)) {
			strcpy(scratch_path, guest_path);
			status = join_paths(2, guest_path, scratch_path, component);
			if (status < 0)
				return status;
			continue;
		}

		/* It's a link, so we have to dereference *and*
		 * canonicalize to ensure we are not going outside the
		 * new root.  */
		comparison = compare_paths("/proc", guest_path);
		switch (comparison) {
		case PATHS_ARE_EQUAL:
		case PATH1_IS_PREFIX:
			/* Some links in "/proc" are generated
			 * dynamically by the kernel.  PRoot has to
			 * emulate some of them.  */
			status = readlink_proc(tracee, scratch_path,
					       guest_path, component, comparison);
			switch (status) {
			case CANONICALIZE:
				/* The symlink is already dereferenced,
				 * now canonicalize it.  */
				goto canon;

			case DONT_CANONICALIZE:
				/* If and only very final, this symlink
				 * shouldn't be dereferenced nor canonicalized.  */
				if (finality == FINAL_NORMAL) {
					strcpy(guest_path, scratch_path);
					return 0;
				}
				break;

			default:
				if (status < 0)
					return status;
			}

		default:
			break;
		}

		status = readlink(host_path, scratch_path, sizeof(scratch_path));
		if (status < 0)
			return status;
		else if (status == sizeof(scratch_path))
			return -ENAMETOOLONG;
		scratch_path[status] = '\0';

		/* Remove the leading "root" part if needed, it's
		 * useful for "/proc/self/cwd/" for instance.  */
		status = detranslate_path(tracee, scratch_path, host_path);
		if (status < 0)
			return status;

	canon:
		/* Canonicalize recursively the referee in case it
		 * is/contains a link, moreover if it is not an
		 * absolute link then it is relative to
		 * 'guest_path'. */
		status = canonicalize(tracee, scratch_path, true, guest_path, recursion_level + 1);
		if (status < 0)
			return status;

		/* Check that a non-final canonicalized/dereferenced
		 * symlink exists and is a directory.  */
		status = substitute_binding_stat(tracee, finality, recursion_level, guest_path, host_path);
		if (status < 0)
			return status;

		/* Here, 'guest_path' shouldn't be a symlink anymore,
		 * unless it is a named file descriptor.  */
		assert(status != 1 || sscanf(guest_path, "/proc/%*d/fd/%d", &status) == 1);
	}

	/* At the exit stage of the first level of recursion,
	 * `guest_path` is fully canonicalized but a terminating '/'
	 * or a terminating '.' may be required to keep the initial
	 * semantic of `user_path`.  */
	if (recursion_level == 0) {
		switch (finality) {
		case FINAL_NORMAL:
			break;

		case FINAL_SLASH:
			strcpy(scratch_path, guest_path);
			status = join_paths(2, guest_path, scratch_path, "");
			if (status < 0)
				return status;
			break;

		case FINAL_DOT:
			strcpy(scratch_path, guest_path);
			status = join_paths(2, guest_path, scratch_path, ".");
			if (status < 0)
				return status;
			break;

		default:
			assert(0);
		}
	}

	return 0;
}

```

`library/src/main/jni/path/canon.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef CANON_H
#define CANON_H

#include <stdbool.h>
#include <limits.h>

#include "tracee/tracee.h"

extern int canonicalize(Tracee *tracee, const char *user_path, bool deref_final,
			char guest_path[PATH_MAX], unsigned int nb_recursion);

#endif /* CANON_H */

```

`library/src/main/jni/path/glue.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sys/types.h> /* mkdir(2), lstat(2), */
#include <sys/stat.h> /* mkdir(2), lstat(2), */
#include <fcntl.h>    /* mknod(2), */
#include <unistd.h>   /* mknod(2), lstat(2), unlink(2), rmdir(2), */
#include <string.h>   /* string(3),  */
#include <assert.h>   /* assert(3), */
#include <limits.h>   /* PATH_MAX, */
#include <errno.h>    /* errno, E* */
#include <talloc.h>   /* talloc_*, */

#include "path/binding.h"
#include "path/path.h"
#include "path/temp.h"
#include "cli/note.h"

#include "compat.h"

/**
 * Remove @path if it is empty only.
 *
 * Note: this is a Talloc destructor.
 */
static int remove_placeholder(char *path)
{
	struct stat statl;
	int status;

	status = lstat(path, &statl);
	if (status)
		return 0; /* Not fatal.  */

	if (!S_ISDIR(statl.st_mode)) {
		if (statl.st_size != 0)
			return 0; /* Not fatal.  */
		status = unlink(path);
	}
	else
		status = rmdir(path);
	if (status)
		return 0; /* Not fatal.  */

	return 0;
}

/**
 * Attach a copy of @path to the autofree context, and set its
 * destructor to remove_placeholder().
 */
static void set_placeholder_destructor(const char *path)
{
	TALLOC_CTX *autofreed;
	char *placeholder;

	autofreed = talloc_autofree_context();
	if (autofreed == NULL)
		return;

	placeholder = talloc_strdup(autofreed, path);
	if (placeholder == NULL)
		return;

	talloc_set_destructor(placeholder, remove_placeholder);
}

/**
 * Build in a temporary filesystem the glue between the guest part and
 * the host part of the @binding_path.  This function returns the type
 * of the bound path, otherwise 0 if an error occured.
 *
 * For example, assuming the host path "/opt" is mounted/bound to the
 * guest path "/black/holes/and/revelations", and assuming this path
 * can't be created in the guest rootfs (eg. permission denied), then
 * it is created in a temporary rootfs and all these paths are glued
 * that way:
 *
 *   $GUEST/black/ --> $GLUE/black/
 *                               ./holes
 *                               ./holes/and
 *                               ./holes/and/revelations --> $HOST/opt/
 *
 * This glue allows operations on paths that do not exist in the guest
 * rootfs but that were specified as the guest part of a binding.
 */
mode_t build_glue(Tracee *tracee, const char *guest_path, char host_path[PATH_MAX],
		Finality finality)
{
	bool belongs_to_gluefs;
	Comparison comparison;
	Binding *binding;
	mode_t type;
	mode_t mode;
	int status;

	assert(tracee->glue_type != 0);

	/* Create the temporary directory where the "glue" rootfs will
	 * lie.  */
	if (tracee->glue == NULL) {
		tracee->glue = create_temp_directory(NULL, tracee->tool_name);
		if (tracee->glue == NULL) {
			note(tracee, ERROR, INTERNAL, "can't create glue rootfs");
			return 0;
		}
		talloc_set_name_const(tracee->glue, "$glue");
	}

	comparison = compare_paths(tracee->glue, host_path);
	belongs_to_gluefs = (comparison == PATHS_ARE_EQUAL || comparison == PATH1_IS_PREFIX);

	/* If it's not a final component then it is a directory.  I definitely
	 * hate how the potential type of the final component is propagated
	 * from initialize_binding() down to here, sadly there's no elegant way
	 * to know its type at this stage.  */
	if (IS_FINAL(finality)) {
		type = tracee->glue_type;
		mode = (belongs_to_gluefs ? 0777 : 0);
	}
	else {
		type = S_IFDIR;
		mode = 0777;
	}

	if (getenv("PROOT_DONT_POLLUTE_ROOTFS") != NULL && !belongs_to_gluefs)
		goto create_binding;

	/* Try to create this component into the "guest" or "glue"
	 * rootfs (depending if there were a glue previously).  */
	if (S_ISDIR(type))
		status = mkdir(host_path, mode);
	else /* S_IFREG, S_IFCHR, S_IFBLK, S_IFIFO or S_IFSOCK.  */
		status = mknod(host_path, mode | type, 0);

	/* Remove placeholders from the guest rootfs once PRoot is
	 * terminated.  */
	if (status >= 0 && !belongs_to_gluefs)
		set_placeholder_destructor(host_path);

	/* Nothing else to do if the path already exists or if it is
	 * the final component since it will be pointed to by the
	 * binding being initialized (from the example,
	 * "$GUEST/black/holes/and/revelations" -> "$HOST/opt").  */
	if (status >= 0 || errno == EEXIST || IS_FINAL(finality))
		return type;

	/* mkdir/mknod are supposed to always succeed in
	 * tracee->glue.  */
	if (belongs_to_gluefs) {
		note(tracee, WARNING, SYSTEM, "mkdir/mknod");
		return 0;
	}

create_binding:
	/* Sanity checks.  */
	if (   strnlen(tracee->glue, PATH_MAX) >= PATH_MAX
	    || strnlen(guest_path, PATH_MAX) >= PATH_MAX) {
		note(tracee, WARNING, INTERNAL, "installing the binding: guest path too long");
		return 0;
	}

	/* From the example, create the binding "/black" ->
	 * "$GLUE/black".  */
	binding = insort_binding3(tracee, tracee->glue, tracee->glue, guest_path);
	if (binding == NULL)
		return 0;

	/* TODO: emulation of getdents(parent(guest_path)) to finalize
	 * the glue, "black" in getdents("/") from the example.  */

	return type;
}

```

`library/src/main/jni/path/glue.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef GLUE_H
#define GLUE_H

#include <limits.h> /* PATH_MAX, */

#include "tracee/tracee.h"
#include "path.h"

extern mode_t build_glue(Tracee *tracee, const char *guest_path, char host_path[PATH_MAX],
			Finality finality);

#endif /* GLUE_H */

```

`library/src/main/jni/path/path.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <string.h>    /* string(3), */
#include <stdarg.h>    /* va_*(3), */
#include <assert.h>    /* assert(3), */
#include <fcntl.h>     /* AT_*,  */
#include <unistd.h>    /* readlink*(2), *stat(2), getpid(2), */
#include <sys/types.h> /* pid_t, */
#include <sys/stat.h>  /* S_ISDIR, */
#include <dirent.h>    /* opendir(3), readdir(3), */
#include <stdio.h>     /* snprintf(3), */
#include <errno.h>     /* E*, */
#include <stddef.h>    /* ptrdiff_t, */
#include <inttypes.h>  /* PRI*, */
#include <stdlib.h>

#include "path/path.h"
//#include "path/binding.h"
#include "path/canon.h"
#include "path/proc.h"
//#include "extension/extension.h"
//#include "cli/note.h"
#include "build.h"

#include "compat.h"
#include "constant.h"
#include "note.h"

/**
 * Copy in @result the concatenation of several paths (@number_paths)
 * and adds a path separator ('/') in between when needed. This
 * function returns -errno if an error occured, otherwise it returns 0.
 */
int join_paths(int number_paths, char result[PATH_MAX], ...)
{
	va_list paths;
	size_t length;
	int status;
	int i;

	result[0] = '\0';
	length = 0;
	status = 0;

	/* Parse the list of variadic arguments. */
	va_start(paths, result);
	for (i = 0; i < number_paths; i++) {
		const char *path;
		size_t path_length;
		size_t new_length;

		path = va_arg(paths, const char *);
		if (path == NULL)
			continue;
		path_length = strlen(path);

		/* A new path separator is needed.  */
		if (length > 0 && result[length - 1] != '/' && path[0] != '/') {
			new_length = length + path_length + 1;
			if (new_length + 1 >= PATH_MAX) {
				status = -ENAMETOOLONG;
				break;
			}
			strcat(result + length, "/");
			strcat(result + length, path);
			length = new_length;
		}
		/* There are already two path separators.  */
		else if (length > 0 && result[length - 1] == '/' && path[0] == '/') {
			new_length = length + path_length - 1;
			if (new_length + 1 >= PATH_MAX) {
				status = -ENAMETOOLONG;
				break;
			}
			strcat(result + length, path + 1);
			length += path_length - 1;
		}
		/* There's already one path separator or result[] is empty.  */
		else {
			new_length = length + path_length;
			if (new_length + 1 >= PATH_MAX) {
				status = -ENAMETOOLONG;
				break;
			}
			strcat(result + length, path);
			length += path_length;
		}

		status = 0;
	}
	va_end(paths);

	return status;
}

/**
 * Put in @host_path the full path to the given shell @command.  The
 * @command is searched in @paths if not null, otherwise in $PATH
 * (relatively to the @tracee's file-system name-space).  This
 * function always returns -1 on error, otherwise 0.
 */
int which(Tracee *tracee, const char *paths, char host_path[PATH_MAX], const char *command)
{
	char path[PATH_MAX];
	const char *cursor;
	struct stat statr;
	int status;

	bool is_explicit;
	bool found;

	assert(command != NULL);
	is_explicit = (strchr(command, '/') != NULL);

	/* Is the command available without any $PATH look-up?  */
	status = realpath2(tracee, host_path, command, true);
	if (status == 0 && stat(host_path, &statr) == 0) {
		if (is_explicit && !S_ISREG(statr.st_mode)) {
//			note(tracee, ERROR, USER, "'%s' is not a regular file", command);
			LOGE("'%s' is not a regular file", command)
			return -EACCES;
		}

		if (is_explicit && (statr.st_mode & S_IXUSR) == 0) {
//			note(tracee, ERROR, USER, "'%s' is not executable", command);
			LOGE("'%s' is not executable", command)
			return -EACCES;
		}

		found = true;

		/* Don't dereference the final component to preserve
		 * argv0 in case it is a symlink to script.  */
		(void) realpath2(tracee, host_path, command, false);
	}
	else
		found = false;

	/* Is the the explicit command was found?  */
	if (is_explicit) {
		if (found)
			return 0;
		else
			goto not_found;
	}

	/* Otherwise search the command in $PATH.  */
	paths = paths ?: getenv("PATH");
	if (paths == NULL || strcmp(paths, "") == 0)
		goto not_found;

	cursor = paths;
	do {
		size_t length;

		length = strcspn(cursor, ":");
		cursor += length + 1;

		if (length >= PATH_MAX)
			continue;
		else if (length == 0)
			strcpy(path, ".");
		else {
			strncpy(path, cursor - length - 1, length);
			path[length] = '\0';
		}

		/* Avoid buffer-overflow.  */
		if (length + strlen(command) + 2 >= PATH_MAX)
			continue;

		strcat(path, "/");
		strcat(path, command);

		status = realpath2(tracee, host_path, path, true);
		if (status == 0
		    && stat(host_path, &statr) == 0
		    && S_ISREG(statr.st_mode)
		    && (statr.st_mode & S_IXUSR) != 0) {
			/* Don't dereference the final component to preserve
			 * argv0 in case it is a symlink to script.  */
			(void) realpath2(tracee, host_path, path, false);
			return 0;
		}
	} while (*(cursor - 1) != '\0');

not_found:
//	status = getcwd2(tracee, path);
//	if (status < 0)
//		strcpy(path, "<unknown>");
    if (getcwd(path,PATH_MAX) == NULL){
        strcpy(path, "<unknown>");
    }

//	note(tracee, ERROR, USER, "'%s' not found (root = %s, cwd = %s, $PATH=%s)",
//		command, get_root(tracee), path, paths);
//	LOGE("'%s' not found (root = %s, cwd = %s, $PATH=%s)",
//		 command, get_root(tracee), path, paths);

	/* Check if the command was found without any $PATH look-up
	 * but it didn't contain "/".  */
	if (found && !is_explicit)
//		note(tracee, ERROR, USER,
//			"to execute a local program, use the './' prefix, for example: ./%s", command);
	LOGE("to execute a local program, use the './' prefix, for example: ./%s", command);

	return -1;
}

/**
 * Put in @host_path the canonicalized form of @path.  In the nominal
 * case (@tracee == NULL), this function is barely equivalent to
 * realpath(), but when doing sub-reconfiguration, the path is
 * canonicalized relatively to the current @tracee's file-system
 * name-space.  This function returns -errno on error, otherwise 0.
 */
int realpath2(Tracee *tracee, char host_path[PATH_MAX], const char *path, bool deref_final)
{
	int status;

	if (tracee == NULL)
		status = (realpath(path, host_path) == NULL ? -errno : 0);
	else
		status = translate_path(tracee, host_path, AT_FDCWD, path, deref_final);
	return status;
}

/**
 * Put in @guest_path the canonicalized current working directory.  In
 * the nominal case (@tracee == NULL), this function is barely
 * equivalent to realpath(), but when doing sub-reconfiguration, the
 * path is canonicalized relatively to the current @tracee's
 * file-system name-space.  This function returns -errno on error,
 * otherwise 0.
 */
int getcwd2(Tracee *tracee, char guest_path[PATH_MAX])
{
	if (tracee == NULL) {
		if (getcwd(guest_path, PATH_MAX) == NULL)
			return -errno;
	}
	else {
		//TODO 是否需要fake一下?
//		if (strlen(tracee->fs->cwd) >= PATH_MAX)
//			return -ENAMETOOLONG;
//
//		strcpy(guest_path, tracee->fs->cwd);
	}

	return 0;
}

/**
 * Remove the trailing "/" or "/.".
 */
void chop_finality(char *path)
{
	size_t length = strlen(path);

	if (path[length - 1] == '.') {
		assert(length >= 2);
		/* Special case for "/." */
		if (length == 2)
			path[length - 1] = '\0';
		else
			path[length - 2] = '\0';
	}
	else if (path[length - 1] == '/') {
		/* Special case for "/" */
		if (length > 1)
			path[length - 1] = '\0';
	}
}

/**
 * Put in @path the result of readlink(/proc/@pid/fd/@fd).  This
 * function returns -errno if an error occured, otherwise 0.
 */
int readlink_proc_pid_fd(pid_t pid, int fd, char path[PATH_MAX])
{
	char link[32]; /* 32 > sizeof("/proc//cwd") + sizeof(#ULONG_MAX) */
	int status;

	/* Format the path to the "virtual" link. */
	status = snprintf(link, sizeof(link), "/proc/%d/fd/%d",	pid, fd);
	if (status < 0)
		return -EBADF;
	if ((size_t) status >= sizeof(link))
		return -EBADF;

	/* Read the value of this "virtual" link. */
	status = readlink(link, path, PATH_MAX);
	if (status < 0)
		return -EBADF;
	if (status >= PATH_MAX)
		return -ENAMETOOLONG;
	path[status] = '\0';

	return 0;
}

/**
 * Copy in @result the equivalent of "@tracee->root + canon(@dir_fd +
 * @user_path)".  If @user_path is not absolute then it is relative to
 * the directory referred by the descriptor @dir_fd (AT_FDCWD is for
 * the current working directory).  See the documentation of
 * canonicalize() for the meaning of @deref_final.  This function
 * returns -errno if an error occured, otherwise 0.
 */
int translate_path(Tracee *tracee, char result[PATH_MAX], int dir_fd,
		const char *user_path, bool deref_final)
{

	char guest_path[PATH_MAX];
	int status;

	/* Use "/" as the base if it is an absolute guest path. */
	if (user_path[0] == '/') { //绝对路径
		strcpy(result, "/");
	}
		/* It is relative to a directory referred by a descriptor, see
         * openat(2) for details. */
	else if (dir_fd != AT_FDCWD) { //相对一个目录
		/* /proc/@tracee->pid/fd/@dir_fd -> result.  */
		status = readlink_proc_pid_fd(tracee->pid, dir_fd, result);
		if (status < 0)
			return status;

		/* Named file descriptors may reference special
		 * objects like pipes, sockets, inodes, ...  Such
		 * objects do not belong to the file-system.  */
		if (result[0] != '/')
			return -ENOTDIR;

		/* Remove the leading "root" part of the base
		 * (required!). */
//		status = detranslate_path(tracee, result, NULL);
//		if (status < 0)
//			return status;
	}
		/* It is relative to the current working directory.  */
	else { //相对工作目录
//		status = getcwd2(tracee, result);
//		if (status < 0)
//			return status;
        if (getcwd(result,PATH_MAX) == NULL)
            return -errno;
	}

	VERBOSE(tracee, 2, "vpid %" PRIu64 ": translate(\"%s\" + \"%s\")",
			tracee != NULL ? tracee->vpid : 0, result, user_path);

//	status = notify_extensions(tracee, GUEST_PATH, (intptr_t) result, (intptr_t) user_path);
//	if (status < 0)
//		return status;
//	if (status > 0)
//		goto skip;

	/* So far "result" was used as a base path, it's time to join
	 * it to the user path.  */
	assert(result[0] == '/');
	status = join_paths(2, guest_path, result, user_path);
	if (status < 0)
		return status;
//	strcpy(result, "/");
	strcpy(result,guest_path);
	LOGSYS("translate_path guest_path %s",guest_path)
	/* Canonicalize regarding the new root. */
//	status = canonicalize(tracee, guest_path, deref_final, result, 0);
//	if (status < 0)
//		return status;


	/* Final binding substitution to convert "result" into a host
	 * path, since canonicalize() works from the guest
	 * point-of-view.  */
//	status = substitute_binding(tracee, GUEST, result);
//	if (status < 0)
//		return status;

//	skip:
	VERBOSE(tracee, 2, "vpid %" PRIu64 ":          -> \"%s\"",
			tracee != NULL ? tracee->vpid : 0, result);

//	status = notify_extensions(tracee, TRANSLATED_PATH, (intptr_t) result, 0);
//	if (status < 0)
//		return status;

	return 0;
}

/**
 * Remove/substitute the leading part of a "translated" @path.  It
 * returns 0 if no transformation is required (ie. symmetric binding),
 * otherwise it returns the size in bytes of the updated @path,
 * including the end-of-string terminator.  On error it returns
 * -errno.
 */
int detranslate_path(Tracee *tracee, char path[PATH_MAX], const char t_referrer[PATH_MAX])
{
    //路径变换(移除/添加前缀)
    return 0;
//	size_t prefix_length;
//	ssize_t new_length;
//
//	bool sanity_check;
//	bool follow_binding;
//
//	/* Sanity check.  */
//	if (strnlen(path, PATH_MAX) >= PATH_MAX)
//		return -ENAMETOOLONG;
//
//	/* Don't try to detranslate relative paths (typically the
//	 * target of a relative symbolic link). */
//	if (path[0] != '/')
//		return 0;
//
//	/* Is it a symlink?  */
//	if (t_referrer != NULL) {
//		Comparison comparison;
//
//		sanity_check = false;
//		follow_binding = false;
//
//		/* In some cases bindings have to be resolved.  */
//		comparison = compare_paths("/proc", t_referrer);
//		if (comparison == PATH1_IS_PREFIX) {
//			/* Some links in "/proc" are generated
//			 * dynamically by the kernel.  PRoot has to
//			 * emulate some of them.  */
//			char proc_path[PATH_MAX];
//			strcpy(proc_path, path);
//			new_length = readlink_proc2(tracee, proc_path, t_referrer);
//			if (new_length < 0)
//				return new_length;
//			if (new_length != 0) {
//				strcpy(path, proc_path);
//				return new_length + 1;
//			}
//
//			/* Always resolve bindings for symlinks in
//			 * "/proc", they always point to the emulated
//			 * file-system namespace by design. */
//			follow_binding = true;
//		}
//		else if (!belongs_to_guestfs(tracee, t_referrer)) {
//			const char *binding_referree;
//			const char *binding_referrer;
//
//			binding_referree = get_path_binding(tracee, HOST, path);
//			binding_referrer = get_path_binding(tracee, HOST, t_referrer);
//			assert(binding_referrer != NULL);
//
//			/* Resolve bindings for symlinks that belong
//			 * to a binding and point to the same binding.
//			 * For example, if "-b /lib:/foo" is specified
//			 * and the symlink "/lib/a -> /lib/b" exists
//			 * in the host rootfs namespace, then it
//			 * should appear as "/foo/a -> /foo/b" in the
//			 * guest rootfs namespace for consistency
//			 * reasons.  */
//			if (binding_referree != NULL) {
//				comparison = compare_paths(binding_referree, binding_referrer);
//				follow_binding = (comparison == PATHS_ARE_EQUAL);
//			}
//		}
//	}
//	else {
//		sanity_check = true;
//		follow_binding = true;
//	}
//
//	if (follow_binding) {
//		switch (substitute_binding(tracee, HOST, path)) {
//		case 0:
//			return 0;
//		case 1:
//			return strlen(path) + 1;
//		default:
//			break;
//		}
//	}
//
//	switch (compare_paths(get_root(tracee), path)) {
//	case PATH1_IS_PREFIX:
//		/* Remove the leading part, that is, the "root".  */
//		prefix_length = strlen(get_root(tracee));
//
//		/* Special case when path to the guest rootfs == "/". */
//		if (prefix_length == 1)
//			prefix_length = 0;
//
//		new_length = strlen(path) - prefix_length;
//		memmove(path, path + prefix_length, new_length);
//
//		path[new_length] = '\0';
//		break;
//
//	case PATHS_ARE_EQUAL:
//		/* Special case when path == root. */
//		new_length = 1;
//		strcpy(path, "/");
//		break;
//
//	default:
//		/* Ensure the path is within the new root.  */
//		if (sanity_check)
//			return -EPERM;
//		else
//			return 0;
//	}
//
//	return new_length + 1;
}

/**
 * Check if the translated @host_path belongs to the guest rootfs,
 * that is, isn't from a binding.
 */
bool belongs_to_guestfs(const Tracee *tracee, const char *host_path)
{
    return true;
//	Comparison comparison;
//
//	comparison = compare_paths(get_root(tracee), host_path);
//	return (comparison == PATHS_ARE_EQUAL || comparison == PATH1_IS_PREFIX);
}

/**
 * Compare @path1 with @path2, which are respectively @length1 and
 * @length2 long.
 *
 * This function works only with paths canonicalized in the same
 * namespace (host/guest)!
 */
Comparison compare_paths2(const char *path1, size_t length1, const char *path2, size_t length2)
{
	size_t length_min;
	bool is_prefix;
	char sentinel;

#if defined DEBUG_OPATH
	assert(length(path1) == length1);
	assert(length(path2) == length2);
#endif
	assert(length1 > 0);
	assert(length2 > 0);

	if (!length1 || !length2) {
		return PATHS_ARE_NOT_COMPARABLE;
	}

	/* Remove potential trailing '/' for the comparison.  */
	if (path1[length1 - 1] == '/')
		length1--;

	if (path2[length2 - 1] == '/')
		length2--;

	if (length1 < length2) {
		length_min = length1;
		sentinel = path2[length_min];
	}
	else {
		length_min = length2;
		sentinel = path1[length_min];
	}

	/* Optimize obvious cases.  */
	if (sentinel != '/' && sentinel != '\0')
		return PATHS_ARE_NOT_COMPARABLE;

	is_prefix = (strncmp(path1, path2, length_min) == 0);

	if (!is_prefix)
		return PATHS_ARE_NOT_COMPARABLE;

	if (length1 == length2)
		return PATHS_ARE_EQUAL;
	else if (length1 < length2)
		return PATH1_IS_PREFIX;
	else if (length1 > length2)
		return PATH2_IS_PREFIX;

	assert(0);
	return PATHS_ARE_NOT_COMPARABLE;
}

Comparison compare_paths(const char *path1, const char *path2)
{
	return compare_paths2(path1, strlen(path1), path2, strlen(path2));
}

typedef int (*foreach_fd_t)(const Tracee *tracee, int fd, char path[PATH_MAX]);

/**
 * Call @callback on each open file descriptors of @pid. It returns
 * the status of the first failure, that is, if @callback returned
 * seomthing lesser than 0, otherwise 0.
 */
static int foreach_fd(const Tracee *tracee, foreach_fd_t callback)
{
	struct dirent *dirent;
	char path[PATH_MAX];
	char proc_fd[32]; /* 32 > sizeof("/proc//fd") + sizeof(#ULONG_MAX) */
	int status;
	DIR *dirp;

	/* Format the path to the "virtual" directory. */
	status = snprintf(proc_fd, sizeof(proc_fd), "/proc/%d/fd", tracee->pid);
	if (status < 0 || (size_t) status >= sizeof(proc_fd))
		return 0;

	/* Open the virtual directory "/proc/$pid/fd". */
	dirp = opendir(proc_fd);
	if (dirp == NULL)
		return 0;

	while ((dirent = readdir(dirp)) != NULL) {
		/* Read the value of this "virtual" link.  Don't use
		 * readlinkat(2) here since it would require Linux >=
		 * 2.6.16 and Glibc >= 2.4, whereas PRoot is supposed
		 * to work on any Linux 2.6 systems.  */

		char tmp[PATH_MAX];
		if (strlen(proc_fd) + strlen(dirent->d_name) + 1 >= PATH_MAX)
			continue;

		strcpy(tmp, proc_fd);
		strcat(tmp, "/");
		strcat(tmp, dirent->d_name);

		status = readlink(tmp, path, PATH_MAX);
		if (status < 0 || status >= PATH_MAX)
			continue;
		path[status] = '\0';

		/* Ensure it points to a path (not a socket or somethink like that). */
		if (path[0] != '/')
			continue;

		status = callback(tracee, atoi(dirent->d_name), path);
		if (status < 0)
			goto end;
	}
	status = 0;

end:
	closedir(dirp);
	return status;
}

/**
 * Helper for list_open_fd().
 */
//static int list_open_fd_callback(const Tracee *tracee, int fd, char path[PATH_MAX])
//{
//	VERBOSE(tracee, 1, "pid %d: access to \"%s\" (fd %d) won't be translated until closed",
//		tracee->pid, path, fd);
//	notify_extensions((Tracee*)tracee, ALREADY_OPENED_FD, (intptr_t)path, (intptr_t)fd);
//	return 0;
//}

/**
 * Warn for files that are open. It is useful right after PRoot has
 * attached a process.
 */
//int list_open_fd(const Tracee *tracee)
//{
//	return foreach_fd(tracee, list_open_fd_callback);
//}

/**
 * Substitute the first @old_prefix_length bytes of @path with
 * @new_prefix (the caller has to provides a correct
 * @new_prefix_length).  This function returns the new length of
 * @path.  Note: this function takes care about special cases (like
 * "/").
 */
size_t substitute_path_prefix(char path[PATH_MAX], size_t old_prefix_length,
			const char *new_prefix, size_t new_prefix_length)
{
	size_t path_length;
	size_t new_length;

	path_length = strlen(path);

	assert(old_prefix_length < PATH_MAX);
	assert(new_prefix_length < PATH_MAX);

	if (new_prefix_length == 1) {
		/* Special case: "/foo" -> "/".  Substitute "/foo/bin"
		 * with "/bin" not "//bin".  */

		new_length = path_length - old_prefix_length;
		if (new_length != 0)
			memmove(path, path + old_prefix_length, new_length);
		else {
			/* Special case: "/".  */
			path[0] = '/';
			new_length = 1;
		}
	}
	else if (old_prefix_length == 1) {
		/* Special case: "/" -> "/foo". Substitute "/bin" with
		 * "/foo/bin" not "/foobin".  */

		new_length = new_prefix_length + path_length;
		if (new_length >= PATH_MAX)
			return -ENAMETOOLONG;

		if (path_length > 1) {
			memmove(path + new_prefix_length, path, path_length);
			memcpy(path, new_prefix, new_prefix_length);
		}
		else {
			/* Special case: "/".  */
			memcpy(path, new_prefix, new_prefix_length);
			new_length = new_prefix_length;
		}
	}
	else {
		/* Generic case.  */

		new_length = path_length - old_prefix_length + new_prefix_length;
		if (new_length >= PATH_MAX)
			return -ENAMETOOLONG;

		memmove(path + new_prefix_length,
			path + old_prefix_length,
			path_length - old_prefix_length);
		memcpy(path, new_prefix, new_prefix_length);
	}

	assert(new_length < PATH_MAX);
	path[new_length] = '\0';

	return new_length;
}

```

`library/src/main/jni/path/path.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef PATH_H
#define PATH_H

#include <sys/types.h> /* pid_t, */
#include <fcntl.h> /* AT_FDCWD, */
#include <limits.h> /* PATH_MAX, */
#include <stdbool.h>

#include "tracee/tracee.h"

/* File type.  */
typedef enum {
	REGULAR,
	SYMLINK,
} Type;

/* Path point-of-view.  */
typedef enum {
	GUEST,
	HOST,

	/* Used for bindings as specified by the user but not
	 * canonicalized yet (new_binding, initialize_binding).  */
	PENDING,
} Side;

/* Path with cached attributes.  */
typedef struct {
	char path[PATH_MAX];
	size_t length;
	Side side;
} Path;

/* Path ending type.  */
typedef enum {
	NOT_FINAL,
	FINAL_NORMAL,
	FINAL_SLASH,
	FINAL_DOT
} Finality;

#define IS_FINAL(a) ((a) != NOT_FINAL)

/* Comparison between two paths.  */
typedef enum Comparison {
	PATHS_ARE_EQUAL,
	PATH1_IS_PREFIX,
	PATH2_IS_PREFIX,
	PATHS_ARE_NOT_COMPARABLE,
} Comparison;

extern int which(Tracee *tracee, const char *paths, char host_path[PATH_MAX], const char *command);
extern int realpath2(Tracee *tracee, char host_path[PATH_MAX], const char *path, bool deref_final);
extern int getcwd2(Tracee *tracee, char guest_path[PATH_MAX]);
extern void chop_finality(char *path);

extern int translate_path(Tracee *tracee, char host_path[PATH_MAX],
			int dir_fd, const char *guest_path, bool deref_final);

extern int detranslate_path(Tracee *tracee, char path[PATH_MAX], const char t_referrer[PATH_MAX]);
extern bool belongs_to_guestfs(const Tracee *tracee, const char *path);

extern int join_paths(int number_paths, char result[PATH_MAX], ...);
extern int list_open_fd(const Tracee *tracee);

extern Comparison compare_paths(const char *path1, const char *path2);
extern Comparison compare_paths2(const char *path1, size_t length1, const char *path2, size_t length2);

extern size_t substitute_path_prefix(char path[PATH_MAX], size_t old_prefix_length,
				const char *new_prefix, size_t new_prefix_length);

extern int readlink_proc_pid_fd(pid_t pid, int fd, char path[PATH_MAX]);

/* Check if path interpretable relatively to dirfd, see openat(2) for details. */
#define AT_FD(dirfd, path) ((dirfd) != AT_FDCWD && ((path) != NULL && (path)[0] != '/'))

#endif /* PATH_H */

```

`library/src/main/jni/path/proc.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <stdio.h>   /* snprintf(3), */
#include <string.h>  /* strcmp(3), */
#include <stdlib.h>  /* atoi(3), strtol(3), */
#include <errno.h>   /* E*, */
#include <assert.h>  /* assert(3), */

#include "path/proc.h"
#include "tracee/tracee.h"
#include "path/path.h"
#include "path/binding.h"

/**
 * This function emulates the @result of readlink("@base/@component")
 * with respect to @tracee, where @base belongs to "/proc" (according
 * to @comparison).  This function returns -errno on error, an enum
 * @action otherwise (c.f. above).
 *
 * Unlike readlink(), this function includes the nul terminating byte
 * to @result.
 */
Action readlink_proc(const Tracee *tracee, char result[PATH_MAX],
			const char base[PATH_MAX], const char component[NAME_MAX],
			Comparison comparison)
{
	const Tracee *known_tracee;
	char proc_path[64]; /* 64 > sizeof("/proc//fd/") + 2 * sizeof(#ULONG_MAX) */
	int status;
	pid_t pid;

	assert(comparison == compare_paths("/proc", base));

	/* Remember: comparison = compare_paths("/proc", base)  */
	switch (comparison) {
	case PATHS_ARE_EQUAL:
		/* Substitute "/proc/self" with "/proc/<PID>".  */
		if (strcmp(component, "self") != 0)
			return DEFAULT;

		status = snprintf(result, PATH_MAX, "/proc/%d", tracee->pid);
		if (status < 0 || status >= PATH_MAX)
			return -EPERM;

		return CANONICALIZE;

	case PATH1_IS_PREFIX:
		/* Handle "/proc/<PID>" below, where <PID> is process
		 * monitored by PRoot.  */
		break;

	default:
		return DEFAULT;
	}

	pid = atoi(base + strlen("/proc/"));
	if (pid == 0)
		return DEFAULT;

	/* Handle links in "/proc/<PID>/".  */
	status = snprintf(proc_path, sizeof(proc_path), "/proc/%d", pid);
	if (status < 0 || (size_t) status >= sizeof(proc_path))
		return -EPERM;

	comparison = compare_paths(proc_path, base);
	switch (comparison) {
	case PATHS_ARE_EQUAL:
		known_tracee = get_tracee(tracee, pid, false);
		if (known_tracee == NULL)
			return DEFAULT;

#define SUBSTITUTE(name, string)				\
		do {						\
			if (strcmp(component, #name) != 0)	\
				break;				\
								\
			status = strlen(string);		\
			if (status >= PATH_MAX)			\
				return -EPERM;			\
								\
			strncpy(result, string, status + 1);	\
			return CANONICALIZE;			\
		} while (0)

		/* Substitute link "/proc/<PID>/???" with the content
		 * of tracee->???.  */
		SUBSTITUTE(exe, known_tracee->exe);
		SUBSTITUTE(cwd, known_tracee->fs->cwd);
		SUBSTITUTE(root, get_root(known_tracee));
#undef SUBSTITUTE
		return DEFAULT;

	case PATH1_IS_PREFIX:
		/* Handle "/proc/<PID>/???" below.  */
		break;

	default:
		return DEFAULT;
	}

	/* Handle links in "/proc/<PID>/fd/".  */
	status = snprintf(proc_path, sizeof(proc_path), "/proc/%d/fd", pid);
	if (status < 0 || (size_t) status >= sizeof(proc_path))
		return -EPERM;

	comparison = compare_paths(proc_path, base);
	switch (comparison) {
		char *end_ptr;

	case PATHS_ARE_EQUAL:
		/* Sanity check: a number is expected.  */
		errno = 0;
		(void) strtol(component, &end_ptr, 10);
		if (errno != 0 || end_ptr == component)
			return -EPERM;

		/* Don't dereference "/proc/<PID>/fd/???" now: they
		 * can point to anonymous pipe, socket, ...  otherwise
		 * they point to a path already canonicalized by the
		 * kernel.
		 *
		 * Note they are still correctly detranslated in
		 * syscall/exit.c if a monitored process uses
		 * readlink() against any of them.  */
		status = snprintf(result, PATH_MAX, "%s/%s", base, component);
		if (status < 0 || status >= PATH_MAX)
			return -EPERM;

		return DONT_CANONICALIZE;

	default:
		break;
	}

	return DEFAULT;
}

/**
 * This function emulates the @result of readlink("@referer") with
 * respect to @tracee, where @referer is a strict subpath of "/proc".
 * This function returns -errno if an error occured, the length of
 * @result if the readlink was emulated, 0 otherwise.
 *
 * Unlike readlink(), this function includes the nul terminating byte
 * to @result (but this byte is not counted in the returned value).
 */
ssize_t readlink_proc2(const Tracee *tracee, char result[PATH_MAX], const char referer[PATH_MAX])
{
	Action action;
	char base[PATH_MAX];
	char *component;

	/* Sanity check.  */
	if (strnlen(referer, PATH_MAX) >= PATH_MAX)
		return -ENAMETOOLONG;

	assert(compare_paths("/proc", referer) == PATH1_IS_PREFIX);

	/* It's safe to use strrchr() here since @referer was
	 * previously canonicalized.  */
	strcpy(base, referer);
	component = strrchr(base, '/');

	/* These cases are not possible: @referer is supposed to be a
	 * canonicalized subpath of "/proc".  */
	assert(component != NULL && component != base);

	component[0] = '\0';
	component++;
	if (component[0] == '\0')
		return 0;

	action = readlink_proc(tracee, result, base, component, PATH1_IS_PREFIX);
	return (action == CANONICALIZE ? strlen(result) : 0);
}

```

`library/src/main/jni/path/proc.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef PROC_H
#define PROC_H

#include <limits.h>

#include "tracee/tracee.h"
#include "path/path.h"

/* Action to do after a call to readlink_proc().  */
typedef enum {
	DEFAULT,           /* Nothing special to do, treat it as a regular link.  */
	CANONICALIZE,      /* The symlink was dereferenced, now canonicalize it.  */
	DONT_CANONICALIZE, /* The symlink shouldn't be dereferenced nor canonicalized.  */
} Action;


extern Action readlink_proc(const Tracee *tracee, char result[PATH_MAX], const char path[PATH_MAX],
			const char component[NAME_MAX],	Comparison comparison);

extern ssize_t readlink_proc2(const Tracee *tracee, char result[PATH_MAX], const char path[PATH_MAX]);

#endif /* PROC_H */

```

`library/src/main/jni/path/temp.c`:

```c
#include <sys/types.h>  /* stat(2), opendir(3), */
#include <sys/stat.h>   /* stat(2), chmod(2), */
#include <unistd.h>     /* stat(2), rmdir(2), unlink(2), readlink(2), */
#include <errno.h>      /* errno(2), */
#include <dirent.h>     /* readdir(3), opendir(3), */
#include <string.h>     /* strcmp(3), */
#include <stdlib.h>     /* free(3), getenv(3), */
#include <stdio.h>      /* P_tmpdir, */
//#include <talloc.h>     /* talloc(3), */

//#include "cli/note.h"
#include "constant.h"

/**
 * Return the path to a directory where temporary files should be
 * created.
 */
const char *get_temp_directory()
{
	//TODO android下临时目录肯定不一样
    LOGE("get_temp_directory");
	return "get_temp_directory";
//	static const char *temp_directory = NULL;
//	char *tmp;
//
//	if (temp_directory != NULL)
//		return temp_directory;
//
//	temp_directory = getenv("PROOT_TMP_DIR");
//	if (temp_directory == NULL) {
//		temp_directory = P_tmpdir;
//		return temp_directory;
//	}
//
//	tmp = realpath(temp_directory, NULL);
//	if (tmp == NULL) {
//		note(NULL, WARNING, SYSTEM,
//			"can't canonicalize %s, using %s instead of PROOT_TMP_DIR",
//			temp_directory, P_tmpdir);
//
//		temp_directory = P_tmpdir;
//		return temp_directory;
//	}
//
//	temp_directory = talloc_strdup(talloc_autofree_context(), tmp);
//	if (temp_directory == NULL)
//		temp_directory = tmp;
//	else
//		free(tmp);
//
//	return temp_directory;
}

/**
 * Handle the return of d_type = DT_UNKNOWN by readdir(3)
 * Not all filesystems support returning d_type in readdir(3)
 */
static int get_dtype(struct dirent *de)
{
	int dtype = de ? de->d_type : DT_UNKNOWN;
	struct stat st;

	if (dtype != DT_UNKNOWN)
		return dtype;
	if (lstat(de->d_name, &st))
		return dtype;
	if (S_ISREG(st.st_mode))
		return DT_REG;
	if (S_ISDIR(st.st_mode))
		return DT_DIR;
	if (S_ISLNK(st.st_mode))
		return DT_LNK;
	return dtype;
}

/**
 * Remove recursively the content of the current working directory.
 * This latter has to lie in temp_directory (ie. "/tmp" on most
 * systems).  This function returns -1 if a fatal error occured
 * (ie. the recursion must be stopped), the number of non-fatal errors
 * otherwise.
 *
 * WARNING: this function changes the current working directory for
 * the calling process.
 */
static int clean_temp_cwd()
{
    LOGE("clean_temp_cwd")
    return 0;
//	const char *temp_directory = get_temp_directory();
//	const size_t length_temp_directory = strlen(temp_directory);
//	char *prefix = NULL;
//	int nb_errors = 0;
//	DIR *dir = NULL;
//	int status;
//
//	prefix = talloc_size(NULL, length_temp_directory + 1);
//	if (prefix == NULL) {
//		note(NULL, WARNING, INTERNAL, "can't allocate memory");
//		nb_errors++;
//		goto end;
//	}
//
//	/* Sanity check: ensure the current directory lies in
//	 * "/tmp".  */
//	status = readlink("/proc/self/cwd", prefix, length_temp_directory);
//	if (status < 0) {
//		note(NULL, WARNING, SYSTEM, "can't readlink '/proc/self/cwd'");
//		nb_errors++;
//		goto end;
//	}
//	prefix[status] = '\0';
//
//	if (strncmp(prefix, temp_directory, length_temp_directory) != 0) {
//		note(NULL, ERROR, INTERNAL,
//			"trying to remove a directory outside of '%s', "
//			"please report this error.\n", temp_directory);
//		nb_errors++;
//		goto end;
//	}
//
//	dir = opendir(".");
//	if (dir == NULL) {
//		note(NULL, WARNING, SYSTEM, "can't open '.'");
//		nb_errors++;
//		goto end;
//	}
//
//	while (1) {
//		struct dirent *entry;
//
//		errno = 0;
//		entry = readdir(dir);
//		if (entry == NULL)
//			break;
//
//		if (   strcmp(entry->d_name, ".")  == 0
//		    || strcmp(entry->d_name, "..") == 0)
//			continue;
//
//		status = chmod(entry->d_name, 0700);
//		if (status < 0) {
//			note(NULL, WARNING, SYSTEM, "cant chmod '%s'", entry->d_name);
//			nb_errors++;
//			continue;
//		}
//
//		if (get_dtype(entry) == DT_DIR) {
//			status = chdir(entry->d_name);
//			if (status < 0) {
//				note(NULL, WARNING, SYSTEM, "can't chdir '%s'", entry->d_name);
//				nb_errors++;
//				continue;
//			}
//
//			/* Recurse.  */
//			status = clean_temp_cwd();
//			if (status < 0) {
//				nb_errors = -1;
//				goto end;
//			}
//			nb_errors += status;
//
//			status = chdir("..");
//			if (status < 0) {
//				note(NULL, ERROR, SYSTEM, "can't chdir to '..'");
//				nb_errors = -1;
//				goto end;
//			}
//
//			status = rmdir(entry->d_name);
//		}
//		else {
//			status = unlink(entry->d_name);
//		}
//		if (status < 0) {
//			note(NULL, WARNING, SYSTEM, "can't remove '%s'", entry->d_name);
//			nb_errors++;
//			continue;
//		}
//	}
//	if (errno != 0) {
//		note(NULL, WARNING, SYSTEM, "can't readdir '.'");
//		nb_errors++;
//	}
//
//end:
//	TALLOC_FREE(prefix);
//
//	if (dir != NULL)
//		(void) closedir(dir);

//	return nb_errors;
}

/**
 * Remove recursively @path.  This latter has to be a directory lying
 * in temp_directory (ie. "/tmp" on most systems).  This function
 * returns -1 on error, otherwise 0.
 */
static int remove_temp_directory2(const char *path)
{
    LOGE("remove_temp_directory2")
    return 0;
//	int result;
//	int status;
//	char *cwd;
//
//#ifdef __ANDROID__
//	cwd = malloc(PATH_MAX);
//	getcwd(cwd, PATH_MAX);
//#else
//	cwd = get_current_dir_name();
//#endif
//
//	status = chmod(path, 0700);
//	if (status < 0) {
//		note(NULL, ERROR, SYSTEM, "can't chmod '%s'", path);
//		result = -1;
//		goto end;
//	}
//
//	status = chdir(path);
//	if (status < 0) {
//		note(NULL, ERROR, SYSTEM, "can't chdir to '%s'", path);
//		result = -1;
//		goto end;
//	}
//
//	status = clean_temp_cwd();
//	result = (status == 0 ? 0 : -1);
//
//	/* Try to remove path even if something went wrong.  */
//	status = chdir("..");
//	if (status < 0) {
//		note(NULL, ERROR, SYSTEM, "can't chdir to '..'");
//		result = -1;
//		goto end;
//	}
//
//	status = rmdir(path);
//	if (status < 0) {
//		note(NULL, ERROR, SYSTEM, "cant remove '%s'", path);
//		result = -1;
//		goto end;
//	}
//
//end:
//	if (cwd != NULL) {
//		status = chdir(cwd);
//		if (status < 0) {
//			result = -1;
//			note(NULL, ERROR, SYSTEM, "can't chdir to '%s'", cwd);
//		}
//		free(cwd);
//	}
//
//	return result;
}

/**
 * Like remove_temp_directory2() but always return 0.
 *
 * Note: this is a talloc destructor.
 */
static int remove_temp_directory(char *path)
{
	(void) remove_temp_directory2(path);
	return 0;
}

/**
 * Remove the file @path.  This function always returns 0.
 *
 * Note: this is a talloc destructor.
 */
static int remove_temp_file(char *path)
{
	int status;

	status = unlink(path);
	if (status < 0)
//		note(NULL, ERROR, SYSTEM, "can't remove '%s'", path);
    LOGE( "can't remove '%s'", path)

	return 0;
}

/**
 * Create a path name with the following format:
 * "/tmp/@prefix-$PID-XXXXXX".  The returned C string is either
 * auto-freed if @context is NULL.  This function returns NULL if an
 * error occurred.
 */
char *create_temp_name(void *context, const char *prefix)
{
    LOGE("create_temp_name ----")
    return "create_temp_name";
//	const char *temp_directory = get_temp_directory();
//	char *name;
//
//	if (context == NULL)
//		context = talloc_autofree_context();
//
//	name = talloc_asprintf(context, "%s/%s-%d-XXXXXX", temp_directory, prefix, getpid());
//	if (name == NULL) {
//		note(NULL, ERROR, INTERNAL, "can't allocate memory");
//		return NULL;
//	}
//
//	return name;
}

/**
 * Create a directory that will be automatically removed either on
 * PRoot termination if @context is NULL, or once its path name
 * (attached to @context) is freed.  This function returns NULL on
 * error, otherwise the absolute path name to the created directory
 * (@prefix-ed).
 */
const char *create_temp_directory(void *context, const char *prefix)
{
    LOGE("create_temp_directory");
    return "create_temp_directory";
//	char *name;
//
//	name = create_temp_name(context, prefix);
//	if (name == NULL)
//		return NULL;
//
//	name = mkdtemp(name);
//	if (name == NULL) {
//		note(NULL, ERROR, SYSTEM, "can't create temporary directory");
//		note(NULL, INFO, USER, "Please set PROOT_TMP_DIR env. variable "
//			"to an alternate location (with write permission).");
//		return NULL;
//	}
//
//	talloc_set_destructor(name, remove_temp_directory);
//
//	return name;
}

/**
 * Create a file that will be automatically removed either on PRoot
 * termination if @context is NULL, or once its path name (attached to
 * @context) is freed.  This function returns NULL on error,
 * otherwise the absolute path name to the created file (@prefix-ed).
 */
const char *create_temp_file(void *context, const char *prefix)
{
    LOGE("create_temp_file")
    return "create_temp_file";
//	char *name;
//	int fd;
//
//	name = create_temp_name(context, prefix);
//	if (name == NULL)
//		return NULL;
//
//	fd = mkstemp(name);
//	if (fd < 0) {
//		note(NULL, ERROR, SYSTEM, "can't create temporary file");
//		note(NULL, INFO, USER, "Please set PROOT_TMP_DIR env. variable "
//			"to an alternate location (with write permission).");
//		return NULL;
//	}
//	close(fd);
//
//	talloc_set_destructor(name, remove_temp_file);
//
//	return name;
}

/**
 * Like create_temp_file() but returns an open file stream to the
 * created file.  It's up to the caller to close returned stream.
 */
FILE* open_temp_file(void *context, const char *prefix)
{
    LOGE("open_temp_file")
    return NULL;
//	char *name;
//	FILE *file;
//	int fd;
//
//	name = create_temp_name(context, prefix);
//	if (name == NULL)
//		return NULL;
//
//	fd = mkstemp(name);
//	if (fd < 0)
//		goto error;
//
//	talloc_set_destructor(name, remove_temp_file);
//
//	file = fdopen(fd, "w");
//	if (file == NULL)
//		goto error;
//
//	return file;
//
//error:
//	if (fd >= 0)
//		close(fd);
//	note(NULL, ERROR, SYSTEM, "can't create temporary file");
//	note(NULL, INFO, USER, "Please set PROOT_TMP_DIR env. variable "
//		"to an alternate location (with write permission).");
//	return NULL;
}

```

`library/src/main/jni/path/temp.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef TEMP_H
#define TEMP_H

//#include <talloc.h>

extern char *create_temp_name(void *context, const char *prefix);
extern const char *create_temp_directory(void *context, const char *prefix);
extern const char *create_temp_file(void *context, const char *prefix);
extern FILE* open_temp_file(void *context, const char *prefix);
extern const char *get_temp_directory();

#endif /* TEMP_H */

```

`library/src/main/jni/ptrace/ptrace.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sys/ptrace.h> /* PTRACE_*,  */
#include <errno.h>      /* E*, */
#include <assert.h>     /* assert(3), */
#include <stdbool.h>    /* bool, true, false, */
#include <signal.h>     /* siginfo_t, */
#include <sys/uio.h>    /* struct iovec, */
#include <sys/param.h>  /* MIN(), MAX(), */
#include <string.h>     /* memcpy(3), */
#include <strings.h>
#include <stdlib.h>

#include "ptrace/ptrace.h"
#include "ptrace/user.h"
#include "tracee/tracee.h"
#include "syscall/sysnum.h"
#include "tracee/reg.h"
#include "tracee/mem.h"
#include "tracee/abi.h"
#include "tracee/event.h"
//#include "cli/note.h"
#include "arch.h"

#include "compat.h"
#include "constant.h"
#include "note.h"

#if defined(ARCH_X86_64) || defined(ARCH_X86)
#include <asm/ldt.h>    /* struct user_desc, */
#include <stdlib.h>

#endif

#if defined(ARCH_X86_64)
#include <asm/prctl.h>    /* ARCH_{G,S}ET_{F,G}S, */
#endif

#if defined(ARCH_ARM_EABI)
#define user_fpregs_struct user_fpregs
#endif

#if defined(ARCH_ARM64)
#define user_fpregs_struct user_fpsimd_struct
#endif

static const char *stringify_ptrace(PTRACE_REQUEST_TYPE request)
{
#define CASE_STR(a) case a: return #a; break;
	switch ((int) request) {
	CASE_STR(PTRACE_TRACEME)	CASE_STR(PTRACE_PEEKTEXT)	CASE_STR(PTRACE_PEEKDATA)
	CASE_STR(PTRACE_PEEKUSER)	CASE_STR(PTRACE_POKETEXT)	CASE_STR(PTRACE_POKEDATA)
	CASE_STR(PTRACE_POKEUSER)	CASE_STR(PTRACE_CONT)		CASE_STR(PTRACE_KILL)
	CASE_STR(PTRACE_SINGLESTEP)	CASE_STR(PTRACE_GETREGS)	CASE_STR(PTRACE_SETREGS)
	CASE_STR(PTRACE_GETFPREGS)	CASE_STR(PTRACE_SETFPREGS)	CASE_STR(PTRACE_ATTACH)
	CASE_STR(PTRACE_DETACH)		CASE_STR(PTRACE_GETFPXREGS)	CASE_STR(PTRACE_SETFPXREGS)
	CASE_STR(PTRACE_SYSCALL)	CASE_STR(PTRACE_SETOPTIONS)	CASE_STR(PTRACE_GETEVENTMSG)
	CASE_STR(PTRACE_GETSIGINFO)	CASE_STR(PTRACE_SETSIGINFO)	CASE_STR(PTRACE_GETREGSET)
	CASE_STR(PTRACE_SETREGSET)	CASE_STR(PTRACE_SEIZE)		CASE_STR(PTRACE_INTERRUPT)
	CASE_STR(PTRACE_LISTEN)		CASE_STR(PTRACE_SET_SYSCALL)
	CASE_STR(PTRACE_GET_THREAD_AREA)	CASE_STR(PTRACE_SET_THREAD_AREA)
	CASE_STR(PTRACE_GETVFPREGS)	CASE_STR(PTRACE_SINGLEBLOCK)	CASE_STR(PTRACE_ARCH_PRCTL)
	default: return "PTRACE_???"; }
}

/**
 * Translate the ptrace syscall made by @tracee into a "void" syscall
 * in order to emulate the ptrace mechanism within PRoot.  This
 * function returns -errno if an error occured (unsupported request),
 * otherwise 0.
 */
int translate_ptrace_enter(Tracee *tracee)
{
	/* The ptrace syscall have to be emulated since it can't be nested.  */
	set_sysnum(tracee, PR_void);
	return 0;
}

/**
 * Set @ptracee's tracer to @ptracer, and increment ptracees counter
 * of this later.
 */
void attach_to_ptracer(Tracee *ptracee, Tracee *ptracer)
{
	bzero(&(PTRACEE), sizeof(PTRACEE));
	PTRACEE.ptracer = ptracer;

	PTRACER.nb_ptracees++;
    LOGSYS("attach_to_ptracer -----------vpid: %lu,ptracer:%p",ptracee->vpid,PTRACEE.ptracer)
}

/**
 * Unset @ptracee's tracer, and decrement ptracees counter of this
 * later.
 */
void detach_from_ptracer(Tracee *ptracee)
{
	Tracee *ptracer = PTRACEE.ptracer;

	PTRACEE.ptracer = NULL;

	assert(PTRACER.nb_ptracees > 0);
	PTRACER.nb_ptracees--;
}

/**
 * Emulate the ptrace syscall made by @tracee.  This function returns
 * -errno if an error occured (unsupported request), otherwise 0.
 */
int translate_ptrace_exit(Tracee *tracee) //针对ptrace的处理(属于特殊处理、对抗了)
{
	word_t request, pid, address, data, result;
	Tracee *ptracee, *ptracer;
	int forced_signal = -1;
	int signal;
	int status;

	/* Read ptrace parameters.  */
	request = peek_reg(tracee, ORIGINAL, SYSARG_1);
	pid     = peek_reg(tracee, ORIGINAL, SYSARG_2);
	address = peek_reg(tracee, ORIGINAL, SYSARG_3);
	data    = peek_reg(tracee, ORIGINAL, SYSARG_4);

	/* Propagate signedness for this special value.  */
	if (is_32on64_mode(tracee) && pid == 0xFFFFFFFF)
		pid = (word_t) -1;
	LOGSYS("translate_ptrace_exit vpid %lu:ptrace request:%lu,%s",tracee->vpid,request, stringify_ptrace(request))
	/* The TRACEME request is the only one used by a tracee.  */
	if (request == PTRACE_TRACEME) {
		ptracer = tracee->parent;
		ptracee = tracee;

		/* The emulated ptrace in PRoot has the same
		 * limitation as the real ptrace in the Linux kernel:
		 * only one tracer per process.  */
		if (PTRACEE.ptracer != NULL || ptracee == ptracer)
			return -EPERM;

		attach_to_ptracer(ptracee, ptracer);

		/* Detect when the ptracer has gone to wait before the
		 * ptracee did the ptrace(ATTACHME) request.  */
		if (PTRACER.waits_in == WAITS_IN_KERNEL) {
			status = kill(ptracer->pid, SIGSTOP);
			if (status < 0)
//				note(tracee, WARNING, INTERNAL,
//					"can't wake ptracer %d", ptracer->pid);
				LOGSYS("can't wake ptracer %d", ptracer->pid)
			else {
				ptracer->sigstop = SIGSTOP_IGNORED;
				PTRACER.waits_in = WAITS_IN_PROOT;
			}
		}

		/* Disable seccomp acceleration for this tracee and
		 * all its children since we can't assume what are the
		 * syscalls its tracer is interested with.  */
		if (tracee->seccomp == ENABLED)
			tracee->seccomp = DISABLING;

		return 0;
	}

	/* The ATTACH, SEIZE, and INTERRUPT requests are the only ones
	 * where the ptracee is in an unknown state.  */
	if (request == PTRACE_ATTACH) {
		ptracer = tracee;
		ptracee = get_tracee(ptracer, pid, false);
		if (ptracee == NULL)
			return -ESRCH;

		/* The emulated ptrace in PRoot has the same
		 * limitation as the real ptrace in the Linux kernel:
		 * only one tracer per process.  */
		if (PTRACEE.ptracer != NULL || ptracee == ptracer)
			return -EPERM;

		attach_to_ptracer(ptracee, ptracer);

		/* The tracee is sent a SIGSTOP, but will not
		 * necessarily have stopped by the completion of this
		 * call.
		 *
		 * -- man 2 ptrace.  */
		kill(pid, SIGSTOP);

		return 0;
	}

	/* Here, the tracee is a ptracer.  Also, the requested ptracee
	 * has to be in the "stopped for ptracer" state.  */
	ptracer = tracee;
	ptracee = get_stopped_ptracee(ptracer, pid, false, __WALL);
	if (ptracee == NULL) {
		static bool warned = false;

		/* Ensure we didn't get there only because inheritance
		 * mechanism has missed this one.  */
		ptracee = get_tracee(tracee, pid, false);
		if (ptracee != NULL && !warned) {
			warned = true;
//			note(ptracer, WARNING, INTERNAL, "ptrace request to an unexpected ptracee");
			LOGSYSW("ptrace request to an unexpected ptracee")
		}

		return -ESRCH;
	}

	/* Sanity checks.  */
	if (   PTRACEE.is_zombie
	    || PTRACEE.ptracer != ptracer
	    || pid == (word_t) -1)
		return -ESRCH;

	switch (request) {
	case PTRACE_SYSCALL:
		PTRACEE.ignore_syscalls = false;
		forced_signal = (int) data;
		status = 0;
		break;  /* Restart the ptracee.  */

	case PTRACE_CONT:
		PTRACEE.ignore_syscalls = true;
		forced_signal = (int) data;
		status = 0;
		break;  /* Restart the ptracee.  */

	case PTRACE_SINGLESTEP:
		ptracee->restart_how = PTRACE_SINGLESTEP;
		forced_signal = (int) data;
		status = 0;
		break;  /* Restart the ptracee.  */

	case PTRACE_SINGLEBLOCK:
		ptracee->restart_how = PTRACE_SINGLEBLOCK;
		forced_signal = (int) data;
		status = 0;
		break;  /* Restart the ptracee.  */

	case PTRACE_DETACH:
		detach_from_ptracer(ptracee);
		status = 0;
		break;  /* Restart the ptracee.  */

	case PTRACE_KILL:
		status = ptrace(request, pid, NULL, NULL);
		break;  /* Restart the ptracee.  */

	case PTRACE_SETOPTIONS:
		if (data & PTRACE_O_TRACESECCOMP) {
			/* We don't really support forwarding seccomp traps */
//			note(ptracer, WARNING, INTERNAL,
//			     "ptrace option PTRACE_O_TRACESECCOMP "
//			     "not supported yet");
			LOGSYSW("ptrace option PTRACE_O_TRACESECCOMP "
					"not supported yet")
			return -EINVAL;
		}
		PTRACEE.options = data;
		return 0;  /* Don't restart the ptracee.  */

	case PTRACE_GETEVENTMSG: {
		status = ptrace(request, pid, NULL, &result);
        note(NULL,INFO,INTERNAL,"translate_ptrace_exit,PTRACE_GETEVENTMSG vpid %ld,"
                                "result:%lu,status:%d,%d,%s",tracee->vpid,result,
             status,errno, strerror(errno));
		if (status < 0)
			return -errno;

		poke_word(ptracer, data, result);
		if (errno != 0)
			return -errno;
        note(NULL,INFO,INTERNAL,"translate_ptrace_exit PTRACE_GETEVENTMSG success");
		return 0;  /* Don't restart the ptracee.  */
	}

	case PTRACE_PEEKUSER:
		if (is_32on64_mode(ptracer)) {
			address = convert_user_offset(address);
			if (address == (word_t) -1)
				return -EIO;
		}
		/* Fall through.  */
	case PTRACE_PEEKTEXT:
	case PTRACE_PEEKDATA:
		errno = 0;
		result = (word_t) ptrace(request, pid, address, NULL);
		if (errno != 0)
			return -errno;

		poke_word(ptracer, data, result);
		if (errno != 0)
			return -errno;

		return 0;  /* Don't restart the ptracee.  */

	case PTRACE_POKEUSER:
		if (is_32on64_mode(ptracer)) {
			address = convert_user_offset(address);
			if (address == (word_t) -1)
				return -EIO;
		}

		status = ptrace(request, pid, address, data);
		if (status < 0)
			return -errno;

		return 0;  /* Don't restart the ptracee.  */

	case PTRACE_POKETEXT:
	case PTRACE_POKEDATA:
		if (is_32on64_mode(ptracer)) {
			word_t tmp;

			errno = 0;
			tmp = (word_t) ptrace(PTRACE_PEEKDATA, ptracee->pid, address, NULL);
			if (errno != 0)
				return -errno;

			data |= (tmp & 0xFFFFFFFF00000000ULL);
		}

		status = ptrace(request, pid, address, data);
		if (status < 0)
			return -errno;

		return 0;  /* Don't restart the ptracee.  */

	case PTRACE_GETSIGINFO: {
		siginfo_t siginfo;

		status = ptrace(request, pid, NULL, &siginfo);
		if (status < 0)
			return -errno;

		status = write_data(ptracer, data, &siginfo, sizeof(siginfo));
		if (status < 0)
			return status;

		return 0;  /* Don't restart the ptracee.  */
	}

	case PTRACE_SETSIGINFO: {
		siginfo_t siginfo;

		status = read_data(ptracer, &siginfo, data, sizeof(siginfo));
		if (status < 0)
			return status;

		status = ptrace(request, pid, NULL, &siginfo);
		if (status < 0)
			return -errno;

		return 0;  /* Don't restart the ptracee.  */
	}

	case PTRACE_GETREGS: {
		size_t size;
		union {
			struct user_regs_struct regs;
			uint32_t regs32[USER32_NB_REGS];
		} buffer;

		status = ptrace(request, pid, NULL, &buffer);
		if (status < 0)
			return -errno;

		if (is_32on64_mode(tracee)) {
			struct user_regs_struct regs64;

			memcpy(&regs64, &buffer.regs, sizeof(struct user_regs_struct));
			convert_user_regs_struct(false,	(uint64_t *) &regs64, buffer.regs32);

			size = sizeof(buffer.regs32);
		}
		else
			size = sizeof(buffer.regs);

		status = write_data(ptracer, data, &buffer, size);
		if (status < 0)
			return status;

		return 0;  /* Don't restart the ptracee.  */
	}

	case PTRACE_SETREGS: {
		size_t size;
		union {
			struct user_regs_struct regs;
			uint32_t regs32[USER32_NB_REGS];
		} buffer;

		size = (is_32on64_mode(ptracer)
			? sizeof(buffer.regs32)
			: sizeof(buffer.regs));

		status = read_data(ptracer, &buffer, data, size);
		if (status < 0)
			return status;

		if (is_32on64_mode(ptracer)) {
			uint32_t regs32[USER32_NB_REGS];

			memcpy(regs32, buffer.regs32, sizeof(regs32));
			convert_user_regs_struct(true, (uint64_t *) &buffer.regs, regs32);
		}

		status = ptrace(request, pid, NULL, &buffer);
		if (status < 0)
			return -errno;

		return 0;  /* Don't restart the ptracee.  */
	}

	case PTRACE_GETFPREGS: {
		size_t size;
		union {
			struct user_fpregs_struct fpregs;
			uint32_t fpregs32[USER32_NB_FPREGS];
		} buffer;

		status = ptrace(request, pid, NULL, &buffer);
		if (status < 0)
			return -errno;

		if (is_32on64_mode(tracee)) {
#if 0 /* TODO */
			struct user_fpregs_struct fpregs64;

			memcpy(&fpregs64, &buffer.fpregs, sizeof(struct user_fpregs_struct));
			convert_user_fpregs_struct(false, (uint64_t *) &fpregs64, buffer.fpregs32);
#else
			static bool warned = false;
			if (!warned)
//				note(ptracer, WARNING, INTERNAL,
//					"ptrace 32-bit request '%s' not supported on 64-bit yet",
//					stringify_ptrace(request));
			LOGSYSW("ptrace 32-bit request '%s' not supported on 64-bit yet",
					stringify_ptrace(request))
			warned = true;
			bzero(&buffer, sizeof(buffer));
#endif
			size = sizeof(buffer.fpregs32);
		}
		else
			size = sizeof(buffer.fpregs);

		status = write_data(ptracer, data, &buffer, size);
		if (status < 0)
			return status;

		return 0;  /* Don't restart the ptracee.  */
	}

	case PTRACE_SETFPREGS: {
		size_t size;
		union {
			struct user_fpregs_struct fpregs;
			uint32_t fpregs32[USER32_NB_FPREGS];
		} buffer;

		size = (is_32on64_mode(ptracer)
			? sizeof(buffer.fpregs32)
			: sizeof(buffer.fpregs));

		status = read_data(ptracer, &buffer, data, size);
		if (status < 0)
			return status;

		if (is_32on64_mode(ptracer)) {
#if 0 /* TODO */
			uint32_t fpregs32[USER32_NB_FPREGS];

			memcpy(fpregs32, buffer.fpregs32, sizeof(fpregs32));
			convert_user_fpregs_struct(true, (uint64_t *) &buffer.fpregs, fpregs32);
#else
			static bool warned = false;
			if (!warned)
//				note(ptracer, WARNING, INTERNAL,
//					"ptrace 32-bit request '%s' not supported on 64-bit yet",
//					stringify_ptrace(request));
			LOGSYSW("ptrace 32-bit request '%s' not supported on 64-bit yet",
					stringify_ptrace(request))
			warned = true;
			return -ENOTSUP;
#endif
		}

		status = ptrace(request, pid, NULL, &buffer);
		if (status < 0)
			return -errno;

		return 0;  /* Don't restart the ptracee.  */
	}

#if defined(ARCH_X86_64) || defined(ARCH_X86)
	case PTRACE_GET_THREAD_AREA: {
		struct user_desc user_desc;

		status = ptrace(request, pid, address, &user_desc);
		if (status < 0)
			return -errno;

		status = write_data(ptracer, data, &user_desc, sizeof(user_desc));
		if (status < 0)
			return status;

		return 0;  /* Don't restart the ptracee.  */
	}

	case PTRACE_SET_THREAD_AREA: {
		struct user_desc user_desc;

		status = read_data(ptracer, &user_desc, data, sizeof(user_desc));
		if (status < 0)
			return status;

		status = ptrace(request, pid, address, &user_desc);
		if (status < 0)
			return -errno;

		return 0;  /* Don't restart the ptracee.  */
	}
#endif

	case PTRACE_GETREGSET: {
		struct iovec local_iovec;
		word_t remote_iovec_base;
		word_t remote_iovec_len;
        note(NULL, INFO, INTERNAL, "translate_ptrace_exit start PTRACE_GETREGSET");
		remote_iovec_base = peek_word(ptracer, data);
		if (errno != 0)
			return -errno;

		remote_iovec_len = peek_word(ptracer, data + sizeof_word(ptracer));
		if (errno != 0)
			return -errno;

		/* Sanity check.  */
		assert(sizeof(local_iovec.iov_len) == sizeof(word_t));

		local_iovec.iov_len  = remote_iovec_len;
//		local_iovec.iov_base = talloc_zero_size(ptracer->ctx, remote_iovec_len);
		local_iovec.iov_base = calloc(1,remote_iovec_len);
		if (local_iovec.iov_base == NULL)
			return -ENOMEM;

		status = ptrace(PTRACE_GETREGSET, pid, address, &local_iovec);
		if (status < 0)
			return status;

		remote_iovec_len = local_iovec.iov_len =
			MIN(remote_iovec_len, local_iovec.iov_len);

		/* Update remote vector content.  */
		status = writev_data(ptracer, remote_iovec_base, &local_iovec, 1);
		if (status < 0)
			return status;

		/* Update remote vector length.  */
		poke_word(ptracer, data + sizeof_word(ptracer), remote_iovec_len);
		if (errno != 0)
			return -errno;
#if defined(ARCH_ARM64)
        //only arm64
        struct user_regs_struct* local_regs = local_iovec.iov_base;
        note(NULL, INFO, INTERNAL, "translate_ptrace_exit end PTRACE_GETREGSET,r0:%lu,r8:%lu",local_regs->regs[0],local_regs->regs[8]);
#endif
		return 0;  /* Don't restart the ptracee.  */
	}

	case PTRACE_SETREGSET: {
		struct iovec local_iovec;
		word_t remote_iovec_base;
		word_t remote_iovec_len;

		remote_iovec_base = peek_word(ptracer, data);
		if (errno != 0)
			return -errno;

		remote_iovec_len = peek_word(ptracer, data + sizeof_word(ptracer));
		if (errno != 0)
			return -errno;

		/* Sanity check.  */
		assert(sizeof(local_iovec.iov_len) == sizeof(word_t));

		local_iovec.iov_len  = remote_iovec_len;
//		local_iovec.iov_base = talloc_zero_size(ptracer->ctx, remote_iovec_len);
		local_iovec.iov_base = calloc( 1,remote_iovec_len);
		if (local_iovec.iov_base == NULL)
			return -ENOMEM;

		/* Copy remote content into the local vector.  */
		status = read_data(ptracer, local_iovec.iov_base,
				remote_iovec_base, local_iovec.iov_len);
		if (status < 0)
			return status;

		status = ptrace(PTRACE_SETREGSET, pid, address, &local_iovec);
		if (status < 0)
			return status;

		return 0;  /* Don't restart the ptracee.  */
	}

	case PTRACE_GETVFPREGS:
	case PTRACE_GETFPXREGS: {
		static bool warned = false;
		if (!warned)
//			note(ptracer, WARNING, INTERNAL, "ptrace request '%s' not supported yet",
//				stringify_ptrace(request));
		LOGSYSW("ptrace request '%s' not supported yet",
				 stringify_ptrace(request))
		warned = true;
		return -ENOTSUP;
	}

#if defined(ARCH_X86_64)
	case PTRACE_ARCH_PRCTL:
		switch (data) {
		case ARCH_GET_GS:
		case ARCH_GET_FS:
			status = ptrace(request, pid, &result, data);
			if (status < 0)
				return -errno;

			poke_word(ptracer, address, result);
			if (errno != 0)
				return -errno;
			break;

		case ARCH_SET_GS:
		case ARCH_SET_FS: {
			static bool warned = false;
			if (!warned)
				note(ptracer, WARNING, INTERNAL,
					"ptrace request '%s' ARCH_SET_{G,F}S not supported yet",
					stringify_ptrace(request));
			return -ENOTSUP;
		}

		default:
			return -ENOTSUP;
		}

		return 0;  /* Don't restart the ptracee.  */
#endif

	case PTRACE_SET_SYSCALL:
		status = ptrace(request, pid, address, data);
		if (status < 0)
			return -errno;

		return 0;  /* Don't restart the ptracee.  */

	default:
//		note(ptracer, WARNING, INTERNAL, "ptrace request '%s' not supported yet",
//			stringify_ptrace(request));
		LOGSYSW("ptrace request '%s' not supported yet",
				stringify_ptrace(request))
		return -ENOTSUP;
	}

	/* Now, the initial tracee's event can be handled.  */
	signal = PTRACEE.event4.proot.pending
		? handle_tracee_event(ptracee, PTRACEE.event4.proot.value)
		: PTRACEE.event4.proot.value;

	/* The restarting signal from the ptracer overrides the
	 * restarting signal from PRoot.  */
	if (forced_signal != -1)
		signal = forced_signal;
    note(NULL,INFO,INTERNAL,"translate_ptrace_exit,vpid %ld,before "
                            "restart_tracee,restart_how:%d,signal:%d",tracee->vpid,
         tracee->restart_how,signal);
	(void) restart_tracee(ptracee, signal);

	return status;
}

```

`library/src/main/jni/ptrace/ptrace.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef PTRACE_H
#define PTRACE_H

#include "tracee/tracee.h"

extern int translate_ptrace_enter(Tracee *tracee);
extern int translate_ptrace_exit(Tracee *tracee);
extern void attach_to_ptracer(Tracee *ptracee, Tracee *ptracer);
extern void detach_from_ptracer(Tracee *ptracee);

#define PTRACEE (ptracee->as_ptracee)
#define PTRACER (ptracer->as_ptracer)

#endif /* PTRACE_H */

```

`library/src/main/jni/ptrace/user.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <stdint.h>
#include <stdbool.h>
#include <assert.h>
#include <sys/types.h>
#include <sys/user.h>
#include <stddef.h>

#include "ptrace/user.h"
#include "cli/note.h"

#if defined(ARCH_X86_64)

/**
 * Return the index in the "regs" field of a 64-bit "user" area that
 * corresponds to the specified @index in the "regs" field of a 32-bit
 * "user" area.
 */
static inline size_t convert_user_regs_index(size_t index)
{
	static size_t mapping[USER32_NB_REGS] = {
		05, /* ?bx */	11, /* ?cx */	12, /* ?dx */
		13, /* ?si */	14, /* ?di */	04, /* ?bp */
		10, /* ?ax */	23, /* ds */	24, /* es */
		25, /* fs */	26, /* gs */	15, /* orig_?ax */
		16, /* ?ip */	17, /* cs */	18, /* eflags */
		19, /* ?sp */	20, /* ss */ };

	/* Sanity check.  */
	assert(index < USER32_NB_REGS);

	return mapping[index];
}

/* Layout of a 32-bit "user" area.  */
#define USER32_REGS_OFFSET	0
#define USER32_REGS_SIZE	(USER32_NB_REGS * sizeof(uint32_t))
#define USER32_FPVALID_OFFSET	(USER32_REGS_OFFSET	+ USER32_REGS_SIZE)
#define USER32_I387_OFFSET	(USER32_FPVALID_OFFSET	+ sizeof(uint32_t))
#define USER32_I387_SIZE	(USER32_NB_FPREGS * sizeof(uint32_t))
#define USER32_TSIZE_OFFSET	(USER32_I387_OFFSET	+ USER32_I387_SIZE)
#define USER32_DSIZE_OFFSET	(USER32_TSIZE_OFFSET	+ sizeof(uint32_t))
#define USER32_SSIZE_OFFSET	(USER32_DSIZE_OFFSET	+ sizeof(uint32_t))
#define USER32_START_CODE_OFFSET  (USER32_SSIZE_OFFSET	+ sizeof(uint32_t))
#define USER32_START_STACK_OFFSET (USER32_START_CODE_OFFSET	+ sizeof(uint32_t))
#define USER32_SIGNAL_OFFSET	(USER32_START_STACK_OFFSET	+ sizeof(uint32_t))
#define USER32_RESERVED_OFFSET	(USER32_SIGNAL_OFFSET	+ sizeof(uint32_t))
#define USER32_AR0_OFFSET	(USER32_RESERVED_OFFSET	+ sizeof(uint32_t))
#define USER32_FPSTATE_OFFSET	(USER32_AR0_OFFSET	+ sizeof(uint32_t))
#define USER32_MAGIC_OFFSET	(USER32_FPSTATE_OFFSET	+ sizeof(uint32_t))
#define USER32_COMM_OFFSET	(USER32_MAGIC_OFFSET	+ sizeof(uint32_t))
#define USER32_COMM_SIZE	(32 * sizeof(uint8_t))
#define USER32_DEBUGREG_OFFSET	(USER32_COMM_OFFSET	+ USER32_COMM_SIZE)
#define USER32_DEBUGREG_SIZE	(8 * sizeof(uint32_t))

/**
 * Return the offset in the "debugreg" field of a 64-bit "user" area
 * that corresponds to the specified @offset in the "debugreg" field
 * of a 32-bit "user" area.
 */
static inline size_t convert_user_debugreg_offset(size_t offset)
{
	size_t index;

	/* Sanity check.  */
	assert(offset >= USER32_DEBUGREG_OFFSET
	    && offset < USER32_DEBUGREG_OFFSET + USER32_DEBUGREG_SIZE);

	index = (offset - USER32_DEBUGREG_OFFSET) / sizeof(uint32_t);
	return offsetof(struct user, u_debugreg) + index * sizeof(uint64_t);
}

/**
 * Return the offset in a 64-bit "user" area that corresponds to the
 * specified @offset in a 32-bit "user" area.  This function returns
 * "(word_t) -1" if the specified @offset is invalid.
 */
word_t convert_user_offset(word_t offset)
{
	const char *area_name = NULL;

	if (/* offset >= 0 && */ offset < USER32_REGS_OFFSET + USER32_REGS_SIZE) {
		/* Sanity checks.  */
		if ((offset % sizeof(uint32_t)) != 0)
			return (word_t) -1;

		return convert_user_regs_index(offset / sizeof(uint32_t)) * sizeof(uint64_t);
	}
	else if (offset == USER32_FPVALID_OFFSET)
		area_name = "fpvalid"; /* Not yet supported.  */
	else if (offset >= USER32_I387_OFFSET && offset < USER32_I387_OFFSET + USER32_I387_SIZE)
		area_name = "i387"; /* Not yet supported.  */
	else if (offset == USER32_TSIZE_OFFSET)
		area_name = "tsize"; /* Not yet supported.  */
	else if (offset == USER32_DSIZE_OFFSET)
		area_name = "dsize"; /* Not yet supported.  */
	else if (offset == USER32_SSIZE_OFFSET)
		area_name = "ssize"; /* Not yet supported.  */
	else if (offset == USER32_START_CODE_OFFSET)
		area_name = "start_code"; /* Not yet supported.  */
	else if (offset == USER32_START_STACK_OFFSET)
		area_name = "start_stack"; /* Not yet supported.  */
	else if (offset == USER32_SIGNAL_OFFSET)
		area_name = "signal"; /* Not yet supported.  */
	else if (offset == USER32_RESERVED_OFFSET)
		area_name = "reserved"; /* Not yet supported.  */
	else if (offset == USER32_AR0_OFFSET)
		area_name = "ar0"; /* Not yet supported.  */
	else if (offset == USER32_FPSTATE_OFFSET)
		area_name = "fpstate"; /* Not yet supported.  */
	else if (offset == USER32_MAGIC_OFFSET)
		area_name = "magic"; /* Not yet supported.  */
	else if (offset >= USER32_COMM_OFFSET && offset < USER32_COMM_OFFSET + USER32_COMM_SIZE)
		area_name = "comm"; /* Not yet supported.  */
	else if (offset >= USER32_DEBUGREG_OFFSET && offset < USER32_DEBUGREG_OFFSET + USER32_DEBUGREG_SIZE)
		return convert_user_debugreg_offset(offset);
	else
		area_name = "<unknown>";

	note(NULL, WARNING, INTERNAL, "ptrace user area '%s' not supported yet", area_name);
	return (word_t) -1;  /* Unknown offset.  */
}

/**
 * Convert the "regs" field from a 64-bit "user" area into a "regs"
 * field from a 32-bit "user" area, or vice versa according to
 * @reverse.
 */
void convert_user_regs_struct(bool reverse, uint64_t *user_regs64,
			uint32_t user_regs32[USER32_NB_REGS])
{
	size_t index32;

	for (index32 = 0; index32 < USER32_NB_REGS; index32++) {
		size_t index64 = convert_user_regs_index(index32);
		assert(index64 != (size_t) -1);

		if (reverse)
			user_regs64[index64] = (uint64_t) user_regs32[index32];
		else
			user_regs32[index32] = (uint32_t) user_regs64[index64];
	}
}

#endif /* ARCH_X86_64 */

```

`library/src/main/jni/ptrace/user.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <stdint.h>
#include <stdbool.h>
#include <assert.h>

#include "arch.h"
#include "attribute.h"

#if defined(ARCH_X86_64)

#define USER32_NB_REGS   17
#define USER32_NB_FPREGS 27

extern word_t convert_user_offset(word_t offset);
extern void convert_user_regs_struct(bool reverse, uint64_t *user_regs64,
				uint32_t user_regs32[USER32_NB_REGS]);

#else

#define USER32_NB_REGS   0
#define USER32_NB_FPREGS 0

static inline word_t convert_user_offset(word_t offset UNUSED)
{
	assert(0);
}

static inline void convert_user_regs_struct(bool reverse UNUSED,
					uint64_t *user_regs64 UNUSED,
					uint32_t user_regs32[USER32_NB_REGS] UNUSED)
{
	assert(0);
}

#endif

```

`library/src/main/jni/ptrace/wait.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sys/ptrace.h> /* PTRACE_*,  */
#include <errno.h>      /* E*, */
#include <assert.h>     /* assert(3), */
#include <stdbool.h>    /* bool, true, false, */
#include <signal.h>     /* SIG*, */
#include <stdlib.h>
//#include <talloc.h>     /* talloc*, */

#include "ptrace/wait.h"
#include "ptrace/ptrace.h"
#include "syscall/sysnum.h"
#include "syscall/chain.h"
#include "tracee/tracee.h"
#include "tracee/event.h"
#include "tracee/reg.h"
#include "tracee/mem.h"

#include "attribute.h"

static const char *stringify_event(int event) UNUSED;
static const char *stringify_event(int event)
{
	if (WIFEXITED(event))
		return "exited";
	else if (WIFSIGNALED(event))
		return "signaled";
	else if (WIFCONTINUED(event))
		return "continued";
	else if (WIFSTOPPED(event)) {
		switch ((event & 0xfff00) >> 8) {
		case SIGTRAP:
			return "stopped: SIGTRAP";
		case SIGTRAP | 0x80:
			return "stopped: SIGTRAP: 0x80";
		case SIGTRAP | PTRACE_EVENT_VFORK << 8:
			return "stopped: SIGTRAP: PTRACE_EVENT_VFORK";
		case SIGTRAP | PTRACE_EVENT_FORK  << 8:
			return "stopped: SIGTRAP: PTRACE_EVENT_FORK";
		case SIGTRAP | PTRACE_EVENT_VFORK_DONE  << 8:
			return "stopped: SIGTRAP: PTRACE_EVENT_VFORK_DONE";
		case SIGTRAP | PTRACE_EVENT_CLONE << 8:
			return "stopped: SIGTRAP: PTRACE_EVENT_CLONE";
		case SIGTRAP | PTRACE_EVENT_EXEC  << 8:
			return "stopped: SIGTRAP: PTRACE_EVENT_EXEC";
		case SIGTRAP | PTRACE_EVENT_EXIT  << 8:
			return "stopped: SIGTRAP: PTRACE_EVENT_EXIT";
		case SIGTRAP | PTRACE_EVENT_SECCOMP2 << 8:
			return "stopped: SIGTRAP: PTRACE_EVENT_SECCOMP2";
		case SIGTRAP | PTRACE_EVENT_SECCOMP << 8:
			return "stopped: SIGTRAP: PTRACE_EVENT_SECCOMP";
		case SIGSTOP:
			return "stopped: SIGSTOP";
		default:
			return "stopped: unknown";
		}
	}
	return "unknown";
}

/**
 * Translate the wait syscall made by @ptracer into a "void" syscall
 * if the expected pid is one of its ptracees, in order to emulate the
 * ptrace mechanism within PRoot.  This function returns -errno if an
 * error occured (unsupported request), otherwise 0.
 */
int translate_wait_enter(Tracee *ptracer)
{
	Tracee *ptracee;
	pid_t pid;

	PTRACER.waits_in = WAITS_IN_KERNEL;

	/* Don't emulate the ptrace mechanism if it's not a ptracer.  */
	if (PTRACER.nb_ptracees == 0)
		return 0;

	/* Don't emulate the ptrace mechanism if the requested pid is
	 * not a ptracee.  */
	pid = (pid_t) peek_reg(ptracer, ORIGINAL, SYSARG_1);
	if (pid != -1) {
		ptracee = get_ptracee(ptracer, pid, false, true,
				      peek_reg(ptracer, ORIGINAL, SYSARG_3));
		if (ptracee == NULL || PTRACEE.ptracer != ptracer)
			return 0;
	}

	/* This syscall is canceled at the enter stage in order to be
	 * handled at the exit stage.  */
	set_sysnum(ptracer, PR_void);
	PTRACER.waits_in = WAITS_IN_PROOT;

	return 0;
}

/**
 * Update pid & wait status of @ptracer's wait(2) for the given
 * @ptracee.  This function returns -errno if an error occurred, 0 if
 * the wait syscall will be restarted (ie. the event is discarded),
 * otherwise @ptracee's pid.
 */
static int update_wait_status(Tracee *ptracer, Tracee *ptracee)
{
	word_t address;
	int result;

	/* Special case: the Linux kernel reports the terminating
	 * event issued by a process to both its parent and its
	 * tracer, except when they are the same.  In this case the
	 * Linux kernel reports the terminating event only once to the
	 * tracing parent ...  */
	if (PTRACEE.ptracer == ptracee->parent
	    && (WIFEXITED(PTRACEE.event4.ptracer.value)
	     || WIFSIGNALED(PTRACEE.event4.ptracer.value))) {
		/* ... So hide this terminating event (toward its
		 * tracer, ie. PRoot) and make the second one appear
		 * (towards its parent, ie. the ptracer).  This will
		 * ensure its exit status is collected from a kernel
		 * point-of-view (ie. it doesn't stay a zombie
		 * forever).  */
		restart_original_syscall(ptracer);

		/* Detach this ptracee from its ptracer, PRoot doesn't
		 * have anything else to emulate.  */
		detach_from_ptracer(ptracee);

		/* Zombies can rest in peace once the ptracer is
		 * notified.  */
		if (PTRACEE.is_zombie){
//			TALLOC_FREE(ptracee);
			before_tracee_free(ptracee);
			free(ptracee); //TODO 其组合指向的内存也要free
		}


		return 0;
	}

	address = peek_reg(ptracer, ORIGINAL, SYSARG_2);
	if (address != 0) {
		poke_int32(ptracer, address, PTRACEE.event4.ptracer.value);
		if (errno != 0)
			return -errno;
	}

	PTRACEE.event4.ptracer.pending = false;

	/* Be careful; ptracee might get freed before its pid is
	 * returned.  */
	result = ptracee->pid;

	/* Zombies can rest in peace once the ptracer is notified.  */
	if (PTRACEE.is_zombie) {
		detach_from_ptracer(ptracee);
//		TALLOC_FREE(ptracee);
		before_tracee_free(ptracee);
		free(ptracee);
	}

	return result;
}

/**
 * Emulate the wait* syscall made by @ptracer if it was in the context
 * of the ptrace mechanism. This function returns -errno if an error
 * occured, otherwise the pid of the expected tracee.
 */
int translate_wait_exit(Tracee *ptracer, bool *set_result)
{
	Tracee *ptracee;
	word_t options;
	int status;
	pid_t pid;

	*set_result = true;
	assert(PTRACER.waits_in == WAITS_IN_PROOT);
	PTRACER.waits_in = DOESNT_WAIT;

	pid = (pid_t) peek_reg(ptracer, ORIGINAL, SYSARG_1);
	options = peek_reg(ptracer, ORIGINAL, SYSARG_3);

	/* Is there such a stopped ptracee with an event not yet
	 * passed to its ptracer?  */
	ptracee = get_stopped_ptracee(ptracer, pid, true, options);
	if (ptracee == NULL) {
		/* Is there still living ptracees?  */
		if (PTRACER.nb_ptracees == 0)
			return -ECHILD;

		/* Non blocking wait(2) ?  */
		if ((options & WNOHANG) != 0) {
			/* if WNOHANG was specified and one or more
			 * child(ren) specified by pid exist, but have
			 * not yet changed state, then 0 is returned.
			 * On error, -1 is returned.
			 *
			 * -- man 2 waitpid  */
			return (has_ptracees(ptracer, pid, options) ? 0 : -ECHILD);
		}

		/* Otherwise put this ptracer in the "waiting for
		 * ptracee" state, it will be woken up in
		 * handle_ptracee_event() later.  */
		PTRACER.wait_pid = pid;
		PTRACER.wait_options = options;

		return 0;
	}

	status = update_wait_status(ptracer, ptracee);
	// If the syscall is restarted, don't touch the result.
	// Not only is it unnecessary, it could overwrite syscall argument on ARM.
	if (status == 0)
		*set_result = false;
	return status;
}

/**
 * For the given @ptracee, pass its current @event to its ptracer if
 * this latter is waiting for it, otherwise put the @ptracee in the
 * "waiting for ptracer" state.  This function returns whether
 * @ptracee shall be kept in the stop state or not.
 */
bool handle_ptracee_event(Tracee *ptracee, int event)
{
	bool handled_by_proot_first = false;
	Tracee *ptracer = PTRACEE.ptracer;
	bool keep_stopped;

	assert(ptracer != NULL);

	/* Remember what the event initially was, this will be
	 * required by PRoot to handle this event later.  */
	PTRACEE.event4.proot.value   = event;
	PTRACEE.event4.proot.pending = true;

	/* By default, this ptracee should be kept stopped until its
	 * ptracer restarts it.  */
	keep_stopped = true;

	/* Not all events are expected for this ptracee.  */
	if (WIFSTOPPED(event)) {
		switch ((event & 0xfff00) >> 8) {
		case SIGTRAP | 0x80:
			if (PTRACEE.ignore_syscalls || PTRACEE.ignore_loader_syscalls)
				return false;

			if ((PTRACEE.options & PTRACE_O_TRACESYSGOOD) == 0)
				event &= ~(0x80 << 8);

			handled_by_proot_first = IS_IN_SYSEXIT(ptracee);
			break;

#define PTRACE_EVENT_VFORKDONE PTRACE_EVENT_VFORK_DONE
#define CASE_FILTER_EVENT(name) \
		case SIGTRAP | PTRACE_EVENT_ ##name << 8:			\
			if ((PTRACEE.options & PTRACE_O_TRACE ##name) == 0)	\
				return false;					\
			PTRACEE.tracing_started = true;				\
			handled_by_proot_first = true;				\
			break;

		CASE_FILTER_EVENT(FORK);
		CASE_FILTER_EVENT(VFORK);
		CASE_FILTER_EVENT(VFORKDONE);
		CASE_FILTER_EVENT(CLONE);
		CASE_FILTER_EVENT(EXIT);
		CASE_FILTER_EVENT(EXEC);

			/* Never reached.  */
			assert(0);

		case SIGTRAP | PTRACE_EVENT_SECCOMP2 << 8:
		case SIGTRAP | PTRACE_EVENT_SECCOMP << 8:
			/* These events are not supported [yet?] under
			 * ptrace emulation.  */
			return false;

		default:
			PTRACEE.tracing_started = true;
			break;
		}
	}
	/* In these cases, the ptracee isn't really alive anymore.  To
	 * ensure it will not be in limbo, PRoot restarts it whether
	 * its ptracer is waiting for it or not.  */
	else if (WIFEXITED(event) || WIFSIGNALED(event)) {
		PTRACEE.tracing_started = true;
		keep_stopped = false;
	}

	/* A process is not traced right from the TRACEME request; it
	 * is traced from the first received signal, whether it was
	 * raised by the process itself (implicitly or explicitly), or
	 * it was induced by a PTRACE_EVENT_*.  */
	if (!PTRACEE.tracing_started)
		return false;

	/* Under some circumstances, the event must be handled by
	 * PRoot first.  */
	if (handled_by_proot_first) {
		int signal;
		signal = handle_tracee_event(ptracee, PTRACEE.event4.proot.value);
		PTRACEE.event4.proot.value = signal;

		/* The computed signal is always 0 since we can come
		 * in this block only on sysexit and special events
		 * (as for now).  */
		assert(signal == 0);
	}

	/* Remember what the new event is, this will be required by
	   the ptracer in translate_ptrace_exit() in order to restart
	   this ptracee.  */
	PTRACEE.event4.ptracer.value   = event;
	PTRACEE.event4.ptracer.pending = true;

	/* Notify asynchronously the ptracer about this event, as the
	 * kernel does.  */
	kill(ptracer->pid, SIGCHLD);

	/* Note: wait_pid is set in translate_wait_exit() if no
	 * ptracee event was pending when the ptracer started to
	 * wait.  */
	if (   (PTRACER.wait_pid == -1 || PTRACER.wait_pid == ptracee->pid)
	    && EXPECTED_WAIT_CLONE(PTRACER.wait_options, ptracee)) {
		bool restarted;
		int status;

		status = update_wait_status(ptracer, ptracee);
		if (status != 0)
			poke_reg(ptracer, SYSARG_RESULT, (word_t) status);

		/* Write ptracer's register cache back.  */
		(void) push_regs(ptracer);

		/* Restart the ptracer.  */
		PTRACER.wait_pid = 0;
		restarted = restart_tracee(ptracer, 0);
		if (!restarted)
			keep_stopped = false;

		return keep_stopped;
	}

	return keep_stopped;
}

```

`library/src/main/jni/ptrace/wait.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef PTRACE_WAIT_H
#define PTRACE_WAIT_H

#include "tracee/tracee.h"

extern int translate_wait_enter(Tracee *ptracer);
extern int translate_wait_exit(Tracee *ptracer, bool *set_result);
extern bool handle_ptracee_event(Tracee *ptracee, int wait_status);

/* __WCLONE: Wait for "clone" children only.  If omitted then wait for
 * "non-clone" children only.  (A "clone" child is one which delivers
 * no signal, or a signal other than SIGCHLD to its parent upon
 * termination.)  This option is ignored if __WALL is also specified.
 *
 * __WALL: Wait for all children, regardless of type ("clone" or
 * "non-clone").
 *
 * -- wait(2) man-page
 */
#define EXPECTED_WAIT_CLONE(wait_options, tracee)		\
	((((wait_options) & __WALL) != 0)			\
      || ((((wait_options) & __WCLONE) != 0) && (tracee)->clone) \
      || ((((wait_options) & __WCLONE) == 0) && !(tracee)->clone))

#endif /* PTRACE_WAIT_H */

```

`library/src/main/jni/syscall/chain.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

//#include <talloc.h>     /* talloc*, */
#include <sys/queue.h>  /* STAILQ_*, */
#include <errno.h>      /* E*, */
#include <assert.h>     /* assert(3), */
#include <stdlib.h>

#include "syscall/chain.h"
#include "syscall/sysnum.h"
#include "tracee/tracee.h"
#include "tracee/reg.h"
#include "arch.h"

struct chained_syscall {
	Sysnum sysnum;
	word_t sysargs[6];
	STAILQ_ENTRY(chained_syscall) link;
};

STAILQ_HEAD(chained_syscalls, chained_syscall);

/**
 * Append a new syscall (@sysnum, @sysarg_*) to the list of
 * "unrequested" syscalls for the given @tracee.  These new syscalls
 * will be triggered in order once the current syscall is done.  The
 * caller is free to force the last result of this syscall chain in
 * @tracee->chain.final_result.  This function returns -errno if an
 * error occurred, otherwise 0.
 */
int register_chained_syscall(Tracee *tracee, Sysnum sysnum,
			word_t sysarg_1, word_t sysarg_2, word_t sysarg_3,
			word_t sysarg_4, word_t sysarg_5, word_t sysarg_6)
{
	struct chained_syscall *syscall;

	if (tracee->chain.syscalls == NULL) {
//		tracee->chain.syscalls = talloc_zero(tracee, struct chained_syscalls);
		tracee->chain.syscalls = calloc(1, sizeof(struct chained_syscalls));
		if (tracee->chain.syscalls == NULL)
			return -ENOMEM;

		STAILQ_INIT(tracee->chain.syscalls);
	}

//	syscall = talloc_zero(tracee->chain.syscalls, struct chained_syscall);
	syscall = calloc(1, sizeof(struct chained_syscalls));
	if (syscall == NULL)
		return -ENOMEM;

	syscall->sysnum     = sysnum;
	syscall->sysargs[0] = sysarg_1;
	syscall->sysargs[1] = sysarg_2;
	syscall->sysargs[2] = sysarg_3;
	syscall->sysargs[3] = sysarg_4;
	syscall->sysargs[4] = sysarg_5;
	syscall->sysargs[5] = sysarg_6;

	STAILQ_INSERT_TAIL(tracee->chain.syscalls, syscall, link);

	return 0;
}

/**
 * Use/remove the first element of @tracee->chain.syscalls to forge a
 * new syscall.  This function should be called only at the end of in
 * the sysexit stage.
 */
void chain_next_syscall(Tracee *tracee)
{
	struct chained_syscall *syscall;
	word_t instr_pointer;
	word_t sysnum;

	assert(tracee->chain.syscalls != NULL);

	/* No more chained syscalls: force the result of the initial
	 * syscall (the one explicitly requested by the tracee).  */
	if (STAILQ_EMPTY(tracee->chain.syscalls)) {
//		TALLOC_FREE(tracee->chain.syscalls);
		free(tracee->chain.syscalls);

		if (tracee->chain.force_final_result)
			poke_reg(tracee, SYSARG_RESULT, tracee->chain.final_result);

		tracee->chain.force_final_result = false;
		tracee->chain.final_result = 0;

		return;
	}

	/* Original register values will be restored right after the
	 * last chained syscall.  */
	tracee->restore_original_regs = false;

	/* The list of chained syscalls is a FIFO.  */
	syscall = STAILQ_FIRST(tracee->chain.syscalls);
	STAILQ_REMOVE_HEAD(tracee->chain.syscalls, link);

	poke_reg(tracee, SYSARG_1, syscall->sysargs[0]);
	poke_reg(tracee, SYSARG_2, syscall->sysargs[1]);
	poke_reg(tracee, SYSARG_3, syscall->sysargs[2]);
	poke_reg(tracee, SYSARG_4, syscall->sysargs[3]);
	poke_reg(tracee, SYSARG_5, syscall->sysargs[4]);
	poke_reg(tracee, SYSARG_6, syscall->sysargs[5]);

	sysnum = detranslate_sysnum(get_abi(tracee), syscall->sysnum);
	poke_reg(tracee, SYSTRAP_NUM, sysnum);

	/* Move the instruction pointer back to the original trap.  */
	instr_pointer = peek_reg(tracee, CURRENT, INSTR_POINTER);
	poke_reg(tracee, INSTR_POINTER, instr_pointer - SYSTRAP_SIZE);
}

/**
 * Force the last result of the @tracee's current syscall chain to be
 * @forced_result.
 */
void force_chain_final_result(Tracee *tracee, word_t forced_result)
{
	tracee->chain.force_final_result = true;
	tracee->chain.final_result = forced_result;
}

/**
 * Restart the original syscall of the given @tracee.  The result of
 * the current syscall will be overwritten.  This function returns the
 * same status as register_chained_syscall().
 */
int restart_original_syscall(Tracee *tracee)
{
	poke_reg(tracee, SYSARG_1, peek_reg(tracee, ORIGINAL, SYSARG_1));
	poke_reg(tracee, SYSARG_2, peek_reg(tracee, ORIGINAL, SYSARG_2));
	poke_reg(tracee, SYSARG_3, peek_reg(tracee, ORIGINAL, SYSARG_3));
	poke_reg(tracee, SYSARG_4, peek_reg(tracee, ORIGINAL, SYSARG_4));
	poke_reg(tracee, SYSARG_5, peek_reg(tracee, ORIGINAL, SYSARG_5));
	poke_reg(tracee, SYSARG_6, peek_reg(tracee, ORIGINAL, SYSARG_6));
	poke_reg(tracee, SYSTRAP_NUM, peek_reg(tracee, ORIGINAL, SYSARG_NUM));

	/* Move the instruction pointer back to the original trap.  */
	poke_reg(tracee, INSTR_POINTER,
		peek_reg(tracee, CURRENT, INSTR_POINTER) - SYSTRAP_SIZE);

	return 0;
}

```

`library/src/main/jni/syscall/chain.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef CHAIN_H
#define CHAIN_H

#include "tracee/tracee.h"
#include "syscall/sysnum.h"
#include "arch.h"

extern int register_chained_syscall(Tracee *tracee, Sysnum sysnum,
			word_t sysarg_1, word_t sysarg_2, word_t sysarg_3,
			word_t sysarg_4, word_t sysarg_5, word_t sysarg_6);

extern void force_chain_final_result(Tracee *tracee, word_t forced_result);

extern int restart_original_syscall(Tracee *tracee);

extern void chain_next_syscall(Tracee *tracee);


#endif /* CHAIN_H */

```

`library/src/main/jni/syscall/enter.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <errno.h>       /* errno(3), E* */
//#include <talloc.h>      /* talloc_*, */
#include <sys/un.h>      /* struct sockaddr_un, */
#include <linux/net.h>   /* SYS_*, */
#include <fcntl.h>       /* AT_FDCWD, */
#include <limits.h>      /* PATH_MAX, */
#include <string.h>      /* strcpy */
#include <sys/prctl.h>   /* PR_SET_DUMPABLE */
#include <inttypes.h>
#include <malloc.h>
#include "syscall/syscall.h"
#include "syscall/sysnum.h"
#include "syscall/socket.h"
#include "ptrace/ptrace.h"
#include "ptrace/wait.h"
#include "syscall/heap.h"
//#include "extension/extension.h"
#include "execve/execve.h"
#include "tracee/tracee.h"
#include "tracee/reg.h"
#include "tracee/mem.h"
#include "tracee/abi.h"
#include "path/path.h"
#include "path/canon.h"
#include "arch.h"
#include "constant.h"
#include "build.h"
#include "note.h"

/**
 * Translate @path and put the result in the @tracee's memory address
 * space pointed to by the @reg argument of the current syscall. See
 * the documentation of translate_path() about the meaning of
 * @type. This function returns -errno if an error occured, otherwise
 * 0.
 */
//static int translate_path2(Tracee *tracee, int dir_fd, char path[PATH_MAX], Reg reg, Type type)
//{
//	char new_path[PATH_MAX];
//	int status;
//
//	/* Special case where the argument was NULL. */
//	if (path[0] == '\0')
//		return 0;
//
//	/* Translate the original path. */
//	status = translate_path(tracee, new_path, dir_fd, path, type != SYMLINK);
//	if (status < 0)
//		return status;
//
//	return set_sysarg_path(tracee, new_path, reg);
//}

/**
 * A helper, see the comment of the function above.
 */
//static int translate_sysarg(Tracee *tracee, Reg reg, Type type)
//{
//	char old_path[PATH_MAX];
//	int status;
//
//	/* Extract the original path. */
//	status = get_sysarg_path(tracee, old_path, reg);
//	if (status < 0)
//		return status;
//
//	return translate_path2(tracee, AT_FDCWD, old_path, reg, type);
//}

/**
 * Translate the input arguments of the current @tracee's syscall in the
 * @tracee->pid process area. This function sets @tracee->status to
 * -errno if an error occured from the tracee's point-of-view (EFAULT
 * for instance), otherwise 0.
 */
int translate_syscall_enter(Tracee *tracee)
{
	int flags;
	int dirfd;
	int olddirfd;
	int newdirfd;

	int status;
	int status2;

	char path[PATH_MAX];
	char oldpath[PATH_MAX];
	char newpath[PATH_MAX];

	word_t syscall_number;
	bool special = false;

//	status = notify_extensions(tracee, SYSCALL_ENTER_START, 0, 0);
    status = 0;
	if (status < 0)
		goto end;
	if (status > 0)
		return 0;

	/* Translate input arguments. */
	syscall_number = get_sysnum(tracee, ORIGINAL);
	LOGSYS("syscall_number:%ld",syscall_number)
#if defined(HANDLE_SYSCALL)
	switch (syscall_number) {
	default:
		/* Nothing to do. */
		LOGSYSW("noting to do,sn:%ld",syscall_number);
		status = 0;
		break;

	case PR_execve:
		status = translate_execve_enter(tracee);
		break;
	case PR_execveat:
		if ((int) peek_reg(tracee, CURRENT, SYSARG_1) == AT_FDCWD) {
			set_sysnum(tracee, PR_execve);
			poke_reg(tracee, SYSARG_1, peek_reg(tracee, CURRENT, SYSARG_2));
			poke_reg(tracee, SYSARG_2, peek_reg(tracee, CURRENT, SYSARG_3));
			poke_reg(tracee, SYSARG_3, peek_reg(tracee, CURRENT, SYSARG_4));
		} else {
			note(tracee, ERROR, SYSTEM, "execveat() with non-AT_FDCWD fd is not currently supported");
			status = -ENOSYS;
			break;
		}
		status = translate_execve_enter(tracee);
		break;

	case PR_ptrace:
		status = translate_ptrace_enter(tracee);
		break;

	case PR_wait4:
	case PR_waitpid:
		status = translate_wait_enter(tracee);
		break;

//	case PR_brk:
//		translate_brk_enter(tracee);
//		status = 0;
//		break;

//	case PR_getcwd:
//		set_sysnum(tracee, PR_void);
//		status = 0;
//		break;

//	case PR_fchdir:
//	case PR_chdir: {
//		struct stat statl;
//		char *tmp;
//
//		/* The ending "." ensures an error will be reported if
//		 * path does not exist or if it is not a directory.  */
//		if (syscall_number == PR_chdir) {
//			status = get_sysarg_path(tracee, path, SYSARG_1);
//			if (status < 0)
//				break;
//
//			status = join_paths(2, oldpath, path, ".");
//			if (status < 0)
//				break;
//
//			dirfd = AT_FDCWD;
//		}
//		else {
//			strcpy(oldpath, ".");
//			dirfd = peek_reg(tracee, CURRENT, SYSARG_1);
//		}
//
//		status = translate_path(tracee, path, dirfd, oldpath, true);
//		if (status < 0)
//			break;
//
//		status = lstat(path, &statl);
//		if (status < 0)
//			break;
//
//		/* Check this directory is accessible.  */
//		if ((statl.st_mode & S_IXUSR) == 0)
//			return -EACCES;
//
//		/* Sadly this method doesn't detranslate statefully,
//		 * this means that there's an ambiguity when several
//		 * bindings are from the same host path:
//		 *
//		 *    $ proot -m /tmp:/a -m /tmp:/b fchdir_getcwd /a
//		 *    /b
//		 *
//		 *    $ proot -m /tmp:/b -m /tmp:/a fchdir_getcwd /a
//		 *    /a
//		 *
//		 * A solution would be to follow each file descriptor
//		 * just like it is done for cwd.
//		 */
//
//		status = detranslate_path(tracee, path, NULL);
//		if (status < 0)
//			break;
//
//		/* Remove the trailing "/" or "/.".  */
//		chop_finality(path);
//
//		tmp = talloc_strdup(tracee->fs, path);
//		if (tmp == NULL) {
//			status = -ENOMEM;
//			break;
//		}
//		TALLOC_FREE(tracee->fs->cwd);
//
//		tracee->fs->cwd = tmp;
//		talloc_set_name_const(tracee->fs->cwd, "$cwd");
//
//		set_sysnum(tracee, PR_void);
//		status = 0;
//		break;
//	}

//	case PR_bind:
//	case PR_connect: {
//		word_t address;
//		word_t size;
//
//		address = peek_reg(tracee, CURRENT, SYSARG_2);
//		size    = peek_reg(tracee, CURRENT, SYSARG_3);
//
//		status = translate_socketcall_enter(tracee, &address, size);
//		if (status <= 0)
//			break;
//
//		poke_reg(tracee, SYSARG_2, address);
//		poke_reg(tracee, SYSARG_3, sizeof(struct sockaddr_un));
//
//		status = 0;
//		break;
//	}

//#define SYSARG_ADDR(n) (args_addr + ((n) - 1) * sizeof_word(tracee))
//
//#define PEEK_WORD(addr, forced_errno)		\
//	peek_word(tracee, addr);		\
//	if (errno != 0) {			\
//		status = forced_errno ?: -errno; \
//		break;				\
//	}
//
//#define POKE_WORD(addr, value)			\
//	poke_word(tracee, addr, value);		\
//	if (errno != 0) {			\
//		status = -errno;		\
//		break;				\
//	}

//	case PR_accept:
//	case PR_accept4:
//		/* Nothing special to do if no sockaddr was specified.  */
//		if (peek_reg(tracee, ORIGINAL, SYSARG_2) == 0) {
//			status = 0;
//			break;
//		}
//		special = true;
		/* Fall through.  */
//	case PR_getsockname:
//	case PR_getpeername:{
//		int size;
//
//		/* Remember: PEEK_WORD puts -errno in status and breaks if an
//		 * error occured.  */
//		size = (int) PEEK_WORD(peek_reg(tracee, ORIGINAL, SYSARG_3), special ? -EINVAL : 0);
//
//		/* The "size" argument is both used as an input parameter
//		 * (max. size) and as an output parameter (actual size).  The
//		 * exit stage needs to know the max. size to not overwrite
//		 * anything, that's why it is copied in the 6th argument
//		 * (unused) before the kernel updates it.  */
//		poke_reg(tracee, SYSARG_6, size);
//
//		status = 0;
//		break;
//	}

//	case PR_socketcall: {
//		word_t args_addr;
//		word_t sock_addr_saved;
//		word_t sock_addr;
//		word_t size_addr;
//		word_t size;
//
//		args_addr = peek_reg(tracee, CURRENT, SYSARG_2);
//
//		switch (peek_reg(tracee, CURRENT, SYSARG_1)) {
//		case SYS_BIND:
//		case SYS_CONNECT:
//			/* Handle these cases below.  */
//			status = 1;
//			break;
//
//		case SYS_ACCEPT:
//		case SYS_ACCEPT4:
//			/* Nothing special to do if no sockaddr was specified.  */
//			sock_addr = PEEK_WORD(SYSARG_ADDR(2), 0);
//			if (sock_addr == 0) {
//				status = 0;
//				break;
//			}
//			special = true;
//			/* Fall through.  */
//		case SYS_GETSOCKNAME:
//		case SYS_GETPEERNAME:
//			/* Remember: PEEK_WORD puts -errno in status and breaks
//			 * if an error occured.  */
//			size_addr =  PEEK_WORD(SYSARG_ADDR(3), 0);
//			size = (int) PEEK_WORD(size_addr, special ? -EINVAL : 0);
//
//			/* See case PR_accept for explanation.  */
//			poke_reg(tracee, SYSARG_6, size);
//			status = 0;
//			break;
//
//		default:
//			status = 0;
//			break;
//		}
//
//		/* An error occured or there's nothing else to do.  */
//		if (status <= 0)
//			break;
//
//		/* Remember: PEEK_WORD puts -errno in status and breaks if an
//		 * error occured.  */
//		sock_addr = PEEK_WORD(SYSARG_ADDR(2), 0);
//		size      = PEEK_WORD(SYSARG_ADDR(3), 0);
//
//		sock_addr_saved = sock_addr;
//		status = translate_socketcall_enter(tracee, &sock_addr, size);
//		if (status <= 0)
//			break;
//
//		/* These parameters are used/restored at the exit stage.  */
//		poke_reg(tracee, SYSARG_5, sock_addr_saved);
//		poke_reg(tracee, SYSARG_6, size);
//
//		/* Remember: POKE_WORD puts -errno in status and breaks if an
//		 * error occured.  */
//		POKE_WORD(SYSARG_ADDR(2), sock_addr);
//		POKE_WORD(SYSARG_ADDR(3), sizeof(struct sockaddr_un));
//
//		status = 0;
//		break;
//	}

#undef SYSARG_ADDR
#undef PEEK_WORD
#undef POKE_WORD

//	case PR_access:
//	case PR_acct:
//	case PR_chmod:
//	case PR_chown:
//	case PR_chown32:
//	case PR_chroot:
//	case PR_getxattr:
//	case PR_listxattr:
//	case PR_mknod:
//	case PR_oldstat:
//	case PR_creat:
//	case PR_removexattr:
//	case PR_setxattr:
//	case PR_stat:
//	case PR_stat64:
//	case PR_statfs:
//	case PR_statfs64:
//	case PR_swapoff:
//	case PR_swapon:
//	case PR_truncate:
//	case PR_truncate64:
//	case PR_umount:
//	case PR_umount2:
//	case PR_uselib:
//	case PR_utime:
//	case PR_utimes:
//		status = translate_sysarg(tracee, SYSARG_1, REGULAR);
//		break;

	case PR_open:
	LOGSYS("vpid %" PRIu64 ",open: %s",tracee->vpid,path)
//		flags = peek_reg(tracee, CURRENT, SYSARG_2);
//
//		if (   ((flags & O_NOFOLLOW) != 0)
//		    || ((flags & O_EXCL) != 0 && (flags & O_CREAT) != 0))
//			status = translate_sysarg(tracee, SYSARG_1, SYMLINK);
//		else
//			status = translate_sysarg(tracee, SYSARG_1, REGULAR);
		break;

//	case PR_fchownat:
//	case PR_fstatat64:
//	case PR_newfstatat:
//	case PR_statx:
//	case PR_utimensat:
//	case PR_utimensat_time64:
//	case PR_name_to_handle_at:
//		dirfd = peek_reg(tracee, CURRENT, SYSARG_1);
//
//		status = get_sysarg_path(tracee, path, SYSARG_2);
//		if (status < 0)
//			break;
//
//		flags = (  syscall_number == PR_fchownat
//			|| syscall_number == PR_name_to_handle_at)
//			? peek_reg(tracee, CURRENT, SYSARG_5)
//			: ((syscall_number == PR_statx) ?
//			   peek_reg(tracee, CURRENT, SYSARG_3) :
//			   peek_reg(tracee, CURRENT, SYSARG_4));
//
//		if ((flags & AT_SYMLINK_NOFOLLOW) != 0)
//			status = translate_path2(tracee, dirfd, path, SYSARG_2, SYMLINK);
//		else
//			status = translate_path2(tracee, dirfd, path, SYSARG_2, REGULAR);
//		break;

//	case PR_fchmodat:
//	case PR_faccessat:
//	case PR_faccessat2:
//	case PR_futimesat:
//	case PR_mknodat:
//		dirfd = peek_reg(tracee, CURRENT, SYSARG_1);
//
//		status = get_sysarg_path(tracee, path, SYSARG_2);
//		if (status < 0)
//			break;
//
//		status = translate_path2(tracee, dirfd, path, SYSARG_2, REGULAR);
//		break;

//	case PR_inotify_add_watch:
//		flags = peek_reg(tracee, CURRENT, SYSARG_3);
//
//		if ((flags & IN_DONT_FOLLOW) != 0)
//			status = translate_sysarg(tracee, SYSARG_2, SYMLINK);
//		else
//			status = translate_sysarg(tracee, SYSARG_2, REGULAR);
//		break;

//	case PR_readlink:
//	case PR_lchown:
//	case PR_lchown32:
//	case PR_lgetxattr:
//	case PR_llistxattr:
//	case PR_lremovexattr:
//	case PR_lsetxattr:
//	case PR_lstat:
//	case PR_lstat64:
//	case PR_oldlstat:
//	case PR_unlink:
//	case PR_rmdir:
//	case PR_mkdir:
//		status = translate_sysarg(tracee, SYSARG_1, SYMLINK);
//		break;

//	case PR_pivot_root:
//		status = translate_sysarg(tracee, SYSARG_1, REGULAR);
//		if (status < 0)
//			break;
//
//		status = translate_sysarg(tracee, SYSARG_2, REGULAR);
//		break;

//	case PR_linkat:
//		olddirfd = peek_reg(tracee, CURRENT, SYSARG_1);
//		newdirfd = peek_reg(tracee, CURRENT, SYSARG_3);
//		flags    = peek_reg(tracee, CURRENT, SYSARG_5);
//
//		status = get_sysarg_path(tracee, oldpath, SYSARG_2);
//		if (status < 0)
//			break;
//
//		status = get_sysarg_path(tracee, newpath, SYSARG_4);
//		if (status < 0)
//			break;
//
//		if ((flags & AT_SYMLINK_FOLLOW) != 0)
//			status = translate_path2(tracee, olddirfd, oldpath, SYSARG_2, REGULAR);
//		else
//			status = translate_path2(tracee, olddirfd, oldpath, SYSARG_2, SYMLINK);
//		if (status < 0)
//			break;
//
//		status = translate_path2(tracee, newdirfd, newpath, SYSARG_4, SYMLINK);
//		break;

//	case PR_mount:
//		status = get_sysarg_path(tracee, path, SYSARG_1);
//		if (status < 0)
//			break;
//
//		/* The following check covers only 90% of the cases. */
//		if (path[0] == '/' || path[0] == '.') {
//			status = translate_path2(tracee, AT_FDCWD, path, SYSARG_1, REGULAR);
//			if (status < 0)
//				break;
//		}
//
//		status = translate_sysarg(tracee, SYSARG_2, REGULAR);
//		break;

	case PR_openat:
		dirfd = peek_reg(tracee, CURRENT, SYSARG_1);
		flags = peek_reg(tracee, CURRENT, SYSARG_3);

		status = get_sysarg_path(tracee, path, SYSARG_2);
		if (status < 0){
            LOGSYS("vpid %" PRIu64 ",openat error,status:%d,err:%d,%s",tracee->vpid,status,errno,
                   strerror(errno))
            break;
        }
		LOGSYS("vpid %" PRIu64 ",openat: %s",tracee->vpid,path)
//		if (   ((flags & O_NOFOLLOW) != 0)
//			|| ((flags & O_EXCL) != 0 && (flags & O_CREAT) != 0))
//			status = translate_path2(tracee, dirfd, path, SYSARG_2, SYMLINK);
//		else
//			status = translate_path2(tracee, dirfd, path, SYSARG_2, REGULAR);
		break;

//	case PR_readlinkat:
//	case PR_unlinkat:
//	case PR_mkdirat:
//		dirfd = peek_reg(tracee, CURRENT, SYSARG_1);
//
//		status = get_sysarg_path(tracee, path, SYSARG_2);
//		if (status < 0)
//			break;
//
//		status = translate_path2(tracee, dirfd, path, SYSARG_2, SYMLINK);
//		break;

//	case PR_link:
//	case PR_rename:
//		status = translate_sysarg(tracee, SYSARG_1, SYMLINK);
//		if (status < 0)
//			break;
//
//		status = translate_sysarg(tracee, SYSARG_2, SYMLINK);
//		break;

//	case PR_renameat:
//	case PR_renameat2:
//		olddirfd = peek_reg(tracee, CURRENT, SYSARG_1);
//		newdirfd = peek_reg(tracee, CURRENT, SYSARG_3);
//
//		status = get_sysarg_path(tracee, oldpath, SYSARG_2);
//		if (status < 0)
//			break;
//
//		status = get_sysarg_path(tracee, newpath, SYSARG_4);
//		if (status < 0)
//			break;
//
//		status = translate_path2(tracee, olddirfd, oldpath, SYSARG_2, SYMLINK);
//		if (status < 0)
//			break;
//
//		status = translate_path2(tracee, newdirfd, newpath, SYSARG_4, SYMLINK);
//		break;

//	case PR_symlink:
//		status = translate_sysarg(tracee, SYSARG_2, SYMLINK);
//		break;

//	case PR_symlinkat:
//		newdirfd = peek_reg(tracee, CURRENT, SYSARG_2);
//
//		status = get_sysarg_path(tracee, newpath, SYSARG_3);
//		if (status < 0)
//			break;
//
//		status = translate_path2(tracee, newdirfd, newpath, SYSARG_3, SYMLINK);
//		break;

	case PR_prctl:
		/* Prevent tracees from setting dumpable flag.
		 * (Otherwise it could break tracee memory access)  */
		if (peek_reg(tracee, CURRENT, SYSARG_1) == PR_SET_DUMPABLE) {
			set_sysnum(tracee, PR_void);
			status = 0;
		}
		break;
	}
#else
	LOGSYS("no syscall enter handle")
	status = 0;
#endif

end:
//	status2 = notify_extensions(tracee, SYSCALL_ENTER_END, status, 0);
	status2 = 0;
	if (status2 < 0)
		status = status2;

	return status;
}


```

`library/src/main/jni/syscall/exit.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <errno.h>       /* errno(3), E* */
#include <sys/utsname.h> /* struct utsname, */
#include <linux/net.h>   /* SYS_*, */
#include <string.h>      /* strlen(3), */
#include <malloc.h>

#include "syscall/syscall.h"
#include "syscall/sysnum.h"
#include "syscall/socket.h"
#include "syscall/chain.h"
#include "syscall/heap.h"
#include "syscall/rlimit.h"
#include "execve/execve.h"
#include "tracee/tracee.h"
#include "tracee/reg.h"
#include "tracee/mem.h"
#include "tracee/abi.h"
#include "path/path.h"
#include "ptrace/ptrace.h"
#include "ptrace/wait.h"
//#include "extension/extension.h"
#include "arch.h"
#include "build.h"
#include "constant.h"

/**
 * Translate the output arguments of the current @tracee's syscall in
 * the @tracee->pid process area. This function sets the result of
 * this syscall to @tracee->status if an error occured previously
 * during the translation, that is, if @tracee->status is less than 0.
 */
void translate_syscall_exit(Tracee *tracee)
{
	word_t syscall_number;
	word_t syscall_result;
	int status;

//	status = notify_extensions(tracee, SYSCALL_EXIT_START, 0, 0);
	status = 0;
	if (status < 0) {
		poke_reg(tracee, SYSARG_RESULT, (word_t) status);
		goto end;
	}
	if (status > 0)
		return;

	/* Set the tracee's errno if an error occured previously during
	 * the translation. */
	if (tracee->status < 0) {
		poke_reg(tracee, SYSARG_RESULT, (word_t) tracee->status);
		goto end;
	}

	/* Translate output arguments:
	 * - break: update the syscall result register with "status"
	 * - goto end: nothing else to do.
	 */
	syscall_number = get_sysnum(tracee, ORIGINAL);
	syscall_result = peek_reg(tracee, CURRENT, SYSARG_RESULT);
#if defined(HANDLE_SYSCALL)
	switch (syscall_number) {
//	case PR_brk:
//		translate_brk_exit(tracee);
//		goto end;

//	case PR_getcwd: {
//		char path[PATH_MAX];
//		size_t new_size;
//		size_t size;
//		word_t output;
//
//		size = (size_t) peek_reg(tracee, ORIGINAL, SYSARG_2);
//		if (size == 0) {
//			status = -EINVAL;
//			break;
//		}
//
//		/* Ensure cwd still exists.  */
//		status = translate_path(tracee, path, AT_FDCWD, ".", false);
//		if (status < 0)
//			break;
//
//		new_size = strlen(tracee->fs->cwd) + 1;
//		if (size < new_size) {
//			status = -ERANGE;
//			break;
//		}
//
//		/* Overwrite the path.  */
//		output = peek_reg(tracee, ORIGINAL, SYSARG_1);
//		status = write_data(tracee, output, tracee->fs->cwd, new_size);
//		if (status < 0)
//			break;
//
//		/* The value of "status" is used to update the returned value
//		 * in translate_syscall_exit().  */
//		status = new_size;
//		break;
//	}

//	case PR_accept:
//	case PR_accept4:
//		/* Nothing special to do if no sockaddr was specified.  */
//		if (peek_reg(tracee, ORIGINAL, SYSARG_2) == 0)
//			goto end;
		/* Fall through.  */
//	case PR_getsockname:
//	case PR_getpeername: {
//		word_t sock_addr;
//		word_t size_addr;
//		word_t max_size;
//
//		/* Error reported by the kernel.  */
//		if ((int) syscall_result < 0)
//			goto end;
//
//		sock_addr = peek_reg(tracee, ORIGINAL, SYSARG_2);
//		size_addr = peek_reg(tracee, MODIFIED, SYSARG_3);
//		max_size  = peek_reg(tracee, MODIFIED, SYSARG_6);
//
//		status = translate_socketcall_exit(tracee, sock_addr, size_addr, max_size);
//		if (status < 0)
//			break;
//
//		/* Don't overwrite the syscall result.  */
//		goto end;
//	}

//#define SYSARG_ADDR(n) (args_addr + ((n) - 1) * sizeof_word(tracee))
//
//#define POKE_WORD(addr, value)			\
//	poke_word(tracee, addr, value);		\
//	if (errno != 0)	{			\
//		status = -errno;		\
//		break;				\
//	}
//
//#define PEEK_WORD(addr)				\
//	peek_word(tracee, addr);		\
//	if (errno != 0) {			\
//		status = -errno;		\
//		break;				\
//	}

//	case PR_socketcall: {
//		word_t args_addr;
//		word_t sock_addr;
//		word_t size_addr;
//		word_t max_size;
//
//		args_addr = peek_reg(tracee, ORIGINAL, SYSARG_2);
//
//		switch (peek_reg(tracee, ORIGINAL, SYSARG_1)) {
//		case SYS_ACCEPT:
//		case SYS_ACCEPT4:
//			/* Nothing special to do if no sockaddr was specified.  */
//			sock_addr = PEEK_WORD(SYSARG_ADDR(2));
//			if (sock_addr == 0)
//				goto end;
//			/* Fall through.  */
//		case SYS_GETSOCKNAME:
//		case SYS_GETPEERNAME:
//			/* Handle these cases below.  */
//			status = 1;
//			break;
//
//		case SYS_BIND:
//		case SYS_CONNECT:
//			/* Restore the initial parameters: this memory was
//			 * overwritten at the enter stage.  Remember: POKE_WORD
//			 * puts -errno in status and breaks if an error
//			 * occured.  */
//			POKE_WORD(SYSARG_ADDR(2), peek_reg(tracee, MODIFIED, SYSARG_5));
//			POKE_WORD(SYSARG_ADDR(3), peek_reg(tracee, MODIFIED, SYSARG_6));
//
//			status = 0;
//			break;
//
//		default:
//			status = 0;
//			break;
//		}
//
//		/* Error reported by the kernel or there's nothing else to do.  */
//		if ((int) syscall_result < 0 || status == 0)
//			goto end;
//
//		/* An error occured in SYS_BIND or SYS_CONNECT.  */
//		if (status < 0)
//			break;
//
//		/* Remember: PEEK_WORD puts -errno in status and breaks if an
//		 * error occured.  */
//		sock_addr = PEEK_WORD(SYSARG_ADDR(2));
//		size_addr = PEEK_WORD(SYSARG_ADDR(3));
//		max_size  = peek_reg(tracee, MODIFIED, SYSARG_6);
//
//		status = translate_socketcall_exit(tracee, sock_addr, size_addr, max_size);
//		if (status < 0)
//			break;
//
//		/* Don't overwrite the syscall result.  */
//		goto end;
//	}

#undef SYSARG_ADDR
#undef PEEK_WORD
#undef POKE_WORD

//	case PR_fchdir:
//	case PR_chdir:
//		/* These syscalls are fully emulated, see enter.c for details
//		 * (like errors).  */
//		status = 0;
//		break;

//	case PR_rename:
//	case PR_renameat:
//	case PR_renameat2: {
//		char old_path[PATH_MAX];
//		char new_path[PATH_MAX];
//		ssize_t old_length;
//		ssize_t new_length;
//		Comparison comparison;
//		Reg old_reg;
//		Reg new_reg;
//		char *tmp;
//
//		/* Error reported by the kernel.  */
//		if ((int) syscall_result < 0)
//			goto end;
//
//		if (syscall_number == PR_rename) {
//			old_reg = SYSARG_1;
//			new_reg = SYSARG_2;
//		}
//		else {
//			old_reg = SYSARG_2;
//			new_reg = SYSARG_4;
//		}
//
//		/* Get the old path, then convert it to the same
//		 * "point-of-view" as tracee->fs->cwd (guest).  */
//		status = read_path(tracee, old_path, peek_reg(tracee, MODIFIED, old_reg));
//		if (status < 0)
//			break;
//
//		status = detranslate_path(tracee, old_path, NULL);
//		if (status < 0)
//			break;
//		old_length = (status > 0 ? status - 1 : (ssize_t) strlen(old_path));
//
//		/* Nothing special to do if the moved path is not the
//		 * current working directory.  */
//		comparison = compare_paths(old_path, tracee->fs->cwd);
//		if (comparison != PATH1_IS_PREFIX && comparison != PATHS_ARE_EQUAL) {
//			status = 0;
//			break;
//		}
//
//		/* Get the new path, then convert it to the same
//		 * "point-of-view" as tracee->fs->cwd (guest).  */
//		status = read_path(tracee, new_path, peek_reg(tracee, MODIFIED, new_reg));
//		if (status < 0)
//			break;
//
//		status = detranslate_path(tracee, new_path, NULL);
//		if (status < 0)
//			break;
//		new_length = (status > 0 ? status - 1 : (ssize_t) strlen(new_path));
//
//		/* Sanity check.  */
//		if (strlen(tracee->fs->cwd) >= PATH_MAX) {
//			status = 0;
//			break;
//		}
//		strcpy(old_path, tracee->fs->cwd);
//
//		/* Update the virtual current working directory.  */
//		substitute_path_prefix(old_path, old_length, new_path, new_length);
//
//		tmp = talloc_strdup(tracee->fs, old_path);
//		if (tmp == NULL) {
//			status = -ENOMEM;
//			break;
//		}
//
//		TALLOC_FREE(tracee->fs->cwd);
//		tracee->fs->cwd = tmp;
//
//		status = 0;
//		break;
//	}

//	case PR_readlink:
//	case PR_readlinkat: {
//		char referee[PATH_MAX];
//		char referer[PATH_MAX];
//		size_t old_size;
//		size_t new_size;
//		size_t max_size;
//		word_t input;
//		word_t output;
//
//		/* Error reported by the kernel.  */
//		if ((int) syscall_result < 0)
//			goto end;
//
//		old_size = syscall_result;
//
//		if (syscall_number == PR_readlink) {
//			output   = peek_reg(tracee, ORIGINAL, SYSARG_2);
//			max_size = peek_reg(tracee, ORIGINAL, SYSARG_3);
//			input    = peek_reg(tracee, MODIFIED, SYSARG_1);
//		}
//		else {
//			output   = peek_reg(tracee, ORIGINAL,  SYSARG_3);
//			max_size = peek_reg(tracee, ORIGINAL, SYSARG_4);
//			input    = peek_reg(tracee, MODIFIED, SYSARG_2);
//		}
//
//		if (max_size > PATH_MAX)
//			max_size = PATH_MAX;
//
//		if (max_size == 0) {
//			status = -EINVAL;
//			break;
//		}
//
//		/* The kernel does NOT put the NULL terminating byte for
//		 * readlink(2).  */
//		status = read_data(tracee, referee, output, old_size);
//		if (status < 0)
//			break;
//		referee[old_size] = '\0';
//
//		/* Not optimal but safe (path is fully translated).  */
//		status = read_path(tracee, referer, input);
//		if (status < 0)
//			break;
//
//		if (status >= PATH_MAX) {
//			status = -ENAMETOOLONG;
//			break;
//		}
//
//		status = detranslate_path(tracee, referee, referer);
//		if (status < 0)
//			break;
//
//		/* The original path doesn't require any transformation, i.e
//		 * it is a symetric binding.  */
//		if (status == 0)
//			goto end;
//
//		/* Overwrite the path.  Note: the output buffer might be
//		 * initialized with zeros but it was updated with the kernel
//		 * result, and then with the detranslated result.  This later
//		 * might be shorter than the former, so it's safier to add a
//		 * NULL terminating byte when possible.  This problem was
//		 * exposed by IDA Demo 6.3.  */
//		if ((size_t) status < max_size) {
//			new_size = status - 1;
//			status = write_data(tracee, output, referee, status);
//		}
//		else {
//			new_size = max_size;
//			status = write_data(tracee, output, referee, max_size);
//		}
//		if (status < 0)
//			break;
//
//		/* The value of "status" is used to update the returned value
//		 * in translate_syscall_exit().  */
//		status = new_size;
//		break;
//	}

//#if defined(ARCH_X86_64)
//	case PR_uname: {
//		struct utsname utsname;
//		word_t address;
//		size_t size;
//
//		if (get_abi(tracee) != ABI_2)
//			goto end;
//
//		/* Error reported by the kernel.  */
//		if ((int) syscall_result < 0)
//			goto end;
//
//		address = peek_reg(tracee, ORIGINAL, SYSARG_1);
//
//		status = read_data(tracee, &utsname, address, sizeof(utsname));
//		if (status < 0)
//			break;
//
//		/* Some 32-bit programs like package managers can be
//		 * confused when the kernel reports "x86_64".  */
//		size = sizeof(utsname.machine);
//		strncpy(utsname.machine, "i686", size);
//		utsname.machine[size - 1] = '\0';
//
//		status = write_data(tracee, address, &utsname, sizeof(utsname));
//		if (status < 0)
//			break;
//
//		status = 0;
//		break;
//	}
//#endif

	case PR_execve:
		translate_execve_exit(tracee);
		goto end;

	case PR_ptrace:
		status = translate_ptrace_exit(tracee);
		break;

//	case PR_readlinkat:
//		if (tracee->user_context_data != NULL){
//			readlink_context*  context = tracee->user_context_data;
//			if (context->type == BUSINESS){
//				business_data * business_data = context->data;
//				word_t buf_size = peek_reg(tracee,CURRENT,SYSARG_4);
//				size_t result_size = strlen(business_data->result);
//				if (buf_size < result_size){
//					//error --- 数据会不完整
//					result_size = buf_size;
//				}
//				set_sysarg_data(tracee,business_data->result,result_size ,SYSARG_3);
//				poke_reg(tracee,SYSARG_RESULT, result_size);
//				free(context->data);
//				free(context);
//			} else if (context->type == NORMAL){
//				//TODO
//			}
//		}
//		break;

	case PR_wait4:
	case PR_waitpid: { //貌似跟ptrace对抗有关
		bool set_result = true;
		if (tracee->as_ptracer.waits_in != WAITS_IN_PROOT)
			goto end;

		status = translate_wait_exit(tracee, &set_result);
		if (!set_result)
			goto end;
		break;
	}

//	case PR_setrlimit:
//	case PR_prlimit64:
//		/* Error reported by the kernel.  */
//		if ((int) syscall_result < 0)
//			goto end;
//
//		status = translate_setrlimit_exit(tracee, syscall_number == PR_prlimit64);
//		if (status < 0)
//			break;
//
//		/* Don't overwrite the syscall result.  */
//		goto end;

	default:
		goto end;
	}
#else
	LOGSYS("no syscall exit handle")
	status = 0;
#endif

	poke_reg(tracee, SYSARG_RESULT, (word_t) status);

end:
//	status = notify_extensions(tracee, SYSCALL_EXIT_END, 0, 0);
	status = 0;
	if (status < 0)
		poke_reg(tracee, SYSARG_RESULT, (word_t) status);
}

```

`library/src/main/jni/syscall/heap.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sys/mman.h>	/* PROT_*, MAP_*, */
#include <assert.h>	/* assert(3),  */
#include <string.h>     /* strerror(3), */
#include <unistd.h>     /* sysconf(3), */
#include <sys/param.h>  /* MIN(), MAX(), */

#include "tracee/tracee.h"
#include "tracee/reg.h"
#include "tracee/mem.h"
#include "syscall/sysnum.h"
#include "execve/execve.h"
#include "cli/note.h"

#include "compat.h"

#define DEBUG_BRK(...) /* fprintf(stderr, __VA_ARGS__) */

/* The size of the heap can be zero, unlike the size of a memory
 * mapping.  As a consequence, the first page of the "heap" memory
 * mapping is discarded in order to emulate an empty heap.  */
static word_t heap_offset = 0;

/**
 * Put @tracee's heap to a reliable location.  By default the Linux
 * kernel puts it near loader's BSS, but this default location is not
 * reliable since the kernel might put another memory mapping right
 * after it (ie. continuously).  In this case, @tracee's heap can't
 * grow anymore and some programs like Bash will abort.  This issue
 * can be reproduced when using a Ubuntu 12.04 x86_64 rootfs on RHEL 5
 * x86_64.
 */
void translate_brk_enter(Tracee *tracee)
{
	word_t new_brk_address;
	size_t old_heap_size;
	size_t new_heap_size;

	if (tracee->heap->disabled)
		return;

	if (heap_offset == 0) {
		heap_offset = sysconf(_SC_PAGE_SIZE);
		if ((int) heap_offset <= 0)
			heap_offset = 0x1000;
	}

	new_brk_address = peek_reg(tracee, CURRENT, SYSARG_1);
	DEBUG_BRK("brk(0x%lx)\n", new_brk_address);

	/* Allocate a new mapping for the emulated heap.  */
	if (tracee->heap->base == 0) {
		Sysnum sysnum;
		Mapping *mappings;
		Mapping *bss;

		/* From PRoot's point-of-view this is the first time this
		 * tracee calls brk(2), although an address was specified.
		 * This is not supposed to happen the first time.  It is
		 * likely because this tracee is the very first child of PRoot
		 * but the first execve(2) didn't happen yet (so this is not
		 * its first call to brk(2)).  For instance, the installation
		 * of seccomp filters is made after this very first process is
		 * traced, and might call malloc(3) before the first
		 * execve(2).  */
		if (new_brk_address != 0) {
			if (tracee->verbose > 0)
				note(tracee, WARNING, INTERNAL,
					"process %d is doing suspicious brk()",	tracee->pid);
			return;
		}

		/* Put the heap as close to the BSS as possible since
		 * some programs -- like dump-emacs -- assume the gap
		 * between the end of the BSS and the start of the
		 * heap is relatively small (ie. < 1MB) even if ALSR
		 * is enabled.  Note that bss->addr + bss->length is
		 * naturally aligned to a page boundary according to
		 * add_mapping() in execve/enter.c, ie. no need to
		 * align new_brk_address again.  Now, the gap between
		 * the BSS and the heap is only "heap_offset" bytes
		 * long.  To emulate ADDR_NO_RANDOMIZE personality,
		 * this gap should be removed (not yet supported).  */
		mappings = tracee->load_info->mappings;
		bss = &mappings[talloc_array_length(mappings) - 1];
		new_brk_address = bss->addr + bss->length;

		/* I don't understand yet why mmap(2) fails (EFAULT)
		 * on architectures that also have mmap2(2).  Maybe
		 * this former implies MAP_FIXED in such cases.  */
		sysnum = detranslate_sysnum(get_abi(tracee), PR_mmap2) != SYSCALL_AVOIDER
			? PR_mmap2
			: PR_mmap;

		set_sysnum(tracee, sysnum);
		poke_reg(tracee, SYSARG_1 /* address */, new_brk_address);
		poke_reg(tracee, SYSARG_2 /* length  */, heap_offset);
		poke_reg(tracee, SYSARG_3 /* prot    */, PROT_READ | PROT_WRITE);
		poke_reg(tracee, SYSARG_4 /* flags   */, MAP_PRIVATE | MAP_ANONYMOUS);
		poke_reg(tracee, SYSARG_5 /* fd      */, -1);
		poke_reg(tracee, SYSARG_6 /* offset  */, 0);

		return;
	}

	/* The size of the heap can't be negative.  */
	if (new_brk_address < tracee->heap->base) {
		set_sysnum(tracee, PR_void);
		return;
	}

	new_heap_size = new_brk_address - tracee->heap->base;
	old_heap_size = tracee->heap->size;

	/* Actually resizing.  */
	set_sysnum(tracee, PR_mremap);
	poke_reg(tracee, SYSARG_1 /* old_address */, tracee->heap->base - heap_offset);
	poke_reg(tracee, SYSARG_2 /* old_size    */, old_heap_size + heap_offset);
	poke_reg(tracee, SYSARG_3 /* new_size    */, new_heap_size + heap_offset);
	poke_reg(tracee, SYSARG_4 /* flags       */, 0);
	poke_reg(tracee, SYSARG_5 /* new_address */, 0);

	return;
}

/**
 * c.f. function above.
 */
void translate_brk_exit(Tracee *tracee)
{
	word_t result;
	word_t sysnum;
	int tracee_errno;

	if (tracee->heap->disabled)
		return;

	assert(heap_offset > 0);

	sysnum = get_sysnum(tracee, MODIFIED);
	result = peek_reg(tracee, CURRENT, SYSARG_RESULT);
	tracee_errno = (int) result;

	switch (sysnum) {
	case PR_void:
		poke_reg(tracee, SYSARG_RESULT, tracee->heap->base + tracee->heap->size);
		break;

	case PR_mmap:
	case PR_mmap2:
		/* On error, mmap(2) returns -errno (the last 4k is
		 * reserved for this), whereas brk(2) returns the
		 * previous value.  */
		if (tracee_errno < 0 && tracee_errno > -4096) {
			poke_reg(tracee, SYSARG_RESULT, 0);
			break;
		}

		tracee->heap->base = result + heap_offset;
		tracee->heap->size = 0;

		poke_reg(tracee, SYSARG_RESULT, tracee->heap->base + tracee->heap->size);
		break;

	case PR_mremap:
		/* On error, mremap(2) returns -errno (the last 4k is
		 * reserved this), whereas brk(2) returns the previous
		 * value.  */
		if (   (tracee_errno < 0 && tracee_errno > -4096)
		    || (tracee->heap->base != result + heap_offset)) {
			poke_reg(tracee, SYSARG_RESULT, tracee->heap->base + tracee->heap->size);
			break;
		}

		tracee->heap->size = peek_reg(tracee, MODIFIED, SYSARG_3) - heap_offset;

		poke_reg(tracee, SYSARG_RESULT, tracee->heap->base + tracee->heap->size);
		break;

	case PR_brk:
		/* Is it confirmed that this suspicious call to brk(2)
		 * is actually legit?  */
		if (result == peek_reg(tracee, ORIGINAL, SYSARG_1))
			tracee->heap->disabled = true;
		break;

	default:
		assert(0);
	}

	DEBUG_BRK("brk() = 0x%lx\n", peek_reg(tracee, CURRENT, SYSARG_RESULT));
}

```

`library/src/main/jni/syscall/heap.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef HEAP_H
#define HEAP_H

#include "tracee/tracee.h"

extern void translate_brk_enter(Tracee *tracee);
extern void translate_brk_exit(Tracee *tracee);

#endif /* HEAP_H */

```

`library/src/main/jni/syscall/rlimit.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <stdbool.h>		/* bool, */
#include <sys/time.h>		/* prlimit(2), */
#include <sys/resource.h>	/* prlimit(2), */

#include "tracee/tracee.h"
#include "tracee/reg.h"
#include "tracee/mem.h"
#include "tracee/abi.h"
#include "cli/note.h"

/**
 * Set PRoot's stack soft limit to @tracee's one if this latter is
 * greater.  This allows to workaround a Linux kernel bug that
 * prevents a tracer to access a tracee's stack beyond its last mapped
 * page, as it might by the case under PRoot.  This function returns
 * -errno if an error occurred, otherwise 0.
 *
 * Details: when a tracer tries to access a tracee's stack beyond its
 * last mapped page, the Linux kernel should be able to increase
 * tracee's stack up to its soft limit.  Unfortunately the Linux
 * kernel checks the limit of the tracer instead the limit of the
 * tracee.  This bug was exposed using UMEQ under PRoot.
 *
 * Ref.: https://bugzilla.kernel.org/show_bug.cgi?id=91791
 *
 * Three strategies were possible:
 *
 * - set PRoot's stack soft limit to the hard limit; this might make
 *   the system collapse if PRoot starts to recurses indefinitely.
 *
 * - as it's done here; this appears to be a good compromise between
 *   the strategy above and the one below.
 *
 * - as it's done here + reduce PRoot's stack soft limit as soon as
 *   it's possible; this would be overly complicated.
 */
int translate_setrlimit_exit(const Tracee *tracee, bool is_prlimit)
{
	struct rlimit proot_stack;
	word_t resource;
	word_t address;
	word_t tracee_stack_limit;
	Reg sysarg;
	int status;

	sysarg = (is_prlimit ? SYSARG_2 : SYSARG_1);

	resource = peek_reg(tracee, ORIGINAL, sysarg);
	address  = peek_reg(tracee, ORIGINAL, sysarg + 1);

	/* Not the resource we're looking for?  */
	if (resource != RLIMIT_STACK)
		return 0;

	/* Retrieve new tracee's stack limit.  */
	if (is_prlimit) {
		/* Not the prlimit usage we're looking for?  */
		if (address == 0)
			return 0;

		tracee_stack_limit = peek_uint64(tracee, address);
	}
	else {
		tracee_stack_limit = peek_word(tracee, address);

		/* Convert this special value from 32-bit to 64-bit,
		 * if needed.  */
		if (is_32on64_mode(tracee) && tracee_stack_limit == (uint32_t) -1)
			tracee_stack_limit = RLIM_INFINITY;
	}
	if (errno != 0)
		return -errno;

	/* Get current PRoot's stack limit.  */
	status = prlimit(0, RLIMIT_STACK, NULL, &proot_stack);
	if (status < 0) {
		VERBOSE(tracee, 1, "can't get stack limit.");
		return 0; /* Not fatal.  */
	}

	/* No need to increase current PRoot's stack limit?  */
	if (proot_stack.rlim_cur >= tracee_stack_limit)
		return 0;

	proot_stack.rlim_cur = tracee_stack_limit;

	/* Increase current PRoot's stack limit.  */
	status = prlimit(0, RLIMIT_STACK, &proot_stack, NULL);
	if (status < 0)
		VERBOSE(tracee, 1, "can't set stack limit.");
	return 0; /* Not fatal.  */

	VERBOSE(tracee, 1, "stack soft limit increased to %ld bytes", proot_stack.rlim_cur);
	return 0;
}

```

`library/src/main/jni/syscall/rlimit.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef RLIMIT_H
#define RLIMIT_H

#include <stdbool.h>
#include "tracee/tracee.h"

extern int translate_setrlimit_exit(const Tracee *tracee, bool is_prlimit);

#endif /* RLIMIT_H */

```

`library/src/main/jni/syscall/seccomp.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include "build.h"
#include "arch.h"
#define HAVE_SECCOMP_FILTER

#if defined(HAVE_SECCOMP_FILTER)

#include <sys/prctl.h>     /* prctl(2), PR_* */
#include <linux/filter.h>  /* struct sock_*, */
#include <linux/seccomp.h> /* SECCOMP_MODE_FILTER, */
#include <linux/filter.h>  /* struct sock_*, */
#include <linux/audit.h>   /* AUDIT_, */
#include <sys/queue.h>     /* LIST_FOREACH, */
#include <sys/types.h>     /* size_t, */
//#include <talloc.h>        /* talloc_*, */
#include <errno.h>         /* E*, */
#include <string.h>        /* memcpy(3), */
#include <stddef.h>        /* offsetof(3), */
#include <stdint.h>        /* uint*_t, UINT*_MAX, */
#include <assert.h>        /* assert(3), */
#include <stdlib.h>

#include "syscall/seccomp.h"
#include "tracee/tracee.h"
#include "syscall/syscall.h"
#include "syscall/sysnum.h"
//#include "extension/extension.h"
//#include "cli/note.h"
#include "cmn/cmn_vlarray.h"

#include "compat.h"
#include "attribute.h"
#include "constant.h"

#define DEBUG_FILTER(...) /* fprintf(stderr, __VA_ARGS__) */

//libc的地址区间
static uintptr_t libc_start = -1;
static uintptr_t libc_end = -1;
static bool s_exclude_libc = true;
/**
 * Allocate an empty @program->filter.  This function returns -errno
 * if an error occurred, otherwise 0.
 */
static int new_program_filter(struct sock_fprog *program)
{
	//分配一个长度为0的数组
//	program->filter = talloc_array(NULL, struct sock_filter, 0);
	program->filter = vl_new_array(sizeof(struct  sock_filter),0);
	if (program->filter == NULL)
		return -ENOMEM;

	program->len = 0;
	return 0;
}

/**
 * Append to @program->filter the given @statements (@nb_statements
 * items).  This function returns -errno if an error occurred,
 * otherwise 0.
 */
static int add_statements(struct sock_fprog *program, size_t nb_statements,
			struct sock_filter *statements)
{
	size_t length;
	void *tmp;
	size_t i;
	//获取program->filter数组的当前长度
//	length = talloc_array_length(program->filter);
	//改变program->filter数组的长度为length + nb_statements,返回新的数组为tmp
//	tmp  = talloc_realloc(NULL, program->filter, struct sock_filter, length + nb_statements);

	length = vl_array_length(program->filter);
	tmp = vl_array_realloc(program->filter, sizeof(struct sock_filter),length + nb_statements);
	if (tmp == NULL)
		return -ENOMEM;
	program->filter = tmp;

	for (i = 0; i < nb_statements; i++, length++)
		memcpy(&program->filter[length], &statements[i], sizeof(struct sock_filter));

	return 0;
}

/**
 * Append to @program->filter the statements required to notify PRoot
 * about the given @syscall made by a tracee, with the given @flag.
 * This function returns -errno if an error occurred, otherwise 0.
 */
static int add_trace_syscall(struct sock_fprog *program, word_t syscall, int flag)
{
	int status;

	/* Sanity check.  */
	if (syscall > UINT32_MAX)
		return -ERANGE;

	#define LENGTH_TRACE_SYSCALL 2
	struct sock_filter statements[LENGTH_TRACE_SYSCALL] = {
		/* Compare the accumulator with the expected syscall:
		 * skip the next statement if not equal.  */
		BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, syscall, 0, 1),

		/* Notify the tracer.  */
		BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_TRACE + flag)
	};

	DEBUG_FILTER("FILTER:     trace if syscall == %ld\n", syscall);

	status = add_statements(program, LENGTH_TRACE_SYSCALL, statements);
	if (status < 0)
		return status;

	return 0;
}

/**
 * Append to @program->filter the statements that allow anything (if
 * unfiltered).  Note that @nb_traced_syscalls is used to make a
 * sanity check.  This function returns -errno if an error occurred,
 * otherwise 0.
 */
static int end_arch_section(struct sock_fprog *program, size_t nb_traced_syscalls)
{
    LOGSECOMP("end_arch_section")
	int status;

	#define LENGTH_END_SECTION 1
	struct sock_filter statements[LENGTH_END_SECTION] = {
		BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)
	};

	DEBUG_FILTER("FILTER:     allow\n");

	status = add_statements(program, LENGTH_END_SECTION, statements);
	if (status < 0)
		return status;

	/* Sanity check, see start_arch_section().  */
//	if (   talloc_array_length(program->filter) - program->len
//	    != LENGTH_END_SECTION + nb_traced_syscalls * LENGTH_TRACE_SYSCALL)
//		return -ERANGE;
	if (   vl_array_length(program->filter) - program->len
		   != LENGTH_END_SECTION + nb_traced_syscalls * LENGTH_TRACE_SYSCALL)
		return -ERANGE;

	return 0;
}

/**
 * Append to @program->filter the statements that check the current
 * @architecture.  Note that @nb_traced_syscalls is used to make a
 * sanity check.  This function returns -errno if an error occurred,
 * otherwise 0.
 */
static int start_arch_section(struct sock_fprog *program, uint32_t arch, size_t nb_traced_syscalls)
{
	const size_t arch_offset    = offsetof(struct seccomp_data, arch);
	const size_t syscall_offset = offsetof(struct seccomp_data, nr);
	const size_t section_length = LENGTH_END_SECTION +
					nb_traced_syscalls * LENGTH_TRACE_SYSCALL;
	int status;

	/* Sanity checks.  */
	if (   arch_offset    > UINT32_MAX
	    || syscall_offset > UINT32_MAX
	    || section_length > UINT32_MAX - 1)
		return -ERANGE;

    if (s_exclude_libc){
        LOGSECOMP("seccomp: exclude libc----------")
        #define LENGTH_START_SECTION 9
        struct sock_filter exclude_statements[LENGTH_START_SECTION] = {
				/* Load the current architecture into the
 				 * accumulator.  */
				BPF_STMT(BPF_LD + BPF_W + BPF_ABS, arch_offset),

				/* Compare the accumulator with the expected
                 * architecture: skip the following statement if
                 * equal.  */
				BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arch, 1, 0),

				/* This is not the expected architecture, so jump
                 * unconditionally to the end of this section.  */
//				BPF_STMT(BPF_JMP + BPF_JA + BPF_K, section_length + 4),
                BPF_STMT(BPF_JMP + BPF_JA + BPF_K, 4),

				/* This is the expected architecture, so load the
                 * current syscall into the accumulator.  */
//				BPF_STMT(BPF_LD + BPF_W + BPF_ABS, syscall_offset)
				//筛选 libc之外的通知
                BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, instruction_pointer)),
                BPF_JUMP(BPF_JMP + BPF_JGT + BPF_K, libc_end, 0, 1), //>= libc_end
				BPF_STMT(BPF_JMP + BPF_JA + BPF_K, 2), //往下跳几行，是我们关心的
                BPF_JUMP(BPF_JMP + BPF_JGE + BPF_K, libc_start, 0, 1), // <= libc_end
				BPF_STMT(BPF_JMP + BPF_JA + BPF_K, section_length), //我们不关心的
				BPF_STMT(BPF_LD + BPF_W + BPF_ABS, syscall_offset) //我们关心的分支
        };
        status = add_statements(program, LENGTH_START_SECTION, exclude_statements);
        if (status < 0)
            return status;
    }else{
        #undef LENGTH_START_SECTION
		#define LENGTH_START_SECTION 4
		struct sock_filter statements[LENGTH_START_SECTION] = {
				/* Load the current architecture into the
                 * accumulator.  */
				BPF_STMT(BPF_LD + BPF_W + BPF_ABS, arch_offset),

				/* Compare the accumulator with the expected
                 * architecture: skip the following statement if
                 * equal.  */
				BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arch, 1, 0),

				/* This is not the expected architecture, so jump
                 * unconditionally to the end of this section.  */
				BPF_STMT(BPF_JMP + BPF_JA + BPF_K, section_length + 1),

				/* This is the expected architecture, so load the
                 * current syscall into the accumulator.  */
				BPF_STMT(BPF_LD + BPF_W + BPF_ABS, syscall_offset)
		};

		DEBUG_FILTER("FILTER: if arch == %ld, up to %zdth statement\n",
					 arch, nb_traced_syscalls);

		status = add_statements(program, LENGTH_START_SECTION, statements);
		if (status < 0)
			return status;
	}

	/* See the sanity check in end_arch_section().  */
//	program->len = talloc_array_length(program->filter);
	program->len = vl_array_length(program->filter);
	return 0;
}

/**
 * Append to @program->filter the statements that forbid anything (if
 * unfiltered) and update @program->len.  This function returns -errno
 * if an error occurred, otherwise 0.
 */
static int finalize_program_filter(struct sock_fprog *program)
{
	int status;

	#define LENGTH_FINALIZE 1
	struct sock_filter statements[LENGTH_FINALIZE] = {
		BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL)
	};

	DEBUG_FILTER("FILTER: kill\n");

	status = add_statements(program, LENGTH_FINALIZE, statements);
	if (status < 0)
		return status;

//	program->len = talloc_array_length(program->filter);
	program->len = vl_array_length(program->filter);
	return 0;
}

/**
 * Free @program->filter and set @program->len to 0.
 */
static void free_program_filter(struct sock_fprog *program)
{
//	TALLOC_FREE(program->filter);
	vl_array_free(program->filter);
	program->len = 0;
}

/**
 * Convert the given @sysnums into BPF filters according to the
 * following pseudo-code, then enabled them for the given @tracee and
 * all of its future children:
 *
 *     for each handled architectures
 *         for each filtered syscall
 *             trace
 *         allow
 *     kill
 *
 * This function returns -errno if an error occurred, otherwise 0.
 */
static int set_seccomp_filters(const FilteredSysnum *sysnums)
{
	SeccompArch seccomp_archs[] = SECCOMP_ARCHS;
	size_t nb_archs = sizeof(seccomp_archs) / sizeof(SeccompArch);

	struct sock_fprog program = { .len = 0, .filter = NULL };
	size_t nb_traced_syscalls;
	size_t i, j, k;
	int status;

	status = new_program_filter(&program);
	if (status < 0)
		goto end;

	/* For each handled architectures */
	for (i = 0; i < nb_archs; i++) {
		word_t syscall;

		nb_traced_syscalls = 0;

		/* Pre-compute the number of traced syscalls for this architecture.  */
		for (j = 0; j < seccomp_archs[i].nb_abis; j++) {
			for (k = 0; sysnums[k].value != PR_void; k++) {
				syscall = detranslate_sysnum(seccomp_archs[i].abis[j], sysnums[k].value);
				if (syscall != SYSCALL_AVOIDER)
					nb_traced_syscalls++;
			}
		}

		/* Filter: if handled architecture */
		status = start_arch_section(&program, seccomp_archs[i].value, nb_traced_syscalls);
		if (status < 0)
			goto end;

		for (j = 0; j < seccomp_archs[i].nb_abis; j++) {
			LOGSECOMP("secomp: set_seccomp_filters abi:%d",seccomp_archs[i].abis[j])
			for (k = 0; sysnums[k].value != PR_void; k++) {
				/* Get the architecture specific syscall number.  */
				syscall = detranslate_sysnum(seccomp_archs[i].abis[j], sysnums[k].value);
				if (syscall == SYSCALL_AVOIDER)
					continue;

				/* Filter: trace if handled syscall */
				LOGSECOMP("secomp: set_seccomp_filters 2 abi:%d,syscall:%lu",seccomp_archs[i].abis[j],syscall)
				status = add_trace_syscall(&program, syscall, sysnums[k].flags);
				if (status < 0)
					goto end;
			}
		}

		/* Filter: allow untraced syscalls for this architecture */
		status = end_arch_section(&program, nb_traced_syscalls);
		if (status < 0)
			goto end;
	}

	status = finalize_program_filter(&program);
	if (status < 0)
		goto end;

	status = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
	if (status < 0)
		goto end;

	/* To output this BPF program for debug purpose:
	 *
	 *     write(2, program.filter, program.len * sizeof(struct sock_filter));
	 */
    LOGSECOMP("secomp: before set---")
	status = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &program);
	if (status < 0)
		goto end;

	status = 0;
end:
	free_program_filter(&program);
	return status;
}

/* List of sysnums handled by PRoot.  */
static FilteredSysnum proot_sysnums[] = {
	{ PR_accept,		FILTER_SYSEXIT },
	{ PR_accept4,		FILTER_SYSEXIT },
	{ PR_access,		0 },
	{ PR_acct,		0 },
	{ PR_bind,		0 },
	{ PR_brk,		FILTER_SYSEXIT },
	{ PR_chdir,		FILTER_SYSEXIT },
	{ PR_chmod,		0 },
	{ PR_chown,		0 },
	{ PR_chown32,		0 },
	{ PR_chroot,		0 },
	{ PR_connect,		0 },
	{ PR_creat,		0 },
	{ PR_execve,		FILTER_SYSEXIT },
	{ PR_faccessat,		0 },
	{ PR_fchdir,		FILTER_SYSEXIT },
	{ PR_fchmodat,		0 },
	{ PR_fchownat,		0 },
	{ PR_fstatat64,		0 },
	{ PR_futimesat,		0 },
	{ PR_getcwd,		FILTER_SYSEXIT },
	{ PR_getpeername,	FILTER_SYSEXIT },
	{ PR_getsockname,	FILTER_SYSEXIT },
	{ PR_getxattr,		0 },
	{ PR_inotify_add_watch,	0 },
	{ PR_lchown,		0 },
	{ PR_lchown32,		0 },
	{ PR_lgetxattr,		0 },
	{ PR_link,		0 },
	{ PR_linkat,		0 },
	{ PR_listxattr,		0 },
	{ PR_llistxattr,	0 },
	{ PR_lremovexattr,	0 },
	{ PR_lsetxattr,		0 },
	{ PR_lstat,		0 },
	{ PR_lstat64,		0 },
	{ PR_mkdir,		0 },
	{ PR_mkdirat,		0 },
	{ PR_mknod,		0 },
	{ PR_mknodat,		0 },
	{ PR_mount,		0 },
	{ PR_name_to_handle_at,	0 },
	{ PR_newfstatat,	0 },
	{ PR_oldlstat,		0 },
	{ PR_oldstat,		0 },
	{ PR_open,		0 },
	{ PR_openat,		0 },
	{ PR_close,		0 }, //添加针对close系统调用的监听
	{ PR_pivot_root,	0 },
	{ PR_prctl, 		0 },
	{ PR_prlimit64,		FILTER_SYSEXIT },
	{ PR_ptrace,		FILTER_SYSEXIT },
	{ PR_readlink,		FILTER_SYSEXIT },
	{ PR_readlinkat,	FILTER_SYSEXIT },
	{ PR_removexattr,	0 },
	{ PR_rename,		FILTER_SYSEXIT },
	{ PR_renameat,		FILTER_SYSEXIT },
	{ PR_renameat2,		FILTER_SYSEXIT },
	{ PR_rmdir,		0 },
	{ PR_setrlimit,		FILTER_SYSEXIT },
	{ PR_setxattr,		0 },
	{ PR_socketcall,	FILTER_SYSEXIT },
	{ PR_stat,		0 },
	{ PR_statx,		0 },
	{ PR_faccessat2,	0 },
	{ PR_stat64,		0 },
	{ PR_statfs,		0 },
	{ PR_statfs64,		0 },
	{ PR_swapoff,		0 },
	{ PR_swapon,		0 },
	{ PR_symlink,		0 },
	{ PR_symlinkat,		0 },
	{ PR_truncate,		0 },
	{ PR_truncate64,	0 },
	{ PR_umount,		0 },
	{ PR_umount2,		0 },
	{ PR_uname,		FILTER_SYSEXIT },
	{ PR_unlink,		0 },
	{ PR_unlinkat,		0 },
	{ PR_uselib,		0 },
	{ PR_utime,		0 },
	{ PR_utimensat,		0 },
	{ PR_utimes,		0 },
	{ PR_wait4,		FILTER_SYSEXIT },
	{ PR_waitpid,		FILTER_SYSEXIT },
	FILTERED_SYSNUM_END,
};

/**
 * Add the @new_sysnums to the list of filtered @sysnums, using the
 * given Talloc @context.  This function returns -errno if an error
 * occurred, otherwise 0.
 */
//static int merge_filtered_sysnums(void *context, FilteredSysnum **sysnums,
//				const FilteredSysnum *new_sysnums)
static int merge_filtered_sysnums(FilteredSysnum **sysnums,
								  const FilteredSysnum *new_sysnums)
{
	size_t i, j;

	assert(sysnums != NULL);

	if (*sysnums == NULL) {
		/* Start with no sysnums but the terminator.  */
//		*sysnums = talloc_array(context, FilteredSysnum, 1);
		LOGSECOMP("secomp: merge_filtered_sysnums 1")
		*sysnums = vl_new_array(sizeof(FilteredSysnum), 1);
		if (*sysnums == NULL)
			return -ENOMEM;

		(*sysnums)[0].value = PR_void;
	}

	for (i = 0; new_sysnums[i].value != PR_void; i++) {
		LOGSECOMP("secomp: merge_filtered_sysnums 2,val:%d",new_sysnums[i].value)
		/* Search for the given sysnum.  */
		for (j = 0; (*sysnums)[j].value != PR_void
			 && (*sysnums)[j].value != new_sysnums[i].value; j++)
			;

		if ((*sysnums)[j].value == PR_void) {
			/* No such sysnum, allocate a new entry.  */
//			(*sysnums) = talloc_realloc(context, (*sysnums), FilteredSysnum, j + 2);
			(*sysnums) = vl_array_realloc((*sysnums), sizeof(FilteredSysnum), j + 2);
			if ((*sysnums) == NULL)
				return -ENOMEM;

			(*sysnums)[j] = new_sysnums[i];

			/* The last item is the terminator.  */
			(*sysnums)[j + 1].value = PR_void;
		}
		else
			/* The sysnum is already filtered, merge the
			 * flags.  */
			(*sysnums)[j].flags |= new_sysnums[i].flags;
	}

	return 0;
}

static void find_libc_exec_maps(){
	LOGD("find_libc_exec_maps-----")
	FILE *fp;
    if(NULL == (fp = fopen("/proc/self/maps", "r")))
	{
		LOGE("fopen /proc/self/maps failed")
		return;
	}
	char line[2048];
	unsigned long offset = 0;
	while (fgets(line, sizeof(line), fp) != NULL) {
		unsigned long base, end, inode;
		base = end = inode = 0;
		int length = 0;

		char perms[5] = { 0, };
		if (sscanf (line,
					"%lx-%lx "
					"%4c "
					"%lx %*s %ld"
					"%n",
					&base,  &end,
					perms,
					&offset, &inode,
					&length) != 5) continue;

		if (perms[2] != 'x') continue;
		if (inode != 0) {
			char *p = strchr (line + length, '/');
			if (p != NULL) {
				*strchr(p, '\n') = '\0';
//				LOGD("zzz p:%s",p)
				if (strstr(p, "/libc.so") != NULL){
                    libc_start = base;
                    libc_end = end;
                    break;
                }
			}
		}
	}
    LOGI("find_libc_exec_maps libc start:%lx,end:%lx",libc_start,libc_end);
}

/**
 * Tell the kernel to trace only syscalls handled by PRoot and its
 * extensions.  This filter will be enabled for the given @tracee and
 * all of its future children.  This function returns -errno if an
 * error occurred, otherwise 0.
 */
int enable_syscall_filtering(const Tracee *tracee,FilteredSysnum* add_filtered_sysnums,bool exclude_libc)
{
    s_exclude_libc = exclude_libc;
	LOGD("enable_syscall_filtering,%d",s_exclude_libc);
	if (s_exclude_libc){
		find_libc_exec_maps();
	}
	FilteredSysnum *filtered_sysnums = NULL;
//	Extension *extension;
	int status;

//	assert(tracee != NULL && tracee->ctx != NULL);
	assert(tracee != NULL);
    LOGSECOMP("secomp: enable_syscall_filtering add print:")
    for (int i = 0; add_filtered_sysnums[i].value != PR_void; i++) {
        LOGSECOMP("secomp: enable_syscall_filtering add,%d,%d",i,add_filtered_sysnums[i].value)
    }
    LOGSECOMP("secomp: enable_syscall_filtering add print end")

    bool sysnum_map[512] = {0};
    int count = 0;
    for (int i = 0; add_filtered_sysnums[i].value != PR_void; i++) {
        sysnum_map[add_filtered_sysnums[i].value] = 1;
        count++;
    }
    FilteredSysnum internal_sysnums[] = {
            { PR_ptrace,		FILTER_SYSEXIT },
            { PR_wait4,		FILTER_SYSEXIT },
            { PR_waitpid,		FILTER_SYSEXIT },
            { PR_execve,		FILTER_SYSEXIT },
            { PR_execveat,		FILTER_SYSEXIT },
			{PR_readlinkat,FILTER_SYSEXIT},
    };

    int max_size = count + sizeof(internal_sysnums)/
                           sizeof(FilteredSysnum) + 1;
    FilteredSysnum * filtered_add_internal_sysnums =  vl_new_array(sizeof(FilteredSysnum),max_size); //include PR_void
    for (int i = 0; i < count; ++i) {
        filtered_add_internal_sysnums[i].value = add_filtered_sysnums[i].value;
        filtered_add_internal_sysnums[i].flags = add_filtered_sysnums[i].flags;
    }
    LOGSECOMP("secomp: count:%d",count)
    for (int i = 0; i < sizeof(internal_sysnums)/sizeof(FilteredSysnum); ++i) {
        if (!sysnum_map[internal_sysnums[i].value]){
            filtered_add_internal_sysnums[count].value = internal_sysnums[i].value;
            filtered_add_internal_sysnums[count].flags = internal_sysnums[i].flags;
            LOGSECOMP("secomp: count:%d,i:%d,val:%d,flag:%lu",count,i,internal_sysnums[i].value,internal_sysnums[i].flags)
            count++;
        }
    }
    filtered_add_internal_sysnums[count].value = PR_void;
    filtered_add_internal_sysnums[count].value = 0;
	/* Add the sysnums required by PRoot to the list of filtered
	 * sysnums.  TODO: only if path translation is required.  */
//	status = merge_filtered_sysnums(tracee->ctx, &filtered_sysnums, proot_sysnums);
    LOGSECOMP("secomp: enable_syscall_filtering add2 print:")
    for (int i = 0; filtered_add_internal_sysnums[i].value != PR_void; i++) {
        LOGSECOMP("secomp: enable_syscall_filtering add2,%d,%d",i,filtered_add_internal_sysnums[i].value)
    }
    LOGSECOMP("secomp: enable_syscall_filtering add2 print end")
	status = merge_filtered_sysnums(&filtered_sysnums, filtered_add_internal_sysnums);
	if (status < 0){
        vl_array_free(filtered_add_internal_sysnums);
        LOGE("secomp: enable_syscall_filtering fail 1,%d",status)
		return status;
	}


	/* Merge the sysnums required by the extensions to the list
	 * of filtered sysnums.  */
//	if (tracee->extensions != NULL) {
//		LIST_FOREACH(extension, tracee->extensions, link) {
//			if (extension->filtered_sysnums == NULL)
//				continue;
//
//			status = merge_filtered_sysnums(tracee->ctx, &filtered_sysnums,
//							extension->filtered_sysnums);
//			if (status < 0)
//				return status;
//		}
//	}

	status = set_seccomp_filters(filtered_sysnums);
    vl_array_free(filtered_add_internal_sysnums);
    if (status < 0){
		LOGE("secomp: enable_syscall_filtering fail 2,%d",status)
		return status;
	}

	LOGD("secomp: enable_syscall_filtering success")
	return 0;
}

#else

#include "tracee/tracee.h"
#include "attribute.h"

int enable_syscall_filtering(const Tracee *tracee UNUSED)
{
	return 0;
}

#endif /* defined(HAVE_SECCOMP_FILTER) */

```

`library/src/main/jni/syscall/seccomp.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef SECCOMP_H
#define SECCOMP_H

#include "syscall/sysnum.h"
#include "tracee/tracee.h"
#include "attribute.h"
#include "arch.h"

typedef struct {
	Sysnum value;
	word_t flags;
} FilteredSysnum;

typedef struct {
	unsigned int value;
	size_t nb_abis;
	Abi abis[NB_MAX_ABIS];
} SeccompArch;

#define FILTERED_SYSNUM_END { PR_void, 0 }

#define FILTER_SYSEXIT  0x1

extern int enable_syscall_filtering(const Tracee *tracee,FilteredSysnum* add_filtered_sysnums,bool exclude_libc);

#endif /* SECCOMP_H */

```

`library/src/main/jni/syscall/socket.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <stddef.h>      /* offsetof(3), */
#include <strings.h>     /* bzero(3), */
#include <string.h>      /* strncpy(3), strlen(3), */
#include <assert.h>      /* assert(3), */
#include <errno.h>       /* E*, */
#include <sys/socket.h>  /* struct sockaddr_un, AF_UNIX, */
#include <sys/un.h>      /* struct sockaddr_un, */
#include <sys/param.h>   /* MIN(), MAX(), */

#include "syscall/socket.h"
#include "tracee/tracee.h"
#include "tracee/mem.h"
#include "path/binding.h"
#include "path/temp.h"
#include "path/path.h"
#include "arch.h"

#include "compat.h"

/* The sockaddr_un structure has exactly the same layout on all
 * architectures.  */
static const off_t offsetof_path = offsetof(struct sockaddr_un, sun_path);
extern struct sockaddr_un sockaddr_un__;
static const size_t sizeof_path  = sizeof(sockaddr_un__.sun_path);

/**
 * Copy in @sockaddr the struct sockaddr_un stored in the @tracee
 * memory at the given @address.  Also, its pathname is copied to the
 * null-terminated @path.  Only @size bytes are read from the @tracee
 * memory (should be <= @max_size <= sizeof(struct sockaddr_un)).
 * This function returns -errno if an error occurred, 0 if the
 * structure was not found (not a sockaddr_un or @size > @max_size),
 * otherwise 1.
 */
static int read_sockaddr_un(Tracee *tracee, struct sockaddr_un *sockaddr, word_t max_size,
			char path[PATH_MAX], word_t address, int size)
{
	int status;

	assert(max_size <= sizeof(struct sockaddr_un));

	/* Nothing to do if the sockaddr has an unexpected size.  */
	if (size <= offsetof_path || (word_t) size > max_size)
		return 0;

	bzero(sockaddr, sizeof(struct sockaddr_un));
	status = read_data(tracee, sockaddr, address, size);
	if (status < 0)
		return status;

	/* Nothing to do if it's not a named Unix domain socket.  */
	if ((sockaddr->sun_family != AF_UNIX)
	    || sockaddr->sun_path[0] == '\0')
		return 0;

	/* Be careful: sun_path doesn't have to be null-terminated.  */
	assert(sizeof_path < PATH_MAX - 1);
	strncpy(path, sockaddr->sun_path, sizeof_path);
	path[sizeof_path] = '\0';

	return 1;
}

/**
 * Translate the pathname of the struct sockaddr_un currently stored
 * in the @tracee memory at the given @address.  See the documentation
 * of read_sockaddr_un() for the meaning of the @size parameter.
 * Also, the new address of the translated sockaddr_un is put in the
 * @address parameter.  This function returns -errno if an error
 * occurred, otherwise 0.
 */
int translate_socketcall_enter(Tracee *tracee, word_t *address, int size)
{
	struct sockaddr_un sockaddr;
	char user_path[PATH_MAX];
	char host_path[PATH_MAX];
	int status;

	if (*address == 0)
		return 0;

	status = read_sockaddr_un(tracee, &sockaddr, sizeof(sockaddr), user_path, *address, size);
	if (status <= 0)
		return status;

	status = translate_path(tracee, host_path, AT_FDCWD, user_path, true);
	if (status < 0)
		return status;

	/* Be careful: sun_path doesn't have to be null-terminated.  */
	if (strlen(host_path) > sizeof_path) {
		const char *shorter_host_dir;
		const char *shorter_host_path;
		Binding *binding;

		/* Ensure the guest path of this new binding is
		 * canonicalized, as it is always assumed.  */
		strcpy(user_path, host_path);
		status = detranslate_path(tracee, user_path, NULL);
		if (status < 0)
			return -EINVAL;

		/* The translated path is too long to fit the sun_path
		 * array, so let's bind it to a shorter path.  */
		shorter_host_dir = create_temp_directory(tracee->ctx, "proot");
		if (shorter_host_dir == NULL)
			return -EINVAL;

		shorter_host_path = talloc_asprintf(tracee->ctx, "%s/s", shorter_host_dir);
		if (strlen(shorter_host_path) > sizeof_path)
			return -EINVAL;

		/* Bing the guest path to a shorter host path.  */
		binding = insort_binding3(tracee, tracee->ctx, shorter_host_path, user_path);
		if (binding == NULL)
			return -EINVAL;

		/* This temporary file (shorter_host_path) will be removed once the
		 * binding is destroyed.  */
		talloc_reparent(tracee->ctx, binding, shorter_host_dir);
		talloc_reparent(tracee->ctx, binding, shorter_host_path);

		/* Let's use this shorter path now.  */
		strcpy(host_path, shorter_host_path);
	}
	strncpy(sockaddr.sun_path, host_path, sizeof_path);

	/* Push the updated sockaddr to a newly allocated space.  */
	*address = alloc_mem(tracee, sizeof(sockaddr));
	if (*address == 0)
		return -EFAULT;

	status = write_data(tracee, *address, &sockaddr, sizeof(sockaddr));
	if (status < 0)
		return status;

	return 1;
}

/**
 * Detranslate the pathname of the struct sockaddr_un currently stored
 * in the @tracee memory at the given @sock_addr.  See the
 * documentation of read_sockaddr_un() for the meaning of the
 * @size_addr and @max_size parameters.  This function returns -errno
 * if an error occurred, otherwise 0.
 */
int translate_socketcall_exit(Tracee *tracee, word_t sock_addr, word_t size_addr, word_t max_size)
{
	struct sockaddr_un sockaddr;
	bool is_truncated = false;
	char path[PATH_MAX];
	int status;
	int size;

	if (sock_addr == 0)
		return 0;

	size = peek_int32(tracee, size_addr);
	if (errno != 0)
		return -errno;

	max_size = MIN(max_size, sizeof(sockaddr));
	status = read_sockaddr_un(tracee, &sockaddr, max_size, path, sock_addr, size);
	if (status <= 0)
		return status;

	status = detranslate_path(tracee, path, NULL);
	if (status < 0)
		return status;

	/* Be careful: sun_path doesn't have to be null-terminated.  */
	size = offsetof_path + strlen(path) + 1;
	if (size < 0 || (word_t) size > max_size) {
		size = max_size;
		is_truncated = true;
	}
	strncpy(sockaddr.sun_path, path, sizeof_path);

	/* Overwrite the sockaddr and socklen parameters.  */
	status = write_data(tracee, sock_addr, &sockaddr, size);
	if (status < 0)
		return status;

	/* If sockaddr is truncated (because the buffer provided is
	 * too small), addrlen will return a value greater than was
	 * supplied to the call.  See man 2 accept. */
	if (is_truncated)
		size = max_size + 1;

	poke_int32(tracee, size_addr, size);
	if (errno != 0)
		return -errno;

	return 0;
}

```

`library/src/main/jni/syscall/socket.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef SOCKET_H
#define SOCKET_H

#include "arch.h" /* word_t */
#include "tracee/tracee.h"

int translate_socketcall_enter(Tracee *tracee, word_t *sock_addr, int size);
int translate_socketcall_exit(Tracee *tracee, word_t sock_addr, word_t size_addr, word_t max_size);

#endif /* SOCKET_H */

```

`library/src/main/jni/syscall/syscall.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <assert.h>      /* assert(3), */
#include <limits.h>      /* PATH_MAX, */
#include <string.h>      /* strlen(3), */
#include <errno.h>       /* errno(3), E* */

#include "syscall/syscall.h"
#include "syscall/chain.h"
//#include "extension/extension.h"
#include "tracee/tracee.h"
#include "tracee/reg.h"
#include "tracee/mem.h"
#include "constant.h"

/**
 * Copy in @path a C string (PATH_MAX bytes max.) from the @tracee's
 * memory address space pointed to by the @reg argument of the
 * current syscall.  This function returns -errno if an error occured,
 * otherwise it returns the size in bytes put into the @path.
 */
int get_sysarg_path(const Tracee *tracee, char path[PATH_MAX], Reg reg)
{
	int size;
	word_t src;

	src = peek_reg(tracee, CURRENT, reg);

	/* Check if the parameter is not NULL. Technically we should
	 * not return an -EFAULT for this special value since it is
	 * allowed for some syscall, utimensat(2) for instance. */
	if (src == 0) {
		path[0] = '\0';
		return 0;
	}

	/* Get the path from the tracee's memory space. */
	size = read_path(tracee, path, src);
	if (size < 0)
		return size;

	path[size] = '\0';
	return size;
}

/**
 * Copy @size bytes of the data pointed to by @tracer_ptr into a
 * @tracee's memory block and make the @reg argument of the current
 * syscall points to this new block.  This function returns -errno if
 * an error occured, otherwise 0.
 */
int set_sysarg_data(Tracee *tracee, const void *tracer_ptr, word_t size, Reg reg)
{
	word_t tracee_ptr;
	int status;

	/* Allocate space into the tracee's memory to host the new data. */
	tracee_ptr = alloc_mem(tracee, size);
	if (tracee_ptr == 0)
		return -EFAULT;

	/* Copy the new data into the previously allocated space. */
	status = write_data(tracee, tracee_ptr, tracer_ptr, size);
	if (status < 0)
		return status;

	/* Make this argument point to the new data. */
	poke_reg(tracee, reg, tracee_ptr);

	return 0;
}

/**
 * Copy @path to a @tracee's memory block and make the @reg argument
 * of the current syscall points to this new block.  This function
 * returns -errno if an error occured, otherwise 0.
 */
int set_sysarg_path(Tracee *tracee, const char path[PATH_MAX], Reg reg)
{
	return set_sysarg_data(tracee, path, strlen(path) + 1, reg);
}

void translate_syscall(Tracee *tracee)
{
	const bool is_enter_stage = IS_IN_SYSENTER(tracee);
	int status;

	//assert(tracee->exe != NULL);

	status = fetch_regs(tracee);
	if (status < 0)
		return;

	if (is_enter_stage) {
		/* Never restore original register values at the end
		 * of this stage.  */
		tracee->restore_original_regs = false;
#if defined(ENABLE_LOG)
		print_current_regs(tracee, 3, "sysenter start");
#endif
		/* Translate the syscall only if it was actually
		 * requested by the tracee, it is not a syscall
		 * chained by PRoot.  */
		if (__LIKELY(tracee->chain.syscalls == NULL)) {
			save_current_regs(tracee, ORIGINAL);
            if (__LIKELY(global_on_sysenter != NULL)){
                syscall_data data;
				data.sysnum = get_sysnum(tracee, CURRENT);
				data.tracee_pid = (tracee->parent != NULL? tracee->parent->pid : tracee->pid);
                data._internal = tracee;
				data.user_context_data = NULL;
                global_on_sysenter(&data);
				tracee->user_context_data = data.user_context_data;
            }
			status = translate_syscall_enter(tracee);
			save_current_regs(tracee, MODIFIED);
		}
		else {
//			status = notify_extensions(tracee, SYSCALL_CHAINED_ENTER, 0, 0);
			tracee->restart_how = PTRACE_SYSCALL;
		}

		/* Remember the tracee status for the "exit" stage and
		 * avoid the actual syscall if an error was reported
		 * by the translation/extension. */
		if (status < 0) {
			set_sysnum(tracee, PR_void);
			poke_reg(tracee, SYSARG_RESULT, (word_t) status);
			tracee->status = status;
		}
		else
			tracee->status = 1;

		/* Restore tracee's stack pointer now if it won't hit
		 * the sysexit stage (i.e. when seccomp is enabled and
		 * there's nothing else to do).  */
		if (tracee->restart_how == PTRACE_CONT) {
			tracee->status = 0;
			poke_reg(tracee, STACK_POINTER, peek_reg(tracee, ORIGINAL, STACK_POINTER));
		}
	}
	else {
		/* By default, restore original register values at the
		 * end of this stage.  */
		tracee->restore_original_regs = true;
#if defined(ENABLE_LOG)
		print_current_regs(tracee, 5, "sysexit start");
#endif
        if (__LIKELY(global_on_sysexit != NULL)){
            syscall_data data;
			data.sysnum = get_sysnum(tracee, CURRENT);
			data.tracee_pid = (tracee->parent != NULL? tracee->parent->pid : tracee->pid);
            data._internal = tracee;
			data.user_context_data = tracee->user_context_data;
            global_on_sysexit(&data);
        }

		/* Translate the syscall only if it was actually
		 * requested by the tracee, it is not a syscall
		 * chained by PRoot.  */
		if (__LIKELY(tracee->chain.syscalls == NULL))
			translate_syscall_exit(tracee);
//		else
//			(void) notify_extensions(tracee, SYSCALL_CHAINED_EXIT, 0, 0);

		/* Reset the tracee's status. */
		tracee->status = 0;

		/* Insert the next chained syscall, if any.  */
		if (__UNLIKELY(tracee->chain.syscalls != NULL))
			chain_next_syscall(tracee);
	}

	(void) push_regs(tracee);

#if defined(ENABLE_LOG)
	if (is_enter_stage)
		print_current_regs(tracee, 5, "sysenter end" );
	else
		print_current_regs(tracee, 4, "sysexit end");
#endif
}

```

`library/src/main/jni/syscall/syscall.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef SYSCALL_H
#define SYSCALL_H

#include <limits.h>     /* PATH_MAX, */

#include "tracee/tracee.h"
#include "tracee/reg.h"

extern int get_sysarg_path(const Tracee *tracee, char path[PATH_MAX], Reg reg);
extern int set_sysarg_path(Tracee *tracee, const char path[PATH_MAX], Reg reg);

extern int set_sysarg_data(Tracee *tracee, const void *tracer_ptr, word_t size, Reg reg);

extern void translate_syscall(Tracee *tracee);
extern int  translate_syscall_enter(Tracee *tracee);
extern void translate_syscall_exit(Tracee *tracee);

#endif /* SYSCALL_H */

```

`library/src/main/jni/syscall/sysnum.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <assert.h>

#include "syscall/sysnum.h"
#include "tracee/tracee.h"
#include "tracee/abi.h"
#include "tracee/reg.h"
#include "arch.h"
//#include "cli/note.h"

#include SYSNUMS_HEADER1

#ifdef SYSNUMS_HEADER2
#include SYSNUMS_HEADER2
#endif

#ifdef SYSNUMS_HEADER3
#include SYSNUMS_HEADER3
#endif

typedef struct {
	const Sysnum *table;
	word_t offset;
	word_t length;
} Sysnums;

/**
 * Update @sysnums' fields with the sysnum table for the given @abi.
 */
static void get_sysnums(Abi abi, Sysnums *sysnums)
{
	switch (abi) {
	case ABI_DEFAULT:
		sysnums->table  = SYSNUMS_ABI1;
		sysnums->length = sizeof(SYSNUMS_ABI1) / sizeof(Sysnum);
		sysnums->offset = 0;
		return;
#ifdef SYSNUMS_ABI2
	case ABI_2:
		sysnums->table  = SYSNUMS_ABI2;
		sysnums->length = sizeof(SYSNUMS_ABI2) / sizeof(Sysnum);
		sysnums->offset = 0;
		return;
#endif
#ifdef SYSNUMS_ABI3
	case ABI_3:
		sysnums->table  = SYSNUMS_ABI3;
		sysnums->length = sizeof(SYSNUMS_ABI3) / sizeof(Sysnum);
		sysnums->offset = 0x40000000; /* x32 */
		return;
#endif
	default:
		assert(0);
	}
}

/**
 * Return the neutral value of @sysnum from the given @abi.
 */
static Sysnum translate_sysnum(Abi abi, word_t sysnum)
{
	Sysnums sysnums;
	word_t index;

	get_sysnums(abi, &sysnums);

	/* Sanity checks.  */
	if (sysnum < sysnums.offset)
		return PR_void;

	index = sysnum - sysnums.offset;

	/* Sanity checks.  */
	if (index > sysnums.length)
		return PR_void;

	return sysnums.table[index];
}

/**
 * Return the architecture value of @sysnum for the given @abi.
 */
word_t detranslate_sysnum(Abi abi, Sysnum sysnum)
{
	Sysnums sysnums;
	size_t i;

	/* Very special case.  */
	if (sysnum == PR_void)
		return SYSCALL_AVOIDER;

	get_sysnums(abi, &sysnums);

	for (i = 0; i < sysnums.length; i++) {
		if (sysnums.table[i] != sysnum)
			continue;

		return i + sysnums.offset;
	}

	return SYSCALL_AVOIDER;
}

/**
 * Return the neutral value of the @tracee's current syscall number.
 */
Sysnum get_sysnum(const Tracee *tracee, RegVersion version)
{
	return translate_sysnum(get_abi(tracee), peek_reg(tracee, version, SYSARG_NUM));
}

/**
 * Overwrite the @tracee's current syscall number with @sysnum.  Note:
 * this neutral value is automatically converted into the architecture
 * value.
 */
void set_sysnum(Tracee *tracee, Sysnum sysnum)
{
	poke_reg(tracee, SYSARG_NUM, detranslate_sysnum(get_abi(tracee), sysnum));
}

/**
 * Return the human readable name of @sysnum.
 */
const char *stringify_sysnum(Sysnum sysnum)
{
	#define SYSNUM(item) [ PR_ ## item ] = #item,
	static const char *names[] = {
		#include "syscall/sysnums.list"
	};
	#undef SYSNUM

	if (sysnum == 0)
		return "void";

	if (sysnum >= PR_NB_SYSNUM)
		return "";

	return names[sysnum];
}

```

`library/src/main/jni/syscall/sysnum.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef SYSNUM_H
#define SYSNUM_H

#include <stdbool.h>

#include "tracee/tracee.h"
#include "tracee/abi.h"
#include "tracee/reg.h"

#define SYSNUM(item) PR_ ## item,
typedef enum {
	PR_void = 0,
	#include "syscall/sysnums.list"
	PR_NB_SYSNUM
} Sysnum;
#undef SYSNUM

extern Sysnum get_sysnum(const Tracee *tracee, RegVersion version);
extern void set_sysnum(Tracee *tracee, Sysnum sysnum);
extern word_t detranslate_sysnum(Abi abi, Sysnum sysnum);
extern const char *stringify_sysnum(Sysnum sysnum);

#endif /* SYSNUM_H */

```

`library/src/main/jni/syscall/sysnums-arm.h`:

```h
#include "syscall/sysnum.h"

static const Sysnum sysnums_arm[] = {
	[ 0 ] = PR_restart_syscall,
	[ 1 ] = PR_exit,
	[ 2 ] = PR_fork,
	[ 3 ] = PR_read,
	[ 4 ] = PR_write,
	[ 5 ] = PR_open,
	[ 6 ] = PR_close,
	[ 8 ] = PR_creat,
	[ 9 ] = PR_link,
	[ 10 ] = PR_unlink,
	[ 11 ] = PR_execve,
	[ 12 ] = PR_chdir,
	[ 14 ] = PR_mknod,
	[ 15 ] = PR_chmod,
	[ 16 ] = PR_lchown,
	[ 19 ] = PR_lseek,
	[ 20 ] = PR_getpid,
	[ 21 ] = PR_mount,
	[ 23 ] = PR_setuid,
	[ 24 ] = PR_getuid,
	[ 26 ] = PR_ptrace,
	[ 29 ] = PR_pause,
	[ 33 ] = PR_access,
	[ 34 ] = PR_nice,
	[ 36 ] = PR_sync,
	[ 37 ] = PR_kill,
	[ 38 ] = PR_rename,
	[ 39 ] = PR_mkdir,
	[ 40 ] = PR_rmdir,
	[ 41 ] = PR_dup,
	[ 42 ] = PR_pipe,
	[ 43 ] = PR_times,
	[ 45 ] = PR_brk,
	[ 46 ] = PR_setgid,
	[ 47 ] = PR_getgid,
	[ 49 ] = PR_geteuid,
	[ 50 ] = PR_getegid,
	[ 51 ] = PR_acct,
	[ 52 ] = PR_umount2,
	[ 54 ] = PR_ioctl,
	[ 55 ] = PR_fcntl,
	[ 57 ] = PR_setpgid,
	[ 60 ] = PR_umask,
	[ 61 ] = PR_chroot,
	[ 62 ] = PR_ustat,
	[ 63 ] = PR_dup2,
	[ 64 ] = PR_getppid,
	[ 65 ] = PR_getpgrp,
	[ 66 ] = PR_setsid,
	[ 67 ] = PR_sigaction,
	[ 70 ] = PR_setreuid,
	[ 71 ] = PR_setregid,
	[ 72 ] = PR_sigsuspend,
	[ 73 ] = PR_sigpending,
	[ 74 ] = PR_sethostname,
	[ 75 ] = PR_setrlimit,
	[ 77 ] = PR_getrusage,
	[ 78 ] = PR_gettimeofday,
	[ 79 ] = PR_settimeofday,
	[ 80 ] = PR_getgroups,
	[ 81 ] = PR_setgroups,
	[ 83 ] = PR_symlink,
	[ 85 ] = PR_readlink,
	[ 86 ] = PR_uselib,
	[ 87 ] = PR_swapon,
	[ 88 ] = PR_reboot,
	[ 91 ] = PR_munmap,
	[ 92 ] = PR_truncate,
	[ 93 ] = PR_ftruncate,
	[ 94 ] = PR_fchmod,
	[ 95 ] = PR_fchown,
	[ 96 ] = PR_getpriority,
	[ 97 ] = PR_setpriority,
	[ 99 ] = PR_statfs,
	[ 100 ] = PR_fstatfs,
	[ 103 ] = PR_syslog,
	[ 104 ] = PR_setitimer,
	[ 105 ] = PR_getitimer,
	[ 106 ] = PR_stat,
	[ 107 ] = PR_lstat,
	[ 108 ] = PR_fstat,
	[ 111 ] = PR_vhangup,
	[ 114 ] = PR_wait4,
	[ 115 ] = PR_swapoff,
	[ 116 ] = PR_sysinfo,
	[ 118 ] = PR_fsync,
	[ 119 ] = PR_sigreturn,
	[ 120 ] = PR_clone,
	[ 121 ] = PR_setdomainname,
	[ 122 ] = PR_uname,
	[ 124 ] = PR_adjtimex,
	[ 125 ] = PR_mprotect,
	[ 126 ] = PR_sigprocmask,
	[ 128 ] = PR_init_module,
	[ 129 ] = PR_delete_module,
	[ 131 ] = PR_quotactl,
	[ 132 ] = PR_getpgid,
	[ 133 ] = PR_fchdir,
	[ 134 ] = PR_bdflush,
	[ 135 ] = PR_sysfs,
	[ 136 ] = PR_personality,
	[ 138 ] = PR_setfsuid,
	[ 139 ] = PR_setfsgid,
	[ 140 ] = PR__llseek,
	[ 141 ] = PR_getdents,
	[ 142 ] = PR__newselect,
	[ 143 ] = PR_flock,
	[ 144 ] = PR_msync,
	[ 145 ] = PR_readv,
	[ 146 ] = PR_writev,
	[ 147 ] = PR_getsid,
	[ 148 ] = PR_fdatasync,
	[ 149 ] = PR__sysctl,
	[ 150 ] = PR_mlock,
	[ 151 ] = PR_munlock,
	[ 152 ] = PR_mlockall,
	[ 153 ] = PR_munlockall,
	[ 154 ] = PR_sched_setparam,
	[ 155 ] = PR_sched_getparam,
	[ 156 ] = PR_sched_setscheduler,
	[ 157 ] = PR_sched_getscheduler,
	[ 158 ] = PR_sched_yield,
	[ 159 ] = PR_sched_get_priority_max,
	[ 160 ] = PR_sched_get_priority_min,
	[ 161 ] = PR_sched_rr_get_interval,
	[ 162 ] = PR_nanosleep,
	[ 163 ] = PR_mremap,
	[ 164 ] = PR_setresuid,
	[ 165 ] = PR_getresuid,
	[ 168 ] = PR_poll,
	[ 169 ] = PR_nfsservctl,
	[ 170 ] = PR_setresgid,
	[ 171 ] = PR_getresgid,
	[ 172 ] = PR_prctl,
	[ 173 ] = PR_rt_sigreturn,
	[ 174 ] = PR_rt_sigaction,
	[ 175 ] = PR_rt_sigprocmask,
	[ 176 ] = PR_rt_sigpending,
	[ 177 ] = PR_rt_sigtimedwait,
	[ 178 ] = PR_rt_sigqueueinfo,
	[ 179 ] = PR_rt_sigsuspend,
	[ 180 ] = PR_pread64,
	[ 181 ] = PR_pwrite64,
	[ 182 ] = PR_chown,
	[ 183 ] = PR_getcwd,
	[ 184 ] = PR_capget,
	[ 185 ] = PR_capset,
	[ 186 ] = PR_sigaltstack,
	[ 187 ] = PR_sendfile,
	[ 190 ] = PR_vfork,
	[ 191 ] = PR_ugetrlimit,
	[ 192 ] = PR_mmap2,
	[ 193 ] = PR_truncate64,
	[ 194 ] = PR_ftruncate64,
	[ 195 ] = PR_stat64,
	[ 196 ] = PR_lstat64,
	[ 197 ] = PR_fstat64,
	[ 198 ] = PR_lchown32,
	[ 199 ] = PR_getuid32,
	[ 200 ] = PR_getgid32,
	[ 201 ] = PR_geteuid32,
	[ 202 ] = PR_getegid32,
	[ 203 ] = PR_setreuid32,
	[ 204 ] = PR_setregid32,
	[ 205 ] = PR_getgroups32,
	[ 206 ] = PR_setgroups32,
	[ 207 ] = PR_fchown32,
	[ 208 ] = PR_setresuid32,
	[ 209 ] = PR_getresuid32,
	[ 210 ] = PR_setresgid32,
	[ 211 ] = PR_getresgid32,
	[ 212 ] = PR_chown32,
	[ 213 ] = PR_setuid32,
	[ 214 ] = PR_setgid32,
	[ 215 ] = PR_setfsuid32,
	[ 216 ] = PR_setfsgid32,
	[ 217 ] = PR_getdents64,
	[ 218 ] = PR_pivot_root,
	[ 219 ] = PR_mincore,
	[ 220 ] = PR_madvise,
	[ 221 ] = PR_fcntl64,
	[ 224 ] = PR_gettid,
	[ 225 ] = PR_readahead,
	[ 226 ] = PR_setxattr,
	[ 227 ] = PR_lsetxattr,
	[ 228 ] = PR_fsetxattr,
	[ 229 ] = PR_getxattr,
	[ 230 ] = PR_lgetxattr,
	[ 231 ] = PR_fgetxattr,
	[ 232 ] = PR_listxattr,
	[ 233 ] = PR_llistxattr,
	[ 234 ] = PR_flistxattr,
	[ 235 ] = PR_removexattr,
	[ 236 ] = PR_lremovexattr,
	[ 237 ] = PR_fremovexattr,
	[ 238 ] = PR_tkill,
	[ 239 ] = PR_sendfile64,
	[ 240 ] = PR_futex,
	[ 241 ] = PR_sched_setaffinity,
	[ 242 ] = PR_sched_getaffinity,
	[ 243 ] = PR_io_setup,
	[ 244 ] = PR_io_destroy,
	[ 245 ] = PR_io_getevents,
	[ 246 ] = PR_io_submit,
	[ 247 ] = PR_io_cancel,
	[ 248 ] = PR_exit_group,
	[ 249 ] = PR_lookup_dcookie,
	[ 250 ] = PR_epoll_create,
	[ 251 ] = PR_epoll_ctl,
	[ 252 ] = PR_epoll_wait,
	[ 253 ] = PR_remap_file_pages,
	[ 256 ] = PR_set_tid_address,
	[ 257 ] = PR_timer_create,
	[ 258 ] = PR_timer_settime,
	[ 259 ] = PR_timer_gettime,
	[ 260 ] = PR_timer_getoverrun,
	[ 261 ] = PR_timer_delete,
	[ 262 ] = PR_clock_settime,
	[ 263 ] = PR_clock_gettime,
	[ 264 ] = PR_clock_getres,
	[ 265 ] = PR_clock_nanosleep,
	[ 266 ] = PR_statfs64,
	[ 267 ] = PR_fstatfs64,
	[ 268 ] = PR_tgkill,
	[ 269 ] = PR_utimes,
	[ 270 ] = PR_arm_fadvise64_64,
	[ 271 ] = PR_pciconfig_iobase,
	[ 272 ] = PR_pciconfig_read,
	[ 273 ] = PR_pciconfig_write,
	[ 274 ] = PR_mq_open,
	[ 275 ] = PR_mq_unlink,
	[ 276 ] = PR_mq_timedsend,
	[ 277 ] = PR_mq_timedreceive,
	[ 278 ] = PR_mq_notify,
	[ 279 ] = PR_mq_getsetattr,
	[ 280 ] = PR_waitid,
	[ 281 ] = PR_socket,
	[ 282 ] = PR_bind,
	[ 283 ] = PR_connect,
	[ 284 ] = PR_listen,
	[ 285 ] = PR_accept,
	[ 286 ] = PR_getsockname,
	[ 287 ] = PR_getpeername,
	[ 288 ] = PR_socketpair,
	[ 289 ] = PR_send,
	[ 290 ] = PR_sendto,
	[ 291 ] = PR_recv,
	[ 292 ] = PR_recvfrom,
	[ 293 ] = PR_shutdown,
	[ 294 ] = PR_setsockopt,
	[ 295 ] = PR_getsockopt,
	[ 296 ] = PR_sendmsg,
	[ 297 ] = PR_recvmsg,
	[ 298 ] = PR_semop,
	[ 299 ] = PR_semget,
	[ 300 ] = PR_semctl,
	[ 301 ] = PR_msgsnd,
	[ 302 ] = PR_msgrcv,
	[ 303 ] = PR_msgget,
	[ 304 ] = PR_msgctl,
	[ 305 ] = PR_shmat,
	[ 306 ] = PR_shmdt,
	[ 307 ] = PR_shmget,
	[ 308 ] = PR_shmctl,
	[ 309 ] = PR_add_key,
	[ 310 ] = PR_request_key,
	[ 311 ] = PR_keyctl,
	[ 312 ] = PR_semtimedop,
	[ 313 ] = PR_vserver,
	[ 314 ] = PR_ioprio_set,
	[ 315 ] = PR_ioprio_get,
	[ 316 ] = PR_inotify_init,
	[ 317 ] = PR_inotify_add_watch,
	[ 318 ] = PR_inotify_rm_watch,
	[ 319 ] = PR_mbind,
	[ 320 ] = PR_get_mempolicy,
	[ 321 ] = PR_set_mempolicy,
	[ 322 ] = PR_openat,
	[ 323 ] = PR_mkdirat,
	[ 324 ] = PR_mknodat,
	[ 325 ] = PR_fchownat,
	[ 326 ] = PR_futimesat,
	[ 327 ] = PR_fstatat64,
	[ 328 ] = PR_unlinkat,
	[ 329 ] = PR_renameat,
	[ 330 ] = PR_linkat,
	[ 331 ] = PR_symlinkat,
	[ 332 ] = PR_readlinkat,
	[ 333 ] = PR_fchmodat,
	[ 334 ] = PR_faccessat,
	[ 335 ] = PR_pselect6,
	[ 336 ] = PR_ppoll,
	[ 337 ] = PR_unshare,
	[ 338 ] = PR_set_robust_list,
	[ 339 ] = PR_get_robust_list,
	[ 340 ] = PR_splice,
	[ 341 ] = PR_arm_sync_file_range,
	[ 342 ] = PR_tee,
	[ 343 ] = PR_vmsplice,
	[ 344 ] = PR_move_pages,
	[ 345 ] = PR_getcpu,
	[ 346 ] = PR_epoll_pwait,
	[ 347 ] = PR_kexec_load,
	[ 348 ] = PR_utimensat,
	[ 349 ] = PR_signalfd,
	[ 350 ] = PR_timerfd_create,
	[ 351 ] = PR_eventfd,
	[ 352 ] = PR_fallocate,
	[ 353 ] = PR_timerfd_settime,
	[ 354 ] = PR_timerfd_gettime,
	[ 355 ] = PR_signalfd4,
	[ 356 ] = PR_eventfd2,
	[ 357 ] = PR_epoll_create1,
	[ 358 ] = PR_dup3,
	[ 359 ] = PR_pipe2,
	[ 360 ] = PR_inotify_init1,
	[ 361 ] = PR_preadv,
	[ 362 ] = PR_pwritev,
	[ 363 ] = PR_rt_tgsigqueueinfo,
	[ 364 ] = PR_perf_event_open,
	[ 365 ] = PR_recvmmsg,
	[ 366 ] = PR_accept4,
	[ 367 ] = PR_fanotify_init,
	[ 368 ] = PR_fanotify_mark,
	[ 369 ] = PR_prlimit64,
	[ 370 ] = PR_name_to_handle_at,
	[ 371 ] = PR_open_by_handle_at,
	[ 372 ] = PR_clock_adjtime,
	[ 373 ] = PR_syncfs,
	[ 374 ] = PR_sendmmsg,
	[ 375 ] = PR_setns,
	[ 376 ] = PR_process_vm_readv,
	[ 377 ] = PR_process_vm_writev,
	[ 378 ] = PR_kcmp,
	[ 379 ] = PR_finit_module,
	[ 380 ] = PR_sched_setattr,
	[ 381 ] = PR_sched_getattr,
	[ 382 ] = PR_renameat2,
	[ 397 ] = PR_statx,
	[ 412 ] = PR_utimensat_time64,
};

```

`library/src/main/jni/syscall/sysnums-arm64.h`:

```h
#include "syscall/sysnum.h"

static const Sysnum sysnums_arm64[] = {
	[ 0 ] = PR_io_setup,
	[ 1 ] = PR_io_destroy,
	[ 2 ] = PR_io_submit,
	[ 3 ] = PR_io_cancel,
	[ 4 ] = PR_io_getevents,
	[ 5 ] = PR_setxattr,
	[ 6 ] = PR_lsetxattr,
	[ 7 ] = PR_fsetxattr,
	[ 8 ] = PR_getxattr,
	[ 9 ] = PR_lgetxattr,
	[ 10 ] = PR_fgetxattr,
	[ 11 ] = PR_listxattr,
	[ 12 ] = PR_llistxattr,
	[ 13 ] = PR_flistxattr,
	[ 14 ] = PR_removexattr,
	[ 15 ] = PR_lremovexattr,
	[ 16 ] = PR_fremovexattr,
	[ 17 ] = PR_getcwd,
	[ 18 ] = PR_lookup_dcookie,
	[ 19 ] = PR_eventfd2,
	[ 20 ] = PR_epoll_create1,
	[ 21 ] = PR_epoll_ctl,
	[ 22 ] = PR_epoll_pwait,
	[ 23 ] = PR_dup,
	[ 24 ] = PR_dup3,
	[ 25 ] = PR_fcntl,
	[ 26 ] = PR_inotify_init1,
	[ 27 ] = PR_inotify_add_watch,
	[ 28 ] = PR_inotify_rm_watch,
	[ 29 ] = PR_ioctl,
	[ 30 ] = PR_ioprio_set,
	[ 31 ] = PR_ioprio_get,
	[ 32 ] = PR_flock,
	[ 33 ] = PR_mknodat,
	[ 34 ] = PR_mkdirat,
	[ 35 ] = PR_unlinkat,
	[ 36 ] = PR_symlinkat,
	[ 37 ] = PR_linkat,
	[ 38 ] = PR_renameat,
	[ 39 ] = PR_umount2,
	[ 40 ] = PR_mount,
	[ 41 ] = PR_pivot_root,
	[ 42 ] = PR_nfsservctl,
	[ 43 ] = PR_statfs,
	[ 44 ] = PR_fstatfs,
	[ 45 ] = PR_truncate,
	[ 46 ] = PR_ftruncate,
	[ 47 ] = PR_fallocate,
	[ 48 ] = PR_faccessat,
	[ 49 ] = PR_chdir,
	[ 50 ] = PR_fchdir,
	[ 51 ] = PR_chroot,
	[ 52 ] = PR_fchmod,
	[ 53 ] = PR_fchmodat,
	[ 54 ] = PR_fchownat,
	[ 55 ] = PR_fchown,
	[ 56 ] = PR_openat,
	[ 57 ] = PR_close,
	[ 58 ] = PR_vhangup,
	[ 59 ] = PR_pipe2,
	[ 60 ] = PR_quotactl,
	[ 61 ] = PR_getdents64,
	[ 62 ] = PR_lseek,
	[ 63 ] = PR_read,
	[ 64 ] = PR_write,
	[ 65 ] = PR_readv,
	[ 66 ] = PR_writev,
	[ 67 ] = PR_pread64,
	[ 68 ] = PR_pwrite64,
	[ 69 ] = PR_preadv,
	[ 70 ] = PR_pwritev,
	[ 71 ] = PR_sendfile,
	[ 72 ] = PR_pselect6,
	[ 73 ] = PR_ppoll,
	[ 74 ] = PR_signalfd4,
	[ 75 ] = PR_vmsplice,
	[ 76 ] = PR_splice,
	[ 77 ] = PR_tee,
	[ 78 ] = PR_readlinkat,
	[ 79 ] = PR_fstatat64,
	[ 80 ] = PR_fstat,
	[ 81 ] = PR_sync,
	[ 82 ] = PR_fsync,
	[ 83 ] = PR_fdatasync,
	[ 84 ] = PR_sync_file_range,
	[ 85 ] = PR_timerfd_create,
	[ 86 ] = PR_timerfd_settime,
	[ 87 ] = PR_timerfd_gettime,
	[ 88 ] = PR_utimensat,
	[ 89 ] = PR_acct,
	[ 90 ] = PR_capget,
	[ 91 ] = PR_capset,
	[ 92 ] = PR_personality,
	[ 93 ] = PR_exit,
	[ 94 ] = PR_exit_group,
	[ 95 ] = PR_waitid,
	[ 96 ] = PR_set_tid_address,
	[ 97 ] = PR_unshare,
	[ 98 ] = PR_futex,
	[ 99 ] = PR_set_robust_list,
	[ 100 ] = PR_get_robust_list,
	[ 101 ] = PR_nanosleep,
	[ 102 ] = PR_getitimer,
	[ 103 ] = PR_setitimer,
	[ 104 ] = PR_kexec_load,
	[ 105 ] = PR_init_module,
	[ 106 ] = PR_delete_module,
	[ 107 ] = PR_timer_create,
	[ 108 ] = PR_timer_gettime,
	[ 109 ] = PR_timer_getoverrun,
	[ 110 ] = PR_timer_settime,
	[ 111 ] = PR_timer_delete,
	[ 112 ] = PR_clock_settime,
	[ 113 ] = PR_clock_gettime,
	[ 114 ] = PR_clock_getres,
	[ 115 ] = PR_clock_nanosleep,
	[ 116 ] = PR_syslog,
	[ 117 ] = PR_ptrace,
	[ 118 ] = PR_sched_setparam,
	[ 119 ] = PR_sched_setscheduler,
	[ 120 ] = PR_sched_getscheduler,
	[ 121 ] = PR_sched_getparam,
	[ 122 ] = PR_sched_setaffinity,
	[ 123 ] = PR_sched_getaffinity,
	[ 124 ] = PR_sched_yield,
	[ 125 ] = PR_sched_get_priority_max,
	[ 126 ] = PR_sched_get_priority_min,
	[ 127 ] = PR_sched_rr_get_interval,
	[ 128 ] = PR_restart_syscall,
	[ 129 ] = PR_kill,
	[ 130 ] = PR_tkill,
	[ 131 ] = PR_tgkill,
	[ 132 ] = PR_sigaltstack,
	[ 133 ] = PR_rt_sigsuspend,
	[ 134 ] = PR_rt_sigaction,
	[ 135 ] = PR_rt_sigprocmask,
	[ 136 ] = PR_rt_sigpending,
	[ 137 ] = PR_rt_sigtimedwait,
	[ 138 ] = PR_rt_sigqueueinfo,
	[ 139 ] = PR_rt_sigreturn,
	[ 140 ] = PR_setpriority,
	[ 141 ] = PR_getpriority,
	[ 142 ] = PR_reboot,
	[ 143 ] = PR_setregid,
	[ 144 ] = PR_setgid,
	[ 145 ] = PR_setreuid,
	[ 146 ] = PR_setuid,
	[ 147 ] = PR_setresuid,
	[ 148 ] = PR_getresuid,
	[ 149 ] = PR_setresgid,
	[ 150 ] = PR_getresgid,
	[ 151 ] = PR_setfsuid,
	[ 152 ] = PR_setfsgid,
	[ 153 ] = PR_times,
	[ 154 ] = PR_setpgid,
	[ 155 ] = PR_getpgid,
	[ 156 ] = PR_getsid,
	[ 157 ] = PR_setsid,
	[ 158 ] = PR_getgroups,
	[ 159 ] = PR_setgroups,
	[ 160 ] = PR_uname,
	[ 161 ] = PR_sethostname,
	[ 162 ] = PR_setdomainname,
	[ 163 ] = PR_getrlimit,
	[ 164 ] = PR_setrlimit,
	[ 165 ] = PR_getrusage,
	[ 166 ] = PR_umask,
	[ 167 ] = PR_prctl,
	[ 168 ] = PR_getcpu,
	[ 169 ] = PR_gettimeofday,
	[ 170 ] = PR_settimeofday,
	[ 171 ] = PR_adjtimex,
	[ 172 ] = PR_getpid,
	[ 173 ] = PR_getppid,
	[ 174 ] = PR_getuid,
	[ 175 ] = PR_geteuid,
	[ 176 ] = PR_getgid,
	[ 177 ] = PR_getegid,
	[ 178 ] = PR_gettid,
	[ 179 ] = PR_sysinfo,
	[ 180 ] = PR_mq_open,
	[ 181 ] = PR_mq_unlink,
	[ 182 ] = PR_mq_timedsend,
	[ 183 ] = PR_mq_timedreceive,
	[ 184 ] = PR_mq_notify,
	[ 185 ] = PR_mq_getsetattr,
	[ 186 ] = PR_msgget,
	[ 187 ] = PR_msgctl,
	[ 188 ] = PR_msgrcv,
	[ 189 ] = PR_msgsnd,
	[ 190 ] = PR_semget,
	[ 191 ] = PR_semctl,
	[ 192 ] = PR_semtimedop,
	[ 193 ] = PR_semop,
	[ 194 ] = PR_shmget,
	[ 195 ] = PR_shmctl,
	[ 196 ] = PR_shmat,
	[ 197 ] = PR_shmdt,
	[ 198 ] = PR_socket,
	[ 199 ] = PR_socketpair,
	[ 200 ] = PR_bind,
	[ 201 ] = PR_listen,
	[ 202 ] = PR_accept,
	[ 203 ] = PR_connect,
	[ 204 ] = PR_getsockname,
	[ 205 ] = PR_getpeername,
	[ 206 ] = PR_sendto,
	[ 207 ] = PR_recvfrom,
	[ 208 ] = PR_setsockopt,
	[ 209 ] = PR_getsockopt,
	[ 210 ] = PR_shutdown,
	[ 211 ] = PR_sendmsg,
	[ 212 ] = PR_recvmsg,
	[ 213 ] = PR_readahead,
	[ 214 ] = PR_brk,
	[ 215 ] = PR_munmap,
	[ 216 ] = PR_mremap,
	[ 217 ] = PR_add_key,
	[ 218 ] = PR_request_key,
	[ 219 ] = PR_keyctl,
	[ 220 ] = PR_clone,
	[ 221 ] = PR_execve,
	[ 222 ] = PR_mmap,
	[ 223 ] = PR_fadvise64,
	[ 224 ] = PR_swapon,
	[ 225 ] = PR_swapoff,
	[ 226 ] = PR_mprotect,
	[ 227 ] = PR_msync,
	[ 228 ] = PR_mlock,
	[ 229 ] = PR_munlock,
	[ 230 ] = PR_mlockall,
	[ 231 ] = PR_munlockall,
	[ 232 ] = PR_mincore,
	[ 233 ] = PR_madvise,
	[ 234 ] = PR_remap_file_pages,
	[ 235 ] = PR_mbind,
	[ 236 ] = PR_get_mempolicy,
	[ 237 ] = PR_set_mempolicy,
	[ 238 ] = PR_migrate_pages,
	[ 239 ] = PR_move_pages,
	[ 240 ] = PR_rt_tgsigqueueinfo,
	[ 241 ] = PR_perf_event_open,
	[ 242 ] = PR_accept4,
	[ 243 ] = PR_recvmmsg,
	[ 244 ] = PR_arch_specific_syscall,
	[ 260 ] = PR_wait4,
	[ 261 ] = PR_prlimit64,
	[ 262 ] = PR_fanotify_init,
	[ 263 ] = PR_fanotify_mark,
	[ 264 ] = PR_name_to_handle_at,
	[ 265 ] = PR_open_by_handle_at,
	[ 266 ] = PR_clock_adjtime,
	[ 267 ] = PR_syncfs,
	[ 268 ] = PR_setns,
	[ 269 ] = PR_sendmmsg,
	[ 270 ] = PR_process_vm_readv,
	[ 271 ] = PR_process_vm_writev,
	[ 272 ] = PR_kcmp,
	[ 273 ] = PR_finit_module,
	[ 274 ] = PR_sched_setattr,
	[ 275 ] = PR_sched_getattr,
	[ 276 ] = PR_renameat2,
	[ 291 ] = PR_statx,
};

```

`library/src/main/jni/syscall/sysnums-i386.h`:

```h
#include "syscall/sysnum.h"

static const Sysnum sysnums_i386[] = {
	[ 0 ] = PR_restart_syscall,
	[ 1 ] = PR_exit,
	[ 2 ] = PR_fork,
	[ 3 ] = PR_read,
	[ 4 ] = PR_write,
	[ 5 ] = PR_open,
	[ 6 ] = PR_close,
	[ 7 ] = PR_waitpid,
	[ 8 ] = PR_creat,
	[ 9 ] = PR_link,
	[ 10 ] = PR_unlink,
	[ 11 ] = PR_execve,
	[ 12 ] = PR_chdir,
	[ 13 ] = PR_time,
	[ 14 ] = PR_mknod,
	[ 15 ] = PR_chmod,
	[ 16 ] = PR_lchown,
	[ 17 ] = PR_break,
	[ 18 ] = PR_oldstat,
	[ 19 ] = PR_lseek,
	[ 20 ] = PR_getpid,
	[ 21 ] = PR_mount,
	[ 22 ] = PR_umount,
	[ 23 ] = PR_setuid,
	[ 24 ] = PR_getuid,
	[ 25 ] = PR_stime,
	[ 26 ] = PR_ptrace,
	[ 27 ] = PR_alarm,
	[ 28 ] = PR_oldfstat,
	[ 29 ] = PR_pause,
	[ 30 ] = PR_utime,
	[ 31 ] = PR_stty,
	[ 32 ] = PR_gtty,
	[ 33 ] = PR_access,
	[ 34 ] = PR_nice,
	[ 35 ] = PR_ftime,
	[ 36 ] = PR_sync,
	[ 37 ] = PR_kill,
	[ 38 ] = PR_rename,
	[ 39 ] = PR_mkdir,
	[ 40 ] = PR_rmdir,
	[ 41 ] = PR_dup,
	[ 42 ] = PR_pipe,
	[ 43 ] = PR_times,
	[ 44 ] = PR_prof,
	[ 45 ] = PR_brk,
	[ 46 ] = PR_setgid,
	[ 47 ] = PR_getgid,
	[ 48 ] = PR_signal,
	[ 49 ] = PR_geteuid,
	[ 50 ] = PR_getegid,
	[ 51 ] = PR_acct,
	[ 52 ] = PR_umount2,
	[ 53 ] = PR_lock,
	[ 54 ] = PR_ioctl,
	[ 55 ] = PR_fcntl,
	[ 56 ] = PR_mpx,
	[ 57 ] = PR_setpgid,
	[ 58 ] = PR_ulimit,
	[ 59 ] = PR_oldolduname,
	[ 60 ] = PR_umask,
	[ 61 ] = PR_chroot,
	[ 62 ] = PR_ustat,
	[ 63 ] = PR_dup2,
	[ 64 ] = PR_getppid,
	[ 65 ] = PR_getpgrp,
	[ 66 ] = PR_setsid,
	[ 67 ] = PR_sigaction,
	[ 68 ] = PR_sgetmask,
	[ 69 ] = PR_ssetmask,
	[ 70 ] = PR_setreuid,
	[ 71 ] = PR_setregid,
	[ 72 ] = PR_sigsuspend,
	[ 73 ] = PR_sigpending,
	[ 74 ] = PR_sethostname,
	[ 75 ] = PR_setrlimit,
	[ 76 ] = PR_getrlimit,
	[ 77 ] = PR_getrusage,
	[ 78 ] = PR_gettimeofday,
	[ 79 ] = PR_settimeofday,
	[ 80 ] = PR_getgroups,
	[ 81 ] = PR_setgroups,
	[ 82 ] = PR_select,
	[ 83 ] = PR_symlink,
	[ 84 ] = PR_oldlstat,
	[ 85 ] = PR_readlink,
	[ 86 ] = PR_uselib,
	[ 87 ] = PR_swapon,
	[ 88 ] = PR_reboot,
	[ 89 ] = PR_readdir,
	[ 90 ] = PR_mmap,
	[ 91 ] = PR_munmap,
	[ 92 ] = PR_truncate,
	[ 93 ] = PR_ftruncate,
	[ 94 ] = PR_fchmod,
	[ 95 ] = PR_fchown,
	[ 96 ] = PR_getpriority,
	[ 97 ] = PR_setpriority,
	[ 98 ] = PR_profil,
	[ 99 ] = PR_statfs,
	[ 100 ] = PR_fstatfs,
	[ 101 ] = PR_ioperm,
	[ 102 ] = PR_socketcall,
	[ 103 ] = PR_syslog,
	[ 104 ] = PR_setitimer,
	[ 105 ] = PR_getitimer,
	[ 106 ] = PR_stat,
	[ 107 ] = PR_lstat,
	[ 108 ] = PR_fstat,
	[ 109 ] = PR_olduname,
	[ 110 ] = PR_iopl,
	[ 111 ] = PR_vhangup,
	[ 112 ] = PR_idle,
	[ 113 ] = PR_vm86old,
	[ 114 ] = PR_wait4,
	[ 115 ] = PR_swapoff,
	[ 116 ] = PR_sysinfo,
	[ 117 ] = PR_ipc,
	[ 118 ] = PR_fsync,
	[ 119 ] = PR_sigreturn,
	[ 120 ] = PR_clone,
	[ 121 ] = PR_setdomainname,
	[ 122 ] = PR_uname,
	[ 123 ] = PR_modify_ldt,
	[ 124 ] = PR_adjtimex,
	[ 125 ] = PR_mprotect,
	[ 126 ] = PR_sigprocmask,
	[ 127 ] = PR_create_module,
	[ 128 ] = PR_init_module,
	[ 129 ] = PR_delete_module,
	[ 130 ] = PR_get_kernel_syms,
	[ 131 ] = PR_quotactl,
	[ 132 ] = PR_getpgid,
	[ 133 ] = PR_fchdir,
	[ 134 ] = PR_bdflush,
	[ 135 ] = PR_sysfs,
	[ 136 ] = PR_personality,
	[ 137 ] = PR_afs_syscall,
	[ 138 ] = PR_setfsuid,
	[ 139 ] = PR_setfsgid,
	[ 140 ] = PR__llseek,
	[ 141 ] = PR_getdents,
	[ 142 ] = PR__newselect,
	[ 143 ] = PR_flock,
	[ 144 ] = PR_msync,
	[ 145 ] = PR_readv,
	[ 146 ] = PR_writev,
	[ 147 ] = PR_getsid,
	[ 148 ] = PR_fdatasync,
	[ 149 ] = PR__sysctl,
	[ 150 ] = PR_mlock,
	[ 151 ] = PR_munlock,
	[ 152 ] = PR_mlockall,
	[ 153 ] = PR_munlockall,
	[ 154 ] = PR_sched_setparam,
	[ 155 ] = PR_sched_getparam,
	[ 156 ] = PR_sched_setscheduler,
	[ 157 ] = PR_sched_getscheduler,
	[ 158 ] = PR_sched_yield,
	[ 159 ] = PR_sched_get_priority_max,
	[ 160 ] = PR_sched_get_priority_min,
	[ 161 ] = PR_sched_rr_get_interval,
	[ 162 ] = PR_nanosleep,
	[ 163 ] = PR_mremap,
	[ 164 ] = PR_setresuid,
	[ 165 ] = PR_getresuid,
	[ 166 ] = PR_vm86,
	[ 167 ] = PR_query_module,
	[ 168 ] = PR_poll,
	[ 169 ] = PR_nfsservctl,
	[ 170 ] = PR_setresgid,
	[ 171 ] = PR_getresgid,
	[ 172 ] = PR_prctl,
	[ 173 ] = PR_rt_sigreturn,
	[ 174 ] = PR_rt_sigaction,
	[ 175 ] = PR_rt_sigprocmask,
	[ 176 ] = PR_rt_sigpending,
	[ 177 ] = PR_rt_sigtimedwait,
	[ 178 ] = PR_rt_sigqueueinfo,
	[ 179 ] = PR_rt_sigsuspend,
	[ 180 ] = PR_pread64,
	[ 181 ] = PR_pwrite64,
	[ 182 ] = PR_chown,
	[ 183 ] = PR_getcwd,
	[ 184 ] = PR_capget,
	[ 185 ] = PR_capset,
	[ 186 ] = PR_sigaltstack,
	[ 187 ] = PR_sendfile,
	[ 188 ] = PR_getpmsg,
	[ 189 ] = PR_putpmsg,
	[ 190 ] = PR_vfork,
	[ 191 ] = PR_ugetrlimit,
	[ 192 ] = PR_mmap2,
	[ 193 ] = PR_truncate64,
	[ 194 ] = PR_ftruncate64,
	[ 195 ] = PR_stat64,
	[ 196 ] = PR_lstat64,
	[ 197 ] = PR_fstat64,
	[ 198 ] = PR_lchown32,
	[ 199 ] = PR_getuid32,
	[ 200 ] = PR_getgid32,
	[ 201 ] = PR_geteuid32,
	[ 202 ] = PR_getegid32,
	[ 203 ] = PR_setreuid32,
	[ 204 ] = PR_setregid32,
	[ 205 ] = PR_getgroups32,
	[ 206 ] = PR_setgroups32,
	[ 207 ] = PR_fchown32,
	[ 208 ] = PR_setresuid32,
	[ 209 ] = PR_getresuid32,
	[ 210 ] = PR_setresgid32,
	[ 211 ] = PR_getresgid32,
	[ 212 ] = PR_chown32,
	[ 213 ] = PR_setuid32,
	[ 214 ] = PR_setgid32,
	[ 215 ] = PR_setfsuid32,
	[ 216 ] = PR_setfsgid32,
	[ 217 ] = PR_pivot_root,
	[ 218 ] = PR_mincore,
	[ 219 ] = PR_madvise,
	[ 220 ] = PR_getdents64,
	[ 221 ] = PR_fcntl64,
	[ 224 ] = PR_gettid,
	[ 225 ] = PR_readahead,
	[ 226 ] = PR_setxattr,
	[ 227 ] = PR_lsetxattr,
	[ 228 ] = PR_fsetxattr,
	[ 229 ] = PR_getxattr,
	[ 230 ] = PR_lgetxattr,
	[ 231 ] = PR_fgetxattr,
	[ 232 ] = PR_listxattr,
	[ 233 ] = PR_llistxattr,
	[ 234 ] = PR_flistxattr,
	[ 235 ] = PR_removexattr,
	[ 236 ] = PR_lremovexattr,
	[ 237 ] = PR_fremovexattr,
	[ 238 ] = PR_tkill,
	[ 239 ] = PR_sendfile64,
	[ 240 ] = PR_futex,
	[ 241 ] = PR_sched_setaffinity,
	[ 242 ] = PR_sched_getaffinity,
	[ 243 ] = PR_set_thread_area,
	[ 244 ] = PR_get_thread_area,
	[ 245 ] = PR_io_setup,
	[ 246 ] = PR_io_destroy,
	[ 247 ] = PR_io_getevents,
	[ 248 ] = PR_io_submit,
	[ 249 ] = PR_io_cancel,
	[ 250 ] = PR_fadvise64,
	[ 252 ] = PR_exit_group,
	[ 253 ] = PR_lookup_dcookie,
	[ 254 ] = PR_epoll_create,
	[ 255 ] = PR_epoll_ctl,
	[ 256 ] = PR_epoll_wait,
	[ 257 ] = PR_remap_file_pages,
	[ 258 ] = PR_set_tid_address,
	[ 259 ] = PR_timer_create,
	[ 260 ] = PR_timer_settime,
	[ 261 ] = PR_timer_gettime,
	[ 262 ] = PR_timer_getoverrun,
	[ 263 ] = PR_timer_delete,
	[ 264 ] = PR_clock_settime,
	[ 265 ] = PR_clock_gettime,
	[ 266 ] = PR_clock_getres,
	[ 267 ] = PR_clock_nanosleep,
	[ 268 ] = PR_statfs64,
	[ 269 ] = PR_fstatfs64,
	[ 270 ] = PR_tgkill,
	[ 271 ] = PR_utimes,
	[ 272 ] = PR_fadvise64_64,
	[ 273 ] = PR_vserver,
	[ 274 ] = PR_mbind,
	[ 275 ] = PR_get_mempolicy,
	[ 276 ] = PR_set_mempolicy,
	[ 277 ] = PR_mq_open,
	[ 278 ] = PR_mq_unlink,
	[ 279 ] = PR_mq_timedsend,
	[ 280 ] = PR_mq_timedreceive,
	[ 281 ] = PR_mq_notify,
	[ 282 ] = PR_mq_getsetattr,
	[ 283 ] = PR_kexec_load,
	[ 284 ] = PR_waitid,
	[ 286 ] = PR_add_key,
	[ 287 ] = PR_request_key,
	[ 288 ] = PR_keyctl,
	[ 289 ] = PR_ioprio_set,
	[ 290 ] = PR_ioprio_get,
	[ 291 ] = PR_inotify_init,
	[ 292 ] = PR_inotify_add_watch,
	[ 293 ] = PR_inotify_rm_watch,
	[ 294 ] = PR_migrate_pages,
	[ 295 ] = PR_openat,
	[ 296 ] = PR_mkdirat,
	[ 297 ] = PR_mknodat,
	[ 298 ] = PR_fchownat,
	[ 299 ] = PR_futimesat,
	[ 300 ] = PR_fstatat64,
	[ 301 ] = PR_unlinkat,
	[ 302 ] = PR_renameat,
	[ 303 ] = PR_linkat,
	[ 304 ] = PR_symlinkat,
	[ 305 ] = PR_readlinkat,
	[ 306 ] = PR_fchmodat,
	[ 307 ] = PR_faccessat,
	[ 308 ] = PR_pselect6,
	[ 309 ] = PR_ppoll,
	[ 310 ] = PR_unshare,
	[ 311 ] = PR_set_robust_list,
	[ 312 ] = PR_get_robust_list,
	[ 313 ] = PR_splice,
	[ 314 ] = PR_sync_file_range,
	[ 315 ] = PR_tee,
	[ 316 ] = PR_vmsplice,
	[ 317 ] = PR_move_pages,
	[ 318 ] = PR_getcpu,
	[ 319 ] = PR_epoll_pwait,
	[ 320 ] = PR_utimensat,
	[ 321 ] = PR_signalfd,
	[ 322 ] = PR_timerfd_create,
	[ 323 ] = PR_eventfd,
	[ 324 ] = PR_fallocate,
	[ 325 ] = PR_timerfd_settime,
	[ 326 ] = PR_timerfd_gettime,
	[ 327 ] = PR_signalfd4,
	[ 328 ] = PR_eventfd2,
	[ 329 ] = PR_epoll_create1,
	[ 330 ] = PR_dup3,
	[ 331 ] = PR_pipe2,
	[ 332 ] = PR_inotify_init1,
	[ 333 ] = PR_preadv,
	[ 334 ] = PR_pwritev,
	[ 335 ] = PR_rt_tgsigqueueinfo,
	[ 336 ] = PR_perf_event_open,
	[ 337 ] = PR_recvmmsg,
	[ 338 ] = PR_fanotify_init,
	[ 339 ] = PR_fanotify_mark,
	[ 340 ] = PR_prlimit64,
	[ 341 ] = PR_name_to_handle_at,
	[ 342 ] = PR_open_by_handle_at,
	[ 343 ] = PR_clock_adjtime,
	[ 344 ] = PR_syncfs,
	[ 345 ] = PR_sendmmsg,
	[ 346 ] = PR_setns,
	[ 347 ] = PR_process_vm_readv,
	[ 348 ] = PR_process_vm_writev,
	[ 349 ] = PR_kcmp,
	[ 350 ] = PR_finit_module,
	[ 351 ] = PR_sched_setattr,
	[ 352 ] = PR_sched_getattr,
	[ 353 ] = PR_renameat2,
	[ 383 ] = PR_statx,
	[ 412 ] = PR_utimensat_time64,
};

```

`library/src/main/jni/syscall/sysnums-sh4.h`:

```h
#include "syscall/sysnum.h"

static const Sysnum sysnums_sh4[] = {
	[ 0 ] = PR_restart_syscall,
	[ 1 ] = PR_exit,
	[ 2 ] = PR_fork,
	[ 3 ] = PR_read,
	[ 4 ] = PR_write,
	[ 5 ] = PR_open,
	[ 6 ] = PR_close,
	[ 7 ] = PR_waitpid,
	[ 8 ] = PR_creat,
	[ 9 ] = PR_link,
	[ 10 ] = PR_unlink,
	[ 11 ] = PR_execve,
	[ 12 ] = PR_chdir,
	[ 13 ] = PR_time,
	[ 14 ] = PR_mknod,
	[ 15 ] = PR_chmod,
	[ 16 ] = PR_lchown,
	[ 18 ] = PR_oldstat,
	[ 19 ] = PR_lseek,
	[ 20 ] = PR_getpid,
	[ 21 ] = PR_mount,
	[ 22 ] = PR_umount,
	[ 23 ] = PR_setuid,
	[ 24 ] = PR_getuid,
	[ 25 ] = PR_stime,
	[ 26 ] = PR_ptrace,
	[ 27 ] = PR_alarm,
	[ 28 ] = PR_oldfstat,
	[ 29 ] = PR_pause,
	[ 30 ] = PR_utime,
	[ 33 ] = PR_access,
	[ 34 ] = PR_nice,
	[ 36 ] = PR_sync,
	[ 37 ] = PR_kill,
	[ 38 ] = PR_rename,
	[ 39 ] = PR_mkdir,
	[ 40 ] = PR_rmdir,
	[ 41 ] = PR_dup,
	[ 42 ] = PR_pipe,
	[ 43 ] = PR_times,
	[ 45 ] = PR_brk,
	[ 46 ] = PR_setgid,
	[ 47 ] = PR_getgid,
	[ 48 ] = PR_signal,
	[ 49 ] = PR_geteuid,
	[ 50 ] = PR_getegid,
	[ 51 ] = PR_acct,
	[ 52 ] = PR_umount2,
	[ 54 ] = PR_ioctl,
	[ 55 ] = PR_fcntl,
	[ 57 ] = PR_setpgid,
	[ 60 ] = PR_umask,
	[ 61 ] = PR_chroot,
	[ 62 ] = PR_ustat,
	[ 63 ] = PR_dup2,
	[ 64 ] = PR_getppid,
	[ 65 ] = PR_getpgrp,
	[ 66 ] = PR_setsid,
	[ 67 ] = PR_sigaction,
	[ 68 ] = PR_sgetmask,
	[ 69 ] = PR_ssetmask,
	[ 70 ] = PR_setreuid,
	[ 71 ] = PR_setregid,
	[ 72 ] = PR_sigsuspend,
	[ 73 ] = PR_sigpending,
	[ 74 ] = PR_sethostname,
	[ 75 ] = PR_setrlimit,
	[ 76 ] = PR_getrlimit,
	[ 77 ] = PR_getrusage,
	[ 78 ] = PR_gettimeofday,
	[ 79 ] = PR_settimeofday,
	[ 80 ] = PR_getgroups,
	[ 81 ] = PR_setgroups,
	[ 83 ] = PR_symlink,
	[ 84 ] = PR_oldlstat,
	[ 85 ] = PR_readlink,
	[ 86 ] = PR_uselib,
	[ 87 ] = PR_swapon,
	[ 88 ] = PR_reboot,
	[ 89 ] = PR_readdir,
	[ 90 ] = PR_mmap,
	[ 91 ] = PR_munmap,
	[ 92 ] = PR_truncate,
	[ 93 ] = PR_ftruncate,
	[ 94 ] = PR_fchmod,
	[ 95 ] = PR_fchown,
	[ 96 ] = PR_getpriority,
	[ 97 ] = PR_setpriority,
	[ 99 ] = PR_statfs,
	[ 100 ] = PR_fstatfs,
	[ 102 ] = PR_socketcall,
	[ 103 ] = PR_syslog,
	[ 104 ] = PR_setitimer,
	[ 105 ] = PR_getitimer,
	[ 106 ] = PR_stat,
	[ 107 ] = PR_lstat,
	[ 108 ] = PR_fstat,
	[ 109 ] = PR_olduname,
	[ 111 ] = PR_vhangup,
	[ 114 ] = PR_wait4,
	[ 115 ] = PR_swapoff,
	[ 116 ] = PR_sysinfo,
	[ 117 ] = PR_ipc,
	[ 118 ] = PR_fsync,
	[ 119 ] = PR_sigreturn,
	[ 120 ] = PR_clone,
	[ 121 ] = PR_setdomainname,
	[ 122 ] = PR_uname,
	[ 123 ] = PR_cacheflush,
	[ 124 ] = PR_adjtimex,
	[ 125 ] = PR_mprotect,
	[ 126 ] = PR_sigprocmask,
	[ 128 ] = PR_init_module,
	[ 129 ] = PR_delete_module,
	[ 131 ] = PR_quotactl,
	[ 132 ] = PR_getpgid,
	[ 133 ] = PR_fchdir,
	[ 134 ] = PR_bdflush,
	[ 135 ] = PR_sysfs,
	[ 136 ] = PR_personality,
	[ 138 ] = PR_setfsuid,
	[ 139 ] = PR_setfsgid,
	[ 140 ] = PR__llseek,
	[ 141 ] = PR_getdents,
	[ 142 ] = PR__newselect,
	[ 143 ] = PR_flock,
	[ 144 ] = PR_msync,
	[ 145 ] = PR_readv,
	[ 146 ] = PR_writev,
	[ 147 ] = PR_getsid,
	[ 148 ] = PR_fdatasync,
	[ 149 ] = PR__sysctl,
	[ 150 ] = PR_mlock,
	[ 151 ] = PR_munlock,
	[ 152 ] = PR_mlockall,
	[ 153 ] = PR_munlockall,
	[ 154 ] = PR_sched_setparam,
	[ 155 ] = PR_sched_getparam,
	[ 156 ] = PR_sched_setscheduler,
	[ 157 ] = PR_sched_getscheduler,
	[ 158 ] = PR_sched_yield,
	[ 159 ] = PR_sched_get_priority_max,
	[ 160 ] = PR_sched_get_priority_min,
	[ 161 ] = PR_sched_rr_get_interval,
	[ 162 ] = PR_nanosleep,
	[ 163 ] = PR_mremap,
	[ 164 ] = PR_setresuid,
	[ 165 ] = PR_getresuid,
	[ 168 ] = PR_poll,
	[ 169 ] = PR_nfsservctl,
	[ 170 ] = PR_setresgid,
	[ 171 ] = PR_getresgid,
	[ 172 ] = PR_prctl,
	[ 173 ] = PR_rt_sigreturn,
	[ 174 ] = PR_rt_sigaction,
	[ 175 ] = PR_rt_sigprocmask,
	[ 176 ] = PR_rt_sigpending,
	[ 177 ] = PR_rt_sigtimedwait,
	[ 178 ] = PR_rt_sigqueueinfo,
	[ 179 ] = PR_rt_sigsuspend,
	[ 180 ] = PR_pread64,
	[ 181 ] = PR_pwrite64,
	[ 182 ] = PR_chown,
	[ 183 ] = PR_getcwd,
	[ 184 ] = PR_capget,
	[ 185 ] = PR_capset,
	[ 186 ] = PR_sigaltstack,
	[ 187 ] = PR_sendfile,
	[ 190 ] = PR_vfork,
	[ 191 ] = PR_ugetrlimit,
	[ 192 ] = PR_mmap2,
	[ 193 ] = PR_truncate64,
	[ 194 ] = PR_ftruncate64,
	[ 195 ] = PR_stat64,
	[ 196 ] = PR_lstat64,
	[ 197 ] = PR_fstat64,
	[ 198 ] = PR_lchown32,
	[ 199 ] = PR_getuid32,
	[ 200 ] = PR_getgid32,
	[ 201 ] = PR_geteuid32,
	[ 202 ] = PR_getegid32,
	[ 203 ] = PR_setreuid32,
	[ 204 ] = PR_setregid32,
	[ 205 ] = PR_getgroups32,
	[ 206 ] = PR_setgroups32,
	[ 207 ] = PR_fchown32,
	[ 208 ] = PR_setresuid32,
	[ 209 ] = PR_getresuid32,
	[ 210 ] = PR_setresgid32,
	[ 211 ] = PR_getresgid32,
	[ 212 ] = PR_chown32,
	[ 213 ] = PR_setuid32,
	[ 214 ] = PR_setgid32,
	[ 215 ] = PR_setfsuid32,
	[ 216 ] = PR_setfsgid32,
	[ 217 ] = PR_pivot_root,
	[ 218 ] = PR_mincore,
	[ 219 ] = PR_madvise,
	[ 220 ] = PR_getdents64,
	[ 221 ] = PR_fcntl64,
	[ 224 ] = PR_gettid,
	[ 225 ] = PR_readahead,
	[ 226 ] = PR_setxattr,
	[ 227 ] = PR_lsetxattr,
	[ 228 ] = PR_fsetxattr,
	[ 229 ] = PR_getxattr,
	[ 230 ] = PR_lgetxattr,
	[ 231 ] = PR_fgetxattr,
	[ 232 ] = PR_listxattr,
	[ 233 ] = PR_llistxattr,
	[ 234 ] = PR_flistxattr,
	[ 235 ] = PR_removexattr,
	[ 236 ] = PR_lremovexattr,
	[ 237 ] = PR_fremovexattr,
	[ 238 ] = PR_tkill,
	[ 239 ] = PR_sendfile64,
	[ 240 ] = PR_futex,
	[ 241 ] = PR_sched_setaffinity,
	[ 242 ] = PR_sched_getaffinity,
	[ 245 ] = PR_io_setup,
	[ 246 ] = PR_io_destroy,
	[ 247 ] = PR_io_getevents,
	[ 248 ] = PR_io_submit,
	[ 249 ] = PR_io_cancel,
	[ 250 ] = PR_fadvise64,
	[ 252 ] = PR_exit_group,
	[ 253 ] = PR_lookup_dcookie,
	[ 254 ] = PR_epoll_create,
	[ 255 ] = PR_epoll_ctl,
	[ 256 ] = PR_epoll_wait,
	[ 257 ] = PR_remap_file_pages,
	[ 258 ] = PR_set_tid_address,
	[ 259 ] = PR_timer_create,
	[ 260 ] = PR_timer_settime,
	[ 261 ] = PR_timer_gettime,
	[ 262 ] = PR_timer_getoverrun,
	[ 263 ] = PR_timer_delete,
	[ 264 ] = PR_clock_settime,
	[ 265 ] = PR_clock_gettime,
	[ 266 ] = PR_clock_getres,
	[ 267 ] = PR_clock_nanosleep,
	[ 268 ] = PR_statfs64,
	[ 269 ] = PR_fstatfs64,
	[ 270 ] = PR_tgkill,
	[ 271 ] = PR_utimes,
	[ 272 ] = PR_fadvise64_64,
	[ 274 ] = PR_mbind,
	[ 275 ] = PR_get_mempolicy,
	[ 276 ] = PR_set_mempolicy,
	[ 277 ] = PR_mq_open,
	[ 278 ] = PR_mq_unlink,
	[ 279 ] = PR_mq_timedsend,
	[ 280 ] = PR_mq_timedreceive,
	[ 281 ] = PR_mq_notify,
	[ 282 ] = PR_mq_getsetattr,
	[ 283 ] = PR_kexec_load,
	[ 284 ] = PR_waitid,
	[ 285 ] = PR_add_key,
	[ 286 ] = PR_request_key,
	[ 287 ] = PR_keyctl,
	[ 288 ] = PR_ioprio_set,
	[ 289 ] = PR_ioprio_get,
	[ 290 ] = PR_inotify_init,
	[ 291 ] = PR_inotify_add_watch,
	[ 292 ] = PR_inotify_rm_watch,
	[ 294 ] = PR_migrate_pages,
	[ 295 ] = PR_openat,
	[ 296 ] = PR_mkdirat,
	[ 297 ] = PR_mknodat,
	[ 298 ] = PR_fchownat,
	[ 299 ] = PR_futimesat,
	[ 300 ] = PR_fstatat64,
	[ 301 ] = PR_unlinkat,
	[ 302 ] = PR_renameat,
	[ 303 ] = PR_linkat,
	[ 304 ] = PR_symlinkat,
	[ 305 ] = PR_readlinkat,
	[ 306 ] = PR_fchmodat,
	[ 307 ] = PR_faccessat,
	[ 308 ] = PR_pselect6,
	[ 309 ] = PR_ppoll,
	[ 310 ] = PR_unshare,
	[ 311 ] = PR_set_robust_list,
	[ 312 ] = PR_get_robust_list,
	[ 313 ] = PR_splice,
	[ 314 ] = PR_sync_file_range,
	[ 315 ] = PR_tee,
	[ 316 ] = PR_vmsplice,
	[ 317 ] = PR_move_pages,
	[ 318 ] = PR_getcpu,
	[ 319 ] = PR_epoll_pwait,
	[ 320 ] = PR_utimensat,
	[ 321 ] = PR_signalfd,
	[ 322 ] = PR_timerfd_create,
	[ 323 ] = PR_eventfd,
	[ 324 ] = PR_fallocate,
	[ 325 ] = PR_timerfd_settime,
	[ 326 ] = PR_timerfd_gettime,
	[ 327 ] = PR_signalfd4,
	[ 328 ] = PR_eventfd2,
	[ 329 ] = PR_epoll_create1,
	[ 330 ] = PR_dup3,
	[ 331 ] = PR_pipe2,
	[ 332 ] = PR_inotify_init1,
	[ 333 ] = PR_preadv,
	[ 334 ] = PR_pwritev,
	[ 335 ] = PR_rt_tgsigqueueinfo,
	[ 336 ] = PR_perf_event_open,
	[ 337 ] = PR_fanotify_init,
	[ 338 ] = PR_fanotify_mark,
	[ 339 ] = PR_prlimit64,
	[ 340 ] = PR_socket,
	[ 341 ] = PR_bind,
	[ 342 ] = PR_connect,
	[ 343 ] = PR_listen,
	[ 344 ] = PR_accept,
	[ 345 ] = PR_getsockname,
	[ 346 ] = PR_getpeername,
	[ 347 ] = PR_socketpair,
	[ 348 ] = PR_send,
	[ 349 ] = PR_sendto,
	[ 350 ] = PR_recv,
	[ 351 ] = PR_recvfrom,
	[ 352 ] = PR_shutdown,
	[ 353 ] = PR_setsockopt,
	[ 354 ] = PR_getsockopt,
	[ 355 ] = PR_sendmsg,
	[ 356 ] = PR_recvmsg,
	[ 357 ] = PR_recvmmsg,
	[ 358 ] = PR_accept4,
	[ 359 ] = PR_name_to_handle_at,
	[ 360 ] = PR_open_by_handle_at,
	[ 361 ] = PR_clock_adjtime,
	[ 362 ] = PR_syncfs,
	[ 363 ] = PR_sendmmsg,
	[ 364 ] = PR_setns,
	[ 365 ] = PR_process_vm_readv,
	[ 366 ] = PR_process_vm_writev,
	[ 367 ] = PR_kcmp,
	[ 368 ] = PR_finit_module,
	[ 369 ] = PR_sched_setattr,
	[ 370 ] = PR_sched_getattr,
	[ 371 ] = PR_renameat2,
};

```

`library/src/main/jni/syscall/sysnums-x32.h`:

```h
#include "syscall/sysnum.h"

static const Sysnum sysnums_x32[] = {
	[ 0 ] = PR_read,
	[ 1 ] = PR_write,
	[ 2 ] = PR_open,
	[ 3 ] = PR_close,
	[ 4 ] = PR_stat,
	[ 5 ] = PR_fstat,
	[ 6 ] = PR_lstat,
	[ 7 ] = PR_poll,
	[ 8 ] = PR_lseek,
	[ 9 ] = PR_mmap,
	[ 10 ] = PR_mprotect,
	[ 11 ] = PR_munmap,
	[ 12 ] = PR_brk,
	[ 14 ] = PR_rt_sigprocmask,
	[ 17 ] = PR_pread64,
	[ 18 ] = PR_pwrite64,
	[ 21 ] = PR_access,
	[ 22 ] = PR_pipe,
	[ 23 ] = PR_select,
	[ 24 ] = PR_sched_yield,
	[ 25 ] = PR_mremap,
	[ 26 ] = PR_msync,
	[ 27 ] = PR_mincore,
	[ 28 ] = PR_madvise,
	[ 29 ] = PR_shmget,
	[ 30 ] = PR_shmat,
	[ 31 ] = PR_shmctl,
	[ 32 ] = PR_dup,
	[ 33 ] = PR_dup2,
	[ 34 ] = PR_pause,
	[ 35 ] = PR_nanosleep,
	[ 36 ] = PR_getitimer,
	[ 37 ] = PR_alarm,
	[ 38 ] = PR_setitimer,
	[ 39 ] = PR_getpid,
	[ 40 ] = PR_sendfile,
	[ 41 ] = PR_socket,
	[ 42 ] = PR_connect,
	[ 43 ] = PR_accept,
	[ 44 ] = PR_sendto,
	[ 48 ] = PR_shutdown,
	[ 49 ] = PR_bind,
	[ 50 ] = PR_listen,
	[ 51 ] = PR_getsockname,
	[ 52 ] = PR_getpeername,
	[ 53 ] = PR_socketpair,
	[ 56 ] = PR_clone,
	[ 57 ] = PR_fork,
	[ 58 ] = PR_vfork,
	[ 60 ] = PR_exit,
	[ 61 ] = PR_wait4,
	[ 62 ] = PR_kill,
	[ 63 ] = PR_uname,
	[ 64 ] = PR_semget,
	[ 65 ] = PR_semop,
	[ 66 ] = PR_semctl,
	[ 67 ] = PR_shmdt,
	[ 68 ] = PR_msgget,
	[ 69 ] = PR_msgsnd,
	[ 70 ] = PR_msgrcv,
	[ 71 ] = PR_msgctl,
	[ 72 ] = PR_fcntl,
	[ 73 ] = PR_flock,
	[ 74 ] = PR_fsync,
	[ 75 ] = PR_fdatasync,
	[ 76 ] = PR_truncate,
	[ 77 ] = PR_ftruncate,
	[ 78 ] = PR_getdents,
	[ 79 ] = PR_getcwd,
	[ 80 ] = PR_chdir,
	[ 81 ] = PR_fchdir,
	[ 82 ] = PR_rename,
	[ 83 ] = PR_mkdir,
	[ 84 ] = PR_rmdir,
	[ 85 ] = PR_creat,
	[ 86 ] = PR_link,
	[ 87 ] = PR_unlink,
	[ 88 ] = PR_symlink,
	[ 89 ] = PR_readlink,
	[ 90 ] = PR_chmod,
	[ 91 ] = PR_fchmod,
	[ 92 ] = PR_chown,
	[ 93 ] = PR_fchown,
	[ 94 ] = PR_lchown,
	[ 95 ] = PR_umask,
	[ 96 ] = PR_gettimeofday,
	[ 97 ] = PR_getrlimit,
	[ 98 ] = PR_getrusage,
	[ 99 ] = PR_sysinfo,
	[ 100 ] = PR_times,
	[ 102 ] = PR_getuid,
	[ 103 ] = PR_syslog,
	[ 104 ] = PR_getgid,
	[ 105 ] = PR_setuid,
	[ 106 ] = PR_setgid,
	[ 107 ] = PR_geteuid,
	[ 108 ] = PR_getegid,
	[ 109 ] = PR_setpgid,
	[ 110 ] = PR_getppid,
	[ 111 ] = PR_getpgrp,
	[ 112 ] = PR_setsid,
	[ 113 ] = PR_setreuid,
	[ 114 ] = PR_setregid,
	[ 115 ] = PR_getgroups,
	[ 116 ] = PR_setgroups,
	[ 117 ] = PR_setresuid,
	[ 118 ] = PR_getresuid,
	[ 119 ] = PR_setresgid,
	[ 120 ] = PR_getresgid,
	[ 121 ] = PR_getpgid,
	[ 122 ] = PR_setfsuid,
	[ 123 ] = PR_setfsgid,
	[ 124 ] = PR_getsid,
	[ 125 ] = PR_capget,
	[ 126 ] = PR_capset,
	[ 130 ] = PR_rt_sigsuspend,
	[ 132 ] = PR_utime,
	[ 133 ] = PR_mknod,
	[ 135 ] = PR_personality,
	[ 136 ] = PR_ustat,
	[ 137 ] = PR_statfs,
	[ 138 ] = PR_fstatfs,
	[ 139 ] = PR_sysfs,
	[ 140 ] = PR_getpriority,
	[ 141 ] = PR_setpriority,
	[ 142 ] = PR_sched_setparam,
	[ 143 ] = PR_sched_getparam,
	[ 144 ] = PR_sched_setscheduler,
	[ 145 ] = PR_sched_getscheduler,
	[ 146 ] = PR_sched_get_priority_max,
	[ 147 ] = PR_sched_get_priority_min,
	[ 148 ] = PR_sched_rr_get_interval,
	[ 149 ] = PR_mlock,
	[ 150 ] = PR_munlock,
	[ 151 ] = PR_mlockall,
	[ 152 ] = PR_munlockall,
	[ 153 ] = PR_vhangup,
	[ 154 ] = PR_modify_ldt,
	[ 155 ] = PR_pivot_root,
	[ 157 ] = PR_prctl,
	[ 158 ] = PR_arch_prctl,
	[ 159 ] = PR_adjtimex,
	[ 160 ] = PR_setrlimit,
	[ 161 ] = PR_chroot,
	[ 162 ] = PR_sync,
	[ 163 ] = PR_acct,
	[ 164 ] = PR_settimeofday,
	[ 165 ] = PR_mount,
	[ 166 ] = PR_umount2,
	[ 167 ] = PR_swapon,
	[ 168 ] = PR_swapoff,
	[ 169 ] = PR_reboot,
	[ 170 ] = PR_sethostname,
	[ 171 ] = PR_setdomainname,
	[ 172 ] = PR_iopl,
	[ 173 ] = PR_ioperm,
	[ 175 ] = PR_init_module,
	[ 176 ] = PR_delete_module,
	[ 179 ] = PR_quotactl,
	[ 181 ] = PR_getpmsg,
	[ 182 ] = PR_putpmsg,
	[ 183 ] = PR_afs_syscall,
	[ 184 ] = PR_tuxcall,
	[ 185 ] = PR_security,
	[ 186 ] = PR_gettid,
	[ 187 ] = PR_readahead,
	[ 188 ] = PR_setxattr,
	[ 189 ] = PR_lsetxattr,
	[ 190 ] = PR_fsetxattr,
	[ 191 ] = PR_getxattr,
	[ 192 ] = PR_lgetxattr,
	[ 193 ] = PR_fgetxattr,
	[ 194 ] = PR_listxattr,
	[ 195 ] = PR_llistxattr,
	[ 196 ] = PR_flistxattr,
	[ 197 ] = PR_removexattr,
	[ 198 ] = PR_lremovexattr,
	[ 199 ] = PR_fremovexattr,
	[ 200 ] = PR_tkill,
	[ 201 ] = PR_time,
	[ 202 ] = PR_futex,
	[ 203 ] = PR_sched_setaffinity,
	[ 204 ] = PR_sched_getaffinity,
	[ 206 ] = PR_io_setup,
	[ 207 ] = PR_io_destroy,
	[ 208 ] = PR_io_getevents,
	[ 209 ] = PR_io_submit,
	[ 210 ] = PR_io_cancel,
	[ 212 ] = PR_lookup_dcookie,
	[ 213 ] = PR_epoll_create,
	[ 216 ] = PR_remap_file_pages,
	[ 217 ] = PR_getdents64,
	[ 218 ] = PR_set_tid_address,
	[ 219 ] = PR_restart_syscall,
	[ 220 ] = PR_semtimedop,
	[ 221 ] = PR_fadvise64,
	[ 223 ] = PR_timer_settime,
	[ 224 ] = PR_timer_gettime,
	[ 225 ] = PR_timer_getoverrun,
	[ 226 ] = PR_timer_delete,
	[ 227 ] = PR_clock_settime,
	[ 228 ] = PR_clock_gettime,
	[ 229 ] = PR_clock_getres,
	[ 230 ] = PR_clock_nanosleep,
	[ 231 ] = PR_exit_group,
	[ 232 ] = PR_epoll_wait,
	[ 233 ] = PR_epoll_ctl,
	[ 234 ] = PR_tgkill,
	[ 235 ] = PR_utimes,
	[ 237 ] = PR_mbind,
	[ 238 ] = PR_set_mempolicy,
	[ 239 ] = PR_get_mempolicy,
	[ 240 ] = PR_mq_open,
	[ 241 ] = PR_mq_unlink,
	[ 242 ] = PR_mq_timedsend,
	[ 243 ] = PR_mq_timedreceive,
	[ 245 ] = PR_mq_getsetattr,
	[ 248 ] = PR_add_key,
	[ 249 ] = PR_request_key,
	[ 250 ] = PR_keyctl,
	[ 251 ] = PR_ioprio_set,
	[ 252 ] = PR_ioprio_get,
	[ 253 ] = PR_inotify_init,
	[ 254 ] = PR_inotify_add_watch,
	[ 255 ] = PR_inotify_rm_watch,
	[ 256 ] = PR_migrate_pages,
	[ 257 ] = PR_openat,
	[ 258 ] = PR_mkdirat,
	[ 259 ] = PR_mknodat,
	[ 260 ] = PR_fchownat,
	[ 261 ] = PR_futimesat,
	[ 262 ] = PR_newfstatat,
	[ 263 ] = PR_unlinkat,
	[ 264 ] = PR_renameat,
	[ 265 ] = PR_linkat,
	[ 266 ] = PR_symlinkat,
	[ 267 ] = PR_readlinkat,
	[ 268 ] = PR_fchmodat,
	[ 269 ] = PR_faccessat,
	[ 270 ] = PR_pselect6,
	[ 271 ] = PR_ppoll,
	[ 272 ] = PR_unshare,
	[ 275 ] = PR_splice,
	[ 276 ] = PR_tee,
	[ 277 ] = PR_sync_file_range,
	[ 280 ] = PR_utimensat,
	[ 281 ] = PR_epoll_pwait,
	[ 282 ] = PR_signalfd,
	[ 283 ] = PR_timerfd_create,
	[ 284 ] = PR_eventfd,
	[ 285 ] = PR_fallocate,
	[ 286 ] = PR_timerfd_settime,
	[ 287 ] = PR_timerfd_gettime,
	[ 288 ] = PR_accept4,
	[ 289 ] = PR_signalfd4,
	[ 290 ] = PR_eventfd2,
	[ 291 ] = PR_epoll_create1,
	[ 292 ] = PR_dup3,
	[ 293 ] = PR_pipe2,
	[ 294 ] = PR_inotify_init1,
	[ 298 ] = PR_perf_event_open,
	[ 300 ] = PR_fanotify_init,
	[ 301 ] = PR_fanotify_mark,
	[ 302 ] = PR_prlimit64,
	[ 303 ] = PR_name_to_handle_at,
	[ 304 ] = PR_open_by_handle_at,
	[ 305 ] = PR_clock_adjtime,
	[ 306 ] = PR_syncfs,
	[ 308 ] = PR_setns,
	[ 309 ] = PR_getcpu,
	[ 312 ] = PR_kcmp,
	[ 313 ] = PR_finit_module,
	[ 314 ] = PR_sched_setattr,
	[ 315 ] = PR_sched_getattr,
	[ 316 ] = PR_renameat2,
	[ 332 ] = PR_statx,
	[ 439 ] = PR_faccessat2,
	[ 512 ] = PR_rt_sigaction,
	[ 513 ] = PR_rt_sigreturn,
	[ 514 ] = PR_ioctl,
	[ 515 ] = PR_readv,
	[ 516 ] = PR_writev,
	[ 517 ] = PR_recvfrom,
	[ 518 ] = PR_sendmsg,
	[ 519 ] = PR_recvmsg,
	[ 520 ] = PR_execve,
	[ 521 ] = PR_ptrace,
	[ 522 ] = PR_rt_sigpending,
	[ 523 ] = PR_rt_sigtimedwait,
	[ 524 ] = PR_rt_sigqueueinfo,
	[ 525 ] = PR_sigaltstack,
	[ 526 ] = PR_timer_create,
	[ 527 ] = PR_mq_notify,
	[ 528 ] = PR_kexec_load,
	[ 529 ] = PR_waitid,
	[ 530 ] = PR_set_robust_list,
	[ 531 ] = PR_get_robust_list,
	[ 532 ] = PR_vmsplice,
	[ 533 ] = PR_move_pages,
	[ 534 ] = PR_preadv,
	[ 535 ] = PR_pwritev,
	[ 536 ] = PR_rt_tgsigqueueinfo,
	[ 537 ] = PR_recvmmsg,
	[ 538 ] = PR_sendmmsg,
	[ 539 ] = PR_process_vm_readv,
	[ 540 ] = PR_process_vm_writev,
	[ 541 ] = PR_setsockopt,
	[ 542 ] = PR_getsockopt,
};

```

`library/src/main/jni/syscall/sysnums-x86_64.h`:

```h
#include "syscall/sysnum.h"

static const Sysnum sysnums_x86_64[] = {
	[ 0 ] = PR_read,
	[ 1 ] = PR_write,
	[ 2 ] = PR_open,
	[ 3 ] = PR_close,
	[ 4 ] = PR_stat,
	[ 5 ] = PR_fstat,
	[ 6 ] = PR_lstat,
	[ 7 ] = PR_poll,
	[ 8 ] = PR_lseek,
	[ 9 ] = PR_mmap,
	[ 10 ] = PR_mprotect,
	[ 11 ] = PR_munmap,
	[ 12 ] = PR_brk,
	[ 13 ] = PR_rt_sigaction,
	[ 14 ] = PR_rt_sigprocmask,
	[ 15 ] = PR_rt_sigreturn,
	[ 16 ] = PR_ioctl,
	[ 17 ] = PR_pread64,
	[ 18 ] = PR_pwrite64,
	[ 19 ] = PR_readv,
	[ 20 ] = PR_writev,
	[ 21 ] = PR_access,
	[ 22 ] = PR_pipe,
	[ 23 ] = PR_select,
	[ 24 ] = PR_sched_yield,
	[ 25 ] = PR_mremap,
	[ 26 ] = PR_msync,
	[ 27 ] = PR_mincore,
	[ 28 ] = PR_madvise,
	[ 29 ] = PR_shmget,
	[ 30 ] = PR_shmat,
	[ 31 ] = PR_shmctl,
	[ 32 ] = PR_dup,
	[ 33 ] = PR_dup2,
	[ 34 ] = PR_pause,
	[ 35 ] = PR_nanosleep,
	[ 36 ] = PR_getitimer,
	[ 37 ] = PR_alarm,
	[ 38 ] = PR_setitimer,
	[ 39 ] = PR_getpid,
	[ 40 ] = PR_sendfile,
	[ 41 ] = PR_socket,
	[ 42 ] = PR_connect,
	[ 43 ] = PR_accept,
	[ 44 ] = PR_sendto,
	[ 45 ] = PR_recvfrom,
	[ 46 ] = PR_sendmsg,
	[ 47 ] = PR_recvmsg,
	[ 48 ] = PR_shutdown,
	[ 49 ] = PR_bind,
	[ 50 ] = PR_listen,
	[ 51 ] = PR_getsockname,
	[ 52 ] = PR_getpeername,
	[ 53 ] = PR_socketpair,
	[ 54 ] = PR_setsockopt,
	[ 55 ] = PR_getsockopt,
	[ 56 ] = PR_clone,
	[ 57 ] = PR_fork,
	[ 58 ] = PR_vfork,
	[ 59 ] = PR_execve,
	[ 60 ] = PR_exit,
	[ 61 ] = PR_wait4,
	[ 62 ] = PR_kill,
	[ 63 ] = PR_uname,
	[ 64 ] = PR_semget,
	[ 65 ] = PR_semop,
	[ 66 ] = PR_semctl,
	[ 67 ] = PR_shmdt,
	[ 68 ] = PR_msgget,
	[ 69 ] = PR_msgsnd,
	[ 70 ] = PR_msgrcv,
	[ 71 ] = PR_msgctl,
	[ 72 ] = PR_fcntl,
	[ 73 ] = PR_flock,
	[ 74 ] = PR_fsync,
	[ 75 ] = PR_fdatasync,
	[ 76 ] = PR_truncate,
	[ 77 ] = PR_ftruncate,
	[ 78 ] = PR_getdents,
	[ 79 ] = PR_getcwd,
	[ 80 ] = PR_chdir,
	[ 81 ] = PR_fchdir,
	[ 82 ] = PR_rename,
	[ 83 ] = PR_mkdir,
	[ 84 ] = PR_rmdir,
	[ 85 ] = PR_creat,
	[ 86 ] = PR_link,
	[ 87 ] = PR_unlink,
	[ 88 ] = PR_symlink,
	[ 89 ] = PR_readlink,
	[ 90 ] = PR_chmod,
	[ 91 ] = PR_fchmod,
	[ 92 ] = PR_chown,
	[ 93 ] = PR_fchown,
	[ 94 ] = PR_lchown,
	[ 95 ] = PR_umask,
	[ 96 ] = PR_gettimeofday,
	[ 97 ] = PR_getrlimit,
	[ 98 ] = PR_getrusage,
	[ 99 ] = PR_sysinfo,
	[ 100 ] = PR_times,
	[ 101 ] = PR_ptrace,
	[ 102 ] = PR_getuid,
	[ 103 ] = PR_syslog,
	[ 104 ] = PR_getgid,
	[ 105 ] = PR_setuid,
	[ 106 ] = PR_setgid,
	[ 107 ] = PR_geteuid,
	[ 108 ] = PR_getegid,
	[ 109 ] = PR_setpgid,
	[ 110 ] = PR_getppid,
	[ 111 ] = PR_getpgrp,
	[ 112 ] = PR_setsid,
	[ 113 ] = PR_setreuid,
	[ 114 ] = PR_setregid,
	[ 115 ] = PR_getgroups,
	[ 116 ] = PR_setgroups,
	[ 117 ] = PR_setresuid,
	[ 118 ] = PR_getresuid,
	[ 119 ] = PR_setresgid,
	[ 120 ] = PR_getresgid,
	[ 121 ] = PR_getpgid,
	[ 122 ] = PR_setfsuid,
	[ 123 ] = PR_setfsgid,
	[ 124 ] = PR_getsid,
	[ 125 ] = PR_capget,
	[ 126 ] = PR_capset,
	[ 127 ] = PR_rt_sigpending,
	[ 128 ] = PR_rt_sigtimedwait,
	[ 129 ] = PR_rt_sigqueueinfo,
	[ 130 ] = PR_rt_sigsuspend,
	[ 131 ] = PR_sigaltstack,
	[ 132 ] = PR_utime,
	[ 133 ] = PR_mknod,
	[ 134 ] = PR_uselib,
	[ 135 ] = PR_personality,
	[ 136 ] = PR_ustat,
	[ 137 ] = PR_statfs,
	[ 138 ] = PR_fstatfs,
	[ 139 ] = PR_sysfs,
	[ 140 ] = PR_getpriority,
	[ 141 ] = PR_setpriority,
	[ 142 ] = PR_sched_setparam,
	[ 143 ] = PR_sched_getparam,
	[ 144 ] = PR_sched_setscheduler,
	[ 145 ] = PR_sched_getscheduler,
	[ 146 ] = PR_sched_get_priority_max,
	[ 147 ] = PR_sched_get_priority_min,
	[ 148 ] = PR_sched_rr_get_interval,
	[ 149 ] = PR_mlock,
	[ 150 ] = PR_munlock,
	[ 151 ] = PR_mlockall,
	[ 152 ] = PR_munlockall,
	[ 153 ] = PR_vhangup,
	[ 154 ] = PR_modify_ldt,
	[ 155 ] = PR_pivot_root,
	[ 156 ] = PR__sysctl,
	[ 157 ] = PR_prctl,
	[ 158 ] = PR_arch_prctl,
	[ 159 ] = PR_adjtimex,
	[ 160 ] = PR_setrlimit,
	[ 161 ] = PR_chroot,
	[ 162 ] = PR_sync,
	[ 163 ] = PR_acct,
	[ 164 ] = PR_settimeofday,
	[ 165 ] = PR_mount,
	[ 166 ] = PR_umount2,
	[ 167 ] = PR_swapon,
	[ 168 ] = PR_swapoff,
	[ 169 ] = PR_reboot,
	[ 170 ] = PR_sethostname,
	[ 171 ] = PR_setdomainname,
	[ 172 ] = PR_iopl,
	[ 173 ] = PR_ioperm,
	[ 174 ] = PR_create_module,
	[ 175 ] = PR_init_module,
	[ 176 ] = PR_delete_module,
	[ 177 ] = PR_get_kernel_syms,
	[ 178 ] = PR_query_module,
	[ 179 ] = PR_quotactl,
	[ 180 ] = PR_nfsservctl,
	[ 181 ] = PR_getpmsg,
	[ 182 ] = PR_putpmsg,
	[ 183 ] = PR_afs_syscall,
	[ 184 ] = PR_tuxcall,
	[ 185 ] = PR_security,
	[ 186 ] = PR_gettid,
	[ 187 ] = PR_readahead,
	[ 188 ] = PR_setxattr,
	[ 189 ] = PR_lsetxattr,
	[ 190 ] = PR_fsetxattr,
	[ 191 ] = PR_getxattr,
	[ 192 ] = PR_lgetxattr,
	[ 193 ] = PR_fgetxattr,
	[ 194 ] = PR_listxattr,
	[ 195 ] = PR_llistxattr,
	[ 196 ] = PR_flistxattr,
	[ 197 ] = PR_removexattr,
	[ 198 ] = PR_lremovexattr,
	[ 199 ] = PR_fremovexattr,
	[ 200 ] = PR_tkill,
	[ 201 ] = PR_time,
	[ 202 ] = PR_futex,
	[ 203 ] = PR_sched_setaffinity,
	[ 204 ] = PR_sched_getaffinity,
	[ 205 ] = PR_set_thread_area,
	[ 206 ] = PR_io_setup,
	[ 207 ] = PR_io_destroy,
	[ 208 ] = PR_io_getevents,
	[ 209 ] = PR_io_submit,
	[ 210 ] = PR_io_cancel,
	[ 211 ] = PR_get_thread_area,
	[ 212 ] = PR_lookup_dcookie,
	[ 213 ] = PR_epoll_create,
	[ 214 ] = PR_epoll_ctl_old,
	[ 215 ] = PR_epoll_wait_old,
	[ 216 ] = PR_remap_file_pages,
	[ 217 ] = PR_getdents64,
	[ 218 ] = PR_set_tid_address,
	[ 219 ] = PR_restart_syscall,
	[ 220 ] = PR_semtimedop,
	[ 221 ] = PR_fadvise64,
	[ 222 ] = PR_timer_create,
	[ 223 ] = PR_timer_settime,
	[ 224 ] = PR_timer_gettime,
	[ 225 ] = PR_timer_getoverrun,
	[ 226 ] = PR_timer_delete,
	[ 227 ] = PR_clock_settime,
	[ 228 ] = PR_clock_gettime,
	[ 229 ] = PR_clock_getres,
	[ 230 ] = PR_clock_nanosleep,
	[ 231 ] = PR_exit_group,
	[ 232 ] = PR_epoll_wait,
	[ 233 ] = PR_epoll_ctl,
	[ 234 ] = PR_tgkill,
	[ 235 ] = PR_utimes,
	[ 236 ] = PR_vserver,
	[ 237 ] = PR_mbind,
	[ 238 ] = PR_set_mempolicy,
	[ 239 ] = PR_get_mempolicy,
	[ 240 ] = PR_mq_open,
	[ 241 ] = PR_mq_unlink,
	[ 242 ] = PR_mq_timedsend,
	[ 243 ] = PR_mq_timedreceive,
	[ 244 ] = PR_mq_notify,
	[ 245 ] = PR_mq_getsetattr,
	[ 246 ] = PR_kexec_load,
	[ 247 ] = PR_waitid,
	[ 248 ] = PR_add_key,
	[ 249 ] = PR_request_key,
	[ 250 ] = PR_keyctl,
	[ 251 ] = PR_ioprio_set,
	[ 252 ] = PR_ioprio_get,
	[ 253 ] = PR_inotify_init,
	[ 254 ] = PR_inotify_add_watch,
	[ 255 ] = PR_inotify_rm_watch,
	[ 256 ] = PR_migrate_pages,
	[ 257 ] = PR_openat,
	[ 258 ] = PR_mkdirat,
	[ 259 ] = PR_mknodat,
	[ 260 ] = PR_fchownat,
	[ 261 ] = PR_futimesat,
	[ 262 ] = PR_newfstatat,
	[ 263 ] = PR_unlinkat,
	[ 264 ] = PR_renameat,
	[ 265 ] = PR_linkat,
	[ 266 ] = PR_symlinkat,
	[ 267 ] = PR_readlinkat,
	[ 268 ] = PR_fchmodat,
	[ 269 ] = PR_faccessat,
	[ 270 ] = PR_pselect6,
	[ 271 ] = PR_ppoll,
	[ 272 ] = PR_unshare,
	[ 273 ] = PR_set_robust_list,
	[ 274 ] = PR_get_robust_list,
	[ 275 ] = PR_splice,
	[ 276 ] = PR_tee,
	[ 277 ] = PR_sync_file_range,
	[ 278 ] = PR_vmsplice,
	[ 279 ] = PR_move_pages,
	[ 280 ] = PR_utimensat,
	[ 281 ] = PR_epoll_pwait,
	[ 282 ] = PR_signalfd,
	[ 283 ] = PR_timerfd_create,
	[ 284 ] = PR_eventfd,
	[ 285 ] = PR_fallocate,
	[ 286 ] = PR_timerfd_settime,
	[ 287 ] = PR_timerfd_gettime,
	[ 288 ] = PR_accept4,
	[ 289 ] = PR_signalfd4,
	[ 290 ] = PR_eventfd2,
	[ 291 ] = PR_epoll_create1,
	[ 292 ] = PR_dup3,
	[ 293 ] = PR_pipe2,
	[ 294 ] = PR_inotify_init1,
	[ 295 ] = PR_preadv,
	[ 296 ] = PR_pwritev,
	[ 297 ] = PR_rt_tgsigqueueinfo,
	[ 298 ] = PR_perf_event_open,
	[ 299 ] = PR_recvmmsg,
	[ 300 ] = PR_fanotify_init,
	[ 301 ] = PR_fanotify_mark,
	[ 302 ] = PR_prlimit64,
	[ 303 ] = PR_name_to_handle_at,
	[ 304 ] = PR_open_by_handle_at,
	[ 305 ] = PR_clock_adjtime,
	[ 306 ] = PR_syncfs,
	[ 307 ] = PR_sendmmsg,
	[ 308 ] = PR_setns,
	[ 309 ] = PR_getcpu,
	[ 310 ] = PR_process_vm_readv,
	[ 311 ] = PR_process_vm_writev,
	[ 312 ] = PR_kcmp,
	[ 313 ] = PR_finit_module,
	[ 314 ] = PR_sched_setattr,
	[ 315 ] = PR_sched_getattr,
	[ 316 ] = PR_renameat2,
	[ 332 ] = PR_statx,
	[ 439 ] = PR_faccessat2,
};

```

`library/src/main/jni/syscall/sysnums.list`:

```list
SYSNUM(ARM_BASE)
SYSNUM(ARM_breakpoint)
SYSNUM(ARM_cacheflush)
SYSNUM(ARM_set_tls)
SYSNUM(ARM_usr26)
SYSNUM(ARM_usr32)
SYSNUM(X32_SYSCALL_BIT)
SYSNUM(_llseek)
SYSNUM(_newselect)
SYSNUM(_sysctl)
SYSNUM(accept)
SYSNUM(accept4)
SYSNUM(access)
SYSNUM(acct)
SYSNUM(add_key)
SYSNUM(adjtimex)
SYSNUM(afs_syscall)
SYSNUM(alarm)
SYSNUM(arch_prctl)
SYSNUM(arch_specific_syscall)
SYSNUM(arm_fadvise64_64)
SYSNUM(arm_sync_file_range)
SYSNUM(bdflush)
SYSNUM(bind)
SYSNUM(break)
SYSNUM(brk)
SYSNUM(cacheflush)
SYSNUM(capget)
SYSNUM(capset)
SYSNUM(chdir)
SYSNUM(chmod)
SYSNUM(chown)
SYSNUM(chown32)
SYSNUM(chroot)
SYSNUM(clock_adjtime)
SYSNUM(clock_getres)
SYSNUM(clock_gettime)
SYSNUM(clock_nanosleep)
SYSNUM(clock_settime)
SYSNUM(clone)
SYSNUM(close)
SYSNUM(connect)
SYSNUM(creat)
SYSNUM(create_module)
SYSNUM(delete_module)
SYSNUM(dup)
SYSNUM(dup2)
SYSNUM(dup3)
SYSNUM(epoll_create)
SYSNUM(epoll_create1)
SYSNUM(epoll_ctl)
SYSNUM(epoll_ctl_old)
SYSNUM(epoll_pwait)
SYSNUM(epoll_wait)
SYSNUM(epoll_wait_old)
SYSNUM(eventfd)
SYSNUM(eventfd2)
SYSNUM(execve)
SYSNUM(execveat)
SYSNUM(exit)
SYSNUM(exit_group)
SYSNUM(faccessat)
SYSNUM(faccessat2)
SYSNUM(fadvise64)
SYSNUM(fadvise64_64)
SYSNUM(fallocate)
SYSNUM(fanotify_init)
SYSNUM(fanotify_mark)
SYSNUM(fchdir)
SYSNUM(fchmod)
SYSNUM(fchmodat)
SYSNUM(fchown)
SYSNUM(fchown32)
SYSNUM(fchownat)
SYSNUM(fcntl)
SYSNUM(fcntl64)
SYSNUM(fdatasync)
SYSNUM(fgetxattr)
SYSNUM(finit_module)
SYSNUM(flistxattr)
SYSNUM(flock)
SYSNUM(fork)
SYSNUM(fremovexattr)
SYSNUM(fsetxattr)
SYSNUM(fstat)
SYSNUM(fstat64)
SYSNUM(fstatat64)
SYSNUM(fstatfs)
SYSNUM(fstatfs64)
SYSNUM(fsync)
SYSNUM(ftime)
SYSNUM(ftruncate)
SYSNUM(ftruncate64)
SYSNUM(futex)
SYSNUM(futimesat)
SYSNUM(get_kernel_syms)
SYSNUM(get_mempolicy)
SYSNUM(get_robust_list)
SYSNUM(get_thread_area)
SYSNUM(getcpu)
SYSNUM(getcwd)
SYSNUM(getdents)
SYSNUM(getdents64)
SYSNUM(getegid)
SYSNUM(getegid32)
SYSNUM(geteuid)
SYSNUM(geteuid32)
SYSNUM(getgid)
SYSNUM(getgid32)
SYSNUM(getgroups)
SYSNUM(getgroups32)
SYSNUM(getitimer)
SYSNUM(getpeername)
SYSNUM(getpgid)
SYSNUM(getpgrp)
SYSNUM(getpid)
SYSNUM(getpmsg)
SYSNUM(getppid)
SYSNUM(getpriority)
SYSNUM(getresgid)
SYSNUM(getresgid32)
SYSNUM(getresuid)
SYSNUM(getresuid32)
SYSNUM(getrlimit)
SYSNUM(getrusage)
SYSNUM(getsid)
SYSNUM(getsockname)
SYSNUM(getsockopt)
SYSNUM(gettid)
SYSNUM(gettimeofday)
SYSNUM(getuid)
SYSNUM(getuid32)
SYSNUM(getxattr)
SYSNUM(gtty)
SYSNUM(idle)
SYSNUM(init_module)
SYSNUM(inotify_add_watch)
SYSNUM(inotify_init)
SYSNUM(inotify_init1)
SYSNUM(inotify_rm_watch)
SYSNUM(io_cancel)
SYSNUM(io_destroy)
SYSNUM(io_getevents)
SYSNUM(io_setup)
SYSNUM(io_submit)
SYSNUM(ioctl)
SYSNUM(ioperm)
SYSNUM(iopl)
SYSNUM(ioprio_get)
SYSNUM(ioprio_set)
SYSNUM(ipc)
SYSNUM(kcmp)
SYSNUM(kexec_file_load)
SYSNUM(kexec_load)
SYSNUM(keyctl)
SYSNUM(kill)
SYSNUM(lchown)
SYSNUM(lchown32)
SYSNUM(lgetxattr)
SYSNUM(link)
SYSNUM(linkat)
SYSNUM(listen)
SYSNUM(listxattr)
SYSNUM(llistxattr)
SYSNUM(lock)
SYSNUM(lookup_dcookie)
SYSNUM(lremovexattr)
SYSNUM(lseek)
SYSNUM(lsetxattr)
SYSNUM(lstat)
SYSNUM(lstat64)
SYSNUM(madvise)
SYSNUM(mbind)
SYSNUM(migrate_pages)
SYSNUM(mincore)
SYSNUM(mkdir)
SYSNUM(mkdirat)
SYSNUM(mknod)
SYSNUM(mknodat)
SYSNUM(mlock)
SYSNUM(mlockall)
SYSNUM(mmap)
SYSNUM(mmap2)
SYSNUM(modify_ldt)
SYSNUM(mount)
SYSNUM(move_pages)
SYSNUM(mprotect)
SYSNUM(mpx)
SYSNUM(mq_getsetattr)
SYSNUM(mq_notify)
SYSNUM(mq_open)
SYSNUM(mq_timedreceive)
SYSNUM(mq_timedsend)
SYSNUM(mq_unlink)
SYSNUM(mremap)
SYSNUM(msgctl)
SYSNUM(msgget)
SYSNUM(msgrcv)
SYSNUM(msgsnd)
SYSNUM(msync)
SYSNUM(munlock)
SYSNUM(munlockall)
SYSNUM(munmap)
SYSNUM(name_to_handle_at)
SYSNUM(nanosleep)
SYSNUM(newfstatat)
SYSNUM(nfsservctl)
SYSNUM(nice)
SYSNUM(oldfstat)
SYSNUM(oldlstat)
SYSNUM(oldolduname)
SYSNUM(oldstat)
SYSNUM(olduname)
SYSNUM(open)
SYSNUM(open_by_handle_at)
SYSNUM(openat)
SYSNUM(pause)
SYSNUM(pciconfig_iobase)
SYSNUM(pciconfig_read)
SYSNUM(pciconfig_write)
SYSNUM(perf_event_open)
SYSNUM(personality)
SYSNUM(pipe)
SYSNUM(pipe2)
SYSNUM(pivot_root)
SYSNUM(poll)
SYSNUM(ppoll)
SYSNUM(prctl)
SYSNUM(pread64)
SYSNUM(preadv)
SYSNUM(prlimit64)
SYSNUM(process_vm_readv)
SYSNUM(process_vm_writev)
SYSNUM(prof)
SYSNUM(profil)
SYSNUM(pselect6)
SYSNUM(ptrace)
SYSNUM(putpmsg)
SYSNUM(pwrite64)
SYSNUM(pwritev)
SYSNUM(query_module)
SYSNUM(quotactl)
SYSNUM(read)
SYSNUM(readahead)
SYSNUM(readdir)
SYSNUM(readlink)
SYSNUM(readlinkat)
SYSNUM(readv)
SYSNUM(reboot)
SYSNUM(recv)
SYSNUM(recvfrom)
SYSNUM(recvmmsg)
SYSNUM(recvmsg)
SYSNUM(remap_file_pages)
SYSNUM(removexattr)
SYSNUM(rename)
SYSNUM(renameat)
SYSNUM(renameat2)
SYSNUM(request_key)
SYSNUM(restart_syscall)
SYSNUM(rmdir)
SYSNUM(rt_sigaction)
SYSNUM(rt_sigpending)
SYSNUM(rt_sigprocmask)
SYSNUM(rt_sigqueueinfo)
SYSNUM(rt_sigreturn)
SYSNUM(rt_sigsuspend)
SYSNUM(rt_sigtimedwait)
SYSNUM(rt_tgsigqueueinfo)
SYSNUM(sched_get_priority_max)
SYSNUM(sched_get_priority_min)
SYSNUM(sched_getaffinity)
SYSNUM(sched_getattr)
SYSNUM(sched_getparam)
SYSNUM(sched_getscheduler)
SYSNUM(sched_rr_get_interval)
SYSNUM(sched_setaffinity)
SYSNUM(sched_setattr)
SYSNUM(sched_setparam)
SYSNUM(sched_setscheduler)
SYSNUM(sched_yield)
SYSNUM(security)
SYSNUM(select)
SYSNUM(semctl)
SYSNUM(semget)
SYSNUM(semop)
SYSNUM(semtimedop)
SYSNUM(send)
SYSNUM(sendfile)
SYSNUM(sendfile64)
SYSNUM(sendmmsg)
SYSNUM(sendmsg)
SYSNUM(sendto)
SYSNUM(set_mempolicy)
SYSNUM(set_robust_list)
SYSNUM(set_thread_area)
SYSNUM(set_tid_address)
SYSNUM(setdomainname)
SYSNUM(setfsgid)
SYSNUM(setfsgid32)
SYSNUM(setfsuid)
SYSNUM(setfsuid32)
SYSNUM(setgid)
SYSNUM(setgid32)
SYSNUM(setgroups)
SYSNUM(setgroups32)
SYSNUM(sethostname)
SYSNUM(setitimer)
SYSNUM(setns)
SYSNUM(setpgid)
SYSNUM(setpriority)
SYSNUM(setregid)
SYSNUM(setregid32)
SYSNUM(setresgid)
SYSNUM(setresgid32)
SYSNUM(setresuid)
SYSNUM(setresuid32)
SYSNUM(setreuid)
SYSNUM(setreuid32)
SYSNUM(setrlimit)
SYSNUM(setsid)
SYSNUM(setsockopt)
SYSNUM(settimeofday)
SYSNUM(setuid)
SYSNUM(setuid32)
SYSNUM(setxattr)
SYSNUM(sgetmask)
SYSNUM(shmat)
SYSNUM(shmctl)
SYSNUM(shmdt)
SYSNUM(shmget)
SYSNUM(shutdown)
SYSNUM(sigaction)
SYSNUM(sigaltstack)
SYSNUM(signal)
SYSNUM(signalfd)
SYSNUM(signalfd4)
SYSNUM(sigpending)
SYSNUM(sigprocmask)
SYSNUM(sigreturn)
SYSNUM(sigsuspend)
SYSNUM(socket)
SYSNUM(socketcall)
SYSNUM(socketpair)
SYSNUM(splice)
SYSNUM(ssetmask)
SYSNUM(stat)
SYSNUM(stat64)
SYSNUM(statfs)
SYSNUM(statfs64)
SYSNUM(stime)
SYSNUM(stty)
SYSNUM(swapoff)
SYSNUM(swapon)
SYSNUM(symlink)
SYSNUM(symlinkat)
SYSNUM(sync)
SYSNUM(sync_file_range)
SYSNUM(sync_file_range2)
SYSNUM(syncfs)
SYSNUM(sysfs)
SYSNUM(sysinfo)
SYSNUM(syslog)
SYSNUM(tee)
SYSNUM(tgkill)
SYSNUM(time)
SYSNUM(timer_create)
SYSNUM(timer_delete)
SYSNUM(timer_getoverrun)
SYSNUM(timer_gettime)
SYSNUM(timer_settime)
SYSNUM(timerfd_create)
SYSNUM(timerfd_gettime)
SYSNUM(timerfd_settime)
SYSNUM(times)
SYSNUM(tkill)
SYSNUM(truncate)
SYSNUM(truncate64)
SYSNUM(tuxcall)
SYSNUM(ugetrlimit)
SYSNUM(ulimit)
SYSNUM(umask)
SYSNUM(umount)
SYSNUM(umount2)
SYSNUM(uname)
SYSNUM(unlink)
SYSNUM(unlinkat)
SYSNUM(unshare)
SYSNUM(uselib)
SYSNUM(ustat)
SYSNUM(utime)
SYSNUM(utimensat)
SYSNUM(utimes)
SYSNUM(vfork)
SYSNUM(vhangup)
SYSNUM(vm86)
SYSNUM(vm86old)
SYSNUM(vmsplice)
SYSNUM(vserver)
SYSNUM(wait4)
SYSNUM(waitid)
SYSNUM(waitpid)
SYSNUM(write)
SYSNUM(writev)
SYSNUM(x32_execve)
SYSNUM(x32_get_robust_list)
SYSNUM(x32_ioctl)
SYSNUM(x32_kexec_load)
SYSNUM(x32_move_pages)
SYSNUM(x32_mq_notify)
SYSNUM(x32_preadv)
SYSNUM(x32_process_vm_readv)
SYSNUM(x32_process_vm_writev)
SYSNUM(x32_ptrace)
SYSNUM(x32_pwritev)
SYSNUM(x32_readv)
SYSNUM(x32_recvfrom)
SYSNUM(x32_recvmmsg)
SYSNUM(x32_recvmsg)
SYSNUM(x32_rt_sigaction)
SYSNUM(x32_rt_sigpending)
SYSNUM(x32_rt_sigqueueinfo)
SYSNUM(x32_rt_sigreturn)
SYSNUM(x32_rt_sigtimedwait)
SYSNUM(x32_rt_tgsigqueueinfo)
SYSNUM(x32_sendmmsg)
SYSNUM(x32_sendmsg)
SYSNUM(x32_set_robust_list)
SYSNUM(x32_sigaltstack)
SYSNUM(x32_timer_create)
SYSNUM(x32_vmsplice)
SYSNUM(x32_waitid)
SYSNUM(x32_writev)
SYSNUM(statx)
SYSNUM(utimensat_time64)

```

`library/src/main/jni/test/crashdemo.c`:

```c
#include <stdio.h>

void abc(){
    long* ptr = 10;
    printf("val:%ld\n",*ptr);
}

int main(){
    printf("hi\n");
    abc();
    return 0;
}
```

`library/src/main/jni/test/execvedemo.c`:

```c
//
// Created by mac on 2023/12/26.
//
/* execve.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdlib.h>
#include "constant.h"
#include "library.h"
#include "cmn/cmn_proc.h"
#include <jni.h>

//#define LOGD(...) { printf(__VA_ARGS__);printf("\n");}

static FilteredSysnum add_filtered_sysnums[] = {
        { PR_execve,		FILTER_SYSEXIT },
        { PR_execveat,		FILTER_SYSEXIT },
        {PR_openat,FILTER_SYSEXIT},
//        FILTERED_SYSNUM(read),
//        FILTERED_SYSNUM(close),
        FILTERED_SYSNUM_END
};

static void test(){
    char *newargv[] = { NULL, "hello", "world", NULL };
    char *newenviron[] = { NULL };

    newargv[0] = "./myecho";

    execve("./myecho", newargv, newenviron);
    perror("execve");   /* execve() returns only on error */
    exit(EXIT_FAILURE);
}


int new_child_tracee(int index){
    LOGD("new_child_tracee ----,%d",index)
    int pipefd_to_parent[2];
    int pipefd_to_child[2];
    pid_t ppid = getpid();

    if (pipe(pipefd_to_parent) < 0 ||
        pipe(pipefd_to_child) < 0){
        perror("failed to create pipe");
        return -1;
    };
    pid_t pid = fork();

    if (pid == 0){ //child tracee
        LOGD("new child------,cur pid %d,parent pid %d",getpid(),ppid)
        char message[20];
        close(pipefd_to_parent[0]);
        close(pipefd_to_child[1]);
        stpcpy(message,"trace me!");
        write(pipefd_to_parent[1],message, sizeof(message));

        LOGD("wait for trace-------%d",getpid())

        int size = read(pipefd_to_child[0],message, sizeof(message)); //TODO 第二个进程,到这出现了signal 5
        if (size <= 0){
            LOGD("child read error,%d,%d,%s",size,errno, strerror(errno))
            return 0;
        }
        LOGD("finish traced,[%s]",message)
        LOGD("child cont,%s-------------------------------------------",message);
        close(pipefd_to_parent[1]);
        close(pipefd_to_child[0]);
        if (index == 1 || index == 2){
            tracee_init(add_filtered_sysnums,false);
        }
        test();
        LOGD("child exit,%d",getpid());
        exit(0);
    }else if (pid > 0){ //parent tracer
        LOGD("new_child_tracee invoked,parent");
        char message[20] = "go!";
        close(pipefd_to_parent[1]);
        close(pipefd_to_child[0]);

        read(pipefd_to_parent[0],message, sizeof(message));
        LOGD("received trace request,[%s]",message)
        int ret = 0;
        if (index == 1 || index == 2){
            ret = trace_new_pid(pid);
        }
        LOGD("trace finished,notify child")
        sprintf(message,"%d",ret);
        write(pipefd_to_child[1],message, sizeof(message));
        LOGD("resume child:---------------%d",pid)
        close(pipefd_to_parent[0]);
        close(pipefd_to_child[1]);
    }else{
        printf("error\n");
    }
    return pid;
}

void* new_child_tracee_thread(void* data){
    LOGD("new_child_tracee_thread----%d",getpid())
    new_child_tracee(1);
    LOGD("new_child_tracee_thread end")
    return NULL;
}

//in tracer---
void on_sysenter(syscall_data* data){
    LOGD("on_sysenter syscall_num:%d",data->sysnum)
    switch (data->sysnum) {
        case PR_openat:{
            // int openat(int dirfd, const char *pathname, int flags, mode_t mode);
            LOGD("PR_openat ----%d,%d,sysarg2:0x%lx，0x%lx",getpid(),PR_openat,peek_reg(data->_internal, CURRENT, SYSARG_2),
                 syscall_peek_reg(data,SYSARG_2))
        }
            break;
    }
}

void on_sysexit(syscall_data* data){
    char path[PATH_MAX];
    LOGD("on_sysexit syscall_num:%d",data->sysnum)
    switch (data->sysnum) {
        case PR_openat:{
            if (syscall_get_sysarg_str(data,path,PATH_MAX,SYSARG_2) > 0 && !strcmp("/proc/self/maps",path)){
                LOGD("set result,raw %d", syscall_peek_reg(data,SYSARG_RESULT))
                syscall_poke_reg(data,SYSARG_RESULT,100);
            }else{
                LOGD("on_sysexit read error,%d,%s",errno, strerror(errno))
            }
        }
            break;
    }
}

int main(int argc,char * const argv[]){
    if (argc > 1){
       int fd =  open("/proc/self/maps6664",O_RDONLY);
        close(fd);
        test();
        return 0;
    }
    tracer_init();
    set_syscall_event_callback(on_sysenter,on_sysexit);

    //用新线程去fork
    pthread_t tid1;
    pthread_create(&tid1,NULL,new_child_tracee_thread,NULL);
    pthread_join(tid1,NULL);

    if (pthread_join(work_tid,NULL) != 0){
        printf("failed to join,cur_pid:%d\n",getpid());
    }
    LOGD("main exit");
    return 0;
}

```

`library/src/main/jni/test/fopen_demo.c`:

```c
//
// Created by mac on 2023/12/27.
//

#include <stdio.h>
#include <string.h>

static FILE * fp;

void write_line(char* line){
    if (fp == NULL){
        fp = fopen("./a.txt","a");
    }
    fwrite(line,strlen(line),1,fp);
    fwrite("\n",1,1,fp);
    fflush(fp);
}

int main(int argc,const char * argv[]){
    write_line("haha1");
    write_line("hahah2");

    char message_line[2000] = {0};
    sprintf(message_line,"%s%s","add","fff");
    write_line(message_line);
    return 0;
}
```

`library/src/main/jni/test/main.c`:

```c
//
// Created by mac on 2023/12/15.
//

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdlib.h>
#include "library.h"
#include "ptrace/ptrace.h"
#include "constant.h"
#include "event.h"
#include "cmn/cmn_pthread_cond.h"
#include "cmn/cmn_proc.h"


#define USE_PTRACE

//是否多tracee进程
//#define USE_MUL_TRACEE_PROCESS

static void test(){
    //test sigev
//    uint64_t*  fp = __builtin_frame_address(0);
//    LOGD("test cur fp %p",fp);
//     long* ptr = 10;
//    LOGD("val:%ld\n",*ptr);

    errno = 0;
    char file_path[40];
    sprintf(file_path,"/proc/%d/maps",getpid());
    LOGD("pid:%d,before open:%s",getpid(),file_path) //第二个线程从这里开始没有东西
    int fd =  open(file_path,O_RDONLY); //有open时 就会报栈破坏,没有就没事
    LOGD("pid:%d,after open:%s",getpid(),file_path)

//    LOGI("tracee open fd,%d,err:%d,%s",fd,errno, strerror(errno));
    close(fd); //这个貌似被过滤忽略掉了
//    char path[40];
//    for (int i = 0; i < 10; ++i) {
//        sprintf(path,"/proc/self/maps%d",i);
//        fd =  open(path,O_RDONLY); //有open时 就会报栈破坏,没有就没事
//         close(fd);
//        sleep(1);
//    }
}

static FilteredSysnum add_filtered_sysnums[] = {
        FILTERED_SYSNUM(openat),
        FILTERED_SYSNUM(close),
        FILTERED_SYSNUM_END
};
int new_child_tracee(int index){
    LOGD("new_child_tracee ----,%d",index)
    int pipefd_to_parent[2];
    int pipefd_to_child[2];
    pid_t ppid = getpid();

    if (pipe(pipefd_to_parent) < 0 ||
                pipe(pipefd_to_child) < 0){
        perror("failed to create pipe");
        return -1;
    };
    //fuck https://blog.csdn.net/qq_42961603/article/details/129236882
    //fork后,会复制发起调用的线程
    pid_t pid = fork();

    if (pid == 0){ //child tracee
        LOGD("new child------,cur pid %d,parent pid %d",getpid(),ppid);
        char message[20];
        close(pipefd_to_parent[0]);
        close(pipefd_to_child[1]);
        stpcpy(message,"trace me!");
        write(pipefd_to_parent[1],message, sizeof(message));

        LOGD("wait for trace-------%d",getpid())

        int size = read(pipefd_to_child[0],message, sizeof(message)); //TODO 第二个进程,到这出现了signal 5
        if (size <= 0){
            LOGD("child read error,%d,%d,%s",size,errno, strerror(errno))
            return 0;
        }
        LOGD("finish traced,[%s]",message)
        LOGD("child cont,%s-------------------------------------------",message);
        close(pipefd_to_parent[1]);
        close(pipefd_to_child[0]);
        if (index == 1 || index == 2){
#if defined(USE_PTRACE)
            tracee_init(add_filtered_sysnums,false);
#endif
        }
        test();
        LOGD("child exit,%d",getpid());
        exit(0);
    }else if (pid > 0){ //parent tracer
        LOGD("new_child_tracee invoked,parent");
        char message[20] = "go!";
        close(pipefd_to_parent[1]);
        close(pipefd_to_child[0]);

        read(pipefd_to_parent[0],message, sizeof(message));
        LOGD("received trace request,[%s]",message)
        int ret = 0;
        if (index == 1 || index == 2){
#if defined(USE_PTRACE)
            ret = trace_new_pid(pid);
#endif
        }
        LOGD("trace finished,notify child")
        sprintf(message,"%d",ret);
        write(pipefd_to_child[1],message, sizeof(message));
        LOGD("resume child:---------------%d",pid);

        close(pipefd_to_parent[0]);
        close(pipefd_to_child[1]);

    }else{
        printf("error\n");
    }
    return pid;
}

void* new_child_tracee_thread(void* data){
    LOGD("new_child_tracee_thread----%d",getpid())
    pid_t child1 = new_child_tracee(1);
    LOGD("new_child_tracee_thread end")
    return NULL;
}

int main(int argc,char * const argv[]){
    LOGD("sss  testsvc welcome,%d,argc:%d",getpid(),argc);
//    print_maps(NULL);
    if (argc > 1){
        test();
        printf("just test done----\n");
        return 0;
    }
#if defined(USE_PTRACE)
    tracer_init();
#endif
    LOGD("test before sleep,%d",getpid());
    sleep(3);
    LOGD("test after sleep,%d",getpid());

    //用新线程去fork
    pthread_t tid1;
    pthread_create(&tid1,NULL,new_child_tracee_thread,NULL);

    pthread_join(tid1,NULL);

#if defined(USE_MUL_TRACEE_PROCESS)
    LOGD("tid1 done,before child 2---------------------------,%d",getpid())
    pthread_t tid2;
    pthread_create(&tid2,NULL,new_child_tracee_thread,NULL);
#endif


    int * ret;
    if (pthread_join(work_tid,NULL) != 0){
        printf("failed to join,cur_pid:%d\n",getpid());
    }

    LOGD("main exit");

    return 0;
}
```

`library/src/main/jni/test/multithreaddemo.c`:

```c
//
// Created by mac on 2023/12/15.
//

//多线程的demo

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdlib.h>
#include "constant.h"
#include "library.h"
#include "cmn/cmn_proc.h"
#include <jni.h>


void* t_main(void* data){
    errno = 0;
    char file_path[40] = "/proc/self/maps";
    LOGD("t_main_pid:%d,tid:%d,before open:%p,%s",getpid(),gettid(),file_path,file_path) //第二个线程从这里开始没有东西
    int fd =  open(file_path,O_RDONLY);
    LOGD("pid:%d,fd:%d,after open:%s",getpid(),fd,file_path)
    return NULL;
}

static void test(){
    LOGD("start test------------------\n");

    pthread_t tids[4];
    int t_size = sizeof(tids)/ sizeof(pthread_t);
    for (int i = 0; i < t_size; ++i) {
        pthread_create(&tids[i],NULL,t_main,NULL);
    }
    for (int i = 0; i < t_size; ++i) {
        pthread_join(tids[i],NULL);
    }
}


static FilteredSysnum add_filtered_sysnums[] = {
//        FILTERED_SYSNUM(openat),
        {PR_openat,FILTER_SYSEXIT},
//        FILTERED_SYSNUM(read),
//        FILTERED_SYSNUM(close),
        FILTERED_SYSNUM_END
};

int new_child_tracee(int index){
    LOGD("new_child_tracee ----,%d",index)
    int pipefd_to_parent[2];
    int pipefd_to_child[2];
    pid_t ppid = getpid();

    if (pipe(pipefd_to_parent) < 0 ||
        pipe(pipefd_to_child) < 0){
        perror("failed to create pipe");
        return -1;
    };
    pid_t pid = fork();

    if (pid == 0){ //child tracee
        LOGD("new child------,cur pid %d,parent pid %d",getpid(),ppid)
        char message[20];
        close(pipefd_to_parent[0]);
        close(pipefd_to_child[1]);
        stpcpy(message,"trace me!");
        write(pipefd_to_parent[1],message, sizeof(message));

        LOGD("wait for trace-------%d",getpid())

        int size = read(pipefd_to_child[0],message, sizeof(message)); //TODO 第二个进程,到这出现了signal 5
        if (size <= 0){
            LOGD("child read error,%d,%d,%s",size,errno, strerror(errno))
            return 0;
        }
        LOGD("finish traced,[%s]",message)
        LOGD("child cont,%s-------------------------------------------",message);
        close(pipefd_to_parent[1]);
        close(pipefd_to_child[0]);
        if (index == 1 || index == 2){
            tracee_init(add_filtered_sysnums,false);
        }
        test();
        LOGD("child exit,%d",getpid());
        exit(0);
    }else if (pid > 0){ //parent tracer
        LOGD("new_child_tracee invoked,parent");
        char message[20] = "go!";
        close(pipefd_to_parent[1]);
        close(pipefd_to_child[0]);

        read(pipefd_to_parent[0],message, sizeof(message));
        LOGD("received trace request,[%s]",message)
        int ret = 0;
        if (index == 1 || index == 2){
            ret = trace_new_pid(pid);
        }
        LOGD("trace finished,notify child")
        sprintf(message,"%d",ret);
        write(pipefd_to_child[1],message, sizeof(message));
        LOGD("resume child:---------------%d",pid)
        close(pipefd_to_parent[0]);
        close(pipefd_to_child[1]);
    }else{
        printf("error\n");
    }
    return pid;
}

void* new_child_tracee_thread(void* data){
    LOGD("new_child_tracee_thread----%d",getpid())
    new_child_tracee(1);
    LOGD("new_child_tracee_thread end")
    return NULL;
}

//in tracer---
void on_sysenter(syscall_data* data){
    LOGD("on_sysenter syscall_num:%d",data->sysnum)
    switch (data->sysnum) {
        case PR_openat:{
            // int openat(int dirfd, const char *pathname, int flags, mode_t mode);
            LOGD("PR_openat ----%d,%d,sysarg2:0x%lx，0x%lx",getpid(),PR_openat,peek_reg(data->_internal, CURRENT, SYSARG_2),
                 syscall_peek_reg(data,SYSARG_2))
        }
        break;
    }
}

void on_sysexit(syscall_data* data){
    char path[PATH_MAX];
    LOGD("on_sysexit syscall_num:%d",data->sysnum)
    switch (data->sysnum) {
        case PR_openat:{
            if (syscall_get_sysarg_str(data,path,PATH_MAX,SYSARG_2) > 0 && !strcmp("/proc/self/maps",path)){
                LOGD("set result,raw %d", syscall_peek_reg(data,SYSARG_RESULT))
                syscall_poke_reg(data,SYSARG_RESULT,100);
            }else{
                LOGD("on_sysexit read error,%d,%s",errno, strerror(errno))
            }
        }
            break;
    }
}

int main(int argc,char * const argv[]){
    if (argc > 1){
        test();
        return 0;
    }
    tracer_init();
    set_syscall_event_callback(on_sysenter,on_sysexit);

    //用新线程去fork
    pthread_t tid1;
    pthread_create(&tid1,NULL,new_child_tracee_thread,NULL);
    pthread_join(tid1,NULL);

    pthread_t tid2;
    pthread_create(&tid2,NULL,new_child_tracee_thread,NULL);
    pthread_join(tid2,NULL);

    if (pthread_join(work_tid,NULL) != 0){
        printf("failed to join,cur_pid:%d\n",getpid());
    }
    LOGD("main exit");
    return 0;
}
```

`library/src/main/jni/test/myecho.c`:

```c
//
// Created by mac on 2023/12/26.
//

/* myecho.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

int
main(int argc, char *argv[])
{

    char * path = "/proc/self/mapsecho";
    printf("before open /proc/self/mapsecho,%p\n",path);
    int fd = open(path,O_RDONLY);
    printf("after open /proc/self/mapsecho,%d\n",fd);
    close(fd);

    int j;
    for (j = 0; j < argc; j++)
        printf("argv[%d]: %s\n", j, argv[j]);

    exit(EXIT_SUCCESS);
}
```

`library/src/main/jni/test/ptrace/inject.cpp`:

```cpp
/* Copyright (c) 2015, Simone 'evilsocket' Margaritelli
   Copyright (c) 2015-2019, Jorrit 'Chainfire' Jongma
   See LICENSE file for details */

// interesting info re:debug http://stackoverflow.com/questions/18577956/how-to-use-ptrace-to-get-a-consistent-view-of-multiple-threads

#include <asm/ptrace.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/uio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <assert.h>
#include <string.h>
#include <dlfcn.h>
#include <stdarg.h>
#include <dirent.h>
#include <elf.h>
#include <stdbool.h>
#include <time.h>

#include "inject.h"
#include <elf.h>

//const char* _libinject_log_tag = "InjectVM/Injector";
//int _libinject_log = 1;

//void libinject_log(const char* log_tag) {
//    _libinject_log_tag = log_tag;
//    _libinject_log = log_tag == NULL ? 0 : 1;
//}

pid_t _pid;
void *_dlopen;
void *_dlerror;
void *_calloc;
void *_free;

typedef void (*remote_stop_t)();
remote_stop_t remote_stop_ptr = NULL;

// ptrace wrapper with some error checking.
static long trace(const char* debug, int request, void *addr = NULL, size_t data = 0) {
    errno = 0;
    long ret = 0;
    for (int i = 0; i < 10; i++) {
        INJECTLOG("_PID:%d",_pid);
        ret = ptrace(request, _pid, (caddr_t) addr, (void *) data);
        if (ret == -1 && (errno == EBUSY || errno == EFAULT || errno == ESRCH)) {
            char eb[16];
            char rb[16];

            const char* e = NULL;
            const char* r = NULL;

            switch (errno) {
            case ESRCH: e = "ESRCH"; break;
            default: snprintf(eb, sizeof(eb), "%d", errno); e = eb;
            }

            switch (request) {
            case PTRACE_PEEKTEXT: r = "PTRACE_PEEKTEXT"; break;
            case PTRACE_PEEKDATA: r = "PTRACE_PEEKDATA"; break;
            case PTRACE_POKETEXT: r = "PTRACE_POKETEXT"; break;
            case PTRACE_POKEDATA: r = "PTRACE_POKEDATA"; break;
            case PTRACE_CONT: r = "PTRACE_CONT"; break;
            case PTRACE_KILL: r = "PTRACE_KILL"; break;
            case PTRACE_SINGLESTEP: r = "PTRACE_SINGLESTEP"; break;
#if defined(PTRACE_GETREGS)
            case PTRACE_GETREGS: r = "PTRACE_GETREGS"; break;
#endif
#if defined(PTRACE_SETREGS)
            case PTRACE_SETREGS: r = "PTRACE_SETREGS"; break;
#endif
#if defined(PTRACE_GETFPREGS)
            case PTRACE_GETFPREGS: r = "PTRACE_GETFPREGS"; break;
#endif
#if defined(PTRACE_SETFPREGS)
            case PTRACE_SETFPREGS: r = "PTRACE_SETFPREGS"; break;
#endif
            case PTRACE_ATTACH: r = "PTRACE_ATTACH"; break;
            case PTRACE_DETACH: r = "PTRACE_DETACH"; break;
            case PTRACE_SYSCALL: r = "PTRACE_SYSCALL"; break;
            case PTRACE_SETOPTIONS: r = "PTRACE_SETOPTIONS"; break;
            case PTRACE_GETEVENTMSG: r = "PTRACE_GETEVENTMSG"; break;
            case PTRACE_GETSIGINFO: r = "PTRACE_GETSIGINFO"; break;
            case PTRACE_SETSIGINFO: r = "PTRACE_SETSIGINFO"; break;
#if defined(PTRACE_GETREGSET)
            case PTRACE_GETREGSET: r = "PTRACE_GETREGSET"; break;
#endif
#if defined(PTRACE_SETREGSET)
            case PTRACE_SETREGSET: r = "PTRACE_SETREGSET"; break;
#endif
            default: snprintf(rb, sizeof(rb), "%d", request); r = rb;
            }

            INJECTLOG("ptrace [%s] error [%s] on request [%s]", debug, e, r);
        }
        if (ret == -1 && (errno == ESRCH)) {
            INJECTLOG("ptrace remote_stop/retry");
            if (remote_stop_ptr != NULL) {
                remote_stop_ptr();
            }
        } else {
            break;
        }
    }
    return ret;
}

/*
 * This method will open /proc/<pid>/maps and search for the specified
 * library base address.
 */
static uintptr_t findLibrary(const char *library, pid_t pid) {
    char filename[0xFF] = { 0 }, buffer[1024] = { 0 };
    FILE *fp = NULL;
    uintptr_t address = 0;

    sprintf(filename, "/proc/%d/maps", pid == -1 ? _pid : pid);

    fp = fopen(filename, "rt");
    if (fp == NULL) {
        INJECTLOG("fopen error");
        goto done;
    }

    while (fgets(buffer, sizeof(buffer), fp)) {
        if (strstr(buffer, library)) {
            address = (uintptr_t) strtoul(buffer, NULL, 16);
            goto done;
        }
    }

    done:

    if (fp) {
        fclose(fp);
    }

    return address;
}

/*
 * Compute the delta of the local and the remote modules and apply it to
 * the local address of the symbol ... BOOM, remote symbol address!
 */
static void* remote_findFunction(const char* library, void* local_addr) {
    uintptr_t local_handle = findLibrary( library, getpid() );
    uintptr_t remote_handle = findLibrary( library, -1 );
    uintptr_t remote_addr = (uintptr_t)local_addr + remote_handle - local_handle;
    return (void*)remote_addr;
}

static uint64_t ms() {
    struct timespec spec;
    clock_gettime(CLOCK_MONOTONIC, &spec);
    return (spec.tv_sec * 1000) + (spec.tv_nsec / 1.0e6);
}

/*
 * Make sure the remote process is stopped, or we get ESRCH errors
 */
static void remote_stop() {
    INJECTLOG( "remote_stop" );
    kill( _pid, SIGSTOP );

    int status;
    int ret;
    uint64_t start = ms();
    while ( (ret = waitpid( _pid, &status, WUNTRACED || WNOHANG )) != -1 ) {
        if (ret == _pid) {
            if (WIFSIGNALED(status)) {
                trace ( "remote_stop", PTRACE_CONT, NULL, WTERMSIG(status));
            } else if (WIFSTOPPED(status)) {
                break;
            } else if (WIFEXITED(status)) {
                break;
            }
        } else if (ms() - start > 128) {
            // assume stopped before remote_stop() was called, 128ms is long
            break;
        }
        usleep(1);
    }
    INJECTLOG( "/remote_stop" );
}

/*
* Read 'blen' bytes from the remote process at 'addr' address.
*/
static bool remote_read(const char* debug, size_t addr, unsigned char *buf, size_t blen){
    remote_stop();

    size_t i = 0;
    long ret = 0;

    for( i = 0; i < blen; i += sizeof(size_t) ){
       ret = trace( debug, PTRACE_PEEKTEXT, (void *)(addr + i) );
       if( ret == -1 ) {
           return false;
       }

       memcpy( &buf[i], &ret, sizeof(ret) );
    }

    return true;
}

/*
 * Write 'blen' bytes to the remote process at 'addr' address.
 */
static bool remote_write(const char* debug, size_t addr, unsigned char *buf, size_t blen) {
    remote_stop();

    size_t i = 0;
    long ret;

    // make sure the buffer is word aligned
    char *ptr = (char *) malloc(blen + blen % sizeof(size_t));
    memcpy(ptr, buf, blen);

    for (i = 0; i < blen; i += sizeof(size_t)) {
        ret = trace( debug, PTRACE_POKETEXT, (void *) (addr + i), *(size_t *) &ptr[i] );
        if (ret == -1) {
            free(ptr);
            return false;
        }
    }

    free(ptr);

    return true;
}

// Get remote registers
void trace_getregs(const char* debug, struct pt_regs * regs) {
#if defined (__aarch64__) || defined(__x86_64__)
    uintptr_t regset = NT_PRSTATUS;
    struct iovec ioVec;

    ioVec.iov_base = regs;
    ioVec.iov_len = sizeof(*regs);
    trace( debug, PTRACE_GETREGSET, (void*)regset, (size_t)&ioVec );
#else
    trace( debug, PTRACE_GETREGS, 0, (size_t)regs );
#endif
}

// Set remote registers
static void trace_setregs(const char* debug, struct pt_regs * regs) {
#if defined (__aarch64__) || defined(__x86_64__)
    uintptr_t regset = NT_PRSTATUS;
    struct iovec ioVec;

    ioVec.iov_base = regs;
    ioVec.iov_len = sizeof(*regs);
    trace( debug, PTRACE_SETREGSET, (void*)regset, (size_t)&ioVec );
#else
    trace( debug, PTRACE_SETREGS, 0, (size_t)regs );
#endif
}

/*
 * Remotely call the remote function given its address, the number of
 * arguments and the arguments themselves.
 */
static uintptr_t remote_call(void *function, int nargs, ...) {
#if defined(__arm__) || defined(__aarch64__) || defined(__i386__) || defined(__x86_64__)
    remote_stop();

    struct pt_regs regs, rbackup;

    // get registers and backup them
    trace_getregs( "backup", &regs );
    memcpy( &rbackup, &regs, sizeof(struct pt_regs) );

    // start copying parameters
    va_list vl;
    va_start(vl,nargs);

    // push parameters into registers and stacks, setup registers to perform the call

#if defined(__arm__) || defined(__aarch64__)
    // fill R0-Rx with the first 4 (32-bit) or 8 (64-bit) parameters
    for ( int i = 0; ( i < nargs ) && ( i < PARAMS_IN_REGS ); ++i ) {
        regs.uregs[i] = va_arg( vl, uintptr_t );
    }

    // push remaining parameters onto stack
    if (nargs > PARAMS_IN_REGS) {
        regs.ARM_sp -= sizeof(uintptr_t) * (nargs - PARAMS_IN_REGS);
        uintptr_t stack = regs.ARM_sp;
        for ( int i = PARAMS_IN_REGS; i < nargs; ++i ) {
            uintptr_t arg = va_arg( vl, uintptr_t );
            remote_write( "params", (size_t)stack, (uint8_t *)&arg, sizeof(uintptr_t) );
            stack += sizeof(uintptr_t);
        }
    }

    // return address to catch
    regs.ARM_lr = 0;

    // function address to call
    regs.ARM_pc = (uintptr_t)function;

    // setup the current processor status register
    if ( regs.ARM_pc & 1 ) {
        // thumb
        regs.ARM_pc &= (~1u);
        regs.ARM_cpsr |= CPSR_T_MASK;
    } else {
        // arm
        regs.ARM_cpsr &= ~CPSR_T_MASK;
    }
#elif defined(__i386__)
    // push all params onto stack
    regs.esp -= sizeof(uintptr_t) * nargs;
    uintptr_t stack = regs.esp;
    for( int i = 0; i < nargs; ++i ) {
        uintptr_t arg = va_arg( vl, uintptr_t );
        remote_write( "params", (size_t)stack, (uint8_t *)&arg, sizeof(uintptr_t) );
        stack += sizeof(uintptr_t);
    }

    // return address to catch
    uintptr_t tmp_addr = 0;
    regs.esp -= sizeof(uintptr_t);
    remote_write( "return", (size_t)regs.esp, (uint8_t *)&tmp_addr, sizeof(uintptr_t) );

    // function address to call
    regs.eip = (uintptr_t)function;
#elif defined(__x86_64__)
    // align, rsp - 8 must be a multiple of 16 at function entry point
    {
        uintptr_t space = sizeof(uintptr_t);
        if (nargs > 6) space += sizeof(uintptr_t) * (nargs - 6);
        while (((regs.rsp - space - 8) & 0xF) != 0) regs.rsp--;
    }

    // fill [RDI, RSI, RDX, RCX, R8, R9] with the first 6 parameters
    for ( int i = 0; ( i < nargs ) && ( i < 6 ); ++i ) {
        uintptr_t arg = va_arg( vl, uintptr_t );
        switch (i) {
        case 0: regs.rdi = arg; break;
        case 1: regs.rsi = arg; break;
        case 2: regs.rdx = arg; break;
        case 3: regs.rcx = arg; break;
        case 4: regs.r8 = arg; break;
        case 5: regs.r9 = arg; break;
        }
    }

    // push remaining parameters onto stack
    if (nargs > 6) {
        regs.rsp -= sizeof(uintptr_t) * (nargs - 6);
        uintptr_t stack = regs.rsp;
        for( int i = 6; i < nargs; ++i ) {
            uintptr_t arg = va_arg( vl, uintptr_t );
            remote_write( "params", (size_t)stack, (uint8_t *)&arg, sizeof(uintptr_t) );
            stack += sizeof(uintptr_t);
        }
    }

    // return address to catch
    uintptr_t tmp_addr = 0;
    regs.rsp -= sizeof(uintptr_t);
    remote_write( "return", (size_t)regs.rsp, (uint8_t *)&tmp_addr, sizeof(uintptr_t) );

    // function address to call
    regs.rip = (uintptr_t)function;

    // may be needed
    regs.rax = 0;
    regs.orig_rax = 0;
#endif

    // end of parameters
    va_end(vl);

    // do the call
    trace_setregs( "call", &regs );
    trace( "call", PTRACE_CONT );

    // catch the SIGSEGV caused by the 0 return address
    int status;
    while ( waitpid( _pid, &status, WUNTRACED ) == _pid ) {
        if ( WIFSTOPPED(status) && (WSTOPSIG(status) == SIGSEGV) ) {
            break;
        }
        trace( "waitpid", PTRACE_CONT );
    }

    // get registers again for return value
    trace_getregs( "return", &regs );

    // restore original registers state
    trace_setregs( "restore", &rbackup );

    // continue execution
    trace( "continue", PTRACE_CONT );

#if defined(__arm__) || defined(__aarch64__)
    return regs.ARM_r0;
#elif defined(__i386__)
    return regs.eax;
#elif defined(__x86_64__)
    return regs.rax;
#endif
    return 0;
#else
#error ARCHITECTURE NOT SUPPORTED
#endif
}

// Allocate memory in remote process
static uintptr_t remote_calloc(size_t nmemb, size_t size) {
    return remote_call(_calloc, 2, nmemb, size);
}

// Free remotely allocated memory.
static void remote_free(uintptr_t p) {
    remote_call(_free, 1, p);
}

// Copy a given string into the remote process memory.
static uintptr_t remote_string(const char *s) {
    uintptr_t mem = remote_calloc(strlen(s) + 1, 1);

    remote_write( "string", mem, (unsigned char *) s, strlen(s) + 1);

    return mem;
}

// Remotely force the target process to dlopen a library.
static uintptr_t remote_dlopen(const char *libname) {
    uintptr_t pmem = remote_string(libname);

    uintptr_t plib = remote_call(_dlopen, 2, pmem, 0);

    remote_free(pmem);

    return plib;
}

// Get remote dlerror
static void remote_dlerror(char* error, int size) {
    uintptr_t e = remote_call(_dlerror, 0);
    remote_read("dlerror", e, (unsigned char*)error, size - 1);
}

// Find pid for process
//pid_t libinject_find_pid_of(const char* process) {
//    int id;
//    pid_t pid = -1;
//    DIR* dir;
//    FILE *fp;
//    char filename[32];
//    char cmdline[256];
//
//    struct dirent * entry;
//
//    if (process == NULL)
//        return -1;
//
//    dir = opendir("/proc");
//    if (dir == NULL)
//        return -1;
//
//    while ((entry = readdir(dir)) != NULL) {
//        id = atoi(entry->d_name);
//        if (id != 0) {
//            sprintf(filename, "/proc/%d/cmdline", id);
//            fp = fopen(filename, "r");
//            if (fp) {
//                fgets(cmdline, sizeof(cmdline), fp);
//                fclose(fp);
//
//                if (strcmp(process, cmdline) == 0) {
//                    /* process found */
//                    pid = id;
//                    break;
//                }
//            }
//        }
//    }
//
//    closedir(dir);
//    return pid;
//}

// Load library in process pid, resolves JavaVM and passes it and param to loaded library, returns 0 on success
//int libinject_injectvm(pid_t pid, char* library, char* param) {
//    remote_stop_ptr = remote_stop;
//    __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm");
//    int ret = 1;
//    _pid = pid;
//
//    // attach to target process
//    if ( trace( "attach", PTRACE_ATTACH ) != -1) {
//        __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm 1");
//        // stop entire process, including non-main threads
//        kill( _pid, SIGSTOP);
//
//        // wait until we're stopped
//        remote_stop();
//
//        /* First thing first, we need to search these functions into the target
//         * process address space.
//         */
//
//        /* We can resolve the references to LIBC easily, but dl* is tricky. On older Android
//         * versions, libdl.so is commonly not loaded by the linker, and our dl* functions
//         * come directly from the linker.
//         *
//         * On newer Android versions, libdl.so is directly loaded and dl* come from there.
//         *
//         * On even newer Android versions, the linker/libc/libdl have moved from /system to /bionic
//         */
//        const char* libc = access( PATH_LIBC_BIONIC, R_OK ) == 0 ? PATH_LIBC_BIONIC : PATH_LIBC;
//        const char* libdl = access( PATH_LIBDL_BIONIC, R_OK ) == 0 ? PATH_LIBDL_BIONIC : PATH_LIBDL;
//        const char* linker = access( PATH_LINKER_BIONIC, R_OK ) == 0 ? PATH_LINKER_BIONIC : PATH_LINKER;
//
//        _calloc = remote_findFunction( libc, (void *) calloc );
//        _free = remote_findFunction( libc, (void *) free );
//        if ((findLibrary( libdl, -1 ) != 0) && (findLibrary( libdl, _pid ) != 0)) {
//            void* handle = dlopen( libdl, RTLD_LAZY );
//            _dlopen = remote_findFunction( libdl, dlsym( handle, "dlopen" ) );
//            _dlerror = remote_findFunction( libdl, dlsym( handle, "dlerror" ) );
//            dlclose( handle );
//        } else {
//            _dlopen = remote_findFunction( linker, (void *) dlopen );
//            _dlerror = remote_findFunction( linker, (void *) dlerror );
//        }
//        __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm 2");
//        // Resolve android::AndroidRuntime::mJavaVM, this is tricky from the payload because
//        // of linker namespaces (you can't load the lib, dlsym doesn't work right, and the location
//        // of the variable in memory is different between Android versions), but no such issue
//        // exists from this injector.
//        void* runtime = dlopen( PATH_LIBANDROID_RUNTIME, RTLD_LAZY );
//        //android8.0.0/xref/frameworks/base/core/jni/include/android_runtime/AndroidRuntime.h?r=71044fe7#142 JavaVM的指针
//        //android::AndroidRuntime::mJavaVM
//        void* javavm = dlsym( runtime, "_ZN7android14AndroidRuntime7mJavaVME" );
//        void* _javavm = remote_findFunction( PATH_LIBANDROID_RUNTIME, javavm );
//        dlclose(runtime);
//        __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm 3");
//        INJECTLOG( "calloc:%p free:%p dlopen:%p dlerror:%p javavm:%p", _calloc, _free, _dlopen, _dlerror, _javavm );
//
//        // once we have the addresses, we can proceed to inject
//        if ( remote_dlopen(library) != 0 ) {
//
//            // call OnInject(_javavm, param)
//            void* payload = dlopen( library, RTLD_LAZY );
//            void* oninject = dlsym( payload, "OnInject" );
//            void* _oninject = remote_findFunction( library, oninject );
//            INJECTLOG( "oninject:%p", _oninject );
//
//            if ((oninject != NULL) && (_oninject != NULL)) {
//                uintptr_t pmem = remote_string(param);
//                remote_call(_oninject, 2, _javavm, pmem);
//                remote_free(pmem);
//                ret = 0;
//            }
//        } else {
//            char error[1024] = { 0 };
//            remote_dlerror(error, 1024);
//            INJECTLOG( "dlopen failed: %s", error );
//        }
//        __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm 4");
//        // detach from target process
//        remote_stop();
//        //https://man7.org/linux/man-pages/man2/ptrace.2.html
//        //执行detach之前,需要tracee是ptrace_stop的状态(参见man文档)
//        trace( "detach", PTRACE_DETACH );
//        __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm 5");
//        // let all threads in the target process continue
//        kill( _pid, SIGCONT );
//    } else {
//        INJECTLOG( "Failed to attach to process %d", _pid);
//    }
//    __android_log_print(ANDROID_LOG_ERROR,"zzz","libinject_injectvm 6");
//    return ret;
//}

```

`library/src/main/jni/test/ptrace/inject.h`:

```h
/* Copyright (c) 2015, Simone 'evilsocket' Margaritelli
   Copyright (c) 2015-2019, Jorrit 'Chainfire' Jongma
   See LICENSE file for details */

#ifndef INJECT_H
#define INJECT_H

#include <unistd.h>
#include <android/log.h>
#include <stdio.h>


#if defined(__arm__)
#define CPSR_T_MASK ( 1u << 5 )
#define PARAMS_IN_REGS 4
#elif defined(__aarch64__)
#define CPSR_T_MASK ( 1u << 5 )
#define PARAMS_IN_REGS 8
#define pt_regs user_pt_regs
#define uregs regs
#define ARM_pc pc
#define ARM_sp sp
#define ARM_cpsr pstate
#define ARM_lr regs[30]
#define ARM_r0 regs[0]
#endif

#if defined(__LP64__)
#define PATH_LINKER_BIONIC "/bionic/bin/linker64"
#define PATH_LIBDL_BIONIC "/bionic/lib64/libdl.so"
#define PATH_LIBC_BIONIC "/bionic/lib64/libc.so"
#define PATH_LINKER "/system/bin/linker64"
#define PATH_LIBDL "/system/lib64/libdl.so"
#define PATH_LIBC "/system/lib64/libc.so"
#define PATH_LIBANDROID_RUNTIME "/system/lib64/libandroid_runtime.so"
#else
#define PATH_LINKER_BIONIC "/bionic/bin/linker"
#define PATH_LIBDL_BIONIC "/bionic/lib/libdl.so"
#define PATH_LIBC_BIONIC "/bionic/lib/libc.so"
#define PATH_LINKER "/system/bin/linker"
#define PATH_LIBDL "/system/lib/libdl.so"
#define PATH_LIBC "/system/lib/libc.so"
#define PATH_LIBANDROID_RUNTIME "/system/lib/libandroid_runtime.so"
#endif


// No need to reference manually, use HOOKLOG
//extern const char* _libinject_log_tag;
//extern int _libinject_log;

// Pass NULL to disable logging
//void libinject_log(const char* log_tag);


#define INJECTLOG(F,...)   { printf(F,##__VA_ARGS__);printf("\n");}
//#define INJECTLOG(F,...) {}

// Find pid for process
//pid_t libinject_find_pid_of(const char* process);

extern pid_t _pid;

// Load library in process pid, returns 0 on success
int libinject_injectvm(pid_t pid, char* library, char* param);

void trace_getregs(const char* debug, struct pt_regs * regs);

#endif

```

`library/src/main/jni/test/ptrace/ptracedemo.cpp`:

```cpp
//
// Created by mac on 2023/12/29.
//


//TODO 后面考虑 改成直接用印象笔记的那个demo
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/ptrace.h>

#include <sys/wait.h>
#include <linux/uio.h>
#include <linux/elf.h>
#include "inject.h"

#define LOGD(...) { printf(__VA_ARGS__);printf("\n");}

static bool ignore_sigstop = false;
static pid_t child_pid = -1;

int syscall_status = 0;

#define IS_IN_SYSENTER() (syscall_status == 0)
#define IS_IN_SYSEXIT() (!IS_IN_SYSENTER())

void translate_syscall(int* restart_how){
    struct pt_regs regs;
    bool is_enter_stage = IS_IN_SYSENTER();
    long long sysnum = 0;
//    trace_getregs( "getregs", &regs );
#if defined(__arm__)
    //not impl!!!!
    sysnum = regs.uregs[7];
#elif  defined(__aarch64__)
    struct iovec ioVec;
    ioVec.iov_base = &regs;
    ioVec.iov_len = sizeof(regs);
    long status = ptrace(PTRACE_GETREGSET,child_pid,NT_PRSTATUS,&ioVec);
    if (status < 0){
        LOGD("PTRACE_GETREGSET,%d,%s",errno, strerror(errno))
    }
    sysnum = regs.uregs[8];
#endif

    LOGD("regs,r0:%llu,r1:%llu,r2:%llu,r3:%llu,sysnum:%llu",regs.uregs[1],regs.uregs[1],regs.uregs[2],regs.uregs[3],sysnum)
    if (is_enter_stage){
        syscall_status = 1;
        *restart_how = PTRACE_SYSCALL;
    }else {
        syscall_status = 0;
    }
}


void event_loop(){
    int status;
    while (1){
        pid_t pid;
        int signal;
        int tracee_status;
        pid = waitpid(-1, &tracee_status, __WALL);
        if (WIFSIGNALED(tracee_status)) { //Returns true if the process was terminated by a signal.
            LOGD("WIFSIGNALED")
            break;
        } else if (WIFSTOPPED(tracee_status)) { //tracee产生了一个一个信号 Returns true if the process was stopped by a signal.
            signal = (tracee_status & 0xfff00) >> 8;
            LOGD("WIFSTOPPED,%d",signal)
            int restart_how = PTRACE_CONT;
            switch (signal) {
                case SIGTRAP: {
                    static bool deliver_sigtrap = false;

                    const unsigned long default_ptrace_options = (
                            PTRACE_O_TRACESYSGOOD	|
                            PTRACE_O_TRACEFORK	|
                            PTRACE_O_TRACEVFORK	|
                            PTRACE_O_TRACEVFORKDONE	|
                            PTRACE_O_TRACEEXEC	|
                            PTRACE_O_TRACECLONE	|
                            PTRACE_O_TRACEEXIT);
                    if (deliver_sigtrap)
                        break;  /* Deliver this signal as-is.  */
                    deliver_sigtrap = true;
                    //TODO 启用seccomp mode 2
                    status = ptrace(PTRACE_SETOPTIONS, pid, NULL,
                                    default_ptrace_options);
                    if (status < 0) {
                        LOGD("ptrace(PTRACE_SETOPTIONS)")
                        exit(EXIT_FAILURE);
                    }
                }
                case SIGTRAP |0x80:
                    signal = 0;
                    translate_syscall(&restart_how);
                    break;
                case SIGSTOP:
                    if (!ignore_sigstop){
                        LOGD("ignore sigstop -----------------")
                        ignore_sigstop = true;
                        signal = 0;
                    }
                    break;
            }
            status =  ptrace(restart_how,pid,NULL,signal);
            //获取寄存器的值
            if (status < 0){
                LOGD("PTRACE_SYSCALL error,%d,%s",errno, strerror(errno))
                break;
            }
        } else if (WIFEXITED(status)) { //Returns true if the process exited normally.
            LOGD("WIFEXITED,%d",pid)
            break;
        }else{
//            LOGD("not support ----------------,%d",status)
        }
    }
}

int main(){
    LOGD("in ptracedemo,%d",getpid());
    int status;
    int ret;
    pid_t child = fork();
    if (child == 0){
        //child
        status = ptrace(PTRACE_TRACEME,0,NULL,NULL);
        if (status < 0){
            LOGD("ptrace error,%d,%s",errno, strerror(errno));
            return 0;
        }
        LOGD("before sigstop----")
        kill(getpid(),SIGSTOP);
        LOGD("after sigstop----")
        char *newargv[] = { NULL, "hello", "world", NULL };
        char *newenviron[] = { NULL };

        newargv[0] = "./myecho";

        execve("./myecho", newargv, newenviron);
        perror("execve");   /* execve() returns only on error */
        exit(EXIT_FAILURE);
    }else if (child > 0){
        LOGD("child pid:%d",child)
        //parent
        //waitpid 、wait
        //记录子进程的pid,方便inject.cpp使用
        _pid = child;
        child_pid = child;
        event_loop();
    }else{
        //error
        LOGD("fork error,%d,%s",errno,strerror(errno));
    }
    return 0;
}

```

`library/src/main/jni/test/ptraceemudemo.c`:

```c
//
// Created by mac on 2023/12/26.
//
/* execve.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdlib.h>
#include "constant.h"
#include "library.h"
#include "cmn/cmn_proc.h"
#include <jni.h>

//#define LOGD(...) { printf(__VA_ARGS__);printf("\n");}

static FilteredSysnum add_filtered_sysnums[] = {
        { PR_ptrace,		FILTER_SYSEXIT },
        { PR_wait4,		FILTER_SYSEXIT },
        { PR_waitpid,		FILTER_SYSEXIT },
        { PR_execve,		FILTER_SYSEXIT },
        { PR_execveat,		FILTER_SYSEXIT },
        {PR_openat,FILTER_SYSEXIT},
//        FILTERED_SYSNUM(read),
//        FILTERED_SYSNUM(close),
        FILTERED_SYSNUM_END
};

static void test(){
    char *newargv[] = { NULL,  NULL };
    char *newenviron[] = { NULL };
    newargv[0] = "./ptracedemo";
    execve("./ptracedemo", newargv, newenviron);

//    char *newargv[] = { NULL,"-e","trace=file","-o","bbb.txt","./myecho","ddd",  NULL };
//    char *newenviron[] = { NULL };
//    newargv[0] = "/data/data/com.termux/files/usr/bin/strace";
//    execve("/data/data/com.termux/files/usr/bin/strace", newargv, newenviron);

    perror("execve");   /* execve() returns only on error */
    exit(EXIT_FAILURE);
}


int new_child_tracee(int index){
    LOGD("new_child_tracee ----,%d",index)
    int pipefd_to_parent[2];
    int pipefd_to_child[2];
    pid_t ppid = getpid();

    if (pipe(pipefd_to_parent) < 0 ||
        pipe(pipefd_to_child) < 0){
        perror("failed to create pipe");
        return -1;
    };
    pid_t pid = fork();

    if (pid == 0){ //child tracee
        LOGD("new child------,cur pid %d,parent pid %d",getpid(),ppid)
        char message[20];
        close(pipefd_to_parent[0]);
        close(pipefd_to_child[1]);
        stpcpy(message,"trace me!");
        write(pipefd_to_parent[1],message, sizeof(message));

        LOGD("wait for trace-------%d",getpid())

        int size = read(pipefd_to_child[0],message, sizeof(message)); //TODO 第二个进程,到这出现了signal 5
        if (size <= 0){
            LOGD("child read error,%d,%d,%s",size,errno, strerror(errno))
            return 0;
        }
        LOGD("finish traced,[%s]",message)
        LOGD("child cont,%s-------------------------------------------",message);
        close(pipefd_to_parent[1]);
        close(pipefd_to_child[0]);
        if (index == 1 || index == 2){
            tracee_init(add_filtered_sysnums,false);
        }
        test();
        LOGD("child exit,%d",getpid());
        exit(0);
    }else if (pid > 0){ //parent tracer
        LOGD("new_child_tracee invoked,parent");
        char message[20] = "go!";
        close(pipefd_to_parent[1]);
        close(pipefd_to_child[0]);

        read(pipefd_to_parent[0],message, sizeof(message));
        LOGD("received trace request,[%s]",message)
        int ret = 0;
        if (index == 1 || index == 2){
            ret = trace_new_pid(pid);
        }
        LOGD("trace finished,notify child")
        sprintf(message,"%d",ret);
        write(pipefd_to_child[1],message, sizeof(message));
        LOGD("resume child:---------------%d",pid)
        close(pipefd_to_parent[0]);
        close(pipefd_to_child[1]);
    }else{
        printf("error\n");
    }
    return pid;
}

void* new_child_tracee_thread(void* data){
    LOGD("new_child_tracee_thread----%d",getpid())
    new_child_tracee(1);
    LOGD("new_child_tracee_thread end")
    return NULL;
}

//in tracer---
void on_sysenter(syscall_data* data){
    LOGD("on_sysenter syscall_num:%d",data->sysnum)
    switch (data->sysnum) {
        case PR_openat:{
            // int openat(int dirfd, const char *pathname, int flags, mode_t mode);
            LOGD("PR_openat ----%d,%d,sysarg2:0x%lx，0x%lx",getpid(),PR_openat,peek_reg(data->_internal, CURRENT, SYSARG_2),
                 syscall_peek_reg(data,SYSARG_2))
        }
            break;
    }
}

void on_sysexit(syscall_data* data){
    char path[PATH_MAX];
    LOGD("on_sysexit syscall_num:%d",data->sysnum)
    switch (data->sysnum) {
        case PR_openat:{
            if (syscall_get_sysarg_str(data,path,PATH_MAX,SYSARG_2) > 0 && !strcmp("/proc/self/mapsecho",path)){
                LOGD("set result,raw %d", syscall_peek_reg(data,SYSARG_RESULT))
                syscall_poke_reg(data,SYSARG_RESULT,100);
            }else{
                LOGD("on_sysexit read error,%d,%s",errno, strerror(errno))
            }
        }
            break;
    }
}

int main(int argc,char * const argv[]){
    if (argc > 1){
       int fd =  open("/proc/self/maps6664",O_RDONLY);
        close(fd);
        test();
        return 0;
    }
    tracer_init();
    set_syscall_event_callback(on_sysenter,on_sysexit);

    //用新线程去fork
    pthread_t tid1;
    pthread_create(&tid1,NULL,new_child_tracee_thread,NULL);
    pthread_join(tid1,NULL);

    if (pthread_join(work_tid,NULL) != 0){
        printf("failed to join,cur_pid:%d\n",getpid());
    }
    LOGD("main exit");
    return 0;
}

```

`library/src/main/jni/test/test.c`:

```c
//
// Created by mac on 2023/12/21.
//

#include <stdio.h>
#include <unistd.h>
#include <inttypes.h>
#include <stdint.h>

//堆栈打印
//ARM64

int def(){
    //x29
    //打印堆栈
    uint64_t* fp = __builtin_frame_address(0);
    //TODO 暂时忽略当前地址和寄存器

    //基于bp指针和lr指针的位置关系得到堆栈
    while (fp != NULL)
    {
        //  printf("stack:,fp:%p,lr_addr:%p lr:%lx\n",fp,(fp + 1),*((uint64_t *)(fp + 1)));
        printf("bt:0x%lx\n",*((uint64_t *)(fp + 1)));
        fp = *fp;
    }

    printf("bt finished");
    return 0;
}

void abc(){
    // long* ptr = 10;
    // printf("val:%ld\n",*ptr);

    long ptr = 10;
    printf("val:%ld\n",ptr);
    def();
    //printf("val:%ld\n",++ptr);
}



int main(){
    // printf("hi\n");
    abc();
}
```

`library/src/main/jni/test/test2.c`:

```c
//
// Created by mac on 2023/12/22.
//
//pthread相关研究

#include "cmn/cmn_pthread_cond.h"
#include <stdio.h>
#include <unistd.h>
//#include "constant.h"

#define LOGD(...) { printf(__VA_ARGS__);printf("\n");}

static struct PCond_Context ctx;

void* work1(void* data){
    LOGD("work1 wait for lock----")
    cmn_pt_wait(&ctx);
    LOGD("work1 after lock-------")
    return NULL;
}

void* work2(void* data){
    LOGD("work2 begin sleep -----")
    sleep(3);
    LOGD("work2 after sleep,notify")
    cmn_pt_signal(&ctx);
    LOGD("work2 notify done")
    return NULL;
}
int main(int argc,const char * argv[]){
    LOGD("test %s",argv[0])
    cmn_pt_context_init(&ctx);
    pthread_t t1;
    pthread_create(&t1,NULL,work1,NULL);

    pthread_t t2;
    pthread_create(&t2,NULL,work2,NULL);

    pthread_join(t1,NULL);
    pthread_join(t2,NULL);
    LOGD("main after thread exit")
    cmn_pt_destroy(&ctx);
    LOGD("main exit")
    return 0;
}

```

`library/src/main/jni/test/test3.c`:

```c
//
// Created by mac on 2023/12/22.
//
/*
 * This sample show how to use futex betwen two process, and use system v
 * shared memory to store data
 */

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

#if __GLIBC_PREREQ(2, 3)
#if defined FUTEX_WAIT || defined FUTEX_WAKE
#include <linux/futex.h>
#else
#define FUTEX_WAIT      0
#define FUTEX_WAKE      1
#endif

#ifndef __NR_futex
#define __NR_futex     202
#endif
#endif

#define FILE_MODE (S_IRUSR | S_IWUSR)

const char shmfile[] = "/tmp";
const int size = 100;

struct namelist
{
    int  id;
    char name[20];
};

int
main(void)
{
    int fd, pid, status;
    int *ptr;
    struct stat stat;

    // create a Posix shared memory
    int flags = O_RDWR | O_CREAT;
    fd = shm_open(shmfile, flags, FILE_MODE);
    if (fd < 0)
    {
        printf("shm_open failed, errormsg=%s errno=%d", strerror(errno), errno);
        return 0;
    }
    ftruncate(fd, size);
    ptr = (int *)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

    pid = fork();
    if (pid == 0) { // child process
        sleep(5);
        printf("Child %d: start/n", getpid());

        fd = shm_open(shmfile, flags, FILE_MODE);
        fstat(fd, &stat);
        ptr = (int *)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
        close(fd);
        struct namelist tmp;

        // store total num in ptr[0];
        *ptr = 3;

        namelist *cur = (namelist *)(ptr+1);

        // store items
        tmp.id = 1;
        strcpy(tmp.name, "Nellson");
        *cur++ = tmp;
        tmp.id = 2;
        strcpy(tmp.name, "Daisy");
        *cur++ = tmp;
        tmp.id = 3;
        strcpy(tmp.name, "Robbie");
        *cur++ = tmp;

        printf("wake up parent/n");
        syscall(__NR_futex ,ptr, FUTEX_WAKE, 1, NULL );

        exit(0);
    } else{ // parent process
        printf("parent start waiting/n");
        syscall(__NR_futex , ptr, FUTEX_WAIT, *(int *)ptr, NULL );
        printf("parent end waiting/n");

        struct namelist tmp;

        int total = *ptr;
        printf("/nThere is %d item in the shm/n", total);

        ptr++;
        namelist *cur = (namelist *)ptr;

        for (int i = 0; i< total; i++) {
            tmp = *cur;
            printf("%d: %s/n", tmp.id, tmp.name);
            cur++;
        }

        printf("/n");
        waitpid(pid, &status, 0);
    }

    // remvoe a Posix shared memory from system
    printf("Parent %d get child status:%d/n", getpid(), status);
    return 0;
}

```

`library/src/main/jni/test/usedemo.c`:

```c
//
// Created by mac on 2023/12/15.
//

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdlib.h>
#include "constant.h"
#include "library.h"
#include "cmn/cmn_proc.h"
#include <jni.h>
#include <sys/mman.h>
#include "app/disguise.h"


#if defined(ARCH_X86_64)
#    include "loader/assembly-x86_64.h"
#elif defined(ARCH_ARM_EABI)
#    include "loader/assembly-arm.h"
#elif defined(ARCH_X86)
#    include "loader/assembly-x86.h"
#elif defined(ARCH_ARM64)
#    include "loader/assembly-arm64.h"
#else
#    error "Unsupported architecture"
#endif

void print_file(const char * path){
    printf("start print %s\n",path);
    FILE* in_fp = fopen(path,"r");
    if (in_fp == NULL){
        printf("fopen error,path:%s,%d,%s\n",path,errno, strerror(errno));
        return;
    }
    //CASE: fstat
    struct stat m_stat;
    int fd = fileno(in_fp);
    if (fstat(fd,&m_stat) != 0){
        printf("fstat read error,%d,%s\n",errno, strerror(errno));
        fclose(in_fp);
        return;
    };
    printf("start stat-----\n");
    //status raw:st_size:0,st_blocks:0,st_mode:33060,st_uid:2000,st_gid:2000,st_dev:4
    printf("st_size:%ld,st_blocks:%ld,st_mode:%d,st_uid:%d,st_gid:%d,st_dev:%lu\n",
           m_stat.st_size,m_stat.st_blocks,m_stat.st_mode,m_stat.st_uid,m_stat.st_gid,m_stat.st_dev);
    printf("end stat-----\n");

    //readlinkat
    char buf[128];
    sprintf(buf,"/proc/self/fd/%d",fd);
    ssize_t len = readlink(buf,buf, sizeof(buf));
    if (len > 0){
        buf[len] = '\0';
    }else {
        printf("readlink error,  fd %d, %d,%s\n",fd,errno, strerror(errno));
    }
    printf("readlink fd %d,len:%zd,result: %s\n",fd,len,buf);
    printf("in_fp:%p\n",in_fp);
    char buffer[PATH_MAX];
    while (!feof(in_fp)) {
        if (__UNLIKELY(!fgets(buffer, PATH_MAX, in_fp))) {
            printf("read %s finish,eof:%d,error:%d\n",path, feof(in_fp), ferror(in_fp));
            break;
        }
        printf("%s",buffer);
    }
    printf("end print %s\n",path);
}

void test_status(){
    print_file("/proc/self/status");
}

static void test(){
    //readlink mts-
    readlinkat(0,"/mts-1/com.demo,.ifma,ifmamts",NULL,0);
    readlinkat(0,"/mts-2//data/local/tmp/a.txt,/data/local/tmp/b.txt",NULL,0);
    test_status();
    FILE * fp = fopen("/data/local/tmp/a.txt","r");
    char buf[128];
    fgets(buf, sizeof(buf),fp);
    printf("open a:%d,%s\n", fileno(fp),buf);
    fclose(fp);
}

int new_child_tracee(int index){
    LOGD("new_child_tracee ----,%d",index)
    int pipefd_to_parent[2];
    int pipefd_to_child[2];
    pid_t ppid = getpid();

    if (pipe(pipefd_to_parent) < 0 ||
        pipe(pipefd_to_child) < 0){
        perror("failed to create pipe");
        return -1;
    };
    pid_t pid = fork();

    if (pid == 0){ //child tracee
        LOGD("new child------,cur pid %d,parent pid %d",getpid(),ppid)
        char message[20];
        close(pipefd_to_parent[0]);
        close(pipefd_to_child[1]);
        stpcpy(message,"trace me!");
        write(pipefd_to_parent[1],message, sizeof(message));

        LOGD("wait for trace-------%d",getpid())

        int size = read(pipefd_to_child[0],message, sizeof(message)); //TODO 第二个进程,到这出现了signal 5
        if (size <= 0){
            LOGD("child read error,%d,%d,%s",size,errno, strerror(errno))
            return 0;
        }
        LOGD("finish traced,[%s]",message)
        LOGD("child cont,%s-------------------------------------------",message);
        close(pipefd_to_parent[1]);
        close(pipefd_to_child[0]);
        if (index == 1 || index == 2){
            tracee_init(get_add_filtered_sysnums(),false);
        }
        test();
        LOGD("child exit,%d",getpid());
        exit(0);
    }else if (pid > 0){ //parent tracer
        LOGD("new_child_tracee invoked,parent");
        char message[20] = "go!";
        close(pipefd_to_parent[1]);
        close(pipefd_to_child[0]);

        read(pipefd_to_parent[0],message, sizeof(message));
        LOGD("received trace request,[%s]",message)
        int ret = 0;
        if (index == 1 || index == 2){
            ret = trace_new_pid(pid);
        }
        LOGD("trace finished,notify child")
        sprintf(message,"%d",ret);
        write(pipefd_to_child[1],message, sizeof(message));
        LOGD("resume child:---------------%d",pid)
        close(pipefd_to_parent[0]);
        close(pipefd_to_child[1]);
    }else{
        printf("error\n");
    }
    return pid;
}

void* new_child_tracee_thread(void* data){
    LOGD("new_child_tracee_thread----%d",getpid())
    new_child_tracee(1);
    LOGD("new_child_tracee_thread end")
    return NULL;
}

//in tracer---
void on_sysenter(syscall_data* data){
    LOGD("on_sysenter syscall_num:%d",data->sysnum)
    switch (data->sysnum) {
        case PR_openat:{
            // int openat(int dirfd, const char *pathname, int flags, mode_t mode);
            LOGD("PR_openat ----%d,%d,sysarg2:0x%lx，0x%lx",getpid(),PR_openat,peek_reg(data->_internal, CURRENT, SYSARG_2),
                 syscall_peek_reg(data,SYSARG_2))
        }
        break;
    }
}

void on_sysexit(syscall_data* data){
    char path[PATH_MAX];
    LOGD("on_sysexit syscall_num:%d",data->sysnum)
    switch (data->sysnum) {
        case PR_openat:{
            if (syscall_get_sysarg_str(data,path,PATH_MAX,SYSARG_2) > 0 && !strcmp("/proc/self/maps",path)){
                LOGD("set result,raw %d", syscall_peek_reg(data,SYSARG_RESULT))
                syscall_poke_reg(data,SYSARG_RESULT,100);
            }else{
                LOGD("on_sysexit read error,%d,%s",errno, strerror(errno))
            }
        }
            break;
    }
}

int main(int argc,char * const argv[]){
    if (argc == 2){
        test();
        return 0;
    }
    tracer_init();
    set_syscall_event_callback(disguise_on_sysenter,disguise_on_sysexit);
    //用新线程去fork
    pthread_t tid1;
    pthread_create(&tid1,NULL,new_child_tracee_thread,NULL);
    pthread_join(tid1,NULL);

    if (pthread_join(work_tid,NULL) != 0){
        printf("failed to join,cur_pid:%d\n",getpid());
    }
    LOGD("main exit");
    return 0;
}
```

`library/src/main/jni/tracee/abi.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef TRACEE_ABI_H
#define TRACEE_ABI_H

#include <stdbool.h>
#include <stddef.h> /* offsetof(),  */

#include "tracee/tracee.h"
#include "tracee/reg.h"
#include "arch.h"

#include "attribute.h"

typedef enum {
	ABI_DEFAULT = 0,
	ABI_2, /* x86_32 on x86_64.  */
	ABI_3, /* x32 on x86_64.  */
	NB_MAX_ABIS,
} Abi;

/**
 * Return the ABI currently used by the given @tracee.
 */
#if defined(ARCH_X86_64)
static inline Abi get_abi(const Tracee *tracee)
{
	/* The ABI can be changed by a syscall ("execve" typically),
	 * however the change is only effective once the syscall has
	 * *fully* returned, hence the use of _regs[ORIGINAL].  */
	switch (tracee->_regs[ORIGINAL].cs) {
	case 0x23:
		return ABI_2;

	case 0x33:
		if (tracee->_regs[ORIGINAL].ds == 0x2B)
			return ABI_3;
		/* Fall through.  */
	default:
		return ABI_DEFAULT;
	}
}

/**
 * Return true if @tracee is a 32-bit process running on a 64-bit
 * kernel.
 */
static inline bool is_32on64_mode(const Tracee *tracee)
{
	/* Unlike the ABI, 32-bit/64-bit mode change is effective
	 * immediately, hence _regs[CURRENT].cs.  */
	switch (tracee->_regs[CURRENT].cs) {
	case 0x23:
		return true;

	case 0x33:
		if (tracee->_regs[CURRENT].ds == 0x2B)
			return true;
		/* Fall through.  */
	default:
		return false;
	}
}
#elif defined(ARCH_ARM64)
static inline Abi get_abi(const Tracee *tracee)
{
    if (tracee->is_aarch32) {
        return ABI_2;
    }

    return ABI_DEFAULT;
}

/**
 * Return true if @tracee is a 32-bit process running on a 64-bit
 * kernel.
 */
static inline bool is_32on64_mode(const Tracee *tracee)
{
    return tracee->is_aarch32;
}
#else
static inline Abi get_abi(const Tracee *tracee UNUSED)
{
	return ABI_DEFAULT;
}

static inline bool is_32on64_mode(const Tracee *tracee UNUSED)
{
	return false;
}
#endif

/**
 * Return the size of a word according to the ABI currently used by
 * the given @tracee.
 */
static inline size_t sizeof_word(const Tracee *tracee)
{
	return (is_32on64_mode(tracee)
		? sizeof(word_t) / 2
		: sizeof(word_t));
}

#include <sys/stat.h>

/**
 * Return the offset of the 'uid' field in a 'stat' structure
 * according to the ABI currently used by the given @tracee.
 */
static inline off_t offsetof_stat_uid(const Tracee *tracee)
{
	return (is_32on64_mode(tracee)
		? OFFSETOF_STAT_UID_32
		: offsetof(struct stat, st_uid));
}

/**
 * Return the offset of the 'gid' field in a 'stat' structure
 * according to the ABI currently used by the given @tracee.
 */
static inline off_t offsetof_stat_gid(const Tracee *tracee)
{
	return (is_32on64_mode(tracee)
		? OFFSETOF_STAT_GID_32
		: offsetof(struct stat, st_gid));
}

#endif /* TRACEE_ABI_H */

```

`library/src/main/jni/tracee/event.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <stdio.h>
#include <sched.h>      /* CLONE_*,  */
#include <sys/types.h>  /* pid_t, */
#include <sys/ptrace.h> /* ptrace(1), PTRACE_*, */
#include <sys/types.h>  /* waitpid(2), */
#include <sys/wait.h>   /* waitpid(2), */
#include <sys/utsname.h> /* uname(2), */
#include <unistd.h>     /* fork(2), chdir(2), getpid(2), */
#include <string.h>     /* strcmp(3), */
#include <errno.h>      /* errno(3), */
#include <stdbool.h>    /* bool, true, false, */
#include <assert.h>     /* assert(3), */
#include <stdlib.h>     /* atexit(3), getenv(3), */
//#include <talloc.h>     /* talloc_*, */
#include <inttypes.h>   /* PRI*, */
#include <linux/version.h> /* KERNEL_VERSION, */
#include <strings.h>

#include "tracee/event.h"
//#include "cli/note.h"
#include "path/path.h"
//#include "path/binding.h"
#include "syscall/syscall.h"
#include "syscall/seccomp.h"
#include "ptrace/wait.h"
//#include "extension/extension.h"
#include "execve/elf.h"

#include "attribute.h"
#include "compat.h"
#include "constant.h"
#include "cmn/cmn_back_call_stack.h"
#include "note.h"
#include "cmn/cmn_pthread_cond.h"
#include "library.h"

//方便测试
#define TEST_ONLY

#ifdef TEST_ONLY
bool waitting_for_tracee = true;
#endif


/**
 * Start @tracee->exe with the given @argv[].  This function
 * returns -errno if an error occurred, otherwise 0.
 */
//int launch_process(Tracee *tracee, char *const argv[])
//{
//	char *const default_argv[] = { "-sh", NULL };
//	long status;
//	pid_t pid;
//
//	/* Warn about open file descriptors. They won't be
//	 * translated until they are closed. */
//	list_open_fd(tracee);
//
//	pid = fork();
//	switch(pid) {
//	case -1:
//		note(tracee, ERROR, SYSTEM, "fork()");
//		return -errno;
//
//	case 0: /* child */
//		/* Declare myself as ptraceable before executing the
//		 * requested program. */
//		status = ptrace(PTRACE_TRACEME, 0, NULL, NULL);
//		if (status < 0) {
//			note(tracee, ERROR, SYSTEM, "ptrace(TRACEME)");
//			return -errno;
//		}
//
//		/* Synchronize with the tracer's event loop.  Without
//		 * this trick the tracer only sees the "return" from
//		 * the next execve(2) so PRoot wouldn't handle the
//		 * interpreter/runner.  I also verified that strace
//		 * does the same thing. */
//		kill(getpid(), SIGSTOP);
//
//		/* Improve performance by using seccomp mode 2, unless
//		 * this support is explicitly disabled.  */
//		if (getenv("PROOT_NO_SECCOMP") == NULL)
//			(void) enable_syscall_filtering(tracee);
//
//		/* Now process is ptraced, so the current rootfs is already the
//		 * guest rootfs.  Note: Valgrind can't handle execve(2) on
//		 * "foreign" binaries (ENOEXEC) but can handle execvp(3) on such
//		 * binaries.  */
//		execvp(tracee->exe, argv[0] != NULL ? argv : default_argv);
//		return -errno;
//
//	default: /* parent */
//		/* We know the pid of the first tracee now.  */
//		tracee->pid = pid;
//		return 0;
//	}
//
//	/* Never reached.  */
//	return -ENOSYS;
//}

/* Send the KILL signal to all tracees when PRoot has received a fatal
 * signal.  */
static void kill_all_tracees2(int signum, siginfo_t *siginfo UNUSED, void *ucontext UNUSED)
{
	LOGSYSW("signal %d received from process %d",signum, siginfo->si_pid)
//    sig_handler_call_stack(signum,siginfo,ucontext);
//	kill_all_tracees();

	/* Exit immediately for system signals (segmentation fault,
	 * illegal instruction, ...), otherwise exit cleanly through
	 * the event loop.  */
	if (signum != SIGQUIT)
		_exit(EXIT_FAILURE);
}

/**
 * Helper for print_talloc_hierarchy().
 */
//static void print_talloc_chunk(const void *ptr, int depth, int max_depth UNUSED,
//			int is_ref, void *data UNUSED)
//{
//	const char *name;
//	size_t count;
//	size_t size;
//
//	name = talloc_get_name(ptr);
//	size = talloc_get_size(ptr);
//	count = talloc_reference_count(ptr);
//
//	if (depth == 0)
//		return;
//
//	while (depth-- > 1)
//		fprintf(stderr, "\t");
//
//	fprintf(stderr, "%-16s ", name);
//
//	if (is_ref)
//		fprintf(stderr, "-> %-8p", ptr);
//	else {
//		fprintf(stderr, "%-8p  %zd bytes  %zd ref'", ptr, size, count);
//
//		if (name[0] == '$') {
//			fprintf(stderr, "\t(\"%s\")", (char *)ptr);
//		}
//		if (name[0] == '@') {
//			char **argv;
//			int i;
//
//			fprintf(stderr, "\t(");
//			for (i = 0, argv = (char **)ptr; argv[i] != NULL; i++)
//				fprintf(stderr, "\"%s\", ", argv[i]);
//			fprintf(stderr, ")");
//		}
//		else if (strcmp(name, "Tracee") == 0) {
//			fprintf(stderr, "\t(pid = %d, parent = %p)",
//				((Tracee *)ptr)->pid, ((Tracee *)ptr)->parent);
//		}
//		else if (strcmp(name, "Bindings") == 0) {
//			Tracee *tracee;
//
//			tracee = TRACEE(ptr);
//
//			if (ptr == tracee->fs->bindings.pending)
//				fprintf(stderr, "\t(pending)");
//			else if (ptr == tracee->fs->bindings.guest)
//				fprintf(stderr, "\t(guest)");
//			else if (ptr == tracee->fs->bindings.host)
//				fprintf(stderr, "\t(host)");
//		}
//		else if (strcmp(name, "Binding") == 0) {
//			Binding *binding = (Binding *)ptr;
//			fprintf(stderr, "\t(%s:%s)", binding->host.path, binding->guest.path);
//		}
//	}
//
//	fprintf(stderr, "\n");
//}

/* Print on stderr the complete talloc hierarchy.  */
static void print_talloc_hierarchy(int signum, siginfo_t *siginfo UNUSED, void *ucontext UNUSED)
{
	LOGSYSE("print_talloc_hierarchy %d",signum)
//	switch (signum) {
//	case SIGUSR1:
//		talloc_report_depth_cb(NULL, 0, 100, print_talloc_chunk, NULL);
//		break;
//
//	case SIGUSR2:
//		talloc_report_depth_file(NULL, 0, 100, stderr);
//		break;
//
//	default:
//		break;
//	}
}

static int last_exit_status = -1;

/**
 * Check if kernel >= 4.8
 */
static bool is_kernel_4_8(void)
{
	static int version_48 = -1;
	int major = 0;
	int minor = 0;

	if (version_48 != -1)
		return version_48;

	version_48 = false;

	struct utsname utsname;

	if (uname(&utsname) < 0)
		return false;

	sscanf(utsname.release, "%d.%d", &major, &minor);

	if ((major == 4 && minor >= 8) || major > 4)
		version_48 = true;

	return version_48;
}

/**
 * Wait then handle any event from any tracee.  This function returns
 * the exit status of the last terminated program.
 */
int event_loop()
{
	struct sigaction signal_action;
	long status;
    long trace_new_status;
	int signum;
    Tracee *new_tracee;

	/* Kill all tracees when exiting.  */
	status = atexit(kill_all_tracees);
	if (status != 0)
		LOGSYSW("atexit() failed")

	/* All signals are blocked when the signal handler is called.
	 * SIGINFO is used to know which process has signaled us and
	 * RESTART is used to restart waitpid(2) seamlessly.  */
	bzero(&signal_action, sizeof(signal_action));
	signal_action.sa_flags = SA_SIGINFO | SA_RESTART;
	status = sigfillset(&signal_action.sa_mask);
	if (status < 0)
		LOGSYSW("sigfillset()")

	/* Handle all signals.  */
	for (signum = 0; signum < SIGRTMAX; signum++) {
		switch (signum) {
		case SIGQUIT:
		case SIGILL:
		case SIGABRT:
		case SIGFPE:
		case SIGSEGV:
			/* Kill all tracees on abnormal termination
			 * signals.  This ensures no process is left
			 * untraced.  */
			signal_action.sa_sigaction = kill_all_tracees2;
			break;

		case SIGUSR1:
		case SIGUSR2:
			/* Print on stderr the complete talloc
			 * hierarchy, useful for debug purpose.  */
			signal_action.sa_sigaction = print_talloc_hierarchy;
			break;

		case SIGCHLD:
		case SIGCONT:
		case SIGSTOP:
		case SIGTSTP:
		case SIGTTIN:
		case SIGTTOU:
			/* The default action is OK for these signals,
			 * they are related to tty and job control.  */
			continue;

		default:
			/* Ignore all other signals, including
			 * terminating ones (^C for instance). */
			signal_action.sa_sigaction = (void *)SIG_IGN;
			break;
		}

		status = sigaction(signum, &signal_action, NULL);
		if (status < 0 && errno != EINVAL)
			note(NULL, WARNING, SYSTEM, "sigaction(%d)", signum);
	}
	LOGD("tracer waitpid start,cur_pid:%d",getpid())
	while (1) {
		int tracee_status;
		Tracee *tracee;
		int signal;
		pid_t pid;

		/* This is the only safe place to free tracees.  */
		free_terminated_tracees();

		/* Wait for the next tracee's stop. */
//		LOGD("tracer waitpid,cur_pid:%d",getpid())
		pid = waitpid(-1, &tracee_status, __WALL);
		if (pid < 0) {
//			LOGD("resume pid error:%d,cur_pid:%d,%d,%s",pid,getpid(),errno, strerror(errno))
			if (errno != ECHILD) {
				LOGSYSE("waitpid()")
				return EXIT_FAILURE;
			}
#ifdef TEST_ONLY
            if (!waitting_for_tracee){
                LOGSYS("no more tracee,exit---------------");
                break;
            }
#endif
			continue;
		}

//        LOGD("resume pid:%d,snew_attach_pid:%d,tracee_status:%d,%d,%d",pid,snew_attach_pid,tracee_status,WIFEXITED(tracee_status),WEXITSTATUS(tracee_status))
		if (snew_attach_pid != -1 && WIFEXITED(tracee_status) == 1 &&  255 == WEXITSTATUS(tracee_status) && get_tracee(NULL, pid, false) == NULL){//会有并发问题吗?? 需要更严格校验不???
			do {
				LOGSYS("handle helper event,snew_attach_pid:%d",snew_attach_pid)
				trace_new_status = ptrace(PTRACE_ATTACH,snew_attach_pid,NULL,NULL);
				if (trace_new_status < 0){
					LOGE("ptrace %d error,%d,%s",snew_attach_pid,errno, strerror(errno))
					break;
				}
#ifdef TEST_ONLY
                waitting_for_tracee = false; //只要存在过tracee,就置为false
                LOGSYS("test only enabled,waitting_for_tracee false")
#endif
				new_tracee = get_tracee(NULL, 0, true);
				if (!new_tracee){
					LOGE("new tracee error,%d",snew_attach_pid)
					break;
				}
				new_tracee->verbose = 6; // -v 6 调试用
				new_tracee->pid = snew_attach_pid;
				new_tracee->is_root = true;
				new_tracee->deliver_sigtrap = false;
				LOGD("notify start trace 进程")
				cmn_pt_signal(&spctx);
				snew_attach_pid = -1;
				LOGD("new trace finished，cur_pid:%d",getpid())
			} while (0);
			continue;
		}

		/* Get information about this tracee. */
		tracee = get_tracee(NULL, pid, true);
		assert(tracee != NULL);
//		LOGD("vpid %" PRIu64 ",resume pid:%d,cur_pid:%d",tracee->vpid,pid,getpid())
		tracee->running = false;

//		VERBOSE(tracee, 6, "vpid %" PRIu64 ": got event %x",
//			tracee->vpid, tracee_status);
		LOGSYS("vpid %" PRIu64 ": got event %x",tracee->vpid, tracee_status)

//		status = notify_extensions(tracee, NEW_STATUS, tracee_status, 0);
//		if (status != 0)
//			continue;

		if (tracee->as_ptracee.ptracer != NULL) {
			bool keep_stopped = handle_ptracee_event(tracee, tracee_status);
			if (keep_stopped)
				continue;
		}

		signal = handle_tracee_event(tracee, tracee_status);
#if 0
        //test only
        if (signal == SIGSEGV){
			//fetch寄存器
			int  fstatus = fetch_regs(tracee);
			if (fstatus < 0){
				VERBOSE(tracee, 6, "vpid %" PRIu64 ": fetch regs fatal error, signal %d, tracee pid %d",
						tracee->vpid, signal,tracee->pid);
			}else{
				#if defined(__aarch64__)
					LOGSYS("vpid %" PRIu64 ": fatal error signal %d, pid %d, pc %lx",
		   			tracee->vpid, signal,tracee->pid, tracee->_regs[CURRENT].pc)
                print_remote_call_stack_arm64(tracee);
                #endif
			}
            exit(0);
        }
#endif
		(void) restart_tracee(tracee, signal);
	}

	return last_exit_status;
}

/**
 * For kernels >= 4.8.0
 * Handle the current event (@tracee_status) of the given @tracee.
 * This function returns the "computed" signal that should be used to
 * restart the given @tracee.
 */
int handle_tracee_event(Tracee *tracee, int tracee_status)
{
//	LOGD("handle_tracee_event_kernel_4_8")
	//TODO 每个进程树放到一个队列里，然后这个队列都维护一个global信息存储seccomp_detected、seccomp_enabled信息
//	static bool seccomp_detected = false;
//	static bool seccomp_enabled = false; /* added for 4.8.0 */
	bool seccomp_detected = tracee->seccomp_detected;
	bool seccomp_enabled = tracee->seccomp_enabled;
	long status;
	int signal;

//	VERBOSE(tracee, 6, "vpid %" PRIu64 ": handle_tracee_event_kernel_4_8  restart_how: %d, seccomp: %d, sysexit_pending: %d",
//			tracee->vpid, tracee->restart_how, tracee->seccomp,tracee->sysexit_pending);
	/* Don't overwrite restart_how if it is explicitly set
	 * elsewhere, i.e in the ptrace emulation when single
	 * stepping.  */
	if (tracee->restart_how == 0) {
		/* When seccomp is enabled, all events are restarted in
		 * non-stop mode, but this default choice could be overwritten
		 * later if necessary.  The check against "sysexit_pending"
		 * ensures PTRACE_SYSCALL (used to hit the exit stage under
		 * seccomp) is not cleared due to an event that would happen
		 * before the exit stage, eg. PTRACE_EVENT_EXEC for the exit
		 * stage of execve(2).  */
		if (tracee->seccomp == ENABLED && !tracee->sysexit_pending)
			tracee->restart_how = PTRACE_CONT;
		else
			tracee->restart_how = PTRACE_SYSCALL;
	}

	/* Not a signal-stop by default.  */
	signal = 0;

	if (WIFEXITED(tracee_status)) {
		last_exit_status = WEXITSTATUS(tracee_status);
//		VERBOSE(tracee, 1,
//			"vpid %" PRIu64 ": exited with status %d",
//			tracee->vpid, last_exit_status);
		LOGSYS("vpid %" PRIu64 ": exited with status %d",
			tracee->vpid, last_exit_status);
		terminate_tracee(tracee);
	}
	else if (WIFSIGNALED(tracee_status)) {
//		check_architecture(tracee);
//		VERBOSE(tracee, 1,
//			"vpid %" PRIu64 ": terminated with signal %d",
//			tracee->vpid, WTERMSIG(tracee_status));
		LOGSYS("vpid %" PRIu64 ": terminated with signal %d",
				tracee->vpid, WTERMSIG(tracee_status));
		terminate_tracee(tracee);
	}
	else if (WIFSTOPPED(tracee_status)) {
		/* Don't use WSTOPSIG() to extract the signal
		 * since it clears the PTRACE_EVENT_* bits. */
		signal = (tracee_status & 0xfff00) >> 8;

		switch (signal) {
//			static bool deliver_sigtrap = false;

		case SIGTRAP: {
			const unsigned long default_ptrace_options = (
				PTRACE_O_TRACESYSGOOD	|
				PTRACE_O_TRACEFORK	|
				PTRACE_O_TRACEVFORK	|
				PTRACE_O_TRACEVFORKDONE	|
				PTRACE_O_TRACEEXEC	|
				PTRACE_O_TRACECLONE	|
				PTRACE_O_TRACEEXIT);


			LOGD("vpid %" PRIu64 ",is_root %d,deliver_sigtrap %d",tracee->vpid,tracee->is_root,tracee->deliver_sigtrap)
			/* Distinguish some events from others and
			 * automatically trace each new process with
			 * the same options.
			 *
			 * Note that only the first bare SIGTRAP is
			 * related to the tracing loop, others SIGTRAP
			 * carry tracing information because of
			 * TRACE*FORK/CLONE/EXEC.  */
//			if (deliver_sigtrap)
//				break;  /* Deliver this signal as-is.  */
//
//			deliver_sigtrap = true;
			if (!tracee->is_root || tracee->deliver_sigtrap){
				break;
			}
			//是进程树root && 它的deliver_sigtrap为false
			tracee->deliver_sigtrap = true;

			/* Try to enable seccomp mode 2...  */
			errno = 0;
			status = ptrace(PTRACE_SETOPTIONS, tracee->pid, NULL,
					default_ptrace_options | PTRACE_O_TRACESECCOMP);
			if (status < 0) {
				LOGD("vpid %" PRIu64 ",PTRACE_SETOPTIONS status %ld,%d,%s",tracee->vpid,status,errno,
					 strerror(errno))
				tracee->seccomp_enabled = false;
				/* ... otherwise use default options only.  */
				status = ptrace(PTRACE_SETOPTIONS, tracee->pid, NULL,
						default_ptrace_options);
				if (status < 0) {
//					note(tracee, ERROR, SYSTEM, "ptrace(PTRACE_SETOPTIONS)");
					LOGSYSE("ptrace(PTRACE_SETOPTIONS)")
					exit(EXIT_FAILURE);
				}
			}
			else {
                tracee->seccomp_enabled = true;
			}
			LOGD("vpid %" PRIu64 ",secomp_enabled %d",tracee->vpid,tracee->seccomp_enabled)
		}
			/* Fall through. */
		case SIGTRAP | PTRACE_EVENT_SECCOMP2 << 8:
		case SIGTRAP | PTRACE_EVENT_SECCOMP << 8:
			LOGD("vpid %" PRIu64 ",secomp_enabled %d,",tracee->vpid,tracee->seccomp_enabled)
			if (!tracee->seccomp_detected && tracee->seccomp_enabled) {
				VERBOSE(tracee, 1, "ptrace acceleration (seccomp mode 2) enabled"); //第二个进程没走这里?
//				LOGSYS("ptrace acceleration (seccomp mode 2) enabled")
				tracee->seccomp = ENABLED;
				tracee->seccomp_detected = true;
			}

			if (signal == (SIGTRAP | PTRACE_EVENT_SECCOMP2 << 8) ||
			    signal == (SIGTRAP | PTRACE_EVENT_SECCOMP << 8)) {

				unsigned long flags = 0;
				signal = 0;

				/* Use the common ptrace flow if seccomp was
				 * explicitly disabled for this tracee.  */
				if (tracee->seccomp != ENABLED)
					break;

				status = ptrace(PTRACE_GETEVENTMSG, tracee->pid, NULL, &flags);
				if (status < 0)
					break;

				if ((flags & FILTER_SYSEXIT) == 0) {
					tracee->restart_how = PTRACE_CONT;
					translate_syscall(tracee);

					if (tracee->seccomp == DISABLING)
						tracee->restart_how = PTRACE_SYSCALL;
					break;
				}
			}

			/* Fall through. */
		case SIGTRAP | 0x80:

			signal = 0;

			/* This tracee got signaled then freed during the
			   sysenter stage but the kernel reports the sysexit
			   stage; just discard this spurious tracee/event.  */

//			if (tracee->exe == NULL) {
//				tracee->restart_how = PTRACE_CONT; /* SYSCALL OR CONT */
//				return 0;
//			}

			switch (tracee->seccomp) {
			case ENABLED:
				if (IS_IN_SYSENTER(tracee)) {
					/* sysenter: ensure the sysexit
					 * stage will be hit under seccomp.  */
					tracee->restart_how = PTRACE_SYSCALL;
					tracee->sysexit_pending = true;
				}
				else {
					/* sysexit: the next sysenter
					 * will be notified by seccomp.  */
					tracee->restart_how = PTRACE_CONT;
					tracee->sysexit_pending = false;
				}
				/* Fall through.  */
			case DISABLED:
				translate_syscall(tracee);

				/* This syscall has disabled seccomp.  */
				if (tracee->seccomp == DISABLING) {
					tracee->restart_how = PTRACE_SYSCALL;
					tracee->seccomp = DISABLED;
				}

				break;

			case DISABLING:
				/* Seccomp was disabled by the
				 * previous syscall, but its sysenter
				 * stage was already handled.  */
				tracee->seccomp = DISABLED;
				if (IS_IN_SYSENTER(tracee))
					tracee->status = 1;
				break;
			}
			break;

		case SIGTRAP | PTRACE_EVENT_VFORK << 8:
			signal = 0;
			(void) new_child(tracee, CLONE_VFORK);
			break;

		case SIGTRAP | PTRACE_EVENT_FORK  << 8:
		case SIGTRAP | PTRACE_EVENT_CLONE << 8:
			signal = 0;
			(void) new_child(tracee, 0);
			break;

		case SIGTRAP | PTRACE_EVENT_VFORK_DONE << 8:
		case SIGTRAP | PTRACE_EVENT_EXEC  << 8:
		case SIGTRAP | PTRACE_EVENT_EXIT  << 8:
			signal = 0;
			break;

		case SIGSTOP:
			/* Stop this tracee until PRoot has received
			 * the EVENT_*FORK|CLONE notification.  */
			//exe为空不是问题
//			if (tracee->exe == NULL) {
//				tracee->sigstop = SIGSTOP_PENDING;
//				signal = -1;
//			}

			/* For each tracee, the first SIGSTOP
			 * is only used to notify the tracer.  */
			if (tracee->sigstop == SIGSTOP_IGNORED) {
				LOGD("in first stop----------------------,tracee pid:%d",tracee->pid)
				tracee->sigstop = SIGSTOP_ALLOWED;
				signal = 0;
			}
			break;

		default:
			/* Deliver this signal as-is.  */
			break;
		}
	}

	/* Clear the pending event, if any.  */
	tracee->as_ptracee.event4.proot.pending = false;

	return signal;
}

/**
 * Restart the given @tracee with the specified @signal.  This
 * function returns false if the tracee was not restarted (error or
 * put in the "waiting for ptracee" state), otherwise true.
 */
bool restart_tracee(Tracee *tracee, int signal)
{
//	LOGSYS("restart_tracee %p,signal:%d,wait_pid:%d,how:%d,trace_pid:%d",tracee,signal,tracee->as_ptracer.wait_pid,tracee->restart_how,tracee->pid)
	int status;

	/* Put in the "stopped"/"waiting for ptracee" state?.  */
	if (tracee->as_ptracer.wait_pid != 0 || signal == -1)
		return false;

	/* Restart the tracee and stop it at the next instruction, or
	 * at the next entry or exit of a system call. */
	status = ptrace(tracee->restart_how, tracee->pid, NULL, signal);
	if (status < 0){
		LOGE("restart_tracee error,%d,%d,%d,err:%d,%s",tracee->restart_how,tracee->pid,signal,errno,
			 strerror(errno))
		return false; /* The process likely died in a syscall.  */
	}

	VERBOSE(tracee, 6, "vpid %" PRIu64 ": restarted using %d, signal %d, tracee pid %d,app_pid %d",
		tracee->vpid, tracee->restart_how, signal,tracee->pid,(tracee->parent != NULL ? tracee->parent->pid : tracee->pid));

	tracee->restart_how = 0;
	tracee->running = true;

	return true;
}

```

`library/src/main/jni/tracee/event.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef TRACEE_EVENT_H
#define TRACEE_EVENT_H

#include <stdbool.h>

#include "tracee/tracee.h"

extern int launch_process(Tracee *tracee, char *const argv[]);
extern int event_loop();
extern int handle_tracee_event(Tracee *tracee, int tracee_status);
extern bool restart_tracee(Tracee *tracee, int signal);

#endif /* TRACEE_EVENT_H */

```

`library/src/main/jni/tracee/mem.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#define __USE_GNU
#include <sys/ptrace.h> /* ptrace(2), PTRACE_*, */
#include <sys/types.h>  /* pid_t, size_t, */
#include <stdlib.h>     /* NULL, */
#include <stddef.h>     /* offsetof(), */
#include <sys/user.h>   /* struct user*, */
#include <errno.h>      /* errno, */
#include <assert.h>     /* assert(3), */
#include <sys/wait.h>   /* waitpid(2), */
#include <string.h>     /* memcpy(3), */
#include <stdint.h>     /* uint*_t, */
#include <sys/uio.h>    /* process_vm_*, struct iovec, */
#include <unistd.h>     /* sysconf(3), */
#include <sys/mman.h>   /* mmap(2), munmap(2), MAP_*, */

#include "tracee/mem.h"
#include "tracee/abi.h"
#include "syscall/heap.h"
#include "arch.h"            /* word_t, NO_MISALIGNED_ACCESS */
#include "build.h"           /* HAVE_PROCESS_VM,  */
//#include "cli/note.h"
#include "constant.h"
#include "note.h"

/**
 * Load the word at the given @address, potentially *not* aligned.
 */
static inline word_t load_word(const void *address)
{
#ifdef NO_MISALIGNED_ACCESS
	if (((word_t)address) % sizeof(word_t) == 0)
		return *(word_t *)address;
	else {
		word_t value;
		memcpy(&value, address, sizeof(word_t));
		return value;
	}
#else
	return *(word_t *)address;
#endif
}

/**
 * Store the word with the given @value to the given @address,
 * potentially *not* aligned.
 */
static inline void store_word(void *address, word_t value)
{
#ifdef NO_MISALIGNED_ACCESS
	if (((word_t)address) % sizeof(word_t) == 0)
		*((word_t *)address) = value;
	else
		memcpy(address, &value, sizeof(word_t));
#else
	*((word_t *)address) = value;
#endif
}

/**
 * Copy @size bytes from the buffer @src_tracer to the address
 * @dest_tracee within the memory space of the @tracee process. It
 * returns -errno if an error occured, otherwise 0.
 */
int write_data(const Tracee *tracee, word_t dest_tracee, const void *src_tracer, word_t size)
{
	word_t *src  = (word_t *)src_tracer;
	word_t *dest = (word_t *)dest_tracee;

	long   status;
	word_t word, i, j;
	word_t nb_trailing_bytes;
	word_t nb_full_words;

	uint8_t *last_dest_word;
	uint8_t *last_src_word;

#if defined(HAVE_PROCESS_VM)
	struct iovec local;
	struct iovec remote;

	local.iov_base = src;
	local.iov_len  = size;

	remote.iov_base = dest;
	remote.iov_len  = size;

	status = process_vm_writev(tracee->pid, &local, 1, &remote, 1, 0);
	if ((size_t) status == size)
		return 0;
	/* Fallback to ptrace if something went wrong.  */

#endif /* HAVE_PROCESS_VM */

	nb_trailing_bytes = size % sizeof(word_t);
	nb_full_words     = (size - nb_trailing_bytes) / sizeof(word_t);

	/* Copy one word by one word, except for the last one. */
	for (i = 0; i < nb_full_words; i++) {
		status = ptrace(PTRACE_POKEDATA, tracee->pid, dest + i, load_word(&src[i]));
		if (status < 0) {
//			note(tracee, WARNING, SYSTEM, "ptrace(POKEDATA)");
			LOGSYSW("ptrace(POKEDATA)")
			return -EFAULT;
		}
	}

	if (nb_trailing_bytes == 0)
		return 0;

	/* Copy the bytes in the last word carefully since we have to
	 * overwrite only the relevant ones. */

	word = ptrace(PTRACE_PEEKDATA, tracee->pid, dest + i, NULL);
	if (errno != 0) {
//		note(tracee, WARNING, SYSTEM, "ptrace(PEEKDATA)");
		LOGW("ptrace(PEEKDATA)")
		return -EFAULT;
	}

	last_dest_word = (uint8_t *)&word;
	last_src_word  = (uint8_t *)&src[i];

	for (j = 0; j < nb_trailing_bytes; j++)
		last_dest_word[j] = last_src_word[j];

	status = ptrace(PTRACE_POKEDATA, tracee->pid, dest + i, word);
	if (status < 0) {
		note(tracee, WARNING, SYSTEM, "ptrace(POKEDATA)");
		return -EFAULT;
	}

	return 0;
}

/**
 * Gather the @src_tracer_count buffers pointed to by @src_tracer to
 * the address @dest_tracee within the memory space of the @tracee
 * process.  This function returns -errno if an error occured,
 * otherwise 0.
 */
int writev_data(const Tracee *tracee, word_t dest_tracee, const struct iovec *src_tracer, int src_tracer_count)
{
	size_t size;
	int status;
	int i;

#if defined(HAVE_PROCESS_VM)
	struct iovec remote;

	for (i = 0, size = 0; i < src_tracer_count; i++)
		size += src_tracer[i].iov_len;

	remote.iov_base = (word_t *)dest_tracee;
	remote.iov_len  = size;

	status = process_vm_writev(tracee->pid, src_tracer, src_tracer_count, &remote, 1, 0);
	if ((size_t) status == size)
		return 0;
	/* Fallback to iterative-write if something went wrong.  */

#endif /* HAVE_PROCESS_VM */

	for (i = 0, size = 0; i < src_tracer_count; i++) {
		status = write_data(tracee, dest_tracee + size,
							src_tracer[i].iov_base, src_tracer[i].iov_len);
		if (status < 0)
			return status;

		size += src_tracer[i].iov_len;
	}

	return 0;
}

/**
 * Copy @size bytes to the buffer @dest_tracer from the address
 * @src_tracee within the memory space of the @tracee process. It
 * returns -errno if an error occured, otherwise 0.
 */
int read_data(const Tracee *tracee, void *dest_tracer, word_t src_tracee, word_t size)
{
	word_t *src  = (word_t *)src_tracee;
	word_t *dest = (word_t *)dest_tracer;

	word_t nb_trailing_bytes;
	word_t nb_full_words;
	word_t word, i, j;

	uint8_t *last_src_word;
	uint8_t *last_dest_word;

#if defined(HAVE_PROCESS_VM)
	long status;
	struct iovec local;
	struct iovec remote;

	local.iov_base = dest;
	local.iov_len  = size;

	remote.iov_base = src;
	remote.iov_len  = size;

	status = process_vm_readv(tracee->pid, &local, 1, &remote, 1, 0);
	if ((size_t) status == size)
		return 0;
	/* Fallback to ptrace if something went wrong.  */

#endif /* HAVE_PROCESS_VM */

	nb_trailing_bytes = size % sizeof(word_t);
	nb_full_words     = (size - nb_trailing_bytes) / sizeof(word_t);

	/* Copy one word by one word, except for the last one. */
	for (i = 0; i < nb_full_words; i++) {
		word = ptrace(PTRACE_PEEKDATA, tracee->pid, src + i, NULL);
		if (errno != 0) {
			note(tracee, WARNING, SYSTEM, "ptrace(PEEKDATA)");
			return -EFAULT;
		}
		store_word(&dest[i], word);
	}

	if (nb_trailing_bytes == 0)
		return 0;

	/* Copy the bytes from the last word carefully since we have
	 * to not overwrite the bytes lying beyond @dest_tracer. */

	word = ptrace(PTRACE_PEEKDATA, tracee->pid, src + i, NULL);
	if (errno != 0) {
		note(tracee, WARNING, SYSTEM, "ptrace(PEEKDATA)");
		return -EFAULT;
	}

	last_dest_word = (uint8_t *)&dest[i];
	last_src_word  = (uint8_t *)&word;

	for (j = 0; j < nb_trailing_bytes; j++)
		last_dest_word[j] = last_src_word[j];

	return 0;
}

/**
 * Copy to @dest_tracer at most @max_size bytes from the string
 * pointed to by @src_tracee within the memory space of the @tracee
 * process. This function returns -errno on error, otherwise
 * it returns the number in bytes of the string, including the
 * end-of-string terminator.
 */
int read_string(const Tracee *tracee, char *dest_tracer, word_t src_tracee, word_t max_size)
{
	word_t *src  = (word_t *)src_tracee;
	word_t *dest = (word_t *)dest_tracer;

	word_t nb_trailing_bytes;
	word_t nb_full_words;
	word_t word, i, j;

	uint8_t *src_word;
	uint8_t *dest_word;

#if defined(HAVE_PROCESS_VM)
	/* [process_vm] system calls do not check the memory regions
	 * in the remote process until just before doing the
	 * read/write.  Consequently, a partial read/write [1] may
	 * result if one of the remote_iov elements points to an
	 * invalid memory region in the remote process.  No further
	 * reads/writes will be attempted beyond that point.  Keep
	 * this in mind when attempting to read data of unknown length
	 * (such as C strings that are null-terminated) from a remote
	 * process, by avoiding spanning memory pages (typically 4KiB)
	 * in a single remote iovec element.  (Instead, split the
	 * remote read into two remote_iov elements and have them
	 * merge back into a single write local_iov entry.  The first
	 * read entry goes up to the page boundary, while the second
	 * starts on the next page boundary.).
	 *
	 * [1] Partial transfers apply at the granularity of iovec
	 * elements. These system calls won't perform a partial
	 * transfer that splits a single iovec element.
	 *
	 * -- man 2 process_vm_readv
	 */
	long status;
	size_t size;
	size_t offset;
	struct iovec local;
	struct iovec remote;

	static size_t chunk_size = 0;
	static uintptr_t chunk_mask;

	/* A chunk shall not cross a page boundary.  */
	if (chunk_size == 0) {
		chunk_size = sysconf(_SC_PAGE_SIZE);
		chunk_size = (chunk_size > 0 && chunk_size < 1024 ? chunk_size : 1024);
		chunk_mask = ~(chunk_size - 1);
	}

	/* Read the string by chunk.  */
	offset = 0;
	do {
		uintptr_t current_chunk = (src_tracee + offset) & chunk_mask;
		uintptr_t next_chunk    = current_chunk + chunk_size;

		/* Compute the number of bytes available up to the
		 * next chunk or up to max_size.  */
		size = next_chunk - (src_tracee + offset);
		size = (size < max_size - offset ? size : max_size - offset);

		local.iov_base = (uint8_t *)dest + offset;
		local.iov_len  = size;

		remote.iov_base = (uint8_t *)src + offset;
		remote.iov_len  = size;

		status = process_vm_readv(tracee->pid, &local, 1, &remote, 1, 0);
		if ((size_t) status != size)
			goto fallback;

		status = strnlen(local.iov_base, size);
		if ((size_t) status < size) {
			size = offset + status + 1;
			assert(size <= max_size);
			return size;
		}

		offset += size;
	} while (offset < max_size);
	assert(offset == max_size);

	/* Fallback to ptrace if something went wrong.  */
	fallback:
#endif /* HAVE_PROCESS_VM */

	nb_trailing_bytes = max_size % sizeof(word_t);
	nb_full_words     = (max_size - nb_trailing_bytes) / sizeof(word_t);

	/* Copy one word by one word, except for the last one. */
	for (i = 0; i < nb_full_words; i++) {
		word = ptrace(PTRACE_PEEKDATA, tracee->pid, src + i, NULL);
		if (errno != 0)
			return -EFAULT;

		store_word(&dest[i], word);

		/* Stop once an end-of-string is detected. */
		src_word = (uint8_t *)&word;
		for (j = 0; j < sizeof(word_t); j++)
			if (src_word[j] == '\0')
				return i * sizeof(word_t) + j + 1;
	}

	/* Copy the bytes from the last word carefully since we have
	 * to not overwrite the bytes lying beyond @dest_tracer. */

	word = ptrace(PTRACE_PEEKDATA, tracee->pid, src + i, NULL);
	if (errno != 0)
		return -EFAULT;

	dest_word = (uint8_t *)&dest[i];
	src_word  = (uint8_t *)&word;

	for (j = 0; j < nb_trailing_bytes; j++) {
		dest_word[j] = src_word[j];
		if (src_word[j] == '\0')
			break;
	}

	return i * sizeof(word_t) + j + 1;
}

/**
 * Return the value of the word at the given @address in the @tracee's
 * memory space.  The caller must test errno to check if an error
 * occured.
 */
word_t peek_word(const Tracee *tracee, word_t address)
{
	word_t result = 0;

#if defined(HAVE_PROCESS_VM)
	int status;
	struct iovec local;
	struct iovec remote;

	local.iov_base = &result;
	local.iov_len  = sizeof_word(tracee);

	remote.iov_base = (void *)address;
	remote.iov_len  = sizeof_word(tracee);

	errno = 0;
	status = process_vm_readv(tracee->pid, &local, 1, &remote, 1, 0);
	if (status > 0)
		return result;
		/* Fallback to ptrace if something went wrong.  */
#endif
	errno = 0;
	result = (word_t) ptrace(PTRACE_PEEKDATA, tracee->pid, address, NULL);

	/* From ptrace(2) manual: "Unfortunately, under Linux,
	 * different variations of this fault will return EIO or
	 * EFAULT more or less arbitrarily."  */
	if (errno == EIO)
		errno = EFAULT;

	/* Use only the 32 LSB when running a 32-bit process on a
	 * 64-bit kernel. */
	if (is_32on64_mode(tracee))
		result &= 0xFFFFFFFF;

	return result;
}

/**
 * Set the word at the given @address in the @tracee's memory space to
 * the given @value.  The caller must test errno to check if an error
 * occured.
 */
void poke_word(const Tracee *tracee, word_t address, word_t value)
{
	word_t tmp;

#if defined(HAVE_PROCESS_VM)
	int status;
	struct iovec local;
	struct iovec remote;

	/* Note: &value points to the 32 LSB on 64-bit little-endian
	 * architecture.  */
	local.iov_base = &value;
	local.iov_len  = sizeof_word(tracee);

	remote.iov_base = (void *)address;
	remote.iov_len  = sizeof_word(tracee);

	errno = 0;
	status = process_vm_writev(tracee->pid, &local, 1, &remote, 1, 0);
	if (status > 0)
		return;
	/* Fallback to ptrace if something went wrong.  */
#endif
	/* Don't overwrite the 32 MSB when running a 32-bit process on
	 * a 64-bit kernel. */
	if (is_32on64_mode(tracee)) {
		errno = 0;
		tmp = (word_t) ptrace(PTRACE_PEEKDATA, tracee->pid, address, NULL);
		if (errno != 0)
			return;

		value |= (tmp & 0xFFFFFFFF00000000ULL);
	}

	errno = 0;
	(void) ptrace(PTRACE_POKEDATA, tracee->pid, address, value);

	/* From ptrace(2) manual: "Unfortunately, under Linux,
	 * different variations of this fault will return EIO or
	 * EFAULT more or less arbitrarily."  */
	if (errno == EIO)
		errno = EFAULT;

	return;
}

/**
 * Allocate @size bytes in the @tracee's memory space.  This function
 * returns the address of the allocated memory in the @tracee's memory
 * space, otherwise 0 if an error occured.
 */
word_t alloc_mem(Tracee *tracee, ssize_t size)
{
	word_t stack_pointer;

	/* This function should be called in sysenter only since the
	 * stack pointer is systematically restored at the end of
	 * sysexit (except for execve, but in this case the stack
	 * pointer should be handled with care since it is used by the
	 * process to retrieve argc, argv, envp, and auxv).  */
	assert(IS_IN_SYSENTER(tracee));

	/* Get the current value of the stack pointer from the tracee's
	 * USER area. */
	stack_pointer = peek_reg(tracee, CURRENT, STACK_POINTER);

	/* Some ABIs specify an amount of bytes after the stack
	 * pointer that shall not be used by anything but the compiler
	 * (for optimization purpose).  */
	if (stack_pointer == peek_reg(tracee, ORIGINAL, STACK_POINTER))
		size += RED_ZONE_SIZE;

	/* Align the stack */
	size = ((size - 1) / STACK_ALIGNMENT + 1) * STACK_ALIGNMENT;

	/* Sanity check. */
	if (   (size > 0 && stack_pointer <= (word_t) size)
		   || (size < 0 && stack_pointer >= ULONG_MAX + size)) {
//		note(tracee, WARNING, INTERNAL, "integer under/overflow detected in %s",
//			__FUNCTION__);
		LOGW("integer under/overflow detected in %s",
			 __FUNCTION__)
		return 0;
	}

	/* Remember the stack grows downward. */
	stack_pointer -= size;

	/* Set the new value of the stack pointer in the tracee's USER
	 * area. */
	poke_reg(tracee, STACK_POINTER, stack_pointer);
	return stack_pointer;
}

/**
 * Clear @size bytes at the given @address in the @tracee's memory
 * space.  This function returns -errno if an error occured, otherwise
 * 0.
 */
int clear_mem(const Tracee *tracee, word_t address, size_t size)
{
	int status;
	void *zeros;

	zeros = mmap(NULL, size, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	if (zeros == MAP_FAILED)
		return -errno;

	status = write_data(tracee, address, zeros, size);
	munmap(zeros, size);
	return status;
}

```

`library/src/main/jni/tracee/mem.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef TRACEE_MEM_H
#define TRACEE_MEM_H

#include <limits.h>    /* PATH_MAX, */
#include <sys/types.h> /* pid_t, size_t, */
#include <stdint.h>    /* pid_t, size_t, */
#include <sys/uio.h>   /* struct iovec, */
#include <errno.h>     /* ENAMETOOLONG, */

#include "arch.h" /* word_t, */
#include "tracee/tracee.h"

extern int write_data(const Tracee *tracee, word_t dest_tracee, const void *src_tracer, word_t size);
extern int writev_data(const Tracee *tracee, word_t dest_tracee, const struct iovec *src_tracer, int src_tracer_count);
extern int read_data(const Tracee *tracee, void *dest_tracer, word_t src_tracee, word_t size);
extern int read_string(const Tracee *tracee, char *dest_tracer, word_t src_tracee, word_t max_size);
extern word_t peek_word(const Tracee *tracee, word_t address);
extern void poke_word(const Tracee *tracee, word_t address, word_t value);
extern word_t alloc_mem(Tracee *tracee, ssize_t size);
extern int clear_mem(const Tracee *tracee, word_t address, size_t size);

/**
 * Copy to @dest_tracer at most PATH_MAX bytes -- including the
 * end-of-string terminator -- from the string pointed to by
 * @src_tracee within the memory space of the @tracee process.  This
 * function returns -errno on error, otherwise it returns the number
 * in bytes of the string, including the end-of-string terminator.
 */
static inline int read_path(const Tracee *tracee, char dest_tracer[PATH_MAX], word_t src_tracee)
{
	int status;

	status = read_string(tracee, dest_tracer, src_tracee, PATH_MAX);
	if (status < 0)
		return status;
	if (status >= PATH_MAX)
		return -ENAMETOOLONG;

	return status;
}

/**
 * Generate a function that returns the value of the @type at the
 * given @address in the @tracee's memory space.  The caller must test
 * errno to check if an error occured.
 */
#define GENERATE_peek(type)							\
static inline type ## _t peek_ ## type(const Tracee *tracee, word_t address) 	\
{										\
	type ## _t result;							\
	errno = -read_data(tracee, &result, address, sizeof(type ## _t));	\
	return result;								\
}

GENERATE_peek(uint8);
GENERATE_peek(uint16);
GENERATE_peek(uint32);
GENERATE_peek(uint64);

GENERATE_peek(int8);
GENERATE_peek(int16);
GENERATE_peek(int32);
GENERATE_peek(int64);

#undef GENERATE_peek

/**
 * Generate a function that set the @type at the given @address in the
 * @tracee's memory space to the given @value.  The caller must test
 * errno to check if an error occured.
 */
#define GENERATE_poke(type)							\
static inline void poke_ ## type(const Tracee *tracee, word_t address, type ## _t value) \
{										\
	errno = -write_data(tracee, address, &value, sizeof(type ## _t));	\
}

GENERATE_poke(uint8);
GENERATE_poke(uint16);
GENERATE_poke(uint32);
GENERATE_poke(uint64);

GENERATE_poke(int8);
GENERATE_poke(int16);
GENERATE_poke(int32);
GENERATE_poke(int64);

#undef GENERATE_poke

#endif /* TRACEE_MEM_H */

```

`library/src/main/jni/tracee/reg.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sys/types.h>  /* off_t */
#include <sys/user.h>   /* struct user*, */
#include <sys/ptrace.h> /* ptrace(2), PTRACE*, */
#include <assert.h>     /* assert(3), */
#include <errno.h>      /* errno(3), */
#include <stddef.h>     /* offsetof(), */
#include <stdint.h>     /* *int*_t, */
#include <inttypes.h>   /* PRI*, */
#include <limits.h>     /* ULONG_MAX, */
#include <string.h>     /* memcpy(3), */
#include <sys/uio.h>    /* struct iovec, */

#include "arch.h"

#if defined(ARCH_ARM64)
#include <linux/elf.h>  /* NT_PRSTATUS */
#endif

#include "syscall/sysnum.h"
#include "tracee/reg.h"
#include "tracee/abi.h"
//#include "cli/note.h"
#include "compat.h"
#include "constant.h"
#include "note.h"
#include "mem.h"
#include "syscall/syscall.h"

/**
 * Compute the offset of the register @reg_name in the USER area.
 */
#define USER_REGS_OFFSET(reg_name)			\
	(offsetof(struct user, regs)			\
	 + offsetof(struct user_regs_struct, reg_name))

#define REG(tracee, version, index)			\
	(*(word_t*) (((uint8_t *) &tracee->_regs[version]) + reg_offset[index]))

/* Specify the ABI registers (syscall argument passing, stack pointer).
 * See sysdeps/unix/sysv/linux/${ARCH}/syscall.S from the GNU C Library. */
#if defined(ARCH_X86_64)

    static off_t reg_offset[] = {
	[SYSARG_NUM]    = USER_REGS_OFFSET(orig_rax),
	[SYSARG_1]      = USER_REGS_OFFSET(rdi),
	[SYSARG_2]      = USER_REGS_OFFSET(rsi),
	[SYSARG_3]      = USER_REGS_OFFSET(rdx),
	[SYSARG_4]      = USER_REGS_OFFSET(r10),
	[SYSARG_5]      = USER_REGS_OFFSET(r8),
	[SYSARG_6]      = USER_REGS_OFFSET(r9),
	[SYSARG_RESULT] = USER_REGS_OFFSET(rax),
	[STACK_POINTER] = USER_REGS_OFFSET(rsp),
	[INSTR_POINTER] = USER_REGS_OFFSET(rip),
	[RTLD_FINI]     = USER_REGS_OFFSET(rdx),
	[STATE_FLAGS]   = USER_REGS_OFFSET(eflags),
	[USERARG_1]     = USER_REGS_OFFSET(rdi),
    };

    static off_t reg_offset_x86[] = {
	[SYSARG_NUM]    = USER_REGS_OFFSET(orig_rax),
	[SYSARG_1]      = USER_REGS_OFFSET(rbx),
	[SYSARG_2]      = USER_REGS_OFFSET(rcx),
	[SYSARG_3]      = USER_REGS_OFFSET(rdx),
	[SYSARG_4]      = USER_REGS_OFFSET(rsi),
	[SYSARG_5]      = USER_REGS_OFFSET(rdi),
	[SYSARG_6]      = USER_REGS_OFFSET(rbp),
	[SYSARG_RESULT] = USER_REGS_OFFSET(rax),
	[STACK_POINTER] = USER_REGS_OFFSET(rsp),
	[INSTR_POINTER] = USER_REGS_OFFSET(rip),
	[RTLD_FINI]     = USER_REGS_OFFSET(rdx),
	[STATE_FLAGS]   = USER_REGS_OFFSET(eflags),
	[USERARG_1]     = USER_REGS_OFFSET(rax),
    };

    #undef  REG
    #define REG(tracee, version, index)					\
	(*(word_t*) (tracee->_regs[version].cs == 0x23			\
		? (((uint8_t *) &tracee->_regs[version]) + reg_offset_x86[index]) \
		: (((uint8_t *) &tracee->_regs[version]) + reg_offset[index])))

#elif defined(ARCH_ARM_EABI)

    static off_t reg_offset[] = {
	[SYSARG_NUM]    = USER_REGS_OFFSET(uregs[7]),
	[SYSARG_1]      = USER_REGS_OFFSET(uregs[0]),
	[SYSARG_2]      = USER_REGS_OFFSET(uregs[1]),
	[SYSARG_3]      = USER_REGS_OFFSET(uregs[2]),
	[SYSARG_4]      = USER_REGS_OFFSET(uregs[3]),
	[SYSARG_5]      = USER_REGS_OFFSET(uregs[4]),
	[SYSARG_6]      = USER_REGS_OFFSET(uregs[5]),
	[SYSARG_RESULT] = USER_REGS_OFFSET(uregs[0]),
	[STACK_POINTER] = USER_REGS_OFFSET(uregs[13]),
	[INSTR_POINTER] = USER_REGS_OFFSET(uregs[15]),
	[USERARG_1]     = USER_REGS_OFFSET(uregs[0]),
    };

#elif defined(ARCH_ARM64)

    #undef  USER_REGS_OFFSET
    #define USER_REGS_OFFSET(reg_name) offsetof(struct user_regs_struct, reg_name)
	#define USER_REGS_OFFSET_32(reg_number) ((reg_number) * 4)

    static off_t reg_offset[] = {
	[SYSARG_NUM]    = USER_REGS_OFFSET(regs[8]),
	[SYSARG_1]      = USER_REGS_OFFSET(regs[0]),
	[SYSARG_2]      = USER_REGS_OFFSET(regs[1]),
	[SYSARG_3]      = USER_REGS_OFFSET(regs[2]),
	[SYSARG_4]      = USER_REGS_OFFSET(regs[3]),
	[SYSARG_5]      = USER_REGS_OFFSET(regs[4]),
	[SYSARG_6]      = USER_REGS_OFFSET(regs[5]),
	[SYSARG_RESULT] = USER_REGS_OFFSET(regs[0]),
	[STACK_POINTER] = USER_REGS_OFFSET(sp),
	[INSTR_POINTER] = USER_REGS_OFFSET(pc),
	[USERARG_1]     = USER_REGS_OFFSET(regs[0]),
    };

	static off_t reg_offset_armeabi[] = {
			[SYSARG_NUM]    = USER_REGS_OFFSET_32(7),
			[SYSARG_1]      = USER_REGS_OFFSET_32(0),
			[SYSARG_2]      = USER_REGS_OFFSET_32(1),
			[SYSARG_3]      = USER_REGS_OFFSET_32(2),
			[SYSARG_4]      = USER_REGS_OFFSET_32(3),
			[SYSARG_5]      = USER_REGS_OFFSET_32(4),
			[SYSARG_6]      = USER_REGS_OFFSET_32(5),
			[SYSARG_RESULT] = USER_REGS_OFFSET_32(0),
			[STACK_POINTER] = USER_REGS_OFFSET_32(13),
			[INSTR_POINTER] = USER_REGS_OFFSET_32(15),
			[USERARG_1]     = USER_REGS_OFFSET_32(0),
	};

	#undef  REG
	#define REG(tracee, version, index)					\
		(*(word_t*) (tracee->is_aarch32									\
			? (((uint8_t *) &tracee->_regs[version]) + reg_offset_armeabi[index]) \
			: (((uint8_t *) &tracee->_regs[version]) + reg_offset[index])))
#elif defined(ARCH_X86)

    static off_t reg_offset[] = {
	[SYSARG_NUM]    = USER_REGS_OFFSET(orig_eax),
	[SYSARG_1]      = USER_REGS_OFFSET(ebx),
	[SYSARG_2]      = USER_REGS_OFFSET(ecx),
	[SYSARG_3]      = USER_REGS_OFFSET(edx),
	[SYSARG_4]      = USER_REGS_OFFSET(esi),
	[SYSARG_5]      = USER_REGS_OFFSET(edi),
	[SYSARG_6]      = USER_REGS_OFFSET(ebp),
	[SYSARG_RESULT] = USER_REGS_OFFSET(eax),
	[STACK_POINTER] = USER_REGS_OFFSET(esp),
	[INSTR_POINTER] = USER_REGS_OFFSET(eip),
	[RTLD_FINI]     = USER_REGS_OFFSET(edx),
	[STATE_FLAGS]   = USER_REGS_OFFSET(eflags),
	[USERARG_1]     = USER_REGS_OFFSET(eax),
    };

#elif defined(ARCH_SH4)

    static off_t reg_offset[] = {
	[SYSARG_NUM]    = USER_REGS_OFFSET(regs[3]),
	[SYSARG_1]      = USER_REGS_OFFSET(regs[4]),
	[SYSARG_2]      = USER_REGS_OFFSET(regs[5]),
	[SYSARG_3]      = USER_REGS_OFFSET(regs[6]),
	[SYSARG_4]      = USER_REGS_OFFSET(regs[7]),
	[SYSARG_5]      = USER_REGS_OFFSET(regs[0]),
	[SYSARG_6]      = USER_REGS_OFFSET(regs[1]),
	[SYSARG_RESULT] = USER_REGS_OFFSET(regs[0]),
	[STACK_POINTER] = USER_REGS_OFFSET(regs[15]),
	[INSTR_POINTER] = USER_REGS_OFFSET(pc),
	[RTLD_FINI]     = USER_REGS_OFFSET(r4),
    };

#else

    #error "Unsupported architecture"

#endif

/**
 * Return the *cached* value of the given @tracees' @reg.
 */
word_t peek_reg(const Tracee *tracee, RegVersion version, Reg reg)
{
	word_t result;

	assert(version < NB_REG_VERSION);

	result = REG(tracee, version, reg);

	/* Use only the 32 least significant bits (LSB) when running
	 * 32-bit processes on a 64-bit kernel.  */
	if (is_32on64_mode(tracee))
		result &= 0xFFFFFFFF;

	return result;
}

/**
 * Set the *cached* value of the given @tracees' @reg.
 */
void poke_reg(Tracee *tracee, Reg reg, word_t value)
{
	if (peek_reg(tracee, CURRENT, reg) == value)
		return;

#ifdef ARCH_ARM64
	if (is_32on64_mode(tracee)) {
		*(uint32_t *) &REG(tracee, CURRENT, reg) = value;
	} else
#endif
	REG(tracee, CURRENT, reg) = value;
	tracee->_regs_were_changed = true;
}

/**
 * Print the value of the current @tracee's registers according
 * to the @verbose_level.  Note: @message is mixed to the output.
 */
void print_current_regs(Tracee *tracee, int verbose_level, const char *message)
{
//	if (tracee->verbose < verbose_level)
//		return;

	note(tracee, INFO, INTERNAL,
		"vpid %" PRIu64 ": %s: %s(0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx) = 0x%lx [0x%lx, %d]",
		tracee->vpid, message,
		stringify_sysnum(get_sysnum(tracee, CURRENT)),
		peek_reg(tracee, CURRENT, SYSARG_1), peek_reg(tracee, CURRENT, SYSARG_2),
		peek_reg(tracee, CURRENT, SYSARG_3), peek_reg(tracee, CURRENT, SYSARG_4),
		peek_reg(tracee, CURRENT, SYSARG_5), peek_reg(tracee, CURRENT, SYSARG_6),
		peek_reg(tracee, CURRENT, SYSARG_RESULT),
		peek_reg(tracee, CURRENT, STACK_POINTER),
		get_abi(tracee));
	//test
	if (strcmp(stringify_sysnum(get_sysnum(tracee, CURRENT)),"openat") == 0){ //openat arm64
		char path[PATH_MAX];
       int status = get_sysarg_path(tracee, path, SYSARG_2); //会导致stack corruption detected
        if (status < 0){
            LOGSYS("vpid %" PRIu64 ",reg openat error,status:%d,err:%d,%s",tracee->vpid,status,errno,
                   strerror(errno))
        }else{
            LOGSYS("vpid %" PRIu64 ": open path:%s",tracee->vpid,path)
        }
	}

}

/**
 * Save the @tracee's current register bank into the @version register
 * bank.
 */
void save_current_regs(Tracee *tracee, RegVersion version)
{
	/* Optimization: don't restore original register values if
	 * they were never changed.  */
	if (version == ORIGINAL)
		tracee->_regs_were_changed = false;

	memcpy(&tracee->_regs[version], &tracee->_regs[CURRENT], sizeof(tracee->_regs[CURRENT]));
}

/**
 * Copy all @tracee's general purpose registers into a dedicated
 * cache.  This function returns -errno if an error occured, 0
 * otherwise.
 */
int fetch_regs(Tracee *tracee)
{
	int status;

#if defined(ARCH_ARM64)
	struct iovec regs;

	regs.iov_base = &tracee->_regs[CURRENT];
	regs.iov_len  = sizeof(tracee->_regs[CURRENT]);

	status = ptrace(PTRACE_GETREGSET, tracee->pid, NT_PRSTATUS, &regs);
#else
	status = ptrace(PTRACE_GETREGS, tracee->pid, NULL, &tracee->_regs[CURRENT]);
#endif
	if (status < 0)
		return status;

	return 0;
}

/**
 * Copy the cached values of all @tracee's general purpose registers
 * back to the process, if necessary.  This function returns -errno if
 * an error occured, 0 otherwise.
 */
int push_regs(Tracee *tracee)
{
	int status;

	if (tracee->_regs_were_changed) {
		/* At the very end of a syscall, with regard to the
		 * entry, only the result register can be modified by
		 * PRoot.  */
		if (tracee->restore_original_regs) {
			/* Restore the sysarg register only if it is
			 * not the same as the result register.  Note:
			 * it's never the case on x86 architectures,
			 * so don't make this check, otherwise it
			 * would introduce useless complexity because
			 * of the multiple ABI support.  */
#if defined(ARCH_X86) || defined(ARCH_X86_64)
#    define		RESTORE(sysarg)	(REG(tracee, CURRENT, sysarg) = REG(tracee, ORIGINAL, sysarg))
#else
#    define	 	RESTORE(sysarg) (void) (reg_offset[SYSARG_RESULT] != reg_offset[sysarg] && \
				(REG(tracee, CURRENT, sysarg) = REG(tracee, ORIGINAL, sysarg)))
#endif

			RESTORE(SYSARG_NUM);
			RESTORE(SYSARG_1);
			RESTORE(SYSARG_2);
			RESTORE(SYSARG_3);
			RESTORE(SYSARG_4);
			RESTORE(SYSARG_5);
			RESTORE(SYSARG_6);
			RESTORE(STACK_POINTER);
		}

#if defined(ARCH_ARM64)
		struct iovec regs;
		word_t current_sysnum = REG(tracee, CURRENT, SYSARG_NUM);

		/* Update syscall number if needed.  On arm64, a new
		 * subcommand has been added to PTRACE_{S,G}ETREGSET
		 * to allow write/read of current sycall number.  */
		if (current_sysnum != REG(tracee, ORIGINAL, SYSARG_NUM)) {
			regs.iov_base = &current_sysnum;
			regs.iov_len = sizeof(current_sysnum);
			status = ptrace(PTRACE_SETREGSET, tracee->pid, NT_ARM_SYSTEM_CALL, &regs);
			if (status < 0)
//				note(tracee, WARNING, SYSTEM, "can't set the syscall number");
			LOGSYSW("can't set the syscall number")
		}

		/* Update other registers.  */
		regs.iov_base = &tracee->_regs[CURRENT];
		regs.iov_len  = sizeof(tracee->_regs[CURRENT]);

		status = ptrace(PTRACE_SETREGSET, tracee->pid, NT_PRSTATUS, &regs);
#else
#    if defined(ARCH_ARM_EABI)
		/* On ARM, a special ptrace request is required to
		 * change effectively the syscall number during a
		 * ptrace-stop.  */
		word_t current_sysnum = REG(tracee, CURRENT, SYSARG_NUM);
		if (current_sysnum != REG(tracee, ORIGINAL, SYSARG_NUM)) {
			status = ptrace(PTRACE_SET_SYSCALL, tracee->pid, 0, current_sysnum);
			if (status < 0)
//				note(tracee, WARNING, SYSTEM, "can't set the syscall number");
                LOGW("can't set the syscall number")
		}
#    endif

		status = ptrace(PTRACE_SETREGS, tracee->pid, NULL, &tracee->_regs[CURRENT]);
#endif
		if (status < 0)
			return status;
	}

	return 0;
}

```

`library/src/main/jni/tracee/reg.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef TRACEE_REG_H
#define TRACEE_REG_H

#include "tracee/tracee.h"
#include "arch.h"

typedef enum {
	SYSARG_NUM = 0,
	SYSARG_1,
	SYSARG_2,
	SYSARG_3,
	SYSARG_4,
	SYSARG_5,
	SYSARG_6,
	SYSARG_RESULT,
	STACK_POINTER,
	INSTR_POINTER,
	RTLD_FINI,
	STATE_FLAGS,
	USERARG_1,
} Reg;

extern int fetch_regs(Tracee *tracee);
extern int push_regs(Tracee *tracee);

extern word_t peek_reg(const Tracee *tracee, RegVersion version, Reg reg);
extern void poke_reg(Tracee *tracee, Reg reg, word_t value);

extern void print_current_regs(Tracee *tracee, int verbose_level, const char *message);
extern void save_current_regs(Tracee *tracee, RegVersion version);

#endif /* TRACEE_REG_H */

```

`library/src/main/jni/tracee/tracee.c`:

```c
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <sched.h>      /* CLONE_*,  */
#include <sys/types.h>  /* pid_t, size_t, */
#include <stdlib.h>     /* NULL, */
#include <assert.h>     /* assert(3), */
#include <string.h>     /* bzero(3), */
#include <stdbool.h>    /* bool, true, false, */
#include <sys/queue.h>  /* LIST_*,  */
#include <signal.h>     /* kill(2), SIGKILL, */
#include <sys/ptrace.h> /* ptrace(2), PTRACE_*, */
#include <errno.h>      /* E*, */
#include <inttypes.h>   /* PRI*, */
#include <strings.h>

#include "tracee/tracee.h"
#include "tracee/reg.h"
//#include "path/binding.h"
#include "syscall/sysnum.h"
#include "tracee/event.h"
#include "ptrace/ptrace.h"
#include "ptrace/wait.h"
//#include "extension/extension.h"
//#include "cli/note.h"

#include "compat.h"
#include "constant.h"

#ifndef __W_STOPCODE
#define __W_STOPCODE(sig)	((sig) <<8 | 0x7f)
#endif

typedef LIST_HEAD(tracees, tracee) Tracees;
static Tracees tracees;


/**
 * Remove @zombie from its parent's list of zombies.  Note: this is a
 * talloc destructor.
 */
static int remove_zombie(Tracee *zombie)
{
    LIST_REMOVE(zombie, link);
    return 0;
}

/**
 * Perform some specific treatments against @pointer according to its
 * type, before it gets unlinked from @tracee_->life_context.
 */
//static void clean_life_span_object(const void *pointer, int depth UNUSED,
//                                   int max_depth UNUSED, int is_ref UNUSED, void *tracee_)
//{
//    Binding *binding;
//    Tracee *tracee;
//
//    tracee = talloc_get_type_abort(tracee_, Tracee);
//
//    /* So far, only bindings need a special treatment.  */
//    binding = talloc_get_type(pointer, Binding);
//    if (binding != NULL)
//        remove_binding_from_all_lists(tracee, binding);
//}

/**
 * Remove @tracee from the list of tracees and update all of its
 * children & ptracees, and its ptracer.  Note: this is a talloc
 * destructor.
 */
static int remove_tracee(Tracee *tracee)
{
    Tracee *relative;
    Tracee *ptracer;
    int event;

    LIST_REMOVE(tracee, link);

    /* Clean objects that are linked to this tracee's life
     * span.  */
//    talloc_report_depth_cb(tracee->life_context, 0, 100, clean_life_span_object, tracee);

    /* This could be optimize by using a dedicated list of
     * children and ptracees.  */
    LIST_FOREACH(relative, &tracees, link) {
        /* Its children are now orphan.  */
        if (relative->parent == tracee)
            relative->parent = NULL;

        /* Its tracees are now free.  */
        if (relative->as_ptracee.ptracer == tracee) {
            /* Release the pending event, if any.  */
            relative->as_ptracee.ptracer = NULL;

            if (relative->as_ptracee.event4.proot.pending) {
                event = handle_tracee_event(relative,
                                            relative->as_ptracee.event4.proot.value);
                (void) restart_tracee(relative, event);
            }
            else if (relative->as_ptracee.event4.ptracer.pending) {
                event = relative->as_ptracee.event4.proot.value;
                (void) restart_tracee(relative, event);
            }

            bzero(&relative->as_ptracee, sizeof(relative->as_ptracee));
        }
    }

    /* Nothing else to do if it's not a ptracee.  */
    ptracer = tracee->as_ptracee.ptracer;
    if (ptracer == NULL)
        return 0;

    /* Zombify this ptracee until its ptracer is notified about
     * its death.  */
    event = tracee->as_ptracee.event4.ptracer.value;
    if (tracee->as_ptracee.event4.ptracer.pending
        && (WIFEXITED(event) || WIFSIGNALED(event))) {
        Tracee *zombie;

        zombie = new_dummy_tracee(ptracer);
        if (zombie != NULL) {
            LIST_INSERT_HEAD(&PTRACER.zombies, zombie, link);
            //TODO 析构函数处理
            zombie->is_zombie = true;
//            talloc_set_destructor(zombie, remove_zombie);

            zombie->parent = tracee->parent;
            zombie->clone = tracee->clone;
            zombie->pid = tracee->pid;

            detach_from_ptracer(tracee);
            attach_to_ptracer(zombie, ptracer);

            zombie->as_ptracee.event4.ptracer.pending = true;
            zombie->as_ptracee.event4.ptracer.value = event;
            zombie->as_ptracee.is_zombie = true;

            return 0;
        }
        /* Fallback to the common path.  */
    }

    detach_from_ptracer(tracee);

    /* Wake its ptracer if there's nothing else to wait for.  */
    if (PTRACER.nb_ptracees == 0 && PTRACER.wait_pid != 0) {
        /* Update the return value of ptracer's wait(2).  */
        poke_reg(ptracer, SYSARG_RESULT, -ECHILD);

        /* Don't forget to write its register cache back.  */
        (void) push_regs(ptracer);

        PTRACER.wait_pid = 0;
        (void) restart_tracee(ptracer, 0);
    }

    return 0;
}


void before_tracee_free(Tracee *tracee){
    if (tracee == NULL) return;
    if (tracee->is_zombie){
        remove_zombie(tracee);
    }else{
        remove_tracee(tracee);
    }
}


/**
 * Allocate a new entry for a dummy tracee (no pid, no destructor, not
 * in the list of tracees, ...).  The new allocated memory is attached
 * to the given @context.  This function returns NULL if an error
 * occurred (ENOMEM), otherwise it returns the newly allocated
 * structure.
 */
Tracee *new_dummy_tracee(void *context)
{
    Tracee *tracee;

//    tracee = talloc_zero(context, Tracee);

    tracee =   calloc(1, sizeof(Tracee));
    if (tracee == NULL)
        return NULL;
    /* Allocate a memory collector.  */
//    tracee->ctx = talloc_new(tracee);
//    if (tracee->ctx == NULL)
//        goto no_mem;

    /* By default new tracees have an empty file-system
     * name-space and heap.  */
//    tracee->fs = talloc_zero(tracee, FileSystemNameSpace);
//    tracee->heap = talloc_zero(tracee, Heap);
//    if (tracee->fs == NULL || tracee->heap == NULL)
//        goto no_mem;

    return tracee;

//    no_mem:
//    TALLOC_FREE(tracee);
//    return NULL;
}

static uint64_t next_vpid = 1;

/**
 * Allocate a new entry for the tracee @pid, then set its destructor
 * and add it to the list of tracees.  This function returns NULL if
 * an error occurred (ENOMEM), otherwise it returns the newly
 * allocated structure.
 */
static Tracee *new_tracee(pid_t pid)
{
    Tracee *tracee;

    tracee = new_dummy_tracee(NULL);
    if (tracee == NULL)
        return NULL;
//    talloc_set_destructor(tracee, remove_tracee);
//new_dummy_tracee中清零了，即都默认为false
//    tracee->is_zombie = false;
//    tracee->is_root = false;
    tracee->pid = pid;
    tracee->vpid = next_vpid++;

    LIST_INSERT_HEAD(&tracees, tracee, link);

//    tracee->life_context = talloc_new(tracee);

    return tracee;
}

/**
 * Return the first [stopped?] tracee with the given
 * @pid (-1 for any) which has the given @ptracer, and which has a
 * pending event for its ptracer if @only_with_pevent is true.  See
 * wait(2) manual for the meaning of @wait_options.  This function
 * returns NULL if there's no such ptracee.
 */
Tracee *get_ptracee(const Tracee *ptracer, pid_t pid, bool only_stopped,
                    bool only_with_pevent, word_t wait_options)
{
    Tracee *ptracee;

    /* Return zombies first.  */
    LIST_FOREACH(ptracee, &PTRACER.zombies, link) {
        /* Not the ptracee you're looking for?  */
        if (pid != ptracee->pid && pid != -1)
            continue;

        /* Not the expected kind of cloned process?  */
        if (!EXPECTED_WAIT_CLONE(wait_options, ptracee))
            continue;

        return ptracee;
    }

    LIST_FOREACH(ptracee, &tracees, link) {
        /* Discard tracees that don't have this ptracer.  */
        if (PTRACEE.ptracer != ptracer)
            continue;

        /* Not the ptracee you're looking for?  */
        if (pid != ptracee->pid && pid != -1)
            continue;

        /* Not the expected kind of cloned process?  */
        if (!EXPECTED_WAIT_CLONE(wait_options, ptracee))
            continue;

        /* No need to do more checks if its stopped state
         * doesn't matter.  Be careful when using such
         * maybe-running tracee.  */
        if (!only_stopped)
            return ptracee;

        /* Is this tracee in the stopped state?  */
        if (ptracee->running)
            continue;

        /* Has a pending event for its ptracer?  */
        if (PTRACEE.event4.ptracer.pending || !only_with_pevent)
            return ptracee;

        /* No need to go further if the specific tracee isn't
         * in the expected state?  */
        if (pid == ptracee->pid)
            return NULL;
    }

    return NULL;
}

/**
 * Wrapper for get_ptracee(), this ensures only a stopped tracee is
 * returned (or NULL).
 */
Tracee *get_stopped_ptracee(const Tracee *ptracer, pid_t pid,
                            bool only_with_pevent, word_t wait_options)
{
    return get_ptracee(ptracer, pid, true, only_with_pevent, wait_options);
}

/**
 * Wrapper for get_ptracee(), this ensures no running tracee is
 * returned.
 */
bool has_ptracees(const Tracee *ptracer, pid_t pid, word_t wait_options)
{
    return (get_ptracee(ptracer, pid, false, false, wait_options) != NULL);
}

/**
 * Return the entry related to the tracee @pid.  If no entry were
 * found, a new one is created if @create is true, otherwise NULL is
 * returned.
 */
Tracee *get_tracee(const Tracee *current_tracee, pid_t pid, bool create)
{
    Tracee *tracee;

    /* Don't reset the memory collector if the searched tracee is
     * the current one: there's likely pointers to the
     * sub-allocated data in the caller.  */
    if (current_tracee != NULL && current_tracee->pid == pid)
        return (Tracee *)current_tracee;
    //TODO 考虑是否应该每个zygote子进程一个tracees
    LIST_FOREACH(tracee, &tracees, link) {
        if (tracee->pid == pid) {
            /* Flush then allocate a new memory collector.  */
//            TALLOC_FREE(tracee->ctx);
//            tracee->ctx = talloc_new(tracee);

            return tracee;
        }
    }

    return (create ? new_tracee(pid) : NULL);
}

/**
 *  tracee 端构造一个Tracee实例(不放到queue里)
 */
Tracee  * get_tracee_for_ee(pid_t pid){
    Tracee *tracee;

    tracee = new_dummy_tracee(NULL);
    if (tracee == NULL)
        return NULL;

    tracee->pid = pid;
    tracee->vpid = next_vpid++;

//    tracee->life_context = talloc_new(tracee);

    return tracee;
}

/**
 * Mark tracee as terminated and optionally take action.
 */
void terminate_tracee(Tracee *tracee)
{
    tracee->terminated = true;

    /* Case where the terminated tracee is marked
       to kill all tracees on exit.
    */
    if (__UNLIKELY(tracee->killall_on_exit)) {
//        VERBOSE(tracee, 1, "terminating all tracees on exit");
        LOGI("terminating all tracees on exit,%p",tracee);
        kill_all_tracees();
    }
}

/**
 * Free all tracees marked as terminated.
 */
void free_terminated_tracees()
{
    Tracee *next;

    /* Items can't be deleted when using LIST_FOREACH.  */
    next = tracees.lh_first;
    while (next != NULL) {
        Tracee *tracee = next;
        next = tracee->link.le_next;

        if (tracee->terminated){
//            TALLOC_FREE(tracee);
            //析构
            before_tracee_free(tracee);
            free(tracee);
        }
    }
}

/**
 * Make new @parent's child inherit from it.  Depending on
 * @clone_flags, some information are copied or shared.  This function
 * returns -errno if an error occured, otherwise 0.
 */
int new_child(Tracee *parent, word_t clone_flags)
{
    int ptrace_options;
    unsigned long pid;
    Tracee *child;
    int status;

    /* If the tracee calls clone(2) with the CLONE_VFORK flag,
     * PTRACE_EVENT_VFORK will be delivered instead [...];
     * otherwise if the tracee calls clone(2) with the exit signal
     * set to SIGCHLD, PTRACE_EVENT_FORK will be delivered [...]
     *
     * -- ptrace(2) man-page
     *
     * That means we have to check if it's actually a clone(2) in
     * order to get the right flags.
     */
    status = fetch_regs(parent);
    if (status >= 0 && get_sysnum(parent, CURRENT) == PR_clone)
        clone_flags = peek_reg(parent, CURRENT, SYSARG_1);

    /* Get the pid of the parent's new child.  */
    status = ptrace(PTRACE_GETEVENTMSG, parent->pid, NULL, &pid);
    if (status < 0 || pid == 0) {
//        note(parent, WARNING, SYSTEM, "ptrace(GETEVENTMSG)");
        LOGW("ptrace(GETEVENTMSG)");
        return status;
    }

    child = get_tracee(parent, (pid_t) pid, true);
    if (child == NULL) {
//        note(parent, WARNING, SYSTEM, "running out of memory");
        LOGW("running out of memory");
        return -ENOMEM;
    }

    /* Sanity checks.  */
    assert(child != NULL
//           && child->exe == NULL
//           && child->fs->cwd == NULL
//           && child->fs->bindings.pending == NULL
//           && child->fs->bindings.guest == NULL
//           && child->fs->bindings.host == NULL
//           && child->qemu == NULL
           && child->glue == NULL
           && child->parent == NULL
           && child->as_ptracee.ptracer == NULL);

    child->verbose = parent->verbose;
    child->seccomp = parent->seccomp;
    child->sysexit_pending = parent->sysexit_pending;
    child->restart_how = parent->restart_how;
#ifdef ARCH_ARM64
    child->is_aarch32 = parent->is_aarch32;
    LOGSYS("is_aarch32 2 %d--------------------",child->is_aarch32)
#endif

    /* If CLONE_VM is set, the calling process and the child
     * process run in the same memory space [...] any memory
     * mapping or unmapping performed with mmap(2) or munmap(2) by
     * the child or calling process also affects the other
     * process.
     *
     * If CLONE_VM is not set, the child process runs in a
     * separate copy of the memory space of the calling process at
     * the time of clone().  Memory writes or file
     * mappings/unmappings performed by one of the processes do
     * not affect the other, as with fork(2).
     *
     * -- clone(2) man-page
     */
//    TALLOC_FREE(child->heap);
//    child->heap = ((clone_flags & CLONE_VM) != 0)
//                  ? talloc_reference(child, parent->heap)
//                  : talloc_memdup(child, parent->heap, sizeof(Heap));
//    if (child->heap == NULL)
//        return -ENOMEM;

    /* If CLONE_PARENT is set, then the parent of the new child
     * (as returned by getppid(2)) will be the same as that of the
     * calling process.
     *
     * If CLONE_PARENT is not set, then (as with fork(2)) the
     * child's parent is the calling process.
     *
     * -- clone(2) man-page
     */
    if ((clone_flags & CLONE_PARENT) != 0)
        child->parent = parent->parent;
    else
        child->parent = parent;

    /* Remember if this child belongs to the same thread group as
     * its parent.  This is currently useful for ptrace emulation
     * only but it deserves to be extended to support execve(2)
     * specificity (ie. when a thread calls execve(2), its pid
     * gets replaced by the pid of its thread group leader).  */
    child->clone = ((clone_flags & CLONE_THREAD) != 0);

    /* Depending on how the new process is created, it may be
     * automatically traced by the parent's tracer.  */
    ptrace_options = ( clone_flags == 0			? PTRACE_O_TRACEFORK
                                                   : (clone_flags & 0xFF) == SIGCHLD	? PTRACE_O_TRACEFORK
                                                                                        : (clone_flags & CLONE_VFORK) != 0	? PTRACE_O_TRACEVFORK
                                                                                                                              : 					  PTRACE_O_TRACECLONE);
    if (parent->as_ptracee.ptracer != NULL
        && (   (ptrace_options & parent->as_ptracee.options) != 0
               || (clone_flags & CLONE_PTRACE) != 0)) {
        attach_to_ptracer(child, parent->as_ptracee.ptracer);

        /* All these flags are inheritable, no matter why this
         * child is being traced.  */
        child->as_ptracee.options |= (parent->as_ptracee.options
                                      & ( PTRACE_O_TRACECLONE
                                          | PTRACE_O_TRACEEXEC
                                          | PTRACE_O_TRACEEXIT
                                          | PTRACE_O_TRACEFORK
                                          | PTRACE_O_TRACESYSGOOD
                                          | PTRACE_O_TRACEVFORK
                                          | PTRACE_O_TRACEVFORKDONE));
    }

    /* If CLONE_FS is set, the parent and the child process share
     * the same file system information.  This includes the root
     * of the file system, the current working directory, and the
     * umask.  Any call to chroot(2), chdir(2), or umask(2)
     * performed by the parent process or the child process also
     * affects the other process.
     *
     * If CLONE_FS is not set, the child process works on a copy
     * of the file system information of the parent process at the
     * time of the clone() call.  Calls to chroot(2), chdir(2),
     * umask(2) performed later by one of the processes do not
     * affect the other process.
     *
     * -- clone(2) man-page
     */
//    TALLOC_FREE(child->fs);
//    if ((clone_flags & CLONE_FS) != 0) {
//        /* File-system name-space is shared.  */
//        child->fs = talloc_reference(child, parent->fs);
//    }
//    else {
//        /* File-system name-space is copied.  */
//        child->fs = talloc_zero(child, FileSystemNameSpace);
//        if (child->fs == NULL)
//            return -ENOMEM;
//
//        child->fs->cwd = talloc_strdup(child->fs, parent->fs->cwd);
//        if (child->fs->cwd == NULL)
//            return -ENOMEM;
//        talloc_set_name_const(child->fs->cwd, "$cwd");
//
//        /* Bindings are shared across file-system name-spaces since a
//         * "mount --bind" made by a process affects all other processes
//         * under Linux.  Actually they are copied when a sub
//         * reconfiguration occured (nested proot or chroot(2)).  */
//        child->fs->bindings.guest = talloc_reference(child->fs, parent->fs->bindings.guest);
//        child->fs->bindings.host  = talloc_reference(child->fs, parent->fs->bindings.host);
//    }

    /* The path to the executable is unshared only once the child
     * process does a call to execve(2).  */
//    child->exe = talloc_reference(child, parent->exe);
//    child->exe = parent->exe;

//    child->qemu = talloc_reference(child, parent->qemu);
//    child->qemu = parent->qemu;
//    child->glue = talloc_reference(child, parent->glue);
    child->glue = parent->glue;

//    child->host_ldso_paths  = talloc_reference(child, parent->host_ldso_paths);
//    child->guest_ldso_paths = talloc_reference(child, parent->guest_ldso_paths);
    child->host_ldso_paths  = parent->host_ldso_paths;
    child->guest_ldso_paths = parent->guest_ldso_paths;

    child->tool_name = parent->tool_name;

//    inherit_extensions(child, parent, clone_flags);

    /* Restart the child tracee if it was already alive but
     * stopped until that moment.  */
    if (child->sigstop == SIGSTOP_PENDING) {
        bool keep_stopped = false;

        child->sigstop = SIGSTOP_ALLOWED;

        /* Notify its ptracer if it is ready to be traced.  */
        if (child->as_ptracee.ptracer != NULL) {
            /* Sanity check.  */
            assert(!child->as_ptracee.tracing_started);

            keep_stopped = handle_ptracee_event(child, __W_STOPCODE(SIGSTOP));

            /* Note that this event was already handled by
             * PRoot since child->as_ptracee.ptracer was
             * NULL up to now.  */
            child->as_ptracee.event4.proot.pending = false;
            child->as_ptracee.event4.proot.value   = 0;
        }

        if (!keep_stopped)
            (void) restart_tracee(child, 0);
    }

//    VERBOSE(child, 1, "vpid %" PRIu64 ": pid %d", child->vpid, child->pid);
    LOGD("vpid %" PRIu64 ": pid %d", child->vpid, child->pid);

    return 0;
}

/**
 * Helper for swap_config().
 */
static void reparent_config(Tracee *new_parent, Tracee *old_parent)
{
    new_parent->verbose = old_parent->verbose;

//#define REPARENT(field) do {							\
//		talloc_reparent(old_parent, new_parent, old_parent->field);	\
//		new_parent->field = old_parent->field;				\
//	} while(0);
#define REPARENT(field) do {							\
		new_parent->field = old_parent->field;				\
	} while(0);

//    REPARENT(fs);
//    REPARENT(exe);
//    REPARENT(qemu);
    REPARENT(glue);
//    REPARENT(extensions);

#undef REPARENT
}

/**
 * Swap configuration (pointers and parentality) between @tracee1 and @tracee2.
 */
int swap_config(Tracee *tracee1, Tracee *tracee2)
{
    Tracee *tmp;

//    tmp = talloc_zero(tracee1->ctx, Tracee);
    tmp = malloc(sizeof(Tracee));
    if (tmp == NULL)
        return -ENOMEM;
    memset(tmp,0, sizeof(Tracee));

    reparent_config(tmp,     tracee1);
    reparent_config(tracee1, tracee2);
    reparent_config(tracee2, tmp);

    return 0;
}

/* Send the KILL signal to all tracees.  */
void kill_all_tracees()
{
    LOGD("kill_all_tracees %d",getpid())
    Tracee *tracee;

    LIST_FOREACH(tracee, &tracees, link)
    kill(tracee->pid, SIGKILL);
}

```

`library/src/main/jni/tracee/tracee.h`:

```h
/* -*- c-set-style: "K&R"; c-basic-offset: 8 -*-
 *
 * This file is part of PRoot.
 *
 * Copyright (C) 2015 STMicroelectronics
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#ifndef TRACEE_H
#define TRACEE_H

#include <sys/types.h> /* pid_t, size_t, */
#include <sys/user.h>  /* struct user*, */
#include <stdbool.h>   /* bool,  */
#include <sys/queue.h> /* LIST_*, */
#include <sys/ptrace.h>/* enum __ptrace_request */
//#include <talloc.h>    /* talloc_*, */
#include <stdint.h>    /* *int*_t, */
#include <sys/wait.h>  /* __WAIT_* */
#include "arch.h" /* word_t, user_regs_struct, */
#include "compat.h"

#if defined(__GLIBC__)
#define PTRACE_REQUEST_TYPE	enum __ptrace_request
#else
#define PTRACE_REQUEST_TYPE	int
#endif

typedef enum {
    CURRENT  = 0,
    ORIGINAL = 1,
    MODIFIED = 2,
    NB_REG_VERSION
} RegVersion;

struct bindings;
struct load_info;
struct extensions;
struct chained_syscalls;

/* Information related to a file-system name-space.  */
typedef struct {
    struct {
        /* List of bindings as specified by the user but not canonicalized yet.  */
        struct bindings *pending;

        /* List of bindings canonicalized and sorted in the "guest" order.  */
        struct bindings *guest;

        /* List of bindings canonicalized and sorted in the "host" order.  */
        struct bindings *host;
    } bindings;

    /* Current working directory, à la /proc/self/pwd.  */
    char *cwd;
} FileSystemNameSpace;

/* Virtual heap, emulated with a regular memory mapping.  */
typedef struct {
    word_t base;
    size_t size;
    bool disabled;
} Heap;

/* Information related to a tracee process. */
typedef struct tracee {
    /**********************************************************************
     * Private resources                                                  *
     **********************************************************************/

    /* Link for the list of all tracees.  */
    LIST_ENTRY(tracee) link;

    /* Process identifier. */
    pid_t pid;

    /* Unique tracee identifier. */
    uint64_t vpid;

    /* Is it currently running or not?  */
    bool running;

    /* Is this tracee ready to be freed?  TODO: move to a list
     * dedicated to terminated tracees instead.  */
    bool terminated;

    /* Whether termination of this tracee implies an immediate kill
     * of all tracees. */
    bool killall_on_exit;

    /* Parent of this tracee, NULL if none.  */
    struct tracee *parent;

    /* Is it a "clone", i.e has the same parent as its creator.  */
    bool clone;

    /* Support for ptrace emulation (tracer side).  */
    struct {
        size_t nb_ptracees;
        LIST_HEAD(zombies, tracee) zombies;

        pid_t wait_pid;
        word_t wait_options;

        enum {
            DOESNT_WAIT = 0,
            WAITS_IN_KERNEL,
            WAITS_IN_PROOT
        } waits_in;
    } as_ptracer;

    /* Support for ptrace emulation (tracee side).  */
    struct {
        struct tracee *ptracer;

        struct {
#define STRUCT_EVENT struct { int value; bool pending; }

            STRUCT_EVENT proot;
            STRUCT_EVENT ptracer;
        } event4;

        bool tracing_started;
        bool ignore_loader_syscalls;
        bool ignore_syscalls;
        word_t options;
        bool is_zombie;
    } as_ptracee;

    /* Current status:
     *        0: enter syscall
     *        1: exit syscall no error
     *   -errno: exit syscall with error.  */
    int status;

#define IS_IN_SYSENTER(tracee) ((tracee)->status == 0)
#define IS_IN_SYSEXIT(tracee) (!IS_IN_SYSENTER(tracee))
#define IS_IN_SYSEXIT2(tracee, sysnum) (IS_IN_SYSEXIT(tracee) \
				     && get_sysnum((tracee), ORIGINAL) == sysnum)

    /* How this tracee is restarted.  */
    PTRACE_REQUEST_TYPE restart_how;

    /* Value of the tracee's general purpose registers.  */
    struct user_regs_struct _regs[NB_REG_VERSION];
    bool _regs_were_changed;
    bool restore_original_regs;

    /* State for the special handling of SIGSTOP.  */
    enum {
        SIGSTOP_IGNORED = 0,  /* Ignore SIGSTOP (once the parent is known).  */
        SIGSTOP_ALLOWED,      /* Allow SIGSTOP (once the parent is known).   */
        SIGSTOP_PENDING,      /* Block SIGSTOP until the parent is unknown.  */
    } sigstop;

    /* Context used to collect all the temporary dynamic memory
     * allocations.  */
//    TALLOC_CTX *ctx;

    /* Context used to collect all dynamic memory allocations that
     * should be released once this tracee is freed.  */
//    TALLOC_CTX *life_context;

    /* Note: I could rename "ctx" in "event_span" and
     * "life_context" in "life_span".  */

    /* Specify the type of the final component during the
     * initialization of a binding.  This variable is first
     * defined in bind_path() then used in build_glue().  */
    mode_t glue_type;

    /* During a sub-reconfiguration, the new setup is relatively
     * to @tracee's file-system name-space.  Also, @paths holds
     * its $PATH environment variable in order to emulate the
     * execvp(3) behavior.  */
    struct {
        struct tracee *tracee;
        const char *paths;
    } reconf;

    /* Unrequested syscalls inserted by PRoot after an actual
     * syscall.  */
    struct {
        struct chained_syscalls *syscalls;
        bool force_final_result;
        word_t final_result;
    } chain;

    /* Load info generated during execve sysenter and used during
     * execve sysexit.  */
    struct load_info *load_info;

    /* Disable mixed-execution (native host) check */
    bool mixed_mode;

#ifdef ARCH_ARM64
    bool is_aarch32;
#endif
    //使用者寄存的数据
    void* user_context_data;
    /**********************************************************************
     * Private but inherited resources                                    *
     **********************************************************************/

    /* Verbose level.  */
    int verbose;

    /* State of the seccomp acceleration for this tracee.  */
    enum { DISABLED = 0, DISABLING, ENABLED } seccomp;

    /* Ensure the sysexit stage is always hit under seccomp.  */
    bool sysexit_pending;


    /**********************************************************************
     * Shared or private resources, depending on the CLONE_FS/VM flags.   *
     **********************************************************************/

    /* Information related to a file-system name-space.  */
//    FileSystemNameSpace *fs;

    /* Virtual heap, emulated with a regular memory mapping.  */
//    Heap *heap;


    /**********************************************************************
     * Shared resources until the tracee makes a call to execve().        *
     **********************************************************************/

    /* Path to the executable, à la /proc/self/exe.  */
//    char *exe;
    char *new_exe;


    /**********************************************************************
     * Shared or private resources, depending on the (re-)configuration   *
     **********************************************************************/

    /* Runner command-line.  */
//    char **qemu; //Execute guest programs through QEMU as specified by *command*. QEMU模拟器状态,去掉 proot.h handle_option_q

    /* Path to glue between the guest rootfs and the host rootfs.  */
    const char *glue;

    /* List of extensions enabled for this tracee.  */
//    struct extensions *extensions;


    /**********************************************************************
     * Shared but read-only resources                                     *
     **********************************************************************/

    /* For the mixed-mode, the guest LD_LIBRARY_PATH is saved
     * during the "guest -> host" transition, in order to be
     * restored during the "host -> guest" transition (only if the
     * host LD_LIBRARY_PATH hasn't changed).  */
    const char *host_ldso_paths;
    const char *guest_ldso_paths;

    /* For diagnostic purpose.  */
    const char *tool_name;
    bool is_zombie;
    /**
     * 是不是进程树的根线程/进程
     */
    bool is_root;
    /**
     * 仅在tracee root线程的首次处理bare sigtrap使用,默认为false
     */
    bool deliver_sigtrap;
    bool seccomp_detected;
    bool seccomp_enabled; /* added for 4.8.0 */
} Tracee;

#define HOST_ROOTFS "/host-rootfs"

#define TRACEE(a) talloc_get_type_abort(talloc_parent(talloc_parent(a)), Tracee)

extern Tracee *get_tracee(const Tracee *tracee, pid_t pid, bool create);
extern Tracee  * get_tracee_for_ee(pid_t pid);
extern Tracee *get_ptracee(const Tracee *ptracer, pid_t pid, bool only_stopped,
                           bool only_with_pevent, word_t wait_options);
extern Tracee *get_stopped_ptracee(const Tracee *ptracer, pid_t pid,
                                   bool only_with_pevent, word_t wait_options);
extern bool has_ptracees(const Tracee *ptracer, pid_t pid, word_t wait_options);
extern int new_child(Tracee *parent, word_t clone_flags);
extern Tracee *new_dummy_tracee(void *context);
extern void terminate_tracee(Tracee *tracee);
extern void free_terminated_tracees();
extern int swap_config(Tracee *tracee1, Tracee *tracee2);
extern void kill_all_tracees();
//对应talloc析构函数位置
void before_tracee_free(Tracee *tracee);

#endif /* TRACEE_H */

```

`settings.gradle`:

```gradle
include ':app'
include ':library'

```