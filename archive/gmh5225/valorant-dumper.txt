Project Path: arc_gmh5225_valorant-dumper_7h_o5wh7

Source Tree:

```txt
arc_gmh5225_valorant-dumper_7h_o5wh7
├── README.md
├── dllmain.cpp
├── dumper.sln
├── dumper.vcxproj
├── dumper.vcxproj.filters
├── dumper.vcxproj.user
├── framework.h
├── func.h
├── pch.cpp
├── pch.h
├── pseh-common.h
├── pseh2.h
├── rtl.h
└── vectorhandler.h

```

`README.md`:

```md
# valorant-dumper

By using a .dll to inject into the memory process, it allows reading of the memory despite the exception handler. The project also includes a work-in-progress exception that can be raised. As of know, I am unsure whether raising the exception matters. 

Instructions
1. Compile the .dll
2. Disable Vanguard, run Valorant from explorer.exe, inject

BEWARE: The signatures and masks are "as-is". They are not 100% perfect and may need to be updated. 
As well, the .dll can sometimes hang or become very slow. Simply re-run Valorant and re-inject. 

As of now, it can properly dump the main, necessary offsets for Valorant as of 5/22/2022
[https://streamable.com/ibb3w2]


```

`dllmain.cpp`:

```cpp
#pragma once

#include "pch.h"

#include <winternl.h>

#include <Windows.h>
#include <iostream>
#include <fstream>
#include <TlHelp32.h>
#include <Psapi.h>
#include <heapapi.h>
#pragma comment(lib, "ntdll.lib")

#include <dbghelp.h>
#include <shlobj.h>
#include <tchar.h>

#include "func.h"

void(__stdcall* ZwRaiseException)(PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ThreadContext, BOOLEAN HandleException);

DWORD_PTR baseTextAddress = 0;
DWORD size_of_text = 0;

DWORD WINAPI protect(PVOID address)
{
	PEXCEPTION_RECORD exr = NULL;
	CONTEXT ctx;

	ctx.Rip = TerminateThread((HANDLE)-2, 0);
	exr->NumberParameters = 2;
	exr->ExceptionCode = EXCEPTION_ACCESS_VIOLATION;
	exr->ExceptionAddress = address;
	exr->ExceptionInformation[1] = (ULONG_PTR)address;

	ZwRaiseException(exr, &ctx, 1);
	return 0;

}

void try_protect(PVOID address)
{
	HANDLE hthread = CreateThread(NULL, 0, protect, address, NULL, 0);
	WaitForSingleObject(hthread, INFINITE);
	CloseHandle(hthread);

}

DWORD WINAPI decrypt()
{
	AllocConsole();
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);

	DWORD textPageCount = 0;
	DWORD dataPageCount = 0;

	PIMAGE_DOS_HEADER imageDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandleA(NULL);
	PIMAGE_NT_HEADERS imageNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)imageDosHeader + imageDosHeader->e_lfanew);
	DWORD sectionCount = imageNtHeaders->FileHeader.NumberOfSections;
	PIMAGE_SECTION_HEADER imageSection = (PIMAGE_SECTION_HEADER)((DWORD_PTR)&imageNtHeaders->OptionalHeader + imageNtHeaders->FileHeader.SizeOfOptionalHeader);
	for (DWORD i = 0; i < sectionCount; ++i)
	{
		if (strcmp((const char*)(imageSection + i)->Name, ".text") == 0)
		{
			baseTextAddress = (DWORD_PTR)imageDosHeader + (imageSection + i)->PointerToRawData - 0x1000;
			size_of_text += ((imageSection + i)->SizeOfRawData);
			textPageCount = ((imageSection + i)->SizeOfRawData) / 0x1000;
			break;

		}
		else
		{
			PrintMessage("[+] failed to find base_address!\n");
			system("pause");
			return 0;

		}

	}
	const char* code_buffer = (const char*)calloc(1, size_of_text);
	*(PVOID*)&ZwRaiseException = GetProcAddress(GetModuleHandleA("ntdll.dll"), "ZwRaiseException");

	for(int i = 0; i < textPageCount; i++)
	{
		PVOID address = (PVOID)(baseTextAddress + i * 0x1000);

		MEMORY_BASIC_INFORMATION mbi;
		memset(&mbi, 0, sizeof(mbi));
		VirtualQuery(address, &mbi, sizeof(mbi));

		if (mbi.Protect == PAGE_NOACCESS) try_protect(address);

		memset(&mbi, 0, sizeof(mbi));
		VirtualQuery(address, &mbi, sizeof(mbi));

		if (mbi.Protect != PAGE_NOACCESS)
			memcpy((char*)code_buffer + ((DWORD_PTR)address - baseTextAddress), address, 0x1000);

		if ((i + 1) % 200 == 0 || i + 1 == textPageCount)
			PrintMessage("[+] loading: ~%c%d/%d~%c\n", 11, i + 1, textPageCount, 15);

	}

	uintptr_t gos = find_pattern(code_buffer, baseTextAddress, size_of_text, "\x4C\x8B\x8C\xD9\x00\x00\x00\x00\x49\xC1\xEA\x20\xB8\x00\x00\x00\x00\xF7\xE3\x8B\xC3", "xxxx????xxxxx????xxxx", 0x5);

	uintptr_t uw = find_pattern(code_buffer, baseTextAddress, size_of_text, "\x4B\x8B\xBC\xD5\x00\x00\x00\x00\x41\x8B\xC2\x2B\xC2\x45\x8B\xCA", "xxxx????xxxxxxxx", 0x5);

	uintptr_t gi = find_pattern(code_buffer, baseTextAddress, size_of_text, "\x49\x8B\x87\x00\x00\x00\x00\x48\x85\xC0\x74\x09\x48\x8B\xB0\x00\x00\x00\x00\xEB\x07", "xxx????xxxxxxxx????xx", 0x4);

	uintptr_t lpa = find_pattern(code_buffer, baseTextAddress, size_of_text, "\x4E\x8B\x4C\xC1\x00\x49\xC1\xEA\x20\xB8\x00\x00\x00\x00\x41\xF7\xE0\x41\x8B\xC0", "xxxx?xxxxx????xxxxxx", 0x5);
	
	uintptr_t apawn = find_pattern(code_buffer, baseTextAddress, size_of_text, "\x48\x8B\x40\x08\xFF\x15\x00\x00\x00\x00\x90\x48\x85\xF6\x74\x14\x48\x8B\x06\x48\x8B\xCE\x48\x8B\x80\x00\x00\x00\x00\xFF\x15\x00\x00\x00\x00\x90", "xxxxxx????xxxxxxxxxxxxxxx????xx????x", 0x1A);

	uintptr_t root = find_pattern(code_buffer, baseTextAddress, size_of_text, "\x48\x8B\x83\x00\x00\x00\x00\x48\x85\xC0\x74\x08\x48\x05\x00\x00\x00\x00\xEB\x07", "xxx????xxxxxxx????xx", 0x4);

	uintptr_t position = find_pattern(code_buffer, baseTextAddress, size_of_text, "\x8B\x87\x00\x00\x00\x00\x89\x83\x00\x00\x00\x00\x48\x8B\x87\x00\x00\x00\x00\x48\x89\x83\x00\x00\x00\x00\x48\x81\xC3\x00\x00\x00\x00\x49\x3B\xDE", "xx????xx????xxx????xxx????xxx????xxx", 0x3);

	uintptr_t damage = find_pattern(code_buffer, baseTextAddress, size_of_text, "\x48\x8B\x89\x00\x00\x00\x00\x0F\x28\xF2\x48\x8B\xFA\x48\x85\xC9", "xxx????xxxxxxxxx", 0x4);

	uintptr_t pcamera = find_pattern(code_buffer, baseTextAddress, size_of_text, "\xF2\x0F\x11\x87\x00\x00\x00\x00\x8B\x48\x08\x89\x8F\x00\x00\x00\x00\xF2\x0F\x10\x40\x00", "xxxx????xxxxx????xxxx?", 0x5);

	uintptr_t rcamera = find_pattern(code_buffer, baseTextAddress, size_of_text, "\xF2\x0F\x11\x87\x00\x00\x00\x00\x8B\x48\x14\x89\x8F\x00\x00\x00\x00\x8B\x40\x18\x89\x87\x00\x00\x00\x00", "xxxx????xxxxx????xxxxx????", 0x5);

	uintptr_t fcamera = find_pattern(code_buffer, baseTextAddress, size_of_text, "\xF2\x0F\x11\x87\x00\x00\x00\x00\x8B\x48\x14\x89\x8F\x00\x00\x00\x00\x8B\x40\x18\x89\x87\x00\x00\x00\x00", "xxxx????xxxxx????xxxxx????", 0x17);

	uintptr_t los = find_pattern(code_buffer, baseTextAddress, size_of_text, "\x48\x8B\x00\x55\x56\x57\x41\x00\x41\x00\x48\x8D\x00\x00\x48\x81\xEC\x00\x00\x00\x00\x48\xC7\x44\x24\x60", "xx?xxxx?x?xx??xxx????xxxxx", 0x1);

	uintptr_t tcomp = find_pattern(code_buffer, baseTextAddress, size_of_text, "\x48\x8B\x03\x45\x33\xC0\x48\x8B\x17\x48\x8B\xCB\x48\x8B\x80\x00\x00\x00\x00", "xxxxxxxxxxxxxxx????", 0x10);

	PrintMessage("===============================\n");

	if (gos)      PrintMessage("uintptr_t g_object_state = 0x%X\n", *(uintptr_t*)gos);
	if (uw)       PrintMessage("uintptr_t uworld_state = 0x%X\n", *(uintptr_t*)uw); else PrintMessage("failed to find uworld_state\n");
	if (uw)       PrintMessage("uintptr_t uworld_key = 0x%X\n", *(uintptr_t*)uw + 0x38); else PrintMessage("failed to find uworld_key\n");
	if (gi)       PrintMessage("uintptr_t game_instance = 0x%X\n", *(uintptr_t*)gi); else PrintMessage("failed to find game_instance\n");
	              PrintMessage("uintptr_t persistent_level = 0x%i\n", 38);
	if (lpa)      PrintMessage("uintptr_t local_player_array = 0x%X\n", *(char*)lpa); else PrintMessage("failed to find local_player_array\n");
	              PrintMessage("uintptr_t player_controller = 0x%i\n", 38);
	if (apawn)    PrintMessage("uintptr_t apawn = 0x%X\n", *(short*)apawn);
	if (root)     PrintMessage("uintptr_t root_component = 0x%X\n", *(short*)root);
	if (position) PrintMessage("uintptr_t position = 0x%X\n", *(short*)position);
	if (damage)   PrintMessage("uintptr_t damage_controller = 0x%X\n", *(short*)damage);
	if (pcamera)  PrintMessage("uintptr_t camera_position = 0x%X\n", *(short*)pcamera);
	if (rcamera)  PrintMessage("uintptr_t camera_position = 0x%X\n", *(short*)rcamera);
	if (fcamera)  PrintMessage("uintptr_t camera_position = 0x%X\n", *(short*)fcamera);
	if (los)      PrintMessage("uintptr_t line_of_sight = 0x%X\n", los - baseTextAddress);
	if (tcomp)    PrintMessage("uintptr_t team_component = 0x%X\n", *(short*)tcomp);

	PrintMessage("===============================\n");

	PrintMessage("[+] dumping!\n");

	if (write_file("C:\\v_dumps\\v_dump.exe", code_buffer, size_of_text)) PrintMessage("[+] dumped!\n");
	else PrintMessage("[-] failed to dump!\n");

	return 0;

}

DWORD WINAPI dump(LPVOID lpParameter)
{
	decrypt();
	return 0;

}

BOOL WINAPI DllMain( HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
	if (ul_reason_for_call == DLL_PROCESS_ATTACH)
	{
		CloseHandle(CreateThread(NULL, 0, dump, NULL, 0, NULL));

	}
	return TRUE;

}

```

`dumper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31702.278
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dumper", "dumper.vcxproj", "{557FB16C-C25A-474B-BC17-FF6303C4667C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Debug|x64.ActiveCfg = Debug|x64
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Debug|x64.Build.0 = Debug|x64
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Debug|x86.ActiveCfg = Debug|Win32
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Debug|x86.Build.0 = Debug|Win32
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Release|x64.ActiveCfg = Release|x64
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Release|x64.Build.0 = Release|x64
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Release|x86.ActiveCfg = Release|Win32
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {39468716-5ECC-4077-80D0-D8FB76EA97E9}
	EndGlobalSection
EndGlobal

```

`dumper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{557fb16c-c25a-474b-bc17-ff6303c4667c}</ProjectGuid>
    <RootNamespace>dumper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>F:\v_dumper\dumper;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>F:\v_dumper\dumper;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>F:\v_dumper\dumper;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>F:\v_dumper\dumper;F:\v_dumper\dumper\include;$(IncludePath)</IncludePath>
    <LibraryPath>$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;DUMPER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;DUMPER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;DUMPER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions); _CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;DUMPER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>MinSpace</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
      <UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\asm.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\cctypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\cmfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\cmtypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\dbgkfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\dbgktypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\exfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\extypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\halfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\haltypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ifssupp.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\inbvfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\inbvtypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\inline_ntcurrentteb.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\iofuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\iotypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\kbd.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\kdfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\kdtypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\kefuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ketypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ldrfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ldrtypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\lpcfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\lpctypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\mmfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\mmtypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\no_sal2.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ntdll.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ntndk.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ntnls.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ntstrsafe.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\obfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\obtypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\peb_teb.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\pofuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\potypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\psfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\pstypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\rtlfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\rtltypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\sefuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\setypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\umfuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\umtypes.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\vffuncs.h" />
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\vftypes.h" />
    <ClInclude Include="framework.h" />
    <ClInclude Include="func.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Text Include="..\..\physical_memory v4\Project1\ndk\dbgkfuncs_deprectated.txt" />
    <Text Include="..\..\physical_memory v4\Project1\ndk\gpl.txt" />
    <Text Include="..\..\physical_memory v4\Project1\ndk\lgpl.txt" />
    <Text Include="..\..\physical_memory v4\Project1\ndk\ndk.txt" />
    <Text Include="..\..\physical_memory v4\Project1\ndk\readme.txt" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\..\physical_memory v4\Project1\ndk\LICENSE" />
    <None Include="..\..\physical_memory v4\Project1\ndk\README.md" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`dumper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="ndk">
      <UniqueIdentifier>{fb8f8930-8137-4177-8749-0da8481b3c75}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="framework.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\asm.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\cctypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\cmfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\cmtypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\dbgkfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\dbgktypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\exfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\extypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\halfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\haltypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ifssupp.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\inbvfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\inbvtypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\inline_ntcurrentteb.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\iofuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\iotypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\kbd.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\kdfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\kdtypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\kefuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ketypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ldrfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ldrtypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\lpcfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\lpctypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\mmfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\mmtypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\no_sal2.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ntdll.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ntndk.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ntnls.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\ntstrsafe.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\obfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\obtypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\peb_teb.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\pofuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\potypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\psfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\pstypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\rtlfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\rtltypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\sefuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\setypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\umfuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\umtypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\vffuncs.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\physical_memory v4\Project1\ndk\vftypes.h">
      <Filter>ndk</Filter>
    </ClInclude>
    <ClInclude Include="func.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Text Include="..\..\physical_memory v4\Project1\ndk\dbgkfuncs_deprectated.txt">
      <Filter>ndk</Filter>
    </Text>
    <Text Include="..\..\physical_memory v4\Project1\ndk\gpl.txt">
      <Filter>ndk</Filter>
    </Text>
    <Text Include="..\..\physical_memory v4\Project1\ndk\lgpl.txt">
      <Filter>ndk</Filter>
    </Text>
    <Text Include="..\..\physical_memory v4\Project1\ndk\ndk.txt">
      <Filter>ndk</Filter>
    </Text>
    <Text Include="..\..\physical_memory v4\Project1\ndk\readme.txt">
      <Filter>ndk</Filter>
    </Text>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\..\physical_memory v4\Project1\ndk\LICENSE">
      <Filter>ndk</Filter>
    </None>
    <None Include="..\..\physical_memory v4\Project1\ndk\README.md">
      <Filter>ndk</Filter>
    </None>
  </ItemGroup>
</Project>
```

`dumper.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`framework.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files
#include <windows.h>

```

`func.h`:

```h
#pragma once

#include<Windows.h>

void PrintSingleCharacter(char c)
{
	DWORD written;
	WriteConsoleA(GetStdHandle(STD_OUTPUT_HANDLE), &c, 1, &written, NULL);

}

void PrintMessage(const char* fmt, ...)
{
	char buf[4096];
	va_list args;
	va_start(args, fmt);
	vsnprintf(buf, 4096, fmt, args);
	char* bufptr = buf;
	while (*bufptr)
	{
		if (*bufptr == '~')
		{
			++bufptr;
			SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), *bufptr);

		}
		else
		{
			PrintSingleCharacter(*bufptr);
		}
		++bufptr;

	}
	PrintSingleCharacter('\n');
	va_end(args);

}


bool write_file(const char* name, const void* data, size_t len)
{
	FILE* f = fopen(name, "wb");

	if (f == NULL)
	{
		PrintMessage("[-] error writing file");
		return false;

	}

	size_t r = fwrite(data, 1, len, f);

	if (r != len)
	{
		PrintMessage("[-] error writing file");
		return false;

	}
	fclose(f);
	return true;

}

uintptr_t find_pattern(const char* block, uint64_t startAddress, uint64_t size, const char* pattern, const char* mask, int offset)
{
	size_t pos = 0;
	auto maskLength = strlen(mask);

	for (int j = 0; j < size; j++)
	{
		if (block[j] == pattern[pos] || mask[pos] == '?')
		{
			if (mask[pos + 1] == '\0')
			{
				PrintMessage("[+] pattern scan succeeded!\n");
				return startAddress + j - maskLength + offset;

			}
			pos++;

		}
		else pos = 0;

	}
	PrintMessage("[-] pattern scan failed!\n");
	return 0;

}


```

`pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H

// add headers that you want to pre-compile here
#include "framework.h"

#endif //PCH_H

```

`pseh-common.h`:

```h
#pragma once
/*
	Copyright (c) 2009, 2010 KJK::Hyperion
	Permission is hereby granted, free of charge, to any person obtaining a
	copy of this software and associated documentation files (the "Software"),
	to deal in the Software without restriction, including without limitation
	the rights to use, copy, modify, merge, publish, distribute, sublicense,
	and/or sell copies of the Software, and to permit persons to whom the
	Software is furnished to do so, subject to the following conditions:
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.
*/

#ifndef KJK_PSEH2_COMMON_H_
#define KJK_PSEH2_COMMON_H_

struct _EXCEPTION_RECORD;
struct _EXCEPTION_POINTERS;
struct _CONTEXT;

typedef int(__cdecl* _SEH2FrameHandler_t)
(
	struct _EXCEPTION_RECORD*,
	void*,
	struct _CONTEXT*,
	void*
	);

typedef struct __SEH2Registration
{
	struct __SEH2Registration* SER_Prev;
	_SEH2FrameHandler_t SER_Handler;
}
_SEH2Registration_t;

typedef struct __SEH2Frame
{
	_SEH2Registration_t SF_Registration;
	volatile struct __SEH2TryLevel* volatile SF_TopTryLevel;
	volatile unsigned long SF_Code;
}
_SEH2Frame_t;

typedef struct __SEH2TryLevel
{
	volatile struct __SEH2TryLevel* ST_Next;
	void* ST_Filter;
	void* ST_Body;
}
_SEH2TryLevel_t;

typedef struct __SEH2HandleTryLevel
{
	_SEH2TryLevel_t  SHT_Common;
	void* volatile SHT_Esp;
	void* volatile SHT_Ebp;
	void* volatile SHT_Ebx;
	void* volatile SHT_Esi;
	void* volatile SHT_Edi;
}
_SEH2HandleTryLevel_t;

#ifdef __cplusplus
extern "C"
{
#endif

	extern int __cdecl _SEH2EnterFrameAndTrylevel(_SEH2Frame_t*, volatile _SEH2TryLevel_t*);
	//extern __attribute__((returns_twice)) int __cdecl _SEH2EnterFrameAndHandleTrylevel(_SEH2Frame_t*, volatile _SEH2HandleTryLevel_t*, void*);
	//extern __attribute__((returns_twice)) int __cdecl _SEH2EnterHandleTrylevel(_SEH2Frame_t*, volatile _SEH2HandleTryLevel_t*, void*);
	extern void __cdecl _SEH2LeaveFrame(void);
	extern void __cdecl _SEH2Return(void);

#ifdef __cplusplus
}
#endif

#define __SEH_EXCEPT_RET long

#endif

/* EOF */

```

`pseh2.h`:

```h
#pragma once
/*
	Copyright (c) 2008 KJK::Hyperion
	Permission is hereby granted, free of charge, to any person obtaining a
	copy of this software and associated documentation files (the "Software"),
	to deal in the Software without restriction, including without limitation
	the rights to use, copy, modify, merge, publish, distribute, sublicense,
	and/or sell copies of the Software, and to permit persons to whom the
	Software is furnished to do so, subject to the following conditions:
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.
*/

#ifndef KJK_PSEH2_H_
#define KJK_PSEH2_H_

#if !defined (__arm__)

#include "pseh-common.h"

#if defined(__GNUC__)

/* A no-op side effect that scares GCC */
#define __SEH_SIDE_EFFECT __asm__ __volatile__("#")

/* A no-op without any real side effects, but silences warnings */
#define __SEH_PRETEND_SIDE_EFFECT (void)0

/* Forces GCC to consider the specified label reachable */
#define __SEH_USE_LABEL(L_) if(__SEH_VOLATILE_FALSE) goto L_;

/* Makes GCC pretend the specified label is reachable, to silence warnings */
#define __SEH_PRETEND_USE_LABEL(L_) (void)(&&L_)

/* Soft memory barrier */
#define __SEH_BARRIER __asm__ __volatile__("#":::"memory")

/* GCC doesn't know that this equals zero */
#define __SEH_VOLATILE_ZERO ({ int zero = 0; __asm__ __volatile__("#" : "+g" (zero)); zero; })

#define __SEH_VOLATILE_FALSE __builtin_expect(__SEH_VOLATILE_ZERO, 0)
#define __SEH_VOLATILE_TRUE  __builtin_expect(!__SEH_VOLATILE_ZERO, 1)

#define ___SEH_STRINGIFY(X_) # X_
#define __SEH_STRINGIFY(X_) ___SEH_STRINGIFY(X_)

#define __SEH_EXCEPT_ARGS __attribute__((unused)) _SEH2Frame_t * _SEH2FrameP, __attribute__((unused)) struct _EXCEPTION_POINTERS * _SEHExceptionInformation
#define __SEH_EXCEPT_ARGS_ , __SEH_EXCEPT_ARGS
#define __SEH_EXCEPT_PFN __SEH_DECLARE_EXCEPT_PFN
#define __SEH_DECLARE_EXCEPT_PFN(NAME_) __SEH_EXCEPT_RET (__cdecl * NAME_)(__SEH_EXCEPT_ARGS)
#define __SEH_DECLARE_EXCEPT(NAME_) __SEH_EXCEPT_RET __cdecl NAME_(__SEH_EXCEPT_ARGS)
#define __SEH_DEFINE_EXCEPT(NAME_) __SEH_EXCEPT_RET __cdecl NAME_(__SEH_EXCEPT_ARGS)

#define __SEH_FINALLY_RET void
#define __SEH_FINALLY_ARGS void
#define __SEH_FINALLY_ARGS_
#define __SEH_FINALLY_PFN __SEH_DECLARE_FINALLY_PFN
#define __SEH_DECLARE_FINALLY_PFN(NAME_) __SEH_FINALLY_RET (__cdecl * NAME_)(__SEH_FINALLY_ARGS)
#define __SEH_DECLARE_FINALLY(NAME_) __SEH_FINALLY_RET __cdecl NAME_(__SEH_FINALLY_ARGS)
#define __SEH_DEFINE_FINALLY(NAME_) __SEH_FINALLY_RET __cdecl NAME_(__SEH_FINALLY_ARGS)

#define __SEH_RETURN_EXCEPT(R_) return (long)(R_)
#define __SEH_RETURN_FINALLY() return

#define __SEH_BEGIN_TRY \
	{ \
		__label__ _SEHEndTry; \
 \
		__SEH_PRETEND_USE_LABEL(_SEHEndTry); \
 \
		{ \
			__SEH_BARRIER;

#define __SEH_END_TRY \
			__SEH_BARRIER; \
		} \
		_SEHEndTry:; \
	}

#define __SEH_SET_TRYLEVEL(TRYLEVEL_) \
	{ \
		__SEH_BARRIER; _SEH2FrameP->SF_TopTryLevel = (TRYLEVEL_); __SEH_BARRIER; \
	}

#define __SEH_ENTER_FRAME_AND_TRYLEVEL(TRYLEVEL_) (_SEH2EnterFrameAndTrylevel(_SEH2FrameP, (TRYLEVEL_)))
#define __SEH_ENTER_TRYLEVEL(TRYLEVEL_) ((__SEH_SET_TRYLEVEL((TRYLEVEL_))), 0)

#define __SEH_ENTER_FRAME_AND_HANDLE_TRYLEVEL(TRYLEVEL_, HANDLE_) _SEH2EnterFrameAndHandleTrylevel(_SEH2FrameP, (TRYLEVEL_), (HANDLE_))
#define __SEH_ENTER_HANDLE_TRYLEVEL(TRYLEVEL_, HANDLE_) _SEH2EnterHandleTrylevel(_SEH2FrameP, (TRYLEVEL_), (HANDLE_))

#define __SEH_ENTER_SCOPE(TRYLEVEL_) (_SEHTopTryLevel ? __SEH_ENTER_FRAME_AND_TRYLEVEL(TRYLEVEL_) : __SEH_ENTER_TRYLEVEL(TRYLEVEL_))
#define __SEH_ENTER_HANDLE_SCOPE(TRYLEVEL_, HANDLE_) (({ __SEH_BARRIER; __asm__ __volatile__("mov %%esp, %0" : "=m" ((TRYLEVEL_)->SHT_Esp)); __SEH_BARRIER; }), (_SEHTopTryLevel ? __SEH_ENTER_FRAME_AND_HANDLE_TRYLEVEL((TRYLEVEL_), (HANDLE_)) : __SEH_ENTER_HANDLE_TRYLEVEL((TRYLEVEL_), (HANDLE_))))

#define __SEH_LEAVE_TRYLEVEL() \
	if(!_SEHTopTryLevel) \
	{ \
		__SEH_SET_TRYLEVEL(_SEHPrevTryLevelP); \
	} \

#define __SEH_LEAVE_FRAME() \
	if(_SEHTopTryLevel) \
	{ \
		_SEH2LeaveFrame(); \
		__asm__ __volatile__("mov %0, %%esp" : : "g" (_SEHStackPointer)); \
	}

#define __SEH_END_SCOPE_CHAIN \
	static __attribute__((unused)) const int _SEH2ScopeKind = 1; \
	static __attribute__((unused)) _SEH2Frame_t * const _SEH2FrameP = 0; \
	static __attribute__((unused)) _SEH2TryLevel_t * const _SEH2TryLevelP = 0;

#define __SEH_BEGIN_SCOPE \
	for(;;) \
	{ \
		const int _SEHTopTryLevel = (_SEH2ScopeKind != 0); \
		_SEH2Frame_t * const _SEHCurFrameP = _SEH2FrameP; \
		volatile _SEH2TryLevel_t * const _SEHPrevTryLevelP = _SEH2TryLevelP; \
		__attribute__((unused)) int _SEHAbnormalTermination; \
 \
        (void)_SEHTopTryLevel; \
        (void)_SEHCurFrameP; \
        (void)_SEHPrevTryLevelP; \
 \
		{ \
			__label__ _SEHBeforeTry; \
			__label__ _SEHDoTry; \
			__label__ _SEHAfterTry; \
			static const int _SEH2ScopeKind = 0; \
			volatile _SEH2TryLevel_t _SEHTryLevel; \
			volatile _SEH2HandleTryLevel_t _SEHHandleTryLevel; \
			void * _SEHStackPointer; \
			volatile _SEH2TryLevel_t * _SEH2TryLevelP; \
			_SEH2Frame_t * const _SEH2FrameP = _SEHTopTryLevel ? \
				({ __asm__ __volatile__("mov %%esp, %0" : "=g" (_SEHStackPointer)); __builtin_alloca(sizeof(_SEH2Frame_t)); }) : \
				_SEHCurFrameP; \
 \
			(void)_SEH2ScopeKind; \
			(void)_SEHTryLevel; \
			(void)_SEHHandleTryLevel; \
			(void)_SEHStackPointer; \
			(void)_SEH2FrameP; \
			(void)_SEH2TryLevelP; \
 \
			goto _SEHBeforeTry; \
 \
			_SEHDoTry:;

#define __SEH_END_SCOPE \
		} \
 \
		break; \
	}

#define __SEH_SCOPE_LOCALS \
	__label__ _SEHBeginExcept; \
	__label__ _SEHEndExcept; \
 \
	auto __SEH_DECLARE_FINALLY(_SEHFinally);

#define _SEH2_TRY \
	__SEH_BEGIN_SCOPE \
	{ \
		__SEH_SCOPE_LOCALS; \
 \
		__SEH_BEGIN_TRY \
		{

#define _SEH2_FINALLY \
		} \
		__SEH_END_TRY; \
 \
		goto _SEHAfterTry; \
		_SEHBeforeTry:; \
 \
		__SEH_PRETEND_USE_LABEL(_SEHBeginExcept); \
		__SEH_PRETEND_USE_LABEL(_SEHEndExcept); \
 \
		_SEHTryLevel.ST_Filter = 0; \
		_SEHTryLevel.ST_Body = &_SEHFinally; \
		_SEHTryLevel.ST_Next = _SEHPrevTryLevelP; \
		__SEH_ENTER_SCOPE(&_SEHTryLevel); \
		_SEH2TryLevelP = &_SEHTryLevel; \
 \
		_SEHAbnormalTermination = 1; \
 \
		goto _SEHDoTry; \
		_SEHAfterTry:; \
 \
		_SEHAbnormalTermination = 0; \
 \
		__SEH_LEAVE_TRYLEVEL(); \
 \
		_SEHFinally(); \
		goto _SEHEndExcept; \
 \
		_SEHBeginExcept:; \
 \
		__attribute__((noinline)) __SEH_DEFINE_FINALLY(_SEHFinally) \
		{ \
			__SEH_END_SCOPE_CHAIN \
 \
			(void)_SEH2ScopeKind; \
			(void)_SEH2FrameP; \
			(void)_SEH2TryLevelP; \
 \
 			for(;; ({ __SEH_RETURN_FINALLY(); })) \
			{

#define _SEH2_EXCEPT(FILTER_...) \
		} \
		__SEH_END_TRY; \
 \
		goto _SEHAfterTry; \
 \
		_SEHBeforeTry:; \
 \
		{ \
			__attribute__((unused)) struct _EXCEPTION_POINTERS * volatile _SEHExceptionInformation; \
 \
			if(__builtin_constant_p((FILTER_)) && (FILTER_) <= 0) \
			{ \
				if((FILTER_) < 0) \
				{ \
					_SEHTryLevel.ST_Filter = (void *)-1; \
					_SEHTryLevel.ST_Body = 0; \
				} \
				else \
				{ \
					_SEHTryLevel.ST_Filter = (void *)0; \
					_SEHTryLevel.ST_Body = 0; \
				} \
 \
				_SEHTryLevel.ST_Next = _SEHPrevTryLevelP; \
				__SEH_ENTER_SCOPE(&_SEHTryLevel); \
				_SEH2TryLevelP = &_SEHTryLevel; \
			} \
			else \
			{ \
				if(__builtin_constant_p((FILTER_)) && (FILTER_) > 0) \
					_SEHHandleTryLevel.SHT_Common.ST_Filter = (void *)1; \
				else \
				{ \
					__SEH_DEFINE_EXCEPT(_SEHExcept) \
					{ \
						__SEH_RETURN_EXCEPT((FILTER_)); \
					} \
 \
					_SEHHandleTryLevel.SHT_Common.ST_Filter = &_SEHExcept; \
				} \
 \
				_SEHHandleTryLevel.SHT_Common.ST_Next = _SEHPrevTryLevelP; \
				_SEH2TryLevelP = &_SEHHandleTryLevel.SHT_Common; \
 \
				if(__builtin_expect(__SEH_ENTER_HANDLE_SCOPE(&_SEHHandleTryLevel, &&_SEHBeginExcept), 0)) \
					goto _SEHBeginExcept; \
			} \
		} \
 \
		goto _SEHDoTry; \
 \
		__attribute__((unused)) __SEH_DEFINE_FINALLY(_SEHFinally) { __SEH_RETURN_FINALLY(); } \
 \
		_SEHAfterTry:; \
		__SEH_LEAVE_TRYLEVEL(); \
 \
		goto _SEHEndExcept; \
 \
		_SEHBeginExcept:; \
		{ \
			{ \
				__SEH_BARRIER;

#define _SEH2_END \
				__SEH_BARRIER; \
			} \
		} \
 \
		_SEHEndExcept:; \
 \
		__SEH_LEAVE_FRAME(); \
	} \
	__SEH_END_SCOPE;

#define _SEH2_GetExceptionInformation() (_SEHExceptionInformation)
#define _SEH2_GetExceptionCode() ((_SEH2FrameP)->SF_Code)
#define _SEH2_AbnormalTermination() (_SEHAbnormalTermination)

#define _SEH2_YIELD(STMT_) \
	for(;;) \
	{ \
		if(!_SEH2ScopeKind) \
			_SEH2Return(); \
 \
		STMT_; \
	}

#define _SEH2_LEAVE goto _SEHEndTry

__SEH_END_SCOPE_CHAIN

#else

#include <excpt.h>

#define _SEH2_TRY __try {
#define _SEH2_FINALLY } __finally {
#define _SEH2_EXCEPT(...) } __except(__VA_ARGS__) {
#define _SEH2_END }

#define _SEH2_GetExceptionInformation() (GetExceptionInformation())
#define _SEH2_GetExceptionCode() (GetExceptionCode())
#define _SEH2_AbnormalTermination() (AbnormalTermination())

#define _SEH2_YIELD(STMT_) STMT_
#define _SEH2_LEAVE __leave

#endif

#else

#define _SEH2_TRY  {
#define _SEH2_FINALLY }  {
#define _SEH2_EXCEPT(...) } if (0) {
#define _SEH2_END }

#define _SEH2_GetExceptionInformation()
#define _SEH2_GetExceptionCode() STATUS_SUCCESS
#define _SEH2_AbnormalTermination()

#define _SEH2_YIELD(STMT_) STMT_
#define _SEH2_LEAVE

#endif

#endif

/* EOF */

```

`rtl.h`:

```h
#pragma once
#include <stdlib.h>
#include <stdio.h>
#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#include <objbase.h>
#include <intsafe.h>

#include <synchapi.h>
#include <heapapi.h>

//#include <ndk/exfuncs.h>
#include <ndk/iofuncs.h>
#include <ndk/kefuncs.h>
#include <ndk/ldrfuncs.h>
#include <ndk/mmfuncs.h>
#include <ndk/obfuncs.h>
#include <ndk/psfuncs.h>
#include <ndk/rtlfuncs.h>
#include <ndk/setypes.h>
#include <ndk/sefuncs.h>
#include <ndk/umfuncs.h>
#include "pseh2.h"

#pragma once
#ifndef _NTINTSAFE_H_INCLUDED_
#define _NTINTSAFE_H_INCLUDED_

/* Include the sdk version */
#include <intsafe.h>

/* We don't want this one */
#undef _INTSAFE_H_INCLUDED_

#endif // !_NTINTSAFE_H_INCLUDED_

#ifdef _PPC_
#define SWAPD(x) ((((x)&0xff)<<24)|(((x)&0xff00)<<8)|(((x)>>8)&0xff00)|(((x)>>24)&0xff))
#define SWAPW(x) ((((x)&0xff)<<8)|(((x)>>8)&0xff))
#define SWAPQ(x) ((SWAPD((x)&0xffffffff) << 32) | (SWAPD((x)>>32)))
#else
#define SWAPD(x) (x)
#define SWAPW(x) (x)
#define SWAPQ(x) (x)
#endif

#define ROUND_DOWN(n, align) \
     (((ULONG_PTR)(n)) & ~((align) - 1l))

#define ROUND_UP(n, align) \
     ROUND_DOWN(((ULONG_PTR)(n)) + (align) - 1, (align))

#define RVA(m, b) ((VOID*)((ULONG_PTR)(b) + (ULONG_PTR)(m)))

extern VOID* MmHighestUserAddress;

NTSTATUS
NTAPI
RtlpSafeCopyMemory(
    _Out_writes_bytes_all_(Length) VOID UNALIGNED* Destination,
    _In_reads_bytes_(Length) CONST VOID UNALIGNED* Source,
    _In_ SIZE_T Length);

VOID
NTAPI
RtlpGetStackLimits(PULONG_PTR LowLimit,
    PULONG_PTR HighLimit);

PEXCEPTION_REGISTRATION_RECORD
NTAPI
RtlpGetExceptionList(VOID);

VOID
NTAPI
RtlpSetHeapParameters(IN PRTL_HEAP_PARAMETERS Parameters);

VOID
NTAPI
RtlpSetExceptionList(PEXCEPTION_REGISTRATION_RECORD NewExceptionList);

BOOL
NTAPI
RtlCallVectoredExceptionHandlers(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT Context
);

VOID
NTAPI
RtlCallVectoredContinueHandlers(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT Context
);

#ifdef _M_IX86
typedef struct _DISPATCHER_CONTEXT
{
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
} DISPATCHER_CONTEXT, * PDISPATCHER_CONTEXT;
#endif

/* These provide support for sharing code between User and Kernel RTL */
VOID*
NTAPI
RtlpAllocateMemory(
    SIZE_T Bytes,
    ULONG Tag);

VOID
NTAPI
RtlpFreeMemory(
    VOID* Mem,
    ULONG Tag);

KPROCESSOR_MODE
NTAPI
RtlpGetMode(VOID);

BOOL
NTAPI
RtlpCaptureStackLimits(
    IN ULONG_PTR Ebp,
    IN ULONG_PTR* StackBegin,
    IN ULONG_PTR* StackEnd
);

NTSTATUS
NTAPI
RtlDeleteHeapLock(IN OUT PHEAP_LOCK Lock);

NTSTATUS
NTAPI
RtlEnterHeapLock(IN OUT PHEAP_LOCK Lock, IN BOOL Exclusive);

BOOL
NTAPI
RtlTryEnterHeapLock(IN OUT PHEAP_LOCK Lock, IN BOOL Exclusive);

NTSTATUS
NTAPI
RtlInitializeHeapLock(IN OUT PHEAP_LOCK* Lock);

NTSTATUS
NTAPI
RtlLeaveHeapLock(IN OUT PHEAP_LOCK Lock);

BOOL
NTAPI
RtlpCheckForActiveDebugger(VOID);

BOOL
NTAPI
RtlpHandleDpcStackException(IN PEXCEPTION_REGISTRATION_RECORD RegistrationFrame,
    IN ULONG_PTR RegistrationFrameEnd,
    IN OUT PULONG_PTR StackLow,
    IN OUT PULONG_PTR StackHigh);

#define RtlpAllocateStringMemory RtlpAllocateMemory
#define RtlpFreeStringMemory     RtlpFreeMemory

ULONG
NTAPI
RtlGetTickCount(VOID);
#define NtGetTickCount RtlGetTickCount

BOOL
NTAPI
RtlpSetInDbgPrint(
    VOID
);

VOID
NTAPI
RtlpClearInDbgPrint(
    VOID
);

/* i386/except.S */

#ifdef _M_IX86
EXCEPTION_DISPOSITION
NTAPI
RtlpExecuteHandlerForException(PEXCEPTION_RECORD ExceptionRecord,
    PEXCEPTION_REGISTRATION_RECORD RegistrationFrame,
    PCONTEXT Context,
    VOID* DispatcherContext,
    PEXCEPTION_ROUTINE ExceptionHandler);
#endif

EXCEPTION_DISPOSITION
NTAPI
RtlpExecuteHandlerForUnwind(PEXCEPTION_RECORD ExceptionRecord,
    PEXCEPTION_REGISTRATION_RECORD RegistrationFrame,
    PCONTEXT Context,
    VOID* DispatcherContext,
    PEXCEPTION_ROUTINE ExceptionHandler);

VOID
NTAPI
RtlpCheckLogException(IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN VOID* ContextData,
    IN ULONG Size);

VOID
NTAPI
RtlpCaptureContext(OUT PCONTEXT ContextRecord);

//
// Debug Service calls
//
ULONG
NTAPI
DebugService(
    IN ULONG Service,
    IN VOID* Argument1,
    IN VOID* Argument2,
    IN VOID* Argument3,
    IN VOID* Argument4
);

VOID
NTAPI
DebugService2(
    IN VOID* Argument1,
    IN VOID* Argument2,
    IN ULONG Service
);

/* Tags for the String Allocators */
#define TAG_USTR        'RTSU'
#define TAG_ASTR        'RTSA'
#define TAG_OSTR        'RTSO'

/* Timer Queue */

extern HANDLE TimerThreadHandle;

NTSTATUS
RtlpInitializeTimerThread(VOID);

/* bitmap64.c */
typedef struct _RTL_BITMAP64
{
    ULONG64 SizeOfBitMap;
    PULONG64 Buffer;
} RTL_BITMAP64, * PRTL_BITMAP64;

typedef struct _RTL_BITMAP_RUN64
{
    ULONG64 StartingIndex;
    ULONG64 NumberOfBits;
} RTL_BITMAP_RUN64, * PRTL_BITMAP_RUN64;

/* nls.c */
WCHAR
NTAPI
RtlpUpcaseUnicodeChar(IN WCHAR Source);

WCHAR
NTAPI
RtlpDowncaseUnicodeChar(IN WCHAR Source);

/* ReactOS only */
VOID
NTAPI
LdrpInitializeProcessCompat(VOID* pProcessActctx, VOID** pOldShimData);

VOID*
NTAPI
RtlpDebugBufferCommit(_Inout_ PRTL_DEBUG_INFORMATION Buffer,
    _In_ SIZE_T Size);


/* EOF */

```

`vectorhandler.h`:

```h
#pragma once
#include <Windows.h>

template <class T>
static inline uintptr_t calculate_relative(std::uintptr_t start, std::uint8_t sz, std::uint8_t off)
{
    return (start + sz + *reinterpret_cast<T*>(start + off));

}

PVOID(_stdcall* NtQueryProcess)
(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL

);

DWORD process_cookie()
{
    DWORD cookie = 0;
    DWORD return_length = 0;

    HMODULE ntdll = GetModuleHandleA("ntdll.dll");

    *(PVOID*)&NtQueryProcess = GetProcAddress(ntdll, "NtQueryInformationProcess"); 
    
    NtQueryProcess(GetModuleHandle(NULL), (PROCESSINFOCLASS)0x24, &cookie, sizeof(cookie), &return_length);

    return cookie;

}

#define ROR(x, y) ((unsigned)(x) >> (y) | (unsigned)(x) << 32 - (y))
DWORD decode_pointer(DWORD pointer) 
{
    static ULONG fprocess_cookie = 0;
    if (!fprocess_cookie) 
    {
        fprocess_cookie = process_cookie();
        if (!fprocess_cookie) 
        {
            return 0;

        }

    }
    unsigned char shift_size = 0x20 - (fprocess_cookie & 0x1f);
    return ROR(pointer, shift_size) ^ fprocess_cookie;

}

DWORD get_veh_offset()
{
    HMODULE ntdll = LoadLibrary("ntdll.dll");


}

```