Project Path: arc_gmh5225_compact_vm_detector_e23pc01w

Source Tree:

```txt
arc_gmh5225_compact_vm_detector_e23pc01w
├── InstructionSet_MS.cpp
├── InstructionSet_MS.hpp
├── LICENSE
├── README.md
├── VMDetect.cpp
├── VMDetect.hpp
└── main.cpp

```

`InstructionSet_MS.cpp`:

```cpp
#include "InstructionSet_MS.hpp"

InstructionSet::InstructionSet_Internal::InstructionSet_Internal()
    : nIds_{ 0 },
    nExIds_{ 0 },
    isIntel_{ false },
    isAMD_{ false },
    f_1_ECX_{ 0 },
    f_1_EDX_{ 0 },
    f_7_EBX_{ 0 },
    f_7_ECX_{ 0 },
    f_81_ECX_{ 0 },
    f_81_EDX_{ 0 },
    data_{},
    extdata_{}
{
    //int cpuInfo[4] = {-1};
    std::array<int, 4> cpui;

    // Calling __cpuid with 0x0 as the function_id argument
    // gets the number of the highest valid function ID.
    __cpuid(cpui.data(), 0);
    nIds_ = cpui[0];

    for (int i = 0; i <= nIds_; ++i)
    {
        __cpuidex(cpui.data(), i, 0);
        data_.push_back(cpui);
    }

    // Capture vendor string
    char vendor[0x20];
    memset(vendor, 0, sizeof(vendor));
    *reinterpret_cast<int*>(vendor) = data_[0][1];
    *reinterpret_cast<int*>(vendor + 4) = data_[0][3];
    *reinterpret_cast<int*>(vendor + 8) = data_[0][2];
    vendor_ = vendor;
    if (vendor_ == "GenuineIntel")
    {
        isIntel_ = true;
    }
    else if (vendor_ == "AuthenticAMD")
    {
        isAMD_ = true;
    }

    // load bitset with flags for function 0x00000001
    if (nIds_ >= 1)
    {
        f_1_ECX_ = data_[1][2];
        f_1_EDX_ = data_[1][3];
    }

    // load bitset with flags for function 0x00000007
    if (nIds_ >= 7)
    {
        f_7_EBX_ = data_[7][1];
        f_7_ECX_ = data_[7][2];
    }

    // Calling __cpuid with 0x80000000 as the function_id argument
    // gets the number of the highest valid extended ID.
    __cpuid(cpui.data(), 0x80000000);
    nExIds_ = cpui[0];

    char brand[0x40];
    memset(brand, 0, sizeof(brand));

    for (int i = 0x80000000; i <= nExIds_; ++i)
    {
        __cpuidex(cpui.data(), i, 0);
        extdata_.push_back(cpui);
    }

    // load bitset with flags for function 0x80000001
    if (nExIds_ >= 0x80000001)
    {
        f_81_ECX_ = extdata_[1][2];
        f_81_EDX_ = extdata_[1][3];
    }

    // Interpret CPU brand string if reported
    if (nExIds_ >= 0x80000004)
    {
        memcpy(brand, extdata_[2].data(), sizeof(cpui));
        memcpy(brand + 16, extdata_[3].data(), sizeof(cpui));
        memcpy(brand + 32, extdata_[4].data(), sizeof(cpui));
        brand_ = brand;
    }
};
```

`InstructionSet_MS.hpp`:

```hpp
#pragma once

#include <iostream>
#include <vector>
#include <bitset>
#include <array>
#include <string>
#include <intrin.h>

class InstructionSet
{
    // forward declarations
    class InstructionSet_Internal;

public:
    // getters
    static std::string Vendor(void) { return CPU_Rep.vendor_; }
    static std::string Brand(void) { return CPU_Rep.brand_; }

    static bool SSE3(void) { return CPU_Rep.f_1_ECX_[0]; }
    static bool PCLMULQDQ(void) { return CPU_Rep.f_1_ECX_[1]; }
    static bool MONITOR(void) { return CPU_Rep.f_1_ECX_[3]; }
    static bool SSSE3(void) { return CPU_Rep.f_1_ECX_[9]; }
    static bool FMA(void) { return CPU_Rep.f_1_ECX_[12]; }
    static bool CMPXCHG16B(void) { return CPU_Rep.f_1_ECX_[13]; }
    static bool SSE41(void) { return CPU_Rep.f_1_ECX_[19]; }
    static bool SSE42(void) { return CPU_Rep.f_1_ECX_[20]; }
    static bool MOVBE(void) { return CPU_Rep.f_1_ECX_[22]; }
    static bool POPCNT(void) { return CPU_Rep.f_1_ECX_[23]; }
    static bool AES(void) { return CPU_Rep.f_1_ECX_[25]; }
    static bool XSAVE(void) { return CPU_Rep.f_1_ECX_[26]; }
    static bool OSXSAVE(void) { return CPU_Rep.f_1_ECX_[27]; }
    static bool AVX(void) { return CPU_Rep.f_1_ECX_[28]; }
    static bool F16C(void) { return CPU_Rep.f_1_ECX_[29]; }
    static bool RDRAND(void) { return CPU_Rep.f_1_ECX_[30]; }

    static bool MSR(void) { return CPU_Rep.f_1_EDX_[5]; }
    static bool CX8(void) { return CPU_Rep.f_1_EDX_[8]; }
    static bool SEP(void) { return CPU_Rep.f_1_EDX_[11]; }
    static bool CMOV(void) { return CPU_Rep.f_1_EDX_[15]; }
    static bool CLFSH(void) { return CPU_Rep.f_1_EDX_[19]; }
    static bool MMX(void) { return CPU_Rep.f_1_EDX_[23]; }
    static bool FXSR(void) { return CPU_Rep.f_1_EDX_[24]; }
    static bool SSE(void) { return CPU_Rep.f_1_EDX_[25]; }
    static bool SSE2(void) { return CPU_Rep.f_1_EDX_[26]; }

    static bool FSGSBASE(void) { return CPU_Rep.f_7_EBX_[0]; }
    static bool BMI1(void) { return CPU_Rep.f_7_EBX_[3]; }
    static bool HLE(void) { return CPU_Rep.isIntel_ && CPU_Rep.f_7_EBX_[4]; }
    static bool AVX2(void) { return CPU_Rep.f_7_EBX_[5]; }
    static bool BMI2(void) { return CPU_Rep.f_7_EBX_[8]; }
    static bool ERMS(void) { return CPU_Rep.f_7_EBX_[9]; }
    static bool INVPCID(void) { return CPU_Rep.f_7_EBX_[10]; }
    static bool RTM(void) { return CPU_Rep.isIntel_ && CPU_Rep.f_7_EBX_[11]; }
    static bool AVX512F(void) { return CPU_Rep.f_7_EBX_[16]; }
    static bool RDSEED(void) { return CPU_Rep.f_7_EBX_[18]; }
    static bool ADX(void) { return CPU_Rep.f_7_EBX_[19]; }
    static bool AVX512PF(void) { return CPU_Rep.f_7_EBX_[26]; }
    static bool AVX512ER(void) { return CPU_Rep.f_7_EBX_[27]; }
    static bool AVX512CD(void) { return CPU_Rep.f_7_EBX_[28]; }
    static bool SHA(void) { return CPU_Rep.f_7_EBX_[29]; }

    static bool PREFETCHWT1(void) { return CPU_Rep.f_7_ECX_[0]; }

    static bool LAHF(void) { return CPU_Rep.f_81_ECX_[0]; }
    static bool LZCNT(void) { return CPU_Rep.isIntel_ && CPU_Rep.f_81_ECX_[5]; }
    static bool ABM(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_ECX_[5]; }
    static bool SSE4a(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_ECX_[6]; }
    static bool XOP(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_ECX_[11]; }
    static bool TBM(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_ECX_[21]; }

    static bool SYSCALL(void) { return CPU_Rep.isIntel_ && CPU_Rep.f_81_EDX_[11]; }
    static bool MMXEXT(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_EDX_[22]; }
    static bool RDTSCP(void) { return CPU_Rep.isIntel_ && CPU_Rep.f_81_EDX_[27]; }
    static bool _3DNOWEXT(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_EDX_[30]; }
    static bool _3DNOW(void) { return CPU_Rep.isAMD_ && CPU_Rep.f_81_EDX_[31]; }

private:
    static const InstructionSet_Internal CPU_Rep;

    class InstructionSet_Internal
    {
    public:

        InstructionSet_Internal();

        int nIds_;
        int nExIds_;
        std::string vendor_;
        std::string brand_;
        bool isIntel_;
        bool isAMD_;
        std::bitset<32> f_1_ECX_;
        std::bitset<32> f_1_EDX_;
        std::bitset<32> f_7_EBX_;
        std::bitset<32> f_7_ECX_;
        std::bitset<32> f_81_ECX_;
        std::bitset<32> f_81_EDX_;
        std::vector<std::array<int, 4>> data_;
        std::vector<std::array<int, 4>> extdata_;
    };
};

```

`LICENSE`:

```
Copyright 2020 Luke Goule

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`README.md`:

```md
# compact_vm_detector
Smaller version of [pafish](https://github.com/a0rtega/pafish) designed to be embedded into other Windows C++ apps.
This will obviously not be nearly as effective as pafish if you're looking to research malware techniques (and hopefully not write your own malware!), so I'd recommend checking out the pafish source for a more in depth look at virtualisation detection. Pafish is written in Linux style C meaning it will not be able to compile using VC++ on Windows, you will need MinGW.

# Screenshot
Running on a Windows 10 VM using Oracle VM VirtualBox
![](https://i.imgur.com/EXiRNfH.png)

```

`VMDetect.cpp`:

```cpp
#include "VMDetect.hpp"
#include "InstructionSet_MS.hpp"


#if _WIN32 && !(_WIN64)
// Inline assembly for possible quicker execution.
DWORD64 VMDetect::CalcRDTSCDifference()
{
	unsigned long long cycles_one, cycles_two;
	unsigned cycles_high, cycles_low;

	__asm
	{
		RDTSC
		MOV cycles_high, eax
		MOV cycles_low, edx
	}

	cycles_one = ((unsigned long long)cycles_high) | (((unsigned long long)cycles_low) << 32);

	__asm
	{
		RDTSC
		MOV cycles_high, eax
		MOV cycles_low, edx
	}

	cycles_two = ((unsigned long long)cycles_high) | (((unsigned long long)cycles_low) << 32);

	return cycles_two - cycles_one;
}
#endif

#if _WIN64

// Inline assembly is not available when compiling using 64 bit.
DWORD64 VMDetect::CalcRDTSCDifference()
{
	DWORD64 dwCyclesFirst = ReadTimeStampCounter();
	DWORD64 dwCyclesSecond = ReadTimeStampCounter();

	return dwCyclesSecond - dwCyclesFirst;
}

#endif
BOOLEAN VMDetect::CheckRTDSCTimings(VOID)
{
	unsigned long long i = 0, average = 0;

	for (; i < 10; i++)
	{
		average += CalcRDTSCDifference();
		Sleep(500);
	}

	average /= i;

	return (average < 750 && average > 0) ? FALSE : TRUE;
}

BOOLEAN VMDetect::CheckCPUIDLeafResponse(VOID)
{
	unsigned int invalid_leaf = 0x13371337;
	unsigned int valid_leaf = 0x40000000;

	struct _HV_DETAILS
	{
		unsigned int Data[4];
	};

	_HV_DETAILS InvalidLeafResponse = { 0 };
	_HV_DETAILS ValidLeafResponse = { 0 };

	__cpuid((int*)&InvalidLeafResponse, invalid_leaf);
	__cpuid((int*)&ValidLeafResponse, valid_leaf);

	if ((InvalidLeafResponse.Data[0] != ValidLeafResponse.Data[0]) ||
		(InvalidLeafResponse.Data[1] != ValidLeafResponse.Data[1]) ||
		(InvalidLeafResponse.Data[2] != ValidLeafResponse.Data[2]) ||
		(InvalidLeafResponse.Data[3] != ValidLeafResponse.Data[3]))
		return TRUE;

	return FALSE;
}

BOOLEAN VMDetect::CheckSyntheticMSRs(VOID)
{
	__try
	{
		__readmsr(HV_SYNTHETIC_MSR_RANGE_START);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		return FALSE;
	}

	return TRUE;
}

BOOLEAN VMDetect::FileExists(std::string FileName)
{
	std::fstream FileToTest(FileName);
	if (FileToTest.is_open())
	{
		FileToTest.close();
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOLEAN VMDetect::CheckDebuggerPresent(VOID)
{
	return IsDebuggerPresent(); // wraps so we get clean output.
}

// https://github.com/a0rtega/pafish/blob/master/pafish/vbox.c#L118
BOOLEAN VMDetect::VirtualBox::CheckSystemFiles(VOID)
{
	std::vector<std::string> Files2Check = {
		"C:\\WINDOWS\\system32\\vboxdisp.dll",
		"C:\\WINDOWS\\system32\\vboxhook.dll",
		"C:\\WINDOWS\\system32\\vboxmrxnp.dll",
		"C:\\WINDOWS\\system32\\vboxogl.dll",
		"C:\\WINDOWS\\system32\\vboxoglarrayspu.dll",
		"C:\\WINDOWS\\system32\\vboxoglcrutil.dll",
		"C:\\WINDOWS\\system32\\vboxoglerrorspu.dll",
		"C:\\WINDOWS\\system32\\vboxoglfeedbackspu.dll",
		"C:\\WINDOWS\\system32\\vboxoglpackspu.dll",
		"C:\\WINDOWS\\system32\\vboxoglpassthroughspu.dll",
		"C:\\WINDOWS\\system32\\vboxservice.exe",
		"C:\\WINDOWS\\system32\\vboxtray.exe",
		"C:\\WINDOWS\\system32\\VBoxControl.exe",
		"C:\\program files\\oracle\\virtualbox guest additions\\"
	};

	for (auto File : Files2Check)
	{
		if (FileExists(File))
		{
			std::cout << "!! Found: " << File << std::endl;
			return TRUE;
		}
	}

	return FALSE;
}

BOOLEAN VMDetect::VirtualBox::CheckTrayWindowExists(VOID)
{
	HWND VBoxTrayToolClass = FindWindow(L"VBoxTrayToolWndClass", NULL);
	HWND VBoxTrayToolWnd = FindWindow(NULL, L"VBoxTrayToolWnd");

	return (VBoxTrayToolClass || VBoxTrayToolWnd);
}
	
BOOLEAN VMDetect::CPU::CheckCpuVendor(VOID)
{
	std::vector<std::string> DisallowedNames = {
		"KVMKVMKVM\0\0\0",
		"Microsoft Hv",
		"VMwareVMware",
		"XenVMMXenVMM",
		"prl hyperv  ",
		"VBoxVBoxVBox"
	};

	auto CurrentCPUName = InstructionSet::Vendor();

	for (auto Vender : DisallowedNames)
	{
		if (Vender == CurrentCPUName)
		{
			std::cout << "!! Vendor name matches disallowed \"" << Vender << "\"" << std::endl;
			return TRUE;
		}
	}

	return FALSE;
}

// https://github.com/a0rtega/pafish/blob/184b3fc3d5431e7334485a1eb33f30d3be125dc3/pafish/bochs.c#L18
BOOLEAN VMDetect::CPU::CheckBochsAMD(VOID)
{
	return (!memcmp(InstructionSet::Brand().data(), "AMD Athlon(tm) processor", 24)) ? TRUE : FALSE;
}

BOOLEAN VMDetect::CPU::CheckHVBit(VOID)
{
	int* values = new int[4];
	__cpuid(values, 0x01);
	return (values[2] >> 32) & 0x1;
}
```

`VMDetect.hpp`:

```hpp
#pragma once

#include <iostream>
#include <Windows.h>
#include <intrin.h>
#include <vector>
#include <fstream>

#define STATUS_HV_DETECTED 1
#define STATUS_HV_NOT_PRESENT 0
#define HV_SYNTHETIC_MSR_RANGE_START 0x40000000

namespace VMDetect
{
#if _WIN32 && !(_WIN64)
	DWORD64 CalcRDTSCDifference();
#endif

#if _WIN64
	DWORD64 CalcRDTSCDifference();
#endif

	BOOLEAN CheckRTDSCTimings(VOID);
	BOOLEAN CheckCPUIDLeafResponse(VOID);
	BOOLEAN CheckSyntheticMSRs(VOID);

	BOOLEAN FileExists(std::string FileName);
	BOOLEAN CheckDebuggerPresent(VOID);

	namespace VirtualBox
	{
		BOOLEAN CheckSystemFiles(VOID);
		BOOLEAN CheckTrayWindowExists(VOID);
	}

	namespace CPU
	{
		BOOLEAN CheckCpuVendor(VOID);
		BOOLEAN CheckBochsAMD(VOID);
		BOOLEAN CheckHVBit(VOID);
	}
}
```

`main.cpp`:

```cpp
#include "VMDetect.hpp"
#include "InstructionSet_MS.hpp"

#define COLOUR_OK 10
#define COLOUR_BAD 12
#define COLOUR_NORMAL 7

// Only supporting Windows currently.
#ifdef _WIN64
#define PLATFORM "Windows 64 Bit"
#else
#define PLATFORM "Windows 32 Bit"
#endif

const InstructionSet::InstructionSet_Internal InstructionSet::CPU_Rep;

HANDLE hConsole;

BOOLEAN TestFunction(std::string Name, BOOLEAN(*Function)(VOID), std::size_t iDesiredSize = 50)
{ 
	if (!hConsole)
		hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	
	if (!hConsole)
	{
		exit(-1);
		return FALSE;
	}

	SetConsoleTextAttribute(hConsole, COLOUR_NORMAL);

	std::string FinalName = Name;
	if (Name.size() < iDesiredSize)
	{
		for (int i = Name.size(); i < iDesiredSize; i++)
		{
			FinalName.push_back(' ');
		}
	}

	printf("%s ", FinalName.c_str());
	
	auto bReturn = Function();
	//printf("%s\n", (bReturn ? "BAD" : "OK"));

	if (bReturn)
	{
		SetConsoleTextAttribute(hConsole, COLOUR_BAD);
		printf("VM DETECTED\n");
		SetConsoleTextAttribute(hConsole, COLOUR_NORMAL);
	}
	else 
	{
		SetConsoleTextAttribute(hConsole, COLOUR_OK);
		printf("BAD\n");
		SetConsoleTextAttribute(hConsole, COLOUR_NORMAL);
	}

	return bReturn;
}

#define Test(Func) TestFunction(#Func##".. ", Func)

std::string DashesGen(int n)
{
	std::string Out;
	for (int i = 0; i < n; i++)
	{
		Out.push_back('-');
	}

	return Out;
}

int main()
{
	std::cout << "Compact VM Detector || Compiled at " __TIME__ " " __DATE__ " for " PLATFORM "\n" << std::endl;
	std::string TitleString = std::string(InstructionSet::Vendor()) + std::string(" | ") + std::string(InstructionSet::Brand());
	std::cout << TitleString << std::endl;
	std::cout << DashesGen(TitleString.size()) << std::endl;

	Test(VMDetect::CheckDebuggerPresent);
	Test(VMDetect::CheckSyntheticMSRs);
	Test(VMDetect::CheckCPUIDLeafResponse);
	Test(VMDetect::VirtualBox::CheckSystemFiles);
	Test(VMDetect::VirtualBox::CheckTrayWindowExists);
	Test(VMDetect::CPU::CheckCpuVendor);
	Test(VMDetect::CPU::CheckHVBit);
	Test(VMDetect::CheckRTDSCTimings);
}
```