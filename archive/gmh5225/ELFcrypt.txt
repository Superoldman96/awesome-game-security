Project Path: arc_gmh5225_ELFcrypt_xvci9adt

Source Tree:

```txt
arc_gmh5225_ELFcrypt_xvci9adt
├── ELFcrypt.c
├── ELFcrypt.h
├── ELFcrypt2-stub.c
├── ELFcrypt2.c
├── LICENSE.md
├── Makefile
├── README.md
└── example.c

```

`ELFcrypt.c`:

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <errno.h>

#include "ELFcrypt.h"


/* Global variables */
unsigned char   *key		= NULL;
char            *outfile	= "crypted";


/* ELFcrypt() -- Encrypts ELF file, writing encrypted results to an output file.
 *
 * Args:
 *     in  - Path to input ELF file.
 *     out - Path to output crypted ELF file.
 *     key - RC4 key to encrypt input file with.
 *
 * Returns:
 *    Nothing.
 */
void ELFcrypt(const char *in, const char *out, const unsigned char *key) {
  int           fd;
  int           output;
  size_t        filesize;
  void          *program;
  Elf64_Shdr    *crypted;


  /* Calculate file size */
  filesize = get_file_size(in);
  if (filesize == -1)
    fatal("Unable to calculate size of input file %s\n", in);

  /* Open input and output files */
  fd = open(in, O_RDONLY);
  if (fd == -1)
    fatal("Failed to open input file %s: %s\n", in, strerror(errno));

  output = open(out, O_WRONLY | O_CREAT, 0755);
  if (output == -1)
    fatal("Failed to open output file %s: %s\n", out, strerror(errno));

  /* mmap input file */
  program = mmap(0, filesize, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
  if (program == MAP_FAILED)
    fatal("Unable to mmap %s: %s\n", in, strerror(errno));

  /* Get .crypted section of ELF file */
  crypted = get_elf_section(program, ".crypted");
  if (crypted == NULL) {
    unlink(out);
    fatal("No .crypted section found in %s\n", in);
  }

  /* Encrypt .crypted section using 'key' */
  if (rc4(program + crypted->sh_offset, crypted->sh_size, (unsigned char *)key) == 1)
    fatal("Failed to encrypt input file %s\n", in);

  /* Store offset and size of .crypted section for future reference. These
   * values will be used later by the ELFdecrypt() function. The
   * e_ident[EI_PAD] section provides a conveinient 7 byte location to store
   * these values in the ELF header.
   */
  *((int *)(program + 0x09)) = crypted->sh_offset;
  *((short *)(program + 0x0d)) = crypted->sh_size;

  /* Write outfile */
  if (write(output, program, filesize) != filesize)
    fatal("Failed to write to output file %s: %s\n", out, strerror(errno));

  /* Close file descriptors. Skipped munmap() because this happens
   * automatically when the program exits.
   */
  close(fd);
  close(output);
}


/* usage() -- Prints help menu and exits.
 *
 * Args:
 *     progname - String containing the name of the program.
 *
 * Returns:
 *     Nothing.
 */
void usage(const char *progname) {
  fprintf(stderr, "usage: %s <program> [-o <outfile>] [-k <key>] [-h?]\n", progname);
  fprintf(stderr, "  -o <outfile> -- final resting place of crypted output. Default: %s\n", outfile);
  fprintf(stderr, "  -k <key>     -- key to crypt ELF with. (bypasses getpass() routine)\n");

  exit(EXIT_FAILURE);
}


/* main()
 */
int main(int argc, char *argv[]) {
  int       ch;
  char      *progname = argv[0];


  printf("ELFcrypt by @dmfroberson\n\n");

  while((ch = getopt(argc, argv, "o:k:h?")) != -1) {
    switch(ch) {
    case 'o':
      outfile = optarg;
      break;
    case 'k':
      key = optarg;
      break;
    case '?':
    case 'h':
    default:
      usage(progname);
      break;
    }
  }

  argc -= optind;
  argv += optind;

  /* Check for required infile argument */
  if (!argv[0])
    usage(progname);

  printf("Crypting .crypted section of %s, outputting to %s\n\n",
	 argv[0],
	 outfile);

  if (key == NULL)
    key = (unsigned char *)get_password();

  ELFcrypt(argv[0], outfile, key);

  return EXIT_SUCCESS;
}

```

`ELFcrypt.h`:

```h
#include <elf.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/mman.h>

#define ENTRY ((unsigned char *)0x400000)
#define CRYPTED __attribute__((section(".crypted")))


/* fatal() -- Prints a message and exits with EXIT_FAILURE
 *
 * Args:
 *     fmt - va_args-style format strings (like printf)
 *
 * Returns:
 *     Nothing.
 */
void fatal(char *fmt, ...) {
  va_list       ap;

  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  va_end(ap);

  exit(EXIT_FAILURE);
}


/* is_valid_elf() -- Determine if data is a valid ELF file.
 *
 * Args:
 *     header - ELF header.
 *
 * Returns:
 *     1 if ELF magic checks are successful.
 *     0 if the magic bytes do not match.
 */
int is_valid_elf(Elf64_Ehdr *header) {
  if (!header)
    return 0;

  if (header->e_ident[EI_MAG0] != ELFMAG0 ||
      header->e_ident[EI_MAG1] != ELFMAG1 ||
      header->e_ident[EI_MAG2] != ELFMAG2 ||
      header->e_ident[EI_MAG3] != ELFMAG3)
    return 0;

  return 1;
}


/* get_elf_size() -- Calculate size of ELF data within a file.
 *
 * Args:
 *     progname - ELF file
 *
 * Returns:
 *     size of ELF data if successful.
 *     -1 if an error occurred.
 *
 * Note: if an error occurs, errno is set appropriately.
 */
size_t get_elf_size(const char *progname) {
  int           fd;
  void          *ELFheaderdata;
  Elf64_Ehdr    *ELFheader;
  size_t        elfsize;


  ELFheaderdata = malloc(64);

  fd = open(progname, O_RDONLY);
  if (fd == -1) {
    free(ELFheaderdata);
    errno = ENOENT;
    return -1;
  }

  read(fd, ELFheaderdata, 64);
  ELFheader = (Elf64_Ehdr *)ELFheaderdata;

  if (is_valid_elf(ELFheader) == 0) {
    errno = ENOEXEC;
    return -1;
  }

  elfsize = ELFheader->e_shoff + (ELFheader->e_shnum * ELFheader->e_shentsize);

  close(fd);
  free(ELFheaderdata);

  return elfsize;
}


/* get_elf_section() -- Get address of ELF section within data.
 *
 * Args:
 *     data    - ELF data in memory
 *     section - section name to search for
 *
 * Returns:
 *     Address of section if successful.
 *     NULL if section does not exist.
 */
Elf64_Shdr *get_elf_section(void *data, const char *section) {
  int           i;
  char          *offset;


  /* Populate ELF headers and section headers from mmapped file */
  Elf64_Ehdr *ELFheader = (Elf64_Ehdr *)data;
  Elf64_Shdr *sectionheader = (Elf64_Shdr *)(data + ELFheader->e_shoff);
  Elf64_Shdr *next = &sectionheader[ELFheader->e_shstrndx];

  /* Make sure this is a valid ELF before proceeding */
  if (is_valid_elf(ELFheader) == 0)
    fatal("Input file is not a valid ELF file.\n");

  offset = data + next->sh_offset;

  /* Search for "section" and return address of matching section header */
  for (i = 0; i < ELFheader->e_shnum; i++) {
    if (!strcmp((char *)offset + sectionheader[i].sh_name, section)) {
      return &sectionheader[i];
    }
  }

  return NULL;
}


/* get_file_size() -- Determine the size of a file.
 *
 * Args:
 *     filename - Path to file.
 *
 * Returns:
 *     Size of file in bytes on success.
 *     -1 if something went wrong.
 */
size_t get_file_size(const char *filename) {
  struct stat     s;

  if (stat(filename, &s) == -1) {
    fprintf(stderr, "Failed to stat file %s: %s\n", filename, strerror(errno));
    return -1;
  }

  return s.st_size;
}


/* get_password() -- Prompt user for a password and password confirmation.
 *
 * Args:
 *     None
 *
 * Returns:
 *     Pointer to string containing the password.
 *
 * Note: this is limited to 256 byte passwords because this is the maximum
 * key length RC4 is able to use.
 */
char *get_password() {
  int             i = 0;
  char            *key;
  char            keyconfirm[256];

  do {
    if (i) {
      printf("Passwords do not match\n");
      sleep(3);
    }

    if ((key = getpass("Enter passphrase: ")) == NULL) {
      printf("Bad password.\n");
      continue;
    }

    strncpy(keyconfirm, key, sizeof(keyconfirm));

    if ((key = getpass("Confirm passphrase: ")) == NULL) {
      printf("Bad password.\n");
      continue;
    }

    i = 1;
  } while (strcmp(key, keyconfirm));

  /* zero out key from memory */
  memset(keyconfirm, 0, sizeof(keyconfirm));

  return key;
}


/* rc4() -- Encrypt data using RC4 encryption algorithm.
 *
 * Args:
 *     data - Data to encrypt
 *     size - Length of data
 *     key  - Passphrase to encrypt data with.
 *
 * Returns:
 *     0 if successful.
 *     1 if unsuccessful.
 */
int rc4(unsigned char *data, size_t size, const unsigned char *key) {
  int           i;
  int           rc4i;
  int           rc4j;
  unsigned char rc4s[256];
  unsigned int  tmp;

  if (strlen((char *)key) > sizeof(rc4s)) {
    fprintf(stderr, "Key must be under %ld bytes\n", sizeof(rc4s));
    return 1;
  }

  /* Key-scheduling algorithm */
  for (i = 0; i < sizeof(rc4s); i++)
    rc4s[i] = i;

  for (rc4i = 0, rc4j = 0; rc4i < sizeof(rc4s); rc4i++) {
    rc4j = (rc4j + rc4s[rc4i] + key[rc4i % strlen((char *)key)]) % sizeof(rc4s);

    /* swap s[i] and s[j] */
    tmp = rc4s[rc4j];
    rc4s[rc4j] = rc4s[rc4i];
    rc4s[rc4i] = tmp;
  }

  /* encrypt data */
  for (rc4i = 0, rc4j = 0, i = 0; i < size; i++) {
    rc4i = (rc4i + 1) % sizeof(rc4s);
    rc4j = (rc4j + rc4s[rc4i]) % sizeof(rc4s);

    /* swap s[i] and s[j] */
    tmp = rc4s[rc4j];
    rc4s[rc4j] = rc4s[rc4i];
    rc4s[rc4i] = tmp;

    tmp = rc4s[(rc4s[rc4i] + rc4s[rc4j]) % sizeof(rc4s)];
    data[i] ^= tmp;
  }

  return 0;
}


/* ELFdecrypt() -- Decrypt .crypted section of ELF file.
 *
 * Args:
 *     pass - If desired, pass the key in here. This is not very secure,
 *            but provides some obfuscation.
 *
 * Returns:
 *     Nothing
 *
 * Note: if the ELFCRYPT environment variable is set, this will attempt to use
 * its contents as the encryption key.
 */
void ELFdecrypt(char *pass) {
  int           section_length;
  int           crypted_section;
  char          *key;
  unsigned char *ptr;
  unsigned char *ptr2;
  size_t        pagesize;
  uintptr_t     pagestart;
  int           size;


  if (pass == NULL) {
    key = getenv("ELFCRYPT");
    if (key == NULL) {
      key = getpass("Enter passphrase: ");
    } else {
      unsetenv("ELFCRYPT");
    }
  } else {
    key = strdup(pass);
  }

  /* Retrieve crypted section offset and size stored by ELFcrypt */
  crypted_section = *((int *)(ENTRY + 0x09));
  section_length = *((short *)(ENTRY + 0x0d));

  /* Calculate offsets and sizes */
  ptr = ENTRY + crypted_section;
  ptr2 = ENTRY + crypted_section + section_length;
  pagesize = sysconf(_SC_PAGESIZE);
  pagestart = (uintptr_t)ptr & -pagesize;
  size = (ptr2 - (unsigned char *)pagestart);

  if (mprotect((void *)pagestart, size, PROT_READ | PROT_WRITE | PROT_EXEC) == -1)
    fatal("mprotect(): %s\n", strerror(errno));

  /* decrypt using specified key */
  rc4(ENTRY + crypted_section, section_length, (unsigned char *)key);

  if (mprotect((void *)pagestart, size, PROT_READ | PROT_EXEC) < 0)
    fatal("mprotect(): %s\n", strerror(errno));

  /* erase key */
  memset(key, 0, strlen(key));
}


```

`ELFcrypt2-stub.c`:

```c
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/syscall.h>

#include "ELFcrypt.h"


/* memfd_create prototype */
static inline int memfd_create(const char *name, unsigned int flags) {
  return syscall(__NR_memfd_create, name, flags);
}


/* main() -- Use the ELFappend technique to retrieve encrypted ELF then attempt
 *           to execute it in memory. I opted out of verbose error messages
 *           for this program to mask its intentions a little bit.
 */
int main(int argc, char *argv[], char *envp[]) {
  int             i;
  int             fd;
  int             in;
  size_t          offset;
  size_t          filesize;
  unsigned char   *key;
  void            *program;
  char            characters[] = \
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";


  /* Seed RNG */
  srand(time(NULL));

  /* Calculate size of the stub + encrypted ELF */
  filesize = get_file_size(argv[0]);

  /* Calculate size of the stub */
  offset = get_elf_size(argv[0]);
  if (offset == -1)
    return EXIT_FAILURE;

  /* Open stub + encrypted ELF for reading, then mmap() it */
  in = open(argv[0], O_RDONLY);
  if (in == -1)
    return EXIT_FAILURE;

  program = mmap(0, filesize, PROT_READ | PROT_WRITE, MAP_PRIVATE, in, 0);
  if (program == MAP_FAILED)
    return EXIT_FAILURE;

  /* Skip the stub. The encrypted data lies right after the stub. */
  program += offset;

  /* Attempt to decrypt the ELF using the key supplied by the user */
  key = (unsigned char *)getenv("ELFCRYPT");
  if (key == NULL)
    key = (unsigned char *)getpass("Enter passphrase: ");

  if (rc4(program, filesize - offset, key) == 1)
    return EXIT_FAILURE;

  /* Overwrite key with random shit to hide its true contents. */
  for(; *key; key++)
    *key = characters[rand() % sizeof(characters) - 1];

  /* Some operating systems may not supply this function. This has only
   * been tested on modern Linux distributions (as of 2018). Alternatively,
   * you can modify this to utilize a temporary file or shm_open(). We use the
   * memfd_create() system call here to avoid writes to the disk.
   */
  fd = memfd_create("asdf", 1);
  if (fd == -1)
    return EXIT_FAILURE;

  /* Write decrypted program data to memory file descriptor */
  if (write(fd, program, filesize - offset) != filesize - offset)
    return EXIT_FAILURE;

  /* Overwrite decrypted program with randomness before unmapping it.*/
  for(i = 0; i < filesize - offset; i++, program++)
    *((char *)program) = rand() % 0xff;

  munmap(program, filesize);
  close(in);

  /* Attempt to execute decrypted ELF which is stored in memory fd. */
  fexecve(fd, argv, envp);
  close(fd);

  return EXIT_SUCCESS;
}


```

`ELFcrypt2.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>

#include "ELFcrypt.h"


/* main() -- Encrypt input file using RC4. Write output to a file.
 */
int main(int argc, char *argv[]) {
  int             in;
  int             out;
  size_t          filesize;
  void            *program;
  unsigned char   *key;


  printf("ELFcrypt2 by @dmfroberson\n");

  if (argc != 3)
    fatal("usage: %s <input program> <output filename>\n", argv[0]);

  in = open(argv[1], O_RDONLY);
  if (in == -1)
    fatal("Failed to open input file %s: %s\n", argv[1], strerror(errno));

  out = open(argv[2], O_WRONLY | O_CREAT, 0755);
  if (out == -1)
    fatal("Failed to open output file %s: %s\n", argv[2], strerror(errno));

  filesize = get_file_size(argv[1]);
  if (filesize == -1)
    fatal("Unable to determine size of input file.\n");

  program = mmap(0, filesize, PROT_READ | PROT_WRITE, MAP_PRIVATE, in, 0);
  if (program == MAP_FAILED)
    fatal("Unable to mmap %s: %s\n", argv[1], strerror(errno));

  key = (unsigned char *)get_password();
  if (rc4(program, filesize, key) == -1)
    fatal("Failed to encrypt input file.\n");

  if (write(out, program, filesize) != filesize)
    fatal("Failed to write to output file %s: %s\n", argv[2], strerror(errno));

  close(in);
  close(out);

  return EXIT_SUCCESS;
}


```

`LICENSE.md`:

```md
The MIT License

Copyright (c) 2018 Daniel Roberson

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
all: ELFcrypt ELFcrypt2 example

ELFcrypt:
	gcc -Wall -o ELFcrypt ELFcrypt.c

ELFcrypt2:
	gcc -Wall -o ELFcrypt2 ELFcrypt2.c
	gcc -Wall -o ELFcrypt2-stub ELFcrypt2-stub.c

example:
	gcc -Wall -o example example.c

clean:
	rm -rf *~ *.o example ELFcrypt ELFcrypt2 ELFcrypt2-stub


```

`README.md`:

```md
# ELFcrypt

```
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMNNNNNNNNNNNNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMNNmdhso///+o++osyyhdmNNNNNNNNNNMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMNmmhs/:...`````..........:ohmNNNNNNNNNNNNMMMMMMMMMMMMMMMM
MMMMMMMNmds:..````````...............:sdmmNNNNNNNNNNNNMMMMMMMMMMMM
MMMMNNNNm+.`.....````.............------odmmmmNNNNNNNNNNNMMMMMMMMM
MNNNNNNdo......`````..........-------:---:ymmmmmmmNNNNNNNNNMMMMMMM
NNNNNNdy.......```.....-------::::::::::--:odmmmmmmmmNNNNNNNNMMMMM
NNNNNmh:...........---::::::::::::::::::----odmmmmmmmmmmNNNNNNNMMM
NNNmmdo......-...---:::::::----::::::------.-odddmmmmmmmmNNNNNNNNM
Nmmmms.....----.------:::::::::::::----::--.-:odddddmmmmmmmNNNNNNN
mmmmd:....---------:-..-------:::--..-oso/::///hdddddmmmmmmmmNNNNN
mmmmy-..---::---.-++++/:----://++///+oo+oooyhs/sdddddddmmmmmmmNNNN
mmmdy-.---:///--.:++osyhsosyhyo/::oyhso//ooyhyo+dddddddddmmmmmmmNN
mmddy.-syysoo+-..:++//+osdhys+:/oooyys+/++::sso+hddddddddddmmmmmmN
mddds.:ohydhhs:..-/+/:/oyy+/::/dddy/oyss+/+so//ohddddddddddmmmmmmm
ddddy.-:syddhso--::/+osss////+hdyydhossyhddysoo+hddddddddddddmmmmm
ddddh/--/hhsyyhyo/+shyssys+:o+hho+hyosdmmmdysssohdddddddddddddmmmm
dddddh:-:+sssosyyydmmmmdho::+/+/+sso+oshmmmhysooddddddddddddddmmmm
dddddh/--/oysyhdhyyhmmdhs+:::---:+--:++shddhyo+sdddddddddddddddmmm
dddddho/::/oyhdddssyhhhoso::-://+ooshhyoyhhsosyhdddddddddddddddmmm
ddddddyo/::+syyhdsssssysddyssydhhhdmNmdooyysyhddddddddddddddddddmm
ddddddho+///oosyhssssossoooohhsyydhsyy+/ohhyhddddddddddddddddddmmm
dddddddy+/:/+o+syhhyysoosso+++::+ssosssssyyydddddddddddddddddddmmm
dddddddh//::/o+o+ydddhssooooos+oyhhhhddh+sshddddddddddddddddddddmm
ddddddhho::::/++/-ydddhyyso++//oyyssyhysoosddddddddddddddddddddmmm
ddddddhhs----://:-+yhhyhddyo+/+ssyydmmddhsdddddddddddddddddddddmmm
dddddhhy+---.-:-:os/shyydmmmdyhddmmmdhmmssdddddddddddddddddddddmmm
dddddddh/---.--ohyhy:-/oyhhdmddmmmd+-.sNdosyhhddddddddddddddddmmmm
dddddddy:+----:hs+hdh+.`..-/shdmmy:..-dNNhhsoooosyhdddddddddddmmmm
dddddddy:+/---:ss:/yddh+-.---/yds.```./hNNdmmdddyyyhdmNNNmmmmmmmmm
mdddddds//:-:-:+ys:-+hmdhyso/--+-.--::/omNmmdmNNNdyyyhmmmhhmNNNNNN
mmddddy+//::+///ohh/.-+omNNNmdsyddmmmmmmNNNNNmdmmdhhddydmyyhNdNNNN
mmmdyo+++o+++///oymmo..oNNNNNNNmdyysyyhhhNNdhhyssydhddsmsddmdyNNNN
dhyssyyyhhss+/++symNNy-+mNmNNmds:-----::+mdyyyyyssymmdmNhdNNsyNNNN
yyyyysyydhhd++osydNNNNd/smmdy/--......--:hmhhyhhysydNNdymNmyyNNNNN
yyhddhhmNNmhsssyhNNNNNNms//:-..........--oNdhhddddmNNNmdymhhhNNNNN
hshdNdmNmNhsyohmNNNNNNNNNy...........`..-:mmmmddNNhNmmNNddmNmNNNNm
ssmNNNsNyNsdshmNNNNNNNNNNNo..........``.--yNNNmdNNoNmNNNNNsmNNNNNm
shydmm+NomymyNddNNNNNNNNNNNo.......-....--sNNNNdNmyhdmdNNNsNNNNNNN
hhh+mhhyssNNddhsdhNNNNNNNNNNy............-sNNmNmmNNNdshyNNmmddmNNN
+yhyNdyhyhNNmNyhydmNNNNNNNNNNy-.......`..-/mNNmNdNyNsydmNNNmmmNNNN
hsNddNdMMNMNmhdmmNdNNNNNNNNNNNs-......``..-yNNNNdmmhoNNNNNmmNNNNNN
```

## Version 1 Quick Start
```
% make
gcc -Wall -o ELFcrypt ELFcrypt.c
gcc -Wall -o example example.c
% ./ELFcrypt example
ELFcrypt by @dmfroberson

Crypting .crypted section of example, outputting to crypted

Enter passphrase: harharhar
Confirm passphrase: harharhar
% ./crypted
Enter passphrase: harharhar
Confirm passphrase: harharhar
This function was crypted
```

To use this in future projects, include ELFcrypt.h, add a call to
ELFdecrypt() to main(), and prefix your functions that you'd like to
protect with CRYPTED. After this make-believe C program is compiled,
run ELFcrypt against it with whatever password you desire and it will
be encrypted with RC4. See example.c for more details.

This also will attempt to read the ELFCRYPT environment variable as
input for the password:

```
% ELFCRYPT="harharhar" ./crypted
This function was crypted
```

## objdump before/after
Before:
```
% objdump -dj .crypted example 

example:     file format elf64-x86-64


Disassembly of section .crypted:

0000000000401022 <crypted_main>:
  401022:	55                   	push   %rbp
  401023:	48 89 e5             	mov    %rsp,%rbp
  401026:	48 83 ec 10          	sub    $0x10,%rsp
  40102a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  40102d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  401031:	bf ec 10 40 00       	mov    $0x4010ec,%edi
  401036:	e8 b5 f7 ff ff       	callq  4007f0 <puts@plt>
  40103b:	b8 64 00 00 00       	mov    $0x64,%eax
  401040:	c9                   	leaveq 
  401041:	c3                   	retq   
```

After:
```
% objdump -dj .crypted crypted

crypted:     file format elf64-x86-64


Disassembly of section .crypted:

0000000000401022 <crypted_main>:
  401022:	68 ac 6c f3 e5       	pushq  $0xffffffffe5f36cac
  401027:	6d                   	insl   (%dx),%es:(%rdi)
  401028:	91                   	xchg   %eax,%ecx
  401029:	59                   	pop    %rcx
  40102a:	d2 7b 05             	sarb   %cl,0x5(%rbx)
  40102d:	6e                   	outsb  %ds:(%rsi),(%dx)
  40102e:	20 3c 38             	and    %bh,(%rax,%rdi,1)
  401031:	74 05                	je     401038 <crypted_main+0x16>
  401033:	54                   	push   %rsp
  401034:	13 d6                	adc    %esi,%edx
  401036:	2c 31                	sub    $0x31,%al
  401038:	18 99 4c 46 5f 38    	sbb    %bl,0x385f464c(%rcx)
  40103e:	ad                   	lods   %ds:(%rsi),%eax
  40103f:	e3 bb                	jrcxz  400ffc <__libc_csu_init+0x4c>
	...

```


As you can see, the second binary contains a bunch of nonsensical rubbish
instead of readable assembler in the .crypted section.


## Quickstart Version 2
```
 ~/ELFcrypt % make
gcc -Wall -o ELFcrypt ELFcrypt.c
gcc -Wall -o ELFcrypt2 ELFcrypt2.c
gcc -Wall -o ELFcrypt2-stub ELFcrypt2-stub.c
gcc -Wall -o example example.c
 ~/ELFcrypt % ./ELFcrypt2 /bin/ls out
ELFcrypt2 by @dmfroberson
Enter passphrase: danger
Confirm passphrase: danger
 ~/ELFcrypt % cat ELFcrypt2-stub out >crypted
 ~/ELFcrypt % chmod +x crypted
 ~/ELFcrypt % ./crypted 
Enter passphrase: danger
Confirm passphrase: danger
crypted    ELFcrypt2.c	     ELFcrypt.c  example.c   out
ELFcrypt   ELFcrypt2-stub    ELFcrypt.h  LICENSE.md  README.md
ELFcrypt2  ELFcrypt2-stub.c  example	 Makefile
```

ELFcrypt2 creates a stub program that reads whatever data resides beyond
the end of its own valid ELF, decrypts this data memory, and finally
executes it in memory by means of fexecve()

To use on different programs, run them through ELFcrypt2, then use cat
as outlined above to create the binary.

This might not work right on older Linux systems that do not have the
memfd_create() function. This can be worked around by modifying the
code to create temporary files rather than utilizing this function.
Maybe one day I will care enough to fix this.

Also, the contents of your crypted executable are vulnerable to memory
dumps while it is running. This simply provides a layer of protection
for your stuff while it is relaxing on a hostile disk drive.


```

`example.c`:

```c
/* Example program using ELFcrypt
 *
 * Include ELFcrypt.h and prefix functions you'd like crypted with CRYPTED.
 * Please also remember to add a call to ELFdecrypt() somewhere in your
 * program before the protected functions are used.
 *
 * Your program must then be ran through ELFcrypt:
 *
 * $ ./ELFcrypt /path/to/program -o output
 */

#include <stdio.h>

/* include ELFcrypt.h for the required macros and functions
 */
#include "ELFcrypt.h"

/* Prefix your functions with CRYPTED to add them to the .crypted section
 */
CRYPTED int crypted_main(int argc, char *argv[]) {
  printf("This function was crypted\n");

  return 100;
}


int main(int argc, char *argv[]) {
  ELFdecrypt(); /* you must call this function and provide a valid
		   password before the functions you've placed into the
		   .crypted section will work */
  return crypted_main(argc, argv);
}

```