Project Path: arc_gmh5225_exe_packer_jk2xh96p

Source Tree:

```txt
arc_gmh5225_exe_packer_jk2xh96p
├── exe_packer.sln
├── exe_packer.vcxproj
├── exe_packer.vcxproj.filters
├── huffman_compressor_internal.cpp
├── huffman_compressor_internal.h
├── huffman_decompressor_stub.cpp
├── huffman_decompressor_stub.h
├── includes.h
├── main.cpp
├── namespaces.h
├── nt_defs.h
├── nt_funcs.h
├── pack_file.cpp
├── pack_file.h
├── strings_init.h
├── tools.cpp
├── tools.h
├── unpacker_stub.cpp
├── unpacker_stub.h
├── win_10.h
├── win_11.h
├── win_7.h
├── win_8.h
└── win_81.h

```

`exe_packer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32014.148
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "exe_packer", "exe_packer.vcxproj", "{B6E6EE1D-51F5-451F-86ED-DB92F513C71B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B6E6EE1D-51F5-451F-86ED-DB92F513C71B}.Debug|x64.ActiveCfg = Debug|x64
		{B6E6EE1D-51F5-451F-86ED-DB92F513C71B}.Debug|x64.Build.0 = Debug|x64
		{B6E6EE1D-51F5-451F-86ED-DB92F513C71B}.Debug|x86.ActiveCfg = Debug|Win32
		{B6E6EE1D-51F5-451F-86ED-DB92F513C71B}.Debug|x86.Build.0 = Debug|Win32
		{B6E6EE1D-51F5-451F-86ED-DB92F513C71B}.Release|x64.ActiveCfg = Release|x64
		{B6E6EE1D-51F5-451F-86ED-DB92F513C71B}.Release|x64.Build.0 = Release|x64
		{B6E6EE1D-51F5-451F-86ED-DB92F513C71B}.Release|x86.ActiveCfg = Release|Win32
		{B6E6EE1D-51F5-451F-86ED-DB92F513C71B}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {23D662F3-5FFF-4F28-AB82-CBC01E170059}
	EndGlobalSection
EndGlobal

```

`exe_packer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b6e6ee1d-51f5-451f-86ed-db92f513c71b}</ProjectGuid>
    <RootNamespace>exepacker</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);Urlmon.lib;Wininet.lib;Dbghelp.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
      <BaseAddress>
      </BaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <Optimization>MinSpace</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>
      </EnableCOMDATFolding>
      <OptimizeReferences>false</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);Urlmon.lib;Wininet.lib;Dbghelp.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <BaseAddress>
      </BaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions);WIN64</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);Urlmon.lib;Wininet.lib;Dbghelp.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
      <BaseAddress>
      </BaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions);_WIN64</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <Optimization>MaxSpeed</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>
      </EnableCOMDATFolding>
      <OptimizeReferences>false</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);Urlmon.lib;Wininet.lib;Dbghelp.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <BaseAddress>
      </BaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="huffman_compressor_internal.cpp" />
    <ClCompile Include="huffman_decompressor_stub.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="pack_file.cpp" />
    <ClCompile Include="tools.cpp" />
    <ClCompile Include="unpacker_stub.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="strings_init.h" />
    <ClInclude Include="huffman_compressor_internal.h" />
    <ClInclude Include="huffman_decompressor_stub.h" />
    <ClInclude Include="includes.h" />
    <ClInclude Include="namespaces.h" />
    <ClInclude Include="nt_defs.h" />
    <ClInclude Include="nt_funcs.h" />
    <ClInclude Include="pack_file.h" />
    <ClInclude Include="tools.h" />
    <ClInclude Include="unpacker_stub.h" />
    <ClInclude Include="win_10.h" />
    <ClInclude Include="win_11.h" />
    <ClInclude Include="win_7.h" />
    <ClInclude Include="win_8.h" />
    <ClInclude Include="win_81.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`exe_packer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Header Files\NT">
      <UniqueIdentifier>{843df7b9-fec7-4be5-bb2a-7857b5d0260b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="tools.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pack_file.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="huffman_compressor_internal.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="huffman_decompressor_stub.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unpacker_stub.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pack_file.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="huffman_compressor_internal.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt_defs.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="nt_funcs.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="win_7.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="win_8.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="win_81.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="win_10.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="win_11.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="huffman_decompressor_stub.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="unpacker_stub.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="tools.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="namespaces.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="includes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="strings_init.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`huffman_compressor_internal.cpp`:

```cpp
#include "includes.h"

bool CalculateCharactersFrequency(std::priority_queue<CHAR_FREQ_PAIR*, std::vector<CHAR_FREQ_PAIR*>, CharAndFreqPairComparator>& char_and_frequency_tree, BYTE* file_raw, DWORD file_size)
{
	if (!file_raw || !file_size)
	{
		return false;
	}

	std::unordered_map<char, int> char_freq;
	for (DWORD i = 0; i < file_size; ++i)
	{
		if (char_freq.find(file_raw[i]) == char_freq.end())
		{
			char_freq[file_raw[i]] = 1;
		}
		else
		{
			++char_freq[file_raw[i]];
		}
	}

	for (const auto& pair : char_freq)
	{
		char_and_frequency_tree.push(new CHAR_FREQ_PAIR( pair.first, pair.second ));
	}

	return true;
}

bool CharAndFreqPairComparator::operator()(const CHAR_FREQ_PAIR* left, const CHAR_FREQ_PAIR* right)
{
	return left->frequency > right->frequency;
}

CHAR_FREQ_PAIR::CHAR_FREQ_PAIR(char ch, int frequency)
{
	this->ch = ch;
	this->frequency = frequency;
}

CHAR_FREQ_PAIR::CHAR_FREQ_PAIR()
{
}

CHAR_FREQ_PAIR* BuildHuffmanTree(std::priority_queue<CHAR_FREQ_PAIR*, std::vector<CHAR_FREQ_PAIR*>, CharAndFreqPairComparator>& char_and_frequency_tree)
{
	CHAR_FREQ_PAIR* head = nullptr;

	while (char_and_frequency_tree.size() != 1)
	{
		auto* left = char_and_frequency_tree.top();
		char_and_frequency_tree.pop();

		auto* right = char_and_frequency_tree.top();
		char_and_frequency_tree.pop();

		auto* new_node = new CHAR_FREQ_PAIR;
		
		new_node->left = left;
		new_node->right = right;
		new_node->ch = '%';
		new_node->frequency = left->frequency + right->frequency;

		head = new_node;

		char_and_frequency_tree.push(head);
	}

	return head;
}

void TraverseTree(CHAR_FREQ_PAIR* head, std::map<char, std::string>& key_char_map, std::string binary_path_to_char)
{
	if (head->left == nullptr && head->right == nullptr)
	{
		key_char_map[head->ch] = binary_path_to_char;

		return;
	}

	TraverseTree(head->left, key_char_map, binary_path_to_char + '0');
	TraverseTree(head->right, key_char_map, binary_path_to_char + '1');
}

void WriteTree(CHAR_FREQ_PAIR* head, std::vector<BYTE>& compressed_file_bytes)
{
	if (head->left == nullptr && head->right == nullptr)
	{
		compressed_file_bytes.push_back('1');
		compressed_file_bytes.push_back(head->ch);

		return;
	}

	compressed_file_bytes.push_back('0');

	WriteTree(head->left, compressed_file_bytes);
	WriteTree(head->right, compressed_file_bytes);
}

DWORD WriteCompressedBytes(std::map<char, std::string>& key_char_map, std::vector<BYTE>& compressed_file_bytes, BYTE* file_raw, DWORD file_size)
{
	if (!file_raw || !file_size)
	{
		return 0;
	}
	
	DWORD out_compressed_bytes_count = 0;

	DWORD bits_remain = 8;
	BYTE out_byte = 0;

	for (DWORD i = 0; i < file_size; ++i)
	{
		BYTE in_byte = file_raw[i];

		std::string key = key_char_map[in_byte];

		for (DWORD j = 0; j < key.size(); ++j)
		{
			if (key[j] == '0')
			{
				out_byte <<= 1;
			}
			else
			{
				out_byte = (out_byte << 1) | 0b1;
			}

			--bits_remain;

			if (bits_remain == 0)
			{
				compressed_file_bytes.push_back(out_byte);
				
				++out_compressed_bytes_count;

				out_byte = 0;
				bits_remain = 8;
			}
		}
	}
	
	if (bits_remain)
	{
		out_byte <<= bits_remain;

		compressed_file_bytes.push_back(out_byte);

		++out_compressed_bytes_count;
	}

	return out_compressed_bytes_count;
}

void DeleteTree(CHAR_FREQ_PAIR* head)
{
	if (head->left == nullptr && head->right == nullptr)
	{
		delete head;

		return;
	}

	DeleteTree(head->left);
	DeleteTree(head->right);
	
	delete head;
}
```

`huffman_compressor_internal.h`:

```h
#pragma once

struct CHAR_FREQ_PAIR
{
	char	ch;
	int		frequency;

	CHAR_FREQ_PAIR* left	= nullptr;
	CHAR_FREQ_PAIR* right	= nullptr;

	CHAR_FREQ_PAIR(char ch, int frequency);
	CHAR_FREQ_PAIR();
};

struct CharAndFreqPairComparator
{
	bool operator() (const CHAR_FREQ_PAIR* left, const CHAR_FREQ_PAIR* right);
};

bool CalculateCharactersFrequency(std::priority_queue<CHAR_FREQ_PAIR*, std::vector<CHAR_FREQ_PAIR*>, CharAndFreqPairComparator>& char_and_frequency_tree, BYTE* file_raw, DWORD file_size);

CHAR_FREQ_PAIR* BuildHuffmanTree(std::priority_queue<CHAR_FREQ_PAIR*, std::vector<CHAR_FREQ_PAIR*>, CharAndFreqPairComparator>& char_and_frequency_tree);

void TraverseTree(CHAR_FREQ_PAIR* head, std::map<char, std::string>& key_char_map, std::string binary_path_to_char);

void WriteTree(CHAR_FREQ_PAIR* head, std::vector<BYTE>& compressed_file_bytes);

DWORD WriteCompressedBytes(std::map<char, std::string>& key_char_map, std::vector<BYTE>& compressed_file_bytes, BYTE* file_raw, DWORD file_size);

void DeleteTree(CHAR_FREQ_PAIR* head);
```

`huffman_decompressor_stub.cpp`:

```cpp
#include "includes.h"

CODE_SEG(".stub_f") CHARS_HUFFMAN_TREE* __stdcall ReadTree_ForStub(STUB_FUNCTION_TABLE* f, BYTE** start_addr)
{
	char node_type = **start_addr;

	++(*start_addr);

	if (node_type == '1')
	{
		char ch = **start_addr;
		
		++(*start_addr);

		auto* head = _HeapAlloc<CHARS_HUFFMAN_TREE>(f, 1);
		
		head->ch = ch;

		return head;
	}

	auto* head = _HeapAlloc<CHARS_HUFFMAN_TREE>(f, 1);
	
	head->ch = '%';
	head->left = ReadTree_ForStub(f, start_addr);
	head->right = ReadTree_ForStub(f, start_addr);

	return head;
}
CODE_SEG(".stub_f") void __stdcall TraverseTree_ForStub(STUB_FUNCTION_TABLE* f, CHARS_CODES_LIST** list_head, CHARS_HUFFMAN_TREE* head, char* code)
{
	if (head->left == nullptr && head->right == nullptr)
	{
		auto* ch_codes_tail = _HeapAlloc<CHARS_CODES_LIST>(f, 1);

		ch_codes_tail->ch = head->ch;
		__strcpy(ch_codes_tail->code, code);

		if ((*list_head) == nullptr)
		{
			(*list_head) = ch_codes_tail;

			return;
		}

		auto* tmp = _HeapAlloc<CHARS_CODES_LIST>(f, 1);

		tmp->next = ch_codes_tail;
		tmp->prev = (*list_head)->prev;
		tmp->ch = (*list_head)->ch;
		__strcpy(tmp->code, (*list_head)->code);

		ch_codes_tail->prev = tmp;

		(*list_head) = ch_codes_tail;

		return;
	}

	char left_code[CHAR_CODE_LEN];
	
	f->RtlZeroMemory(left_code, CHAR_CODE_LEN);

	__strcat(left_code, code);
	__strcat(left_code, '0');

	char right_code[CHAR_CODE_LEN];
	
	f->RtlZeroMemory(right_code, CHAR_CODE_LEN);

	__strcpy(right_code, code);
	__strcat(right_code, '1');

	TraverseTree_ForStub(f, &(*list_head), head->left, left_code);
	TraverseTree_ForStub(f, &(*list_head), head->right, right_code);
}

CODE_SEG(".stub_f") void DeleteTree_ForStub(STUB_FUNCTION_TABLE* f, CHARS_HUFFMAN_TREE* head)
{
	if (head->left == nullptr && head->right == nullptr)
	{
		_FreeHeap(f, head);

		return;
	}

	DeleteTree_ForStub(f, head->left);
	DeleteTree_ForStub(f, head->right);

	_FreeHeap(f, head);
}
```

`huffman_decompressor_stub.h`:

```h
#pragma once

#define CHAR_CODE_LEN 0x50
#define BYTE_SIZE_IN_BITS 8
#define KEY_MAX_LEN CHAR_CODE_LEN

struct CHARS_CODES_LIST
{
	char ch;
	char code[CHAR_CODE_LEN];

	CHARS_CODES_LIST* next = nullptr;
	CHARS_CODES_LIST* prev = nullptr;
};

struct CHARS_HUFFMAN_TREE
{
	char ch;

	CHARS_HUFFMAN_TREE* left	= nullptr;
	CHARS_HUFFMAN_TREE* right	= nullptr;
};

CODE_SEG(".stub_f") CHARS_HUFFMAN_TREE* __stdcall ReadTree_ForStub(STUB_FUNCTION_TABLE* f, BYTE** start_addr);
CODE_SEG(".stub_f") void __stdcall TraverseTree_ForStub(STUB_FUNCTION_TABLE* f, CHARS_CODES_LIST** list_head, CHARS_HUFFMAN_TREE* head, char* code);
CODE_SEG(".stub_f") void DeleteTree_ForStub(STUB_FUNCTION_TABLE* f, CHARS_HUFFMAN_TREE* head);

__forceinline CHARS_CODES_LIST* FindCharCodeInList(CHARS_CODES_LIST* list_tail, char* some_code)
{
	if (!list_tail)
	{
		return nullptr;
	}

	while (true)
	{
		if (__strcmp(list_tail->code, some_code))
		{
			return list_tail;
		}

		if (list_tail->prev)
		{
			list_tail = list_tail->prev;
		
			continue;
		}

		return nullptr;
	}
}

__forceinline char* ByteToBitsInString(STUB_FUNCTION_TABLE* f, BYTE byte)
{
	char* out_str = _HeapAlloc<char>(f, BYTE_SIZE_IN_BITS + 1);
	
	for (DWORD i = 0; i < BYTE_SIZE_IN_BITS; ++i)
	{
		if ((byte << i) & 0b10000000)
		{
			out_str[i] = '1';
		}
		else
		{
			out_str[i] = '0';
		}
	}

	out_str[BYTE_SIZE_IN_BITS] = '\0';

	return out_str;
}

__forceinline BYTE* DecompressBytes(STUB_FUNCTION_TABLE* f, CHARS_CODES_LIST* list_tail, BYTE* compressed_bytes, DWORD compressed_bytes_count, DWORD initial_bytes_count)
{
	BYTE* out_bytes = nullptr;
	SIZE_T bytes_count = initial_bytes_count;

	if (NT_FAIL(f->NtAllocateVirtualMemory(NtCurrentProcess(), (void**)&out_bytes, NULL, &bytes_count, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)))
	{
		return nullptr;
	}

	if (!out_bytes)
	{
		return nullptr;
	}

	DWORD readed_bytes = 0;
	char key[KEY_MAX_LEN];

	f->RtlZeroMemory(key, KEY_MAX_LEN);

	for (DWORD i = 0; readed_bytes < initial_bytes_count; ++i)
	{
		char* bits = ByteToBitsInString(f, compressed_bytes[i]);
		
		if (!bits)
		{
			return nullptr;
		}

		for (DWORD j = 0; j < BYTE_SIZE_IN_BITS; j++)
		{
			__strcat(key, bits[j]);

			auto* node = FindCharCodeInList(list_tail, key);

			if (node)
			{
				out_bytes[readed_bytes] = node->ch;
				f->RtlZeroMemory(key, KEY_MAX_LEN);
				++readed_bytes;
			}
		}

		_FreeHeap(f, bits);
	}

	return out_bytes;
}
```

`includes.h`:

```h
#pragma once

#include <Windows.h>
#include <iostream>
#include <filesystem>
#include <fstream>
#include <WinInet.h>
#include <dbghelp.h>
#include <locale>
#include <codecvt>
#include <string>
#include <map>
#include <unordered_map>
#include <vector>
#include <algorithm>
#include <queue>
#include "strings_init.h"
#include "namespaces.h"
#include "tools.h"
#include "nt_defs.h"
#include "nt_funcs.h"
#include "pack_file.h"
#include "huffman_compressor_internal.h"
#include "unpacker_stub.h"
#include "huffman_decompressor_stub.h"

#pragma warning(disable : 4996)
```

`main.cpp`:

```cpp
#include "includes.h"

#ifdef _WIN64
const wchar_t file_path[] = L"C:\\Users\\Andrew\\Desktop\\Programming\\cpp\\garbage\\test_for_injection\\x64\\Release\\test_for_injection.exe";
#else
const wchar_t file_path[] = L"C:\\Users\\Andrew\\Desktop\\Programming\\cpp\\garbage\\test_for_injection\\Release\\test_for_injection.exe";
#endif

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)
{
	if (!AllocConsole())
	{
		return 1;
	}

	if (!SetConsoleTitleW(L"exe_packer.exe"))
	{
		return 1;
	}

	FILE* con_out = nullptr;
	if (freopen_s(&con_out, "CONOUT$", "w", stdout) || !con_out)
	{
		if (con_out)
		{
			fclose(con_out);
		}

		return 1;
	}

	if (!PackFile(file_path))
	{
		fclose(con_out);

		return 1;
	}

	fclose(con_out);
	
	return 0;
}
```

`namespaces.h`:

```h
#pragma once

namespace fs = std::filesystem;
```

`nt_defs.h`:

```h
#pragma once

#include <Windows.h>

#pragma region nt (un)defines

#ifndef NT_FAIL
#define NT_FAIL(status) (status < 0)
#endif

#define INIT_ANSI_STRING(ansi_str, arr) \
ansi_str.szBuffer = arr; \
ansi_str.Length = sizeof(arr); \
ansi_str.MaxLength = MAX_PATH;

#ifndef NT_SUCCESS
#define NT_SUCCESS(status) (status >= 0)
#endif

#define NtCurrentThread() ((HANDLE)(LONG_PTR)-2)

#ifdef memmove
#undef memmove
#endif

#ifdef RtlZeroMemory
#undef RtlZeroMemory
#endif

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED	0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH	0x00000002 //broken?!
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER	0x00000004

#define OBJ_CASE_INSENSITIVE 0x00000040

#define STATUS_SUCCESS				0x00000000
#define STATUS_UNSUCCESSFUL			0xC0000001
#define STATUS_NOT_IMPLEMENTED		0xC0000002
#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004
#define STATUS_ALREADY_COMMITTED    0xC0000021

#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020

#define InitializeObjectAttributes(p, n, a, r, s) \
{ \
	(p)->Length = sizeof(OBJECT_ATTRIBUTES); \
	(p)->RootDirectory				= r; \
	(p)->Attributes					= a; \
	(p)->ObjectName					= n; \
	(p)->SecurityDescriptor			= s; \
	(p)->SecurityQualityOfService	= NULL; \
}

struct PEB;

typedef PEB* PPEB;
typedef LONG KPRIORITY;

#define KUSER_SHARED_DATA (DWORD)0x7FFE0000
#define P_KUSER_SHARED_DATA_COOKIE (DWORD*)(KUSER_SHARED_DATA + 0x0330)

#define NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 ) 

#pragma endregion

#pragma region LdrLoadDll flags

#define DONT_RESOLVE_DLL_REFERENCES         0x00000001
#define LOAD_LIBRARY_AS_DATAFILE            0x00000002
// reserved for internal LOAD_PACKAGED_LIBRARY: 0x00000004
#define LOAD_WITH_ALTERED_SEARCH_PATH       0x00000008
#define LOAD_IGNORE_CODE_AUTHZ_LEVEL        0x00000010
#define LOAD_LIBRARY_AS_IMAGE_RESOURCE      0x00000020
#define LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE  0x00000040
#define LOAD_LIBRARY_REQUIRE_SIGNED_TARGET  0x00000080
#define LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR    0x00000100
#define LOAD_LIBRARY_SEARCH_APPLICATION_DIR 0x00000200
#define LOAD_LIBRARY_SEARCH_USER_DIRS       0x00000400
#define LOAD_LIBRARY_SEARCH_SYSTEM32        0x00000800
#define LOAD_LIBRARY_SEARCH_DEFAULT_DIRS    0x00001000

#if (NTDDI_VERSION >= NTDDI_WIN10_RS1)

#define LOAD_LIBRARY_SAFE_CURRENT_DIRS      0x00002000

#define LOAD_LIBRARY_SEARCH_SYSTEM32_NO_FORWARDER   0x00004000

#else

#endif

//
// For anything building for downlevel, set the flag to be the same as LOAD_LIBRARY_SEARCH_SYSTEM32
// such that they're treated the same when running on older version of OS.
//

#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)

#define LOAD_LIBRARY_OS_INTEGRITY_CONTINUITY   0x00008000

#endif

#pragma endregion

#pragma region enums

typedef enum class _PROCESSINFOCLASS
{
	ProcessBasicInformation = 0,
	ProcessSessionInformation = 24,
	ProcessWow64Information = 26,
	ProcessCookie = 36,
	ProcessProtectionInformation = 61
} PROCESSINFOCLASS;

typedef enum class _SYSTEM_INFORMATION_CLASS {

	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemNextEventIdInformation,
	SystemEventIdsInformation,
	SystemCrashDumpInformation,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,
	SystemPrioritySeperation,
	SystemPlugPlayBusInformation,
	SystemDockInformation,
	SystemPowerInformation,
	SystemProcessorSpeedInformation,
	SystemCurrentTimeZoneInformation,
	SystemLookasideInformation

} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef enum class _THREADINFOCLASS
{
	ThreadBasicInformation = 0,
	ThreadQuerySetWin32StartAddress = 9
} THREADINFOCLASS;

typedef enum class _THREAD_STATE
{
	Running = 0x02,
	Waiting = 0x05
} THREAD_STATE;

typedef enum class _KWAIT_REASON
{
	Executive,
	FreePage,
	PageIn,
	PoolAllocation,
	DelayExecution,
	Suspended,
	UserRequest,
	WrExecutive,
	WrFreePage,
	WrPageIn,
	WrPoolAllocation,
	WrDelayExecution,
	WrSuspended,
	WrUserRequest,
	WrEventPair,
	WrQueue,
	WrLpcReceive,
	WrLpcReply,
	WrVirtualMemory,
	WrPageOut,
	WrRendezvous,
	Spare2,
	Spare3,
	Spare4,
	Spare5,
	Spare6,
	WrKernel,
	MaximumWaitReason
} KWAIT_REASON;

typedef enum class _OBEJECT_TYPE_NUMBER
{
	Process = 0x07
} OBJECT_TYPE_NUMBER;

typedef enum _FILE_INFORMATION_CLASS
{
	FileStandardInformation = 5,
	FilePositionInformation = 14
} FILE_INFORMATION_CLASS, * PFILE_INFORMATION_CLASS;

typedef enum _LDR_DDAG_STATE : int
{
	LdrModulesMerged = -5,
	LdrModulesInitError = -4,
	LdrModulesSnapError = -3,
	LdrModulesUnloaded = -2,
	LdrModulesUnloading = -1,
	LdrModulesPlaceHolder = 0,
	LdrModulesMapping = 1,
	LdrModulesMapped = 2,
	LdrModulesWaitingForDependencies = 3,
	LdrModulesSnapping = 4,
	LdrModulesSnapped = 5,
	LdrModulesCondensed = 6,
	LdrModulesReadyToInit = 7,
	LdrModulesInitializing = 8,
	LdrModulesReadyToRun = 9
} LDR_DDAG_STATE, * PLDR_DDAG_STATE;

typedef enum _LDR_DLL_LOAD_REASON : int
{
	LoadReasonUnknown = -1,
	LoadReasonStaticDependency = 0,
	LoadReasonStaticForwarderDependency = 1,
	LoadReasonDynamicForwarderDependency = 2,
	LoadReasonDelayloadDependency = 3,
	LoadReasonDynamicLoad = 4,
	LoadReasonAsImageLoad = 5,
	LoadReasonAsDataLoad = 6,
	LoadReasonEnclavePrimary = 7,
	LoadReasonEnclaveDependency = 8
} LDR_DLL_LOAD_REASON, * PLDR_DLL_LOAD_REASON;

typedef enum _SECTION_INHERIT
{
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT, * PSECTION_INHERIT;

typedef enum _LDR_HOT_PATCH_STATE
{
	LdrHotPatchBaseImage = 0,
	LdrHotPatchNotApplied = 1,
	LdrHotPatchAppliedReverse = 2,
	LdrHotPatchAppliedForward = 3,
	LdrHotPatchFailedToPatch = 4,
	LdrHotPatchStateMax = 5
} LDR_HOT_PATCH_STATE, * PLDR_HOT_PATCH_STATE;

#pragma endregion

typedef struct _ANSI_STRING
{
	USHORT	Length;
	USHORT	MaxLength;
	char* szBuffer;
} ANSI_STRING, * PANSI_STRING;

typedef struct _UNICODE_STRING
{
	WORD		Length;
	WORD		MaxLength;
	wchar_t* szBuffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _RTL_BALANCED_NODE
{
	union
	{
		struct _RTL_BALANCED_NODE* Children[2];
		struct
		{
			struct _RTL_BALANCED_NODE* Left;
			struct _RTL_BALANCED_NODE* Right;
		};
	};

	union
	{
		UCHAR Red : 1;
		UCHAR Balance : 2;
		ULONG_PTR ParentValue;
	};
} RTL_BALANCED_NODE, * PRTL_BALANCED_NODE;

typedef struct _RTL_RB_TREE
{
	RTL_BALANCED_NODE* Root;
	RTL_BALANCED_NODE* Min;
} RTL_RB_TREE, * PRTL_RB_TREE;

typedef struct _CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	WORD		UniqueProcessId;
	WORD		CreateBackTraceIndex;
	BYTE		ObjectTypeIndex;
	BYTE		HandleAttributes;
	WORD		HandleValue;
	void* Object;
	ULONG		GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _THREAD_BASIC_INFORMATION
{
	NTSTATUS	ExitStatus;
	PVOID		TebBaseAddress;
	CLIENT_ID	ClientId;
	KAFFINITY	AffinityMask;
	KPRIORITY	Priority;
	KPRIORITY	BasePriority;
} THREAD_BASIC_INFORMATION, * PTHREAD_BASIC_INFORMATION;

typedef struct _PROCESS_BASIC_INFORMATION
{
	NTSTATUS	ExitStatus;
	PEB* pPEB;
	ULONG_PTR	AffinityMask;
	LONG		BasePriority;
	HANDLE		UniqueProcessId;
	HANDLE		InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, * PPROCESS_BASIC_INFORMATION;

typedef struct _PROCESS_SESSION_INFORMATION
{
	ULONG SessionId;
} PROCESS_SESSION_INFORMATION, * PPROCESS_SESSION_INFORMATION;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER	KernelTime;
	LARGE_INTEGER	UserTime;
	LARGE_INTEGER	CreateTime;
	ULONG			WaitTime;
	PVOID			StartAddress;
	CLIENT_ID		ClientId;
	KPRIORITY		Priority;
	LONG			BasePriority;
	ULONG			ContextSwitches;
	THREAD_STATE	ThreadState;
	KWAIT_REASON	WaitReason;
} SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
	ULONG			NextEntryOffset;
	ULONG			NumberOfThreads;
	LARGE_INTEGER	WorkingSetPrivateSize;
	ULONG			HardFaultCount;
	ULONG			NumberOfThreadsHighWatermark;
	ULONGLONG		CycleTime;
	LARGE_INTEGER	CreateTime;
	LARGE_INTEGER	UserTime;
	LARGE_INTEGER	KernelTime;
	UNICODE_STRING	ImageName;
	KPRIORITY		BasePriority;
	HANDLE			UniqueProcessId;
	HANDLE			InheritedFromUniqueProcessId;
	ULONG			HandleCount;
	ULONG			SessionId;
	ULONG_PTR		UniqueProcessKey;
	SIZE_T			PeakVirtualSize;
	SIZE_T			VirtualSize;
	ULONG			PageFaultCount;
	SIZE_T 			PeakWorkingSetSize;
	SIZE_T			WorkingSetSize;
	SIZE_T			QuotaPeakPagedPoolUsage;
	SIZE_T 			QuotaPagedPoolUsage;
	SIZE_T 			QuotaPeakNonPagedPoolUsage;
	SIZE_T 			QuotaNonPagedPoolUsage;
	SIZE_T 			PagefileUsage;
	SIZE_T 			PeakPagefileUsage;
	SIZE_T 			PrivatePageCount;
	LARGE_INTEGER	ReadOperationCount;
	LARGE_INTEGER	WriteOperationCount;
	LARGE_INTEGER	OtherOperationCount;
	LARGE_INTEGER 	ReadTransferCount;
	LARGE_INTEGER	WriteTransferCount;
	LARGE_INTEGER	OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION
{
	LARGE_INTEGER AllocationSize;
	LARGE_INTEGER EndOfFile;
	ULONG         NumberOfLinks;
	BOOLEAN       DeletePending;
	BOOLEAN       Directory;
} FILE_STANDARD_INFORMATION, * PFILE_STANDARD_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION
{
	LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, * PFILE_POSITION_INFORMATION;

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG				Length;
	HANDLE				RootDirectory;
	UNICODE_STRING* ObjectName;
	ULONG				Attributes;
	PVOID				SecurityDescriptor;
	PVOID				SecurityQualityOfService;
}  OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK
{
	union
	{
		NTSTATUS	Status;
		PVOID		Pointer;
	} DUMMYUNIONNAME;

	ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

typedef struct _PEB_LDR_DATA
{
	ULONG		Length;
	ULONG		Initialized; // may be BOOLEAN but in my system this 4 bytes long
	HANDLE		SsHandle;
	LIST_ENTRY	InLoadOrderModuleListHead;
	LIST_ENTRY	InMemoryOrderModuleListHead;
	LIST_ENTRY	InInitializationOrderModuleListHead;
	PVOID		EntryInProgress;
	BYTE		ShutdownInProgress;
	HANDLE		ShutdownThreadId;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

struct PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;

	union
	{
		UCHAR BitField;
		struct
		{
			UCHAR ImageUsedLargePages : 1;
			UCHAR IsProtectedProcess : 1;
			UCHAR IsImageDynamicallyRelocated : 1;
			UCHAR SkipPatchingUser32Forwarders : 1;
			UCHAR IsPackagedProcess : 1;
			UCHAR IsAppContainer : 1;
			UCHAR IsProtectedProcessLight : 1;
			UCHAR IsLongPathAwareProcess : 1;
		};
	};

	HANDLE Mutant;

	PVOID ImageBaseAddress;

	PEB_LDR_DATA* Ldr;

	PVOID* ProcessParameters;
	PVOID						SubSystemData;
	HANDLE						ProcessHeap;
	RTL_CRITICAL_SECTION* FastPebLock;
	PVOID						AtlThunkSListPtr;
	PVOID						IFEOKey;

	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ProcessPreviouslyThrottled : 1;
			ULONG ProcessCurrentlyThrottled : 1;
			ULONG ProcessImagesHotPatched : 1;
			ULONG ReservedBits0 : 24;
		};
	};

#ifdef _WIN64
	UCHAR Padding1[4];
#endif

	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	};

	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
	ULONG TlsExpansionCounter;

#ifdef _WIN64
	UCHAR Padding2[4];
#endif

	PVOID TlsBitmap;
	ULONG TlsBitmapBits[2];
	PVOID ReadOnlySharedMemoryBase;

	union
	{
		PVOID HotpatchInformation;	// till Win8
		PVOID SparePvoid0;			// Win8.1 -> Win10 (1607)
		PVOID SharedData;			// Win10 (1703) +
	};

	PVOID* ReadOnlyStaticServerData;
	PVOID AnsiCodePageData;
	PVOID OemCodePageData;
	PVOID UnicodeCaseTableData;
	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;
	LARGE_INTEGER CriticalSectionTimeout;
	ULONG_PTR HeapSegmentReserve;
	ULONG_PTR HeapSegmentCommit;
	ULONG_PTR HeapDeCommitTotalFreeThreshold;
	ULONG_PTR HeapDeCommitFreeBlockThreshold;
	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	PVOID* ProcessHeaps;
	PVOID GdiSharedHandleTable;
	PVOID ProcessStarterHelper;
	ULONG GdiDCAttributeList;

#ifdef _WIN64
	UCHAR Padding3[4];
#endif

	RTL_CRITICAL_SECTION* LoaderLock;
	ULONG OSMajorVersion;
	ULONG OSMinorVersion;

	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
};

typedef struct _LDR_SERVICE_TAG_RECORD
{
	struct _LDR_SERVICE_TAG_RECORD* Next;
	ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, * PLDR_SERVICE_TAG_RECORD;

typedef struct _LDRP_CSLIST
{
	struct _SINGLE_LIST_ENTRY* Tail;
} LDRP_CSLIST, * PLDRP_CSLIST;

typedef struct _LDRP_UNICODE_STRING_BUNDLE
{
	UNICODE_STRING	String;
	WCHAR			StaticBuffer[128];
} LDRP_UNICODE_STRING_BUNDLE, * PLDRP_UNICODE_STRING_BUNDLE;

typedef struct _RTL_INVERTED_FUNCTION_TABLE_ENTRY
{
	IMAGE_RUNTIME_FUNCTION_ENTRY* ExceptionDirectory;
	PVOID							ImageBase;
	ULONG							ImageSize;
	ULONG							ExceptionDirectorySize;
} RTL_INVERTED_FUNCTION_TABLE_ENTRY, * PRTL_INVERTED_FUNCTION_TABLE_ENTRY;

typedef struct _RTL_INVERTED_FUNCTION_TABLE
{
	ULONG Count;
	ULONG MaxCount;
	ULONG Epoch;
	UCHAR Overflow;
	RTL_INVERTED_FUNCTION_TABLE_ENTRY Entries[ANYSIZE_ARRAY];
} RTL_INVERTED_FUNCTION_TABLE, * PRTL_INVERTED_FUNCTION_TABLE;

typedef union _LDR_SEARCH_PATH
{
	BOOLEAN NoPath : 1;
	wchar_t* szSearchPath;
} LDR_SEARCH_PATH, * PLDR_SEARCH_PATH;

//Win10 1511
typedef struct _LDRP_PATH_SEARCH_CONTEXT_1511
{
	wchar_t* DllSearchPathOut;
	void* Unknown_0[2];
	wchar_t* OriginalFullDllName;
	void* unknown_1[7];
	ULONG64		unknown_2[4];
} LDRP_PATH_SEARCH_CONTEXT_1511, * PLDRP_PATH_SEARCH_CONTEXT_1511; //x86 size = 0x4C, x64 size = 0x78

//Win10 1507, 1607+
typedef struct _LDRP_PATH_SEARCH_CONTEXT
{
	wchar_t* DllSearchPathOut;
	void* Unknown_0[3];
	wchar_t* OriginalFullDllName;
	void* unknown_1[7];
	ULONG64		unknown_2[4];
} LDRP_PATH_SEARCH_CONTEXT, * PLDRP_PATH_SEARCH_CONTEXT; //x86 size <= 0x50, x64 size <= 0x80

typedef union _LDRP_LOAD_CONTEXT_FLAGS
{
	ULONG32 Flags;
	struct
	{
		ULONG32 Redirected : 1;
		ULONG32 Static : 1;
		ULONG32 BaseNameOnly : 1;
		ULONG32 HasFullPath : 1;
		ULONG32 KnownDll : 1;
		ULONG32 SystemImage : 1;
		ULONG32 ExecutableImage : 1;
		ULONG32 AppContainerImage : 1;
		ULONG32 CallInit : 1;
		ULONG32 UserAllocated : 1;
		ULONG32 SearchOnlyFirstPathSegment : 1;
		ULONG32 RedirectedByAPISet : 1;
	};
} LDRP_LOAD_CONTEXT_FLAGS, * PLDRP_LOAD_CONTEXT_FLAGS;

typedef struct _RTL_VECTORED_HANDLER_LIST
{
	SRWLOCK     Lock;
	LIST_ENTRY  List;
} RTL_VECTORED_HANDLER_LIST, * PRTL_VECTORED_HANDLER_LIST;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY //Win7 till Win10 1909
{
	LIST_ENTRY					List;
	DWORD						Flag;
	PVECTORED_EXCEPTION_HANDLER	VectoredHandler;
} RTL_VECTORED_EXCEPTION_ENTRY, * PRTL_VECTORED_EXCEPTION_ENTRY;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004 //Win10 2004+
{
	LIST_ENTRY                  List;
	PULONG_PTR                  pFlag; //points to Flag
	ULONG                       RefCount;
	PVECTORED_EXCEPTION_HANDLER VectoredHandler;
	ULONG_PTR					Flag; //normally allocated somewhere else on LdrpMrdataHeap, just for convenience
} RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004, * PRTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004;

typedef struct _TLS_ENTRY
{
	LIST_ENTRY				TlsEntryLinks;
	IMAGE_TLS_DIRECTORY		TlsDirectory;
	PVOID 					ModuleEntry; //LdrDataTableEntry
	SIZE_T					TlsIndex;
} TLS_ENTRY, * PTLS_ENTRY;

typedef struct _TEB
{
	NT_TIB                  Tib;
	PVOID                   EnvironmentPointer;
	CLIENT_ID               Cid;
	PVOID                   ActiveRpcInfo;
	PVOID                   ThreadLocalStoragePointer;
	PPEB                    Peb;
	ULONG                   LastErrorValue;
	ULONG                   CountOfOwnedCriticalSections;
	PVOID                   CsrClientThread;
	PVOID                   Win32ThreadInfo;
	ULONG                   Win32ClientInfo[0x1F];
	PVOID                   WOW32Reserved;
	ULONG                   CurrentLocale;
	ULONG                   FpSoftwareStatusRegister;
	PVOID                   SystemReserved1[0x36];
	PVOID                   Spare1;
	ULONG                   ExceptionCode;
	ULONG                   SpareBytes1[0x28];
	PVOID                   SystemReserved2[0xA];
	ULONG                   GdiRgn;
	ULONG                   GdiPen;
	ULONG                   GdiBrush;
	CLIENT_ID               RealClientId;
	PVOID                   GdiCachedProcessHandle;
	ULONG                   GdiClientPID;
	ULONG                   GdiClientTID;
	PVOID                   GdiThreadLocaleInfo;
	PVOID                   UserReserved[5];
	PVOID                   GlDispatchTable[0x118];
	ULONG                   GlReserved1[0x1A];
	PVOID                   GlReserved2;
	PVOID                   GlSectionInfo;
	PVOID                   GlSection;
	PVOID                   GlTable;
	PVOID                   GlCurrentRC;
	PVOID                   GlContext;
	NTSTATUS                LastStatusValue;
	UNICODE_STRING          StaticUnicodeString;
	WCHAR                   StaticUnicodeBuffer[0x105];
	PVOID                   DeallocationStack;
	PVOID                   TlsSlots[0x40];
	LIST_ENTRY              TlsLinks;
	PVOID                   Vdm;
	PVOID                   ReservedForNtRpc;
	PVOID                   DbgSsReserved[0x2];
	ULONG                   HardErrorDisabled;
	PVOID                   Instrumentation[0x10];
	PVOID                   WinSockData;
	ULONG                   GdiBatchCount;
	ULONG                   Spare2;
	ULONG                   Spare3;
	ULONG                   Spare4;
	PVOID                   ReservedForOle;
	ULONG                   WaitingOnLoaderLock;
	PVOID                   StackCommit;
	PVOID                   StackCommitMax;
	PVOID                   StackReserved;

} TEB, * PTEB;

typedef struct _PUBLIC_OBJECT_BASIC_INFORMATION {
	ULONG       Attributes;
	ACCESS_MASK GrantedAccess;
	ULONG       HandleCount;
	ULONG       PointerCount;
	ULONG       Reserved[10];
} PUBLIC_OBJECT_BASIC_INFORMATION, * PPUBLIC_OBJECT_BASIC_INFORMATION;

typedef enum _OBJECT_INFORMATION_CLASS {
	ObjectBasicInformation,
	ObjectTypeInformation
} OBJECT_INFORMATION_CLASS;

#ifdef _WIN64

typedef __declspec(align(4)) struct _UNICODE_STRING_32
{
	WORD	Length;
	WORD	MaxLength;
	DWORD	szBuffer;
} UNICODE_STRING_32, * PUNICODE_STRING_32;

typedef __declspec(align(4)) struct _RTL_BALANCED_NODE_32
{
	union
	{
		DWORD Children[2];
		struct
		{
			DWORD Left;
			DWORD Right;
		};
	};

	union
	{
		UCHAR Red : 1;
		UCHAR Balance : 2;
		DWORD ParentValue;
	};
} RTL_BALANCED_NODE_32, * PRTL_BALANCED_NODE_32;

typedef struct _SINGLE_LIST_ENTRY_32
{
	DWORD Next; // -> SINGLE_LIST_ENTRY_32
} SINGLE_LIST_ENTRY_32, * PSINGLE_LIST_ENTRY_32;

typedef __declspec(align(4)) struct _LDR_SERVICE_TAG_RECORD_32
{
	DWORD Next; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD_32, * PLDR_SERVICE_TAG_RECORD_32;

typedef __declspec(align(4)) struct _LDRP_CSLIST_32
{
	DWORD Tail; // -> SINGLE_LIST_ENTRY_32
} LDRP_CSLIST_32, * PLDRP_CSLIST_32;

typedef __declspec(align(4)) struct _RTL_CRITICAL_SECTION_32
{
	DWORD	DebugInfo; // -> RTL_CRITICAL_SECTION_DEBUG_32
	LONG	LockCount;
	LONG	RecursionCount;
	DWORD	OwningThread;
	DWORD	LockSemaphore;
	DWORD	SpinCount;
} RTL_CRITICAL_SECTION_32, * PRTL_CRITICAL_SECTION_32;

typedef __declspec(align(4)) struct _RTL_CRITICAL_SECTION_DEBUG_32
{
	WORD			Type;
	WORD			CreatorBackTraceIndex;
	DWORD			CriticalSection; // -> RTL_CRITICAL_SECTION_32
	LIST_ENTRY32	ProcessLocksList;
	DWORD			EntryCount;
	DWORD			ContentionCount;
	DWORD			Flags;
	WORD			CreatorBackTraceIndexHigh;
	WORD			SpareWORD;
} RTL_CRITICAL_SECTION_DEBUG_32, * PRTL_CRITICAL_SECTION_DEBUG_32, _RTL_RESOURCE_DEBUG_32, RTL_RESOURCE_DEBUG_32, * PRTL_RESOURCE_DEBUG_32;

typedef __declspec(align(4)) struct _PEB_LDR_DATA_32
{
	ULONG			Length;
	BYTE			Initialized;
	DWORD			SsHandle;
	LIST_ENTRY32	InLoadOrderModuleListHead;
	LIST_ENTRY32	InMemoryOrderModuleListHead;
	LIST_ENTRY32	InInitializationOrderModuleListHead;
	DWORD			EntryInProgress;
	BYTE			ShutdownInProgress;
	DWORD			ShutdownThreadId;
} PEB_LDR_DATA_32, * PPEB_LDR_DATA_32;

typedef struct _PEB_32
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;

	union
	{
		UCHAR BitField;
		struct
		{
			UCHAR ImageUsedLargePages : 1;
			UCHAR IsProtectedProcess : 1;
			UCHAR IsImageDynamicallyRelocated : 1;
			UCHAR SkipPatchingUser32Forwarders : 1;
			UCHAR IsPackagedProcess : 1;
			UCHAR IsAppContainer : 1;
			UCHAR IsProtectedProcessLight : 1;
			UCHAR IsLongPathAwareProcess : 1;
		};
	};

	DWORD Mutant;

	DWORD ImageBaseAddress;
	DWORD Ldr; // -> PEB_LDR_DATA_32

	DWORD ProcessParameters;
	DWORD SubSystemData;
	DWORD ProcessHeap;
	DWORD FastPebLock; // -> RTL_CRITICAL_SECTION_32
	DWORD AtlThunkSListPtr;
	DWORD IFEOKey;

	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ProcessPreviouslyThrottled : 1;
			ULONG ProcessCurrentlyThrottled : 1;
			ULONG ProcessImagesHotPatched : 1;
			ULONG ReservedBits0 : 24;
		};
	};

	union
	{
		DWORD KernelCallbackTable;
		DWORD UserSharedInfoPtr;
	};

	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	DWORD ApiSetMap;
	ULONG TlsExpansionCounter;

	DWORD TlsBitmap;
	ULONG TlsBitmapBits[2];
	DWORD ReadOnlySharedMemoryBase;

	union
	{
		DWORD HotpatchInformation;	// till Win8
		DWORD SparePvoid0;			// Win8.1 -> Win10 (1607)
		DWORD SharedData;			// Win10 (1703) +
	};

	DWORD ReadOnlyStaticServerData;
	DWORD AnsiCodePageData;
	DWORD OemCodePageData;
	DWORD UnicodeCaseTableData;
	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;
	LARGE_INTEGER CriticalSectionTimeout;
	DWORD HeapSegmentReserve;
	DWORD HeapSegmentCommit;
	DWORD HeapDeCommitTotalFreeThreshold;
	DWORD HeapDeCommitFreeBlockThreshold;
	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	DWORD ProcessHeaps;
	DWORD GdiSharedHandleTable;
	DWORD ProcessStarterHelper;
	ULONG GdiDCAttributeList;

	DWORD LoaderLock; // -> RTL_CRITICAL_SECTION_32
	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
} PEB_32, * PPEB_32;

typedef __declspec(align(4)) struct _LDRP_UNICODE_STRING_BUNDLE_32
{
	UNICODE_STRING_32	String;
	WCHAR				StaticBuffer[128];
} LDRP_UNICODE_STRING_BUNDLE_32, * PLDRP_UNICODE_STRING_BUNDLE_32;

typedef __declspec(align(4)) struct _LDRP_PATH_SEARCH_CONTEXT_32 //dummy structure, needs to be at least 0x50 bytes in size, members don't matter
{
	DWORD DllSearchPathOut; // wchar_t *
	DWORD unknown_0[3];
	DWORD OriginalFullDllName; // wchar_t *
	DWORD unknown_1[15];
} LDRP_PATH_SEARCH_CONTEXT_32, * PLDRP_PATH_SEARCH_CONTEXT_32;

typedef __declspec(align(4)) struct _RTL_INVERTED_FUNCTION_TABLE_ENTRY_32
{
	DWORD ExceptionDirectory; // -> IMAGE_RUNTIME_FUNCTION_ENTRY
	DWORD ImageBase;
	ULONG ImageSize;
	ULONG ExceptionDirectorySize;
} RTL_INVERTED_FUNCTION_TABLE_ENTRY_32, * PRTL_INVERTED_FUNCTION_TABLE_ENTRY_32;

typedef __declspec(align(4)) struct _RTL_INVERTED_FUNCTION_TABLE_32
{
	ULONG Count;
	ULONG MaxCount;
	ULONG Epoch;
	UCHAR Overflow;
	RTL_INVERTED_FUNCTION_TABLE_ENTRY_32 Entries[ANYSIZE_ARRAY];
} RTL_INVERTED_FUNCTION_TABLE_32, * PRTL_INVERTED_FUNCTION_TABLE_32;

typedef __declspec(align(4)) union _LDRP_PATH_SEARCH_OPTIONS_32
{
	ULONG32 Flags;

	struct
	{
		ULONG32 Unknown;
	};
} LDRP_PATH_SEARCH_OPTIONS_32, * PLDRP_PATH_SEARCH_OPTIONS_32;

typedef __declspec(align(4)) union _LDRP_LOAD_CONTEXT_FLAGS_32
{
	ULONG32 Flags;
	struct
	{
		ULONG32 Redirected : 1;
		ULONG32 BaseNameOnly : 1;
		ULONG32 HasFullPath : 1;
		ULONG32 KnownDll : 1;
		ULONG32 SystemImage : 1;
		ULONG32 ExecutableImage : 1;
		ULONG32 AppContainerImage : 1;
		ULONG32 CallInit : 1;
		ULONG32 UserAllocated : 1;
		ULONG32 SearchOnlyFirstPathSegment : 1;
		ULONG32 RedirectedByAPISet : 1;
	};
} LDRP_LOAD_CONTEXT_FLAGS_32, * PLDRP_LOAD_CONTEXT_FLAGS_32;

typedef struct _RTL_VECTORED_HANDLER_LIST_32
{
	DWORD			Lock;
	LIST_ENTRY32	List;
} RTL_VECTORED_HANDLER_LIST_32, * PRTL_VECTORED_HANDLER_LIST_32;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY_32 //Win7 till Win10 1909
{
	LIST_ENTRY32	List;
	DWORD			Flag;
	DWORD			VectoredHandler;
} RTL_VECTORED_EXCEPTION_ENTRY_32, * PRTL_VECTORED_EXCEPTION_ENTRY_32;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32 //Win10 2004+
{
	LIST_ENTRY32	List;
	DWORD			pFlag; //DWORD *
	ULONG			RefCount;
	DWORD			VectoredHandler; //PVECTORED_EXCEPTION_HANDLER
	DWORD			Flag;
} RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32, * PRTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32;

#endif
```

`nt_funcs.h`:

```h
#pragma once

#include "win_7.h"
#include "win_8.h"
#include "win_81.h"
#include "win_10.h"
#include "win_11.h"

#define DEF_STRUCT_DEFAULT(name, suffix)	\
using name		= name##suffix;				\
using P##name	= P##name##suffix;			\
using _##name	= _##name##suffix;

#define DEF_STRUCT_DEFAULT_32(name, suffix)	\
using name##_32		= name##suffix##_32;	\
using P##name##_32	= P##name##suffix##_32;	\
using _##name##_32	= _##name##suffix##_32;

#ifndef _WIN32_WINNT
#error Not supported
#else
#if(_WIN32_WINNT == _WIN32_WINNT_WIN7)
DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN7)
DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN7)

#ifdef _WIN64
DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN7)
DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN7)
#endif
#elif (_WIN32_WINNT == _WIN32_WINNT_WIN8)
DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN8)
DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN8)

#ifdef _WIN64
DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN8)
DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN8)
#endif
#elif (_WIN32_WINNT == _WIN32_WINNT_WINBLUE)
DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN81)
DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN81)

#ifdef _WIN64
DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN81)
DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN81)
#endif
#elif (_WIN32_WINNT == _WIN32_WINNT_WIN10) //includes Win11
#if (WDK_NTDDI_VERSION == NTDDI_WIN10_CO) //Win11 SDK is called NTDDI_WIN10_CO
DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN11)
DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN11)

#ifdef _WIN64
DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN11)
DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN11)
#endif
#else
DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN10)
DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN10)

#ifdef _WIN64
DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN10)
DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN10)
#endif
#endif
#else
#error Not supported
#endif
#endif

#pragma region function prototypes

using f_NtCreateThreadEx = NTSTATUS(__stdcall*)
(
	HANDLE* pHandle,
	ACCESS_MASK		DesiredAccess,
	void* pAttr,
	HANDLE			hTargetProc,
	void* pFunc,
	void* pArg,
	ULONG			Flags,
	SIZE_T			ZeroBits,
	SIZE_T			StackSize,
	SIZE_T			MaxStackSize,
	void* pAttrListOut
	);

using f_LdrLoadDll = NTSTATUS(__stdcall*)
(
	PWCHAR               PathToFile,
	ULONG* pFlags,
	UNICODE_STRING* pModuleFileName,
	HANDLE* pOut
	);

using f_LdrLoadDll_WIN8 = NTSTATUS(__stdcall*)
(
	BOOLEAN Unknown1, //set to TRUE
	ULONG* LoadFlags,
	UNICODE_STRING* pModuleFileName,
	HANDLE* pOut
	);

using f_LdrUnloadDll = NTSTATUS(__stdcall*)
(
	HANDLE DllHandle
	);

using f_LdrpLoadDll_WIN7 = NTSTATUS(__stdcall*)
(
	UNICODE_STRING* dll_path,
	UNICODE_STRING* search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	BOOLEAN							Unknown1, //set to TRUE
	PVOID							Unknown2, //can be nullptr
	LDR_DATA_TABLE_ENTRY_WIN7** ldr_out
	);

using f_LdrpLoadDll_WIN8 = NTSTATUS(__stdcall*)
(
	UNICODE_STRING* dll_path,
	LDRP_PATH_SEARCH_CONTEXT_WIN8* search_ctx,
	LDRP_LOAD_CONTEXT_FLAGS				Flags,
	BOOLEAN								Unknown, //set to TRUE
	LDR_DATA_TABLE_ENTRY_WIN8** entry_out,
	LDR_DDAG_NODE_WIN8** ddag_out
	);

using f_LdrpLoadDll_WIN81 = NTSTATUS(__fastcall*)
(
	UNICODE_STRING* dll_path,
	LDRP_PATH_SEARCH_CONTEXT_WIN81* search_ctx,
	LDRP_LOAD_CONTEXT_FLAGS				Flags,
	BOOLEAN								Unknown, //set to TRUE
	LDR_DATA_TABLE_ENTRY_WIN81** entry_out,
	LDR_DDAG_NODE_WIN81** ddag_out
	);

//1507-1803
using f_LdrpLoadDll_1507 = NTSTATUS(__fastcall*)
(
	UNICODE_STRING* dll_path,
	LDRP_PATH_SEARCH_CONTEXT* search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	BOOLEAN							bUnknown, //set to TRUE
	LDR_DATA_TABLE_ENTRY_WIN10** ldr_out
	);

//1809+
using f_LdrpLoadDll = NTSTATUS(__fastcall*)
(
	UNICODE_STRING* dll_path,
	LDRP_PATH_SEARCH_CONTEXT* search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	LDR_DATA_TABLE_ENTRY** ldr_out
	);

using f_LdrpLoadDllInternal = NTSTATUS(__fastcall*)
(
	UNICODE_STRING* dll_path,
	LDRP_PATH_SEARCH_CONTEXT* search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	ULONG32							Unknown0,	//set to 4
	LDR_DATA_TABLE_ENTRY_WIN10* Unknown1,	//set to nullptr
	LDR_DATA_TABLE_ENTRY_WIN10* Unknown2,	//set to nullptr
	LDR_DATA_TABLE_ENTRY_WIN10** ldr_out,
	ULONG_PTR* Unknown3	//set to pointer to nullptr
	);

using f_LdrpLoadDllInternal_WIN11 = NTSTATUS(__fastcall*)
(
	UNICODE_STRING* dll_path,
	LDRP_PATH_SEARCH_CONTEXT* search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	ULONG32							Unknown0,	//set to 4
	LDR_DATA_TABLE_ENTRY_WIN11* Unknown1,	//set to nullptr
	LDR_DATA_TABLE_ENTRY_WIN11* Unknown2,	//set to nullptr
	LDR_DATA_TABLE_ENTRY_WIN11** ldr_out,
	ULONG_PTR* Unknown3,	//set to pointer to nullptr
	ULONG							Unknown4	//set to 0
	);

using f_LdrGetDllHandleEx = NTSTATUS(__stdcall*)
(
	ULONG				Flags,
	PWSTR				OptDllPath,
	PULONG				OptDllCharacteristics,
	UNICODE_STRING* DllName,
	PVOID* DllHandle
	);

using f_LdrGetProcedureAddress = NTSTATUS(__stdcall*)
(
	PVOID				BaseAddress,
	ANSI_STRING* Name,
	ULONG				Ordinal,
	PVOID* ProcedureAddress
	);

using f_NtQueryInformationProcess = NTSTATUS(__stdcall*)
(
	HANDLE					hTargetProc,
	PROCESSINFOCLASS		PIC,
	void* pBuffer,
	ULONG					BufferSize,
	ULONG* SizeOut
	);

using f_NtQuerySystemInformation = NTSTATUS(__stdcall*)
(
	SYSTEM_INFORMATION_CLASS		SIC,
	void* pBuffer,
	ULONG							BufferSize,
	ULONG* SizeOut
	);

using f_NtQueryInformationThread = NTSTATUS(__stdcall*)
(
	HANDLE				hThread,
	THREADINFOCLASS		TIC,
	void* pBuffer,
	ULONG				BufferSize,
	ULONG* SizeOut
	);

using f_RtlQueueApcWow64Thread = NTSTATUS(__stdcall*)
(
	HANDLE		hThread,
	void* pRoutine,
	void* pArg1,
	void* pArg2,
	void* pArg3
	);

using f_LdrpPreprocessDllName = NTSTATUS(__fastcall*)
(
	UNICODE_STRING* DllName,
	LDRP_UNICODE_STRING_BUNDLE* OutputDllName,
	LDR_DATA_TABLE_ENTRY* pOptParentEntry,
	LDRP_LOAD_CONTEXT_FLAGS* LoadContextFlags
	);

using f_RtlInsertInvertedFunctionTable_WIN7 = NTSTATUS(__stdcall*)
(
	RTL_INVERTED_FUNCTION_TABLE_WIN7* pTable,
	void* ImageBase,
	DWORD								SizeOfImage
	);

using f_RtlInsertInvertedFunctionTable_WIN8 = NTSTATUS(__stdcall*)
(
	void* ImageBase,
	DWORD	SizeOfImage
	);

using f_RtlInsertInvertedFunctionTable = BOOL(__fastcall*)
(
	void* ImageBase,
	DWORD	SizeOfImage
	);

#ifdef _WIN64
using f_RtlAddFunctionTable = BOOL(__stdcall*)
(
	RUNTIME_FUNCTION* FunctionTable,
	DWORD				EntryCount,
	DWORD64				BaseAddress
	);
#endif

using f_LdrpHandleTlsData_WIN8 = NTSTATUS(__stdcall*)
(
	LDR_DATA_TABLE_ENTRY_WIN8* pEntry
	);

using f_LdrpHandleTlsData = NTSTATUS(__fastcall*)
(
	LDR_DATA_TABLE_ENTRY* pEntry
	);

using f_LdrLockLoaderLock = NTSTATUS(__stdcall*)
(
	ULONG			Flags,
	ULONG* State,
	ULONG_PTR* Cookie
	);

using f_LdrUnlockLoaderLock = NTSTATUS(__stdcall*)
(
	ULONG		Flags,
	ULONG_PTR	Cookie
	);

using f_memmove = VOID(__cdecl*)
(
	PVOID	UNALIGNED	Destination,
	LPCVOID	UNALIGNED	Source,
	SIZE_T				Length
	);

using f_RtlZeroMemory = VOID(__stdcall*)
(
	PVOID	UNALIGNED	Destination,
	SIZE_T				Length
	);

using f_RtlAllocateHeap = PVOID(__stdcall*)
(
	PVOID	HeapHandle,
	ULONG	Flags,
	SIZE_T	Size
	);

using f_RtlFreeHeap = BOOLEAN(__stdcall*)
(
	PVOID	HeapHandle,
	ULONG	Flags,
	PVOID	BaseAddress
	);

using f_RtlAnsiStringToUnicodeString = NTSTATUS(__stdcall*)
(
	UNICODE_STRING* DestinationString,
	ANSI_STRING* SourceString,
	BOOLEAN				AllocateDestinationString
	);

using f_RtlRbInsertNodeEx = VOID(__stdcall*)
(
	RTL_RB_TREE* Tree,
	RTL_BALANCED_NODE* Parent,
	BOOLEAN					Right,
	RTL_BALANCED_NODE* Node
	);

using f_RtlRbRemoveNode = VOID(__stdcall*)
(
	RTL_RB_TREE* pTree,
	RTL_BALANCED_NODE* pNode
	);

using f_NtOpenFile = NTSTATUS(__stdcall*)
(
	HANDLE* hFileOut,
	ACCESS_MASK				DesiredAccess,
	OBJECT_ATTRIBUTES* pAtrributes,
	IO_STATUS_BLOCK* pIoStatusBlock,
	ULONG					ShareAccess,
	ULONG					OpenOptions
	);

using f_NtReadFile = NTSTATUS(__stdcall*)
(
	HANDLE					FileHandle,
	HANDLE					hOptEvent,
	PVOID					pOptApc,
	PVOID					pOptApcContext,
	IO_STATUS_BLOCK* IoStatusBlock,
	PVOID					Buffer,
	ULONG					Length,
	LARGE_INTEGER* pOptByteOffset,
	ULONG* pOptKey
	);

using f_NtSetInformationFile = NTSTATUS(__stdcall*)
(
	HANDLE						FileHandle,
	IO_STATUS_BLOCK* IoStatusBlock,
	PVOID						FileInformation,
	ULONG						Length,
	FILE_INFORMATION_CLASS		FileInformationClass
	);

using f_NtQueryInformationFile = NTSTATUS(__stdcall*)
(
	HANDLE						FileHandle,
	IO_STATUS_BLOCK* pIoStatusBlock,
	PVOID						FileInformation,
	ULONG						Length,
	FILE_INFORMATION_CLASS		FileInformationClass
	);

using f_NtClose = NTSTATUS(__stdcall*)
(
	HANDLE Handle
	);

using f_NtAllocateVirtualMemory = NTSTATUS(__stdcall*)
(
	HANDLE			ProcessHandle,
	PVOID* BaseAddress,
	ULONG_PTR		ZeroBits,
	SIZE_T* RegionSize,
	ULONG			AllocationType,
	ULONG			Protect
	);

using f_NtFreeVirtualMemory = NTSTATUS(__stdcall*)
(
	HANDLE		ProcessHandle,
	PVOID* BaseAddress,
	SIZE_T* RegionSize,
	ULONG		FreeType
	);

using f_NtProtectVirtualMemory = NTSTATUS(__stdcall*)
(
	HANDLE		ProcessHandle,
	PVOID* BaseAddress,
	SIZE_T* Size,
	ULONG		NewAccess,
	ULONG* OldAccess
	);

using f_NtCreateSection = NTSTATUS(__stdcall*)
(
	HANDLE* SectionHandle,
	ACCESS_MASK				DesiredAccess,
	OBJECT_ATTRIBUTES* ObjectAttributes,
	LARGE_INTEGER* MaximumSize,
	ULONG					SectionPageProtection,
	ULONG					AllocationAttributes,
	HANDLE					FileHandle
);

using f_NtMapViewOfSection = NTSTATUS(__stdcall*)
(
	HANDLE				SectionHandle,
	HANDLE				ProcessHandle,
	PVOID* BaseAddress,
	ULONG_PTR			ZeroBits,
	SIZE_T				CommitSize,
	LARGE_INTEGER* SectionOffset,
	SIZE_T* ViewSize,
	SECTION_INHERIT		InheritDisposition,
	ULONG				AllocationType,
	ULONG				Win32Protect
);

using f_LdrProtectMrdata = VOID(__stdcall*)
(
	BOOL bProtected
);

using f_RtlAddVectoredExceptionHandler = PVOID(__stdcall*)
(
	ULONG						FirstHandler,
	PVECTORED_EXCEPTION_HANDLER VectoredHandler
);

using f_RtlRemoveVectoredExceptionHandler = ULONG(__stdcall*)
(
	PVOID Handle
);

using f_NtDelayExecution = NTSTATUS(__stdcall*)
(
	BOOLEAN			Alertable,
	LARGE_INTEGER* DelayInterval
);

using f_NtQueryObject = NTSTATUS(__stdcall*)
(
	HANDLE                   Handle,
	OBJECT_INFORMATION_CLASS ObjectInformationClass,
	PVOID                    ObjectInformation,
	ULONG                    ObjectInformationLength,
	PULONG                   ReturnLength
);

using f_RtlCreateHeap = PVOID(__stdcall*)
(
	ULONG   Flags,
	PVOID   HeapBase,
	SIZE_T  ReserveSize,
	SIZE_T  CommitSize,
	PVOID   Lock,
	PVOID	PRTL_HEAP_PARAMETER
);

using f_LdrShutdownProcess = void(__stdcall*)
(
	void
);

using f_NtContinue = NTSTATUS(__stdcall*)
(
	CONTEXT*     ThreadContext,
	BOOLEAN      RaiseAlert
);

using f_NtGetContextThread = NTSTATUS(__stdcall*)
(
	HANDLE              ThreadHandle,
	CONTEXT*            pContext
);

using f_memset = decltype(memset)*;

using f_LdrpModuleBaseAddressIndex = RTL_RB_TREE*;
using f_LdrpMappingInfoIndex = RTL_RB_TREE*;
using f_LdrpHeap = PVOID*;
using f_LdrpInvertedFunctionTable = RTL_INVERTED_FUNCTION_TABLE*;
using f_LdrpDefaultPath = UNICODE_STRING*;
using f_LdrpVectorHandlerList = RTL_VECTORED_HANDLER_LIST*;
using f_LdrpTlsList = LIST_ENTRY*;

//ntdll.dll:
using f_RtlpUnhandledExceptionFilter = ULONG_PTR*; //encrypted with RtlEncodePointer, points to kernel32.UnhandledExceptionFilter

//kernel32.dll:
using f_UnhandledExceptionFilter = ULONG_PTR*; //PTOP_LEVEL_EXCEPTION_FILTER 
using f_SingleHandler = ULONG_PTR*; //encrypted with RtlEncodePointer, points to kernel32.DefaultHandler
using f_DefaultHandler = ULONG_PTR*; //PTOP_LEVEL_EXCEPTION_FILTER 

#pragma endregion
```

`pack_file.cpp`:

```cpp
#include "includes.h"

void SetEntryPointAddress(std::vector<BYTE>* vec, DWORD entry_point_addr)
{
	BYTE* raw_ptr = vec->begin()._Ptr;

	IMAGE_OPTIONAL_HEADER* opt_header = &((IMAGE_NT_HEADERS*)(((IMAGE_DOS_HEADER*)raw_ptr)->e_lfanew + raw_ptr))->OptionalHeader;

	opt_header->AddressOfEntryPoint = entry_point_addr;
}

void GetSizeAndAddressOfSegmentInThisFile(const char* segment_name, DWORD64* out_virtual_address, DWORD* out_size)
{
	DWORD64 this_module_base = (DWORD64)GetModuleHandle(NULL);

	IMAGE_NT_HEADERS* this_file_nt_header = (IMAGE_NT_HEADERS*)(((IMAGE_DOS_HEADER*)this_module_base)->e_lfanew + this_module_base);

	IMAGE_SECTION_HEADER* sec = IMAGE_FIRST_SECTION(this_file_nt_header);

	for (DWORD i = 0; i < this_file_nt_header->FileHeader.NumberOfSections; ++i, ++sec)
	{
		if (!strcmp(segment_name, (char*)sec->Name))
		{
			*out_virtual_address = sec->VirtualAddress + this_module_base;
			*out_size = sec->Misc.VirtualSize;

			return;
		}
	}
}

void PushBytesInVector(std::vector<BYTE>* vec, void* ptr, DWORD size)
{
	BYTE* b_ptr = (BYTE*)ptr;

	for (DWORD i = 0; i < size; ++i)
	{
		vec->push_back(b_ptr[i]);
	}
}

void PushValueInVector(std::vector<BYTE>* vec, int value, DWORD size)
{
	for (DWORD i = 0; i < size; ++i)
	{
		vec->push_back(value);
	}
}

void PushBytesInVectorByAlignment(std::vector<BYTE>* vec, void* ptr, DWORD size, DWORD alignment)
{
	DWORD zero_align_count = ALIGN(size, alignment) - size;

	PushBytesInVector(vec, ptr, size);
	PushValueInVector(vec, 0, zero_align_count);
}

bool PackFile(const wchar_t* file_path)
{
#ifdef _WIN64
	WORD desired_machine = IMAGE_FILE_MACHINE_AMD64;
#else
	WORD desired_machine = IMAGE_FILE_MACHINE_I386;
#endif

	if (!VerifyFile(file_path, desired_machine, IMAGE_FILE_EXECUTABLE_IMAGE))
	{
		ERRLOG("Verification of the file failed");

		return false;
	}

	std::fstream file(file_path, std::ios::in | std::ios::binary);

	DWORD file_size = fs::file_size(file_path);

	BYTE* file_raw = new BYTE[file_size];

	file.read((char*)file_raw, file_size);
	file.close();

	std::priority_queue<CHAR_FREQ_PAIR*, std::vector<CHAR_FREQ_PAIR*>, CharAndFreqPairComparator> char_and_frequency_tree;
	if (!CalculateCharactersFrequency(char_and_frequency_tree, file_raw, file_size))
	{
		delete[] file_raw;

		return false;
	}

	if (char_and_frequency_tree.size() < 2)
	{
		delete char_and_frequency_tree.top();

		delete[] file_raw;

		return false;
	}

	auto* head = BuildHuffmanTree(char_and_frequency_tree);

	char_and_frequency_tree.pop();

	std::map<char, std::string> key_char_map;
	TraverseTree(head, key_char_map, std::string());
	
	std::vector<BYTE> compressed_file_bytes;
	WriteTree(head, compressed_file_bytes);

	DeleteTree(head);

	for (DWORD i = 0; i < sizeof(DWORD); ++i)
	{
		compressed_file_bytes.push_back(((BYTE*)&file_size)[i]);
	}

	DWORD compressed_bytes_count = WriteCompressedBytes(key_char_map, compressed_file_bytes, file_raw, file_size);

	if (!compressed_bytes_count)
	{
		delete[] file_raw;

		return false;
	}

	std::vector<BYTE>* compressed_file = GenerateCompressedFile(compressed_file_bytes, file_raw);

	delete[] file_raw;

	fs::path p = "C:\\Users\\Andrew\\Desktop\\new_exe.exe";

	std::fstream f(p, std::ios::out | std::ios::binary);

	f.write((char*)compressed_file->begin()._Ptr, compressed_file->size());

	f.close();

	return true;
}

std::vector<BYTE>* GenerateCompressedFile(std::vector<BYTE>& compressed_file, BYTE* file_raw)
{
	std::vector<BYTE>* out_file = new std::vector<BYTE>;

	if (!out_file)
	{
		return nullptr;
	}
	
	DWORD64 stub_funcs_VA = 0;
	DWORD stub_funcs_size = 0;

	GetSizeAndAddressOfSegmentInThisFile(".stub_f", &stub_funcs_VA, &stub_funcs_size);

	if (!stub_funcs_size || !stub_funcs_VA)
	{
		return nullptr;
	}

	// HEADERS SETUP
	IMAGE_FILE_HEADER* orig_file_header = (IMAGE_FILE_HEADER*)(&((IMAGE_NT_HEADERS*)(((IMAGE_DOS_HEADER*)file_raw)->e_lfanew + file_raw))->FileHeader);
	IMAGE_OPTIONAL_HEADER* orig_opt_header = &((IMAGE_NT_HEADERS*)(((IMAGE_DOS_HEADER*)file_raw)->e_lfanew + file_raw))->OptionalHeader;

	IMAGE_DOS_HEADER dos_header = { 0 };

	dos_header.e_magic = IMAGE_DOS_SIGNATURE;
	dos_header.e_lfanew = sizeof(IMAGE_DOS_HEADER);
	dos_header.e_cblp = 0x90;
	dos_header.e_cp = 0x03;
	dos_header.e_cparhdr = 0x04;
	dos_header.e_maxalloc = 0xFFFF;
	dos_header.e_sp = 0xB8;
	dos_header.e_lfarlc = 0x40;

	// pushing dos header (without DOS stub)
	PUSH_BYTES_IN_VECTOR(out_file, &dos_header);

	// setting up PE headers
	IMAGE_NT_HEADERS nt_header = { 0 };

	nt_header.Signature = IMAGE_NT_SIGNATURE;
	
	IMAGE_FILE_HEADER* file_header = &nt_header.FileHeader;

	file_header->Machine = orig_file_header->Machine;
	file_header->Characteristics = orig_file_header->Characteristics;
	file_header->NumberOfSections = PF_NUMBER_OF_SECTIONS;
	file_header->SizeOfOptionalHeader = sizeof(IMAGE_OPTIONAL_HEADER);
	file_header->TimeDateStamp = time(NULL);
	
	IMAGE_OPTIONAL_HEADER& opt_header = nt_header.OptionalHeader;

	opt_header.Magic = IMAGE_NT_OPTIONAL_HDR_MAGIC;
	opt_header.NumberOfRvaAndSizes = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;
	opt_header.SizeOfStackReserve = PF_STACK_RESERVE;
	opt_header.SizeOfStackCommit = PF_STACK_COMMIT;
	opt_header.SizeOfHeapReserve = PF_HEAP_RESERVE;
	opt_header.SizeOfHeapCommit = PF_HEAP_COMMIT;
	opt_header.FileAlignment = PF_FILE_ALIGNMENT;
	opt_header.SectionAlignment = PF_SECTION_ALIGNMENT;
	opt_header.SizeOfUninitializedData = NULL;
	opt_header.Subsystem = orig_opt_header->Subsystem;
	opt_header.MinorSubsystemVersion = orig_opt_header->MinorSubsystemVersion;
	opt_header.MajorSubsystemVersion = orig_opt_header->MajorSubsystemVersion;
	opt_header.DllCharacteristics = orig_opt_header->DllCharacteristics;
	opt_header.MajorOperatingSystemVersion = orig_opt_header->MajorOperatingSystemVersion;
	opt_header.MinorOperatingSystemVersion = orig_opt_header->MinorOperatingSystemVersion;
	opt_header.ImageBase = EXE_IMAGE_BASE;
	opt_header.SizeOfHeaders = FILE_ALIGN(sizeof(IMAGE_SECTION_HEADER) * PF_NUMBER_OF_SECTIONS + sizeof(IMAGE_NT_HEADERS) + dos_header.e_lfanew);

	IMAGE_SECTION_HEADER import_names_data_seg = { 0 };

	IMAGE_SECTION_HEADER text_seg = { 0 };

	IMAGE_SECTION_HEADER orig_compressed_seg = { 0 };

	// setting up import segment

	char RtlAllocateHeap_name[] = "RtlAllocateHeap";
	char RtlCreateHeap_name[] = "RtlCreateHeap";
	char RtlFreeHeap_name[] = "RtlFreeHeap";
	char RtlZeroMemory_name[] = "RtlZeroMemory";
	char LdrGetProcedureAddress_name[] = "LdrGetProcedureAddress";
	char LdrLoadDll_name[] = "LdrLoadDll";
	char NtAllocateVirtualMemory_name[] = "NtAllocateVirtualMemory";
	char NtContinue_name[] = "NtContinue";
	char NtGetContextThread_name[] = "NtGetContextThread";
	char NtFreeVirtualMemory_name[] = "NtFreeVirtualMemory";
	char memmove_name[] = "memmove";

	DWORD size_of_all_names = sizeof(RtlAllocateHeap_name) + sizeof(RtlCreateHeap_name) + sizeof(RtlFreeHeap_name) + sizeof(RtlZeroMemory_name) +
							  sizeof(LdrGetProcedureAddress_name) + sizeof(LdrLoadDll_name) + sizeof(NtAllocateVirtualMemory_name) + sizeof(NtContinue_name) + sizeof(NtGetContextThread_name) +
							  sizeof(NtFreeVirtualMemory_name) + sizeof(memmove_name);

	import_names_data_seg.Characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;
	strcpy((char*)import_names_data_seg.Name, ".data");
	import_names_data_seg.SizeOfRawData = FILE_ALIGN(size_of_all_names);
	import_names_data_seg.Misc.VirtualSize = size_of_all_names;
	import_names_data_seg.PointerToRawData = opt_header.SizeOfHeaders;
	import_names_data_seg.VirtualAddress = VIRTUAL_ALIGN(opt_header.SizeOfHeaders);

#ifndef _WIN64
	opt_header.BaseOfData = import_names_data_seg.VirtualAddress;
#endif

	// setting up text segment
	text_seg.Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE;
	strcpy((char*)text_seg.Name, ".text");
	text_seg.PointerToRawData = import_names_data_seg.PointerToRawData + import_names_data_seg.SizeOfRawData;
	text_seg.VirtualAddress = import_names_data_seg.VirtualAddress + VIRTUAL_ALIGN(import_names_data_seg.SizeOfRawData);
	text_seg.SizeOfRawData = FILE_ALIGN(stub_funcs_size);
	text_seg.Misc.VirtualSize = stub_funcs_size;

	opt_header.BaseOfCode = text_seg.VirtualAddress;
	opt_header.SizeOfCode = text_seg.SizeOfRawData;

	// setting up compressed data segment
	orig_compressed_seg.Characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;
	strcpy((char*)orig_compressed_seg.Name, ".fuck_u");
	orig_compressed_seg.PointerToRawData = text_seg.PointerToRawData + text_seg.SizeOfRawData;
	orig_compressed_seg.VirtualAddress = text_seg.VirtualAddress + VIRTUAL_ALIGN(text_seg.SizeOfRawData);
	orig_compressed_seg.SizeOfRawData = FILE_ALIGN(compressed_file.size());
	orig_compressed_seg.Misc.VirtualSize = compressed_file.size();

	opt_header.SizeOfImage = VIRTUAL_ALIGN(opt_header.SizeOfHeaders) + VIRTUAL_ALIGN(import_names_data_seg.SizeOfRawData) + VIRTUAL_ALIGN(text_seg.SizeOfRawData) + VIRTUAL_ALIGN(orig_compressed_seg.SizeOfRawData);

	// pushing PE header and align whole headers section by file alignment
	PUSH_BYTES_IN_VECTOR(out_file, &nt_header);
	PUSH_BYTES_IN_VECTOR(out_file, &import_names_data_seg);
	PUSH_BYTES_IN_VECTOR(out_file, &text_seg);
	PUSH_BYTES_IN_VECTOR(out_file, &orig_compressed_seg);

	ALIGN_SECTION_BY_FILE_ALIGNMENT(out_file);

	// import stuff
	char import_strings_encryption_key[ENTRYPTYON_KEY_SIZE];

	ENCRYPTION_KEY_INIT(import_strings_encryption_key);

	PushBytesInVector(out_file, RtlAllocateHeap_name, sizeof(RtlAllocateHeap_name));
	PushBytesInVector(out_file, RtlCreateHeap_name, sizeof(RtlCreateHeap_name));
	PushBytesInVector(out_file, RtlFreeHeap_name, sizeof(RtlFreeHeap_name));
	PushBytesInVector(out_file, RtlZeroMemory_name, sizeof(RtlZeroMemory_name));
	PushBytesInVector(out_file, LdrGetProcedureAddress_name, sizeof(LdrGetProcedureAddress_name));
	PushBytesInVector(out_file, LdrLoadDll_name, sizeof(LdrLoadDll_name));
	PushBytesInVector(out_file, NtAllocateVirtualMemory_name, sizeof(NtAllocateVirtualMemory_name));
	PushBytesInVector(out_file, NtContinue_name, sizeof(NtContinue_name));
	PushBytesInVector(out_file, NtGetContextThread_name, sizeof(NtGetContextThread_name));
	PushBytesInVector(out_file, NtFreeVirtualMemory_name, sizeof(NtFreeVirtualMemory_name));
	PushBytesInVector(out_file, memmove_name, sizeof(memmove_name));

	for (DWORD i = out_file->size() - size_of_all_names, key_i = 0; i < out_file->size(); ++i, ++key_i)
	{
		if (key_i == ENTRYPTYON_KEY_SIZE - 1)
		{
			key_i = 0;
		}

		out_file->at(i) ^= import_strings_encryption_key[key_i];
	}

	ALIGN_SECTION_BY_FILE_ALIGNMENT(out_file);

	std::vector<BYTE> stub_main_signature;

	for (DWORD i = 0; i < PF_STUB_MAIN_SIGNATURE_LENGTH; ++i)
	{
		stub_main_signature.push_back(((BYTE*)StubMain)[i]);
	}

	PushBytesInVector(out_file, (void*)stub_funcs_VA, stub_funcs_size);
	
	std::vector<BYTE>::iterator start_of_code = out_file->end() - stub_funcs_size;

	std::vector<BYTE>::iterator* stub_main_in_file = SignatureScanForVector(start_of_code, stub_funcs_size, stub_main_signature);

	if (!stub_main_in_file)
	{
		return nullptr;
	}

	for (DWORD i = out_file->size() - stub_funcs_size, j = 0; i < out_file->size(); ++i, ++j)
	{
		if (out_file->begin() + i == *stub_main_in_file)
		{
			SetEntryPointAddress(out_file, text_seg.VirtualAddress + j);

			break;
		}
	}
	
	ALIGN_SECTION_BY_FILE_ALIGNMENT(out_file);

	for (const auto& byte : compressed_file)
	{
		out_file->push_back(byte);
	}

	ALIGN_SECTION_BY_FILE_ALIGNMENT(out_file);

	return out_file;
}
```

`pack_file.h`:

```h
#pragma once

#define PF_NUMBER_OF_SECTIONS			3
#define PF_SECTION_ALIGNMENT			0x1000
#define PF_FILE_ALIGNMENT				0x200
#define PF_STACK_RESERVE				0x100000
#define PF_STACK_COMMIT					0x1000
#define PF_HEAP_RESERVE					0x100000
#define PF_HEAP_COMMIT					0x1000
#define PF_STUB_MAIN_SIGNATURE_LENGTH	0x30

#define EXE_IMAGE_BASE 0x00400000

#define ALIGN(val, alignment) (((val) / alignment + 1) * alignment)
#define FILE_ALIGN(val) ALIGN(val, PF_FILE_ALIGNMENT)
#define VIRTUAL_ALIGN(val) ALIGN(val, PF_SECTION_ALIGNMENT)

#define ALIGN_SECTION_BY_FILE_ALIGNMENT(out_file) PushValueInVector(out_file, 0, FILE_ALIGN(out_file->size()) - out_file->size());
#define PUSH_BYTES_IN_VECTOR(out_file, ptr) PushBytesInVector(out_file, ptr, sizeof(*(ptr)))

bool PackFile(const wchar_t* file_path);

void PushBytesInVector(std::vector<BYTE>* vec, void* ptr, DWORD size);

void PushValueInVector(std::vector<BYTE>* vec, int value, DWORD size);

void PushBytesInVectorByAlignment(std::vector<BYTE>* vec, void* ptr, DWORD size, DWORD alignment);

std::vector<BYTE>* GenerateCompressedFile(std::vector<BYTE>& compressed_file, BYTE* file_raw);

void SetEntryPointAddress(std::vector<BYTE>* vec, DWORD entry_point_addr);

void GetSizeAndAddressOfSegmentInThisFile(const char* segment_name, DWORD64* out_virtual_address, DWORD* out_size);
```

`strings_init.h`:

```h
#pragma once

#define NT_DLL_NAME_INIT(arr)					arr[0] = 'n'; arr[1] = 't'; arr[2] = 'd'; arr[3] = 'l'; arr[4] = 'l'; arr[5] = '.'; arr[6] = 'd'; arr[7] = 'l'; arr[8] = 'l'; arr[9] = '\0'
#define NT_DLL_NAME_INIT_UNICODE(arr)			arr[0] = L'n'; arr[1] = L't'; arr[2] = L'd'; arr[3] = L'l'; arr[4] = L'l'; arr[5] = L'.'; arr[6] = L'd'; arr[7] = L'l'; arr[8] = L'l'; arr[9] = L'\0'
#define KERNEL_DLL_NAME_INIT_UNICODE(arr)		arr[0] = L'K'; arr[1] = L'E'; arr[2] = L'R'; arr[3] = L'N'; arr[4] = L'E'; arr[5] = L'L'; arr[6] = L'3'; arr[7] = L'2'; arr[8] = L'.'; arr[9] = L'D'; arr[10] = L'L'; arr[11] = L'L'; arr[12] = L'\0'
#define COMPRESSED_SECTION_NAME_INIT(arr)		arr[0] = '.'; arr[1] = 'f'; arr[2] = 'u'; arr[3] = 'c'; arr[4] = 'k'; arr[5] = '_'; arr[6] = 'u'; arr[7] = '\0'
#define ENCRYPTION_KEY_INIT(arr)				arr[0] = 'q'; arr[1] = 'w'; arr[2] = 'e'; arr[3] = 'r'; arr[4] = 't'; arr[5] = 'y'; arr[6] = '1'; arr[7] = '4'; arr[8] = '8'; arr[9] = '8'; arr[10] = '\0'
#define IMPORT_NAMES_SECTION_INIT(arr)			arr[0] = '.'; arr[1] = 'd'; arr[2] = 'a'; arr[3] = 't'; arr[4] = 'a'; arr[5] = '\0'
#define LOAD_LIBRARY_STR_INIT(arr)				arr[0] = 'L'; arr[1] = 'o'; arr[2] = 'a'; arr[3] = 'd'; arr[4] = 'L'; arr[5] = 'i'; arr[6] = 'b'; arr[7] = 'r'; arr[8] = 'a'; arr[9] = 'r'; arr[10] = 'y'; arr[11] = 'A'; arr[12] = '\0'

#define NT_DLL_NAME_SIZE					10
#define KERNEL_DLL_NAME_SIZE				13
#define COMPRESSED_SECTION_NAME_SIZE		8
#define ENTRYPTYON_KEY_SIZE					11
#define IMPORT_NAMES_SECTION_SIZE			6
#define LOAD_LIBRARY_STR_SIZE				13
```

`tools.cpp`:

```cpp
#include "includes.h"

bool VerifyFile(const wchar_t* file_path, WORD desired_machine, WORD desired_characteristics)
{
	if (!file_path)
	{
		return false;
	}

	std::fstream file(file_path, std::ios::binary | std::ios::in);

	if (!file.good())
	{
		return false;
	}

	DWORD file_size = fs::file_size(file_path);

	if (!file_size || file_size < PAGE_SIZE)
	{
		file.close();

		return false;
	}

	BYTE* file_raw = new BYTE[PAGE_SIZE];

	if (!file_raw)
	{
		file.close();

		return false;
	}

	file.read((char*)file_raw, PAGE_SIZE);
	file.close();

	IMAGE_DOS_HEADER*	dos_header		= nullptr;
	IMAGE_NT_HEADERS*	nt_header		= nullptr;
	IMAGE_FILE_HEADER*	file_header		= nullptr;

	dos_header = (IMAGE_DOS_HEADER*)file_raw;

	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE || dos_header->e_lfanew > PAGE_SIZE)
	{
		delete[] file_raw;

		return false;
	}

	nt_header = (IMAGE_NT_HEADERS*)(file_raw + dos_header->e_lfanew);

	if (nt_header->Signature != IMAGE_NT_SIGNATURE)
	{
		delete[] file_raw;

		return false;
	}

	file_header = &nt_header->FileHeader;

	if (((file_header->Machine & desired_machine) != desired_machine) || ((file_header->Characteristics & desired_characteristics)) != desired_characteristics)
	{
		delete[] file_raw;

		return false;
	}

	delete[] file_raw;

	return true;
}

DWORD GetOwnModuleFullPathW(fs::path& mod_name_path)
{
	wchar_t mod_name_buf[MAX_PATH] = { 0 };

	HMODULE h_current_module = GetModuleHandle(NULL);

	DWORD mod_name_len = GetModuleFileNameW(h_current_module, mod_name_buf, sizeof(mod_name_buf) / sizeof(mod_name_buf[0]));

	if (!mod_name_len || GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	{
		return 0;
	}

	mod_name_path = mod_name_buf;

	return mod_name_len;
}

std::vector<BYTE>::iterator* SignatureScanForVector(std::vector<BYTE>::iterator& start, size_t len, std::vector<BYTE>& signature)
{
	if (signature.empty())
	{
		return nullptr;
	}

	bool found = false;

	for (DWORD i = 0; i < len; ++start, ++i)
	{
		found = true;

		for (DWORD j = 0; j < signature.size(); ++j)
		{
			if (start[j] != signature[j])
			{
				found = false;

				break;
			}
		}

		if (found)
		{
			return &start;
		}
	}

	return nullptr;
}
```

`tools.h`:

```h
#pragma once

#define PAGE_SIZE 0x1000

#define _LOG(format, type, ...) printf("[ "##type" ] "##format"\n", __VA_ARGS__)
#define ERRLOG(format, ...) _LOG(format, "ERROR", __VA_ARGS__)
#define SUCCLOG(format, ...) _LOG(format, "SUCCESS", __VA_ARGS__)
#define LOG(format, ...) _LOG(format, "LOG", __VA_ARGS__)

#define CODE_SEG(seg_name) __declspec(code_seg(seg_name))

#define _ZeroMemory(ptr, size) memset(ptr, 0, size)

bool VerifyFile(const wchar_t* file_path, WORD desired_machine, WORD desired_characteristics);

DWORD GetOwnModuleFullPathW(fs::path& mod_name_path);

std::vector<BYTE>::iterator* SignatureScanForVector(std::vector<BYTE>::iterator& start, size_t len, std::vector<BYTE>& signature);
```

`unpacker_stub.cpp`:

```cpp
#include "includes.h"

CODE_SEG(".stub_f") BYTE* __stdcall StubMain()
{
	UINT_PTR module_base = (UINT_PTR)GetThisModuleBaseAddress();

	STUB_FUNCTION_TABLE f;

	wchar_t nt_dll[NT_DLL_NAME_SIZE];
	wchar_t kernel_32_dll[KERNEL_DLL_NAME_SIZE];

	NT_DLL_NAME_INIT_UNICODE(nt_dll);
	KERNEL_DLL_NAME_INIT_UNICODE(kernel_32_dll);

	HANDLE nt_dll_base = GetDllBaseAddress(nt_dll);
	HANDLE kernel_dll_base = GetDllBaseAddress(kernel_32_dll);
	
	if (!nt_dll_base || !kernel_dll_base)
	{
		return 0;
	}

	if (!ResolveNtDllImports(&f, module_base, (DWORD64)nt_dll_base))
	{
		return 0;
	}

	f_LoadLibraryA _LoadLibraryA = nullptr;

	ANSI_STRING LoadLibrary_ansi_name;

	char LoadLibrary_name[LOAD_LIBRARY_STR_SIZE];
	LOAD_LIBRARY_STR_INIT(LoadLibrary_name);

	if (!InitAnsiString(&LoadLibrary_ansi_name, LoadLibrary_name))
	{
		return 0;
	}

	if (NT_FAIL(f.LdrGetProcedureAddress(kernel_dll_base, &LoadLibrary_ansi_name, NULL, (void**)&_LoadLibraryA)))
	{
		return 0;
	}

	if (!_LoadLibraryA)
	{
		return 0;
	}

	f.p_Heap = f.RtlCreateHeap(HEAP_GROWABLE, NULL, NULL, NULL, NULL, NULL);

	DWORD64 compressed_section_addr = 0;
	DWORD compressed_section_size = 0;

	char compressed_section_name[COMPRESSED_SECTION_NAME_SIZE];

	COMPRESSED_SECTION_NAME_INIT(compressed_section_name);

	GetSectionAddressAndSize(compressed_section_name, module_base, &compressed_section_addr, &compressed_section_size);

	if (!compressed_section_addr || !compressed_section_size)
	{
		return 0;
	}

	compressed_section_addr += module_base;

	CHARS_HUFFMAN_TREE* tree_head = ReadTree_ForStub(&f, (BYTE**)&compressed_section_addr);

	DWORD initial_bytes_num = *(DWORD*)compressed_section_addr;
	compressed_section_addr += sizeof(DWORD);

	CHARS_CODES_LIST* list_tail = nullptr;

	char useless_var[1]; useless_var[0] = '\0';

	TraverseTree_ForStub(&f, &list_tail, tree_head, useless_var);

	DeleteTree_ForStub(&f, tree_head);
	
	BYTE* decompressed_section = DecompressBytes(&f, list_tail, (BYTE*)compressed_section_addr, compressed_section_size, initial_bytes_num);

	if (!decompressed_section)
	{
		return 0;
	}

	IMAGE_NT_HEADERS* nt_header = (IMAGE_NT_HEADERS*)(((IMAGE_DOS_HEADER*)decompressed_section)->e_lfanew + decompressed_section);
	IMAGE_OPTIONAL_HEADER* opt_header = &nt_header->OptionalHeader;

	BYTE* main_image_base = (BYTE*)opt_header->ImageBase;
	SIZE_T new_main_image_size = opt_header->SizeOfImage;

	SIZE_T virtual_free_size = 0;

	if (NT_FAIL(f.NtAllocateVirtualMemory(NtCurrentProcess(), (void**)&main_image_base, NULL, &new_main_image_size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)))
	{
		main_image_base = nullptr;

		if (NT_FAIL(f.NtAllocateVirtualMemory(NtCurrentProcess(), (void**)&main_image_base, NULL, &new_main_image_size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)))
		{
			return 0;
		}
	}

	IMAGE_SECTION_HEADER* sec = IMAGE_FIRST_SECTION(nt_header);

	f.memmove(main_image_base, decompressed_section, opt_header->SizeOfHeaders);

	for (DWORD i = 0; i < nt_header->FileHeader.NumberOfSections; ++i, ++sec)
	{
		if (sec->SizeOfRawData)
		{
			f.memmove(main_image_base + sec->VirtualAddress, decompressed_section + sec->PointerToRawData, sec->SizeOfRawData);
		}
	}
	
	BYTE* location_delta = main_image_base - opt_header->ImageBase;

	if (location_delta)
	{
		if (!opt_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size)
		{
			return 0;
		}

		IMAGE_BASE_RELOCATION* reloc_data = (IMAGE_BASE_RELOCATION*)(main_image_base + opt_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);

		while (reloc_data->VirtualAddress)
		{
			DWORD amount_of_entries = (reloc_data->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
			WORD* relative_info = (WORD*)(reloc_data + 1);

			for (DWORD i = 0; i < amount_of_entries; ++i, ++relative_info)
			{
				if (RELOC_FLAG(*relative_info))
				{
					DWORD* patch = (DWORD*)(main_image_base + reloc_data->VirtualAddress + ((*relative_info) & 0xFFF));
					*patch += (DWORD64)location_delta;
				}
			}

			reloc_data = (IMAGE_BASE_RELOCATION*)((BYTE*)reloc_data + reloc_data->SizeOfBlock);
		}

		opt_header->ImageBase += (DWORD64)location_delta;
	}

	// TODO: resolve imports
	if (opt_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size)
	{
		IMAGE_IMPORT_DESCRIPTOR* import_desc = (IMAGE_IMPORT_DESCRIPTOR*)(main_image_base + opt_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
	
		while (import_desc->Name)
		{
			char* dll_name = (char*)(main_image_base + import_desc->Name);
			HMODULE h_dll = _LoadLibraryA(dll_name);

			if (!h_dll)
			{
				return 0;
			}

			IMAGE_THUNK_DATA* orig_thunk = (IMAGE_THUNK_DATA*)(main_image_base + import_desc->OriginalFirstThunk);
			IMAGE_THUNK_DATA* first_thunk = (IMAGE_THUNK_DATA*)(main_image_base + import_desc->FirstThunk);

			for (; orig_thunk->u1.AddressOfData; ++orig_thunk, ++first_thunk)
			{
				if (IMAGE_SNAP_BY_ORDINAL(orig_thunk->u1.Ordinal))
				{
					NTSTATUS st = f.LdrGetProcedureAddress(h_dll, NULL, IMAGE_ORDINAL(orig_thunk->u1.Ordinal), (void**)first_thunk);
					if (NT_FAIL(st))
					{
						return 0;
					}
				}
				else
				{
					IMAGE_IMPORT_BY_NAME* name_imp = (IMAGE_IMPORT_BY_NAME*)(main_image_base + orig_thunk->u1.AddressOfData);

					ANSI_STRING* ansi_name = _HeapAlloc<ANSI_STRING>(&f, 1);

					if (!ansi_name)
					{
						return 0;
					}

					if (!InitAnsiString(ansi_name, name_imp->Name))
					{
						return 0;
					}

					if (NT_FAIL(f.LdrGetProcedureAddress(h_dll, ansi_name, NULL, (void**)first_thunk)))
					{
						return 0;
					}

					_FreeHeap(&f, ansi_name);
				}
			}

			++import_desc;
		}
	}
	else
	{
		return 0;
	}

#ifdef _WIN64
	DWORD64 orig_entry_point = opt_header->AddressOfEntryPoint + (DWORD64)main_image_base;
#else
	DWORD orig_entry_point = opt_header->AddressOfEntryPoint + (DWORD)main_image_base;
#endif

	if (NT_FAIL(f.NtFreeVirtualMemory(NtCurrentProcess(), (void**)&decompressed_section, &virtual_free_size, MEM_RELEASE)))
	{
		return 0;
	}

	OriginalEntryPoint EntryPoint = (OriginalEntryPoint)orig_entry_point;

	EntryPoint();

	return decompressed_section;
}
```

`unpacker_stub.h`:

```h
#pragma once

#define NT_LOCAL(func) f_##func func

#define PEB_PTR_64 (PEB*)__readgsqword(0x60)
#define PEB_PTR_32 (PEB*)__readfsdword(0x30)

#ifdef _WIN64
#define PEB_PTR PEB_PTR_64
#else
#define PEB_PTR PEB_PTR_32
#endif

#define MAX_IMPORT_NAME_SIZE 50

#define RELOC_FLAG_64(rel_info) ((rel_info >> 12) == IMAGE_REL_BASED_DIR64)
#define RELOC_FLAG_32(rel_info) ((rel_info >> 12) == IMAGE_REL_BASED_HIGHLOW)

#ifdef _WIN64
#define RELOC_FLAG RELOC_FLAG_64
#else
#define RELOC_FLAG RELOC_FLAG_32
#endif

using OriginalEntryPoint = void (__cdecl*)();
using f_LoadLibraryA = decltype(LoadLibraryA)*;

struct STUB_FUNCTION_TABLE
{
	NT_LOCAL(RtlAllocateHeap);
	NT_LOCAL(RtlCreateHeap);
	NT_LOCAL(RtlFreeHeap);
	NT_LOCAL(RtlZeroMemory);
	NT_LOCAL(LdrGetProcedureAddress);
	NT_LOCAL(LdrLoadDll);
	NT_LOCAL(NtAllocateVirtualMemory);
	NT_LOCAL(NtContinue);
	NT_LOCAL(NtGetContextThread);
	NT_LOCAL(NtFreeVirtualMemory);
	NT_LOCAL(memmove);

	void* p_Heap = nullptr;
};

CODE_SEG(".stub_f") BYTE* __stdcall StubMain();

template <class T>
__forceinline T* _HeapAlloc(STUB_FUNCTION_TABLE* f, size_t size)
{
	return (T*)f->RtlAllocateHeap(f->p_Heap, HEAP_ZERO_MEMORY, sizeof(T) * size);
}

__forceinline bool _FreeHeap(STUB_FUNCTION_TABLE* f, void* ptr)
{
	return (bool)f->RtlFreeHeap(f->p_Heap, NULL, ptr);
}

__forceinline int __strlen(const char* str)
{
	int i = 0;

	for (; *str; ++str, i += sizeof(char));

	return i;
}

__forceinline bool __strcmp(const char* str1, const char* str2)
{
	if (__strlen(str1) != __strlen(str2))
	{
		return false;
	}

	for (; *str1 && *str2; ++str1, ++str2)
	{
		if (*str1 != *str2)
		{
			return false;
		}
	}

	return true;
}

__forceinline int __wcslen(const wchar_t* str)
{
	int i = 0;

	for (; *str; ++str, i += sizeof(wchar_t));

	return i;
}

__forceinline bool __wcscmp(const wchar_t* str1, const wchar_t* str2)
{
	if (__wcslen(str1) != __wcslen(str2))
	{
		return false;
	}

	for (; *str1 && *str2; ++str1, ++str2)
	{
		if (*str1 != *str2)
		{
			return false;
		}
	}

	return true;
}

__forceinline void __strcat(char* dst, const char* src)
{
	for (; *dst; ++dst);

	for (; *src; ++src, ++dst)
	{
		*dst = *src;
	}

	*(++dst) = '\0';
}

__forceinline void __strcat(char* dst, char ch)
{
	for (; *dst; ++dst);

	*dst = ch;

	*(++dst) = '\0';
}

__forceinline void __strcpy(char* dst, const char* src)
{
	for (; *src != '\0'; ++src, ++dst)
	{
		*dst = *src;
	}

	*(++dst) = '\0';
}

__forceinline HANDLE GetThisModuleBaseAddress()
{
	PEB* peb = PEB_PTR;

	if (!peb)
	{
		return nullptr;
	}

	return peb->ImageBaseAddress;
}

__forceinline HANDLE GetDllBaseAddress(wchar_t* dll_name)
{
	if (!dll_name)
	{
		return nullptr;
	}

	PEB* peb = PEB_PTR;

	if (!peb)
	{
		return nullptr;
	}

	PEB_LDR_DATA* ldr_data = peb->Ldr;

	LIST_ENTRY* head = &ldr_data->InLoadOrderModuleListHead;
	LIST_ENTRY* current = ldr_data->InLoadOrderModuleListHead.Flink;

	LDR_DATA_TABLE_ENTRY* entry = nullptr;

	while (current != head)
	{
		entry = (LDR_DATA_TABLE_ENTRY*)current;

		if (__wcscmp(entry->BaseDllName.szBuffer, dll_name))
		{
			return entry->DllBase;
		}

		current = current->Flink;
	}

	return nullptr;
}


__forceinline bool InitAnsiString(ANSI_STRING* ansi_str, char* str)
{
	if (!ansi_str || !str)
	{
		return false;
	}

	if (!__strlen(str))
	{
		return false;
	}

	ansi_str->szBuffer = str;
	ansi_str->Length = __strlen(str) + 1;
	ansi_str->MaxLength = ansi_str->Length * 2;

	return true;
}

__forceinline void GetSectionAddressAndSize(const char* sec_name, DWORD64 module_base, DWORD64* out_address, DWORD* out_size)
{
	if (!out_address || !out_size)
	{
		return;
	}

	IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*)module_base;
	IMAGE_NT_HEADERS* nt_header = (IMAGE_NT_HEADERS*)(dos_header->e_lfanew + module_base);
	IMAGE_FILE_HEADER* file_header = &nt_header->FileHeader;

	IMAGE_SECTION_HEADER* section = IMAGE_FIRST_SECTION(nt_header);

	for (DWORD i = 0; i < file_header->NumberOfSections; ++i, ++section)
	{
		if (__strcmp((char*)section->Name, sec_name))
		{
			*out_address = section->VirtualAddress;
			*out_size = section->SizeOfRawData;

			break;
		}
	}
}

__forceinline bool ResolveNtDllImports(STUB_FUNCTION_TABLE* f, UINT_PTR module_base, UINT_PTR nt_base)
{
	if (!f || !module_base || !nt_base)
	{
		return false;
	}

	char import_names_sec_name[IMPORT_NAMES_SECTION_SIZE];

	IMPORT_NAMES_SECTION_INIT(import_names_sec_name);
	
	DWORD64 import_names_sec_addr = 0;
	DWORD import_names_sec_size = 0;

	GetSectionAddressAndSize(import_names_sec_name, module_base, &import_names_sec_addr, &import_names_sec_size);
	
	if (!import_names_sec_addr || !import_names_sec_size)
	{
		return false;
	}

	import_names_sec_addr += module_base;

	char import_names_encryption_key[ENTRYPTYON_KEY_SIZE];

	ENCRYPTION_KEY_INIT(import_names_encryption_key);

	DWORD stub_f_count = sizeof(STUB_FUNCTION_TABLE) / sizeof(void*) - 1;

	DWORD names_count = 0;

	for (BYTE* i = (BYTE*)import_names_sec_addr, key_i = 0; i < (BYTE*)import_names_sec_addr + import_names_sec_size; ++i, ++key_i)
	{
		if (!(*i) && !(*(i + 1)))
		{
			break;
		}

		if (key_i == ENTRYPTYON_KEY_SIZE - 1)
		{
			key_i = 0;
		}

		*i ^= import_names_encryption_key[key_i];

		if (*i == '\0')
		{
			++names_count;
		}
	}

	if (names_count != stub_f_count)
	{
		return false;
	}

	IMAGE_EXPORT_DIRECTORY* export_dir = (IMAGE_EXPORT_DIRECTORY*)(((IMAGE_NT_HEADERS*)(((IMAGE_DOS_HEADER*)nt_base)->e_lfanew + nt_base))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + nt_base);

	char import_name[MAX_IMPORT_NAME_SIZE];

	for (DWORD i = 0; i < stub_f_count; ++i)
	{
		for (DWORD j = 0; ; ++j, ++import_names_sec_addr)
		{ 
			if (*(BYTE*)import_names_sec_addr == 0)
			{
				import_name[j] = '\0';
				++import_names_sec_addr;

				break;
			}

			import_name[j] = *(BYTE*)import_names_sec_addr;
		}

		bool found_flag = false;                                                     

		for (DWORD k = 0; k < export_dir->NumberOfNames; ++k)
		{
			char* export_name = (char*)((*(DWORD*)((nt_base + export_dir->AddressOfNames) + k * sizeof(DWORD)) + nt_base));

			if (__strcmp(export_name, import_name))
			{
				WORD name_ordinal = *(((WORD*)(nt_base + export_dir->AddressOfNameOrdinals)) + k);

 				*((void**)f + i) = (void*)(*(((DWORD*)(nt_base + export_dir->AddressOfFunctions)) + name_ordinal) + nt_base);

				found_flag = true;

				break;
			}
		}

		if (!found_flag)
		{
			return false;
		}
	}

	return true;
}
```

`win_10.h`:

```h
#pragma once

#include "nt_defs.h"

typedef struct _LDR_DDAG_NODE_WIN10
{
	LIST_ENTRY				Modules;
	PLDR_SERVICE_TAG_RECORD	ServiceTagList;
	ULONG					LoadCount;
	ULONG					LoadWhileUnloadingCount;
	ULONG					LowestLink;
	PLDRP_CSLIST			Dependencies;
	PLDRP_CSLIST			IncomingDependencies;
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY		CondenseLink;
	ULONG					PreorderNumber;
} LDR_DDAG_NODE_WIN10, * PLDR_DDAG_NODE_WIN10;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN10
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG LoadConfigProcessed : 1;
			ULONG EntryProcessed : 1;
			ULONG ProtectDelayLoad : 1;
			ULONG ReservedFlags3 : 2;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ChpeImage : 1;
			ULONG ReservedFlags5 : 2;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY HashLinks;

	ULONG TimedateStamp;
	PVOID EntryPointActivationContext;
	PVOID Lock;

	LDR_DDAG_NODE_WIN10* DdagNode;

	LIST_ENTRY	NodeModuleLink;
	PVOID		LoadContext;
	PVOID		ParentDllBase;
	PVOID		SwitchBackContext;

	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;

	ULONG_PTR			OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
	ULONG				ImplicitPathOptions;

	ULONG ReferenceCount;

	//1607+
	ULONG DependentLoadFlags;

	//1703+
	UCHAR SigningLevel;
} LDR_DATA_TABLE_ENTRY_WIN10, * PLDR_DATA_TABLE_ENTRY_WIN10;

#ifdef _WIN64

typedef __declspec(align(4)) struct _LDR_DDAG_NODE_WIN10_32
{
	LIST_ENTRY32			Modules;
	DWORD					ServiceTagList; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG					LoadCount;
	ULONG					LoadWhileUnloadingCount;
	ULONG					LowestLink;
	DWORD					Dependencies; // -> LDRP_CSLIST_32
	DWORD					IncomingDependencies; // -> LDRP_CSLIST_32
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY_32	CondenseLink;
	ULONG					PreorderNumber;
} LDR_DDAG_NODE_WIN10_32, * PLDR_DDAG_NODE_WIN10_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN10_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG LoadConfigProcessed : 1;
			ULONG EntryProcessed : 1;
			ULONG ProtectDelayLoad : 1;
			ULONG ReservedFlags3 : 2;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ChpeImage : 1;
			ULONG ReservedFlags5 : 2;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY32 HashLinks;

	ULONG TimedateStamp;
	DWORD EntryPointActivationContext;
	DWORD Spare;

	DWORD DdagNode; // -> LDR_DDAG_NODE_WIN10_32

	LIST_ENTRY32	NodeModuleLink;
	DWORD			LoadContext;
	DWORD			ParentDllBase;
	DWORD			SwitchBackContext;

	RTL_BALANCED_NODE_32 BaseAddressIndexNode;
	RTL_BALANCED_NODE_32 MappingInfoIndexNode;

	DWORD				OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
	ULONG				ImplicitPathOptions;

	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
	UCHAR SigningLevel;
} LDR_DATA_TABLE_ENTRY_WIN10_32, * PLDR_DATA_TABLE_ENTRY_WIN10_32;

#endif
```

`win_11.h`:

```h
#pragma once

#include "nt_defs.h"

typedef struct _LDR_DDAG_NODE_WIN11
{
	LIST_ENTRY				Modules;
	PLDR_SERVICE_TAG_RECORD	ServiceTagList;
	ULONG					LoadCount;
	ULONG					LoadWhileUnloadingCount;
	ULONG					LowestLink;
	PLDRP_CSLIST			Dependencies;
	PLDRP_CSLIST			IncomingDependencies;
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY		CondenseLink;
	ULONG					PreorderNumber;
} LDR_DDAG_NODE_WIN11, * PLDR_DDAG_NODE_WIN11;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN11
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG LoadConfigProcessed : 1;
			ULONG EntryProcessed : 1;
			ULONG ProtectDelayLoad : 1;
			ULONG ReservedFlags3 : 2;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ChpeImage : 1;
			ULONG ReservedFlags5 : 2;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY HashLinks;

	ULONG TimedateStamp;
	PVOID EntryPointActivationContext;
	PVOID Lock;

	LDR_DDAG_NODE_WIN11* DdagNode;

	LIST_ENTRY	NodeModuleLink;
	PVOID		LoadContext;
	PVOID		ParentDllBase;
	PVOID		SwitchBackContext;

	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;

	ULONG_PTR			OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
	ULONG				ImplicitPathOptions;

	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
	UCHAR SigningLevel;

	ULONG CheckSum;
	PVOID ActivePathImageBase;
	LDR_HOT_PATCH_STATE HotPatchState;
} LDR_DATA_TABLE_ENTRY_WIN11, * PLDR_DATA_TABLE_ENTRY_WIN11;

#ifdef _WIN64

typedef struct _LDR_DDAG_NODE_WIN11_32
{
	LIST_ENTRY32			Modules;
	DWORD					ServiceTagList; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG					LoadCount;
	ULONG					LoadWhileUnloadingCount;
	ULONG					LowestLink;
	DWORD					Dependencies; // -> LDRP_CSLIST_32
	DWORD					IncomingDependencies; // -> LDRP_CSLIST_32
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY_32	CondenseLink;
	ULONG					PreorderNumber;
} LDR_DDAG_NODE_WIN11_32, * PLDR_DDAG_NODE_WIN11_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN11_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG LoadConfigProcessed : 1;
			ULONG EntryProcessed : 1;
			ULONG ProtectDelayLoad : 1;
			ULONG ReservedFlags3 : 2;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ChpeImage : 1;
			ULONG ReservedFlags5 : 2;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY32 HashLinks;

	ULONG TimedateStamp;
	DWORD EntryPointActivationContext;
	DWORD Spare;

	DWORD DdagNode; // -> LDR_DDAG_NODE_WIN11_32

	LIST_ENTRY32	NodeModuleLink;
	DWORD			LoadContext;
	DWORD			ParentDllBase;
	DWORD			SwitchBackContext;

	RTL_BALANCED_NODE_32 BaseAddressIndexNode;
	RTL_BALANCED_NODE_32 MappingInfoIndexNode;

	DWORD				OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
	ULONG				ImplicitPathOptions;

	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
	UCHAR SigningLevel;

	ULONG CheckSum;
	DWORD ActivePathImageBase;
	LDR_HOT_PATCH_STATE HotPatchState;
} LDR_DATA_TABLE_ENTRY_WIN11_32, * PLDR_DATA_TABLE_ENTRY_WIN11_32;

#endif
```

`win_7.h`:

```h
#pragma once

#include "nt_defs.h"

//some flags might not be Win7 but w/e, stolen from here:
//https://doxygen.reactos.org/d1/d97/ldrtypes_8h_source.html#l00034

//0x00000001
#define LDRP_STATIC_LINK				0x00000002
#define LDRP_IMAGE_DLL					0x00000004
#define LDRP_SHIMENG_ENTRY_PROCESSED	0x00000008
#define LDRP_TELEMETRY_ENTRY_PROCESSED	0x00000010
#define LDRP_IMAGE_INTEGRITY_FORCED		0x00000020
//0x00000040 - 0x00000800
#define LDRP_LOAD_IN_PROGRESS			0x00001000
#define LDRP_UNLOAD_IN_PROGRESS			0x00002000
#define LDRP_ENTRY_PROCESSED			0x00004000
#define LDRP_ENTRY_INSERTED				0x00008000  
#define LDRP_CURRENT_LOAD				0x00010000
#define LDRP_FAILED_BUILTIN_LOAD		0x00020000
#define LDRP_DONT_CALL_FOR_THREADS		0x00040000
#define LDRP_PROCESS_ATTACH_CALLED		0x00080000
#define LDRP_DEBUG_SYMBOLS_LOADED		0x00100000 
#define LDRP_IMAGE_NOT_AT_BASE			0x00200000 
#define LDRP_COR_IMAGE					0x00400000 
#define LDR_COR_OWNS_UNMAP				0x00800000 
#define LDRP_SYSTEM_MAPPED				0x01000000 
#define LDRP_IMAGE_VERIFYING			0x02000000 
#define LDRP_DRIVER_DEPENDENT_DLL		0x04000000 
#define LDRP_ENTRY_NATIVE				0x08000000 
#define LDRP_REDIRECTED					0x10000000 
#define LDRP_NON_PAGED_DEBUG_INFO		0x20000000 
#define LDRP_MM_LOADED					0x40000000 
#define LDRP_COMPAT_DATABASE_PROCESSED	0x80000000

typedef struct _LDR_DDAG_NODE_WIN7 //dummy for macros
{
} LDR_DDAG_NODE_WIN7, * PLDR_DDAG_NODE_WIN7;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN7
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING	FullDllName;
	UNICODE_STRING	BaseDllName;

	ULONG	Flags;
	WORD	LoadCount;
	WORD	TlsIndex;

	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};

	union
	{
		ULONG TimeDateStamp;
		PVOID LoadedImports;
	};

	PVOID EntryPointActivationContext;
	PVOID PatchInformation;

	LIST_ENTRY ForwarderLinks;
	LIST_ENTRY ServiceTagLinks;
	LIST_ENTRY StaticLinks;

	PVOID			ContextInformation;
	ULONG_PTR		OriginalBase;
	LARGE_INTEGER	LoadTime;
} LDR_DATA_TABLE_ENTRY_WIN7, * PLDR_DATA_TABLE_ENTRY_WIN7;

typedef struct _RTL_INVERTED_FUNCTION_TABLE_WIN7
{
	ULONG Count;
	ULONG MaxCount;
	ULONG Epoch;
	RTL_INVERTED_FUNCTION_TABLE_ENTRY Entries[ANYSIZE_ARRAY];
} RTL_INVERTED_FUNCTION_TABLE_WIN7, * PRTL_INVERTED_FUNCTION_TABLE_WIN7;

#ifdef _WIN64

typedef struct _LDR_DDAG_NODE_WIN7_32 //dummy for macros
{
} LDR_DDAG_NODE_WIN7_32, * PLDR_DDAG_NODE_WIN7_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN7_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	ULONG	Flags;
	WORD	LoadCount;
	WORD	TlsIndex;

	union
	{
		LIST_ENTRY32 HashLinks;
		struct
		{
			DWORD SectionPointer;
			ULONG CheckSum;
		};
	};

	union
	{
		ULONG TimeDateStamp;
		DWORD LoadedImports;
	};

	DWORD EntryPointActivationContext;
	DWORD PatchInformation;

	LIST_ENTRY32 ForwarderLinks;
	LIST_ENTRY32 ServiceTagLinks;
	LIST_ENTRY32 StaticLinks;

	DWORD			ContextInformation;
	DWORD			OriginalBase;
	LARGE_INTEGER	LoadTime;
} LDR_DATA_TABLE_ENTRY_WIN7_32, * PLDR_DATA_TABLE_ENTRY_WIN7_32;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY_WIN7_32 //prototype
{
	LIST_ENTRY32	List;
	DWORD			Flag;
	DWORD			VectoredHandler; //PVECTORED_EXCEPTION_HANDLER
} RTL_VECTORED_EXCEPTION_ENTRY_WIN7_32, * PRTL_VECTORED_EXCEPTION_ENTRY_WIN7_32;

#endif
```

`win_8.h`:

```h
#pragma once

#include "nt_defs.h"

typedef struct _LDR_DDAG_NODE_WIN8
{
	LIST_ENTRY				Modules;
	PLDR_SERVICE_TAG_RECORD	ServiceTagList;
	ULONG					LoadCount;
	ULONG					ReferenceCount;
	ULONG					DependencyCount;
	union
	{
		LDRP_CSLIST			Dependencies;
		SINGLE_LIST_ENTRY* RemovalLink;
	};
	PLDRP_CSLIST			IncomingDependencies;
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY		CondenseLink;
	ULONG					PreorderNumber;
	ULONG					LowestLink;
} LDR_DDAG_NODE_WIN8, * PLDR_DDAG_NODE_WIN8;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN8
{
	LIST_ENTRY		InLoadOrderLinks;
	LIST_ENTRY		InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING	FullDllName;
	UNICODE_STRING	BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG ReservedFlags2 : 1;
			ULONG EntryProcessed : 1;
			ULONG ReservedFlags3 : 3;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ReservedFlags5 : 3;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY HashLinks;

	ULONG TimedateStamp;
	PVOID EntryPointActivationContext;
	PVOID PatchInformation;

	LDR_DDAG_NODE_WIN8* DdagNode;

	LIST_ENTRY	NodeModuleLink;
	PVOID		SnapContext;
	PVOID		ParentDllBase;
	PVOID		SwitchBackContext;

	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;

	ULONG_PTR			OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
} LDR_DATA_TABLE_ENTRY_WIN8, * PLDR_DATA_TABLE_ENTRY_WIN8;

typedef struct _LDRP_PATH_SEARCH_CONTEXT_WIN8
{
	ULONG_PTR Flags; //probably LDRP_LOAD_CONTEXT_FLAGS
	wchar_t* OriginalFullDllName; //can be path
	BOOLEAN		unknown2; //only low byte relevant
	ULONG_PTR	unknown3[3]; //sometimes imagebase?
} LDRP_PATH_SEARCH_CONTEXT_WIN8, * PLDRP_PATH_SEARCH_CONTEXT_WIN8;

#ifdef _WIN64

typedef __declspec(align(4)) struct _LDR_DDAG_NODE_WIN8_32
{
	LIST_ENTRY32	Modules;
	DWORD			ServiceTagList; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG			LoadCount;
	ULONG			ReferenceCount;
	ULONG			DependencyCount;
	union
	{
		LDRP_CSLIST_32	Dependencies;
		DWORD			RemovalLink; // -> SINGLE_LIST_ENTRY_32
	};
	DWORD					IncomingDependencies; // -> LDRP_CSLIST_32
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY_32	CondenseLink;
	ULONG					PreorderNumber;
	ULONG					LowestLink;
} LDR_DDAG_NODE_WIN8_32, * PLDR_DDAG_NODE_WIN8_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN8_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	union
	{
		LIST_ENTRY32 InInitializationOrderLinks;
		LIST_ENTRY32 InProgressLinks;
	};

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG ReservedFlags2 : 1;
			ULONG EntryProcessed : 1;
			ULONG ReservedFlags3 : 3;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ReservedFlags5 : 3;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY32 HashLinks;

	ULONG TimedateStamp;
	DWORD EntryPointActivationContext;
	DWORD PatchInformation;

	DWORD DdagNode; // -> LDR_DDAG_NODE_WIN8_32

	LIST_ENTRY32	NodeModuleLink;
	DWORD			SnapContext;
	DWORD			ParentDllBase;
	DWORD			SwitchBackContext;

	RTL_BALANCED_NODE_32 BaseAddressIndexNode;
	RTL_BALANCED_NODE_32 MappingInfoIndexNode;

	DWORD				OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
} LDR_DATA_TABLE_ENTRY_WIN8_32, * PLDR_DATA_TABLE_ENTRY_WIN8_32;

#endif
```

`win_81.h`:

```h
#pragma once

#include "nt_defs.h"

typedef struct _LDR_DDAG_NODE_WIN81
{
	LIST_ENTRY				Modules;
	PLDR_SERVICE_TAG_RECORD	ServiceTagList;
	ULONG					LoadCount;
	ULONG					ReferenceCount;
	ULONG					DependencyCount;
	union
	{
		LDRP_CSLIST			Dependencies;
		SINGLE_LIST_ENTRY* RemovalLink;
	};
	PLDRP_CSLIST			IncomingDependencies;
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY		CondenseLink;
	ULONG					PreorderNumber;
	ULONG					LowestLink;
} LDR_DDAG_NODE_WIN81, * PLDR_DDAG_NODE_WIN81;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN81
{
	LIST_ENTRY		InLoadOrderLinks;
	LIST_ENTRY		InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING	FullDllName;
	UNICODE_STRING	BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG ReservedFlags2 : 1;
			ULONG EntryProcessed : 1;
			ULONG ReservedFlags3 : 3;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ReservedFlags5 : 3;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY HashLinks;

	ULONG TimedateStamp;
	PVOID EntryPointActivationContext;
	PVOID Spare;

	LDR_DDAG_NODE_WIN81* DdagNode;

	LIST_ENTRY	NodeModuleLink;
	PVOID		SnapContext;
	PVOID		ParentDllBase;
	PVOID		SwitchBackContext;

	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;

	ULONG_PTR			OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;

	ULONG ImplicitPathOptions;
} LDR_DATA_TABLE_ENTRY_WIN81, * PLDR_DATA_TABLE_ENTRY_WIN81;

typedef struct _LDRP_PATH_SEARCH_CONTEXT_WIN81
{
	UINT_PTR unknown_0[3];
	wchar_t* OriginalFullDllName;
	UINT_PTR unknown_1[1];
} LDRP_PATH_SEARCH_CONTEXT_WIN81, * PLDRP_PATH_SEARCH_CONTEXT_WIN81; //x86 size = 0x14, x64 size = 0x28

#ifdef _WIN64

typedef __declspec(align(4)) struct _LDR_DDAG_NODE_WIN81_32
{
	LIST_ENTRY32	Modules;
	DWORD			ServiceTagList; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG			LoadCount;
	ULONG			ReferenceCount;
	ULONG			DependencyCount;
	union
	{
		LDRP_CSLIST_32	Dependencies;
		DWORD			RemovalLink; // -> SINGLE_LIST_ENTRY_32
	};
	DWORD					IncomingDependencies; // -> LDRP_CSLIST_32
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY_32	CondenseLink;
	ULONG					PreorderNumber;
	ULONG					LowestLink;
} LDR_DDAG_NODE_WIN81_32, * PLDR_DDAG_NODE_WIN81_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN81_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	union
	{
		LIST_ENTRY32 InInitializationOrderLinks;
		LIST_ENTRY32 InProgressLinks;
	};

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG ReservedFlags2 : 1;
			ULONG EntryProcessed : 1;
			ULONG ReservedFlags3 : 3;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ReservedFlags5 : 3;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY32 HashLinks;

	ULONG TimedateStamp;
	DWORD EntryPointActivationContext;
	DWORD Spare;

	DWORD DdagNode; // -> LDR_DDAG_NODE_WIN81_32

	LIST_ENTRY32	NodeModuleLink;
	DWORD			SnapContext;
	DWORD			ParentDllBase;
	DWORD			SwitchBackContext;

	RTL_BALANCED_NODE_32 BaseAddressIndexNode;
	RTL_BALANCED_NODE_32 MappingInfoIndexNode;

	DWORD				OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;

	ULONG ImplicitPathOptions;
} LDR_DATA_TABLE_ENTRY_WIN81_32, * PLDR_DATA_TABLE_ENTRY_WIN81_32;

#endif
```