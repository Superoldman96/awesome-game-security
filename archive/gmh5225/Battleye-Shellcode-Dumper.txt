Project Path: arc_gmh5225_Battleye-Shellcode-Dumper_sxmecodg

Source Tree:

```txt
arc_gmh5225_Battleye-Shellcode-Dumper_sxmecodg
├── BattleyeShellCodeDumper
│   ├── BattleyeShellCodeDumper.vcxproj
│   ├── BattleyeShellCodeDumper.vcxproj.filters
│   ├── BattleyeShellCodeDumper.vcxproj.user
│   ├── dllmain.cpp
│   ├── lazy_importer.h
│   └── xor.h
├── BattleyeShellCodeDumper.sln
├── LICENSE
└── README.md

```

`BattleyeShellCodeDumper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30225.117
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BattleyeShellCodeDumper", "BattleyeShellCodeDumper\BattleyeShellCodeDumper.vcxproj", "{C000D07B-3806-437C-8F0E-912744897A4D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C000D07B-3806-437C-8F0E-912744897A4D}.Debug|x64.ActiveCfg = Debug|x64
		{C000D07B-3806-437C-8F0E-912744897A4D}.Debug|x64.Build.0 = Debug|x64
		{C000D07B-3806-437C-8F0E-912744897A4D}.Debug|x86.ActiveCfg = Debug|Win32
		{C000D07B-3806-437C-8F0E-912744897A4D}.Debug|x86.Build.0 = Debug|Win32
		{C000D07B-3806-437C-8F0E-912744897A4D}.Release|x64.ActiveCfg = Release|x64
		{C000D07B-3806-437C-8F0E-912744897A4D}.Release|x64.Build.0 = Release|x64
		{C000D07B-3806-437C-8F0E-912744897A4D}.Release|x86.ActiveCfg = Release|Win32
		{C000D07B-3806-437C-8F0E-912744897A4D}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C2060FFB-8A2E-4215-BE7E-F0CAF6671391}
	EndGlobalSection
EndGlobal

```

`BattleyeShellCodeDumper/BattleyeShellCodeDumper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c000d07b-3806-437c-8f0e-912744897a4d}</ProjectGuid>
    <RootNamespace>BattleyeShellCodeDumper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;BATTLEYESHELLCODEDUMPER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;BATTLEYESHELLCODEDUMPER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;BATTLEYESHELLCODEDUMPER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;BATTLEYESHELLCODEDUMPER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="lazy_importer.h" />
    <ClInclude Include="xor.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BattleyeShellCodeDumper/BattleyeShellCodeDumper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Arquivos de Origem">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Arquivos de Cabeçalho">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Arquivos de Recurso">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="xor.h">
      <Filter>Arquivos de Cabeçalho</Filter>
    </ClInclude>
    <ClInclude Include="lazy_importer.h">
      <Filter>Arquivos de Cabeçalho</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Arquivos de Origem</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`BattleyeShellCodeDumper/BattleyeShellCodeDumper.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`BattleyeShellCodeDumper/dllmain.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include <vector>
#include <Windows.h>
#include "lazy_importer.h"
#include "xor.h"



bool IsValidPtr(void* pointer)
{
    constexpr auto minimum_application_address = intptr_t(0x00010000);
    constexpr auto maximum_application_address = intptr_t(0x7FFFFFFEFFFF);
    return !(reinterpret_cast<intptr_t>(pointer) < minimum_application_address || reinterpret_cast<intptr_t>(pointer) >
             maximum_application_address) && pointer;
}

int LockLibraryIntoProcessMem(HMODULE dllHandle, HMODULE* localDllHandle)
{
    if (nullptr == localDllHandle)
        return ERROR_INVALID_PARAMETER;


    *localDllHandle = nullptr;

    TCHAR moduleName[1024];

    if (0 == iat(GetModuleFileNameW).cached()(dllHandle, moduleName, sizeof moduleName / sizeof(TCHAR)))
        return iat(GetLastError).cached()();

    *localDllHandle = iat(LoadLibraryW).cached()(moduleName);

    if (nullptr == *localDllHandle)
        return iat(GetLastError).cached()();


    return NO_ERROR;
}

uintptr_t PatternScan(const uintptr_t moduleAdress, const char* signature)
{
    static auto patternToByte = [](const char* pattern)
    {
        auto       bytes = std::vector<int>{};
        const auto start = const_cast<char*>(pattern);
        const auto end   = const_cast<char*>(pattern) + strlen(pattern);

        for (auto current = start; current < end; ++current)
        {
            if (*current == '?')
            {
                ++current;
                if (*current == '?')
                    ++current;
                bytes.push_back(-1);
            }
            else { bytes.push_back(strtoul(current, &current, 16)); }
        }
        return bytes;
    };

    const auto dosHeader = (PIMAGE_DOS_HEADER)moduleAdress;
    const auto ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)moduleAdress + dosHeader->e_lfanew);

    const auto sizeOfImage  = ntHeaders->OptionalHeader.SizeOfImage;
    auto       patternBytes = patternToByte(signature);
    const auto scanBytes    = reinterpret_cast<std::uint8_t*>(moduleAdress);

    const auto s = patternBytes.size();
    const auto d = patternBytes.data();

    for (auto i = 0ul; i < sizeOfImage - s; ++i)
    {
        bool found = true;
        for (auto j = 0ul; j < s; ++j)
        {
            if (scanBytes[i + j] != d[j] && d[j] != -1)
            {
                found = false;
                break;
            }
        }
        if (found) { return reinterpret_cast<uintptr_t>(&scanBytes[i]); }
    }
    return NULL;
}

bool CreateHook(uintptr_t originalPresent, uintptr_t originalHooked, uintptr_t pOriginal)
{
    using CreateHook_t = uint64_t(__fastcall*)(LPVOID, LPVOID, LPVOID*);
    static CreateHook_t fnCreateHook = nullptr;


    if (!IsValidPtr(fnCreateHook))
    {
        fnCreateHook = (CreateHook_t)PatternScan((uintptr_t)GetModuleHandle(xorstr_(L"DiscordHook64.dll").c_str()),
                                                 xorstr_(
                                                     "40 53 55 56 57 41 54 41 56 41 57 48 83 EC 60").
                                                 c_str());
    }

    if (!IsValidPtr(fnCreateHook))
    {
        printf(xorstr_("[FAIL] CreateHook was NULL").c_str());
        return false;
    }


    return fnCreateHook((void*)originalPresent, (void*)originalHooked,
                        (void**)pOriginal) == 0
               ? true
               : false;
}

bool EnableHook(uintptr_t pTarget, bool toggle)
{
    using EnableHook_t = uint64_t(__fastcall*)(LPVOID, bool);
    static EnableHook_t fnEnableHook = nullptr;

    if (!IsValidPtr(fnEnableHook))
    {
        fnEnableHook = (EnableHook_t)PatternScan((uintptr_t)GetModuleHandle(xorstr_(L"DiscordHook64.dll").c_str()),
                                                 xorstr_(
                                                     "48 89 5C 24 ? 48 89 6C 24 ? 48 89 74 24 ? 57 41 56 41 57 48 83 EC 20 33 F6 8B FA")
                                                 .c_str());
    }

    if (!IsValidPtr(fnEnableHook))
    {
        printf(xorstr_("[FAIL] EnableHook was NULL").c_str());
        return false;
    }

    return fnEnableHook((void*)pTarget, toggle) == 0 ? true : false;
}

bool EnableHookQue()
{
    using EnableHookQueu_t = uint64_t(__stdcall*)(VOID);
    static EnableHookQueu_t fnEnableHookQueu = nullptr;

    if (!IsValidPtr(fnEnableHookQueu))
    {
        fnEnableHookQueu = (EnableHookQueu_t)PatternScan(
            (uintptr_t)GetModuleHandle(xorstr_(L"DiscordHook64.dll").c_str()),
            xorstr_(
                "48 89 5C 24 ? 48 89 6C 24 ? 48 89 7C 24 ? 41 57")
            .c_str());
    }

    if (!IsValidPtr(fnEnableHookQueu))
    {
        printf(xorstr_("[FAIL] EnableHookQue was NULL").c_str());
        return false;
    }

    return fnEnableHookQueu() == 0 ? true : false;
}

bool HookFunction(uintptr_t originalPresent, uintptr_t originalHooked, uintptr_t pTrampolim)
{
    if (CreateHook(originalPresent, originalHooked, pTrampolim))
    {
        if (EnableHook(originalPresent, true))
        {
            if (EnableHookQue())
            {
                return true;
            }
        }
    }

    return false;
}

void AttachConsole()
{
    iat(AllocConsole).cached()();
    freopen(xorstr_("CONOUT$").c_str(), "w", stdout);
}


using CreateFileA_t = HANDLE(__stdcall*)(
    LPCSTR                lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
);


using CreateFileW_t = HANDLE (__stdcall*)(
    LPCWSTR               lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
);


using WriteFile_t = BOOL (__stdcall*)(
    HANDLE       hFile,
    LPCVOID      lpBuffer,
    DWORD        nNumberOfBytesToWrite,
    LPDWORD      lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
);

using WriteFileEx_t = BOOL (__stdcall*)(
    HANDLE                          hFile,
    LPCVOID                         lpBuffer,
    DWORD                           nNumberOfBytesToWrite,
    LPOVERLAPPED                    lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
);


CreateFileA_t orig_CreateFileA;
CreateFileW_t orig_CreateFileW;
WriteFile_t   orig_WriteFile;
WriteFileEx_t orig_WriteFileEx;


HANDLE BE_StreamedHandle = nullptr;

HANDLE CreateFileA_Hk(
    LPCSTR                lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
)
{
    // If we found BEClient2
    if (strstr(lpFileName, xorstr_("BEClient2").c_str()) != nullptr)
    {
        printf(xorstr_("\n\n-----------[ Battleye Streamed BEClient2 ] -----------\n").c_str());
        printf(xorstr_("USING: CreateFileA.\n").c_str());
        printf(xorstr_("SAVE PATH: %s.\n").c_str(), lpFileName);

        // Get the handle to where it wants to save.
        auto tempHandle = orig_CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
                                           dwCreationDisposition,
                                           dwFlagsAndAttributes, hTemplateFile);

        printf(xorstr_("HANDLE: %d.\n").c_str(), tempHandle);
        printf(xorstr_("-------------------------------------------------------------\n\n").c_str());

        BE_StreamedHandle = tempHandle;

        return tempHandle;
    }
    if (strstr(lpFileName, xorstr_("BattlEye").c_str()) != nullptr)
    {
        printf(xorstr_("[Battleye-Stuf]: %s \n").c_str(), lpFileName);
    }
    else
    {
        printf(xorstr_("[HK-CreateFileA]: %s \n").c_str(), lpFileName);
    }

    return orig_CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition,
                            dwFlagsAndAttributes, hTemplateFile);
}

HANDLE CreateFileW_Hk(
    LPCWSTR               lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
)
{
    // If we found BEClient2
    if (wcsstr(lpFileName, xorstr_(L"BEClient2").c_str()) != nullptr)
    {
        printf(xorstr_("\n\n-----------[ Battleye Streamed BEClient2 ] -----------\n").c_str());
        printf(xorstr_("USING: CreateFileA.\n").c_str());
        printf(xorstr_("SAVE PATH: %ls.\n").c_str(), lpFileName);
        printf(xorstr_("DESIRE AACCESS: %d.\n").c_str(), dwShareMode);

        // Get the handle to where it wants to save.
        auto tempHandle = orig_CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
                                           dwCreationDisposition,
                                           dwFlagsAndAttributes, hTemplateFile);

        printf(xorstr_("HANDLE: %p.\n").c_str(), tempHandle);
        printf(xorstr_("-------------------------------------------------------------\n\n").c_str());

        BE_StreamedHandle = tempHandle;

        return tempHandle;
    }
    if (wcsstr(lpFileName, xorstr_(L"BattlEye").c_str()) != nullptr)
    {
        printf(xorstr_("[BE-Stuff]: %ls \n").c_str(), lpFileName);
    }
    else
    {
        printf(xorstr_("[HK-CreateFileW]: %ls \n").c_str(), lpFileName);
    }

    return orig_CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition,
                            dwFlagsAndAttributes, hTemplateFile);
}


bool WriteFile_Hk(
    HANDLE       hFile,
    LPCVOID      lpBuffer,
    DWORD        nNumberOfBytesToWrite,
    LPDWORD      lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
)
{
    // Check if BE_StreamedHandle is not null, if its not, it means that be streamed the module, then, check if the current file to be save is the streamed module.
    if (BE_StreamedHandle != nullptr && hFile == BE_StreamedHandle)
    {
        printf(xorstr_("\n\n-----------[ Saving BEClient2 ] -----------\n").c_str());
        printf(xorstr_("HANDLE: %p.\n").c_str(), hFile);
        printf(xorstr_("Buffer: %p.\n").c_str(), lpBuffer);
        printf(xorstr_("Size: %p.\n\n").c_str(), nNumberOfBytesToWrite);


        static int i = 0; // We increase that +=1 each for each dump


        std::wstring filePath = xorstr_(L"D:\\BEClient2_").c_str(); //Location to be saved the BEClient2.
        filePath.append(std::to_wstring(i) + xorstr_(L".dll").c_str());


        printf(xorstr_("[-] Opening handle to our file... \n").c_str());
        // Open a handle for saving
        auto* handleOurDump = CreateFile(filePath.c_str(),
                                         GENERIC_WRITE,
                                         0,
                                         nullptr,
                                         CREATE_NEW,
                                         FILE_ATTRIBUTE_NORMAL,
                                         nullptr);


        // Check if the handle was opened with sucess.
        if (hFile == INVALID_HANDLE_VALUE)
        {
            printf(xorstr_("[x] Failed top open the file for Writing... \n").c_str());
            i++;


            return orig_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
        }

        printf(xorstr_("[+] Handle Opened: %p\n").c_str(), handleOurDump);

        printf(xorstr_("[-] Saving %d bytes of (BEClient2) to: %ls\n").c_str(), nNumberOfBytesToWrite,
               filePath.c_str());


        // WriteFile file to our location
        if (orig_WriteFile(handleOurDump, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped))
        {
            printf(xorstr_("[+] Saved %d bytes successfully.\n").c_str(), *lpNumberOfBytesWritten);
        }
        else
        {
            //todo: GestLastError maybe?
            printf(xorstr_("[x] Failed to save the file \n").c_str());
        }

        printf(xorstr_("-------------------------------------------------------------\n\n").c_str());

        
        // Close our opened file.
        CloseHandle(handleOurDump);

        // To save the next file
        i++;

        // Save the file where be desired in the first place.
        return orig_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
    }


    return orig_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}

bool WriteFileEx_Hk(
    HANDLE                          hFile,
    LPCVOID                         lpBuffer,
    DWORD                           nNumberOfBytesToWrite,
    LPOVERLAPPED                    lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
)
{
    // Check if BE_StreamedHandle is not null, if its not, it means that be streamed the module, then, check if the current file to be save is the streamed module.
    if (BE_StreamedHandle != nullptr && hFile == BE_StreamedHandle)
    {
        printf(xorstr_("\n\n-----------[ Saving BEClient2 ] -----------\n").c_str());
        printf(xorstr_("HANDLE: %p.\n").c_str(), hFile);
        printf(xorstr_("Buffer: %p.\n").c_str(), lpBuffer);
        printf(xorstr_("Size: %p.\n\n").c_str(), nNumberOfBytesToWrite);


        static int b = 0; // We increase that +=1 each for each dump


        std::wstring filePath = xorstr_(L"D:\\BEClient2Ex_").c_str(); //Location to be saved the BEClient2.
        filePath.append(std::to_wstring(b) + xorstr_(L".dll").c_str());


        printf(xorstr_("[-] Opening handle to our file... \n").c_str());
        // Open a handle for saving
        auto* handleOurDump = CreateFile(filePath.c_str(),
                                         GENERIC_WRITE,
                                         0,
                                         nullptr,
                                         CREATE_NEW,
                                         FILE_ATTRIBUTE_NORMAL,
                                         nullptr);


        // Check if the handle was opened with sucess.
        if (hFile == INVALID_HANDLE_VALUE)
        {
            printf(xorstr_("[x] Failed top open the file for Writing... \n").c_str());
            b++;
            return orig_WriteFileEx(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
        }

        printf(xorstr_("[+] Handle Opened: %p\n").c_str(), handleOurDump);

        printf(xorstr_("[-] Saving %d bytes of (BEClient2) to: %ls\n").c_str(), nNumberOfBytesToWrite,
               filePath.c_str());


        DWORD lpNumberOfBytesWritten;

        // WriteFile file to our location
        if (orig_WriteFile(handleOurDump, lpBuffer, nNumberOfBytesToWrite, &lpNumberOfBytesWritten, lpOverlapped))
        {
            printf(xorstr_("[+] Saved %d bytes successfully.\n").c_str(), lpNumberOfBytesWritten);
        }
        else
        {
            //todo: GestLastError maybe?
            printf(xorstr_("[x] Failed to save the file \n").c_str());
        }

        printf(xorstr_("-------------------------------------------------------------\n\n").c_str());


        // Close our opened file.
        CloseHandle(handleOurDump);

        // To save the next file
        b++;

        // Save the file where be desired in the first place.
        return orig_WriteFileEx(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
    }


    return orig_WriteFileEx(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
}


void HookStuff()
{
    AttachConsole();


    printf(xorstr_("------------------------------ STARTING HOOKING --------------------------------- \n\n\n").c_str());

    if (HookFunction((uintptr_t)CreateFileA, (uintptr_t)CreateFileA_Hk, (uintptr_t)&orig_CreateFileA))
        printf(xorstr_("[S] Hooked CreateFileA \n").c_str());
    else
        printf(xorstr_("[X] Failed CreateFileA \n").c_str());

    if (HookFunction((uintptr_t)CreateFileW, (uintptr_t)CreateFileW_Hk, (uintptr_t)&orig_CreateFileW))
        printf(xorstr_("[S] Hooked CreateFileW \n").c_str());
    else
        printf(xorstr_("[X] Failed CreateFileW \n").c_str());

    if (HookFunction((uintptr_t)WriteFile, (uintptr_t)WriteFile_Hk, (uintptr_t)&orig_WriteFile))
        printf(xorstr_("[S] Hooked WriteFile \n").c_str());
    else
        printf(xorstr_("[X] Failed WriteFile \n").c_str());

    if (HookFunction((uintptr_t)WriteFileEx, (uintptr_t)WriteFileEx_Hk, (uintptr_t)&orig_WriteFileEx))
        printf(xorstr_("[S] Hooked WriteFileEx \n").c_str());
    else
        printf(xorstr_("[X] Failed WriteFileEx \n").c_str());
}


HMODULE handler;

BOOL APIENTRY DllMain(HMODULE hModule,
                      DWORD   ul_reason_for_call,
                      LPVOID  lpReserved
)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        HookStuff();
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

```

`BattleyeShellCodeDumper/lazy_importer.h`:

```h
/*
 * Copyright 2018 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 // documentation is available at https://github.com/JustasMasiulis/lazy_importer

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP

#define LI_FN(name) \
    ::li::detail::lazy_function<::li::detail::khash(#name), decltype(&name)>()

#define iat(name) \
    ::li::detail::lazy_function<::li::detail::khash(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<::li::detail::khash(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<::li::detail::khash(name)>()

// NOTE only std::forward is used from this header.
// If there is a need to eliminate this dependency the function itself is very small.
#include <utility>
#include <cstddef>
#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif

#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_TOLOWER(c) (c >= 'A' && c <= 'Z' ? (c | (1 << 5)) : c)
#else
#define LAZY_IMPORTER_TOLOWER(c) (c)
#endif

namespace li {
    namespace detail {

        template<class First, class Second>
        struct pair {
            First  first;
            Second second;
        };

        namespace win {

            struct LIST_ENTRY_T {
                const char* Flink;
                const char* Blink;
            };

            struct UNICODE_STRING_T {
                unsigned short Length;
                unsigned short MaximumLength;
                wchar_t* Buffer;
            };

            struct PEB_LDR_DATA_T {
                unsigned long Length;
                unsigned long Initialized;
                const char* SsHandle;
                LIST_ENTRY_T  InLoadOrderModuleList;
            };

            struct PEB_T {
                unsigned char   Reserved1[2];
                unsigned char   BeingDebugged;
                unsigned char   Reserved2[1];
                const char* Reserved3[2];
                PEB_LDR_DATA_T* Ldr;
            };

            struct LDR_DATA_TABLE_ENTRY_T {
                LIST_ENTRY_T InLoadOrderLinks;
                LIST_ENTRY_T InMemoryOrderLinks;
                LIST_ENTRY_T InInitializationOrderLinks;
                const char* DllBase;
                const char* EntryPoint;
                union {
                    unsigned long SizeOfImage;
                    const char* _dummy;
                };
                UNICODE_STRING_T FullDllName;
                UNICODE_STRING_T BaseDllName;

                LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                    load_order_next() const noexcept
                {
                    return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
                        InLoadOrderLinks.Flink);
                }
            };

            struct IMAGE_DOS_HEADER { // DOS .EXE header
                unsigned short e_magic; // Magic number
                unsigned short e_cblp; // Bytes on last page of file
                unsigned short e_cp; // Pages in file
                unsigned short e_crlc; // Relocations
                unsigned short e_cparhdr; // Size of header in paragraphs
                unsigned short e_minalloc; // Minimum extra paragraphs needed
                unsigned short e_maxalloc; // Maximum extra paragraphs needed
                unsigned short e_ss; // Initial (relative) SS value
                unsigned short e_sp; // Initial SP value
                unsigned short e_csum; // Checksum
                unsigned short e_ip; // Initial IP value
                unsigned short e_cs; // Initial (relative) CS value
                unsigned short e_lfarlc; // File address of relocation table
                unsigned short e_ovno; // Overlay number
                unsigned short e_res[4]; // Reserved words
                unsigned short e_oemid; // OEM identifier (for e_oeminfo)
                unsigned short e_oeminfo; // OEM information; e_oemid specific
                unsigned short e_res2[10]; // Reserved words
                long           e_lfanew; // File address of new exe header
            };

            struct IMAGE_FILE_HEADER {
                unsigned short Machine;
                unsigned short NumberOfSections;
                unsigned long  TimeDateStamp;
                unsigned long  PointerToSymbolTable;
                unsigned long  NumberOfSymbols;
                unsigned short SizeOfOptionalHeader;
                unsigned short Characteristics;
            };

            struct IMAGE_EXPORT_DIRECTORY {
                unsigned long  Characteristics;
                unsigned long  TimeDateStamp;
                unsigned short MajorVersion;
                unsigned short MinorVersion;
                unsigned long  Name;
                unsigned long  Base;
                unsigned long  NumberOfFunctions;
                unsigned long  NumberOfNames;
                unsigned long  AddressOfFunctions; // RVA from base of image
                unsigned long  AddressOfNames; // RVA from base of image
                unsigned long  AddressOfNameOrdinals; // RVA from base of image
            };

            struct IMAGE_DATA_DIRECTORY {
                unsigned long VirtualAddress;
                unsigned long Size;
            };

            struct IMAGE_OPTIONAL_HEADER64 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long long   ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long long   SizeOfStackReserve;
                unsigned long long   SizeOfStackCommit;
                unsigned long long   SizeOfHeapReserve;
                unsigned long long   SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_OPTIONAL_HEADER32 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long        BaseOfData;
                unsigned long        ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long        SizeOfStackReserve;
                unsigned long        SizeOfStackCommit;
                unsigned long        SizeOfHeapReserve;
                unsigned long        SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_NT_HEADERS {
                unsigned long     Signature;
                IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
                IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
                IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
            };

        } // namespace win

        // hashing stuff
        struct hash_t {
            using value_type = unsigned long;
            constexpr static value_type         offset = 2166136261;
            constexpr static value_type         prime = 16777619;
            constexpr static unsigned long long prime64 = prime;

            LAZY_IMPORTER_FORCEINLINE constexpr static value_type single(value_type value,
                char c) noexcept
            {
                return static_cast<hash_t::value_type>(
                    (value ^ LAZY_IMPORTER_TOLOWER(c)) *
                    static_cast<unsigned long long>(prime));
            }
        };

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE constexpr hash_t::value_type
            khash(const CharT* str, hash_t::value_type value = hash_t::offset) noexcept
        {
            return (*str ? khash(str + 1, hash_t::single(value, *str)) : value);
        }

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(const CharT* str) noexcept
        {
            hash_t::value_type value = hash_t::offset;

            for (;;) {
                char c = *str++;
                if (!c)
                    return value;
                value = hash_t::single(value, c);
            }
        }

        LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(
            const win::UNICODE_STRING_T& str) noexcept
        {
            auto       first = str.Buffer;
            const auto last = first + (str.Length / sizeof(wchar_t));
            auto       value = hash_t::offset;
            for (; first != last; ++first)
                value = hash_t::single(value, static_cast<char>(*first));

            return value;
        }

        LAZY_IMPORTER_FORCEINLINE pair<hash_t::value_type, hash_t::value_type> hash_forwarded(
            const char* str) noexcept
        {
            pair<hash_t::value_type, hash_t::value_type> module_and_function{
                hash_t::offset, hash_t::offset
            };

            for (; *str != '.'; ++str)
                hash_t::single(module_and_function.first, *str);

            ++str;

            for (; *str; ++str)
                hash_t::single(module_and_function.second, *str);

            return module_and_function;
        }


        // some helper functions
        LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
        {
#if defined(_WIN64)
            return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_WIN32)
            return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
        }

        LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
        {
            return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
            const char* base) noexcept
        {
            return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
                base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
            const char* base) noexcept
        {
            return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
        }

        LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
        {
            return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
                ldr()->InLoadOrderModuleList.Flink);
        }

        struct exports_directory {
            const char* _base;
            const win::IMAGE_EXPORT_DIRECTORY* _ied;
            unsigned long                      _ied_size;

        public:
            using size_type = unsigned long;

            LAZY_IMPORTER_FORCEINLINE
                exports_directory(const char* base) noexcept : _base(base)
            {
                const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
                _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                    base + ied_data_dir.VirtualAddress);
                _ied_size = ied_data_dir.Size;
            }

            LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
            {
                return reinterpret_cast<const char*>(_ied) != _base;
            }

            LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
            {
                return _ied->NumberOfNames;
            }

            LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
            LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
            {
                return _ied;
            }

            LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
            {
                return reinterpret_cast<const char*>(
                    _base + reinterpret_cast<const unsigned long*>(
                        _base + _ied->AddressOfNames)[index]);
            }

            LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
            {
                const auto* const rva_table =
                    reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

                const auto* const ord_table = reinterpret_cast<const unsigned short*>(
                    _base + _ied->AddressOfNameOrdinals);

                return _base + rva_table[ord_table[index]];
            }

            LAZY_IMPORTER_FORCEINLINE bool is_forwarded(const char* export_address) const
                noexcept
            {
                const auto ui_ied = reinterpret_cast<const char*>(_ied);
                return (export_address > ui_ied && export_address < ui_ied + _ied_size);
            }
        };

        struct safe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
            value_type* value;
            value_type* const head;

            LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
                : value(ldr_data_entry()), head(value)
            {}

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = head; }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept
            {
                value = value->load_order_next();
                return value != head && value->DllBase;
            }
        };

        struct unsafe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
            value_type value;

            LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
                : value(ldr_data_entry())
            {}

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept
            {
                value = value->load_order_next();
                return true;
            }
        };

        // provides the cached functions which use Derive classes methods
        template<class Derived, class DefaultType = void*>
        class lazy_base {
        protected:
            // This function is needed because every templated function
            // with different args has its own static buffer
            LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
            {
                static void* value = nullptr;
                return value;
            }

        public:
            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
            {
                return Derived::template get<T, safe_module_enumerator>();
            }

            template<class T = DefaultType, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
            {
                auto& cached = _cache();
                if (!cached)
                    cached = Derived::template get<void*, Enum>();

                return (T)(cached);
            }

            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
            {
                return cached<T, safe_module_enumerator>();
            }
        };

        template<hash_t::value_type Hash>
        struct lazy_module : lazy_base<lazy_module<Hash>> {
            template<class T = void*, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T get() noexcept
            {
                Enum e;
                do {
                    if (hash(e.value->BaseDllName) == Hash)
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }
        };

        template<hash_t::value_type Hash, class T>
        struct lazy_function : lazy_base<lazy_function<Hash, T>, T> {
            using base_type = lazy_base<lazy_function<Hash, T>, T>;

            template<class... Args>
            LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&& ... args) const
            {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
                return get()(std::forward<Args>(args)...);
#else
                return this->cached()(std::forward<Args>(args)...);
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F get() noexcept
            {
                // for backwards compatability.
                // Before 2.0 it was only possible to resolve forwarded exports when
                // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
                return forwarded<F, Enum>();
#else
                Enum e;
                do {
                    const exports_directory exports(e.value->DllBase);

                    if (exports) {
                        auto export_index = exports.size();
                        while (export_index--)
                            if (hash(exports.name(export_index)) == Hash)
                                return (F)(exports.address(export_index));
                    }
                } while (e.next());
                return {};
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
            {
                detail::win::UNICODE_STRING_T name;
                hash_t::value_type            module_hash = 0;
                auto                          function_hash = Hash;

                Enum e;
                do {
                    name = e.value->BaseDllName;
                    name.Length -= 8; // get rid of .dll extension

                    if (!module_hash || hash(name) == module_hash) {
                        const exports_directory exports(e.value->DllBase);

                        if (exports) {
                            auto export_index = exports.size();
                            while (export_index--)
                                if (hash(exports.name(export_index)) == function_hash) {
                                    const auto addr = exports.address(export_index);

                                    if (exports.is_forwarded(addr)) {
                                        auto hashes = hash_forwarded(
                                            reinterpret_cast<const char*>(addr));

                                        function_hash = hashes.second;
                                        module_hash = hashes.first;

                                        e.reset();
                                        break;
                                    }
                                    return (F)(addr);
                                }
                        }
                    }
                } while (e.next());
                return {};
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
            {
                return forwarded<F, safe_module_enumerator>();
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
            {
                auto& value = base_type::_cache();
                if (!value)
                    value = forwarded<void*, Enum>();
                return (F)(value);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
            {
                return forwarded_cached<F, safe_module_enumerator>();
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
            {
                if (IsSafe && !m)
                    return {};

                const exports_directory exports((const char*)(m));
                if (IsSafe && !exports)
                    return {};

                for (unsigned long i{};; ++i) {
                    if (IsSafe && i == exports.size())
                        break;

                    if (hash(exports.name(i)) == Hash)
                        return (F)(exports.address(i));
                }
                return {};
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
            {
                return in<F, true>(m);
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
            {
                auto& value = base_type::_cache();
                if (!value)
                    value = in<void*, IsSafe>(m);
                return (F)(value);
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
            {
                return in_cached<F, true>(m);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
            {
                return in<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
            {
                return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
            {
                return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
            {
                return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }
        };

    }
} // namespace li::detail

#endif // include guard

```

`BattleyeShellCodeDumper/xor.h`:

```h
#pragma once

#include <string>
#ifdef _MSC_VER
#define ALWAYS_INLINE __forceinline
#else
#define ALWAYS_INLINE __attribute__((always_inline))
#endif


template<typename T, size_t L>
class XorStrEx
{
    static constexpr auto kLengthMinusOne = L - 1;

public:
    constexpr ALWAYS_INLINE XorStrEx(T const (&str)[L])
        : XorStrEx(str, std::make_index_sequence<kLengthMinusOne>())
    {
    }

    auto c_str_raw() const
    {
        return data;
    }

    auto c_str() const
    {
        decrypt();
        return data;
    }

    auto str() const
    {
        decrypt();
        return std::basic_string<T>(data, data + kLengthMinusOne);
    }

    operator std::basic_string<T>() const
    {
        return str();
    }

    void encrypt() const
    {
        if (!encrypted)
        {
            xorData();
            encrypted = true;
        }
    }

    void decrypt() const
    {
        if (encrypted)
        {
            xorData();
            encrypted = false;
        }
    }

private:
    mutable T data[L];
    mutable bool encrypted;

    template<size_t... indices>
    constexpr ALWAYS_INLINE XorStrEx(T const (&str)[L], std::index_sequence<indices...>)
        : data{ xorChar(str[indices], indices)..., '\0' },
        encrypted(true)
    {
    }

    static ALWAYS_INLINE constexpr int atoi(char c)
    {
        return c - '0';
    }

    static constexpr auto RANDOM_XOR_KEY = static_cast<T>(
        atoi(__TIME__[7]) +
        atoi(__TIME__[6]) * 10 +
        atoi(__TIME__[4]) * 60 +
        atoi(__TIME__[3]) * 600 +
        atoi(__TIME__[1]) * 3600 +
        atoi(__TIME__[0]) * 36000
        );

    static ALWAYS_INLINE constexpr auto xorChar(T c, size_t i)
    {
        return static_cast<T>(c ^ (RANDOM_XOR_KEY + i));
    }

    void xorData() const
    {
        for (size_t t = 0; t < kLengthMinusOne; t++)
        {
            data[t] = xorChar(data[t], t);
        }
    }
};
//---------------------------------------------------------------------------
template<size_t L>
using XorStrA = XorStrEx<char, L>;
template<size_t L>
using XorStrW = XorStrEx<wchar_t, L>;
//---------------------------------------------------------------------------
template<typename T, size_t L>
constexpr ALWAYS_INLINE auto xorstr_(const T(&str)[L])
{
    return XorStrEx<T, L>(str);
}



template<typename T, size_t L, size_t LC>
auto operator==(const XorStrEx<T, L>& lhs, const XorStrEx<T, LC>& rhs)
{
    static_assert(L == LC, "XorStrEx length is different");

    return L == LC && lhs.str() == rhs.str();
}

template<typename T, size_t L>
auto operator==(const T& lhs, const XorStrEx<T, L>& rhs)
{
    return lhs.size() == L && lhs == rhs.str();
}

template<typename ST, typename T, size_t L>
auto& operator<<(ST& lhs, const XorStrEx<T, L>& rhs)
{
    lhs << rhs.c_str();

    return lhs;
}

template<typename T, size_t L, size_t LC>
auto operator+(const XorStrEx<T, L>& lhs, const XorStrEx<T, LC>& rhs)
{
    return lhs.str() + rhs.str();
}

template<typename T, size_t L>
auto operator+(const T& lhs, const XorStrEx<T, L>& rhs)
{
    return lhs + rhs.str();
}
```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Lucas Guilherme

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Battleye-Shellcode-Dumper

This project dump Battleye streamed shellcode. Compile and inject!

```