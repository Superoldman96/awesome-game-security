Project Path: arc_gmh5225_ELFpacker_ifn6juxa

Source Tree:

```txt
arc_gmh5225_ELFpacker_ifn6juxa
├── Makefile
├── defs.h
├── dump.c
├── elflib.c
├── elfpack.c
├── main.c
└── stub.c

```

`Makefile`:

```
OBJS = \
	dump.o\
	elflib.o\
	elfpack.o\
	stub.o\

CC = gcc
CFLAGS = -Wall

binary_packer: main.o $(OBJS)
	$(CC) $(CFLAGS) -o binary_packer main.o $(OBJS)

clean:
	rm *.o

form:
	clang-format-6.0 -i *.[ch]

```

`defs.h`:

```h
#pragma once

#include <elf.h>
#include <stdio.h>
#include <sys/stat.h>

#define XORKEY 0x19

struct elf32_t {
    struct stat st;
    char *bin;
    Elf32_Ehdr *elfhdr;
    Elf32_Phdr *phdr;
    Elf32_Shdr *shdr;
    uint32_t stubsz;
};

// dump.c
void dump_elf(const struct elf32_t *e);

// elflib.c
void memsft(char *bin, int off, size_t size);
void remove_section_name(Elf32_Ehdr *elfhdr, Elf32_Shdr *shdr);
int search_entry_phdr(const Elf32_Phdr *phdr, int phnum, uint32_t entry);
int search_entry_shdr(const Elf32_Shdr *shdr, int shnum, uint32_t entry);

// elfpack.c
void free_elf(struct elf32_t *e);
int load_elf(struct elf32_t *e, const char *fname);
int pack_elf(struct elf32_t *e);
int write_elf(const struct elf32_t *e, const char *fname);

// stub.c
void add_stub(char *addr, uint32_t size);
void make_stub(uint32_t addr, uint32_t size, uint32_t entry, uint8_t key);
uint32_t stub_size();
```

`dump.c`:

```c
#include <elf.h>
#include <stdio.h>

#include "defs.h"

void dump_elfhdr(const Elf32_Ehdr *elfhdr);
void dump_phdr(const Elf32_Phdr *phdr);
void dump_shdr(const Elf32_Shdr *shdr, const char *strtab, uint32_t tabsize);

void dump_elf(const struct elf32_t *e)
{
    printf("----------------------------------------\n");
    dump_elfhdr(e->elfhdr);
    printf("----------------------------------------\n");
    for (int i = 0; i < e->elfhdr->e_phnum; i++) {
        dump_phdr(e->phdr + i);
    }
    printf("----------------------------------------\n");
    for (int i = 0; i < e->elfhdr->e_shnum; i++) {
        dump_shdr(e->shdr + i, &e->bin[e->shdr[e->elfhdr->e_shstrndx].sh_offset],
                  e->shdr[e->elfhdr->e_shstrndx].sh_size);
    }
    printf("----------------------------------------\n");
}

void dump_elfhdr(const Elf32_Ehdr *elfhdr)
{
    // dump e_ident
    printf("e_ident    :");
    for (int i = 0; i < EI_NIDENT; i++) {
        printf("%02x ", elfhdr->e_ident[i]);
    }
    putchar('\n');

    // class
    switch (elfhdr->e_ident[EI_CLASS]) {
    case ELFCLASS32:
        printf("ELF32 - ");
        break;
    case ELFCLASS64:
        printf("ELF64 - ");
        break;
    default:
        printf("Invalid class - ");
        break;
    }

    // data coding
    switch (elfhdr->e_ident[EI_DATA]) {
    case ELFDATA2LSB:
        printf("2's complement - little endian - ");
        break;
    case ELFDATA2MSB:
        printf("2's complement - big endian - ");
        break;
    default:
        printf("Invalid data format - ");
        break;
    }

    // OS/ABI
    if (elfhdr->e_ident[EI_OSABI] == ELFOSABI_SYSV) {
        printf("UNIX System V ABI.");
    }
    else {
        printf("Other OS/ABI. (see elf.h)");
    }
    putchar('\n');

    printf("e_type     :0x%x ", elfhdr->e_type);
    switch (elfhdr->e_type) {
    case ET_NONE:
        printf("(ET_NONE) No file type.");
        break;
    case ET_REL:
        printf("(ET_REL) Relocatable file.");
        break;
    case ET_EXEC:
        printf("(ET_EXEC) Executable file.");
        break;
    case ET_CORE:
        printf("(ET_CORE) Core file.");
        break;
    case ET_LOPROC:
        printf("(ET_LOPROC) Processor-specific file.");
        break;
    case ET_HIPROC:
        printf("(ET_HIPROC) Processor-specific file.");
        break;
    default:
        printf("(---------) Unknown type.");
        break;
    }
    putchar('\n');

    printf("e_machine  :0x%x (See elh.h)\n", elfhdr->e_machine);
    printf("e_version  :0x%x\n", elfhdr->e_version);
    printf("e_entry    :0x%x\n", elfhdr->e_entry);
    printf("e_phoff    :0x%x\n", elfhdr->e_phoff);
    printf("e_shoff    :0x%x\n", elfhdr->e_shoff);
    printf("e_flags    :0x%x\n", elfhdr->e_flags);
    printf("e_ehsize   :0x%x\n", elfhdr->e_ehsize);
    printf("e_phentsize:0x%x\n", elfhdr->e_phentsize);
    printf("e_phnum    :0x%x\n", elfhdr->e_phnum);
    printf("e_shentsize:0x%x\n", elfhdr->e_shentsize);
    printf("e_shnum    :0x%x\n", elfhdr->e_shnum);
    printf("e_shstrndx :0x%x\n", elfhdr->e_shstrndx);
    putchar('\n');
}

void dump_phdr(const Elf32_Phdr *phdr)
{
    printf("p_type  :");
    switch (phdr->p_type) {
    case PT_NULL:
        printf("(PT_NULL) Program header table entry unused.");
        break;
    case PT_LOAD:
        printf("(PT_LOAD) Loadable program segment.");
        break;
    case PT_DYNAMIC:
        printf("(PT_DYNAMIC) Dynamic linking information.");
        break;
    case PT_INTERP:
        printf("(PT_INTERP) Program interpreter.");
        break;
    case PT_NOTE:
        printf("(PT_NOTE) Auxiliary information.");
        break;
    case PT_SHLIB:
        printf("(PT_SHLIB) Reserved.");
        break;
    case PT_PHDR:
        printf("(PT_PHDR) Entry for header table itself.");
        break;
    case PT_TLS:
        printf("(PT_TLS) Thread-local storage segment.");
        break;
    default:
        printf("(------) Unknown segment type.");
        break;
    }
    putchar('\n');

    printf("p_offset:0x%x\n", phdr->p_offset);
    printf("p_vaddr :0x%x\n", phdr->p_vaddr);
    printf("p_paddr :0x%x\n", phdr->p_paddr);
    printf("p_filesz:0x%x\n", phdr->p_filesz);
    printf("p_memsz :0x%x\n", phdr->p_memsz);

    printf("p_flags :");
    (phdr->p_flags & PF_R) ? printf("R") : printf("-");
    (phdr->p_flags & PF_W) ? printf("W") : printf("-");
    (phdr->p_flags & PF_X) ? printf("X") : printf("-");
    putchar('\n');

    printf("p_align :0x%x\n", phdr->p_align);
    putchar('\n');
}

void dump_shdr(const Elf32_Shdr *shdr, const char *strtab, uint32_t tabsize)
{
    printf("sh_name     :");
    if (shdr->sh_name < tabsize && strtab[shdr->sh_name]) {
        printf("%s", &strtab[shdr->sh_name]);
    }
    else {
        printf("(NULL)");
    }
    putchar('\n');

    printf("sh_type     :");
    switch (shdr->sh_type) {
    case SHT_NULL:
        printf("NULL - unused.");
        break;
    case SHT_PROGBITS:
        printf("PROGBITS - Program data.");
        break;
    case SHT_SYMTAB:
        printf("SYMTAB - Symbol table.");
        break;
    case SHT_STRTAB:
        printf("STRTAB - String table.");
        break;
    case SHT_RELA:
        printf("RELA - Relocation entries with addends.");
        break;
    case SHT_HASH:
        printf("HASH - Symbol hash table.");
        break;
    case SHT_DYNAMIC:
        printf("DYNAMIC - Dynamic linking information.");
        break;
    case SHT_NOTE:
        printf("NOTE - Notes.");
        break;
    case SHT_NOBITS:
        printf("NOBITS - Program space with no data (bss).");
        break;
    case SHT_REL:
        printf("REL - Relocation entries, no addends.");
        break;
    case SHT_SHLIB:
        printf("SHLIB - Reserved.");
        break;
    case SHT_DYNSYM:
        printf("DYNSYM - Dynamic linker symbol table.");
        break;
    case SHT_INIT_ARRAY:
        printf("INIT_ARRAY - Array of constructors.");
        break;
    case SHT_FINI_ARRAY:
        printf("FINI_ARRAY - Array of destructors.");
        break;
    case SHT_PREINIT_ARRAY:
        printf("PREINIT_ARRAY - Array of pre-constructors.");
        break;
    case SHT_GROUP:
        printf("GROUP - Section group.");
        break;
    case SHT_SYMTAB_SHNDX:
        printf("SYMTAB_SHNDX - Extended section indeces.");
        break;
    default:
        printf("Unknown Section Header type.");
        break;
    }
    putchar('\n');

    printf("sh_flags    :");
    {
        if (shdr->sh_flags & SHF_WRITE) {
            printf("write, ");
        };
        if (shdr->sh_flags & SHF_ALLOC) {
            printf("alloc, ");
        };
        if (shdr->sh_flags & SHF_EXECINSTR) {
            printf("execute, ");
        };
        if (shdr->sh_flags & SHF_MERGE) {
            printf("merge, ");
        };
        if (shdr->sh_flags & SHF_STRINGS) {
            printf("strings, ");
        };
        if (shdr->sh_flags & SHF_INFO_LINK) {
            printf("info, ");
        };
        if (shdr->sh_flags & SHF_LINK_ORDER) {
            printf("link order, ");
        };
        if (shdr->sh_flags & SHF_OS_NONCONFORMING) {
            printf("extra OS processing required, ");
        };
        if (shdr->sh_flags & SHF_GROUP) {
            printf("group, ");
        };
        if (shdr->sh_flags & SHF_TLS) {
            printf("TLS, ");
        };
        if (shdr->sh_flags & SHF_COMPRESSED) {
            printf("compressed, ");
        };
        if (shdr->sh_flags & SHF_MASKOS) {
            printf("OS specific, ");
        };
        if (shdr->sh_flags & SHF_MASKPROC) {
            printf("processor specific, ");
        };
        if (shdr->sh_flags & SHF_EXCLUDE) {
            printf("exclude, ");
        };
    }
    putchar('\n');

    printf("sh_addr     :0x%x\n", shdr->sh_addr);
    printf("sh_offset   :0x%x\n", shdr->sh_offset);
    printf("sh_size     :0x%x\n", shdr->sh_size);
    printf("sh_link     :0x%x\n", shdr->sh_link);
    printf("sh_info     :0x%x\n", shdr->sh_info);
    printf("sh_addralign:0x%x\n", shdr->sh_addralign);
    printf("sh_entsize  :0x%x\n\n", shdr->sh_entsize);
}
```

`elflib.c`:

```c
#include <elf.h>
#include <string.h>

#include "defs.h"

void memsft(char *bin, int off, size_t size) { memmove(bin + off, bin, size); }

void remove_section_name(Elf32_Ehdr *elfhdr, Elf32_Shdr *shdr)
{
    elfhdr->e_shstrndx = 0;
    for (int i = 0; i < elfhdr->e_shnum; i++) {
        shdr[i].sh_name = 0;
    }
};

int search_entry_phdr(const Elf32_Phdr *phdr, int phnum, uint32_t entry)
{
    for (int i = 0; i < phnum; i++) {
        if (phdr[i].p_vaddr <= entry && phdr[i].p_vaddr + phdr[i].p_memsz > entry) {
            return i;
        }
    }
    return -1;
}

int search_entry_shdr(const Elf32_Shdr *shdr, int shnum, uint32_t entry)
{
    for (int i = 0; i < shnum; i++) {
        if (shdr[i].sh_addr <= entry && shdr[i].sh_addr + shdr[i].sh_size > entry) {
            return i;
        }
    }
    return -1;
}
```

`elfpack.c`:

```c
#include <elf.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include "defs.h"

void free_elf(struct elf32_t *e)
{
    if (e->bin) {
        free(e->bin);
        e->bin = NULL;
    }
}

int load_elf(struct elf32_t *e, const char *fname)
{
    FILE *fp = 0;
    int err  = 0;

    e->stubsz = stub_size();

    if (stat(fname, &e->st)) {
        fprintf(stderr, "error: stat()\n");
        goto bad;
    }

    if (!(fp = fopen(fname, "rb"))) {
        fprintf(stderr, "error: fopen()\n");
        goto bad;
    }

    if (!(e->bin = (char *)malloc((size_t)e->st.st_size + e->stubsz))) {
        fprintf(stderr, "error: malloc()\n");
        goto bad;
    }

    if (fread(e->bin, sizeof(char), (size_t)e->st.st_size, fp) != e->st.st_size) {
        fprintf(stderr, "error: fread()\n");
        goto bad;
    }

    e->elfhdr = (Elf32_Ehdr *)e->bin;
    e->phdr   = (Elf32_Phdr *)(e->bin + e->elfhdr->e_phoff);
    e->shdr   = (Elf32_Shdr *)(e->bin + e->elfhdr->e_shoff);

    if (memcmp(e->elfhdr->e_ident, ELFMAG, SELFMAG)) {
        fprintf(stderr, "Format error: Input is not an ELF\n");
        goto bad;
    }
    if (e->elfhdr->e_ident[EI_CLASS] != ELFCLASS32) {
        fprintf(stderr, "Format error: Only support ELF32\n");
        goto bad;
    }
    if (e->elfhdr->e_shstrndx >= e->elfhdr->e_shnum) {
        fprintf(stderr, "Format error: Can't find shdr's string table\n");
        goto bad;
    }

    goto out;

bad:
    err = -1;

out:
    if (fp) {
        fclose(fp);
    }
    return err;
}

int pack_elf(struct elf32_t *e)
{
    // shift section header
    memsft(e->bin + e->elfhdr->e_shoff, (int)e->stubsz,
           (size_t)(e->elfhdr->e_shnum * e->elfhdr->e_shentsize));

    // change elfhdr info
    e->elfhdr->e_shoff += e->stubsz;
    e->shdr = (Elf32_Shdr *)(e->bin + e->elfhdr->e_shoff);

    // get shstrtab for stub
    Elf32_Shdr *stub = &e->shdr[e->elfhdr->e_shstrndx];

    // search entry header
    int pi = search_entry_phdr(e->phdr, e->elfhdr->e_phnum, e->elfhdr->e_entry);
    int si = search_entry_shdr(e->shdr, e->elfhdr->e_shnum, e->elfhdr->e_entry);
    if (pi == -1 || si == -1) {
        fprintf(stderr, "Can't find entry section/program header.\n");
        fprintf(stderr, "DEBUG: pi:%d, si:%d\n", pi, si);
        return -1;
    }

    // encode
    for (uint32_t i = 0; i < e->shdr[si].sh_size; i++) {
        e->bin[e->shdr[si].sh_offset + i] ^= XORKEY;
    }

    // change shstrtab to stub
    stub->sh_size += e->stubsz;
    stub->sh_addr      = e->phdr[pi].p_vaddr + e->phdr[pi].p_memsz;
    stub->sh_type      = SHT_PROGBITS;
    stub->sh_addralign = 1;
    stub->sh_flags     = (SHF_ALLOC | SHF_EXECINSTR);

    // make decode stub binary
    make_stub(e->shdr[si].sh_addr, e->shdr[si].sh_size, e->elfhdr->e_entry, XORKEY);

    // add decode stub
    add_stub(e->bin + stub->sh_offset, stub->sh_size);

    // change flags
    e->shdr[si].sh_flags |= SHF_WRITE;
    e->phdr[pi].p_flags |= PF_W;
    e->phdr[pi].p_filesz += e->stubsz; // TODO: if over align, need more change
    e->phdr[pi].p_memsz += e->stubsz;

    // set new entry point
    e->elfhdr->e_entry = stub->sh_addr;

    // remove section name
    remove_section_name(e->elfhdr, e->shdr);

    return 0;
}

int write_elf(const struct elf32_t *e, const char *fname)
{
    FILE *fp;

    if (!(fp = fopen(fname, "wb"))) {
        fprintf(stderr, "Can't make output file.\n");
        return -1;
    }

    fwrite(e->bin, sizeof(char), malloc_usable_size(e->bin), fp);
    fclose(fp);

    return 0;
}

```

`main.c`:

```c
#include <stdio.h>

#include "defs.h"

/* only support elf32_i386 */

#define DEBUG 1

struct elf32_t e;

int main(int argc, char **argv)
{
    if (argc != 3) {
        fprintf(stderr, "Usage: pac <input> <output>\n");
        return -1;
    }

    if (load_elf(&e, argv[1])) {
        fprintf(stderr, "error: load_elf()\n");
        goto out;
    }

#if DEBUG
    dump_elf(&e);
#endif

    if (pack_elf(&e)) {
        fprintf(stderr, "error: pack_elf()\n");
        goto out;
    }

    if (write_elf(&e, argv[2])) {
        fprintf(stderr, "error: write_elf()\n");
        goto out;
    }

    chmod(argv[2], 0755);

out:
    free_elf(&e);
    return 0;
}
```

`stub.c`:

```c
#include <elf.h>
#include <string.h>

#include "defs.h"

unsigned char decode_stub[] = {
    0x60,                         // pushad
    0xBE, 0xFF, 0xFF, 0xFF, 0xFF, // mov esi, decode_start
    0xB9, 0xFF, 0xFF, 0xFF, 0xFF, // mov ecx, decode_size
    0xB0, 0xFF,                   // mov al, decoder
    0x30, 0x06,                   // xor byte ptr [esi], al (LOOP)
    0x46,                         // inc esi
    0x49,                         // dec ecx
    0x75, 0xFA,                   // jnz LOOP
    0x61,                         // popad
    0x68, 0xFF, 0xFF, 0xFF, 0xFF, // mov eax, OEP
    0xC3                          // ret
};

#define DECODE_START 2
#define DECODE_SIZE 7
#define KEY_OFFSET 12
#define OEP_OFFSET 21

void add_stub(char *addr, uint32_t size)
{
    memset(addr, 0, size);
    memcpy(addr, decode_stub, sizeof(decode_stub));
}

void make_stub(uint32_t addr, uint32_t size, uint32_t entry, uint8_t key)
{
    memcpy(&decode_stub[DECODE_START], &addr, sizeof(int32_t));
    memcpy(&decode_stub[DECODE_SIZE], &size, sizeof(int32_t));
    memcpy(&decode_stub[KEY_OFFSET], &key, sizeof(int8_t));
    memcpy(&decode_stub[OEP_OFFSET], &entry, sizeof(int32_t));
}

uint32_t stub_size() { return sizeof(decode_stub); }

```