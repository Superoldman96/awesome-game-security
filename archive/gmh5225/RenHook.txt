Project Path: arc_gmh5225_RenHook_t1tydi5g

Source Tree:

```txt
arc_gmh5225_RenHook_t1tydi5g
├── CMakeLists.txt
├── LICENSE.md
├── README.md
├── deps
│   ├── catch2
│   └── zydis
├── src
│   ├── CMakeLists.txt
│   └── renhook
│       ├── exception.cpp
│       ├── exception.hpp
│       ├── executable.cpp
│       ├── executable.hpp
│       ├── hook_writer.cpp
│       ├── hook_writer.hpp
│       ├── hooks
│       │   └── prologue_hook.hpp
│       ├── memory
│       │   ├── memory_allocator.cpp
│       │   ├── memory_allocator.hpp
│       │   ├── protection_enum.hpp
│       │   ├── utils.hpp
│       │   ├── virtual_protect.cpp
│       │   └── virtual_protect.hpp
│       ├── pattern.cpp
│       ├── pattern.hpp
│       ├── renhook.hpp
│       ├── suspend_threads.cpp
│       ├── suspend_threads.hpp
│       ├── utils.cpp
│       ├── utils.hpp
│       ├── version.hpp
│       ├── version.hpp.in
│       ├── zydis.cpp
│       └── zydis.hpp
└── tests
    ├── CMakeLists.txt
    ├── executable.cpp
    ├── hook_writer.cpp
    ├── hooks
    │   └── prologue_hook.cpp
    ├── main.cpp
    ├── memory
    │   ├── memory_allocator.cpp
    │   ├── utils.cpp
    │   └── virtual_protect.cpp
    ├── pattern.cpp
    ├── suspend_threads.cpp
    ├── utils.cpp
    └── zydis.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.8)

project(RenHook LANGUAGES CXX VERSION 1.0.0)

# Properties.
set_property(GLOBAL PROPERTY USE_FOLDERS ON)

# Variables.
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED YES)

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/libs")
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")

foreach(configuration ${CMAKE_CONFIGURATION_TYPES})
    string(TOLOWER ${configuration} configuration_lower)
    string(TOUPPER ${configuration} configuration_upper)

    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${configuration_upper} "${CMAKE_BINARY_DIR}/${configuration_lower}/libs")
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${configuration_upper} "${CMAKE_BINARY_DIR}/${configuration_lower}/bin")
endforeach()

# Options.
option(RENHOOK_ENABLE_TESTS "Build unit tests" ON)

# Dependencies.

# Catch2
if(RENHOOK_ENABLE_TESTS)
    set(CATCH_BUILD_STATIC_LIBRARY OFF CACHE INTERNAL "")
    set(BUILD_TESTING OFF CACHE INTERNAL "")
    set(CATCH_USE_VALGRIND OFF CACHE INTERNAL "")
    set(CATCH_BUILD_TESTING OFF CACHE INTERNAL "")
    set(CATCH_BUILD_EXAMPLES OFF CACHE INTERNAL "")
    set(CATCH_BUILD_EXTRA_TESTS OFF CACHE INTERNAL "")
    set(CATCH_ENABLE_COVERAGE OFF CACHE INTERNAL "")
    set(CATCH_ENABLE_WERROR OFF CACHE INTERNAL "")
    set(CATCH_INSTALL_DOCS OFF CACHE INTERNAL "")
    set(CATCH_INSTALL_HELPERS OFF CACHE INTERNAL "")

    add_subdirectory(deps/catch2)
endif()

# Zydis
set(ZYAN_DEV_MODE OFF CACHE INTERNAL "")
set(ZYAN_NO_LIBC OFF CACHE INTERNAL "")
set(ZYAN_WHOLE_PROGRAM_OPTIMIZATION OFF CACHE INTERNAL "")

set(ZYCORE_BUILD_EXAMPLES OFF CACHE INTERNAL "")
set(ZYCORE_BUILD_SHARED_LIB OFF CACHE INTERNAL "")
set(ZYCORE_BUILD_TESTS OFF CACHE INTERNAL "")

set(ZYDIS_BUILD_EXAMPLES OFF CACHE INTERNAL "")
set(ZYDIS_BUILD_SHARED_LIB OFF CACHE INTERNAL "")
set(ZYDIS_BUILD_TOOLS OFF CACHE INTERNAL "")
set(ZYDIS_FEATURE_AVX512 ON CACHE INTERNAL "")
set(ZYDIS_FEATURE_DECODER ON CACHE INTERNAL "")
set(ZYDIS_FEATURE_FORMATTER ON CACHE INTERNAL "")
set(ZYDIS_FEATURE_KNC ON CACHE INTERNAL "")
set(ZYDIS_FUZZ_AFL_FAST OFF CACHE INTERNAL "")
set(ZYDIS_LIBFUZZER OFF CACHE INTERNAL "")
set(ZYDIS_MINIMAL_MODE OFF CACHE INTERNAL "")

add_subdirectory(deps/zydis)

set_target_properties(Zydis PROPERTIES FOLDER "Dependencies")
set_target_properties(Zycore PROPERTIES FOLDER "Dependencies")

# Projects.
add_subdirectory(src)

if(RENHOOK_ENABLE_TESTS)
    add_subdirectory(tests)
endif()

```

`LICENSE.md`:

```md
MIT License

Copyright (c) 2017 - present Octavian Dima

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# RenHook

[![Build Status](https://github.com/WopsS/RenHook/actions/workflows/build.yml/badge.svg)](https://github.com/WopsS/RenHook/actions/workflows/build.yml)

An open-source **x86 / x86-64** hooking library for **Windows**.

## Features

* Supports x86 and x86-64 (uses [Zydis](https://github.com/zyantific/zydis) as diassembler)
* Completely written in C++11
* Safe and easy to use
* Hooking methods
  * **Inline hook** - Patches the prologue of a function to redirect its code flow, also allocates a trampoline to that can be used to execute the original function.

## Quick examples

### Hooking by address

```cpp
#include <Windows.h>
#include <renhook/renhook.hpp>

void func_detour();

using func_t = void(*)();
renhook::inline_hook<func_t> func_hook(0x14000000, &func_detour);

void func_detour()
{
    OutputDebugStringA("Hello from the hook!\n");
    func_hook();
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)
{
    func_hook.attach();
    func_hook();
    func_hook.detach();

    func_hook();
    return 0;
}
```

### Hooking by pattern

```cpp
#include <Windows.h>
#include <renhook/renhook.hpp>

void func_detour();

using func_t = void(*)();
renhook::inline_hook<func_t> func_hook({ 0x89, 0x79, 0xF8, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0x0D, 0xCC, 0xCC, 0xCC, 0xCC }, &func_detour, 0xCC, 3);

void func_detour()
{
    OutputDebugStringA("Hello from the hook!\n");
    func_hook();
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)
{
    func_hook.attach();
    func_hook();
    func_hook.detach();

    func_hook();
    return 0;
}
```

### Hooking a function from a module

```cpp
#include <Windows.h>
#include <renhook/renhook.hpp>

int WINAPI msgbox_detour(HWND wnd, LPCWSTR text, LPCWSTR caption, UINT type);

using MessageBoxW_t = int(WINAPI*)(HWND, LPCWSTR, LPCWSTR, UINT);
renhook::inline_hook<MessageBoxW_t> msgbox_hook("user32", "MessageBoxW", &msgbox_detour);

int WINAPI msgbox_detour(HWND wnd, LPCWSTR text, LPCWSTR caption, UINT type)
{
    return msgbox_hook(wnd, L"Hello from the hook!", L"RenHook", MB_OK | MB_ICONINFORMATION);
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)
{
    msgbox_hook.attach();
    MessageBoxW(nullptr, L"Hello", L"Message", MB_OK);
    msgbox_hook.detach();

    MessageBoxW(nullptr, L"Hello", L"Message", MB_OK);
    return 0;
}
```

## Build instructions

### Requirements

* **[CMake 3.8+](https://cmake.org/)**.

### Windows

1. Download and install **[Visual Studio 2019 Community Edition](https://www.visualstudio.com/)** or a higher version.
2. Download and install the **[Requirements](#requirements)**.
3. Clone this repository.
4. Clone the dependencies (`git submodule update --init --recursive`).
5. Create a directory named `build` and run **[CMake](https://cmake.org/)** in it.
6. Open the solution (**RenHook.sln**) located in **build** directory.
7. Build the projects.

```

`src/CMakeLists.txt`:

```txt
add_library(RenHook STATIC "")

math(EXPR PROJECT_VERSION_INT "${PROJECT_VERSION_MAJOR} * 10000 + ${PROJECT_VERSION_MINOR} * 100 + ${PROJECT_VERSION_PATCH}")
configure_file("renhook/version.hpp.in" "${CMAKE_CURRENT_SOURCE_DIR}/renhook/version.hpp" @ONLY)

file(GLOB_RECURSE HEADERS renhook/*.hpp)
file(GLOB_RECURSE SOURCES renhook/*.cpp)

source_group(TREE "${CMAKE_CURRENT_SOURCE_DIR}/renhook" FILES ${HEADERS} ${SOURCES})

target_include_directories(RenHook PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
target_sources(RenHook PRIVATE ${HEADERS} ${SOURCES})
target_link_libraries(RenHook PUBLIC Zydis)

```

`src/renhook/exception.cpp`:

```cpp
#include <renhook/exception.hpp>

renhook::exception::exception(const char* message)
    : runtime_error(message)
{
}

renhook::exception::exception(const std::string& message)
    : runtime_error(message)
{
}

renhook::exception::exception(const std::string& message, uint32_t last_error)
    : runtime_error(message + ", last_error: " + std::to_string(last_error))
{
}

```

`src/renhook/exception.hpp`:

```hpp
#ifndef RENHOOK_EXCEPTION_H
#define RENHOOK_EXCEPTION_H

#include <cstdint>
#include <stdexcept>
#include <string>

namespace renhook
{
    /**
     * @brief The general exception of the library.
     */
    class exception : public std::runtime_error
    {
    public:

        /**
         * @brief Construct a new exception.
         *
         * @param[in] message The message.
         */
        exception(const char* message);

        /**
         * @brief Construct a new exception.
         *
         * @param[in] message The message.
         */
        exception(const std::string& message);

        /**
         * @brief Construct a new exception.
         *
         * @param[in] message       The message.
         * @param[in] last_error    The error code returned by <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
         */
        exception(const std::string& message, uint32_t last_error);

        ~exception() = default;
    };
}
#endif

```

`src/renhook/executable.cpp`:

```cpp
#include <renhook/executable.hpp>

#include <Windows.h>

namespace
{
    PIMAGE_NT_HEADERS get_nt_header()
    {
        auto base_address = renhook::executable::get_base_address();
        auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(base_address);
        return reinterpret_cast<PIMAGE_NT_HEADERS>(base_address + static_cast<uintptr_t>(dos_header->e_lfanew));
    }
}

uintptr_t renhook::executable::get_base_address()
{
    static auto base_address = reinterpret_cast<uintptr_t>(GetModuleHandle(nullptr));
    return base_address;
}

uintptr_t renhook::executable::get_code_base_address()
{
    static auto code_base_address = get_base_address() + get_nt_header()->OptionalHeader.BaseOfCode;
    return code_base_address;
}

uintptr_t renhook::executable::get_code_end_address()
{
    static auto code_end_address = get_code_base_address() + get_nt_header()->OptionalHeader.SizeOfCode;
    return code_end_address;
}

size_t renhook::executable::get_code_size()
{
    static auto code_size = get_nt_header()->OptionalHeader.SizeOfCode;
    return code_size;
}

```

`src/renhook/executable.hpp`:

```hpp
#ifndef RENHOOK_EXECUTABLE_H
#define RENHOOK_EXECUTABLE_H

#include <cstdint>

namespace renhook
{
    /**
     * @brief Helper namespace for the executable.
     */
    namespace executable
    {
        /**
         * @brief Returns the base address of the executable.
         *
         * @return The address of the executable.
         */
        uintptr_t get_base_address();

        /**
         * @brief Returns the start of the code section.
         *
         * @return The start of the code section.
         */
        uintptr_t get_code_base_address();

        /**
         * @brief Returns the base address of the executable.
         *
         * @return The address of the executable.
         */
        uintptr_t get_code_end_address();

        /**
         * @brief Returns the size of code (text) section.
         *
         * @return The size of code (text) section.
         */
        uintptr_t get_code_size();
    }
}
#endif

```

`src/renhook/hook_writer.cpp`:

```cpp
#include <renhook/hook_writer.hpp>

#include <cstring>
#include <renhook/utils.hpp>

renhook::hook_writer::hook_writer(uint8_t* address)
    : m_address(address)
{
}

renhook::hook_writer::hook_writer(uintptr_t address)
    : hook_writer(reinterpret_cast<uint8_t*>(address))
{
}

void renhook::hook_writer::copy_from(uint8_t* address, size_t length)
{
    std::memcpy(m_address, address, length);
    m_address += length;
}

void renhook::hook_writer::copy_from(uintptr_t address, size_t length)
{
    copy_from(reinterpret_cast<uint8_t*>(address), length);
}

#ifdef _WIN64
void renhook::hook_writer::write_indirect_jump(uintptr_t target_address)
{
    uint8_t bytes[] =
    {
        0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,             // jmp [rip+0]
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // Address where to jump.
    };

    *(reinterpret_cast<uintptr_t*>(&bytes[6])) = target_address;
    copy_from(bytes, sizeof(bytes));
}
#endif

void renhook::hook_writer::write_relative_jump(uintptr_t target_address)
{
    uint8_t bytes[] =
    {
        0xE9, 0x00, 0x00, 0x00, 0x00    // jmp [rip+0x??]
    };

    *(reinterpret_cast<int32_t*>(&bytes[1])) = static_cast<int32_t>(utils::calculate_displacement(reinterpret_cast<uintptr_t>(m_address), target_address, 5));
    copy_from(bytes, sizeof(bytes));
}

void renhook::hook_writer::write_nops(size_t size)
{
    std::memset(m_address, 0x90, size);
    m_address += size;
}

```

`src/renhook/hook_writer.hpp`:

```hpp
#ifndef RENHOOK_HOOK_WRITER_H
#define RENHOOK_HOOK_WRITER_H

#include <cstdint>

namespace renhook
{
    /**
     * @brief Helper class for writing a codecave.
     */
    class hook_writer
    {
    public:

        /**
         * @brief Construct a hook writer.
         *
         * @param address[in] The address where to write.
         */
        hook_writer(uint8_t* address);

        /**
         * @copydoc renhook::hook_writer::hook_writer(uint8_t*)
         */
        hook_writer(uintptr_t address);

        ~hook_writer() = default;

        /**
         * @brief Copy bytes to the codecave.
         *
         * @param address[in]   The address from where to copy.
         * @param length[in]    The length.
         */
        void copy_from(uint8_t* address, size_t length);

        /**
         * @copydoc renhook::hook_writer::copy_from(uint8_t*, size_t)
         */
        void copy_from(uintptr_t address, size_t length);

#ifdef _WIN64
        /**
         * @brief Write an indirect (14 bytes) jump to #target_address.
         *
         * @param target_address[in] The address where the jump is.
         */
        void write_indirect_jump(uintptr_t target_address);
#endif

        /**
         * @brief Write a relative (5 bytes) jump to #target_address.
         *
         * @param target_address[in] The address where the jump is.
         */
        void write_relative_jump(uintptr_t target_address);

        /**
         * @brief Write NOP.
         *
         * @param size[in] The number of NOPs.
         */
        void write_nops(size_t size);

    private:

        uint8_t* m_address;
    };
}
#endif

```

`src/renhook/hooks/prologue_hook.hpp`:

```hpp
#ifndef RENHOOK_HOOKS_PROLOGUE_HOOK_H
#define RENHOOK_HOOKS_PROLOGUE_HOOK_H

#include <algorithm>
#include <limits>
#include <string>

#include <Windows.h>

#include <renhook/exception.hpp>
#include <renhook/executable.hpp>
#include <renhook/hook_writer.hpp>
#include <renhook/pattern.hpp>
#include <renhook/suspend_threads.hpp>
#include <renhook/utils.hpp>
#include <renhook/zydis.hpp>

#include <renhook/memory/memory_allocator.hpp>
#include <renhook/memory/virtual_protect.hpp>

namespace renhook
{
    /**
     * @brief A function prologue hook.
     *
     * @tparam T The hooked function type.
     */
    template<typename T>
    class prologue_hook
    {
    public:

        /**
         * @brief The size of a relative jump.
         */
        static constexpr size_t relative_jump_size = 5;

        /**
         * @brief The size of an indirect jump.
         */
        static constexpr size_t indirect_jump_size = 14;

        /**
         * @brief Construct an empty hook.
         */
        prologue_hook()
            : m_target_address(0)
            , m_detour_address(0)
            , m_wildcard(0)
            , m_offset(0)
            , m_attached(false)
            , m_decoded_length(0)
            , m_block(nullptr)
        {
        }

        /**
         * @brief Construct a new hook.
         *
         * @param target_address[in] The address of the function that will be hooked.
         * @param detour_address[in] The address of the callback.
         */
        prologue_hook(uintptr_t target_address, uintptr_t detour_address)
            : prologue_hook()
        {
            m_target_address = target_address;
            m_detour_address = detour_address;
        }

        /**
         * @brief Construct a new hook.
         *
         * @param target_address[in] The address of the function that will be hooked.
         * @param detour_address[in] The address of the callback.
         */
        prologue_hook(uintptr_t target_address, T detour_address)
            : prologue_hook(target_address, reinterpret_cast<uintptr_t>(detour_address))
        {
        }

        /**
         * @brief Construct a new hook using a pattern.
         *
         * @param pattern[in]           The pattern of the function that will be hooked.
         * @param detour_address[in]    The address of the callback.
         * @param wildcard[in]          The wildcard for #pattern.
         * @param offset[in]            The offset of the #pattern.
         */
        prologue_hook(pattern pattern, uintptr_t detour_address, uint8_t wildcard = 0xCC, size_t offset = 0)
            : prologue_hook()
        {
            m_detour_address = detour_address;
            m_pattern = std::move(pattern);
            m_wildcard = wildcard;
            m_offset = offset;
        }

        /**
         * @brief Construct a new hook using a pattern.
         *
         * @param pattern[in]           The pattern of the function that will be hooked.
         * @param detour_address[in]    The address of the callback.
         * @param wildcard[in]          The wildcard for #pattern.
         * @param offset[in]            The offset of the #pattern.
         */
        prologue_hook(pattern pattern, T detour_address, uint8_t wildcard = 0xCC, size_t offset = 0)
            : prologue_hook(pattern, reinterpret_cast<uintptr_t>(detour_address), wildcard, offset)
        {
        }

        /**
         * @brief Construct a new hook.
         *
         * @param module[in]            The module which contain the #function.
         * @param function[in]          The function that will be hooked.
         * @param detour_address[in]    The address of the callback.
         *
         * @note If the module is not loaded, the library will load it when the hook is attached.
         */
        prologue_hook(const std::string& module, const std::string& function, uintptr_t detour_address)
            : prologue_hook()
        {
            m_module = module;
            m_function = function;
            m_detour_address = detour_address;
        }

        /**
         * @brief Construct a new hook.
         *
         * @param module[in]            The module which contain the #function.
         * @param function[in]          The function that will be hooked.
         * @param detour_address[in]    The address of the callback.
         *
         * @note If the module is not loaded, the library will load it when the hook is attached.
         */
        prologue_hook(const std::string& module, const std::string& function, T detour_address)
            : prologue_hook(module, function, reinterpret_cast<uintptr_t>(detour_address))
        {
        }

        prologue_hook(prologue_hook&& rhs) noexcept
            : m_target_address(rhs.m_target_address)
            , m_detour_address(rhs.m_detour_address)
            , m_pattern(std::move(rhs.m_pattern))
            , m_wildcard(rhs.m_wildcard)
            , m_offset(rhs.m_offset)
            , m_attached(rhs.m_attached)
            , m_decoded_length(rhs.m_decoded_length)
            , m_block(rhs.m_block)
        {
            rhs.m_attached = false;
            rhs.m_block = nullptr;
        }

        ~prologue_hook()
        {
            if (m_attached)
            {
                // Hacky fix: Check if the memory is stil valid. Usually it isn't when the program is finished and all global variables are uninitialized.
                // Another solution would be to store the global allocator and all hooks in a structure then remove the hooks when the structure's destructor is called,
                // but that would require the library to consume more memory.

                MEMORY_BASIC_INFORMATION memory_info = { 0 };
                if (VirtualQuery(m_block, &memory_info, sizeof(memory_info)))
                {
                    if (memory_info.State == MEM_COMMIT)
                    {
                        detach();
                    }
                }
            }
        }

        prologue_hook& operator=(prologue_hook&& rhs) noexcept
        {
            m_target_address = rhs.m_target_address;
            m_detour_address = rhs.m_detour_address;
            m_pattern = std::move(rhs.m_pattern);
            m_wildcard = rhs.m_wildcard;
            m_offset = rhs.m_offset;
            m_attached = rhs.m_attached;
            m_decoded_length = rhs.m_decoded_length;
            m_block = rhs.m_block;

            rhs.m_attached = false;
            rhs.m_block = nullptr;

            return *this;
        }

        prologue_hook(prologue_hook&) = delete;
        prologue_hook& operator=(const prologue_hook&) = delete;

        /**
         * @brief Call the original function.
         *
         * @return The value returned by the original function.
         */
        operator T() const
        {
            return reinterpret_cast<T>(m_block);
        }

        /**
         * @brief Enable the hook.
         */
        void attach()
        {
            using namespace renhook::memory;

            if (m_attached)
            {
                return;
            }

            if (!m_module.empty())
            {
                auto module_handle = GetModuleHandleA(m_module.c_str());
                if (!module_handle)
                {
                    LoadLibraryA(m_module.c_str());

                    module_handle = GetModuleHandleA(m_module.c_str());
                    if (!module_handle)
                    {
                        throw renhook::exception("module not found");
                    }
                }

                m_target_address = reinterpret_cast<uintptr_t>(GetProcAddress(module_handle, m_function.c_str()));
                if (m_target_address == 0)
                {
                    throw renhook::exception("cannot find function in module");
                }
            }

            if (m_target_address == 0)
            {
                if (m_pattern.empty())
                {
                    throw renhook::exception("cannot attach an empty hook");
                }

                auto addresses = m_pattern.find(m_wildcard);
                m_target_address = addresses.at(m_offset);
            }

            m_target_address = skip_jumps(m_target_address);
            m_detour_address = skip_jumps(m_detour_address);

            renhook::zydis zydis;
            auto decoded_info = zydis.decode(m_target_address, executable::get_code_size(), relative_jump_size, m_decoded_length);

            // Find the jump bounds (± 2GB).
            auto lower_bound = (std::min)(m_target_address, decoded_info.lowest_relative_address);
            auto upper_bound = (std::max)(m_target_address, decoded_info.highest_relative_address);

            constexpr auto two_gb_in_bytes = (std::numeric_limits<int32_t>::max)();
            constexpr auto max_pointer_address = (std::numeric_limits<uintptr_t>::max)();

            // Used to prevent upper bound overflow.
            constexpr auto max_upper_bound_memory = max_pointer_address - two_gb_in_bytes;

            if (lower_bound > two_gb_in_bytes)
            {
                lower_bound -= two_gb_in_bytes;
            }

            if (upper_bound < max_upper_bound_memory)
            {
                upper_bound += two_gb_in_bytes;
            }

            suspend_threads threads(m_target_address, m_decoded_length);

            extern memory_allocator global_allocator;
            m_block = static_cast<uint8_t*>(global_allocator.alloc(lower_bound, upper_bound));

            // Write the bytes to our memory.
            virtual_protect block_protection(m_block, memory_allocator::block_size, protection::read | protection::write | protection::execute);
            hook_writer block_writer(m_block);

            block_writer.copy_from(m_target_address, m_decoded_length);

#ifdef _WIN64
            block_writer.write_indirect_jump(m_target_address + m_decoded_length);
#else
            block_writer.write_relative_jump(m_target_address + m_decoded_length);
#endif

#ifdef _WIN64
            // On x86-64 place an indirect jump to the detour. It might be far away.
            block_writer.write_indirect_jump(m_detour_address);
#endif

            relocate_instructions(decoded_info.instructions, &block_writer);

            // Write the jump in the original function.
            virtual_protect func_protection(m_target_address, m_decoded_length, protection::read | protection::write | protection::execute);
            hook_writer func_writer(m_target_address);

#ifdef _WIN64
            // On x86-64 jump to our memory then jump to the detour.
            func_writer.write_relative_jump(reinterpret_cast<uintptr_t>(m_block) + m_decoded_length + indirect_jump_size);
#else
            // On x86 jump directly to the detour.
            func_writer.write_relative_jump(m_detour_address);
#endif

            func_writer.write_nops(m_decoded_length - relative_jump_size);

            flush_cache();
            m_attached = true;
        }

        /**
         * @brief Disable the hook.
         */
        void detach()
        {
            using namespace renhook::memory;

            if (!m_attached)
            {
                return;
            }

            suspend_threads threads(m_target_address, m_decoded_length);
            virtual_protect func_protection(m_target_address, m_decoded_length, protection::read | protection::write | protection::execute);

            hook_writer func_writer(m_target_address);
            func_writer.copy_from(m_block, m_decoded_length);

            renhook::zydis zydis;
            auto decoded_info = zydis.decode(reinterpret_cast<uintptr_t>(m_block), executable::get_code_size(), m_decoded_length, m_decoded_length);

            relocate_instructions(decoded_info.instructions, nullptr);

            extern memory_allocator global_allocator;
            global_allocator.free(m_block);

            m_block = nullptr;

            flush_cache();
            m_attached = false;
        }

        /**
         * @brief Get the attach status.
         * 
         * @return True if the hook is attached, false otherwise.
        */
        bool is_attached() const
        {
            return m_attached;
        }

        /**
         * @brief Get the block address.
         *
         * @return The block address.
         */
        uint8_t* get_block_address() const
        {
            return m_block;
        }

    private:

        /**
         * @brief Check if the first instruction is a jump, if it is follow it until the real address of the function is found.
         *
         * @param address[in] The address to check.
         *
         * @return The real function's address.
         */
        uintptr_t skip_jumps(uintptr_t address) const
        {
            if (address == 0)
            {
                return 0;
            }

            constexpr auto min_decode_length = 2;
            constexpr auto max_decode_length = 32;

            size_t decoded_length;

            renhook::zydis zydis;
            auto decoded_info = zydis.decode(address, max_decode_length, min_decode_length, decoded_length);
            if (decoded_info.instructions.size() == 0)
            {
                return address;
            }

            // JCC and friends not supported.
            auto& instr = decoded_info.instructions[0];
            if (instr.mnemonic == ZYDIS_MNEMONIC_JMP)
            {
                // Instructions using RIP relative addresses.
                if ((instr.attributes & ZYDIS_ATTRIB_HAS_MODRM) && instr.raw.modrm.mod == 0 && instr.raw.modrm.rm == 5)
                {
#ifdef _WIN64
                    auto absAddr = reinterpret_cast<uintptr_t*>(instr.disp.absolute_address);
                    return skip_jumps(*absAddr);
#else
                    return skip_jumps(static_cast<uintptr_t>(instr.raw.disp.value));
#endif
                }

                if (instr.is_relative)
                {
                    return skip_jumps(instr.disp.absolute_address);
                }
                else
                {
                    throw renhook::exception("jump instruction not handled");
                }
            }

            return address;
        }

        /**
         * @brief Relocate all EIP / RIP instructions.
         *
         * @param instructions[in] An array of decoded instructions.
         * @param block_writer[in] The writer of the block (only necessary if the hook is attached).
         */
        void relocate_instructions(std::vector<zydis::decoded_info::instruction>& instructions, hook_writer* block_writer)
        {
            auto instr_address = m_attached ? m_target_address : reinterpret_cast<uintptr_t>(m_block);
            size_t index = 0;

            for (auto& instr : instructions)
            {
                if (instr.is_relative)
                {
                    // Calculate where the displacement is in instruction.
                    auto disp_address = instr_address + instr.disp.offset;

                    if (instr.add_to_jump_table && instr.disp.size < sizeof(int32_t) * 8)
                    {
#ifdef _WIN64
                        constexpr size_t jmp_size = indirect_jump_size;
                        constexpr size_t jmp_instr_size = 6;
#else
                        constexpr size_t jmp_size = relative_jump_size;
                        constexpr size_t jmp_instr_size = 1;
#endif

                        auto table_address = m_block + m_decoded_length + jmp_size;

#ifdef _WIN64
                        // On x86-64 we have another jump that redirect the target to detour.
                        table_address += indirect_jump_size;
#endif

                        // The address of the jump instruction in jump table for the current instruction.
                        auto jmp_instr_address = table_address + (jmp_size * index);

                        // Create a jump table if it is not attached, else get the real address from jump table.
                        if (!m_attached)
                        {
#ifdef _WIN64
                            block_writer->write_indirect_jump(instr.disp.absolute_address);
#else
                            block_writer->write_relative_jump(instr.disp.absolute_address);
#endif

                            instr.disp.absolute_address = reinterpret_cast<uintptr_t>(jmp_instr_address);
                        }
                        else
                        {
                            instr.disp.absolute_address = *reinterpret_cast<uintptr_t*>(jmp_instr_address + jmp_instr_size);

#ifndef _WIN64
                            // On x86 we have a displacement instead of absolute address.
                            instr.disp.absolute_address += reinterpret_cast<uintptr_t>(jmp_instr_address) + jmp_size;
#endif
                        }
                    }

                    switch (instr.disp.size)
                    {
                        case 8:
                        {
                            *reinterpret_cast<int8_t*>(disp_address) = static_cast<int8_t>(utils::calculate_displacement(instr_address, instr.disp.absolute_address, instr.length));
                            break;
                        }
                        case 16:
                        {
                            *reinterpret_cast<int16_t*>(disp_address) = static_cast<int16_t>(utils::calculate_displacement(instr_address, instr.disp.absolute_address, instr.length));
                            break;
                        }
                        case 32:
                        {
                            *reinterpret_cast<int32_t*>(disp_address) = static_cast<int32_t>(utils::calculate_displacement(instr_address, instr.disp.absolute_address, instr.length));
                            break;
                        }
                        case 64:
                        {
                            *reinterpret_cast<int64_t*>(disp_address) = static_cast<int64_t>(utils::calculate_displacement(instr_address, instr.disp.absolute_address, instr.length));
                            break;
                        }
                    }

                    index++;
                }

                instr_address += instr.length;
            }
        }

        /**
         * @brief Flush instruction cache for the original function and for the codecave.
         */
        void flush_cache() const
        {
            auto current_process = GetCurrentProcess();

            FlushInstructionCache(current_process, m_block, memory::memory_allocator::block_size);
            FlushInstructionCache(current_process, reinterpret_cast<void*>(m_target_address), m_decoded_length);
        }

        uintptr_t m_target_address;
        uintptr_t m_detour_address;

        pattern m_pattern;
        uint8_t m_wildcard;
        size_t m_offset;

        std::string m_module;
        std::string m_function;

        bool m_attached;

        size_t m_decoded_length;
        uint8_t* m_block;
    };

    template<typename T>
    using
#if (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
      [[deprecated("Use 'prologue_hook' instead.")]]
 #endif
        inline_hook = prologue_hook<T>;
}
#endif

```

`src/renhook/memory/memory_allocator.cpp`:

```cpp
#include <renhook/memory/memory_allocator.hpp>

#include <Windows.h>

#include <renhook/exception.hpp>
#include <renhook/memory/utils.hpp>
#include <renhook/memory/virtual_protect.hpp>

namespace renhook
{
    namespace memory
    {
        renhook::memory::memory_allocator global_allocator;
    }
}

renhook::memory::memory_allocator::memory_allocator() noexcept
    : m_regions(nullptr)
{
    SYSTEM_INFO system_info = { 0 };
    GetSystemInfo(&system_info);

    m_region_size = system_info.dwAllocationGranularity;
    m_minimum_address = reinterpret_cast<uintptr_t>(system_info.lpMinimumApplicationAddress);
    m_maximum_address = reinterpret_cast<uintptr_t>(system_info.lpMaximumApplicationAddress);
}

renhook::memory::memory_allocator::~memory_allocator() noexcept
{
    while (m_regions)
    {
        auto current_region = m_regions;
        m_regions = current_region->next;

        VirtualFree(current_region, 0, MEM_RELEASE);
    }
}

void* renhook::memory::memory_allocator::alloc(uintptr_t lower_bound, uintptr_t upper_bound)
{
    if (lower_bound < m_minimum_address)
    {
        lower_bound = m_minimum_address;
    }

    if (upper_bound > m_maximum_address)
    {
        upper_bound = m_maximum_address;
    }

    std::lock_guard<std::mutex> _(m_mutex);

    auto region = m_regions;
    if (!region)
    {
        region = alloc_region(lower_bound, upper_bound);
    }

    auto region_address = reinterpret_cast<uintptr_t>(region);

    // If the region doesn't have a free block, check all regions.
    if (region->free_blocks == 0 || !is_region_in_range(region_address, lower_bound, upper_bound))
    {
        region = region->next;
        while (region)
        {
            // Stop if we find a region with a free block.
            if (region->free_blocks > 0)
            {
                region_address = reinterpret_cast<uintptr_t>(region);
                if (is_region_in_range(region_address, lower_bound, upper_bound))
                {
                    break;
                }
            }

            region = region->next;
        }

        // No region found? Then allocate a new one.
        if (!region)
        {
            region = alloc_region(lower_bound, upper_bound);
        }
    }

    virtual_protect protection(region, m_region_size, protection::read | protection::write);

    auto block = region->next_block;
    region->next_block = block->next;

    region->free_blocks--;
    return block;
}

void renhook::memory::memory_allocator::free(void* address)
{
    std::lock_guard<std::mutex> _(m_mutex);

    auto region = reinterpret_cast<regionptr_t>(utils::align_down(reinterpret_cast<uintptr_t>(address), m_region_size));
    auto block = static_cast<blockptr_t>(address);

    virtual_protect protection(region, m_region_size, protection::read | protection::write);

    block->next = region->next_block;
    region->next_block = block;

    region->free_blocks++;

    // Free the region if we reached the maximum number of blocks.
    auto maximum_blocks = m_region_size / block_size - 1;
    if (region->free_blocks == maximum_blocks)
    {
        auto prev = region->prev;
        auto next = region->next;

        if (prev)
        {
            virtual_protect protection(prev, m_region_size, protection::write);
            prev->next = next;
        }

        if (next)
        {
            virtual_protect protection(next, m_region_size, protection::write);
            next->prev = prev;
        }

        if (m_regions == region)
        {
            m_regions = nullptr;
        }

        VirtualFree(region, 0, MEM_RELEASE);
    }
}

renhook::memory::memory_allocator::regionptr_t renhook::memory::memory_allocator::alloc_region(uintptr_t lower_bound, uintptr_t upper_bound)
{
    auto middle = (lower_bound + upper_bound) / 2;
    auto alloc_address_lower = utils::align_down(middle, m_region_size);
    auto alloc_address_higher = utils::align_up(middle, m_region_size);

    regionptr_t region = nullptr;

    bool is_lower_in_range = false;
    bool is_upper_in_range = false;

    do
    {
        is_lower_in_range = is_region_in_range(alloc_address_lower, lower_bound, upper_bound);
        if (is_lower_in_range)
        {
            region = try_alloc_region_at_address(alloc_address_lower);
            if (region)
            {
                break;
            }

            alloc_address_lower -= m_region_size;
        }

        is_upper_in_range = is_region_in_range(alloc_address_higher, lower_bound, upper_bound);
        if (is_upper_in_range)
        {
            region = try_alloc_region_at_address(alloc_address_higher);
            if (region)
            {
                break;
            }

            alloc_address_higher += m_region_size;
        }
    } while (is_lower_in_range || is_upper_in_range);

    if (!region)
    {
        throw renhook::exception("no free region found", GetLastError());
    }

#ifdef _DEBUG
    // In debug fill it with 0xCC, it makes it easier to debug.
    std::memset(region, 0xCC, m_region_size);
#endif

    region->next_block = nullptr;
    region->free_blocks = m_region_size / block_size - 1;

    for (size_t i = region->free_blocks; i > 0; i--)
    {
        auto block_address = reinterpret_cast<char*>(region) + block_size * i;
        auto block = reinterpret_cast<blockptr_t>(block_address);

        block->next = region->next_block;
        region->next_block = block;
    }

    if (m_regions)
    {
        virtual_protect protection(m_regions, m_region_size, protection::write);
        m_regions->prev = region;
    }

    region->prev = nullptr;
    region->next = m_regions;
    m_regions = region;

    virtual_protect protection(region, m_region_size, protection::read | protection::execute, true);
    return region;
}

renhook::memory::memory_allocator::regionptr_t renhook::memory::memory_allocator::try_alloc_region_at_address(uintptr_t address)
{
    MEMORY_BASIC_INFORMATION memory_info = { 0 };
    if (!VirtualQuery(reinterpret_cast<void*>(address), &memory_info, sizeof(memory_info)))
    {
        throw renhook::exception("cannot retrieves region information", GetLastError());
    }

    if (memory_info.State == MEM_FREE && memory_info.RegionSize >= m_region_size)
    {
        auto result = static_cast<regionptr_t>(VirtualAlloc(memory_info.BaseAddress, m_region_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE));
        if (result)
        {
            return result;
        }
    }

    return nullptr;
}

bool renhook::memory::memory_allocator::is_region_in_range(uintptr_t address, uintptr_t lower_bound, uintptr_t upper_bound)
{
    return address >= lower_bound && address < upper_bound;
}

```

`src/renhook/memory/memory_allocator.hpp`:

```hpp
#ifndef RENHOOK_MEMORY_ALLOCATOR_H
#define RENHOOK_MEMORY_ALLOCATOR_H

#include <cstdint>
#include <mutex>

namespace renhook
{
    namespace memory
    {
        /**
         * @brief A memory allocator class.
         */
        class memory_allocator
        {
        public:

            /**
             * @brief The size of a block.
             */
            static constexpr size_t block_size = 256;

            memory_allocator() noexcept;
            ~memory_allocator() noexcept;

            memory_allocator(memory_allocator&) = delete;
            memory_allocator(memory_allocator&&) = delete;

            memory_allocator& operator=(const memory_allocator&) = delete;
            memory_allocator& operator=(memory_allocator&&) = delete;

            /**
             * @brief Return a memory block between #lower_bound and #upper_bound.
             *
             * @param lower_bound[in] The lower bound of the memory.
             * @param upper_bound[in] The lower bound of the memory.
             *
             * @return The memory block of \ref block_size bytes.
             */
            void* alloc(uintptr_t lower_bound, uintptr_t upper_bound);

            /**
             * @brief Free the allocated memory block.
             *
             * @param[in] address The block's address.
             *
             * @note This function <b>does not</b> check if the address was allocated by this class.
             */
            void free(void* address);

        private:

            struct block
            {
                block* next;
            };
            using blockptr_t = block*;

            struct region
            {
                blockptr_t next_block;
                size_t free_blocks;

                region* prev;
                region* next;
            };
            using regionptr_t = region*;

            /**
             * @brief Allocate a region between #lower_bound and #upper_bound.
             *
             * @param lower_bound[in] The lower bound of the memory.
             * @param upper_bound[in] The lower bound of the memory.
             *
             * @return The allocated region.
             */
            regionptr_t alloc_region(uintptr_t lower_bound, uintptr_t upper_bound);

            /**
             * @brief Try to allocate a region at a specific address.
             *
             * @param address[in] The address where to allocation.

             * @return The allocated region.
             *
             * @note A region is allocated by calling <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a>.
             */
            regionptr_t try_alloc_region_at_address(uintptr_t address);

            /**
             * @brief Check if a region is in rage of #lower_bound and #upper_bound.
             *
             * @param address       The region address.
             * @param lower_bound[in] The lower bound of the memory.
             * @param upper_bound[in] The lower bound of the memory.
             *
             * @return true if it is.
             * @return false if it is not.
             */
            bool is_region_in_range(uintptr_t address, uintptr_t lower_bound, uintptr_t upper_bound);

            /**
             * @brief The size of a memory.
             *
             */
            size_t m_region_size;

            /**
             * @brief The lowest address accessible to applications.
             *
             */
            uintptr_t m_minimum_address;

            /**
             * @brief The highest address accessible to applications.
             *
             */
            uintptr_t m_maximum_address;

            regionptr_t m_regions;
            std::mutex m_mutex;
        };

        extern memory_allocator global_allocator;
    }
}
#endif

```

`src/renhook/memory/protection_enum.hpp`:

```hpp
#ifndef RENHOOK_PROTECTION_ENUM_H
#define RENHOOK_PROTECTION_ENUM_H

#include <cstdint>
#include <type_traits>

namespace renhook
{
    namespace memory
    {
        enum class protection : uint8_t
        {
            read = 1 << 0,
            write = 1 << 1,
            execute = 1 << 2
        };

        inline std::underlying_type<protection>::type operator&(protection lhs, protection rhs)
        {
            using underlying_type = std::underlying_type<protection>::type;
            return static_cast<underlying_type>(lhs) & static_cast<underlying_type>(rhs);
        }   

        inline protection operator|(protection lhs, protection rhs)
        {
            using underlying_type = std::underlying_type<protection>::type;
            return static_cast<protection>(static_cast<underlying_type>(lhs) | static_cast<underlying_type>(rhs));
        }
    }
}
#endif

```

`src/renhook/memory/utils.hpp`:

```hpp
#ifndef RENHOOK_MEMORY_UTILS_H
#define RENHOOK_MEMORY_UTILS_H

#include <type_traits>

namespace renhook
{
    namespace memory
    {
        namespace utils
        {
            /**
             * @brief Return the aligned down number by the specified #alignment.
             *
             * @tparam T            The type of the numbers.
             * @param[in] number    The number to be aligned.
             * @param[in] alignment The alignment.
             *
             * @return The number aligned by the specified #alignment.
             */
            template<typename T, typename = typename std::enable_if<std::is_integral<T>::value, T>::type>
            inline T align_down(T number, T alignment)
            {
                return number & ~(alignment - 1);
            }

            /**
             * @brief Return the aligned up number by the specified #alignment.
             *
             * @tparam T            The type of the numbers.
             * @param[in] number    The number to be aligned.
             * @param[in] alignment The alignment.
             *
             * @return The number aligned by the specified #alignment.
             */
            template<typename T, typename = typename std::enable_if<std::is_integral<T>::value, T>::type>
            inline T align_up(T number, T alignment)
            {
                return align_down(number + (alignment - 1), alignment);
            }
        }
    }
}
#endif

```

`src/renhook/memory/virtual_protect.cpp`:

```cpp
#include <renhook/exception.hpp>
#include <renhook/memory/virtual_protect.hpp>

#include <Windows.h>

renhook::memory::virtual_protect::virtual_protect(void* address, size_t size, protection new_protection, bool permanent)
    : m_address(address)
    , m_size(size)
    , m_is_permanent(permanent)
{
    uint32_t protection_option = 0;

    if ((new_protection & protection::read) && (new_protection & protection::write) && (new_protection & protection::execute))
    {
        protection_option = PAGE_EXECUTE_READWRITE;
    }
    else if ((new_protection & protection::read) && (new_protection & protection::write) || new_protection == protection::write)
    {
        protection_option = PAGE_READWRITE;
    }
    else if ((new_protection & protection::read) && (new_protection & protection::execute))
    {
        protection_option = PAGE_EXECUTE_READ;
    }
    else if (new_protection == protection::read)
    {
        protection_option = PAGE_READONLY;
    }
    else if (new_protection == protection::execute)
    {
        protection_option = PAGE_EXECUTE;
    }

    if (!VirtualProtect(address, size, protection_option, reinterpret_cast<PDWORD>(&m_old_protection)))
    {
        throw renhook::exception("couldn't change protection", GetLastError());
    }
}

renhook::memory::virtual_protect::virtual_protect(uintptr_t address, size_t size, protection new_protection, bool permanent)
    : virtual_protect(reinterpret_cast<void*>(address), size, new_protection, permanent)
{
}

renhook::memory::virtual_protect::~virtual_protect() noexcept
{
    if (!m_is_permanent)
    {
        decltype(m_old_protection) old_protection;
        VirtualProtect(m_address, m_size, m_old_protection, reinterpret_cast<PDWORD>(&old_protection));
    }
}

```

`src/renhook/memory/virtual_protect.hpp`:

```hpp
#ifndef RENHOOK_MEMORY_VIRTUAL_PROTECT_H
#define RENHOOK_MEMORY_VIRTUAL_PROTECT_H

#include <cstdint>
#include <renhook/memory/protection_enum.hpp>

namespace renhook
{
    namespace memory
    {
        /**
         * @brief Change protection of the address in a RAII fashion.
         */
        class virtual_protect
        {
        public:

            /**
             * @brief Change protection of the address.
             *
             * @param address[in]           A pointer to the start of the region.
             * @param size[in]              The size of the region.
             * @param new_protection[in]    The new protection.
             * @param permanent[in]         If true the protection is applied permanently.
             *                              If false the protection will be reverted to the original one when object is destroyed.
             */
            virtual_protect(void* address, size_t size, protection new_protection, bool permanent = false);
            virtual_protect(uintptr_t address, size_t size, protection new_protection, bool permanent = false);

            ~virtual_protect() noexcept;

            virtual_protect(virtual_protect&) = delete;
            virtual_protect(virtual_protect&&) = delete;

            virtual_protect& operator=(const virtual_protect&) = delete;
            virtual_protect& operator=(virtual_protect&&) = delete;

        private:

            void* m_address;
            size_t m_size;
            uint32_t m_old_protection;

            bool m_is_permanent;
        };
    }
}
#endif

```

`src/renhook/pattern.cpp`:

```cpp
#include <renhook/pattern.hpp>

#include <algorithm>
#include <renhook/executable.hpp>
#include <renhook/exception.hpp>

renhook::pattern::pattern(std::vector<uint8_t> pattern)
    : m_pattern(std::move(pattern))
{
}

renhook::pattern::pattern(std::initializer_list<uint8_t> pattern)
    : m_pattern(pattern)
{
}

bool renhook::pattern::empty() const
{
    return m_pattern.empty();
}

size_t renhook::pattern::size() const
{
    return m_pattern.size();
}

std::vector<uintptr_t> renhook::pattern::find(uint8_t wildcard, uint8_t* start, uint8_t* end) const
{
    if (empty())
    {
        throw renhook::exception("pattern is empty");
    }

    if (start == 0)
    {
        start = reinterpret_cast<uint8_t*>(executable::get_code_base_address());
    }

    if (end == 0)
    {
        end = reinterpret_cast<uint8_t*>(executable::get_code_end_address());
    }

    std::vector<uintptr_t> offsets;

    while (true)
    {
        auto offset = std::search(start, end, m_pattern.begin(), m_pattern.end(), [&wildcard](uint8_t memory_value, uint8_t pattern_value)
        {
            return memory_value == pattern_value || pattern_value == wildcard;
        });

        // Did we found something?
        if (offset >= end)
        {
            break;
        }

        offsets.emplace_back(reinterpret_cast<uintptr_t>(offset));
        start = offset + m_pattern.size();
    }

    return offsets;
}

```

`src/renhook/pattern.hpp`:

```hpp
#ifndef RENHOOK_PATTERN_H
#define RENHOOK_PATTERN_H

#include <cstdint>
#include <initializer_list>
#include <vector>

namespace renhook
{
    /**
     * @brief The pattern class.
     */
    class pattern
    {
    public:

        /**
         * @brief Construct a new empty pattern.
         */
        pattern() = default;

        /**
         * @brief Construct a new pattern.
         *
         * @param[in] pattern The pattern.
         */
        pattern(std::vector<uint8_t> pattern);

        /**
         * @brief Construct a new pattern.
         *
         * @param[in] pattern The pattern.
         */
        pattern(std::initializer_list<uint8_t> pattern);

        ~pattern() = default;

        /**
         * @brief Checks if the pattern is empty.
         *
         * @return true if the pattern is empty.
         * @return false otherwise.
         */
        bool empty() const;

        /**
         * @brief Return the size of the pattern.
         *
         * @return The size of the patter.
         */
        size_t size() const;

        /**
         * @brief Return an array of addresses where the pattern was found.
         *
         * @param[in] wildcard  The wildcard.
         * @param[in] start     The start address. If value is \b 0 then \ref renhook::executable::get_code_base_address() is used.
         * @param[in] end       The end address. If value is \b 0 then \ref renhook::executable::get_code_end_address() is used.
         *
         * @return An array of addresses where the pattern was found.
         *
         * @par Examples
         *
         * The following
         *
         * @code{.cpp}
         * renhook::pattern pattern({ 0x48, 0x89, 0x5C, 0x24, 0x08 });
         * auto addresses = pattern.find(0xCC);
         *
         * std::cout << addresses.size() << " matches found\n";
         *
         * for (auto& address : addresses)
         * {
         *      std::cout << "Pattern found at " << std::hex << address << '\n';
         * }
         * @endcode
         *
         * is equivalent with
         *
         * @code{.cpp}
         * renhook::pattern pattern({ 0x48, 0x89, 0x5C, 0x24, 0x08 });
         * auto addresses = pattern.find(0xCC, renhook::executable::get_code_base_address(), renhook::executable::get_code_end_address());
         *
         * std::cout << addresses.size() << " matches found\n";
         *
         * for (auto& address : addresses)
         * {
         *      std::cout << "Pattern found at " << std::hex << address << '\n';
         * }
         * @endcode
         */
        std::vector<uintptr_t> find(uint8_t wildcard, uint8_t* start = 0, uint8_t* end = 0) const;

    private:

        /**
         * @brief Pattern to search.
         */
        std::vector<uint8_t> m_pattern;
    };
}
#endif

```

`src/renhook/renhook.hpp`:

```hpp
#pragma once

#include <renhook/hooks/prologue_hook.hpp>

```

`src/renhook/suspend_threads.cpp`:

```cpp
#include <renhook/suspend_threads.hpp>

#include <chrono>
#include <thread>

#include <Windows.h>
#include <TlHelp32.h>

#include <renhook/exception.hpp>

renhook::suspend_threads::suspend_threads(uintptr_t ip_address, size_t ip_length)
{
    suspend(ip_address, ip_length);
}

renhook::suspend_threads::~suspend_threads()
{
    resume();
}

void renhook::suspend_threads::suspend(uintptr_t ip_address, size_t ip_length)
{
    auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (snapshot == INVALID_HANDLE_VALUE)
    {
        throw renhook::exception("cannot take process snapshot", GetLastError());
    }

    THREADENTRY32 entry;
    entry.dwSize = sizeof(THREADENTRY32);

    if (!Thread32First(snapshot, &entry))
    {
        throw renhook::exception("cannot retrieves information about the first thread", GetLastError());
    }

    auto process_id = GetCurrentProcessId();
    auto thread_id = GetCurrentThreadId();

    do
    {
        if (entry.th32OwnerProcessID == process_id && entry.th32ThreadID != thread_id)
        {
            auto handle = suspend_thread(entry.th32ThreadID, ip_address, ip_length);
            m_handles.emplace_back(handle);
        }
    } while (Thread32Next(snapshot, &entry));
}

void renhook::suspend_threads::resume()
{
    for (auto handle : m_handles)
    {
        resume_thread(handle);
    }

    m_handles.clear();
}

void* renhook::suspend_threads::suspend_thread(uint32_t id, uintptr_t ip_address, size_t ip_length)
{
    auto handle = OpenThread(THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME, false, id);
    if (!handle)
    {
        throw renhook::exception("cannot open thread object", GetLastError());
    }

    auto count = SuspendThread(handle);
    if (count == -1)
    {
        CloseHandle(handle);
        throw renhook::exception("cannot suspend thread", GetLastError());
    }

    size_t tries = 1;
    do
    {
        CONTEXT context = { 0 };
        context.ContextFlags = CONTEXT_CONTROL;

        if (!GetThreadContext(handle, &context))
        {
            auto a = GetLastError();
            throw renhook::exception("cannot get thread context", GetLastError());
        }

#ifdef _WIN64
        auto ip = context.Rip;
#else
        auto ip = context.Eip;
#endif

        if (ip_address < ip || ip_address > (ip + ip_length))
        {
            break;
        }

        if (tries <= 3)
        {
            ResumeThread(handle);

            using namespace std::chrono_literals;
            std::this_thread::sleep_for(tries * 50ms);

            SuspendThread(handle);
        }

        tries++;
    } while (tries <= 3);

    return handle;
}

void renhook::suspend_threads::resume_thread(void* handle)
{
    ResumeThread(handle);
    CloseHandle(handle);
}

```

`src/renhook/suspend_threads.hpp`:

```hpp
#ifndef RENHOOK_SUSPEND_THREADS_H
#define RENHOOK_SUSPEND_THREADS_H

#include <cstdint>
#include <vector>

namespace renhook
{
    /**
     * @brief Temporary suspend all threads, except the running one, in a RAII fashion.
     */
    class suspend_threads
    {
    public:

        /**
         * @brief Suspends all threads and make sure their instruction pointer is not in range.
         *
         * @param ip_address[in]    The address of the instruction pointer.
         * @param ip_length[in]     The length of the instruction pointer.
         */
        suspend_threads(uintptr_t ip_address, size_t ip_length);

        suspend_threads(suspend_threads&) = delete;
        suspend_threads(suspend_threads&&) = delete;

        ~suspend_threads();

        suspend_threads& operator=(const suspend_threads&) = delete;
        suspend_threads& operator=(suspend_threads&&) = delete;

    private:

        void suspend(uintptr_t ip_address, size_t ip_length);
        void resume();

        void* suspend_thread(uint32_t id, uintptr_t ip_address, size_t ip_length);
        void resume_thread(void* handle);

        std::vector<void*> m_handles;
    };
}
#endif

```

`src/renhook/utils.cpp`:

```cpp
#include <renhook/utils.hpp>

intptr_t renhook::utils::calculate_displacement(uintptr_t from, uintptr_t to, size_t instruction_size)
{
    if (to < from)
    {
        return 0 - (from - to) - instruction_size;
    }

    return to - (from + instruction_size);
}

```

`src/renhook/utils.hpp`:

```hpp
#ifndef RENHOOK_UTILS_H
#define RENHOOK_UTILS_H

#include <cstdint>

namespace renhook
{
    namespace utils
    {
        /**
         * @brief Calculate the displacement between two addresses.
         *
         * @param from[in]              The source.
         * @param to[in]                The destination.
         * @param instruction_size[in]  The size of the instruction at the source (#from).
         *
         * @return The displacement.
         */
        intptr_t calculate_displacement(uintptr_t from, uintptr_t to, size_t instruction_size);
    }
}
#endif

```

`src/renhook/version.hpp`:

```hpp
#ifndef RENHOOK_VERSION_H
#define RENHOOK_VERSION_H

#include <cstdint>

namespace renhook
{
    /**
     * @brief The namespace containing library version helpers.
     */
    namespace version
    {
        /**
         * @brief Return the version as string.
         *
         * @return The version as string.
         */
        constexpr const char* as_string()
        {
            return "1.0.0";
        }

        /**
         * @brief Return the version as integer (uint32_t).
         *
         * @return The version as integer (uint32_t).
         */
        constexpr uint32_t as_int()
        {
            return 10000;
        }

        /**
         * @brief Return the major version of the library.
         *
         * @return The major version of the library.
         */
        constexpr uint8_t get_major()
        {
            return 1;
        }

        /**
         * @brief Return the minor version of the library.
         *
         * @return The minor version of the library.
         */
        constexpr uint8_t get_minor()
        {
            return 0;
        }

        /**
         * @brief Return the patch version of the library.
         *
         * @return The patch version of the library.
         */
        constexpr uint8_t get_patch()
        {
            return 0;
        }
    }
}
#endif

```

`src/renhook/version.hpp.in`:

```in
#ifndef RENHOOK_VERSION_H
#define RENHOOK_VERSION_H

#include <cstdint>

namespace renhook
{
    /**
     * @brief The namespace containing library version helpers.
     */
    namespace version
    {
        /**
         * @brief Return the version as string.
         *
         * @return The version as string.
         */
        constexpr const char* as_string()
        {
            return "@PROJECT_VERSION@";
        }

        /**
         * @brief Return the version as integer (uint32_t).
         *
         * @return The version as integer (uint32_t).
         */
        constexpr uint32_t as_int()
        {
            return @PROJECT_VERSION_INT@;
        }

        /**
         * @brief Return the major version of the library.
         *
         * @return The major version of the library.
         */
        constexpr uint8_t get_major()
        {
            return @PROJECT_VERSION_MAJOR@;
        }

        /**
         * @brief Return the minor version of the library.
         *
         * @return The minor version of the library.
         */
        constexpr uint8_t get_minor()
        {
            return @PROJECT_VERSION_MINOR@;
        }

        /**
         * @brief Return the patch version of the library.
         *
         * @return The patch version of the library.
         */
        constexpr uint8_t get_patch()
        {
            return @PROJECT_VERSION_PATCH@;
        }
    }
}
#endif

```

`src/renhook/zydis.cpp`:

```cpp
#include <renhook/zydis.hpp>
#include <renhook/exception.hpp>

ZydisDecoder renhook::zydis::m_decoder;
bool renhook::zydis::m_initialized = false;

renhook::zydis::zydis()
{
    if (!m_initialized)
    {
        m_initialized = true;

#ifdef _WIN64
        auto status = ZydisDecoderInit(&m_decoder, ZYDIS_MACHINE_MODE_LONG_64, ZYDIS_ADDRESS_WIDTH_64);
#else
        auto status = ZydisDecoderInit(&m_decoder, ZYDIS_MACHINE_MODE_LONG_COMPAT_32, ZYDIS_ADDRESS_WIDTH_32);
#endif

        if (!ZYAN_SUCCESS(status))
        {
            throw renhook::exception("decoder initialization failed");
        }
    }
}

const renhook::zydis::decoded_info renhook::zydis::decode(uintptr_t address, size_t length, size_t minimum_decoded_length, size_t& decoded_length) const
{
    decoded_info info;
    info.lowest_relative_address = -1;
    info.highest_relative_address = 0;

    decoded_length = 0;
    while (decoded_length < minimum_decoded_length)
    {
        decoded_info::instruction instruction;
        auto instruction_address = address + decoded_length;

        auto status = ZydisDecoderDecodeBuffer(&m_decoder, reinterpret_cast<void*>(instruction_address), length, &instruction);
        if (!ZYAN_SUCCESS(status))
        {
            break;
        }

        instruction.is_relative = instruction.attributes & ZYDIS_ATTRIB_IS_RELATIVE;

        // Calculate the absolute address if it is relative.
        if (instruction.is_relative)
        {
            get_absolute_address(instruction_address, instruction, instruction.disp);

            if (instruction.disp.absolute_address < info.lowest_relative_address)
            {
                info.lowest_relative_address = instruction.disp.absolute_address;
            }

            if (instruction.disp.absolute_address > info.highest_relative_address)
            {
                info.highest_relative_address = instruction.disp.absolute_address;
            }

            instruction.add_to_jump_table =
                (instruction.opcode & 0xF0) == 0x70
                || (instruction.opcode_map == ZYDIS_OPCODE_MAP_0F && (instruction.opcode & 0xF0) == 0x80)
                || instruction.mnemonic == ZYDIS_MNEMONIC_CALL;
        }
        else
        {
            instruction.disp.absolute_address = 0;
            instruction.disp.offset = 0;
            instruction.disp.size = 0;
        }

        info.instructions.emplace_back(std::move(instruction));
        decoded_length += instruction.length;
    }

    return info;
}

void renhook::zydis::get_absolute_address(uintptr_t instr_address, const ZydisDecodedInstruction& decoded_instr, decoded_info::instruction::displacement& displacement) const
{
    if (decoded_instr.raw.imm[0].is_relative)
    {
        displacement.absolute_address = instr_address + decoded_instr.length + static_cast<int32_t>(decoded_instr.raw.imm[0].value.s);
        displacement.offset = decoded_instr.raw.imm[0].offset;
        displacement.size = decoded_instr.raw.imm[0].size;
    }
    else if ((decoded_instr.attributes & ZYDIS_ATTRIB_HAS_MODRM) && decoded_instr.raw.modrm.mod == 0 && decoded_instr.raw.modrm.rm == 5)
    {
        displacement.absolute_address = instr_address + decoded_instr.length + static_cast<int32_t>(decoded_instr.raw.disp.value);
        displacement.offset = decoded_instr.raw.disp.offset;
        displacement.size = decoded_instr.raw.disp.size;
    }
}

```

`src/renhook/zydis.hpp`:

```hpp
#ifndef RENHOOK_ZYDIS_H
#define RENHOOK_ZYDIS_H

#include <vector>
#include <Zydis/Zydis.h>

namespace renhook
{
    /**
     * @brief A Zydis C++ wrapper.
     */
    class zydis
    {
    public:

        struct decoded_info
        {
            struct instruction : ZydisDecodedInstruction
            {
                struct displacement
                {
                    uintptr_t absolute_address;
                    uint8_t offset;

                    
                    /**
                    * @brief The size of displacement in bits.
                    */
                    uint8_t size;
                };

                bool is_relative;
                bool add_to_jump_table;

                displacement disp;
            };

            std::vector<instruction> instructions;

            uintptr_t lowest_relative_address;
            uintptr_t highest_relative_address;
        };

        zydis();
        ~zydis() = default;

        /**
         * @brief Decode instructions until #minimum_decoded_length is met.
         *
         * @param address[in]                   The start address where to begin the decoding.
         * @param length[in]                    The length of the code section.
         * @param minimum_decoded_length[in]    The minimum length of decoded instructions.
         * @param decoded_length[out]           The actual decoded length.
         *
         * @return A structure containing the decoded information.
         */
        const decoded_info decode(uintptr_t address, size_t length, size_t minimum_decoded_length, size_t& decoded_length) const;

    private:

        void get_absolute_address(uintptr_t instr_address, const ZydisDecodedInstruction& decoded_instr, decoded_info::instruction::displacement& displacement) const;

        static ZydisDecoder m_decoder;
        static bool m_initialized;
    };
}
#endif

```

`tests/CMakeLists.txt`:

```txt
add_executable(Tests "")

file(GLOB_RECURSE HEADERS *.hpp)
file(GLOB_RECURSE SOURCES *.cpp)

source_group(TREE "${CMAKE_CURRENT_SOURCE_DIR}" FILES ${HEADERS} ${SOURCES})

target_include_directories(Tests PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
target_sources(Tests PRIVATE ${HEADERS} ${SOURCES})
target_link_libraries(Tests PRIVATE Catch2::Catch2 RenHook)

```

`tests/executable.cpp`:

```cpp
#include <catch2/catch.hpp>

#include <Windows.h>
#include <renhook/executable.hpp>

TEST_CASE("executable")
{
    SECTION("base address")
    {
        REQUIRE(renhook::executable::get_base_address() == reinterpret_cast<uintptr_t>(GetModuleHandle(nullptr)));
    }
    SECTION("code section")
    {
        auto base_address = renhook::executable::get_base_address();
        auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(base_address);
        auto nt_header = reinterpret_cast<PIMAGE_NT_HEADERS>(base_address + static_cast<uintptr_t>(dos_header->e_lfanew));
        auto code_base_address = base_address + nt_header->OptionalHeader.BaseOfCode;

        SECTION("base address")
        {
            REQUIRE(code_base_address == renhook::executable::get_code_base_address());
        }
        SECTION("end address")
        {
            auto code_end_address = code_base_address + nt_header->OptionalHeader.SizeOfCode;
            REQUIRE(code_end_address == renhook::executable::get_code_end_address());
        }
        SECTION("size")
        {
            auto code_size = nt_header->OptionalHeader.SizeOfCode;
            REQUIRE(code_size == renhook::executable::get_code_size());
        }
    }
}

```

`tests/hook_writer.cpp`:

```cpp
#include <catch2/catch.hpp>

#include <renhook/hook_writer.hpp>
#include <renhook/utils.hpp>

bool compare_memory(const uint8_t* memory, std::vector<uint8_t> bytes)
{
    if (bytes.size() == 0)
    {
        return false;
    }

    for (size_t i = 0; i < bytes.size(); i++)
    {
        auto byte = bytes[i];
        if (byte == 0xCC)
        {
            continue;
        }

        if (byte != memory[i])
        {
            return false;
        }
    }

    return true;
}

TEST_CASE("hook_writer")
{
    uint8_t bytes[64];
    uint8_t copy_bytes[] = { 0x57, 0x56, 0x55, 0x90, 0x90 };

#ifdef _WIN64
    size_t relative_jump_index = 19;
#else
    size_t relative_jump_index = 5;
#endif

    renhook::hook_writer writer(bytes);
    writer.copy_from(copy_bytes, sizeof(copy_bytes));

#ifdef _WIN64
    writer.write_indirect_jump(0);
#endif

    writer.write_relative_jump(reinterpret_cast<uintptr_t>(&bytes[relative_jump_index] + 5 - 0x30));
    writer.write_nops(5);

    std::vector<uint8_t> expected_bytes =
    {
        0x57, 0x56, 0x55, 0x90, 0x90,

#ifdef _WIN64
        0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#endif

        0xE9, 0xD0, 0xFF, 0xFF, 0xFF,
        0x90, 0x90, 0x90, 0x90, 0x90
    };

    REQUIRE(compare_memory(bytes, expected_bytes));
}

```

`tests/hooks/prologue_hook.cpp`:

```cpp
#include <catch2/catch.hpp>

#include <renhook/utils.hpp>
#include <renhook/hooks/prologue_hook.hpp>

template<typename T>
using hook_t = renhook::prologue_hook<T>;

extern renhook::memory::memory_allocator global_allocator;
extern bool compare_memory(const uint8_t* memory, std::vector<uint8_t> bytes);

__declspec(noinline) uint32_t fibonacci(uint32_t a)
{
    if (a == 0 || a == 1)
    {
        return a;
    }

    return fibonacci(a - 1) + fibonacci(a - 2);
}

__declspec(noinline) uint32_t fibonacci_hooked(uint32_t a)
{
    return a;
}

TEST_CASE("hooks::inline_hook", "[hooks][inline_hook]")
{
    using void_func_t = void(*)();
     
    SECTION("skip jumps")
    {
        uint8_t data[] =
        {
            0xEB, 0x00,
            0xE9, 0x00, 0x00, 0x00, 0x00,
            0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,

#ifdef _WIN64
            0x48, 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,
            0x48, 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,
#endif

            0xE9, 0x06, 0x00, 0x00, 0x00,
            0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,
            0xEB, 0x00,

            0x57,                               // push edi / rdi
            0x8D, 0x85, 0xE8, 0x03, 0x00, 0x00, // lea r8, [rbp+3C0h+arg_1]
            0x8D, 0x54, 0x24, 0x50,             // lea rdx, [rsp+4C0h+var_2]
            0x8B, 0xC8,                         // mov rcx, rax
            0xE8, 0x00, 0x00, 0x00, 0x00,       // call 0x00000000

            0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,

            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,

            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,

            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,

            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
        };

#ifdef _WIN64
        auto data_len = sizeof(data);
        struct displacements
        {
            uint8_t* source;
            uint8_t* target;
            uint8_t* indirect_storage;
            uint8_t prefix_length;

            displacements(uint8_t* source, uint8_t* target, uint8_t* indirect_storage, uint8_t prefix_length)
                : source(source)
                , target(target)
                , indirect_storage(indirect_storage)
                , prefix_length(prefix_length)
            {
            }
        };

        std::vector<displacements> disps =
        {
            displacements(&data[9], &data[13], &data[data_len - 64], 2),
            displacements(&data[16], &data[20], &data[data_len - 48], 3),
            displacements(&data[23], &data[27], &data[data_len - 32], 3),
            displacements(&data[34], &data[33], &data[data_len - 16], 2)
        };

        for (auto& disp : disps)
        {
            *reinterpret_cast<int64_t*>(disp.indirect_storage) = reinterpret_cast<uintptr_t>(disp.target);

            auto rel_disp = disp.indirect_storage - disp.source - sizeof(int32_t);
            *reinterpret_cast<int32_t*>(disp.source) = static_cast<int32_t>(rel_disp);
        }
#else
        *(reinterpret_cast<uintptr_t*>(&data[9])) = reinterpret_cast<uintptr_t>(&data[13]);
        *(reinterpret_cast<uintptr_t*>(&data[20])) = reinterpret_cast<uintptr_t>(&data[24]);
#endif

        hook_t<void_func_t> hook(reinterpret_cast<uintptr_t>(&data), static_cast<uintptr_t>(0));
        hook.attach();

        auto block = hook.get_block_address();
        std::vector<uint8_t> expected_block_bytes =
        {
            0x57,
            0x8D, 0x85, 0xE8, 0x03, 0x00, 0x00
        };

        REQUIRE(compare_memory(block, expected_block_bytes));
    }
    SECTION("empty hook")
    {
        hook_t<void_func_t> empty_hook;
        REQUIRE_THROWS(empty_hook.attach());
    }
    SECTION("fake hook")
    {
        SECTION("without relative instruction pointers")
        {
            uint8_t data[] =
            {
#ifdef _WIN64
                0x48, 0x89, 0x5C, 0x24, 0x08,               // mov [rsp+arg_0], rbx
                0x57,                                       // push rdi
                0x48, 0x83, 0xEC, 0x20,                     // sub rsp, 20h
                0x48, 0x8B, 0xD9,                           // mov rbx, rcx
                0x33, 0xFF,                                 // xor edi, edi
                0x48, 0x83, 0xC1, 0x08,                     // add rcx, 8
                0x48, 0x89, 0x79, 0xF8,                     // mov [rcx-8], rdi
                0xE8, 0x34, 0x32, 0xAF, 0xFE,               // call 0xFFFFFFFFFEAF3239
                0x48, 0x8B, 0x0D, 0x2D, 0x76, 0x2F, 0x01    // mov rcx, [0x00000000012F7634]
#else
                0x89, 0x54, 0x24, 0x08,                     // mov [esp+arg_0], ebx
                0x57,                                       // push edi
                0x83, 0xEC, 0x20,                           // sub esp, 20h
                0x8B, 0xD9,                                 // mov ebx, ecx
                0x33, 0xFF,                                 // xor edi, edi
                0x83, 0xC1, 0x08,                           // add ecx, 8
                0x89, 0x79, 0xF8,                           // mov [ecx-8], edi
                0xE8, 0x34, 0x32, 0xAF, 0xFE,               // call 0xEAF3239
                0x8B, 0x0D, 0x2D, 0x76, 0x2F, 0x01          // mov ecx, [0x12F7634]
#endif
            };

            hook_t<void_func_t> hook(reinterpret_cast<uintptr_t>(&data), static_cast<uintptr_t>(0));
            hook.attach();

            auto block = hook.get_block_address();
            std::vector<uint8_t> expected_data_bytes =
            {
#ifdef _WIN64
                0xE9, 0x00, 0x00, 0x00, 0x00,
                0x57,
                0x48, 0x83, 0xEC, 0x20,
                0x48, 0x8B, 0xD9,
                0x33, 0xFF,
                0x48, 0x83, 0xC1, 0x08,
                0x48, 0x89, 0x79, 0xF8
#else
                0xE9, 0x00, 0x00, 0x00, 0x00,
                0x83, 0xEC, 0x20
#endif
            };

            std::vector<uint8_t> expected_block_bytes =
            {
#ifdef _WIN64
                0x48, 0x89, 0x5C, 0x24, 0x08,
                0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#else
                0x89, 0x54, 0x24, 0x08,
                0x57,
                0xE9, 0x00, 0x00, 0x00, 0x00
#endif
            };

#ifdef _WIN64
            *(reinterpret_cast<int32_t*>(&expected_data_bytes[1])) = static_cast<int32_t>(renhook::utils::calculate_displacement(reinterpret_cast<uintptr_t>(&data), reinterpret_cast<uintptr_t>(block + 5 + hook_t<void_func_t>::indirect_jump_size), 5));
            *(reinterpret_cast<uintptr_t*>(&expected_block_bytes[11])) = reinterpret_cast<uintptr_t>(&data[5]);
#else
            *(reinterpret_cast<int32_t*>(&expected_data_bytes[1])) = static_cast<int32_t>(renhook::utils::calculate_displacement(reinterpret_cast<uintptr_t>(&data), 0, 5));
            *(reinterpret_cast<int32_t*>(&expected_block_bytes[6])) = renhook::utils::calculate_displacement(reinterpret_cast<uintptr_t>(block + 5), reinterpret_cast<uintptr_t>(&data[5]), 5);
#endif

            REQUIRE(compare_memory(data, expected_data_bytes));
            REQUIRE(compare_memory(block, expected_block_bytes));

            hook.detach();

            expected_data_bytes =
            {
#ifdef _WIN64
                0x48, 0x89, 0x5C, 0x24, 0x08,
                0x57,
                0x48, 0x83, 0xEC, 0x20,
                0x48, 0x8B, 0xD9,
                0x33, 0xFF,
                0x48, 0x83, 0xC1, 0x08,
                0x48, 0x89, 0x79, 0xF8
#else
                0x89, 0x54, 0x24, 0x08,
                0x57,
                0x83, 0xEC, 0x20
#endif
            };

            REQUIRE(compare_memory(data, expected_data_bytes));
        }
        SECTION("with relative instruction pointers")
        {
            uint8_t data[] =
            {
                0x57,                               // push edi / rdi
                0x74, 0x60,                         // jz 0x60
                0x0F, 0x84, 0x80, 0xFF, 0xFF, 0xFF, // jz 0xFFFFFF80
                0x8D, 0x85, 0xE8, 0x03, 0x00, 0x00, // lea r8, [rbp+3C0h+arg_1]
                0x8D, 0x54, 0x24, 0x50,             // lea rdx, [rsp+4C0h+var_2]
                0x8B, 0xC8,                         // mov rcx, rax
                0xE8, 0x97, 0x05, 0xD0, 0x00,       // call 0x00D0059C
                0x8B, 0xC8                          // mov rcx, rax
            };

            auto first_jump_real_addr = reinterpret_cast<uintptr_t>(&data[1]) + data[2] + 2;
            auto second_jump_real_addr = reinterpret_cast<uintptr_t>(&data[3]) + *reinterpret_cast<int32_t*>(&data[5]) + 6;

            hook_t<void_func_t> hook(reinterpret_cast<uintptr_t>(&data), static_cast<uintptr_t>(0));
            hook.attach();

            auto block = hook.get_block_address();
            std::vector<uint8_t> expected_data_bytes =
            {
                0xE9, 0x00, 0x00, 0x00, 0x00,
                0x90, 0x90, 0x90, 0x90,
                0x8D, 0x85, 0xE8, 0x03, 0x00, 0x00
            };

            std::vector<uint8_t> expected_block_bytes =
            {
                0x57,
                0x74, 0x00,
                0x0F, 0x84, 0x00, 0x00, 0x00, 0x00,

#ifdef _WIN64
                // Return to function jump.
                0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                // Indirect jump to detour.
                0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                // First item in jump table (for the 2 bytes jump).
                0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#else
                // Return to function jump.
                0xE9, 0x00, 0x00, 0x00, 0x00,

                // First item in jump table (for the 2 bytes jump).
                0xE9, 0x00, 0x00, 0x00, 0x00,
#endif
            };

#ifdef _WIN64
            *(reinterpret_cast<int32_t*>(&expected_data_bytes[1])) = static_cast<int32_t>(renhook::utils::calculate_displacement(reinterpret_cast<uintptr_t>(&data), reinterpret_cast<uintptr_t>(block + 9 + hook_t<void_func_t>::indirect_jump_size), 5));

            *(reinterpret_cast<int8_t*>(&expected_block_bytes[2])) = static_cast<int8_t>(renhook::utils::calculate_displacement(reinterpret_cast<uintptr_t>(&data[1]), reinterpret_cast<uintptr_t>(&data[0] + 37), 2));
            *(reinterpret_cast<uintptr_t*>(&expected_block_bytes[15])) = reinterpret_cast<uintptr_t>(&data[9]);
            *(reinterpret_cast<uintptr_t*>(&expected_block_bytes[43])) = first_jump_real_addr;
            *(reinterpret_cast<int32_t*>(&expected_block_bytes[5])) = static_cast<int32_t>(renhook::utils::calculate_displacement(reinterpret_cast<uintptr_t>(block + 3), second_jump_real_addr, 6));
#else
            *(reinterpret_cast<int32_t*>(&expected_data_bytes[1])) = static_cast<int32_t>(renhook::utils::calculate_displacement(reinterpret_cast<uintptr_t>(&data), 0, 5));

            *(reinterpret_cast<int8_t*>(&expected_block_bytes[2])) = static_cast<int8_t>(renhook::utils::calculate_displacement(reinterpret_cast<uintptr_t>(&data[1]), reinterpret_cast<uintptr_t>(&data[0] + 14), 2));
            *(reinterpret_cast<int32_t*>(&expected_block_bytes[5])) = renhook::utils::calculate_displacement(reinterpret_cast<uintptr_t>(&data[3]), reinterpret_cast<uintptr_t>(&data[0] + 19), 6);
            *(reinterpret_cast<int32_t*>(&expected_block_bytes[10])) = renhook::utils::calculate_displacement(reinterpret_cast<uintptr_t>(block + 9), reinterpret_cast<uintptr_t>(&data[9]), 5);
            *(reinterpret_cast<int32_t*>(&expected_block_bytes[15])) = renhook::utils::calculate_displacement(reinterpret_cast<uintptr_t>(block + 14), first_jump_real_addr, 5);
            *(reinterpret_cast<int32_t*>(&expected_block_bytes[5])) = renhook::utils::calculate_displacement(reinterpret_cast<uintptr_t>(block + 3), second_jump_real_addr, 6);
#endif

            REQUIRE(compare_memory(data, expected_data_bytes));
            REQUIRE(compare_memory(block, expected_block_bytes));

            hook.detach();

            expected_data_bytes =
            {
                0x57,
                0x74, 0x60,
                0x0F, 0x84, 0x80, 0xFF, 0xFF, 0xFF,
                0x8D, 0x85, 0xE8, 0x03, 0x00, 0x00,
                0x8D, 0x54, 0x24, 0x50
            };

            REQUIRE(compare_memory(data, expected_data_bytes));
        }
    }
    SECTION("real hook")
    {
        REQUIRE(fibonacci(11) == 89);

        using fibonacci_t = uint32_t (*)(uint32_t);
        hook_t<fibonacci_t> hook(reinterpret_cast<uintptr_t>(&fibonacci), &fibonacci_hooked);

        hook.attach();
        REQUIRE(fibonacci(127) == 127);

        hook.detach();
        REQUIRE(fibonacci(17) == 1597);
    }
}

```

`tests/main.cpp`:

```cpp
#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>

```

`tests/memory/memory_allocator.cpp`:

```cpp
#include <catch2/catch.hpp>

#include <Windows.h>

#include <renhook/memory/memory_allocator.hpp>
#include <renhook/memory/virtual_protect.hpp>

TEST_CASE("memory::memory_allocator", "[memory][memory_allocator]")
{
    SYSTEM_INFO system_info = { 0 };
    GetSystemInfo(&system_info);

    size_t region_size = system_info.dwAllocationGranularity;
    auto minimum_address = reinterpret_cast<uintptr_t>(system_info.lpMinimumApplicationAddress);
    auto maximum_address = reinterpret_cast<uintptr_t>(system_info.lpMaximumApplicationAddress);

    renhook::memory::memory_allocator allocator;

    char* block_a = static_cast<char*>(allocator.alloc(0, -1));

    MEMORY_BASIC_INFORMATION memoryInfo = { 0 };
    VirtualQuery(block_a, &memoryInfo, sizeof(memoryInfo));

    REQUIRE(memoryInfo.Protect == PAGE_EXECUTE_READ);

    renhook::memory::virtual_protect protection(block_a, renhook::memory::memory_allocator::block_size, renhook::memory::protection::write);

    REQUIRE(block_a != nullptr);
    block_a[0] = '1';
    block_a[255] = '1';

    auto block_b = allocator.alloc(minimum_address + 0x10000, maximum_address / 2);
    REQUIRE(block_b != nullptr);

    auto block_c = allocator.alloc(minimum_address + 0x10000, maximum_address / 2 + 0x500);
    REQUIRE(block_c != nullptr);

    size_t diff = std::abs(reinterpret_cast<intptr_t>(block_c) - reinterpret_cast<intptr_t>(block_b));
    REQUIRE(diff < region_size);

    REQUIRE_THROWS(allocator.alloc(reinterpret_cast<uintptr_t>(block_c), reinterpret_cast<uintptr_t>(block_c) + 0x10));

    auto block_d = allocator.alloc(maximum_address / 2 + 0x100, maximum_address);
    REQUIRE(block_d != nullptr);

    diff = std::abs(reinterpret_cast<intptr_t>(block_d) - reinterpret_cast<intptr_t>(block_b));
    REQUIRE(diff >= region_size);

    std::vector<void*> blocks;
    for (size_t i = 0; i < 10000; i++)
    {
        auto block = allocator.alloc(0, -1);
        blocks.emplace_back(block);
    }

    auto block_e = allocator.alloc(0, -1);
    auto block_f = allocator.alloc(0, -1);
    auto block_g = allocator.alloc(0, -1);

    allocator.free(block_a);

    auto block_h = allocator.alloc(0, -1);

    allocator.free(block_b);
    allocator.free(block_c);
    allocator.free(block_g);

    auto block_i = allocator.alloc(0, -1);
    allocator.free(block_h);

    allocator.free(block_d);
    allocator.free(block_e);
    allocator.free(block_f);
    allocator.free(block_i);

    for (auto block : blocks)
    {
        allocator.free(block);
    }
}

```

`tests/memory/utils.cpp`:

```cpp
#include <catch2/catch.hpp>
#include <renhook/memory/utils.hpp>

TEST_CASE("memory::utils", "[memory][utils]")
{
    constexpr size_t granularity = 128;

    SECTION("align up")
    {
        REQUIRE(renhook::memory::utils::align_up<size_t>(1, granularity) == 128);
        REQUIRE(renhook::memory::utils::align_up<size_t>(127, granularity) == 128);
        REQUIRE(renhook::memory::utils::align_up<size_t>(128, granularity) == 128);

        REQUIRE(renhook::memory::utils::align_up<size_t>(129, granularity) == 256);
        REQUIRE(renhook::memory::utils::align_up<size_t>(200, granularity) == 256);
        REQUIRE(renhook::memory::utils::align_up<size_t>(240, granularity) == 256);

        REQUIRE(renhook::memory::utils::align_up<size_t>(257, granularity) == 384);
    }
    SECTION("align down")
    {
        REQUIRE(renhook::memory::utils::align_down<size_t>(1, granularity) == 0);
        REQUIRE(renhook::memory::utils::align_down<size_t>(30, granularity) == 0);
        REQUIRE(renhook::memory::utils::align_down<size_t>(127, granularity) == 0);

        REQUIRE(renhook::memory::utils::align_down<size_t>(128, granularity) == 128);
        REQUIRE(renhook::memory::utils::align_down<size_t>(129, granularity) == 128);
        REQUIRE(renhook::memory::utils::align_down<size_t>(240, granularity) == 128);

        REQUIRE(renhook::memory::utils::align_down<size_t>(256, granularity) == 256);
    }
}
```

`tests/memory/virtual_protect.cpp`:

```cpp
#include <catch2/catch.hpp>

#include <Windows.h>

#include <renhook/exception.hpp>
#include <renhook/memory/virtual_protect.hpp>

constexpr size_t allocation_size = 0x10000;

uint32_t get_memory_protection(void* address)
{
    MEMORY_BASIC_INFORMATION memory_info = { 0 };
    if (!VirtualQuery(address, &memory_info, sizeof(memory_info)))
    {
        throw renhook::exception("retrieving information about memory failed", GetLastError());
    }

    return memory_info.Protect;
}

TEST_CASE("memory::virtual_protect", "[memory][protection]")
{
    using protection = renhook::memory::protection;

    SECTION("valid address")
    {
        auto address = VirtualAlloc(nullptr, allocation_size, MEM_COMMIT, PAGE_NOACCESS);
        REQUIRE(get_memory_protection(address) == PAGE_NOACCESS);

        SECTION("protection::read")
        {
            renhook::memory::virtual_protect _(address, allocation_size, protection::read);
            REQUIRE(get_memory_protection(address) == PAGE_READONLY);
        }
        SECTION("protection::write")
        {
            renhook::memory::virtual_protect _(address, allocation_size, protection::write);
            REQUIRE(get_memory_protection(address) == PAGE_READWRITE);
        }
        SECTION("protection::execute")
        {
            renhook::memory::virtual_protect _(address, allocation_size, protection::execute);
            REQUIRE(get_memory_protection(address) == PAGE_EXECUTE);
        }
        SECTION("protection::read | protection::write")
        {
            renhook::memory::virtual_protect _(address, allocation_size, protection::read | protection::write);
            REQUIRE(get_memory_protection(address) == PAGE_READWRITE);
        }
        SECTION("protection::read | protection::execute")
        {
            renhook::memory::virtual_protect _(address, allocation_size, protection::read | protection::execute);
            REQUIRE(get_memory_protection(address) == PAGE_EXECUTE_READ);
        }
        SECTION("protection::read | protection::write | protection::execute")
        {
            renhook::memory::virtual_protect _(address, allocation_size, protection::read | protection::write | protection::execute);
            REQUIRE(get_memory_protection(address) == PAGE_EXECUTE_READWRITE);
        }

        REQUIRE(get_memory_protection(address) == PAGE_NOACCESS);

        SECTION("permanent change")
        {
            {
                renhook::memory::virtual_protect _(address, allocation_size, protection::read, true);
            }

            REQUIRE(get_memory_protection(address) == PAGE_READONLY);
        }

        VirtualFree(address, 0, MEM_RELEASE);
        address = nullptr;
    }
    SECTION("invalid address")
    {
        REQUIRE_THROWS(renhook::memory::virtual_protect(nullptr, allocation_size, protection::read));
        REQUIRE_THROWS(renhook::memory::virtual_protect(reinterpret_cast<void*>(1), allocation_size, protection::read));
        REQUIRE_THROWS(renhook::memory::virtual_protect(reinterpret_cast<uintptr_t*>(-1), allocation_size, protection::read));
    }
}

```

`tests/pattern.cpp`:

```cpp
#include <catch2/catch.hpp>

#include <renhook/pattern.hpp>

TEST_CASE("pattern")
{
    std::vector<uint8_t> fake_memory =
    {
        0x48, 0x89, 0x5C, 0x24, 0x08,               // mov [rsp+arg_0], rbx
        0x57,                                       // push rdi
        0x48, 0x83, 0xEC, 0x20,                     // sub rsp, 20h
        0x48, 0x8B, 0xD9,                           // mov rbx, rcx
        0x33, 0xFF,                                 // xor edi, edi
        0x48, 0x83, 0xC1, 0x08,                     // add rcx, 8
        0x48, 0x89, 0x79, 0xF8,                     // mov [rcx-8], rdi
        0xE8, 0x34, 0x32, 0xAF, 0xFE,               // call 0xFFFFFFFFFEAF3239
        0x48, 0x8B, 0x0D, 0x2D, 0x76, 0x2F, 0x01,   // mov rcx, [0x00000000012F7634]
        0xE8, 0x2B, 0x32, 0xAF, 0xFE,               // call 0xFFFFFFFFF4A13636
        0x48, 0x8D, 0x4B, 0x20,                     // mov rcx, [0xFFFFFFFFA1277631]
        0xE8, 0x22, 0x32, 0xAF, 0xFE,               // call 0x0000000045030105
        0x48, 0x89, 0x7B, 0x30,                     // mov [rbx+30h], rdi
        0x89, 0x7B, 0x38,                           // mov [rbx+38h], edi
        0x48, 0x8B, 0xC3,                           // mov rax, rbx
        0x48, 0x8B, 0x5C, 0x24, 0x30,               // mov rbx, [rsp+28h+arg_0]
        0x48, 0x83, 0xC4, 0x20,                     // add rsp, 20h
        0x5F,                                       // pop rdi
        0xC3                                        // retn
    };

    auto start = fake_memory.data();
    auto end = start + fake_memory.size();

    SECTION("{}")
    {
        renhook::pattern pattern;

        REQUIRE(pattern.empty());
        REQUIRE(pattern.size() == 0);
        REQUIRE_THROWS(pattern.find(0xCC, start, end));
    }
    SECTION("48 89 5C 24 08")
    {
        renhook::pattern pattern({ 0x48, 0x89, 0x5C, 0x24, 0x08 });

        REQUIRE(!pattern.empty());
        REQUIRE(pattern.size() == 5);

        auto offsets = pattern.find(0xCC, start, end);

        REQUIRE(offsets.size() == 1);
        REQUIRE(offsets[0] == reinterpret_cast<uintptr_t>(&fake_memory[0]));
    }
    SECTION("E8 ? ? ? ?")
    {
        renhook::pattern pattern({ 0xE8, 0xCC, 0xCC, 0xCC, 0xCC });

        REQUIRE(!pattern.empty());
        REQUIRE(pattern.size() == 5);

        auto offsets = pattern.find(0xCC, start, end);

        REQUIRE(offsets.size() == 3);
        REQUIRE(offsets[0] == reinterpret_cast<uintptr_t>(&fake_memory[23]));
        REQUIRE(offsets[1] == reinterpret_cast<uintptr_t>(&fake_memory[35]));
        REQUIRE(offsets[2] == reinterpret_cast<uintptr_t>(&fake_memory[44]));
    }
    SECTION("48 89 79 F8 E8 ? ? ? ? 48 8B 0D ? ? ? ?")
    {
        renhook::pattern pattern({ 0x48, 0x89, 0x79, 0xF8, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0x0D, 0xCC, 0xCC, 0xCC, 0xCC });

        REQUIRE(!pattern.empty());
        REQUIRE(pattern.size() == 16);

        auto offsets = pattern.find(0xCC, start, end);

        REQUIRE(offsets.size() == 1);
        REQUIRE(offsets[0] == reinterpret_cast<uintptr_t>(&fake_memory[19]));
    }
}

```

`tests/suspend_threads.cpp`:

```cpp
#include <catch2/catch.hpp>

#include <atomic>
#include <thread>
#include <Windows.h>

#include <renhook/suspend_threads.hpp>

namespace
{
    std::atomic_bool running = true;
    void suspend_threads_test()
    {
        while (running)
        {
        }
    }
}

TEST_CASE("suspend_threads")
{
    std::thread thread(suspend_threads_test);
    auto handle = thread.native_handle();

    {
        renhook::suspend_threads _(0, 0);

        auto count = SuspendThread(handle);
        ResumeThread(handle);

        REQUIRE(count > 0);

        running = false;
    }

    auto count = SuspendThread(handle);
    ResumeThread(handle);

    REQUIRE(count == 0);

    thread.join();
}

```

`tests/utils.cpp`:

```cpp
#include <catch2/catch.hpp>

#include <renhook/utils.hpp>

TEST_CASE("utils")
{
    REQUIRE(renhook::utils::calculate_displacement(100, 50, 5) == -55);
    REQUIRE(renhook::utils::calculate_displacement(30, 60, 5) == 25);
}

```

`tests/zydis.cpp`:

```cpp
#include <catch2/catch.hpp>

#include <renhook/zydis.hpp>

TEST_CASE("zydis")
{
    uint8_t data[] =
    {
#ifdef _WIN64
        0x48, 0x89, 0x5C, 0x24, 0x08,               // mov [rsp+arg_0], rbx
        0x57,                                       // push rdi
        0x48, 0x83, 0xEC, 0x20,                     // sub rsp, 20h
        0x48, 0x8B, 0xD9,                           // mov rbx, rcx
        0x33, 0xFF,                                 // xor edi, edi
        0x48, 0x83, 0xC1, 0x08,                     // add rcx, 8
        0x48, 0x89, 0x79, 0xF8,                     // mov [rcx-8], rdi
        0xE8, 0x34, 0x32, 0xAF, 0xFE,               // call 0xFFFFFFFFFEAF3239
        0x48, 0x8B, 0x0D, 0x2D, 0x76, 0x2F, 0x01    // mov rcx, [0x00000000012F7634]
#else
        0x89, 0x54, 0x24, 0x08,                     // mov [esp+arg_0], ebx
        0x57,                                       // push edi
        0x83, 0xEC, 0x20,                           // sub esp, 20h
        0x8B, 0xD9,                                 // mov ebx, ecx
        0x33, 0xFF,                                 // xor edi, edi
        0x83, 0xC1, 0x08,                           // add ecx, 8
        0x89, 0x79, 0xF8,                           // mov [ecx-8], edi
        0xE8, 0x34, 0x32, 0xAF, 0xFE,               // call 0xEAF3239
        0x8B, 0x0D, 0x2D, 0x76, 0x2F, 0x01          // mov ecx, [0x12F7634]
#endif
    };

    size_t decoded_length;

    renhook::zydis zydis;
    auto decoded_info = zydis.decode(reinterpret_cast<uintptr_t>(&data), sizeof(data), 5, decoded_length);

#ifdef _WIN64
    REQUIRE(decoded_length == 5);
    REQUIRE(decoded_info.instructions.size() == 1);

    decoded_info = zydis.decode(reinterpret_cast<uintptr_t>(&data), sizeof(data), 16, decoded_length);

    REQUIRE(decoded_length == 19);
    REQUIRE(decoded_info.instructions.size() == 6);

    decoded_info = zydis.decode(reinterpret_cast<uintptr_t>(&data), sizeof(data), 32, decoded_length);

    REQUIRE(decoded_length == 35);
    REQUIRE(decoded_info.instructions.size() == 9);
#else
    REQUIRE(decoded_length == 5);
    REQUIRE(decoded_info.instructions.size() == 2);

    decoded_info = zydis.decode(reinterpret_cast<uintptr_t>(&data), sizeof(data), 14, decoded_length);

    REQUIRE(decoded_length == 15);
    REQUIRE(decoded_info.instructions.size() == 6);

    decoded_info = zydis.decode(reinterpret_cast<uintptr_t>(&data), sizeof(data), 29, decoded_length);

    REQUIRE(decoded_length == 29);
    REQUIRE(decoded_info.instructions.size() == 9);
#endif
}

```