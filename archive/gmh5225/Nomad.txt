Project Path: arc_gmh5225_Nomad_j8gx9s_e

Source Tree:

```txt
arc_gmh5225_Nomad_j8gx9s_e
├── Nomad.sln
├── NomadDriver
│   ├── Common.h
│   ├── Driver.cpp
│   ├── Driver.h
│   ├── Hook.h
│   ├── Hooks.cpp
│   ├── Memory.cpp
│   ├── NomadDriver.vcxproj
│   ├── NomadDriver.vcxproj.filters
│   ├── PEHdr.h
│   ├── Threads.cpp
│   ├── Utility.cpp
│   └── Utility.h
├── NomadOutput.png
├── README.md
└── nomadImg.jpg

```

`Nomad.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31829.152
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Nomad", "NomadDriver\NomadDriver.vcxproj", "{A2D95A16-9A85-4061-B474-D77A252EBCE2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug Verbose|ARM = Debug Verbose|ARM
		Debug Verbose|ARM64 = Debug Verbose|ARM64
		Debug Verbose|x64 = Debug Verbose|x64
		Debug Verbose|x86 = Debug Verbose|x86
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug Verbose|ARM.ActiveCfg = DebugVerbose|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug Verbose|ARM.Build.0 = DebugVerbose|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug Verbose|ARM.Deploy.0 = DebugVerbose|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug Verbose|ARM64.ActiveCfg = DebugVerbose|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug Verbose|ARM64.Build.0 = DebugVerbose|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug Verbose|ARM64.Deploy.0 = DebugVerbose|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug Verbose|x64.ActiveCfg = DebugVerbose|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug Verbose|x64.Build.0 = DebugVerbose|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug Verbose|x64.Deploy.0 = DebugVerbose|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug Verbose|x86.ActiveCfg = DebugVerbose|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug Verbose|x86.Build.0 = DebugVerbose|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug Verbose|x86.Deploy.0 = DebugVerbose|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|ARM.ActiveCfg = Debug|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|ARM.Build.0 = Debug|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|ARM.Deploy.0 = Debug|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|ARM64.Build.0 = Debug|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|x64.ActiveCfg = Debug|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|x64.Build.0 = Debug|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|x64.Deploy.0 = Debug|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|x86.ActiveCfg = Debug|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|x86.Build.0 = Debug|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|x86.Deploy.0 = Debug|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|ARM.ActiveCfg = Release|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|ARM.Build.0 = Release|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|ARM.Deploy.0 = Release|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|ARM64.ActiveCfg = Release|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|ARM64.Build.0 = Release|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|ARM64.Deploy.0 = Release|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|x64.ActiveCfg = Release|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|x64.Build.0 = Release|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|x64.Deploy.0 = Release|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|x86.ActiveCfg = Release|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|x86.Build.0 = Release|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {353E8AC0-8867-4B77-A0C5-C2DFB8974CDC}
	EndGlobalSection
EndGlobal

```

`NomadDriver/Common.h`:

```h
#pragma once

#define MEMORY_DUMPER_DEVICE 0x8000
#define KERNEL_MAX_ADDR 0xFFFFFFFFFFFFFFFF
#define KERNEL_MIN_ADDR 0xFFFF000000000000

#define IOCTL_DUMP_KERNEL_MODULE CTL_CODE(MEMORY_DUMPER_DEVICE, \
	0x8000, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_VERIFY_ADDRESS CTL_CODE(MEMORY_DUMPER_DEVICE, \
	0x8001, METHOD_NEITHER, FILE_ANY_ACCESS)

#define MAX_NAME_LENGTH 20

typedef struct _MODULE_DATA {
	bool isAddr = false;
	UINT64 address = 0;
	UINT64 size = 0;
	char moduleName[MAX_NAME_LENGTH] = { 0 };
} MD_MODULE_DATA, *PMD_MODULE_DATA;

```

`NomadDriver/Driver.cpp`:

```cpp
#pragma once
#include "Utility.h"
#include "Driver.h"
#include "Common.h"
#include <intrin.h>

namespace NomadDrv {
    
    extern "C" NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
    {
        UNREFERENCED_PARAMETER(RegistryPath);
        Log("Starting Initialization\n");

        // map major function handlers
        DriverObject->MajorFunction[IRP_MJ_CREATE] = Create;
        DriverObject->MajorFunction[IRP_MJ_CLOSE] = Close;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceControl;
        DriverObject->DriverUnload = Unload;

        // Create a device object for the usermode application to use
        UNICODE_STRING devName = RTL_CONSTANT_STRING(L"\\Device\\Nomad");

        PDEVICE_OBJECT DeviceObject;
        NTSTATUS status = IoCreateDevice(DriverObject, 0, &devName, FILE_DEVICE_UNKNOWN, 0, FALSE, &DeviceObject);

        // error check for successful driver object creation
        if (!NT_SUCCESS(status))
        {
            LogError("Failed to create device object (0x%08X)\n", status);
            return status;
        }

        // provide symbolic link to device object to make accessible to usermode
        UNICODE_STRING symLink = RTL_CONSTANT_STRING(L"\\??\\Nomad");
        status = IoCreateSymbolicLink(&symLink, &devName);

        // error check for sym link creation
        if (!NT_SUCCESS(status))
        {
            LogError("Failed to create symbolic link (0x%08X)\n", status);
            IoDeleteDevice(DeviceObject);
            return status;
        }

        LogInfo("Driver initialized successfully\n");

        Utility MainUtility(DriverObject);
        MainUtility.EnumKernelModuleInfo(NULL);
        MainUtility.ScanSystemThreads();
        MainUtility.check_driver_dispatch();
        LogInfo("~Driver\n");
        // All checks complete
        return STATUS_SUCCESS;
    }

    void Unload(_In_ PDRIVER_OBJECT DriverObject)
    {
        UNICODE_STRING symLink = RTL_CONSTANT_STRING(L"\\??\\Nomad");
        // delete sym link
        IoDeleteSymbolicLink(&symLink);

        // delete device object
        IoDeleteDevice(DriverObject->DeviceObject);
        LogInfo("Nomad unloaded\n");
    }

    _Use_decl_annotations_
    NTSTATUS Create(PDEVICE_OBJECT DeviceObject, PIRP Irp)
    {
        UNREFERENCED_PARAMETER(DeviceObject);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        LogInfo("Client connection received\n");
        return STATUS_SUCCESS;
    }

    _Use_decl_annotations_
    NTSTATUS Close(PDEVICE_OBJECT DeviceObject, PIRP Irp)
    {
        UNREFERENCED_PARAMETER(DeviceObject);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        LogInfo("Client closed handle.\n");
        return STATUS_SUCCESS;
    }

    _Use_decl_annotations_
    NTSTATUS DeviceControl(PDEVICE_OBJECT, PIRP Irp)
    {
        // get our IO_STACK_LOCATION
        auto stack = IoGetCurrentIrpStackLocation(Irp);
        auto status = STATUS_SUCCESS;

        switch (stack->Parameters.DeviceIoControl.IoControlCode)
        {
        case IOCTL_DUMP_KERNEL_MODULE: {
            // do the work
            if (stack->Parameters.DeviceIoControl.InputBufferLength < sizeof(MD_MODULE_DATA))
            {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            auto data = (PMD_MODULE_DATA)stack->Parameters.DeviceIoControl.Type3InputBuffer;

            if (data == nullptr)
            {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            //status = DumpKernelModule(data->moduleName);
            //if (!NT_SUCCESS(status))
            //{
            //    KdPrint(("[NOMAD] [ERROR] Failed to dump kernel module\n"));
            //    break;
            //}
            KdPrint(("[NOMAD] [INFO] Successfully dumped kernel module\n"));
            break;
        }
        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //NTSTATUS DumpKernelModule(_In_ char* moduleName) {
    //
    //    RTL_PROCESS_MODULE_INFORMATION ModuleInfo;
    //    NTSTATUS status = EnumKernelModuleInfo(moduleName, &ModuleInfo);
    //
    //    if (!NT_SUCCESS(status)) {
    //        return STATUS_UNSUCCESSFUL;
    //    }
    //    KdPrint(("[NOMAD] [INFO] RTL_PROCESS_MODULE_INFORMATION DEBUG INFO\n"));
    //    KdPrint(("[NOMAD] [INFO] ModuleInfo.ImageSize: 0x%lx\n", ModuleInfo.ImageSize));
    //    KdPrint(("[NOMAD] [INFO] ModuleInfo.ImageBase: 0x%p\n", ModuleInfo.ImageBase));
    //    KdPrint(("[NOMAD] [INFO] ModuleInfo.FullPathName: 0x%s\n", ModuleInfo.FullPathName));
    //    KdPrint(("[NOMAD] [INFO] ModuleInfo.MappedBase: 0x%p\n", ModuleInfo.MappedBase));
    //    KdPrint(("[NOMAD] [INFO] ModuleInfo.Section: 0x%p\n", ModuleInfo.Section));
    //
    //
    //    //PVOID byteBuffer = ExAllocatePool(NonPagedPool, ModuleInfo.ImageSize);
    //    PVOID byteBuffer = ExAllocatePoolZero(NonPagedPool, ModuleInfo.ImageSize, 0x4A4A4A4A);
    //    PVOID byteBufferBase = byteBuffer;
    //    if (!byteBuffer) {
    //        KdPrint(("[NOMAD] [ERROR] Failed to allocate pool\n"));
    //        return STATUS_UNSUCCESSFUL;
    //    }
    //
    //    MM_COPY_ADDRESS mmCopyAddress;
    //    MM_COPY_ADDRESS mmCurrCopyAddr;
    //    mmCopyAddress.VirtualAddress = ModuleInfo.ImageBase;
    //    mmCurrCopyAddr.VirtualAddress = ModuleInfo.ImageBase;
    //    size_t numOfBytesCopied = 0;
    //    
    //    size_t remainingBytes = ModuleInfo.ImageSize;
    //    size_t incrementVal = PAGE_SIZE;
    //    size_t totalBytesCopied = 0;
    //    PVOID finalAddress = ((BYTE*)mmCopyAddress.VirtualAddress + ModuleInfo.ImageSize);
    //
    //    if (ModuleInfo.ImageSize < PAGE_SIZE)
    //    {
    //        KdPrint(("[NOMAD] [ERROR] ImageSize shouldn't be less than a page in size.  Halting operation\n"));
    //        return STATUS_UNSUCCESSFUL;
    //    }
    //
    //    KdPrint(("[NOMAD] [INFO] Starting MmCopyMemory Routine from %p to %p\n", mmCopyAddress.VirtualAddress, finalAddress));
    //    while (mmCopyAddress.VirtualAddress < finalAddress)
    //    {
    //        bool isValid = MmIsAddressValid(mmCopyAddress.VirtualAddress);
    //        if (isValid)
    //        {
    //            KdPrint(("[NOMAD] [INFO] MmIsAddressValid found valid page at %p\n", mmCopyAddress.VirtualAddress));
    //            // read it
    //            status = MmCopyMemory(byteBuffer, mmCopyAddress, PAGE_SIZE, MM_COPY_MEMORY_VIRTUAL, (PSIZE_T)&numOfBytesCopied);
    //            if (!NT_SUCCESS(status))
    //            {
    //                KdPrint(("[NOMAD] [WARN] Failed to copy bytes at address: %p\n", mmCopyAddress.VirtualAddress));
    //                KdPrint(("[NOMAD] [WARN] MmCopyMemory() NTSTATUS: STATUS_ACCESS_VIOLATION.  Handling by filling invalid pages with 00's\n"));
    //                goto makeBlank;
    //            }
    //
    //            byteBuffer = ((BYTE*)byteBuffer + incrementVal);
    //            totalBytesCopied += incrementVal;
    //            mmCopyAddress.VirtualAddress = ((BYTE*)mmCopyAddress.VirtualAddress + incrementVal);
    //            remainingBytes -= incrementVal;
    //            continue;
    //        }
    //        else {
    //            // make a blank page
    //            KdPrint(("[NOMAD] [WARN] MmIsAddressValid invalid page: %p\n", mmCopyAddress.VirtualAddress));
    //        makeBlank:
    //            RtlSecureZeroMemory(byteBuffer, PAGE_SIZE);
    //            byteBuffer = ((BYTE*)byteBuffer + incrementVal);
    //            totalBytesCopied += incrementVal;
    //            mmCopyAddress.VirtualAddress = ((BYTE*)mmCopyAddress.VirtualAddress + incrementVal);
    //            remainingBytes -= incrementVal;
    //        }
    //    }
    //    KdPrint(("[NOMAD] [INFO] Copied memory range from %p to %p into buffer at %p\n", ModuleInfo.ImageBase, mmCopyAddress.VirtualAddress, byteBufferBase));
    //    KdPrint(("[NOMAD] [INFO] Number of bytes copied: %zu\n", totalBytesCopied));
    //    HANDLE fileHandle = NULL;
    //    UNICODE_STRING fileName = RTL_CONSTANT_STRING(L"\\DosDevices\\C:\\DumpedDriver.sys");
    //    OBJECT_ATTRIBUTES objAttr;
    //    IO_STATUS_BLOCK ioStatusBlock;
    //
    //    InitializeObjectAttributes(&objAttr, &fileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
    //
    //    if (!NT_SUCCESS(ZwCreateFile(&fileHandle, GENERIC_WRITE, &objAttr, &ioStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0))) {
    //        KdPrint(("[NOMAD] [ERROR] Failed to create file\n"));
    //        //ExFreePool(byteBufferBase);
    //        ExFreePoolWithTag(byteBufferBase, 0x4A4A4A4A);
    //        return STATUS_UNSUCCESSFUL;
    //    }
    //
    //    if (!NT_SUCCESS(ZwWriteFile(fileHandle, NULL, NULL, NULL, &ioStatusBlock, byteBufferBase, ModuleInfo.ImageSize, NULL, NULL))) {
    //        KdPrint(("[NOMAD] [ERROR] Failed to write to file!\n"));
    //        //ExFreePool(byteBufferBase);
    //        ExFreePoolWithTag(byteBufferBase, 0x4A4A4A4A);
    //        return STATUS_UNSUCCESSFUL;
    //    }
    //
    //    KdPrint(("[NOMAD] [INFO] %s was saved \n", moduleName));
    //    ZwClose(fileHandle);
    //    //ExFreePool(byteBufferBase);
    //    ExFreePoolWithTag(byteBufferBase, 0x4A4A4A4A);
    //    return STATUS_SUCCESS;
    //}
}
```

`NomadDriver/Driver.h`:

```h
#pragma once
#include <ntifs.h>
#include <windef.h>
#include <ntstrsafe.h>
#include "PEHdr.h"

#define MAX_NAME_LEN 25

#define PAGE_SIZE 0x1000
#define PML4_OFFSET_MASK 0b00000000 11111111 00000000 00000000 00000000 00000000 00000000 00000000

#define SYS_MOD_INF 0x0B

#define DEBUG

// @jk2
#ifdef DEBUG
#define Log(format, ...) DbgPrint("[NOMAD] " format "\n", __VA_ARGS__)
#define LogInfo(format, ...) DbgPrint("[NOMAD] [INFO] " format "\n", __VA_ARGS__)
#define LogError(format, ...) DbgPrint("[NOMAD] [ERROR] " format "\n", __VA_ARGS__)

#else
#define Log(format, ...) 
#define LogInfo(format, ...) 
#define LogError(format, ...)

#endif

typedef unsigned long long uint64_t, _QWORD;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

//typedef struct _SYSTEM_MODULE_ENTRY
//{
//	ULONG  Unused;
//	ULONG  Always0;
//	PVOID  ModuleBaseAddress;
//	ULONG  ModuleSize;
//	ULONG  Unknown;
//	ULONG  ModuleEntryIndex;
//	USHORT ModuleNameLength;
//	USHORT ModuleNameOffset;
//	CHAR   ModuleName[256];
//
//} 	SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG               	ModulesCount;
	SYSTEM_MODULE_ENTRY		Modules[1];		// changed from 0...using React OS's def https://doxygen.reactos.org/da/dda/filesystems_2udfs_2Include_2ntddk__ex_8h_source.html#l00087

} 	SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

extern "C" {
	NTKERNELAPI PVOID NTAPI RtlFindExportsRoutineByName(
		_In_ PVOID ImageBase,
		_In_ PCCH RoutineName
	);

	NTKERNELAPI PPEB PsGetProcessPeb(
		_In_ PEPROCESS Process
	);

	NTSTATUS NTAPI MmCopyVirtualMemory(
		PEPROCESS SourceProcess,
		PVOID SourceAddress,
		PEPROCESS TargetProcess,
		PVOID TargetAddress,
		SIZE_T BufferSize,
		KPROCESSOR_MODE PreviousMode,
		PSIZE_T ReturnSize
	);

	NTKERNELAPI
		POBJECT_TYPE
		NTAPI
		ObGetObjectType(
			_In_ PVOID Object
		);
	// https://github.com/processhacker/processhacker/blob/1aa402b6a29e8b60d5c93c8385c68f719896cb24/KProcessHacker/include/ntfill.h#L261
	NTKERNELAPI
		NTSTATUS
		NTAPI
		ObOpenObjectByName(
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ POBJECT_TYPE ObjectType,
			_In_ KPROCESSOR_MODE PreviousMode,
			_In_opt_ PACCESS_STATE AccessState,
			_In_opt_ ACCESS_MASK DesiredAccess,
			_In_opt_ PVOID ParseContext,
			_Out_ PHANDLE Handle
		);

	// https://github.com/processhacker/processhacker/blob/27c3377a9c1d3500396ed886af3d070890a68164/phnt/include/ntzwapi.h#L2765
	NTSYSCALLAPI
		NTSTATUS
		NTAPI
		ZwQueryDirectoryObject(
			_In_ HANDLE DirectoryHandle,
			_Out_writes_bytes_opt_(Length) PVOID Buffer,
			_In_ ULONG Length,
			_In_ BOOLEAN ReturnSingleEntry,
			_In_ BOOLEAN RestartScan,
			_Inout_ PULONG Context,
			_Out_opt_ PULONG ReturnLength
		);

	// https://doxygen.reactos.org/db/d18/obref_8c.html#a727c1f0726c97a4d0f526d541cee1f6a
	NTSTATUS
		NTAPI
		ObReferenceObjectByName(IN PUNICODE_STRING ObjectPath,
			IN ULONG Attributes,
			IN PACCESS_STATE PassedAccessState,
			IN ACCESS_MASK DesiredAccess,
			IN POBJECT_TYPE ObjectType,
			IN KPROCESSOR_MODE AccessMode,
			IN OUT PVOID ParseContext,
			OUT PVOID* ObjectPtr);
}

namespace NomadDrv {
	extern "C" NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath);
	NTSTATUS Create(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp);
	NTSTATUS Close(_In_ PDEVICE_OBJECT DeviceObject, PIRP Irp);
	NTSTATUS DeviceControl(_In_ PDEVICE_OBJECT, _Inout_ PIRP Irp);
	void Unload(_In_ PDRIVER_OBJECT DriverObject);
}

```

`NomadDriver/Hook.h`:

```h
#pragma once
// https://doxygen.reactos.org/d8/d5b/struct__DIRECTORY__BASIC__INFORMATION.html

// https://community.osr.com/discussion/166794/obreferenceobjectbyname-0xc00000024-windows-7
extern "C" POBJECT_TYPE * IoDriverObjectType;

typedef struct  _DIRECTORY_BASIC_INFORMATION {
	UNICODE_STRING ObjectName;
	UNICODE_STRING ObjectTypeName;
} DIRECTORY_BASIC_INFORMATION, * PDIRECTORY_BASIC_INFORMATION;
```

`NomadDriver/Hooks.cpp`:

```cpp
#pragma once
#include "Utility.h"
#include "Hook.h"



void Utility::check_driver_dispatch()
{
	HANDLE hDir;
	UNICODE_STRING str;
	OBJECT_ATTRIBUTES oa;
	RtlInitUnicodeString(&str, L"\\Driver");
	InitializeObjectAttributes(&oa, &str, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, (HANDLE)NULL, (PSECURITY_DESCRIPTOR)NULL);
	if (!NT_SUCCESS(ZwOpenDirectoryObject(&hDir, DIRECTORY_QUERY, &oa))) {
		LogError("Failed to open \\Driver directory object.");
		return;
	}

	PVOID Obj;
	if (!NT_SUCCESS(ObReferenceObjectByHandle(hDir, DIRECTORY_QUERY, nullptr, KernelMode, &Obj, nullptr))) {
		LogError("ObReferenceObjectByHandle failed.");
		return;
	}
	NtClose(hDir);

	auto obj_type = ObGetObjectType(Obj);
	ObDereferenceObject(Obj);
	
	HANDLE h;

	if (!NT_SUCCESS(ObOpenObjectByName(&oa, obj_type, KernelMode, NULL, DIRECTORY_QUERY, nullptr, &h))) {
		LogError("ObOpenObjectByName failed.");
		return;
	}

	auto dirInfo = (PDIRECTORY_BASIC_INFORMATION)ExAllocatePoolWithTag(POOL_TYPE::NonPagedPool, PAGE_SIZE, POOL_TAG);

	if (!dirInfo)
	{
		LogError("checkDispatch() Failed to allocate pool.");
		return;
	}

	ULONG ulContext = 0;

	ULONG returnedBytes;
	bool isClean = true;
	int suspiciousDrivers = 0;
	while (NT_SUCCESS(ZwQueryDirectoryObject(h, dirInfo, PAGE_SIZE, TRUE, FALSE, &ulContext, &returnedBytes)))
	{
		isClean = true;
		PDRIVER_OBJECT pObj;
		wchar_t wsDriverName[100] = L"\\Driver\\";
		wcscat(wsDriverName, dirInfo->ObjectName.Buffer);
		UNICODE_STRING objName;
		objName.Length = objName.MaximumLength = wcslen(wsDriverName) * 2;
		objName.Buffer = wsDriverName;
		if (NT_SUCCESS(ObReferenceObjectByName(&objName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL, *IoDriverObjectType, KernelMode, nullptr, (PVOID*)&pObj)))
		{
			LogInfo("Checking driver object: %ls", wsDriverName);
			LogInfo("\t\tChecking ->MajorFunction[IRP_MJ_DEVICE_CONTROL]");
			if (!CheckModulesForAddress(reinterpret_cast<uintptr_t>(pObj->MajorFunction[IRP_MJ_DEVICE_CONTROL]), outProcMods)) {
				LogInfo("\t\t\t[SUSPICIOUS] %wZ driver has suspicious driver dispatch", pObj->DriverName);
				isClean = false;
			}

			LogInfo("\t\tChecking ->DriverStart");
			if (!CheckModulesForAddress((uintptr_t)pObj->DriverStart, outProcMods)) {
				LogInfo("\t\t\t[SUSPICIOUS] %wZ driver has suspicious DriverStart", pObj->DriverName);
				isClean = false;
			}

			LogInfo("\t\tChecking ->FastIoDispatch");
			if (reinterpret_cast<uintptr_t>(pObj->FastIoDispatch))
			{
				if (!CheckModulesForAddress(reinterpret_cast<uintptr_t>(pObj->FastIoDispatch->FastIoDeviceControl), outProcMods)) {
					LogInfo("\t\t\t[SUSPICIOUS] %wZ driver has suspicious FastIoDispatch->FastIoDeviceControl", pObj->DriverName);
					isClean = false;
				}
			}
			else
			{
				LogInfo("\t\t\tFastIoDispatch == NULL");
			}
			
			if (isClean)
			{
				LogInfo("Driver object clean.");
			}
			else
			{
				suspiciousDrivers++;
			}

			ObDereferenceObject(pObj);
		}
	}
	LogInfo("[REPORT] Found %d driver object(s) with suspicious pointer(s)", suspiciousDrivers);

	ZwClose(h);
}
```

`NomadDriver/Memory.cpp`:

```cpp
#pragma once
#include "Utility.h"
#include "Driver.h"


INT Utility::ScanBigPoolsForAddr(_In_ uintptr_t addr)
{
	ULONG len = 4 * 1024 * 1024;
	auto mem = ExAllocatePoolWithTag(POOL_TYPE::NonPagedPool, len, POOL_TAG);

	if (!mem)
	{
		LogError("\t\t\tFailed to allocate memory pool in ScanBigPoolsForAddr().");
		return 0;
	}

	if (NT_SUCCESS(pZwQuerySysInfo(SystemBigPoolInformation, mem, len, &len))) {
		auto pBuf = reinterpret_cast<PSYSTEM_BIGPOOL_INFORMATION>(mem);
		for (ULONG i = 0; i < pBuf->Count; i++) {
			if (addr >= pBuf->AllocatedInfo[i].VirtualAddress && addr < pBuf->AllocatedInfo[i].VirtualAddress + pBuf->AllocatedInfo[i].SizeInBytes)
			{
				LogInfo("[DETECTION] Detected a mapped image in an allocated memory pool!  Pool tag:0x%04x\n", pBuf->AllocatedInfo[i].TagUlong);
				ExFreePoolWithTag(mem, POOL_TAG);
				return 1;
			}

			if (pBuf->AllocatedInfo[i].TagUlong == 'enoN' && addr >= pBuf->AllocatedInfo[i].VirtualAddress && addr < pBuf->AllocatedInfo[i].VirtualAddress + pBuf->AllocatedInfo[i].SizeInBytes) {
				if (pBuf->AllocatedInfo[i].SizeInBytes > 0x1000) {
					__try {
						UCHAR zeroedoutpehdr[0x1000]{};
						if (auto pe_hdr = MmMapIoSpace(MmGetPhysicalAddress((void*)pBuf->AllocatedInfo[i].VirtualAddress), PAGE_SIZE, MEMORY_CACHING_TYPE::MmNonCached)) {
							if (memcmp(pe_hdr, zeroedoutpehdr, 0x1000))
							{
								LogInfo("[DETECTION] kdmapper/drvmap manual mapped driver detected (99%% confidence).\n");
								MmUnmapIoSpace(pe_hdr, PAGE_SIZE);
								ExFreePoolWithTag(mem, POOL_TAG);
								return 1;
							}
							else
							{
								LogInfo("[DETECTION] Detected a mapped image!\n");
								MmUnmapIoSpace(pe_hdr, PAGE_SIZE);
								ExFreePoolWithTag(mem, POOL_TAG);
								return 1;
							}
							MmUnmapIoSpace(pe_hdr, PAGE_SIZE);
						}
						else
						{
							LogInfo("[DETECTION] Unable to map physical memory to dump/verify but manual map driver detected anyways with 95%% confidence.\n");
							ExFreePoolWithTag(mem, POOL_TAG);
							return 1;
						}
					}
					__except (EXCEPTION_EXECUTE_HANDLER) {
						LogError("Access Violation was raised.\n");
						ExFreePoolWithTag(mem, POOL_TAG);
						return 0;
					}
				}
			}
		}
	}
	else
		LogError("Failed to get bigpool.\n");

	ExFreePoolWithTag(mem, POOL_TAG);
	return 0;
}
```

`NomadDriver/NomadDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="DebugVerbose|ARM">
      <Configuration>DebugVerbose</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugVerbose|ARM64">
      <Configuration>DebugVerbose</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugVerbose|Win32">
      <Configuration>DebugVerbose</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugVerbose|x64">
      <Configuration>DebugVerbose</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A2D95A16-9A85-4061-B474-D77A252EBCE2}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>MemoryDumper</RootNamespace>
    <ProjectName>Nomad</ProjectName>
    <WindowsTargetPlatformVersion>10.0.22000.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Windows Driver</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Windows Driver</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ShowIncludes>true</ShowIncludes>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SetChecksum>false</SetChecksum>
      <AdditionalOptions>/verbose %(AdditionalOptions)</AdditionalOptions>
      <SubSystem>Windows</SubSystem>
    </Link>
    <MASM>
      <UseSafeExceptionHandlers>false</UseSafeExceptionHandlers>
    </MASM>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ShowIncludes>true</ShowIncludes>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard_C>stdc11</LanguageStandard_C>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalOptions>/kernel %(ClCompile.AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <AdditionalOptions>/kernel %(AdditionalOptions)</AdditionalOptions>
      <SubSystem>Native</SubSystem>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SetChecksum>false</SetChecksum>
    </Link>
    <MASM>
      <UseSafeExceptionHandlers>false</UseSafeExceptionHandlers>
    </MASM>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ShowIncludes>true</ShowIncludes>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;VERBOSE_LOG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>
      </RuntimeLibrary>
    </ClCompile>
    <Link>
      <AdditionalOptions>/verbose %(AdditionalOptions)</AdditionalOptions>
      <SubSystem>Windows</SubSystem>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SetChecksum>false</SetChecksum>
    </Link>
    <MASM>
      <UseSafeExceptionHandlers>false</UseSafeExceptionHandlers>
    </MASM>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp" />
    <ClCompile Include="Hooks.cpp" />
    <ClCompile Include="Memory.cpp" />
    <ClCompile Include="Threads.cpp" />
    <ClCompile Include="Utility.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Common.h" />
    <ClInclude Include="Driver.h" />
    <ClInclude Include="Hook.h" />
    <ClInclude Include="PEHdr.h" />
    <ClInclude Include="Utility.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`NomadDriver/NomadDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utility.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Threads.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Hooks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PEHdr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utility.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NomadDriver/PEHdr.h`:

```h
// From winnnt.h
#pragma once
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
#define IMAGE_SIZEOF_SHORT_NAME              8
#define E_MAGIC 0x5A4D
#define NT_HDR_SIG 0x4550

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
	WORD   e_magic;                     // Magic number
	WORD   e_cblp;                      // Bytes on last page of file
	WORD   e_cp;                        // Pages in file
	WORD   e_crlc;                      // Relocations
	WORD   e_cparhdr;                   // Size of header in paragraphs
	WORD   e_minalloc;                  // Minimum extra paragraphs needed
	WORD   e_maxalloc;                  // Maximum extra paragraphs needed
	WORD   e_ss;                        // Initial (relative) SS value
	WORD   e_sp;                        // Initial SP value
	WORD   e_csum;                      // Checksum
	WORD   e_ip;                        // Initial IP value
	WORD   e_cs;                        // Initial (relative) CS value
	WORD   e_lfarlc;                    // File address of relocation table
	WORD   e_ovno;                      // Overlay number
	WORD   e_res[4];                    // Reserved words
	WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
	WORD   e_oeminfo;                   // OEM information; e_oemid specific
	WORD   e_res2[10];                  // Reserved words
	LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER;

typedef struct _IMAGE_SECTION_HEADER {
	BYTE  Name[8];
	union {
		DWORD PhysicalAddress;
		DWORD VirtualSize;
	} Misc;
	DWORD VirtualAddress;
	DWORD SizeOfRawData;
	DWORD PointerToRawData;
	DWORD PointerToRelocations;
	DWORD PointerToLinenumbers;
	WORD  NumberOfRelocations;
	WORD  NumberOfLinenumbers;
	DWORD Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
	DWORD   VirtualAddress;
	DWORD   Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_FILE_HEADER {
	WORD    Machine;
	WORD    NumberOfSections;
	DWORD   TimeDateStamp;
	DWORD   PointerToSymbolTable;
	DWORD   NumberOfSymbols;
	WORD    SizeOfOptionalHeader;
	WORD    Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
	WORD        Magic;
	BYTE        MajorLinkerVersion;
	BYTE        MinorLinkerVersion;
	DWORD       SizeOfCode;
	DWORD       SizeOfInitializedData;
	DWORD       SizeOfUninitializedData;
	DWORD       AddressOfEntryPoint;
	DWORD       BaseOfCode;
	ULONGLONG   ImageBase;
	DWORD       SectionAlignment;
	DWORD       FileAlignment;
	WORD        MajorOperatingSystemVersion;
	WORD        MinorOperatingSystemVersion;
	WORD        MajorImageVersion;
	WORD        MinorImageVersion;
	WORD        MajorSubsystemVersion;
	WORD        MinorSubsystemVersion;
	DWORD       Win32VersionValue;
	DWORD       SizeOfImage;
	DWORD       SizeOfHeaders;
	DWORD       CheckSum;
	WORD        Subsystem;
	WORD        DllCharacteristics;
	ULONGLONG   SizeOfStackReserve;
	ULONGLONG   SizeOfStackCommit;
	ULONGLONG   SizeOfHeapReserve;
	ULONGLONG   SizeOfHeapCommit;
	DWORD       LoaderFlags;
	DWORD       NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64 {
	DWORD Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD   Characteristics;
	DWORD   TimeDateStamp;
	WORD    MajorVersion;
	WORD    MinorVersion;
	DWORD   Name;
	DWORD   Base;
	DWORD   NumberOfFunctions;
	DWORD   NumberOfNames;
	DWORD   AddressOfFunctions;
	DWORD   AddressOfNames;
	DWORD   AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY;

typedef struct _SYSTEM_MODULE_ENTRY {
	ULONG  Unused;
	ULONG  Always0;
	PVOID  ModuleBaseAddress;
	ULONG  ModuleSize;
	ULONG  Unknown;
	ULONG  ModuleEntryIndex;
	USHORT ModuleNameLength;
	USHORT ModuleNameOffset;
	CHAR   ModuleName[256];
	//HANDLE Section;
	//PVOID MappedBase;
	//PVOID ImageBase;
	//ULONG ImageSize;
	//ULONG Flags;
	//USHORT LoadOrderIndex;
	//USHORT InitOrderIndex;
	//USHORT LoadCount;
	//USHORT OffsetToFileName;
	//UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;		// using https://doxygen.reactos.org/da/dda/filesystems_2udfs_2Include_2ntddk__ex_8h_source.html#l00074


```

`NomadDriver/Threads.cpp`:

```cpp
#pragma once
#include "Utility.h"
#include "Driver.h"
//#include <winnt.h>

// https://www.unknowncheats.me/forum/anti-cheat-bypass/325212-eac-system-thread-detection.html

/// <summary>
/// Scans for system threads and checks if within a valid module
/// </summary>
/// <returns>success on no error</returns>
NTSTATUS Utility::ScanSystemThreads()
{
    if (mImportFail)
    {
        LogInfo("An import failed.  Aborting ScanSystemThreads()\n");
        return STATUS_UNSUCCESSFUL;
    }

    PEPROCESS thisEPROC;
    BOOLEAN isSystemThread = 0;
    HANDLE systemProcId;
    PVOID systemBigPoolInformation = NULL;
    PRTL_PROCESS_MODULES systemModuleInformation = NULL;
    CONTEXT* context;
    HANDLE processID;
    PEPROCESS processObject;

    NTSTATUS status;
    STACKWALK_BUFFER stackwalkBuffer;
    PETHREAD threadObject;
    UINT32 susThreadStacks = 0;
    UINT32 susThreadEntry = 0;
    UINT32 mappedDriverEntry = 0;
    uintptr_t threadStartAddr;

    LogInfo("ScanSystemThreads(), Starting routine\n");
    systemProcId = pPsGetCurrentProcessId();
    LogInfo("\tpPsGetCurrentProcessId() returned %p\n", (VOID*)systemProcId);
    if (pPsIsSystemThread)
    {
        isSystemThread = pPsIsSystemThread((PETHREAD)__readgsqword(0x188u));
        LogInfo("\tpPsIsSystemThread() returned %u\n", isSystemThread);
    }
    else
    {
        isSystemThread = 0;
    }
    if (isSystemThread)
    {
        thisEPROC = pPsGetCurrentProcess();
        LogInfo("\tpPsGetCurrentProcess() returned %p\n", (VOID*)thisEPROC);
        if (thisEPROC == PsInitialSystemProcess)  // PsInitialSystemProcess is global from ntkrnl
        {
            // Get system big pool info
            if (!NT_SUCCESS(status = QuerySystemInformation(SystemBigPoolInformation, &systemBigPoolInformation)))
            {
                LogError("\tQuerySystemInformation(SystemBigPoolInformation) was unsuccessful 0x%08x\n", status);
                return status;
            }

            // System != Process module info
            if (!NT_SUCCESS(status = QuerySystemInformation(SystemModuleInformation, (PVOID*)&systemModuleInformation)))
            {
                LogError("\tQuerySystemInformation(SystemModuleInformation) was unsuccessful 0x%08x\n", (long)status);
                return status;
            }

            //systemModuleInformation = (PSYSTEM_MODULE_INFORMATION)result;
            
            if (systemModuleInformation)
            {
                // allocate memory to store a thread's context
                context = (CONTEXT*)ExAllocatePoolWithTag(NonPagedPool, sizeof(CONTEXT), POOL_TAG);
                if (context)
                {
                    // thread id's are multiple of 4
                    for (size_t currentThreadId = 4; currentThreadId < 0x3000; currentThreadId += 4)
                    {
                        status = pPsLookupThreadByThreadId((HANDLE)currentThreadId, &threadObject);

                        if (status == STATUS_SUCCESS)
                        {
#ifdef VERBOSE_LOG
                            LogInfo("\tFound valid thread id: 0x%llx (%llu)", currentThreadId, currentThreadId);
#endif // VERBOSE_LOG
                            processObject = pIoThreadToProcess(threadObject);

                            if (!processObject)
                            {
                                LogError("\t\tpFailed to get process object, pIoThreadToProcess(threadObject) == NULL, skipping thread ID: %llu\n", currentThreadId);
                                continue;
                            }

                            processID = pPsGetProcessId(processObject);

                            if (!processID)
                            {
                                LogError("\t\tAborting thread check:  Failed to get process id, pPsGetProcessId(processObject) == NULL\n");
                                continue;
                            }

                            if (processID == systemProcId)                                      // if...the thread's pid is the same as system pid, and threadobject 
                            {
#ifndef VERBOSE_LOG
                                LogInfo("\tFound thread belonging to system process. ID: 0x%llx (%llu)", currentThreadId, currentThreadId);
#endif // !VERBOSE_LOG
                               if (threadObject != (PVOID)__readgsqword(0x188))                    // and thread obj is not our current thread
                                {
                                    if (StackwalkThread(threadObject, context, &stackwalkBuffer))   // and succesfully walks the stack of thread
                                    {
                                        if (stackwalkBuffer.EntryCount > 0)                         // and has more than 1 entry in the stack
                                        {
                                            LogInfo("\t\t\tExamining thread stack.....");
                                            LogInfo("\t\t\tstackwalkBuffer.EntryCount: %lu", stackwalkBuffer.EntryCount);
                                            for (size_t i = 0; i < stackwalkBuffer.EntryCount; i++)
                                            {
                                                LogInfo("\t\t\tstackwalkBuffer.Entry[%llu].RipValue: 0x%p", i, (VOID*)stackwalkBuffer.Entry[i].RipValue);
                                                if (!CheckModulesForAddress(stackwalkBuffer.Entry[i].RipValue, systemModuleInformation))
                                                {
                                                    LogInfo("\t\t\t[SUSPICIOUS] Thread found with addr outside of legit modules (low confidence)\n");
                                                    susThreadStacks += 1;
                                                    break;
                                                }
                                                else if(i == stackwalkBuffer.EntryCount - 1)
                                                {
                                                    LogInfo("\t\t\tThread stack is clean...");
                                                }
                                            }
                                        }
                                        else
                                        {
                                            LogInfo("\t\t\t[ABORT] Stack check:  No entries in thread stack");
                                        }
                                    }
                                    else
                                    {
                                        LogInfo("\t\t\t[ABORT] Stack check:  Failed to walk thread's stack.");
                                    }
                                    
                                    if (NT_SUCCESS(status = GetThreadStartAddr(threadObject, &threadStartAddr)))
                                    {
                                        
                                        if (!CheckModulesForAddress(threadStartAddr, systemModuleInformation))
                                        {
                                            susThreadEntry += 1;
                                            LogInfo("\t\t\t[DETECTION] Thread's entry 0x%p is outside of legit modules (high confidence)\n", (VOID*)threadStartAddr);
                                            LogInfo("\t\t\tChecking if address is within an allocated pool...\n");
                                            if (ScanBigPoolsForAddr(threadStartAddr) == 1)
                                            {
                                                mappedDriverEntry += 1;
                                            }
                                        }
                                        else
                                        {
                                            LogInfo("\t\t\tThread entry point is clean: 0x%p", (VOID*)threadStartAddr);
                                        }
                                    }
                                }
                                else
                                {
#ifdef VERBOSE_LOG
                                    LogInfo("\t\tAborting thread check:  Our thread");
#endif // VERBOSE_LOG
                                }
                            }
                            else
                            {
#ifdef VERBOSE_LOG
                                LogInfo("\t\tAborting thread check:  Not a System thread");
                                //GetCurrentThreadContext(threadObject);
                                //KbGetThreadContext(threadObject);
#endif // VERBOSE_LOG
                            }
                            ObfDereferenceObject(threadObject); // reference count was incremented by pPsLookupThreadByThreadId
                        }
                    }

                    if (susThreadStacks)
                    {
                        LogInfo("[REPORT] Found %lu thread(s) with suspicious stack(s) (low confidence)", susThreadStacks);
                    }

                    if (susThreadEntry)
                    {
                        LogInfo("[REPORT] Found %lu thread(s) with suspicious entry point(s) (high confidence)!", susThreadEntry);
                    }

                    if (!susThreadStacks && !susThreadEntry)
                    {
                        LogInfo("[REPORT] No suspicious threads found.");
                    }

                    if (mappedDriverEntry)
                    {
                        LogInfo("[REPORT] Found %lu mapped driver(s)!", mappedDriverEntry);
                    }

                    ExFreePool(context);
                }
                else
                {
                    LogError("\t\tUtility.cpp:%d, ExAllocatePool failed\n", __LINE__);
                    return STATUS_UNSUCCESSFUL;
                }
                ExFreePool(systemModuleInformation);
            }
            else
            {
                LogError("\t\tUtility.cpp:%d, systemModuleInformation == NULL\n", __LINE__);
                return STATUS_UNSUCCESSFUL;
            }
            if (systemBigPoolInformation)
                ExFreePoolWithTag(systemBigPoolInformation, POOL_TAG);
        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS Utility::KbGetThreadContext(IN PETHREAD threadObject)
{
    if (!threadObject)
        return STATUS_NOT_FOUND;

    NTSTATUS Status = STATUS_SUCCESS;
    
    PCONTEXT Context = (PCONTEXT)ExAllocatePool(NonPagedPool, sizeof(CONTEXT));

    //KPROCESSOR_MODE PreviousMode = ExGetPreviousMode();
    if (!Context)
    {
        LogInfo("Failed to allocate pool for context.");
        return STATUS_UNSUCCESSFUL;
    }

    RtlZeroMemory(Context, sizeof(CONTEXT));
    // FLAGS ARE VERY SPECIFIC TO FUNCTION BEHAVIORS.  CONTEXT_ALL locks it.
    //Context->ContextFlags = WOW64_;
    Status = pPsGetContextThread(threadObject, Context, KernelMode);
    LogInfo("\t\t\tpPsGetContextThread status: 0x%p", (PVOID)Status);
    LogInfo("\t\t\tThread Context->Rip: 0x%p", (PVOID)Context->Rip);
    ExFreePool(Context);
    return Status;
}

BOOLEAN Utility::GetCurrentThreadContext(PETHREAD threadObject)
{
//    // _PETHREAD+0x2c8 WaitPrcb         : Ptr64 _KPRCB
//    //PVOID WaitPrcb = *((PVOID*)((UINT64)threadObject + 0x2c8));
//    //if (WaitPrcb == NULL)
//    //{
//    //    LogInfo("\t\t\tWaitPrcb == NULL");
//    //    return false;
//    //}
//    //LogInfo("\t\t\tWaitPrcb: %p", WaitPrcb);
//
//    // _KPRCB+0x85c0 Context          : Ptr64 _CONTEXT
    CONTEXT threadContext = {};
    threadContext.ContextFlags = 0xFFFFFFFF; //00000020;
//    if (threadContext == NULL)
//    {
//        LogInfo("\t\t\tthreadContext == NULL");
//        return false;
//    }
//    LogInfo("\t\t\tthreadContext->Rip: %p", (PVOID)threadContext->Rip);

    KPROCESSOR_MODE PreviousMode = ExGetPreviousMode();
    pPsGetContextThread(threadObject, &threadContext, PreviousMode);
    LogInfo("\t\t\tthreadContext->Rax: %p", (PVOID)threadContext.R9);
    return true;
}

/// <summary>
/// Unwinds and walks the thread's stack.  Can't scan threads that aren't in Waiting state.
/// </summary>
/// <param name="threadObject">thread being examined</param>
/// <param name="context"></param>
/// <param name="stackwalkBuffer">rip/rsp entries from the stack being walked</param>
/// <returns>1 on successful thread stack walk</returns>
BOOLEAN Utility::StackwalkThread(_In_ PETHREAD threadObject, _Out_ CONTEXT* context, _Out_ STACKWALK_BUFFER* stackwalkBuffer)
{
    UINT64* stackBuffer;
    size_t copiedSize;
    UINT64 startRip;
    UINT64 rip;
    UINT64 rsp;
    PRUNTIME_FUNCTION functionTableEntry;
    UINT64 moduleBase;
    UINT64 establisherFrame;
    UINT64 handlerData;
    DWORD sectionVa;
    DWORD sectionSize;
    UINT64 textBase;
    
    if (!threadObject)
        return FAIL;
    if (!stackwalkBuffer)
        return FAIL;
    memset(context, 0, sizeof(CONTEXT));
    memset(stackwalkBuffer, 0, 0x208);
    
    stackBuffer = (UINT64*)ExAllocatePoolWithTag(NonPagedPool, STACK_BUF_SIZE, POOL_TAG);
    if (stackBuffer)
    {
        copiedSize = CopyThreadKernelStack(threadObject, stackBuffer);
#ifdef VERBOSE_LOG
        LogInfo("\t\t\tCopyThreadKernelStack() stackSize is: %llu", copiedSize);
#endif // VERBOSE_LOG
        if (copiedSize)
        {
            if (copiedSize != 0x1000 && copiedSize >= 0x48)
            {
                if (GetNtoskrnlSection(".text", &sectionVa, &sectionSize))
                {
                    textBase = (UINT64)((BYTE*)kernBase + sectionVa);
                    startRip = stackBuffer[7];
#ifdef VERBOSE_LOG
                    LogInfo("\t\t\tntos textBase is: 0x%llx", textBase);
                    LogInfo("\t\t\tntos textBase end is: 0x%llx", (UINT64)textBase + sectionVa);
#endif // VERBOSE_LOG
                    if (startRip >= textBase && startRip < (UINT64)textBase + sectionVa)
                    {
                        context->Rip = startRip;
                        context->Rsp = (DWORD64)(stackBuffer + 8);
                        for (size_t i = 0; i < 0x20; i++)
                        {
                            rip = context->Rip;
                            rsp = context->Rsp;
                            stackwalkBuffer->Entry[stackwalkBuffer->EntryCount].RipValue = rip;
                            stackwalkBuffer->Entry[stackwalkBuffer->EntryCount++].RspValue = rsp;
                            if (rip < (UINT64)MmSystemRangeStart || rsp < (UINT64)MmSystemRangeStart)
                                break;

                            functionTableEntry = pRtlLookupFunctionEntry(rip, (PDWORD64)&moduleBase, 0);
                            
                            if (!functionTableEntry)
                                break;
                            pRtlVirtualUnwind(0, moduleBase, context->Rip, functionTableEntry, context, (PVOID*)&handlerData, (PDWORD64)&establisherFrame, 0);
                            
                            if (!context->Rip)
                            {
                                stackwalkBuffer->Succeeded = 1;
                                break;
                            }
                        }
                    }
                }
                else
                {
                    LogError("\t\t\tUnable to find .text section of ntoskrnl");
                    return FAIL;
                }
            }
            else
            {
                LogInfo("\t\t\tCopyThreadKernelStack() stackSize is 0");
                return FAIL;
            }
        }
        else
        {
            LogInfo("\t\t\tCopyThreadKernelStack() returned stackSize: %llu", copiedSize);
            return FAIL;
        }
        ExFreePoolWithTag(stackBuffer, POOL_TAG);
    }
    return SUCCESS;
}

/// <summary>
/// Copies the passed thread's kernel stack into a passed buffer
/// </summary>
/// <param name="threadObject">thread to copy kernel stack of</param>
/// <param name="outStackBuffer">buffer that receives stack contents</param>
/// <returns>size that was copied</returns>
UINT32 Utility::CopyThreadKernelStack(_In_ PETHREAD threadObject, _Out_ void* outStackBuffer)
{
    UINT32 stackSize = 0;
    UINT32 threadStateOffset;
    UINT32 kernelStackOffset;
    UINT32 threadStackBaseOffset;
    UINT32 threadStackLimitOffset;
    UINT32 threadLockOffset;
    UINT64 stackBase;
    UINT64 threadStackLimit;
    bool isSystemThread;
    void** pKernelStack;
    KSPIN_LOCK* threadLock;
    KIRQL oldIrql;

    threadStateOffset = GetThreadStateOffset();    
    kernelStackOffset = GetKernelStackOffset();
    threadStackBaseOffset = GetStackBaseOffset();

#ifdef VERBOSE_LOG
    LogInfo("\t\t\tthreadStateOffset: 0x%lx", threadStateOffset);
    LogInfo("\t\t\tkernelStackOffset: 0x%lx", kernelStackOffset);
    LogInfo("\t\t\tthreadStackBaseOffset: 0x%lx", threadStackBaseOffset);
#endif // VERBOSE_LOG
    
    if (threadObject && threadStackBaseOffset)
        stackBase = *(UINT64*)(threadStackBaseOffset + (UINT64)threadObject);
    else
        stackBase = 0;

    threadStackLimitOffset = GetThreadStackLimit();
#ifdef VERBOSE_LOG
    LogInfo("\t\t\tthreadStackLimitOffset: 0x%lx", threadStackLimitOffset);
#endif // VERBOSE_LOG
    if (!threadObject)
    {
        LogError("\t\t\tCopyThreadKernelStack(): threadObject == NULL");
        return 0;
    }

    threadStackLimit = threadStackLimitOffset ? *(UINT64*)(threadStackLimitOffset + (UINT64)threadObject) : 0;
    isSystemThread = pPsIsSystemThread ? pPsIsSystemThread(threadObject) : 0;

    if (!isSystemThread
        || !outStackBuffer
        || !threadStateOffset
        || !kernelStackOffset
        || !stackBase
        || !threadStackLimit
        || KeGetCurrentIrql() > 1
        || (PKTHREAD)threadObject == KeGetCurrentThread())
    {
        LogInfo("\t\t\tCopyThreadKernelStack() aborted.  Examine checks.");
        LogInfo("\t\t\tPsIsSystemThread: %d", isSystemThread);
        return 0;
    }

    pKernelStack = (void**)((BYTE*)threadObject + kernelStackOffset);
    memset(outStackBuffer, 0, STACK_BUF_SIZE);
    if (LockThread((PKTHREAD)threadObject, &oldIrql))
    {
        PHYSICAL_ADDRESS physAddr = MmGetPhysicalAddress(*pKernelStack);
        if (!PsIsThreadTerminating(threadObject))
        {

            if (*(BYTE*)(threadStateOffset + (BYTE*)threadObject) == KTHREAD_STATE::Waiting)
            {
                //GetCurrentThreadContext(threadObject);

                if ((UINT64)*pKernelStack > threadStackLimit)
                {
                    if ((UINT64)*pKernelStack < stackBase)
                    {
                        if (physAddr.QuadPart)
                        {
                            stackSize = stackBase - (_QWORD)*pKernelStack;
                            if (stackSize > STACK_BUF_SIZE)
                                stackSize = STACK_BUF_SIZE;
                            memmove(outStackBuffer, *pKernelStack, stackSize);
                        }
                        else
                        {
                            LogInfo("\t\t\tCopyThreadKernelStack() aborted.  !physAddr.QuadPart");

                        }
                    }
                    else
                    {
                        LogInfo("\t\t\tCopyThreadKernelStack() aborted.  *pKernelStack >= stackBase");
                    }
                }
                else
                {
                    LogInfo("\t\t\tCopyThreadKernelStack() aborted.  *pKernelStack >= stackBase");
                }

            }
            else
            {
                LogInfo("\t\t\tCopyThreadKernelStack() aborted.  *(BYTE*)(threadStateOffset + (BYTE*)threadObject) != 5(Waiting state)");
                LogInfo("\t\t\tThread State is: %hhu", *(BYTE*)(threadStateOffset + (BYTE*)threadObject));
            }
        }
        else
        {
            LogInfo("\t\t\tCopyThreadKernelStack() aborted.  PsIsThreadTerminating(threadObject) == true");
        }

        if (SharedUserData->NtMajorVersion >= 6 && SharedUserData->NtMajorVersion != 6 || !SharedUserData->NtMinorVersion)  //  https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi_x/kuser_shared_data/index.htm
        {
            threadLockOffset = GetThreadLockOffset();
#ifdef VERBOSE_LOG
            LogInfo("\t\t\tthreadLockOffset: 0x%lx", threadLockOffset);
#endif // VERBOSE_LOG
            threadLock = (KSPIN_LOCK*)((BYTE*)threadObject + threadLockOffset);

            if (threadLockOffset)
            {
                if (threadLock != 0)
                {
                    KeReleaseSpinLockFromDpcLevel(threadLock);
                    __writecr8(oldIrql);
                }
            }
        }
        else
        {
            KeReleaseQueuedSpinLock(0, oldIrql);
        }
    }
    else
    {
        LogError("\t\t\tCopyThreadKernelStack(), LockThread() failed.  Examine.");
    }
    return stackSize;
}

/// <summary>
/// Acquires a spinlock from a thread.
/// </summary>
/// <param name="Thread">the thread we are acquiring a spinlock from</param>
/// <param name="Irql">old irql</param>
/// <returns>returns true when acquiring thread spinlock</returns>
_Success_(return) BOOL Utility::LockThread(_In_ PKTHREAD Thread, _Out_ KIRQL * Irql)
{
    KIRQL currentIrql;
    UINT64 ThreadLockOffset;
    KSPIN_LOCK* threadLock;

    if (Thread && Irql)
    {
        if (SharedUserData->NtMajorVersion >= 6 && (SharedUserData->NtMajorVersion != 6 || SharedUserData->NtMinorVersion))
        {
            ThreadLockOffset = GetThreadLockOffset();
            threadLock = (PKSPIN_LOCK)((BYTE*)Thread + ThreadLockOffset);
            if (threadLock && ThreadLockOffset)
            {
                currentIrql = KeGetCurrentIrql();
#ifdef VERBOSE_LOG
                LogInfo("\t\t\tCurrent IRQL: %d", currentIrql);
#endif // VERBOSE_LOG
                // set cr8[3:0] (interrupt mask)
                __writecr8(0xC);
                *Irql = currentIrql;
                currentIrql = KeGetCurrentIrql();
#ifdef VERBOSE_LOG
                LogInfo("\t\t\tCurrent IRQL after __writecr8(0xC): %hhu", currentIrql);
#endif
#ifdef VERBOSE_LOG
                LogInfo("\t\t\tThread State before KeAcquireSpinLockAtDpcLevel: %hhu", *((BYTE*)Thread + gkThreadStateOffset));
#endif
                KeAcquireSpinLockAtDpcLevel(threadLock);
#ifdef VERBOSE_LOG
                LogInfo("\t\t\tThread State after KeAcquireSpinLockAtDpcLevel: %hhu", *((BYTE*)Thread + gkThreadStateOffset));
#endif

                currentIrql = KeGetCurrentIrql();
#ifdef VERBOSE_LOG
                LogInfo("\t\t\tCurrent IRQL after KeAcquireSpinLockAtDpcLevel: %hhu", currentIrql);
#endif
                return SUCCESS;
            }
            else
            {
                return FAIL;
            }
        }
        else
        {
            LogInfo("\t\t\tUsing pKeAcquireQueuedSpinLockRaiseToSynch");
            *Irql = pKeAcquireQueuedSpinLockRaiseToSynch(0);
            return SUCCESS;
        }
    }
    else
    {
        return FAIL;
    }
}

/// <summary>
/// Get offset of Tcb.StackLimit from ETHREAD
/// </summary>
/// <returns>offset on success</returns>
UINT32 Utility::GetThreadStackLimit()
{
    PETHREAD thisThread;
    UINT64 currThreadStackLimit;
    UINT64* currThreadAddr;
    USHORT maxOffset = 0x2F8;

    if (SpinLock(&gSpinLock6) == 259)
    {
        thisThread = (PETHREAD)__readgsqword(0x188);
        currThreadStackLimit = (UINT64)pPsGetCurrentThreadStackLimit();
        currThreadAddr = (UINT64*)thisThread;
        if ((UINT64)thisThread < ((UINT64)thisThread + maxOffset))
        {
            while (*currThreadAddr != currThreadStackLimit)
            {
                if ((UINT64)++currThreadAddr >= ((UINT64)thisThread + maxOffset))
                {
                    _InterlockedExchange64(&gSpinLock6, 2);
                    return gThreadStackLimit;
                }
            }
            gThreadStackLimit = (UINT64)currThreadAddr - (UINT64)thisThread;
        }
    }
    _InterlockedExchange64(&gSpinLock6, 2);
    return gThreadStackLimit;
}

/// <summary>
/// Get offset of Tcb.KernelStack from ETHREAD
/// </summary>
/// <returns>offset on success</returns>
UINT32 Utility::GetKernelStackOffset()
{
    PETHREAD thisThread;
    UINT32 initialStackOffset;
    UINT32 stackBaseOffset;
    UINT64 stackLimit;
    UINT64 stackLimitOffset;
    UINT64* currThreadAddr;
    _LARGE_INTEGER interval;
    UINT64 stackBase;
    USHORT maxOffset = 0x2F8;

    thisThread = (PETHREAD)__readgsqword(0x188);
    initialStackOffset = GetInitialStackOffset();

    stackBaseOffset = GetStackBaseOffset();
    
    if (thisThread)
    {
        if (stackBaseOffset)
            stackBase = *((UINT64*)(stackBaseOffset + (UINT64)thisThread));
        else
            stackBase = 0;

        stackLimitOffset = GetThreadStackLimit();
        
        if (stackLimitOffset)
            stackLimit = *(UINT64*)(stackLimitOffset + (PBYTE)thisThread);
        else
            stackLimit = 0;
    }
    else
    {
        GetThreadStackLimit();
        stackLimit = 0;
        stackBase = 0;
    }
    
    if (KeGetCurrentIrql() > APC_LEVEL)
        return 0;

    if (SpinLock(&gSpinLock4) == 259)
    {
        if (initialStackOffset && stackLimit && stackBase)
        {
            interval.QuadPart = 0;
            if (KeDelayExecutionThread(KernelMode, FALSE, &interval))
            {
                // 1 second delay
                interval.QuadPart = -10000;
                KeDelayExecutionThread(KernelMode, FALSE, &interval);
            }
            currThreadAddr = (UINT64*)thisThread;
            while ((UINT64)currThreadAddr < ((UINT64)thisThread + maxOffset))
            {
                if (((UINT64)currThreadAddr - (UINT64)thisThread) != initialStackOffset)
                {
                    if (*currThreadAddr < stackBase && *currThreadAddr > stackLimit)
                    {
                        gKernelStackOffset = (UINT64)currThreadAddr - (UINT64)thisThread;
                        break;
                    }
                }
                ++currThreadAddr;
            }
        }
        _InterlockedExchange64(&gSpinLock4, 2);
    }
    return gKernelStackOffset;
}

/// <summary>
/// Get offset of Tcb.InitialStack from ETHREAD
/// </summary>
/// <returns>offset on success</returns>
UINT32 Utility::GetInitialStackOffset()
{
    PETHREAD thisThread;
    UINT64 initialStack;
    UINT64* currThreadAddr;
    USHORT maxOffset = 0x2F8;

    if (SpinLock(&gSpinLock2) == 259)
    {
        thisThread = (PETHREAD)__readgsqword(0x188);
        initialStack = (UINT64)IoGetInitialStack();
        currThreadAddr = (UINT64*)thisThread;
        
        while (*currThreadAddr != initialStack)
        {
            if ((UINT64)++currThreadAddr >= (UINT64)thisThread + maxOffset)
            {
                _InterlockedExchange64(&gSpinLock2, 2);
                return FAIL;
            }
        }
        gInitialStackOffset = (UINT64)currThreadAddr - (UINT64)thisThread;
    }
    _InterlockedExchange64(&gSpinLock2, 2);
    return gInitialStackOffset;
}

/// <summary>
/// Get offset of Tcb.StackBase from ETHREAD
/// </summary>
/// <returns>offset on success</returns>
UINT32 Utility::GetStackBaseOffset()
{
    PETHREAD kThread;
    PVOID stackBase;
    UINT64* kThreadStackBaseAddr;

    if (SpinLock(&gSpinLock5) == 259)
    {
        kThread = (PETHREAD)__readgsqword(0x188);
        stackBase = pPsGetCurrentThreadStackBase();
        kThreadStackBaseAddr = (UINT64*)kThread;
        
        while (*kThreadStackBaseAddr != (UINT64)stackBase)
        {
            if ((UINT64)++kThreadStackBaseAddr >= (UINT64)kThread + 0x2F8)
            {
                LogInfo("\t\t\tUnable to find Stack Base Offset.");
                _InterlockedExchange64(&gSpinLock5, 2);
                return FAIL;
            }
        }
        gStackBaseOffset = (UINT64)kThreadStackBaseAddr - (UINT64)kThread;
    }
    _InterlockedExchange64(&gSpinLock5, 2);
    return gStackBaseOffset;
}

/// <summary>
/// Get the thread lock offset
/// </summary>
/// <returns>byte offset of thread lock from base of ETHREAD</returns>
UINT32 Utility::GetThreadLockOffset()
{
    BYTE* threadLockOffset = NULL;

    if (SpinLock(&gSpinLock1) == 259)
    {
        if ((UINT64)KeSetPriorityThread)
        {
            if (threadLockPatternMatch((BYTE*)KeSetPriorityThread, &threadLockOffset, 0xF1))
            {
                LogInfo("\t\t\tthreadLockPatternMatch() found a match at %p with offset value %lu", threadLockOffset, *threadLockOffset);
                gThreadLockOffset = (unsigned __int8)*threadLockOffset;
            }
            else
            {
                LogInfo("\t\t\tthreadLockPatternMatch() failed to find a match");
                gThreadLockOffset = 0;
            }
        }
        _InterlockedExchange64(&gSpinLock1, 2);
    }
    return gThreadLockOffset;
}

/// <summary>
/// Get the thread state offset
/// </summary>
/// <returns>byte offset of thread state from base of ETHREAD</returns>
UINT32 Utility::GetThreadStateOffset()
{
    UINT32* threadStateOffset = NULL;

    if (SpinLock(&gSpinLock3) == 259)
    {
        if (IsWindows7())
        {
            gkThreadStateOffset = 0x164;
        }
        else
        {
            if (pKeAlertThread)
            {
                if (threadStatePatternMatch((BYTE*)pKeAlertThread, &threadStateOffset, 0x132))
                {
                    LogInfo("\t\t\tthreadStatePatternMatch() found a match at %p with offset value %lu", threadStateOffset, *threadStateOffset);
                    gkThreadStateOffset = *threadStateOffset;
                }
                else
                {
                    LogError("\t\t\tthreadStatePatternMatch() failed to find a match");
                    return gkThreadStateOffset;
                }
            }
        }
        if (gkThreadStateOffset)
        {
            auto kThreadState = *((BYTE*)__readgsqword(0x188) + gkThreadStateOffset);

            if (kThreadState != KTHREAD_STATE::Running)
            {
                LogError("\t\t\tGetThreadState(), thread state offset check failure.");
                gkThreadStateOffset = 0;
            }
        }
        _InterlockedExchange64(&gSpinLock3, 2);
    }
    return gkThreadStateOffset;
}

/// <summary>
/// Only tested on 2104 (21H1)
/// </summary>
/// <param name="address">start address</param>
/// <param name="outOffset">if successful, initialized with offset</param>
/// <param name="range">length to scan</param>
/// <returns>1 on success</returns>
BOOLEAN Utility::threadLockPatternMatch(_In_ BYTE* address, _Inout_ UINT8** outOffset, _In_ UINT32 range)
{
    for (UINT8* currByte = address; currByte < (address + range); currByte++)
    {
        if (currByte[0] == threadLockPattern[0]
            && currByte[1] == threadLockPattern[1]
            && currByte[2] == threadLockPattern[2]
            && currByte[3] == threadLockPattern[3]
            && currByte[4] == threadLockPattern[4]
            && currByte[6] == threadLockPattern[6]
            && currByte[7] == threadLockPattern[7])
        {
            *outOffset = currByte + 5;
            return SUCCESS;
        }
    }
    return FAIL;
}

/// <summary>
/// Only tested on 2104 (21H1)
/// </summary>
/// <param name="address">start address</param>
/// <param name="outOffset">if successful, initialized with offset</param>
/// <param name="range">length to scan</param>
/// <returns>1 on success</returns>
BOOLEAN Utility::threadStatePatternMatch(_In_ BYTE* address, _Inout_ UINT32** outOffset, _In_ UINT32 range)
{
    for (BYTE* currByte = address; currByte < (address + range); currByte++)
    {
        if (currByte[0] == threadStatePattern[0]
            && currByte[1] == threadStatePattern[1]
            && currByte[6] == threadStatePattern[6]
            && currByte[7] == threadStatePattern[7])
        {
            *outOffset = (UINT32*)((BYTE*)currByte + 2);
            return SUCCESS;
        }
    }
    return FAIL;
}

/// <summary>
/// Queries start address of the thread using NtQueryInformationThread.
/// </summary>
/// <param name="threadObject"></param>
/// <param name="pStartAddr"></param>
/// <returns></returns>
NTSTATUS Utility::GetThreadStartAddr(_In_ PETHREAD threadObject, _Out_ uintptr_t* pStartAddr)
{
    *pStartAddr = NULL;
    HANDLE hThread;
    NTSTATUS status;

    if (!NT_SUCCESS(status = ObOpenObjectByPointer(threadObject, OBJ_KERNEL_HANDLE, nullptr, GENERIC_READ, *PsThreadType, KernelMode, &hThread))) {
        LogError("ObOpenObjectByPointer failed.\n");
        return status;
    }

    uintptr_t startAddr = NULL;
    ULONG returnedBytes;
    
    if (!NT_SUCCESS(status = pNtQueryInformationThread(hThread, ThreadQuerySetWin32StartAddress, &startAddr, sizeof(startAddr), &returnedBytes))) {
        LogError("NtQueryInformationThread failed.\n");
        NtClose(hThread);
        return status;
    }

    if (MmIsAddressValid((void*)startAddr)) {
        *pStartAddr = startAddr;
    }
    else
    {
        LogError("\t\tThread entry point not paged in: 0x%p (not a detection)\n", (uintptr_t*)startAddr);
        return STATUS_UNSUCCESSFUL;
    }
    NtClose(hThread);
    return STATUS_SUCCESS;
}

```

`NomadDriver/Utility.cpp`:

```cpp
#pragma once
#include "Utility.h"
#include "Driver.h"

Utility::Utility(PDRIVER_OBJECT DriverObject)
{
    if (!NT_SUCCESS(InitUtils(DriverObject)))
    {
        LogError("Failed to init Utilities\n");
    }
    else
    {
        LogInfo("Utilities initialized\n");
    }
}

Utility::~Utility()
{
    LogInfo("Deconstructing utilities...\n");

    if (outProcMods)
    {
        ExFreePool(outProcMods);
    }
}

NTSTATUS Utility::InitUtils(_In_ PDRIVER_OBJECT DriverObject)
{
    NTSTATUS status;

    kernBase = Utility::GetKernelBaseAddr(DriverObject);
    if (!kernBase)
    {
        LogError("Unable to get kernel base. Aborting init\n");
        return STATUS_UNSUCCESSFUL;
    }

    LogInfo("Frostiest method:  Found ntoskrnl.exe base @ 0x%p\n", kernBase);

    // On 21H1, this method doesn't work.  Issue is that there are multiple PE Headers between the true PE Header of ntoskrnl and from where the IDT entry points to.
    //kernBase = GetNtoskrnlBaseAddress();

    //LogInfo("Barakat method: Found ntoskrnl.exe base @ 0x%p\n", kernBase);

    status = FindExport((uintptr_t)kernBase, "MmGetSystemRoutineAddress", (uintptr_t*)&pMmSysRoutine);

    if (!NT_SUCCESS(status))
    {
        LogError("Unable to import core Nt function MmGetSystemRoutineAddress. Aborting init\n");
        return STATUS_UNSUCCESSFUL;
    }

    LogInfo("Parsed export MmGetSystemRoutineAddress: %p\n", pMmSysRoutine);

    status = ImportNtPrimitives();
    if (!NT_SUCCESS(status))
    {
        LogError("Unable to Nt* primitives via MmGetSystemRoutineAddress. Aborting init\n");
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}
/// <summary>
/// Uses a pointer to ZwQuerySystemInformation to enumerate all loaded modules
/// </summary>
/// <returns></returns>
NTSTATUS Utility::EnumKernelModuleInfo(_In_opt_ PRTL_PROCESS_MODULES* procMods)
{
    ULONG size = NULL;

    NTSTATUS status = pZwQuerySysInfo(SYS_MOD_INF, 0, 0, &size);
    if (STATUS_INFO_LENGTH_MISMATCH == status) {
        LogInfo("ZwQuerySystemInformation data struct size retrieved");
    }
    else
    {
        LogError("ZwQuerySystemInformation, status: %08x", status);
        return status;
    }

    if (outProcMods)
    {
        ExFreePool(outProcMods);
        outProcMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, size, POOL_TAG);
    }
    else
    {
        outProcMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, size, POOL_TAG);
    }
        
    if (!outProcMods) {
        LogError("Insufficient memory in the free pool to satisfy the request");
        return STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(status = pZwQuerySysInfo(SYS_MOD_INF, outProcMods, size, 0))) {
        LogError("ZwQuerySystemInformation failed");
        ExFreePoolWithTag(outProcMods, POOL_TAG);
        outProcMods = NULL;
        return status;
    }

    //auto whatIsthisAddr = *(long long*)((int*)outProcMods + 6);
    //LogInfo("whatIsthisAddr: %016X", outProcMods->Modules->);
    //LogInfo("whatIsthisAddr: %x", whatIsthisAddr);

    if (procMods != NULL)
    {
        *procMods = outProcMods;
    }

#ifdef VERBOSE_LOG
    LogInfo("\tModules->NumberOfModules = %lu\n", outProcMods->NumberOfModules);
    for (ULONG i = 0; i < outProcMods->NumberOfModules; i++)
    {
        LogInfo("\tModule[%d].FullPathName: %s\n", (int)i, (char*)outProcMods->Modules[i].FullPathName);
        LogInfo("\tModule[%d].ImageBase: %p\n", (int)i, (char*)outProcMods->Modules[i].ImageBase);
        LogInfo("\tModule[%d].MappedBase: %p\n", (int)i, (char*)outProcMods->Modules[i].MappedBase);
        LogInfo("\tModule[%d].LoadCount: %p\n", (int)i, (char*)outProcMods->Modules[i].LoadCount);
        LogInfo("\tModule[%d].ImageSize: %p\n", (int)i, (char*)outProcMods->Modules[i].ImageSize);
    }
    LogInfo("EnumKernelModuleInfo() complete\n");
#endif // VERBOSE_LOG

    return STATUS_SUCCESS;
}

/// <summary>
/// Dynamic importing via a documented method
/// </summary>
/// <param name="pNtPrimitives"></param>
/// <param name="names"></param>
/// <returns></returns>
NTSTATUS Utility::ImportNtPrimitives()
{
    LogInfo("Importing windows primitives\n");
    const wchar_t* names[WINAPI_IMPORT_COUNT] = { L"ZwQuerySystemInformation",    L"PsGetCurrentProcessId",       L"PsIsSystemThread",             L"PsGetCurrentProcess", 
                                            L"IoThreadToProcess",           L"PsGetProcessId",              L"RtlVirtualUnwind",             L"RtlLookupFunctionEntry", 
                                            L"KeAlertThread",               L"PsGetCurrentThreadStackBase", L"PsGetCurrentThreadStackLimit", L"KeAcquireQueuedSpinLockRaiseToSynch", 
                                            L"KeReleaseQueuedSpinLock",     L"PsLookupThreadByThreadId",    L"NtQueryInformationThread",     L"PsGetContextThread"};
    UNICODE_STRING uniNames[WINAPI_IMPORT_COUNT];

    for (size_t i = 0; i < WINAPI_IMPORT_COUNT; i++)
    {
        RtlInitUnicodeString(&uniNames[i], names[i]);
    }

    CHAR ansiImportName[MAX_NAME_LEN];

    for (size_t i = 0; i < WINAPI_IMPORT_COUNT; i++)
    {
        pNtPrimitives[i] = (GenericFuncPtr)pMmSysRoutine(&uniNames[i]);
        if (pNtPrimitives[i] == NULL)
        {
            LogError("Failed to import %s\n", (unsigned char*)ansiImportName);
            mImportFail = true;
            return STATUS_UNSUCCESSFUL;
        }
        else
        {
            LogInfo("Succesfully imported %ls at %p\n", uniNames[i].Buffer, pNtPrimitives[i]);
        }
    }

    pZwQuerySysInfo = (ZwQuerySysInfoPtr)pNtPrimitives[_ZwQuerySystemInformationIDX];
    pPsGetCurrentProcessId = (PsGetCurrentProcessIdPtr)pNtPrimitives[_PsGetCurrentProcessIdIDX];
    pPsIsSystemThread = (PsIsSystemThreadPtr)pNtPrimitives[_PsIsSystemThreadIDX];
    pPsGetCurrentProcess = (PsGetCurrentProcessPtr)pNtPrimitives[_PsGetCurrentProcessIDX];
    pIoThreadToProcess = (IoThreadToProcessPtr)pNtPrimitives[_IoThreadToProcessIDX];
    pPsGetProcessId = (PsGetProcessIdPtr)pNtPrimitives[_PsGetProcessIdIDX];
    pRtlVirtualUnwind = (RtlVirtualUnwindPtr)pNtPrimitives[_RtlVirtualUnwindIDX];
    pRtlLookupFunctionEntry = (RtlLookupFunctionEntryPtr)pNtPrimitives[_RtlLookupFunctionEntryIDX];
    pKeAlertThread = (KeAlertThreadPtr)pNtPrimitives[_KeAlertThreadIDX];
    pPsGetCurrentThreadStackBase = (PsGetCurrentThreadStackBasePtr)pNtPrimitives[_PsGetCurrentThreadStackBaseIDX];
    pPsGetCurrentThreadStackLimit = (PsGetCurrentThreadStackLimitPtr)pNtPrimitives[_PsGetCurrentThreadStackLimitIDX];
    pKeAcquireQueuedSpinLockRaiseToSynch = (KeAcquireQueuedSpinLockRaiseToSynchPtr)pNtPrimitives[_KeAcquireQueuedSpinLockRaiseToSynchIDX];
    pKeReleaseQueuedSpinLock = (KeReleaseQueuedSpinLockPtr)pNtPrimitives[_KeReleaseQueuedSpinLockIDX];
    pPsLookupThreadByThreadId = (PsLookupThreadByThreadIdPtr)pNtPrimitives[_PsLookupThreadByThreadIdIDX];
    pNtQueryInformationThread = (NtQueryInformationThreadPtr)pNtPrimitives[_NtQueryInformationThreadIDX];
    pPsGetContextThread = (PsGetContextThreadPtr)pNtPrimitives[_PsGetContextThreadIDX];
    return STATUS_SUCCESS;
}

bool Utility::IsValidPEHeader(_In_ const uintptr_t pHead)
{
    if (!MmIsAddressValid((PVOID)pHead))
    {
#ifdef VERBOSE_LOG
        LogError("Was unable to read page @ 0x%p", (PVOID)pHead);
#endif
        return false;
    }

    if (!pHead)
    {
        LogInfo("pHead is null @ 0x%p", (PVOID)pHead);
        return false;
    }

    if (reinterpret_cast<PIMAGE_DOS_HEADER>(pHead)->e_magic != E_MAGIC)
    {
        //LogInfo("pHead is != 0x%02x @ %p", E_MAGIC, (PVOID)pHead);
        return false;
    }

    const auto ntHeader = reinterpret_cast<PIMAGE_NT_HEADERS64>(pHead + reinterpret_cast<PIMAGE_DOS_HEADER>(pHead)->e_lfanew);

    // avoid reading a page not paged in
    if (reinterpret_cast<PIMAGE_DOS_HEADER>(pHead)->e_lfanew > 0x1000)
    {
        LogInfo("pHead->e_lfanew > 0x1000 , doesn't seem valid @ 0x%p", (PVOID)pHead);
        return false;
    }

    if (ntHeader->Signature != NT_HDR_SIG)
    {
        LogInfo("ntHeader->Signature != 0x%02x @ 0x%p", NT_HDR_SIG, (PVOID)pHead);
        return false;
    }

    LogInfo("Found valid PE header @ 0x%p", (PVOID)pHead);
    return true;
}

BOOLEAN Utility::IsWindows7()
{
    return SharedUserData->NtMajorVersion == 6 && SharedUserData->NtMinorVersion == 1;
}

// @ weak1337
// https://github.com/weak1337/EvCommunication/blob/cab42dda45a5feb9d2c62f8685d00b0d39fb783e/Driver/Driver/nt.cpp
NTSTATUS Utility::FindExport(_In_ const uintptr_t imageBase, _In_ const char* exportName, _Out_ uintptr_t* functionPointer)
{
    if (!imageBase)
        return STATUS_INVALID_PARAMETER_1;

    const auto ntHeader = reinterpret_cast<PIMAGE_NT_HEADERS64>(imageBase + reinterpret_cast<PIMAGE_DOS_HEADER>(imageBase)->e_lfanew);
    const auto exportDirectory = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(imageBase + ntHeader->OptionalHeader.DataDirectory[0].VirtualAddress);

    if (!exportDirectory)
        return STATUS_INVALID_IMAGE_FORMAT;

    const auto exportedFunctions = reinterpret_cast<DWORD*>(imageBase + exportDirectory->AddressOfFunctions);
    const auto exportedNames = reinterpret_cast<DWORD*>(imageBase + exportDirectory->AddressOfNames);
    const auto exportedNameOrdinals = reinterpret_cast<UINT16*>(imageBase + exportDirectory->AddressOfNameOrdinals);

    for (size_t i{}; i < exportDirectory->NumberOfNames; ++i) {
        const auto functionName = reinterpret_cast<const char*>(imageBase + exportedNames[i]);
        if (!strcmp(exportName, functionName)) {
            *functionPointer = imageBase + exportedFunctions[exportedNameOrdinals[i]];
            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}

__forceinline wchar_t Utility::locase_w(_In_ wchar_t c)
{
    if ((c >= 'A') && (c <= 'Z'))
        return c + 0x20;
    else
        return c;
}

int Utility::strcmpi_w(_In_ const wchar_t* s1, _In_ const wchar_t* s2)
{
    wchar_t c1, c2;

    if (s1 == s2)
        return 0;

    if (s1 == 0)
        return -1;

    if (s2 == 0)
        return 1;

    do {
        c1 = locase_w(*s1);
        c2 = locase_w(*s2);
        s1++;
        s2++;
    } while ((c1 != 0) && (c1 == c2));

    return (int)(c1 - c2);
}

// @Frostiest
// https://www.unknowncheats.me/forum/general-programming-and-reversing/427419-getkernelbase.html

/// <summary>
/// Finds the kernel's base through our driver object (credits @Frostiest)
/// </summary>
/// <param name="DriverObject">our driver obj</param>
/// <returns>ntoskrnl's base addr on success</returns>
PVOID Utility::GetKernelBaseAddr(_In_ PDRIVER_OBJECT DriverObject)
{
    PLDR_DATA_TABLE_ENTRY entry = (PLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;
    PLDR_DATA_TABLE_ENTRY first = entry;

    while ((PLDR_DATA_TABLE_ENTRY)entry->InLoadOrderLinks.Flink != first)
    {
        if (strcmpi_w(entry->BaseDllName.Buffer, L"ntoskrnl.exe") == 0)
            return entry->DllBase;
        entry = (PLDR_DATA_TABLE_ENTRY)entry->InLoadOrderLinks.Flink;
    }
    return NULL;
}

// @ Barakat , GS Register, reverse page walk until MZ header of ntos
// https://gist.github.com/Barakat/34e9924217ed81fd78c9c92d746ec9c6
// Lands above nt module, but can page fault! Tweak to check PTE's instead of using MmIsAddressValid.  Refer to:  https://www.unknowncheats.me/forum/anti-cheat-bypass/437451-whats-proper-write-read-physical-memory.html
// NOTE: not working on 21H1.  Multiple PE Headers exist before true nt header is reached.  could tweak though.
PVOID Utility::GetNtoskrnlBaseAddress()
{
#pragma pack(push, 1)
    typedef struct
    {
        UCHAR Padding[4];
        PVOID InterruptServiceRoutine;
    } IDT_ENTRY;
#pragma pack(pop)

    // Find the address of IdtBase using gs register.
    const auto idt_base = reinterpret_cast<IDT_ENTRY*>(__readgsqword(0x38));

    // Find the address of the first (or any) interrupt service routine.
    const auto first_isr_address = idt_base[0].InterruptServiceRoutine;

    // Align the address on page boundary.
    auto pageInNtoskrnl = reinterpret_cast<uintptr_t>(first_isr_address) & ~static_cast<uintptr_t>(0xfff);

    // Traverse pages backward until we find the PE signature (MZ) of ntoskrnl.exe in the beginning of some page.
    Log("Current IRQL: %d", (int)KeGetCurrentIrql());
    while (!IsValidPEHeader(pageInNtoskrnl))
    {
        pageInNtoskrnl -= 0x1000;
    }

    // Now we have the base address of ntoskrnl.exe
    return reinterpret_cast<void*>(pageInNtoskrnl);
}

/// <summary>
/// Wrapper for ZwQuerySystemInformation
/// </summary>
/// <param name="infoClass">type of query</param>
/// <param name="dataBuf">query data buffer</param>
/// <returns>NTSTATUS success on success</returns>
NTSTATUS Utility::QuerySystemInformation(_In_ ULONG infoClass, _Inout_ PVOID* dataBuf) /*, 0x100000, 0x2000000) <- ?? */
{
    if (!dataBuf)
    {
        LogError("QuerySystemInformation(), dataBuf == NULL");
        return STATUS_UNSUCCESSFUL;
    }

    if (infoClass == SystemBigPoolInformation)
    {
        // https://github.com/ApexLegendsUC/anti-cheat-emulator/blob/9e53bb4a329e0286ff4f237c5ded149d53b0dd56/Source.cpp#L428
        ULONG len = 4 * 1024 * 1024;
        ULONG attemptedSize = 0;
        *dataBuf = ExAllocatePoolWithTag(NonPagedPool, len, POOL_TAG);

        if (!*dataBuf) {
            LogError("\tInsufficient memory in the free pool to satisfy the request");
            return STATUS_UNSUCCESSFUL;
        }

        if (!NT_SUCCESS(pZwQuerySysInfo(infoClass, *dataBuf, len, &attemptedSize)))
        {
            LogError("\tZwQuerySystemInformation failed for SystemBigPoolInformation. *dataBuf: %p , len: %d , attemptedSize: %d", *dataBuf, len, attemptedSize);
            ExFreePoolWithTag(*dataBuf, POOL_TAG);
            return STATUS_UNSUCCESSFUL;
        }
        LogInfo("\tQuerySystemInformation() succeeded for SystemBigPoolInformation.\n");
    }
    else
    {
        ULONG size = NULL;
        NTSTATUS status = pZwQuerySysInfo(infoClass, 0, 0, &size);
        if (STATUS_INFO_LENGTH_MISMATCH == status) {
            LogInfo("\tZwQuerySystemInformation data struct size: %d", size);
        }
        else
        {
            LogError("\tZwQuerySystemInformation, status: %08x", status);
            return status;
        }

        *dataBuf = ExAllocatePoolWithTag(NonPagedPool, size, POOL_TAG);

        if (!*dataBuf) {
            LogError("\tInsufficient memory in the free pool to satisfy the request");
            return STATUS_UNSUCCESSFUL;
        }

        ULONG attemptedSize = 0;
        if (!NT_SUCCESS(status = pZwQuerySysInfo(infoClass, *dataBuf, size, &attemptedSize))) {
            LogError("\tZwQuerySystemInformation failed. *dataBuf: %p , size: %d , attemptedSize: %d", *dataBuf, size, attemptedSize);
            ExFreePoolWithTag(*dataBuf, POOL_TAG);
            outProcMods = NULL;
            return status;
        }
        LogInfo("\tQuerySystemInformation() succeeded for infoClass: %lu\n", infoClass);
    }

    
    return STATUS_SUCCESS;
}

/// <summary>
/// Checks if given address is within any module reported from ZwQueryInfo
/// </summary>
/// <param name="address">address to check</param>
/// <param name="procMods">unused, using global for now</param>
/// <returns></returns>
BOOLEAN Utility::CheckModulesForAddress(_In_ UINT64 address, _In_ PRTL_PROCESS_MODULES procMods)
{
    if (address < (UINT64)MmSystemRangeStart)
    {
        LogInfo("Address is not in system range: %p", (PVOID)address);
        return SUCCESS;
    }

    UNREFERENCED_PARAMETER(procMods);
    RTL_PROCESS_MODULE_INFORMATION sysMod;
    for (size_t i = 0; i < outProcMods->NumberOfModules; i++)
    {
        sysMod = outProcMods->Modules[i];

        if ((UINT64)sysMod.ImageBase <= address && address <= ((UINT64)sysMod.ImageBase + sysMod.ImageSize))
        {
#ifdef VERBOSE_LOG
            LogInfo("\t\t\tAddress %p is within system module:  sysMod.ImageBase: 0x%p , sysMod.MaxAddr: 0x%llx", (VOID*)address, sysMod.ImageBase, ((UINT64)sysMod.ImageBase + sysMod.ImageSize));
#endif // VERBOSE_LOG
            return SUCCESS;
        }
    }
    LogInfo("\t\t\t[SUSPICIOUS] Address NOT within system module: 0x%p", (VOID*)address);
    return FAIL;
}

/// <summary>
/// Locates a given section in ntoskrnl
/// </summary>
/// <param name="sectionName">section to locate</param>
/// <param name="sectionVa">RVA from section base</param>
/// <param name="sectionSize">Virtual size</param>
/// <returns>1 on success</returns>
_Success_(return) BOOLEAN Utility::GetNtoskrnlSection(_In_ const char* sectionName, _Out_ DWORD* sectionVa, _Out_ DWORD* sectionSize)
{
    if (!kernBase)
    {
        kernBase = GetNtoskrnlBaseAddress();
    }
    
    if (reinterpret_cast<PIMAGE_DOS_HEADER>(kernBase)->e_magic != E_MAGIC)
    {
        LogInfo("\t\t\tGetNtoskrnlSection() expected MZ header != 0x%02x @ %p", E_MAGIC, kernBase);
        return FAIL;
    }

    const auto ntHeader = reinterpret_cast<PIMAGE_NT_HEADERS64>((BYTE*)kernBase + reinterpret_cast<PIMAGE_DOS_HEADER>(kernBase)->e_lfanew);

    // avoid reading a page not paged in
    if (reinterpret_cast<PIMAGE_DOS_HEADER>(kernBase)->e_lfanew > 0x1000)
    {
        LogInfo("\t\t\tGetNtoskrnlSection() pHead->e_lfanew > 0x1000 , doesn't seem valid @ 0x%p", kernBase);
        return FAIL;
    }

    if (ntHeader->Signature != NT_HDR_SIG)
    {
        LogInfo("\t\t\tGetNtoskrnlSection() ntHeader->Signature != 0x%02x @ 0x%p", NT_HDR_SIG, kernBase);
        return FAIL;
    }

    auto ntSection = reinterpret_cast<PIMAGE_SECTION_HEADER>((BYTE*)ntHeader + sizeof(IMAGE_NT_HEADERS64));

    for (size_t i = 0; i < ntHeader->FileHeader.NumberOfSections; i++)
    {
        char* ret = strstr((char*)ntSection[i].Name, sectionName);
        
        if (ret)
        {
            *sectionVa = ntSection[i].VirtualAddress;
            *sectionSize = ntSection[i].Misc.VirtualSize;
#ifdef VERBOSE_LOG
            LogInfo("\t\t\tfound %s in ntoskrnl.exe at VA offset 0x%08x , size %lu", sectionName, (VOID*)*sectionVa, (ULONG)*sectionSize);
#endif
            return SUCCESS;
        }
    }
    LogInfo("\t\t\tfailed to find %s in ntoskrnl.exe", sectionName);
    return FAIL;
}

UINT32 Utility::SpinLock(_In_ volatile signed __int64* Lock)
{
    if (*Lock != 2)
    {
        if (!_InterlockedCompareExchange64(Lock, 1, 0))
            return 259;
        while (*Lock != 2)
            _mm_pause();
    }
    return 0;
}

NTSTATUS Utility::Sleep(_In_ LONG milliseconds)
{
    LARGE_INTEGER interval;
    interval.QuadPart = -(10ll * milliseconds);

    return KeDelayExecutionThread(KernelMode, FALSE, &interval);
}

/// <summary>
/// Search for pattern https://github.com/DarthTon/Blackbone/blob/a672509b5458efeb68f65436259b96fa8cd4dcfc/src/BlackBoneDrv/Utils.c#L199
/// </summary>
/// <param name="pattern">Pattern to search for</param>
/// <param name="wildcard">Used wildcard</param>
/// <param name="len">Pattern length</param>
/// <param name="base">Base address for searching</param>
/// <param name="size">Address range to search in</param>
/// <param name="ppFound">Found location</param>
/// <returns>Status code</returns>
NTSTATUS Utility::SearchPattern(_In_ PCUCHAR pattern, _In_ UCHAR wildcard, _In_ ULONG_PTR len, _In_ const VOID* base, _In_ ULONG_PTR size, _Out_ PVOID* ppFound)
{
    ASSERT(ppFound != NULL && pattern != NULL && base != NULL);
    if (ppFound == NULL || pattern == NULL || base == NULL)
        return STATUS_INVALID_PARAMETER;

    for (ULONG_PTR i = 0; i < size - len; i++)
    {
        BOOLEAN found = TRUE;
        for (ULONG_PTR j = 0; j < len; j++)
        {
            if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])
            {
                found = FALSE;
                break;
            }
        }

        if (found != FALSE)
        {
            *ppFound = (PUCHAR)base + i;
            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}

```

`NomadDriver/Utility.h`:

```h
#pragma once
#include <ntifs.h>
#include "Driver.h"

#define POOL_TAG 0x040703A2

#define LAST_IND(x,part_type)	(sizeof(x)/sizeof(part_type) - 1)
#define HIGH_IND(x,part_type)	LAST_IND(x,part_type)
#define LOW_IND(x,part_type)	0

#pragma warning( disable : 4005 )
#define BYTEn(x, n)   (*((BYTE*)&(x)+n))

#define LOBYTE(x)  BYTEn(x,LOW_IND(x,BYTE))

#define CURRENT_KTHREAD_PTR 0x188
#define SystemBigPoolInformation 0x42
#define SystemModuleInformation 0x0B
#define STACK_BUF_SIZE 0x2000

#define WINAPI_IMPORT_COUNT 16
#define _ZwQuerySystemInformationIDX 0
#define _PsGetCurrentProcessIdIDX 1
#define _PsIsSystemThreadIDX 2
#define _PsGetCurrentProcessIDX 3
#define _IoThreadToProcessIDX 4
#define _PsGetProcessIdIDX 5
#define _RtlVirtualUnwindIDX 6
#define _RtlLookupFunctionEntryIDX 7
#define _KeAlertThreadIDX 8
#define _PsGetCurrentThreadStackBaseIDX 9
#define _PsGetCurrentThreadStackLimitIDX 10
#define _KeAcquireQueuedSpinLockRaiseToSynchIDX 11
#define _KeReleaseQueuedSpinLockIDX 12
#define _PsLookupThreadByThreadIdIDX 13
#define _NtQueryInformationThreadIDX 14
#define _PsGetContextThreadIDX 15

#define SUCCESS 1
#define FAIL 0

#define CONTEXT_AMD64   0x00100000L

// end_wx86

#define CONTEXT_CONTROL         (CONTEXT_AMD64 | 0x00000001L)
#define CONTEXT_INTEGER         (CONTEXT_AMD64 | 0x00000002L)
#define CONTEXT_SEGMENTS        (CONTEXT_AMD64 | 0x00000004L)
#define CONTEXT_FLOATING_POINT  (CONTEXT_AMD64 | 0x00000008L)
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_AMD64 | 0x00000010L)

#define CONTEXT_FULL            (CONTEXT_CONTROL | CONTEXT_INTEGER | \
                                 CONTEXT_FLOATING_POINT)

#define CONTEXT_ALL             (CONTEXT_CONTROL | CONTEXT_INTEGER | \
                                 CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | \
                                 CONTEXT_DEBUG_REGISTERS)

typedef enum _KTHREAD_STATE
{
	Initialized,
	Ready,
	Running,
	Standby,
	Terminated,
	Waiting,
	Transition,
	DeferredReady
} KTHREAD_STATE, * PKTHREAD_STATE;

typedef struct _SYSTEM_BIGPOOL_ENTRY {
	union {
		uintptr_t	VirtualAddress;
		ULONG_PTR	NonPaged : 1;
	};
	ULONG_PTR SizeInBytes;
	union {
		UCHAR Tag[4];
		ULONG TagUlong;
	};
} SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
	ULONG Count;
	SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ANYSIZE_ARRAY];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
	DWORD BeginAddress;
	DWORD EndAddress;
	union {
		DWORD UnwindInfoAddress;
		DWORD UnwindData;
	} DUMMYUNIONNAME;
} RUNTIME_FUNCTION, * PRUNTIME_FUNCTION, _IMAGE_RUNTIME_FUNCTION_ENTRY, * _PIMAGE_RUNTIME_FUNCTION_ENTRY;

typedef struct _STACKWALK_ENTRY {
	UINT64 RipValue;
	UINT64 RspValue;
} STACKWALK_ENTRY, *PSTACKWALK_ENTRY;

constexpr int entries = (STACK_BUF_SIZE - sizeof(UINT32) - sizeof(bool)) / sizeof(STACKWALK_ENTRY);

typedef struct _STACKWALK_BUFFER {
	bool			Succeeded = 0;
	UINT32			EntryCount = 0;
	STACKWALK_ENTRY Entry[entries];
} STACKWALK_BUFFER, * PSTACKWALK_BUFFER;

typedef void (*GenericFuncPtr)();
typedef NTSTATUS(*ZwQuerySysInfoPtr)(ULONG, PVOID, ULONG, PULONG);
typedef PVOID(*MmSystemRoutinePtr)(PUNICODE_STRING);
typedef HANDLE(*PsGetCurrentProcessIdPtr)();
typedef BOOLEAN(*PsIsSystemThreadPtr)(PETHREAD);
typedef PEPROCESS(*PsGetCurrentProcessPtr)();
typedef NTSTATUS(*PsLookupThreadByThreadIdPtr)(
	_In_	HANDLE		ThreadId, 
	_Out_	PETHREAD*	Thread
	);
typedef PEPROCESS(*IoThreadToProcessPtr)(_In_ PETHREAD Thread);
typedef HANDLE(*PsGetProcessIdPtr)(_In_ PEPROCESS Process);
typedef PEXCEPTION_ROUTINE(*RtlVirtualUnwindPtr)(
	_In_		DWORD				HandlerType, 
	_In_		DWORD64				ImageBase, 
	_In_		DWORD64				ControlPc, 
	_In_		PRUNTIME_FUNCTION	FunctionEntry, 
	_Inout_		PCONTEXT			ContextRecord, 
	_Out_		PVOID*				HandlerData, 
	_Out_		PDWORD64			EstablisherFrame, 
	_Inout_opt_ PVOID				ContextPointers
	);
typedef PRUNTIME_FUNCTION(*RtlLookupFunctionEntryPtr)(
	_In_	DWORD64		ControlPc,
	_Out_	PDWORD64	ImageBase, 
	_Out_	PVOID		HistoryTable
	);
typedef BOOLEAN(*KeAlertThreadPtr)(
	_In_ PKTHREAD			Thread,
	_In_ KPROCESSOR_MODE	AlertMode
	);
typedef PVOID(*PsGetCurrentThreadStackBasePtr)();
typedef PVOID(*PsGetCurrentThreadStackLimitPtr)();
typedef void(*KeReleaseQueuedSpinLockPtr)(
	_In_ KSPIN_LOCK_QUEUE_NUMBER	Number, 
	_In_ KIRQL						OldIrql
	);
typedef KIRQL(*KeAcquireQueuedSpinLockRaiseToSynchPtr)(
	_In_ KSPIN_LOCK_QUEUE_NUMBER	Number
	);
typedef NTSTATUS (*NtQueryInformationThreadPtr)(
	_In_			HANDLE			ThreadHandle,
	_In_            THREADINFOCLASS ThreadInformationClass,
	_Inout_			PVOID           ThreadInformation,
	_In_            ULONG           ThreadInformationLength,
	_Out_opt_		PULONG          ReturnLength
	);
typedef NTSTATUS (*NTAPI PsGetContextThreadPtr)(
	_In_			PETHREAD Thread,
	_Inout_			PCONTEXT ThreadContext,
	_In_			KPROCESSOR_MODE PreviousMode
	);


class Utility
{
public:
	Utility(PDRIVER_OBJECT DriverObject);
	~Utility();
	NTSTATUS InitUtils(
		_In_		PDRIVER_OBJECT			DriverObject);
	NTSTATUS EnumKernelModuleInfo(
		_In_opt_	PRTL_PROCESS_MODULES*	procMods);
	NTSTATUS ImportNtPrimitives();
	bool IsValidPEHeader(
		_In_		const uintptr_t			head);
	BOOLEAN IsWindows7();
	PVOID GetKernelBaseAddr(
		_In_		PDRIVER_OBJECT			DriverObject);
	NTSTATUS FindExport(
		_In_		const uintptr_t			imageBase, 
		_In_		const char*				exportName, 
		_Out_		uintptr_t*				functionPointer);
	PVOID GetNtoskrnlBaseAddress();
	
	NTSTATUS QuerySystemInformation(
		_In_		ULONG		infoClass, 
		_Inout_		PVOID*		dataBuf);
	int	strcmpi_w(
		_In_	const wchar_t*		s1, 
		_In_	const wchar_t*		s2);
	
	__forceinline wchar_t locase_w(
		_In_	wchar_t		c);
	BOOLEAN CheckModulesForAddress(
		_In_	UINT64					address, 
		_In_	PRTL_PROCESS_MODULES	procMods);
	_Success_(return) BOOLEAN GetNtoskrnlSection(
		_In_	const char*		sectionName, 
		_Out_	DWORD*		sectionVa, 
		_Out_	DWORD*		sectionSize);
	UINT32 SpinLock(
		_In_ volatile signed __int64* Lock);
	NTSTATUS Sleep(
		_In_ LONG miliseconds);
	
	NTSTATUS ScanSystemThreads();
	BOOLEAN StackwalkThread(
		_In_	PETHREAD			threadObject, 
		_Out_	CONTEXT*			context, 
		_Out_	STACKWALK_BUFFER*	stackwalkBuffer);
	UINT32 CopyThreadKernelStack(
		_In_	PETHREAD	threadObject, 
		_Out_	void*		outStackBuffer);
	_Success_(return) BOOL LockThread(
		_In_	PKTHREAD	Thread, 
		_Out_	KIRQL*		Irql);
	UINT32 GetThreadStackLimit();
	UINT32 GetThreadStateOffset();
	UINT32 GetKernelStackOffset();
	UINT32 GetInitialStackOffset();
	UINT32 GetStackBaseOffset();
	UINT32 GetThreadLockOffset();
	BOOLEAN threadLockPatternMatch(
		_In_	BYTE*	address, 
		_Inout_	UINT8** outOffset, 
		_In_	UINT32	range);
	BOOLEAN threadStatePatternMatch(
		_In_	BYTE*		address, 
		_Inout_ UINT32**	outOffset, 
		_In_	UINT32		range);
	NTSTATUS GetThreadStartAddr(
		_In_	PETHREAD	threadObject,
		_Out_	uintptr_t*	pStartAddr);
	INT ScanBigPoolsForAddr(
		_In_ uintptr_t addr);
	NTSTATUS SearchPattern(
		_In_ PCUCHAR pattern,
		_In_ UCHAR wildcard, 
		_In_ ULONG_PTR len, 
		_In_ const VOID* base, 
		_In_ ULONG_PTR size, 
		_Out_ PVOID* ppFound);
	BOOLEAN GetCurrentThreadContext(
		PETHREAD threadObject);
	NTSTATUS KbGetThreadContext(
		IN PETHREAD threadObject);
	void check_driver_dispatch();
private:
	bool mImportFail = false;

	GenericFuncPtr pNtPrimitives[WINAPI_IMPORT_COUNT];
	MmSystemRoutinePtr pMmSysRoutine = NULL;
	ZwQuerySysInfoPtr pZwQuerySysInfo = NULL;
	PsGetCurrentProcessIdPtr pPsGetCurrentProcessId = NULL;
	PsIsSystemThreadPtr pPsIsSystemThread = NULL;
	PsGetCurrentProcessPtr pPsGetCurrentProcess = NULL;
	PsLookupThreadByThreadIdPtr pPsLookupThreadByThreadId = NULL;
	IoThreadToProcessPtr pIoThreadToProcess = NULL;
	PsGetProcessIdPtr pPsGetProcessId = NULL;
	RtlVirtualUnwindPtr pRtlVirtualUnwind = NULL;
	RtlLookupFunctionEntryPtr pRtlLookupFunctionEntry = NULL;
	KeAlertThreadPtr pKeAlertThread = NULL;
	PsGetCurrentThreadStackBasePtr pPsGetCurrentThreadStackBase = NULL;
	PsGetCurrentThreadStackLimitPtr pPsGetCurrentThreadStackLimit = NULL;
	KeReleaseQueuedSpinLockPtr pKeReleaseQueuedSpinLock = NULL;
	KeAcquireQueuedSpinLockRaiseToSynchPtr pKeAcquireQueuedSpinLockRaiseToSynch = NULL;
	NtQueryInformationThreadPtr pNtQueryInformationThread = NULL;
	PsGetContextThreadPtr pPsGetContextThread = NULL;

	PRTL_PROCESS_MODULES outProcMods = NULL;

	UINT32 gkThreadStateOffset = 0;
	UINT32 gThreadLockOffset = 0;
	UINT32 gKernelStackOffset = 0;
	UINT32 gInitialStackOffset = 0;
	UINT32 gStackBaseOffset = 0;
	UINT32 gThreadStackLimit = 0;

	PVOID kernBase = NULL;

	volatile signed long long gSpinLock1 = 0;
	volatile signed long long gSpinLock2 = 0;
	volatile signed long long gSpinLock3 = 0;
	volatile signed long long gSpinLock4 = 0;
	volatile signed long long gSpinLock5 = 0;
	volatile signed long long gSpinLock6 = 0;

	BYTE threadStatePattern[8] = { 0x8a, 0x83, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x05 };
	BYTE threadLockPattern[8] = {0xF0, 0x48, 0x0F, 0xBA, 0x6B, 0x00, 0x00, 0x0F};
};





	

```

`README.md`:

```md
<img src="nomadImg.jpg" width="500" height="300">

# Nomad
Uses known heuristic detection methods to find manulaly mapped kernel code and suspicious threads.  
# Features

**Threads**
- Stack walk system threads
- Check thread entry points

**Hook Detection**
- Checks for driver IOCTL hooks

**Big Pool Scans**
- Checks big pools referenced by a non-legit address

<img src="NomadOutput.png" width="600" height="300">

# Credits
- ApexLegendsUC (anti-cheat-emulator)
- Credits not listed here are in code comments

```