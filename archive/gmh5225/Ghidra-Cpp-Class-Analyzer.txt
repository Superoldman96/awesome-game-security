Project Path: arc_gmh5225_Ghidra-Cpp-Class-Analyzer_cvypag0j

Source Tree:

```txt
arc_gmh5225_Ghidra-Cpp-Class-Analyzer_cvypag0j
├── .github
│   └── workflows
│       └── test.yml
├── LICENSE
├── Module.manifest
├── NOTICE
├── README.md
├── build.gradle
├── data
│   └── ExtensionPoint.manifest
├── developer_scripts
│   ├── CppClassAnalyzerTestScript.java
│   ├── CppClassAnalyzerTestScript.py
│   ├── NamespaceSymbolFixer.java
│   ├── ResetDatabaseScript.java
│   ├── TestBuilder.java
│   └── svg_converter.py
├── extension.properties
├── ghidra_scripts
│   ├── ClassReferences.java
│   ├── DynamicCaster.java
│   ├── ResetVfTableScript.java
│   └── ShowClassTreeGraph.java
└── src
    ├── main
    │   ├── java
    │   │   ├── cppclassanalyzer
    │   │   │   ├── analysis
    │   │   │   │   ├── AbstractCppClassAnalyzer.java
    │   │   │   │   ├── cmd
    │   │   │   │   │   ├── AbstractConstructorAnalysisCmd.java
    │   │   │   │   │   └── AbstractDecompilerBasedConstructorAnalysisCmd.java
    │   │   │   │   ├── gcc
    │   │   │   │   │   ├── GccConstructorAnalysisCmd.java
    │   │   │   │   │   ├── GccCppClassAnalyzer.java
    │   │   │   │   │   ├── GccDecompilerConstructorAnalysisCmd.java
    │   │   │   │   │   └── GccVtableAnalysisCmd.java
    │   │   │   │   └── vs
    │   │   │   │       ├── VsConstructorAnalysisCmd.java
    │   │   │   │       ├── VsCppClassAnalyzer.java
    │   │   │   │       ├── VsDecompilerConstructorAnalysisCmd.java
    │   │   │   │       └── VsVftableAnalysisCmd.java
    │   │   │   ├── cmd
    │   │   │   │   ├── ApplyVtableDefinitionsBackgroundCmd.java
    │   │   │   │   ├── CreateExternalSymbolBackgroundCmd.java
    │   │   │   │   └── FillOutClassBackgroundCmd.java
    │   │   │   ├── data
    │   │   │   │   ├── ArchivedRttiData.java
    │   │   │   │   ├── ClassTypeInfoManager.java
    │   │   │   │   ├── ProgramClassTypeInfoManager.java
    │   │   │   │   ├── TypeInfoManager.java
    │   │   │   │   ├── manager
    │   │   │   │   │   ├── AbstractRttiRecordWorker.java
    │   │   │   │   │   ├── ArchiveClassTypeInfoManager.java
    │   │   │   │   │   ├── ArchiveRttiRecordWorker.java
    │   │   │   │   │   ├── ClassTypeInfoManagerDB.java
    │   │   │   │   │   ├── FileArchiveClassTypeInfoManager.java
    │   │   │   │   │   ├── ItaniumAbiClassTypeInfoManager.java
    │   │   │   │   │   ├── LibraryClassTypeInfoManager.java
    │   │   │   │   │   ├── ProjectClassTypeInfoManager.java
    │   │   │   │   │   ├── VsClassTypeInfoManager.java
    │   │   │   │   │   ├── caches
    │   │   │   │   │   │   ├── ArchivedRttiCachePair.java
    │   │   │   │   │   │   ├── ProgramRttiCachePair.java
    │   │   │   │   │   │   └── RttiCachePair.java
    │   │   │   │   │   ├── recordmanagers
    │   │   │   │   │   │   ├── ArchiveRttiRecordManager.java
    │   │   │   │   │   │   ├── ProgramRttiRecordManager.java
    │   │   │   │   │   │   └── RttiRecordManager.java
    │   │   │   │   │   └── tables
    │   │   │   │   │       ├── ArchivedRttiTablePair.java
    │   │   │   │   │       ├── ProgramRttiTablePair.java
    │   │   │   │   │       └── RttiTablePair.java
    │   │   │   │   ├── typeinfo
    │   │   │   │   │   ├── AbstractClassTypeInfoDB.java
    │   │   │   │   │   ├── ArchivedClassTypeInfo.java
    │   │   │   │   │   ├── ClassTypeInfoDB.java
    │   │   │   │   │   ├── GnuClassTypeInfoDB.java
    │   │   │   │   │   └── VsClassTypeInfoDB.java
    │   │   │   │   └── vtable
    │   │   │   │       ├── AbstractVtableDB.java
    │   │   │   │       ├── ArchivedGnuVtable.java
    │   │   │   │       ├── ArchivedVtable.java
    │   │   │   │       ├── VftableDB.java
    │   │   │   │       └── VtableModelDB.java
    │   │   │   ├── database
    │   │   │   │   ├── SchemaMismatchException.java
    │   │   │   │   ├── record
    │   │   │   │   │   ├── AbstractDatabaseRecord.java
    │   │   │   │   │   ├── ArchivedClassTypeInfoRecord.java
    │   │   │   │   │   ├── ArchivedGnuVtableRecord.java
    │   │   │   │   │   ├── ClassTypeInfoRecord.java
    │   │   │   │   │   ├── DatabaseRecord.java
    │   │   │   │   │   ├── SchemaRecordIterator.java
    │   │   │   │   │   └── VtableRecord.java
    │   │   │   │   ├── schema
    │   │   │   │   │   ├── AbstractSchema.java
    │   │   │   │   │   ├── ArchivedClassTypeInfoSchema.java
    │   │   │   │   │   ├── ArchivedGnuVtableSchema.java
    │   │   │   │   │   ├── ClassTypeInfoSchema.java
    │   │   │   │   │   ├── DatabaseSchema.java
    │   │   │   │   │   ├── VtableSchema.java
    │   │   │   │   │   └── fields
    │   │   │   │   │       ├── ArchivedClassTypeInfoSchemaFields.java
    │   │   │   │   │       ├── ArchivedGnuVtableSchemaFields.java
    │   │   │   │   │       ├── ClassTypeInfoSchemaFields.java
    │   │   │   │   │       ├── FieldEnum.java
    │   │   │   │   │       └── VtableSchemaFields.java
    │   │   │   │   ├── tables
    │   │   │   │   │   ├── AbstractDatabaseTable.java
    │   │   │   │   │   ├── ArchivedClassTypeInfoDatabaseTable.java
    │   │   │   │   │   ├── ArchivedGnuVtableDatabaseTable.java
    │   │   │   │   │   ├── ClassTypeInfoDatabaseTable.java
    │   │   │   │   │   ├── DatabaseTable.java
    │   │   │   │   │   └── VtableDatabaseTable.java
    │   │   │   │   └── utils
    │   │   │   │       ├── LongStack.java
    │   │   │   │       └── TransactionHandler.java
    │   │   │   ├── decompiler
    │   │   │   │   ├── DecompilerAPI.java
    │   │   │   │   ├── action
    │   │   │   │   │   └── FillOutClassAction.java
    │   │   │   │   ├── function
    │   │   │   │   │   ├── AbstractHighStructAccess.java
    │   │   │   │   │   ├── HighFunctionCall.java
    │   │   │   │   │   ├── HighFunctionCallParameter.java
    │   │   │   │   │   ├── HighStructAccess.java
    │   │   │   │   │   └── HighVariableAssignment.java
    │   │   │   │   └── token
    │   │   │   │       ├── ClangNodeUtils.java
    │   │   │   │       └── ClangTokenGroupIterator.java
    │   │   │   ├── graph
    │   │   │   │   └── InheritanceGraphDisplayProvider.java
    │   │   │   ├── plugin
    │   │   │   │   ├── ClassTypeInfoManagerPlugin.java
    │   │   │   │   ├── CppClassAnalyzerPluginPackage.java
    │   │   │   │   ├── HeadlessClassTypeInfoManagerService.java
    │   │   │   │   ├── TypeInfoArchiveChangeRecord.java
    │   │   │   │   ├── TypeInfoManagerListener.java
    │   │   │   │   └── typemgr
    │   │   │   │       ├── TypeInfoArchiveGTree.java
    │   │   │   │       ├── TypeInfoDragNDropHandler.java
    │   │   │   │       ├── TypeInfoTreeProvider.java
    │   │   │   │       ├── action
    │   │   │   │       │   ├── AbstractArchiveClipboardAction.java
    │   │   │   │       │   ├── AbstractFileArchivePopupAction.java
    │   │   │   │       │   ├── AbstractTypeInfoNodeAction.java
    │   │   │   │       │   ├── AbstractTypeMgrAction.java
    │   │   │   │       │   ├── ArchiveFileChooser.java
    │   │   │   │       │   ├── CloseArchiveAction.java
    │   │   │   │       │   ├── CopyArchiveAction.java
    │   │   │   │       │   ├── CppClassAnalyzerPreferences.java
    │   │   │   │       │   ├── CreateArchiveAction.java
    │   │   │   │       │   ├── CreateProjectArchiveAction.java
    │   │   │   │       │   ├── DummyClipboardOwner.java
    │   │   │   │       │   ├── EditDataTypeAction.java
    │   │   │   │       │   ├── GoToVtableAction.java
    │   │   │   │       │   ├── OpenArchiveAction.java
    │   │   │   │       │   ├── OpenForEditAction.java
    │   │   │   │       │   ├── OpenProjectArchiveAction.java
    │   │   │   │       │   ├── PasteArchiveAction.java
    │   │   │   │       │   ├── RenameManagerAction.java
    │   │   │   │       │   ├── SaveAction.java
    │   │   │   │       │   └── TypeInfoArchiveHandler.java
    │   │   │   │       ├── dialog
    │   │   │   │       │   └── OpenProjectArchiveDialog.java
    │   │   │   │       ├── filter
    │   │   │   │       │   └── ProjectArchiveFilter.java
    │   │   │   │       ├── icon
    │   │   │   │       │   ├── AbstractSwappedColorModel.java
    │   │   │   │       │   ├── BlueGreenSwappedColorModel.java
    │   │   │   │       │   ├── PurpleSwappedColorModel.java
    │   │   │   │       │   ├── RedGreenSwappedColorModel.java
    │   │   │   │       │   └── YellowSwappedColorModel.java
    │   │   │   │       └── node
    │   │   │   │           ├── AbstractManagerNode.java
    │   │   │   │           ├── AbstractSingleManagerNode.java
    │   │   │   │           ├── AbstractSortedNode.java
    │   │   │   │           ├── NamespacePathNode.java
    │   │   │   │           ├── ProjectArchiveTypeInfoNode.java
    │   │   │   │           ├── TypeInfoArchiveNode.java
    │   │   │   │           ├── TypeInfoLibraryNode.java
    │   │   │   │           ├── TypeInfoNode.java
    │   │   │   │           ├── TypeInfoRootNode.java
    │   │   │   │           ├── TypeInfoTreeNode.java
    │   │   │   │           └── TypeInfoTreeNodeManager.java
    │   │   │   ├── provider
    │   │   │   │   ├── ItaniumAbiRttiManagerProvider.java
    │   │   │   │   └── VsRttiManagerProvider.java
    │   │   │   ├── scanner
    │   │   │   │   ├── DynlibRttiScanner.java
    │   │   │   │   ├── DynlibRttiScannerProvider.java
    │   │   │   │   ├── ItaniumAbiRttiScanner.java
    │   │   │   │   ├── ItaniumAbiRttiScannerProvider.java
    │   │   │   │   ├── RttiScanner.java
    │   │   │   │   ├── RttiScannerProvider.java
    │   │   │   │   └── TypeInfoFactory.java
    │   │   │   ├── script
    │   │   │   │   ├── CppClassAnalyzerGhidraScript.java
    │   │   │   │   └── CppClassAnalyzerHeadlessScript.java
    │   │   │   ├── service
    │   │   │   │   ├── ClassTypeInfoManagerService.java
    │   │   │   │   └── RttiManagerProvider.java
    │   │   │   ├── utils
    │   │   │   │   ├── ConstantPropagationUtils.java
    │   │   │   │   ├── CppClassAnalyzerUtils.java
    │   │   │   │   └── LanguageIdHandler.java
    │   │   │   └── vs
    │   │   │       ├── RttiModelSearcher.java
    │   │   │       ├── RttiModelWrapper.java
    │   │   │       ├── VsClassTypeInfo.java
    │   │   │       ├── VsCppClassBuilder.java
    │   │   │       └── VsVtableModel.java
    │   │   └── ghidra
    │   │       └── app
    │   │           ├── cmd
    │   │           │   └── data
    │   │           │       └── rtti
    │   │           │           ├── AbstractCppClassBuilder.java
    │   │           │           ├── ClassTypeInfo.java
    │   │           │           ├── GnuVtable.java
    │   │           │           ├── TypeInfo.java
    │   │           │           ├── Vtable.java
    │   │           │           └── gcc
    │   │           │               ├── AbstractCreateVtableBackgroundCmd.java
    │   │           │               ├── ClassTypeInfoUtils.java
    │   │           │               ├── CreateConstructionVtableBackgroundCmd.java
    │   │           │               ├── CreateTypeInfoBackgroundCmd.java
    │   │           │               ├── CreateVtableBackgroundCmd.java
    │   │           │               ├── CreateVttBackgroundCmd.java
    │   │           │               ├── ExternalClassTypeInfo.java
    │   │           │               ├── ExternalClassTypeInfoFactory.java
    │   │           │               ├── GccCppClassBuilder.java
    │   │           │               ├── GnuUtils.java
    │   │           │               ├── TypeInfoUtils.java
    │   │           │               ├── UnresolvedClassTypeInfoException.java
    │   │           │               ├── VtableModel.java
    │   │           │               ├── VtableUtils.java
    │   │           │               ├── VttModel.java
    │   │           │               ├── builder
    │   │           │               │   ├── AbstractTypeInfoProgramBuilder.java
    │   │           │               │   ├── Ppc64TypeInfoProgramBuilder.java
    │   │           │               │   └── X86TypeInfoProgramBuilder.java
    │   │           │               ├── factory
    │   │           │               │   └── TypeInfoFactory.java
    │   │           │               └── typeinfo
    │   │           │                   ├── AbstractClassTypeInfoModel.java
    │   │           │                   ├── AbstractPBaseTypeInfoModel.java
    │   │           │                   ├── AbstractSiClassTypeInfoModel.java
    │   │           │                   ├── AbstractTypeInfoModel.java
    │   │           │                   ├── ArrayTypeInfoModel.java
    │   │           │                   ├── BaseClassTypeInfoModel.java
    │   │           │                   ├── ClassTypeInfoModel.java
    │   │           │                   ├── EnumTypeInfoModel.java
    │   │           │                   ├── FunctionTypeInfoModel.java
    │   │           │                   ├── FundamentalTypeInfoModel.java
    │   │           │                   ├── IosFailTypeInfoModel.java
    │   │           │                   ├── PBaseTypeInfoModel.java
    │   │           │                   ├── PointerToMemberTypeInfoModel.java
    │   │           │                   ├── PointerTypeInfoModel.java
    │   │           │                   ├── SiClassTypeInfoModel.java
    │   │           │                   ├── TypeInfoModel.java
    │   │           │                   ├── VmiClassTypeInfoModel.java
    │   │           │                   └── VmiOffsetFlagsModel.java
    │   │           └── plugin
    │   │               ├── core
    │   │               │   └── decompile
    │   │               │       └── actions
    │   │               │           └── AbstractNonPackageDecompilerAction.java
    │   │               └── prototype
    │   │                   └── GccRttiAnalyzer.java
    │   └── resources
    │       └── images
    │           ├── cpp_logo.png
    │           └── cpp_logo.svg
    └── test
        ├── java
        │   └── ghidra
        │       └── app
        │           └── cmd
        │               └── data
        │                   └── rtti
        │                       └── gcc
        │                           ├── ClassBuilderTest.java
        │                           ├── GenericGccRttiTest.java
        │                           ├── Ppc64GccRttiTest.java
        │                           ├── Ppc64VtableModelTest.java
        │                           ├── TypeInfoTest.java
        │                           ├── VtableModelTest.java
        │                           ├── VttModelTest.java
        │                           ├── X86GccRttiTest.java
        │                           └── X86VtableModelTest.java
        └── resources
            ├── cpp_classes.json
            └── defaultTools
                └── TestCodeBrowser.tool

```

`.github/workflows/test.yml`:

```yml
name: Run tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        ghidra: ["10.2"]
    steps:
      - uses: actions/checkout@v1
      - uses: actions/setup-java@v1
        with:
          java-version: "17"
          java-package: jdk
          architecture: x64
      - uses: er28-0652/setup-ghidra@master
        with:
          version: ${{ matrix.ghidra }}
      - uses: eskatos/gradle-command-action@v1
        with:
          gradle-version: 7.3
          arguments: test --info -PGHIDRA_INSTALL_DIR=${{ env.GHIDRA_INSTALL_DIR }}

```

`LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2019-2020 Andrew J. Strelsky

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

```

`NOTICE`:

```
The C++ logo is a trademark of the Standard C++ Foundation and is used with permission.

```

`README.md`:

```md
[![Run tests](https://github.com/astrelsky/Ghidra-Cpp-Class-Analyzer/actions/workflows/test.yml/badge.svg)](https://github.com/astrelsky/Ghidra-Cpp-Class-Analyzer/actions/workflows/test.yml)  
Ghidra C++ Class and Run Time Type Information Analyzer
=======================================================

API Documentation
-----------------

A fully built and linked version of the documentation is available at <https://astrelsky.github.io/Ghidra-Cpp-Class-Analyzer>.

Building
--------

Run the following command in a terminal of your choice.

`gradle buildExtension`

Upon completion the output will be located in the dist folder.

Installation
------------

Extract the archive to a destination folder of your choice.
Launch ghidra and from the project manager go to `file->Install Extensions...`
Click the + icon near the top right corner of the window.
Select the the path of the extracted Ghidra-Cpp-Class-Analyzer folder and select OK.
After restarting ghidra open the CodeBrowser and go to `file->Configure...->Experimental` and select `ClassTypeInfoManagerPlugin`. Restart the CodeBrowser to allow the analyzers to be refreshed.

Features
--------

* GCC RTTI models and analysis.
* Vtable analysis and class namespace setting.
* Constructor/Destructor analysis.
* Reconstruction of class inheritance models for virtual multiple inheritance.
* Tree style display of inheritance hierarchy.

Supported Compilers
-------------------

* GCC
* Clang
* Visual Studio (Control Flow Guard (CFG) not supported)

Inheritance Modeling via the Type Info Tree
-------------------------------------------

![Capture](https://user-images.githubusercontent.com/46897303/86498580-62295580-bd54-11ea-9434-d1b3e6e40a4c.PNG)

Class Type Info Color Coding
----------------------------

![#FFFF00](https://via.placeholder.com/15/ffff00/000000?text=+) - Nested Class  
![#28a745](https://via.placeholder.com/15/28a745/000000?text=+) - Basic Class  
![#d73a49](https://via.placeholder.com/15/d73a49/000000?text=+) - Abstract Class  
![#0366d6](https://via.placeholder.com/15/0366d6/000000?text=+) - Virtual Class  
![#6f42c1](https://via.placeholder.com/15/6f42c1/000000?text=+) - Virtual Abstract Class

CppClassAnalyzerGhidraScript
----------------------------

Want to make a GhidraScript with easy access to the ClassTypeInfoManager for the currentProgram? Try extending the CppClassAnalyzerGhidraScript class instead of GhidraScript. Unfortunately this is currently only possible for scripts written in Java.

Fill Out Class Decompiler Action
--------------------------------

Right clicking within the decompiler window in a `__thiscall` function with which a ClassTypeInfo exists will contain an action to fill out the class. It behaves similarly to the fill out structure action accept class members are determined via calls to other `__thiscall` functions.

Dynamic RTTI Handling
---------------------

For GNU binaries a project archive will need to be created to provide data required for analysis. Each library containing dynamic RTTI will need to be analyzed and copied into the project archive via the TypeInfoTree prior to analyzing the program. In the future an archive wil be distributed for libstdc++.

TODO
----

* Graphing
* Type Info Tree filter
* Help Documentation

```

`build.gradle`:

```gradle
// Builds a Ghidra Extension for a given Ghidra installation.
//
// An absolute path to the Ghidra installation directory must be supplied either by setting the
// GHIDRA_INSTALL_DIR environment variable or Gradle project property:
//
//     > export GHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//     > gradle
//
//         or
//
//     > gradle -PGHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//
// Gradle should be invoked from the directory of the project to build.  Please see the
// application.gradle.version property in <GHIDRA_INSTALL_DIR>/Ghidra/application.properties
// for the correction version of Gradle to use for the Ghidra installation you specify.

//----------------------START "DO NOT MODIFY" SECTION------------------------------
apply plugin: 'java'
apply plugin: 'eclipse'
def ghidraInstallDir

if (System.env.GHIDRA_INSTALL_DIR) {
	ghidraInstallDir = System.env.GHIDRA_INSTALL_DIR
}
else if (project.hasProperty("GHIDRA_INSTALL_DIR")) {
	ghidraInstallDir = project.getProperty("GHIDRA_INSTALL_DIR")
}

if (ghidraInstallDir) {
	apply from: new File(ghidraInstallDir).getCanonicalPath() + "/support/buildExtension.gradle"
}
else {
	throw new GradleException("GHIDRA_INSTALL_DIR is not defined!")
}
//----------------------END "DO NOT MODIFY" SECTION-------------------------------
def docs = file(ghidraInstallDir+'/docs/GhidraAPI_javadoc.zip')
def ghidraUserDir = System.getProperty("user.home") + "/.ghidra/.${DISTRO_PREFIX}_${RELEASE_NAME}"

repositories { mavenCentral() }

dependencies {
	testImplementation "org.hamcrest:hamcrest-all:1.3"
	testImplementation "org.jmockit:jmockit:1.44"
	testImplementation "junit:junit:4.12"
	runtimeOnly fileTree(dir: ghidraInstallDir + '/Ghidra/patch', include: "**/*.jar")
	runtimeOnly fileTree(dir: ghidraInstallDir + '/Ghidra/Configurations', include: "**/*.jar")
	runtimeOnly fileTree(dir: ghidraInstallDir + '/Ghidra/Features', include: "**/*.jar")
	runtimeOnly fileTree(dir: ghidraInstallDir + '/Ghidra/Framework', include: "**/*.jar")
	runtimeOnly fileTree(dir: ghidraInstallDir + '/Ghidra/Processors', include: "**/*.jar")
	runtimeOnly fileTree(dir: ghidraInstallDir + '/Ghidra/Debug', include: "**/*.jar")
	runtimeOnly fileTree(dir: ghidraInstallDir + '/Ghidra/Extensions',
						 include: "**/*.jar", exclude: project.name)
	runtimeOnly fileTree(dir: ghidraUserDir + "/Extensions",
						 include: "**/*.jar", exclude: project.name)
}

eclipse {
    classpath {
        downloadJavadoc = true
        downloadSources = true
		file {
			whenMerged {
				File javaDoc = new File(ghidraInstallDir+"/docs/GhidraAPI_javadoc.zip");
				for (entry in entries) {
					if (entry.path.contains('jar')) {
						File folder = new File(entry.getPath()).getParentFile();
						for (File file : folder.listFiles()) {
							if (file.getName().endsWith(".zip")) {
								if (file.getName().contains("-src")) {
									entry.setSourcePath(it.fileReference(file));
								}
								entry.setJavadocPath(it.fileReference(javaDoc));
							}
						}
					}
				}
				entries.add(
					new org.gradle.plugins.ide.eclipse.model.Library(
						it.fileReference(new File(projectDir, '/data'))
					)
				)
			}
		}
    }
}

javadoc.destinationDir = new File(projectDir, 'docs')

copyDependencies.exclude { fileTreeElement ->
	def fileAbsPath = fileTreeElement.getFile().getCanonicalFile().toPath()
	return fileAbsPath.startsWith(ghidraUserDir)
}

buildExtension {
	exclude '.vscode'
	exclude 'gradle*'
	exclude '.editorconfig'
	exclude '*.github'
}

buildExtension.dependsOn(javadoc)

```

`data/ExtensionPoint.manifest`:

```manifest
RttiManagerProvider
RttiScannerProvider

```

`developer_scripts/CppClassAnalyzerTestScript.java`:

```java
//@category CppClassAnalyzer
import cppclassanalyzer.script.CppClassAnalyzerGhidraScript;

public class CppClassAnalyzerTestScript extends CppClassAnalyzerGhidraScript {

	@Override
	public void run() throws Exception {
		println("The current class is " + getClass().getSimpleName());
		println("Its super class is " + getClass().getSuperclass().getName());
		println("The current manager is " + currentManager.getName());
	}
}
```

`developer_scripts/CppClassAnalyzerTestScript.py`:

```py

if __name__ == '__main__':
    println("The current class is " + getClass().getSimpleName())
    println("Its super class is " + getClass().getSuperclass().getName())
    println("The current manager is " + currentManager.getName())

```

`developer_scripts/NamespaceSymbolFixer.java`:

```java
//@category CppClassAnalyzer
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import ghidra.app.script.GhidraScript;
import ghidra.program.model.data.Category;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.DataTypePath;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.listing.VariableUtilities;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.symbol.SourceType;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.util.exception.DuplicateNameException;

import com.google.common.collect.ImmutableList;

import util.CollectionUtils;

public class NamespaceSymbolFixer extends GhidraScript {

	@Override
	public void run() throws Exception {
		fixCategories();
		fixDataTypes();
		fixStructures();
		fixSymbols();
		fixClasses();
	}

	private void fixDataTypes() throws Exception {
		DataTypeManager dtm = currentProgram.getDataTypeManager();
		List<DataType> types = CollectionUtils.asStream(dtm.getAllDataTypes())
			.filter(dt -> dt.getName().contains("--"))
			.collect(Collectors.toList());
		println(String.format("Located %d datatypes", types.size()));
		monitor.setMessage("Repairing DataTypes");
		monitor.initialize(types.size());
		for (DataType dt : types) {
			monitor.checkCanceled();
			String name = dt.getName();
			try {
				dt.setName(name.replaceAll("--", "::"));
			} catch (DuplicateNameException e) {
				DataTypePath path =
					new DataTypePath(dt.getCategoryPath(), name.replaceAll("--", "::"));
				printerr("Duplicate type "+path.toString());
			}
			monitor.incrementProgress(1);
		}
	}

	private void fixStructures() throws Exception {
		DataTypeManager dtm = currentProgram.getDataTypeManager();
		List<Structure> structs = CollectionUtils.asList(dtm.getAllStructures());
		monitor.setMessage("Repairing Structure Members");
		for (Structure struct : structs) {
			monitor.checkCanceled();
			if (!struct.getName().equals("vtable")) {
				for (DataTypeComponent comp : struct.getComponents()) {
					String name = comp.getFieldName();
					if (name != null && name.contains("--")) {
						comp.setFieldName(name.replaceAll("--", "::"));
					}
				}
			}
			monitor.incrementProgress(1);
		}
	}

	private void fixCategories() throws Exception {
		DataTypeManager dtm = currentProgram.getDataTypeManager();
		List<DataType> types = ImmutableList.copyOf(dtm.getAllDataTypes());
		monitor.setMessage("Repairing Categories");
		monitor.initialize(types.size());
		for (DataType dt : types) {
			monitor.checkCanceled();
			fixCategory(dt);
			monitor.incrementProgress(1);
		}
	}

	private void fixCategory(DataType dt) throws Exception {
		DataTypeManager dtm = currentProgram.getDataTypeManager();
		Category cat = dtm.getCategory(dt.getCategoryPath());
		String name = cat.getName();
		if (name.contains("--")) {
			cat.setName(name.replaceAll("--", "::"));
		}
	}

	private void fixSymbols() throws Exception {
		SymbolTable table = currentProgram.getSymbolTable();
		monitor.setMessage("Repairing Symbols");
		monitor.initialize(table.getNumSymbols());
		for (Symbol symbol : table.getAllSymbols(false)) {
			monitor.checkCanceled();
			String name = symbol.getName();
			if (name.contains("--")) {
				symbol.setName(name.replaceAll("--", "::"), SourceType.USER_DEFINED);
			}
			monitor.incrementProgress(1);
		}
	}

	private void fixClasses() throws Exception {
		SymbolTable table = currentProgram.getSymbolTable();
		List<GhidraClass> classes = CollectionUtils.asList(table.getClassNamespaces());
		monitor.setMessage("Repairing Classes");
		monitor.initialize(classes.size());
		for (GhidraClass gc : classes) {
			monitor.checkCanceled();
			String name = gc.getName();
			if (name.contains("--")) {
				gc.getSymbol().setName(name.replaceAll("--", "::"), SourceType.USER_DEFINED);
			}
			monitor.incrementProgress(1);
		}
	}
}

```

`developer_scripts/ResetDatabaseScript.java`:

```java
//@category CppClassAnalyzer
import ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoTreeNodeManager;
import ghidra.app.script.GhidraScript;
import cppclassanalyzer.service.ClassTypeInfoManagerService;
import ghidra.program.database.ProgramDB;
import cppclassanalyzer.data.manager.ClassTypeInfoManagerDB;
import cppclassanalyzer.data.typeinfo.AbstractClassTypeInfoDB;
import cppclassanalyzer.data.vtable.AbstractVtableDB;

import db.DBHandle;

public class ResetDatabaseScript extends GhidraScript {

	private static final String TREE_TABLE_NAME =
		TypeInfoTreeNodeManager.class.getSimpleName();
	private static final String TYPE_TABLE_NAME =
		AbstractClassTypeInfoDB.CLASS_TYPEINFO_TABLE_NAME;
	private static final String VTABLE_TABLE_NAME =
		AbstractVtableDB.VTABLE_TABLE_NAME;

	@Override
	public void run() throws Exception {
		if (ClassTypeInfoManagerService.isEnabled(currentProgram)) {
			printerr("Please disable the plugin prior to removing the database");
			return;
		}
		DBHandle handle = ((ProgramDB) currentProgram).getDBHandle();
		if (handle.getTable(TYPE_TABLE_NAME) != null) {
			handle.deleteTable(TYPE_TABLE_NAME);
		}
		if (handle.getTable(VTABLE_TABLE_NAME) != null) {
			handle.deleteTable(VTABLE_TABLE_NAME);
		}
		if (handle.getTable(TREE_TABLE_NAME) != null) {
			handle.deleteTable(TREE_TABLE_NAME);
		}
		println("Database removed. You may now re-enable the plugin.");
	}
}

```

`developer_scripts/TestBuilder.java`:

```java
//@category CppClassAnalyzer

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

import ghidra.app.script.GhidraScript;
import ghidra.app.cmd.data.rtti.gcc.builder.AbstractTypeInfoProgramBuilder;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils;
import ghidra.app.cmd.data.rtti.gcc.CreateVtableBackgroundCmd;
import ghidra.app.cmd.data.rtti.gcc.GnuUtils;
import ghidra.app.cmd.data.rtti.gcc.UnresolvedClassTypeInfoException;
import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.VtableModel;
import ghidra.app.cmd.data.rtti.gcc.VttModel;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.TypeInfoModel;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataUtilities;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.mem.Memory;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.program.model.reloc.Relocation;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.program.model.mem.MemoryBufferImpl;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.Structure;

import javax.lang.model.element.Modifier;

import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import static ghidra.app.util.datatype.microsoft.MSDataTypeUtils.getAbsoluteAddress;
import static ghidra.program.model.data.DataUtilities.ClearDataMode.CLEAR_ALL_CONFLICT_DATA;

import java.io.File;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class TestBuilder extends GhidraScript {

	private static final String MAP_OF_ENTRIES = "Map.ofEntries(\n";
	private static final String TYPE_MAP_FIELD = "typeMap";
	private static final String NAME_MAP_FIELD = "nameMap";
	private static final String VTABLE_MAP_FIELD = "vtableMap";
	private static final String VTT_MAP_FIELD = "vttMap";
	private static final String RELOCATION_MAP_FIELD = "relocationMap";
	private static final String FUNCTION_OFFSETS_FIELD = "functionOffsets";
	private static final String RETURN_STRING_FIELD = "returnString";
	private static final String FUNCTION_DESCRIPTORS_FIELD = "fDescriptors";

	private Map<TypeInfo, byte[]> tiMap = new LinkedHashMap<>();
	private Map<String, Address> nameMap = new LinkedHashMap<>();
	private Map<Vtable, byte[]> vtableMap = new LinkedHashMap<>();
	private Map<VttModel, byte[]> vttMap = new LinkedHashMap<>();
	private Set<Function> functionSet = new LinkedHashSet<>();

	private static final TypeName MAP_TYPE =
		ParameterizedTypeName.get(Map.class, Long.class, String.class);
	private static final TypeName ARRAY_TYPE = ArrayTypeName.of(Long.class);
	private static final TypeName STRING_TYPE = TypeName.get(String.class);

	private static final String VTABLE_PREFIX = "_ZTV";
	private static final String CREATE_MEMORY = "createMemory($S, $S, $L)";
	private static final String PURE_VIRTUAL = "__cxa_pure_virtual";

	@Override
	public void run() throws Exception {
		populateMaps();
		buildClass();
	}

	private void buildClass() throws Exception {
		File file = askDirectory("Select Directory", "Ok");
		String name = askString("Class Name", "Enter Class Name");
		TypeSpec tester = TypeSpec.classBuilder(name)
			.addModifiers(Modifier.PUBLIC)
			.superclass(AbstractTypeInfoProgramBuilder.class)
			.addField(getTypeMapField())
			.addField(getNameMapField())
			.addField(getVtableMapField())
			.addField(getVttMapField())
			.addField(getRelocationMapField())
			.addField(getFunctionArrayField())
			.addField(getReturnFunctionField())
			.addField(getFunctionDescriptorField())
			.addMethod(makeConstructor())
			.addMethod(makeGetter("getTypeInfoMap", TYPE_MAP_FIELD, MAP_TYPE))
			.addMethod(makeGetter("getTypeNameMap", NAME_MAP_FIELD, MAP_TYPE))
			.addMethod(makeGetter("getVtableMap", VTABLE_MAP_FIELD, MAP_TYPE))
			.addMethod(makeGetter("getVttMap", VTT_MAP_FIELD, MAP_TYPE))
			.addMethod(makeGetter("getRelocationMap", RELOCATION_MAP_FIELD, MAP_TYPE))
			.addMethod(makeGetter("getFunctionOffsets", FUNCTION_OFFSETS_FIELD, ARRAY_TYPE))
			.addMethod(makeGetter("getReturnInstruction", RETURN_STRING_FIELD, STRING_TYPE))
			.addMethod(
				makeGetter("getFunctionDescriptors", FUNCTION_DESCRIPTORS_FIELD, STRING_TYPE))
			.addMethod(makeSetupMemory())
			.build();

		JavaFile.builder("ghidra.app.cmd.data.rtti.gcc.builder", tester)
			.skipJavaLangImports(true)
			.indent("	")
			.build().writeTo(file);
	}

	private FieldSpec getTypeMapField() throws Exception {
		return FieldSpec.builder(MAP_TYPE, TYPE_MAP_FIELD)
			.addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
			.initializer(getTypeMapInitializer()).build();
	}

	private FieldSpec getNameMapField() throws Exception {
		return FieldSpec.builder(MAP_TYPE, NAME_MAP_FIELD)
			.addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
			.initializer(getNameMapInitializer()).build();
	}

	private FieldSpec getVtableMapField() throws Exception {
		return FieldSpec.builder(MAP_TYPE, VTABLE_MAP_FIELD)
			.addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
			.initializer(getVtableMapInitializer()).build();
	}

	private FieldSpec getVttMapField() throws Exception {
		return FieldSpec.builder(MAP_TYPE, VTT_MAP_FIELD)
			.addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
			.initializer(getVttMapInitializer()).build();
	}

	private FieldSpec getRelocationMapField() throws Exception {
		return FieldSpec.builder(MAP_TYPE, RELOCATION_MAP_FIELD)
			.addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
			.initializer(getRelocationMapInitializer()).build();
	}

	private FieldSpec getFunctionArrayField() throws Exception {
		return FieldSpec.builder(ARRAY_TYPE, FUNCTION_OFFSETS_FIELD)
			.addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
			.initializer(getFunctionArrayInitializer()).build();
	}

	private FieldSpec getReturnFunctionField() throws Exception {
		for (Symbol symbol : currentProgram.getSymbolTable().getSymbols("g_foo")) {
			Function function = getFunctionAt(symbol.getAddress());
			return FieldSpec.builder(String.class, RETURN_STRING_FIELD)
				.addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
				.initializer("$S", byteArrayToHex(getBytes(
					function.getEntryPoint(), (int) function.getBody().getNumAddresses())))
				.build();
		}
		return null;
	}

	private FieldSpec getFunctionDescriptorField() throws Exception {
		FieldSpec.Builder builder = FieldSpec.builder(STRING_TYPE, FUNCTION_DESCRIPTORS_FIELD)
			.addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL);
		if (GnuUtils.hasFunctionDescriptors(currentProgram)) {
			MemoryBlock block = getFunctionDescriptorBlock();
			byte[] bytes = new byte[(int) block.getSize()];
			block.getBytes(block.getStart(), bytes);
			return builder.initializer("$S", byteArrayToHex(bytes)).build();
		} return builder.initializer("$S", "").build();
	}

	private MemoryBlock getFunctionDescriptorBlock() {
		return currentProgram.getMemory().getBlock(".opd");
	}

	private CodeBlock getTypeMapInitializer() throws Exception {
		List<CodeBlock> blocks = new LinkedList<>();
		for (TypeInfo type : tiMap.keySet()) {
			blocks.add(
				CodeBlock.builder().add(
					"getEntry(0x$LL, $S)",
					type.getAddress().toString(), byteArrayToHex(tiMap.get(type))
					).build());
		}
		return CodeBlock.builder()
			.add(MAP_OF_ENTRIES)
			.indent()
			.add(CodeBlock.join(blocks, ",\n"))
			.unindent()
			.add("\n)")
			.build();
	}

	private CodeBlock getNameMapInitializer() throws Exception {
		List<CodeBlock> blocks = new LinkedList<>();
		for (String name : nameMap.keySet()) {
			blocks.add(
				CodeBlock.builder().add(
					"getEntry(0x$LL, $S)",
					nameMap.get(name), name
				).build());
		}
		return CodeBlock.builder()
			.add(MAP_OF_ENTRIES)
			.indent()
			.add(CodeBlock.join(blocks, ",\n"))
			.unindent()
			.add("\n)")
			.build();
	}

	private CodeBlock getVtableMapInitializer() throws Exception {
		List<CodeBlock> blocks = new LinkedList<>();
		for (Vtable vtable : vtableMap.keySet()) {
			blocks.add(
				CodeBlock.builder().add(
					"getEntry(0x$LL, $S)",
					vtable.getAddress().toString(), byteArrayToHex(vtableMap.get(vtable))
					).build());
		}
		return CodeBlock.builder()
			.add(MAP_OF_ENTRIES)
			.indent()
			.add(CodeBlock.join(blocks, ",\n"))
			.unindent()
			.add("\n)")
			.build();
	}

	private CodeBlock getVttMapInitializer() throws Exception {
		List<CodeBlock> blocks = new LinkedList<>();
		for (VttModel vtt : vttMap.keySet()) {
			blocks.add(
				CodeBlock.builder().add(
					"getEntry(0x$LL, $S)",
					vtt.getAddress().toString(), byteArrayToHex(vttMap.get(vtt))
					).build());
		}
		return CodeBlock.builder()
			.add(MAP_OF_ENTRIES)
			.indent()
			.add(CodeBlock.join(blocks, ",\n"))
			.unindent()
			.add("\n)")
			.build();
	}

	private static boolean validRelocationSymbol(String symbolName) {
		if (symbolName == null) {
			return false;
		} if (symbolName.equals(PURE_VIRTUAL)) {
			return true;
		} if (symbolName.contains(VTABLE_PREFIX) && symbolName.contains(TypeInfoModel.STRUCTURE_NAME)) {
			return true;
		} return false;
	}

	private CodeBlock getRelocationMapInitializer() throws Exception {
		Iterator<Relocation> relocations = currentProgram.getRelocationTable().getRelocations();
		List<CodeBlock> blocks = new LinkedList<>();
		while (relocations.hasNext()) {
			Relocation relocation = relocations.next();
			if (validRelocationSymbol(relocation.getSymbolName())) {
				blocks.add(
					CodeBlock.builder().add(
						"getEntry(0x$LL, $S)",
						relocation.getAddress().toString(), relocation.getSymbolName()
						).build());
			}
		}
		return CodeBlock.builder()
			.add(MAP_OF_ENTRIES)
			.indent()
			.add(CodeBlock.join(blocks, ",\n"))
			.unindent()
			.add("\n)")
			.build();
	}

	private CodeBlock getFunctionArrayInitializer() throws Exception {
		List<CodeBlock> blocks = new LinkedList<>();
		for (Function function : functionSet) {
			blocks.add(
				CodeBlock.builder().add(
					"0x$LL",
					function.getEntryPoint().toString()).build());
		}
		return CodeBlock.builder()
			.add("new Long[]{\n")
			.indent()
			.add(CodeBlock.join(blocks, ",\n"))
			.add("\n}")
			.build();
	}

	private MethodSpec makeGetter(String methodName, String field, TypeName type) {
		return MethodSpec.methodBuilder(methodName)
		.addAnnotation(Override.class)
		.addModifiers(Modifier.PROTECTED)
		.returns(type)
		.addStatement("return $L", field)
		.build();
	}

	private MethodSpec makeConstructor() {
		return MethodSpec.constructorBuilder()
			.addModifiers(Modifier.PUBLIC)
			.addException(Exception.class)
			.addStatement(
				"super($S, $S)",
				currentProgram.getLanguage().getLanguageID().toString(),
				currentProgram.getCompilerSpec().getCompilerSpecID().toString()
			)
			.build();
	}

	private MethodSpec makeSetupMemory() {
		MemoryBlock codeBlock = getFunctionBlock();
		MemoryBlock dataBlock = getDataBlock();
		MethodSpec.Builder builder = MethodSpec.methodBuilder("setupMemory")
			.addAnnotation(Override.class)
			.addModifiers(Modifier.PROTECTED)
			.addStatement(
				CREATE_MEMORY,
				codeBlock.getName(),
				codeBlock.getStart().toString(),
				codeBlock.getSize())
			.addStatement(
				CREATE_MEMORY,
				dataBlock.getName(),
				dataBlock.getStart().toString(),
				dataBlock.getSize());
		if (GnuUtils.hasFunctionDescriptors(currentProgram)) {
			MemoryBlock block = getFunctionDescriptorBlock();
			builder = builder.addStatement(
				CREATE_MEMORY,
				block.getName(),
				block.getStart().toString(),
				block.getSize()
			);
		}
		return builder.build();
	}

	private MemoryBlock getFunctionBlock() {
		for (Function function : functionSet) {
			return getMemoryBlock(function.getEntryPoint());
		}
		return null;
	}

	private MemoryBlock getDataBlock() {
		for (TypeInfo type : tiMap.keySet()) {
			return getMemoryBlock(type.getAddress());
		}
		return null;
	}

	private void populateMaps() throws Exception {
		ProgramClassTypeInfoManager manager = CppClassAnalyzerUtils.getManager(currentProgram);
		int pointerSize = currentProgram.getDefaultPointerSize();
		SymbolTable table = currentProgram.getSymbolTable();
		Listing listing = currentProgram.getListing();
		Memory mem = currentProgram.getMemory();
		for (Symbol symbol : table.getSymbols(TypeInfo.SYMBOL_NAME)) {
			TypeInfo type = null;
			try {
				type = manager.getTypeInfo(symbol.getAddress());
			} catch (UnresolvedClassTypeInfoException e) {
				continue;
			}
			if (type == null) {
					println("TypeInfo at "+symbol.getAddress().toString()+" is null");
					continue;
			}
			DataType dt = type.getDataType();
			Data data = DataUtilities.createData(
				currentProgram, type.getAddress(), dt,
				dt.getLength(), false, CLEAR_ALL_CONFLICT_DATA);
			if (data.isStructure() && ((Structure) data.getDataType()).hasFlexibleArrayComponent()) {
				MemoryBufferImpl buf = new MemoryBufferImpl(
					mem, data.getAddress());
				Data flexData = listing.getDataAt(data.getAddress().add(data.getLength()));
				int length = data.getLength();
				if (flexData != null) {
					length += flexData.getLength();
				}
				byte[] bytes = new byte[length];
				buf.getBytes(bytes, 0);
				tiMap.put(type, bytes);
			} else {
				tiMap.put(type, data.getBytes());
			}
			Address nameAddress = getAbsoluteAddress(
				currentProgram, symbol.getAddress().add(pointerSize));
			nameMap.put(type.getTypeName(), nameAddress);

			if (type instanceof ClassTypeInfo) {
				ClassTypeInfo classType = (ClassTypeInfo) type;
				GnuVtable vtable = (GnuVtable) classType.getVtable();
				if (!Vtable.isValid(vtable)) {
					continue;
				}
				MemoryBufferImpl buf = new MemoryBufferImpl(
					mem, vtable.getAddress());
				byte[] bytes = new byte[vtable.getLength()];
				buf.getBytes(bytes, 0);
				vtableMap.put(vtable, bytes);
				for (Function[] functionTable : vtable.getFunctionTables()) {
					for (Function function : functionTable) {
						if (function != null) {
							functionSet.add(function);
						}
					}
				}
			}
		}
		for (Symbol symbol : table.getSymbols(VttModel.SYMBOL_NAME)) {
			VttModel vtt = new VttModel(currentProgram, symbol.getAddress());
			if (!vtt.isValid()) {
				printerr(symbol.getParentNamespace().getName()+"'s vtt is invalid");
				continue;
			}
			DataType dt = vtt.getDataType();
			Data data = DataUtilities.createData(
				currentProgram, vtt.getAddress(), dt,
				dt.getLength(), false, CLEAR_ALL_CONFLICT_DATA);
			vttMap.put(vtt, data.getBytes());
		}
	}

	public static String byteArrayToHex(byte[] a) {
		StringBuilder sb = new StringBuilder(a.length * 2);
		for(byte b: a)
		   sb.append(String.format("%02x", b));
		return sb.toString();
	 }
}

```

`developer_scripts/svg_converter.py`:

```py
import argparse
from pathlib import Path
from PyQt5.QtCore import QSize # pylint: disable=no-name-in-module
from PyQt5.QtGui import QIcon, QImage # pylint: disable=no-name-in-module
from PyQt5.QtWidgets import QApplication # pylint: disable=no-name-in-module

parser = argparse.ArgumentParser()
parser.add_argument("input", help="input svg file", type=Path)
parser.add_argument("output", help="output png file", type=Path)
parser.add_argument("size", help="output image size (w,h)", nargs=2, type=int)

if __name__ == '__main__':
    args = parser.parse_args()
    assert args.input.exists(), "Input file does not exist"
    app = QApplication([])
    icon = QIcon(str(args.input))
    size = QSize(*args.size)
    pixmap = icon.pixmap(size)
    image = pixmap.toImage()
    image.save(str(args.output))

```

`extension.properties`:

```properties
name=Ghidra-Cpp-Class-Analyzer
description=Run Time Type Information and Class Analyzers
author=Andrew Strelsky <ajs222@njit.edu>
createdOn=6/2019
version=@extversion@

```

`ghidra_scripts/ClassReferences.java`:

```java
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2019-2020 Andrew J. Strelsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */
// Iterates through all vtable assignments and changes the assigned variable to
// the appropriate class datatype.
//@category CppClassAnalyzer
//@author Andrew J. Strelsky
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.Structure;
import ghidra.program.model.lang.Register;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Variable;
import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.ReferenceManager;
import ghidra.program.model.symbol.SourceType;

import cppclassanalyzer.script.CppClassAnalyzerGhidraScript;

public class ClassReferences extends CppClassAnalyzerGhidraScript {

	private int count;

	@Override
	public void run() throws Exception {
		println("This script is currently in development and may not function properly");

		count = 0;
		List<Vtable> vftables = currentManager.getVtableStream()
			.collect(Collectors.toList());
		monitor.setMessage("Setting variable datatypes");
		monitor.initialize(vftables.size());
		for (Vtable vtable : vftables) {
			monitor.checkCanceled();
			processVtable(vtable);
			monitor.incrementProgress(1);
		}
		println("Created "+Integer.toString(count)+" class variable references.");
	}

	private void processVtable(Vtable vtable) throws Exception {
		Address vtableAddress = vtable.getTableAddresses()[0];
		ReferenceManager manager = currentProgram.getReferenceManager();
		for (Reference ref : manager.getReferencesTo(vtableAddress)) {
			monitor.checkCanceled();
			if (manager.getReferencedVariable(ref) != null) {
				Variable var = manager.getReferencedVariable(ref);
				if (!(var.getDataType() instanceof Structure)) {
					var.setDataType(vtable.getTypeInfo().getClassDataType(),
									true, true, SourceType.ANALYSIS);
					count++;
					continue;
				}
			}
			ReferenceProcessor processor = new ReferenceProcessor(vtable, ref);
			processor.process();
		}
	}

	private class ReferenceProcessor {

		private final Vtable vtable;
		private Instruction inst;
		private Function function;

		ReferenceProcessor(Vtable vtable, Reference ref) {
			this.vtable = vtable;
			Listing listing = currentProgram.getListing();
			this.inst = listing.getInstructionAt(ref.getFromAddress());
			if (inst != null) {			
				this.function = listing.getFunctionContaining(inst.getAddress());
			}
		}

		void process() throws Exception {
			if (inst == null || function == null) {
				return;
			}
			ReferenceManager manager = currentProgram.getReferenceManager();
			Reference[] refs = inst.getReferencesFrom();
			Variable var = Arrays.stream(refs)
				.map(manager::getReferencedVariable)
				.filter(Objects::nonNull)
				.findFirst()
				.orElse(null);
			if (var != null) {
				DataType dt = vtable.getTypeInfo().getClassDataType();
				DataType varDt = var.getDataType();
				if (varDt.isEquivalent(dt) || varDt.dependsOn(dt)) {
					return;
				}
				var.setDataType(dt, true, true, SourceType.ANALYSIS);
				Address addr = var.getMinAddress();
				if (addr != null) {
					String msg = String.format(
						"Set variable %s at %s to %s",
						var, inst.getAddress(), dt.getDataTypePath());
					println(msg);
				}
				count++;
				return;
			}
		}
	}
}

```

`ghidra_scripts/DynamicCaster.java`:

```java
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2019-2020 Andrew J. Strelsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */
// Finds all calls to __dynamic_cast, determines the source and destination data types from the
// __class_type_info parameters and then generated a function signature override. This is extremely
// useful as it assists the decompiler's type propogation algorithm which cannot handle virtual classes.
//@category CppClassAnalyzer
//@author Andrew J. Strelsky
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionSignature;
import ghidra.program.model.pcode.DataTypeSymbol;
import ghidra.program.model.pcode.HighFunction;
import ghidra.program.model.pcode.Varnode;
import ghidra.program.model.symbol.*;
import ghidra.util.exception.InvalidInputException;

import cppclassanalyzer.decompiler.DecompilerAPI;
import cppclassanalyzer.decompiler.function.HighFunctionCall;
import cppclassanalyzer.decompiler.function.HighFunctionCallParameter;
import cppclassanalyzer.script.CppClassAnalyzerGhidraScript;

public class DynamicCaster extends CppClassAnalyzerGhidraScript {

	private static final String FORMAL_SIGNATURE =
		"void * __dynamic_cast(void * src_ptr, __class_type_info * src_type, "
		+"__class_type_info * dst_type, ptrdiff_t src2dst)";
	private static final String DYNAMIC_CAST = "__dynamic_cast";
	private static final String TMP_NAME = "tmpname";
	private static final String NAME_ROOT = "prt";
	private static final String AUTO_CAT = "/auto_proto";

	private SymbolTable table;
	private DataTypeManager dtm;
	private FunctionSignature sig;
	private DecompilerAPI api;
	private Function dynamicCast;

	@Override
	public void run() throws Exception {
		api = getService().getDecompilerAPI(currentProgram);
		api.setMonitor(monitor);
		table = currentProgram.getSymbolTable();
		dtm = currentProgram.getDataTypeManager();
		dynamicCast = getDynamicCast();
		if (dynamicCast == null) {
			return;
		}
		if (!dynamicCast.getPrototypeString(true, false).equals(FORMAL_SIGNATURE)) {
			printerr("The function at "+dynamicCast.getEntryPoint().toString()
					 +" doesnt match the cxxabi defined functions signature:\n"
					 +FORMAL_SIGNATURE);
			return;
		}
		sig = dynamicCast.getSignature();
		List<Function> functions =
			Arrays.stream(getReferencesTo(dynamicCast.getEntryPoint()))
			  .filter(DynamicCaster::isCall)
			  .map(Reference::getFromAddress)
			  .map(this::getFunctionContaining)
			  .filter(Objects::nonNull)
			  .distinct()
			  .collect(Collectors.toList());
		monitor.initialize(functions.size());
		monitor.setMessage("Analyzing __dynamic_cast calls");
		for (Function function : functions) {
			monitor.checkCanceled();
			doDynamicCast(function);
			monitor.incrementProgress(1);
		}
	}

	private Function getDynamicCast() {
		List<Function> functions = getGlobalFunctions(DYNAMIC_CAST);
		if (functions.size() > 1) {
			printerr("More than one __dynamic_cast function found.");
			return null;
		}
		if (functions.isEmpty()) {
			printerr("__dynamic_cast function not found");
			return null;
		}
		return functions.get(0);
	}

	private static boolean isCall(Reference r) {
		RefType type = r.getReferenceType();
		if (type.isCall()) {
			return !(type.isComputed() || type.isIndirect());
		}
		return false;
	}

	private void doDynamicCast(Function function) throws Exception {
		List<HighFunctionCall> calls = api.getFunctionCalls(function)
			.stream()
			.filter(f -> f.getFunction().equals(dynamicCast))
			.collect(Collectors.toList());
		for (HighFunctionCall call : calls) {
			monitor.checkCanceled();
			List<HighFunctionCallParameter> params = call.getParameters();
			Symbol srcSymbol = getSymbol(params.get(1));
			Symbol destSymbol = getSymbol(params.get(2));
			if (srcSymbol == null || destSymbol == null) {
				continue;
			}
			ClassTypeInfo srcType = currentManager.getType(srcSymbol.getAddress());
			ClassTypeInfo destType = currentManager.getType(destSymbol.getAddress());
			if (srcType != null && destType != null) {
				overrideFunction(function, call.getAddress(), srcType, destType);
			}
		}
	}

	private Symbol getSymbol(HighFunctionCallParameter param) {
		Varnode v = param.getVariableToken().getPcodeOp().getInput(1);
		if (v != null) {
			return v.getHigh()
				.getSymbol()
				.getSymbol();
		}
		return null;
	}

	private static ParameterDefinition getParameter(DataType dataType) {
		DataType dt = PointerDataType.getPointer(dataType, -1);
		return new ParameterDefinitionImpl(null, dt, null);
	}

	private FunctionDefinition getFunctionSignature(ClassTypeInfo src, ClassTypeInfo dest,
			Function function)throws Exception {
		FunctionDefinition def = new FunctionDefinitionDataType(sig);
		ParameterDefinition[] params = def.getArguments();
		params[0] = getParameter(src.getClassDataType());
		params[1] = getParameter(src.getDataType());
		params[2] = getParameter(dest.getDataType());
		def.setName(TMP_NAME);
		def.setArguments(params);
		def.setReturnType(dtm.getPointer(dest.getClassDataType()));
		return def;
	}

	private void overrideFunction(Function function, Address address,
			ClassTypeInfo src, ClassTypeInfo dest) throws Exception {
		FunctionDefinition def = getFunctionSignature(src, dest, function);
		if (def != null) {
			DataTypeSymbol symbol = new DataTypeSymbol(def, NAME_ROOT, AUTO_CAT);
			Namespace space = HighFunction.findCreateOverrideSpace(function);
			if (space != null) {
				try {
					symbol.writeSymbol(table, address, space, dtm, true);
				} catch (InvalidInputException e) {
					// already overridden
				}
			}
		}
	}
}

```

`ghidra_scripts/ResetVfTableScript.java`:

```java
//@category CppClassAnalyzer
import db.*;
import ghidra.app.script.GhidraScript;
import ghidra.program.database.ProgramDB;
import cppclassanalyzer.data.typeinfo.AbstractClassTypeInfoDB;
import cppclassanalyzer.data.vtable.AbstractVtableDB;
import cppclassanalyzer.database.record.ClassTypeInfoRecord;
import cppclassanalyzer.database.schema.fields.ClassTypeInfoSchemaFields;

public class ResetVfTableScript extends GhidraScript {

	private static final String TYPE_TABLE_NAME =
		AbstractClassTypeInfoDB.CLASS_TYPEINFO_TABLE_NAME;
	private static final String VTABLE_TABLE_NAME =
		AbstractVtableDB.VTABLE_TABLE_NAME;

	@Override
	public void run() throws Exception {
		DBHandle handle = ((ProgramDB) currentProgram).getDBHandle();
		synchronized(handle) {
			if (handle.getTable(VTABLE_TABLE_NAME) != null) {
				handle.getTable(VTABLE_TABLE_NAME).deleteAll();
			}
			Table table = handle.getTable(TYPE_TABLE_NAME);
			if (table != null) {
				RecordIterator it = table.iterator();
				while (it.hasNext()) {
					ClassTypeInfoRecord record = new ClassTypeInfoRecord(it.next());
					record.setLongValue(ClassTypeInfoSchemaFields.VTABLE_KEY, -1);
					record.setBooleanValue(ClassTypeInfoSchemaFields.VTABLE_SEARCHED, false);
					table.putRecord(record.getRecord());
				}
			}
		}
		println("Vtables reset. Please close and reopen the program.");
	}
}

```

`ghidra_scripts/ShowClassTreeGraph.java`:

```java
// Given a class name, render a graph with the entire class hierarchy (all supertypes and subtypes).
// @category CppClassAnalyzer
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.script.CppClassAnalyzerGhidraScript;
import docking.widgets.EventTrigger;
import ghidra.GhidraException;
import ghidra.app.services.GraphDisplayBroker;
import ghidra.framework.plugintool.PluginTool;
import ghidra.service.graph.AttributedGraph;
import ghidra.service.graph.AttributedVertex;
import ghidra.service.graph.GraphDisplay;

import java.util.*;

public class ShowClassTreeGraph extends CppClassAnalyzerGhidraScript {

	@Override
	protected void run() throws Exception {
		String typeName = askString("Class name", "Enter name of the class to print the class tree of");
		ClassTypeInfoDB type = currentManager.getTypeStream()
			.filter(ty -> typeName.equalsIgnoreCase(ty.getName()))
			.findFirst()
			.orElseThrow(() -> new GhidraException("No type found with given name"));

		monitor.setMessage("Generating class tree graph");

		PluginTool tool = getState().getTool();
		GraphDisplayBroker service = tool.getService(GraphDisplayBroker.class);
		GraphDisplay display = service.getDefaultGraphDisplay(false, monitor);
		Map<Long, AttributedVertex> vertices = new HashMap<>();

		AttributedGraph graph = new AttributedGraph();
		AttributedVertex typeVertex = graph.addVertex(type.getFullName());
		vertices.put(type.getClassDataTypeId(), typeVertex);

		Set<Long> subtypes = new HashSet<>();
		subtypes.add(type.getClassDataTypeId());

		while (!subtypes.isEmpty()) {
			Set<Long> currentParents = new HashSet<>(subtypes);
			subtypes.clear();

			for (ClassTypeInfoDB candidate : currentManager.getTypes()) {
				for (ClassTypeInfoDB parent : candidate.getParentModels()) {
					if (monitor.isCancelled()) {
						return;
					}

					long parentId = parent.getClassDataTypeId();

					if (currentParents.contains(parentId)) {
						subtypes.add(candidate.getClassDataTypeId());
						AttributedVertex vertex = graph.addVertex(candidate.getFullName());

						vertices.put(candidate.getClassDataTypeId(), vertex);
						graph.addEdge(vertices.get(parentId), vertex);
					}
				}
			}
		}

		Deque<ClassTypeInfoDB> supertypes = new ArrayDeque<>();
		supertypes.push(type);

		while (!supertypes.isEmpty()) {
			ClassTypeInfoDB supertype = supertypes.pop();
			AttributedVertex vertex = vertices.computeIfAbsent(supertype.getClassDataTypeId(),
				(key) -> new AttributedVertex(supertype.getFullName()));

			for (ClassTypeInfoDB parent : supertype.getParentModels()) {
				if (monitor.isCancelled()) {
					return;
				}

				AttributedVertex parentVertex = vertices.computeIfAbsent(parent.getClassDataTypeId(),
					(key) -> new AttributedVertex(parent.getFullName()));

				supertypes.push(parent);
				graph.addEdge(parentVertex, vertex);
			}
		}

		display.setGraph(graph, "Class Tree", false, monitor);
		display.selectVertices(Set.of(typeVertex), EventTrigger.MODEL_CHANGE);
	}
}

```

`src/main/java/cppclassanalyzer/analysis/AbstractCppClassAnalyzer.java`:

```java
package cppclassanalyzer.analysis;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.app.cmd.data.rtti.gcc.VtableUtils;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.TypeInfoModel;
import ghidra.app.services.AbstractAnalyzer;
import ghidra.app.services.AnalyzerType;
import ghidra.app.util.importer.MessageLog;
import ghidra.framework.options.Options;
import ghidra.program.model.address.AddressSetView;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.*;
import ghidra.util.exception.*;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.analysis.cmd.AbstractConstructorAnalysisCmd;
import cppclassanalyzer.cmd.ApplyVtableDefinitionsBackgroundCmd;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.AbstractClassTypeInfoDB;
import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.vtable.ArchivedVtable;
import cppclassanalyzer.decompiler.DecompilerAPI;
import cppclassanalyzer.service.ClassTypeInfoManagerService;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

public abstract class AbstractCppClassAnalyzer extends AbstractAnalyzer {

	private static final String DESCRIPTION =
		"This analyzer analyzes RTTI metadata to recreate classes and their functions";

	private static final String OPTION_VTABLE_ANALYSIS_NAME = "Locate Constructors";
	private static final boolean OPTION_DEFAULT_VTABLE_ANALYSIS = false;
	private static final String OPTION_VTABLE_ANALYSIS_DESCRIPTION =
		"Turn on to search for Constructors/Destructors.\n" +
		"WARNING: This can take a SIGNIFICANT Amount of Time!\n" +
		"         Turned off by default" + "\n";

	private static final String OPTION_ARCHIVED_DATA_NAME = "Use Archived RTTI Data";
	private static final boolean OPTION_DEFAULT_ARCHIVED_DATA = true;
	private static final String OPTION_ARCHIVED_DATA_DESCRIPTION =
		"Use open archives to apply virtual function definitions and structures.\n"
		+ "This will replace previously defined structures and function definitions.";

	private static final String OPTION_NAME_DECOMPILER_TIMEOUT_SECS =
		"Analysis Decompiler Timeout (sec)";
	private static final String OPTION_DESCRIPTION_DECOMPILER_TIMEOUT_SECS =
		"Set timeout in seconds for analyzer decompiler calls.";
	private static final int OPTION_DEFAULT_DECOMPILER_TIMEOUT_SECS = 30;

	private boolean constructorAnalysisOption;
	private boolean useArchivedData;
	private int decompilerTimeout;

	protected Program program;
	protected TaskMonitor monitor;

	private ProgramClassTypeInfoManager manager;

	protected AbstractConstructorAnalysisCmd constructorAnalyzer;

	protected MessageLog log;

	/**
	 * Constructs an AbstractCppClassAnalyzer.
	 *
	 * @param name The name of the analyzer
	 *
	 */
	public AbstractCppClassAnalyzer(String name) {
		super(name, DESCRIPTION, AnalyzerType.BYTE_ANALYZER);
		setSupportsOneTimeAnalysis();
		setDefaultEnablement(true);
		setPrototype();
	}

	@Override
	public boolean canAnalyze(Program program) {
		return CppClassAnalyzerUtils.getManager(program) != null;
	}

	protected abstract boolean hasVtt();
	protected abstract void init();
	protected abstract boolean analyzeVftable(ClassTypeInfo type);
	protected abstract boolean analyzeConstructor(ClassTypeInfo type);
	protected abstract boolean isDestructor(Function function);

	@Override
	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
			throws CancelledException {
		this.program = program;
		this.monitor = monitor;
		this.log = log;
		this.manager = CppClassAnalyzerUtils.getManager(program);
		if (manager == null) {
			return false;
		}
		init();
		if (manager == null) {
			return false;
		}
		try {
			if (manager == null) {
				return false;
			}
			repairInheritance();
			analyzeVftables();
			return true;
		} catch (CancelledException e) {
			throw e;
		} catch (Exception e) {
			e.printStackTrace();
			log.appendException(e);
			return false;
		}
	}

	@Override
	public void analysisEnded(Program program) {
		manager = null;
		constructorAnalyzer = null;
		super.analysisEnded(program);
	}

	private void repairInheritance() throws CancelledException, InvalidDataTypeException {
		ClassTypeInfoManagerService service = getService();
		monitor.initialize(manager.getTypeCount());
		monitor.setMessage("Fixing Class Inheritance...");
		for (ClassTypeInfo type : manager.getTypes()) {
			monitor.checkCanceled();
			if (type.getName().contains(TypeInfoModel.STRUCTURE_NAME)) {
				// this works for both vs and gcc
				monitor.incrementProgress(1);
				continue;
			}
			if (useArchivedData) {
				String symbolName = TypeInfoUtils.getSymbolName(type);
				ArchivedClassTypeInfo data = service.getArchivedClassTypeInfo(symbolName);
				if (data != null) {
					((AbstractClassTypeInfoDB) type).setClassDataType(data.getClassDataType());
					monitor.incrementProgress(1);
					continue;
				}
			}
			// this takes care of everything
			try {
				type.getClassDataType();
			} catch (Exception e) {
				log.appendException(e);
			}
			monitor.incrementProgress(1);
		}
	}

	protected void analyzeVftables() throws Exception {
		ClassTypeInfoManagerService service = getService();
		monitor.initialize(manager.getVtableCount());
		monitor.setMessage("Analyzing Vftables");
		for (Vtable vtable : manager.getVtables()) {
			monitor.checkCanceled();
			if (useArchivedData) {
				ArchivedVtable data =
					service.getArchivedVtable(VtableUtils.getSymbolName(vtable));
				if (data != null) {
					ApplyVtableDefinitionsBackgroundCmd cmd =
						new ApplyVtableDefinitionsBackgroundCmd(vtable, data);
					if (!cmd.applyTo(program, monitor)) {
						monitor.checkCanceled();
					}
					monitor.incrementProgress(1);
					continue;
				}
			}
			analyzeVftable(vtable.getTypeInfo());
			monitor.incrementProgress(1);
		}
		if (constructorAnalysisOption) {
			analyzeConstructors();
		}
	}

	protected boolean shouldAnalyzeConstructors() {
		return constructorAnalysisOption;
	}

	protected boolean shouldUseArchivedData() {
		return useArchivedData;
	}

	protected void analyzeConstructors() throws Exception {
		monitor.initialize(manager.getVtableCount());
		monitor.setMessage("Creating Constructors");
		for (Vtable vtable : manager.getVtableIterable(true)) {
			monitor.checkCanceled();
			analyzeConstructor(vtable.getTypeInfo());
			monitor.incrementProgress(1);
		}
		clearCache();
	}

	protected static DecompilerAPI getDecompilerAPI(Program program) {
		return CppClassAnalyzerUtils.getService(program).getDecompilerAPI(program);
	}

	private void clearCache() {
		getDecompilerAPI(program).clearCache();
	}

	protected int getTimeout() {
		return decompilerTimeout;
	}

	@Override
	public void registerOptions(Options options, Program program) {
		options.registerOption(OPTION_VTABLE_ANALYSIS_NAME, OPTION_DEFAULT_VTABLE_ANALYSIS, null,
			OPTION_VTABLE_ANALYSIS_DESCRIPTION);
		options.registerOption(OPTION_ARCHIVED_DATA_NAME, OPTION_DEFAULT_ARCHIVED_DATA, null,
			OPTION_ARCHIVED_DATA_DESCRIPTION);
		options.registerOption(OPTION_NAME_DECOMPILER_TIMEOUT_SECS,
			OPTION_DEFAULT_DECOMPILER_TIMEOUT_SECS, null,
			OPTION_DESCRIPTION_DECOMPILER_TIMEOUT_SECS);
	}

	@Override
	public void optionsChanged(Options options, Program program) {
		constructorAnalysisOption =
			options.getBoolean(OPTION_VTABLE_ANALYSIS_NAME, OPTION_DEFAULT_VTABLE_ANALYSIS);
		useArchivedData =
			options.getBoolean(OPTION_ARCHIVED_DATA_NAME, OPTION_DEFAULT_ARCHIVED_DATA);
		decompilerTimeout =
			options.getInt(OPTION_NAME_DECOMPILER_TIMEOUT_SECS,
			OPTION_DEFAULT_DECOMPILER_TIMEOUT_SECS);
	}

	private ClassTypeInfoManagerService getService() {
		return CppClassAnalyzerUtils.getService(program);
	}

}

```

`src/main/java/cppclassanalyzer/analysis/cmd/AbstractConstructorAnalysisCmd.java`:

```java
package cppclassanalyzer.analysis.cmd;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import cppclassanalyzer.utils.ConstantPropagationUtils;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils;
import ghidra.framework.cmd.BackgroundCommand;
import ghidra.framework.model.DomainObject;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSetView;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.GenericCallingConvention;
import ghidra.program.model.lang.Register;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.*;
import ghidra.program.util.SymbolicPropogator;
import ghidra.util.Msg;
import ghidra.util.datastruct.IntSet;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

public abstract class AbstractConstructorAnalysisCmd extends BackgroundCommand {

	protected ClassTypeInfo type = null;
	protected Program program;
	protected TaskMonitor monitor;
	protected FunctionManager fManager;
	protected ReferenceManager manager;
	protected Listing listing;

	protected AbstractConstructorAnalysisCmd(String name) {
		super(name, false, true, false);
	}

	public AbstractConstructorAnalysisCmd(String name, ClassTypeInfo typeinfo) {
		this(name);
		this.type = typeinfo;
	}

	@Override
	public boolean applyTo(DomainObject obj, TaskMonitor taskMonitor) {
		if (!(obj instanceof Program)) {
			String message = "Can only apply a constructor to a program.";
			Msg.error(this, message);
			return false;
		}
		this.program = (Program) obj;
		this.monitor = taskMonitor;
		this.listing = program.getListing();
		this.fManager = program.getFunctionManager();
		this.manager = program.getReferenceManager();
		try {
			// TODO follow calls to new to pick up simpler constructors first
			return analyze();
		} catch (CancelledException e) {
			return false;
		} catch (Exception e) {
			e.printStackTrace();
			Msg.trace(this, e);
			return false;
		}
	}

	protected abstract boolean analyze() throws Exception;

	public void setTypeInfo(ClassTypeInfo typeinfo) {
		this.type = typeinfo;
	}

	protected boolean isProcessed(Address address) {
		Function function = fManager.getFunctionContaining(address);
		return !CppClassAnalyzerUtils.isDefaultFunction(function);
	}

	protected void setDestructor(ClassTypeInfo typeinfo, Function function) throws Exception {
		setFunction(typeinfo, function, true);
		if (function.isThunk()) {
			setFunction(typeinfo, function.getThunkedFunction(false), true);
		}
	}

	protected Function createConstructor(ClassTypeInfo typeinfo, Address address) throws Exception {
		Function function = fManager.getFunctionContaining(address);
		if (function != null && !CppClassAnalyzerUtils.isDefaultFunction(function)) {
			if (function.getName().equals(typeinfo.getName())) {
				return function;
			}
		} else if (function != null) {
			function = ClassTypeInfoUtils.getClassFunction(
				program, typeinfo, function.getEntryPoint());
		} else {
			function = ClassTypeInfoUtils.getClassFunction(program, typeinfo, address);
		}
		setFunction(typeinfo, function, false);
		createSubConstructors(typeinfo, function, false);
		return function;
	}

	protected boolean isConstructor(ClassTypeInfo typeinfo, Address address) {
		Function function = fManager.getFunctionContaining(address);
		if (function != null && function.getName().equals(typeinfo.getName())) {
			return true;
		}
		return false;
	}

	protected void setFunction(ClassTypeInfo typeinfo, Function function, boolean destructor)
			throws Exception {
		String name = destructor ? "~"+typeinfo.getName() : typeinfo.getName();
		function.setName(name, SourceType.IMPORTED);
		function.setParentNamespace(typeinfo.getGhidraClass());
		function.setCallingConvention(GenericCallingConvention.thiscall.getDeclarationName());
		CppClassAnalyzerUtils.setConstructorDestructorTag(function, !destructor);
	}

	protected void createSubConstructors(ClassTypeInfo type, Function constructor,
		boolean destructor) throws Exception {
			if (constructor.getParameter(0).isStackVariable()) {
				// TODO Need to figure out how to handle stack parameters
				return;
			}
			ConstructorAnalyzerHelper helper = new ConstructorAnalyzerHelper(type, constructor);
			SymbolicPropogator symProp = analyzeFunction(constructor);
			Register thisReg = getThisRegister(constructor.getParameter(0));
			for (Address address : helper.getCalledFunctionAddresses()) {
				monitor.checkCanceled();
				Instruction inst = listing.getInstructionAt(address);
				int delayDepth = inst.getDelaySlotDepth();
				if (delayDepth > 0) {
					while (inst.isInDelaySlot()) {
						monitor.checkCanceled();
						inst = inst.getNext();
					}
				}
				SymbolicPropogator.Value value =
					symProp.getRegisterValue(inst.getAddress(), thisReg);
				if (value == null || !helper.isValidOffset((int) value.getValue())) {
					continue;
				}
				ClassTypeInfo parent = helper.getParentAt((int) value.getValue());
				Function function = getCalledFunction(address);
				if (destructor) {
					setDestructor(parent, function);
				} else {
					createConstructor(parent, function.getEntryPoint());
				}
			}
	}

	private Function getCalledFunction(Address address) {
		Instruction inst = listing.getInstructionAt(address);

		// If it didn't this doesn't get reached
		Address target = inst.getReferencesFrom()[0].getToAddress();
		return listing.getFunctionAt(target);
	}

	private Register getThisRegister(Parameter param) {
		if (param.getAutoParameterType() == AutoParameterType.THIS) {
			return param.getRegister();
		}
		return null;
	}

	protected SymbolicPropogator analyzeFunction(Function function) throws CancelledException {
		return ConstantPropagationUtils.analyzeFunction(function, monitor);
	}

	protected static class ConstructorAnalyzerHelper {

		private final ClassTypeInfo type;
		private final Function function;
		private final IntSet offsets;

		protected ConstructorAnalyzerHelper(ClassTypeInfo type, Function function) {
			this.type = type;
			this.function = function;
			this.offsets = new IntSet(type.getParentModels().length);
			DataTypeComponent[] comps = type.getClassDataType().getDefinedComponents();
			Arrays.stream(comps)
				.filter(c -> c.getFieldName().contains("super_"))
				.mapToInt(DataTypeComponent::getOffset)
				.forEach(offsets::add);
		}

		protected List<Address> getCalledFunctionAddresses() {
			AddressSetView body = function.getBody();
			return function.getCalledFunctions(TaskMonitor.DUMMY)
				.stream()
				.filter(CppClassAnalyzerUtils::isDefaultFunction)
				.map(Function::getSymbol)
				.map(Symbol::getReferences)
				.flatMap(Arrays::stream)
				.map(Reference::getFromAddress)
				.filter(body::contains)
				.collect(Collectors.toList());
		}

		protected boolean isValidOffset(int offset) {
			return offsets.contains(offset);
		}

		protected ClassTypeInfo getParentAt(int offset) {
			if (!offsets.contains(offset)) {
				return null;
			}
			offsets.remove(offset);
			String name = type.getClassDataType()
				.getComponentAt(offset)
				.getFieldName()
				.replace("super_", "");
			return Arrays.stream(type.getParentModels())
				.filter(t -> t.getName().equals(name))
				.findFirst()
				.orElse(null);
		}
	}

}

```

`src/main/java/cppclassanalyzer/analysis/cmd/AbstractDecompilerBasedConstructorAnalysisCmd.java`:

```java
package cppclassanalyzer.analysis.cmd;

import java.util.*;
import java.util.stream.Collectors;

import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.decompiler.DecompilerAPI;
import cppclassanalyzer.decompiler.function.HighFunctionCall;
import cppclassanalyzer.decompiler.function.HighFunctionCallParameter;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Function;
import ghidra.program.model.pcode.*;
import ghidra.program.model.symbol.Reference;
import ghidra.util.exception.AssertException;
import util.CollectionUtils;

public abstract class AbstractDecompilerBasedConstructorAnalysisCmd
		extends AbstractConstructorAnalysisCmd {

	private final DecompilerAPI api;

	protected AbstractDecompilerBasedConstructorAnalysisCmd(String name, DecompilerAPI api) {
		super(name);
		this.api = api;
	}

	protected AbstractDecompilerBasedConstructorAnalysisCmd(String name, ClassTypeInfo typeinfo,
			DecompilerAPI api) {
		super(name, typeinfo);
		this.api = api;
	}

	@Override
	protected boolean analyze() throws Exception {
		if (!type.hasParent()) {
			return false;
		}
		Vtable vtable = type.getVtable();
		if (!Vtable.isValid(vtable)) {
			return false;
		}
		for (ClassFunction function : getFunctions()) {
			monitor.checkCanceled();
			if (function.function.isThunk()) {
				continue;
			}
			boolean success = false;
			try {
				HighFunction hf = api.getHighFunction(function.function);
				if (hf == null) {
					// timed out
					continue;
				}
				LocalSymbolMap map = hf.getLocalSymbolMap();
				if (map.getNumParams() == 0) {
					continue;
				}
				HighParam thisParam = map.getParam(0);
				List<HighFunctionCall> statements = api.getFunctionCalls(function.function);
				if (type.getParentModels().length >= statements.size()) {
					continue;
				}
				if (function.isDestructor()) {
					success = processDestructor(thisParam, function.getFunction(), statements);
				} else {
					success = processConstructor(thisParam, function.getFunction(), statements);
				}
			} finally {
				if (success) {
					setFunction(type, function.function, function.isDestructor());
				}
			}
		}
		return true;
	}

	private boolean processDestructor(HighParam thisParam, Function function,
			List<HighFunctionCall> calls) throws Exception {
		// The in-charge destructor must end with all
		// parents destructors + return. No exceptions.
		ClassTypeInfo[] parents = type.getParentModels();
		int end = calls.size() - 1;
		int start = end - parents.length;
		List<HighFunctionCall> destructorCalls = calls.subList(start, end);
		boolean hasExternal = destructorCalls.stream()
			.map(HighFunctionCall::getFunction)
			.anyMatch(Function::isExternal);
		if (hasExternal) {
			return false;
		}
		return setFunctions(thisParam, destructorCalls, false);
	}

	private static boolean isExternalFunction(Function f) {
		if (f.isThunk()) {
			f = f.getThunkedFunction(true);
		}
		return f.isExternal();
	}

	private boolean processConstructor(HighParam thisParam, Function function,
			List<HighFunctionCall> calls) throws Exception {
		// The in-charge constructor must start with all
		// parents constructors. No exceptions.
		ClassTypeInfo[] parents = type.getParentModels();
		int start = 0;
		int end = parents.length;
		List<HighFunctionCall> constructorCalls = calls.subList(start, end);
		boolean hasExternal = constructorCalls.stream()
			.map(HighFunctionCall::getFunction)
			.anyMatch(AbstractDecompilerBasedConstructorAnalysisCmd::isExternalFunction);
		if (hasExternal) {
			return false;
		}
		return setFunctions(thisParam, constructorCalls, true);
	}

	private boolean setFunctions(HighParam thisParam, List<HighFunctionCall> calls,
			boolean isConstructor) throws Exception {
		for (HighFunctionCall call : calls) {
			List<HighFunctionCallParameter> params = call.getParameters();
			if (params.isEmpty()) {
				return false;
			}
			HighFunctionCallParameter self = params.get(0);
			if (!self.hasLocalRef()) {
				return false;
			}
			HighVariable var = self.getVariableToken().getHighVariable();
			if (var == null || !var.equals(thisParam)) {
				return false;
			}
			final int offset;
			if (self.hasFieldToken()) {
				offset = self.getOffset() + self.getFieldToken().getOffset();
			} else {
				offset = self.getOffset();
			}
			//var.
			//FunctionCallParser parser = new FunctionCallParser(statement);
			//Function fun = parser.getCalledFunction();
			//ClassTypeInfo parent = parser.getParentParameter();
			ClassTypeInfo parent = ((ClassTypeInfoDB) type).getBaseOffsets()
				.entrySet()
				.stream()
				.filter(e -> e.getValue().intValue() == offset)
				.findFirst()
				.map(Map.Entry::getKey)
				.orElse(null);
			if (parent == null) {
				return false;
			}
			Function fun = call.getFunction();
			if (fun.isThunk()) {
				fun = fun.getThunkedFunction(true);
			}
			setFunction(parent, fun, !isConstructor);
		}
		return true;
	}

	private List<ClassFunction> getFunctions() {
		Vtable vtable = type.getVtable();
		if (!Vtable.isValid(vtable)) {
			return Collections.emptyList();
		}
		Address[] tableAddresses = vtable.getTableAddresses();
		if (tableAddresses.length == 0) {
			// no virtual functions, nothing to analyze.
			return Collections.emptyList();
		}
		Data data = listing.getDataContaining(tableAddresses[0]);
		if (data == null) {
			String msg = String.format(
				"Vtable data for %s at %s has been deleted",
				type.getFullName(),
				tableAddresses[0]);
			throw new AssertException(msg);
		}
		return CollectionUtils.asStream(data.getReferenceIteratorTo())
			.filter(r -> r.getReferenceType().isData())
			.map(Reference::getFromAddress)
			.map(listing::getFunctionContaining)
			.filter(Objects::nonNull)
			.filter(CppClassAnalyzerUtils::isDefaultFunction)
			.map(f -> new ClassFunction(f, vtable.containsFunction(f)))
			.collect(Collectors.toList());
	}

	public void setDecompilerTimeout(int timeout) {
		api.setTimeout(timeout);
	}

	protected static class ClassFunction {

		private final Function function;
		private final boolean isDestructor;

		public ClassFunction(Function function, boolean isDestructor) {
			this.function = function;
			this.isDestructor = isDestructor;
		}

		protected Function getFunction() {
			return function;
		}

		protected boolean isDestructor() {
			return isDestructor;
		}
	}
}

```

`src/main/java/cppclassanalyzer/analysis/gcc/GccConstructorAnalysisCmd.java`:

```java
package cppclassanalyzer.analysis.gcc;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils;
import ghidra.app.cmd.data.rtti.gcc.VttModel;
import ghidra.app.cmd.function.AddParameterCommand;
import ghidra.app.util.XReferenceUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.VoidDataType;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.Parameter;
import ghidra.program.model.listing.ParameterImpl;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.symbol.RefType;
import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.Msg;

import cppclassanalyzer.analysis.cmd.AbstractConstructorAnalysisCmd;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

public class GccConstructorAnalysisCmd extends AbstractConstructorAnalysisCmd {

	private static final String NAME = GccConstructorAnalysisCmd.class.getSimpleName();
	private static final String VTT_PARAM_NAME = "vttParam";

	private VttModel vtt = null;

	GccConstructorAnalysisCmd() {
		super(NAME);
	}

	public GccConstructorAnalysisCmd(VttModel vtt) {
		this();
		this.vtt = vtt;
		this.type = vtt.getVtableModel(0).getTypeInfo();
	}

	public GccConstructorAnalysisCmd(ClassTypeInfo typeinfo) {
		this();
		this.type = typeinfo;
	}

	@Override
	public void setTypeInfo(ClassTypeInfo typeinfo) {
		this.type = typeinfo;
		this.vtt = null;
	}

	public void setVtt(VttModel vtt) {
		this.vtt = vtt;
		this.type = vtt.getVtableModel(0).getTypeInfo();
	}

	private Address getCalledFunctionAddress(Address fromAddress) {
		Instruction instr = listing.getInstructionAt(fromAddress);
		while (!instr.getFlowType().isCall()) {
			if (monitor.isCancelled()) {
				return Address.NO_ADDRESS;
			}
			instr = instr.getNext();
		}
		return instr.getFlows()[0];
	}

	private boolean isInherited(ClassTypeInfo typeinfo, Namespace ns)
			throws InvalidDataTypeException {
		for (ClassTypeInfo parent : typeinfo.getParentModels()) {
			if (ns.equals(parent.getGhidraClass())) {
				return true;
			}
		}
		return false;
	}

	private void detectVirtualDestructors(Set<Address> addresses, Vtable vtable) throws Exception {
		Function[][] fTable = vtable.getFunctionTables();
		if (fTable.length == 0 || fTable[0].length == 0 || fTable[0][0] == null) {
			return;
		} else if (fTable[0][0].getName().equals(vtable.getTypeInfo().getName())) {
			// if this was marked as a constructor fix it
			fTable[0][0].removeTag(CppClassAnalyzerUtils.CONSTRUCTOR);
			createVirtualDestructors(vtable.getTypeInfo());
			return;
		}
		// The function must make a reference to the vtable
		for (Instruction inst : listing.getInstructions(fTable[0][0].getBody(), true)) {
			for (Reference ref : inst.getReferencesFrom()) {
				if (addresses.contains(ref.getToAddress())) {
					createVirtualDestructors(vtable.getTypeInfo());
					return;
				}
			}
		}
	}

	private void addAddresses(Set<Address> addresses, Collection<ClassTypeInfo> parents) {
		for (ClassTypeInfo parent : parents) {
			addAddresses(addresses, List.of(parent.getParentModels()));
			addAddresses(addresses, parent.getVirtualParents());
			Vtable parentVtable = parent.getVtable();
			if (parentVtable != Vtable.NO_VTABLE) {
				addresses.addAll(List.of(parentVtable.getTableAddresses()));
			}
		}
	}

	private boolean analyzeVtable(Vtable vtable) throws Exception {
		Address[] tableAddresses = vtable.getTableAddresses();
		if (tableAddresses.length == 0) {
			// no virtual functions, nothing to analyze.
			return true;
		}
		Data data = listing.getDataContaining(tableAddresses[0]);
		if (data == null) {
			return false;
		}
		ClassTypeInfo typeinfo = vtable.getTypeInfo();
		List<Reference> references = XReferenceUtils.getOffcutXReferences(data, -1);
		Collections.reverse(references);
		Set<Address> addresses = new HashSet<>(List.of(tableAddresses));
		addAddresses(addresses, List.of(typeinfo.getParentModels()));
		addAddresses(addresses, typeinfo.getVirtualParents());
		detectVirtualDestructors(addresses, vtable);
		for (Reference reference : references) {
			if (monitor.isCancelled()) {
				return false;
			}
			Address fromAddress = reference.getFromAddress();
			if (!fManager.isInFunction(fromAddress)) {
				continue;
			}
			if (isProcessed(fromAddress)) {
				Function function = fManager.getFunctionContaining(fromAddress);
				if (function != null && !function.getParentNamespace().isGlobal()) {
					Namespace ns = function.getParentNamespace();
					if (!(ns.equals(typeinfo.getGhidraClass()) || isInherited(typeinfo, ns))) {
						return true;
					}
					continue;
				}
			} else {
				try {
					if (reference.getReferenceType().equals(RefType.PARAM)) {
						Address calledAddress = getCalledFunctionAddress(fromAddress);
						if (!calledAddress.equals(Address.NO_ADDRESS)) {
							createConstructor(typeinfo, calledAddress, vtt != null);
						}
					} else if (reference.getReferenceType().isData()) {
						if (isValidConstructor(fromAddress, reference)) {
							createConstructor(typeinfo, fromAddress, false);
						}
					}
				} catch (Exception e) {
					e.printStackTrace();
					Msg.trace(this, e);
				}
			}
		}
		return true;
	}

	private boolean isValidConstructor(Address address, Reference ref) {
		Function function = fManager.getFunctionContaining(address);
		Instruction inst = listing.getInstructionAt(function.getEntryPoint());
		while (function.getBody().contains(inst.getAddress())) {
			Reference[] references = inst.getReferencesFrom();
			if (references.length > 0) {
				for (Reference instRef : references) {
					if (instRef.getFromAddress().equals(inst.getAddress())) {
						return instRef.equals(ref);
					}
				}
			}
			if (inst.getFlowType().isFlow()) {
				for (int i = 0; i < inst.getDelaySlotDepth(); i++) {
					inst = inst.getNext();
					references = inst.getReferencesFrom();
					if (references.length > 0) {
						for (Reference instRef : references) {
							if (instRef.getFromAddress().equals(inst.getAddress())) {
								return instRef.equals(ref);
							}
						}
					}
				}
				return false;
			}
			inst = inst.getNext();
		}
		return false;
	}

	private boolean createFromVttModel() throws Exception {
		Address address = vtt.getAddress();
		Vtable vtable = vtt.getVtableModel(0);
		Function[][] fTables = vtable.getFunctionTables();
		if (fTables.length == 0 || fTables[0].length == 0 || fTables[0][0] == null) {
			return false;
		}
		for (int i = 0; i < vtt.getElementCount(); i++) {
			for (Reference reference : manager.getReferencesTo(address)) {
				if (isFunctionReference(reference)) {
					Function function = fManager.getFunctionContaining(reference.getFromAddress());
					if (fTables[0][0].equals(function)) {
						createVirtualDestructors(type);
					} else if (!CppClassAnalyzerUtils.isDestructor(function)) {
						createConstructor(type, function.getEntryPoint());
					}
				}
			}
			address = address.add(program.getDefaultPointerSize());
		}
		address = vtt.getAddress();
		for (int i = 0; i < vtt.getElementCount(); i++) {
			ClassTypeInfo baseType = vtt.getTypeInfo(i);
			if (!baseType.equals(type)) {
				for (Reference reference : manager.getReferencesTo(address)) {
					if (isFunctionReference(reference)) {
						if (reference.getReferenceType().equals(RefType.PARAM)) {
							Address fromAddress = reference.getFromAddress();
							Function caller = fManager.getFunctionContaining(fromAddress);
							if (caller == null || !caller.getParentNamespace().equals(
								type.getGhidraClass())) {
									continue;
							}
							Address calleeAddress = getCalledFunctionAddress(fromAddress);
							if (!calleeAddress.equals(Address.NO_ADDRESS)) {
								Function callee = ClassTypeInfoUtils.getClassFunction(
									program, baseType, calleeAddress);
								setFunction(
									baseType, callee, CppClassAnalyzerUtils.isDestructor(caller));
								setVttParam(callee, baseType);
							}
						}
					}
				}
			}
			address = address.add(program.getDefaultPointerSize());
		}
		return true;
	}

	private boolean isFunctionReference(Reference ref) {
		if (ref.isEntryPointReference()) {
			return false;
		}
		return program.getMemory().getBlock(ref.getFromAddress()).isExecute();
	}

	private void createConstructor(ClassTypeInfo typeinfo, Address address, boolean vttParam)
		throws Exception {
			Function function = createConstructor(typeinfo, address);
			createSubConstructors(typeinfo, function, false);
	}

	private void setVttParam(Function function, ClassTypeInfo typeinfo) {
		DataTypeManager dtm = program.getDataTypeManager();
		DataType vpp = dtm.getPointer(dtm.getPointer(VoidDataType.dataType));
		try {
			if (function.getParameterCount() == 1) {
				ParameterImpl param = new ParameterImpl(VTT_PARAM_NAME, vpp, program);
				AddParameterCommand cmd = new AddParameterCommand(function, param, 1, SourceType.ANALYSIS);
				cmd.applyTo(program);
			} else {
				Parameter param = function.getParameter(1);
				param.setName(VTT_PARAM_NAME, SourceType.IMPORTED);
				param.setDataType(vpp, SourceType.IMPORTED);
			}
		} catch (Exception e) {
			e.printStackTrace();
			Msg.trace(this, e);
		}
	}

	private void createVirtualDestructors(ClassTypeInfo typeinfo) throws Exception {
		Vtable vtable = typeinfo.getVtable();
		Function[][] functionTables = vtable.getFunctionTables();
		for (int i = 0; i < functionTables.length; i++) {
			for (int j = 0; j < functionTables[i].length && j < 2; j++) {
				Address address = functionTables[i][j].getEntryPoint();
				if (i == 0) {
					Function function = ClassTypeInfoUtils.getClassFunction(program, typeinfo, address);
					if (CppClassAnalyzerUtils.isDestructor(function)) {
						return;
					}
					setFunction(typeinfo, function, true);
				} else {
					functionTables[i][j].setThunkedFunction(functionTables[0][j]);
					try {
						functionTables[i][j].setParentNamespace(typeinfo.getGhidraClass());
					} catch (Exception e) {
						Msg.error(this, "Failed to set function namespace at "
										+ functionTables[i][j].getEntryPoint(), e);
					}
				}
			}
		}
	}

	@Override
	protected boolean analyze() throws Exception {
		try {
			return vtt != null ? createFromVttModel() : analyzeVtable(type.getVtable());
		} catch (InvalidDataTypeException e) {
			Msg.error(this, "analyze: "+type.getTypeName(), e);
			return false;
		}
	}
}

```

`src/main/java/cppclassanalyzer/analysis/gcc/GccCppClassAnalyzer.java`:

```java
package cppclassanalyzer.analysis.gcc;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.plugin.prototype.GccRttiAnalyzer;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;

import cppclassanalyzer.analysis.AbstractCppClassAnalyzer;
import cppclassanalyzer.decompiler.DecompilerAPI;

import static ghidra.app.cmd.data.rtti.gcc.GnuUtils.isGnuCompiler;

public class GccCppClassAnalyzer extends AbstractCppClassAnalyzer {

	public static final String ANALYZER_NAME = "GCC C++ Class Analyzer";
	private DecompilerAPI api;
	private GccVtableAnalysisCmd vtableAnalyzer;

	public GccCppClassAnalyzer() {
		super(ANALYZER_NAME);
		setPriority(new GccRttiAnalyzer().getPriority().after());
	}

	@Override
	public boolean canAnalyze(Program program) {
		return super.canAnalyze(program) && isGnuCompiler(program);
	}

	@Override
	protected boolean hasVtt() {
		return true;
	}

	@Override
	protected void init() {
		this.vtableAnalyzer = new GccVtableAnalysisCmd();
		this.api = getDecompilerAPI(program);
		api.setMonitor(monitor);
		api.setTimeout(getTimeout());
		this.constructorAnalyzer = new GccDecompilerConstructorAnalysisCmd(api);
	}

	@Override
	protected boolean isDestructor(Function function) {
		return function.getName().startsWith("~");
	}

	@Override
	protected boolean analyzeVftable(ClassTypeInfo type) {
		vtableAnalyzer.setTypeInfo(type);
		return vtableAnalyzer.applyTo(program);
	}

	@Override
	protected boolean analyzeConstructor(ClassTypeInfo type) {
		Vtable vtable = type.getVtable();
		if (!Vtable.isValid(vtable)) {
			// can only analyze types with valid vtables
			return false;
		}
		//VttModel vtt = VtableUtils.getVttModel(program, (GnuVtable) vtable);
		constructorAnalyzer.setTypeInfo(type);
		return constructorAnalyzer.applyTo(program);
	}
}

```

`src/main/java/cppclassanalyzer/analysis/gcc/GccDecompilerConstructorAnalysisCmd.java`:

```java
package cppclassanalyzer.analysis.gcc;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.program.model.listing.Function;

import cppclassanalyzer.analysis.cmd.AbstractDecompilerBasedConstructorAnalysisCmd;
import cppclassanalyzer.decompiler.DecompilerAPI;

public class GccDecompilerConstructorAnalysisCmd
		extends AbstractDecompilerBasedConstructorAnalysisCmd {

	private static final String NAME = GccDecompilerConstructorAnalysisCmd.class.getSimpleName();

	GccDecompilerConstructorAnalysisCmd(DecompilerAPI api) {
		super(NAME, api);
	}

	public GccDecompilerConstructorAnalysisCmd(ClassTypeInfo typeinfo, DecompilerAPI api) {
		super(NAME, api);
		this.type = typeinfo;
	}

	@Override
	protected boolean analyze() throws Exception {
		boolean result = super.analyze();
		if (result) {
			// set the destructor [not-in-charge]
			Function fun = type.getVtable().getFunctionTables()[0][1];
			setFunction(type, fun, true);
			createVirtualDestructors();
		}
		return result;
	}

	private void createVirtualDestructors() throws Exception {
		Vtable vtable = type.getVtable();
		if (!Vtable.isValid(vtable)) {
			return;
		}
		Function[][] functionTables = vtable.getFunctionTables();
		for (int i = 0; i < functionTables.length; i++) {
			for (int j = 0; j < functionTables[i].length && j < 2; j++) {
				if (i == 0) {
					if (functionTables[i][j] == null) {
						continue;
					}
					setFunction(type, functionTables[i][j], true);
				} else {
					functionTables[i][j].setThunkedFunction(functionTables[0][j]);
					functionTables[i][j].setParentNamespace(type.getGhidraClass());
				}
			}
		}
	}

}

```

`src/main/java/cppclassanalyzer/analysis/gcc/GccVtableAnalysisCmd.java`:

```java
package cppclassanalyzer.analysis.gcc;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.VtableUtils;
import ghidra.app.cmd.data.rtti.gcc.VttModel;
import ghidra.app.cmd.function.CreateThunkFunctionCmd;
import ghidra.framework.cmd.BackgroundCommand;
import ghidra.framework.model.DomainObject;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.utils.CppClassAnalyzerUtils;

import static ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils.getClassFunction;

public class GccVtableAnalysisCmd extends BackgroundCommand {

	private static final String NAME = GccVtableAnalysisCmd.class.getSimpleName();

	private ClassTypeInfo typeinfo;
	private Program program;
	private TaskMonitor monitor;

	GccVtableAnalysisCmd() {
		super(NAME, false, true, false);
	}

	public GccVtableAnalysisCmd(ClassTypeInfo type) {
		this();
		this.typeinfo = type;
	}

	public void setTypeInfo(ClassTypeInfo type) {
		this.typeinfo = type;
	}

	@Override
	public boolean applyTo(DomainObject obj, TaskMonitor monitor) {
		if (!(obj instanceof Program)) {
			String message = "Can only analyze a vtable in a program.";
			Msg.error(this, message);
			return false;
		}
		this.program = (Program) obj;
		this.monitor = monitor;
		try {
			Vtable vtable = typeinfo.getVtable();
			VttModel vtt = null;
			if (Vtable.isValid(vtable)) {
				vtt = VtableUtils.getVttModel(program, (GnuVtable) vtable);
			}
			if (vtt != null && vtt.isValid()) {
				for (Vtable parentVtable : vtt.getConstructionVtableModels()) {
					monitor.checkCanceled();
					setupFunctions(parentVtable);
				}
			}
			setupFunctions(vtable);
		} catch (CancelledException e) {
		} catch (Exception e) {
			setStatusMsg(e.getMessage());
			return false;
		}
		return true;
	}

	private static boolean isPureVirtual(Function f) {
		return f.getName().equals(GnuVtable.PURE_VIRTUAL_FUNCTION_NAME);
	}

	private void setupFunctions(Vtable vftable) throws Exception {
		ClassTypeInfo type = vftable.getTypeInfo();
		Function[][] functionTables = vftable.getFunctionTables();
		// Also if the function has a reference to this::vtable, then it owns the function
		for (int i = 0; i < functionTables.length; i++) {
			monitor.checkCanceled();
			if (i == 0) {
				for (Function f : functionTables[i]) {
					monitor.checkCanceled();
					if (!CppClassAnalyzerUtils.isDefaultFunction(f) || isPureVirtual(f)) {
						continue;
					}
					getClassFunction(program, type, f.getEntryPoint());
				}
			} else {
				setupThunkFunctions(type, vftable, functionTables[i], i);
			}
		}
	}

	private void setupThunkFunctions(ClassTypeInfo type, Vtable vftable,
		Function[] functionTable, int ordinal) throws CancelledException {
		for (Function function : functionTable) {
			monitor.checkCanceled();
			if (!CppClassAnalyzerUtils.isDefaultFunction(function)) {
				continue;
			}
			if (CreateThunkFunctionCmd.isThunk(program, function)) {
				CreateThunkFunctionCmd cmd =
					new CreateThunkFunctionCmd(function.getEntryPoint(), false);
				cmd.applyTo(program, monitor);
			} else {
				getClassFunction(program, type, function.getEntryPoint());
			}
		}
	}
}

```

`src/main/java/cppclassanalyzer/analysis/vs/VsConstructorAnalysisCmd.java`:

```java
package cppclassanalyzer.analysis.vs;

import java.util.*;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils;
import ghidra.app.cmd.function.CreateFunctionCmd;
import ghidra.app.util.XReferenceUtils;
import ghidra.app.util.pdb.PdbProgramAttributes;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSetView;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.symbol.FlowType;
import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.Msg;

import cppclassanalyzer.analysis.cmd.AbstractConstructorAnalysisCmd;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

public class VsConstructorAnalysisCmd extends AbstractConstructorAnalysisCmd {

	private static final String NAME = VsConstructorAnalysisCmd.class.getSimpleName();
	private static final String VECTOR_DESTRUCTOR = "vector_deleting_destructor";
	private static final String VBASE_DESTRUCTOR = "vbase_destructor";

	VsConstructorAnalysisCmd() {
		super(NAME);
	}

	public VsConstructorAnalysisCmd(ClassTypeInfo typeinfo) {
		super(NAME, typeinfo);
	}

	private boolean isDebugable() {
		PdbProgramAttributes pdb = new PdbProgramAttributes(program);
		return pdb.getPdbFile() != null;
	}

	private Address getFunctionStart(Address address) {
		Instruction inst = listing.getInstructionAt(address);
		while (inst.getFallFrom() != null) {
			inst = inst.getPrevious();
		}
		return inst.getAddress();
	}

	private boolean analyzeVtable(Vtable vtable) throws Exception,
		InvalidDataTypeException {
			Address[] tableAddresses = vtable.getTableAddresses();
			if (tableAddresses.length == 0) {
				// no virtual functions, nothing to analyze.
				return true;
			}
			Address tableAddress = tableAddresses[0];
			monitor.checkCanceled();
			Data data = listing.getDataContaining(tableAddress);
			if (data == null) {
				return false;
			}
			ClassTypeInfo typeinfo = vtable.getTypeInfo();

			List<Reference> references = XReferenceUtils.getXReferences(data, -1);
			if (references.isEmpty()) {
				return false;
			}
			Set<Function> functions = new LinkedHashSet<>(references.size());
			if (!isDebugable()) {
				Function function = fManager.getFunctionContaining(references.get(0).getFromAddress());
				if (function == null) {
					data = listing.getDataAt(references.get(0).getFromAddress());
					if (data != null && data.isPointer()) {
						references = XReferenceUtils.getXReferences(data, -1);
						Collections.reverse(references);
						Address start = getFunctionStart(references.get(0).getFromAddress());
						CreateFunctionCmd cmd = new CreateFunctionCmd(start, true);
						if (cmd.applyTo(program)) {
							function = cmd.getFunction();
						} else {
							return false;
						}
					}
				}
				createConstructor(typeinfo, function.getEntryPoint());
				setDestructor(typeinfo, function);
				return true;
			}
			Collections.reverse(references);
			for (Reference ref : references) {
				monitor.checkCanceled();
				Address fromAddress = ref.getFromAddress();
				if(!fManager.isInFunction(fromAddress)) {
					continue;
				}
				Function function = fManager.getFunctionContaining(fromAddress);
				createConstructor(typeinfo, function.getEntryPoint());
				functions.add(function);
			}
			if (functions.size() < 2) {
				return false;
			}
			Iterator<Function> iter =functions.iterator();
			Function destructor = iter.next();
			setDestructor(typeinfo, destructor);
			detectVirtualDestructors(destructor, vtable);
			createSubConstructors(typeinfo, iter.next(), false);
			return true;
	}

	private Set<Function> getThunks(Function function) {
		Set<Function> functions = new HashSet<>();
		functions.add(function);
		Address[] addresses = function.getFunctionThunkAddresses(true);
		if (addresses == null) {
			return functions;
		}
		for (Address address : addresses) {
			Function thunkFunction = fManager.getFunctionContaining(address);
			functions.add(thunkFunction);
		}
		return functions;
	}

	private void detectVirtualDestructors(Function destructor, Vtable vtable)
		throws InvalidDataTypeException {
			Function[][] fTable = vtable.getFunctionTables();
			if (fTable.length == 0) {
				return;
			}
			for (Function[] functionTable : vtable.getFunctionTables()) {
				if (functionTable.length == 0) {
					continue;
				}
				Set<Function> destructors = getThunks(destructor);
				Function vDestructor = CppClassAnalyzerUtils.createThunkFunctions(functionTable[0]);
				Function calledFunction = getFirstCalledFunction(vDestructor);
				if (calledFunction == null) {
					continue;
				}
				if (destructors.contains(calledFunction)) {
					try {
						ClassTypeInfoUtils.getClassFunction(
							program, type, vDestructor.getEntryPoint());
						vDestructor.setName(VECTOR_DESTRUCTOR, SourceType.IMPORTED);
						continue;
					} catch (Exception e) {
						Msg.error(this, "Failed to set "+VECTOR_DESTRUCTOR+" function.", e);
					}
				}
				Function vBaseDestructor = calledFunction;
				calledFunction = getFirstCalledFunction(calledFunction);
				if (calledFunction == null) {
					continue;
				}
				if (destructors.contains(calledFunction)) {
					try {
						ClassTypeInfoUtils.getClassFunction(
							program, type, vBaseDestructor.getEntryPoint());
						ClassTypeInfoUtils.getClassFunction(
							program, type, vDestructor.getEntryPoint());
						vBaseDestructor.setName(VBASE_DESTRUCTOR, SourceType.IMPORTED);
						vDestructor.setName(VECTOR_DESTRUCTOR, SourceType.IMPORTED);
						continue;
					} catch (Exception e) {
						Msg.error(this, "Failed to set "+VBASE_DESTRUCTOR+" function.", e);
					}
				}
			}
	}

	private Function getFirstCalledFunction(Function function) {
		if (function.getCalledFunctions(monitor).size() < 1) {
			return null;
		}
		Instruction inst = listing.getInstructionAt(function.getEntryPoint());
		AddressSetView body = function.getBody();
		while (inst.isFallthrough() && body.contains(inst.getAddress())) {
			inst = inst.getNext();
		}
		final FlowType flow = inst.getFlowType();
		if (flow.isUnConditional() && !flow.isComputed()) {
			function = listing.getFunctionAt(inst.getFlows()[0]);
			if (function == null) {
				CreateFunctionCmd cmd = new CreateFunctionCmd(inst.getFlows()[0]);
				if (cmd.applyTo(program)) {
					function = cmd.getFunction();
				} else {
					return null;
				}
			}
			return CppClassAnalyzerUtils.createThunkFunctions(function);
		}
		return null;
	}

	@Override
	protected boolean analyze() throws Exception {
		return analyzeVtable(type.getVtable());
	}

}

```

`src/main/java/cppclassanalyzer/analysis/vs/VsCppClassAnalyzer.java`:

```java
package cppclassanalyzer.analysis.vs;

import java.util.*;
import java.util.stream.Collectors;

import cppclassanalyzer.analysis.AbstractCppClassAnalyzer;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.decompiler.DecompilerAPI;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import cppclassanalyzer.vs.RttiModelWrapper;
import cppclassanalyzer.vs.VsClassTypeInfo;

import ghidra.app.cmd.data.TypeDescriptorModel;
import ghidra.app.cmd.data.rtti.*;
import ghidra.app.cmd.data.rtti.gcc.GnuUtils;
import ghidra.app.plugin.prototype.MicrosoftCodeAnalyzerPlugin.PEUtil;
import ghidra.app.plugin.prototype.MicrosoftCodeAnalyzerPlugin.RttiAnalyzer;
import ghidra.app.util.datatype.microsoft.DataApplyOptions;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.AddressSet;
import ghidra.program.model.address.AddressSetView;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.*;
import ghidra.util.Msg;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.CancelOnlyWrappingTaskMonitor;
import ghidra.util.task.TaskMonitor;
import util.CollectionUtils;

public class VsCppClassAnalyzer extends AbstractCppClassAnalyzer {

	private static final String NAME = "Windows C++ Class Analyzer";
	private static final String SYMBOL_NAME = "RTTI_Type_Descriptor";

	// union doesn't really do much good but it isn't included for completion
	private static final Set<String> REF_TYPES = Set.of("class", "struct", "union");
	private static final String GUARD_FUNCTION = "_guard_check_icall_nop";
	private static final String CFG_WARNING =
		"Control Flow Guard (CFG) detected. Vftables not analyzed.";

	private static final DataApplyOptions DEFAULT_APPLY_OPTIONS = new DataApplyOptions();

	static {
		DEFAULT_APPLY_OPTIONS.setClearInstructions(true);
		DEFAULT_APPLY_OPTIONS.setFollowData(false);
	}

	private VsVftableAnalysisCmd vfTableAnalyzer;
	private DecompilerAPI api;

	public VsCppClassAnalyzer() {
		super(NAME);
		setPriority(new RttiAnalyzer().getPriority().after());
	}

	@Override
	public boolean canAnalyze(Program program) {
		if (super.canAnalyze(program)) {
			return PEUtil.canAnalyze(program) && !GnuUtils.isGnuCompiler(program);
		}
		return false;
	}

	@Override
	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
			throws CancelledException {
		if (CppClassAnalyzerUtils.getManager(program) == null) {
			return false;
		}
		buildClassTypeInfoDatabase(program, monitor);
		return super.added(program, set, monitor, log);
	}

	private boolean hasGuardedVftables() {
		Iterable<Function> functions = program.getFunctionManager().getFunctions(true);
		return CollectionUtils.asStream(functions)
			.map(Function::getName)
			.anyMatch(GUARD_FUNCTION::equals);
	}

	@Override
	protected boolean hasVtt() {
		return false;
	}

	/**
	 * @deprecated use {@link ProgramClassTypeInfoManager#getTypes()}
	 * after invoking {@link #buildClassTypeInfoDatabase(Program, TaskMonitor)} or having run
	 * the WindowsCppClassAnalyzer.
	 *
	 * @param program the program
	 * @param monitor the monitor
	 * @return the typeinfo list
	 * @throws CancelledException if the operation is cancelled
	 */
	@Deprecated
	public static List<ClassTypeInfo> getClassTypeInfoList(Program program, TaskMonitor monitor)
			throws CancelledException {
		ProgramClassTypeInfoManager manager = CppClassAnalyzerUtils.getManager(program);
		if (manager.getTypeCount() == 0) {
			buildClassTypeInfoDatabase(program, monitor);
		}
		return manager.getTypeStream().collect(Collectors.toList());
	}

	/**
	 * Locates known Run Time Type Information and adds them to the
	 * program's {@link ProgramClassTypeInfoManager}.
	 * @param program the program
	 * @param monitor the monitor
	 * @throws CancelledException if the operation is cancelled
	 */
	public static void buildClassTypeInfoDatabase(Program program, TaskMonitor monitor)
			throws CancelledException {
		ProgramClassTypeInfoManager manager = CppClassAnalyzerUtils.getManager(program);
		DescriptorProcessor processor = new DescriptorProcessor(manager, monitor);
		SymbolTable table = program.getSymbolTable();
		AddressSet addrSet = new AddressSet();
		CppClassAnalyzerUtils.getAllDataBlocks(program)
			.forEach((b)->addrSet.addRange(b.getStart(), b.getEnd()));
		Iterable<Symbol> rawSymbols = table.getSymbols(addrSet, SymbolType.LABEL, true);
		List<Symbol> symbols = CollectionUtils.asStream(rawSymbols)
			 .filter((s)->s.getName().contains(SYMBOL_NAME))
			 .collect(Collectors.toList());
		monitor.initialize(symbols.size());
		monitor.setMessage("Locating Type Information");
		for (Symbol symbol : symbols) {
			monitor.checkCanceled();
			TypeDescriptorModel descriptor = new TypeDescriptorModel(
				program, symbol.getAddress(), VsClassTypeInfo.DEFAULT_OPTIONS);
			processor.process(descriptor);
			monitor.incrementProgress(1);
		}
	}

	@Override
	protected void analyzeVftables() throws Exception {
		if (!hasGuardedVftables()) {
			super.analyzeVftables();
		} else {
			if (shouldAnalyzeConstructors()) {
				analyzeConstructors();
			}
			log.appendMsg(CFG_WARNING);
		}
	}

	@Override
	protected boolean analyzeVftable(ClassTypeInfo type) {
		vfTableAnalyzer.setTypeInfo(type);
		return vfTableAnalyzer.applyTo(program);
	}

	@Override
	protected boolean analyzeConstructor(ClassTypeInfo type) {
	   constructorAnalyzer.setTypeInfo(type);
	   return constructorAnalyzer.applyTo(program);
	}

	@Override
	protected void init() {
		this.vfTableAnalyzer = new VsVftableAnalysisCmd();
		this.api = getDecompilerAPI(program);
		api.setMonitor(monitor);
		api.setTimeout(getTimeout());
		this.constructorAnalyzer = new VsDecompilerConstructorAnalysisCmd(api);
	}

	@Override
	protected boolean isDestructor(Function function) {
		return function.getName().contains("destructor");
	}

	private static final class DescriptorProcessor {

		private final ProgramClassTypeInfoManager manager;
		private final TaskMonitor monitor;

		DescriptorProcessor(ProgramClassTypeInfoManager manager, TaskMonitor monitor) {
			this.manager = manager;
			this.monitor = new CancelOnlyWrappingTaskMonitor(monitor);
		}

		void process(TypeDescriptorModel descriptor) throws CancelledException {
			try {
				if (!REF_TYPES.contains(descriptor.getRefType())) {
					return;
				}
				descriptor.validate();
			} catch (InvalidDataTypeException | NullPointerException e) {
				return;
			}
			VsClassTypeInfo type = (VsClassTypeInfo) manager.getType(descriptor.getAddress());
			if (type == null) {
				type = RttiModelWrapper.getWrapper(descriptor, monitor);
			}
			if (type != null) {
				fixMissingMarkup(type);
				type = (VsClassTypeInfo) manager.resolve(type);
				Vtable vtable = type.findVtable(monitor);
				if (Vtable.isValid(vtable)) {
					manager.resolve(vtable);
				}
			} else {
				String msg = String.format(
					"Unable to process %s at %s due to lack of information",
					descriptor.getDescriptorAsNamespace().getName(true), descriptor.getAddress());
				Msg.info(this, msg);
			}
		}

		private void fixMissingMarkup(VsClassTypeInfo type) throws CancelledException {
			// Only create the slow Rtti#Models if necessary
			if (needsRtti3Markup(type)) {
				markupRtti3(type);
			}
			if (needsRtti2Markup(type)) {
				markupRtti2(type);
			}
		}

		private boolean needsRtti3Markup(VsClassTypeInfo type) {
			return needsRttiMarkup(type, VsClassTypeInfo.HIERARCHY_SYMBOL_NAME);
		}

		private boolean needsRtti2Markup(VsClassTypeInfo type) {
			return needsRttiMarkup(type, VsClassTypeInfo.BASE_ARRAY_SYMBOL_NAME);
		}

		private boolean needsRttiMarkup(VsClassTypeInfo type, String symbolName) {
			GhidraClass gc = type.getGhidraClass();
			Program program = gc.getSymbol().getProgram();
			SymbolIterator it = program.getSymbolTable().getChildren(gc.getSymbol());
			return CollectionUtils.asStream(it)
				.map(Symbol::getName)
				.noneMatch(s -> s.contains(symbolName));
		}

		private void markupRtti3(VsClassTypeInfo type) {
			Rtti3Model rtti3 = type.getHierarchyDescriptor();
			if (rtti3 == null) {
				return;
			}
			CreateRtti3BackgroundCmd cmd =
				new CreateRtti3BackgroundCmd(
					rtti3.getAddress(), VsClassTypeInfo.DEFAULT_OPTIONS,
					DEFAULT_APPLY_OPTIONS);
			cmd.applyTo(rtti3.getProgram());
		}

		private void markupRtti2(VsClassTypeInfo type) {
			Rtti2Model rtti2 = type.getBaseClassArray();
			if (rtti2 == null) {
				return;
			}
			CreateRtti2BackgroundCmd cmd =
				new CreateRtti2BackgroundCmd(
					rtti2.getAddress(), rtti2.getCount(),
					VsClassTypeInfo.DEFAULT_OPTIONS, DEFAULT_APPLY_OPTIONS);
			cmd.applyTo(rtti2.getProgram());
		}
	}
}

```

`src/main/java/cppclassanalyzer/analysis/vs/VsDecompilerConstructorAnalysisCmd.java`:

```java
package cppclassanalyzer.analysis.vs;

import java.util.HashSet;
import java.util.Set;

import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils;
import ghidra.app.cmd.function.CreateFunctionCmd;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSetView;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.symbol.*;
import ghidra.util.Msg;

import cppclassanalyzer.analysis.cmd.AbstractDecompilerBasedConstructorAnalysisCmd;
import cppclassanalyzer.decompiler.DecompilerAPI;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import cppclassanalyzer.vs.VsClassTypeInfo;
import util.CollectionUtils;

public class VsDecompilerConstructorAnalysisCmd
		extends AbstractDecompilerBasedConstructorAnalysisCmd {


	private static final String NAME = VsDecompilerConstructorAnalysisCmd.class.getSimpleName();
	private static final String VECTOR_DESTRUCTOR = "vector_deleting_destructor";
	private static final String VBASE_DESTRUCTOR = "vbase_destructor";

	protected VsDecompilerConstructorAnalysisCmd(DecompilerAPI api) {
		super(NAME, api);
	}

	protected VsDecompilerConstructorAnalysisCmd(VsClassTypeInfo type, DecompilerAPI api) {
		super(NAME, api);
		this.type = type;
	}

	@Override
	protected boolean analyze() throws Exception {
		boolean result = super.analyze();
		if (result) {
			Vtable vtable = type.getVtable();
			GhidraClass gc = type.getGhidraClass();
			SymbolTable t = gc.getSymbol().getProgram().getSymbolTable();
			Iterable<Symbol> it = t.getChildren(gc.getSymbol());
			CollectionUtils.asStream(it)
				.filter(s -> s.getSymbolType() == SymbolType.FUNCTION)
				.filter(s -> s.getName().startsWith("~"))
				.map(Symbol::getObject)
				.map(Function.class::cast)
				.forEach(fun -> detectVirtualDestructors(fun, vtable));
		}
		return result;
	}

	private Set<Function> getThunks(Function function) {
		Set<Function> functions = new HashSet<>();
		functions.add(function);
		Address[] addresses = function.getFunctionThunkAddresses(true);
		if (addresses == null) {
			return functions;
		}
		for (Address address : addresses) {
			Function thunkFunction = fManager.getFunctionContaining(address);
			functions.add(thunkFunction);
		}
		return functions;
	}

	private void detectVirtualDestructors(Function destructor, Vtable vtable) {
			Function[][] fTable = vtable.getFunctionTables();
			if (fTable.length == 0) {
				return;
			}
			for (Function[] functionTable : vtable.getFunctionTables()) {
				if (functionTable.length == 0) {
					continue;
				}
				Set<Function> destructors = getThunks(destructor);
				Function vDestructor = CppClassAnalyzerUtils.createThunkFunctions(functionTable[0]);
				Function calledFunction = getFirstCalledFunction(vDestructor);
				if (calledFunction == null) {
					continue;
				}
				if (destructors.contains(calledFunction)) {
					try {
						ClassTypeInfoUtils.getClassFunction(
							program, type, vDestructor.getEntryPoint());
						vDestructor.setName(VECTOR_DESTRUCTOR, SourceType.IMPORTED);
						continue;
					} catch (Exception e) {
						Msg.error(this, "Failed to set "+VECTOR_DESTRUCTOR+" function.", e);
					}
				}
				Function vBaseDestructor = calledFunction;
				calledFunction = getFirstCalledFunction(calledFunction);
				if (calledFunction == null) {
					continue;
				}
				if (destructors.contains(calledFunction)) {
					try {
						ClassTypeInfoUtils.getClassFunction(
							program, type, vBaseDestructor.getEntryPoint());
						ClassTypeInfoUtils.getClassFunction(
							program, type, vDestructor.getEntryPoint());
						vBaseDestructor.setName(VBASE_DESTRUCTOR, SourceType.IMPORTED);
						vDestructor.setName(VECTOR_DESTRUCTOR, SourceType.IMPORTED);
						continue;
					} catch (Exception e) {
						Msg.error(this, "Failed to set "+VBASE_DESTRUCTOR+" function.", e);
					}
				}
			}
	}

	private Function getFirstCalledFunction(Function function) {
		if (function.getCalledFunctions(monitor).size() < 1) {
			return null;
		}
		Instruction inst = listing.getInstructionAt(function.getEntryPoint());
		AddressSetView body = function.getBody();
		while (inst.isFallthrough() && body.contains(inst.getAddress())) {
			inst = inst.getNext();
		}
		FlowType flow = inst.getFlowType();
		if (flow.isUnConditional() && !flow.isComputed()) {
			function = listing.getFunctionAt(inst.getFlows()[0]);
			if (function == null) {
				CreateFunctionCmd cmd = new CreateFunctionCmd(inst.getFlows()[0]);
				if (cmd.applyTo(program)) {
					function = cmd.getFunction();
				} else {
					return null;
				}
			}
			return CppClassAnalyzerUtils.createThunkFunctions(function);
		}
		return null;
	}

}

```

`src/main/java/cppclassanalyzer/analysis/vs/VsVftableAnalysisCmd.java`:

```java
package cppclassanalyzer.analysis.vs;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils;
import ghidra.framework.cmd.BackgroundCommand;
import ghidra.framework.model.DomainObject;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import cppclassanalyzer.vs.VsVtableModel;

public class VsVftableAnalysisCmd extends BackgroundCommand {

	private ClassTypeInfo type;
	private TaskMonitor monitor;

	protected VsVftableAnalysisCmd() {
		super(VsVftableAnalysisCmd.class.getSimpleName(), false, true, false);
	}

	public VsVftableAnalysisCmd(ClassTypeInfo type) {
		this();
		this.type = type;
	}

	public void setTypeInfo(ClassTypeInfo type) {
		this.type = type;
	}

	@Override
	public boolean applyTo(DomainObject obj, TaskMonitor monitor) {
		if (!(obj instanceof Program)) {
			String message = "Can only analyze a vtable in a program.";
			Msg.error(this, message);
			return false;
		}
		this.monitor = monitor;
		try {
			Vtable vtable = type.getVtable();
			if (!Vtable.isValid(vtable)) {
				return false;
			}
			setupFunctions(vtable);
			return true;
		} catch (Exception e) {
			Msg.error(this, e);
			e.printStackTrace();
		}
		return true;
	}

	private static boolean isPureVirtual(Function f) {
		return f.getName().equals(VsVtableModel.PURE_VIRTUAL_FUNCTION_NAME);
	}

	private void setupFunctions(Vtable vftable) throws CancelledException {
		Function[][] functionTables = vftable.getFunctionTables();
		for (Function[] functionTable : functionTables) {
			monitor.checkCanceled();
			for (Function f : functionTable) {
				monitor.checkCanceled();
				CppClassAnalyzerUtils.createThunkFunctions(f);
				while (f.isThunk()) {
					f = f.getThunkedFunction(true);
				}
				if (f.isExternal()) {
					continue;
				}
				if (!CppClassAnalyzerUtils.isDefaultFunction(f) || isPureVirtual(f)) {
					continue;
				}
				ClassTypeInfoUtils.setClassFunction(type, f);
			}
		}
	}

}

```

`src/main/java/cppclassanalyzer/cmd/ApplyVtableDefinitionsBackgroundCmd.java`:

```java
package cppclassanalyzer.cmd;

import java.util.Objects;

import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.function.ApplyFunctionSignatureCmd;
import ghidra.framework.cmd.BackgroundCommand;
import ghidra.framework.model.DomainObject;
import ghidra.program.model.data.FunctionDefinition;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.data.vtable.ArchivedVtable;

/**
 * BackgroundCommand to apply virtual function definitions to the functions
 * pointed to in the provided vtable.
 */
public class ApplyVtableDefinitionsBackgroundCmd extends BackgroundCommand {

	private final Vtable vtable;
	private final ArchivedVtable archived;

	/**
	 * Constructs a new ApplyVtableDefinitionsBackgroundCmd
	 * @param vtable the vtable to apply the definitions to
	 * @param archived the archived vtable
	 */
	public ApplyVtableDefinitionsBackgroundCmd(Vtable vtable, ArchivedVtable archived) {
		this.vtable = Objects.requireNonNull(vtable);
		this.archived = Objects.requireNonNull(archived);
	}

	@Override
	public boolean applyTo(DomainObject obj, TaskMonitor monitor) {
		if (!(obj instanceof Program)) {
			setStatusMsg("Can only be applied to a program");
			return false;
		}
		Function[][] functions = vtable.getFunctionTables();
		FunctionDefinition[][] definitions = archived.getFunctionDefinitions();
		if (functions.length != definitions.length) {
			return reportNonMatchingData();
		}
		for (int i = 0; i < functions.length; i++) {
			if (functions[i].length != definitions[i].length) {
				return reportNonMatchingData();
			}
		}
		try {
			for (int i = 0; i < functions.length; i++) {
				monitor.checkCanceled();
				for (int j = 0; j < functions[i].length; j++) {
					monitor.checkCanceled();
					Function function = functions[i][j];
					FunctionDefinition definition = definitions[i][j];
					if (function == null || definition == null) {
						// nothing to do
						continue;
					}
					ApplyFunctionSignatureCmd cmd = new ApplyFunctionSignatureCmd(
						function.getEntryPoint(), definition, SourceType.ANALYSIS, false, true);
					if (!cmd.applyTo(function.getProgram(), monitor)) {
						return false;
					}
					if (function.isGlobal()) {
						function.setParentNamespace(vtable.getTypeInfo().getGhidraClass());
					}
				}
			}
		} catch (CancelledException e) {
			setStatusMsg("Task Cancelled");
			return false;
		} catch (Exception e) {
			setStatusMsg(e.getLocalizedMessage());
			return false;
		}
		return true;
	}

	private boolean reportNonMatchingData() {
		setStatusMsg("Vtable definitions for " + vtable.getTypeInfo().getFullName()
			+ " doesn't match archived data");
		return false;
	}

}

```

`src/main/java/cppclassanalyzer/cmd/CreateExternalSymbolBackgroundCmd.java`:

```java
package cppclassanalyzer.cmd;

import java.util.Objects;

import ghidra.framework.cmd.BackgroundCommand;
import ghidra.framework.model.DomainObject;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Library;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.ExternalLocation;
import ghidra.program.model.symbol.ExternalManager;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;

/**
 * BackgroundCommand to create an ExternalLocation
 */
public class CreateExternalSymbolBackgroundCmd extends BackgroundCommand {

	private final SymbolInfoProvider provider;
	private ExternalLocation location;

	/**
	 * Constructs a new CreateExternalSymbolBackgroundCmd
	 * @param type the archived type providing the symbol information
	 */
	public CreateExternalSymbolBackgroundCmd(ArchivedClassTypeInfo type) {
		this.provider = new TypeSymbolInfoProvider(type);
	}

	/**
	 * Constructs a new CreateExternalSymbolBackgroundCmd
	 * @param libName the library name
	 * @param symbol the symbol name
	 */
	public CreateExternalSymbolBackgroundCmd(String libName, String symbol) {
		this.provider = new RawSymbolInfoProvider(libName, symbol);
	}

	@Override
	public boolean applyTo(DomainObject obj, TaskMonitor monitor) {
		if (!(obj instanceof Program)) {
			setStatusMsg("obj must be a program");
			return false;
		}
		Program program = (Program) obj;
		ExternalManager man = program.getExternalManager();
		if (!man.contains(provider.getLibraryName())) {
			setStatusMsg(provider.getLibraryName() + " is not an existing library");
			return false;
		}
		Library lib = man.getExternalLibrary(provider.getLibraryName());
		String symbol = provider.getSymbolName();
		Address address;
		if (provider instanceof TypeSymbolInfoProvider) {
			address = ((TypeSymbolInfoProvider) provider).getType().getExternalAddress(program);
		} else {
			address = null;
		}
		try {
			this.location = man.addExtLocation(lib, symbol, address, SourceType.IMPORTED, true);
		} catch (InvalidInputException e) {
			throw new AssertException(e);
		}
		return this.location != null;
	}

	/**
	 * Gets the created external location
	 * @return the created external location
	 */
	public ExternalLocation getExternalLocation() {
		return location;
	}

	private static interface SymbolInfoProvider {

		String getLibraryName();
		String getSymbolName();
	}

	private static class TypeSymbolInfoProvider implements SymbolInfoProvider {

		private final ArchivedClassTypeInfo type;

		private TypeSymbolInfoProvider(ArchivedClassTypeInfo type) {
			this.type = Objects.requireNonNull(type);
		}

		@Override
		public String getLibraryName() {
			return type.getProgramName();
		}

		@Override
		public String getSymbolName() {
			return type.getSymbolName();
		}

		private ArchivedClassTypeInfo getType() {
			return type;
		}
	}

	private static class RawSymbolInfoProvider implements SymbolInfoProvider {

		private final String libName;
		private final String symbol;

		private RawSymbolInfoProvider(String libName, String symbol) {
			this.libName = Objects.requireNonNull(libName);
			this.symbol = Objects.requireNonNull(symbol);
		}

		@Override
		public String getLibraryName() {
			return libName;
		}

		@Override
		public String getSymbolName() {
			return symbol;
		}
	}

}

```

`src/main/java/cppclassanalyzer/cmd/FillOutClassBackgroundCmd.java`:

```java
package cppclassanalyzer.cmd;

import java.util.*;
import java.util.function.Predicate;

import ghidra.app.decompiler.*;
import ghidra.app.plugin.core.decompile.DecompilerActionContext;
import ghidra.framework.cmd.BackgroundCommand;
import ghidra.framework.model.DomainObject;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.model.pcode.*;
import ghidra.util.UniversalID;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.decompiler.function.*;
import cppclassanalyzer.decompiler.token.ClangNodeUtils;
import cppclassanalyzer.service.ClassTypeInfoManagerService;

/**
 * BackgroundCommand to fill out a ClassTypeInfo's Structure
 */
public final class FillOutClassBackgroundCmd extends BackgroundCommand {

	private final DecompilerActionContext context;
	private final ClassTypeInfoDB type;

	/**
	 * Constructs a new FillOutClassCmd
	 * @param context the decompiler context
	 */
	public FillOutClassBackgroundCmd(DecompilerActionContext context) {
		this.context = context;
		ClassTypeInfoManagerService service =
			context.getTool().getService(ClassTypeInfoManagerService.class);
		ProgramClassTypeInfoManager manager =
			service.getManager(context.getFunction().getProgram());
		this.type = manager.getType(context.getFunction());
	}

	@Override
	public boolean applyTo(DomainObject obj, TaskMonitor monitor) {
		try {
			monitor.checkCanceled();
			doApplyTo(monitor);
			return true;
		} catch (CancelledException e) {
			setStatusMsg(e.getLocalizedMessage());
		}
		return false;
	}

	private ProgramClassTypeInfoManager getManager() {
		return (ProgramClassTypeInfoManager) type.getManager();
	}

	private void doApplyTo(TaskMonitor monitor) throws CancelledException {
		applyFunctionCalls(monitor);
		applyVptrAssignments(monitor);
	}

	private void applyFunctionCalls(TaskMonitor monitor) throws CancelledException {
		List<HighFunctionCall> calls =
			ClangNodeUtils.getClangFunctionCalls(context.getCCodeModel());
		monitor.setMessage("Analyzing "+type.getName()+" member usage in calls");
		monitor.initialize(calls.size());
		for (HighFunctionCall call : calls) {
			monitor.checkCanceled();
			analyzeCall(call);
			monitor.incrementProgress(1);
		}
	}

	private void applyVptrAssignments(TaskMonitor monitor) throws CancelledException {
		List<ClangStatement> statements = ClangNodeUtils.getClangStatements(context.getCCodeModel());
		statements.removeIf(Predicate.not(FillOutClassBackgroundCmd::isAssignment));
		monitor.setMessage("Analyzing "+type.getName()+" member vptr assignments");
		monitor.initialize(statements.size());
		for (ClangStatement statement : statements) {
			monitor.checkCanceled();
			HighVariableAssignment assignment = new HighVariableAssignment(statement);
			if (assignment.hasGlobalRef() && isThisVariable(assignment)) {
				final int offset;
				if (assignment.hasFieldToken()) {
					offset = assignment.getOffset() + assignment.getFieldToken().getOffset();
				} else {
					offset = assignment.getOffset();
				}
				ClassTypeInfoDB member = getType(assignment);
				if (member != null && !member.equals(type)) {
					setMember(member, offset);
				}
			}
			monitor.incrementProgress(1);
		}
	}

	private ClassTypeInfoDB getType(HighVariableAssignment assignment) {
		Address addr = assignment.getGlobalRefAddress();
		if (addr != null) {
			Program program = getManager().getProgram();
			int ptrSize = program.getDefaultPointerSize();
			Data d = program.getListing().getDataAt(addr.subtract(ptrSize));
			if (d != null && d.isPointer()) {
				return getManager().getType((Address) d.getValue());
			}
		}
		return null;
	}

	private static boolean isAssignment(ClangStatement statement) {
		PcodeOp op = statement.getPcodeOp();
		if (op != null) {
			return op.getOpcode() == PcodeOp.STORE;
		}
		return false;
	}

	private void analyzeCall(HighFunctionCall call) {
		List<HighFunctionCallParameter> params = call.getParameters();
		if (params.isEmpty()) {
			return;
		}
		HighFunctionCallParameter self = params.get(0);
		if (!self.hasLocalRef() || !isThisVariable(self)) {
			return;
		}
		final int offset;
		if (self.hasFieldToken()) {
			offset = self.getOffset() + self.getFieldToken().getOffset();
		} else {
			offset = self.getOffset();
		}
		setMember(call.getFunction(), offset);
	}

	private boolean isThisVariable(HighStructAccess self) {
		HighVariable var = self.getVariableToken().getHighVariable();
		if (var == null) {
			return false;
		}
		DataType dt = var.getDataType();
		if (!(dt instanceof Pointer)) {
			return false;
		}
		UniversalID id = ((Pointer) dt).getDataType().getUniversalID();
		if (id == null) {
			return false;
		}
		ClassTypeInfoDB member = getManager().getType(id);
		if (member == null || !member.equals(type)) {
			return false;
		}
		return true;
	}

	private void setMember(Function fun, int offset) {
		ClassTypeInfoDB member = getManager().getType(fun);
		if (member != null) {
			setMember(member, offset);
		}
	}

	private void setMember(ClassTypeInfoDB member, int offset) {
		MemberValidator validator = new MemberValidator(member);
		Structure struct = type.getClassDataType();
		DataTypeComponent comp = struct.getComponentAt(offset);
		while (comp != null) {
			DataType dt = comp.getDataType();
			if (!(dt instanceof Structure)) {
				break;
			}
			if (validator.isInvalidMember(dt)) {
				return;
			}
			offset -= comp.getOffset();
			struct = (Structure) dt;
			if (struct.getNumComponents() == 0 || offset >= struct.getLength()) {
				break;
			}
			comp = struct.getComponent(offset);
		}
		if (comp != null && comp.getFieldName() != null) {
			if (comp.getFieldName().startsWith("super_") && offset == 0) {
				return;
			}
		}
		DataType memberDt = member.getClassDataType();
		String name = createMemberName(memberDt, struct, offset);
		if (offset > struct.getLength()) {
			struct.insertAtOffset(offset, memberDt, memberDt.getLength());
		} else {
			struct.replaceAtOffset(offset, memberDt, memberDt.getLength(), name, null);
		}
	}

	private static String createMemberName(DataType dt, Structure struct, int offset) {
		String name = dt.getName();
		if (Character.isUpperCase(name.charAt(0))) {
			Character C = Character.valueOf(name.charAt(0));
			Character c = Character.valueOf(Character.toLowerCase(C));
			name = name.replaceFirst(C.toString(), c.toString());
		}
		boolean exists = Arrays.stream(struct.getDefinedComponents())
			.map(DataTypeComponent::getFieldName)
			.filter(Objects::nonNull)
			.anyMatch(name::equals);
		if (exists) {
			name += "_" + Integer.toString(offset);
		}
		return name;
	}

	private static class MemberValidator {

		private final ClassTypeInfoDB type;

		MemberValidator(ClassTypeInfoDB type) {
			this.type = Objects.requireNonNull(type);
		}

		boolean isInvalidMember(DataType dt) {
			Structure struct = type.getClassDataType();
			if (dt.isEquivalent(struct)) {
				return true;
			}
			struct = type.getSuperClassDataType();
			return dt.isEquivalent(struct);
		}
	}
}

```

`src/main/java/cppclassanalyzer/data/ArchivedRttiData.java`:

```java
package cppclassanalyzer.data;

/**
 * Marker interface for Run Time Type Information stored in a Ghidra Archive
 */
public interface ArchivedRttiData {	
}
```

`src/main/java/cppclassanalyzer/data/ClassTypeInfoManager.java`:

```java
package cppclassanalyzer.data;

import java.util.stream.Stream;

import javax.swing.Icon;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.gcc.UnresolvedClassTypeInfoException;
import ghidra.framework.model.DomainObjectListener;

import cppclassanalyzer.plugin.typemgr.node.TypeInfoTreeNodeManager;

import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import db.util.ErrorHandler;

import ghidra.program.database.map.AddressMap;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.symbol.Namespace;
import ghidra.util.Disposable;

/**
 * ClassTypeInfoManager manages all {@link ClassTypeInfo} within
 * a {@link ghidra.framework.model.DomainObject DomainObject}
 */
public interface ClassTypeInfoManager extends Disposable, ErrorHandler {

	/** The value which represents an invalid database key */
	public static final long INVALID_KEY = AddressMap.INVALID_ADDRESS_KEY;

	/**
	 * Gets the name of this manager
	 * @return the managers name
	 */
	String getName();

	/**
	 * Gets the icon for this manager to be used in the
	 * {@link cppclassanalyzer.plugin.typemgr.TypeInfoArchiveGTree TypeInfoArchiveGTree}
	 * @param expanded true if the manager tree node is expanded
	 * @return the icon to be used in the tree
	 */
	Icon getIcon(boolean expanded);

	/**
	 * Returns a ClassTypeInfo that is managed by this ClassTypeInfoManager.
	 * If one does not currently exist a new one is created.
	 * @param type the type to resolve
	 * @return the equivalent type managed by this ClassTypeInfoManager
	 */
	ClassTypeInfoDB resolve(ClassTypeInfo type);

	/**
	 * Gets the ClassTypeInfo for the corresponding database key
	 * @param key the database key
	 * @return the ClassTypeInfo or null if it doesn't exist
	 */
	ClassTypeInfoDB getType(long key);

	/**
	 * Gets the ClassTypeInfo for the corresponding {@link GhidraClass}
	 * @param gc the GhidraClass
	 * @return the ClassTypeInfo or null if it doesn't exist
	 * @throws UnresolvedClassTypeInfoException if this type requires a copy relocation
	 * which cannot be resolved.
	 */
	ClassTypeInfoDB getType(GhidraClass gc) throws UnresolvedClassTypeInfoException;

	/**
	 * Gets the ClassTypeInfo for the corresponding {@link Function}
	 * @param fun the function
	 * @return the ClassTypeInfo or null if it doesn't exist
	 * @throws UnresolvedClassTypeInfoException if this type requires a copy relocation
	 * which cannot be resolved.
	 */
	ClassTypeInfoDB getType(Function fun) throws UnresolvedClassTypeInfoException;

	/**
	 * Gets the ClassTypeInfo with the specified name and {@link Namespace}
	 * @param name the type's name
	 * @param namespace the type's namespace
	 * @return the ClassTypeInfo or null if it doesn't exist
	 * @throws UnresolvedClassTypeInfoException if this type requires a copy relocation
	 * which cannot be resolved.
	 */
	ClassTypeInfoDB getType(String name, Namespace namespace)
		throws UnresolvedClassTypeInfoException;

	/**
	 * Gets the ClassTypeInfo with the specified symbol.
	 * The supplied symbol should be mangled.
	 * @param symbolName the mangled symbol name
	 * @return the ClassTypeInfo or null if it doesn't exist
	 * @throws UnresolvedClassTypeInfoException if this type requires a copy relocation
	 * which cannot be resolved.
	 */
	ClassTypeInfoDB getType(String symbolName) throws UnresolvedClassTypeInfoException;

	/**
	 * Gets an iterable over all the managed ClassTypeInfos
	 * @return an iterable over all the managed ClassTypeInfos
	 */
	Iterable<ClassTypeInfoDB> getTypes();

	/**
	 * Gets a stream of all the managed ClassTypeInfos
	 * @return a stream of all the managed ClassTypeInfos
	 */
	Stream<ClassTypeInfoDB> getTypeStream();

	/**
	 * Gets the number of managed ClassTypeInfos
	 * @return the number of managed ClassTypeInfos
	 */
	int getTypeCount();

	/**
	 * Gets the {@link TypeInfoTreeNodeManager} for this ClassTypeInfoManager
	 * @return this manager's TypeInfoTreeNodeManager
	 */
	TypeInfoTreeNodeManager getTreeNodeManager();

	default void addListener(DomainObjectListener listener) {
	}

	default void removeListener(DomainObjectListener listener) {
	}
}

```

`src/main/java/cppclassanalyzer/data/ProgramClassTypeInfoManager.java`:

```java
package cppclassanalyzer.data;

import java.util.stream.Stream;

import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.UnresolvedClassTypeInfoException;
import ghidra.framework.model.DomainObjectListener;

import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.data.vtable.ArchivedGnuVtable;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.util.UniversalID;

/**
 * {@link ClassTypeInfoManager} for a {@link Program}
 */
public interface ProgramClassTypeInfoManager extends TypeInfoManager, ClassTypeInfoManager {

	/**
	 * Gets the program
	 * @return the program
	 */
	Program getProgram();

	/**
	 * Gets the ClassTypeInfo at the specified address
	 * @param address the address of the ClassTypeInfo
	 * @return the ClassTypeInfo or null if invalid
	 * @throws UnresolvedClassTypeInfoException if this type requires a copy relocation
	 * which cannot be resolved.
	 */
	ClassTypeInfoDB getType(Address address) throws UnresolvedClassTypeInfoException;

	/**
	 * Returns a Vtable that is managed by this ProgramClassTypeInfoManager.
	 * If one does not currently exist a new one is created.
	 * @param vtable the vtable to resolve
	 * @return the equivalent vtable managed by this ProgramClassTypeInfoManager
	 */
	Vtable resolve(Vtable vtable);

	/**
	 * Gets the Vtable at the specified address
	 * @param address the address of the vtable
	 * @return the vtable at the address or null if none is present
	 */
	Vtable getVtable(Address address);

	@Override
	default Iterable<ClassTypeInfoDB> getTypes() {
		return getTypes(false);
	}

	/**
	 * Gets an iterable over all the managed ClassTypeInfos in the specified direction
	 * @param reverse true if the types should be provided in reverse
	 * @return an iterable over all the managed ClassTypeInfos
	 */
	Iterable<ClassTypeInfoDB> getTypes(boolean reverse);

	/**
	 * Gets an iterable over all the managed Vtables
	 * @return an iterable over all the managed Vtables
	 */
	default Iterable<Vtable> getVtables() {
		return getVtableIterable(false);
	}

	/**
	 * Gets an iterable over all the managed Vtables in the specified direction
	 * @param reverse true if the Vtables should be provided in reverse
	 * @return an iterable over all the managed Vtables
	 */
	Iterable<Vtable> getVtableIterable(boolean reverse);

	/**
	 * Gets the number of managed Vtables
	 * @return the number of managed Vtables
	 */
	int getVtableCount();

	@Override
	default Stream<ClassTypeInfoDB> getTypeStream() {
		return getTypeStream(false);
	}

	/**
	 * Gets a stream of all the managed ClassTypeInfos in the specified direction
	 * @param reverse true if the types should be provided in reverse
	 * @return a stream of all the managed ClassTypeInfos
	 */
	Stream<ClassTypeInfoDB> getTypeStream(boolean reverse);

	/**
	 * Gets a stream of all the managed Vtables
	 * @return a stream of all the managed Vtables
	 */
	Stream<Vtable> getVtableStream();

	/**
	 * Returns a ClassTypeInfo that is managed by this ClassTypeInfoManager.
	 * If the ArchivedClassTypeInfo hasn't already been resolved the type
	 * will be created and all required data will be added to the program.
	 * @param type the type to resolve
	 * @return the equivalent type managed by this ClassTypeInfoManager
	 */
	ClassTypeInfoDB resolve(ArchivedClassTypeInfo type);

	/**
	 * Returns a Vtable that is managed by this ClassTypeInfoManager.
	 * If the ArchivedGnuVtable hasn't already been resolved the vtable
	 * will be created and all required data will be added to the program.
	 * @param vtable the vtable to resolve
	 * @return the equivalent vtable managed by this ClassTypeInfoManager
	 */
	Vtable resolve(ArchivedGnuVtable vtable);

	/**
	 * Gets the Type info at the specified address. If the TypeInfo is a ClassTypeInfo
	 * it can be resolved if requested.
	 * @param address the address of the TypeInfo
	 * @param resolve true to resolve the TypeInfo if it happens to be a ClassTypeInfo
	 * @return the TypeInfo at the address
	 */
	TypeInfo getTypeInfo(Address address, boolean resolve);

	/**
	 * Gets the type with a class data type that has the provided id
	 * @param id the universal id
	 * @return the type with the corresponding data type id or null
	 */
	ClassTypeInfoDB getType(UniversalID id);

	@Override
	default void addListener(DomainObjectListener listener) {
		getProgram().addListener(listener);
	}

	@Override
	default void removeListener(DomainObjectListener listener) {
		getProgram().removeListener(listener);
	}

}

```

`src/main/java/cppclassanalyzer/data/TypeInfoManager.java`:

```java
package cppclassanalyzer.data;

import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.gcc.UnresolvedClassTypeInfoException;
import ghidra.program.model.address.Address;

/**
 * Manager for {@link TypeInfo}
 */
public interface TypeInfoManager {

	/**
	 * Get the TypeInfo at the address
	 * @param address the address of the TypeInfo
	 * @return the TypeInfo at the specified address or null if none exists.
	 * @throws UnresolvedClassTypeInfoException if this type requires a copy relocation
	 * which cannot be resolved.
	 */
	TypeInfo getTypeInfo(Address address) throws UnresolvedClassTypeInfoException;

	/**
	 * Checks if a valid TypeInfo is located at the address in the program.
	 * @param address the address of the TypeInfo
	 * @return true if the data is a valid TypeInfo
	 */
	boolean isTypeInfo(Address address);

}

```

`src/main/java/cppclassanalyzer/data/manager/AbstractRttiRecordWorker.java`:

```java
package cppclassanalyzer.data.manager;

import java.io.IOException;
import java.util.stream.LongStream;
import java.util.stream.Stream;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.program.database.DBObjectCache;
import ghidra.program.database.DatabaseObject;
import cppclassanalyzer.data.manager.caches.RttiCachePair;
import cppclassanalyzer.data.manager.recordmanagers.RttiRecordManager;
import cppclassanalyzer.data.manager.tables.RttiTablePair;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;

import cppclassanalyzer.database.record.DatabaseRecord;
import cppclassanalyzer.database.schema.AbstractSchema;
import cppclassanalyzer.database.utils.TransactionHandler;
import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;
import cppclassanalyzer.plugin.TypeInfoArchiveChangeRecord;
import cppclassanalyzer.plugin.TypeInfoArchiveChangeRecord.ChangeType;
import cppclassanalyzer.service.ClassTypeInfoManagerService;
import db.DBRecord;
import db.util.ErrorHandler;

public abstract class AbstractRttiRecordWorker<T1 extends ClassTypeInfoDB,
		T2 extends DatabaseObject, T3 extends DatabaseRecord<?>, T4 extends DatabaseRecord<?>,
		T5 extends RttiTablePair<? extends AbstractSchema<T3>, ? extends AbstractSchema<T4>>>
		implements RttiRecordManager<T1, T2, T3, T4>, ErrorHandler {

	private final T5 tables;
	private final RttiCachePair<T1, T2> caches;
	private final TransactionHandler handler;

	AbstractRttiRecordWorker(T5 tables, RttiCachePair<T1, T2> caches, TransactionHandler handler) {
		this.tables = tables;
		this.caches = caches;
		this.handler = handler;
	}
	abstract long getTypeKey(ClassTypeInfo type);

	abstract long getVtableKey(Vtable vtable);

	abstract T1 buildType(T3 record);

	abstract T1 buildType(ClassTypeInfo type, T3 record);

	abstract T2 buildVtable(T4 record);

	abstract T2 buildVtable(Vtable vtable, T4 record);

	abstract ClassTypeInfoManagerService getPlugin();

	private T3 createTypeRecord(long key) throws IOException {
		T3 record = tables.getTypeSchema().getNewRecord(key);
		tables.getTypeTable().putRecord(record.getRecord());
		return record;
	}

	private T4 createVtableRecord(long key) throws IOException {
		T4 record = tables.getVtableSchema().getNewRecord(key);
		tables.getVtableTable().putRecord(record.getRecord());
		return record;
	}

	@Override
	public final T3 getTypeRecord(long key) {
		try {
			DBRecord record = tables.getTypeTable().getRecord(key);
			if (record != null) {
				return tables.getTypeSchema().getRecord(record);
			}
		} catch (IOException e) {
			dbError(e);
		}
		return null;
	}

	@Override
	public final T4 getVtableRecord(long key) {
		try {
			DBRecord record = tables.getVtableTable().getRecord(key);
			if (record != null) {
				return tables.getVtableSchema().getRecord(record);
			}
		} catch (IOException e) {
			dbError(e);
		}
		return null;
	}

	@Override
	public final void updateRecord(DatabaseRecord<?> record) {
		if (!record.isDirty()) {
			return;
		}
		try {
			handler.startTransaction("Updating Record");
			if (record.hasSameSchema(tables.getTypeSchema())) {
				tables.getTypeTable().putRecord(record.getRecord());
			} else if (record.hasSameSchema(tables.getVtableSchema())) {
				tables.getVtableTable().putRecord(record.getRecord());
			} else {
				throw new IllegalArgumentException(
					"Ghidra-Cpp-Class-Analyzer: unexpected record schema");
			}
		} catch (IOException e) {
			dbError(e);
		} finally {
			handler.endTransaction();
		}
	}

	final T5 getTables() {
		return tables;
	}

	final RttiCachePair<T1, T2> getCaches() {
		return caches;
	}

	@Override
	public final DBObjectCache<T1> getTypeCache() {
		return caches.getTypeCache();
	}

	@Override
	public final DBObjectCache<T2> getVtableCache() {
		return caches.getVtableCache();
	}

	@Override
	public final T1 resolve(ClassTypeInfo type) {
		long key = getTypeKey(type);
		if (key != INVALID_KEY) {
			return getType(key);
		}
		try {
			handler.startTransaction();
			key = getClassKey();
			try {
				T3 record = createTypeRecord(key);
				T1 typeDb = buildType(type, record);
				ClassTypeInfoManagerService service = getPlugin();
				if (service instanceof ClassTypeInfoManagerPlugin) {
					ClassTypeInfoManagerPlugin plugin = (ClassTypeInfoManagerPlugin) service;
					TypeInfoArchiveChangeRecord change =
						new TypeInfoArchiveChangeRecord(ChangeType.TYPE_ADDED, typeDb);
					plugin.managerChanged(change);
				}

				return typeDb;
			} catch (RuntimeException e) {
				getTables().getTypeTable().deleteRecord(key);
				throw e;
			}
		} catch (IOException e) {
			dbError(e);
		} finally {
			handler.endTransaction();
		}
		return null;
	}

	@Override
	public final T2 resolve(Vtable vtable) {
		long key = getVtableKey(vtable);
		if (key != INVALID_KEY) {
			return getVtable(key);
		}
		try {
			handler.startTransaction();
			key = getVtableKey();
			T4 record = createVtableRecord(key);
			return buildVtable(vtable, record);
		} catch (IOException e) {
			dbError(e);
		} finally {
			handler.endTransaction();
		}
		return null;
	}

	@Override
	public final T1 getType(long key) {
		T3 record = getTypeRecord(key);
		if (record == null) {
			return null;
		}
		T1 type = caches.getTypeCache().get(record.getRecord());
		if (type == null) {
			type = buildType(record);
		}
		return type;
	}

	@Override
	public final T2 getVtable(long key) {
		T4 record = getVtableRecord(key);
		if (record == null) {
			return null;
		}
		T2 vtable = caches.getVtableCache().get(record.getRecord());
		if (vtable == null) {
			vtable = buildVtable(record);
		}
		return vtable;
	}

	final long getClassKey() {
		return tables.getTypeTable().getKey();
	}

	final long getVtableKey() {
		return tables.getVtableTable().getKey();
	}

	final Stream<ClassTypeInfoDB> getTypeStream() {
		return getTypeStream(false);
	}

	final Stream<ClassTypeInfoDB> getTypeStream(boolean reverse) {
		long maxKey = tables.getTypeTable().getMaxKey();
		LongStream keys = reverse ? LongStream.iterate(maxKey, i -> i >= 0, i -> i - 1)
			: LongStream.rangeClosed(0, maxKey);
		return keys.filter(this::containsTypeKey)
		.mapToObj(this::getType);
	}

	final Stream<T2> getVtableStream() {
		long maxKey = tables.getVtableTable().getMaxKey();
		return LongStream.rangeClosed(0, maxKey)
			.mapToObj(this::getVtable);
	}

	final Iterable<ClassTypeInfoDB> getTypes() {
		return getTypes(false);
	}

	final Iterable<ClassTypeInfoDB> getTypes(boolean reverse) {
		return () -> getTypeStream(reverse).iterator();
	}

	private boolean containsTypeKey(long key) {
		return getType(key) != null;
	}

}

```

`src/main/java/cppclassanalyzer/data/manager/ArchiveClassTypeInfoManager.java`:

```java
package cppclassanalyzer.data.manager;

import java.io.File;
import java.io.IOException;
import java.util.stream.Stream;

import javax.swing.Icon;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.plugin.core.datamgr.archive.Archive;
import ghidra.app.plugin.core.datamgr.archive.FileArchive;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoTreeNodeManager;
import cppclassanalyzer.service.ClassTypeInfoManagerService;

import ghidra.framework.store.db.PackedDBHandle;
import ghidra.framework.store.db.PackedDatabase;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.manager.caches.ArchivedRttiCachePair;
import cppclassanalyzer.data.manager.tables.ArchivedRttiTablePair;
import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.data.typeinfo.GnuClassTypeInfoDB;
import cppclassanalyzer.data.vtable.ArchivedGnuVtable;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.StandAloneDataTypeManager;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.symbol.Namespace;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

import org.apache.commons.io.FilenameUtils;

import cppclassanalyzer.database.schema.ArchivedClassTypeInfoSchema;
import cppclassanalyzer.database.schema.ArchivedGnuVtableSchema;
import cppclassanalyzer.database.tables.ArchivedClassTypeInfoDatabaseTable;
import cppclassanalyzer.database.tables.ArchivedGnuVtableDatabaseTable;
import cppclassanalyzer.database.utils.TransactionHandler;
import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;
import db.DBConstants;
import db.DBHandle;
import db.Table;
import generic.jar.ResourceFile;
import resources.ResourceManager;

import static ghidra.util.SystemUtilities.isInHeadlessMode;

public final class ArchiveClassTypeInfoManager extends StandAloneDataTypeManager
		implements FileArchiveClassTypeInfoManager {

	private static final Icon[] ICONS = new Icon[] {
		ResourceManager.loadImage("images/openBookGreen.png"),
		ResourceManager.loadImage("images/closedBookGreen.png")
	};

	private final File file;
	private final ClassTypeInfoManagerService plugin;
	private final RttiRecordWorker worker;
	private final TypeInfoTreeNodeManager treeNodeManager;

	private ArchiveClassTypeInfoManager(ClassTypeInfoManagerService plugin,
			File file, int openMode) throws IOException {
		super(new ResourceFile(file), openMode);
		this.plugin = plugin;
		this.file = file;
		ArchivedClassTypeInfoDatabaseTable classTable = getClassTable();
		ArchivedGnuVtableDatabaseTable vtableTable = getVtableTable();
		if (classTable == null) {
			classTable = createClassTable();
		}
		if (vtableTable == null) {
			vtableTable = createVtableTable();
		}
		ArchivedRttiCachePair caches = new ArchivedRttiCachePair();
		ArchivedRttiTablePair tables = new ArchivedRttiTablePair(classTable, vtableTable);
		this.worker = new RttiRecordWorker(tables, caches);
		this.name = FilenameUtils.removeExtension(file.getName());
		if (!isInHeadlessMode()) {
			this.treeNodeManager =
				new TypeInfoTreeNodeManager((ClassTypeInfoManagerPlugin) plugin, this);
			treeNodeManager.generateTree();
		} else {
			this.treeNodeManager = null;
		}
	}

	@Override
	public ClassTypeInfoManagerPlugin getPlugin() {
		try {
			return (ClassTypeInfoManagerPlugin) plugin;
		} catch (ClassCastException e) {
			throw new AssertException("This should be unreachable in headless mode", e);
		}
	}

	private ArchivedClassTypeInfoDatabaseTable getClassTable() {
		Table classTable = dbHandle.getTable(ArchivedClassTypeInfo.TABLE_NAME);
		if (classTable == null) {
			return null;
		}
		return new ArchivedClassTypeInfoDatabaseTable(classTable);
	}

	private ArchivedGnuVtableDatabaseTable getVtableTable() {
		Table vtableTable = dbHandle.getTable(ArchivedGnuVtable.TABLE_NAME);
		if (vtableTable == null) {
			return null;
		}
		return new ArchivedGnuVtableDatabaseTable(vtableTable);
	}

	private ArchivedClassTypeInfoDatabaseTable createClassTable() throws IOException {
		long id = dbHandle.startTransaction();
		Table classTable = dbHandle.createTable(
			ArchivedClassTypeInfo.TABLE_NAME,
			ArchivedClassTypeInfoSchema.SCHEMA,
			ArchivedClassTypeInfoSchema.INDEXED_COLUMNS);
		dbHandle.endTransaction(id, true);
		return new ArchivedClassTypeInfoDatabaseTable(classTable);
	}

	private ArchivedGnuVtableDatabaseTable createVtableTable() throws IOException {
		long id = dbHandle.startTransaction();
		Table vtableTable = dbHandle.createTable(
			ArchivedGnuVtable.TABLE_NAME,
			ArchivedGnuVtableSchema.SCHEMA,
			ArchivedGnuVtableSchema.INDEXED_COLUMNS);
		dbHandle.endTransaction(id, true);
		return new ArchivedGnuVtableDatabaseTable(vtableTable);
	}

	public static ArchiveClassTypeInfoManager createManager(ClassTypeInfoManagerService plugin,
			File file) throws IOException {
		return new ArchiveClassTypeInfoManager(plugin, file, DBConstants.CREATE);
	}

	@Override
	public String getPath() {
		return file.getAbsolutePath();
	}

	@Override
	public boolean isModifiable() {
		return dbHandle.canUpdate();
	}

	public static ArchiveClassTypeInfoManager open(ClassTypeInfoManagerService plugin, File file,
			boolean openForUpdate) throws IOException {
		int mode = openForUpdate ? DBConstants.UPDATE : DBConstants.READ_ONLY;
		return new ArchiveClassTypeInfoManager(plugin, file, mode);
	}

	@Override
	public void close() {
		try {
			if (dbHandle.isChanged()) {
				File tmp = new File(file.getParentFile(), file.getName() + "_tmp");
				((PackedDBHandle) dbHandle).saveAs(
					"CTIArchive", tmp.getParentFile(), tmp.getName(), null, TaskMonitor.DUMMY);
				super.close();
				file.delete();
				tmp.renameTo(file);
			} else {
				super.close();
			}
		} catch (CancelledException e) {
			throw new AssertException(e);
		} catch (IOException ioe) {
			worker.dbError(ioe);
		}
	}

	@Override
	public boolean isChanged() {
		return dbHandle.isChanged();
	}

	@Override
	public void save() {
		try {
			if (dbHandle.isChanged()) {
				((PackedDBHandle) dbHandle).save(TaskMonitor.DUMMY);
			}
		} catch (IOException e) {
			worker.dbError(e);
		} catch (CancelledException ce) {
			throw new AssertException(ce);
		}
	}

	public ArchivedClassTypeInfo resolve(ClassTypeInfo type) {
		if (type instanceof GnuClassTypeInfoDB) {
			return resolve((GnuClassTypeInfoDB) type);
		}
		return null;
	}

	public ArchivedClassTypeInfo resolve(GnuClassTypeInfoDB type) {
		return worker.resolve(type);
	}

	@Override
	public Stream<ClassTypeInfoDB> getTypeStream() {
		return worker.getTypeStream();
	}

	@Override
	public ClassTypeInfoDB getType(GhidraClass gc) {
		return worker.getType(gc);
	}

	@Override
	public ClassTypeInfoDB getType(Function fun) {
		return worker.getType(fun);
	}

	@Override
	public ClassTypeInfoDB getType(String name, Namespace namespace) {
		return worker.getType(name, namespace);
	}

	@Override
	public ClassTypeInfoDB getType(String symbolName) {
		return worker.getType(symbolName);
	}

	public void populate(ProgramClassTypeInfoManager manager, TaskMonitor monitor)
			throws CancelledException {
		long id = dbHandle.startTransaction();
		try {
			monitor.initialize(manager.getTypeCount());
			monitor.setMessage("Populating Data Archive");
			for (ClassTypeInfo type : manager.getTypes()) {
				monitor.checkCanceled();
				if (!(type instanceof GnuClassTypeInfoDB)) {
					monitor.setMessage("Only GNU db are supported");
					break;
				}
				worker.resolve(type);
				Vtable vtable = type.getVtable();
				if (Vtable.isValid(vtable)) {
					worker.resolve(vtable);
				}
				monitor.incrementProgress(1);
			}
			dbHandle.endTransaction(id, true);
		} catch (IOException e) {
			dbError(e);
		}
	}

	@Override
	public int getTypeCount() {
		return worker.getTables().getTypeTable().getRecordCount();
	}

	@Override
	public Iterable<ClassTypeInfoDB> getTypes() {
		return () -> worker.getTypeStream().iterator();
	}

	@Override
	public Icon getIcon(boolean expanded) {
		return expanded ? ICONS[0] : ICONS[1];
	}

	@Override
	public TypeInfoTreeNodeManager getTreeNodeManager() {
		return treeNodeManager;
	}

	@Override
	public ClassTypeInfoDB getType(long key) {
		return worker.getType(key);
	}

	public static FileArchiveClassTypeInfoManager openIfManagerArchive(
			ClassTypeInfoManagerPlugin plugin, Archive archive) throws IOException {
		if (archive instanceof FileArchive) {
			try {
				ResourceFile resource = ((FileArchive) archive).getFile();
				PackedDatabase db =
					PackedDatabase.getPackedDatabase(resource, false, TaskMonitor.DUMMY);
				DBHandle handle = db.open(TaskMonitor.DUMMY);
				if (handle.getTable(ArchivedClassTypeInfo.TABLE_NAME) != null) {
					File file = resource.getFile(false);
					boolean updateable = archive.isModifiable();
					plugin.getDataTypeManagerHandler().closeArchive(archive);
					return open(plugin, file, updateable);
				}
			} catch (CancelledException e) {
			}
		}
		return null;
	}

	private void endTransaction(long id, boolean commit) {
		endTransaction((int) id, commit);
	}

	private TransactionHandler getHandler() {
		return new TransactionHandler(this::startTransaction, this::endTransaction);
	}

	private final class RttiRecordWorker extends ArchiveRttiRecordWorker {

		RttiRecordWorker(ArchivedRttiTablePair tables, ArchivedRttiCachePair caches) {
			super(ArchiveClassTypeInfoManager.this, tables, caches, getHandler());
		}

		@Override
		ClassTypeInfoManagerService getPlugin() {
			return plugin;
		}

		@Override
		public DataTypeManager getDataTypeManager() {
			return ArchiveClassTypeInfoManager.this;
		}
	}
}

```

`src/main/java/cppclassanalyzer/data/manager/ArchiveRttiRecordWorker.java`:

```java
package cppclassanalyzer.data.manager;

import java.io.IOException;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.app.cmd.data.rtti.gcc.UnresolvedClassTypeInfoException;
import ghidra.app.cmd.data.rtti.gcc.VtableUtils;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.manager.caches.ArchivedRttiCachePair;
import cppclassanalyzer.data.manager.recordmanagers.ArchiveRttiRecordManager;
import cppclassanalyzer.data.manager.tables.ArchivedRttiTablePair;
import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.typeinfo.GnuClassTypeInfoDB;
import cppclassanalyzer.data.vtable.ArchivedGnuVtable;

import ghidra.program.database.DatabaseObject;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.util.Msg;

import cppclassanalyzer.database.record.ArchivedClassTypeInfoRecord;
import cppclassanalyzer.database.record.ArchivedGnuVtableRecord;
import cppclassanalyzer.database.schema.fields.ArchivedClassTypeInfoSchemaFields;
import cppclassanalyzer.database.schema.fields.ArchivedGnuVtableSchemaFields;
import cppclassanalyzer.database.utils.TransactionHandler;
import db.Field;
import db.StringField;

abstract class ArchiveRttiRecordWorker extends
		AbstractRttiRecordWorker<ArchivedClassTypeInfo, ArchivedGnuVtable,
			ArchivedClassTypeInfoRecord, ArchivedGnuVtableRecord, ArchivedRttiTablePair>
		implements ArchiveRttiRecordManager {

	private static final String MANGLED_TYPEINFO_PREFIX = "_ZTI";

	private final ClassTypeInfoManager manager;

	ArchiveRttiRecordWorker(ClassTypeInfoManager manager, ArchivedRttiTablePair tables,
			ArchivedRttiCachePair caches, TransactionHandler handler) {
		super(tables, caches, handler);
		this.manager = manager;
	}

	@Override
	public ClassTypeInfoManager getManager() {
		return manager;
	}

	@Override
	long getTypeKey(ClassTypeInfo type) {
		if (type instanceof ArchivedClassTypeInfo) {
			return ((ArchivedClassTypeInfo) type).getKey();
		}
		return getTypeKey(TypeInfoUtils.getSymbolName(type));
	}

	@Override
	long getVtableKey(Vtable vtable) {
		return getVtableKey(VtableUtils.getSymbolName(vtable));
	}

	@Override
	ArchivedClassTypeInfo buildType(ArchivedClassTypeInfoRecord record) {
		return new ArchivedClassTypeInfo(this, record);
	}

	@Override
	ArchivedClassTypeInfo buildType(ClassTypeInfo type, ArchivedClassTypeInfoRecord record) {
		if (type instanceof GnuClassTypeInfoDB) {
			return new ArchivedClassTypeInfo(this, (GnuClassTypeInfoDB) type, record);
		}
		return null;
	}

	@Override
	public void dbError(IOException e) {
		Msg.showError(this, null, "IO ERROR", e.getMessage(), e);
	}

	@Override
	final ArchivedGnuVtable buildVtable(ArchivedGnuVtableRecord record) {
		return new ArchivedGnuVtable(this, record);
	}

	@Override
	final ArchivedGnuVtable buildVtable(Vtable vtable, ArchivedGnuVtableRecord record) {
		return new ArchivedGnuVtable(this, (GnuVtable) vtable, record);
	}

	public final long getTypeKey(String symbolName) {
		try {
			StringField field = new StringField(symbolName);
			Field[] results = getTables().getTypeTable().findRecords(
				field, ArchivedClassTypeInfoSchemaFields.MANGLED_SYMBOL.ordinal());
			if (results.length == 1) {
				return results[0].getLongValue();
			}
		} catch (IOException e) {
			dbError(e);
		}
		return INVALID_KEY;
	}

	public final long getVtableKey(String symbolName) {
		try {
			StringField field = new StringField(symbolName);
			Field[] results = getTables().getVtableTable().findRecords(
				field, ArchivedGnuVtableSchemaFields.MANGLED_SYMBOL.ordinal());
			if (results.length == 1) {
				return results[0].getLongValue();
			}
		} catch (IOException e) {
			dbError(e);
		}
		return INVALID_KEY;
	}

	ArchivedClassTypeInfo getType(GhidraClass gc) throws UnresolvedClassTypeInfoException {
		Program program = gc.getSymbol().getProgram();
		SymbolTable table = program.getSymbolTable();
		return table.getSymbols(TypeInfo.TYPENAME_SYMBOL_NAME, gc)
			.stream()
			.findFirst()
			.map(Symbol::getAddress)
			.map(a -> TypeInfoUtils.getTypeName(program, a))
			.map(this::getType)
			.orElseGet(() -> {
				return null;
			});
	}

	ArchivedClassTypeInfo getType(Function fun) throws UnresolvedClassTypeInfoException {
		Namespace ns = fun.getParentNamespace();
		if (ns instanceof GhidraClass) {
			return getType((GhidraClass) ns);
		}
		return null;
	}

	ArchivedClassTypeInfo getType(String name, Namespace namespace)
			throws UnresolvedClassTypeInfoException {
		Program program = namespace.getSymbol().getProgram();
		SymbolTable table = program.getSymbolTable();
		Symbol s = table.getClassSymbol(name, namespace);
		if (s != null) {
			return getType((GhidraClass) s.getObject());
		}
		return null;
	}

	ArchivedClassTypeInfo getType(String symbolName) throws UnresolvedClassTypeInfoException {
		if (symbolName.isBlank() || !symbolName.startsWith(MANGLED_TYPEINFO_PREFIX)) {
			return null;
		}
		try {
			db.Field f = new StringField(symbolName);
			Field[] keys = getTables().getTypeTable().findRecords(
				f, ArchivedClassTypeInfoSchemaFields.MANGLED_SYMBOL.ordinal());
			if (keys.length == 1) {
				return getType(keys[0].getLongValue());
			}
		} catch (IOException e) {
			dbError(e);
		}
		return null;
	}
	
	DatabaseObject getArchivedData(String symbolName) {
		long key = getTypeKey(symbolName);
		if (key != INVALID_KEY) {
			return getType(key);
		}
		key = getVtableKey(symbolName);
		if (key != INVALID_KEY) {
			return getVtable(key);
		}
		return null;
	}

}

```

`src/main/java/cppclassanalyzer/data/manager/ClassTypeInfoManagerDB.java`:

```java
package cppclassanalyzer.data.manager;

import java.io.IOException;
import java.util.*;
import java.util.function.ToLongFunction;
import java.util.stream.Stream;

import javax.swing.Icon;

import ghidra.app.cmd.data.rtti.*;

import cppclassanalyzer.plugin.typemgr.node.TypeInfoTreeNodeManager;
import cppclassanalyzer.service.ClassTypeInfoManagerService;
import db.*;

import ghidra.program.database.ManagerDB;
import ghidra.program.database.ProgramDB;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.manager.caches.ProgramRttiCachePair;
import cppclassanalyzer.data.manager.recordmanagers.ProgramRttiRecordManager;
import cppclassanalyzer.data.manager.tables.ProgramRttiTablePair;
import cppclassanalyzer.data.typeinfo.*;
import cppclassanalyzer.data.vtable.*;
import ghidra.program.database.map.AddressMap;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressOverflowException;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.*;
import ghidra.util.Msg;
import ghidra.util.UniversalID;
import ghidra.util.datastruct.LongArrayList;
import ghidra.util.exception.*;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.database.record.ClassTypeInfoRecord;
import cppclassanalyzer.database.record.VtableRecord;
import cppclassanalyzer.database.schema.ClassTypeInfoSchema;
import cppclassanalyzer.database.schema.VtableSchema;
import cppclassanalyzer.database.schema.fields.ClassTypeInfoSchemaFields;
import cppclassanalyzer.database.schema.fields.VtableSchemaFields;
import cppclassanalyzer.database.tables.ClassTypeInfoDatabaseTable;
import cppclassanalyzer.database.tables.VtableDatabaseTable;
import cppclassanalyzer.database.utils.TransactionHandler;
import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;
import cppclassanalyzer.plugin.TypeInfoArchiveChangeRecord;
import cppclassanalyzer.plugin.TypeInfoArchiveChangeRecord.ChangeType;
import resources.ResourceManager;
import util.CollectionUtils;

public abstract class ClassTypeInfoManagerDB implements ManagerDB, ProgramClassTypeInfoManager {

	private static final Icon[] ICONS = new Icon[] {
		ResourceManager.loadImage("images/openBookRed.png"),
		ResourceManager.loadImage("images/closedBookRed.png")
	};

	private final AddressMap map;
	protected final ClassTypeInfoManagerService plugin;
	protected final ProgramDB program;
	protected final RttiRecordWorker worker;
	protected final TypeInfoTreeNodeManager treeNodeManager;

	protected ClassTypeInfoManagerDB(ClassTypeInfoManagerService service, ProgramDB program) {
		this.plugin = service;
		this.program = program;
		this.map = program.getAddressMap();
		DBHandle handle = program.getDBHandle();
		ClassTypeInfoDatabaseTable classTable = getClassTable(handle);
		VtableDatabaseTable vtableTable = getVtableTable(handle);
		if (shouldResetDatabase(classTable, vtableTable)) {
			try {
				long id = handle.isTransactionActive() ? -1 : handle.startTransaction();
				if (classTable != null) {
					handle.deleteTable(AbstractClassTypeInfoDB.CLASS_TYPEINFO_TABLE_NAME);
				}
				if (vtableTable != null) {
					handle.deleteTable(AbstractVtableDB.VTABLE_TABLE_NAME);
				}
				classTable = getNewClassTable(handle);
				vtableTable = getNewVtableTable(handle);
				if (id != -1) {
					handle.endTransaction(id, true);
				}
			} catch (IOException e) {
				dbError(e);
			}
		}
		ProgramRttiCachePair caches = new ProgramRttiCachePair();
		ProgramRttiTablePair tables = new ProgramRttiTablePair(classTable, vtableTable);
		this.worker = getWorker(tables, caches);
		if (service instanceof ClassTypeInfoManagerPlugin) {
			ClassTypeInfoManagerPlugin plugin = (ClassTypeInfoManagerPlugin) service;
			this.treeNodeManager = new TypeInfoTreeNodeManager(plugin, this);
			treeNodeManager.generateTree();
		} else {
			this.treeNodeManager = null;
		}
	}

	private ClassTypeInfoDatabaseTable getClassTable(DBHandle handle) {
		Table classTable = handle.getTable(AbstractClassTypeInfoDB.CLASS_TYPEINFO_TABLE_NAME);
		if (classTable != null) {
			return new ClassTypeInfoDatabaseTable(classTable);
		}
		return null;
	}

	private VtableDatabaseTable getVtableTable(DBHandle handle) {
		Table vtableTable = handle.getTable(AbstractVtableDB.VTABLE_TABLE_NAME);
		if (vtableTable != null) {
			return new VtableDatabaseTable(vtableTable);
		}
		return null;
	}

	private static boolean shouldResetDatabase(ClassTypeInfoDatabaseTable classTable,
			VtableDatabaseTable vtableTable) {
		if (classTable == null || vtableTable == null) {
			return true;
		}
		if (!ClassTypeInfoSchema.SCHEMA.equals(classTable.getSchema())) {
			return true;
		}
		return !VtableSchema.SCHEMA.equals(vtableTable.getSchema());
	}

	protected abstract RttiRecordWorker getWorker(
		ProgramRttiTablePair tables, ProgramRttiCachePair caches);

	protected static ClassTypeInfoDatabaseTable getNewClassTable(DBHandle handle) throws IOException {
		Table classTable = handle.createTable(
			AbstractClassTypeInfoDB.CLASS_TYPEINFO_TABLE_NAME,
			ClassTypeInfoSchema.SCHEMA,
			ClassTypeInfoSchema.INDEXED_COLUMNS);
		return new ClassTypeInfoDatabaseTable(classTable);
	}

	private static VtableDatabaseTable getNewVtableTable(DBHandle handle) throws IOException {
		Table vtableTable = handle.createTable(
			AbstractVtableDB.VTABLE_TABLE_NAME,
			VtableSchema.SCHEMA,
			VtableSchema.INDEXED_COLUMNS);
		return new VtableDatabaseTable(vtableTable);
	}

	@Override
	public final String getName() {
		return getProgram().getName();
	}

	@Override
	public Icon getIcon(boolean expanded) {
		return expanded ? ICONS[0] : ICONS[1];
	}

	public final long getTypeKey(Address address) {
		try {
			long addrKey = encodeAddress(address);
			Field[] keys = worker.getTables()
				.getTypeTable()
				.findRecords(
					new LongField(addrKey),
					ClassTypeInfoSchemaFields.ADDRESS.ordinal());
			if (keys.length == 1) {
				return keys[0].getLongValue();
			}
			if (keys.length > 1) {
				throw new AssertException(
					"Ghidra-Cpp-Class-Analyzer: duplicate ClassTypeInfo detected");
			}
		} catch (IOException e) {
			dbError(e);
		}
		return INVALID_KEY;
	}

	public final long getVtableKey(Address address) {
		try {
			long addrKey = encodeAddress(address);
			Field[] keys = worker.getTables()
				.getVtableTable()
				.findRecords(
					new LongField(addrKey), VtableSchemaFields.ADDRESS.ordinal());
			if (keys.length == 1) {
				return keys[0].getLongValue();
			}
			if (keys.length > 1) {
				throw new AssertException(
					"Ghidra-Cpp-Class-Analyzer: duplicate Vtable detected");
			}
		} catch (IOException e) {
			dbError(e);
		}
		return INVALID_KEY;
	}

	public final Address decodeAddress(long offset) {
		return map.decodeAddress(offset);
	}

	public final long encodeAddress(Address address) {
		return map.getKey(address, true);
	}

	private boolean containsClassKey(Address address) {
		try {
			long key = getTypeKey(address);
			if (key != INVALID_KEY) {
				return worker.getTables().getTypeTable().hasRecord(key);
			}
		} catch (IOException e) {
			dbError(e);
		}
		return false;
	}

	boolean hasVtable(long key) {
		if (key == 0) {
			return false;
		}
		try {
			return worker.getTables().getVtableTable().hasRecord(key);
		} catch (IOException e) {
			dbError(e);
			return false;
		}
	}

	public final boolean containsRecord(AbstractVtableDB vtable) {
		return hasVtable(vtable.getKey());
	}

	@Override
	public final ProgramDB getProgram() {
		return program;
	}

	@Override
	public final void setProgram(ProgramDB program) {
		throw new UnsupportedOperationException();
	}

	@Override
	public void programReady(int openMode, int currentRevision, TaskMonitor monitor)
			throws IOException, CancelledException {
		// do nothing
	}

	@Override
	public final void invalidateCache(boolean all) {
		worker.getCaches().invalidate();
	}

	private LongArrayList getTypeKeys(Address startAddr, Address endAddr, TaskMonitor monitor)
			throws CancelledException {
		return getRangedKeys(startAddr, endAddr, this::getTypeKey, monitor);
	}

	private LongArrayList getVtableKeys(Address startAddr, Address endAddr, TaskMonitor monitor)
			throws CancelledException {
		return getRangedKeys(startAddr, endAddr, this::getVtableKey, monitor);
	}

	private LongArrayList getRangedKeys(Address startAddr, Address endAddr,
			ToLongFunction<Address> keyFinder, TaskMonitor monitor) throws CancelledException {
		LongArrayList keys = new LongArrayList();
		Address currentAddress = startAddr;
		while (currentAddress.compareTo(endAddr) < 0) {
			monitor.checkCanceled();
			long key = keyFinder.applyAsLong(currentAddress);
			if (key != INVALID_KEY) {
				keys.add(key);
			}
			currentAddress.add(currentAddress.getPointerSize());
		}
		return keys;
	}

	@Override
	public void deleteAddressRange(Address startAddr, Address endAddr, TaskMonitor monitor)
			throws CancelledException {
		try {
			Table table = worker.getTables().getTypeTable();
			for (long key : getTypeKeys(startAddr, endAddr, monitor)) {
				monitor.checkCanceled();
				table.deleteRecord(key);
			}
			table = worker.getTables().getVtableTable();
			for (long key : getVtableKeys(startAddr, endAddr, monitor)) {
				monitor.checkCanceled();
				table.deleteRecord(key);
			}
		} catch (IOException e) {
			dbError(e);
		}
	}

	@Override
	public void moveAddressRange(Address fromAddr, Address toAddr, long length, TaskMonitor monitor)
			throws AddressOverflowException, CancelledException {
		try {
			Address endAddr = fromAddr.add(length);
			Table table = worker.getTables().getTypeTable();
			int ordinal = ClassTypeInfoSchemaFields.ADDRESS.ordinal();
			for (long key : getTypeKeys(fromAddr, endAddr, monitor)) {
				monitor.checkCanceled();
				DBRecord record = table.getRecord(key);
				Address addr = decodeAddress(record.getLongValue(ordinal));
				long offset = addr.subtract(fromAddr);
				record.setLongValue(ordinal, encodeAddress(toAddr.add(offset)));
			}
			table = worker.getTables().getVtableTable();
			ordinal = VtableSchemaFields.ADDRESS.ordinal();
			for (long key : getVtableKeys(fromAddr, endAddr, monitor)) {
				monitor.checkCanceled();
				DBRecord record = table.getRecord(key);
				Address addr = decodeAddress(record.getLongValue(ordinal));
				long offset = addr.subtract(fromAddr);
				record.setLongValue(ordinal, encodeAddress(toAddr.add(offset)));
			}
		} catch (IOException e) {
			dbError(e);
		}
	}

	@Override
	public ClassTypeInfoDB getType(Address address) {
		long key = getTypeKey(address);
		if (key != INVALID_KEY) {
			return worker.getType(key);
		}
		if (!isTypeInfo(address)) {
			return null;
		}
		return (ClassTypeInfoDB) getTypeInfo(address, true);
	}

	@Override
	public Vtable getVtable(Address address) {
		long key = getVtableKey(address);
		if (key == INVALID_KEY) {
			return Vtable.NO_VTABLE;
		}
		return worker.getVtable(key);
	}

	@Override
	public ClassTypeInfoDB getType(GhidraClass gc) {
		SymbolTable table = program.getSymbolTable();
		List<Symbol> symbols = table.getSymbols("typeinfo", gc);
		if (symbols.size() == 1) {
			return getType(symbols.get(0).getAddress());
		}
		return null;
	}

	@Override
	public ClassTypeInfoDB getType(Function fun) {
		if (fun.getParentNamespace().isGlobal()) {
			return null;
		}
		GenericCallingConvention cc = fun.getSignature().getGenericCallingConvention();
		if (cc.equals(GenericCallingConvention.thiscall)) {
			if (!(fun.getParentNamespace() instanceof GhidraClass)) {
				Msg.info(this, fun.getParentNamespace().getName(true)+" is not a class");
				return null;
			}
			return getType((GhidraClass) fun.getParentNamespace());
		}
		return null;
	}

	@Override
	public ClassTypeInfoDB getType(String name) {
		SymbolTable table = program.getSymbolTable();
		return CollectionUtils.asStream(table.getSymbols(name))
			.map(Symbol::getAddress)
			.map(this::getType)
			.findFirst()
			.orElse(null);
	}

	@Override
	public ClassTypeInfoDB getType(String name, Namespace namespace) {
		SymbolTable table = program.getSymbolTable();
		Symbol symbol = table.getClassSymbol(name, namespace);
		if (symbol != null) {
			return getType((GhidraClass) symbol.getObject());
		}
		return null;
	}

	@Override
	public AbstractClassTypeInfoDB resolve(ClassTypeInfo type) {
		if (type instanceof AbstractClassTypeInfoDB) {
			if (((AbstractClassTypeInfoDB) type).checkIsValid()) {
				return (AbstractClassTypeInfoDB) type;
			}
		}
		return (AbstractClassTypeInfoDB) worker.resolve(type);
	}

	@Override
	public Vtable resolve(Vtable vtable) {
		return (Vtable) worker.resolve(vtable);
	}

	@Override
	public AbstractClassTypeInfoDB resolve(ArchivedClassTypeInfo type) {
		Address address = type.getAddress(program);
		long key = getTypeKey(address);
		if (key != INVALID_KEY) {
			return (AbstractClassTypeInfoDB) worker.getType(key);
		}
		key = worker.getClassKey();
		ClassTypeInfoRecord record =
			ClassTypeInfoSchema.SCHEMA.getNewRecord(key);
		worker.updateRecord(record);
		AbstractClassTypeInfoDB result = new GnuClassTypeInfoDB(worker, type, record);
		TypeInfoArchiveChangeRecord changeRecord =
			new TypeInfoArchiveChangeRecord(ChangeType.TYPE_ADDED, result);
		if (plugin instanceof ClassTypeInfoManagerPlugin) {
			((ClassTypeInfoManagerPlugin) plugin).managerChanged(changeRecord);
		}
		return result;
	}

	@Override
	public Vtable resolve(ArchivedGnuVtable vtable) {
		Address address = vtable.getAddress(program);
		long key = getVtableKey(address);
		if (key != INVALID_KEY) {
			return (Vtable) worker.getVtable(key);
		}
		SymbolTable table = program.getSymbolTable();
		Symbol s = table.getExternalSymbol(vtable.getSymbolName());
		if (s == null) {
			// nothing to do
			return null;
		}
		ExternalManager man = program.getExternalManager();
		ExternalLocation loc = man.getExternalLocation(s);
		try {
			loc.setAddress(address);
		} catch (InvalidInputException e) {
			throw new AssertException(e);
		}
		key = worker.getVtableKey();
		VtableRecord record = VtableSchema.SCHEMA.getNewRecord(key);
		worker.updateRecord(record);
		return new VtableModelDB(worker, vtable, record);
	}

	@Override
	public int getTypeCount() {
		return worker.getTables().getTypeTable().getRecordCount();
	}

	@Override
	public int getVtableCount() {
		return worker.getTables().getVtableTable().getRecordCount();
	}

	@Override
	public Iterable<ClassTypeInfoDB> getTypes(boolean reverse) {
		return worker.getTypes(reverse);
	}

	@Override
	public Iterable<Vtable> getVtableIterable(boolean reverse) {
		return () -> getTypeStream(reverse)
			.map(ClassTypeInfo::getVtable)
			.filter(Vtable::isValid)
			.iterator();
	}

	@Override
	public Stream<ClassTypeInfoDB> getTypeStream(boolean reverse) {
		return worker.getTypeStream(reverse);
	}

	@Override
	public Stream<Vtable> getVtableStream() {
		// vtableTable is NOT sorted
		return getTypeStream()
			.map(ClassTypeInfo::getVtable)
			.filter(Vtable::isValid);
	}

	@Override
	public TypeInfo getTypeInfo(Address address) {
		return getTypeInfo(address, true);
	}

	public TypeInfo getTypeInfo(Address address, boolean resolve) {
		if (containsClassKey(address) && resolve) {
			return getType(address);
		}
		return null;
	}

	@Override
	public TypeInfoTreeNodeManager getTreeNodeManager() {
		return treeNodeManager;
	}

	@Override
	public void dbError(IOException e) {
		program.dbError(e);
	}

	@Override
	public synchronized ClassTypeInfoDB getType(long key) {
		return worker.getType(key);
	}

	@Override
	public AbstractClassTypeInfoDB getType(UniversalID id) {
		try {
			Table table = worker.getTables().getTypeTable();
			LongField field = new LongField(id.getValue());
			Field[] keys =
				table.findRecords(field, ClassTypeInfoSchemaFields.DATATYPE_ID.ordinal());
			if (keys.length == 1) {
				return worker.getType(keys[0].getLongValue());
			}
		} catch (IOException e) {
			dbError(e);
		}
		return null;
	}

	@Override
	public void dispose() {
		if (treeNodeManager != null) {
			treeNodeManager.dispose();
		}
	}

	private void endTransaction(long id, boolean commit) {
		program.endTransaction((int) id, commit);
	}

	private TransactionHandler getHandler() {
		return new TransactionHandler(program::startTransaction, this::endTransaction);
	}

	protected abstract class RttiRecordWorker
			extends AbstractRttiRecordWorker<
				AbstractClassTypeInfoDB, AbstractVtableDB,
				ClassTypeInfoRecord, VtableRecord, ProgramRttiTablePair>
			implements ProgramRttiRecordManager {

		RttiRecordWorker(ProgramRttiTablePair tables, ProgramRttiCachePair caches) {
			super(tables, caches, getHandler());
		}

		@Override
		public final void dbError(IOException e) {
			dbError(e);
		}

		@Override
		public final ClassTypeInfoManagerDB getManager() {
			return ClassTypeInfoManagerDB.this;
		}

		@Override
		final long getTypeKey(ClassTypeInfo type) {
			return getManager().getTypeKey(type.getAddress());
		}

		@Override
		final long getVtableKey(Vtable vtable) {
			return getManager().getVtableKey(vtable.getAddress());
		}

		@Override
		final ClassTypeInfoManagerService getPlugin() {
			return plugin;
		}

		@Override
		public final AbstractClassTypeInfoDB resolve(ArchivedClassTypeInfo type) {
			return getManager().resolve(type);
		}
	}
}

```

`src/main/java/cppclassanalyzer/data/manager/FileArchiveClassTypeInfoManager.java`:

```java
package cppclassanalyzer.data.manager;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;

import ghidra.program.model.data.FileBasedDataTypeManager;

/**
 * A ClassTypeInfoManager implementation which is based on a FileArchive
 */
public interface FileArchiveClassTypeInfoManager extends ClassTypeInfoManager,
		FileBasedDataTypeManager {

	/**
	 * Saves all changed data
	 */
	public void save();

	/**
	 * Checks if the manager can be changed
	 * @return true if the manager can be changed
	 */
	public boolean isModifiable();

	/**
	 * Checks if data in the manager has been changed
	 * @return true if data has been changed
	 */
	public boolean isChanged();

	public ClassTypeInfoManagerPlugin getPlugin();
}

```

`src/main/java/cppclassanalyzer/data/manager/ItaniumAbiClassTypeInfoManager.java`:

```java
package cppclassanalyzer.data.manager;

import java.io.IOException;
import java.util.Arrays;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import ghidra.app.cmd.data.rtti.*;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.database.ProgramDB;
import ghidra.program.model.address.Address;
import ghidra.program.model.symbol.Symbol;
import ghidra.util.datastruct.LongIntHashtable;
import ghidra.util.datastruct.RedBlackLongKeySet;
import ghidra.util.exception.*;
import ghidra.util.task.CancelOnlyWrappingTaskMonitor;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.data.manager.caches.ProgramRttiCachePair;
import cppclassanalyzer.data.manager.tables.ProgramRttiTablePair;
import cppclassanalyzer.data.typeinfo.*;
import cppclassanalyzer.data.vtable.AbstractVtableDB;
import cppclassanalyzer.data.vtable.VtableModelDB;
import cppclassanalyzer.database.record.ClassTypeInfoRecord;
import cppclassanalyzer.database.record.SchemaRecordIterator;
import cppclassanalyzer.database.record.VtableRecord;
import cppclassanalyzer.database.schema.fields.ClassTypeInfoSchemaFields;
import cppclassanalyzer.database.tables.ClassTypeInfoDatabaseTable;
import cppclassanalyzer.database.utils.LongStack;
import cppclassanalyzer.scanner.ItaniumAbiRttiScanner;
import cppclassanalyzer.scanner.RttiScanner;
import cppclassanalyzer.service.ClassTypeInfoManagerService;
import db.*;

public final class ItaniumAbiClassTypeInfoManager extends ClassTypeInfoManagerDB {

	private ItaniumAbiRttiScanner scanner;

	public ItaniumAbiClassTypeInfoManager(ClassTypeInfoManagerService plugin, ProgramDB program) {
		super(plugin, program);
	}

	protected final ItaniumAbiRttiScanner getScanner() {
		if (scanner == null) {
			this.scanner = (ItaniumAbiRttiScanner) RttiScanner.getScanner(program);
		}
		return scanner;
	}

	@Override
	public TypeInfo getTypeInfo(Address address, boolean resolve) {
		TypeInfo ti = super.getTypeInfo(address, resolve);
		if (ti == null) {
			ti = getScanner().getTypeInfo(address);
		}
		if (ti instanceof ClassTypeInfo && resolve) {
			ti = resolve((ClassTypeInfo) ti);
		}
		return ti;
	}

	@Override
	public boolean isTypeInfo(Address address) {
		return getScanner().isTypeInfo(address);
	}

	public ClassTypeInfoDB getExternalClassTypeInfo(Address address) {
		String mangled = Arrays.stream(program.getSymbolTable().getSymbols(address))
			.map(Symbol::getName)
			.filter(s -> s.startsWith("_ZTI"))
			.filter(s -> !s.contains("@"))
			.findFirst()
			.orElse(null);
		if (mangled != null) {
			ArchivedClassTypeInfo type = plugin.getExternalClassTypeInfo(program, mangled);
			if (type != null) {
				return resolve(type);
			}
		}
		return null;
	}

	@Override
	protected GnuRttiRecordWorker getWorker(ProgramRttiTablePair tables,
			ProgramRttiCachePair caches) {
		return new GnuRttiRecordWorker(tables, caches);
	}

	private ClassTypeInfoRecord[] getClassRecords() {
		try {
			ClassTypeInfoRecord[] keys = new ClassTypeInfoRecord[getTypeCount()];
			RecordIterator iter = worker.getTables().getTypeTable().iterator();
			for (int i = 0; i < keys.length && iter.hasNext(); i++) {
				keys[i] = new ClassTypeInfoRecord(iter.next());
			}
			return keys;
		} catch (IOException e) {
			dbError(e);
			return null;
		}
	}

	private Stream<ClassTypeInfoRecord> getRecordStream(ClassTypeInfoRecord[] records) {
		return Arrays.stream(records)
			.parallel();
	}

	public void findVtables(TaskMonitor monitor, MessageLog log) throws CancelledException {
		TaskMonitor dummy = new CancelOnlyWrappingTaskMonitor(monitor);
		sort(monitor);
		monitor.initialize(getTypeCount());
		monitor.setMessage("Finding vtables");
		for (ClassTypeInfoDB type : getTypes(true)) {
			monitor.checkCanceled();
			try {
				type.findVtable(dummy);
			} catch (CancelledException e) {
				throw e;
			} catch (Exception e) {
				if (log != null) {
					log.appendException(e);
				}
			}
			monitor.incrementProgress(1);
		}
		if (treeNodeManager != null) {
			treeNodeManager.getRoot().removeAll();
			treeNodeManager.generateTree();
		}
	}

	private boolean isValidRecord(ClassTypeInfoRecord record) {
		try {
			AbstractClassTypeInfoDB.getBaseCount(record);
			return true;
		} catch (Exception e) {
			// record is incomplete and will be removed
		}
		return false;
	}

	private void sort(TaskMonitor monitor) throws CancelledException {
		try {
			Table classTable = worker.getTables().getTypeTable();
			classTable.rebuild(monitor);
			if (classTable.getMaxKey() > Integer.MAX_VALUE) {
				throw new AssertException(
					"Ghidra-Cpp-Class-Analyzer: Unable to sort Database. Too many keys");
			}
			ClassTypeInfoRecord[] records = getClassRecords();
			Map<Long, ReferenceCounter> keys = getRecordStream(records)
				.filter(this::isValidRecord)
				.map(ReferenceCounter::new)
				.collect(Collectors.toMap(ReferenceCounter::getKey, r -> r));
			for (ClassTypeInfoRecord record : records) {
				monitor.checkCanceled();
				if (keys.containsKey(record.getKey())) {
					long[] baseKeys = AbstractClassTypeInfoDB.getBaseKeys(record);
					for (long key : baseKeys) {
						keys.get(key).referencesFrom.getAndIncrement();
					}
				}
			}
			long[] newKeys = keys.values()
				.parallelStream()
				.sorted()
				.mapToLong(ReferenceCounter::getKey)
				.toArray();
			newKeys = sortByMostDerived(newKeys, monitor);
			rebuildTable(newKeys, monitor);
			for (long key = 0; key < classTable.getMaxKey(); key++) {
				monitor.checkCanceled();
				ClassTypeInfoRecord record = worker.getTypeRecord(key);
				for (long baseKey : AbstractClassTypeInfoDB.getBaseKeys(record)) {
					monitor.checkCanceled();
					if (baseKey > key) {
						throw new AssertException(String.format(
							"%d must come before %d because it is inherited by it.",
							baseKey, key));
					}
				}
			}
			for (ClassTypeInfoRecord record : getClassRecords()) {
				monitor.checkCanceled();
				AbstractClassTypeInfoDB type =
					(AbstractClassTypeInfoDB) worker.getType(record.getKey());
				Vtable vtable = type.getVtable();
				if (vtable instanceof AbstractVtableDB) {
					AbstractVtableDB vtableDB = (AbstractVtableDB) vtable;
					vtableDB.setClassKey(record.getKey());
				}
			}
		} catch (IOException e) {
			dbError(e);
		}
	}


	private void rebuildTable(long[] newKeys, TaskMonitor monitor) throws CancelledException {
		try {
			DBHandle handle = program.getDBHandle();
			Table classTable = worker.getTables().getTypeTable();
			try {
				classTable.setName("old" + classTable.getName());
			} catch (DuplicateNameException e) {
				throw new AssertException(
					"Ghidra-Cpp-Class-Analyzer: cannot create temporary table");
			}
			ClassTypeInfoDatabaseTable tmpTable = getNewClassTable(handle);
			SchemaRecordIterator<ClassTypeInfoRecord> iter =
				new SchemaRecordIterator<>(classTable.iterator(), ClassTypeInfoRecord::new);
			LongIntHashtable keyMap = new LongIntHashtable(newKeys.length);
			for (int i = 0; i < newKeys.length; i++) {
				monitor.checkCanceled();
				keyMap.put(newKeys[i], i);
			}
			try {
				while (iter.hasNext()) {
					monitor.checkCanceled();
					ClassTypeInfoRecord oldRecord = iter.next();
					if (!keyMap.contains(oldRecord.getKey())) {
						continue;
					}
					ClassTypeInfoRecord record = oldRecord.copy();
					record.setKey(keyMap.get(record.getKey()));
					if (record.getBooleanValue(ClassTypeInfoSchemaFields.VTABLE_SEARCHED)) {
						// since the vtable table will be removed
						// this information must be cleared if present
						record.setBooleanValue(ClassTypeInfoSchemaFields.VTABLE_SEARCHED, false);
						record.setLongValue(ClassTypeInfoSchemaFields.VTABLE_KEY, INVALID_KEY);
					}
					AbstractClassTypeInfoDB.updateRecord(record, keyMap);
					tmpTable.getTable().putRecord(record.getRecord());
				}
			} catch (NoValueException e) {
				// impossible. this should not be a checked exception!
				throw new AssertException(e);
			}
			worker.getTables().deleteAll();
			worker.getCaches().invalidate();
			iter = new SchemaRecordIterator<>(
				tmpTable.getTable().iterator(), ClassTypeInfoRecord::new);
			while (iter.hasNext()) {
				monitor.checkCanceled();
				classTable.putRecord(iter.next().copy().getRecord());
			}
			handle.deleteTable(tmpTable.getName());
			classTable.setName(AbstractClassTypeInfoDB.CLASS_TYPEINFO_TABLE_NAME);
		} catch (IOException e) {
			dbError(e);
		} catch (DuplicateNameException e) {
			throw new AssertException(e);
		}
	}

	private long[] sortByMostDerived(long[] oldKeys, TaskMonitor monitor)
			throws CancelledException {
		// cannot reuse old keys due to risk of overrunning the position of 'oldKey'
		long[] newKeys = new long[oldKeys.length];
		RedBlackLongKeySet processed = new RedBlackLongKeySet();
		LongStack stack = new LongStack();
		int index = 0;
		for (long oldKey : oldKeys) {
			monitor.checkCanceled();
			stack.push(oldKey);
			while (!stack.isEmpty()) {
				monitor.checkCanceled();
				long key = stack.pop();
				if (processed.containsKey(key)) {
					continue;
				}
				ClassTypeInfoRecord record = worker.getTypeRecord(key);
				boolean dirty = false;
				for (long base : AbstractClassTypeInfoDB.getBaseKeys(record)) {
					monitor.checkCanceled();
					if (!processed.containsKey(base)) {
						if (!dirty) {
							stack.push(key);
						}
						dirty = true;
						stack.push(base);
					}
				}
				if (!dirty) {
					processed.put(key);
					newKeys[index++] = key;
				}
			}
		}
		return newKeys;
	}

	private final class GnuRttiRecordWorker extends RttiRecordWorker {

		GnuRttiRecordWorker(ProgramRttiTablePair tables, ProgramRttiCachePair caches) {
			super(tables, caches);
		}

		@Override
		GnuClassTypeInfoDB buildType(ClassTypeInfoRecord record) {
			return new GnuClassTypeInfoDB(this, record);
		}

		@Override
		GnuClassTypeInfoDB buildType(ClassTypeInfo type, ClassTypeInfoRecord record) {
			return new GnuClassTypeInfoDB(this, type, record);
		}

		@Override
		VtableModelDB buildVtable(VtableRecord record) {
			return new VtableModelDB(this, record);
		}

		@Override
		VtableModelDB buildVtable(Vtable vtable, VtableRecord record) {
			return new VtableModelDB(this, (GnuVtable) vtable, record);
		}

	}

	private static class ReferenceCounter implements Comparable<ReferenceCounter> {

		final long key;
		final long referencesTo;
		final AtomicLong referencesFrom;

		ReferenceCounter(ClassTypeInfoRecord record) {
			key = record.getKey();
			referencesTo = AbstractClassTypeInfoDB.getBaseCount(record);
			referencesFrom = new AtomicLong();
		}

		public long getKey() {
			return key;
		}

		@Override
		public int compareTo(ReferenceCounter o) {
			long tFrom = referencesFrom.get();
			long oFrom = o.referencesFrom.get();
			if (tFrom < oFrom) {
				return -1;
			}
			if (tFrom > oFrom) {
				return 1;
			}
			if (referencesTo < o.referencesTo) {
				return -1;
			}
			if (referencesTo > o.referencesTo) {
				return 1;
			}
			return 0;
		}
	}

}

```

`src/main/java/cppclassanalyzer/data/manager/LibraryClassTypeInfoManager.java`:

```java
package cppclassanalyzer.data.manager;

import java.io.IOException;
import java.util.stream.Stream;

import javax.swing.Icon;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.plugin.core.datamgr.util.DataTypeUtils;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoTreeNodeManager;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.manager.caches.ArchivedRttiCachePair;
import cppclassanalyzer.data.manager.tables.ArchivedRttiTablePair;
import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.database.utils.TransactionHandler;
import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;

import ghidra.program.database.DatabaseObject;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.symbol.Namespace;
import ghidra.util.InvalidNameException;
import ghidra.util.exception.DuplicateNameException;

/**
 * A ClassTypeInfoManager representing an external library
 */
public final class LibraryClassTypeInfoManager implements ClassTypeInfoManager {

	private final ProjectClassTypeInfoManager manager;
	private final TypeInfoTreeNodeManager treeNodeManager;
	private final RttiRecordWorker worker;
	private String name;

	LibraryClassTypeInfoManager(ProjectClassTypeInfoManager manager, ArchivedRttiTablePair tables,
			String name) {
		this.manager = manager;
		this.worker = new RttiRecordWorker(tables, new ArchivedRttiCachePair());
		this.name = name;
		this.treeNodeManager = new TypeInfoTreeNodeManager(manager.getPlugin(), this);
		treeNodeManager.generateTree();
	}

	ArchivedRttiTablePair getTables() {
		return worker.getTables();
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public ArchivedClassTypeInfo resolve(ClassTypeInfo type) {
		return worker.resolve(type);
	}

	@Override
	public ArchivedClassTypeInfo getType(GhidraClass gc) {
		return worker.getType(gc);
	}

	@Override
	public ArchivedClassTypeInfo getType(Function fun) {
		return worker.getType(fun);
	}

	@Override
	public ArchivedClassTypeInfo getType(String name, Namespace namespace) {
		return worker.getType(name, namespace);
	}

	@Override
	public ArchivedClassTypeInfo getType(String symbolName) {
		return worker.getType(symbolName);
	}

	@Override
	public Iterable<ClassTypeInfoDB> getTypes() {
		return worker.getTypes();
	}

	@Override
	public Stream<ClassTypeInfoDB> getTypeStream() {
		return worker.getTypeStream();
	}

	@Override
	public int getTypeCount() {
		return worker.getTables().getTypeTable().getRecordCount();
	}

	@Override
	public Icon getIcon(boolean expanded) {
		if (expanded) {
			return DataTypeUtils.getOpenFolderIcon(false);
		}
		return DataTypeUtils.getClosedFolderIcon(false);
	}

	@Override
	public TypeInfoTreeNodeManager getTreeNodeManager() {
		return treeNodeManager;
	}

	@Override
	public ArchivedClassTypeInfo getType(long key) {
		return worker.getType(key);
	}

	/**
	 * Gets the project manager containing this library
	 * @return the project manager
	 */
	public ProjectClassTypeInfoManager getProjectManager() {
		return manager;
	}

	@Override
	public void dbError(IOException e) {
		manager.dbError(e);
	}

	private TransactionHandler getHandler() {
		return manager.getHandler();
	}

	/**
	 * Renames this library
	 * @param name the new library name
	 * @throws InvalidNameException if the new name is invalid
	 * @throws DuplicateNameException if a library with this name already exists
	 * in the project manager.
	 */
	public void rename(String name) throws InvalidNameException, DuplicateNameException {
		manager.getLibMap().rename(this.name, name);
		this.name = name;
	}

	@Override
	public String toString() {
		return name;
	}

	@Override
	public void dispose() {
		if (treeNodeManager != null) {
			treeNodeManager.dispose();
		}
	}

	DatabaseObject getArchivedData(String symbolName) {
		return worker.getArchivedData(symbolName);
	}

	private final class RttiRecordWorker extends ArchiveRttiRecordWorker {

		RttiRecordWorker(ArchivedRttiTablePair tables, ArchivedRttiCachePair caches) {
			super(LibraryClassTypeInfoManager.this, tables, caches, getHandler());
		}

		@Override
		ClassTypeInfoManagerPlugin getPlugin() {
			return manager.getPlugin();
		}

		@Override
		public DataTypeManager getDataTypeManager() {
			return manager;
		}
	}
}

```

`src/main/java/cppclassanalyzer/data/manager/ProjectClassTypeInfoManager.java`:

```java
package cppclassanalyzer.data.manager;

import java.io.IOException;
import java.util.*;
import java.util.stream.Stream;

import javax.swing.Icon;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.gcc.UnresolvedClassTypeInfoException;
import ghidra.app.plugin.core.datamgr.archive.Archive;
import ghidra.app.plugin.core.datamgr.archive.ProjectArchive;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoTreeNodeManager;
import cppclassanalyzer.service.ClassTypeInfoManagerService;

import ghidra.framework.cmd.BackgroundCommand;
import ghidra.framework.model.DomainObjectListener;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.database.DataTypeArchiveDB;
import ghidra.program.database.data.ProjectDataTypeManager;

import cppclassanalyzer.data.ArchivedRttiData;
import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.manager.tables.ArchivedRttiTablePair;
import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.data.vtable.ArchivedGnuVtable;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.util.ChangeManager;
import ghidra.util.InvalidNameException;
import ghidra.util.Lock;
import ghidra.util.Msg;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.VersionException;
import ghidra.util.task.CancelOnlyWrappingTaskMonitor;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.database.schema.ArchivedClassTypeInfoSchema;
import cppclassanalyzer.database.schema.ArchivedGnuVtableSchema;
import cppclassanalyzer.database.tables.ArchivedClassTypeInfoDatabaseTable;
import cppclassanalyzer.database.tables.ArchivedGnuVtableDatabaseTable;
import cppclassanalyzer.database.utils.TransactionHandler;
import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;
import db.*;
import resources.ResourceManager;

/**
 * A ClassTypeInfoManager representing a project containing external libraries
 */
public final class ProjectClassTypeInfoManager extends ProjectDataTypeManager
		implements FileArchiveClassTypeInfoManager {

	private static final Icon[] ICONS = new Icon[] {
		ResourceManager.loadImage("images/openBookBlue.png"),
		ResourceManager.loadImage("images/closedBookBlue.png")
	};

	private static final Schema SCHEMA = new Schema(
		0,
		"key",
		new Class<?>[] { StringField.class, StringField.class, StringField.class },
		new String[] { "Name", "TypeTable", "VtableTable" });

	private static final int NAME_INDEX = 0;
	private static final int TYPE_INDEX = 1;
	private static final int VTABLE_INDEX = 2;

	private final ClassTypeInfoManagerService plugin;
	private final ProjectArchive archive;
	private final LibraryMap libMap;
	private final TypeInfoTreeNodeManager treeNodeManager;

	private ProjectClassTypeInfoManager(ClassTypeInfoManagerService service, ProjectArchive archive)
			throws CancelledException, VersionException, IOException {
		super(getDBHandle(archive), DBConstants.UPDATE, getDB(archive),
			getLock(archive), TaskMonitor.DUMMY);
		this.archive = archive;
		this.plugin = service;
		setDataTypeArchive(getDB(archive));
		if (service instanceof ClassTypeInfoManagerPlugin) {
			this.treeNodeManager =
				new TypeInfoTreeNodeManager((ClassTypeInfoManagerPlugin) service, this);
		} else {
			this.treeNodeManager = null;
		}
		this.libMap = new LibraryMap();
	}

	private static DataTypeArchiveDB getDB(ProjectArchive archive) {
		return (DataTypeArchiveDB) archive.getDomainObject();
	}

	private static DBHandle getDBHandle(ProjectArchive archive) {
		return getDB(archive).getDBHandle();
	}

	private static Lock getLock(ProjectArchive archive) {
		return getDB(archive).getLock();
	}

	public static ProjectClassTypeInfoManager open(ClassTypeInfoManagerService service,
			ProjectArchive archive) throws IOException {
		try {
			return new ProjectClassTypeInfoManager(service, archive);
		} catch (VersionException | CancelledException e) {
			throw new AssertException(e);
		}
	}

	private ArchivedClassTypeInfoDatabaseTable getClassTable(String name)
			throws IOException {
		return new ArchivedClassTypeInfoDatabaseTable(dbHandle.getTable(name));
	}

	private ArchivedGnuVtableDatabaseTable getVtableTable(String name)
			throws IOException {
		return new ArchivedGnuVtableDatabaseTable(dbHandle.getTable(name));
	}

	private ArchivedClassTypeInfoDatabaseTable createClassTable(String name) throws IOException {
		Table classTable = dbHandle.createTable(
			name + " " + ArchivedClassTypeInfo.TABLE_NAME,
			ArchivedClassTypeInfoSchema.SCHEMA,
			ArchivedClassTypeInfoSchema.INDEXED_COLUMNS);
		return new ArchivedClassTypeInfoDatabaseTable(classTable);
	}

	private ArchivedGnuVtableDatabaseTable createVtableTable(String name) throws IOException {
		Table vtableTable = dbHandle.createTable(
			name + " " + ArchivedGnuVtable.TABLE_NAME,
			ArchivedGnuVtableSchema.SCHEMA,
			ArchivedGnuVtableSchema.INDEXED_COLUMNS);
		return new ArchivedGnuVtableDatabaseTable(vtableTable);
	}

	private void checkForManager(Program program) throws UnresolvedClassTypeInfoException {
		if (!libMap.containsKey(program.getName())) {
			throw new UnresolvedClassTypeInfoException(program);
		}
	}

	private LibraryClassTypeInfoManager getManager(String name) {
		try {
			if (!(libMap.containsKey(name))) {
				ArchivedClassTypeInfoDatabaseTable classTable = createClassTable(name);
				ArchivedGnuVtableDatabaseTable vtableTable = createVtableTable(name);
				ArchivedRttiTablePair pair = new ArchivedRttiTablePair(classTable, vtableTable);
				LibraryClassTypeInfoManager manager =
					new LibraryClassTypeInfoManager(this, pair, name);
				libMap.put(name, manager);
			}
			return libMap.get(name);
		} catch (IOException e) {
			dbError(e);
		}
		return null;
	}

	@Override
	public ClassTypeInfoDB resolve(ClassTypeInfo type) {
		String name = null;
		if (type instanceof ClassTypeInfoDB) {
			ClassTypeInfoManager manager = ((ClassTypeInfoDB) type).getManager();
			if (manager instanceof ProgramClassTypeInfoManager) {
				name = ((ProgramClassTypeInfoManager) manager).getName();
			} else {
				name = ((ArchivedClassTypeInfo) type).getProgramName();
			}
		} else {
			name = type.getGhidraClass().getSymbol().getProgram().getName();
		}
		return getManager(name).resolve(type);
	}

	@Override
	public ClassTypeInfoDB getType(GhidraClass gc) throws UnresolvedClassTypeInfoException {
		Program program = gc.getSymbol().getProgram();
		checkForManager(program);
		return getManager(program.getName()).getType(gc);
	}

	@Override
	public ClassTypeInfoDB getType(Function fun) throws UnresolvedClassTypeInfoException {
		Program program = fun.getSymbol().getProgram();
		checkForManager(program);
		return getManager(program.getName()).getType(fun);
	}

	@Override
	public ClassTypeInfoDB getType(String name, Namespace namespace)
			throws UnresolvedClassTypeInfoException {
		Program program = namespace.getSymbol().getProgram();
		checkForManager(program);
		return getManager(program.getName()).getType(name, namespace);
	}

	@Override
	public ClassTypeInfoDB getType(String symbolName) throws UnresolvedClassTypeInfoException {
		for (LibraryClassTypeInfoManager manager : libMap.values()) {
			ClassTypeInfoDB type = manager.getType(symbolName);
			if (type != null) {
				return type;
			}
		}
		String msg =
			"Unable to locate an archived ClassTypeInfo with symbol name " + symbolName;
		throw new UnresolvedClassTypeInfoException(msg);
	}

	@Override
	public Iterable<ClassTypeInfoDB> getTypes() {
		return () -> getTypeStream().iterator();
	}

	@Override
	public Stream<ClassTypeInfoDB> getTypeStream() {
		return libMap.values()
			.stream()
			.flatMap(ClassTypeInfoManager::getTypeStream);
	}

	@Override
	public int getTypeCount() {
		return libMap.values()
			.stream()
			.mapToInt(ClassTypeInfoManager::getTypeCount)
			.sum();
	}

	@Override
	public ClassTypeInfoManagerPlugin getPlugin() {
		try {
			return (ClassTypeInfoManagerPlugin) plugin;
		} catch (ClassCastException e) {
			throw new AssertException("This should be unreachable in headless mode", e);
		}
	}

	@Override
	public Icon getIcon(boolean expanded) {
		return expanded ? ICONS[0] : ICONS[1];
	}

	@Override
	public boolean isModifiable() {
		return archive.isModifiable();
	}

	@Override
	public void save() {
		if (plugin instanceof ClassTypeInfoManagerPlugin) {
			ClassTypeInfoManagerPlugin p  = (ClassTypeInfoManagerPlugin) plugin;
			p.getDataTypeManagerHandler().save(getDB(archive));
		} else {
			try {
				getDB(archive).getDomainFile().save(TaskMonitor.DUMMY);
			} catch (CancelledException e) {
				throw new AssertException(e);
			} catch (IOException e) {
				Msg.showError(this, null, "Failed to save "+getName(), e);
			}
		}
	}

	/**
	 * Gets a collection of libraries contained within this project manager
	 * @return the collection of libraries
	 */
	public Collection<LibraryClassTypeInfoManager> getLibraries() {
		return Collections.unmodifiableCollection(libMap.values());
	}

	/**
	 * Gets the library in this project with the specified name
	 * @param name the name of the library
	 * @return the library manager or null if none exists
	 */
	public LibraryClassTypeInfoManager getLibrary(String name) {
		return libMap.get(name);
	}

	@Override
	public TypeInfoTreeNodeManager getTreeNodeManager() {
		return treeNodeManager;
	}

	@Override
	public ClassTypeInfoDB getType(long key) {
		throw new UnsupportedOperationException("Cannot get type from project archive by key");
	}

	@Override
	public void addListener(DomainObjectListener listener) {
		archive.getDomainObject().addListener(listener);
	}

	@Override
	public void removeListener(DomainObjectListener listener) {
		archive.getDomainObject().removeListener(listener);
	}

	/**
	 * Inserts a ClassTypeInfoManager into this project
	 * @param manager the manager to insert
	 * @param monitor the current task monitor
	 * @throws CancelledException if the operation is cancelled
	 */
	public void insert(ClassTypeInfoManager manager, TaskMonitor monitor)
			throws CancelledException {
		insert(List.of(manager), monitor);
	}

	/**
	 * Inserts the collection of managers into this project
	 * @param managers the collection of managers to insert
	 * @param monitor the current task monitor
	 * @throws CancelledException if the operation is cancelled
	 */
	public void insert(Collection<? extends ClassTypeInfoManager> managers, TaskMonitor monitor)
			throws CancelledException {
		String format = "Inserting %s (%d/%d)";
		int size = managers.size();
		int i = 0;
		for (ClassTypeInfoManager manager : managers) {
			monitor.checkCanceled();
			String msg = String.format(format, manager.getName(), ++i, size);
			monitor.setMessage(msg);
			doInsert(manager, monitor);
		}
	}

	private void doInsert(ClassTypeInfoManager manager, TaskMonitor monitor)
			throws CancelledException {
		if (manager instanceof ProjectClassTypeInfoManager) {
			TaskMonitor dummy = new CancelOnlyWrappingTaskMonitor(monitor);
			Collection<LibraryClassTypeInfoManager> managers =
				((ProjectClassTypeInfoManager) manager).libMap.values();
			insert(managers, dummy);
			return;
		}
		LibraryClassTypeInfoManager libManager = getManager(manager.getName());
		monitor.initialize(manager.getTypeCount());
		for (ClassTypeInfo type : manager.getTypes()) {
			monitor.checkCanceled();
			libManager.resolve(type);
			monitor.incrementProgress(1);
		}
	}

	/**
	 * Executes the provided background command in the provided tool
	 * on this manager.
	 * @param tool the plugin tool
	 * @param cmd the background command
	 */
	public void executeCommand(PluginTool tool, BackgroundCommand cmd) {
		tool.executeBackgroundCommand(cmd, archive.getDomainObject());
	}

	LibraryMap getLibMap() {
		return libMap;
	}

	@Override
	public void close() {
		archive.close();
		if (treeNodeManager != null) {
			treeNodeManager.dispose();
		}
	}

	@Override
	public void dispose() {
		close();
	}

	/**
	 * Initialize the {@link ProjectArchive} as a ClassTypeInfoManager
	 * @param archive the project archive
	 * @throws IOException if an error occurs initializing the archive
	 */
	public static void init(ProjectArchive archive) throws IOException {
		Lock lock = getDB(archive).getLock();
		lock.acquire();
		try {
			Table table = createLibMapTable(getDBHandle(archive));
			getDB(archive).setChanged(ChangeManager.DOCR_OBJECT_CREATED, null, table);
		} finally {
			lock.release();
		}
	}

	private static Table createLibMapTable(DBHandle dbHandle) throws IOException {
		Table table = dbHandle.getTable(LibraryMap.NAME);
		if (table != null) {
			return table;
		}
		long id = dbHandle.startTransaction();
		boolean success = false;
		try {
			table = dbHandle.createTable(LibraryMap.NAME, SCHEMA, new int[] { NAME_INDEX });
			success = true;
			return table;
		} finally {
			dbHandle.endTransaction(id, success);
		}
	}

	public <T extends ArchivedRttiData> T getRttiData(Class<T> clazz, String symbolName) {
		return libMap.values()
			.stream()
			.map(lib -> lib.getArchivedData(symbolName))
			.filter(clazz::isInstance)
			.map(clazz::cast)
			.findFirst()
			.orElse(null);
	}

	/**
	 * Opens the Archive iff it contains a ProjectClassTypeInfoManager
	 * @param plugin the plugin
	 * @param archive the archive to open
	 * @return the manager or null if it did not contain one
	 * @throws IOException if an error occurs opening the archive
	 */
	public static FileArchiveClassTypeInfoManager openIfManagerArchive(
			ClassTypeInfoManagerPlugin plugin, Archive archive) throws IOException {
		if (archive instanceof ProjectArchive) {
			DBHandle handle = getDB((ProjectArchive) archive).getDBHandle();
			if (handle.getTable(LibraryMap.NAME) != null) {
				return open(plugin, (ProjectArchive) archive);
			}
		}
		return null;
	}

	/**
	 * Gets a stream of all available managers with the provided names
	 * @param names the names of the libraries to get
	 * @return a stream of all available specified libraries
	 */
	public Stream<LibraryClassTypeInfoManager> getAvailableManagers(Collection<String> names) {
		Stream.Builder<LibraryClassTypeInfoManager> builder = Stream.builder();
		for (String name : names) {
			if (libMap.containsKey(name)) {
				builder.add(libMap.get(name));
			}
		}
		return builder.build();
	}

	/**
	 * Gets a stream of all available managers with the provided names
	 * @param names the names of the libraries to get
	 * @return a stream of all available specified libraries
	 * @see #getAvailableManagers(Collection)
	 */
	public Stream<LibraryClassTypeInfoManager> getAvailableManagers(String[] names) {
		return getAvailableManagers(List.of(names));
	}

	private void endTransaction(long id, boolean commit) {
		endTransaction((int) id, commit);
	}

	TransactionHandler getHandler() {
		return new TransactionHandler(this::startTransaction, this::endTransaction);
	}

	class LibraryMap {

		private static final String NAME = "LibraryMap";
		private static final int NAME_ORDINAL = 0;

		private final Map<String, LibraryClassTypeInfoManager> libMap;
		private final Table table;

		LibraryMap() {
			Table tmp = dbHandle.getTable(NAME);
			if (tmp == null) {
				try {
					tmp = createLibMapTable(dbHandle);
				} catch (IOException e) {
					dbError(e);
				}
			}
			this.table = tmp;
			this.libMap = Collections.synchronizedMap(new HashMap<>(table.getRecordCount()));
			fillMap();
		}

		public Collection<LibraryClassTypeInfoManager> values() {
			return libMap.values();
		}

		public boolean containsKey(String name) {
			return libMap.containsKey(name);
		}

		private void fillMap() {
			try {
				DBRecord record;
				for (RecordIterator it = table.iterator(); it.hasNext();) {
					record = it.next();
					String name = record.getString(0);
					String typeTableName = record.getString(1);
					String vtableTableName = record.getString(2);
					ArchivedRttiTablePair tables = new ArchivedRttiTablePair(
						getClassTable(typeTableName), getVtableTable(vtableTableName));
					LibraryClassTypeInfoManager man = new LibraryClassTypeInfoManager(
						ProjectClassTypeInfoManager.this, tables, name);
					libMap.put(name, man);
				}
			} catch (IOException e) {
				dbError(e);
			}
		}

		LibraryClassTypeInfoManager get(String name) {
			return libMap.get(name);
		}

		void put(String name, LibraryClassTypeInfoManager man) {
			try {
				libMap.put(name, man);
				ArchivedRttiTablePair tables = man.getTables();
				DBRecord record = SCHEMA.createRecord(table.getKey());
				record.setString(NAME_INDEX, name);
				record.setString(TYPE_INDEX, tables.getTypeTable().getName());
				record.setString(VTABLE_INDEX, tables.getVtableTable().getName());
				table.putRecord(record);
			} catch (IOException e) {
				dbError(e);
			}
		}

		DBRecord getRecord(String name) {
			try {
				StringField nameField = new StringField(name);
				Field[] keys = table.findRecords(nameField, NAME_ORDINAL);
				if (keys.length > 1) {
					throw new AssertException("Duplicate library "+name+" detected");
				}
				if (keys.length == 1) {
					return table.getRecord(keys[0].getLongValue());
				}
			} catch (IOException e) {
				dbError(e);
			}
			return null;
		}

		void rename(String oldName, String newName)
				throws InvalidNameException, DuplicateNameException {
			if (newName == null || newName.length() == 0) {
				throw new InvalidNameException("Name is invalid: " + newName);
			}
			if (oldName.equals(newName)) {
				return;
			}
			if (libMap.containsKey(newName)) {
				throw new DuplicateNameException(newName + " already exists");
			}
			int id = startTransaction("Renaming "+oldName+" to "+newName);
			boolean success = false;
			try {
				DBRecord record = getRecord(oldName);
				if (record == null) {
					throw new AssertException("Library "+oldName+" does not exist");
				}
				Renamer renamer = new Renamer(libMap.remove(oldName), newName, record);
				renamer.renameTypeTable();
				renamer.renameVtableTable();
				libMap.put(newName, renamer.getManager());
				table.putRecord(record);
				success = true;
			} catch (IOException e) {
				dbError(e);
			} finally {
				endTransaction(id, success);
			}
		}
	}

	private class Renamer {
		private final LibraryClassTypeInfoManager manager;
		private final String name;
		private final DBRecord record;

		Renamer(LibraryClassTypeInfoManager manager, String name, DBRecord record) {
			this.manager = manager;
			this.name = name;
			this.record = record;
			record.setString(NAME_INDEX, name);
		}

		void renameTypeTable() throws DuplicateNameException {
			rename(manager.getTables().getTypeTable(), TYPE_INDEX);
		}

		void renameVtableTable() throws DuplicateNameException {
			rename(manager.getTables().getVtableTable(), VTABLE_INDEX);
		}

		private void rename(Table table, int index) throws DuplicateNameException {
			String oldName = table.getName();
			table.setName(oldName.replace(manager.getName(), name));
			record.setString(index, table.getName());
		}

		LibraryClassTypeInfoManager getManager() {
			return manager;
		}
	}
}

```

`src/main/java/cppclassanalyzer/data/manager/VsClassTypeInfoManager.java`:

```java
package cppclassanalyzer.data.manager;

import ghidra.app.cmd.data.TypeDescriptorModel;
import ghidra.app.cmd.data.rtti.*;
import ghidra.program.database.ProgramDB;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.listing.VariableUtilities;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.data.manager.caches.ProgramRttiCachePair;
import cppclassanalyzer.data.manager.tables.ProgramRttiTablePair;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.data.typeinfo.VsClassTypeInfoDB;
import cppclassanalyzer.data.vtable.VftableDB;
import cppclassanalyzer.database.record.ClassTypeInfoRecord;
import cppclassanalyzer.database.record.VtableRecord;
import cppclassanalyzer.service.ClassTypeInfoManagerService;
import cppclassanalyzer.vs.RttiModelWrapper;
import cppclassanalyzer.vs.VsClassTypeInfo;
import cppclassanalyzer.vs.VsVtableModel;

public final class VsClassTypeInfoManager extends ClassTypeInfoManagerDB {

	public VsClassTypeInfoManager(ClassTypeInfoManagerService service, ProgramDB program) {
		super(service, program);
	}

	@Override
	protected RttiRecordWorker getWorker(ProgramRttiTablePair tables,
			ProgramRttiCachePair caches) {
		return new WindowsRttiRecordWorker(tables, caches);
	}

	private static boolean isRtti4Model(Data data) {
		if (data == null) {
			return false;
		}
		return data.getMnemonicString().equals(VsClassTypeInfo.LOCATOR_SYMBOL_NAME);
	}

	@Override
	public ClassTypeInfoDB getType(Address address) {
		Data data = program.getListing().getDataAt(address);
		if (isRtti4Model(data)) {
			Rtti4Model model =
				new Rtti4Model(program, address, VsClassTypeInfo.DEFAULT_OPTIONS);
			try {
				address = model.getRtti0Address();
			} catch (InvalidDataTypeException e) {
				throw new AssertException(e);
			}
		}
		return super.getType(address);
	}

	@Override
	public ClassTypeInfoDB getType(GhidraClass gc) {
		// this isn't reliable but now required for vs binaries
		DataType dt =
			VariableUtilities.findOrCreateClassStruct(gc, program.getDataTypeManager());
		return getType(dt.getUniversalID());
	}

	@Override
	public TypeInfo getTypeInfo(Address address, boolean resolve) {
		TypeInfo ti = super.getTypeInfo(address, resolve);
		if (ti == null) {
			TypeDescriptorModel model =
				new TypeDescriptorModel(program, address, VsClassTypeInfo.DEFAULT_OPTIONS);
			try {
				ti = RttiModelWrapper.getWrapper(model, TaskMonitor.DUMMY);
			} catch (CancelledException e) {
				throw new AssertException(e);
			}
		}
		if (ti instanceof ClassTypeInfo && resolve) {
			ti = resolve((ClassTypeInfo) ti);
		}
		return ti;
	}

	@Override
	public boolean isTypeInfo(Address address) {
		try {
			TypeDescriptorModel model =
				new TypeDescriptorModel(program, address, VsClassTypeInfo.DEFAULT_OPTIONS);
			model.validate();
			return true;
		} catch (InvalidDataTypeException e) {
			// do nothing
		}
		return false;
	}

	private final class WindowsRttiRecordWorker extends RttiRecordWorker {

		WindowsRttiRecordWorker(ProgramRttiTablePair tables, ProgramRttiCachePair caches) {
			super(tables, caches);
		}

		@Override
		VsClassTypeInfoDB buildType(ClassTypeInfoRecord record) {
			return new VsClassTypeInfoDB(this, record);
		}

		@Override
		VsClassTypeInfoDB buildType(ClassTypeInfo type, ClassTypeInfoRecord record) {
			return new VsClassTypeInfoDB(this, (VsClassTypeInfo) type, record);
		}

		@Override
		VftableDB buildVtable(VtableRecord record) {
			return new VftableDB(this, record);
		}

		@Override
		VftableDB buildVtable(Vtable vtable, VtableRecord record) {
			return new VftableDB(this, (VsVtableModel) vtable, record);
		}

	}

}

```

`src/main/java/cppclassanalyzer/data/manager/caches/ArchivedRttiCachePair.java`:

```java
package cppclassanalyzer.data.manager.caches;

import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.vtable.ArchivedGnuVtable;

public final class ArchivedRttiCachePair
	extends RttiCachePair<ArchivedClassTypeInfo, ArchivedGnuVtable> {

	public static final int DEFAULT_CACHE_SIZE = 10;

	public ArchivedRttiCachePair() {
		this(DEFAULT_CACHE_SIZE);
	}
	public ArchivedRttiCachePair(int capacity) {
		super(capacity);
	}
}
```

`src/main/java/cppclassanalyzer/data/manager/caches/ProgramRttiCachePair.java`:

```java
package cppclassanalyzer.data.manager.caches;

import cppclassanalyzer.data.typeinfo.AbstractClassTypeInfoDB;
import cppclassanalyzer.data.vtable.AbstractVtableDB;

public final class ProgramRttiCachePair
	extends RttiCachePair<AbstractClassTypeInfoDB, AbstractVtableDB> {

	public static final int DEFAULT_CACHE_SIZE = 100;

	public ProgramRttiCachePair() {
		this(DEFAULT_CACHE_SIZE);
	}

	public ProgramRttiCachePair(int capacity) {
		super(capacity);
	}
}
```

`src/main/java/cppclassanalyzer/data/manager/caches/RttiCachePair.java`:

```java
package cppclassanalyzer.data.manager.caches;

import ghidra.program.database.DBObjectCache;
import ghidra.program.database.DatabaseObject;

public abstract class RttiCachePair<T1 extends DatabaseObject, T2 extends DatabaseObject>  {

	private final DBObjectCache<T1> classCache;
	private final DBObjectCache<T2> vtableCache;

	RttiCachePair(int capacity) {
		this.classCache = new DBObjectCache<>(capacity);
		this.vtableCache = new DBObjectCache<>(capacity);
	}

	public final DBObjectCache<T1> getTypeCache() {
		return classCache;
	}

	public final DBObjectCache<T2> getVtableCache() {
		return vtableCache;
	}

	public final void invalidate() {
		classCache.invalidate();
		vtableCache.invalidate();
	}
}
```

`src/main/java/cppclassanalyzer/data/manager/recordmanagers/ArchiveRttiRecordManager.java`:

```java
package cppclassanalyzer.data.manager.recordmanagers;

import ghidra.program.model.data.DataTypeManager;

import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.vtable.ArchivedGnuVtable;

import cppclassanalyzer.database.record.ArchivedClassTypeInfoRecord;
import cppclassanalyzer.database.record.ArchivedGnuVtableRecord;

// Tagging interface for generic simplification
public interface ArchiveRttiRecordManager extends
		RttiRecordManager<ArchivedClassTypeInfo, ArchivedGnuVtable,
			ArchivedClassTypeInfoRecord, ArchivedGnuVtableRecord> {

	DataTypeManager getDataTypeManager();
}

```

`src/main/java/cppclassanalyzer/data/manager/recordmanagers/ProgramRttiRecordManager.java`:

```java
package cppclassanalyzer.data.manager.recordmanagers;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.AbstractClassTypeInfoDB;
import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.vtable.AbstractVtableDB;

import cppclassanalyzer.database.record.ClassTypeInfoRecord;
import cppclassanalyzer.database.record.VtableRecord;

// Tagging interface for generic simplification
public interface ProgramRttiRecordManager extends
		RttiRecordManager<AbstractClassTypeInfoDB, AbstractVtableDB,
			ClassTypeInfoRecord, VtableRecord> {

	AbstractClassTypeInfoDB resolve(ArchivedClassTypeInfo type);

	@Override
	public ProgramClassTypeInfoManager getManager();
}

```

`src/main/java/cppclassanalyzer/data/manager/recordmanagers/RttiRecordManager.java`:

```java
package cppclassanalyzer.data.manager.recordmanagers;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.program.database.DBObjectCache;
import ghidra.program.database.DatabaseObject;
import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import ghidra.program.database.map.AddressMap;

import cppclassanalyzer.database.record.DatabaseRecord;

public interface RttiRecordManager<T1 extends ClassTypeInfoDB, T2 extends DatabaseObject,
		T3 extends DatabaseRecord<?>, T4 extends DatabaseRecord<?>> {

	static final long INVALID_KEY = AddressMap.INVALID_ADDRESS_KEY;

	public T3 getTypeRecord(long key);

	public T4 getVtableRecord(long key);

	public void updateRecord(DatabaseRecord<?> record);

	public ClassTypeInfoManager getManager();

	public T1 getType(long key);

	public T2 getVtable(long key);

	public DBObjectCache<T1> getTypeCache();

	public DBObjectCache<T2> getVtableCache();

	public T1 resolve(ClassTypeInfo type);

	public T2 resolve(Vtable vtable);
}

```

`src/main/java/cppclassanalyzer/data/manager/tables/ArchivedRttiTablePair.java`:

```java
package cppclassanalyzer.data.manager.tables;

import cppclassanalyzer.database.schema.ArchivedClassTypeInfoSchema;
import cppclassanalyzer.database.schema.ArchivedGnuVtableSchema;
import cppclassanalyzer.database.tables.ArchivedClassTypeInfoDatabaseTable;
import cppclassanalyzer.database.tables.ArchivedGnuVtableDatabaseTable;

public final class ArchivedRttiTablePair extends RttiTablePair<ArchivedClassTypeInfoSchema,
		ArchivedGnuVtableSchema> {

	public ArchivedRttiTablePair(ArchivedClassTypeInfoDatabaseTable classTable,
			ArchivedGnuVtableDatabaseTable vtableTable) {
		super(classTable, vtableTable);
	}

}
```

`src/main/java/cppclassanalyzer/data/manager/tables/ProgramRttiTablePair.java`:

```java
package cppclassanalyzer.data.manager.tables;

import cppclassanalyzer.database.schema.ClassTypeInfoSchema;
import cppclassanalyzer.database.schema.VtableSchema;
import cppclassanalyzer.database.tables.ClassTypeInfoDatabaseTable;
import cppclassanalyzer.database.tables.VtableDatabaseTable;

public final class ProgramRttiTablePair extends RttiTablePair<ClassTypeInfoSchema, VtableSchema> {

	public ProgramRttiTablePair(ClassTypeInfoDatabaseTable classTable,
			VtableDatabaseTable vtableTable) {
		super(classTable, vtableTable);
	}

}
```

`src/main/java/cppclassanalyzer/data/manager/tables/RttiTablePair.java`:

```java
package cppclassanalyzer.data.manager.tables;

import java.io.IOException;

import cppclassanalyzer.database.schema.AbstractSchema;
import cppclassanalyzer.database.tables.DatabaseTable;
import db.Table;

public abstract class RttiTablePair<T1 extends AbstractSchema<?>, T2 extends AbstractSchema<?>> {

	private final DatabaseTable<T1> classTable;
	private final DatabaseTable<T2> vtableTable;

	RttiTablePair(DatabaseTable<T1> classTable, DatabaseTable<T2> vtableTable) {
		this.classTable = classTable;
		this.vtableTable = vtableTable;
	}

	public final T1 getTypeSchema() {
		return classTable.getSchema();
	}

	public final T2 getVtableSchema() {
		return vtableTable.getSchema();
	}

	public final Table getTypeTable() {
		return classTable.getTable();
	}

	public final Table getVtableTable() {
		return vtableTable.getTable();
	}

	public final void deleteAll() throws IOException {
		classTable.getTable().deleteAll();
		vtableTable.getTable().deleteAll();
	}
}

```

`src/main/java/cppclassanalyzer/data/typeinfo/AbstractClassTypeInfoDB.java`:

```java
package cppclassanalyzer.data.typeinfo;

import java.util.*;

import cppclassanalyzer.data.manager.ClassTypeInfoManagerDB;
import cppclassanalyzer.data.manager.recordmanagers.ProgramRttiRecordManager;
import cppclassanalyzer.data.vtable.AbstractVtableDB;
import cppclassanalyzer.data.vtable.ArchivedGnuVtable;
import cppclassanalyzer.database.record.ClassTypeInfoRecord;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import cppclassanalyzer.vs.RttiModelWrapper;
import db.DBRecord;

import ghidra.app.cmd.data.rtti.*;
import ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.ClassTypeInfoModel;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.SiClassTypeInfoModel;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.VmiClassTypeInfoModel;
import ghidra.app.util.demangler.DemangledObject;
import ghidra.app.util.demangler.DemanglerUtil;
import ghidra.program.database.DatabaseObject;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidra.util.UniversalID;
import ghidra.util.datastruct.LongIntHashtable;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.NoValueException;

import static cppclassanalyzer.database.schema.fields.ClassTypeInfoSchemaFields.*;
import static ghidra.program.model.data.DataTypeConflictHandler.REPLACE_HANDLER;

public abstract class AbstractClassTypeInfoDB extends ClassTypeInfoDB {

	public static final String CLASS_TYPEINFO_TABLE_NAME = "ClassTypeInfo Table";

	protected final ProgramRttiRecordManager manager;
	private final Address address;
	private final String typename;
	private boolean vtableSearched;
	private long vtableKey;
	private Structure struct;

	protected AbstractClassTypeInfoDB(ProgramRttiRecordManager manager,
			ClassTypeInfoRecord record) {
		super(manager, record.getKey());
		this.manager = manager;
		this.address = getManager().decodeAddress(record.getLongValue(ADDRESS));
		this.typename = record.getStringValue(TYPENAME);
		this.vtableSearched = record.getBooleanValue(VTABLE_SEARCHED);
		this.vtableKey = record.getLongValue(VTABLE_KEY);
		this.struct = fetchDataType(record);
		fillModelData(record);
	}

	protected AbstractClassTypeInfoDB(ProgramRttiRecordManager manager, ClassTypeInfo type,
			ClassTypeInfoRecord record) {
		super(manager, record.getKey());
		this.manager = manager;
		this.address = type.getAddress();
		this.typename = type.getTypeName();
		setRecord(type, record);
		fillModelData(type, record);
	}

	protected AbstractClassTypeInfoDB(ProgramRttiRecordManager manager, ArchivedClassTypeInfo type,
			ClassTypeInfoRecord record) {
		super(manager, record.getKey());
		this.manager = manager;
		Program program = getProgram();
		this.address = type.getAddress(program);
		this.typename = type.getTypeName();
		ArchivedGnuVtable archivedVtable = type.getArchivedVtable();
		if (archivedVtable == null) {
			this.vtableKey = INVALID_KEY;
		} else {
			Vtable vtable = getManager().resolve(archivedVtable);
			if (vtable instanceof DatabaseObject) {
				this.vtableKey = ((DatabaseObject) vtable).getKey();
			} else {
				this.vtableKey = INVALID_KEY;
			}
		}
		DataTypeManager dtm = program.getDataTypeManager();
		this.struct = (Structure) dtm.resolve(type.getDataType(), REPLACE_HANDLER);
		dtm.resolve(type.getSuperDataType(), REPLACE_HANDLER);
		record.setStringValue(TYPENAME, typename);
		record.setLongValue(ADDRESS, encodeAddress(address));
		manager.updateRecord(record);
		record.setByteValue(TYPEINFO_ID, type.getClassId());
		record.setLongValue(DATATYPE_ID, struct.getUniversalID().getValue());
		this.vtableSearched = true;
		record.setBooleanValue(VTABLE_SEARCHED, vtableSearched);
		record.setLongValue(VTABLE_KEY, vtableKey);
		manager.updateRecord(record);
	}

	private void setRecord(ClassTypeInfo type, ClassTypeInfoRecord record) {
		record.setStringValue(TYPENAME, type.getTypeName());
		record.setByteValue(TYPEINFO_ID, TypeId.encode(type));
		record.setLongValue(ADDRESS, encodeAddress(type.getAddress()));
		record.setLongValue(DATATYPE_ID, INVALID_KEY);
		Vtable vtable = type.getVtable();
		if (Vtable.isValid(vtable)) {
			this.vtableSearched = true;
			vtable = manager.resolve(vtable);
			((AbstractVtableDB) vtable).setClassKey(key);
			vtableKey = ((DatabaseObject) vtable).getKey();
		} else {
			this.vtableSearched = false;
			this.vtableKey = -1;
		}
		record.setBooleanValue(VTABLE_SEARCHED, vtableSearched);
		record.setLongValue(VTABLE_KEY, vtableKey);
		manager.updateRecord(record);
	}

	protected abstract long[] getBaseKeys();
	protected abstract int[] getOffsets();
	protected abstract String getPureVirtualFunctionName();
	protected abstract AbstractCppClassBuilder getClassBuilder();
	protected abstract void fillModelData(ClassTypeInfoRecord record);
	protected abstract void fillModelData(ClassTypeInfo type, ClassTypeInfoRecord record);

	protected long encodeAddress(Address addr) {
		return getManager().encodeAddress(addr);
	}

	protected Address decodeAddress(long addr) {
		return getManager().decodeAddress(addr);
	}

	protected ClassTypeInfo getRawType() {
		TypeInfo type = manager.getManager().getTypeInfo(getAddress(), false);
		return (ClassTypeInfo) type;
	}

	@Override
	public ClassTypeInfoManagerDB getManager() {
		return (ClassTypeInfoManagerDB) manager.getManager();
	}

	@Override
	public Map<ClassTypeInfo, Integer> getBaseOffsets() {
		long[] baseKeys = getBaseKeys();
		int[] baseOffsets = getOffsets();
		if (baseKeys.length > 0 && baseOffsets.length == 0) {
			String msg = "Invalid model data for "+getGhidraClass().getName(true);
			Msg.warn(this, msg);
			return Collections.emptyMap();
		}
		Map<ClassTypeInfoDB, Integer> map = new HashMap<>(baseKeys.length);
		for (int i = 0; i < baseKeys.length && i < baseOffsets.length; i++) {
			map.put(manager.getType(baseKeys[i]), baseOffsets[i]);
		}
		return Collections.unmodifiableMap(map);
	}

	protected static byte[] getClassData(ClassTypeInfoRecord record) {
		byte[] data = record.getBinaryData(MODEL_DATA);
		if (data == null) {
			DemangledObject o = DemanglerUtil.demangle("_ZTI"+record.getStringValue(TYPENAME));
			String name;
			if (o != null) {
				name = o.getNamespace().getOriginalDemangled();
			} else {
				name = record.getStringValue(TYPENAME);
			}
			Msg.warn(AbstractClassTypeInfoDB.class, "Model data for "+name+" was null");
		}
		return data;
	}

	protected static String getIdentifier(byte id) {
		return TypeId.decode(id).getIdentifier();
	}

	protected boolean getVtableSearched() {
		ClassTypeInfoRecord record = getRecord();
		return record.getBooleanValue(VTABLE_SEARCHED);
	}

	public static int getBaseCount(ClassTypeInfoRecord record) {
		byte id = record.getByteValue(TYPEINFO_ID);
		switch (TypeId.decode(id)) {
			case CLASS:
			case SI_CLASS:
			case VMI_CLASS:
				return GnuClassTypeInfoDB.getBaseCount(record);
			case RTTI_MODEL_WRAPPER:
				return VsClassTypeInfoDB.getBaseCount(record);
			default:
				// impossible but javac complains for some reason
				throw new AssertException("Ghidra-Cpp-Class-Analyzer: invalid database record");
		}
	}

	private Structure fetchDataType(ClassTypeInfoRecord record) {
		long id = record.getLongValue(DATATYPE_ID);
		if (id != INVALID_KEY) {
			DataType dt = getProgram().getDataTypeManager().findDataTypeForID(
				new UniversalID(id));
			if (dt instanceof Structure) {
				return (Structure) dt;
			}
		}
		return null;
	}

	public static long[] getBaseKeys(ClassTypeInfoRecord record) {
		byte id = record.getByteValue(TYPEINFO_ID);
		switch (TypeId.decode(id)) {
			case CLASS:
			case SI_CLASS:
			case VMI_CLASS:
				return GnuClassTypeInfoDB.getBaseKeys(record);
			case RTTI_MODEL_WRAPPER:
				return VsClassTypeInfoDB.getBaseKeys(record);
			default:
				// impossible but javac complains for some reason
				throw new AssertException("Ghidra-Cpp-Class-Analyzer: invalid database record");
		}
	}

	public TypeId getTypeId() {
		return TypeId.decode(getRecord().getByteValue(TYPEINFO_ID));
	}

	protected static void updateKeys(long[] keys, LongIntHashtable keyMap) {
		try {
			for (int i = 0; i < keys.length; i++) {
				keys[i] = keyMap.get(keys[i]);
			}
		} catch (NoValueException e) {
			throw new AssertException("Ghidra-Cpp-Class-Analyzer: Failed to remap keys", e);
		}
	}

	public static void updateRecord(ClassTypeInfoRecord record, LongIntHashtable keyMap) {
		byte id = record.getByteValue(TYPEINFO_ID);
		switch (TypeId.decode(id)) {
			case CLASS:
			case SI_CLASS:
			case VMI_CLASS:
				GnuClassTypeInfoDB.updateRecord(record, keyMap);
				break;
			case RTTI_MODEL_WRAPPER:
				VsClassTypeInfoDB.updateRecord(record, keyMap);
				break;
		}
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof ClassTypeInfo) {
			return getAddress().equals(((ClassTypeInfo) o).getAddress());
		}
		return false;
	}

	@Override
	public final int hashCode() {
		return getTypeName().hashCode();
	}

	@Override
	protected final boolean refresh() {
		return refresh(getRecord());
	}

	@Override
	protected boolean refresh(DBRecord record) {
		return refresh(new ClassTypeInfoRecord(record));
	}

	protected boolean isVtableSearched() {
		return vtableSearched;
	}

	protected void setVtableSearched() {
		this.vtableSearched = true;
		ClassTypeInfoRecord record = getRecord();
		record.setBooleanValue(VTABLE_SEARCHED, true);
		manager.updateRecord(record);
	}

	protected boolean refresh(ClassTypeInfoRecord record) {
		if (record == null) {
			return false;
		}
		Address addr = getManager().decodeAddress(record.getLongValue(ADDRESS));
		if (address.equals(addr)) {
			vtableSearched = record.getBooleanValue(VTABLE_SEARCHED);
			vtableKey = record.getLongValue(VTABLE_KEY);
			struct = fetchDataType(record);
			return true;
		}
		return false;
	}

	public Program getProgram() {
		return getManager().getProgram();
	}

	@Override
	public String getName() {
		return getNamespace().getName();
	}

	@Override
	public final GhidraClass getGhidraClass() {
		return (GhidraClass) getNamespace();
	}

	@Override
	public String getTypeName() {
		return typename;
	}

	protected ClassTypeInfoRecord getRecord() {
		ClassTypeInfoRecord record = manager.getTypeRecord(key);
		if (record != null) {
			return record;
		}
		throw new AssertException(
			String.format("Ghidra-Cpp-Class-Analyzer: %s db record no longer exists",
			getName()));
	}

	@Override
	public String getIdentifier() {
		ClassTypeInfoRecord record = getRecord();
		byte id = record.getByteValue(TYPEINFO_ID);
		return TypeId.decode(id).getIdentifier();
	}

	@Override
	public DataType getDataType() {
		ClassTypeInfoRecord record = getRecord();
		byte id = record.getByteValue(TYPEINFO_ID);
		try {
			return (DataType) TypeId.decode(id).clazz
				.getDeclaredMethod("getDataType", DataTypeManager.class)
				.invoke(null, getProgram().getDataTypeManager());
		} catch (Exception e) {
			throw new AssertException("Ghidra-Cpp-Class-Analyzer: ", e);
		}
	}

	@Override
	public Address getAddress() {
		return address;
	}

	@Override
	public Vtable getVtable() {
		Vtable vtable = manager.getVtable(vtableKey);
		if (vtable == null) {
			return Vtable.NO_VTABLE;
		}
		return vtable;
	}

	public void setVtable(Vtable vtable) {
		ClassTypeInfoRecord record = getRecord();
		if (vtable != Vtable.NO_VTABLE) {
			if (!(vtable instanceof DatabaseObject)) {
				vtable = manager.resolve(vtable);
				((AbstractVtableDB) vtable).setClassKey(key);
			}
			vtableKey = ((DatabaseObject) vtable).getKey();
		} else {
			vtableKey = -1;
		}
		record.setLongValue(VTABLE_KEY, vtableKey);
		fillModelData(record);
		manager.updateRecord(record);
	}

	@Override
	public Structure getClassDataType() {
		ClassTypeInfoRecord record = getRecord();
		if (struct != null) {
			if (!ClassTypeInfoUtils.isPlaceholder(struct)) {
				long dtKey = record.getLongValue(DATATYPE_ID);
				if (dtKey == INVALID_KEY) {
					record.setLongValue(DATATYPE_ID, struct.getUniversalID().getValue());
					manager.updateRecord(record);
				}
				return struct;
			}
		}
		refreshDataType();
		return struct;
	}

	public void refreshDataType() {
		ClassTypeInfoRecord record = getRecord();
		AbstractCppClassBuilder builder = getClassBuilder();
		struct = builder.getDataType();
		record.setLongValue(DATATYPE_ID, struct.getUniversalID().getValue());
		manager.updateRecord(record);
	}

	public void setClassDataType(Structure struct) {
		if (this.struct == null) {
			this.struct =
				ClassTypeInfoUtils.getPlaceholderStruct(this, getProgram().getDataTypeManager());
		}
		this.struct.replaceWith(struct);
		ClassTypeInfoRecord record = getRecord();
		record.setLongValue(DATATYPE_ID, this.struct.getUniversalID().getValue());
		manager.updateRecord(record);
	}

	@Override
	public long getClassDataTypeId() {
		ClassTypeInfoRecord record = getRecord();
		return record.getLongValue(DATATYPE_ID);
	}

	@Override
	public final boolean isAbstract() {
		return CppClassAnalyzerUtils.isAbstract(this, getPureVirtualFunctionName());
	}

	@Override
	public String toString() {
		return getName();
	}

	@Override
	public final boolean isModifiable() {
		return true;
	}

	public static enum TypeId {
		CLASS(ClassTypeInfoModel.class),
		SI_CLASS(SiClassTypeInfoModel.class),
		VMI_CLASS(VmiClassTypeInfoModel.class),
		RTTI_MODEL_WRAPPER(RttiModelWrapper.class);

		private final Class<? extends ClassTypeInfo> clazz;

		private TypeId(Class<? extends ClassTypeInfo> clazz) {
			this.clazz = clazz;
		}

		public String getIdentifier() {
			switch (this) {
				case CLASS:
					return ClassTypeInfoModel.ID_STRING;
				case SI_CLASS:
					return SiClassTypeInfoModel.ID_STRING;
				case VMI_CLASS:
					return VmiClassTypeInfoModel.ID_STRING;
				default:
					return "";
			}
		}

		private static TypeId decode(byte b) {
			return values()[b];
		}

		private static byte encode(ClassTypeInfo type) {
			return (byte) Arrays.stream(values())
				.filter(v -> v.isEquivalent(type))
				.mapToInt(TypeId::ordinal)
				.findFirst()
				.orElseThrow();
		}

		private boolean isEquivalent(ClassTypeInfo type) {
			return clazz == type.getClass();
		}

		protected byte encode() {
			return (byte) ordinal();
		}
	}

}

```

`src/main/java/cppclassanalyzer/data/typeinfo/ArchivedClassTypeInfo.java`:

```java
package cppclassanalyzer.data.typeinfo;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import javax.help.UnsupportedOperationException;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.app.util.SymbolPath;
import ghidra.app.util.SymbolPathParser;
import ghidra.app.util.demangler.Demangled;
import ghidra.app.util.demangler.DemanglerUtil;

import cppclassanalyzer.cmd.CreateExternalSymbolBackgroundCmd;
import cppclassanalyzer.data.ArchivedRttiData;
import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.manager.FileArchiveClassTypeInfoManager;
import cppclassanalyzer.data.manager.LibraryClassTypeInfoManager;
import cppclassanalyzer.data.manager.recordmanagers.ArchiveRttiRecordManager;
import cppclassanalyzer.data.vtable.ArchivedGnuVtable;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.FunctionDefinition;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.symbol.Symbol;
import ghidra.util.UniversalID;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.database.record.ArchivedClassTypeInfoRecord;

import static cppclassanalyzer.database.schema.fields.ArchivedClassTypeInfoSchemaFields.*;
import static ghidra.program.model.data.DataTypeConflictHandler.KEEP_HANDLER;

public final class ArchivedClassTypeInfo extends ClassTypeInfoDB implements ArchivedRttiData {

	public static final String TABLE_NAME = "ClassTypeInfo Archive Table";

	private static final Set<String> PURE_VIRTUAL_FUNCTION_NAMES =
		Set.of("__cxa_pure_virtual", "_purecall");

	private final ArchiveRttiRecordManager manager;
	private final long address;
	private final String programName;
	private final String typeName;
	private final String symbolName;
	private final byte classId;
	private final Structure struct;
	private final Structure superStruct;
	private final ArchivedGnuVtable vtable;
	private final int[] baseOffsets;
	private final long[] baseKeys;
	private final long[] nonVirtualBaseKeys;
	private final long[] virtualKeys;
	private final Demangled demangled;

	public ArchivedClassTypeInfo(ArchiveRttiRecordManager manager, GnuClassTypeInfoDB type,
			ArchivedClassTypeInfoRecord record) {
		super(manager, record);
		this.manager = manager;
		DataTypeManager archiveDtm = getDataTypeManager();
		this.address = type.getManager().encodeAddress(type.getAddress());
		record.setLongValue(ADDRESS, address);
		this.programName = type.getProgram().getName();
		this.typeName = type.getTypeName();
		this.symbolName = TypeInfoUtils.getSymbolName(type);
		this.classId = type.getTypeId().encode();
		this.struct = (Structure) archiveDtm.resolve(type.getClassDataType(), KEEP_HANDLER);
		DataTypeManager dtm = struct.getDataTypeManager();
		DataType superDt = dtm.getDataType(getCategoryPath(), "super_" + struct.getName());
		if (superDt != null) {
			this.superStruct = (Structure) archiveDtm.resolve(superDt, KEEP_HANDLER);
		} else {
			this.superStruct = this.struct;
		}
		this.baseKeys = type.getBaseKeys();
		this.nonVirtualBaseKeys = type.getNonVirtualBaseKeys();
		this.baseOffsets = type.getOffsets();
		this.virtualKeys = type.getVirtualBaseKeys();
		record.setStringValue(PROGRAM_NAME, programName);
		record.setStringValue(TYPENAME, typeName);
		record.setStringValue(MANGLED_SYMBOL, symbolName);
		record.setByteValue(CLASS_ID, classId);
		record.setLongValue(DATATYPE_ID, struct.getUniversalID().getValue());
		record.setLongValue(SUPER_DATATYPE_ID, superStruct.getUniversalID().getValue());
		record.setLongArray(BASE_KEYS, baseKeys);
		record.setLongArray(NON_VIRTUAL_BASE_KEYS, nonVirtualBaseKeys);
		record.setLongArray(VIRTUAL_BASE_KEYS, virtualKeys);
		record.setIntArray(BASE_OFFSETS, baseOffsets);

		// vtable must be done last to resolve symbol name
		if (Vtable.isValid(type.getVtable())) {
			// must update first or face infinite recursion
			manager.updateRecord(record);
			this.vtable = this.manager.resolve(type.getVtable());
			record.setLongValue(VTABLE_KEY, vtable.getKey());
		} else {
			this.vtable = null;
			record.setLongValue(VTABLE_KEY, -1);
		}
		manager.updateRecord(record);
		this.demangled = doDemangle(symbolName);
	}

	public ArchivedClassTypeInfo(ArchiveRttiRecordManager manager,
			ArchivedClassTypeInfoRecord record) {
		super(manager, record);
		this.manager = manager;
		DataTypeManager classManager = getDataTypeManager();
		this.address = record.getLongValue(ADDRESS);
		this.programName = record.getStringValue(PROGRAM_NAME);
		this.typeName = record.getStringValue(TYPENAME);
		this.symbolName = record.getStringValue(MANGLED_SYMBOL);
		this.classId = record.getByteValue(CLASS_ID);
		UniversalID id = new UniversalID(record.getLongValue(DATATYPE_ID));
		this.struct = (Structure) classManager.findDataTypeForID(id);
		id = new UniversalID(
			record.getLongValue(SUPER_DATATYPE_ID));
		this.superStruct = (Structure) classManager.findDataTypeForID(id);
		long vtableKey = record.getLongValue(VTABLE_KEY);
		if (vtableKey != -1) {
			this.vtable = this.manager.getVtable(vtableKey);
		}
		else {
			this.vtable = null;
		}
		this.baseKeys = record.getLongArray(BASE_KEYS);
		this.nonVirtualBaseKeys = record.getLongArray(NON_VIRTUAL_BASE_KEYS);
		this.baseOffsets = record.getIntArray(BASE_OFFSETS);
		this.virtualKeys = record.getLongArray(VIRTUAL_BASE_KEYS);
		this.demangled = doDemangle(symbolName);
	}

	public String getProgramName() {
		return programName;
	}

	private static Demangled doDemangle(String symbolName) {
		Demangled demangled = DemanglerUtil.demangle(symbolName);
		if (demangled == null) {
			throw new AssertException("ArchivedClassTypeInfo symbol "
				+ symbolName + " failed to demangle");
		}
		return demangled.getNamespace();
	}

	public Address getAddress(Program program) {
		List<Symbol> symbols = program.getSymbolTable().getGlobalSymbols(symbolName);
		if (symbols.isEmpty()) {
			CreateExternalSymbolBackgroundCmd cmd = new CreateExternalSymbolBackgroundCmd(this);
			if (!cmd.applyTo(program)) {
				// this should never fail
				throw new AssertException("Failed to create external symbol for "+symbolName);
			}
			return cmd.getExternalLocation().getExternalSpaceAddress();
		}
		if (symbols.size() != 1) {
			throw new AssertException("Expected only 1 " + symbolName + " to exist");
		}
		return symbols.get(0).getAddress();
	}

	public Address getExternalAddress(Program program) {
		if (address != 0) {
			return program.getAddressMap().decodeAddress(address);
		}
		return Address.NO_ADDRESS;
	}

	@Override
	protected boolean refresh() {
		return false;
	}

	@Override
	public ClassTypeInfoManager getManager() {
		return manager.getManager();
	}

	public DataTypeManager getDataTypeManager() {
		return manager.getDataTypeManager();
	}

	public byte getClassId() {
		return classId;
	}

	public String getTypeName() {
		return typeName;
	}

	public String getSymbolName() {
		return symbolName;
	}

	/**
	 * @return the datatype
	 */
	public Structure getDataType() {
		return struct;
	}

	public Structure getSuperDataType() {
		return superStruct;
	}

	public CategoryPath getCategoryPath() {
		return struct.getCategoryPath();
	}

	public ArchivedGnuVtable getArchivedVtable() {
		return vtable;
	}

	public ArchivedClassTypeInfo[] getParentModels() {
		ClassTypeInfoManager classManager = getManager();
		return Arrays.stream(baseKeys)
				.mapToObj(classManager::getType)
				.toArray(ArchivedClassTypeInfo[]::new);
	}

	public ArchivedClassTypeInfo[] getArchivedVirtualParents() {
		ClassTypeInfoManager classManager = getManager();
		return Arrays.stream(virtualKeys)
				.mapToObj(classManager::getType)
				.toArray(ArchivedClassTypeInfo[]::new);
	}

	/**
	 * @return the baseKeys
	 */
	protected long[] getBaseKeys() {
		return baseKeys;
	}

	protected long[] getNonVirtualBaseKeys() {
		return nonVirtualBaseKeys;
	}

	protected long[] getVirtualKeys() {
		return virtualKeys;
	}

	/**
	 * @return the baseOffsets
	 */
	public int[] getBaseOffsetValues() {
		return baseOffsets;
	}

	@Override
	public Map<ClassTypeInfo, Integer> getBaseOffsets() {
		Map<ClassTypeInfo, Integer> map = new HashMap<>(baseKeys.length);
		for (int i = 0; i < baseKeys.length; i++) {
			map.put(manager.getType(baseKeys[i]), baseOffsets[i]);
		}
		return Collections.unmodifiableMap(map);
	}

	@Override
	public String getName() {
		return demangled.getDemangledName();
	}

	private static UnsupportedOperationException getUnsupportedMsg(Method method) {
		return new UnsupportedOperationException(
			"Method "+method.getName()+" is not supported for an ArchivedClassTypeInfo");
	}

	@Override
	public Namespace getNamespace() {
		throw getUnsupportedMsg(new Object(){}.getClass().getEnclosingMethod());
	}

	@Override
	public String getIdentifier() {
		return AbstractClassTypeInfoDB.getIdentifier(classId);
	}

	@Override
	public Address getAddress() {
		throw getUnsupportedMsg(new Object(){}.getClass().getEnclosingMethod());
	}

	@Override
	public GhidraClass getGhidraClass() {
		throw getUnsupportedMsg(new Object(){}.getClass().getEnclosingMethod());
	}

	@Override
	public boolean hasParent() {
		return baseKeys.length > 0;
	}

	@Override
	public Set<ClassTypeInfo> getVirtualParents() {
		return Set.of(getArchivedVirtualParents());
	}

	@Override
	public boolean isAbstract() {
		if (vtable != null) {
			return Arrays.stream(vtable.getFunctionDefinitions())
				.flatMap(Arrays::stream)
				.filter(Objects::nonNull)
				.map(FunctionDefinition::getName)
				.filter(PURE_VIRTUAL_FUNCTION_NAMES::contains)
				.findFirst()
				.isPresent();
		}
		return false;
	}

	@Override
	public Vtable findVtable(TaskMonitor monitor) throws CancelledException {
		throw getUnsupportedMsg(new Object(){}.getClass().getEnclosingMethod());
	}

	@Override
	public Vtable getVtable() {
		throw getUnsupportedMsg(new Object(){}.getClass().getEnclosingMethod());
	}

	@Override
	public Structure getClassDataType() {
		long id = manager.getTypeRecord(key).getLongValue(DATATYPE_ID);
		return (Structure) getDataTypeManager().findDataTypeForID(new UniversalID(id));
	}

	@Override
	public SymbolPath getSymbolPath() {
		return new SymbolPath(SymbolPathParser.parse(demangled.getNamespaceString()));
	}

	@Override
	public long getClassDataTypeId() {
		return struct.getUniversalID().getValue();
	}

	@Override
	public boolean isModifiable() {
		ClassTypeInfoManager manager = getManager();
		if (manager instanceof LibraryClassTypeInfoManager) {
			manager = ((LibraryClassTypeInfoManager) manager).getProjectManager();
		}
		return ((FileArchiveClassTypeInfoManager) manager).isModifiable();
	}

}

```

`src/main/java/cppclassanalyzer/data/typeinfo/ClassTypeInfoDB.java`:

```java
package cppclassanalyzer.data.typeinfo;

import java.util.Map;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.program.database.DatabaseObject;
import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.manager.recordmanagers.ArchiveRttiRecordManager;
import cppclassanalyzer.data.manager.recordmanagers.ProgramRttiRecordManager;
import ghidra.program.database.map.AddressMap;
import ghidra.program.model.data.*;

import cppclassanalyzer.database.record.ArchivedClassTypeInfoRecord;
import cppclassanalyzer.database.record.ClassTypeInfoRecord;

/**
 * A {@link DatabaseObject} implementation of a {@link ClassTypeInfo}
 */
public abstract class ClassTypeInfoDB extends DatabaseObject implements ClassTypeInfo {

	public static final long INVALID_KEY = AddressMap.INVALID_ADDRESS_KEY;

	ClassTypeInfoDB(ProgramRttiRecordManager manager, ClassTypeInfoRecord record) {
		super(manager.getTypeCache(), record.getKey());
	}

	ClassTypeInfoDB(ProgramRttiRecordManager manager, long key) {
		super(manager.getTypeCache(), key);
	}

	ClassTypeInfoDB(ArchiveRttiRecordManager manager, ArchivedClassTypeInfoRecord record) {
		super(manager.getTypeCache(), record.getKey());
	}

	/**
	 * Gets the manager containing this type
	 * @return the manager containing this type
	 */
	public abstract ClassTypeInfoManager getManager();

	@Override
	public abstract ClassTypeInfoDB[] getParentModels();

	/**
	 * Gets the id for this type's class data type
	 * @return the class data type's id
	 */
	public abstract long getClassDataTypeId();

	/**
	 * Checks if this type is modifiable
	 * @return true if this type is modifiable
	 */
	public abstract boolean isModifiable();

	/**
	 * Gets a map of this types bases and offsets
	 * @return a map of bases to offsets
	 */
	public abstract Map<ClassTypeInfo, Integer> getBaseOffsets();

	/**
	 * Gets this type class data type which is appropriate for inheriting
	 * @return an inheritable form of the class data type
	 */
	public final Structure getSuperClassDataType() {
		Structure struct = getClassDataType();
		CategoryPath path = new CategoryPath(struct.getCategoryPath(), struct.getName());
		DataTypeManager dtm = struct.getDataTypeManager();
		if (!dtm.containsCategory(path)) {
			return struct;
		}
		DataType superStruct = dtm.getDataType(path, "super_"+struct.getName());
		return superStruct != null ? (Structure) superStruct : struct;
	}

	@Override
	public boolean checkIsValid() {
		return super.checkIsValid();
	}

}

```

`src/main/java/cppclassanalyzer/data/typeinfo/GnuClassTypeInfoDB.java`:

```java
package cppclassanalyzer.data.typeinfo;

import static cppclassanalyzer.database.schema.fields.ClassTypeInfoSchemaFields.*;

import java.nio.ByteBuffer;
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.LongStream;
import java.util.stream.Stream;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils;
import ghidra.app.cmd.data.rtti.gcc.GccCppClassBuilder;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.BaseClassTypeInfoModel;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.VmiClassTypeInfoModel;
import ghidra.program.database.DatabaseObject;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.symbol.Namespace;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.manager.recordmanagers.ProgramRttiRecordManager;

import ghidra.util.datastruct.LongArrayList;
import ghidra.util.datastruct.LongIntHashtable;

import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.database.record.ClassTypeInfoRecord;

public class GnuClassTypeInfoDB extends AbstractClassTypeInfoDB {

	private final GhidraClass gc;
	private long[] nonVirtualBaseKeys;
	private long[] virtualBaseKeys;
	private long[] baseKeys;
	private int[] baseOffsets;

	public GnuClassTypeInfoDB(ProgramRttiRecordManager worker, ClassTypeInfoRecord record) {
		super(worker, record);
		this.gc = ClassTypeInfoUtils.getGhidraClassFromTypeName(getProgram(), getTypeName());
	}

	public GnuClassTypeInfoDB(ProgramRttiRecordManager worker, ClassTypeInfo type,
			ClassTypeInfoRecord record) {
		super(worker, type, record);
		this.gc = ClassTypeInfoUtils.getGhidraClassFromTypeName(getProgram(), getTypeName());
	}

	public GnuClassTypeInfoDB(ProgramRttiRecordManager worker, ArchivedClassTypeInfo type,
			ClassTypeInfoRecord record) {
		super(worker, type, record);
		this.gc = ClassTypeInfoUtils.getGhidraClassFromTypeName(getProgram(), getTypeName());
		ClassTypeInfoManager aMan = type.getManager();
		this.nonVirtualBaseKeys = extractKeys(aMan, type.getNonVirtualBaseKeys());
		this.virtualBaseKeys = extractKeys(aMan, type.getVirtualKeys());
		this.baseKeys = extractKeys(aMan, type.getBaseKeys());
		this.baseOffsets = type.getBaseOffsetValues();
		fillRecord(record);
		setVtableSearched();
		Vtable vtable = type.getVtable();
		if (Vtable.isValid(vtable)) {
			vtable = worker.resolve(vtable);
			setVtable(vtable);
		}
	}

	private long[] extractKeys(ClassTypeInfoManager aMan, long[] keys) {
		return Arrays.stream(keys)
			.mapToObj(aMan::getType)
			.map(ArchivedClassTypeInfo.class::cast)
			.map(manager::resolve)
			.mapToLong(DatabaseObject::getKey)
			.toArray();
	}

	private void fillRecord(ClassTypeInfoRecord record) {
		ByteBuffer buf = ByteBuffer.allocate(getSize());
		ClassTypeInfoRecord.setLongArray(buf, nonVirtualBaseKeys);
		ClassTypeInfoRecord.setLongArray(buf, virtualBaseKeys);
		ClassTypeInfoRecord.setLongArray(buf, baseKeys);
		ClassTypeInfoRecord.setIntArray(buf, baseOffsets);
		record.setBinaryData(MODEL_DATA, buf.array());
		manager.updateRecord(record);
	}

	private int getSize() {
		return ClassTypeInfoRecord.getArraySize(nonVirtualBaseKeys)
			+ ClassTypeInfoRecord.getArraySize(virtualBaseKeys)
			+ ClassTypeInfoRecord.getArraySize(baseKeys)
			+ ClassTypeInfoRecord.getArraySize(baseOffsets);
	}

	@Override
	public boolean hasParent() {
		return nonVirtualBaseKeys.length > 0 || virtualBaseKeys.length > 0;
	}

	@Override
	public ClassTypeInfoDB[] getParentModels() {
		return LongStream.concat(
			LongStream.of(nonVirtualBaseKeys),
			LongStream.of(virtualBaseKeys))
				.mapToObj(manager::getType)
				.toArray(ClassTypeInfoDB[]::new);
	}

	@Override
	public Set<ClassTypeInfo> getVirtualParents() {
		return LongStream.of(virtualBaseKeys)
			.mapToObj(manager::getType)
			.collect(Collectors.toSet());
	}

	@Override
	public Vtable findVtable(TaskMonitor monitor) throws CancelledException {
		if (isVtableSearched()) {
			return getVtable();
		}
		setVtableSearched();
		Vtable vtable = ClassTypeInfoUtils.findVtable(getProgram(), this, monitor);
		if (Vtable.isValid(vtable)) {
			setVtable(vtable);
			return getVtable();
		}
		return vtable;
	}

	public static long[] getBaseKeys(ClassTypeInfoRecord record) {
		ByteBuffer buf = ByteBuffer.wrap(getClassData(record));
		long[] nonVirtualBaseKeys = ClassTypeInfoRecord.getLongArray(buf);
		long[] virtualBaseKeys = ClassTypeInfoRecord.getLongArray(buf);
		return LongStream.concat(
			LongStream.of(nonVirtualBaseKeys),
			LongStream.of(virtualBaseKeys)).toArray();
	}

	public static int getBaseCount(ClassTypeInfoRecord record) {
		ByteBuffer buf = ByteBuffer.wrap(getClassData(record));
		long[] nonVirtualBaseKeys = ClassTypeInfoRecord.getLongArray(buf);
		long[] virtualBaseKeys = ClassTypeInfoRecord.getLongArray(buf);
		return nonVirtualBaseKeys.length + virtualBaseKeys.length;
	}

	public static void updateRecord(ClassTypeInfoRecord record, LongIntHashtable keyMap) {
		ByteBuffer buf = ByteBuffer.wrap(getClassData(record));
		long[] nonVirtualBaseKeys = ClassTypeInfoRecord.getLongArray(buf);
		long[] virtualBaseKeys = ClassTypeInfoRecord.getLongArray(buf);
		updateKeys(nonVirtualBaseKeys, keyMap);
		updateKeys(virtualBaseKeys, keyMap);
		buf = ByteBuffer.allocate(buf.array().length);
		ClassTypeInfoRecord.setLongArray(buf, nonVirtualBaseKeys);
		ClassTypeInfoRecord.setLongArray(buf, virtualBaseKeys);
		record.setBinaryData(MODEL_DATA, buf.array());
	}

	@Override
	protected long[] getBaseKeys() {
		return baseKeys;
	}

	@Override
	protected int[] getOffsets() {
		return baseOffsets;
	}

	protected long[] getNonVirtualBaseKeys() {
		return nonVirtualBaseKeys;
	}

	protected long[] getVirtualBaseKeys() {
		return virtualBaseKeys;
	}

	@Override
	public Vtable getVtable() {
		return super.getVtable();
	}

	@Override
	protected void fillModelData(ClassTypeInfoRecord record) {
		byte[] data = getClassData(record);
		if (data != null) {
			ByteBuffer buf = ByteBuffer.wrap(data);
			nonVirtualBaseKeys = ClassTypeInfoRecord.getLongArray(buf);
			virtualBaseKeys = ClassTypeInfoRecord.getLongArray(buf);
			baseKeys = ClassTypeInfoRecord.getLongArray(buf);
			baseOffsets = ClassTypeInfoRecord.getIntArray(buf);
			if (nonVirtualBaseKeys.length == 0 && virtualBaseKeys.length == 0) {
				return;
			}
			if (baseKeys.length == 0 && baseOffsets.length == 0 && isVtableSearched()) {
				baseKeys = getBaseKeys(record);
				baseOffsets = doGetBaseOffsets();
				fillRecord(record);
			}
		} else {
			fillModelData(getRawType(), record);
		}
	}

	private int[] doGetBaseOffsets() {
		return Stream.concat(doGetOffsets().stream(), getSortedOffsets().stream())
			.mapToInt(Long::intValue)
			.toArray();
	}

	List<Long> doGetOffsets() {
		if (getTypeId() == TypeId.VMI_CLASS) {
			BaseClassTypeInfoModel[] bases = getBases();
			LongArrayList result = new LongArrayList();
			for (BaseClassTypeInfoModel base : bases) {
				if(!base.isVirtual()) {
					result.add((long) base.getOffset());
				}
			}
			return result;
		}
		if (nonVirtualBaseKeys.length == 1) {
			return List.of(0L);
		}
		return Collections.emptyList();
	}

	List<Long> getSortedOffsets() {
		GnuVtable vtable = (GnuVtable) getVtable();
		if (Vtable.isValid(vtable)) {
			List<Long> offsets = new ArrayList<>(vtable.getPrefixes().get(0).getOffsets());
			if (offsets.size() > 0) {
				offsets.sort(null);
				offsets.remove(0);
			}
			return offsets;
		}
		return Collections.emptyList();
	}

	private BaseClassTypeInfoModel[] getBases() {
		return VmiClassTypeInfoModel.getBases(getProgram(), getAddress());
	}

	@Override
	protected boolean refresh(ClassTypeInfoRecord record) {
		if (super.refresh(record)) {
			fillModelData(record);
			return true;
		}
		return false;
	}

	@Override
	public Namespace getNamespace() {
		return gc;
	}

	@Override
	protected String getPureVirtualFunctionName() {
		return GnuVtable.PURE_VIRTUAL_FUNCTION_NAME;
	}

	@Override
	protected GccCppClassBuilder getClassBuilder() {
		return new GccCppClassBuilder(this);
	}

	@Override
	protected void fillModelData(ClassTypeInfo type, ClassTypeInfoRecord record) {
		if (type.hasParent()) {
			virtualBaseKeys = type.getVirtualParents()
				.stream()
				.map(manager::resolve)
				.mapToLong(DatabaseObject::getKey)
				.toArray();
		} else {
			virtualBaseKeys = new long[0];
		}
		if (type instanceof VmiClassTypeInfoModel) {
			VmiClassTypeInfoModel vmi = (VmiClassTypeInfoModel) type;
			nonVirtualBaseKeys =
				Arrays.stream(vmi.getBases())
					.filter(Predicate.not(BaseClassTypeInfoModel::isVirtual))
					.map(BaseClassTypeInfoModel::getClassModel)
					.map(manager::resolve)
					.mapToLong(DatabaseObject::getKey)
					.toArray();
		} else if (type.hasParent()) {
			nonVirtualBaseKeys =
				Arrays.stream(type.getParentModels())
					.map(manager::resolve)
					.mapToLong(DatabaseObject::getKey)
					.toArray();
		} else {
			nonVirtualBaseKeys = new long[0];
		}
		baseKeys = new long[0];
		baseOffsets = new int[0];
		fillRecord(record);
	}
}

```

`src/main/java/cppclassanalyzer/data/typeinfo/VsClassTypeInfoDB.java`:

```java
package cppclassanalyzer.data.typeinfo;

import static cppclassanalyzer.database.schema.fields.ClassTypeInfoSchemaFields.*;

import java.nio.ByteBuffer;
import java.util.*;
import java.util.stream.LongStream;

import ghidra.app.cmd.data.TypeDescriptorModel;
import ghidra.app.cmd.data.rtti.*;
import ghidra.app.util.NamespaceUtils;

import cppclassanalyzer.data.manager.recordmanagers.ProgramRttiRecordManager;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.symbol.Namespace;
import ghidra.util.datastruct.LongIntHashtable;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.database.record.ClassTypeInfoRecord;
import cppclassanalyzer.vs.*;

public class VsClassTypeInfoDB extends AbstractClassTypeInfoDB implements VsClassTypeInfo {

	private long[] baseKeys;
	private int[] baseOffsets;
	private long baseModelAddress;
	private long hierarchyDescriptorAddress;
	private final GhidraClass gc;

	public VsClassTypeInfoDB(ProgramRttiRecordManager worker, ClassTypeInfoRecord record) {
		super(worker, record);
		this.gc = doGetGhidraClass();
	}

	public VsClassTypeInfoDB(ProgramRttiRecordManager worker, VsClassTypeInfo type,
			ClassTypeInfoRecord record) {
		super(worker, type, record);
		this.gc = type.getGhidraClass();
	}

	private GhidraClass doGetGhidraClass() {
		int id = getProgram().startTransaction(getClass().getSimpleName()+": Getting GhidraClass");
		boolean success = false;
		try {
			Namespace ns = getTypeDescriptor().getDescriptorAsNamespace();
			if (!(ns instanceof GhidraClass)) {
				ns = NamespaceUtils.convertNamespaceToClass(ns);
			}
			success = true;
			return (GhidraClass) ns;
		} catch (InvalidInputException e) {
			throw new AssertException(e);
		} finally {
			getProgram().endTransaction(id, success);
		}
	}

	private void fillRecord(ClassTypeInfoRecord record) {
		ByteBuffer buf = ByteBuffer.allocate(getSize());
		ClassTypeInfoRecord.setLongArray(buf, baseKeys);
		ClassTypeInfoRecord.setIntArray(buf, baseOffsets);
		buf.putLong(baseModelAddress);
		buf.putLong(hierarchyDescriptorAddress);
		record.setBinaryData(MODEL_DATA, buf.array());
		manager.updateRecord(record);
	}

	private int getSize() {
		return ClassTypeInfoRecord.getArraySize(baseKeys) +
			ClassTypeInfoRecord.getArraySize(baseOffsets) + Long.BYTES * 3;
	}

	@Override
	public boolean hasParent() {
		return baseKeys.length > 0;
	}

	@Override
	public ClassTypeInfoDB[] getParentModels() {
		return LongStream.of(baseKeys)
			.mapToObj(manager::getType)
			.toArray(ClassTypeInfoDB[]::new);
	}

	static boolean isVirtual(Rtti1Model model) throws InvalidDataTypeException {
		return (model.getAttributes() >> 4 & 1) == 1;
	}

	private ClassTypeInfo getParent(Rtti1Model model) {
		try {
			return manager.getManager().getType(model.getRtti0Address());
		} catch (InvalidDataTypeException e) {
			invalidError(e);
		}
		return null;
	}

	@Override
	public Set<ClassTypeInfo> getVirtualParents() {
		try {
			Set<ClassTypeInfo> result = new LinkedHashSet<>();
			Rtti3Model rtti3 = getHierarchyDescriptor();
			if (rtti3 == null) {
				return Collections.emptySet();
			}
			Rtti2Model baseArray = rtti3.getRtti2Model();
			for (int i = 1; i < rtti3.getRtti1Count(); i++) {
				Rtti1Model model = baseArray.getRtti1Model(i);
				ClassTypeInfo parent = getParent(model);
				result.addAll(parent.getVirtualParents());
				if (isVirtual(model)) {
					result.add(getManager().getType(model.getRtti0Address()));
				}
			}
			return result;
		} catch (InvalidDataTypeException e) {
			invalidError(e);
		}
		return null;
	}

	@Override
	public Vtable findVtable(TaskMonitor monitor) throws CancelledException {
		if (isVtableSearched()) {
			return getVtable();
		}
		RttiModelWrapper wrapper = RttiModelWrapper.getWrapper(getTypeDescriptorModel(), monitor);
		Vtable vtable = wrapper.findVtable(monitor);
		setVtableSearched();
		if (Vtable.isValid(vtable)) {
			vtable = manager.resolve(vtable);
			setVtable(vtable);
		}
		return vtable;
	}

	public static long[] getBaseKeys(ClassTypeInfoRecord record) {
		ByteBuffer buf = ByteBuffer.wrap(getClassData(record));
		return ClassTypeInfoRecord.getLongArray(buf);
	}

	@Override
	public Rtti1Model getBaseModel() {
		if (baseModelAddress != INVALID_KEY) {
			return new Rtti1Model(getProgram(), decodeAddress(baseModelAddress), DEFAULT_OPTIONS);
		}
		return null;
	}

	@Override
	public Rtti2Model getBaseClassArray() {
		Rtti3Model model = getHierarchyDescriptor();
		if (model != null) {
			try {
				return model.getRtti2Model();
			} catch (InvalidDataTypeException e) {
				throw new AssertException(e);
			}
		}
		return null;
	}

	@Override
	public Rtti3Model getHierarchyDescriptor() {
		if (hierarchyDescriptorAddress != INVALID_KEY) {
			Address rtti3Address = decodeAddress(hierarchyDescriptorAddress);
			return new Rtti3Model(getProgram(), rtti3Address, DEFAULT_OPTIONS);
		}
		return null;
	}

	public static int getBaseCount(ClassTypeInfoRecord record) {
		ByteBuffer buf = ByteBuffer.wrap(getClassData(record));
		return ClassTypeInfoRecord.getLongArray(buf).length;
	}

	public static void updateRecord(ClassTypeInfoRecord record, LongIntHashtable keyMap) {
		ByteBuffer buf = ByteBuffer.wrap(getClassData(record));
		long[] baseKeys = ClassTypeInfoRecord.getLongArray(buf);
		int[] baseOffsets = ClassTypeInfoRecord.getIntArray(buf);
		long baseModelAddress = buf.getLong();
		long hierarchyDescriptorAddress = buf.getLong();
		updateKeys(baseKeys, keyMap);
		buf = ByteBuffer.allocate(buf.array().length);
		ClassTypeInfoRecord.setLongArray(buf, baseKeys);
		ClassTypeInfoRecord.setIntArray(buf, baseOffsets);
		buf.putLong(baseModelAddress);
		buf.putLong(hierarchyDescriptorAddress);
		record.setBinaryData(MODEL_DATA, buf.array());
	}

	@Override
	protected long[] getBaseKeys() {
		return baseKeys;
	}

	@Override
	protected int[] getOffsets() {
		return baseOffsets;
	}

	@Override
	protected boolean refresh(ClassTypeInfoRecord record) {
		if (super.refresh(record)) {
			fillModelData(record);
			return true;
		}
		return false;
	}

	@Override
	public Namespace getNamespace() {
		return gc;
	}

	private void invalidError(InvalidDataTypeException e) {
		throw new AssertException(
			"Ghidra-Cpp-Class-Analyzer: previously validated data is no longer valid?", e);
	}

	@Override
	protected String getPureVirtualFunctionName() {
		return VsVtableModel.PURE_VIRTUAL_FUNCTION_NAME;
	}

	private TypeDescriptorModel getTypeDescriptorModel() {
		return new TypeDescriptorModel(getProgram(), getAddress(), DEFAULT_OPTIONS);
	}

	@Override
	protected VsCppClassBuilder getClassBuilder() {
		return new VsCppClassBuilder(this);
	}

	@Override
	protected void fillModelData(ClassTypeInfoRecord record) {
		byte[] data = getClassData(record);
		if (data != null) {
			ByteBuffer buf = ByteBuffer.wrap(data);
			this.baseKeys = ClassTypeInfoRecord.getLongArray(buf);
			this.baseOffsets = ClassTypeInfoRecord.getIntArray(buf);
			this.baseModelAddress = buf.getLong();
			this.hierarchyDescriptorAddress = buf.getLong();
		} else {
			fillModelData(getRawType(), record);
		}
	}

	@Override
	public TypeDescriptorModel getTypeDescriptor() {
		return new TypeDescriptorModel(getProgram(), getAddress(), DEFAULT_OPTIONS);
	}

	@Override
	protected void fillModelData(ClassTypeInfo type, ClassTypeInfoRecord record) {
		VsClassTypeInfo vsType = (VsClassTypeInfo) type;
		List<Map.Entry<ClassTypeInfo, Integer>> baseEntries =
			new ArrayList<>(
				vsType.getBaseOffsets()
				.entrySet()
			);
		baseKeys = new long[baseEntries.size()];
		baseOffsets = new int[baseEntries.size()];
		for (int i = 0; i < baseKeys.length; i++) {
			Map.Entry<ClassTypeInfo, Integer> entry = baseEntries.get(i);
			baseKeys[i] = manager.resolve(entry.getKey()).getKey();
			baseOffsets[i] = entry.getValue();
		}
		Rtti1Model base = vsType.getBaseModel();
		baseModelAddress = base != null ? encodeAddress(base.getAddress()) : INVALID_KEY;
		Rtti3Model model = vsType.getHierarchyDescriptor();
		hierarchyDescriptorAddress = model != null
			? encodeAddress(model.getAddress()) : INVALID_KEY;
		fillRecord(record);
	}
}

```

`src/main/java/cppclassanalyzer/data/vtable/AbstractVtableDB.java`:

```java
package cppclassanalyzer.data.vtable;

import static cppclassanalyzer.database.schema.fields.VtableSchemaFields.*;

import java.nio.ByteBuffer;
import java.util.Arrays;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.VtableModel;
import ghidra.program.database.DatabaseObject;
import cppclassanalyzer.data.manager.ClassTypeInfoManagerDB;
import cppclassanalyzer.data.manager.recordmanagers.ProgramRttiRecordManager;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidra.util.exception.AssertException;

import cppclassanalyzer.database.record.VtableRecord;

public abstract class AbstractVtableDB extends DatabaseObject implements Vtable {

	public static final String VTABLE_TABLE_NAME = "Vtable Table";

	protected final ProgramRttiRecordManager manager;

	AbstractVtableDB(ProgramRttiRecordManager worker, VtableRecord record) {
		super(worker.getVtableCache(), record.getKey());
		this.manager = worker;
	}

	AbstractVtableDB(ProgramRttiRecordManager worker, Vtable vtable,
			VtableRecord record) {
		super(worker.getVtableCache(), record.getKey());
		this.manager = worker;
		long classKey = getManager().getTypeKey(vtable.getTypeInfo().getAddress());
		Address address = null;
		if (vtable instanceof VtableModel) {
			address = ((VtableModel) vtable).getAddress();
		} else {
			address = vtable.getTableAddresses()[0];
		}
		record.setLongValue(ADDRESS, getManager().encodeAddress(address));
		record.setLongValue(CLASS, classKey);
		manager.updateRecord(record);
	}

	AbstractVtableDB(ProgramRttiRecordManager worker, ArchivedGnuVtable vtable,
			VtableRecord record) {
		this(worker, record);
	}

	protected final ClassTypeInfoManagerDB getManager() {
		return (ClassTypeInfoManagerDB) manager.getManager();
	}

	public void setClassKey(long key) {
		VtableRecord record = getRecord();
		record.setLongValue(CLASS, key);
		manager.updateRecord(record);
	}

	public Address getAddress() {
		VtableRecord record = getRecord();
		return getManager().decodeAddress(record.getLongValue(ADDRESS));
	}

	public Program getProgram() {
		return getManager().getProgram();
	}

	protected VtableRecord getRecord() {
		VtableRecord record = manager.getVtableRecord(getKey());
		if (record == null) {
			throw new AssertException("Ghidra-Cpp-Class-Analyzer: vtable record no longer exists");
		}
		return record;
	}

	protected byte[] getModelData(VtableRecord record) {
		byte[] data = getRecord().getBinaryData(RECORDS);
		if (data == null) {
			String msg = "Vftable record data for "+getTypeInfo(record).getFullName()+" was null";
			Msg.warn(this, msg);
			ByteBuffer buf = ByteBuffer.allocate(Integer.BYTES);
			buf.putInt(0);
			data = buf.array();
			record.setBinaryData(RECORDS, data);
			manager.updateRecord(record);
		}
		return data;
	}

	@Override
	public ClassTypeInfo getTypeInfo() {
		return getTypeInfo(getRecord());
	}

	private ClassTypeInfo getTypeInfo(VtableRecord record) {
		return manager.getType(record.getLongValue(CLASS));
	}

	@Override
	public boolean containsFunction(Function function) {
		return Arrays.stream(getFunctionTables()).flatMap((a) -> Arrays.stream(a))
			.filter(function::equals)
			.findAny()
			.isPresent();
	}

	@Override
	protected boolean refresh() {
		return getManager().containsRecord(this);
	}
}

```

`src/main/java/cppclassanalyzer/data/vtable/ArchivedGnuVtable.java`:

```java
package cppclassanalyzer.data.vtable;

import static cppclassanalyzer.database.schema.fields.ArchivedGnuVtableSchemaFields.*;

import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Optional;
import java.util.function.Supplier;
import java.util.stream.Stream;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.GnuVtable.VtablePrefix;
import ghidra.app.cmd.data.rtti.gcc.VtableUtils;
import ghidra.program.database.DatabaseObject;

import cppclassanalyzer.data.manager.recordmanagers.ArchiveRttiRecordManager;
import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataTypeConflictHandler;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.FunctionDefinition;
import ghidra.program.model.data.FunctionDefinitionDataType;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionSignature;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.util.UniversalID;

import cppclassanalyzer.database.record.ArchivedGnuVtableRecord;

public class ArchivedGnuVtable extends DatabaseObject implements ArchivedVtable {

	private static final UniversalID BAD_ID = new UniversalID(-1);
	public static final String TABLE_NAME = "Vtable Archive Table";

	private final ArchiveRttiRecordManager manager;
	private final long address;
	private final ArchivedClassTypeInfo type;
	private final String symbolName;
	private final ArchivedVtablePrefix[] prefixes;

	public ArchivedGnuVtable(ArchiveRttiRecordManager worker, GnuVtable vtable,
			ArchivedGnuVtableRecord record) {
		super(worker.getVtableCache(), record.getKey());
		this.manager = worker;
		this.symbolName = VtableUtils.getSymbolName(vtable);
		Program program = VtableUtils.getProgram(vtable);
		this.address = program.getAddressMap().getKey(vtable.getAddress(), true);
		this.type = (ArchivedClassTypeInfo) manager.getManager().resolve(vtable.getTypeInfo());
		this.prefixes = vtable.getPrefixes()
			.stream()
			.map(ArchivedVtablePrefix::new)
			.toArray(ArchivedVtablePrefix[]::new);
		record.setLongValue(ADDRESS, address);
		record.setStringValue(MANGLED_SYMBOL, symbolName);
		record.setLongValue(TYPE_KEY, type.getKey());
		record.setBinaryData(DATA, getVtableData());
		manager.updateRecord(record);
	}

	public ArchivedGnuVtable(ArchiveRttiRecordManager worker, ArchivedGnuVtableRecord record) {
		super(worker.getVtableCache(), record.getKey());
		this.manager = worker;
		this.address = record.getLongValue(ADDRESS);
		this.symbolName = record.getStringValue(MANGLED_SYMBOL);
		this.type = manager.getType(record.getLongValue(TYPE_KEY));
		byte[] data = record.getBinaryData(DATA);
		this.prefixes = getArray(data);
	}

	@Override
	protected boolean refresh() {
		return false;
	}

	@Override
	public ClassTypeInfo getTypeInfo() {
		return type;
	}

	@Override
	public FunctionDefinition[][] getFunctionDefinitions() {
		return Arrays.stream(prefixes)
			.map(ArchivedVtablePrefix::getDefinitions)
			.toArray(FunctionDefinition[][]::new);
	}

	public Address getAddress(Program program) {
		return program.getAddressMap().decodeAddress(address);
	}

	public static Function getFunction(Program program, FunctionDefinition def) {
		SymbolTable table = program.getSymbolTable();
		String name = def.getName();
		Symbol s = table.getExternalSymbol(name);
		if (s != null && s.getObject() instanceof Function) {
			return (Function) s.getObject();
		}
		throw new IllegalArgumentException(
			def.getPrototypeString()+" does not exist in "+program.getName());
	}

	static Function[] getFunctions(Program program, ArchivedVtablePrefix prefix) {
		return Arrays.stream(prefix.getDefinitions())
			.map(f -> getFunction(program, f))
			.toArray(Function[]::new);
	}

	public String getSymbolName() {
		return symbolName;
	}

	private ArchivedVtablePrefix[] getArray(byte[] data) {
		ByteBuffer buf = ByteBuffer.wrap(data);
		PrefixGenerator generator = new PrefixGenerator(buf);
		return Stream.generate(generator)
			.limit(generator.size)
			.toArray(ArchivedVtablePrefix[]::new);
	}

	private byte[] getVtableData() {
		int size = Arrays.stream(prefixes)
			.mapToInt(ArchivedVtablePrefix::getSize)
			.sum() + Integer.BYTES;
		ByteBuffer buf = ByteBuffer.allocate(size);
		buf.putInt(prefixes.length);
		for (ArchivedVtablePrefix prefix : prefixes) {
			buf.put(prefix.toBytes());
		}
		return buf.array();
	}

	ArchivedVtablePrefix[] getPrefixes() {
		return prefixes;
	}

	class ArchivedVtablePrefix {

		final long[] offsets;
		final long[] functions;

		ArchivedVtablePrefix(VtablePrefix prefix) {
			this.offsets = prefix.getOffsets()
				.stream()
				.mapToLong(Long::longValue)
				.toArray();
			this.functions = prefix.getFunctionTable()
				.stream()
				.map(Optional::ofNullable)
				.map(this::getFunctionId)
				.mapToLong(UniversalID::getValue)
				.toArray();
		}

		ArchivedVtablePrefix(ByteBuffer buf) {
			this.offsets = ArchivedGnuVtableRecord.getLongArray(buf);
			this.functions = ArchivedGnuVtableRecord.getLongArray(buf);
		}

		private UniversalID getFunctionId(Optional<Function> fun) {
			return fun.map(Function::getSignature)
			.map(this::resolve)
			.map(FunctionDefinition::getUniversalID)
			.orElse(BAD_ID);
		}

		private FunctionDefinition resolve(FunctionSignature sig) {
			DataTypeManager dtm = manager.getDataTypeManager();
			FunctionDefinition def = new FunctionDefinitionDataType(sig, dtm);
			return (FunctionDefinition) dtm.resolve(def, DataTypeConflictHandler.KEEP_HANDLER);
		}

		int getSize() {
			return Integer.BYTES * 2
				+ Long.BYTES * offsets.length
				+ Long.BYTES * functions.length;
		}

		byte[] toBytes() {
			ByteBuffer buf = ByteBuffer.allocate(getSize());
			ArchivedGnuVtableRecord.setLongArray(buf, offsets);
			ArchivedGnuVtableRecord.setLongArray(buf, functions);
			return buf.array();
		}

		FunctionDefinition[] getDefinitions() {
			DataTypeManager dtm = manager.getDataTypeManager();
			return Arrays.stream(functions)
				.mapToObj(UniversalID::new)
				.map(dtm::findDataTypeForID)
				.map(FunctionDefinition.class::cast)
				.toArray(FunctionDefinition[]::new);
		}
	}

	private class PrefixGenerator implements Supplier<ArchivedVtablePrefix> {

		private final int size;
		private final ByteBuffer buf;

		PrefixGenerator(ByteBuffer buf) {
			this.size = buf.getInt();
			this.buf = buf;
		}

		@Override
		public ArchivedVtablePrefix get() {
			return new ArchivedVtablePrefix(buf);
		}

	}
}

```

`src/main/java/cppclassanalyzer/data/vtable/ArchivedVtable.java`:

```java
package cppclassanalyzer.data.vtable;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.program.model.data.FunctionDefinition;

import cppclassanalyzer.data.ArchivedRttiData;

public interface ArchivedVtable extends ArchivedRttiData {
	
	/**
	 * Returns the TypeInfo Model this vtable points to
	 * @return the pointed to TypeInfo Model
	 */
	public ClassTypeInfo getTypeInfo();
	
	public FunctionDefinition[][] getFunctionDefinitions();
}
```

`src/main/java/cppclassanalyzer/data/vtable/VftableDB.java`:

```java
package cppclassanalyzer.data.vtable;

import static cppclassanalyzer.database.schema.fields.VtableSchemaFields.*;

import java.nio.ByteBuffer;
import java.util.Arrays;

import cppclassanalyzer.data.manager.ClassTypeInfoManagerDB;
import cppclassanalyzer.data.manager.recordmanagers.ProgramRttiRecordManager;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Listing;
import ghidra.util.Msg;

import cppclassanalyzer.database.record.VtableRecord;
import cppclassanalyzer.database.record.DatabaseRecord.ByteConvertable;
import cppclassanalyzer.vs.VsVtableModel;

public class VftableDB extends AbstractVtableDB {

	private final VftableRecord[] records;

	public VftableDB(ProgramRttiRecordManager worker, VtableRecord record) {
		super(worker, record);
		ByteBuffer buf = ByteBuffer.wrap(getModelData(record));
		this.records = new VftableRecord[buf.getInt()];
		for (int i = 0; i < records.length; i++) {
			records[i] = new VftableRecord(buf);
		}
	}

	public VftableDB(ProgramRttiRecordManager worker, VsVtableModel vtable, VtableRecord record) {
		super(worker, vtable, record);
		Address[] addresses = vtable.getTableAddresses();
		Function[][] functions = vtable.getFunctionTables();
		this.records = new VftableRecord[addresses.length];
		for (int i = 0; i < records.length; i++) {
			records[i] = new VftableRecord(addresses[i], functions[i]);
		}
		int size = Arrays.stream(records)
			.mapToInt(VftableRecord::getSize)
			.sum();
		ByteBuffer buf = ByteBuffer.allocate(size + Integer.BYTES);
		VtableRecord.putObjectArray(buf, records);
		record.setBinaryData(RECORDS, buf.array());
		manager.updateRecord(record);
	}

	@Override
	public Address[] getTableAddresses() {
		return Arrays.stream(records)
			 .map(VftableRecord::getAddress)
			 .toArray(Address[]::new);
	}

	@Override
	public Function[][] getFunctionTables() {
		return Arrays.stream(records)
					 .map(VftableRecord::getFunctions)
					 .toArray(Function[][]::new);
	}

	private class VftableRecord implements ByteConvertable {

		private final long address;
		private final long[] functions;

		VftableRecord(ByteBuffer buf) {
			this.address = buf.getLong();
			this.functions = VtableRecord.getLongArray(buf);
		}

		VftableRecord(Address address, Function[] functions) {
			ClassTypeInfoManagerDB typeManager = getManager();
			this.address = typeManager.encodeAddress(address);
			long[] fKeys = null;
			try {
				fKeys = Arrays.stream(functions)
				   .map(Function::getEntryPoint)
				   .mapToLong(typeManager::encodeAddress)
				   .toArray();
			} catch (NullPointerException e) {
				Msg.error(this, e);
			}
			this.functions = fKeys;
		}

		public int getSize() {
			return Long.BYTES
				+ Integer.BYTES
				+ Long.BYTES * functions.length;
		}

		@Override
		public byte[] toBytes() {
			ByteBuffer buf = ByteBuffer.allocate(getSize());
			buf.putLong(address);
			VtableRecord.setLongArray(buf, functions);
			return buf.array();
		}

		Address getAddress() {
			return getManager().decodeAddress(address);
		}

		Function[] getFunctions() {
			ClassTypeInfoManagerDB typeManager = getManager();
			Listing listing = getProgram().getListing();
			return Arrays.stream(functions)
						 .mapToObj(typeManager::decodeAddress)
						 .map(listing::getFunctionAt)
						 .toArray(Function[]::new);
		}
	}

}

```

`src/main/java/cppclassanalyzer/data/vtable/VtableModelDB.java`:

```java
package cppclassanalyzer.data.vtable;

import static cppclassanalyzer.database.schema.fields.VtableSchemaFields.*;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.gcc.GnuUtils;
import cppclassanalyzer.data.manager.ClassTypeInfoManagerDB;
import cppclassanalyzer.data.manager.recordmanagers.ProgramRttiRecordManager;
import cppclassanalyzer.data.vtable.ArchivedGnuVtable.ArchivedVtablePrefix;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.ArrayDataType;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;

import com.google.common.primitives.Longs;

import cppclassanalyzer.database.record.VtableRecord;
import cppclassanalyzer.database.record.DatabaseRecord.ByteConvertable;

public final class VtableModelDB extends AbstractVtableDB implements GnuVtable {

	private final VtableModelPrefixRecord[] records;

	public VtableModelDB(ProgramRttiRecordManager worker, VtableRecord record) {
		super(worker, record);
		ByteBuffer buf = ByteBuffer.wrap(getModelData(record));
		this.records = new VtableModelPrefixRecord[buf.getInt()];
		for (int i = 0; i < records.length; i++) {
			records[i] = new VtableModelPrefixRecord(buf);
		}
	}

	public VtableModelDB(ProgramRttiRecordManager worker, GnuVtable vtable, VtableRecord record) {
		super(worker, vtable, record);
		this.records = vtable.getPrefixes().stream()
			.map(VtableModelPrefixRecord::new)
			.toArray(VtableModelPrefixRecord[]::new);
		int size = Arrays.stream(records)
				.mapToInt(VtableModelPrefixRecord::getSize)
				.sum();
		ByteBuffer buf = ByteBuffer.allocate(size + Integer.BYTES);
		VtableRecord.putObjectArray(buf, records);
		record.setBinaryData(RECORDS, buf.array());
		manager.updateRecord(record);
	}

	public VtableModelDB(ProgramRttiRecordManager worker, ArchivedGnuVtable vtable,
			VtableRecord record) {
		super(worker, vtable, record);
		Program program = getProgram();
		Address address = vtable.getAddress(program);
		ArchivedVtablePrefix[] prefixes = vtable.getPrefixes();
		this.records = new VtableModelPrefixRecord[prefixes.length];
		for (int i = 0; i < records.length; i++) {
			ArchivedVtablePrefix prefix = prefixes[i];
			Function[] functions = ArchivedGnuVtable.getFunctions(program, prefix);
			records[i] = new VtableModelPrefixRecord(address, functions, prefix.offsets);
			address = address.add(records[i].getLength());
		}
	}

	@Override
	public long getOffset(int index, int ordinal) {
		return records[index].offsets[ordinal];
	}

	@Override
	public Address[] getTableAddresses() {
		Program program = getProgram();
		int pointerSize = program.getDefaultPointerSize();
		int ptrdiffSize = GnuUtils.getPtrDiffSize(program.getDataTypeManager());
		Address[] addresses = new Address[records.length];
		for (int i = 0; i < records.length; i++) {
			VtableModelPrefixRecord record = records[i];
			int offset = pointerSize + ptrdiffSize * record.offsets.length;
			addresses[i] = record.getAddress().add(offset);
		}
		return addresses;
	}

	@Override
	public Function[][] getFunctionTables() {
		return Arrays.stream(records)
				.map(VtableModelPrefixRecord::getFunctions)
				.toArray(Function[][]::new);
	}

	@Override
	public List<DataType> getDataTypes() {
		// 3 datatypes per prefix
		List<DataType> types = new ArrayList<>(3 * records.length);
		DataTypeManager dtm = getProgram().getDataTypeManager();
		DataType tiPointer = new PointerDataType(null, -1, dtm);
		DataType ptrdiff_t = GnuUtils.getPtrDiff_t(dtm);
		for (VtableModelPrefixRecord record : records) {
			DataType offsets =
				new ArrayDataType(ptrdiff_t, record.offsets.length, ptrdiff_t.getLength(), dtm);
			types.add(offsets);
			types.add(tiPointer);
			if (record.functions.length > 0) {
				DataType functions =
					new ArrayDataType(PointerDataType.dataType, record.functions.length, -1, dtm);
				types.add(functions);
			}
		}
		return types;
	}

	@Override
	public List<VtablePrefix> getPrefixes() {
		return List.of(records);
	}

	class VtableModelPrefixRecord implements VtablePrefix, ByteConvertable {
		private final long address;
		private final long[] offsets;
		private final long[] functions;

		VtableModelPrefixRecord(ByteBuffer buf) {
			this.address = buf.getLong();
			this.offsets = VtableRecord.getLongArray(buf);
			this.functions = VtableRecord.getLongArray(buf);

		}

		VtableModelPrefixRecord(VtablePrefix prefix) {
			ClassTypeInfoManagerDB typeManager = getManager();
			this.address = typeManager.encodeAddress(prefix.getAddress());
			this.offsets = Longs.toArray(prefix.getOffsets());
			this.functions = prefix.getFunctionTable()
				.stream()
				.map(f -> {return f != null ? f.getEntryPoint() : Address.NO_ADDRESS;})
				.mapToLong(typeManager::encodeAddress)
				.toArray();
		}

		VtableModelPrefixRecord(Address address, Function[] functions, long[] offsets) {
			ClassTypeInfoManagerDB typeManager = getManager();
			this.address = typeManager.encodeAddress(address);
			this.offsets = offsets;
			this.functions = Arrays.stream(functions)
				.map(Function::getEntryPoint)
				.mapToLong(typeManager::encodeAddress)
				.toArray();
		}

		int getLength() {
			Program program = getProgram();
			DataType ptrdiff_t = GnuUtils.getPtrDiff_t(program.getDataTypeManager());
			return ptrdiff_t.getLength() * offsets.length
				+ program.getDefaultPointerSize() * (1 + functions.length);
		}

		int getSize() {
			return Long.BYTES + Integer.BYTES * 2 + offsets.length * Long.BYTES +
				functions.length * Long.BYTES;
		}

		@Override
		public byte[] toBytes() {
			ByteBuffer buf = ByteBuffer.allocate(getSize());
			buf.putLong(address);
			VtableRecord.setLongArray(buf, offsets);
			VtableRecord.setLongArray(buf, functions);
			return buf.array();
		}

		@Override
		public Address getAddress() {
			return getManager().decodeAddress(address);
		}

		private Function[] getFunctions() {
			ClassTypeInfoManagerDB typeManager = getManager();
			Listing listing = getProgram().getListing();
			return Arrays.stream(functions)
				.mapToObj(typeManager::decodeAddress)
				.map(listing::getFunctionContaining)
				.toArray(Function[]::new);
		}

		@Override
		public List<Long> getOffsets() {
			return Arrays.stream(offsets)
				.boxed()
				.collect(Collectors.toUnmodifiableList());
		}

		@Override
		public List<Function> getFunctionTable() {
			// the array is regenerated each time. not required to be immutable
			return Arrays.asList(getFunctions());
		}

		@Override
		public List<DataType> getDataTypes() {
			DataTypeManager dtm = getProgram().getDataTypeManager();
			DataType ptrDiff = GnuUtils.getPtrDiff_t(dtm);
			List<DataType> result = new ArrayList<>(3);
			result.add(new ArrayDataType(ptrDiff, offsets.length, ptrDiff.getLength(), dtm));
			result.add(new PointerDataType(null, -1, dtm));
			result.add(new ArrayDataType(
				PointerDataType.dataType, functions.length, -1, dtm));
			return result;
		}
	}

}

```

`src/main/java/cppclassanalyzer/database/SchemaMismatchException.java`:

```java
package cppclassanalyzer.database;

import cppclassanalyzer.database.tables.DatabaseTable;

public final class SchemaMismatchException extends RuntimeException {

	private static final long serialVersionUID = 0L;

	public SchemaMismatchException(Class<? extends DatabaseTable<?>> clazz) {
		super(generateMessage(clazz));
	}

	private static String generateMessage(Class<? extends DatabaseTable<?>> clazz) {
		return "The Schema for the " + clazz.getSimpleName() + " has been changed.\n"
		+"Please run the ResetDatabaseScript with the plugin disabled.";
	}
}

```

`src/main/java/cppclassanalyzer/database/record/AbstractDatabaseRecord.java`:

```java
package cppclassanalyzer.database.record;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.stream.IntStream;
import java.util.stream.LongStream;

import cppclassanalyzer.database.schema.fields.FieldEnum;
import db.*;

abstract class AbstractDatabaseRecord<T extends FieldEnum> implements DatabaseRecord<T> {

	private final DBRecord record;

	AbstractDatabaseRecord(Field key, Table table) {
		this.record = getSchema().createRecord(key);
	}

	AbstractDatabaseRecord(Table table) {
		long key = table.getKey();
		this.record = getSchema().createRecord(key);
	}

	AbstractDatabaseRecord(DBRecord record) {
		this.record = record;
	}

	private ByteBuffer getBuffer(T type) {
		byte[] data = record.getBinaryData(type.getIndex());
		if (data == null) {
			data = new byte[Integer.BYTES];
		}
		return ByteBuffer.wrap(data);
	}

	public static int getArraySize(int[] data) {
		return Integer.BYTES + Integer.BYTES * data.length;
	}

	public static int getArraySize(long[] data) {
		return Integer.BYTES + Long.BYTES * data.length;
	}

	public static int[] getIntArray(ByteBuffer buf) {
		int size = buf.getInt();
		return IntStream.generate(buf::getInt)
			.limit(size)
			.toArray();
	}

	public static long[] getLongArray(ByteBuffer buf) {
		int size = buf.getInt();
		return LongStream.generate(buf::getLong)
				.limit(size)
				.toArray();
	}

	public static void setIntArray(ByteBuffer buf, int[] values) {
		buf.putInt(values.length);
		for (int value : values) {
			buf.putInt(value);
		}
	}

	public static void setLongArray(ByteBuffer buf, long[] values) {
		buf.putInt(values.length);
		for (long value : values) {
			buf.putLong(value);
		}
	}

	public static void putObjectArray(ByteBuffer buf, ByteConvertable[] obj) {
		byte[][] data = Arrays.stream(obj)
			.map(ByteConvertable::toBytes)
			.toArray(byte[][]::new);
		buf.putInt(data.length);
		for (byte[] bytes : data) {
			buf.put(bytes);
		}
	}

	@Override
	public final synchronized byte[] getBinaryData(T type) {
		return record.getBinaryData(type.getIndex());
	}

	@Override
	public final synchronized boolean getBooleanValue(T type) {
		return record.getBooleanValue(type.getIndex());
	}

	@Override
	public final synchronized byte getByteValue(T type) {
		return record.getByteValue(type.getIndex());
	}

	@Override
	public final synchronized int getColumnCount() {
		return record.getColumnCount();
	}

	@Override
	public final synchronized Field getFieldValue(T type) {
		return record.getFieldValue(type.getIndex());
	}

	@Override
	public final synchronized int getIntValue(T type) {
		return record.getIntValue(type.getIndex());
	}

	@Override
	public final synchronized long getKey() {
		return record.getKey();
	}

	@Override
	public final synchronized Field getKeyField() {
		return record.getKeyField();
	}

	@Override
	public final synchronized long getLongValue(T type) {
		return record.getLongValue(type.getIndex());
	}

	@Override
	public final synchronized short getShortValue(T type) {
		return record.getShortValue(type.getIndex());
	}

	@Override
	public final synchronized String getStringValue(T type) {
		return record.getString(type.getIndex());
	}

	@Override
	public final synchronized long[] getLongArray(T type) {
		ByteBuffer buf = getBuffer(type);
		return getLongArray(buf);
	}

	@Override
	public final synchronized int[] getIntArray(T type) {
		ByteBuffer buf = getBuffer(type);
		return getIntArray(buf);
	}

	@Override
	public final synchronized int hashCode() {
		return record.hashCode();
	}

	@Override
	public final synchronized boolean hasSameSchema(DBRecord other) {
		return other.hasSameSchema(getSchema());
	}

	@Override
	public final synchronized boolean hasSameSchema(Schema schema) {
		return record.hasSameSchema(schema);
	}

	@Override
	public final synchronized boolean isDirty() {
		return record.isDirty();
	}

	@Override
	public final synchronized int length() {
		return record.length();
	}

	@Override
	public final synchronized void read(Buffer buf, int offset) throws IOException {
		record.read(buf, offset);
	}

	@Override
	public final synchronized void setBinaryData(T type, byte[] bytes) {
		record.setBinaryData(type.getIndex(), bytes);
	}

	@Override
	public final synchronized void setBooleanValue(T type, boolean value) {
		record.setBooleanValue(type.getIndex(), value);
	}

	@Override
	public final synchronized void setByteValue(T type, byte value) {
		record.setByteValue(type.getIndex(), value);
	}

	@Override
	public final synchronized void setFieldValue(T type, Field field) {
		record.setField(type.getIndex(), field);
	}

	@Override
	public final synchronized void setIntValue(T type, int value) {
		record.setIntValue(type.getIndex(), value);
	}

	@Override
	public final synchronized void setKey(long key) {
		record.setKey(key);
	}

	@Override
	public final synchronized void setKey(Field key) {
		record.setKey(key);
	}

	@Override
	public final synchronized void setLongValue(T type, long value) {
		record.setLongValue(type.getIndex(), value);
	}

	@Override
	public final synchronized void setShortValue(T type, short value) {
		record.setShortValue(type.getIndex(), value);
	}

	@Override
	public final synchronized void setStringValue(T type, String value) {
		record.setString(type.getIndex(), value);
	}

	@Override
	public final synchronized void setLongArray(T type, long[] values) {
		ByteBuffer buf = ByteBuffer.allocate(Integer.BYTES + Long.BYTES * values.length);
		setLongArray(buf, values);
		record.setBinaryData(type.getIndex(), buf.array());
	}

	@Override
	public final synchronized void setIntArray(T type, int[] values) {
		ByteBuffer buf = ByteBuffer.allocate(Integer.BYTES + Integer.BYTES * values.length);
		setIntArray(buf, values);
		record.setBinaryData(type.getIndex(), buf.array());
	}

	@Override
	public final synchronized void write(Buffer buf, int offset) throws IOException {
		record.write(buf, offset);
	}

	@Override
	public final DBRecord getRecord() {
		return record;
	}
}

```

`src/main/java/cppclassanalyzer/database/record/ArchivedClassTypeInfoRecord.java`:

```java
package cppclassanalyzer.database.record;

import cppclassanalyzer.database.schema.ArchivedClassTypeInfoSchema;
import cppclassanalyzer.database.schema.fields.ArchivedClassTypeInfoSchemaFields;
import db.*;

public final class ArchivedClassTypeInfoRecord
		extends AbstractDatabaseRecord<ArchivedClassTypeInfoSchemaFields> {

	public ArchivedClassTypeInfoRecord(Field key, Table table) {
		super(key, table);
	}

	public ArchivedClassTypeInfoRecord(Table table) {
		super(table);
	}

	public ArchivedClassTypeInfoRecord(DBRecord record) {
		super(record);
	}

	@Override
	public Schema getSchema() {
		return ArchivedClassTypeInfoSchema.SCHEMA;
	}

	@Override
	public ArchivedClassTypeInfoRecord copy() {
		return new ArchivedClassTypeInfoRecord(getRecord().copy());
	}

}

```

`src/main/java/cppclassanalyzer/database/record/ArchivedGnuVtableRecord.java`:

```java
package cppclassanalyzer.database.record;

import cppclassanalyzer.database.schema.ArchivedGnuVtableSchema;
import cppclassanalyzer.database.schema.fields.ArchivedGnuVtableSchemaFields;
import db.*;

public final class ArchivedGnuVtableRecord extends AbstractDatabaseRecord<ArchivedGnuVtableSchemaFields> {

	public ArchivedGnuVtableRecord(Field key, Table table) {
		super(key, table);
	}

	public ArchivedGnuVtableRecord(Table table) {
		super(table);
	}

	public ArchivedGnuVtableRecord(DBRecord record) {
		super(record);
	}

	@Override
	public Schema getSchema() {
		return ArchivedGnuVtableSchema.SCHEMA;
	}

	@Override
	public ArchivedGnuVtableRecord copy() {
		return new ArchivedGnuVtableRecord(getRecord().copy());
	}

}

```

`src/main/java/cppclassanalyzer/database/record/ClassTypeInfoRecord.java`:

```java
package cppclassanalyzer.database.record;

import cppclassanalyzer.database.schema.ClassTypeInfoSchema;
import cppclassanalyzer.database.schema.fields.ClassTypeInfoSchemaFields;
import db.*;

public final class ClassTypeInfoRecord extends AbstractDatabaseRecord<ClassTypeInfoSchemaFields> {

	public ClassTypeInfoRecord(DBRecord record) {
		super(record);
	}

	@Override
	public Schema getSchema() {
		return ClassTypeInfoSchema.SCHEMA;
	}

	@Override
	public ClassTypeInfoRecord copy() {
		return new ClassTypeInfoRecord(getRecord().copy());
	}

}

```

`src/main/java/cppclassanalyzer/database/record/DatabaseRecord.java`:

```java
package cppclassanalyzer.database.record;

import java.io.IOException;

import db.*;
import cppclassanalyzer.database.schema.fields.FieldEnum;

public interface DatabaseRecord<T extends FieldEnum> {
	Schema getSchema();

	DatabaseRecord<T> copy();

	byte[] getBinaryData(T type);

	boolean getBooleanValue(T type);

	byte getByteValue(T type);

	int getColumnCount();

	Field getFieldValue(T type);

	int getIntValue(T type);

	long getKey();

	Field getKeyField();

	long getLongValue(T type);

	short getShortValue(T type);

	String getStringValue(T type);

	long[] getLongArray(T type);

	int[] getIntArray(T type);

	boolean hasSameSchema(DBRecord other);

	boolean hasSameSchema(Schema schema);

	boolean isDirty();

	int length();

	void read(Buffer buf, int offset) throws IOException;

	void setBinaryData(T type, byte[] bytes);

	void setBooleanValue(T type, boolean value);

	void setByteValue(T type, byte value);

	void setFieldValue(T type, Field field);

	void setIntValue(T type, int value);

	void setLongValue(T type, long value);

	void setShortValue(T type, short value);

	void setStringValue(T type, String value);

	void setLongArray(T type, long[] values);

	void setIntArray(T type, int[] values);

	void setKey(long key);

	void setKey(Field key);

	void write(Buffer buf, int offset) throws IOException;

	DBRecord getRecord();

	public interface ByteConvertable {
		byte[] toBytes();
	}
}

```

`src/main/java/cppclassanalyzer/database/record/SchemaRecordIterator.java`:

```java
package cppclassanalyzer.database.record;

import java.io.IOException;
import java.util.function.Function;

import cppclassanalyzer.database.schema.fields.FieldEnum;

import db.*;

public class SchemaRecordIterator<T extends DatabaseRecord<? extends FieldEnum>>  {

	private final RecordIterator iter;
	private final Function<DBRecord, T> constructor;

	public SchemaRecordIterator(RecordIterator iter, Function<DBRecord, T> constructor) {
		this.iter = iter;
		this.constructor = constructor;
	}

	public boolean hasNext() throws IOException {
		return iter.hasNext();
	}

	public boolean hasPrevious() throws IOException {
		return iter.hasPrevious();
	}

	public T next() throws IOException {
		return constructor.apply(iter.next());
	}

	public T previous() throws IOException {
		return constructor.apply(iter.previous());
	}

	public boolean delete() throws IOException {
		return iter.delete();
	}
}

```

`src/main/java/cppclassanalyzer/database/record/VtableRecord.java`:

```java
package cppclassanalyzer.database.record;

import cppclassanalyzer.database.schema.VtableSchema;
import cppclassanalyzer.database.schema.fields.VtableSchemaFields;
import db.*;

public final class VtableRecord extends AbstractDatabaseRecord<VtableSchemaFields> {

	public VtableRecord(Field key, Table table) {
		super(key, table);
	}

	public VtableRecord(Table table) {
		super(table);
	}

	public VtableRecord(DBRecord record) {
		super(record);
	}

	@Override
	public Schema getSchema() {
		return VtableSchema.SCHEMA;
	}

	@Override
	public VtableRecord copy() {
		return new VtableRecord(getRecord().copy());
	}

}

```

`src/main/java/cppclassanalyzer/database/schema/AbstractSchema.java`:

```java
package cppclassanalyzer.database.schema;

import cppclassanalyzer.database.record.DatabaseRecord;
import db.Field;
import db.Schema;

public abstract class AbstractSchema<T extends DatabaseRecord<?>> extends Schema
		implements DatabaseSchema<T> {

	protected AbstractSchema(int version, Class<? extends Field> keyFieldClass, String keyName,
			Class<?>[] fieldClasses, String[] fieldNames) {
		super(version, keyFieldClass, keyName, fieldClasses, fieldNames);
	}

	protected AbstractSchema(int version, String keyName, Class<?>[] fieldClasses,
			String[] fieldNames) {
		super(version, keyName, fieldClasses, fieldNames);
	}

	@Override
	public final T getNewRecord(long key) {
		return getRecord(createRecord(key));
	}

	@Override
	public final T getNewRecord(Field key) {
		return getRecord(createRecord(key));
	}
}
```

`src/main/java/cppclassanalyzer/database/schema/ArchivedClassTypeInfoSchema.java`:

```java
package cppclassanalyzer.database.schema;

import cppclassanalyzer.database.record.ArchivedClassTypeInfoRecord;
import cppclassanalyzer.database.schema.fields.ArchivedClassTypeInfoSchemaFields;
import db.DBRecord;

public final class ArchivedClassTypeInfoSchema
		extends AbstractSchema<ArchivedClassTypeInfoRecord> {

	private static final int VERSION = 0;
	public static final ArchivedClassTypeInfoSchema SCHEMA =
		new ArchivedClassTypeInfoSchema(VERSION);
	public static final int[] INDEXED_COLUMNS = new int[] {
		ArchivedClassTypeInfoSchemaFields.MANGLED_SYMBOL.ordinal(),
		ArchivedClassTypeInfoSchemaFields.DATATYPE_ID.ordinal()
	};

	private ArchivedClassTypeInfoSchema(int version) {
		super(version, "Key",
			ArchivedClassTypeInfoSchemaFields.getFields(),
			ArchivedClassTypeInfoSchemaFields.getFieldNames());
	}

	@Override
	public ArchivedClassTypeInfoRecord getRecord(DBRecord record) {
		return new ArchivedClassTypeInfoRecord(record);
	}

}

```

`src/main/java/cppclassanalyzer/database/schema/ArchivedGnuVtableSchema.java`:

```java
package cppclassanalyzer.database.schema;

import cppclassanalyzer.database.record.ArchivedGnuVtableRecord;
import cppclassanalyzer.database.schema.fields.ArchivedGnuVtableSchemaFields;
import db.DBRecord;

public final class ArchivedGnuVtableSchema extends AbstractSchema<ArchivedGnuVtableRecord> {

	private static final int VERSION = 0;
	public static final ArchivedGnuVtableSchema SCHEMA = new ArchivedGnuVtableSchema(VERSION);
	public static final int[] INDEXED_COLUMNS = new int[] {
		ArchivedGnuVtableSchemaFields.MANGLED_SYMBOL.ordinal()
	};

	private ArchivedGnuVtableSchema(int version) {
		super(version, "Key",
			ArchivedGnuVtableSchemaFields.getFields(),
			ArchivedGnuVtableSchemaFields.getFieldNames());
	}

	@Override
	public ArchivedGnuVtableRecord getRecord(DBRecord record) {
		return new ArchivedGnuVtableRecord(record);
	}

}

```

`src/main/java/cppclassanalyzer/database/schema/ClassTypeInfoSchema.java`:

```java
package cppclassanalyzer.database.schema;

import cppclassanalyzer.database.record.ClassTypeInfoRecord;
import cppclassanalyzer.database.schema.fields.ClassTypeInfoSchemaFields;
import db.DBRecord;

public final class ClassTypeInfoSchema extends AbstractSchema<ClassTypeInfoRecord> {

	private static final int VERSION = 0;
	public static final ClassTypeInfoSchema SCHEMA = new ClassTypeInfoSchema(VERSION);
	public static final int[] INDEXED_COLUMNS = new int[] {
		ClassTypeInfoSchemaFields.ADDRESS.ordinal(),
		ClassTypeInfoSchemaFields.DATATYPE_ID.ordinal()
	};

	private ClassTypeInfoSchema(int version) {
		super(version, "Key",
			ClassTypeInfoSchemaFields.getFields(),
			ClassTypeInfoSchemaFields.getFieldNames());
	}

	@Override
	public ClassTypeInfoRecord getRecord(DBRecord record) {
		return new ClassTypeInfoRecord(record);
	}

}

```

`src/main/java/cppclassanalyzer/database/schema/DatabaseSchema.java`:

```java
package cppclassanalyzer.database.schema;

import cppclassanalyzer.database.record.DatabaseRecord;
import db.*;

public interface DatabaseSchema<T extends DatabaseRecord<?>> {

	T getNewRecord(long key);
	T getNewRecord(Field key);
	T getRecord(DBRecord record);
}

```

`src/main/java/cppclassanalyzer/database/schema/VtableSchema.java`:

```java
package cppclassanalyzer.database.schema;

import cppclassanalyzer.database.record.VtableRecord;
import cppclassanalyzer.database.schema.fields.VtableSchemaFields;
import db.DBRecord;

public final class VtableSchema extends AbstractSchema<VtableRecord> {

	private static final int VERSION = 0;
	public static final VtableSchema SCHEMA = new VtableSchema(VERSION);
	public static final int[] INDEXED_COLUMNS = new int[] {
		VtableSchemaFields.ADDRESS.ordinal()
	};

	private VtableSchema(int version) {
		super(version, "Key",
			VtableSchemaFields.getFields(),
			VtableSchemaFields.getFieldNames());
	}

	@Override
	public VtableRecord getRecord(DBRecord record) {
		return new VtableRecord(record);
	}

}

```

`src/main/java/cppclassanalyzer/database/schema/fields/ArchivedClassTypeInfoSchemaFields.java`:

```java
package cppclassanalyzer.database.schema.fields;

import java.util.Arrays;

import db.*;

public enum ArchivedClassTypeInfoSchemaFields implements FieldEnum {

	/** Name of the Program the type originated from */
	PROGRAM_NAME(StringField.class),
	TYPENAME(StringField.class),
	/** Address within the external program */
	ADDRESS(LongField.class),
	MANGLED_SYMBOL(StringField.class),
	CLASS_ID(ByteField.class),
	DATATYPE_ID(LongField.class),
	SUPER_DATATYPE_ID(LongField.class),
	VTABLE_KEY(LongField.class),
	BASE_KEYS(BinaryField.class),
	NON_VIRTUAL_BASE_KEYS(BinaryField.class),
	VIRTUAL_BASE_KEYS(BinaryField.class),
	BASE_OFFSETS(BinaryField.class);

	private final Class<? extends Field> fieldClass;

	private ArchivedClassTypeInfoSchemaFields(Class<? extends Field> fieldClass) {
		this.fieldClass = fieldClass;
	}
	public static Class<?>[] getFields() {
		return Arrays.stream(values())
			.map(FieldEnum::getFieldClass)
			.toArray(Class<?>[]::new);
	}

	public static String[] getFieldNames() {
		return Arrays.stream(values())
			.map(FieldEnum::getName)
			.toArray(String[]::new);
	}


	@Override
	public String getName() {
		return name();
	}

	@Override
	public Class<? extends Field> getFieldClass() {
		return fieldClass;
	}

	@Override
	public int getIndex() {
		return ordinal();
	}

}
```

`src/main/java/cppclassanalyzer/database/schema/fields/ArchivedGnuVtableSchemaFields.java`:

```java
package cppclassanalyzer.database.schema.fields;

import java.util.Arrays;

import db.*;

public enum ArchivedGnuVtableSchemaFields implements FieldEnum {

	/** Address within the external program */
	ADDRESS(LongField.class),
	MANGLED_SYMBOL(StringField.class),
	TYPE_KEY(LongField.class),
	DATA(BinaryField.class);

	private final Class<? extends Field> fieldClass;

	private ArchivedGnuVtableSchemaFields(Class<? extends Field> fieldClass) {
		this.fieldClass = fieldClass;
	}
	public static Class<?>[] getFields() {
		return Arrays.stream(values())
			.map(FieldEnum::getFieldClass)
			.toArray(Class<?>[]::new);
	}

	public static String[] getFieldNames() {
		return Arrays.stream(values())
			.map(FieldEnum::getName)
			.toArray(String[]::new);
	}


	@Override
	public String getName() {
		return name();
	}

	@Override
	public Class<? extends Field> getFieldClass() {
		return fieldClass;
	}

	@Override
	public int getIndex() {
		return ordinal();
	}
}
```

`src/main/java/cppclassanalyzer/database/schema/fields/ClassTypeInfoSchemaFields.java`:

```java
package cppclassanalyzer.database.schema.fields;

import java.util.Arrays;

import db.*;

public enum ClassTypeInfoSchemaFields implements FieldEnum {

	TYPENAME(StringField.class),
	TYPEINFO_ID(ByteField.class),
	ADDRESS(LongField.class),
	DATATYPE_ID(LongField.class),
	VTABLE_SEARCHED(BooleanField.class),
	VTABLE_KEY(LongField.class),
	MODEL_DATA(BinaryField.class);

	private final Class<? extends Field> fieldClass;

	private ClassTypeInfoSchemaFields(Class<? extends Field> fieldClass) {
		this.fieldClass = fieldClass;
	}

	public static Class<?>[] getFields() {
		return Arrays.stream(values())
			.map(FieldEnum::getFieldClass)
			.toArray(Class<?>[]::new);
	}

	public static String[] getFieldNames() {
		return Arrays.stream(values())
			.map(FieldEnum::getName)
			.toArray(String[]::new);
	}


	@Override
	public String getName() {
		return name();
	}

	@Override
	public Class<? extends Field> getFieldClass() {
		return fieldClass;
	}

	@Override
	public int getIndex() {
		return ordinal();
	}
}
```

`src/main/java/cppclassanalyzer/database/schema/fields/FieldEnum.java`:

```java
package cppclassanalyzer.database.schema.fields;

import db.Field;

public interface FieldEnum {
	String getName();
	Class<? extends Field> getFieldClass();
	int getIndex();
}
```

`src/main/java/cppclassanalyzer/database/schema/fields/VtableSchemaFields.java`:

```java
package cppclassanalyzer.database.schema.fields;

import java.util.Arrays;

import db.*;

public enum VtableSchemaFields implements FieldEnum {

	/** Name of the Program the type originated from */
	PROGRAM_NAME(StringField.class),
	ADDRESS(LongField.class),
	CLASS(LongField.class),
	RECORDS(BinaryField.class);

	private final Class<? extends Field> fieldClass;

	VtableSchemaFields(Class<? extends Field> fieldClass) {
		this.fieldClass = fieldClass;
	}

	public static Class<?>[] getFields() {
		return Arrays.stream(values())
			.map(FieldEnum::getFieldClass)
			.toArray(Class<?>[]::new);
	}

	public static String[] getFieldNames() {
		return Arrays.stream(values())
			.map(FieldEnum::getName)
			.toArray(String[]::new);
	}


	@Override
	public String getName() {
		return name();
	}

	@Override
	public Class<? extends Field> getFieldClass() {
		return fieldClass;
	}

	@Override
	public int getIndex() {
		return ordinal();
	}
}
```

`src/main/java/cppclassanalyzer/database/tables/AbstractDatabaseTable.java`:

```java
package cppclassanalyzer.database.tables;

import java.io.IOException;

import ghidra.util.exception.AssertException;

import cppclassanalyzer.database.schema.AbstractSchema;
import db.*;

abstract class AbstractDatabaseTable<T extends AbstractSchema<?>> implements DatabaseTable<T> {

	private final Table table;

	AbstractDatabaseTable(Table table) {
		if (!table.getSchema().equals(getSchema())) {
			throw new AssertException("Schema's do not match");
		}
		this.table = table;
	}

	@Override
	public final Table getTable() {
		return table;
	}

	@Override
	public final String getName() {
		return table.getName();
	}

	protected final DBRecord getRawRecord(long key) throws IOException {
		return table.getRecord(key);
	}

	protected final DBRecord getRawRecord(Field key) throws IOException {
		return table.getRecord(key);
	}

}

```

`src/main/java/cppclassanalyzer/database/tables/ArchivedClassTypeInfoDatabaseTable.java`:

```java
package cppclassanalyzer.database.tables;

import java.io.IOException;

import cppclassanalyzer.database.record.ArchivedClassTypeInfoRecord;
import cppclassanalyzer.database.schema.ArchivedClassTypeInfoSchema;
import db.*;

public class ArchivedClassTypeInfoDatabaseTable
		extends AbstractDatabaseTable<ArchivedClassTypeInfoSchema> {

	public ArchivedClassTypeInfoDatabaseTable(Table table) {
		super(table);
	}

	@Override
	public ArchivedClassTypeInfoSchema getSchema() {
		return ArchivedClassTypeInfoSchema.SCHEMA;
	}

	@Override
	@SuppressWarnings("unchecked")
	public final ArchivedClassTypeInfoRecord getRecord(long key) throws IOException {
		DBRecord record = getRawRecord(key);
		if (record != null) {
			return getSchema().getRecord(record);
		}
		return null;
	}

	@Override
	@SuppressWarnings("unchecked")
	public ArchivedClassTypeInfoRecord getRecord(Field key) throws IOException {
		DBRecord record = getRawRecord(key);
		if (record != null) {
			return getSchema().getRecord(record);
		}
		return null;
	}
}

```

`src/main/java/cppclassanalyzer/database/tables/ArchivedGnuVtableDatabaseTable.java`:

```java
package cppclassanalyzer.database.tables;

import java.io.IOException;

import cppclassanalyzer.database.record.ArchivedGnuVtableRecord;
import cppclassanalyzer.database.schema.ArchivedGnuVtableSchema;
import db.*;

public class ArchivedGnuVtableDatabaseTable extends AbstractDatabaseTable<ArchivedGnuVtableSchema> {

	public ArchivedGnuVtableDatabaseTable(Table table) {
		super(table);
	}

	@Override
	public ArchivedGnuVtableSchema getSchema() {
		return ArchivedGnuVtableSchema.SCHEMA;
	}

	@Override
	@SuppressWarnings("unchecked")
	public final ArchivedGnuVtableRecord getRecord(long key) throws IOException {
		DBRecord record = getRawRecord(key);
		if (record != null) {
			return getSchema().getRecord(record);
		}
		return null;
	}

	@Override
	@SuppressWarnings("unchecked")
	public ArchivedGnuVtableRecord getRecord(Field key) throws IOException {
		DBRecord record = getRawRecord(key);
		if (record != null) {
			return getSchema().getRecord(record);
		}
		return null;
	}

}

```

`src/main/java/cppclassanalyzer/database/tables/ClassTypeInfoDatabaseTable.java`:

```java
package cppclassanalyzer.database.tables;

import java.io.IOException;

import cppclassanalyzer.database.record.ClassTypeInfoRecord;
import cppclassanalyzer.database.schema.ClassTypeInfoSchema;
import db.*;

public class ClassTypeInfoDatabaseTable extends AbstractDatabaseTable<ClassTypeInfoSchema> {

	public ClassTypeInfoDatabaseTable(Table table) {
		super(table);
	}

	@Override
	public ClassTypeInfoSchema getSchema() {
		return ClassTypeInfoSchema.SCHEMA;
	}

	@Override
	@SuppressWarnings("unchecked")
	public final ClassTypeInfoRecord getRecord(long key) throws IOException {
		DBRecord record = getRawRecord(key);
		if (record != null) {
			return ClassTypeInfoSchema.SCHEMA.getRecord(record);
		}
		return null;
	}

	@Override
	@SuppressWarnings("unchecked")
	public ClassTypeInfoRecord getRecord(Field key) throws IOException {
		DBRecord record = getRawRecord(key);
		if (record != null) {
			return ClassTypeInfoSchema.SCHEMA.getRecord(record);
		}
		return null;
	}

}

```

`src/main/java/cppclassanalyzer/database/tables/DatabaseTable.java`:

```java
package cppclassanalyzer.database.tables;

import java.io.IOException;

import cppclassanalyzer.database.record.DatabaseRecord;
import cppclassanalyzer.database.schema.AbstractSchema;
import db.*;

public interface DatabaseTable<T extends AbstractSchema<?>> {
	T getSchema();
	Table getTable();

	String getName();

	<R extends DatabaseRecord<?>> R getRecord(long key) throws IOException;
	<R extends DatabaseRecord<?>> R getRecord(Field key) throws IOException;
}

```

`src/main/java/cppclassanalyzer/database/tables/VtableDatabaseTable.java`:

```java
package cppclassanalyzer.database.tables;

import java.io.IOException;

import cppclassanalyzer.database.record.VtableRecord;
import cppclassanalyzer.database.schema.VtableSchema;
import db.*;

public class VtableDatabaseTable extends AbstractDatabaseTable<VtableSchema> {

	public VtableDatabaseTable(Table table) {
		super(table);
	}

	@Override
	public VtableSchema getSchema() {
		return VtableSchema.SCHEMA;
	}

	@Override
	@SuppressWarnings("unchecked")
	public final VtableRecord getRecord(long key) throws IOException {
		DBRecord record = getRawRecord(key);
		if (record != null) {
			return VtableSchema.SCHEMA.getRecord(record);
		}
		return null;
	}

	@Override
	@SuppressWarnings("unchecked")
	public VtableRecord getRecord(Field key) throws IOException {
		DBRecord record = getRawRecord(key);
		if (record != null) {
			return VtableSchema.SCHEMA.getRecord(record);
		}
		return null;
	}

}

```

`src/main/java/cppclassanalyzer/database/utils/LongStack.java`:

```java
package cppclassanalyzer.database.utils;

import ghidra.util.datastruct.LongArrayList;

public class LongStack extends LongArrayList {

	/**
	 * Removes the object at the top of this stack and returns that object as the value
	 * of this function.
	 * @return the element popped from the stack
	 */
	public long pop() {
		return remove(size() - 1);
	}

	/**
	 * Pushes an item onto the top of this stack
	 * @param item the object to push onto the stack
	 * @return the item pushed onto the stack
	 */
	public long push(long item) {
		add(item);
		return item;
	}
}

```

`src/main/java/cppclassanalyzer/database/utils/TransactionHandler.java`:

```java
package cppclassanalyzer.database.utils;

public class TransactionHandler {

	private final TransactionStarter starter;
	private final TransactionEnder ender;
	private final LongStack transactions;

	public TransactionHandler(TransactionStarter starter, TransactionEnder ender) {
		this.starter = starter;
		this.ender = ender;
		this.transactions = new LongStack();
	}

	public void startTransaction() {
		startTransaction(null);
	}

	public void startTransaction(String description) {
		transactions.push(starter.startTransaction(description));
	}

	public void endTransaction() {
		endTransaction(true);
	}

	public void endTransaction(boolean commit) {
		long id = transactions.pop();
		ender.endTransaction(id, commit);
	}

	@FunctionalInterface
	public static interface TransactionStarter {
		long startTransaction(String description);
	}

	@FunctionalInterface
	public static interface TransactionEnder {
		void endTransaction(long id, boolean commit);
	}
}
```

`src/main/java/cppclassanalyzer/decompiler/DecompilerAPI.java`:

```java
package cppclassanalyzer.decompiler;

import java.util.*;

import ghidra.app.decompiler.*;
import ghidra.app.decompiler.component.DecompilerUtils;
import ghidra.framework.options.ToolOptions;
import ghidra.framework.plugintool.PluginTool;
import ghidra.framework.plugintool.util.OptionsService;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.model.pcode.HighFunction;
import ghidra.util.Disposable;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheStats;

import cppclassanalyzer.decompiler.function.HighFunctionCall;
import cppclassanalyzer.decompiler.token.ClangNodeUtils;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

/**
 * A Decompiler API with more to offer than the
 * {@link ghidra.app.decompiler.flatapi.FlatDecompilerAPI FlatDecompilerAPI}
 */
public final class DecompilerAPI implements Disposable, AutoCloseable {

	private final PluginTool tool;
	private final DecompInterface decompiler;
	private Cache<Function, DecompileResults> cache;
	private TaskMonitor monitor;
	private int timeout;

	/**
	 * Constructs a new DecompilerAPI
	 * @param tool the current tool
	 */
	public DecompilerAPI(PluginTool tool) {
		this.tool = tool;
		this.decompiler = new DecompInterface();
		this.monitor = TaskMonitor.DUMMY;
	}

	/**
	 * Constructs a new DecompilerAPI
	 * @param program the current program
	 */
	public DecompilerAPI(Program program) {
		this(program, TaskMonitor.DUMMY, 0);
	}

	/**
	 * Constructs a new DecompilerAPI
	 * @param program the current program
	 * @param monitor the monitor to use for the decompiler
	 * @param timeout the timeout to use for the decompiler or &lt; 0 to use
	 * the default timeout provided by user settings.
	 */
	public DecompilerAPI(Program program, TaskMonitor monitor, int timeout) {
		this.tool = CppClassAnalyzerUtils.getTool(program);
		this.decompiler = new DecompInterface();
		setUpDecompiler(program);
		this.cache = buildCache(decompiler.getOptions().getCacheSize());
		this.monitor = monitor;
		if (timeout >= 0) {
			this.timeout = timeout;
		} else {
			this.timeout = decompiler.getOptions().getDefaultTimeout();
		}
	}

	@Override
	public void dispose() {
		if (decompiler != null) {
			decompiler.dispose();
		}
	}

	@Override
	public void close() {
		dispose();
	}

	private DecompInterface setUpDecompiler(Program program) {

		// call it to get results
		if (!decompiler.openProgram(program)) {
			decompiler.dispose();
			throw new AssertException("Decompile Error: " + decompiler.getLastMessage());
		}

		DecompileOptions options;
		options = new DecompileOptions();
		OptionsService service = tool != null ? tool.getService(OptionsService.class) : null;
		if (service != null) {
			ToolOptions opt = service.getOptions("Decompiler");
			options.grabFromToolAndProgram(null, opt, program);
		}
		decompiler.setOptions(options);

		decompiler.toggleCCode(true);
		decompiler.toggleSyntaxTree(true);
		decompiler.setSimplificationStyle("decompile");

		return decompiler;
	}

	/**
	 * Get the current program opened in the decompiler
	 * @return the decompiler's opened program
	 */
	public Program getProgram() {
		return decompiler.getProgram();
	}

	/**
	 * Sets the program for the decompiler to use
	 * @param program to program to open in the decompiler
	 */
	public void setProgram(Program program) {
		Program currentProgram = getProgram();
		if (currentProgram == null || !currentProgram.equals(program)) {
			if (currentProgram != null) {
				decompiler.closeProgram();
			}
			setUpDecompiler(program);
			this.cache = buildLargeCache();
		}
	}

	/**
	 * Gets the tool
	 * @return the tool
	 */
	public PluginTool getTool() {
		return tool;
	}

	/**
	 * Gets the decompiler
	 * @return the decompiler
	 */
	public DecompInterface getDecompiler() {
		return decompiler;
	}

	/**
	 * Gets the decompiler timeout
	 * @return the decompiler timeout
	 */
	public int getTimeout() {
		return timeout;
	}

	/**
	 * Sets the decompiler timeout
	 * @param timeout the timeout
	 */
	public void setTimeout(int timeout) {
		this.timeout = timeout;
	}

	/**
	 * Sets the task monitor to use
	 * @param monitor the task monitor
	 */
	public void setMonitor(TaskMonitor monitor) {
		this.monitor = monitor;
	}

	/**
	 * Gets a thread safe and unmodifiable view of the decompiler cache
	 * @return a map of the decompiler cache
	 */
	public Map<Function, DecompileResults> getCache() {
		return Collections.unmodifiableMap(cache.asMap());
	}

	/**
	 * Flushes the decompiler cache
	 */
	public void clearCache() {
		cache.invalidateAll();
	}

	/**
	 * Decompiles the provided function
	 * @param function the function to decompile
	 * @return the decompiled function
	 * @throws CancelledException if the decompilation is cancelled
	 */
	public DecompileResults decompileFunction(Function function) throws CancelledException {
		DecompileResults results = cache.getIfPresent(Objects.requireNonNull(function));
		if (results != null) {
			return results;
		}
		results = decompiler.decompileFunction(function, timeout, monitor);
		monitor.checkCanceled();
		cache.put(function, results);
		return results;
	}

	/**
	 * Gets all the {@link ClangStatement}s in the decompiled function
	 * @param function the function to decompile
	 * @return a list of all the functions statements
	 * @throws CancelledException if the decompilation is cancelled
	 */
	public List<ClangStatement> getClangStatements(Function function) throws CancelledException {
		DecompileResults results = decompileFunction(Objects.requireNonNull(function));
		return ClangNodeUtils.getClangStatements(results.getCCodeMarkup());
	}

	/**
	 * Gets the HighFunction for the decompiled function
	 * @param function the function to decompile
	 * @return the functions HighFunction
	 * @throws CancelledException if the decompilation is cancelled
	 */
	public HighFunction getHighFunction(Function function) throws CancelledException {
		DecompileResults results = decompileFunction(Objects.requireNonNull(function));
		return results.getHighFunction();
	}

	/**
	 * Gets a list of all the functions the decompiled function calls
	 * @param function the function to decompile
	 * @return a list of function calls
	 * @throws CancelledException if the decompilation is cancelled
	 */
	public List<HighFunctionCall> getFunctionCalls(Function function) throws CancelledException {
		DecompileResults results = decompileFunction(Objects.requireNonNull(function));
		return ClangNodeUtils.getClangFunctionCalls(results.getCCodeMarkup());
	}

	/**
	 * A convience method to get the corresponding Function for a function name
	 * @param token the function name
	 * @return the function
	 */
	public Function getFunction(ClangFuncNameToken token) {
		return DecompilerUtils.getFunction(getProgram(), Objects.requireNonNull(token));
	}

	/**
	 * Gets the decompiler cache stats
	 * @return the decompiler cache stats
	 */
	public CacheStats getCacheStats() {
		return cache.stats();
	}

	private static Cache<Function, DecompileResults> buildCache(int cacheSize) {
		return CacheBuilder.newBuilder()
           .softValues()
           .maximumSize(cacheSize)
           .build();
	}

	private static Cache<Function, DecompileResults> buildLargeCache() {
		return CacheBuilder.newBuilder()
           .softValues()
           .maximumSize(100)
           .build();
	}
}

```

`src/main/java/cppclassanalyzer/decompiler/action/FillOutClassAction.java`:

```java
package cppclassanalyzer.decompiler.action;

import ghidra.app.cmd.data.rtti.gcc.UnresolvedClassTypeInfoException;
import ghidra.app.plugin.core.decompile.DecompilerActionContext;
import ghidra.app.plugin.core.decompile.actions.AbstractNonPackageDecompilerAction;

import cppclassanalyzer.cmd.FillOutClassBackgroundCmd;
import cppclassanalyzer.data.manager.ClassTypeInfoManagerDB;
import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;
import docking.action.MenuData;

public class FillOutClassAction extends AbstractNonPackageDecompilerAction {

	private static final String NAME = FillOutClassAction.class.getSimpleName();
	private static final MenuData MENU_ENTRY =
		new MenuData(new String[] { "Fill Out Class" }, "Decompile");

	private final ClassTypeInfoManagerPlugin plugin;

	public FillOutClassAction(ClassTypeInfoManagerPlugin plugin) {
		super(NAME);
		this.plugin = plugin;
		setPopupMenuData(MENU_ENTRY);
		setDescription("Automatically fill out class members");
	}

	@Override
	protected boolean isEnabledForDecompilerContext(DecompilerActionContext context) {
		if (!context.hasRealFunction()) {
			return false;
		}
		ClassTypeInfoManagerDB manager =
			(ClassTypeInfoManagerDB) plugin.getManager(context.getProgram());
		if (manager == null) {
			return false;
		}
		try {
			return manager.getType(context.getFunction()) != null;
		} catch (UnresolvedClassTypeInfoException e) {
			// allowing the use of the action will just cause the exception to be thrown again
			return false;
		}
	}

	@Override
	protected void decompilerActionPerformed(DecompilerActionContext context) {
		FillOutClassBackgroundCmd cmd = new FillOutClassBackgroundCmd(context);
		context.getTool().executeBackgroundCommand(cmd, context.getProgram());
	}

}

```

`src/main/java/cppclassanalyzer/decompiler/function/AbstractHighStructAccess.java`:

```java
package cppclassanalyzer.decompiler.function;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import ghidra.app.decompiler.*;
import ghidra.program.model.pcode.*;
import ghidra.program.model.scalar.Scalar;

abstract class AbstractHighStructAccess implements HighStructAccess {

	private final List<ClangNode> tokens;

	AbstractHighStructAccess(ClangTokenGroup group) {
		this.tokens = new ArrayList<>(group.numChildren());
		group.flatten(tokens);
	}

	private <T extends ClangNode> boolean hasNode(Class<T> clazz) {
		return tokens.stream()
			.anyMatch(clazz::isInstance);
	}

	private <T extends ClangNode> T getFirstNode(Class<T> clazz) {
		return tokens.stream()
			.filter(clazz::isInstance)
			.map(clazz::cast)
			.findFirst()
			.orElse(null);
	}

	private <T extends ClangToken> List<T> getTokens(Class<T> clazz) {
		return tokens.stream()
			.filter(clazz::isInstance)
			.map(clazz::cast)
			.collect(Collectors.toList());
	}

	@Override
	public final ClangVariableToken getVariableToken() {
		return getFirstNode(ClangVariableToken.class);
	}

	@Override
	public final boolean hasFieldToken() {
		return hasNode(ClangFieldToken.class);
	}

	@Override
	public final ClangFieldToken getFieldToken() {
		return getFirstNode(ClangFieldToken.class);
	}

	@Override
	public final boolean hasLocalRef() {
		ClangVariableToken token = getVariableToken();
		if (token == null) {
			return false;
		}
		HighFunction hf = token.getClangFunction().getHighFunction();
		if (hf == null) {
			return false;
		}
		HighVariable var = token.getHighVariable();
		if (var == null) {
			return false;
		}
		return hf.getLocalSymbolMap().containsVariableWithName(var.getName());
	}

	@Override
	public final List<ClangOpToken> getOpTokens() {
		return getTokens(ClangOpToken.class);
	}

	@Override
	public final List<ClangNode> getTokens() {
		return Collections.unmodifiableList(tokens);
	}

	@Override
	public final int getOffset() {
		ClangVariableToken var = getVariableToken();
		PcodeOp op = var.getPcodeOp();
		if (op.getOpcode() == PcodeOp.PTRADD) {
			Varnode index = op.getInput(1);
			Scalar value = ((HighConstant) index.getHigh()).getScalar();
			return var.getHighVariable().getDataType().getLength()
				* (int) value.getValue();
		}
		return 0;
	}

	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		for (ClangNode node : tokens) {
			builder.append(((ClangToken) node).getText());
		}
		return builder.toString();
	}

}

```

`src/main/java/cppclassanalyzer/decompiler/function/HighFunctionCall.java`:

```java
package cppclassanalyzer.decompiler.function;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import ghidra.app.decompiler.*;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.listing.*;
import ghidra.program.model.pcode.*;
import ghidra.program.model.symbol.ExternalLocationIterator;
import ghidra.program.model.symbol.ExternalManager;

public final class HighFunctionCall implements Comparable<HighFunctionCall> {

	private final HighFunction hf;
	private final ClangFuncNameToken name;
	private final List<HighFunctionCallParameter> parameters;

	private HighFunctionCall(ClangStatement statement, FunctionNameParamSupplier supplier) {
		this.hf = statement.getClangFunction().getHighFunction();
		this.name = supplier.getFunctionName();
		this.parameters = supplier.getParameterGroups()
			.stream()
			.map(HighFunctionCallParameter::new)
			.collect(Collectors.toList());
	}

	public static HighFunctionCall getHighFunctionCall(ClangStatement statement) {
		FunctionNameParamSupplier supplier = new FunctionNameParamSupplier(statement);
		if (supplier.getFunctionName() == null) {
			return null;
		}
		return new HighFunctionCall(statement, supplier);
	}

	private VarnodeAST getVarnode() {
		return (VarnodeAST) name.getPcodeOp().getInput(0);
	}

	public Function getFunction() {
		VarnodeAST varnode = getVarnode();
		long offset = varnode.getOffset();
		AddressSpace space = hf.getAddressFactory().getAddressSpace(varnode.getSpace());
		Listing listing = getProgram().getListing();
		Function f = listing.getFunctionAt(space.getAddress(offset));
		return f != null ? f : getExternalFunction(space.getAddress(offset));
	}

	private Function getExternalFunction(Address address) {
		Program program = getProgram();
		Listing listing = getProgram().getListing();
		Data data = listing.getDataAt(address);
		if (data != null && data.isPointer()) {
			ExternalManager man = program.getExternalManager();
			ExternalLocationIterator it = man.getExternalLocations((Address) data.getValue());
			if (it.hasNext()) {
				return it.next().getFunction();
			}
		}
		return null;
	}

	private Program getProgram() {
		return hf.getFunction().getProgram();
	}

	public Address getAddress() {
		return getVarnode().getPCAddress();
	}

	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder(name.getText());
		builder.append('(');
		Iterator<HighFunctionCallParameter> params = parameters.iterator();
		while (params.hasNext()) {
			HighFunctionCallParameter param = params.next();
			builder.append(param.toString());
			if (params.hasNext()) {
				builder.append(", ");
			}
		}
		builder.append(");");
		return builder.toString();
	}

	public List<HighFunctionCallParameter> getParameters() {
		return parameters;
	}

	private static boolean isSeparator(ClangToken token) {
		if (token instanceof ClangOpToken) {
			return token.getText().equals(",");
		}
		return false;
	}

	private static final class FunctionNameParamSupplier {

		private final ClangStatement statement;
		private int nameIndex;

		FunctionNameParamSupplier(ClangStatement statement) {
			this.statement = statement;
			this.nameIndex = -1;
		}

		ClangFuncNameToken getFunctionName() {
			if (nameIndex == -1) {
				for (int i = 0; i < statement.numChildren(); i++) {
					if (statement.Child(i) instanceof ClangFuncNameToken) {
						nameIndex = i;
						break;
					}
				}
			}
			return nameIndex != -1 ? (ClangFuncNameToken) statement.Child(nameIndex) : null;
		}

		List<ClangTokenGroup> getParameterGroups() {
			List<ClangToken> tokens = IntStream.range(nameIndex + 1, statement.numChildren())
				.mapToObj(statement::Child)
				.filter(ClangToken.class::isInstance)
				.map(ClangToken.class::cast)
				.collect(Collectors.toList());
			List<ClangTokenGroup> tokenLists = new ArrayList<>();
			int prev = 0;
			for (int i = 0; i < tokens.size(); i++) {
				if (isSeparator(tokens.get(i))) {
					ClangTokenGroup group = new ClangTokenGroup(null);
					List<ClangToken> groupTokens;
					if (prev == 0) {
						groupTokens = tokens.subList(prev+1, i++);
					} else {
						groupTokens = tokens.subList(prev, i++);
					}
					prev = i;
					groupTokens.forEach(group::AddTokenGroup);
					tokenLists.add(group);
				}
			}
			if (prev != tokens.size()) {
				ClangTokenGroup group = new ClangTokenGroup(null);
				List<ClangToken> groupTokens = tokens.subList(prev, tokens.size()-1);
				groupTokens.forEach(group::AddTokenGroup);
				tokenLists.add(group);
			}
			return tokenLists;
		}
	}

	@Override
	public int compareTo(HighFunctionCall o) {
		return name.getMinAddress().compareTo(o.name.getMinAddress());
	}

}

```

`src/main/java/cppclassanalyzer/decompiler/function/HighFunctionCallParameter.java`:

```java
package cppclassanalyzer.decompiler.function;

import ghidra.app.decompiler.*;

public final class HighFunctionCallParameter extends AbstractHighStructAccess {

	HighFunctionCallParameter(ClangTokenGroup group) {
		super(group);
	}

	@Override
	public AccessType getAccessType() {
		return AccessType.PARAMETER;
	}

}

```

`src/main/java/cppclassanalyzer/decompiler/function/HighStructAccess.java`:

```java
package cppclassanalyzer.decompiler.function;

import java.util.List;

import ghidra.app.decompiler.*;

public interface HighStructAccess {

	public boolean hasFieldToken();

	public ClangFieldToken getFieldToken();

	public ClangVariableToken getVariableToken();

	public boolean hasLocalRef();

	public int getOffset();

	public List<ClangOpToken> getOpTokens();

	public List<ClangNode> getTokens();

	public AccessType getAccessType();

	public static enum AccessType {
		PARAMETER,
		GLOBAL
	}
}

```

`src/main/java/cppclassanalyzer/decompiler/function/HighVariableAssignment.java`:

```java
package cppclassanalyzer.decompiler.function;

import java.util.Arrays;
import java.util.Objects;
import java.util.stream.Stream;

import ghidra.app.decompiler.*;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.VariableStorage;
import ghidra.program.model.pcode.*;

public final class HighVariableAssignment extends AbstractHighStructAccess {

	public HighVariableAssignment(ClangStatement statement) {
		super(statement);
	}

	private Stream<VariableStorage> getVarnodeStream() {
		return getTokens()
			.stream()
			.filter(ClangVariableToken.class::isInstance)
			.map(ClangVariableToken.class::cast)
			.map(ClangVariableToken::getPcodeOp)
			.map(PcodeOp::getInputs)
			.flatMap(Arrays::stream)
			.map(Varnode::getHigh)
			.filter(Objects::nonNull)
			.map(HighVariable::getSymbol)
			.filter(Objects::nonNull)
			.map(HighSymbol::getStorage)
			.filter(HighVariableAssignment::isAddress);
	}

	private static boolean isAddress(VariableStorage storage) {
		return storage.isMemoryStorage()
			&& !(storage.isRegisterStorage() || storage.isStackStorage());
	}

	public boolean hasGlobalRef() {
		return getVarnodeStream()
			.findAny()
			.isPresent();
	}

	public Address getGlobalRefAddress() {
		return getVarnodeStream()
			.map(VariableStorage::getMinAddress)
			.findFirst()
			.orElse(null);
	}

	@Override
	public AccessType getAccessType() {
		return AccessType.GLOBAL;
	}
}

```

`src/main/java/cppclassanalyzer/decompiler/token/ClangNodeUtils.java`:

```java
package cppclassanalyzer.decompiler.token;

import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import ghidra.app.decompiler.*;
import ghidra.app.decompiler.component.DecompilerUtils;
import ghidra.program.model.pcode.PcodeOp;

import cppclassanalyzer.decompiler.function.HighFunctionCall;

public final class ClangNodeUtils {

	private ClangNodeUtils() {
	}

	public static Stream<ClangNode> asStream(ClangTokenGroup group) {
		return IntStream.range(0, group.numChildren())
			.mapToObj(group::Child);
	}

	public static Stream<ClangNode> asFlatStream(ClangTokenGroup group) {
		FlatNodeMapper mapper = new FlatNodeMapper(group);
		return IntStream.range(0, group.numChildren())
			.mapToObj(mapper::flatten)
			.flatMap(Objects::requireNonNull);
	}

	public static Iterator<ClangNode> asIterator(ClangTokenGroup group) {
		return asStream(group)
			.iterator();
	}

	public static Iterator<ClangNode> asFlatIterator(ClangTokenGroup group) {
		return asFlatStream(group)
			.iterator();
	}

	public static Iterable<ClangNode> asIterable(ClangTokenGroup group) {
		return () -> asIterator(group);
	}

	public static Iterable<ClangNode> asFlatIterable(ClangTokenGroup group) {
		return () -> asFlatIterator(group);
	}

	private static Stream<ClangStatement> getStatementStream(ClangTokenGroup group) {
		return asFlatStream(group)
			.filter(ClangStatement.class::isInstance)
			.map(ClangStatement.class::cast);
	}

	public static List<ClangStatement> getClangStatements(ClangTokenGroup group) {
		return getStatementStream(group)
			.collect(Collectors.toList());
	}

	public static List<HighFunctionCall> getClangFunctionCalls(ClangTokenGroup group) {
		return getStatementStream(group)
			.filter(ClangNodeUtils::isCallStatement)
			.map(HighFunctionCall::getHighFunctionCall)
			.filter(Objects::nonNull)
			.sorted()
			.collect(Collectors.toList());
	}

	public static ClangLine getClangLine(ClangTokenGroup group, int line) {
		return getClangLines(group)
			.stream()
			.filter(l -> l.getLineNumber() == line)
			.findFirst()
			.orElse(null);
	}

	public static List<ClangLine> getClangLines(ClangTokenGroup group) {
		return DecompilerUtils.toLines(group);
	}

	///////////////////////////////////////////////////////////////////////////
	//                             Filters                                   //
	///////////////////////////////////////////////////////////////////////////

	public static boolean isClangTokenGroup(ClangNode node) {
		return node.getClass() == ClangTokenGroup.class;
	}

	private static boolean isCallStatement(ClangStatement statement) {
		PcodeOp op = statement.getPcodeOp();
		return op != null ? op.getOpcode() == PcodeOp.CALL : false;
	}

	///////////////////////////////////////////////////////////////////////////
	//                           Comparitors                                 //
	///////////////////////////////////////////////////////////////////////////

	public static int compareClangLines(ClangLine lineA, ClangLine lineB) {
		return Integer.compare(lineA.getLineNumber(), lineB.getLineNumber());
	}

	private static class FlatNodeMapper {

		private final ClangTokenGroup group;

		FlatNodeMapper(ClangTokenGroup group) {
			this.group = group;
		}

		Stream<ClangNode> flatten(int i) {
			ClangNode node = group.Child(i);
			if (isClangTokenGroup(node)) {
				return asFlatStream((ClangTokenGroup) node);
			}
			return Stream.of(node);
		}
	}
}

```

`src/main/java/cppclassanalyzer/decompiler/token/ClangTokenGroupIterator.java`:

```java
package cppclassanalyzer.decompiler.token;

import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import ghidra.app.decompiler.ClangNode;
import ghidra.app.decompiler.ClangTokenGroup;

import util.CollectionUtils;

public class ClangTokenGroupIterator implements Iterator<ClangTokenGroup> {

	private final List<ClangTokenGroup> groups;
	private Iterator<ClangTokenGroup> it;
	private ClangTokenGroup group;
	private int index;

	public ClangTokenGroupIterator(ClangTokenGroup group) {
		this.group = group;
		this.groups = ClangNodeUtils.asStream(group)
			.filter(ClangTokenGroupIterator::isTokenGroup)
			.map(ClangTokenGroup.class::cast)
			.collect(Collectors.toList());
		if (groups.isEmpty()) {
			this.it = Collections.emptyIterator();
		} else {
			this.it = new ClangTokenGroupIterator(groups.get(index++));
		}
	}

	private static boolean isTokenGroup(ClangNode node) {
		return node.getClass() == ClangTokenGroup.class;
	}

	@Override
	public boolean hasNext() {
		return group != null || it.hasNext() || index < groups.size();
	}

	@Override
	public ClangTokenGroup next() {
		if (group != null) {
			ClangTokenGroup next = group;
			group = null;
			return next;
		}
		if (!it.hasNext()) {
			it = new ClangTokenGroupIterator(groups.get(index++));
		}
		return it.next();
	}

	public Stream<ClangTokenGroup> stream() {
		return CollectionUtils.asStream(this);
	}

}

```

`src/main/java/cppclassanalyzer/graph/InheritanceGraphDisplayProvider.java`:

```java
package cppclassanalyzer.graph;

import ghidra.graph.visualization.DefaultGraphDisplayProvider;

public class InheritanceGraphDisplayProvider extends DefaultGraphDisplayProvider {

	@Override
	public String getName() {
		return "Inheritance Graph Display (Not Implemented)";
	}
}

```

`src/main/java/cppclassanalyzer/plugin/ClassTypeInfoManagerPlugin.java`:

```java
package cppclassanalyzer.plugin;

import java.awt.datatransfer.Clipboard;
import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

import ghidra.app.cmd.data.rtti.gcc.UnresolvedClassTypeInfoException;
import ghidra.app.plugin.PluginCategoryNames;
import ghidra.app.plugin.ProgramPlugin;
import ghidra.app.plugin.core.datamgr.DataTypeManagerPlugin;
import ghidra.app.plugin.core.datamgr.archive.Archive;
import ghidra.app.plugin.core.datamgr.archive.ArchiveManagerListener;
import ghidra.app.plugin.core.datamgr.archive.DataTypeManagerHandler;
import ghidra.app.plugin.core.datamgr.archive.FileArchive;
import ghidra.app.plugin.core.datamgr.archive.ProjectArchive;
import ghidra.app.plugin.core.decompile.DecompilerProvider;
import cppclassanalyzer.plugin.typemgr.TypeInfoTreeProvider;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoNode;
import cppclassanalyzer.service.ClassTypeInfoManagerService;
import cppclassanalyzer.service.RttiManagerProvider;

import ghidra.app.services.DataTypeManagerService;
import ghidra.app.services.GoToService;
import ghidra.framework.plugintool.PluginInfo;
import ghidra.framework.plugintool.PluginTool;
import ghidra.framework.plugintool.util.PluginStatus;
import cppclassanalyzer.data.manager.ArchiveClassTypeInfoManager;
import cppclassanalyzer.data.ArchivedRttiData;
import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.manager.FileArchiveClassTypeInfoManager;
import cppclassanalyzer.data.manager.LibraryClassTypeInfoManager;
import cppclassanalyzer.data.manager.ProjectClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.vtable.ArchivedVtable;
import cppclassanalyzer.database.SchemaMismatchException;
import cppclassanalyzer.decompiler.DecompilerAPI;
import cppclassanalyzer.decompiler.action.FillOutClassAction;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;

import docking.ActionContext;
import docking.Tool;
import docking.action.DockingActionIf;
import docking.actions.PopupActionProvider;
import docking.widgets.tree.GTree;

import static ghidra.util.SystemUtilities.isInHeadlessMode;

/**
 * Plugin to pop up the dialog to manage rtti in the program
 * and archived rtti files. The dialog shows a single tree with
 * different classes.
 */
//@formatter:off
@PluginInfo(
	status = PluginStatus.UNSTABLE,
	packageName = CppClassAnalyzerPluginPackage.NAME,
	category = PluginCategoryNames.CODE_VIEWER,
	shortDescription = "Window for managing rtti",
	description = "Provides the window for managing rtti " +
			"The rtti display shows all rtti found in the " +
			"current program, and rtti in all open archives.",
	servicesProvided = { ClassTypeInfoManagerService.class },
	servicesRequired = { DataTypeManagerService.class, GoToService.class }
)
//@formatter:on
public class ClassTypeInfoManagerPlugin extends ProgramPlugin
		implements ClassTypeInfoManagerService, PopupActionProvider, ArchiveManagerListener {

	private final DecompilerAPI api;
	private final List<ClassTypeInfoManager> managers;
	private final TypeInfoTreeProvider provider;
	private final Clipboard clipboard;
	private final FillOutClassAction fillOutClassAction;
	private DataTypeManagerPlugin dtmPlugin;
	private ProgramClassTypeInfoManager currentManager;

	public ClassTypeInfoManagerPlugin(PluginTool tool) {
		super(tool);
		this.api = new DecompilerAPI(tool);
		this.clipboard = new Clipboard(getName());
		this.managers = Collections.synchronizedList(new ArrayList<>());
		this.provider = !isInHeadlessMode() ? new TypeInfoTreeProvider(tool, this) : null;
		this.fillOutClassAction = new FillOutClassAction(this);
	}

	@Override
	protected void init() {
		DataTypeManagerService service = tool.getService(DataTypeManagerService.class);
		dtmPlugin = (DataTypeManagerPlugin) service;
		dtmPlugin.getDataTypeManagerHandler().addArchiveManagerListener(this);
		if (!isInHeadlessMode()) {
			DecompilerProvider provider =
				(DecompilerProvider) tool.getComponentProvider("Decompiler");
			provider.addLocalAction(fillOutClassAction);
		}
	}

	@Override
	protected void programOpened(Program program) {
		try {
			RttiManagerProvider provider =
				ClassTypeInfoManagerService.getManagerProvider(program);
			if (provider != null) {
				managers.add(provider.getManager(program));
			}
		} catch (SchemaMismatchException e) {
			Msg.showInfo(this, null, "Ghidra C++ Class Analyzer", e.getMessage());
		} catch (UnsupportedOperationException e) {
			// do nothing
		}
	}

	@Override
	protected void programClosed(Program program) {
		ClassTypeInfoManager man = getManager(program);
		if (man != null) {
			managers.remove(man);
			man.dispose();
		}
	}

	@Override
	protected void programActivated(Program program) {
		currentManager = getManager(program);
	}

	@Override
	protected void programDeactivated(Program program) {
		ClassTypeInfoManager manager = getManager(program);
		if (currentManager != null && currentManager.equals(manager)) {
			currentManager = null;
		}
	}

	@Override
	public List<ClassTypeInfoManager> getManagers() {
		return Collections.unmodifiableList(managers);
	}

	@Override
	public List<DockingActionIf> getPopupActions(Tool tool, ActionContext context) {
		return Collections.emptyList();
	}

	@Override
	public void closeManager(ClassTypeInfoManager manager) {
		if (manager instanceof FileArchiveClassTypeInfoManager) {
			((FileArchiveClassTypeInfoManager) manager).close();
		}
	}

	@Override
	public void openArchive(File file, boolean updateable) throws IOException {
		ClassTypeInfoManager manager =
			ArchiveClassTypeInfoManager.open(this, file, updateable);
		managers.add(manager);
	}

	@Override
	public void createArchive(File file) throws IOException {
		ClassTypeInfoManager manager = ArchiveClassTypeInfoManager.createManager(this, file);
		managers.add(manager);
	}

	@Override
	public DecompilerAPI getDecompilerAPI(Program program) {
		api.setProgram(program);
		return api;
	}

	public List<ClassTypeInfoManager> getManagersByName(List<String> names) {
		return managers.stream()
			.filter(m -> names.contains(m.getName()))
			.collect(Collectors.toList());
	}

	public boolean hasManager(ProjectArchive archive) {
		String name = archive.getName();
		return managers.stream()
			.filter(ProjectClassTypeInfoManager.class::isInstance)
			.map(ClassTypeInfoManager::getName)
			.anyMatch(name::equals);
	}

	public void openProjectArchive(ProjectArchive archive) throws IOException {
		ClassTypeInfoManager manager = ProjectClassTypeInfoManager.open(this, archive);
		projectManagerOpened(manager);
	}

	private void projectManagerOpened(ClassTypeInfoManager manager) {
		managers.add(manager);
	}

	public Clipboard getClipboard() {
		return clipboard;
	}

	public DataTypeManagerPlugin getDataTypeManagerPlugin() {
		return dtmPlugin;
	}

	public DataTypeManagerHandler getDataTypeManagerHandler() {
		return dtmPlugin.getDataTypeManagerHandler();
	}

	public void managerChanged(TypeInfoArchiveChangeRecord record) {
		switch (record.getChangeType()) {
			case TYPE_ADDED:
				provider.getTree().typeAdded(record.getType());
				break;
			case TYPE_REMOVED:
				provider.getTree().typeRemoved(record.getType());
				break;
			case TYPE_UPDATED:
				provider.getTree().typeUpdated(record.getType());
				break;
		}
	}

	@Override
	public ProgramClassTypeInfoManager getManager(Program program) {
		if (managers.isEmpty()) {
			return null;
		}
		return managers.stream()
			.filter(ProgramClassTypeInfoManager.class::isInstance)
			.map(ProgramClassTypeInfoManager.class::cast)
			.filter(m -> m.getProgram().equals(program))
			.findAny()
			.orElse(null);
	}

	@Override
	protected void dispose() {
		if (!isInHeadlessMode()) {
			tool.removeComponentProvider(provider);
			provider.dispose();
			fillOutClassAction.dispose();
		}
		getDataTypeManagerHandler().removeArchiveManagerListener(this);
		api.dispose();
	}

	public TypeInfoTreeProvider getProvider() {
		return provider;
	}

	@Override
	public boolean goTo(Address address) {
		return super.goTo(address);
	}

	public void goTo(TypeInfoNode node) {
		Address address = node.getAddress();
		if (address != null) {
			goTo(address);
		}
	}

	@Override
	public GTree getTree() {
		return !isInHeadlessMode() ? provider.getTree() : null;
	}

	@Override
	public void archiveOpened(Archive archive) {
		ClassTypeInfoManager manager = null;
		try {
			if (archive instanceof FileArchive) {
				manager = ArchiveClassTypeInfoManager.openIfManagerArchive(this, archive);
			} else if (archive instanceof ProjectArchive) {
				manager = ProjectClassTypeInfoManager.openIfManagerArchive(this, archive);
			}
		} catch (IOException e) {
			Msg.error(manager, e);
		}
		if (manager != null) {
			managers.add(manager);
		}
	}

	@Override
	public ProgramClassTypeInfoManager getCurrentManager() {
		return currentManager;
	}

	private ClassTypeInfoManager getManager(Archive archive) {
		return managers.stream()
			.filter(FileArchiveClassTypeInfoManager.class::isInstance)
			.filter(m -> m.getName().equals(archive.getName()))
			.findFirst()
			.orElse(null);
	}

	@Override
	public void archiveClosed(Archive archive) {
		ClassTypeInfoManager manager = getManager(archive);
		if (manager != null) {
			managers.remove(manager);
		}
	}

	@Override
	public void archiveStateChanged(Archive archive) {
	}

	@Override
	public void archiveDataTypeManagerChanged(Archive archive) {
	}

	@Override
	public ArchivedClassTypeInfo getExternalClassTypeInfo(Program program, String mangled) {
		String[] libs = program.getExternalManager().getExternalLibraryNames();
		List<LibraryClassTypeInfoManager> libManagers = managers.stream()
			.filter(ProjectClassTypeInfoManager.class::isInstance)
			.map(ProjectClassTypeInfoManager.class::cast)
			.flatMap(m -> m.getAvailableManagers(libs))
			.collect(Collectors.toList());
		for (LibraryClassTypeInfoManager manager : libManagers) {
			ArchivedClassTypeInfo type = manager.getType(mangled);
			if (type != null) {
				return type;
			}
		}
		throw new UnresolvedClassTypeInfoException(program, mangled);
	}

	@Override
	public ArchivedClassTypeInfo getArchivedClassTypeInfo(String symbolName) {
		return getArchivedRttiData(ArchivedClassTypeInfo.class, symbolName);
	}

	@Override
	public ArchivedVtable getArchivedVtable(String symbolName) {
		return getArchivedRttiData(ArchivedVtable.class, symbolName);
	}

	private <T extends ArchivedRttiData> T getArchivedRttiData(Class<T> clazz, String symbolName) {
		return managers.stream()
			.filter(ProjectClassTypeInfoManager.class::isInstance)
			.map(ProjectClassTypeInfoManager.class::cast)
			.map(m -> m.getRttiData(clazz, symbolName))
			.filter(Objects::nonNull)
			.findFirst()
			.orElse(null);
	}
}

```

`src/main/java/cppclassanalyzer/plugin/CppClassAnalyzerPluginPackage.java`:

```java
package cppclassanalyzer.plugin;

import ghidra.framework.plugintool.util.PluginPackage;

import resources.ResourceManager;

/**
 * The {@link PluginPackage} for the {@value #NAME}
 */
public class CppClassAnalyzerPluginPackage extends PluginPackage {

	public static final String NAME = "Ghidra C++ Class Analyzer";
	private static final String DESCRIPTION = "These plugins are for analyzing C++ Classes.";

	public CppClassAnalyzerPluginPackage() {
		super(NAME, ResourceManager.loadImage("images/cpp_logo.png"), DESCRIPTION);
	}

}

```

`src/main/java/cppclassanalyzer/plugin/HeadlessClassTypeInfoManagerService.java`:

```java
package cppclassanalyzer.plugin;

import java.awt.HeadlessException;
import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

import ghidra.app.cmd.data.rtti.gcc.UnresolvedClassTypeInfoException;
import ghidra.app.plugin.core.datamgr.archive.ProjectArchive;
import ghidra.framework.model.DomainObjectClosedListener;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;

import cppclassanalyzer.data.ArchivedRttiData;
import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.manager.*;
import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.vtable.ArchivedVtable;
import cppclassanalyzer.database.SchemaMismatchException;
import cppclassanalyzer.decompiler.DecompilerAPI;
import cppclassanalyzer.service.ClassTypeInfoManagerService;
import cppclassanalyzer.service.RttiManagerProvider;
import docking.widgets.tree.GTree;

public final class HeadlessClassTypeInfoManagerService implements ClassTypeInfoManagerService {

	protected final DecompilerAPI api;
	protected final List<ClassTypeInfoManager> managers;
	protected ProgramClassTypeInfoManager currentManager;

	private static HeadlessClassTypeInfoManagerService instance;

	public static HeadlessClassTypeInfoManagerService getInstance() {
		if (instance == null) {
			instance = new HeadlessClassTypeInfoManagerService();
		}
		return instance;
	}

	private HeadlessClassTypeInfoManagerService() {
		this.api = new DecompilerAPI((PluginTool) null);
		this.managers = Collections.synchronizedList(new ArrayList<>());
	}

	protected ProgramClassTypeInfoManager programOpened(Program program) {
		try {
			RttiManagerProvider provider =
				ClassTypeInfoManagerService.getManagerProvider(program);
			if (provider != null) {
				ProgramClassTypeInfoManager manager = provider.getManager(program);
				managers.add(manager);
				program.addCloseListener(new ManagerRemover(program));
				return manager;
			}
		} catch (SchemaMismatchException e) {
			Msg.showError(this, null, "Ghidra C++ Class Analyzer", e.getMessage());
		} catch (UnsupportedOperationException e) {
			// do nothing
		}
		return null;
	}

	protected void programClosed(Program program) {
		ClassTypeInfoManager man = getManager(program);
		if (man != null) {
			managers.remove(getManager(program));
		}
	}

	protected void programActivated(Program program) {
		currentManager = getManager(program);
	}

	protected void programDeactivated(Program program) {
		ClassTypeInfoManager manager = getManager(program);
		if (currentManager != null && currentManager.equals(manager)) {
			currentManager = null;
		}
	}

	@Override
	public List<ClassTypeInfoManager> getManagers() {
		return Collections.unmodifiableList(managers);
	}

	@Override
	public void closeManager(ClassTypeInfoManager manager) {
		if (manager instanceof FileArchiveClassTypeInfoManager) {
			((FileArchiveClassTypeInfoManager) manager).close();
		}
	}

	@Override
	public void openArchive(File file, boolean updateable) throws IOException {
		ClassTypeInfoManager manager =
			ArchiveClassTypeInfoManager.open(this, file, updateable);
		managers.add(manager);
	}

	@Override
	public void createArchive(File file) throws IOException {
		ClassTypeInfoManager manager = ArchiveClassTypeInfoManager.createManager(this, file);
		managers.add(manager);
	}

	@Override
	public DecompilerAPI getDecompilerAPI(Program program) {
		api.setProgram(program);
		return api;
	}

	public List<ClassTypeInfoManager> getManagersByName(List<String> names) {
		return managers.stream()
			.filter(m -> names.contains(m.getName()))
			.collect(Collectors.toList());
	}

	public boolean hasManager(ProjectArchive archive) {
		String name = archive.getName();
		return managers.stream()
			.filter(ProjectClassTypeInfoManager.class::isInstance)
			.map(ClassTypeInfoManager::getName)
			.anyMatch(name::equals);
	}

	public void openProjectArchive(ProjectArchive archive) throws IOException {
		ClassTypeInfoManager manager = ProjectClassTypeInfoManager.open(this, archive);
		projectManagerOpened(manager);
	}

	private void projectManagerOpened(ClassTypeInfoManager manager) {
		managers.add(manager);
	}

	@Override
	public ProgramClassTypeInfoManager getManager(Program program) {
		ProgramClassTypeInfoManager manager = managers.stream()
			.filter(ProgramClassTypeInfoManager.class::isInstance)
			.map(ProgramClassTypeInfoManager.class::cast)
			.filter(m -> m.getProgram().equals(program))
			.findAny()
			.orElse(null);
		if (manager == null) {
			manager = programOpened(program);
		}
		return manager;
	}

	@Override
	public ProgramClassTypeInfoManager getCurrentManager() {
		return currentManager;
	}

	@Override
	public ArchivedClassTypeInfo getExternalClassTypeInfo(Program program, String mangled) {
		String[] libs = program.getExternalManager().getExternalLibraryNames();
		List<LibraryClassTypeInfoManager> libManagers = managers.stream()
			.filter(ProjectClassTypeInfoManager.class::isInstance)
			.map(ProjectClassTypeInfoManager.class::cast)
			.flatMap(m -> m.getAvailableManagers(libs))
			.collect(Collectors.toList());
		for (LibraryClassTypeInfoManager manager : libManagers) {
			ArchivedClassTypeInfo type = manager.getType(mangled);
			if (type != null) {
				return type;
			}
		}
		throw new UnresolvedClassTypeInfoException(program, mangled);
	}

	@Override
	public ArchivedClassTypeInfo getArchivedClassTypeInfo(String symbolName) {
		return getArchivedRttiData(ArchivedClassTypeInfo.class, symbolName);
	}

	@Override
	public ArchivedVtable getArchivedVtable(String symbolName) {
		return getArchivedRttiData(ArchivedVtable.class, symbolName);
	}

	private <T extends ArchivedRttiData> T getArchivedRttiData(Class<T> clazz, String symbolName) {
		return managers.stream()
			.filter(ProjectClassTypeInfoManager.class::isInstance)
			.map(ProjectClassTypeInfoManager.class::cast)
			.map(m -> m.getRttiData(clazz, symbolName))
			.filter(Objects::nonNull)
			.findFirst()
			.orElse(null);
	}

	@Override
	public GTree getTree() {
		throw new HeadlessException();
	}

	private class ManagerRemover implements DomainObjectClosedListener {

		private final Program program;

		ManagerRemover(Program program) {
			this.program = program;
		}

		@Override
		public void domainObjectClosed() {
			programClosed(program);
		}
	}

}

```

`src/main/java/cppclassanalyzer/plugin/TypeInfoArchiveChangeRecord.java`:

```java
package cppclassanalyzer.plugin;

import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;

public class TypeInfoArchiveChangeRecord {

	private final ChangeType changeType;
	private final ClassTypeInfoDB type;

	public TypeInfoArchiveChangeRecord(ChangeType changeType, ClassTypeInfoDB type) {
		this.changeType = changeType;
		this.type = type;
	}

	public ChangeType getChangeType() {
		return changeType;
	}

	public ClassTypeInfoDB getType() {
		return type;
	}

	public static enum ChangeType {
		TYPE_ADDED,
		TYPE_REMOVED,
		TYPE_UPDATED
	};
}

```

`src/main/java/cppclassanalyzer/plugin/TypeInfoManagerListener.java`:

```java
package cppclassanalyzer.plugin;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;

/**
 * Listener interface for {@link ClassTypeInfoManager}
 */
public interface TypeInfoManagerListener {

	/**
	 * Invoked when a type has been added to a manager
	 * @param type the added type
	 */
	void typeAdded(ClassTypeInfoDB type);

	/**
	 * Invoked when a type has been removed to a manager
	 * @param type the removed type
	 */
	void typeRemoved(ClassTypeInfoDB type);

	/**
	 * Invoked when a type has been updated
	 * @param type the updated type
	 */
	void typeUpdated(ClassTypeInfoDB type);
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/TypeInfoArchiveGTree.java`:

```java
package cppclassanalyzer.plugin.typemgr;

import java.util.*;
import java.util.stream.Collectors;

import javax.swing.Icon;
import javax.swing.tree.TreePath;

import cppclassanalyzer.plugin.typemgr.node.ProjectArchiveTypeInfoNode;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoArchiveNode;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoNode;
import ghidra.app.plugin.core.datamgr.util.DataTypeUtils;
import ghidra.util.exception.AssertException;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.manager.LibraryClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;
import cppclassanalyzer.plugin.TypeInfoManagerListener;
import docking.widgets.tree.GTree;
import docking.widgets.tree.GTreeNode;
import docking.widgets.tree.support.GTreeDragNDropHandler;

public final class TypeInfoArchiveGTree extends GTree implements TypeInfoManagerListener {

	private static final long serialVersionUID = 1L;

	private final TypeInfoDragNDropHandler dropHandler;
	private final ClassTypeInfoManagerPlugin plugin;

	public TypeInfoArchiveGTree(ClassTypeInfoManagerPlugin plugin) {
		super(new TypeInfoArchiveGTreeRootNode());
		this.dropHandler = new TypeInfoDragNDropHandler();
		this.plugin = plugin;

		// temporarily disable filter
		setFilteringEnabled(false);
	}

	private TypeInfoArchiveGTreeRootNode getRoot() {
		return (TypeInfoArchiveGTreeRootNode) getModelRoot();
	}

	public ClassTypeInfoManagerPlugin getPlugin() {
		return plugin;
	}

	@Override
	public GTreeDragNDropHandler getDragNDropHandler() {
		return dropHandler;
	}

	@Override
	public void setDragNDropHandler(GTreeDragNDropHandler dummy) {
	}

	private TypeInfoArchiveNode getManagerNode(ClassTypeInfoDB type) {
		return getRoot().getNode(type.getManager());
	}

	@Override
	public void typeAdded(ClassTypeInfoDB type) {
		getManagerNode(type).addNode(type);
	}

	@Override
	public void typeRemoved(ClassTypeInfoDB type) {
		GTreeNode node = getNode(type);
		if (node != null && node.getName().equals(type.getName())) {
			GTreeNode root = (GTreeNode) getManagerNode(type);
			root.removeNode(node);
		}
	}

	@Override
	public void typeUpdated(ClassTypeInfoDB type) {
		TypeInfoNode node = getNode(type);
		node.typeUpdated(type);
	}

	TypeInfoNode getNode(ClassTypeInfoDB type) {
		return getManagerNode(type).getNode(type);
	}

	public List<GTreeNode> getSelectedNodes() {
		TreePath[] selectionPaths = getSelectionPaths();
		if (selectionPaths == null || selectionPaths.length == 0) {
			return Collections.emptyList();
		}
		return Arrays.stream(selectionPaths)
			.map(TreePath::getLastPathComponent)
			.filter(GTreeNode.class::isInstance)
			.map(GTreeNode.class::cast)
			.collect(Collectors.toList());
	}

	private static class TypeInfoArchiveGTreeRootNode extends GTreeNode {

		@Override
		public String getName() {
			return "TypeInfo Archives";
		}

		@Override
		public Icon getIcon(boolean expanded) {
			return DataTypeUtils.getRootIcon(expanded);
		}

		@Override
		public String getToolTip() {
			return null;
		}

		@Override
		public boolean isLeaf() {
			return false;
		}

		@Override
		public void addNode(GTreeNode node) {
			if (isLoaded()) {
				List<GTreeNode> kids = children();
				int index = Collections.binarySearch(kids, node);
				if (index >= 0) {
					String msg = "Child node " + node.getName() + " already exists in " + getName();
					throw new AssertException(msg);
				}
				super.addNode(-(index + 1), node);
			}
		}

		TypeInfoArchiveNode getNode(ClassTypeInfoManager manager) {
			if (manager instanceof LibraryClassTypeInfoManager) {
				LibraryClassTypeInfoManager libMan = (LibraryClassTypeInfoManager) manager;
				ProjectArchiveTypeInfoNode node =
					(ProjectArchiveTypeInfoNode) getNode(libMan.getProjectManager());
				return (TypeInfoArchiveNode) node.getChild(manager.getName());
			}
			return (TypeInfoArchiveNode) getChild(manager.getName());
		}

	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/TypeInfoDragNDropHandler.java`:

```java
package cppclassanalyzer.plugin.typemgr;

import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.dnd.DnDConstants;
import java.util.List;

import javax.help.UnsupportedOperationException;

import cppclassanalyzer.plugin.typemgr.node.TypeInfoArchiveNode;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoRootNode;

import cppclassanalyzer.data.manager.ProjectClassTypeInfoManager;
import docking.dnd.GenericDataFlavor;
import docking.widgets.tree.GTreeNode;
import docking.widgets.tree.support.GTreeDragNDropHandler;

public final class TypeInfoDragNDropHandler implements GTreeDragNDropHandler {

	private static final DataFlavor FLAVOR = new GenericDataFlavor(
		DataFlavor.javaJVMLocalObjectMimeType +
		"; class=java.util.List", "Local list of Drag/Drop TypeInfoTreeNode objects");

	@Override
	public DataFlavor[] getSupportedDataFlavors(List<GTreeNode> transferNodes) {
		boolean acceptable = transferNodes.stream()
			.allMatch(TypeInfoArchiveNode.class::isInstance);
		return acceptable ? new DataFlavor[] { FLAVOR } : new DataFlavor[0];
	}

	@Override
	public Object getTransferData(List<GTreeNode> transferNodes, DataFlavor flavor)
			throws UnsupportedFlavorException {
		if (flavor != FLAVOR) {
			throw new UnsupportedFlavorException(flavor);
		}
		return transferNodes;
	}

	@Override
	public boolean isStartDragOk(List<GTreeNode> dragUserData, int dragAction) {
		return true;
	}

	@Override
	public int getSupportedDragActions() {
		return DnDConstants.ACTION_COPY_OR_MOVE;
	}

	@Override
	public boolean isDropSiteOk(GTreeNode node, DataFlavor[] flavors, int dropAction) {
		if (node == null || !((node instanceof TypeInfoRootNode))) {
			return false;
		}
		if (flavors.length != 1 || flavors[0] != FLAVOR) {
			return false;
		}
		TypeInfoRootNode root = (TypeInfoRootNode) node;
		return root.getTypeManager() instanceof ProjectClassTypeInfoManager;
	}

	@Override
	public void drop(GTreeNode destUserData, Transferable transferable, int dropAction) {
		throw new UnsupportedOperationException("Old API call?");
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/TypeInfoTreeProvider.java`:

```java
package cppclassanalyzer.plugin.typemgr;

import java.awt.BorderLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import javax.swing.Icon;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.tree.TreePath;

import cppclassanalyzer.plugin.typemgr.action.TypeInfoArchiveHandler;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoNode;
import ghidra.framework.plugintool.ComponentProviderAdapter;
import ghidra.framework.plugintool.PluginTool;

import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;
import resources.ResourceManager;

public class TypeInfoTreeProvider extends ComponentProviderAdapter {

	private static final String NAME = "ClassTypeInfo Tree";
	private static Icon ICON = ResourceManager.loadImage("images/cpp_logo.png");

	private final ClassTypeInfoManagerPlugin plugin;
	private final TreeMouseListener mouseListener = new TreeMouseListener();
	private JPanel mainPanel;
	private TypeInfoArchiveGTree tree;

	public TypeInfoTreeProvider(PluginTool tool, ClassTypeInfoManagerPlugin plugin) {
		super(tool, NAME, plugin.getName());
		this.plugin = plugin;
		setIcon(ICON);
		buildProvider();
		addToToolbar();
		plugin.getTool().addComponentProvider(this, false);
		createActions();
	}

	@Override
	public JComponent getComponent() {
		return mainPanel;
	}

	public TypeInfoArchiveGTree getTree() {
		return tree;
	}

	private void buildProvider() {
		mainPanel = new JPanel(new BorderLayout());

		tree = new TypeInfoArchiveGTree(plugin);
		mainPanel.add(tree, BorderLayout.CENTER);
		tree.addMouseListener(mouseListener);

		tree.setRootVisible(true);
	}

	private void createActions() {
		// TODO things like graph n stuff
		TypeInfoArchiveHandler handler = new TypeInfoArchiveHandler(plugin);
		addLocalAction(handler.getOpenAction());
		addLocalAction(handler.getCreateAction());
		addLocalAction(handler.getCloseAction());
		addLocalAction(handler.getOpenForEditAction());
		addLocalAction(handler.getSaveAction());
		addLocalAction(handler.getCreateProjectArchiveAction());
		addLocalAction(handler.getOpenProjectArchiveAction());
		addLocalAction(handler.getCopyArchiveAction());
		addLocalAction(handler.getPasteArchiveAction());
		addLocalAction(handler.getEditDataTypeAction());
		addLocalAction(handler.getRenameAction());
		addLocalAction(handler.getGoToVtableAction());
	}

	public void dispose() {
		mainPanel.removeAll();
	}

	private void goToTypeInfo() {

		TreePath[] paths = tree.getSelectionPaths();
		if (paths == null || paths.length != 1) {
			return;
		}

		Object object = paths[0].getLastPathComponent();
		if (!(object instanceof TypeInfoNode)) {
			return;
		}
		plugin.goTo((TypeInfoNode) object);
	}

	private class TreeMouseListener extends MouseAdapter {

		@Override
		public void mouseClicked(MouseEvent e) {
			if (!e.isConsumed() && SwingUtilities.isLeftMouseButton(e)) {
				if (e.getClickCount() == 2) {
					e.consume();
					goToTypeInfo();
				}
			}
		}
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/AbstractArchiveClipboardAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.Transferable;
import java.awt.event.InputEvent;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import javax.swing.KeyStroke;

import cppclassanalyzer.plugin.typemgr.TypeInfoArchiveGTree;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoArchiveNode;

import docking.ActionContext;
import docking.KeyBindingPrecedence;
import docking.action.KeyBindingData;
import docking.widgets.tree.GTree;
import docking.widgets.tree.GTreeNode;
import docking.widgets.tree.support.GTreeNodeTransferable;
import docking.widgets.tree.support.GTreeTransferHandler;

abstract class AbstractArchiveClipboardAction extends AbstractFileArchivePopupAction {

	private final Clipboard clipboard;

	AbstractArchiveClipboardAction(String name, int keyCode, TypeInfoArchiveHandler handler) {
		super(name, handler);
		this.clipboard = handler.getPlugin().getClipboard();
		setPopupMenu();
		setKeyBindingData(new KeyBindingData(KeyStroke.getKeyStroke(keyCode,
			InputEvent.CTRL_DOWN_MASK), KeyBindingPrecedence.ActionMapLevel));
	}

	@Override
	final MenuGroupType getGroup() {
		return MenuGroupType.EDIT;
	}

	final List<GTreeNode> getSelectedRootTreeNodes(ActionContext context) {
		return getTree()
			.getSelectedNodes()
			.stream()
			.filter(TypeInfoArchiveNode.class::isInstance)
			.map(GTreeNode.class::cast)
			.collect(Collectors.toList());
	}

	final void setClipboardContents(GTree gTree, List<GTreeNode> nodes) {
		GTreeTransferHandler dragNDropHandler = gTree.getDragNDropHandler();
		Transferable contents = new GTreeNodeTransferable(dragNDropHandler, nodes);
		clipboard.setContents(contents, DummyClipboardOwner.DUMMY);
	}

	final List<GTreeNode> getClipboardContents() {
		Transferable contents = clipboard.getContents(this);
		if (contents instanceof GTreeNodeTransferable) {
			return ((GTreeNodeTransferable) contents).getAllData();
		}
		return Collections.emptyList();
	}

	final TypeInfoArchiveGTree getTree() {
		return getHandler().getTree();
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/AbstractFileArchivePopupAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import javax.swing.tree.TreePath;

import cppclassanalyzer.plugin.typemgr.TypeInfoArchiveGTree;
import cppclassanalyzer.plugin.typemgr.TypeInfoTreeProvider;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoArchiveNode;
import ghidra.util.exception.AssertException;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.manager.FileArchiveClassTypeInfoManager;
import cppclassanalyzer.data.manager.LibraryClassTypeInfoManager;
import docking.ActionContext;
import docking.widgets.tree.GTreeNode;

abstract class AbstractFileArchivePopupAction extends AbstractTypeMgrAction {

	AbstractFileArchivePopupAction(String name, TypeInfoArchiveHandler handler) {
		super(name, handler);
		setPopupMenu();
	}

	@Override
	public boolean isAddToPopup(ActionContext context) {
		Object provider = context.getComponentProvider();
		if (!(provider instanceof TypeInfoTreeProvider)) {
			return false;
		}
		TypeInfoArchiveGTree tree = ((TypeInfoTreeProvider) provider).getTree();
		TreePath[] selectionPaths = tree.getSelectionPaths();

		if (selectionPaths.length == 0) {
			return false;
		}

		for (TreePath path : selectionPaths) {
			GTreeNode node = (GTreeNode) path.getLastPathComponent();
			if (!(node instanceof TypeInfoArchiveNode)) {
				return false;
			}
			if (((TypeInfoArchiveNode) node).isProgramNode()) {
				return false;
			}
		}
		return true;
	}

	@Override
	public boolean isEnabledForContext(ActionContext context) {
		return isAddToPopup(context);
	}

	@Override
	final FileArchiveClassTypeInfoManager getManager(ActionContext context) {
		ClassTypeInfoManager manager = super.getManager(context);
		if (manager == null) {
			return null;
		}
		if (manager instanceof FileArchiveClassTypeInfoManager) {
			return (FileArchiveClassTypeInfoManager) manager;
		}
		if (manager instanceof LibraryClassTypeInfoManager) {
			return ((LibraryClassTypeInfoManager) manager).getProjectManager();
		}
		throw new AssertException(
			"Unexpected ClassTypeInfoManager "+manager.getClass().getSimpleName());
	}

	@Override
	final TypeInfoArchiveNode getSelectedNode(ActionContext context) {
		return getHandler().getArchiveNode(context);
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/AbstractTypeInfoNodeAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import cppclassanalyzer.plugin.typemgr.node.TypeInfoNode;

import docking.ActionContext;

abstract class AbstractTypeInfoNodeAction extends AbstractTypeMgrAction {

	AbstractTypeInfoNodeAction(String name, TypeInfoArchiveHandler handler) {
		super(name, handler);
		setPopupMenu();
	}

	@Override
	final TypeInfoNode getSelectedNode(ActionContext context) {
		return getHandler().getTypeInfoNode(context);
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/AbstractTypeMgrAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import javax.swing.Icon;

import ghidra.app.plugin.core.datamgr.archive.DataTypeManagerHandler;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoArchiveNode;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoTreeNode;

import cppclassanalyzer.data.ClassTypeInfoManager;
import docking.ActionContext;
import docking.action.DockingAction;
import docking.action.MenuData;

abstract class AbstractTypeMgrAction extends DockingAction {

	private final TypeInfoArchiveHandler handler;
	private final MenuData data;

	AbstractTypeMgrAction(String name, TypeInfoArchiveHandler handler) {
		super(name, handler.getPlugin().getName());
		this.handler = handler;
		this.data = new MenuData(
			new String[] {getName()}, getIcon(), getGroup().displayName);
		setEnabled(true);
	}

	final void setPopupMenu() {
		setPopupMenuData(data);
	}

	final void setMenuBar() {
		setMenuBarData(data);
	}

	final DataTypeManagerHandler getDataTypeManagerHandler() {
		return handler.getPlugin().getDataTypeManagerHandler();
	}

	abstract MenuGroupType getGroup();

	Icon getIcon() {
		return null;
	}

	TypeInfoArchiveHandler getHandler() {
		return handler;
	}

	ClassTypeInfoManager getManager(ActionContext context) {
		TypeInfoArchiveNode node = handler.getArchiveNode(context);
		return node != null ? node.getTypeManager() : null;
	}

	TypeInfoTreeNode getSelectedNode(ActionContext context) {
		return handler.getTreeNode(context);
	}

	static enum MenuGroupType {
		FILE("File"),
		EDIT("Edit"),
		ARCHIVE("Archive"),
		TYPEINFO("TypeInfo");

		private final String displayName;

		MenuGroupType(String displayName) {
			this.displayName = displayName;
		}
	};
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/ArchiveFileChooser.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import java.awt.Component;
import java.io.File;

import ghidra.framework.GenericRunInfo;

import docking.widgets.OptionDialog;
import docking.widgets.filechooser.GhidraFileChooser;

final class ArchiveFileChooser extends GhidraFileChooser {

	private final Component component;

	ArchiveFileChooser(TypeInfoArchiveHandler handler) {
		super(handler.getProvider().getComponent());
		this.component = handler.getProvider().getComponent();

		setFileFilter(CppClassAnalyzerPreferences.EXTENSION_FILTER);
		setApproveButtonText("Save As");
		setApproveButtonToolTipText("Save As");
	}

	public File promptUserForFile() {
		File path = CppClassAnalyzerPreferences.getLastOpenedArchivePath();
		if (path.equals(CppClassAnalyzerPreferences.DEFAULT_ARCHIVE_PATH)) {
			// DEFAULT_ARCHIVE_PATH is read only
			path = new File(GenericRunInfo.getProjectsDirPath());
		}
		setCurrentDirectory(path);
		File file = getSelectedFile();
		if (file == null) {
			return null;
		}
		if (!file.getName().endsWith(CppClassAnalyzerPreferences.ARCHIVE_EXTENSION)) {
			file = new File(
				file.getAbsolutePath() + "." + CppClassAnalyzerPreferences.ARCHIVE_EXTENSION);
		}
		CppClassAnalyzerPreferences.setLastOpenedArchivePath(file);

		return file;
	}

	/**
	 * Prompts user to overwrite existing file
	 *
	 * @return true if overwrite is accepted
	 */
	public boolean promptForOverwrite() {
		String msg = "Do you want to overwrite existing file\n"
			+ getSelectedFile().getAbsolutePath();
		return OptionDialog.showYesNoDialogWithNoAsDefaultButton(component,
			"Overwrite Existing File?", msg) == OptionDialog.OPTION_ONE;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/CloseArchiveAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import docking.ActionContext;

final class CloseArchiveAction extends AbstractFileArchivePopupAction {

	CloseArchiveAction(TypeInfoArchiveHandler handler) {
		super("Close", handler);
	}

	@Override
	public final String getDescription() {
		return "Closes a type info archive";
	}

	@Override
	public boolean isAddToPopup(ActionContext context) {
		if (super.isAddToPopup(context)) {
			return !(getManager(context) instanceof ProgramClassTypeInfoManager);
		}
		return false;
	}

	@Override
	public void actionPerformed(ActionContext context) {
		getHandler().getPlugin().closeManager(getManager(context));
	}

	@Override
	MenuGroupType getGroup() {
		return MenuGroupType.FILE;
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/CopyArchiveAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import java.awt.event.KeyEvent;

import docking.ActionContext;

final class CopyArchiveAction extends AbstractArchiveClipboardAction {

	public CopyArchiveAction(TypeInfoArchiveHandler handler) {
		super("Copy", KeyEvent.VK_C, handler);
	}

	@Override
	public final String getDescription() {
		return "Copy Archive";
	}

	@Override
	public boolean isAddToPopup(ActionContext context) {
		return !getSelectedRootTreeNodes(context).isEmpty();
	}

	@Override
	public void actionPerformed(ActionContext context) {
		setClipboardContents(getTree(), getSelectedRootTreeNodes(context));
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/CppClassAnalyzerPreferences.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import java.io.File;
import java.util.List;

import ghidra.framework.Application;
import ghidra.framework.preferences.Preferences;
import ghidra.util.filechooser.ExtensionFileFilter;

import generic.jar.ResourceFile;
import utility.application.ApplicationLayout;

final class CppClassAnalyzerPreferences {

	private static final String EXTENSION_NAME = "Ghidra-Cpp-Class-Analyzer";
	static final String ARCHIVE_EXTENSION = "cdb";
	static final ExtensionFileFilter EXTENSION_FILTER =
		new ExtensionFileFilter(
			new String[]{ CppClassAnalyzerPreferences.ARCHIVE_EXTENSION },
			"Ghidra Type Info Archive Files");
	static final String LAST_OPENED_TYPE_INFO_ARCHIVE_PATH = "LastOpenedTypeInfoArchiveDirectory";
	static final String LAST_USER_TYPE_INFO_ARCHIVE_PATH = "LastUserTypeInfoArchiveDirectory";
	static final File DEFAULT_ARCHIVE_PATH =  new File(getExtensionRoot(), "data");

	private CppClassAnalyzerPreferences() {
	}

	static File getExtensionRoot() {
		ApplicationLayout layout = Application.getApplicationLayout();
		List<ResourceFile> paths = layout.getExtensionInstallationDirs();
		for (ResourceFile path : paths) {
			File f = new File(path.getFile(false), EXTENSION_NAME);
			if (f.exists()) {
				return f;
			}
		}
		return null;
	}

	static File getLastOpenedArchivePath() {
		String path = Preferences.getProperty(LAST_OPENED_TYPE_INFO_ARCHIVE_PATH);
		if (path != null) {
			return new File(path);
		}
		return DEFAULT_ARCHIVE_PATH;
	}

	static void setLastOpenedArchivePath(File path) {
		Preferences.setProperty(LAST_OPENED_TYPE_INFO_ARCHIVE_PATH, path.getAbsolutePath());
		Preferences.store();
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/CreateArchiveAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import java.io.File;
import java.io.IOException;

import ghidra.util.Msg;

import docking.ActionContext;

final class CreateArchiveAction extends AbstractTypeMgrAction {

	CreateArchiveAction(TypeInfoArchiveHandler handler) {
		super("Create File Archive", handler);
		setMenuBar();
	}

	@Override
	public String getDescription() {
		return "Creates a new type info archive";
	}

	@Override
	public void actionPerformed(ActionContext context) {
		ArchiveFileChooser fileChooser = getHandler().getFileChooser();
		fileChooser.setApproveButtonText("Create Archive");
		fileChooser.setApproveButtonToolTipText("Create Archive");
		fileChooser.setTitle("Create Archive");

		File file = fileChooser.promptUserForFile();
		if (file == null) {
			return;
		}

		if (file.exists()) {
			if (!fileChooser.promptForOverwrite()) {
				return;
			}
			file.delete();
		}
		try {
			getHandler().getPlugin().createArchive(file);
		} catch (IOException e) {
			Msg.error(this, e);
		}
	}

	@Override
	MenuGroupType getGroup() {
		return MenuGroupType.ARCHIVE;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/CreateProjectArchiveAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import java.io.IOException;

import ghidra.app.plugin.core.datamgr.archive.ProjectArchive;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.CancelledException;

import cppclassanalyzer.data.manager.ProjectClassTypeInfoManager;
import docking.ActionContext;

final class CreateProjectArchiveAction extends AbstractTypeMgrAction {

	CreateProjectArchiveAction(TypeInfoArchiveHandler handler) {
		super("Create Project Archive", handler);
		setMenuBar();
	}

	@Override
	public String getDescription() {
		return "Creates a new project type info archive";
	}

	@Override
	public void actionPerformed(ActionContext context) {
		try {
			ProjectArchive archive =
				(ProjectArchive) getDataTypeManagerHandler().createProjectArchive();
			ProjectClassTypeInfoManager.init((ProjectArchive) archive);
			getDataTypeManagerHandler().save(archive.getDomainObject());
			getHandler().getPlugin().archiveOpened(archive);
		} catch(IOException e) {
			throw new AssertException(e);
		} catch (CancelledException e) {
		}
	}

	@Override
	MenuGroupType getGroup() {
		return MenuGroupType.ARCHIVE;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/DummyClipboardOwner.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.ClipboardOwner;
import java.awt.datatransfer.Transferable;

final class DummyClipboardOwner implements ClipboardOwner {

	static final DummyClipboardOwner DUMMY = new DummyClipboardOwner();

	private DummyClipboardOwner() {
	}

	@Override
	public void lostOwnership(Clipboard clipboard, Transferable contents) {
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/EditDataTypeAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import cppclassanalyzer.plugin.typemgr.node.TypeInfoNode;

import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import docking.ActionContext;

final class EditDataTypeAction extends AbstractTypeInfoNodeAction {

	EditDataTypeAction(TypeInfoArchiveHandler handler) {
		super("Edit", handler);
	}

	@Override
	public final String getDescription() {
		return "Edit DataType";
	}

	@Override
	public boolean isEnabledForContext(ActionContext context) {
		TypeInfoNode node = getSelectedNode(context);
		if (node != null) {
			ClassTypeInfoDB type = node.getType();
			return type.isModifiable() && type.getClassDataTypeId() != ClassTypeInfoDB.INVALID_KEY;
		}
		return false;
	}

	@Override
	public void actionPerformed(ActionContext context) {
		ClassTypeInfoDB type = getSelectedNode(context).getType();
		getHandler().getPlugin().getDataTypeManagerPlugin().edit(type.getClassDataType());
	}

	@Override
	MenuGroupType getGroup() {
		return MenuGroupType.EDIT;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/GoToVtableAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import ghidra.app.cmd.data.rtti.Vtable;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoNode;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoTreeNode;
import docking.ActionContext;

final class GoToVtableAction extends AbstractTypeInfoNodeAction {

	GoToVtableAction(TypeInfoArchiveHandler handler) {
		super("Goto Vtable", handler);
	}

	@Override
	MenuGroupType getGroup() {
		return MenuGroupType.TYPEINFO;
	}

	@Override
	public boolean isEnabledForContext(ActionContext context) {
		TypeInfoTreeNode node = getSelectedNode(context);
		if (node instanceof TypeInfoNode) {
			ClassTypeInfoDB type = ((TypeInfoNode) node).getType();
			return type.getManager() instanceof ProgramClassTypeInfoManager
				&& Vtable.isValid(type.getVtable());
		}
		return false;
	}

	@Override
	public void actionPerformed(ActionContext context) {
		TypeInfoNode node = (TypeInfoNode) getSelectedNode(context);
		Vtable vtable = node.getType().getVtable();
		getHandler().getPlugin().goTo(vtable.getAddress());
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/OpenArchiveAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import java.io.File;
import java.io.IOException;

import ghidra.app.plugin.core.datamgr.archive.DuplicateIdException;
import ghidra.util.Msg;

import docking.ActionContext;
import docking.widgets.filechooser.GhidraFileChooser;

final class OpenArchiveAction extends AbstractTypeMgrAction {

	OpenArchiveAction(TypeInfoArchiveHandler handler) {
		super("Open File Archive", handler);
		setMenuBar();
	}

	@Override
	public String getDescription() {
		return "Opens a type info archive";
	}

	@Override
	public void actionPerformed(ActionContext context) {
		GhidraFileChooser fileChooser = new GhidraFileChooser(getHandler().getTree());

		File archiveDirectory = CppClassAnalyzerPreferences.getLastOpenedArchivePath();
		fileChooser.setFileFilter(CppClassAnalyzerPreferences.EXTENSION_FILTER);
		fileChooser.setCurrentDirectory(archiveDirectory);
		fileChooser.setApproveButtonText("Open Type Info Archive File");
		fileChooser.setApproveButtonToolTipText("Open Type Info Archive File");

		File file = fileChooser.getSelectedFile();
		if (file == null || !file.exists()) {
			return;
		}

		File lastOpenedDir = file.getParentFile();
		CppClassAnalyzerPreferences.setLastOpenedArchivePath(lastOpenedDir);

		try {
			getHandler().getPlugin().openArchive(file);
		} catch (IOException | DuplicateIdException e) {
			Msg.error(this, e);
		}
	}

	@Override
	MenuGroupType getGroup() {
		return MenuGroupType.ARCHIVE;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/OpenForEditAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import java.io.File;
import java.io.IOException;

import cppclassanalyzer.data.manager.FileArchiveClassTypeInfoManager;
import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;

import ghidra.util.Msg;

import docking.ActionContext;

final class OpenForEditAction extends AbstractFileArchivePopupAction {

	OpenForEditAction(TypeInfoArchiveHandler handler) {
		super("Open for editing", handler);
	}

	@Override
	public String getDescription() {
		return "Opens an existing type info archive for editing";
	}

	@Override
	public boolean isAddToPopup(ActionContext context) {
		if (super.isAddToPopup(context)) {
			return !getManager(context).isModifiable();
		}
		return false;
	}

	@Override
	public boolean isEnabledForContext(ActionContext context) {
		if (super.isEnabledForContext(context)) {
			return !getManager(context).isModifiable();
		}
		return false;
	}

	@Override
	public void actionPerformed(ActionContext context) {
		FileArchiveClassTypeInfoManager manager = getManager(context);
		File file = new File(manager.getPath());
		ClassTypeInfoManagerPlugin plugin = getHandler().getPlugin();
		plugin.closeManager(manager);
		try {
			plugin.openArchive(file, true);
		} catch (IOException e) {
			Msg.showError(plugin, null, "Failed to open archive for editing", e);
		}
	}

	@Override
	MenuGroupType getGroup() {
		return MenuGroupType.FILE;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/OpenProjectArchiveAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import docking.ActionContext;

final class OpenProjectArchiveAction extends AbstractTypeMgrAction {

	OpenProjectArchiveAction(TypeInfoArchiveHandler handler) {
		super("Open Project Archive", handler);
		setMenuBar();
	}

	@Override
	public String getDescription() {
		return "Opens an existing project type info archive";
	}

	@Override
	public void actionPerformed(ActionContext context) {
		getHandler().getPlugin().getDataTypeManagerPlugin().openProjectDataTypeArchive();
	}

	@Override
	MenuGroupType getGroup() {
		return MenuGroupType.ARCHIVE;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/PasteArchiveAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import java.awt.event.KeyEvent;
import java.util.List;
import java.util.stream.Collectors;

import cppclassanalyzer.plugin.typemgr.node.TypeInfoArchiveNode;
import ghidra.framework.cmd.BackgroundCommand;
import ghidra.framework.model.DomainObject;
import ghidra.framework.plugintool.PluginTool;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.manager.ProjectClassTypeInfoManager;
import docking.ActionContext;

final class PasteArchiveAction extends AbstractArchiveClipboardAction {

	PasteArchiveAction(TypeInfoArchiveHandler handler) {
		super("Paste", KeyEvent.VK_V, handler);
	}

	@Override
	public final String getDescription() {
		return "Paste Archive";
	}

	@Override
	public boolean isAddToPopup(ActionContext context) {
		return getSelectedRootTreeNodes(context)
				.stream()
				.map(TypeInfoArchiveNode.class::cast)
				.map(TypeInfoArchiveNode::getTypeManager)
				.filter(ProjectClassTypeInfoManager.class::isInstance)
				.count() == 1;
	}

	private ProjectClassTypeInfoManager getSelectedManager(ActionContext context) {
		TypeInfoArchiveNode node = (TypeInfoArchiveNode) getSelectedRootTreeNodes(context).get(0);
		return (ProjectClassTypeInfoManager) node.getTypeManager();
	}

	@Override
	public void actionPerformed(ActionContext context) {
		PluginTool tool = getHandler().getPlugin().getTool();
		ProjectClassTypeInfoManager manager = getSelectedManager(context);
		List<ClassTypeInfoManager> srcManagers = getClipboardContents()
				.stream()
				.map(TypeInfoArchiveNode.class::cast)
				.map(TypeInfoArchiveNode::getTypeManager)
				.collect(Collectors.toList());
		PasteArchiveBackgroundCommand cmd =
			new PasteArchiveBackgroundCommand(manager, srcManagers);
		manager.executeCommand(tool, cmd);
	}

	private static final class PasteArchiveBackgroundCommand extends BackgroundCommand {

		private final ProjectClassTypeInfoManager manager;
		private final List<ClassTypeInfoManager> srcManagers;

		public PasteArchiveBackgroundCommand(ProjectClassTypeInfoManager manager,
				List<ClassTypeInfoManager> srcManagers) {
			super("Paste Archive", true, true, true);
			this.manager = manager;
			this.srcManagers = srcManagers;
		}

		@Override
		public boolean applyTo(DomainObject obj, TaskMonitor monitor) {
			try {
				manager.insert(srcManagers, monitor);
			} catch (CancelledException e) {
				setStatusMsg("Task cancelled");
				return false;
			}
			return true;
		}

	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/RenameManagerAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import javax.swing.KeyStroke;

import docking.ActionContext;
import docking.KeyBindingPrecedence;
import docking.action.KeyBindingData;
import docking.widgets.tree.GTreeNode;

public class RenameManagerAction extends AbstractFileArchivePopupAction {

    private static final KeyBindingData KEY_BINDING =
        new KeyBindingData(KeyStroke.getKeyStroke("F2"), KeyBindingPrecedence.ActionMapLevel);

	RenameManagerAction(TypeInfoArchiveHandler handler) {
        super("Rename", handler);
        setKeyBindingData(KEY_BINDING);
	}

	@Override
	MenuGroupType getGroup() {
		return MenuGroupType.EDIT;
    }

    @Override
    public boolean isAddToPopup(ActionContext context) {
        GTreeNode node = (GTreeNode) getSelectedNode(context);
        if (node != null) {
            return node.isEditable();
        }
        return false;
    }

	@Override
	public void actionPerformed(ActionContext context) {
        GTreeNode node = (GTreeNode) getSelectedNode(context);
		node.getTree().startEditing(node.getParent(), node.getName());
    }

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/SaveAction.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import docking.ActionContext;

final class SaveAction extends AbstractFileArchivePopupAction {

	SaveAction(TypeInfoArchiveHandler handler) {
		super("Save File Archive", handler);
	}

	@Override
	public String getDescription() {
		return "Saves the selected type info archive";
	}

	@Override
	public boolean isAddToPopup(ActionContext context) {
		if (super.isAddToPopup(context)) {
			return getManager(context).isModifiable();
		}
		return false;
	}

	@Override
	public boolean isEnabledForContext(ActionContext context) {
		if (super.isEnabledForContext(context)) {
			return getManager(context).isChanged();
		}
		return false;
	}

	@Override
	public void actionPerformed(ActionContext context) {
		getManager(context).save();
	}

	@Override
	MenuGroupType getGroup() {
		return MenuGroupType.FILE;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/action/TypeInfoArchiveHandler.java`:

```java
package cppclassanalyzer.plugin.typemgr.action;

import java.util.Arrays;
import java.util.stream.Stream;

import javax.swing.tree.TreePath;

import cppclassanalyzer.plugin.typemgr.TypeInfoArchiveGTree;
import cppclassanalyzer.plugin.typemgr.TypeInfoTreeProvider;
import cppclassanalyzer.plugin.typemgr.node.NamespacePathNode;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoArchiveNode;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoNode;
import cppclassanalyzer.plugin.typemgr.node.TypeInfoTreeNode;

import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;
import docking.ActionContext;
import docking.action.DockingAction;

public final class TypeInfoArchiveHandler {

	private final ClassTypeInfoManagerPlugin plugin;

	public TypeInfoArchiveHandler(ClassTypeInfoManagerPlugin plugin) {
		this.plugin = plugin;
	}

	TypeInfoTreeProvider getProvider() {
		return plugin.getProvider();
	}

	ClassTypeInfoManagerPlugin getPlugin() {
		return plugin;
	}

	ArchiveFileChooser getFileChooser() {
		return new ArchiveFileChooser(this);
	}

	TypeInfoArchiveGTree getTree() {
		return plugin.getProvider().getTree();
	}

	public DockingAction getCreateAction() {
		return new CreateArchiveAction(this);
	}

	public DockingAction getOpenAction() {
		return new OpenArchiveAction(this);
	}

	public DockingAction getCloseAction() {
		return new CloseArchiveAction(this);
	}

	public DockingAction getOpenForEditAction() {
		return new OpenForEditAction(this);
	}

	public DockingAction getSaveAction() {
		return new SaveAction(this);
	}

	public DockingAction getCreateProjectArchiveAction() {
		return new CreateProjectArchiveAction(this);
	}

	public DockingAction getOpenProjectArchiveAction() {
		return new OpenProjectArchiveAction(this);
	}

	public DockingAction getCopyArchiveAction() {
		return new CopyArchiveAction(this);
	}

	public DockingAction getPasteArchiveAction() {
		return new PasteArchiveAction(this);
	}

	public DockingAction getEditDataTypeAction() {
		return new EditDataTypeAction(this);
	}

	public DockingAction getRenameAction() {
		return new RenameManagerAction(this);
	}

	public DockingAction getGoToVtableAction() {
		return new GoToVtableAction(this);
	}

	private Stream<TypeInfoTreeNode> getSelectedNodes(ActionContext context) {
		TreePath[] selectionPaths = getTree().getSelectionPaths();
		if (selectionPaths.length == 0) {
			return Stream.empty();
		}
		return Arrays.stream(selectionPaths)
			.map(TreePath::getLastPathComponent)
			.filter(TypeInfoTreeNode.class::isInstance)
			.map(TypeInfoTreeNode.class::cast);
	}

	private <T extends TypeInfoTreeNode> T getSpecialNode(ActionContext context, Class<T> clazz) {
		return getSelectedNodes(context)
			.filter(clazz::isInstance)
			.map(clazz::cast)
			.findFirst()
			.orElse(null);
	}

	TypeInfoTreeNode getTreeNode(ActionContext context) {
		return getSelectedNodes(context)
			.findFirst()
			.orElse(null);
	}

	TypeInfoArchiveNode getArchiveNode(ActionContext context) {
		return getSpecialNode(context, TypeInfoArchiveNode.class);
	}

	TypeInfoNode getTypeInfoNode(ActionContext context) {
		return getSpecialNode(context, TypeInfoNode.class);
	}

	NamespacePathNode getNamespacePathNode(ActionContext context) {
		return getSpecialNode(context, NamespacePathNode.class);
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/dialog/OpenProjectArchiveDialog.java`:

```java
package cppclassanalyzer.plugin.typemgr.dialog;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import ghidra.app.plugin.core.datamgr.archive.DataTypeManagerHandler;
import ghidra.app.plugin.core.datamgr.archive.ProjectArchive;
import cppclassanalyzer.plugin.typemgr.filter.ProjectArchiveFilter;
import ghidra.app.util.HelpTopics;
import ghidra.framework.main.OpenVersionedFileDialog;
import ghidra.framework.model.DomainFile;
import ghidra.util.HelpLocation;
import ghidra.util.MessageType;

import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;

public class OpenProjectArchiveDialog extends OpenVersionedFileDialog {

	private static final HelpLocation HELP_LOCATION =
		new HelpLocation(HelpTopics.PROGRAM, "Open_File_Dialog");

	private final ClassTypeInfoManagerPlugin plugin;

	public OpenProjectArchiveDialog(ClassTypeInfoManagerPlugin plugin) {
		super(plugin.getTool(), "Open Project Data Type Archive", ProjectArchiveFilter.FILTER);
		this.plugin = plugin;
		setHelpLocation(HELP_LOCATION);
		addOkActionListener(new ProjectArchiveActionListener());
	}

	public void show() {
		plugin.getTool().showDialog(this);
	}

	private class ProjectArchiveActionListener implements ActionListener {

		@Override
		public void actionPerformed(ActionEvent event) {
			DomainFile domainFile = getDomainFile();
			if (domainFile == null) {
				setStatusText("Please choose a Project Data Type Archive");
			}
			else {
				close();
				DataTypeManagerHandler handler = plugin.getDataTypeManagerHandler();
				try {
					ProjectArchive archive = (ProjectArchive) handler.openArchive(
						domainFile, true, false, getTaskMonitorComponent());
					plugin.openProjectArchive(archive);
				} catch (Exception e) {
					setStatusText(e.getMessage(), MessageType.ERROR);
				}
			}
		}
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/filter/ProjectArchiveFilter.java`:

```java
package cppclassanalyzer.plugin.typemgr.filter;

import ghidra.framework.model.DomainFile;
import ghidra.framework.model.DomainFileFilter;
import ghidra.program.model.listing.DataTypeArchive;

public class ProjectArchiveFilter implements DomainFileFilter {

	public static final ProjectArchiveFilter FILTER = new ProjectArchiveFilter();

	private ProjectArchiveFilter() {
	}

	@Override
	public boolean accept(DomainFile df) {
		Class<?> c = df.getDomainObjectClass();
		return DataTypeArchive.class.isAssignableFrom(c);
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/icon/AbstractSwappedColorModel.java`:

```java
package cppclassanalyzer.plugin.typemgr.icon;

import java.awt.image.ColorModel;
import java.awt.image.Raster;

abstract class AbstractSwappedColorModel extends ColorModel {

	private final ColorModel original;

	AbstractSwappedColorModel(ColorModel original) {
		super(original.getPixelSize());
		this.original = original;
	}

	final ColorModel getOriginal() {
		return original;
	}

	@Override
	public final boolean isCompatibleRaster(Raster raster) {
		return original.isCompatibleRaster(raster);
	}

	@Override
	public int getRed(int pixel) {
		return original.getRed(pixel);
	}

	@Override
	public int getGreen(int pixel) {
		return original.getGreen(pixel);
	}

	@Override
	public int getBlue(int pixel) {
		return original.getBlue(pixel);
	}

	@Override
	public final int getAlpha(int pixel) {
		return original.getAlpha(pixel);
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/icon/BlueGreenSwappedColorModel.java`:

```java
package cppclassanalyzer.plugin.typemgr.icon;

import java.awt.image.ColorModel;

public final class BlueGreenSwappedColorModel extends AbstractSwappedColorModel {

	public BlueGreenSwappedColorModel(ColorModel original) {
		super(original);
	}

	@Override
	public int getGreen(int pixel) {
		return getOriginal().getBlue(pixel);
	}

	@Override
	public int getBlue(int pixel) {
		return getOriginal().getGreen(pixel);
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/icon/PurpleSwappedColorModel.java`:

```java
package cppclassanalyzer.plugin.typemgr.icon;

import java.awt.image.ColorModel;

public class PurpleSwappedColorModel extends AbstractSwappedColorModel {

	public PurpleSwappedColorModel(ColorModel original) {
		super(original);
	}

	@Override
	public int getRed(int pixel) {
		return getOriginal().getGreen(pixel);
	}

	@Override
	public int getGreen(int pixel) {
		return getOriginal().getRed(pixel);
	}

	@Override
	public int getBlue(int pixel) {
		return getOriginal().getGreen(pixel);
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/icon/RedGreenSwappedColorModel.java`:

```java
package cppclassanalyzer.plugin.typemgr.icon;

import java.awt.image.ColorModel;

public final class RedGreenSwappedColorModel extends AbstractSwappedColorModel {

	public RedGreenSwappedColorModel(ColorModel original) {
		super(original);
	}

	@Override
	public int getRed(int pixel) {
		return getOriginal().getGreen(pixel);
	}

	@Override
	public int getGreen(int pixel) {
		return getOriginal().getRed(pixel);
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/icon/YellowSwappedColorModel.java`:

```java
package cppclassanalyzer.plugin.typemgr.icon;

import java.awt.image.ColorModel;

public final class YellowSwappedColorModel extends AbstractSwappedColorModel {

	public YellowSwappedColorModel(ColorModel original) {
		super(original);
	}

	@Override
	public int getRed(int pixel) {
		return getOriginal().getGreen(pixel);
	}

	@Override
	public int getBlue(int pixel) {
		return getOriginal().getBlue(pixel);
	}
	
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/node/AbstractManagerNode.java`:

```java
package cppclassanalyzer.plugin.typemgr.node;

import javax.swing.Icon;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import docking.widgets.tree.GTree;
import docking.widgets.tree.GTreeNode;

abstract class AbstractManagerNode extends AbstractSortedNode implements TypeInfoArchiveNode {

	private final ClassTypeInfoManager manager;

	AbstractManagerNode(ClassTypeInfoManager manager) {
		this.manager = manager;
	}

	@Override
	public final GTreeNode clone() {
		return this;
	}

	@Override
	public final String getName() {
		return manager.getName();
	}

	@Override
	public final Icon getIcon(boolean expanded) {
		return manager.getIcon(expanded);
	}

	@Override
	public final boolean isLeaf() {
		return false;
	}

	@Override
	public final String getToolTip() {
		return null;
	}

	@Override
	public ClassTypeInfoManager getTypeManager() {
		return manager;
	}

	@Override
	public TypeInfoTreeNodeManager getManager() {
		return manager.getTreeNodeManager();
	}

	@Override
	public final boolean isProgramNode() {
		return getTypeManager() instanceof ProgramClassTypeInfoManager;
	}

	@Override
	public GTree getTree() {
		GTree tree = super.getTree();
		if (tree == null) {
			// circumvent race condition it'll get set eventually
			// all tasks requiring the tree end up in the end of the swing queue
			if (isProgramNode()) {
				ProgramClassTypeInfoManager manager =
					(ProgramClassTypeInfoManager) getTypeManager();
				tree = CppClassAnalyzerUtils.getService(manager.getProgram()).getTree();
			}
		}
		return tree;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/node/AbstractSingleManagerNode.java`:

```java
package cppclassanalyzer.plugin.typemgr.node;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import docking.widgets.tree.GTreeNode;

import java.util.*;

import ghidra.app.util.SymbolPath;
import ghidra.util.Msg;

abstract class AbstractSingleManagerNode extends AbstractManagerNode {

	private final Map<SymbolPath, GTreeNode> treePaths;

	AbstractSingleManagerNode(ClassTypeInfoManager manager) {
		super(manager);
		this.treePaths = Collections.synchronizedMap(new HashMap<>(manager.getTypeCount()));
	}

	@Override
	public final void addNode(ClassTypeInfoDB type) {
		getManager().createTypeNode(type);
	}

	@Override
	public final TypeInfoNode getNode(ClassTypeInfoDB type) {
		SymbolPath path = type.getSymbolPath();
		if (!treePaths.containsKey(path)) {
			Msg.warn(this, "Node for "+type.getName()+" not found");
			addNode(type);
		}
		GTreeNode node = treePaths.get(path);
		if (node instanceof NamespacePathNode) {
			node = new TypeInfoNode(type, (NamespacePathNode) node);
		}
		return (TypeInfoNode) node;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/node/AbstractSortedNode.java`:

```java
package cppclassanalyzer.plugin.typemgr.node;

import java.util.Collections;
import java.util.List;

import docking.widgets.tree.GTreeNode;

abstract class AbstractSortedNode extends GTreeNode {

	@Override
	public final void addNode(GTreeNode node) {
		int index;
		synchronized (this) {
			List<GTreeNode> kids = children();
			index = Collections.binarySearch(kids, node);
		}
		if (index >= 0) {
			//String msg = "Child node "+node.getName()+" already exists in "+getName();
			//throw new AssertException(msg);
			//TODO fixme
			return;
		}
		addNode(-(index + 1), node);
	}

	@Override
	public String getToolTip() {
		return null;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/node/NamespacePathNode.java`:

```java
package cppclassanalyzer.plugin.typemgr.node;

import javax.swing.Icon;

import ghidra.app.plugin.core.symboltree.nodes.NamespaceSymbolNode;

import docking.widgets.tree.GTreeNode;

public final class NamespacePathNode extends AbstractSortedNode implements TypeInfoTreeNode {

	private final TypeInfoTreeNodeManager manager;
	private final String name;

	NamespacePathNode(String name, TypeInfoTreeNodeManager manager) {
		this.name = name;
		this.manager = manager;
	}

	@Override
	public GTreeNode clone() {
		return this;
	}

	@Override
	public int compareTo(GTreeNode node) {
		if (node instanceof TypeInfoNode) {
			return -1;
		}
		return super.compareTo(node);
	}

	@Override
	public Icon getIcon(boolean expanded) {
		return NamespaceSymbolNode.NAMESPACE_ICON;
	}

	@Override
	public TypeInfoTreeNodeManager getManager() {
		return manager;
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public boolean isLeaf() {
		return false;
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/node/ProjectArchiveTypeInfoNode.java`:

```java
package cppclassanalyzer.plugin.typemgr.node;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.manager.LibraryClassTypeInfoManager;
import cppclassanalyzer.data.manager.ProjectClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import docking.widgets.tree.GTreeNode;

public final class ProjectArchiveTypeInfoNode extends AbstractManagerNode {

	public ProjectArchiveTypeInfoNode(ProjectClassTypeInfoManager manager) {
		super(manager);
	}

	public void addNode(LibraryClassTypeInfoManager libManager) {
		addNode(new TypeInfoLibraryNode(libManager));
	}

	@Override
	public void addNode(ClassTypeInfoDB type) {
		throw new UnsupportedOperationException();
	}

	@Override
	public TypeInfoNode getNode(ClassTypeInfoDB type) {
		throw new UnsupportedOperationException();
	}

	@Override
	public int compareTo(GTreeNode node) {
		if (node instanceof TypeInfoRootNode) {
			TypeInfoRootNode other = (TypeInfoRootNode) node;
			if (other.getTypeManager() instanceof ProgramClassTypeInfoManager) {
				return 1;
			}
			return -1;
		}
		return super.compareTo(node);
	}

	@Override
	public ProjectClassTypeInfoManager getTypeManager() {
		return (ProjectClassTypeInfoManager) super.getTypeManager();
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/node/TypeInfoArchiveNode.java`:

```java
package cppclassanalyzer.plugin.typemgr.node;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;

public interface TypeInfoArchiveNode extends TypeInfoTreeNode {

	ClassTypeInfoManager getTypeManager();
	void addNode(ClassTypeInfoDB type);

	TypeInfoNode getNode(ClassTypeInfoDB type);

	boolean isProgramNode();
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/node/TypeInfoLibraryNode.java`:

```java
package cppclassanalyzer.plugin.typemgr.node;

import ghidra.util.InvalidNameException;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;

import cppclassanalyzer.data.manager.LibraryClassTypeInfoManager;

public final class TypeInfoLibraryNode extends AbstractSingleManagerNode {

	TypeInfoLibraryNode(LibraryClassTypeInfoManager manager) {
		super(manager);
	}

	@Override
	public boolean isEditable() {
		return true;
	}

	@Override
	public LibraryClassTypeInfoManager getTypeManager() {
		return (LibraryClassTypeInfoManager) super.getTypeManager();
	}

	@Override
	public void valueChanged(Object newValue) {
		if (newValue instanceof String) {
			LibraryClassTypeInfoManager manager = getTypeManager();
			try {
				manager.rename((String) newValue);
			} catch (InvalidNameException | DuplicateNameException e) {
				Msg.error(this, e);
			}
		}
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/node/TypeInfoNode.java`:

```java
package cppclassanalyzer.plugin.typemgr.node;

import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.WritableRaster;
import java.util.*;
import java.util.stream.Collectors;

import javax.swing.Icon;
import javax.swing.ImageIcon;

import ghidra.program.model.address.Address;

import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.plugin.typemgr.icon.*;
import docking.widgets.tree.GTreeLazyNode;
import docking.widgets.tree.GTreeNode;
import generic.util.image.ImageUtils;
import resources.ResourceManager;
import resources.icons.DerivedImageIcon;

public final class TypeInfoNode extends GTreeLazyNode implements TypeInfoTreeNode {

	private final boolean isVirtual;
	private ClassTypeInfoDB type;
	private ModifierType modifier;
	private List<GTreeNode> nested = Collections.synchronizedList(new ArrayList<>());

	TypeInfoNode(ClassTypeInfoDB type) {
		this(type, (ModifierType) null);
	}

	private TypeInfoNode(ClassTypeInfoDB type, ModifierType modifier) {
		this.isVirtual = modifier == ModifierType.VIRTUAL;
		this.type = type;

		// will determine if type is also abstract
		this.modifier = getModifier();
	}

	// conversion constructor
	TypeInfoNode(ClassTypeInfoDB type, NamespacePathNode existing) {
		this.isVirtual = false;
		this.type = type;
		this.modifier = getModifier();
		List<GTreeNode> children = new ArrayList<>(existing.getChildren());
		children.forEach(existing::removeNode);
		GTreeNode parent = existing.getParent();
		parent.removeNode(existing);
		parent.addNode(this);
		nested.addAll(children);
		for (GTreeNode node : nested) {
			if (node instanceof TypeInfoNode) {
				((TypeInfoNode) node).modifier = ModifierType.NESTED;
			}
		}
	}

	private ModifierType getModifier() {
		if (modifier == ModifierType.NESTED) {
			return modifier;
		}
		if (type.isAbstract()) {
			return isVirtual ? ModifierType.VIRTUAL_ABSTRACT : ModifierType.ABSTRACT;
		}
		return isVirtual ? ModifierType.VIRTUAL : ModifierType.NORMAL;
	}

	@Override
	public GTreeNode clone() {
		return this;
	}

	@Override
	public int compareTo(GTreeNode node) {
		if (node instanceof NamespacePathNode) {
			return 1;
		}
		return super.compareTo(node);
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o instanceof TypeInfoNode) {
			return type.equals(((TypeInfoNode) o).type);
		}
		return false;
	}

	@Override
	public int hashCode() {
		return type.hashCode();
	}

	@Override
	public String toString() {
		return type.toString();
	}

	@Override
	public String getName() {
		return type.getName();
	}

	@Override
	public Icon getIcon(boolean expanded) {
		return modifier.getIcon();
	}

	@Override
	public String getToolTip() {
		return modifier.getModifier() + " " + type.getName();
	}

	@Override
	public boolean isLeaf() {
		return !type.hasParent();
	}

	@Override
	public void addNode(GTreeNode node) {
		if (node instanceof TypeInfoNode) {
			((TypeInfoNode) node).modifier = ModifierType.NESTED;
		}
		nested.add(node);
	}

	public ClassTypeInfoDB getType() {
		return type;
	}

	public void typeUpdated(ClassTypeInfoDB type) {
		this.type = type;
		modifier = getModifier();
	}

	public Address getAddress() {
		if (type instanceof ArchivedClassTypeInfo) {
			return null;
		}
		return type.getAddress();
	}

	@Override
	public TypeInfoTreeNodeManager getManager() {
		return type.getManager().getTreeNodeManager();
	}

	private static enum ModifierType {
		NORMAL,
		ABSTRACT,
		VIRTUAL,
		VIRTUAL_ABSTRACT,
		NESTED;

		private static String[] MODIFIERS = new String[]{
			"class",
			"abstract class",
			"virtual base class",
			"virtual abstract base class",
			"nested class"
		};

		private static final ImageIcon CLASS_ICON = ResourceManager.loadImage("images/class.png");

		private static Icon[] ICONS = new Icon[]{
			CLASS_ICON,
			createIcon(ABSTRACT),
			createIcon(VIRTUAL),
			createIcon(VIRTUAL_ABSTRACT),
			createIcon(NESTED)
		};

		private static Icon createIcon(ModifierType type) {
			BufferedImage image = ImageUtils.getBufferedImage(CLASS_ICON.getImage());
			ColorModel model = null;
			switch (type) {
				case ABSTRACT:
					model = new RedGreenSwappedColorModel(image.getColorModel());
					break;
				case NORMAL:
					break;
				case VIRTUAL:
					model = new BlueGreenSwappedColorModel(image.getColorModel());
					break;
				case VIRTUAL_ABSTRACT:
					model = new PurpleSwappedColorModel(image.getColorModel());
					break;
				case NESTED:
					model = new YellowSwappedColorModel(image.getColorModel());
					break;
				default:
					break;
			}
			WritableRaster raster = image.getRaster();
			Hashtable<String, Object> properties = getProperties(image);
			boolean preMultiplied = image.isAlphaPremultiplied();
			image = new BufferedImage(model, raster, preMultiplied, properties);
			return new DerivedImageIcon(type.name(), image);
		}

		private static Hashtable<String, Object> getProperties(BufferedImage image) {
			String[] names = image.getPropertyNames();
			if (names == null) {
				return null;
			}
			Hashtable<String, Object> table = new Hashtable<>(names.length);
			for (String name : names) {
				table.put(name, image.getProperty(name));
			}
			return table;
		}

		Icon getIcon() {
			return ICONS[ordinal()];
		}

		String getModifier() {
			return MODIFIERS[ordinal()];
		}
	}

	@Override
	protected List<GTreeNode> generateChildren() {
		List<GTreeNode> parents;
		Set<GTreeNode> vParents;
		synchronized (type.getManager()) {
			parents = Arrays.stream(type.getParentModels())
				.map(TypeInfoNode::new)
				.collect(Collectors.toList());
			vParents = type.getVirtualParents()
				.stream()
				.map(ClassTypeInfoDB.class::cast)
				.map(p -> new TypeInfoNode(p, ModifierType.VIRTUAL))
				.collect(Collectors.toCollection(LinkedHashSet::new));
		}
		vParents.addAll(parents);
		List<GTreeNode> result = new ArrayList<>(vParents);
		result.addAll(nested);
		result.sort(null);
		return result;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/node/TypeInfoRootNode.java`:

```java
package cppclassanalyzer.plugin.typemgr.node;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;

import docking.widgets.tree.GTreeNode;

public final class TypeInfoRootNode extends AbstractSingleManagerNode {

	public TypeInfoRootNode(ClassTypeInfoManager manager) {
		super(manager);
	}

	public void removeNode(ClassTypeInfoDB type) {
		GTreeNode node = (GTreeNode) getNode(type);
		if (node != null) {
			removeNode(node);
		}
	}

	@Override
	public int compareTo(GTreeNode node) {
		if (getTypeManager() instanceof ProgramClassTypeInfoManager) {
			return -1;
		}
		if (node instanceof ProjectArchiveTypeInfoNode) {
			return 1;
		}
		return super.compareTo(node);
	}

}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/node/TypeInfoTreeNode.java`:

```java
package cppclassanalyzer.plugin.typemgr.node;

import docking.widgets.tree.GTreeNode;

public interface TypeInfoTreeNode {

	public TypeInfoTreeNodeManager getManager();

	default GTreeNode getNode() {
		return (GTreeNode) this;
	}
}

```

`src/main/java/cppclassanalyzer/plugin/typemgr/node/TypeInfoTreeNodeManager.java`:

```java
package cppclassanalyzer.plugin.typemgr.node;

import ghidra.app.util.SymbolPath;
import ghidra.framework.model.DomainObject;
import ghidra.framework.model.DomainObjectChangedEvent;
import ghidra.framework.model.DomainObjectListener;
import ghidra.util.Disposable;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.manager.ArchiveClassTypeInfoManager;
import cppclassanalyzer.data.manager.LibraryClassTypeInfoManager;
import cppclassanalyzer.data.manager.ProjectClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;
import cppclassanalyzer.plugin.typemgr.TypeInfoArchiveGTree;
import docking.widgets.tree.GTree;
import docking.widgets.tree.GTreeNode;
import docking.widgets.tree.tasks.GTreeBulkTask;

public class TypeInfoTreeNodeManager implements DomainObjectListener, Disposable {

	private final AbstractManagerNode root;

	private TypeInfoTreeNodeManager(AbstractManagerNode root) {
		this.root = root;
		root.getTypeManager().addListener(this);
	}

	public TypeInfoTreeNodeManager(ClassTypeInfoManagerPlugin plugin,
			ProgramClassTypeInfoManager manager) {
		this(new TypeInfoRootNode(manager));
		plugin.getTree().getModelRoot().addNode(root);
	}

	public TypeInfoTreeNodeManager(ClassTypeInfoManagerPlugin plugin,
			ArchiveClassTypeInfoManager manager) {
		this(new TypeInfoRootNode(manager));
		plugin.getTree().getModelRoot().addNode(root);
	}

	public TypeInfoTreeNodeManager(ClassTypeInfoManagerPlugin plugin,
			LibraryClassTypeInfoManager manager) {
		this(new TypeInfoLibraryNode(manager));
		manager.getProjectManager().getTreeNodeManager().root.addNode(root);
	}

	public TypeInfoTreeNodeManager(ClassTypeInfoManagerPlugin plugin,
			ProjectClassTypeInfoManager manager) {
		this(new ProjectArchiveTypeInfoNode(manager));
		plugin.getTree().getModelRoot().addNode(root);
	}

	private GTreeNode getParentNode(SymbolPath paths) {
		if (paths.getParent() == null) {
			return root;
		}
		GTreeNode node = root;
		for (String path : paths.getParent().asList()) {
			GTreeNode child = node.getChild(path);
			if (child == null) {
				child = new NamespacePathNode(path, this);
				node.addNode(child);
			}
			node = child;
		}
		return node;
	}

	GTreeNode createTypeNode(ClassTypeInfoDB type) {
		SymbolPath path = type.getSymbolPath();
		GTreeNode parent = getParentNode(path);
		GTreeNode existing = parent.getChild(path.getName());
		if (existing instanceof NamespacePathNode) {
			return new TypeInfoNode(type, (NamespacePathNode) existing);
		}
		if (existing instanceof TypeInfoNode) {
			return existing;
		}
		GTreeNode node = new TypeInfoNode(type);
		parent.addNode(node);
		return node;
	}

	private TypeInfoArchiveGTree getTree() {
		return (TypeInfoArchiveGTree) root.getTree();
	}

	public GTreeNode getRoot() {
		return root;
	}

	public void generateTree() {
		ManagerLoaderBulkTask task = new ManagerLoaderBulkTask(getTree(), root);
		getTree().runBulkTask(task);
	}

	@Override
	public void domainObjectChanged(DomainObjectChangedEvent event) {
		if (getTree() == null || !getTree().isVisible()) {
			return;
		}

		if (event.containsEvent(DomainObject.DO_OBJECT_RESTORED)) {
			DomainObject source = (DomainObject) event.getSource();
			if (root.getName().equals(source.getName())) {
				root.removeAll();
				generateTree();
			}
		}
	}

	@Override
	public void dispose() {
		getTree().getModelRoot().removeNode(root);
		root.dispose();
	}

	private static class ManagerLoaderBulkTask extends GTreeBulkTask {

		private final TypeInfoArchiveNode node;

		ManagerLoaderBulkTask(GTree tree, TypeInfoArchiveNode node) {
			super(tree);
			this.node = node;
		}

		@Override
		public void runBulk(TaskMonitor monitor) throws CancelledException {
			ClassTypeInfoManager manager = node.getTypeManager();
			monitor.initialize(manager.getTypeCount());
			for (ClassTypeInfoDB type : manager.getTypes()) {
				monitor.checkCanceled();
				node.addNode(type);
				monitor.incrementProgress(1);
			}
		}
	}
}

```

`src/main/java/cppclassanalyzer/provider/ItaniumAbiRttiManagerProvider.java`:

```java
package cppclassanalyzer.provider;

import ghidra.app.cmd.data.rtti.gcc.GnuUtils;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.database.ProgramDB;
import ghidra.program.model.listing.Program;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.manager.ItaniumAbiClassTypeInfoManager;
import cppclassanalyzer.plugin.HeadlessClassTypeInfoManagerService;
import cppclassanalyzer.service.ClassTypeInfoManagerService;
import cppclassanalyzer.service.RttiManagerProvider;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

import static ghidra.util.SystemUtilities.isInHeadlessMode;

public final class ItaniumAbiRttiManagerProvider implements RttiManagerProvider {

	public static final ItaniumAbiRttiManagerProvider INSTANCE = new ItaniumAbiRttiManagerProvider();

	@Override
	public boolean canProvideManager(Program program) {
		return GnuUtils.isGnuCompiler(program);
	}

	@Override
	public ProgramClassTypeInfoManager getManager(Program program) {
		if (!canProvideManager(program)) {
			return null;
		}
		ClassTypeInfoManagerService service;
		if (isInHeadlessMode()) {
			service = HeadlessClassTypeInfoManagerService.getInstance();
		} else {
			PluginTool tool = CppClassAnalyzerUtils.getTool(program);
			service = tool.getService(ClassTypeInfoManagerService.class);
		}
		return new ItaniumAbiClassTypeInfoManager(service, (ProgramDB) program);
	}

}

```

`src/main/java/cppclassanalyzer/provider/VsRttiManagerProvider.java`:

```java
package cppclassanalyzer.provider;

import ghidra.app.cmd.data.rtti.gcc.GnuUtils;
import ghidra.app.plugin.prototype.MicrosoftCodeAnalyzerPlugin.PEUtil;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.database.ProgramDB;
import ghidra.program.model.listing.Program;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.manager.VsClassTypeInfoManager;
import cppclassanalyzer.plugin.HeadlessClassTypeInfoManagerService;
import cppclassanalyzer.service.ClassTypeInfoManagerService;
import cppclassanalyzer.service.RttiManagerProvider;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

import static ghidra.util.SystemUtilities.isInHeadlessMode;

public final class VsRttiManagerProvider implements RttiManagerProvider {

	public static final VsRttiManagerProvider INSTANCE = new VsRttiManagerProvider();

	@Override
	public boolean canProvideManager(Program program) {
		return PEUtil.canAnalyze(program) && !GnuUtils.isGnuCompiler(program);
	}

	@Override
	public ProgramClassTypeInfoManager getManager(Program program) {
		if (!canProvideManager(program)) {
			return null;
		}
		ClassTypeInfoManagerService service;
		if (isInHeadlessMode()) {
			service = HeadlessClassTypeInfoManagerService.getInstance();
		} else {
			PluginTool tool = CppClassAnalyzerUtils.getTool(program);
			service = tool.getService(ClassTypeInfoManagerService.class);
		}
		return new VsClassTypeInfoManager(service, (ProgramDB) program);
	}
}

```

`src/main/java/cppclassanalyzer/scanner/DynlibRttiScanner.java`:

```java
package cppclassanalyzer.scanner;

import java.util.Collections;
import java.util.List;
import java.util.Set;

import ghidra.app.cmd.data.rtti.gcc.GnuUtils;
import ghidra.app.cmd.data.rtti.gcc.VtableModel;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

public class DynlibRttiScanner extends ItaniumAbiRttiScanner {

	public DynlibRttiScanner(Program program) {
		super(program);
	}

	@Override
	protected Set<Address> getReferences(String typeString) throws Exception {
		Program program = manager.getProgram();
		SymbolTable table = program.getSymbolTable();
		Namespace global = program.getGlobalNamespace();
		List<Symbol> symbols = table.getSymbols("_"+VtableModel.MANGLED_PREFIX+typeString, global);
		if (symbols.size() != 1) {
			return Collections.emptySet();
		}
		return GnuUtils.getDirectDataReferences(
			program, symbols.get(0).getAddress(), getDummyMonitor());
	}

	@Override
	public boolean scan(MessageLog log, TaskMonitor monitor) throws CancelledException {
		this.log = log;
		this.monitor = monitor;
		for (String typeString : CLASS_TYPESTRINGS) {
			try {
				if (!getReferences(typeString).isEmpty()) {
					return doScan(log, monitor);
				}
			} catch (CancelledException e) {
				throw e;
			} catch (Exception e) {
				log.appendException(e);
				return false;
			}
		}
		return false;
	}
}

```

`src/main/java/cppclassanalyzer/scanner/DynlibRttiScannerProvider.java`:

```java
package cppclassanalyzer.scanner;

import ghidra.app.cmd.data.rtti.gcc.GnuUtils;
import ghidra.app.util.opinion.MachoLoader;
import ghidra.program.model.listing.Program;

public final class DynlibRttiScannerProvider implements RttiScannerProvider {

	public static final DynlibRttiScannerProvider INSTANCE = new DynlibRttiScannerProvider();

	@Override
	public boolean canScan(Program program) {
		if (program.getExecutableFormat().equals(MachoLoader.MACH_O_NAME)) {
			return GnuUtils.isGnuCompiler(program);
		}
		return false;
	}

	@Override
	public RttiScanner getScanner(Program program) {
		return new DynlibRttiScanner(program);
	}

}

```

`src/main/java/cppclassanalyzer/scanner/ItaniumAbiRttiScanner.java`:

```java
package cppclassanalyzer.scanner;

import java.util.*;
import java.util.stream.Collectors;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.*;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.*;
import ghidra.app.plugin.core.analysis.ReferenceAddressPair;
import ghidra.app.util.XReferenceUtils;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSet;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.Memory;
import ghidra.program.model.reloc.Relocation;
import ghidra.program.model.symbol.*;
import ghidra.program.util.ProgramMemoryUtil;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.CancelOnlyWrappingTaskMonitor;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.data.manager.ItaniumAbiClassTypeInfoManager;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import util.CollectionUtils;

import static ghidra.program.model.data.DataTypeConflictHandler.REPLACE_HANDLER;

public class ItaniumAbiRttiScanner implements RttiScanner {

	// The only one excluded is BaseClassTypeInfoModel
	protected static final List<String> CLASS_TYPESTRINGS = List.of(
		ClassTypeInfoModel.ID_STRING,
		SiClassTypeInfoModel.ID_STRING,
		VmiClassTypeInfoModel.ID_STRING
	);

	protected static final List<String> FUNDAMENTAL_TYPESTRINGS = List.of(
		FundamentalTypeInfoModel.ID_STRING,
		PBaseTypeInfoModel.ID_STRING,
		PointerToMemberTypeInfoModel.ID_STRING,
		PointerTypeInfoModel.ID_STRING,
		ArrayTypeInfoModel.ID_STRING,
		EnumTypeInfoModel.ID_STRING,
		FunctionTypeInfoModel.ID_STRING,
		IosFailTypeInfoModel.ID_STRING
	);

	protected final ItaniumAbiClassTypeInfoManager manager;
	protected TaskMonitor monitor;
	protected MessageLog log;
	private Set<Relocation> relocations;
	private boolean relocatable;
	private boolean reportedMissingRtti = false;

	public ItaniumAbiRttiScanner(Program program) {
		this.manager =
				(ItaniumAbiClassTypeInfoManager) CppClassAnalyzerUtils.getManager(program);
		this.relocations = new HashSet<>();
	}

	protected String getDynamicSymbol(String symbol) {
		return symbol;
	}

	protected String getDynamicSymbol(Relocation relocation) {
		return relocation.getSymbolName();
	}

	protected final ItaniumAbiClassTypeInfoManager getManager() {
		return manager;
	}

	protected final TaskMonitor getDummyMonitor() {
		return new CancelOnlyWrappingTaskMonitor(monitor);
	}

	protected final MessageLog getLog() {
		return log;
	}

	protected final TaskMonitor getMonitor() {
		return monitor;
	}

	protected final Program getProgram() {
		return manager.getProgram();
	}

	public boolean isTypeInfo(Address address) {
		return TypeInfoFactory.isTypeInfo(getProgram(), address);
	}

	public TypeInfo getTypeInfo(Address address) {
		return TypeInfoFactory.getTypeInfo(getProgram(), address);
	}

	protected final Set<Relocation> getRelocations() {
		return relocations;
	}

	protected final void setLog(MessageLog log) {
		this.log = log;
	}

	protected final void setMonitor(TaskMonitor monitor) {
		this.monitor = monitor;
	}

	@Override
	public boolean scan(MessageLog log, TaskMonitor monitor) throws CancelledException {
		this.log = log;
		this.monitor = monitor;
		relocations.addAll(getRelocations(CLASS_TYPESTRINGS));
		if (!relocations.isEmpty()) {
			relocatable = true;
			createOffcutVtableRefs(relocations);
		}
		if (!relocatable) {
			TypeInfo ti = TypeInfoUtils.findTypeInfo(
				getProgram(), getProgram().getMemory(),
				TypeInfoModel.ID_STRING, getDummyMonitor());
			if (ti == null) {
				return false;
			}
		}
		return doScan(log, monitor);
	}

	protected boolean doScan(MessageLog log, TaskMonitor monitor) throws CancelledException {
		try {
			/* Create the vmi replacement base to prevent a
			   placeholder struct from being generated  */
			addDataTypes();
			applyTypeInfoTypes(TypeInfoModel.ID_STRING);
			for (String typeString : CLASS_TYPESTRINGS) {
				applyTypeInfoTypes(typeString);
			}
			relocations.clear();
			return true;
		} catch (CancelledException e) {
			throw e;
		} catch (Exception e) {
			log.appendException(e);
			return false;
		}
	}

	@Override
	public Set<Address> scanFundamentals(MessageLog log, TaskMonitor monitor)
			throws CancelledException {
		this.monitor = monitor;
		relocations.addAll(getRelocations(CLASS_TYPESTRINGS));
		if (!relocations.isEmpty()) {
			relocatable = true;
			createOffcutVtableRefs(relocations);
		}
		Set<Address> addresses = new TreeSet<>();
		for (String typeString : FUNDAMENTAL_TYPESTRINGS) {
			monitor.checkCanceled();
			try {
				addresses.addAll(getReferences(typeString));
			} catch (CancelledException e) {
				throw e;
			} catch (Exception e) {
				log.appendException(e);
			}
		}
		relocations.clear();
		return addresses;
	}

	private void addDataTypes() {
		DataTypeManager dtm = getProgram().getDataTypeManager();
		dtm.resolve(VmiClassTypeInfoModel.getDataType(dtm), REPLACE_HANDLER);
	}

	private void addReferences(AddressSet addresses) throws CancelledException {
		if (addresses.isEmpty()) {
			return;
		}
		Program program = getProgram();
		TaskMonitor dummy = getDummyMonitor();
		Memory mem = program.getMemory();
		ReferenceManager refMan = program.getReferenceManager();
		List<ReferenceAddressPair> refList = new LinkedList<>();
		ProgramMemoryUtil.loadDirectReferenceList(
			program, program.getDefaultPointerSize(), addresses.getMinAddress(),
			addresses, refList, dummy);
		monitor.setProgress(monitor.getMaximum());
		for (ReferenceAddressPair ref : refList) {
			monitor.checkCanceled();
			if (CppClassAnalyzerUtils.isDataBlock(mem.getBlock(ref.getSource()))) {
				refMan.addMemoryReference(
					ref.getSource(), ref.getDestination(),
					RefType.DATA, SourceType.ANALYSIS, 0);
			}
		}
	}

	private void applyTypeInfoTypes(String typeString) throws Exception {
		Program program = getProgram();
		boolean isClass = CLASS_TYPESTRINGS.contains(typeString);
		Set<Address> types = getReferences(typeString);
		if (types.isEmpty()) {
			return;
		}
		Namespace typeClass = TypeInfoUtils.getNamespaceFromTypeName(program, typeString);
		monitor.initialize(types.size());
		monitor.setMessage(
				"Scanning for "+typeClass.getName()+" structures");
		for (Address reference : types) {
			monitor.checkCanceled();
			try {
				TypeInfo type = getTypeInfo(reference);
				if (type != null) {
					if (isClass) {
						ClassTypeInfo classType = ((ClassTypeInfo) type);
						manager.resolve(classType);
						classType.getGhidraClass();
					}
				}
			} catch (UnresolvedClassTypeInfoException e) {
				if (!reportedMissingRtti) {
					log.appendMsg(
						"Missing dynamic RTTI detected. Not all RTTI created.\n"
						+ "See README for more information on how to fix this.");
					reportedMissingRtti = true;
				}
			} catch (Exception e) {
				if (e instanceof IndexOutOfBoundsException) {
					e.printStackTrace();
				}
				//log.appendException(e);
			}
			monitor.incrementProgress(1);
		}
	}

	private void createOffcutVtableRefs(Set<Relocation> relocs) throws CancelledException {
		Listing listing = getProgram().getListing();
		AddressSet addresses = new AddressSet();
		relocs.stream()
			.map(Relocation::getAddress)
			.map(listing::getDataAt)
			.filter(Objects::nonNull)
			.forEach(d -> addresses.add(d.getMinAddress(), d.getMaxAddress()));
		addReferences(addresses);
	}

	private Set<Address> getClangDynamicReferences(Address address) throws CancelledException {
		Data data = getProgram().getListing().getDataContaining(address);
		if (data == null) {
			log.appendMsg("Null data at clang relocation");
			return null;
		}
		return XReferenceUtils.getOffcutXReferences(data, -1)
			.stream()
			.filter(r -> r.getReferenceType().isData())
			.map(Reference::getFromAddress)
			.collect(Collectors.toSet());
	}

	private Set<Address> getDynamicReferences(String typeString) throws CancelledException {
		String target = getDynamicSymbol(VtableModel.MANGLED_PREFIX+typeString);
		Set<Address> result = relocations.stream()
			.filter(r -> target.equals(getDynamicSymbol(r)))
			.map(Relocation::getAddress)
			.collect(Collectors.toSet());
		if (result.size() == 1) {
			Set<Address> clangResults =
				getClangDynamicReferences(result.toArray(Address[]::new)[0]);
			if (!clangResults.isEmpty()) {
				return clangResults;
			}
		}
		return result;
	}

	protected Set<Address> getReferences(String typeString) throws Exception {
		if (relocatable) {
			return getDynamicReferences(typeString);
		}
		return getStaticReferences(typeString);
	}

	private Set<Relocation> getRelocations(List<String> names) {
		Set<String> symbols = names.stream()
			.map(n -> VtableModel.MANGLED_PREFIX+n)
			.map(this::getDynamicSymbol)
			.collect(Collectors.toSet());
		Iterator<Relocation> relocations = getProgram().getRelocationTable()
			.getRelocations();
		List<Relocation> relocs = CollectionUtils.asStream(relocations)
			.filter(r -> r.getSymbolName() != null)
			.collect(Collectors.toList());
		return relocs.stream()
			.filter(r -> symbols.contains(getDynamicSymbol(r)))
			.collect(Collectors.toSet());
	}

	private Set<Address> getStaticReferences(String typeString) throws Exception {
		try {
			Program program = getProgram();
			TaskMonitor dummy = getDummyMonitor();
			ClassTypeInfo typeinfo = (ClassTypeInfo) TypeInfoUtils.findTypeInfo(
				program, typeString, dummy);
			monitor.setMessage("Locating vtable for "+typeinfo.getName());
			Vtable vtable = typeinfo.findVtable(dummy);
			if (!Vtable.isValid(vtable)) {
				throw new Exception("Vtable for "+typeinfo.getFullName()+" not found");
			}
			return GnuUtils.getDirectDataReferences(
				program, vtable.getTableAddresses()[0], dummy);
		} catch (NullPointerException e) {
			return Collections.emptySet();
		}
	}
}

```

`src/main/java/cppclassanalyzer/scanner/ItaniumAbiRttiScannerProvider.java`:

```java
package cppclassanalyzer.scanner;

import ghidra.app.cmd.data.rtti.gcc.GnuUtils;
import ghidra.program.model.listing.Program;

public final class ItaniumAbiRttiScannerProvider implements RttiScannerProvider {

	public static final ItaniumAbiRttiScannerProvider INSTANCE =
		new ItaniumAbiRttiScannerProvider();

	@Override
	public boolean canScan(Program program) {
		return GnuUtils.isGnuCompiler(program);
	}

	@Override
	public RttiScanner getScanner(Program program) {
		return new ItaniumAbiRttiScanner(program);
	}

}

```

`src/main/java/cppclassanalyzer/scanner/RttiScanner.java`:

```java
package cppclassanalyzer.scanner;

import java.util.List;
import java.util.Set;

import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.util.classfinder.ClassSearcher;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

public interface RttiScanner {

	/**
	 * Scan the program for the ClassTypeInfo's
	 * @param log the log to use for logging errors
	 * @param monitor the task monitor
	 * @return true if the scan was successful
	 * @throws CancelledException if the scan is cancelled
	 */
	public boolean scan(MessageLog log, TaskMonitor monitor) throws CancelledException;

	/**
	 * Scans the program for Fundamental TypeInfo's
	 * @param log the log to use for logging errors
	 * @param monitor the task monitor
	 * @return the addresses of the fundamental type info's
	 * @throws CancelledException if the scan is cancelled
	 */
	public Set<Address> scanFundamentals(MessageLog log, TaskMonitor monitor) throws CancelledException;

	public static RttiScanner getScanner(Program program) {
		List<RttiScannerProvider> providers =
			ClassSearcher.getInstances(RttiScannerProvider.class);
		providers.add(DynlibRttiScannerProvider.INSTANCE);
		providers.add(ItaniumAbiRttiScannerProvider.INSTANCE);
		for (RttiScannerProvider scanner : providers) {
			if (scanner.canScan(program)) {
				return scanner.getScanner(program);
			}
		}
		return null;
	}

}

```

`src/main/java/cppclassanalyzer/scanner/RttiScannerProvider.java`:

```java
package cppclassanalyzer.scanner;

import ghidra.program.model.listing.Program;
import ghidra.util.classfinder.ExtensionPoint;

public interface RttiScannerProvider extends ExtensionPoint {

	public boolean canScan(Program program);

	public RttiScanner getScanner(Program program);
}

```

`src/main/java/cppclassanalyzer/scanner/TypeInfoFactory.java`:

```java
package cppclassanalyzer.scanner;

import java.util.Map;
import java.util.function.Function;

import ghidra.util.exception.AssertException;

import db.NoTransactionException;

import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressOutOfBoundsException;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemBuffer;
import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.*;

class TypeInfoFactory {

	private TypeInfoFactory() {}

	private static final Map<String, MethodPair> COPY_MAP =
		Map.ofEntries(
			Map.entry(
				ArrayTypeInfoModel.ID_STRING,
				new MethodPair(
					ArrayTypeInfoModel::getModel,
					ArrayTypeInfoModel::getDataType)),
			Map.entry(
				ClassTypeInfoModel.ID_STRING,
				new MethodPair(
					ClassTypeInfoModel::getModel,
					ClassTypeInfoModel::getDataType)),
			Map.entry(
				EnumTypeInfoModel.ID_STRING,
				new MethodPair(
					EnumTypeInfoModel::getModel,
					EnumTypeInfoModel::getDataType)),
			Map.entry(
				FunctionTypeInfoModel.ID_STRING,
				new MethodPair(
					FunctionTypeInfoModel::getModel,
					FunctionTypeInfoModel::getDataType)),
			Map.entry(
				FundamentalTypeInfoModel.ID_STRING,
				new MethodPair(
					FundamentalTypeInfoModel::getModel,
					FundamentalTypeInfoModel::getDataType)),
			Map.entry(
				PBaseTypeInfoModel.ID_STRING,
				new MethodPair(
					PBaseTypeInfoModel::getModel,
					PBaseTypeInfoModel::getDataType)),
			Map.entry(
				PointerToMemberTypeInfoModel.ID_STRING,
				new MethodPair(
					PointerToMemberTypeInfoModel::getModel,
					PointerToMemberTypeInfoModel::getDataType)),
			Map.entry(
				PointerTypeInfoModel.ID_STRING,
				new MethodPair(
					PointerTypeInfoModel::getModel,
					PointerTypeInfoModel::getDataType)),
			Map.entry(
				SiClassTypeInfoModel.ID_STRING,
				new MethodPair(
					SiClassTypeInfoModel::getModel,
					SiClassTypeInfoModel::getDataType)),
			Map.entry(
				VmiClassTypeInfoModel.ID_STRING,
				new MethodPair(
					VmiClassTypeInfoModel::getModel,
					VmiClassTypeInfoModel::getDataType)),
			Map.entry(
				TypeInfoModel.ID_STRING,
				new MethodPair(
					TypeInfoModel::getModel,
					TypeInfoModel::getDataType)),
			Map.entry(
				IosFailTypeInfoModel.ID_STRING,
				new MethodPair(
					IosFailTypeInfoModel::getModel,
					IosFailTypeInfoModel::getDataType)));

	/**
	 * Get the TypeInfo in the buffer
	 * @param buf the memory buffer containing the TypeInfo data
	 * @return the TypeInfo at the buffers address
	 */
	static TypeInfo getTypeInfo(MemBuffer buf) {
		return getTypeInfo(buf.getMemory().getProgram(), buf.getAddress());
	}

	private static TypeInfo doGetTypeInfo(ModelGetter getter, Program program, Address address)
			throws InvalidDataTypeException {
		try {
			return getter.getModel(program, address);
		} catch (NoTransactionException e) {
			// this is rare occurance where it is better to catch this
			// it is preferred to only create a transaction when necessary
			addTypeInfoTypes(program);
			return getter.getModel(program, address);
		}
	}

	private static void addTypeInfoTypes(Program program) {
		int id = program.startTransaction("Creating typeinfo structures");
		DataTypeManager dtm = program.getDataTypeManager();
		for (MethodPair pair : COPY_MAP.values()) {
			pair.dataTypeGetter.apply(dtm);
		}
		program.endTransaction(id, true);
	}

	/**
	 * Get the TypeInfo at the address
	 * @param program the program containing the TypeInfo
	 * @param address the address of the TypeInfo
	 * @return the TypeInfo at the specified address in the specified program
	 * or null if none exists.
	 */
	static TypeInfo getTypeInfo(Program program, Address address) {
			String baseTypeName = TypeInfoUtils.getIDString(program, address);
			if (!COPY_MAP.containsKey(baseTypeName)) {
				// invalid typeinfo
				return null;
			} try {
				ModelGetter getter = COPY_MAP.get(baseTypeName).modelGetter;
				return doGetTypeInfo(getter, program, address);
			} catch (InvalidDataTypeException e) {
				throw new AssertException(
					TypeInfoUtils.getErrorMessage(program, address, baseTypeName));
			}
	}

	/**
	 * Checks if a valid TypeInfo is located at the start of the buffer
	 * @param buf the memory buffer containing the TypeInfo data
	 * @return true if the buffer contains a valid TypeInfo
	 */
	static boolean isTypeInfo(MemBuffer buf) {
		return buf != null ? isTypeInfo(buf.getMemory().getProgram(), buf.getAddress()) : false;
	}

	/**
	 * Checks if a valid TypeInfo is located at the address in the program.
	 * @param program the program containing the TypeInfo
	 * @param address the address of the TypeInfo
	 * @return true if the data is a valid TypeInfo
	 */
	static boolean isTypeInfo(Program program, Address address) {
		try {
			if (COPY_MAP.containsKey(TypeInfoUtils.getIDString(program, address))) {
				return !TypeInfoUtils.getTypeName(program, address).isBlank();
			}
		} catch (AddressOutOfBoundsException e) {
			return false;
		}
		return false;
	}

	/**
	 * Invokes getDataType on the TypeInfo containing the specified typename
	 * @param program the program containing the TypeInfo
	 * @param typename the type_info class's typename
	 * @return the TypeInfo structure for the typename
	 * @see TypeInfoModel#getDataType()
	 */
	static Structure getDataType(Program program, String typename) {
		if (COPY_MAP.containsKey(typename)) {
			final Function<DataTypeManager, DataType> getter =
				COPY_MAP.get(typename).dataTypeGetter;
			return (Structure) getter.apply(program.getDataTypeManager());
		}
		return null;
	}

	private interface ModelGetter {
		TypeInfo getModel(Program program, Address address) throws InvalidDataTypeException;
	}

	private static final class MethodPair {

		final ModelGetter modelGetter;
		final Function<DataTypeManager, DataType> dataTypeGetter;

		MethodPair(ModelGetter modelGetter,
			Function<DataTypeManager, DataType> dataTypeGetter) {
				this.modelGetter = modelGetter;
				this.dataTypeGetter = dataTypeGetter;
		}
	}

}

```

`src/main/java/cppclassanalyzer/script/CppClassAnalyzerGhidraScript.java`:

```java
package cppclassanalyzer.script;

import java.io.IOException;

import ghidra.app.script.GhidraScript;
import ghidra.app.util.demangler.DemangledObject;
import ghidra.app.util.demangler.DemanglerUtil;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.service.ClassTypeInfoManagerService;

/**
 * A GhidraScript extension providing convenient access to the current
 * {@link ProgramClassTypeInfoManager}.
 */
public abstract class CppClassAnalyzerGhidraScript extends GhidraScript {

	protected ProgramClassTypeInfoManager currentManager;

	@Override
	protected void loadPropertiesFile() throws IOException {
		super.loadPropertiesFile();
		this.currentManager = getService().getManager(currentProgram);
	}

	/**
	 * A convience method for demangling the provided label
	 * @param mangled the mangled label
	 * @return the demangled object or null if it was not mangled
	 */
	protected final DemangledObject demangle(String mangled) {
		return DemanglerUtil.demangle(currentProgram, mangled);
	}

	/**
	 * Gets the ClassTypeInfoManagerService
	 * @return the ClassTypeInfoManagerService
	 */
	protected final ClassTypeInfoManagerService getService() {
		return state.getTool().getService(ClassTypeInfoManagerService.class);
	}
}

```

`src/main/java/cppclassanalyzer/script/CppClassAnalyzerHeadlessScript.java`:

```java
package cppclassanalyzer.script;

import java.io.IOException;

import ghidra.app.util.headless.HeadlessScript;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.plugin.HeadlessClassTypeInfoManagerService;
import cppclassanalyzer.service.ClassTypeInfoManagerService;

public abstract class CppClassAnalyzerHeadlessScript extends HeadlessScript {

	protected ProgramClassTypeInfoManager currentManager;

	@Override
	protected void loadPropertiesFile() throws IOException {
		super.loadPropertiesFile();
		this.currentManager = getService().getManager(currentProgram);
	}

	/**
	 * Gets the ClassTypeInfoManagerService
	 * @return the ClassTypeInfoManagerService
	 */
	protected final ClassTypeInfoManagerService getService() {
		return HeadlessClassTypeInfoManagerService.getInstance();
	}
}

```

`src/main/java/cppclassanalyzer/service/ClassTypeInfoManagerService.java`:

```java
package cppclassanalyzer.service;

import java.io.File;
import java.io.IOException;
import java.util.List;

import ghidra.app.plugin.core.datamgr.archive.DuplicateIdException;
import ghidra.framework.plugintool.PluginTool;
import ghidra.framework.plugintool.ServiceInfo;

import cppclassanalyzer.data.ClassTypeInfoManager;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo;
import cppclassanalyzer.data.vtable.ArchivedVtable;
import cppclassanalyzer.decompiler.DecompilerAPI;
import cppclassanalyzer.plugin.ClassTypeInfoManagerPlugin;
import cppclassanalyzer.provider.ItaniumAbiRttiManagerProvider;
import cppclassanalyzer.provider.VsRttiManagerProvider;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import docking.widgets.tree.GTree;

import ghidra.program.model.listing.Program;
import ghidra.util.classfinder.ClassSearcher;

//@formatter:off
@ServiceInfo(
	defaultProvider = ClassTypeInfoManagerPlugin.class,
	description = "Service to provide ClassTypeInfoManagers"
)
//@formatter:on
public interface ClassTypeInfoManagerService {

	public void closeManager(ClassTypeInfoManager manager);

	public default void openArchive(File archive)
			throws IOException, DuplicateIdException {
		openArchive(archive, false);
	}

	public void openArchive(File archive, boolean updateable)
		throws IOException, DuplicateIdException;

	public void createArchive(File archive)
		throws IOException, DuplicateIdException;

	public ProgramClassTypeInfoManager getManager(Program program);

	public List<ClassTypeInfoManager> getManagers();

	public GTree getTree();

	public static boolean isEnabled(Program program) {
		PluginTool tool = CppClassAnalyzerUtils.getTool(program);
		if (tool == null) {
			return false;
		}
		return tool.getService(ClassTypeInfoManagerService.class) != null;
	}

	public ArchivedClassTypeInfo getExternalClassTypeInfo(Program program, String mangled);

	public ArchivedClassTypeInfo getArchivedClassTypeInfo(String symbolName);
	public ArchivedVtable getArchivedVtable(String symbolName);

	public DecompilerAPI getDecompilerAPI(Program program);

	public ProgramClassTypeInfoManager getCurrentManager();

	public static RttiManagerProvider getManagerProvider(Program program) {
		List<RttiManagerProvider> providers =
			ClassSearcher.getInstances(RttiManagerProvider.class);
		providers.add(ItaniumAbiRttiManagerProvider.INSTANCE);
		providers.add(VsRttiManagerProvider.INSTANCE);
		for (RttiManagerProvider p : providers) {
			if (p.canProvideManager(program)) {
				return p;
			}
		}
		return null;
	}

}

```

`src/main/java/cppclassanalyzer/service/RttiManagerProvider.java`:

```java
package cppclassanalyzer.service;

import ghidra.program.model.listing.Program;
import ghidra.util.classfinder.ExtensionPoint;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;

/**
 * Provides a {@link ProgramClassTypeInfoManager}.
 * <p>
 * An RttiManagerProvider <b>may not</b> fail in Headless mode
 */
public interface RttiManagerProvider extends ExtensionPoint {

	public boolean canProvideManager(Program program);

	public ProgramClassTypeInfoManager getManager(Program program);
}

```

`src/main/java/cppclassanalyzer/utils/ConstantPropagationUtils.java`:

```java
package cppclassanalyzer.utils;

import java.util.List;

import ghidra.app.plugin.core.analysis.AutoAnalysisManager;
import ghidra.app.plugin.core.analysis.ConstantPropagationAnalyzer;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.util.SymbolicPropogator;
import ghidra.util.classfinder.ClassSearcher;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

public class ConstantPropagationUtils {

	private ConstantPropagationUtils() {
	}

	public static ConstantPropagationAnalyzer getConstantAnalyzer(Program program) {
		AutoAnalysisManager mgr = AutoAnalysisManager.getAnalysisManager(program);
		List<ConstantPropagationAnalyzer> analyzers =
			ClassSearcher.getInstances(ConstantPropagationAnalyzer.class);
		for (ConstantPropagationAnalyzer analyzer : analyzers) {
			if (analyzer.canAnalyze(program)) {
				return (ConstantPropagationAnalyzer) mgr.getAnalyzer(analyzer.getName());
			}
		}
		return null;
	}

	public static SymbolicPropogator analyzeFunction(Function function, TaskMonitor monitor)
		throws CancelledException {
			Program program = function.getProgram();
			ConstantPropagationAnalyzer analyzer = getConstantAnalyzer(program);
			SymbolicPropogator symEval = new SymbolicPropogator(program);
			symEval.setParamRefCheck(true);
			symEval.setReturnRefCheck(true);
			symEval.setStoredRefCheck(true);
			analyzer.flowConstants(program, function.getEntryPoint(), function.getBody(),
				symEval, monitor);
			return symEval;
	}

}
```

`src/main/java/cppclassanalyzer/utils/CppClassAnalyzerUtils.java`:

```java
package cppclassanalyzer.utils;

import java.util.*;
import java.util.function.Predicate;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.function.AddFunctionTagCmd;
import ghidra.app.cmd.function.CreateFunctionCmd;
import ghidra.app.cmd.function.CreateThunkFunctionCmd;
import ghidra.framework.model.DomainObject;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionManager;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.program.model.symbol.SymbolUtilities;
import ghidra.util.Msg;
import ghidra.util.exception.AssertException;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.plugin.HeadlessClassTypeInfoManagerService;
import cppclassanalyzer.service.ClassTypeInfoManagerService;

import static ghidra.util.SystemUtilities.isInHeadlessMode;

public final class CppClassAnalyzerUtils {

	public static final String CONSTRUCTOR = "CONSTRUCTOR";
	public static final String DESTRUCTOR = "DESTRUCTOR";
	public static final String DESTRUCTOR_CHAR = "~";

	private CppClassAnalyzerUtils() {
	}

	/**
	 * Gets the first PluginTool which has the provided domain object opened
	 * @param obj the domain object
	 * @return the first found PluginTool or null if none found
	 */
	public static PluginTool getTool(DomainObject obj) {
		for (Object o : obj.getConsumerList()) {
			if (o instanceof PluginTool) {
				return (PluginTool) o;
			}
		}
		return null;
	}

	/**
	 * Checks if the function is a default function
	 * @param function the function to check
	 * @return true if the function is a default function or if it is null
	 */
	public static boolean isDefaultFunction(Function function) {
		if (function == null || function.isThunk()) {
			return true;
		}
		if (!function.getParentNamespace().isGlobal()) {
			return false;
		}
		String defaultName = SymbolUtilities.getDefaultFunctionName(function.getEntryPoint());
		return defaultName.equals(function.getName());
	}

	/**
	 * Checks if the function is a destructor
	 * @param function the function to check
	 * @return true if the function is a desructor
	 */
	public static boolean isDestructor(Function function) {
		return function.getName().contains(DESTRUCTOR_CHAR);
	}

	/**
	 * Sets the Constructor/Destructor tags for the function
	 * @param function the function
	 * @param isConstructor true if the function is a constructor
	 */
	public static void setConstructorDestructorTag(Function function, boolean isConstructor) {
		Objects.requireNonNull(function);
		String tag = isConstructor ? CONSTRUCTOR : DESTRUCTOR;
		String oldTag = isConstructor ? DESTRUCTOR : CONSTRUCTOR;
		AddFunctionTagCmd cmd = new AddFunctionTagCmd(tag, function.getEntryPoint());
		function.removeTag(oldTag);
		cmd.applyTo(function.getProgram());
	}

	/**
	 * Recursively creates thunked functions starting a the following potential
	 * thunked function.
	 * @param function the potential thunked function
	 * @return the thunked-to function
	 */
	public static Function createThunkFunctions(Function function) {
		Objects.requireNonNull(function);
		Program program = function.getProgram();
		FunctionManager manager = program.getFunctionManager();
		while(true) {
			Address thunkedAddress = CreateThunkFunctionCmd.getThunkedAddr(
				program, function.getEntryPoint(), false);
			if (thunkedAddress == null || thunkedAddress == Address.NO_ADDRESS) {
				// difference in ghidra versions
				break;
			}
			Function thunkedFunction = manager.getFunctionAt(thunkedAddress);
			if (thunkedFunction == null) {
				CreateFunctionCmd cmd = new CreateFunctionCmd(thunkedAddress);
				if (cmd.applyTo(program)) {
					thunkedFunction = cmd.getFunction();
				} else {
					String msg = "Failed to create function at "+thunkedAddress.toString();
					Msg.info(CppClassAnalyzerUtils.class, msg);
					return function;
				}
			}
			function.setThunkedFunction(thunkedFunction);
			function = function.getThunkedFunction(true);
		}
		return function;
	}

	public static ClassTypeInfoManagerService getService(Program program) {
		if (isInHeadlessMode()) {
			return HeadlessClassTypeInfoManagerService.getInstance();
		}
		PluginTool tool = getTool(program);
		if (tool == null) {
			return null;
		}
		return tool.getService(ClassTypeInfoManagerService.class);
	}

	/**
	 * Gets the ClassTypeInfoManager for the specified program
	 * @param program the program
	 * @return the program's ClassTypeInfoManager
	 */
	public static ProgramClassTypeInfoManager getManager(Program program) {
		ClassTypeInfoManagerService service;
		if (isInHeadlessMode()) {
			service = HeadlessClassTypeInfoManagerService.getInstance();
			if (service == null) {
				throw new AssertException("HeadlessClassTypeInfoManagerService.getInstance() returned null");
			}
			if (service.getManager(program) == null) {
				throw new AssertException("service.getManager(program) returned null");
			}
		} else {
			service = getService(program);
		}
		return service != null ? service.getManager(program) : null;
	}

	/**
	 * Gets all MemoryBlocks in a Program which hold non-volatile data
	 * @param program the program to be searched
	 * @return A list of all memory blocks whose name contains "data" with non-volatile data
	 */
	public static List<MemoryBlock> getAllDataBlocks(Program program) {
		MemoryBlock[] blocks = program.getMemory().getBlocks();
		ArrayList<MemoryBlock> dataBlocks = new ArrayList<>(blocks.length);
		for (MemoryBlock block : blocks) {
			if (isDataBlock(block) && isDataBlockName(block)) {
				if (!block.isVolatile()) {
					dataBlocks.add(block);
				}
			}
		}
		dataBlocks.trimToSize();
		return dataBlocks;
	}

	private static boolean isDataBlockName(MemoryBlock block) {
		String name = block.getName().toLowerCase();
		return name.contains("data") || name.equals(".bss") || name.contains("__const");
	}

	/**
	 * Returns true if this MemoryBlock has non-volatile data
	 * @param block the memory block to test
	 * @return true if this MemoryBlock has non-volatile data
	 */
	public static boolean isDataBlock(MemoryBlock block) {
		return block != null ? block.isRead() || block.isWrite() : false;
	}

	public static boolean isAbstract(ClassTypeInfo type, String pureVirtualFunctionName) {
		Vtable vtable = type.getVtable();
		if (!Vtable.isValid(vtable)) {
			return false;
		}
		AbstractFunctionChecker checker = new AbstractFunctionChecker(pureVirtualFunctionName);
		return Arrays.stream(vtable.getFunctionTables())
			.flatMap(Arrays::stream)
			.anyMatch(checker);
	}

	private static final class AbstractFunctionChecker implements Predicate<Function> {

		private final String fName;

		AbstractFunctionChecker(String fName) {
			this.fName = fName;
		}

		@Override
		public boolean test(Function f) {
			// f can only be null if the class is abstract
			return f != null ? f.getName().contains(fName) : true;
		}
	}
}

```

`src/main/java/cppclassanalyzer/utils/LanguageIdHandler.java`:

```java
package cppclassanalyzer.utils;

import ghidra.program.model.lang.LanguageID;

/**
 * {@link LanguageID} helper class
 */
public class LanguageIdHandler {

	private final String[] id;

	/**
	 * Constructs a new LanguageIdHandler
	 * @param id the language id
	 */
	public LanguageIdHandler(LanguageID id) {
		this.id = id.getIdAsString().split(":");
	}

	/**
	 * Gets the processor name
	 * @return the processor name
	 */
	public String getProcessor() {
		return id[0];
	}

	/**
	 * Gets the processor endianess
	 * @return the processor endianess
	 */
	public String getEndianess() {
		return id[1];
	}

	/**
	 * Gets the address size
	 * @return the address size
	 */
	public String getAddressSize() {
		return id[2];
	}

	/**
	 * Gets the processor variant
	 * @return the processor variant
	 */
	public String getVariant() {
		return id[3];
	}
}

```

`src/main/java/cppclassanalyzer/vs/RttiModelSearcher.java`:

```java
package cppclassanalyzer.vs;

import java.util.Comparator;
import java.util.Iterator;
import java.util.Objects;

import ghidra.app.cmd.data.TypeDescriptorModel;
import ghidra.app.cmd.data.rtti.Rtti1Model;
import ghidra.app.cmd.data.rtti.Rtti3Model;
import ghidra.app.cmd.data.rtti.Rtti4Model;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Reference;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

import util.CollectionUtils;

import static cppclassanalyzer.vs.VsClassTypeInfo.DEFAULT_OPTIONS;

final class RttiModelSearcher {

	private final TypeDescriptorModel type;
	private AnyRttiModel any;

	RttiModelSearcher(TypeDescriptorModel type) {
		this.type = Objects.requireNonNull(type);
		this.any = AnyRttiModel.EMPTY;
		try {
			type.validate();
		} catch (InvalidDataTypeException e) {
			throw new IllegalArgumentException("The TypeDescriptorModel must be valid");
		}
	}

	static Rtti4Model findRtti4Model(Program program, Address addr, TaskMonitor monitor)
			throws CancelledException {
		Data data = program.getListing().getDataAt(addr);
		if (data != null) {
			Iterator<Reference> it = data.getReferenceIteratorTo();
			Iterator<Address> addresses = CollectionUtils.asStream(it)
				.map(Reference::getFromAddress)
				.sorted(Comparator.reverseOrder())
				.iterator();
			for (Address address : CollectionUtils.asIterable(addresses)) {
				monitor.checkCanceled();
				AnyRttiModel result = getAnyRttiModel(program, address);
				if (result.isPresent()) {
					// short circuit rtti4 comes after rtti3
					return result.getRtti4Model();
				}
			}
		}
		return null;
	}

	void search(TaskMonitor monitor) throws CancelledException {
		Program program = type.getProgram();
		Address addr = type.getAddress();
		Data data = program.getListing().getDataAt(addr);
		if (data != null) {
			Iterator<Reference> it = data.getReferenceIteratorTo();
			Iterator<Address> addresses = CollectionUtils.asStream(it)
				.map(Reference::getFromAddress)
				.sorted(Comparator.reverseOrder())
				.iterator();
			for (Address address : CollectionUtils.asIterable(addresses)) {
				monitor.checkCanceled();
				AnyRttiModel result = getAnyRttiModel(program, address);
				if (result.isPresent()) {
					this.any = result;
					return;
				}
			}
		}
	}

	AnyRttiModel getSearchResult() {
		return any;
	}

	private static AnyRttiModel getAnyRttiModel(Program program, Address address) {
		Listing listing = program.getListing();
		Data data = listing.getDataContaining(address);
		if (data != null) {
			if (data.getDataType().equals(Rtti4Model.getDataType(program))) {
				Rtti4Model model = new Rtti4Model(program, data.getAddress(), DEFAULT_OPTIONS);
				return new AnyRttiModel(model);
			}
			if (data.getDataType().equals(Rtti1Model.getDataType(program))) {
				if (data.getAddress().equals(address)) {
					Rtti3Model model = getValidRtti3Model(program, address);
					if (model != null) {
						return new AnyRttiModel(model);
					}
				}
			}
		}
		try {
			Address rtti4Address = address.subtract(Rtti4Model.getRtti0PointerComponentOffset());
			Rtti4Model model = new Rtti4Model(program, rtti4Address, DEFAULT_OPTIONS);
			model.validate();
			return new AnyRttiModel(model);
		} catch (InvalidDataTypeException e) {
		}
		Rtti3Model model = getValidRtti3Model(program, address);
		if (model != null) {
			return new AnyRttiModel(model);
		}
		return AnyRttiModel.EMPTY;
	}

	private static Rtti3Model getValidRtti3Model(Program program, Address address) {
		Rtti1Model rtti1 = new Rtti1Model(program, address, DEFAULT_OPTIONS);
		try {
			Address rtti3Address = rtti1.getRtti3Address();
			Rtti3Model model = new Rtti3Model(program, rtti3Address, DEFAULT_OPTIONS);
			model.validate();
			return model;
		} catch (InvalidDataTypeException e) {
			return null;
		}
	}

	static final class AnyRttiModel {

		private static final AnyRttiModel EMPTY = new AnyRttiModel(null);

		private final Object o;

		private AnyRttiModel(Object o) {
			this.o = o;
		}

		boolean isPresent() {
			return o != null;
		}

		boolean isRtti3Model() {
			return o instanceof Rtti3Model;
		}

		boolean isRtti4Model() {
			return o instanceof Rtti4Model;
		}

		Rtti3Model getRtti3Model() {
			if (isRtti3Model()) {
				return (Rtti3Model) o;
			}
			return null;
		}

		Rtti4Model getRtti4Model() {
			if (isRtti4Model()) {
				return (Rtti4Model) o;
			}
			return null;
		}
	}
}

```

`src/main/java/cppclassanalyzer/vs/RttiModelWrapper.java`:

```java
package cppclassanalyzer.vs;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.*;

import ghidra.app.cmd.data.TypeDescriptorModel;
import ghidra.app.cmd.data.rtti.*;
import ghidra.app.util.NamespaceUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.*;
import ghidra.util.Msg;
import ghidra.util.exception.*;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import cppclassanalyzer.vs.RttiModelSearcher.AnyRttiModel;
import util.CollectionUtils;

import static ghidra.app.util.datatype.microsoft.MSDataTypeUtils.getReferencedAddress;

public final class RttiModelWrapper implements VsClassTypeInfo {

	private static final String VFTABLE_SYMBOL_NAME = "vftable_meta_ptr";

	private final TypeDescriptorModel type;
	private final Rtti2Model baseArray;
	private final Rtti3Model hierarchyDescriptor;
	private final Vtable vtable;
	private final ClassTypeInfo[] parents;
	private final Rtti1Model baseModel;
	private final VsCppClassBuilder builder;
	private final String typeName;
	private final Set<ClassTypeInfo> virtualParents;
	private final Map<ClassTypeInfo, Integer> baseOffsets;

	private RttiModelWrapper(TypeDescriptorModel model) throws InvalidDataTypeException {
		this.type = model;
		this.baseArray = null;
		this.hierarchyDescriptor = null;
		this.vtable = Vtable.NO_VTABLE;
		this.parents = new ClassTypeInfo[0];
		this.baseModel = null;
		this.builder = new VsCppClassBuilder(this);
		this.typeName = type.getTypeName();
		this.virtualParents = Collections.emptySet();
		this.baseOffsets = Collections.emptyMap();
	}

	private RttiModelWrapper(Rtti1Model model) throws InvalidDataTypeException {
		Program program = model.getProgram();
		this.baseModel = model;
		this.type = model.getRtti0Model();
		this.hierarchyDescriptor =
			new Rtti3Model(program, model.getRtti3Address(), DEFAULT_OPTIONS);
		this.baseArray = hierarchyDescriptor.getRtti2Model();
		this.parents = doGetParentModels();
		this.vtable = doGetVtable();
		this.builder = new VsCppClassBuilder(this);
		this.typeName = type.getTypeName();
		this.virtualParents = doGetVirtualParents();
		this.baseOffsets = doGetBaseOffsets();
	}

	private RttiModelWrapper(Rtti4Model model) throws InvalidDataTypeException {
		model.validate();
		this.type = model.getRtti0Model();
		type.validate();
		this.hierarchyDescriptor = model.getRtti3Model();
		hierarchyDescriptor.validate();
		this.baseArray = hierarchyDescriptor.getRtti2Model();
		baseArray.validate();
		this.baseModel = baseArray.getRtti1Model(0);
		baseModel.validate();
		this.parents = doGetParentModels();
		this.vtable = doGetVtable();
		this.builder = new VsCppClassBuilder(this);
		this.typeName = type.getTypeName();
		this.virtualParents = doGetVirtualParents();
		this.baseOffsets = doGetBaseOffsets();
	}

	private RttiModelWrapper(Rtti3Model model) throws InvalidDataTypeException {
		model.validate();
		this.hierarchyDescriptor = model;
		this.type = model.getRtti0Model();
		type.validate();
		this.baseArray = model.getRtti2Model();
		baseArray.validate();
		this.baseModel = baseArray.getRtti1Model(0);
		baseModel.validate();
		this.parents = doGetParentModels();
		this.vtable = doGetVtable();
		this.builder = new VsCppClassBuilder(this);
		this.typeName = type.getTypeName();
		this.virtualParents = doGetVirtualParents();
		this.baseOffsets = doGetBaseOffsets();
	}

	private static AssertException getPreValidatedError(InvalidDataTypeException e, Address a) {
		String msg = String.format("Previously validated data at %s is no longer valid", a);
		return new AssertException(msg, e);
	}

	private static ClassTypeInfo wrapNoExcept(Rtti1Model model) {
		// models must have already been checked
		try {
			Program program = model.getProgram();
			ProgramClassTypeInfoManager manager = CppClassAnalyzerUtils.getManager(program);
			ClassTypeInfo parent = manager.getType(model.getRtti0Address());
			if (parent != null) {
				return parent;
			}
			return manager.resolve(new RttiModelWrapper(model));
		} catch (InvalidDataTypeException e) {
			throw getPreValidatedError(e, model.getAddress());
		}
	}

	public static RttiModelWrapper getWrapper(TypeDescriptorModel typeModel, TaskMonitor monitor)
			throws CancelledException {
		try {
			typeModel.validate();
		} catch (InvalidDataTypeException e) {
			throw new IllegalArgumentException(e);
		}
		RttiModelSearcher searcher = new RttiModelSearcher(typeModel);
		searcher.search(monitor);
		AnyRttiModel any = searcher.getSearchResult();
		try {
			if (any.isRtti4Model()) {
				return new RttiModelWrapper(any.getRtti4Model());
			}
			if (any.isRtti3Model()) {
				return new RttiModelWrapper(any.getRtti3Model());
			}
			// This is just a lone class and is common for exceptions, lambdas, std::bind, etc
			return new RttiModelWrapper(typeModel);
		} catch (InvalidDataTypeException e) {
			// impossible
			throw new AssertException(e);
		}
	}

	public Rtti1Model getBaseModel() {
		return baseModel;
	}

	@Override
	public TypeDescriptorModel getTypeDescriptor() {
		return type;
	}

	@Override
	public Rtti2Model getBaseClassArray() {
		return baseArray;
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof RttiModelWrapper) {
			return type.equals(((RttiModelWrapper) o).type);
		}
		return false;
	}

	@Override
	public int hashCode() {
		return getAddress().hashCode();
	}

	@Override
	public String getName() {
		return getNamespace().getName();
	}

	@Override
	public Namespace getNamespace() {
		return type.getDescriptorAsNamespace();
	}

	@Override
	public String getTypeName() {
		return typeName;
	}

	@Override
	public String getIdentifier() {
		return RttiUtil.TYPE_INFO_STRING;
	}

	@Override
	public DataType getDataType() {
		return null;
	}

	@Override
	public Address getAddress() {
		return type.getAddress();
	}

	@Override
	public GhidraClass getGhidraClass() {
		if (getNamespace() instanceof GhidraClass) {
			return (GhidraClass) getNamespace();
		}
		try {
			return NamespaceUtils.convertNamespaceToClass(getNamespace());
		} catch (InvalidInputException e) {
			Msg.error(this, e);
		}
		return null;
	}

	@Override
	public boolean hasParent() {
		return parents.length > 0;
	}

	private List<Address> getVftableAddresses() {
		final SymbolTable table = type.getProgram().getSymbolTable();
		SymbolIterator symbols = table.getChildren(getNamespace().getSymbol());
		int pointerSize = type.getProgram().getDefaultPointerSize();
		return StreamSupport.stream(symbols.spliterator(), false)
			.filter(s -> s.getName().equals(VFTABLE_SYMBOL_NAME))
			.map(Symbol::getAddress)
			.map(a -> a.add(pointerSize))
			.sorted()
			.collect(Collectors.toList());
	}

	@Override
	public ClassTypeInfo[] getParentModels() {
		return parents;
	}

	private static List<Rtti1Model> getRtti1Models(Program program, Address addr, int count) {
		List<Rtti1Model> result = new ArrayList<>(count-1);
		int size = 4;
		Address currentAddr = addr.add(size);
		for (int i = 1; i < count; i++) {
			// start at 1 since the first base is this
			Address address = getReferencedAddress(program, currentAddr);
			Rtti1Model model = new Rtti1Model(program, address, DEFAULT_OPTIONS);
			try {
				model.validate();
				result.add(model);
			} catch (InvalidDataTypeException e) {
				throw getPreValidatedError(e, address);
			}
			currentAddr = currentAddr.add(size);
		}
		return result;
	}

	private ClassTypeInfo[] doGetParentModels() {
		Program program = type.getProgram();
		Address addr = hierarchyDescriptor.getAddress();
		int baseCount = Rtti3Model.getRtti1Count(program, addr);
		return getRtti1Models(program, baseArray.getAddress(), baseCount)
			.stream()
			.filter(Predicate.not(this::shouldIgnore))
			.map(RttiModelWrapper::wrapNoExcept)
			.toArray(ClassTypeInfo[]::new);
	}

	static boolean isVirtual(Rtti1Model model) throws InvalidDataTypeException {
		return (model.getAttributes() >> 4 & 1) == 1;
	}

	private Vtable doGetVtable() {
		final List<Address> addresses = getVftableAddresses();
		if (!addresses.isEmpty()) {
			return new VsVtableModel(type.getProgram(), getVftableAddresses(), this);
		}
		return Vtable.NO_VTABLE;
	}

	@Override
	public Vtable getVtable() {
		return vtable;
	}

	@Override
	public Vtable findVtable(TaskMonitor monitor) throws CancelledException {
		return getVtable();
	}

	private int getVirtualOffset(Rtti1Model model) {
		if (Vtable.isValid(vtable)) {
			try {
				return ((VsVtableModel) vtable).getVirtualOffset(model);
			} catch (InvalidDataTypeException e) {
				// return -1
			}
		}
		return -1;
	}

	private int getOffset(Rtti1Model model) {
		try {
			if (isVirtual(model)) {
				final int pDisp = model.getPDisp();
				final int vDisp = getVirtualOffset(model);
				if (vDisp > 0 && pDisp >= 0) {
					return vDisp + pDisp;
				}
				if (vDisp > 0) {
					return vDisp;
				}
				Msg.warn(this, "Missing offset for: " + model.getRtti0Model().getTypeName());
				return -1;
			}
			return model.getMDisp();
		} catch (InvalidDataTypeException e) {
			Msg.error(this, e);
		}
		return -1;
	}

	private boolean shouldIgnore(Rtti1Model model) {
		try {
			// Not virtual and a repeated base
			return !isVirtual(model) && ((model.getAttributes() & 2) == 2);
		} catch (InvalidDataTypeException e) {
			Msg.error(this, e);
			return true;
		}
	}

	@Override
	public Set<ClassTypeInfo> getVirtualParents() {
		return virtualParents;
	}

	private Set<ClassTypeInfo> doGetVirtualParents() throws InvalidDataTypeException {
		Set<ClassTypeInfo> result = new LinkedHashSet<>();
		int baseCount = hierarchyDescriptor.getRtti1Count();
		for (int i = 1; i < baseCount; i++) {
			Rtti1Model model = baseArray.getRtti1Model(i);
			ClassTypeInfo parent = wrapNoExcept(model);
			result.addAll(parent.getVirtualParents());
			if (isVirtual(model)) {
				result.add(wrapNoExcept(model));
			}
		}
		return result;
	}

	public Map<ClassTypeInfo, Integer> getBaseOffsets() {
		return baseOffsets;
	}

	private Map<ClassTypeInfo, Integer> doGetBaseOffsets() throws InvalidDataTypeException {
		Map<ClassTypeInfo, Integer> map = new HashMap<>();
		for (int i = 1; i < baseArray.getCount(); i++) {
			Rtti1Model base = baseArray.getRtti1Model(i);
			if (!shouldIgnore(base) && !isVirtual(base)) {
				map.put(wrapNoExcept(base), getOffset(base));
			}
		}
		Set<ClassTypeInfo> vParents = getVirtualParents();
		if (!vParents.isEmpty()) {
			List<Rtti4Model> models = getCompleteObjectLocators();
			if (models.size() >= vParents.size()) {
				models = models.subList(models.size() - vParents.size(), models.size());
				int i = 0;
				for (ClassTypeInfo parent : vParents) {
					map.put(parent, models.get(i++).getVbTableOffset());
				}
			} else {
				for (int i = 1; i < baseArray.getCount(); i++) {
					Rtti1Model base = baseArray.getRtti1Model(i);
					if (!shouldIgnore(base) && isVirtual(base)) {
						map.put(wrapNoExcept(base), getOffset(base));
					}
				}
			}
		}
		return map;
	}

	@Override
	public Structure getClassDataType() {
		return builder.getDataType();
	}

	@Override
	public Rtti3Model getHierarchyDescriptor() {
		return hierarchyDescriptor;
	}

	public List<Rtti4Model> getCompleteObjectLocators() {
		String dtName = "RTTICompleteObjectLocator";
		Listing listing = type.getProgram().getListing();
		Data data = listing.getDataAt(getAddress());
		Iterable<Reference> it = data.getReferenceIteratorTo();
		return CollectionUtils.asStream(it)
			.map(Reference::getFromAddress)
			.map(listing::getDataContaining)
			.filter(Objects::nonNull)
			.filter(d -> d.getMnemonicString().equals(dtName))
			.sorted((a, b) -> a.getAddress().compareTo(b.getAddress()))
			.map(d -> new Rtti4Model(d.getProgram(), d.getAddress(), DEFAULT_OPTIONS))
			.collect(Collectors.toList());
	}
}

```

`src/main/java/cppclassanalyzer/vs/VsClassTypeInfo.java`:

```java
package cppclassanalyzer.vs;

import java.util.Map;

import ghidra.app.cmd.data.TypeDescriptorModel;
import ghidra.app.cmd.data.rtti.*;
import ghidra.app.util.datatype.microsoft.DataValidationOptions;

import cppclassanalyzer.utils.CppClassAnalyzerUtils;

public interface VsClassTypeInfo extends ClassTypeInfo {

	public static final String LOCATOR_SYMBOL_NAME = Rtti4Model.DATA_TYPE_NAME;
	public static final String HIERARCHY_SYMBOL_NAME = Rtti3Model.DATA_TYPE_NAME;
	public static final String BASE_ARRAY_SYMBOL_NAME = Rtti2Model.DATA_TYPE_NAME;
	public static final DataValidationOptions DEFAULT_OPTIONS = new DataValidationOptions();

	public Map<ClassTypeInfo, Integer> getBaseOffsets();
	public Rtti1Model getBaseModel();
	public Rtti2Model getBaseClassArray();
	public Rtti3Model getHierarchyDescriptor();
	public TypeDescriptorModel getTypeDescriptor();

	@Override
	default public boolean isAbstract() {
		return CppClassAnalyzerUtils.isAbstract(this, VsVtableModel.PURE_VIRTUAL_FUNCTION_NAME);
	}

}

```

`src/main/java/cppclassanalyzer/vs/VsCppClassBuilder.java`:

```java
package cppclassanalyzer.vs;

import static ghidra.program.model.data.Undefined.isUndefined;

import java.util.Map;

import ghidra.app.cmd.data.rtti.*;
import ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils;
import ghidra.app.util.datatype.microsoft.MSDataTypeUtils;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.Program;

public class VsCppClassBuilder extends AbstractCppClassBuilder {

	private static final String VFPTR = "_vfptr";
	private static final String VBPTR = "_vbptr";

	public VsCppClassBuilder(VsClassTypeInfo type) {
		super(type);
	}

	@Override
	protected AbstractCppClassBuilder getParentBuilder(ClassTypeInfo parent) {
		return new VsCppClassBuilder((VsClassTypeInfo) parent);
	}

	@Override
	protected void addVptr(Structure struct) {
		try {
			addPointers(struct);
		} catch (InvalidDataTypeException e) {
			return;
		}
	}

	private void addVfptr(Structure struct, int offset) {
		ClassTypeInfo type = getType();
		Program program = getProgram();
		DataType vfptr = ClassTypeInfoUtils.getVptrDataType(program, type);
		DataTypeComponent comp = struct.getComponentContaining(offset);
		if (comp == null || isUndefined(comp.getDataType())) {
			replaceComponent(struct, vfptr, VFPTR, offset);
		} else if (comp.getFieldName() == null || !comp.getFieldName().startsWith(SUPER)) {
			replaceComponent(struct, vfptr, VFPTR, offset);
		}
	}


	/**  {@link Rtti4Model#getVbTableOffset} */
	private void addVbptr(Structure struct, int offset) throws InvalidDataTypeException {
		Program program = getProgram();
		DataTypeManager dtm = program.getDataTypeManager();
		int ptrSize = program.getDefaultPointerSize();
		DataType vbptr = dtm.getPointer(
			MSDataTypeUtils.getPointerDisplacementDataType(program), ptrSize);
		DataTypeComponent comp = struct.getComponentContaining(offset);
		if (comp == null || isUndefined(comp.getDataType())) {
			replaceComponent(struct, vbptr, VBPTR, offset);
		} else if (comp.getFieldName() == null || !comp.getFieldName().startsWith(SUPER)) {
			replaceComponent(struct, vbptr, VBPTR, offset);
		}
	}

	private void addPointers(Structure struct) throws InvalidDataTypeException {
		VsClassTypeInfo type = getType();
		int offset = 0;
		Vtable vtable = type.getVtable();
		if (Vtable.isValid(vtable)) {
			addVfptr(struct, offset);
			offset = getProgram().getDefaultPointerSize();
		}
		if (!type.getVirtualParents().isEmpty()) {
			addVbptr(struct, offset);
		}
	}

	@Override
	protected Map<ClassTypeInfo, Integer> getBaseOffsets() {
		return getType().getBaseOffsets();
	}

	@Override
	protected VsClassTypeInfo getType() {
		return (VsClassTypeInfo) super.getType();
	}
}

```

`src/main/java/cppclassanalyzer/vs/VsVtableModel.java`:

```java
package cppclassanalyzer.vs;

import java.util.List;
import java.util.ArrayList;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Rtti1Model;
import ghidra.app.cmd.data.rtti.VfTableModel;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.util.datatype.microsoft.DataValidationOptions;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.Array;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.listing.*;
import ghidra.program.model.mem.MemBuffer;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.mem.MemoryBufferImpl;
import ghidra.program.model.scalar.Scalar;
import ghidra.util.Msg;
import ghidra.util.exception.AssertException;

import static ghidra.program.model.data.Undefined.isUndefined;

public class VsVtableModel implements Vtable {

	public static final String PURE_VIRTUAL_FUNCTION_NAME = "_purecall";

	private final Program program;
	private final List<VfTableModel> vftables;
	private final ClassTypeInfo type;
	private final MemBuffer vbtableBuffer;

	private static final DataValidationOptions DEFAULT_OPTIONS = new DataValidationOptions();

	public VsVtableModel(Program program, List<Address> addresses, RttiModelWrapper type) {
		this.program = program;
		this.vftables = new ArrayList<>(addresses.size());
		this.type = type;
		for (Address address : addresses) {
			vftables.add(new VfTableModel(program, address, DEFAULT_OPTIONS));
		}
		this.vbtableBuffer = getVbtableBuffer();
	}

	private MemBuffer getVbtableBuffer() {
		if (vftables.isEmpty()) {
			return null;
		}
		VfTableModel vtable = vftables.get(vftables.size() - 1);
		Array array = (Array) vtable.getDataType();
		if (array == null) {
			return null;
		}
		final Address addr = vtable.getAddress().add(array.getLength()+array.getElementLength());
		return new MemoryBufferImpl(program.getMemory(), addr);
	}

	@Override
	public ClassTypeInfo getTypeInfo() {
		return type;
	}

	@Override
	public Address[] getTableAddresses() {
		Address[] addresses = new Address[vftables.size()];
		for (int i = 0; i < addresses.length; i++) {
			addresses[i] = vftables.get(i).getAddress();
		}
		return addresses;
	}

	private Function[] getFunctions(VfTableModel vftable) {
		List<Function> functions = new ArrayList<>(vftable.getElementCount());
		FunctionManager manager = program.getFunctionManager();
		for (int i = 0; i < vftable.getElementCount(); i++) {
			Function f = manager.getFunctionAt(vftable.getVirtualFunctionPointer(i));
			if (f == null) {
				break;
			}
			functions.add(f);
		}
		return functions.toArray(Function[]::new);
	}

	@Override
	public Function[][] getFunctionTables() {
		List<Function[]> tables = new ArrayList<>(vftables.size());
		for (VfTableModel vftable : vftables) {
			tables.add(getFunctions(vftable));
		}
		return tables.toArray(new Function[tables.size()][]);
	}

	protected List<VfTableModel> getVfTables() {
		return vftables;
	}

	@Override
	public boolean containsFunction(Function function) {
		for (Function[] functionTables : getFunctionTables()) {
			for (Function vFunction : functionTables) {
				if (vFunction.equals(function)) {
					return true;
				}
			}
		}
		return false;
	}

	public int getVirtualOffset(Rtti1Model model) throws InvalidDataTypeException {
		if (vbtableBuffer != null) {
			try {
				final int offset = model.getVDisp();
				final Address addr = vbtableBuffer.getAddress().add(offset);
				final Data data = program.getListing().getDataContaining(addr);
				if (data != null) {
					if (!isUndefined(data.getDataType()) && !(data.getValue() instanceof Scalar)) {
						return 0;
					}
				}
				return vbtableBuffer.getInt(offset);
			} catch (MemoryAccessException e) {
				Msg.error(this, e);
			}
		}
		return 0;
	}

	@Override
	public Address getAddress() {
		if (!vftables.isEmpty()) {
			return vftables.get(0).getAddress();
		}
		throw new AssertException("Ghidra-Cpp-Class-Analyzer: no vftables");
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/AbstractCppClassBuilder.java`:

```java
package ghidra.app.cmd.data.rtti;

import java.util.*;
import java.util.function.IntSupplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.DataTypeConflictHandler;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.DataTypePath;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CompositeDataTypeElementInfo;
import ghidra.util.InvalidNameException;
import ghidra.util.Msg;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.DuplicateNameException;

public abstract class AbstractCppClassBuilder {

	protected static final String SUPER = "super_";

	private final Program program;
	protected Structure struct;
	private final CategoryPath path;
	private final ClassTypeInfo type;

	private Map<CompositeDataTypeElementInfo, String> dtComps = Collections.emptyMap();

	protected AbstractCppClassBuilder(ClassTypeInfo type) {
		this.type = type;
		GhidraClass gc = type.getGhidraClass();
		this.program = gc.getSymbol().getProgram();
		this.struct = ClassTypeInfoUtils.getPlaceholderStruct(type, program.getDataTypeManager());
		this.struct = resolveStruct(struct);
		this.path = new CategoryPath(TypeInfoUtils.getCategoryPath(type), type.getName());
	}

	protected abstract AbstractCppClassBuilder getParentBuilder(ClassTypeInfo parent);

	protected ClassTypeInfo getType() {
		return type;
	}

	protected final Program getProgram() {
		return program;
	}

	private String getSuperName() {
		return SUPER + type.getName();
	}

	protected final void addVptr() {
		addVptr(struct);
	}

	protected abstract Map<ClassTypeInfo, Integer> getBaseOffsets();
	protected abstract void addVptr(Structure struct);

	public Structure getDataType() {
		if (struct.isDeleted()) {
			struct = ClassTypeInfoUtils.getPlaceholderStruct(
				type, program.getDataTypeManager());
		}
		Integer id = null;
		boolean success = false;
		if (program.getCurrentTransaction() == null) {
			id = program.startTransaction("creating datatype for "+type.getName());
		}

		try {
			stashComponents();
			Map<ClassTypeInfo, Integer> baseMap = getBaseOffsets();
			boolean primaryBaseSet = false;
			for (ClassTypeInfo parent : baseMap.keySet()) {
				AbstractCppClassBuilder parentBuilder = getParentBuilder(parent);
				Structure parentStruct = parentBuilder.getSuperClassDataType();
				String memberName = SUPER + parent.getName();
				int offset = baseMap.get(parent);
				if (offset == 0) {
					if (parentStruct.isNotYetDefined()) {
						// it is an empty class, interface or essentially a namespace
						continue;
					}
					if (!primaryBaseSet) {
						replaceComponent(struct, parentStruct, memberName, 0);
						primaryBaseSet = true;
					}
				} else if (offset < 0) {
					// it is contained within another base class
					// or unable to resolve and already reported
					continue;
				} else {
					replaceComponent(struct, parentStruct, memberName, offset);
				}
			}
			addVptr();
			fixComponents();
			getSuperClassDataType();
			success = true;
		} finally {
			if (id != null) {
				program.endTransaction(id, success);
			}
		}
		return struct;
	}

	protected void setSuperStructureCategoryPath(Structure parent) {
		try {
			parent.setCategoryPath(path);
			parent.setName(SUPER+parent.getName());
		} catch (InvalidNameException | DuplicateNameException e) {
			Msg.error(
				this, "Failed to change placeholder struct "+type.getName()+"'s CategoryPath", e);
		}
	}

	protected Structure getSuperClassDataType() {
		if (type.getVirtualParents().isEmpty()) {
			return struct;
		}
		DataTypeManager dtm = program.getDataTypeManager();
		DataTypePath dtPath = new DataTypePath(path, SUPER+type.getName());
		DataType dt = dtm.getDataType(dtPath);
		if (dt == null) {
			Structure superStruct = (Structure) struct.copy(dtm);
			setSuperStructureCategoryPath(superStruct);
			superStruct = resolveStruct(superStruct);
			int ordinal = getFirstVirtualOrdinal(superStruct);
			if (ordinal != -1) {
				ComponentInfo[] comps = new ComponentInfo[ordinal];
				DataTypeComponent[] dcomps = superStruct.getDefinedComponents();
				for (int i = 0; i < ordinal; i++) {
					comps[i] = new ComponentInfo(dcomps[i]);
				}
				superStruct.deleteAll();
				for (ComponentInfo comp : comps) {
					comp.insert(superStruct);
				}
			}
			addVptr(superStruct);
			//if (!superStruct.isMachineAligned()) {
			//	trimStructure(superStruct);
			//}
			return superStruct;
		}
		return (Structure) dt;
	}

	protected static void clearComponent(Structure struct, int length, int offset) {
		if (offset >= struct.getLength()) {
			return;
		}
		for (int size = 0; size < length;) {
			DataTypeComponent comp = struct.getComponentAt(offset);
			if (comp!= null) {
				size += comp.getLength();
			} else {
				size++;
			}
			struct.deleteAtOffset(offset);
		}
	}

	protected static void replaceComponent(Structure struct, DataType parent,
			String name, int offset) {
		clearComponent(struct, parent.getLength(), offset);
		struct.insertAtOffset(offset, parent, parent.getLength(), name, null);
	}

	protected static Structure resolveStruct(Structure struct) {
		DataTypeManager dtm = struct.getDataTypeManager();
		return (Structure) dtm.resolve(struct, DataTypeConflictHandler.KEEP_HANDLER);
	}

	protected int getFirstVirtualOrdinal(Structure superStruct) {
		Set<String> parents = type.getVirtualParents()
			.stream()
			.map(this::getParentBuilder)
			.map(AbstractCppClassBuilder::getSuperName)
			.collect(Collectors.toSet());
		DataTypeComponent[] comps = superStruct.getDefinedComponents();
		return getReverseIndexStream(comps.length)
			.filter(i -> parents.contains(comps[i].getFieldName()))
			.findFirst()
			.orElse(-1);
	}

	private static IntStream getReverseIndexStream(int max) {
		return IntStream.generate(new ReverseIndexSupplier(max - 1))
			.limit(max);
	}

	private boolean validFieldName(String name) {
		if (name == null) {
			return true;
		}
		return !name.startsWith(SUPER) && !name.contains("_vptr");
	}

	private void stashComponents() {
		if (struct.isPackingEnabled()) {
			struct.setPackingEnabled(false);
		}
		if(dtComps.isEmpty()) {
			dtComps = new HashMap<>(struct.getNumDefinedComponents());
			for (DataTypeComponent comp : struct.getDefinedComponents()) {
				if (comp.getDataType() == null) {
					String msg = struct.getDataTypePath().toString()
						+ " is corrupted and must be deleted through the user interface";
					throw new AssertException(msg);
				}
				String fieldName = comp.getFieldName();
				if (validFieldName(fieldName)) {
					if (!comp.getDataType().isNotYetDefined()) {
						CompositeDataTypeElementInfo savedComp = new CompositeDataTypeElementInfo(
							comp.getDataType(), comp.getOffset(),
							comp.getLength(), comp.getDataType().getAlignment());
						dtComps.put(savedComp, comp.getFieldName());
					}
				}
			}
			struct.deleteAll();
		}
	}

	private void fixComponents() {
		for (CompositeDataTypeElementInfo comp : dtComps.keySet()) {
			int offset = comp.getDataTypeOffset();
			DataTypeComponent replaced = struct.getComponentContaining(offset);
			if (replaced != null && !validFieldName(replaced.getFieldName())) {
				continue;
			}
			replaceComponent(struct, (DataType) comp.getDataTypeHandle(),
							 dtComps.get(comp), offset);
		}
	}

	private static final class ReverseIndexSupplier implements IntSupplier {

		private int index;

		ReverseIndexSupplier(int index) {
			this.index = index;
		}

		@Override
		public int getAsInt() {
			return index--;
		}
	}
	
	private static class ComponentInfo {
		final DataType type;
		final String name;
		final String comment;
		final int offset;
		
		ComponentInfo(DataTypeComponent comp) {
			type = comp.getDataType();
			name = comp.getFieldName();
			comment = comp.getComment();
			offset = comp.getOffset();
		}
		
		void insert(Structure struct) {
			struct.insertAtOffset(offset, type, type.getLength(), name, comment);
		}
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/ClassTypeInfo.java`:

```java
package ghidra.app.cmd.data.rtti;

import java.util.Set;

import ghidra.app.util.SymbolPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.GhidraClass;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

/**
 * Interface for modeling std::type_info and its derivatives.
 * <br>
 * All derived models are based on dwarf information from libstdc++.a
 */
public interface ClassTypeInfo extends TypeInfo {

	default DataType getRepresentedDataType() {
		return getClassDataType();
	}

	/**
	 * Gets the corresponding Ghidra Class for this TypeInfo and
	 * creates it if none exists.
	 * @return The class representation of this TypeInfo instance
	 */
	GhidraClass getGhidraClass();

	/**
	 * Checks if this ClassTypeInfo is a subclass of another type
	 * @return true if this is a subclass
	 */
	boolean hasParent();

	/**
	 * Retrieves the Models of this ClassTypeInfo classes base classes
	 * @return the parent models
	 */
	ClassTypeInfo[] getParentModels();

	/**
	 * Retrieves an ordered set of all virtually inherited base classes
	 * @return the set of virtual bases
	 */
	public Set<ClassTypeInfo> getVirtualParents();

	/**
	 * Determines if the represented class is an abstract base
	 * @return true if abstract
	 */
	boolean isAbstract();

	/**
	 * Locates the TypeInfo's Vtable Model
	 * @param monitor the task monitor to be used while searching for the vtable
	 * @return The TypeInfo's Vtable Model or {@link Vtable#NO_VTABLE} if none exists
	 * @throws CancelledException if the search is cancelled
	 */
	Vtable findVtable(TaskMonitor monitor) throws CancelledException;

	/**
	 * Locates the TypeInfo's Vtable Model using the DUMMY TaskMonitor
	 * @return The TypeInfo's Vtable Model or {@link Vtable#NO_VTABLE} if none exists
	 * or the search is cancelled
	 * @see TaskMonitor#DUMMY
	 */
	default Vtable findVtable() {
		try {
			return findVtable(TaskMonitor.DUMMY);
		} catch (CancelledException e) {
			return Vtable.NO_VTABLE;
		}
	}

	/**
	 * Gets the TypeInfo's Vtable Model
	 * @return The TypeInfo's Vtable Model or {@link Vtable#NO_VTABLE} if none exists
	 */
	Vtable getVtable();

	/**
	 * Gets the underlying structure of the class for this ClassTypeInfo
	 * @return the structure datatype for this class
	 */
	Structure getClassDataType();

	default boolean isExternal() {
		return false;
	}

	default SymbolPath getSymbolPath() {
		return new SymbolPath(getGhidraClass().getSymbol());
	}

	default String getFullName() {
		return getGhidraClass().getName(true);
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/GnuVtable.java`:

```java
package ghidra.app.cmd.data.rtti;

import java.util.List;

import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.listing.Function;

public interface GnuVtable extends Vtable {

	public static final String PURE_VIRTUAL_FUNCTION_NAME = "__cxa_pure_virtual";

	/**
	 * Gets the ptrdiff_t value within the base offset array.
	 *
	 * @param index the index in the vtable_prefix array.
	 * @param ordinal the offset ordinal.
	 * @return the offset value.
	 */
	long getOffset(int index, int ordinal);

	/**
	 * Gets the DataTypes that compose this Vtable
	 *
	 * @return the list of DataTypes this Vtable is made of
	 */
	List<DataType> getDataTypes();

	/**
	 * Gets the vtable prefixes that compose this vtable
	 *
	 * @return the list of vtable prefixes
	 */
	List<VtablePrefix> getPrefixes();

	default int getLength() {
		return getDataTypes().stream()
							 .mapToInt(DataType::getLength)
							 .sum();
	}

	interface VtablePrefix {

		/**
		 * Gets the whole ptrdiff_t array.
		 *
		 * @return the whole ptrdiff_t array.
		 */
		List<Long> getOffsets();
		List<Function> getFunctionTable();
		List<DataType> getDataTypes();
		Address getAddress();
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/TypeInfo.java`:

```java
package ghidra.app.cmd.data.rtti;

import ghidra.program.model.data.DataType;
import ghidra.program.model.symbol.Namespace;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.TypeInfoModel;
import ghidra.program.model.address.Address;

/**
 * Interface for modeling std::type_info and its derivatives.
 * <br>
 * All derived models are based on dwarf information from libstdc++.a
 */
public interface TypeInfo {

	static final String SYMBOL_NAME = "typeinfo";
	static final String TYPENAME_SYMBOL_NAME = SYMBOL_NAME + "-name";

	/**
	 * Gets name for the TypeInfo DataType Model
	 * @return the TypeInfo's name
	 */
	String getName();

	/**
	 * Gets the namespace for this TypeInfo
	 * @return the TypeInfo's namespace
	 */
	Namespace getNamespace();

	/**
	 * Gets The TypeInfo's typename string
	 * @return the TypeInfo's typename
	 */
	String getTypeName();

	/**
	 * Gets The TypeInfo's Identifier String
	 * @return the TypeInfo's ID_STRING field
	 * @see TypeInfoModel#ID_STRING
	 */
	String getIdentifier();

	/**
	 * Gets corresponding structure for this TypeInfo Model
	 * @return the type_info or subclasses DataType
	 */
	DataType getDataType();

	/**
	 * Gets the DataType represented by this TypeInfo
	 * @return the represented DataType
	 */
	DataType getRepresentedDataType();

	/**
	 * Gets the address of this TypeInfo structure.
	 * @return the TypeInfo's address.
	 */
	Address getAddress();

}

```

`src/main/java/ghidra/app/cmd/data/rtti/Vtable.java`:

```java
package ghidra.app.cmd.data.rtti;

import java.util.List;

import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.listing.Function;

public interface Vtable {

	public static final InvalidVtable NO_VTABLE = new InvalidVtable();

	public static boolean isValid(Vtable vtable) {
		return vtable != NO_VTABLE;
	}

	/**
	 * Returns the TypeInfo Model this vtable points to
	 * @return the pointed to TypeInfo Model
	 */
	public ClassTypeInfo getTypeInfo();

	/**
	 * Gets the addresses of this vtable's function tables
	 * @return the addresses of this vtable's function tables
	 */
	public Address[] getTableAddresses();

	/**
	 * Gets the address of the start of the vtable
	 * @return the address of the start of the vtable
	 */
	public Address getAddress();

	/**
	 * Gets the function tables in this vtable
	 * @return this vtable's function tables
	 */
	public Function[][] getFunctionTables();

	/**
	 * Checks if this vtable contains the specified function
	 * @param function the function to check for
	 * @return true if this vtable contains the specified function
	 */
	public boolean containsFunction(Function function);

	static class InvalidVtable implements GnuVtable {

		private static final String MESSAGE = "Invalid Vtable";

		private InvalidVtable() {
		}

		@Override
		public ClassTypeInfo getTypeInfo() {
			throw new UnsupportedOperationException(MESSAGE);
		}

		@Override
		public Address[] getTableAddresses() {
			throw new UnsupportedOperationException(MESSAGE);
		}

		@Override
		public Address getAddress() {
			throw new UnsupportedOperationException(MESSAGE);
		}

		@Override
		public Function[][] getFunctionTables() {
			throw new UnsupportedOperationException(MESSAGE);
		}

		@Override
		public boolean containsFunction(Function function) {
			throw new UnsupportedOperationException(MESSAGE);
		}

		@Override
		public long getOffset(int index, int ordinal) {
			throw new UnsupportedOperationException(MESSAGE);
		}

		@Override
		public List<DataType> getDataTypes() {
			throw new UnsupportedOperationException(MESSAGE);
		}

		@Override
		public List<VtablePrefix> getPrefixes() {
			throw new UnsupportedOperationException(MESSAGE);
		}
	}
}
```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/AbstractCreateVtableBackgroundCmd.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.List;

import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeConflictHandler;
import ghidra.program.model.data.DataTypeManager;
import ghidra.framework.model.DomainObject;
import ghidra.program.model.listing.Program;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.util.demangler.DemangledObject;
import ghidra.app.util.demangler.DemanglerOptions;
import ghidra.app.util.demangler.DemanglerUtil;
import ghidra.framework.cmd.BackgroundCommand;
import ghidra.program.model.data.DataUtilities;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.util.exception.CancelledException;

import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.program.model.data.DataUtilities.ClearDataMode;

public abstract class AbstractCreateVtableBackgroundCmd extends BackgroundCommand {

	private GnuVtable vtable;
	private TaskMonitor monitor;
	private Program program;

	private static final DemanglerOptions OPTIONS = new DemanglerOptions();

	protected AbstractCreateVtableBackgroundCmd(GnuVtable vtable, String name) {
		super(name, true, true, false);
		this.vtable = vtable;
	}

	@Override
	public boolean applyTo(DomainObject obj, TaskMonitor taskMonitor) {
		try {
			if (!(obj instanceof Program)) {
				String message = "Can only apply a vtable data type to a program.";
				Msg.error(this, message);
				return false;
			}
			program = (Program) obj;
			monitor = taskMonitor;
			return doApplyTo();
		} catch (CancelledException e) {
			setStatusMsg("User cancelled " + getName() + ".");
			return false;
		}
	}

	private boolean doApplyTo() throws CancelledException {
		try {
			monitor.checkCanceled();
			createData(vtable.getDataTypes());
			return createAssociatedData();
		} catch (CodeUnitInsertionException e) {
			Msg.error(this, e);
			return false;
		}
	}

	private void createData(List<DataType> dataTypes) throws CodeUnitInsertionException {
		Listing listing = program.getListing();
		DataTypeManager dtm = program.getDataTypeManager();
		Address currentAddress = vtable.getAddress();
		for (DataType dt : dataTypes) {
			dt = dtm.resolve(dt, DataTypeConflictHandler.KEEP_HANDLER);
			Data data = listing.getDataContaining(currentAddress);
			if (data != null && data.getDataType().equals(dt)) {
				currentAddress = currentAddress.add(data.getLength());
				continue;
			}
			DataUtilities.createData(
				program, currentAddress, dt, 0,
				false, ClearDataMode.CLEAR_ALL_CONFLICT_DATA);
			currentAddress = currentAddress.add(dt.getLength());
		}
	}

	protected abstract String getMangledString() throws InvalidDataTypeException;
	protected abstract String getSymbolName();

	private boolean createAssociatedData() {
		try {
			DemangledObject demangled = DemanglerUtil.demangle(program, getMangledString());
			return demangled.applyTo(program, vtable.getAddress(), OPTIONS, monitor);
		} catch (Exception e) {
			return false;
		}
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/ClassTypeInfoUtils.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.GnuClassTypeInfoDB;
import cppclassanalyzer.data.typeinfo.AbstractClassTypeInfoDB.TypeId;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import util.CollectionUtils;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.BaseClassTypeInfoModel;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.VmiClassTypeInfoModel;
import ghidra.app.cmd.disassemble.DisassembleCommand;
import ghidra.app.cmd.function.CreateFunctionCmd;
import ghidra.app.util.NamespaceUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.SpecialAddress;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.*;
import ghidra.program.model.mem.DumbMemBufferImpl;
import ghidra.program.model.mem.MemBuffer;
import ghidra.program.model.mem.Memory;
import ghidra.program.model.scalar.Scalar;
import ghidra.program.model.symbol.*;
import ghidra.util.Msg;
import ghidra.util.exception.*;
import ghidra.util.task.TaskMonitor;

import static ghidra.app.cmd.data.rtti.GnuVtable.PURE_VIRTUAL_FUNCTION_NAME;

public class ClassTypeInfoUtils {

	private static final String PLACEHOLDER_DESCRIPTION = "PlaceHolder Class Structure";
	private static final String MISSING = "Missing";

	private ClassTypeInfoUtils() {
	}

	/**
	 * Finds the Vtable for the corresponding TypeInfo
	 *
	 * @param program the program to be searched
	 * @param address the address of the TypeInfo Model's DataType
	 * @param monitor the taskmonitor to be used while searching for the vtable
	 * @return The TypeInfo's Vtable Model or null if none exists
	 * @throws CancelledException if the search is cancelled
	 */
	public static Vtable findVtable(Program program, Address address, TaskMonitor monitor)
		throws CancelledException {
			ProgramClassTypeInfoManager manager = CppClassAnalyzerUtils.getManager(program);
			ClassTypeInfo type = manager.getType(address);
			if (type != null) {
				return findVtable(program, type, monitor);
			}
			return Vtable.NO_VTABLE;
	}

	/**
	 * Finds the Vtable for the corresponding TypeInfo
	 *
	 * @param program the program to be searched
	 * @param type the typeinfo to find the vtable for
	 * @param monitor the taskmonitor to be used while searching for the vtable
	 * @return The TypeInfo's Vtable Model or null if none exists
	 * @throws CancelledException if the search is cancelled
	 */
	public static Vtable findVtable(Program program, ClassTypeInfo type, TaskMonitor monitor)
		throws CancelledException {
			SymbolTable table = program.getSymbolTable();
			Listing listing = program.getListing();
			List<Symbol> symbols =
				table.getSymbols(VtableModel.SYMBOL_NAME, type.getNamespace());
			for (Symbol symbol : symbols) {
				try {
					return new VtableModel(program, symbol.getAddress(), type);
				} catch (InvalidDataTypeException e) {
					break;
				}
			}
			Set<Address> references = Collections.emptySet();
			Data tiData = listing.getDataAt(type.getAddress());
			if (tiData != null) {
				references = CollectionUtils.asStream(tiData.getReferenceIteratorTo())
					.map(Reference::getFromAddress)
					.filter(Predicate.not(SpecialAddress.class::isInstance))
					.collect(Collectors.toSet());
				if (!references.isEmpty()) {
					Vtable vtable = getValidVtable(program, references, monitor, type);
					if (Vtable.isValid(vtable)) {
						return vtable;
					}
				}
			}
			if (type.getName().contains("type_info")) {
				references = GnuUtils.getDirectDataReferences(program, type.getAddress());
				if (!references.isEmpty()) {
					Vtable vtable = getValidVtable(program, references, monitor, type);
					if (Vtable.isValid(vtable)) {
						return vtable;
					}
				}
			}
			return Vtable.NO_VTABLE;
	}

	private static boolean invalidData(Data data) {
		if (data == null) {
			return false;
		}
		if (data.getDataType() instanceof Pointer) {
			return false;
		}
		if (data.getDataType() instanceof DefaultDataType) {
			return false;
		}
		return true;
	}

	private static Vtable getValidVtable(Program program, Set<Address> references,
		TaskMonitor monitor, ClassTypeInfo typeinfo) throws CancelledException {
		Listing listing = program.getListing();
		Memory mem = program.getMemory();
		DataType ptrDiff = GnuUtils.getPtrDiff_t(program.getDataTypeManager());
		Scalar zero = new Scalar(ptrDiff.getLength(), 0);
		boolean hasPureVirtual = program.getSymbolTable().getSymbols(
			PURE_VIRTUAL_FUNCTION_NAME).hasNext();
		for (Address reference : references) {
			monitor.checkCanceled();
			MemBuffer buf = new DumbMemBufferImpl(mem, reference.subtract(ptrDiff.getLength()));
			Object value = ptrDiff.getValue(
				buf, ptrDiff.getDefaultSettings(), ptrDiff.getLength());
			if(!zero.equals(value)) {
				continue;
			}
			Data data = listing.getDataContaining(reference);
			if (invalidData(data)) {
				continue;
			}
			try {
				final VtableModel vtable = new VtableModel(program, reference, typeinfo);
				final Function[][] functionTables = vtable.getFunctionTables();
				if (functionTables.length > 0) {
					if (functionTables[0].length > 0) {
						if (functionTables[0][0] == null) {
							for (Function function : functionTables[0]) {
								if (function == null) {
									continue;
								} if (hasPureVirtual) {
									if (PURE_VIRTUAL_FUNCTION_NAME.equals(function.getName())) {
										return vtable;
									}
								} else {
									return vtable;
								}
							}
							// construction vtable
							continue;
						}
					}
				}
				return vtable;
			} catch (InvalidDataTypeException e) {
				continue;
			}
		}
		return VtableModel.NO_VTABLE;
	}

	/**
	 * Gets the placeholder struct for a ClassTypeInfo in a specified DataTypeManager
	 * @param type the ClassTypeInfo
	 * @param dtm the DataTypeManager
	 * @return the placeholder struct for a ClassTypeInfo in a specified DataTypeManager
	 */
	public static Structure getPlaceholderStruct(ClassTypeInfo type, DataTypeManager dtm) {
		ProgramClassTypeInfoManager manager =
			CppClassAnalyzerUtils.getManager(type.getGhidraClass().getSymbol().getProgram());
		DataType thiscallStruct =
			VariableUtilities.findOrCreateClassStruct(type.getGhidraClass(), dtm);
		ClassTypeInfo otherType = manager.getType(thiscallStruct.getUniversalID());
		if (otherType != null && !otherType.equals(type)) {
			return getFixedIncorrectStructure(type, dtm);
		}
		CategoryPath path = TypeInfoUtils.getCategoryPath(type);
		CategoryPath otherPath = thiscallStruct.getCategoryPath();
		if (!path.isRoot() && !otherPath.isRoot()) {
			if (path.equals(otherPath)) {
				return (Structure) thiscallStruct;
			}
		}
		Namespace ns = type.getNamespace().getParentNamespace();
		if (ns != null && !ns.isGlobal() && ns.getName().equals(path.getName())) {
			// assume VariableUtilities found the type from debug info
			return (Structure) thiscallStruct;
		}
		if (path.isRoot() && !otherPath.isRoot()) {
			// assume VariableUtilities found the type from debug info
			return (Structure) thiscallStruct;
		}
		return getFixedIncorrectStructure(type, dtm);
	}

	private static Structure getFixedIncorrectStructure(ClassTypeInfo type, DataTypeManager dtm) {
		String msg = "Variable Utils returned wrong class structure! " + type.getName();
		Msg.warn(ClassTypeInfoUtils.class, msg);
		int id = dtm.startTransaction("getting placeholder struct for "+type.getName());
		boolean success = false;
		try {
			CategoryPath path = TypeInfoUtils.getDataTypePath(type).getCategoryPath();
			DataType struct = dtm.getDataType(path, type.getName());
			if (struct == null) {
				struct = new StructureDataType(path, type.getName(), 0, dtm);
				struct = dtm.resolve(struct, DataTypeConflictHandler.KEEP_HANDLER);
			}
			success = true;
			return (Structure) struct;
		} finally {
			dtm.endTransaction(id, success);
		}
	}

	/**
	 * Returns true if the Structure is a "placeholder" structure.
	 *
	 * @param struct the Structure to check.
	 * @return true if the Structure is a "placeholder" structure.
	 */
	public static boolean isPlaceholder(Structure struct) {
		if (struct == null) {
			return true;
		}
		String description = struct.getDescription();
		return description.equals(PLACEHOLDER_DESCRIPTION) || description.startsWith(MISSING);
	}

	/**
	 * Gets the function for the ClassTypeInfo at the specified address.
	 *
	 * @param program the Program the function is in.
	 * @param type the ClassTypeInfo for the function.
	 * @param address the Address of the function.
	 * @return the requested ClassTypeInfo's function.
	 */
	public static Function getClassFunction(Program program, ClassTypeInfo type, Address address) {
		Listing listing = program.getListing();
		FunctionManager functionManager = program.getFunctionManager();
		if (listing.getInstructionAt(address) == null) {
			DisassembleCommand cmd = new DisassembleCommand(address, null, true);
			cmd.applyTo(program);
		}
		if (!functionManager.isInFunction(address)) {
			CreateFunctionCmd cmd = new CreateFunctionCmd(address, true);
			if (!cmd.applyTo(program)) {
				return null;
			}
		}
		Function function = functionManager.getFunctionContaining(address);
		if (listing.getInstructionAt(function.getEntryPoint()) == null) {
			DisassembleCommand cmd =
				new DisassembleCommand(function.getEntryPoint(), null, true);
			cmd.applyTo(program);
		}
		try {
			if (function.isThunk()) {
				function = function.getThunkedFunction(true);
			}
			function.setParentNamespace(type.getGhidraClass());
			function.setCallingConvention(GenericCallingConvention.thiscall.getDeclarationName());
			// necessary due to ghidra bug.
			function.setCustomVariableStorage(true);
			function.setCustomVariableStorage(false);
			return function;
		} catch (Exception e) {
			throw new AssertException(String.format(
				"Failed to retrieve class function for %s at %s", type, address), e);
		}
	}

	/**
	 * Sets the provided function to be a class function for the provided type
	 * @param type the class type
	 * @param function the function
	 * @throws IllegalArgumentException if the function is external
	 */
	public static void setClassFunction(ClassTypeInfo type, Function function) {
		Objects.requireNonNull(type);
		Objects.requireNonNull(function);
		if (function.isExternal()) {
			throw new IllegalArgumentException(function.getName(true)+" is an external function");
		}
		Address entry = function.getEntryPoint();
		if (function.getBody().getNumAddresses() <= 1) {
			DisassembleCommand cmd =
				new DisassembleCommand(entry, null, true);
			cmd.applyTo(function.getProgram());
		}
		if (function.isThunk()) {
			function = function.getThunkedFunction(true);
		}
		boolean success = false;
		int id = function.getProgram().startTransaction(
			String.format("Setting class function for %s at %s", type, entry));
		try {
			function.setParentNamespace(type.getGhidraClass());
			function.setCallingConvention(GenericCallingConvention.thiscall.getDeclarationName());
			success = true;
		} catch (Exception e) {
			throw new AssertException(String.format(
				"Failed to retrieve class function for %s at %s", type, entry), e);
		} finally {
			function.getProgram().endTransaction(id, success);
		}
	}

	/**
	 * Sorts a list of classes in order of most derived
	 * @param program the program containing the list of ClassTypeInfo
	 * @param classes the list of ClassTypeInfo
	 * @param monitor the task monitor
	 * @throws CancelledException if the operation is cancelled
	 */
	public static void sortByMostDerived(Program program, List<ClassTypeInfo> classes,
		TaskMonitor monitor) throws CancelledException {
			Set<ClassTypeInfo> classSet = new LinkedHashSet<>(classes);
			List<ClassTypeInfo> sortedClasses = new ArrayList<>(classes.size());
			Iterator<ClassTypeInfo> classIterator = classSet.iterator();
			while (classIterator.hasNext()) {
				monitor.checkCanceled();
				ClassTypeInfo type = classIterator.next();
				ArrayDeque<ClassTypeInfo> stack = new ArrayDeque<>();
				stack.push(type);
				while(!stack.isEmpty()) {
					monitor.checkCanceled();
					ClassTypeInfo classType = stack.pop();
					if (classType.hasParent() && classSet.contains(classType)) {
						ClassTypeInfo parent = classType.getParentModels()[0];
						if (classSet.contains(parent)) {
							stack.push(classType);
							stack.push(parent);
							continue;
						}
					}
					sortedClasses.add(classType);
					classSet.remove(classType);
				} classIterator = classSet.iterator();
			}
			classes.clear();
			classes.addAll(sortedClasses);
	}

	/**
	 * Gets the DataType representation of the _vptr for the specified ClassTypeInfo.
	 * @param program the program containing the ClassTypeInfo
	 * @param type the ClassTypeInfo
	 * @return the ClassTypeInfo's _vptr DataType
	 */
	public static DataType getVptrDataType(Program program, ClassTypeInfo type) {
		try {
			Vtable vtable = type.getVtable();
			CategoryPath path =
				new CategoryPath(TypeInfoUtils.getCategoryPath(type), type.getName());
			DataTypeManager dtm = program.getDataTypeManager();
			Structure struct = new StructureDataType(path, VtableModel.SYMBOL_NAME, 0, dtm);
			Function[][] functionTable = vtable.getFunctionTables();
			if (functionTable.length > 0 && functionTable[0].length > 0) {
				for (Function function : functionTable[0]) {
					if (function != null) {
						if (function.getName().equals(PURE_VIRTUAL_FUNCTION_NAME)) {
							DataType dt = dtm.getPointer(VoidDataType.dataType);
							struct.add(dt, dt.getLength(), PURE_VIRTUAL_FUNCTION_NAME, null);
							continue;
						}
						DataType dt = new FunctionDefinitionDataType(function, false);
						dt.setCategoryPath(path);
						if (dtm.contains(dt)) {
							dt = dtm.getDataType(dt.getDataTypePath());
						} else {
							dt = dtm.resolve(dt, DataTypeConflictHandler.KEEP_HANDLER);
						}
						dt = dtm.getPointer(dt);
						struct.add(dt, dt.getLength(), function.getName(), null);
					} else {
						struct.add(PointerDataType.dataType);
					}
				}
			}
			struct.setPackingEnabled(true);
			struct.setToMachineAligned();
			struct = (Structure) dtm.resolve(struct, DataTypeConflictHandler.REPLACE_HANDLER);
			return dtm.getPointer(struct);
		} catch (DuplicateNameException e) {
			throw new AssertException("Ghidra-Cpp-Class-Analyzer: "+e.getMessage(), e);
		}
	}

	/**
	 * Gets the DataType representation of the _vptr for the specified ClassTypeInfo.
	 * @param program the program containing the ClassTypeInfo
	 * @param type the ClassTypeInfo
	 * @param path The category path to place the datatype in.
	 * @return the ClassTypeInfo's _vptr DataType
	 * @deprecated the path parameter is now ignored
	 */
	@Deprecated(forRemoval=true)
	public static DataType getVptrDataType(Program program, ClassTypeInfo type, CategoryPath path) {
		return getVptrDataType(program, type);
	}

	public static Map<ClassTypeInfo, Integer> getBaseOffsets(ClassTypeInfo type) {
		if (!type.hasParent()) {
			return Collections.emptyMap();
		}
		if (type.getParentModels().length == 1) {
			if (Vtable.isValid(type.getVtable())) {
				GnuVtable vtable = (GnuVtable) type.getVtable();
				long offset = vtable.getOffset(0, 0);
				if (offset < Long.MAX_VALUE && offset > 0) {
					return Map.of(type.getParentModels()[0], (int) offset);
				}
			}
			return Map.of(type.getParentModels()[0], 0);
		}
		if (type instanceof VmiClassTypeInfoModel) {
			VmiClassTypeInfoModel vmi = (VmiClassTypeInfoModel) type;
			List<Long> offsets = vmi.getOffsets();
			ClassTypeInfo[] parents = vmi.getParentModels();
			Map<ClassTypeInfo, Integer> result = new HashMap<>(parents.length);
			for (int i = 0; i < parents.length; i++) {
				result.put(parents[i], offsets.get(i).intValue());
			}
			return result;
		}
		throw new IllegalArgumentException("Ghidra-Cpp-Class-Analyzer: type must be a GNU ClassTypeInfo");
	}

	public static GhidraClass getGhidraClassFromTypeName(Program program, String typename) {
		Namespace ns = TypeInfoUtils.getNamespaceFromTypeName(program, typename);
		if (ns instanceof GhidraClass) {
			return (GhidraClass) ns;
		}
		try {
			if (!ns.isGlobal()) {
				return NamespaceUtils.convertNamespaceToClass(ns);
			}
		} catch (InvalidInputException e) {
			// impossible
			throw new AssertException(e);
		}
		throw new AssertException(
			"Ghidra-Cpp-Class-Analyzer: failed to get GhidraClass from typename "
			+ typename);
	}

	public static int getMaxVtableCount(ClassTypeInfo type) {
		if (type instanceof VmiClassTypeInfoModel) {
			return doGetMaxVtableCount(type);
		}
		if (type instanceof GnuClassTypeInfoDB) {
			if (((GnuClassTypeInfoDB) type).getTypeId() == TypeId.VMI_CLASS) {
				return doGetMaxVtableCount(type);
			}
		}
		return type.getVirtualParents().size()+1;
	}

	private static int doGetMaxVtableCount(ClassTypeInfo type) {
		Program program = type.getGhidraClass().getSymbol().getProgram();
		int defaultMax = type.getVirtualParents().size()+1;
		BaseClassTypeInfoModel[] bases;
		if (type instanceof VmiClassTypeInfoModel) {
			// vmi already has it constructed so check first
			bases = ((VmiClassTypeInfoModel) type).getBases();
		} else {
			bases = VmiClassTypeInfoModel.getBases(program, type.getAddress());
		}
		int offset = Arrays.stream(bases)
			.map(BaseClassTypeInfoModel::getVirtualBases)
			.flatMap(Set::stream)
			.mapToInt(BaseClassTypeInfoModel::getOffset)
			.min()
			.orElse(0);
		if (offset >= 0) {
			return type.getVirtualParents().size()+1;
		}
		return Math.max(defaultMax, Math.abs(offset) / program.getDefaultPointerSize() - 1);
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/CreateConstructionVtableBackgroundCmd.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.TypeInfo;

public class CreateConstructionVtableBackgroundCmd extends AbstractCreateVtableBackgroundCmd {

	private static final String NAME = CreateConstructionVtableBackgroundCmd.class.getSimpleName();

	private TypeInfo parent;
	private TypeInfo child;

	private static final String PREFIX = "_ZTC";
	private static final String SEPARATOR = "_";

	public CreateConstructionVtableBackgroundCmd(GnuVtable vtable, ClassTypeInfo child) {
		super(vtable, NAME);
		this.parent = vtable.getTypeInfo();
		this.child = child;
	}

	@Override
	protected String getSymbolName() {
		return VtableModel.CONSTRUCTION_SYMBOL_NAME;
	}

	@Override
	protected String getMangledString() {
		return PREFIX+child.getTypeName()+SEPARATOR+parent.getTypeName();
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/CreateTypeInfoBackgroundCmd.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;
import ghidra.program.model.listing.Data;
import ghidra.program.model.data.DataType;
import ghidra.framework.model.DomainObject;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.framework.cmd.BackgroundCommand;
import ghidra.program.model.data.DataUtilities;
import ghidra.util.exception.CancelledException;
import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.VmiClassTypeInfoModel;
import ghidra.app.util.demangler.DemangledObject;
import ghidra.app.util.demangler.DemanglerOptions;
import ghidra.app.util.demangler.DemanglerUtil;
import ghidra.program.model.util.CodeUnitInsertionException;

import static ghidra.app.util.datatype.microsoft.MSDataTypeUtils.getAbsoluteAddress;
import static ghidra.program.model.data.DataUtilities.ClearDataMode.CLEAR_ALL_CONFLICT_DATA;


public class CreateTypeInfoBackgroundCmd extends BackgroundCommand {

	private static final String NAME = CreateTypeInfoBackgroundCmd.class.getSimpleName();
	private static final DemanglerOptions OPTIONS = new DemanglerOptions();

	private TypeInfo type;
	private TaskMonitor monitor;
	private Program program;

	/**
	 * Constructs a command for applying a TypeInfo at an address
	 * and its associated data.
	 *
	 * @param typeInfo the TypeInfo to be created.
	 */
	public CreateTypeInfoBackgroundCmd(TypeInfo typeInfo) {
		super(NAME, true, true, false);
		this.type = typeInfo;
	}

	@Override
	public final boolean applyTo(DomainObject obj, TaskMonitor taskMonitor) {
		try {
			if (!(obj instanceof Program)) {
				String message = "Can only apply a " + type.getName() + " data type to a program.";
				Msg.error(this, message);
				return false;
			}
			program = (Program) obj;
			monitor = taskMonitor;
			return doApplyTo();
		} catch (CancelledException e) {
			setStatusMsg("User cancelled " + getName() + ".");
		}
		return false;
	}

	private boolean doApplyTo() throws CancelledException {
		try {
			monitor.checkCanceled();
			Data data = createData(type.getAddress(), type.getDataType());
			if (type.getIdentifier().equals(VmiClassTypeInfoModel.ID_STRING)) {
				DataType array = VmiClassTypeInfoModel.getBaseArrayDataType(data);
				Address arrayAddress = type.getAddress().add(data.getLength());
				createData(arrayAddress, array);
			}
			return applyTypeInfoSymbols() && data != null;
		} catch (CodeUnitInsertionException e) {
			Msg.error(this, e);
		} catch (RuntimeException e) {
			Throwable cause = e.getCause();
			if (cause instanceof MemoryAccessException) {
				Address addr = type.getAddress();
				if (addr != null) {
					Msg.error(this, "Failed to apply typeinfo at "+type.getAddress().toString(), cause);
				} else {
					Msg.error(this, "Failed to apply typeinfo because it's address is null", cause);
				}
			}
		}
		return false;
	}

	private Data createData(Address address, DataType dt) throws CodeUnitInsertionException {
		return DataUtilities.createData(program, address, dt, 0, false, CLEAR_ALL_CONFLICT_DATA);
	}

	private boolean applyTypeInfoSymbols() {
		Address typenameAddress = getAbsoluteAddress(
			program, type.getAddress().add(program.getDefaultPointerSize()));
		String typename = type.getTypeName();
		try {
			DemangledObject demangled = DemanglerUtil.demangle(program, "_ZTI" +typename);
			if (demangled != null) {
				demangled.applyTo(program, type.getAddress(), OPTIONS, monitor);
			}
			demangled = DemanglerUtil.demangle(program, "_ZTS" +typename);
			if (demangled != null) {
				demangled.applyTo(program, typenameAddress, OPTIONS, monitor);
			}
			return true;
		} catch (Exception e) {
			setStatusMsg(e.getMessage());
			return false;
		}
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/CreateVtableBackgroundCmd.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.TypeInfo;

public class CreateVtableBackgroundCmd extends AbstractCreateVtableBackgroundCmd {

	private static final String NAME = CreateVtableBackgroundCmd.class.getSimpleName();

	private static final String SYMBOL_NAME = "vtable";

	private TypeInfo type;

	public CreateVtableBackgroundCmd(GnuVtable vtable) {
		super(vtable, NAME);
		this.type = vtable.getTypeInfo();
	}

	@Override
	protected String getSymbolName() {
		return SYMBOL_NAME;
	}

	@Override
	protected String getMangledString() {
		return VtableModel.MANGLED_PREFIX+type.getTypeName();
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/CreateVttBackgroundCmd.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;

import ghidra.program.model.listing.Data;
import ghidra.program.model.data.Array;
import ghidra.program.model.data.DataType;
import ghidra.framework.model.DomainObject;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.util.demangler.DemangledObject;
import ghidra.app.util.demangler.DemanglerOptions;
import ghidra.app.util.demangler.DemanglerUtil;
import ghidra.framework.cmd.BackgroundCommand;
import ghidra.program.model.data.DataUtilities;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.Pointer;
import ghidra.util.exception.CancelledException;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.program.model.data.DataUtilities.ClearDataMode;

public class CreateVttBackgroundCmd extends BackgroundCommand {

	private static final String NAME = CreateVttBackgroundCmd.class.getSimpleName();

	private VttModel vtt;
	private ClassTypeInfo child;
	private TaskMonitor monitor;
	private Program program;

	private static final String PREFIX = "_ZTT";
	private static final String VTT = "VTT";
	private static final DemanglerOptions OPTIONS = new DemanglerOptions();

	public CreateVttBackgroundCmd(VttModel vtt, ClassTypeInfo child) {
		super(NAME, true, true, false);
		this.vtt = vtt;
		this.child = child;
	}

	@Override
	public final boolean applyTo(DomainObject obj, TaskMonitor taskMonitor) {
		try {
			if (!vtt.isValid()) {
				return false;
			} else if (!(obj instanceof Program)) {
				String message = "Can only apply a vtable data type to a program.";
				Msg.error(this, message);
				return false;
			}
			program = (Program) obj;
			monitor = taskMonitor;
			return doApplyTo();
		} catch (CancelledException e) {
			setStatusMsg("User cancelled " + getName() + ".");
			return false;
		}
	}

	private boolean doApplyTo() throws CancelledException {
		try {
			monitor.checkCanceled();
			Data data = program.getListing().getDataContaining(vtt.getAddress());
			if (data != null && data.isArray()) {
				Array array = (Array) data.getDataType();
				if (array.getDataType() instanceof Pointer) {
					if (array.getNumElements() > vtt.getElementCount()) {
						return createAssociatedData();
					}
				}
			}
			createData(vtt.getAddress(), vtt.getDataType());
			return createAssociatedData();
		} catch (CodeUnitInsertionException | InvalidDataTypeException e) {
			Msg.trace(this, e);
			return false;
		}
	}

	private Data createData(Address address, DataType dt) throws CodeUnitInsertionException {
		return DataUtilities.createData(program, address, dt, 0, false, ClearDataMode.CLEAR_ALL_CONFLICT_DATA);
	}

	private boolean createAssociatedData() throws InvalidDataTypeException {
		SymbolTable table = program.getSymbolTable();
		for (GnuVtable model : vtt.getConstructionVtableModels()) {
			if (model instanceof VtableModel && ((VtableModel) model).isConstruction()) {
					CreateConstructionVtableBackgroundCmd cmd =
					new CreateConstructionVtableBackgroundCmd(model, child);
					if (!cmd.applyTo(program, monitor)) {
						return false;
					}
			} else {
				CreateVtableBackgroundCmd cmd =
				new CreateVtableBackgroundCmd(model);
				if (!cmd.applyTo(program, monitor)) {
					return false;
				}
			}
		}
		Symbol primarySymbol = table.getPrimarySymbol(vtt.getAddress());
		if (primarySymbol != null && primarySymbol.getName().equals(VTT)) {
			return true;
		}
		try {
			DemangledObject demangled = DemanglerUtil.demangle(program, PREFIX+child.getTypeName());
			if (!demangled.applyTo(program, vtt.getAddress(), OPTIONS, monitor)) {
				return false;
			}
			Symbol[] symbols = table.getSymbols(vtt.getAddress());
			for (Symbol symbol : symbols) {
				if (symbol.getName(true).equals(demangled.getDemangledName())) {
					symbol.setPrimary();
				}
			}
			return true;
		} catch (Exception e) {
			Msg.error(this, e);
			return false;
		}
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/ExternalClassTypeInfo.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.Set;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.util.NamespaceUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.listing.Program;
import ghidra.program.model.reloc.Relocation;
import ghidra.program.model.symbol.Namespace;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

/**
 * Representation of a dynamically linked ClassTypeInfo
 * @deprecated
 * @see cppclassanalyzer.data.typeinfo.ArchivedClassTypeInfo
 * ArchivedGnuClassTypeInfo
 */
@Deprecated(since = "1.5", forRemoval = true)
public class ExternalClassTypeInfo implements ClassTypeInfo {

	private final Program program;
	private final Relocation reloc;

	public ExternalClassTypeInfo(Program program, Relocation reloc) {
		this.program = program;
		this.reloc = reloc;
		if (reloc.getSymbolName() == null) {
			throw new AssertException(
				String.format("External Relocation at %s has no symbol name", reloc.getAddress()));
		}
	}

	@Override
	public String getName() {
		Namespace ns = TypeInfoUtils.getNamespaceFromTypeName(program, reloc.getSymbolName());
		return ns.getName();
	}

	@Override
	public Namespace getNamespace() {
		return TypeInfoUtils.getNamespaceFromTypeName(program, reloc.getSymbolName());
	}

	@Override
	public String getTypeName() {
		return reloc.getSymbolName();
	}

	@Override
	public String getIdentifier() {
		throw new UnsupportedOperationException(getClass().getSimpleName()+" has no identifier");
	}

	@Override
	public DataType getDataType() {
		// This successfully prevents its creation in the listing
		return null;
	}

	@Override
	public Address getAddress() {
		return reloc.getAddress();
	}

	@Override
	public GhidraClass getGhidraClass() {
		Namespace ns = getNamespace();
		if (ns instanceof GhidraClass) {
			return (GhidraClass) ns;
		}
		try {
			return NamespaceUtils.convertNamespaceToClass(ns);
		} catch (InvalidInputException e) {
			// should not occur
			throw new AssertException(e);
		}
	}

	@Override
	public boolean hasParent() {
		return false;
	}

	@Override
	public ClassTypeInfo[] getParentModels() {
		throw new UnsupportedOperationException(
			"Cannot determine the parent models of an "+getClass().getSimpleName());
	}

	@Override
	public Set<ClassTypeInfo> getVirtualParents() {
		throw new UnsupportedOperationException(
			"Cannot determine the virtual parent models of an "+getClass().getSimpleName());
	}

	@Override
	public boolean isAbstract() {
		throw new UnsupportedOperationException(
			String.format("Cannot determine if an %s is abstract", getClass().getSimpleName()));
	}

	@Override
	public Vtable getVtable() {
		return Vtable.NO_VTABLE;
	}

	@Override
	public Vtable findVtable(TaskMonitor monitor) throws CancelledException {
		return Vtable.NO_VTABLE;
	}

	@Override
	public Structure getClassDataType() {
		return ClassTypeInfoUtils.getPlaceholderStruct(this, program.getDataTypeManager());
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/ExternalClassTypeInfoFactory.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.Set;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.symbol.Symbol;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

public class ExternalClassTypeInfoFactory {

	private ExternalClassTypeInfoFactory() {
	}

	public static ClassTypeInfo getExternalTypeInfo(Program program, Address address) {
		return new UnresolvedExternalTypeInfo(program, address);
	}

	private static class UnresolvedExternalTypeInfo implements ClassTypeInfo {

		private final Address address;
		private final String symbol;

		UnresolvedExternalTypeInfo(Program program, Address address) {
			this.address = address;
			Symbol s = program.getSymbolTable().getPrimarySymbol(address);
			this.symbol = s != null ? s.getName(true) : "";
		}

		@Override
		public String getName() {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

		@Override
		public Namespace getNamespace() {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

		@Override
		public String getTypeName() {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

		@Override
		public String getIdentifier() {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

		@Override
		public DataType getDataType() {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

		@Override
		public Address getAddress() {
			return address;
		}

		@Override
		public GhidraClass getGhidraClass() {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

		@Override
		public boolean hasParent() {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

		@Override
		public ClassTypeInfo[] getParentModels() {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

		@Override
		public Set<ClassTypeInfo> getVirtualParents() {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

		@Override
		public boolean isAbstract() {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

		@Override
		public Vtable findVtable(TaskMonitor monitor) throws CancelledException {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

		@Override
		public Vtable getVtable() {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

		@Override
		public Structure getClassDataType() {
			throw new UnresolvedClassTypeInfoException(address, symbol);
		}

	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/GccCppClassBuilder.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.Map;

import ghidra.app.cmd.data.rtti.AbstractCppClassBuilder;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import cppclassanalyzer.data.typeinfo.AbstractClassTypeInfoDB;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.Structure;

import static ghidra.program.model.data.Undefined.isUndefined;

public class GccCppClassBuilder extends AbstractCppClassBuilder {

	private static final String VPTR = "_vptr";

	public GccCppClassBuilder(ClassTypeInfo type) {
		super(type);
	}

	@Override
	protected AbstractCppClassBuilder getParentBuilder(ClassTypeInfo parent) {
		return new GccCppClassBuilder(parent);
	}

	@Override
	protected void addVptr(Structure struct) {
		if (!Vtable.isValid(getType().getVtable())) {
			return;
		}
		DataType vptr = ClassTypeInfoUtils.getVptrDataType(getProgram(), getType());
		DataTypeComponent comp = struct.getComponentAt(0);
		if (comp == null || isUndefined(comp.getDataType())) {
			if (vptr != null) {
				clearComponent(struct, getProgram().getDefaultPointerSize(), 0);
				struct.insertAtOffset(0, vptr, vptr.getLength(), VPTR, null);
			}
		} else if (comp.getFieldName() == null || !comp.getFieldName().startsWith(SUPER)) {
			clearComponent(struct, getProgram().getDefaultPointerSize(), 0);
			struct.insertAtOffset(0, vptr, vptr.getLength(), VPTR, null);
		}
	}

	@Override
	protected Map<ClassTypeInfo, Integer> getBaseOffsets() {
		ClassTypeInfo type = getType();
		if (type instanceof AbstractClassTypeInfoDB) {
			return ((AbstractClassTypeInfoDB) type).getBaseOffsets();
		}
		return ClassTypeInfoUtils.getBaseOffsets(type);
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/GnuUtils.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.List;
import java.util.Set;
import java.util.Collections;

import docking.Tool;
import ghidra.program.model.data.DataType;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.util.datatype.microsoft.MSDataTypeUtils;
import ghidra.app.util.demangler.*;
import ghidra.framework.main.AppInfo;
import ghidra.framework.model.DomainFile;
import ghidra.framework.model.Project;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.address.Address;
import ghidra.program.model.mem.*;
import ghidra.program.model.reloc.Relocation;
import ghidra.program.model.reloc.RelocationTable;
import ghidra.program.model.symbol.*;
import ghidra.program.model.listing.Library;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;
import ghidra.program.model.data.*;
import ghidra.program.util.ProgramMemoryUtil;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.DummyCancellableTaskMonitor;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.utils.CppClassAnalyzerUtils;

import static ghidra.app.util.demangler.DemanglerUtil.demangle;
import static ghidra.plugins.fsbrowser.FSBUtils.getProgramManager;
import static ghidra.program.model.data.DataTypeConflictHandler.KEEP_HANDLER;

/**
 * Static Utility Class for GNU Binaries
 */
public final class GnuUtils {

	private static final String PTRDIFF = "ptrdiff_t";
	private static final String PPC = "PowerPC";
	private static final String CXXABI = "__cxxabiv1";
	private static final String EXTERNAL = "<EXTERNAL>";

	public static final Set<String> COMPILER_NAMES = Set.of("gcc", "default");

	private static final CategoryPath CXXABI_PATH = new CategoryPath(CategoryPath.ROOT, CXXABI);

	private GnuUtils() {
	}

	/**
	 * Gets the {@value #CXXABI} CategoryPath
	 * @return the {@value #CXXABI} CategoryPath
	 */
	public static CategoryPath getCxxAbiCategoryPath() {
		return CXXABI_PATH;
	}

	/**
	 * @param dtm the programs datatype manager
	 * @return true if LLP64 was defined
	 */
	public static boolean isLLP64(DataTypeManager dtm) {
		return dtm.getDataOrganization().getPointerSize() == 8;
	}

	private static DataType createPtrDiff(DataTypeManager dtm) {
		DataOrganization org = dtm.getDataOrganization();
		DataType dataType = AbstractIntegerDataType.getSignedDataType(org.getPointerSize(), dtm);
		return new TypedefDataType(CategoryPath.ROOT, PTRDIFF, dataType, dtm);
	}

	/**
	 * Gets the appropriate TypeDefDataType for the builtin __PTRDIFF_TYPE__
	 * @param dtm the programs datatype manager
	 * @return the appropriate TypeDefDataType for the builtin __PTRDIFF_TYPE__
	 */
	public static DataType getPtrDiff_t(DataTypeManager dtm) {
		DataType ptrdiff_t = createPtrDiff(dtm);
		if (dtm.contains(ptrdiff_t)) {
			return dtm.resolve(ptrdiff_t, KEEP_HANDLER);
		}
		return ptrdiff_t;
	}

	/**
	 * Gets the size in bytes of __PTRDIFF_TYPE__
	 * @param dtm the programs datatype manager
	 * @return the size in bytes of __PTRDIFF_TYPE__
	 */
	public static int getPtrDiffSize(DataTypeManager dtm) {
		return getPtrDiff_t(dtm).getLength();
	}

	/**
	 * Gets all MemoryBlocks in a Program which hold non-volatile data
	 * @param program the program to be searched
	 * @return A list of all memory blocks whose name contains "data" with non-volatile data
	 * @deprecated use {@link CppClassAnalyzerUtils#getAllDataBlocks(Program)}
	 */
	@Deprecated(forRemoval = true)
	public static List<MemoryBlock> getAllDataBlocks(Program program) {
		return CppClassAnalyzerUtils.getAllDataBlocks(program);
	}

	/**
	 * Returns true if this MemoryBlock has non-volatile data
	 * @param block the memory block to test
	 * @return true if this MemoryBlock has non-volatile data
	 * @deprecated use {@link CppClassAnalyzerUtils#isDataBlock(MemoryBlock)}
	 */
	@Deprecated(forRemoval = true)
	public static boolean isDataBlock(MemoryBlock block) {
		return CppClassAnalyzerUtils.isDataBlock(block);
	}

	/**
	 * Checks if a Program's language is PowerPC64
	 * @param program the program to test
	 * @return true if the program's language is PowerPC64
	 */
	public static boolean hasFunctionDescriptors(Program program) {
		String[] ids = program.getLanguageID().toString().split(":");
		return ids[0].contentEquals(PPC) && ids[2].contentEquals("64");
	}

	/**
	 * Checks if the Program was compiled by a GNU variant
	 * @param program the program to check
	 * @return true if compiled by a GNU variant
	 */
	public static boolean isGnuCompiler(Program program) {
		String id = program.getCompilerSpec().getCompilerSpecID().getIdAsString().toLowerCase();
		return COMPILER_NAMES.contains(id);
	}

	/**
	 * Checks if a function pointer is located at the specified address
	 * @param program the program containing the data
	 * @param address the address of the data
	 * @return true if a function pointer is located at the specified address
	 */
	public static boolean isFunctionPointer(Program program, Address address) {
		RelocationTable table = program.getRelocationTable();
		if (table.isRelocatable()) {
			List<Relocation> relocs = table.getRelocations(address);
			if (!relocs.isEmpty()) {
				Relocation reloc = relocs.get(0);
				if (reloc != null) {
					String name = reloc.getSymbolName();
					if (name != null) {
						if (name.equals(GnuVtable.PURE_VIRTUAL_FUNCTION_NAME)) {
							return true;
						}
						DemangledObject demangled = demangle(name);
						if (demangled != null && demangled instanceof DemangledFunction) {
							return true;
						}
					}
				}
			}
		}
		Address pointee = getAbsoluteAddress(program, address);
		if (pointee == null) {
			return false;
		}
		if (hasFunctionDescriptors(program)) {
			// the PowerPC Elf64 ABI has Function Descriptors :/
			pointee = getAbsoluteAddress(program, pointee);
			if (pointee == null) {
				return false;
			}
		}
		Listing listing = program.getListing();
		if (listing.getFunctionAt(pointee) != null) {
			// takes care of external functions
			return true;
		}
		MemoryBlock block = program.getMemory().getBlock(pointee);
		return block != null ? block.isExecute() : false;
	}

	/**
	 * Checks if a null pointer is located at the specified address
	 * @param program the program containing the data
	 * @param address the address of the data
	 * @return true if a null pointer is located at the specified address
	 */
	public static boolean isNullPointer(Program program, Address address) {
		return isNullPointer(new MemoryBufferImpl(program.getMemory(), address));
	}

	/**
	 * Checks if a null pointer is located at the specified address
	 * @param buf the memory buffer containing the data
	 * @return true if a null pointer is located at the specified address
	 */
	public static boolean isNullPointer(MemBuffer buf) {
		try {
			return buf.getBigInteger(
				0, buf.getMemory().getProgram().getDefaultPointerSize(), false).longValue() == 0;
		} catch (MemoryAccessException e) {
			return false;
		}
	}

	/**
	 * Checks if a valid pointer is located at the specified address
	 * @param program the program containing the data
	 * @param address the address of the data
	 * @return true if a valid pointer is located at the specified address
	 */
	public static boolean isValidPointer(Program program, Address address) {
		Address pointee = getAbsoluteAddress(program, address);
		if (pointee != null) {
			return program.getMemory().getLoadedAndInitializedAddressSet().contains(pointee);
		}
		return false;
	}

	/**
	 * Checks if a valid pointer is located at the specified address
	 * @param buf the memory buffer containing the data
	 * @return true if a valid pointer is located at the specified address
	 */
	public static boolean isValidPointer(MemBuffer buf) {
		return buf != null ? isValidPointer(buf.getMemory().getProgram(), buf.getAddress()) : false;
	}

	/**
	 * Checks if a valid pointer to a .*data section address is located at the specified address
	 * @param buf the memory buffer containing the data
	 * @return true if a valid data pointer is located at the specified address
	 */
	public static boolean isDataPointer(MemBuffer buf) {
		if (isValidPointer(buf)) {
			Memory mem = buf.getMemory();
			Address pointee = getAbsoluteAddress(mem.getProgram(), buf.getAddress());
			MemoryBlock block = mem.getBlock(pointee);
			if (block != null) {
				return getAllDataBlocks(mem.getProgram()).contains(block);
			}
		}
		return false;
	}

	/**
	 * Gets all direct data references to the specified address
	 * @param program the program containing the data
	 * @param address the address of the data
	 * @return a set of all direct data references to the specified address
	 */
	public static Set<Address> getDirectDataReferences(Program program, Address address) {
		try {
			return getDirectDataReferences(program, address, new DummyCancellableTaskMonitor());
		} catch (CancelledException e) {
			return null;
		}
	}

	/**
	 * Gets all direct data references to the specified address
	 * @param program the program containing the data
	 * @param address the address of the data
	 * @param monitor the task monitor
	 * @return a set of all direct data references to the specified address
	 * @throws CancelledException if the search is cancelled
	 */
	public static Set<Address> getDirectDataReferences(Program program, Address address,
			TaskMonitor monitor) throws CancelledException {
		if (address == null)
			return Collections.emptySet();
		List<MemoryBlock> dataBlocks = getAllDataBlocks(program);
		int pointerAlignment =
			program.getDataTypeManager().getDataOrganization().getDefaultPointerAlignment();
		return ProgramMemoryUtil.findDirectReferences(program, dataBlocks,
			pointerAlignment, address, monitor);
	}

	/**
	 * Attempts to get the Program containing the data for the relocation
	 * @param program the program containing the relocation
	 * @param reloc the relocation
	 * @return the external program or null if not resolved
	 */
	public static Program getExternalProgram(Program program, Relocation reloc) {
		ExternalManager manager = program.getExternalManager();
		SymbolTable table = program.getSymbolTable();
		for (Symbol symbol : table.getSymbols(reloc.getSymbolName())) {
			for (String path : symbol.getPath()) {
				Library library = manager.getExternalLibrary(path);
				if (library != null) {
					return openProgram(library.getAssociatedProgramPath());
				}
			}
		}
		// If still not found, brute force it
		for (String name : manager.getExternalLibraryNames()) {
			if (name.equals(EXTERNAL)) {
				continue;
			}
			String path = manager.getExternalLibraryPath(name);
			if (path == null) {
				continue;
			}
			Program exProgram = openProgram(path);
			if (exProgram != null) {
				Namespace global = exProgram.getGlobalNamespace();
				SymbolTable exTable = exProgram.getSymbolTable();
				if (!exTable.getSymbols(reloc.getSymbolName(), global).isEmpty()) {
					return exProgram;
				}
			}
		}
		return null;
	}

	private static Program openProgram(String path) {
		Project project = AppInfo.getActiveProject();
		DomainFile file = project.getProjectData().getFile(path);
		if (file == null) {
			return null;
		}
		Tool[] tools = project.getToolManager().getRunningTools();
		for (Tool tool : tools) {
			if (tool instanceof PluginTool) {
				return getProgramManager((PluginTool) tool, false).openProgram(file);
			}
		}
		return null;
	}

	/**
	 * Checks if the provided address is located within the {@value MemoryBlock#EXTERNAL_BLOCK_NAME}
	 * memory block.
	 * @param program the program containing the address
	 * @param address the address to check
	 * @return true if it is an external address
	 */
	public static boolean isExternal(Program program, Address address) {
		Memory mem = program.getMemory();
		MemoryBlock block = mem.getBlock(address);
		return block.getName().equals(MemoryBlock.EXTERNAL_BLOCK_NAME);
	}

	private static Address getAbsoluteAddress(Program program, Address address) {
		Memory mem = program.getMemory();
		if (!mem.contains(address)) {
			return null;
		}
		try {
			Address pointee = MSDataTypeUtils.getAbsoluteAddress(program, address);
			if (pointee != null && mem.contains(pointee)) {
				return pointee;
			}
		} catch (NullPointerException e) {
			// don't care
		}
		return null;
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/TypeInfoUtils.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import ghidra.program.model.listing.Data;
import cppclassanalyzer.data.TypeInfoManager;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import util.CollectionUtils;

import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressOutOfBoundsException;
import ghidra.program.model.address.AddressSetView;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.*;
import ghidra.program.model.reloc.Relocation;
import ghidra.program.model.reloc.RelocationTable;
import ghidra.program.model.symbol.*;
import ghidra.util.Msg;
import ghidra.util.StringUtilities;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;
import ghidra.program.model.data.*;
import ghidra.program.util.ProgramMemoryUtil;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.FundamentalTypeInfoModel;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.TypeInfoModel;
import ghidra.app.util.NamespaceUtils;
import ghidra.app.util.datatype.microsoft.MSDataTypeUtils;
import ghidra.app.util.demangler.Demangled;
import ghidra.app.util.demangler.DemangledObject;
import ghidra.app.util.demangler.DemanglerUtil;
import ghidra.docking.settings.Settings;

public class TypeInfoUtils {

	private static final Pattern LAMBDA_PATTERN = Pattern.compile("[\\$\\.]_");
	private static final String DYNLIB_VTABLE_PREFIX = "_"+VtableModel.MANGLED_PREFIX;

	private TypeInfoUtils() {
	}

	private static boolean isValidTypeName(String s) {
		Matcher matcher = LAMBDA_PATTERN.matcher(s);
		if (matcher.find()) {
			// lambda
			return true;
		}
		return s.chars().allMatch(c -> StringUtilities.isValidCLanguageChar((char) c));
	}

	/**
	 * Gets the typename for the {@value TypeInfoModel#STRUCTURE_NAME} at the specified address
	 * @param program the program to be searched
	 * @param address the address of the TypeInfo Model's DataType
	 * @return the TypeInfo's typename string or "" if invalid
	 */
	public static String getTypeName(Program program, Address address) {
		try {
			int pointerSize = program.getDefaultPointerSize();
			Address nameAddress = getAbsoluteAddress(program, address.add(pointerSize));
			if (nameAddress == null) {
				return "";
			}
			DataType dt = TerminatedStringDataType.dataType;
			Settings settings = dt.getDefaultSettings();
			MemoryBufferImpl buf = new MemoryBufferImpl(program.getMemory(), nameAddress);
			StringDataInstance string = new StringDataInstance(dt, settings, buf, -1);
			if (string.getStringLength() != -1) {
				string = new StringDataInstance(dt, settings, buf, string.getStringLength());
				String result = string.getStringValue();

				/*
				 * Some anonymous namespaces typename strings start with * Unfortunately the *
				 * causes issues with demangling so exclude it
				 */
				result = result.startsWith("*") ? result.substring(1) : result;
				if (isValidTypeName(result)) {
					return result;
				}
			}
		} catch (AddressOutOfBoundsException e) {
			// occured while reading assumed string, not a problem
		}
		return "";
	}

	/**
	 * Locates the TypeInfo with the specified ID_STRING
	 * @param program  the program to be searched
	 * @param typename the typename of the typeinfo to search for
	 * @param monitor  the active task monitor
	 * @return the TypeInfo with the corresponding typename or invalid if it doesn't exist
	 * @throws CancelledException if the search is cancelled
	 * @see TypeInfoModel#ID_STRING
	 */
	public static TypeInfo findTypeInfo(Program program, String typename, TaskMonitor monitor)
		throws CancelledException {
			return findTypeInfo(program, program.getAddressFactory().getAddressSet(),
								typename, monitor);
	}

	/**
	 * Locates the TypeInfo with the specified typename
	 * @param program the program to be searched
	 * @param set the address set to be searched
	 * @param typename the typename to search for
	 * @param monitor the active task monitor
	 * @return the TypeInfo with the corresponding typename or null if it doesn't exist
	 * @throws CancelledException if the search is cancelled
	 */
	public static TypeInfo findTypeInfo(Program program, AddressSetView set, String typename,
		TaskMonitor monitor) throws CancelledException {
			TypeInfoManager manager = CppClassAnalyzerUtils.getManager(program);
			TypeInfo type = getExistingTypeInfo(program, manager, typename);
			if (type != null) {
				return type;
			}
			int pointerAlignment =
				program.getDataTypeManager().getDataOrganization().getDefaultPointerAlignment();
			List<Address> stringAddresses = findTypeString(program, set, typename, monitor);
			for (Address stringAddress : stringAddresses) {
				Set<Address> references = ProgramMemoryUtil.findDirectReferences(program,
					pointerAlignment, stringAddress, monitor);
				if (references.isEmpty()) {
					continue;
				}
				for (Address reference : references) {
					Address typeinfoAddress = reference.subtract(program.getDefaultPointerSize());
					type = manager.getTypeInfo(typeinfoAddress);
					if (type == null) {
						continue;
					}
					if (type.getTypeName().equals(typename)) {
						return type;
					}
				}
			}
			return null;
	}

	private static TypeInfo getExistingTypeInfo(Program program, TypeInfoManager manager,
			String typename) {
		Namespace ns = getNamespaceFromTypeName(program, typename);
		SymbolTable table = program.getSymbolTable();
		return CollectionUtils.asStream(table.getChildren(ns.getSymbol()))
			.filter(s -> s.getName().equals(TypeInfo.SYMBOL_NAME))
			.map(Symbol::getAddress)
			.map(manager::getTypeInfo)
			.filter(Objects::nonNull)
			.findFirst()
			.orElse(null);
	}

	private static List<Address> findTypeString(Program program, AddressSetView set,
		String typename, TaskMonitor monitor) throws CancelledException {
			List<MemoryBlock> dataBlocks = CppClassAnalyzerUtils.getAllDataBlocks(program);
			List<Address> typeInfoAddresses =
				ProgramMemoryUtil.findString(typename, program, dataBlocks, set, monitor);
			return typeInfoAddresses;
	}

	private static String relocationToID(Relocation reloc) {
		String baseTypeName = reloc.getSymbolName();
		if (baseTypeName != null) {
			if (baseTypeName.contains("_ZTI")) {
				if (!baseTypeName.contains(TypeInfoModel.STRUCTURE_NAME)) {
					return FundamentalTypeInfoModel.ID_STRING;
				}
			}
			return baseTypeName.substring(4);
		}
		return null;
	}

	private static String externalSymbolToID(Program program, Address address) {
		SymbolTable table = program.getSymbolTable();
		for (Symbol symbol : table.getSymbols(address)) {
			if (symbol.getName().startsWith(DYNLIB_VTABLE_PREFIX)) {
				return symbol.getName().substring(DYNLIB_VTABLE_PREFIX.length());
			}
		}
		return null;
	}
	
	static Relocation getRelocation(Program program, Address address) {
		RelocationTable table = program.getRelocationTable();
		List<Relocation> relocs = table.getRelocations(address);
		if (relocs.isEmpty()) {
			return null;
		}
		if (relocs.size() > 1) {
			String msg = "Multiple relocations at " + address.toString();
			Msg.warn(TypeInfoUtils.class, msg);
		}
		return relocs.get(0);
	}

	/**
	 * Gets the identifier string for the {@value TypeInfoModel#STRUCTURE_NAME}
	 * at the specified address.
	 * @param program the program to be searched
	 * @param address the address of the TypeInfo Model's DataType
	 * @return The TypeInfo's identifier string or "" if invalid
	 * @see TypeInfoModel#ID_STRING
	 */
	public static String getIDString(Program program, Address address) {
		Relocation reloc = getRelocation(program, address);
		if (reloc != null && reloc.getSymbolName() != null) {
			if (reloc.getSymbolName().startsWith(VtableModel.MANGLED_PREFIX)) {
				return reloc.getSymbolName().substring(VtableModel.MANGLED_PREFIX.length());
			}
			Address relocationAddress = getAbsoluteAddress(program, address);
			if (relocationAddress == null || relocationAddress.getOffset() == 0) {
				return "";
			}
			MemoryBlock block = program.getMemory().getBlock(relocationAddress);
			if (block == null || !block.isInitialized()) {
				String name = relocationToID(reloc);
				if (name != null) {
					return name;
				}
			}
		} else {
			Address relocAddress = getAbsoluteAddress(program, address);
			if (relocAddress != null) {
				Data data = program.getListing().getDataContaining(relocAddress);
				if (data != null) {
					reloc = getRelocation(program, data.getAddress());
					if (reloc != null) {
						String name = relocationToID(reloc);
						if (name != null) {
							return name;
						}
					}
				}
				String name = externalSymbolToID(program, relocAddress);
				if (name != null) {
					return name;
				}
			}
		}
		final int POINTER_SIZE = program.getDefaultPointerSize();
		Address baseVtableAddress = getAbsoluteAddress(program, address);
		if (baseVtableAddress == null || baseVtableAddress.getOffset() == 0) {
			return "";
		}
		Address baseTypeInfoAddress = getAbsoluteAddress(
			program, baseVtableAddress.subtract(POINTER_SIZE));
		if (baseTypeInfoAddress == null) {
			return "";
		}
		return getTypeName(program, baseTypeInfoAddress);
	}

	/**
	 * Checks if a typeinfo* is located at the specified address
	 * @param program the program to be searched
	 * @param address the address of the suspected pointer
	 * @return true if a typeinfo* is present at the address
	 */
	public static boolean isTypeInfoPointer(Program program, Address address) {
		Address pointee = getAbsoluteAddress(program, address);
		if (pointee == null) {
			return false;
		}
		return isTypeInfo(program, pointee);
	}

	/**
	 * Checks if a typeinfo* is present at the buffer's address
	 * @param buf the buffer containing the data
	 * @return true if a typeinfo* is present at the buffer's address
	 */
	public static boolean isTypeInfoPointer(MemBuffer buf) {
		return buf != null ?
			isTypeInfoPointer(buf.getMemory().getProgram(), buf.getAddress()) : false;
	}

	/**
	 * Checks if a valid TypeInfo is located at the address in the program.
	 * @param program the program containing the TypeInfo
	 * @param address the address of the TypeInfo
	 * @return true if the buffer contains a valid TypeInfo
	 * @deprecated please use {@link TypeInfoManager#isTypeInfo(Address)}
	 */
	@Deprecated(since = "1.5", forRemoval = true)
	public static boolean isTypeInfo(Program program, Address address) {
		/* Makes more sense to have it in this utility, but more convient to check
		   if it is valid or not within the factory */
		TypeInfoManager manager = CppClassAnalyzerUtils.getManager(program);
		return manager.isTypeInfo(address);
	}

	/**
	 * Checks if a valid TypeInfo is located at the start of the buffer
	 * @param buf the memory buffer containing the TypeInfo data
	 * @return true if the buffer contains a valid TypeInfo
	 * @deprecated please use {@link TypeInfoManager#isTypeInfo(Address)}
	 */
	@Deprecated(since = "1.5", forRemoval = true)
	public static boolean isTypeInfo(MemBuffer buf) {
		return isTypeInfo(buf.getMemory().getProgram(), buf.getAddress());
	}

	/**
	 * Gets the Namespace for the corresponding typeinfo
	 * @param program the program containing the namespace
	 * @param type the typeinfo
	 * @return the Namespace for the corresponding typeinfo
	 */
	public static Namespace getNamespaceFromTypeName(Program program, TypeInfo type) {
		int id = -1;
		String typename = type.getTypeName();
		if (program.getCurrentTransaction() == null) {
			id = program.startTransaction("Creating namespace for " + typename);
		}
		try {
			Namespace ns;
			if (!(type instanceof ClassTypeInfo)) {
				ns = getFundamentalNamespace(program, typename);
			} else {
				ns = getNamespaceFromTypeName(program, typename);
			}
			if (id != -1) {
				program.endTransaction(id, true);
			}
			return ns;
		} catch (InvalidInputException e) {
			if (id != -1) {
				program.endTransaction(id, false);
			}
			throw new AssertException(e);
		}
	}

	private static Namespace getFundamentalNamespace(Program program, String typename)
			throws InvalidInputException {
		String mangled = typename.startsWith("_ZTI") ? typename : "_ZTI" + typename;
		Demangled demangled = DemanglerUtil.demangle(program, mangled);
		String signature = demangled.getNamespace().getSignature().replaceAll("_\\[", "[");
		signature = SymbolUtilities.replaceInvalidChars(signature, true);
		return NamespaceUtils.createNamespaceHierarchy(
			signature, null, program, SourceType.ANALYSIS);
	}

	/**
	 * Gets the Namespace for the corresponding typename
	 * @param program the program containing the namespace
	 * @param typename the typename corresponding to the namespace
	 * @return the Namespace for the corresponding typename
	 */
	public static Namespace getNamespaceFromTypeName(Program program, String typename) {
		String mangled = typename.startsWith("_ZTI") ? typename : "_ZTI" + typename;
		Demangled demangled = DemanglerUtil.demangle(program, mangled);
		if (demangled == null) {
			throw new AssertException("Failed to demangle " + typename);
		}
		Namespace ns =  DemangledObject.createNamespace(
			program, demangled.getNamespace(), program.getGlobalNamespace(), false);
		if (ns.isGlobal()) {
			throw new AssertException("Global Namespace returned!");
		}
		return ns;
	}
	
	/**
	 * Retrieves the CategoryPath for the represented datatype
	 * @param type the TypeInfo
	 * @return the TypeInfo's datatype CategoryPath
	 */
	public static CategoryPath getCategoryPath(TypeInfo type) {
		Namespace ns = type.getNamespace().getParentNamespace();
		String path;
		if (ns.isGlobal()) {
			path = "";
		} else {
			path = Namespace.DELIMITER+ns.getName(true);
		}
		path = path.replaceAll(Namespace.DELIMITER, CategoryPath.DELIMITER_STRING);
		return new CategoryPath(path);
	}

	/**
	 * Retrieves the DataTypePath for the represented datatype
	 * @param type the TypeInfo
	 * @return the TypeInfo's datatype DataTypePath
	 */
	public static DataTypePath getDataTypePath(TypeInfo type) {
		return new DataTypePath(getCategoryPath(type), type.getName());
	}

	/**
	 * Generates an appropriate error message for when an invalid type_info is encountered
	 *
	 * @param program the program containing the data
	 * @param address the address of the data
	 * @param id the expected type_info identification string
	 * @return an appropriate error message
	 */
	public static String getErrorMessage(Program program, Address address, String id) {
		StringBuilder builder = new StringBuilder("Exception caused by Ghidra-Cpp-Class-Analyzer\n");
		builder.append(String.format("The TypeInfo at %s is not valid\n", address));
		builder.append(
			String.format("Expected %s to match identifier %s\n",
						  getIDString(program, address),
						  id))
			   .append("Potential typename: ")
			   .append(getTypeName(program, address));
		Relocation reloc = getRelocation(program, address);
		if (reloc != null) {
			builder.append(String.format(
				"\nrelocation at %s to symbol %s", reloc.getAddress(), reloc.getSymbolName()));
		}
		return builder.toString();
	}

	/**
	 * Gets the program this TypeInfo is in
	 *
	 * @param type the TypeInfo
	 * @return the program containing the TypeInfo
	 */
	public static Program getProgram(TypeInfo type) {
		return type.getNamespace().getSymbol().getProgram();
	}


	private static boolean isMangled(String s) {
		return s.startsWith("_ZTI") && !s.contains("@");
	}

	/**
	 * Gets the symbol name for the ClassTypeInfo
	 *
	 * @param type the ClassTypeInfo
	 * @return the type info symbol nane
	 */
	public static String getSymbolName(TypeInfo type) {
		Program program = getProgram(type);
		SymbolTable table = program.getSymbolTable();
		return Arrays.stream(table.getSymbols(type.getAddress()))
			.map(Symbol::getName)
			.filter(TypeInfoUtils::isMangled)
			.findFirst()
			.orElse("_ZTI" + type.getTypeName());
	}

	private static Address getAbsoluteAddress(Program program, Address address) {
		Memory mem = program.getMemory();
		if (!mem.contains(address)) {
			return null;
		}
		try {
			Address pointee = MSDataTypeUtils.getAbsoluteAddress(program, address);
			if (pointee != null && mem.contains(pointee)) {
				return pointee;
			}
		} catch (NullPointerException e) {
			// don't care
		}
		return null;
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/UnresolvedClassTypeInfoException.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import ghidra.app.util.demangler.Demangled;
import ghidra.app.util.demangler.DemanglerUtil;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;

/**
 * Exception thrown when the data for a dynamically linked __class_type_info
 * cannot be located.
 */
@SuppressWarnings("serial")
public class UnresolvedClassTypeInfoException extends RuntimeException {

	public UnresolvedClassTypeInfoException(Address address, String symbol) {
		super(
			String.format(
				"A base class at %s cannot be resolved because"
				+ " the data for the relocated symbol %s is missing", address, symbol)
		);
	}

	public UnresolvedClassTypeInfoException(Program program) {
		super("The ClassTypeInfo Archive for " + program.getName() + " could not be found");
	}

	public UnresolvedClassTypeInfoException(String msg) {
		super(msg);
	}

	public UnresolvedClassTypeInfoException(Program program, String mangled) {
		super(buildMessage(program, mangled));
	}

	private static String buildMessage(Program program, String mangled) {
		Demangled d = DemanglerUtil.demangle(program, mangled);
		String name = d != null ? d.getNamespaceString() : mangled;
		return "Unable to locate archived data for " + name;
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/VtableModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import ghidra.program.model.data.Array;
import ghidra.program.model.data.ArrayDataType;
import ghidra.program.model.data.DataType;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.data.typeinfo.ClassTypeInfoDB;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.mem.MemoryBufferImpl;
import ghidra.util.Msg;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.Vtable;

import static ghidra.app.util.datatype.microsoft.MSDataTypeUtils.getAbsoluteAddress;

/**
 * Model for GNU Vtables
 */
public final class VtableModel implements GnuVtable {

	public static final String SYMBOL_NAME = "vtable";
	public static final String CONSTRUCTION_SYMBOL_NAME = "construction-"+SYMBOL_NAME;
	public static final String DESCRIPTION = "Vtable Model";
	public static final String MANGLED_PREFIX = "_ZTV";

	private Program program;
	private Address address;
	private static final int FUNCTION_TABLE_ORDINAL = 2;
	private static final int MAX_PREFIX_ELEMENTS = 3;
	private int arrayCount;
	private boolean construction;
	private Set<Function> functions = new HashSet<>();
	private ClassTypeInfo type = null;
	private List<VtablePrefixModel> vtablePrefixes;

	public static GnuVtable getVtable(Program program, Address address) {
		return getVtable(program, address, null);
	}

	public static GnuVtable getVtable(Program program, Address address, ClassTypeInfo type) {
		try {
			return new VtableModel(program, address, type);
		} catch (InvalidDataTypeException e) {
			return NO_VTABLE;
		}
	}

	VtableModel(Program program, Address address) throws InvalidDataTypeException {
		this(program, address, null, -1, false);
	}

	VtableModel(Program program, Address address, ClassTypeInfo type)
		throws InvalidDataTypeException {
			this(program, address, type, -1, false);
	}

	/**
	 * Constructs a new VtableModel
	 *
	 * @param program	  program the vtable is in.
	 * @param address	  starting address of the vtable or the first typeinfo pointer.
	 * @param type		 the ClassTypeInfo this vtable belongs to.
	 * @param arrayCount   the maximum vtable table count, if known.
	 * @param construction true if this should be a construction vtable.
	 * @throws InvalidDataTypeException
	 */
	VtableModel(Program program, Address address, ClassTypeInfo type,
			int arrayCount, boolean construction) throws InvalidDataTypeException {
			this.program = program;
			this.address = address;
			this.type = type;
			this.arrayCount = arrayCount;
			this.construction = construction;
			ProgramClassTypeInfoManager manager = CppClassAnalyzerUtils.getManager(program);
			if (TypeInfoUtils.isTypeInfoPointer(program, address)) {
				if (this.type == null) {
					Address typeAddress = getAbsoluteAddress(program, address);
					this.type = manager.getType(typeAddress);
				}
			} else if (this.type == null) {
				int length = VtableUtils.getNumPtrDiffs(program, address);
				DataType ptrdiff_t = GnuUtils.getPtrDiff_t(program.getDataTypeManager());
				Address typePointerAddress = address.add(length * ptrdiff_t.getLength());
				Address typeAddress = getAbsoluteAddress(program, typePointerAddress);
				this.type = manager.getType(typeAddress);
			}
			setupVtablePrefixes();
			if (vtablePrefixes.isEmpty()) {
				throw new InvalidDataTypeException(
					String.format("The vtable at %s is empty", address));
			}
	}

	@Override
	public ClassTypeInfo getTypeInfo() {
		if (type == null) {
			type = VtableUtils.getTypeInfo(program, address);
		}
		return type;
	}

	@Override
	public int hashCode() {
		getTypeInfo();
		if (type != null) {
			return type.hashCode();
		}
		return super.hashCode();
	}

	@Override
	public boolean equals(Object object) {
		if (!(object instanceof GnuVtable)) {
			return false;
		}
		if (object == NO_VTABLE) {
			return this == object;
		}
		getTypeInfo();
		ClassTypeInfo otherType = ((VtableModel) object).getTypeInfo();
		if (type != null && otherType != null) {
			return type.equals(otherType);
		}
		return super.equals(object);
	}

	/**
	 * Gets the corrected start address of the vtable.
	 *
	 * @return the correct start address or NO_ADDRESS if invalid.
	 */
	public Address getAddress() {
		return address;
	}

	@Override
	public Address[] getTableAddresses() {
		Address[] result = new Address[vtablePrefixes.size()];
		for (int i = 0; i < result.length; i++) {
			try {
				result[i] = vtablePrefixes.get(i).getTableAddress();
			} catch (IndexOutOfBoundsException e) {
				result = Arrays.copyOf(result, i);
				break;
			}
		}
		return result;
	}

	@Override
	public Function[][] getFunctionTables() {
		Address[] tableAddresses = getTableAddresses();
		if (tableAddresses.length == 0) {
			return new Function[0][];
		}
		Function[][] result = new Function[tableAddresses.length][];
		for (int i = 0; i < tableAddresses.length; i++) {
			result[i] = VtableUtils.getFunctionTable(program, tableAddresses[i]);
		} return result;
	}

	@Override
	public boolean containsFunction(Function function) {
		if (functions.isEmpty()) {
			getFunctionTables();
		} return functions.contains(function);
	}

	/**
	 * @see ghidra.program.model.data.DataType#getLength()
	 * @return the vtable length
	 */
	@Override
	public int getLength() {
		if (Vtable.isValid(this)) {
			int size = 0;
			for (VtablePrefixModel prefix : vtablePrefixes) {
				size += prefix.getPrefixSize();
			}
			return size;
		}
		return 0;
	}

	@Override
	public long getOffset(int index, int ordinal) {
		if (ordinal >= getElementCount()) {
			return Long.MAX_VALUE;
		}
		return vtablePrefixes.get(index).getBaseOffset(ordinal);
	}

	/**
	 * Gets the number of vtable_prefix's in this vtable
	 *
	 * @return the number of vtable_prefix's in this vtable
	 */
	public int getElementCount() {
		return vtablePrefixes.size();
	}

	private Address getNextPrefixAddress() {
		int size = 0;
		for (VtablePrefixModel prefix : vtablePrefixes) {
			size += prefix.getPrefixSize();
		}
		return address.add(size);
	}

	@Override
	public List<DataType> getDataTypes() {
		List<DataType> result = new ArrayList<>(vtablePrefixes.size() * MAX_PREFIX_ELEMENTS);
		for (VtablePrefixModel prefix : vtablePrefixes) {
			result.addAll(prefix.dataTypes);
		}
		return result;
	}

	private void setupVtablePrefixes() {
		vtablePrefixes = new ArrayList<>();
		ClassTypeInfo tmpType;
		if (type instanceof ClassTypeInfoDB) {
			ProgramClassTypeInfoManager manager =
				(ProgramClassTypeInfoManager) ((ClassTypeInfoDB) type).getManager();
			tmpType = (ClassTypeInfo) manager.getTypeInfo(type.getAddress(), false);
			if (tmpType == null) {
				return;
			}
		} else {
			tmpType = type;
		}
		int count = construction ? 2 : ClassTypeInfoUtils.getMaxVtableCount(tmpType);
		VtablePrefixModel prefix = new VtablePrefixModel(getNextPrefixAddress(), count);
		if (!prefix.isValid()) {
			return;
		}
		if (TypeInfoUtils.isTypeInfoPointer(program, address)) {
			address = prefix.prefixAddress;
		}
		if (arrayCount < 0) {
			while (prefix.isValid()) {
				vtablePrefixes.add(prefix);
				prefix = new VtablePrefixModel(getNextPrefixAddress());
			}
		} else {
			vtablePrefixes.add(prefix);
			for (int i = 1; i < arrayCount; i++) {
				prefix = new VtablePrefixModel(getNextPrefixAddress());
				if (!prefix.isValid()) {
					break;
				}
				vtablePrefixes.add(prefix);
			}
		}
	}

	@Override
	public List<VtablePrefix> getPrefixes() {
		return Collections.unmodifiableList(vtablePrefixes);
	}

	public boolean isConstruction() {
		return construction;
	}

	private class VtablePrefixModel implements VtablePrefix {

		private Address prefixAddress;
		private List<DataType> dataTypes;

		private VtablePrefixModel(Address prefixAddress) {
			this(prefixAddress, -1);
		}

		private VtablePrefixModel(Address prefixAddress, int ptrDiffs) {
			this.prefixAddress = prefixAddress;
			int numPtrDiffs = ptrDiffs > 0 ? ptrDiffs :
				VtableUtils.getNumPtrDiffs(program, prefixAddress);
			dataTypes = new ArrayList<>(3);
			if (numPtrDiffs > 0) {
				DataTypeManager dtm = program.getDataTypeManager();
				DataType ptrdiff_t = GnuUtils.getPtrDiff_t(dtm);
				//int pointerSize = program.getDefaultPointerSize();
				if (TypeInfoUtils.isTypeInfoPointer(program, prefixAddress)) {
					this.prefixAddress = prefixAddress.subtract(numPtrDiffs * ptrdiff_t.getLength());
				}
				dataTypes.add(new ArrayDataType(ptrdiff_t, numPtrDiffs, ptrdiff_t.getLength(), dtm));
				dataTypes.add(new PointerDataType(null, -1, dtm));
				Address tableAddress = this.prefixAddress.add(getPrefixSize());
				int tableSize = VtableUtils.getFunctionTableLength(program, tableAddress);
				if (tableSize > 0) {
					ArrayDataType table = new ArrayDataType(
						PointerDataType.dataType, tableSize, -1, dtm);
					dataTypes.add(table);
				}
			}
		}

		private boolean isValid() {
			if (dataTypes.size() > 1) {
				int offset = dataTypes.get(0).getLength();
				Address pointee = getAbsoluteAddress(
					program, prefixAddress.add(offset));
				if (pointee != null) {
					return pointee.equals(type.getAddress());
				}
			}
			return false;
		}

		private int getPrefixSize() {
			int size = 0;
			for (DataType dt : dataTypes) {
				size += dt.getLength();
			}
			return size;
		}

		private Address getTableAddress() {
			int size = 0;
			for (int i = 0; i < FUNCTION_TABLE_ORDINAL; i++) {
				size += dataTypes.get(i).getLength();
			}
			return prefixAddress.add(size);
		}

		@Override
		public List<Long> getOffsets() {
			try {
				Array array = (Array) dataTypes.get(0);
				MemoryBufferImpl prefixBuf = new MemoryBufferImpl(
					program.getMemory(), prefixAddress);
				int length = array.getElementLength();
				long[] result = new long[array.getNumElements()];
				for (int i = 0; i < result.length; i++) {
					result[i] = prefixBuf.getBigInteger(i*length, length, true).longValue();
				}
				return Arrays.stream(result)
					.boxed()
					.collect(Collectors.toUnmodifiableList());
			} catch (MemoryAccessException e) {
				Msg.error(this, "Failed to retreive base offsets at "+prefixAddress, e);
				return Collections.emptyList();
			}
		}

		private long getBaseOffset(int ordinal) {
			Array array = (Array) dataTypes.get(0);
			if (ordinal >= array.getElementLength()) {
				return -1;
			}
			return getOffsets().get(ordinal);
		}

		@Override
		public List<Function> getFunctionTable() {
			Function[] result = VtableUtils.getFunctionTable(program, getTableAddress());
			return Collections.unmodifiableList(Arrays.asList(result));
		}

		@Override
		public List<DataType> getDataTypes() {
			return Collections.unmodifiableList(dataTypes);
		}

		@Override
		public Address getAddress() {
			return prefixAddress;
		}
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/VtableUtils.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;
import util.CollectionUtils;

import ghidra.program.model.address.*;
import ghidra.program.model.data.Array;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.DefaultDataType;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.data.Undefined;
import ghidra.program.model.listing.*;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.mem.MemoryBufferImpl;
import ghidra.program.model.reloc.Relocation;
import ghidra.program.model.symbol.*;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.TypeInfoModel;
import ghidra.app.cmd.disassemble.DisassembleCommand;
import ghidra.app.cmd.function.CreateFunctionCmd;

import static ghidra.app.util.datatype.microsoft.MSDataTypeUtils.getAbsoluteAddress;

public class VtableUtils {

	// that's still a awful lot
	public static final int MAX_PTR_DIFFS = 25;

	private VtableUtils() {}

	@FunctionalInterface
	private interface IntToLongFunction {
		long applyAsLong(int value) throws MemoryAccessException;
	}

	/**
	 * Gets the number of ptrdiff_t's in the vtable_prefix at the address
	 * @param program the program containing the vtable_prefix
	 * @param address the address of the vtable_prefix
	 * @return the number of ptrdiff_t's in the vtable_prefix at the address
	 */
	public static int getNumPtrDiffs(Program program, Address address) {
		return getNumPtrDiffs(program, address, -1);
	}

	/**
	 * Gets the size of the ptrdiff_t array at the start of a vtable_prefix
	 * @param program the program containing the ptrdiff_t array
	 * @param address the address of the ptrdiff_t array
	 * @param maxLength the max length for the ptrdiff_t array
	 * @return the number of ptrdiff_t's in the array or 0 if invalid
	 */
	public static int getNumPtrDiffs(Program program, Address address, int maxLength) {
		/**
		 * This is not pretty. The rules I have found are as follows.
		 * Positive values may only repeate when going down.
		 * Negative values and 0 may repeate.
		 * Values may not go from negative/positive and then back or vise-versa.
		 * AddressOverflowException and MemoryAccessException may only occur when
		 * counting upwards from the typeinfo pointer.
		 * Most classes within libstdc++ contain no more than 2 ptrdiff_t's,
		 * however this was written to be able to withstand large inheritance chains.
		 */
		if (maxLength < 0) {
			maxLength = MAX_PTR_DIFFS;
		}
		Listing listing = program.getListing();
		Data before = listing.getDefinedDataBefore(address);
		Data after = listing.getDefinedDataAfter(address);
		Data containing = listing.getDefinedDataContaining(address);
		if (isValidData(containing)) {
			AddressRangeImpl set;
			if (before.equals(containing)) {
				set = new AddressRangeImpl(before.getAddress(), after.getAddress());
			} else {
				while(isValidData(before)) {
					before = listing.getDefinedDataBefore(before.getAddress());
				}
				if (after == null) {
					set = new AddressRangeImpl(before.getMaxAddress(), program.getMaxAddress());
				} else {
					AddressSpace beforeSpace = before.getMaxAddress().getAddressSpace();
					AddressSpace afterSpace = after.getAddress().getAddressSpace();
					if (!beforeSpace.equals(afterSpace)) {
						return 0;
					}
					set = new AddressRangeImpl(before.getMaxAddress(), after.getAddress());
				}
			}
			if (TypeInfoUtils.isTypeInfoPointer(program, address)) {
				if (isPtrDiffArray(before)) {
					return before.getNumComponents();
				}
				if (isVptrArray(after)) {
					after = listing.getDefinedDataAfter(after.getMaxAddress());
				}
				int ptrDiffSize = GnuUtils.getPtrDiffSize(program.getDataTypeManager());
				set = new AddressRangeImpl(before.getMaxAddress(), after.getAddress());
				return getNumPtrDiffs(program, address.subtract(ptrDiffSize), set, true, maxLength);
			}
			return getNumPtrDiffs(program, address, set, false, maxLength);
		}
		return 0;
	}

	private static boolean isPtrDiffArray(Data data) {
		if (data != null && data.isArray()) {
			DataType ptrDiff = GnuUtils.getPtrDiff_t(data.getDataType().getDataTypeManager());
			return ((Array) data.getDataType()).getDataType().equals(ptrDiff);
		}
		return false;
	}

	private static boolean isVptrArray(Data data) {
		if (data != null && data.isArray()) {
			return ((Array) data.getDataType()).getDataType().equals(PointerDataType.dataType);
		}
		return false;
	}

	private static int getNumPtrDiffs(Program program, Address address,
		AddressRange range, boolean reverse, int maxLength) {
			MemoryBufferImpl buf = new MemoryBufferImpl(program.getMemory(), address);
			DataType ptrdiff_t = GnuUtils.getPtrDiff_t(program.getDataTypeManager());
			int length = ptrdiff_t.getLength();
			int direction = reverse ? -1 : 1;
			int count = 0;
			long value = 0;
			List<Long> values = new ArrayList<>();
			IntToLongFunction getValue = length == 8 ? buf::getLong : buf::getInt;
			while (range.contains(buf.getAddress()) && count < maxLength) {
				try {
					if (GnuUtils.isDataPointer(buf) && !(getValue.applyAsLong(0) == 0)) {
						if ((direction < 0) ^ TypeInfoUtils.isTypeInfoPointer(buf)) {
							break;
						} else if (direction < 0) {
							break;
						} return 0;
					}
					value = getValue.applyAsLong(0);
					if (value < 0 && direction < 0) {
						return count;
					}
					if (value > 0 && direction < 0) {
						if (values.contains(value)) {
							return 0;
						} values.add(value);
					}
					count++;
					buf.advance(direction * length);
				} catch (MemoryAccessException | AddressOverflowException e) {
					if (direction < 0) {
						return count;
					} return 0;
				}
			}
			return count;
	}

	private static boolean isValidData(Data data) {
		if (data == null) {
			return true;
		}
		if (data.isPointer()) {
			return TypeInfoUtils.isTypeInfoPointer(data);
		}
		if (Undefined.isUndefined(data.getDataType())) {
			return true;
		}
		if (!data.isArray()) {
			return data.getDataType() instanceof DefaultDataType;
		}
		if (Undefined.isUndefinedArray(data.getDataType())) {
			return true;
		}
		DataType ptrDiff = GnuUtils.getPtrDiff_t(data.getDataType().getDataTypeManager());
		return ((Array) data.getDataType()).getDataType().equals(ptrDiff);
	}

	/**
	 * Returns the TypeInfo Model this vtable points to
	 * @param program program the vtable is in
	 * @param address address of the start of the vtable
	 * @return the pointed to TypeInfo Model or null if not found
	 */
	public static ClassTypeInfo getTypeInfo(Program program, Address address) {
		ProgramClassTypeInfoManager manager = CppClassAnalyzerUtils.getManager(program);
		DataTypeManager dtm = program.getDataTypeManager();
		int ptrDiffSize = GnuUtils.getPtrDiffSize(dtm);
		int numPtrDiffs = getNumPtrDiffs(program, address);
		Address currentAddress = address.add(ptrDiffSize * numPtrDiffs);
		if (TypeInfoUtils.isTypeInfoPointer(program, currentAddress)) {
			return manager.getType(getAbsoluteAddress(program, currentAddress));
		}
		return null;
	}

	/**
	 * Gets the number of elements in the vtable_prefix's function table
	 * @param program the program containing the function table
	 * @param address the address of the function table
	 * @return the number of elements in the vtable_prefix's function table
	 */
	public static int getFunctionTableLength(Program program, Address address) {
		int tableSize = 0;
		MemoryBufferImpl buf = new MemoryBufferImpl(program.getMemory(), address);
		int pointerSize = program.getDefaultPointerSize();
		while (GnuUtils.isNullPointer(buf)) {
			tableSize++;
			try {
				buf.advance(pointerSize);
			} catch (AddressOverflowException e) {
				return 0;
			}
		}
		while (GnuUtils.isFunctionPointer(program, buf.getAddress())) {
			if (isNotDefinedPointerData(program, buf.getAddress())) {
				break;
			}
			tableSize++;
			try {
				buf.advance(pointerSize);
			} catch (AddressOverflowException e) {
				// Assume table ends at end of address set
				break;
			}
		}
		return tableSize;
	}

	private static boolean isNotDefinedPointerData(Program program, Address address) {
		Data data = program.getListing().getDataAt(address);
		if (data != null && data.isDefined()) {
			return !data.isPointer();
		}
		return false;
	}

	/**
	 * Gets the function table at the specified address.
	 * @param program the program containing the function table
	 * @param address the address of the function table
	 * @return a Function[] representing the function table.
	 */
	public static Function[] getFunctionTable(Program program, Address address) {
		Function[] functions = new Function[getFunctionTableLength(program, address)];
		int pointerSize = program.getDefaultPointerSize();
		for (int i = 0; i < functions.length; i++) {
			Address functionAddress = getFunctionAddress(program, address.add(i * pointerSize));
			if (functionAddress.getOffset() != 0) {
				functions[i] = createFunction(program, functionAddress);
			} else {
				functions[i] = null;
			}
		}
		return functions;
	}

	private static Address getFunctionAddress(Program program, Address currentAddress) {
		Address functionAddress = getAbsoluteAddress(program, currentAddress);
		if (GnuUtils.hasFunctionDescriptors(program) && functionAddress.getOffset() != 0) {
			Relocation reloc =TypeInfoUtils.getRelocation(program, currentAddress);
			if (reloc == null || reloc.getSymbolName() == null) {
				return getAbsoluteAddress(program, functionAddress);
			}
		} return functionAddress;
	}

	private static Function createFunction(Program program, Address currentAddress) {
		Listing listing = program.getListing();
		Function function = listing.getFunctionContaining(currentAddress);
		if (function != null) {
			return function;
		}
		Instruction inst = listing.getInstructionContaining(currentAddress);
		if (inst == null) {
			// If it has not been disassembled, disassemble it first.
			if (program.getMemory().getBlock(currentAddress).isInitialized()) {
				DisassembleCommand cmd = new DisassembleCommand(currentAddress, null, true);
				cmd.applyTo(program);
			}
			inst = listing.getInstructionContaining(currentAddress);
			if (inst == null) {
				return null;
			}
		}
		// handle thumb mode pointer offset
		Address entry = inst.getAddress();
		CreateFunctionCmd cmd = new CreateFunctionCmd(entry);
		cmd.applyTo(program);
		return cmd.getFunction();
	}

	/**
	 * Gets the VttModel for the specified VtableModel if one exists
	 * @param program the program containing the vtable
	 * @param vtable the vtable
	 * @return the VttModel or {@link VttModel#INVALID} if none
	 */
	public static VttModel getVttModel(Program program, GnuVtable vtable) {
		if (vtable.getTypeInfo().getTypeName().contains(TypeInfoModel.STRUCTURE_NAME)) {
			return VttModel.INVALID;
		}
		Address[] tableAddresses = vtable.getTableAddresses();
		if (tableAddresses.length == 0) {
			return VttModel.INVALID;
		}
		ReferenceManager man = program.getReferenceManager();
		Address addr = tableAddresses[0];
		Set<Address> references = CollectionUtils.asStream(man.getReferencesTo(addr))
			.map(Reference::getFromAddress)
			.filter(Predicate.not(SpecialAddress.class::isInstance))
			.collect(Collectors.toSet());
		if (references.isEmpty()) {
			return VttModel.INVALID;
		}
		// VTT typically follows the vtable
		Address address = vtable.getAddress().add(vtable.getLength());
		if (references.contains(address)) {
			VttModel vtt = new VttModel(program, address);
			if (vtt.isValid()) {
				return vtt;
			}
		}
		Iterator<Address> refIterator = references.iterator();
		while (refIterator.hasNext()) {
			VttModel vtt = new VttModel(program, refIterator.next());
			if (vtt.isValid()) {
				return vtt;
			}
		}
		return VttModel.INVALID;
	}

	public static boolean isMangled(String s) {
		return s.startsWith("_ZTV") && !s.contains("@");
	}

	public static String getSymbolName(Vtable vtable) {
		ClassTypeInfo type = vtable.getTypeInfo();
		Program program = TypeInfoUtils.getProgram(type);
		SymbolTable table = program.getSymbolTable();
		return Arrays.stream(table.getSymbols(vtable.getAddress()))
			.map(Symbol::getName)
			.filter(VtableUtils::isMangled)
			.findFirst()
			.orElseGet(() -> { return "_ZTV" + type.getTypeName(); });
	}

	public static Program getProgram(Vtable vtable) {
		ClassTypeInfo type = vtable.getTypeInfo();
		return TypeInfoUtils.getProgram(type);
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/VttModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.*;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.Vtable;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressOutOfBoundsException;
import ghidra.program.model.address.AddressSet;
import ghidra.program.model.data.ArrayDataType;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.listing.Program;

import static ghidra.app.util.datatype.microsoft.MSDataTypeUtils.getAbsoluteAddress;

public class VttModel {

	public static final String SYMBOL_NAME = "VTT";
	public static final VttModel INVALID = new VttModel();

	private final Address address;
	private int elementCount = -1;
	private DataType dataType;
	private ClassTypeInfo typeinfo;
	private int pointerSize;
	private List<GnuVtable> constructionModels;
	private final ProgramClassTypeInfoManager manager;
	private Set<Address> validAddresses;

	private VttModel() {
		this.elementCount = 0;
		this.address = null;
		this.manager = null;
	}

	/**
	 * Constructs a new VttModel
	 * @param program the program containing the VttModel
	 * @param address the address of the VttModel
	 */
	public VttModel(Program program, Address address) {
		this.manager = CppClassAnalyzerUtils.getManager(program);
		this.address = address;
		this.pointerSize = program.getDefaultPointerSize();
		if (GnuUtils.isValidPointer(program, address)) {
			Address pointee = getAbsoluteAddress(program, address).subtract(pointerSize);
			if (!TypeInfoUtils.isTypeInfoPointer(program, pointee)) {
				elementCount = 0;
			} else {
				pointee =  getAbsoluteAddress(program, pointee);
				this.typeinfo = manager.getType(pointee);
				if (!typeinfo.hasParent()) {
					elementCount = 0;
				}
				validAddresses = new HashSet<>();
				for (ClassTypeInfo base : typeinfo.getParentModels()) {
					validAddresses.add(base.getAddress());
				}
				validAddresses.add(typeinfo.getAddress());
			}
		} else {
			elementCount = 0;
		}
	}

	private Program getProgram() {
		return manager.getProgram();
	}

	@Override
	public int hashCode() {
		if (isValid()) {
			return getAddress().hashCode();
		}
		return super.hashCode();
	}

	@Override
	public boolean equals(Object object) {
		if (!(object instanceof VttModel)) {
			return false;
		}
		return ((VttModel) object).getAddress().equals(address);
	}

	/**
	 * Gets the address of this VttModel
	 * @return the address of this VttModel
	 */
	public Address getAddress() {
		return address;
	}

	/**
	 * Checks if this VttModel is valid
	 * @return true if valid
	 */
	public boolean isValid() {
		int count = getElementCount();
		return count > 0;
	}

	/**
	 * Gets the Vtable at the specified ordinal
	 * @param ordinal the ordinal of the Vtable
	 * @return the Vtable at the specified ordinal
	 */
	public Vtable getVtableModel(int ordinal) {
		Address pointee = getElementPointee(ordinal);
		return pointee != null ? getVtableContaining(pointee) : GnuVtable.NO_VTABLE;
	}

	/**
	 * Gets the ClassTypeInfo at the specified ordinal
	 * @param ordinal the ordinal of the Vtable containing the ClassTypeInfo pointer
	 * @return the ClassTypeInfo at the specified ordinal or null if none exists
	 * @see Vtable#getTypeInfo()
	 */
	public ClassTypeInfo getTypeInfo(int ordinal) {
		Address pointee = getElementPointee(ordinal);
		if (pointee != null) {
			Address typeAddress = getAbsoluteAddress(getProgram(), pointee);
			return manager.getType(typeAddress);
		}
		return null;
	}

	private Address getElementPointee(int ordinal) {
		if (ordinal >= getElementCount()) {
			return null;
		}
		Address currentAddress = address.add(ordinal * pointerSize);
		return getAbsoluteAddress(getProgram(), currentAddress).subtract(pointerSize);
	}

	private static boolean vtableContainsAddress(GnuVtable vtable, Address a) {
		Address startAddress = vtable.getAddress();
		AddressSet set = new AddressSet(startAddress, startAddress.add(vtable.getLength()));
		return set.contains(a);
	}

	private GnuVtable getVtableContaining(Address a) {
		for (GnuVtable vtable : constructionModels) {
			if (vtableContainsAddress(vtable, a)) {
				return vtable;
			}
		}
		GnuVtable vtable = (GnuVtable) typeinfo.getVtable();
		if (vtableContainsAddress(vtable, a)) {
			return vtable;
		}
		return null;
	}

	/**
	 * Gets the construction vtable models in this VttModel
	 * @return the construction vtable models in this VttModel
	 */
	public GnuVtable[] getConstructionVtableModels() {
		if (!isValid()) {
			return new GnuVtable[0];
		}
		return constructionModels.toArray(new GnuVtable[constructionModels.size()]);
	}

	private Address getTIAddress(Address pointerAddress) {
		try {
			Address pointer = getTIPointer(pointerAddress);
			return pointer.equals(Address.NO_ADDRESS) ? pointer
				: getAbsoluteAddress(getProgram(), pointer);
		} catch (AddressOutOfBoundsException e) {
			return null;
		}
	}

	private Address getTIPointer(Address pointerAddress) {
		Program program = getProgram();
		Address pointee = getAbsoluteAddress(program, pointerAddress);
		if (pointee != null) {
			Address pointer = pointee.subtract(pointerSize);
			if (!TypeInfoUtils.isTypeInfoPointer(program, pointer)) {
				return Address.NO_ADDRESS;
			} return pointer;
		}
		return Address.NO_ADDRESS;
	}

	private int getSubTableCount(Address startAddress) {
		int i = 0;
		Address tiAddress = getTIAddress(startAddress);
		Address currentTIAddress = tiAddress;
		while (tiAddress.equals(currentTIAddress)) {
			if (!GnuUtils.isValidPointer(getProgram(), startAddress)) {
				break;
			}
			if(!validAddresses.contains(tiAddress)) {
				break;
			}
			currentTIAddress = getTIAddress(startAddress.add(++i * pointerSize));
		} return i;
	}

	private int getVTTableCount() throws InvalidDataTypeException {
		int tableSize = 0;
		Program program = getProgram();
		Address currentAddress = address;
		Set<ClassTypeInfo> validTypes = new HashSet<>(List.of(typeinfo.getParentModels()));
		Set<ClassTypeInfo> vParents = typeinfo.getVirtualParents();
		if (!validTypes.containsAll(vParents)) {
			for (ClassTypeInfo parent : new HashSet<>(validTypes)) {
				validTypes.addAll(List.of(parent.getParentModels()));
			}
			validTypes.addAll(vParents);
		}
		validTypes.add(typeinfo);
		validTypes.forEach((a) -> validAddresses.add(a.getAddress()));
		constructionModels = new ArrayList<>();
		while (true) {
			if (!GnuUtils.isValidPointer(program, currentAddress)) {
				break;
			}
			Address tiAddress = getTIAddress(currentAddress);
			if (tiAddress == null || tiAddress.equals(Address.NO_ADDRESS)) {
				break;
			}
			ClassTypeInfo currentType = manager.getType(tiAddress);
			if (!validTypes.contains((currentType))) {
				break;
			}
			int subCount = getSubTableCount(currentAddress);
			if(tiAddress.equals(typeinfo.getAddress())) {
				tableSize += subCount;
				currentAddress = address.add(tableSize * pointerSize);
				continue;
			}
			GnuVtable cvtable = new VtableModel(
				program, getTIPointer(currentAddress), currentType, subCount, true);
			tableSize += subCount;
			currentAddress = address.add(tableSize * pointerSize);
			constructionModels.add(cvtable);
		} return tableSize;
	}

	/**
	 * Gets the number of elements in this VttModel
	 * @return the number of VTable Table elements or 0 if invalid
	 */
	public int getElementCount() {
		if (elementCount == -1) {
			try {
				elementCount = getVTTableCount();
			} catch (InvalidDataTypeException e) {
				elementCount = 0;
			}
		}
		return elementCount;
	}

	/**
	 * Gets the DataType for this VttModel
	 * @return the DataType for this VttModel
	 */
	public DataType getDataType() {
		if (dataType == null) {
			DataTypeManager dtm = getProgram().getDataTypeManager();
			PointerDataType pointerDt = new PointerDataType(dtm);
			dataType = new ArrayDataType(pointerDt, getElementCount(), pointerSize, dtm);
		}
		return dataType;
	}

	@Override
	public String toString() {
		return "VTT for " + typeinfo.getFullName();
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/builder/AbstractTypeInfoProgramBuilder.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.builder;

import java.nio.charset.StandardCharsets;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.List;

import ghidra.app.cmd.data.rtti.gcc.GnuUtils;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.VtableModel;
import ghidra.app.cmd.data.rtti.gcc.VtableUtils;
import ghidra.app.cmd.data.rtti.gcc.VttModel;
import ghidra.program.database.ProgramBuilder;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

import ghidra.program.model.data.StringDataType;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.program.model.reloc.RelocationTable;
import ghidra.util.Msg;

public abstract class AbstractTypeInfoProgramBuilder extends ProgramBuilder {

	private Map<Long, String> typeMap;
	private Map<Long, String> nameMap;
	private Map<Long, String> vtableMap;
	private Map<Long, String> vttMap;
	private Long[] functionOffsets;
	private ProgramClassTypeInfoManager manager;

	protected AbstractTypeInfoProgramBuilder(String languageName, String compilerSpecID)
			throws Exception {
		super("TestProgram", languageName, compilerSpecID, null);
	}

	protected abstract void setupMemory();

	public final void init() throws Exception {
		setupMemory();
		Program program = getProgram();
		manager = CppClassAnalyzerUtils.getManager(program);
		startTransaction();
		typeMap = getTypeInfoMap();
		nameMap = getTypeNameMap();
		vtableMap = getVtableMap();
		vttMap = getVttMap();
		functionOffsets = getFunctionOffsets();
		Map<Long, String> relocationMap = getRelocationMap();
		try {
			for (Long offset : typeMap.keySet()) {
				setBytes(addr(offset).toString(), typeMap.get(offset));
			}
			for (Long offset : nameMap.keySet()) {
				createString(addr(offset).toString(), nameMap.get(offset));
			}
			for (Long offset : vtableMap.keySet()) {
				setBytes(addr(offset).toString(), vtableMap.get(offset));
			}
			for (Long offset : vttMap.keySet()) {
				setBytes(addr(offset).toString(), vttMap.get(offset));
			}
			MemoryBlock codeBlock = program.getMemory().getBlock(addr(functionOffsets[0]));
			if (!codeBlock.isExecute()) {
				setExecute(codeBlock, true);
			}
			for (Long offset : functionOffsets) {
				try {
					setBytes(addr(offset).toString(), getReturnInstruction(), true);
				} catch (Exception e) {
				}
			}
			if (GnuUtils.hasFunctionDescriptors(program)) {
				MemoryBlock block = program.getMemory().getBlock(".opd");
				setBytes(block.getStart().toString(), getFunctionDescriptors());
			}
		} catch (Exception e) {
			Msg.error(this, e);
			return;
		}
		RelocationTable table = program.getRelocationTable();
		for (Long offset : relocationMap.keySet()) {
			table.add(addr(offset), 1, null, null, relocationMap.get(offset));
		}
		buildTypes();
		endTransaction();
	}

	@Override
	public final void startTransaction() {
		super.startTransaction();
	}

	@Override
	public final void endTransaction() {
		super.endTransaction();
	}

	protected abstract Map<Long, String> getTypeInfoMap();
	protected abstract Map<Long, String> getTypeNameMap();
	protected abstract Map<Long, String> getVtableMap();
	protected abstract Map<Long, String> getVttMap();
	protected abstract Map<Long, String> getRelocationMap();
	protected abstract Long[] getFunctionOffsets();
	protected abstract String getReturnInstruction();
	protected abstract String getFunctionDescriptors();

	public List<TypeInfo> getTypeInfoList() {
		return typeMap.keySet().stream()
		   .map(this::addr)
		   .map(manager::getTypeInfo)
		   .collect(Collectors.toList());
	}

	public Stream<TypeInfo> getTypeInfoStream() {
		return typeMap.keySet().stream()
		   .map(this::addr)
		   .map(manager::getTypeInfo);
	}

	private void buildTypes() {
		typeMap.keySet().stream()
			.map(this::addr)
			.forEach(manager::getTypeInfo);
	}

	public List<GnuVtable> getVtableList() {
		List<GnuVtable> list = new ArrayList<>(vtableMap.size());
		Program program = getProgram();
		for (Long offset : vtableMap.keySet()) {
			ClassTypeInfo type = VtableUtils.getTypeInfo(program, addr(offset));
			list.add(VtableModel.getVtable(program, addr(offset), type));
		}
		return list;
	}

	public Stream<Vtable> getVtableStream() {
		return vtableMap.keySet().stream()
								 .map(this::addr)
								 .map(a -> VtableModel.getVtable(getProgram(), a));
	}

	public List<VttModel> getVttList() {
		List<VttModel> list = new ArrayList<>(vttMap.size());
		Program program = getProgram();
		vttMap.keySet().forEach((a) -> list.add(new VttModel(program, addr(a))));
		return list;
	}

	public Stream<VttModel> getVttStream() {
		return vttMap.keySet().stream()
							  .map(this::addr)
							  .map(a -> new VttModel(getProgram(), a));
	}

	protected static Entry<Long, String> getEntry(Long offset, String bytes) {
		return new AbstractMap.SimpleImmutableEntry<>(offset, bytes);
	}

	private void createString(String address, String string) throws Exception {
		createString(address, string, StandardCharsets.US_ASCII,
				true, StringDataType.dataType);
	}

	public ProgramClassTypeInfoManager getManager() {
		return manager;
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/builder/Ppc64TypeInfoProgramBuilder.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.builder;

import java.util.Map;

public class Ppc64TypeInfoProgramBuilder extends AbstractTypeInfoProgramBuilder {
	private static final Map<Long, String> typeMap = Map.ofEntries(
		getEntry(0x0014b2e0L, "00000000001511e800000000001218900000000000000002000000000014bbf00000000000000002000000000014b3a00000000000000002"),
		getEntry(0x0014b318L, "00000000001511e800000000001218b80000000100000002000000000014b3680000000000000002000000000014b3500000000000001002"),
		getEntry(0x0014b350L, "000000000015118000000000001218d8000000000014b390"),
		getEntry(0x0014b368L, "00000000001511e800000000001218f80000000000000001000000000014b390ffffffffffffe803"),
		getEntry(0x0014b390L, "00000000001510b00000000000121918"),
		getEntry(0x0014b3a0L, "00000000001510b00000000000121938"),
		getEntry(0x0014b3b0L, "00000000001511e80000000000121a580000000000000002000000000014bbf00000000000000002000000000014b3a00000000000000002"),
		getEntry(0x0014b3e8L, "00000000001511e80000000000121a700000000200000002000000000014b4480000000000000002000000000014b4200000000000001002"),
		getEntry(0x0014b420L, "00000000001511e80000000000121a800000000000000001000000000014b470ffffffffffffe803"),
		getEntry(0x0014b448L, "00000000001511e80000000000121a900000000000000001000000000014b470ffffffffffffe803"),
		getEntry(0x0014b470L, "00000000001510b00000000000121aa0"),
		getEntry(0x0014b498L, "00000000001511800000000000121ac8000000000014bbf0"),
		getEntry(0x0014b4b0L, "00000000001511a80000000000121ae8"),
		getEntry(0x0014b4c0L, "00000000001511700000000000121af00000000000000000000000000014b50800000000"),
		getEntry(0x0014b4e8L, "00000000001511c80000000000121b18"),
		getEntry(0x0014b4f8L, "00000000001510380000000000121b38"),
		getEntry(0x0014b508L, "00000000001511a80000000000121b40"),
		getEntry(0x0014b578L, "00000000001511e80000000000121d300000000000000004000000000014b7600000000000000002000000000014b7300000000000000002000000000014b7400000000000000002000000000014b7500000000000000002"),
		getEntry(0x0014b5d0L, "00000000001511800000000000121d18000000000014bbf0"),
		getEntry(0x0014b5e8L, "00000000001511e80000000000121d580000000000000004000000000014b760ffffffffffffe803000000000014b730ffffffffffffe003000000000014b740ffffffffffffd803000000000014b750ffffffffffffd003"),
		getEntry(0x0014b640L, "00000000001511e80000000000121d800000000000000004000000000014b720ffffffffffffe003000000000014b710ffffffffffffd803000000000014b700ffffffffffffd003000000000014b6f0ffffffffffffc803"),
		getEntry(0x0014b698L, "00000000001511e80000000000121da80000000000000004000000000014b7200000000000000002000000000014b7100000000000000802000000000014b7000000000000001002000000000014b6f00000000000001802"),
		getEntry(0x0014b6f0L, "00000000001510b00000000000121dd0"),
		getEntry(0x0014b700L, "00000000001510b00000000000121df8"),
		getEntry(0x0014b710L, "00000000001510b00000000000121e20"),
		getEntry(0x0014b720L, "00000000001510b00000000000121e48"),
		getEntry(0x0014b730L, "00000000001510b00000000000121e70"),
		getEntry(0x0014b740L, "00000000001510b00000000000121e98"),
		getEntry(0x0014b750L, "00000000001510b00000000000121ec0"),
		getEntry(0x0014b760L, "00000000001510b00000000000121ee8"),
		getEntry(0x0014b770L, "00000000001511e800000000001221c80000000000000002000000000014bbf00000000000000002000000000014b3a00000000000000002"),
		getEntry(0x0014b7a8L, "00000000001511e800000000001221e80000000000000004000000000014b8c00000000000000002000000000014b8880000000000001002000000000014b8780000000000002002000000000014b9580000000000003002"),
		getEntry(0x0014b800L, "00000000001511e800000000001222000000000200000006000000000014b930ffffffffffffe003000000000014b958ffffffffffffd803000000000014b8880000000000000002000000000014b908ffffffffffffd003000000000014b8c00000000000001002000000000014b8780000000000002002"),
		getEntry(0x0014b878L, "00000000001510b00000000000122218"),
		getEntry(0x0014b888L, "00000000001511e800000000001222300000000000000001000000000014b8b0ffffffffffffe803"),
		getEntry(0x0014b8b0L, "00000000001510b00000000000122248"),
		getEntry(0x0014b8c0L, "00000000001510b00000000000122260"),
		getEntry(0x0014b8d0L, "00000000001511e800000000001222780000000200000002000000000014b9300000000000000002000000000014b9080000000000001002"),
		getEntry(0x0014b908L, "00000000001511e800000000001222900000000000000001000000000014b958ffffffffffffe803"),
		getEntry(0x0014b930L, "00000000001511e800000000001222a80000000000000001000000000014b958ffffffffffffe803"),
		getEntry(0x0014b958L, "00000000001510b000000000001222c0"),
		getEntry(0x0014b968L, "00000000001511e800000000001223480000000000000002000000000014bbf00000000000000002000000000014b3a00000000000000002"),
		getEntry(0x0014b9a0L, "00000000001511e800000000001223600000000000000001000000000014ba10ffffffffffffe801"),
		getEntry(0x0014b9c8L, "00000000001511e800000000001223780000000000000002000000000014ba48ffffffffffffe803000000000014ba00ffffffffffffe003"),
		getEntry(0x0014ba00L, "00000000001510b00000000000122390"),
		getEntry(0x0014ba10L, "00000000001511e800000000001223a80000000000000002000000000014ba480000000000000002000000000014ba000000000000000002"),
		getEntry(0x0014ba48L, "00000000001510b000000000001223c0"),
		getEntry(0x0014ba58L, "00000000001511e800000000001225380000000000000002000000000014bbf00000000000000002000000000014b3a00000000000000002"),
		getEntry(0x0014ba90L, "00000000001511e800000000001225500000000100000002000000000014bae00000000000000002000000000014bac80000000000001002"),
		getEntry(0x0014bac8L, "00000000001511800000000000122568000000000014bb08"),
		getEntry(0x0014bae0L, "00000000001511e800000000001225800000000000000001000000000014bb08ffffffffffffe803"),
		getEntry(0x0014bb08L, "00000000001510b00000000000122598"),
		getEntry(0x0014bb18L, "00000000001511e800000000001226d00000000000000002000000000014bbf00000000000000002000000000014b3a00000000000000002"),
		getEntry(0x0014bb50L, "000000000015118000000000001226f8000000000014bb90"),
		getEntry(0x0014bb68L, "00000000001511e800000000001227180000000000000001000000000014bb90ffffffffffffe803"),
		getEntry(0x0014bb90L, "00000000001511e800000000001227380000000000000001000000000014bbb8ffffffffffffe803"),
		getEntry(0x0014bbb8L, "00000000001510b00000000000122758"),
		getEntry(0x0014bbf0L, "00000000001510b00000000000122808"),
		getEntry(0x0014bc30L, "00000000001511800000000000122848000000000014bbf0"),
		getEntry(0x0014bc48L, "00000000001511e800000000001228680000000100000002000000000014bce0ffffffffffffe803000000000014bcb8ffffffffffffe003"),
		getEntry(0x0014bc80L, "00000000001511e800000000001228880000000100000002000000000014bce00000000000000002000000000014bcb80000000000001002"),
		getEntry(0x0014bcb8L, "00000000001511e800000000001228a80000000000000001000000000014bd90ffffffffffffe803"),
		getEntry(0x0014bce0L, "000000000015118000000000001228c8000000000014bd90"),
		getEntry(0x0014bcf8L, "00000000001511e800000000001228e80000000200000002000000000014bd580000000000000002000000000014bd300000000000001002"),
		getEntry(0x0014bd30L, "00000000001511e800000000001229080000000000000001000000000014bd80ffffffffffffe803"),
		getEntry(0x0014bd58L, "00000000001511e800000000001229280000000000000001000000000014bd80ffffffffffffe803"),
		getEntry(0x0014bd80L, "00000000001510b00000000000122948"),
		getEntry(0x0014bd90L, "00000000001510b00000000000122968")
	);

	private static final Map<Long, String> nameMap = Map.ofEntries(
		getEntry(0x00121890L, "N20abstract_inheritance7PrinterE"),
		getEntry(0x001218b8L, "N20abstract_inheritance1IE"),
		getEntry(0x001218d8L, "N20abstract_inheritance1HE"),
		getEntry(0x001218f8L, "N20abstract_inheritance1GE"),
		getEntry(0x00121918L, "N20abstract_inheritance1FE"),
		getEntry(0x00121938L, "12Serializable"),
		getEntry(0x00121a58L, "N7diamond7PrinterE"),
		getEntry(0x00121a70L, "N7diamond1DE"),
		getEntry(0x00121a80L, "N7diamond1CE"),
		getEntry(0x00121a90L, "N7diamond1BE"),
		getEntry(0x00121aa0L, "N7diamond1AE"),
		getEntry(0x00121ac8L, "N17fundamental_types4._83E"),
		getEntry(0x00121ae8L, "FvvE"),
		getEntry(0x00121af0L, "MN20abstract_inheritance1GEKFmvE"),
		getEntry(0x00121b18L, "N17fundamental_types6NumberE"),
		getEntry(0x00121b38L, "A_i"),
		getEntry(0x00121b40L, "FmvE"),
		getEntry(0x00121d30L, "N10interfaces21non_virtual_functions1EE"),
		getEntry(0x00121d18L, "N10interfaces4._83E"),
		getEntry(0x00121d58L, "N10interfaces21non_virtual_functions1FE"),
		getEntry(0x00121d80L, "N10interfaces17virtual_functions1FE"),
		getEntry(0x00121da8L, "N10interfaces17virtual_functions1EE"),
		getEntry(0x00121dd0L, "N10interfaces17virtual_functions1DE"),
		getEntry(0x00121df8L, "N10interfaces17virtual_functions1CE"),
		getEntry(0x00121e20L, "N10interfaces17virtual_functions1BE"),
		getEntry(0x00121e48L, "N10interfaces17virtual_functions1AE"),
		getEntry(0x00121e70L, "N10interfaces21non_virtual_functions1BE"),
		getEntry(0x00121e98L, "N10interfaces21non_virtual_functions1CE"),
		getEntry(0x00121ec0L, "N10interfaces21non_virtual_functions1DE"),
		getEntry(0x00121ee8L, "N10interfaces21non_virtual_functions1AE"),
		getEntry(0x001221c8L, "N17large_inheritance7PrinterE"),
		getEntry(0x001221e8L, "N17large_inheritance1VE"),
		getEntry(0x00122200L, "N17large_inheritance1WE"),
		getEntry(0x00122218L, "N17large_inheritance1XE"),
		getEntry(0x00122230L, "N17large_inheritance1YE"),
		getEntry(0x00122248L, "N17large_inheritance1UE"),
		getEntry(0x00122260L, "N17large_inheritance1ZE"),
		getEntry(0x00122278L, "N17large_inheritance1DE"),
		getEntry(0x00122290L, "N17large_inheritance1CE"),
		getEntry(0x001222a8L, "N17large_inheritance1BE"),
		getEntry(0x001222c0L, "N17large_inheritance1AE"),
		getEntry(0x00122348L, "N10no_members7PrinterE"),
		getEntry(0x00122360L, "N10no_members1EE"),
		getEntry(0x00122378L, "N10no_members1DE"),
		getEntry(0x00122390L, "N10no_members1BE"),
		getEntry(0x001223a8L, "N10no_members1CE"),
		getEntry(0x001223c0L, "N10no_members1AE"),
		getEntry(0x00122538L, "N11non_diamond7PrinterE"),
		getEntry(0x00122550L, "N11non_diamond1DE"),
		getEntry(0x00122568L, "N11non_diamond1CE"),
		getEntry(0x00122580L, "N11non_diamond1BE"),
		getEntry(0x00122598L, "N11non_diamond1AE"),
		getEntry(0x001226d0L, "N20no_virtual_functions7PrinterE"),
		getEntry(0x001226f8L, "N20no_virtual_functions1DE"),
		getEntry(0x00122718L, "N20no_virtual_functions1CE"),
		getEntry(0x00122738L, "N20no_virtual_functions1BE"),
		getEntry(0x00122758L, "N20no_virtual_functions1AE"),
		getEntry(0x00122808L, "9Printable"),
		getEntry(0x00122848L, "N21virtual_member_access4._83E"),
		getEntry(0x00122868L, "N21virtual_member_access1HE"),
		getEntry(0x00122888L, "N21virtual_member_access1GE"),
		getEntry(0x001228a8L, "N21virtual_member_access1FE"),
		getEntry(0x001228c8L, "N21virtual_member_access1EE"),
		getEntry(0x001228e8L, "N21virtual_member_access1DE"),
		getEntry(0x00122908L, "N21virtual_member_access1CE"),
		getEntry(0x00122928L, "N21virtual_member_access1BE"),
		getEntry(0x00122948L, "N21virtual_member_access1AE"),
		getEntry(0x00122968L, "N21virtual_member_access9AbstractAE")
	);

	private static final Map<Long, String> vtableMap = Map.ofEntries(
		getEntry(0x00149208L, "0000000000000000000000000014b2e0000000000014c758000000000014c770000000000014c500"),
		getEntry(0x00149230L, "00000000000000280000000000000000000000000014b318000000000014c788000000000014c7d0000000000014c158000000000014c470000000000014c428000000000014c3e0000000000014c3c8fffffffffffffff0000000000014b318000000000014c7a0000000000014c7e8000000000014c080000000000014c458000000000014c098000000000014c410000000000014c4a0000000000014c248ffffffffffffffd8ffffffffffffffd80000000000000000ffffffffffffffd80000000000000000ffffffffffffffd8ffffffffffffffd8000000000014b318000000000014c7b8000000000014c800000000000014c080000000000014c440000000000014c098000000000014c3f8000000000014c488"),
		getEntry(0x00149428L, "0000000000000000000000000014b350000000000014c368000000000014c380000000000014c080000000000014c278000000000014c098000000000014c290000000000014c260000000000014c248"),
		getEntry(0x00149478L, "00000000000000100000000000000000000000000014b368000000000014c308000000000014c338000000000014c158000000000014c170000000000014c1a0000000000014c1d0fffffffffffffff0fffffffffffffff00000000000000000fffffffffffffff00000000000000000fffffffffffffff0fffffffffffffff0000000000014b368000000000014c320000000000014c350000000000014c080000000000014c1b8000000000014c098000000000014c1e8000000000014c188"),
		getEntry(0x0014b298L, "0000000000000000000000000014b39000000000000000000000000000000000000000000014c0800000000000151210000000000014c0980000000000151210000000000014c0b0"),
		getEntry(0x00149548L, "0000000000000000000000000014b3b0000000000014cce0000000000014ccf8000000000014cbf0"),
		getEntry(0x00149570L, "00000000000000200000000000000000000000000014b3e8000000000014cd10000000000014cd58000000000014c8c0000000000014c8d8000000000014c8f0000000000014c9b0000000000014c9c8000000000014c9e00000000000000010fffffffffffffff0000000000014b3e8000000000014cd28000000000014cd70000000000014c938000000000014c950000000000014c968000000000000000000000000000000000000000000000000ffffffffffffffe0ffffffffffffffe0000000000014b3e8000000000014cd40000000000014cd88000000000014c848000000000014c860000000000014c878"),
		getEntry(0x001497c8L, "00000000000000100000000000000000000000000014b420000000000014cb60000000000014cb90000000000014c938000000000014c950000000000014c968000000000000000000000000000000000000000000000000fffffffffffffff0fffffffffffffff0000000000014b420000000000014cb78000000000014cba8000000000014c848000000000014c860000000000014c878"),
		getEntry(0x00149870L, "00000000000000100000000000000000000000000014b448000000000014cae8000000000014cb18000000000014c8c0000000000014c8d8000000000014c8f0000000000000000000000000000000000000000000000000fffffffffffffff0fffffffffffffff0000000000014b448000000000014cb00000000000014cb30000000000014c848000000000014c860000000000014c878"),
		getEntry(0x00149918L, "0000000000000000000000000014b470000000000014ca40000000000014ca58000000000014c848000000000014c860000000000014c878"),
		getEntry(0x00149970L, "0000000000000000000000000014b498000000000014ce30000000000014ce48000000000014ce00"),
		getEntry(0x00149998L, "0000000000000000000000000014b5d0000000000014d2c8000000000014d2e0000000000014d118"),
		getEntry(0x00149b18L, "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014b5e8"),
		getEntry(0x001499c0L, "000000000000001800000000000000100000000000000008000000000000000000000000000000000000000000000000000000000014b640000000000014cf38000000000014cf68000000000014cf98000000000014cfc8fffffffffffffff8fffffffffffffff8000000000014b640000000000014cf80fffffffffffffff0fffffffffffffff0000000000014b640000000000014cfb0ffffffffffffffe8ffffffffffffffe8000000000014b640000000000014cfe0"),
		getEntry(0x00149aa0L, "0000000000000000000000000014b698000000000014ce90000000000014cea8000000000014ced8000000000014cf08fffffffffffffff8000000000014b698000000000014cec0fffffffffffffff0000000000014b698000000000014cef0ffffffffffffffe8000000000014b698000000000014cf20"),
		getEntry(0x0014b518L, "0000000000000000000000000014b6f00000000000151210"),
		getEntry(0x0014b530L, "0000000000000000000000000014b7000000000000151210"),
		getEntry(0x0014b548L, "0000000000000000000000000014b7100000000000151210"),
		getEntry(0x0014b560L, "0000000000000000000000000014b7200000000000151210"),
		getEntry(0x00149b50L, "0000000000000000000000000014b770000000000014df70000000000014df88000000000014dd18"),
		getEntry(0x00149b78L, "00000000000000480000000000000000000000000014b7a8000000000014d460000000000014d4d8000000000014d9d0000000000014d748000000000014d760000000000014d9b8000000000014d9e8000000000014da18000000000014da48000000000014da78000000000014da900000000000000038fffffffffffffff0000000000014b7a8000000000014d4c0000000000014d538000000000014da00000000000014d838000000000014d850ffffffffffffffe0000000000014b7a8000000000014d4a8000000000014d520000000000014da30000000000014d8b0000000000014d8c8ffffffffffffffd0000000000014b7a8000000000014d490000000000014d508000000000014da60000000000014d568000000000014d580000000000000000000000000000000000000000000000000ffffffffffffffb8ffffffffffffffb8000000000014b7a8000000000014d478000000000014d4f0000000000014d7a8000000000014d7c0000000000014d7d8"),
		getEntry(0x00149db0L, "00000000000000600000000000000040000000000000003000000000000000500000000000000000000000000014b800000000000014dfa0000000000014e018000000000014d820000000000014d838000000000014d850000000000014d910000000000014d928000000000014d958000000000014d970fffffffffffffff0000000000014b800000000000014dfb8000000000014e030000000000014d940000000000014d748000000000014d760ffffffffffffffe0000000000014b800000000000014dfd0000000000014e048000000000014d898000000000014d8b0000000000014d8c8000000000000000000000000000000000000000000000000ffffffffffffffd00000000000000010ffffffffffffffd0000000000014b800000000000014dfe8000000000014e060000000000014d5c8000000000014d5e0000000000014d5f8000000000000000000000000000000000000000000000000ffffffffffffffc0ffffffffffffffc0000000000014b800000000000014e000000000000014e078000000000014d550000000000014d568000000000014d580000000000000000000000000000000000000000000000000ffffffffffffffb0ffffffffffffffb0000000000014b800000000000014e000000000000014e078000000000014d7a8000000000014d7c0000000000014d7d8000000000000000000000000000000000000000000000000ffffffffffffffa0ffffffffffffffe0ffffffffffffffa0000000000014b800000000000014dfe8000000000014e060000000000014d640000000000014d658000000000014d670"),
		getEntry(0x0014a228L, "0000000000000000000000000014b878000000000014d400000000000014d418000000000014d898000000000014d8b0000000000014d8c8"),
		getEntry(0x0014a260L, "00000000000000100000000000000000000000000014b888000000000014d3a0000000000014d3d0000000000014d820000000000014d838000000000014d850000000000000000000000000000000000000000000000000fffffffffffffff0fffffffffffffff0000000000014b888000000000014d3b8000000000014d3e8000000000014d7a8000000000014d7c0000000000014d7d8"),
		getEntry(0x0014a308L, "0000000000000000000000000014b8b0000000000014d328000000000014d340000000000014d7a8000000000014d7c0000000000014d7d8"),
		getEntry(0x0014a340L, "0000000000000000000000000014b8c0000000000014d358000000000014d370000000000014d730000000000014d748000000000014d760"),
		getEntry(0x0014a378L, "00000000000000200000000000000000000000000014b8d0000000000014e090000000000014e0d8000000000014d5c8000000000014d5e0000000000014d5f8000000000014d6b8000000000014d6d0000000000014d6e80000000000000010fffffffffffffff0000000000014b8d0000000000014e0a8000000000014e0f0000000000014d640000000000014d658000000000014d670000000000000000000000000000000000000000000000000ffffffffffffffe0ffffffffffffffe0000000000014b8d0000000000014e0c0000000000014e108000000000014d550000000000014d568000000000014d580"),
		getEntry(0x0014a5d0L, "00000000000000100000000000000000000000000014b908000000000014dbe0000000000014dc10000000000014d640000000000014d658000000000014d670000000000000000000000000000000000000000000000000fffffffffffffff0fffffffffffffff0000000000014b908000000000014dbf8000000000014dc28000000000014d550000000000014d568000000000014d580"),
		getEntry(0x0014a678L, "00000000000000100000000000000000000000000014b930000000000014db68000000000014db98000000000014d5c8000000000014d5e0000000000014d5f8000000000000000000000000000000000000000000000000fffffffffffffff0fffffffffffffff0000000000014b930000000000014db80000000000014dbb0000000000014d550000000000014d568000000000014d580"),
		getEntry(0x0014a720L, "0000000000000000000000000014b958000000000014d430000000000014d448000000000014d550000000000014d568000000000014d580"),
		getEntry(0x0014a758L, "0000000000000000000000000014b968000000000014e480000000000014e498000000000014e3a8"),
		getEntry(0x0014a780L, "00000000000000000000000000000000000000000014b9a0"),
		getEntry(0x0014a7a0L, "000000000000000000000000000000000000000000000000000000000014b9c8"),
		getEntry(0x0014a7c8L, "0000000000000000000000000014ba58000000000014e930000000000014e948000000000014e858"),
		getEntry(0x0014a7f0L, "00000000000000280000000000000000000000000014ba90000000000014e960000000000014e9a8000000000014e558000000000014e570000000000014e588000000000014e648000000000014e660000000000014e678fffffffffffffff0000000000014ba90000000000014e978000000000014e9c0000000000014e4e0000000000014e4f8000000000014e510000000000014e5d0000000000014e5e8000000000014e600000000000000000000000000000000000000000000000000ffffffffffffffd8ffffffffffffffd8000000000014ba90000000000014e990000000000014e9d8000000000014e4e0000000000014e4f8000000000014e510"),
		getEntry(0x0014a9a8L, "0000000000000000000000000014bac8000000000014e7f8000000000014e810000000000014e4e0000000000014e4f8000000000014e510000000000014e5d0000000000014e5e8000000000014e600"),
		getEntry(0x0014a9f8L, "00000000000000100000000000000000000000000014bae0000000000014e798000000000014e7c8000000000014e558000000000014e570000000000014e588000000000000000000000000000000000000000000000000fffffffffffffff0fffffffffffffff0000000000014bae0000000000014e7b0000000000014e7e0000000000014e4e0000000000014e4f8000000000014e510"),
		getEntry(0x0014aaa0L, "0000000000000000000000000014bb08000000000014e708000000000014e720000000000014e4e0000000000014e4f8000000000014e510"),
		getEntry(0x0014aad8L, "0000000000000000000000000014bb18000000000014ed50000000000014ed68000000000014ec78"),
		getEntry(0x0014ab00L, "00000000000000100000000000000000000000000014bb50"),
		getEntry(0x0014ab40L, "000000000000001c00000000000000100000000000000000000000000014bb68000000000000000cfffffffffffffff0000000000014bb68"),
		getEntry(0x0014aba8L, "000000000000000c0000000000000000000000000014bb90"),
		getEntry(0x0014bbc8L, "0000000000000000000000000014bbf0000000000000000000000000000000000000000000151210"),
		getEntry(0x0014abc8L, "0000000000000000000000000014bc30000000000014fba8000000000014fbc0000000000014fb78"),
		getEntry(0x0014abf0L, "0000000000000030000000000000002000000000000000100000000000000000000000000014bc48000000000014fbd8000000000014fc20000000000014f818fffffffffffffff00000000000000000fffffffffffffff0fffffffffffffff0000000000014bc48000000000014fbf0000000000014fc38000000000014f740000000000014f848ffffffffffffffe00000000000000000ffffffffffffffe00000000000000010ffffffffffffffe0000000000014bc48000000000014fc08000000000014fc50000000000014f770000000000014f830ffffffffffffffd0fffffffffffffff0ffffffffffffffd0ffffffffffffffd0000000000014bc48000000000014fbf0000000000014fc38000000000014f788000000000014f848"),
		getEntry(0x0014adc0L, "00000000000000200000000000000000000000000014bc80000000000014fc68000000000014fcb0000000000014f740000000000014f7d00000000000000010fffffffffffffff0000000000014bc80000000000014fc80000000000014fcc8000000000014f770000000000014f800ffffffffffffffe0fffffffffffffff0ffffffffffffffe0ffffffffffffffe0000000000014bc80000000000014fc98000000000014fce0000000000014f788000000000014f7e8"),
		getEntry(0x0014af20L, "00000000000000100000000000000000000000000014bcb8000000000014fae8000000000014fb18000000000014f770000000000014f7a0fffffffffffffff0fffffffffffffff0fffffffffffffff0fffffffffffffff0000000000014bcb8000000000014fb00000000000014fb30000000000014f788000000000014f7b8"),
		getEntry(0x0014afb0L, "0000000000000000000000000014bce0000000000014faa0000000000014fab8000000000014f740000000000014f758"),
		getEntry(0x0014afe0L, "00000000000000200000000000000000000000000014bcf8000000000014fcf8000000000014fd40000000000014f6f80000000000000010fffffffffffffff0000000000014bcf8000000000014fd10000000000014fd58000000000014f728ffffffffffffffe0ffffffffffffffe0ffffffffffffffe0000000000014bcf8000000000014fd28000000000014fd70000000000014f710"),
		getEntry(0x0014b180L, "00000000000000100000000000000000000000000014bd30000000000014f998000000000014f9c8000000000014f6c8fffffffffffffff0fffffffffffffff0fffffffffffffff0000000000014bd30000000000014f9b0000000000014f9e0000000000014f6e0"),
		getEntry(0x0014b1f8L, "00000000000000100000000000000000000000000014bd58000000000014f920000000000014f950000000000014f698fffffffffffffff0fffffffffffffff0fffffffffffffff0000000000014bd58000000000014f938000000000014f968000000000014f6b0"),
		getEntry(0x0014b270L, "0000000000000000000000000014bd80000000000014f878000000000014f890000000000014f680"),
		getEntry(0x0014bc00L, "0000000000000000000000000014bd90000000000000000000000000000000000000000000151210000000000014f668")
	);

	private static final Map<Long, String> vttMap = Map.ofEntries(
		getEntry(0x00149348L, "0000000000149248000000000014938000000000001493f00000000000149310"),
		getEntry(0x00149538L, "00000000001494900000000000149500"),
		getEntry(0x00149660L, "000000000014958800000000001496b00000000000149708000000000014974800000000001497a0000000000014963800000000001495e0"),
		getEntry(0x00149860L, "00000000001497e00000000000149838"),
		getEntry(0x00149908L, "000000000014988800000000001498e0"),
		getEntry(0x00149a78L, "00000000001499f800000000001499f80000000000149a300000000000149a500000000000149a70"),
		getEntry(0x00149b48L, "0000000000149b48"),
		getEntry(0x00149cf0L, "0000000000149b900000000000149d300000000000149d880000000000149c000000000000149cc8"),
		getEntry(0x0014a008L, "0000000000149de0000000000014a078000000000014a0d00000000000149ed00000000000149f280000000000149f800000000000149fe0000000000014a110000000000014a168000000000014a1a8000000000014a200"),
		getEntry(0x0014a2f8L, "000000000014a278000000000014a2d0"),
		getEntry(0x0014a468L, "000000000014a390000000000014a4b8000000000014a510000000000014a550000000000014a5a8000000000014a440000000000014a3e8"),
		getEntry(0x0014a668L, "000000000014a5e8000000000014a640"),
		getEntry(0x0014a710L, "000000000014a690000000000014a6e8"),
		getEntry(0x0014a798L, "000000000014a798"),
		getEntry(0x0014a7c0L, "000000000014a7c0"),
		getEntry(0x0014a8f0L, "000000000014a808000000000014a928000000000014a980000000000014a8c8"),
		getEntry(0x0014aa90L, "000000000014aa10000000000014aa68"),
		getEntry(0x0014ab18L, "000000000014ab18000000000014ab40"),
		getEntry(0x0014ab78L, "000000000014ab60000000000014ab78000000000014aba8"),
		getEntry(0x0014abc0L, "000000000014abc0"),
		getEntry(0x0014ad10L, "000000000014ac18000000000014ac58000000000014aca8000000000014acf0000000000014ad58000000000014ada0"),
		getEntry(0x0014ae78L, "000000000014add8000000000014aeb8000000000014af00000000000014ae10000000000014ae58"),
		getEntry(0x0014afa0L, "000000000014af38000000000014af80"),
		getEntry(0x0014b078L, "000000000014aff8000000000014b0c8000000000014b100000000000014b130000000000014b168000000000014b060000000000014b028"),
		getEntry(0x0014b1e8L, "000000000014b198000000000014b1d0"),
		getEntry(0x0014b260L, "000000000014b210000000000014b248")
	);

	private static final Map<Long, String> relocationMap = Map.ofEntries(
		getEntry(0x0014b2c0L, "__cxa_pure_virtual"),
		getEntry(0x0014b2d0L, "__cxa_pure_virtual"),
		getEntry(0x0014b2e0L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b318L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b350L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0014b368L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b390L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b3a0L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b3b0L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b3e8L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b420L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b448L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b470L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b498L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0014b4b0L, "_ZTVN10__cxxabiv120__function_type_infoE"),
		getEntry(0x0014b4c0L, "_ZTVN10__cxxabiv129__pointer_to_member_type_infoE"),
		getEntry(0x0014b4e8L, "_ZTVN10__cxxabiv116__enum_type_infoE"),
		getEntry(0x0014b4f8L, "_ZTVN10__cxxabiv117__array_type_infoE"),
		getEntry(0x0014b508L, "_ZTVN10__cxxabiv120__function_type_infoE"),
		getEntry(0x0014b528L, "__cxa_pure_virtual"),
		getEntry(0x0014b540L, "__cxa_pure_virtual"),
		getEntry(0x0014b558L, "__cxa_pure_virtual"),
		getEntry(0x0014b570L, "__cxa_pure_virtual"),
		getEntry(0x0014b578L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b5d0L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0014b5e8L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b640L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b698L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b6f0L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b700L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b710L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b720L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b730L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b740L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b750L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b760L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b770L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b7a8L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b800L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b878L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b888L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b8b0L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b8c0L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b8d0L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b908L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b930L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b958L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014b968L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b9a0L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014b9c8L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014ba00L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014ba10L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014ba48L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014ba58L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014ba90L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014bac8L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0014bae0L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014bb08L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014bb18L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014bb50L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0014bb68L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014bb90L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014bbb8L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014bbe8L, "__cxa_pure_virtual"),
		getEntry(0x0014bbf0L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014bc20L, "__cxa_pure_virtual"),
		getEntry(0x0014bc30L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0014bc48L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014bc80L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014bcb8L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014bce0L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0014bcf8L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014bd30L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014bd58L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0014bd80L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0014bd90L, "_ZTVN10__cxxabiv117__class_type_infoE")
	);

	private static final Long[] functionOffsets = new Long[]{
		0x00111f2cL,
		0x00111f88L,
		0x00110d6cL,
		0x00111fdcL,
		0x001120a8L,
		0x0010ff50L,
		0x001109bcL,
		0x001108f8L,
		0x001108b0L,
		0x00110884L,
		0x00112090L,
		0x001120fcL,
		0x0010fad4L,
		0x001109b4L,
		0x0010fb00L,
		0x001108f0L,
		0x00110b0cL,
		0x00110394L,
		0x00112098L,
		0x00112104L,
		0x001109a4L,
		0x001108e0L,
		0x00110afcL,
		0x001112b4L,
		0x00111310L,
		0x00110478L,
		0x00110524L,
		0x001103c0L,
		0x001111ccL,
		0x00111250L,
		0x0010ff7cL,
		0x0011005cL,
		0x00110118L,
		0x00111240L,
		0x001112a4L,
		0x00110108L,
		0x00110148L,
		0x0011004cL,
		0x00151210L,
		0x0010fb34L,
		0x001138a8L,
		0x00113904L,
		0x00112bbcL,
		0x00113958L,
		0x00113a30L,
		0x001122e4L,
		0x00112310L,
		0x00112350L,
		0x001127f4L,
		0x00112820L,
		0x00112860L,
		0x00113a18L,
		0x00113a84L,
		0x0011256cL,
		0x00112598L,
		0x001125d8L,
		0x00113a20L,
		0x00113a8cL,
		0x00112114L,
		0x00112140L,
		0x00112180L,
		0x001132c0L,
		0x00113344L,
		0x00113334L,
		0x00113398L,
		0x00113170L,
		0x001131f4L,
		0x001131e4L,
		0x00113248L,
		0x00112ec0L,
		0x00112efcL,
		0x00113d4cL,
		0x00113da8L,
		0x00113c88L,
		0x00114b08L,
		0x00114b64L,
		0x0011444cL,
		0x001140c4L,
		0x00114128L,
		0x0011418cL,
		0x001141f0L,
		0x0011417cL,
		0x001141e0L,
		0x00114244L,
		0x00113f5cL,
		0x00113fb0L,
		0x0011400cL,
		0x00114068L,
		0x00114004L,
		0x00114060L,
		0x001140bcL,
		0x00118b94L,
		0x00118bf0L,
		0x00116d84L,
		0x001175d4L,
		0x001176f8L,
		0x00116898L,
		0x00115a0cL,
		0x00115a4cL,
		0x0011686cL,
		0x001168c4L,
		0x001168f8L,
		0x0011692cL,
		0x00116960L,
		0x001169a0L,
		0x001176f0L,
		0x0011776cL,
		0x001168f0L,
		0x00115dacL,
		0x00115decL,
		0x001176e8L,
		0x00117764L,
		0x00116924L,
		0x0011601cL,
		0x0011605cL,
		0x001176e0L,
		0x0011775cL,
		0x00116958L,
		0x00114ef8L,
		0x00114f38L,
		0x001176d0L,
		0x0011774cL,
		0x00115bb0L,
		0x00115bdcL,
		0x00115c1cL,
		0x00118c44L,
		0x00118ddcL,
		0x00115d80L,
		0x001161c0L,
		0x001161ecL,
		0x00116220L,
		0x00116260L,
		0x00118dacL,
		0x00118e30L,
		0x00116218L,
		0x00118db4L,
		0x00118e38L,
		0x00115ff0L,
		0x00118dbcL,
		0x00118e40L,
		0x0011509cL,
		0x001150c8L,
		0x00115108L,
		0x00118dccL,
		0x00118e50L,
		0x00114eccL,
		0x0011532cL,
		0x00115358L,
		0x00115398L,
		0x001174b4L,
		0x001174f0L,
		0x001173ccL,
		0x00117450L,
		0x00117440L,
		0x001174a4L,
		0x00117244L,
		0x00117280L,
		0x001172d4L,
		0x00117310L,
		0x001159e0L,
		0x00118e60L,
		0x00118f38L,
		0x001155bcL,
		0x001155e8L,
		0x00115628L,
		0x00118f20L,
		0x00118f8cL,
		0x00118f28L,
		0x00118f94L,
		0x00117b20L,
		0x00117ba4L,
		0x00117b94L,
		0x00117bf8L,
		0x001179d0L,
		0x00117a54L,
		0x00117a44L,
		0x00117aa8L,
		0x00117544L,
		0x00117580L,
		0x00119fe4L,
		0x0011a040L,
		0x00119988L,
		0x0011b768L,
		0x0011b7c4L,
		0x0011ac40L,
		0x0011b818L,
		0x0011b8e4L,
		0x0011a264L,
		0x0011a290L,
		0x0011a2d0L,
		0x0011a6a4L,
		0x0011a6d0L,
		0x0011a710L,
		0x0011b8ccL,
		0x0011b938L,
		0x0011a094L,
		0x0011a0c0L,
		0x0011a100L,
		0x0011a434L,
		0x0011a460L,
		0x0011a4a0L,
		0x0011b8d4L,
		0x0011b940L,
		0x0011b25cL,
		0x0011b2b8L,
		0x0011b174L,
		0x0011b1f8L,
		0x0011b1e8L,
		0x0011b24cL,
		0x0011af44L,
		0x0011af80L,
		0x0011cc28L,
		0x0011cc84L,
		0x0011c5ccL,
		0x0012016cL,
		0x001201c8L,
		0x0012001cL,
		0x00121010L,
		0x00121100L,
		0x0011fe58L,
		0x001210e0L,
		0x00121154L,
		0x0011fbb8L,
		0x0012000cL,
		0x001210f0L,
		0x00121164L,
		0x0011fc5cL,
		0x0011fffcL,
		0x0011fc88L,
		0x00121174L,
		0x00121240L,
		0x0011fd6cL,
		0x00121228L,
		0x00121294L,
		0x0011fe50L,
		0x00121230L,
		0x0012129cL,
		0x0011fe40L,
		0x00120da4L,
		0x00120e28L,
		0x0011fc98L,
		0x00120e18L,
		0x00120e7cL,
		0x0011fd5cL,
		0x00120c8cL,
		0x00120ce8L,
		0x0011fbe4L,
		0x001212acL,
		0x00121384L,
		0x0011fa88L,
		0x0012136cL,
		0x001213d8L,
		0x0011fbb0L,
		0x00121374L,
		0x001213e0L,
		0x0011fba0L,
		0x001208e0L,
		0x00120964L,
		0x0011f9b4L,
		0x00120954L,
		0x001209b8L,
		0x0011fa78L,
		0x00120790L,
		0x00120814L,
		0x0011f8e0L,
		0x00120804L,
		0x00120868L,
		0x0011f9a4L,
		0x001204e0L,
		0x0012051cL,
		0x0011f8a0L,
		0x0011f860L
		};

		private static final String returnString = "fbe1fff8f821ffc17c3f0b78f87f007060000000383f0040ebe1fff84e800020";

		private static final String fDescriptors = "000000000010f8800000000000157e000000000000000000000000000010f1600000000000157e00000000000000000000000000001217440000000000157e000000000000000000000000000010f8c00000000000157e000000000000000000000000000010f9200000000000157e000000000000000000000000000010f9900000000000157e000000000000000000000000000010fa800000000000157e0000000000000000000000000000110fe00000000000157e00000000000000000000000000001110200000000000157e000000000000000000000000000010fa840000000000157e000000000000000000000000000010fad40000000000157e000000000000000000000000000010fb000000000000157e000000000000000000000000000010fb340000000000157e000000000000000000000000000010fbe00000000000157e000000000000000000000000000010fc340000000000157e00000000000000000000000000001110980000000000157e00000000000000000000000000001110d40000000000157e000000000000000000000000000010fe600000000000157e000000000000000000000000000010fed00000000000157e000000000000000000000000000010ff500000000000157e000000000000000000000000000010ff7c0000000000157e000000000000000000000000000011004c0000000000157e000000000000000000000000000011005c0000000000157e00000000000000000000000000001101080000000000157e00000000000000000000000000001101180000000000157e00000000000000000000000000001101480000000000157e00000000000000000000000000001101580000000000157e00000000000000000000000000001101ac0000000000157e000000000000000000000000000011032c0000000000157e00000000000000000000000000001103940000000000157e00000000000000000000000000001103c00000000000157e00000000000000000000000000001104780000000000157e00000000000000000000000000001105240000000000157e00000000000000000000000000001105540000000000157e00000000000000000000000000001105a80000000000157e00000000000000000000000000001111280000000000157e00000000000000000000000000001111640000000000157e00000000000000000000000000001111cc0000000000157e00000000000000000000000000001112400000000000157e00000000000000000000000000001112500000000000157e00000000000000000000000000001112a40000000000157e00000000000000000000000000001112b40000000000157e00000000000000000000000000001113100000000000157e00000000000000000000000000001106f80000000000157e00000000000000000000000000001107c00000000000157e00000000000000000000000000001108840000000000157e00000000000000000000000000001108b00000000000157e00000000000000000000000000001108e00000000000157e00000000000000000000000000001108f00000000000157e00000000000000000000000000001108f80000000000157e00000000000000000000000000001109a40000000000157e00000000000000000000000000001109b40000000000157e00000000000000000000000000001109bc0000000000157e0000000000000000000000000000110afc0000000000157e0000000000000000000000000000110b0c0000000000157e0000000000000000000000000000110b140000000000157e0000000000000000000000000000110b680000000000157e00000000000000000000000000001113640000000000157e0000000000000000000000000000110d6c0000000000157e00000000000000000000000000001113c00000000000157e00000000000000000000000000001114100000000000157e00000000000000000000000000001114a40000000000157e00000000000000000000000000001114ec0000000000157e00000000000000000000000000001116140000000000157e00000000000000000000000000001116900000000000157e000000000000000000000000000011176c0000000000157e00000000000000000000000000001117d00000000000157e00000000000000000000000000001118340000000000157e00000000000000000000000000001118b40000000000157e00000000000000000000000000001119180000000000157e00000000000000000000000000001119800000000000157e00000000000000000000000000001119f80000000000157e0000000000000000000000000000111a5c0000000000157e0000000000000000000000000000111ac40000000000157e0000000000000000000000000000111b300000000000157e0000000000000000000000000000111b940000000000157e0000000000000000000000000000111bf00000000000157e0000000000000000000000000000111c200000000000157e0000000000000000000000000000111c800000000000157e0000000000000000000000000000111d040000000000157e0000000000000000000000000000111e7c0000000000157e0000000000000000000000000000111eb80000000000157e0000000000000000000000000000111eec0000000000157e0000000000000000000000000000111f2c0000000000157e0000000000000000000000000000111f880000000000157e0000000000000000000000000000111fdc0000000000157e00000000000000000000000000001120900000000000157e00000000000000000000000000001120980000000000157e00000000000000000000000000001120a80000000000157e00000000000000000000000000001120fc0000000000157e00000000000000000000000000001121040000000000157e0000000000000000000000000000110e400000000000157e0000000000000000000000000000110f9c0000000000157e00000000000000000000000000001121140000000000157e00000000000000000000000000001121400000000000157e00000000000000000000000000001121800000000000157e00000000000000000000000000001121b40000000000157e00000000000000000000000000001122080000000000157e00000000000000000000000000001122e40000000000157e00000000000000000000000000001123100000000000157e00000000000000000000000000001123500000000000157e00000000000000000000000000001123840000000000157e00000000000000000000000000001123d80000000000157e000000000000000000000000000011256c0000000000157e00000000000000000000000000001125980000000000157e00000000000000000000000000001125d80000000000157e000000000000000000000000000011260c0000000000157e00000000000000000000000000001126600000000000157e00000000000000000000000000001127f40000000000157e00000000000000000000000000001128200000000000157e00000000000000000000000000001128600000000000157e00000000000000000000000000001128940000000000157e00000000000000000000000000001128e80000000000157e0000000000000000000000000000112e840000000000157e0000000000000000000000000000112ec00000000000157e0000000000000000000000000000112efc0000000000157e0000000000000000000000000000112f500000000000157e0000000000000000000000000000112fb80000000000157e000000000000000000000000000011302c0000000000157e00000000000000000000000000001130940000000000157e00000000000000000000000000001131080000000000157e00000000000000000000000000001131700000000000157e00000000000000000000000000001131e40000000000157e00000000000000000000000000001131f40000000000157e00000000000000000000000000001132480000000000157e00000000000000000000000000001132580000000000157e00000000000000000000000000001132c00000000000157e00000000000000000000000000001133340000000000157e00000000000000000000000000001133440000000000157e00000000000000000000000000001133980000000000157e00000000000000000000000000001133a80000000000157e00000000000000000000000000001134680000000000157e0000000000000000000000000000112bbc0000000000157e00000000000000000000000000001134c40000000000157e00000000000000000000000000001135280000000000157e000000000000000000000000000011358c0000000000157e000000000000000000000000000011360c0000000000157e00000000000000000000000000001136700000000000157e00000000000000000000000000001136f00000000000157e00000000000000000000000000001137540000000000157e00000000000000000000000000001137bc0000000000157e000000000000000000000000000011383c0000000000157e00000000000000000000000000001138a80000000000157e00000000000000000000000000001139040000000000157e00000000000000000000000000001139580000000000157e0000000000000000000000000000113a180000000000157e0000000000000000000000000000113a200000000000157e0000000000000000000000000000113a300000000000157e0000000000000000000000000000113a840000000000157e0000000000000000000000000000113a8c0000000000157e0000000000000000000000000000112cb40000000000157e0000000000000000000000000000112e400000000000157e0000000000000000000000000000113f040000000000157e0000000000000000000000000000113a9c0000000000157e0000000000000000000000000000113c880000000000157e0000000000000000000000000000113cf00000000000157e0000000000000000000000000000113d4c0000000000157e0000000000000000000000000000113da80000000000157e0000000000000000000000000000113df80000000000157e0000000000000000000000000000113ec00000000000157e0000000000000000000000000000113f5c0000000000157e0000000000000000000000000000113fb00000000000157e00000000000000000000000000001140040000000000157e000000000000000000000000000011400c0000000000157e00000000000000000000000000001140600000000000157e00000000000000000000000000001140680000000000157e00000000000000000000000000001140bc0000000000157e00000000000000000000000000001140c40000000000157e00000000000000000000000000001141180000000000157e00000000000000000000000000001141280000000000157e000000000000000000000000000011417c0000000000157e000000000000000000000000000011418c0000000000157e00000000000000000000000000001141e00000000000157e00000000000000000000000000001141f00000000000157e00000000000000000000000000001142440000000000157e00000000000000000000000000001142540000000000157e00000000000000000000000000001142a80000000000157e00000000000000000000000000001142fc0000000000157e00000000000000000000000000001143500000000000157e00000000000000000000000000001143a40000000000157e00000000000000000000000000001143f80000000000157e0000000000000000000000000000114cc00000000000157e0000000000000000000000000000114cfc0000000000157e0000000000000000000000000000114d380000000000157e0000000000000000000000000000114d740000000000157e0000000000000000000000000000114db00000000000157e0000000000000000000000000000114e900000000000157e000000000000000000000000000011444c0000000000157e00000000000000000000000000001145fc0000000000157e00000000000000000000000000001146580000000000157e000000000000000000000000000011469c0000000000157e00000000000000000000000000001146e00000000000157e00000000000000000000000000001147240000000000157e00000000000000000000000000001147680000000000157e00000000000000000000000000001147ac0000000000157e00000000000000000000000000001147f00000000000157e00000000000000000000000000001148340000000000157e00000000000000000000000000001148780000000000157e00000000000000000000000000001148bc0000000000157e000000000000000000000000000011491c0000000000157e00000000000000000000000000001149600000000000157e00000000000000000000000000001149c00000000000157e0000000000000000000000000000114a040000000000157e0000000000000000000000000000114a640000000000157e0000000000000000000000000000114aa80000000000157e0000000000000000000000000000114b080000000000157e0000000000000000000000000000114b640000000000157e0000000000000000000000000000114bb40000000000157e0000000000000000000000000000114c7c0000000000157e00000000000000000000000000001172440000000000157e00000000000000000000000000001172800000000000157e00000000000000000000000000001172d40000000000157e00000000000000000000000000001173100000000000157e00000000000000000000000000001173640000000000157e00000000000000000000000000001173cc0000000000157e00000000000000000000000000001174400000000000157e00000000000000000000000000001174500000000000157e00000000000000000000000000001174a40000000000157e00000000000000000000000000001174b40000000000157e00000000000000000000000000001174f00000000000157e00000000000000000000000000001175440000000000157e00000000000000000000000000001175800000000000157e00000000000000000000000000001175d40000000000157e00000000000000000000000000001176d00000000000157e00000000000000000000000000001176e00000000000157e00000000000000000000000000001176e80000000000157e00000000000000000000000000001176f00000000000157e00000000000000000000000000001176f80000000000157e000000000000000000000000000011774c0000000000157e000000000000000000000000000011775c0000000000157e00000000000000000000000000001177640000000000157e000000000000000000000000000011776c0000000000157e0000000000000000000000000000114ecc0000000000157e0000000000000000000000000000114ef80000000000157e0000000000000000000000000000114f380000000000157e0000000000000000000000000000114f6c0000000000157e0000000000000000000000000000114fc00000000000157e000000000000000000000000000011509c0000000000157e00000000000000000000000000001150c80000000000157e00000000000000000000000000001151080000000000157e000000000000000000000000000011513c0000000000157e00000000000000000000000000001151980000000000157e000000000000000000000000000011532c0000000000157e00000000000000000000000000001153580000000000157e00000000000000000000000000001153980000000000157e00000000000000000000000000001153cc0000000000157e00000000000000000000000000001154280000000000157e00000000000000000000000000001155bc0000000000157e00000000000000000000000000001155e80000000000157e00000000000000000000000000001156280000000000157e000000000000000000000000000011565c0000000000157e00000000000000000000000000001156b80000000000157e00000000000000000000000000001159e00000000000157e0000000000000000000000000000115a0c0000000000157e0000000000000000000000000000115a4c0000000000157e0000000000000000000000000000115a800000000000157e0000000000000000000000000000115ad40000000000157e0000000000000000000000000000115bb00000000000157e0000000000000000000000000000115bdc0000000000157e0000000000000000000000000000115c1c0000000000157e0000000000000000000000000000115c500000000000157e0000000000000000000000000000115ca40000000000157e0000000000000000000000000000115d800000000000157e0000000000000000000000000000115dac0000000000157e0000000000000000000000000000115dec0000000000157e0000000000000000000000000000115e200000000000157e0000000000000000000000000000115e740000000000157e0000000000000000000000000000115ff00000000000157e000000000000000000000000000011601c0000000000157e000000000000000000000000000011605c0000000000157e00000000000000000000000000001160900000000000157e00000000000000000000000000001160e40000000000157e00000000000000000000000000001161c00000000000157e00000000000000000000000000001161ec0000000000157e00000000000000000000000000001162180000000000157e00000000000000000000000000001162200000000000157e00000000000000000000000000001162600000000000157e00000000000000000000000000001162940000000000157e00000000000000000000000000001162e80000000000157e000000000000000000000000000011686c0000000000157e00000000000000000000000000001168980000000000157e00000000000000000000000000001168c40000000000157e00000000000000000000000000001168f00000000000157e00000000000000000000000000001168f80000000000157e00000000000000000000000000001169240000000000157e000000000000000000000000000011692c0000000000157e00000000000000000000000000001169580000000000157e00000000000000000000000000001169600000000000157e00000000000000000000000000001169a00000000000157e00000000000000000000000000001169d40000000000157e0000000000000000000000000000116a280000000000157e00000000000000000000000000001177740000000000157e00000000000000000000000000001177b00000000000157e00000000000000000000000000001178180000000000157e000000000000000000000000000011788c0000000000157e00000000000000000000000000001178f40000000000157e00000000000000000000000000001179680000000000157e00000000000000000000000000001179d00000000000157e0000000000000000000000000000117a440000000000157e0000000000000000000000000000117a540000000000157e0000000000000000000000000000117aa80000000000157e0000000000000000000000000000117ab80000000000157e0000000000000000000000000000117b200000000000157e0000000000000000000000000000117b940000000000157e0000000000000000000000000000117ba40000000000157e0000000000000000000000000000117bf80000000000157e0000000000000000000000000000117c080000000000157e0000000000000000000000000000117cc80000000000157e0000000000000000000000000000117d040000000000157e0000000000000000000000000000117d400000000000157e0000000000000000000000000000117da80000000000157e0000000000000000000000000000117e1c0000000000157e0000000000000000000000000000117e580000000000157e0000000000000000000000000000117f540000000000157e00000000000000000000000000001180bc0000000000157e0000000000000000000000000000116d840000000000157e00000000000000000000000000001181180000000000157e000000000000000000000000000011817c0000000000157e00000000000000000000000000001181fc0000000000157e000000000000000000000000000011827c0000000000157e00000000000000000000000000001182fc0000000000157e00000000000000000000000000001183640000000000157e00000000000000000000000000001183d00000000000157e00000000000000000000000000001184340000000000157e00000000000000000000000000001184980000000000157e00000000000000000000000000001184fc0000000000157e000000000000000000000000000011857c0000000000157e00000000000000000000000000001185e00000000000157e00000000000000000000000000001186440000000000157e00000000000000000000000000001186c40000000000157e00000000000000000000000000001187440000000000157e00000000000000000000000000001187c40000000000157e00000000000000000000000000001188300000000000157e00000000000000000000000000001188980000000000157e00000000000000000000000000001189040000000000157e00000000000000000000000000001189840000000000157e00000000000000000000000000001189e80000000000157e0000000000000000000000000000118a500000000000157e0000000000000000000000000000118abc0000000000157e0000000000000000000000000000118b280000000000157e0000000000000000000000000000118b940000000000157e0000000000000000000000000000118bf00000000000157e0000000000000000000000000000118c440000000000157e0000000000000000000000000000118dac0000000000157e0000000000000000000000000000118db40000000000157e0000000000000000000000000000118dbc0000000000157e0000000000000000000000000000118dcc0000000000157e0000000000000000000000000000118ddc0000000000157e0000000000000000000000000000118e300000000000157e0000000000000000000000000000118e380000000000157e0000000000000000000000000000118e400000000000157e0000000000000000000000000000118e500000000000157e0000000000000000000000000000118e600000000000157e0000000000000000000000000000118f200000000000157e0000000000000000000000000000118f280000000000157e0000000000000000000000000000118f380000000000157e0000000000000000000000000000118f8c0000000000157e0000000000000000000000000000118f940000000000157e0000000000000000000000000000116f540000000000157e00000000000000000000000000001172000000000000157e0000000000000000000000000000118fa40000000000157e00000000000000000000000000001191880000000000157e00000000000000000000000000001191e00000000000157e00000000000000000000000000001192380000000000157e00000000000000000000000000001192880000000000157e00000000000000000000000000001192e80000000000157e000000000000000000000000000011933c0000000000157e00000000000000000000000000001193940000000000157e00000000000000000000000000001193ec0000000000157e00000000000000000000000000001194400000000000157e000000000000000000000000000011947c0000000000157e00000000000000000000000000001194c80000000000157e00000000000000000000000000001190a80000000000157e00000000000000000000000000001191440000000000157e00000000000000000000000000001194f80000000000157e000000000000000000000000000011954c0000000000157e00000000000000000000000000001195cc0000000000157e00000000000000000000000000001196200000000000157e00000000000000000000000000001196a00000000000157e00000000000000000000000000001196f40000000000157e00000000000000000000000000001198140000000000157e00000000000000000000000000001198680000000000157e0000000000000000000000000000119bb00000000000157e0000000000000000000000000000119bec0000000000157e0000000000000000000000000000119c280000000000157e00000000000000000000000000001199880000000000157e0000000000000000000000000000119c840000000000157e0000000000000000000000000000119ce80000000000157e0000000000000000000000000000119d4c0000000000157e0000000000000000000000000000119db00000000000157e0000000000000000000000000000119e180000000000157e0000000000000000000000000000119e800000000000157e0000000000000000000000000000119ee40000000000157e0000000000000000000000000000119f640000000000157e0000000000000000000000000000119fe40000000000157e000000000000000000000000000011a0400000000000157e0000000000000000000000000000119a800000000000157e0000000000000000000000000000119b6c0000000000157e000000000000000000000000000011a0940000000000157e000000000000000000000000000011a0c00000000000157e000000000000000000000000000011a1000000000000157e000000000000000000000000000011a1340000000000157e000000000000000000000000000011a1880000000000157e000000000000000000000000000011a2640000000000157e000000000000000000000000000011a2900000000000157e000000000000000000000000000011a2d00000000000157e000000000000000000000000000011a3040000000000157e000000000000000000000000000011a3580000000000157e000000000000000000000000000011a4340000000000157e000000000000000000000000000011a4600000000000157e000000000000000000000000000011a4a00000000000157e000000000000000000000000000011a4d40000000000157e000000000000000000000000000011a5280000000000157e000000000000000000000000000011a6a40000000000157e000000000000000000000000000011a6d00000000000157e000000000000000000000000000011a7100000000000157e000000000000000000000000000011a7440000000000157e000000000000000000000000000011a7980000000000157e000000000000000000000000000011a8040000000000157e000000000000000000000000000011a85c0000000000157e000000000000000000000000000011af080000000000157e000000000000000000000000000011af440000000000157e000000000000000000000000000011af800000000000157e000000000000000000000000000011afd40000000000157e000000000000000000000000000011b03c0000000000157e000000000000000000000000000011b0b00000000000157e000000000000000000000000000011b10c0000000000157e000000000000000000000000000011b1740000000000157e000000000000000000000000000011b1e80000000000157e000000000000000000000000000011b1f80000000000157e000000000000000000000000000011b24c0000000000157e000000000000000000000000000011b25c0000000000157e000000000000000000000000000011b2b80000000000157e000000000000000000000000000011b30c0000000000157e000000000000000000000000000011b3c00000000000157e000000000000000000000000000011ac400000000000157e000000000000000000000000000011b41c0000000000157e000000000000000000000000000011b4800000000000157e000000000000000000000000000011b4e40000000000157e000000000000000000000000000011b5480000000000157e000000000000000000000000000011b5b00000000000157e000000000000000000000000000011b6140000000000157e000000000000000000000000000011b67c0000000000157e000000000000000000000000000011b6fc0000000000157e000000000000000000000000000011b7680000000000157e000000000000000000000000000011b7c40000000000157e000000000000000000000000000011b8180000000000157e000000000000000000000000000011b8cc0000000000157e000000000000000000000000000011b8d40000000000157e000000000000000000000000000011b8e40000000000157e000000000000000000000000000011b9380000000000157e000000000000000000000000000011b9400000000000157e000000000000000000000000000011ad380000000000157e000000000000000000000000000011aec40000000000157e000000000000000000000000000011b9500000000000157e000000000000000000000000000011b9900000000000157e000000000000000000000000000011b9c40000000000157e000000000000000000000000000011ba040000000000157e000000000000000000000000000011ba580000000000157e000000000000000000000000000011bb300000000000157e000000000000000000000000000011bb840000000000157e000000000000000000000000000011bbd40000000000157e000000000000000000000000000011bc080000000000157e000000000000000000000000000011bc480000000000157e000000000000000000000000000011bc9c0000000000157e000000000000000000000000000011c8140000000000157e000000000000000000000000000011bd780000000000157e000000000000000000000000000011bdf40000000000157e000000000000000000000000000011be880000000000157e000000000000000000000000000011bebc0000000000157e000000000000000000000000000011befc0000000000157e000000000000000000000000000011bf500000000000157e000000000000000000000000000011c1980000000000157e000000000000000000000000000011c2180000000000157e000000000000000000000000000011c2940000000000157e000000000000000000000000000011c2c80000000000157e000000000000000000000000000011c3080000000000157e000000000000000000000000000011c35c0000000000157e000000000000000000000000000011c8540000000000157e000000000000000000000000000011c5cc0000000000157e000000000000000000000000000011c8b00000000000157e000000000000000000000000000011c9140000000000157e000000000000000000000000000011c9780000000000157e000000000000000000000000000011c9dc0000000000157e000000000000000000000000000011ca5c0000000000157e000000000000000000000000000011cadc0000000000157e000000000000000000000000000011cb400000000000157e000000000000000000000000000011cba80000000000157e000000000000000000000000000011cc280000000000157e000000000000000000000000000011cc840000000000157e000000000000000000000000000011c6c40000000000157e000000000000000000000000000011c7d00000000000157e000000000000000000000000000011d4100000000000157e000000000000000000000000000011d4440000000000157e000000000000000000000000000011d4980000000000157e000000000000000000000000000011d4f40000000000157e000000000000000000000000000011d53c0000000000157e000000000000000000000000000011d5880000000000157e000000000000000000000000000011ccd80000000000157e000000000000000000000000000011d5d40000000000157e000000000000000000000000000011cdcc0000000000157e000000000000000000000000000011ceac0000000000157e000000000000000000000000000011cefc0000000000157e000000000000000000000000000011cfcc0000000000157e000000000000000000000000000011d6200000000000157e000000000000000000000000000011d6540000000000157e000000000000000000000000000011d6880000000000157e000000000000000000000000000011d6f40000000000157e000000000000000000000000000011d73c0000000000157e000000000000000000000000000011d7a80000000000157e000000000000000000000000000011d83c0000000000157e000000000000000000000000000011d8940000000000157e000000000000000000000000000011d8e40000000000157e000000000000000000000000000011d99c0000000000157e000000000000000000000000000011d9d00000000000157e000000000000000000000000000011da600000000000157e000000000000000000000000000011daa80000000000157e000000000000000000000000000011dad40000000000157e000000000000000000000000000011db000000000000157e000000000000000000000000000011db980000000000157e000000000000000000000000000011dbcc0000000000157e000000000000000000000000000011dbfc0000000000157e000000000000000000000000000011dd400000000000157e000000000000000000000000000011ddcc0000000000157e000000000000000000000000000011de940000000000157e000000000000000000000000000011ded40000000000157e000000000000000000000000000011df000000000000157e000000000000000000000000000011df340000000000157e000000000000000000000000000011df680000000000157e000000000000000000000000000011dfc80000000000157e000000000000000000000000000011e1f40000000000157e000000000000000000000000000011e2280000000000157e000000000000000000000000000011e2640000000000157e000000000000000000000000000011e2940000000000157e000000000000000000000000000011e3f00000000000157e000000000000000000000000000011e46c0000000000157e000000000000000000000000000011e4a80000000000157e000000000000000000000000000011e4d80000000000157e000000000000000000000000000011e5080000000000157e000000000000000000000000000011e5480000000000157e000000000000000000000000000011e7540000000000157e000000000000000000000000000011e7880000000000157e000000000000000000000000000011e8e40000000000157e000000000000000000000000000011e95c0000000000157e000000000000000000000000000011e9c00000000000157e000000000000000000000000000011e9f40000000000157e000000000000000000000000000011ea580000000000157e000000000000000000000000000011eaa40000000000157e000000000000000000000000000011eafc0000000000157e000000000000000000000000000011eb4c0000000000157e000000000000000000000000000011ebc80000000000157e000000000000000000000000000011ec280000000000157e000000000000000000000000000011ec740000000000157e000000000000000000000000000011ece40000000000157e000000000000000000000000000011ed580000000000157e000000000000000000000000000011ed880000000000157e000000000000000000000000000011edb80000000000157e000000000000000000000000000011eea00000000000157e000000000000000000000000000011ef880000000000157e000000000000000000000000000011f0040000000000157e000000000000000000000000000011f0540000000000157e000000000000000000000000000011f0ac0000000000157e000000000000000000000000000011f11c0000000000157e000000000000000000000000000011f1980000000000157e000000000000000000000000000011f21c0000000000157e000000000000000000000000000011f24c0000000000157e000000000000000000000000000011f2a00000000000157e000000000000000000000000000011f2f00000000000157e000000000000000000000000000011f3480000000000157e000000000000000000000000000011f37c0000000000157e000000000000000000000000000011f3ac0000000000157e000000000000000000000000000011f3dc0000000000157e000000000000000000000000000011f4580000000000157e000000000000000000000000000011f4a40000000000157e000000000000000000000000000011f4d40000000000157e000000000000000000000000000011f5200000000000157e000000000000000000000000000011f5800000000000157e000000000000000000000000000011f62c0000000000157e000000000000000000000000000011f65c0000000000157e000000000000000000000000000011f6b40000000000157e000000000000000000000000000011f71c0000000000157e000000000000000000000000000011f7b00000000000157e000000000000000000000000000011f82c0000000000157e000000000000000000000000000011d2a40000000000157e000000000000000000000000000011d3cc0000000000157e000000000000000000000000000011f8600000000000157e000000000000000000000000000011f8a00000000000157e000000000000000000000000000011f8e00000000000157e000000000000000000000000000011f9a40000000000157e000000000000000000000000000011f9b40000000000157e000000000000000000000000000011fa780000000000157e000000000000000000000000000011fa880000000000157e000000000000000000000000000011fba00000000000157e000000000000000000000000000011fbb00000000000157e000000000000000000000000000011fbb80000000000157e000000000000000000000000000011fbe40000000000157e000000000000000000000000000011fc5c0000000000157e000000000000000000000000000011fc880000000000157e000000000000000000000000000011fc980000000000157e000000000000000000000000000011fd5c0000000000157e000000000000000000000000000011fd6c0000000000157e000000000000000000000000000011fe400000000000157e000000000000000000000000000011fe500000000000157e000000000000000000000000000011fe580000000000157e000000000000000000000000000011fffc0000000000157e000000000000000000000000000012000c0000000000157e00000000000000000000000000001204a40000000000157e00000000000000000000000000001204e00000000000157e000000000000000000000000000012051c0000000000157e00000000000000000000000000001205700000000000157e00000000000000000000000000001205d80000000000157e000000000000000000000000000012064c0000000000157e00000000000000000000000000001206b40000000000157e00000000000000000000000000001207280000000000157e00000000000000000000000000001207900000000000157e00000000000000000000000000001208040000000000157e00000000000000000000000000001208140000000000157e00000000000000000000000000001208680000000000157e00000000000000000000000000001208780000000000157e00000000000000000000000000001208e00000000000157e00000000000000000000000000001209540000000000157e00000000000000000000000000001209640000000000157e00000000000000000000000000001209b80000000000157e00000000000000000000000000001209c80000000000157e0000000000000000000000000000120a880000000000157e0000000000000000000000000000120ac40000000000157e0000000000000000000000000000120b000000000000157e0000000000000000000000000000120b540000000000157e0000000000000000000000000000120bb00000000000157e0000000000000000000000000000120c180000000000157e0000000000000000000000000000120c8c0000000000157e0000000000000000000000000000120ce80000000000157e0000000000000000000000000000120d3c0000000000157e0000000000000000000000000000120da40000000000157e0000000000000000000000000000120e180000000000157e0000000000000000000000000000120e280000000000157e0000000000000000000000000000120e7c0000000000157e0000000000000000000000000000120e8c0000000000157e0000000000000000000000000000120f400000000000157e000000000000000000000000000012001c0000000000157e00000000000000000000000000001201100000000000157e000000000000000000000000000012016c0000000000157e00000000000000000000000000001201c80000000000157e00000000000000000000000000001210100000000000157e00000000000000000000000000001210e00000000000157e00000000000000000000000000001210f00000000000157e00000000000000000000000000001211000000000000157e00000000000000000000000000001211540000000000157e00000000000000000000000000001211640000000000157e00000000000000000000000000001211740000000000157e00000000000000000000000000001212280000000000157e00000000000000000000000000001212300000000000157e00000000000000000000000000001212400000000000157e00000000000000000000000000001212940000000000157e000000000000000000000000000012129c0000000000157e00000000000000000000000000001212ac0000000000157e000000000000000000000000000012136c0000000000157e00000000000000000000000000001213740000000000157e00000000000000000000000000001213840000000000157e00000000000000000000000000001213d80000000000157e00000000000000000000000000001213e00000000000157e00000000000000000000000000001202180000000000157e00000000000000000000000000001204600000000000157e00000000000000000000000000001213f00000000000157e00000000000000000000000000001214c00000000000157e00000000000000000000000000001214e00000000000157e000000000000000000";

		public Ppc64TypeInfoProgramBuilder() throws Exception {
			super("PowerPC:BE:64:default", "default");
		}

		@Override
		protected Map<Long, String> getTypeInfoMap() {
			return typeMap;
		}

		@Override
		protected Map<Long, String> getTypeNameMap() {
			return nameMap;
		}

		@Override
		protected Map<Long, String> getVtableMap() {
			return vtableMap;
		}

		@Override
		protected Map<Long, String> getVttMap() {
			return vttMap;
		}

		@Override
		protected Map<Long, String> getRelocationMap() {
			return relocationMap;
		}

		@Override
		protected Long[] getFunctionOffsets() {
			return functionOffsets;
		}

		@Override
		protected String getReturnInstruction() {
			return returnString;
		}

		@Override
		protected String getFunctionDescriptors() {
			return fDescriptors;
		}

		@Override
		protected void setupMemory() {
			createMemory(".text", "0010f1c0", 75140);
			createMemory(".data.rel.ro", "001491e8", 11192);
			createMemory(".opd", "0014bf90", 15984);
		}
	}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/builder/X86TypeInfoProgramBuilder.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.builder;

import java.util.Map;

public class X86TypeInfoProgramBuilder extends AbstractTypeInfoProgramBuilder {
	private static final Map<Long, String> typeMap = Map.ofEntries(
		getEntry(0x0011e2e0L, "b001120000000000e0301100000000000000000002000000f0eb1100000000000200000000000000a0e31100000000000200000000000000"),
		getEntry(0x0011e318L, "b0011200000000001031110000000000010000000200000068e3110000000000020000000000000050e31100000000000210000000000000"),
		getEntry(0x0011e350L, "5801120000000000303111000000000090e3110000000000"),
		getEntry(0x0011e368L, "b0011200000000005031110000000000000000000100000090e311000000000003e8ffffffffffff"),
		getEntry(0x0011e390L, "98001200000000007031110000000000"),
		getEntry(0x0011e3a0L, "98001200000000009031110000000000"),
		getEntry(0x0011e3b0L, "b00112000000000050321100000000000000000002000000f0eb1100000000000200000000000000a0e31100000000000200000000000000"),
		getEntry(0x0011e3e8L, "b0011200000000006832110000000000020000000200000048e4110000000000020000000000000020e41100000000000210000000000000"),
		getEntry(0x0011e420L, "b0011200000000007832110000000000000000000100000070e411000000000003e8ffffffffffff"),
		getEntry(0x0011e448L, "b0011200000000008832110000000000000000000100000070e411000000000003e8ffffffffffff"),
		getEntry(0x0011e470L, "98001200000000009832110000000000"),
		getEntry(0x0011e498L, "5801120000000000d032110000000000f0eb110000000000"),
		getEntry(0x0011e4b0L, "7801120000000000ec32110000000000"),
		getEntry(0x0011e4c0L, "50011200000000000033110000000000000000000000000008e511000000000068e3110000000000"),
		getEntry(0x0011e4e8L, "98011200000000003033110000000000"),
		getEntry(0x0011e4f8L, "30001200000000004d33110000000000"),
		getEntry(0x0011e508L, "78011200000000005133110000000000"),
		getEntry(0x0011e578L, "b0011200000000004035110000000000000000000400000060e7110000000000020000000000000030e7110000000000020000000000000040e7110000000000020000000000000050e71100000000000200000000000000"),
		getEntry(0x0011e5d0L, "58011200000000001035110000000000f0eb110000000000"),
		getEntry(0x0011e5e8L, "b0011200000000008035110000000000000000000400000060e711000000000003e8ffffffffffff30e711000000000003e0ffffffffffff40e711000000000003d8ffffffffffff50e711000000000003d0ffffffffffff"),
		getEntry(0x0011e640L, "b001120000000000c035110000000000000000000400000020e711000000000003e0ffffffffffff10e711000000000003d8ffffffffffff00e711000000000003d0fffffffffffff0e611000000000003c8ffffffffffff"),
		getEntry(0x0011e698L, "b0011200000000000036110000000000000000000400000020e7110000000000020000000000000010e7110000000000020800000000000000e71100000000000210000000000000f0e61100000000000218000000000000"),
		getEntry(0x0011e6f0L, "98001200000000004036110000000000"),
		getEntry(0x0011e700L, "98001200000000008036110000000000"),
		getEntry(0x0011e710L, "9800120000000000c036110000000000"),
		getEntry(0x0011e720L, "98001200000000000037110000000000"),
		getEntry(0x0011e730L, "98001200000000004037110000000000"),
		getEntry(0x0011e740L, "98001200000000008037110000000000"),
		getEntry(0x0011e750L, "9800120000000000c037110000000000"),
		getEntry(0x0011e760L, "98001200000000000038110000000000"),
		getEntry(0x0011e770L, "b001120000000000f0391100000000000000000002000000f0eb1100000000000200000000000000a0e31100000000000200000000000000"),
		getEntry(0x0011e7a8L, "b001120000000000103a1100000000000000000004000000c0e8110000000000020000000000000088e8110000000000021000000000000078e8110000000000022000000000000058e91100000000000230000000000000"),
		getEntry(0x0011e800L, "b001120000000000303a110000000000020000000600000030e911000000000003e0ffffffffffff58e911000000000003d8ffffffffffff88e8110000000000020000000000000008e911000000000003d0ffffffffffffc0e8110000000000021000000000000078e81100000000000220000000000000"),
		getEntry(0x0011e878L, "9800120000000000503a110000000000"),
		getEntry(0x0011e888L, "b001120000000000703a1100000000000000000001000000b0e811000000000003e8ffffffffffff"),
		getEntry(0x0011e8b0L, "9800120000000000903a110000000000"),
		getEntry(0x0011e8c0L, "9800120000000000b03a110000000000"),
		getEntry(0x0011e8d0L, "b001120000000000d03a110000000000020000000200000030e9110000000000020000000000000008e91100000000000210000000000000"),
		getEntry(0x0011e908L, "b001120000000000f03a110000000000000000000100000058e911000000000003e8ffffffffffff"),
		getEntry(0x0011e930L, "b001120000000000103b110000000000000000000100000058e911000000000003e8ffffffffffff"),
		getEntry(0x0011e958L, "9800120000000000303b110000000000"),
		getEntry(0x0011e968L, "b001120000000000903b1100000000000000000002000000f0eb1100000000000200000000000000a0e31100000000000200000000000000"),
		getEntry(0x0011e9a0L, "b001120000000000b03b110000000000000000000100000010ea11000000000001e8ffffffffffff"),
		getEntry(0x0011e9c8L, "b001120000000000d03b110000000000000000000200000048ea11000000000003e8ffffffffffff00ea11000000000003e0ffffffffffff"),
		getEntry(0x0011ea00L, "9800120000000000f03b110000000000"),
		getEntry(0x0011ea10L, "b001120000000000103c110000000000000000000200000048ea110000000000020000000000000000ea1100000000000200000000000000"),
		getEntry(0x0011ea48L, "9800120000000000303c110000000000"),
		getEntry(0x0011ea58L, "b001120000000000403d1100000000000000000002000000f0eb1100000000000200000000000000a0e31100000000000200000000000000"),
		getEntry(0x0011ea90L, "b001120000000000603d1100000000000100000002000000e0ea1100000000000200000000000000c8ea1100000000000210000000000000"),
		getEntry(0x0011eac8L, "5801120000000000803d11000000000008eb110000000000"),
		getEntry(0x0011eae0L, "b001120000000000a03d110000000000000000000100000008eb11000000000003e8ffffffffffff"),
		getEntry(0x0011eb08L, "9800120000000000c03d110000000000"),
		getEntry(0x0011eb18L, "b001120000000000a03e1100000000000000000002000000f0eb1100000000000200000000000000a0e31100000000000200000000000000"),
		getEntry(0x0011eb50L, "5801120000000000d03e11000000000090eb110000000000"),
		getEntry(0x0011eb68L, "b001120000000000f03e110000000000000000000100000090eb11000000000003e8ffffffffffff"),
		getEntry(0x0011eb90L, "b001120000000000103f1100000000000000000001000000b8eb11000000000003e8ffffffffffff"),
		getEntry(0x0011ebb8L, "9800120000000000303f110000000000"),
		getEntry(0x0011ebf0L, "9800120000000000d83f110000000000"),
		getEntry(0x0011ec30L, "58011200000000004040110000000000f0eb110000000000"),
		getEntry(0x0011ec48L, "b00112000000000060401100000000000100000002000000e0ec11000000000003e8ffffffffffffb8ec11000000000003e0ffffffffffff"),
		getEntry(0x0011ec80L, "b00112000000000080401100000000000100000002000000e0ec1100000000000200000000000000b8ec1100000000000210000000000000"),
		getEntry(0x0011ecb8L, "b001120000000000a040110000000000000000000100000090ed11000000000003e8ffffffffffff"),
		getEntry(0x0011ece0L, "5801120000000000c04011000000000090ed110000000000"),
		getEntry(0x0011ecf8L, "b001120000000000e040110000000000020000000200000058ed110000000000020000000000000030ed1100000000000210000000000000"),
		getEntry(0x0011ed30L, "b0011200000000000041110000000000000000000100000080ed11000000000003e8ffffffffffff"),
		getEntry(0x0011ed58L, "b0011200000000002041110000000000000000000100000080ed11000000000003e8ffffffffffff"),
		getEntry(0x0011ed80L, "98001200000000004041110000000000"),
		getEntry(0x0011ed90L, "98001200000000006041110000000000")
	);

	private static final Map<Long, String> nameMap = Map.ofEntries(
		getEntry(0x001130e0L, "N20abstract_inheritance7PrinterE"),
		getEntry(0x00113110L, "N20abstract_inheritance1IE"),
		getEntry(0x00113130L, "N20abstract_inheritance1HE"),
		getEntry(0x00113150L, "N20abstract_inheritance1GE"),
		getEntry(0x00113170L, "N20abstract_inheritance1FE"),
		getEntry(0x00113190L, "12Serializable"),
		getEntry(0x00113250L, "N7diamond7PrinterE"),
		getEntry(0x00113268L, "N7diamond1DE"),
		getEntry(0x00113278L, "N7diamond1CE"),
		getEntry(0x00113288L, "N7diamond1BE"),
		getEntry(0x00113298L, "N7diamond1AE"),
		getEntry(0x001132d0L, "N17fundamental_types4._83E"),
		getEntry(0x001132ecL, "FvvE"),
		getEntry(0x00113300L, "MN20abstract_inheritance1GEKFmvE"),
		getEntry(0x00113330L, "N17fundamental_types6NumberE"),
		getEntry(0x0011334dL, "A_i"),
		getEntry(0x00113351L, "FmvE"),
		getEntry(0x00113540L, "N10interfaces21non_virtual_functions1EE"),
		getEntry(0x00113510L, "N10interfaces4._83E"),
		getEntry(0x00113580L, "N10interfaces21non_virtual_functions1FE"),
		getEntry(0x001135c0L, "N10interfaces17virtual_functions1FE"),
		getEntry(0x00113600L, "N10interfaces17virtual_functions1EE"),
		getEntry(0x00113640L, "N10interfaces17virtual_functions1DE"),
		getEntry(0x00113680L, "N10interfaces17virtual_functions1CE"),
		getEntry(0x001136c0L, "N10interfaces17virtual_functions1BE"),
		getEntry(0x00113700L, "N10interfaces17virtual_functions1AE"),
		getEntry(0x00113740L, "N10interfaces21non_virtual_functions1BE"),
		getEntry(0x00113780L, "N10interfaces21non_virtual_functions1CE"),
		getEntry(0x001137c0L, "N10interfaces21non_virtual_functions1DE"),
		getEntry(0x00113800L, "N10interfaces21non_virtual_functions1AE"),
		getEntry(0x001139f0L, "N17large_inheritance7PrinterE"),
		getEntry(0x00113a10L, "N17large_inheritance1VE"),
		getEntry(0x00113a30L, "N17large_inheritance1WE"),
		getEntry(0x00113a50L, "N17large_inheritance1XE"),
		getEntry(0x00113a70L, "N17large_inheritance1YE"),
		getEntry(0x00113a90L, "N17large_inheritance1UE"),
		getEntry(0x00113ab0L, "N17large_inheritance1ZE"),
		getEntry(0x00113ad0L, "N17large_inheritance1DE"),
		getEntry(0x00113af0L, "N17large_inheritance1CE"),
		getEntry(0x00113b10L, "N17large_inheritance1BE"),
		getEntry(0x00113b30L, "N17large_inheritance1AE"),
		getEntry(0x00113b90L, "N10no_members7PrinterE"),
		getEntry(0x00113bb0L, "N10no_members1EE"),
		getEntry(0x00113bd0L, "N10no_members1DE"),
		getEntry(0x00113bf0L, "N10no_members1BE"),
		getEntry(0x00113c10L, "N10no_members1CE"),
		getEntry(0x00113c30L, "N10no_members1AE"),
		getEntry(0x00113d40L, "N11non_diamond7PrinterE"),
		getEntry(0x00113d60L, "N11non_diamond1DE"),
		getEntry(0x00113d80L, "N11non_diamond1CE"),
		getEntry(0x00113da0L, "N11non_diamond1BE"),
		getEntry(0x00113dc0L, "N11non_diamond1AE"),
		getEntry(0x00113ea0L, "N20no_virtual_functions7PrinterE"),
		getEntry(0x00113ed0L, "N20no_virtual_functions1DE"),
		getEntry(0x00113ef0L, "N20no_virtual_functions1CE"),
		getEntry(0x00113f10L, "N20no_virtual_functions1BE"),
		getEntry(0x00113f30L, "N20no_virtual_functions1AE"),
		getEntry(0x00113fd8L, "9Printable"),
		getEntry(0x00114040L, "N21virtual_member_access4._83E"),
		getEntry(0x00114060L, "N21virtual_member_access1HE"),
		getEntry(0x00114080L, "N21virtual_member_access1GE"),
		getEntry(0x001140a0L, "N21virtual_member_access1FE"),
		getEntry(0x001140c0L, "N21virtual_member_access1EE"),
		getEntry(0x001140e0L, "N21virtual_member_access1DE"),
		getEntry(0x00114100L, "N21virtual_member_access1CE"),
		getEntry(0x00114120L, "N21virtual_member_access1BE"),
		getEntry(0x00114140L, "N21virtual_member_access1AE"),
		getEntry(0x00114160L, "N21virtual_member_access9AbstractAE")
	);

	private static final Map<Long, String> vtableMap = Map.ofEntries(
		getEntry(0x0011c1a0L, "0000000000000000e0e2110000000000a499100000000000ce99100000000000d68f100000000000"),
		getEntry(0x0011c1c8L, "2800000000000000000000000000000018e3110000000000fa99100000000000809a100000000000f086100000000000388d100000000000c28c100000000000a48c100000000000988c100000000000f0ffffffffffffff18e31100000000006e9a100000000000ab9a1000000000006c84100000000000328d1000000000007884100000000000bc8c1000000000001e8e1000000000008689100000000000d8ffffffffffffffd8ffffffffffffff0000000000000000d8ffffffffffffff0000000000000000d8ffffffffffffffd8ffffffffffffff18e3110000000000749a100000000000b19a1000000000006c84100000000000298d1000000000007884100000000000b38c100000000000128e100000000000"),
		getEntry(0x0011c3c0L, "000000000000000050e3110000000000fe9210000000000028931000000000006c84100000000000028a10000000000078841000000000006a8a10000000000092891000000000008689100000000000"),
		getEntry(0x0011c410L, "1000000000000000000000000000000068e31100000000008292100000000000ca92100000000000f086100000000000fc861000000000008c87100000000000fc87100000000000f0fffffffffffffff0ffffffffffffff0000000000000000f0ffffffffffffff0000000000000000f0fffffffffffffff0ffffffffffffff68e3110000000000c192100000000000f5921000000000006c84100000000000f38710000000000078841000000000000b881000000000007f87100000000000"),
		getEntry(0x0011e298L, "000000000000000090e3110000000000000000000000000000000000000000006c84100000000000e0011200000000007884100000000000e0011200000000008a84100000000000"),
		getEntry(0x0011c4e0L, "0000000000000000b0e311000000000072a81000000000009ca810000000000016a1100000000000"),
		getEntry(0x0011c508L, "20000000000000000000000000000000e8e3110000000000c8a81000000000005ca9100000000000a49b100000000000b09b100000000000c89b1000000000009c9e100000000000a89e100000000000c09e1000000000001000000000000000f0ffffffffffffffe8e311000000000046a910000000000087a9100000000000209d1000000000002c9d100000000000449d100000000000000000000000000000000000000000000000000000000000e0ffffffffffffffe0ffffffffffffffe8e31100000000004fa91000000000008da9100000000000ba9a100000000000c69a100000000000de9a100000000000"),
		getEntry(0x0011c760L, "1000000000000000000000000000000020e41100000000004aa510000000000092a5100000000000209d1000000000002c9d100000000000449d100000000000000000000000000000000000000000000000000000000000f0fffffffffffffff0ffffffffffffff20e411000000000089a5100000000000bda5100000000000ba9a100000000000c69a100000000000de9a100000000000"),
		getEntry(0x0011c808L, "1000000000000000000000000000000048e41100000000008ea4100000000000d6a4100000000000a49b100000000000b09b100000000000c89b100000000000000000000000000000000000000000000000000000000000f0fffffffffffffff0ffffffffffffff48e4110000000000cda410000000000001a5100000000000ba9a100000000000c69a100000000000de9a100000000000"),
		getEntry(0x0011c8b0L, "000000000000000070e411000000000008a310000000000022a3100000000000ba9a100000000000c69a100000000000de9a100000000000"),
		getEntry(0x0011c908L, "000000000000000098e411000000000036ab10000000000060ab100000000000d2aa100000000000"),
		getEntry(0x0011c930L, "0000000000000000d0e5110000000000e2b11000000000000cb210000000000056ae100000000000"),
		getEntry(0x0011cab0L, "00000000000000000000000000000000000000000000000000000000000000000000000000000000e8e5110000000000"),
		getEntry(0x0011c958L, "18000000000000001000000000000000080000000000000000000000000000000000000000000000000000000000000040e6110000000000daac10000000000006ad10000000000032ad1000000000005ead100000000000f8fffffffffffffff8ffffffffffffff40e611000000000028ad100000000000f0fffffffffffffff0ffffffffffffff40e611000000000054ad100000000000e8ffffffffffffffe8ffffffffffffff40e611000000000080ad100000000000"),
		getEntry(0x0011ca38L, "000000000000000098e611000000000040ac10000000000062ac1000000000008aac100000000000b2ac100000000000f8ffffffffffffff98e611000000000084ac100000000000f0ffffffffffffff98e6110000000000acac100000000000e8ffffffffffffff98e6110000000000d4ac100000000000"),
		getEntry(0x0011e518L, "0000000000000000f0e6110000000000e001120000000000"),
		getEntry(0x0011e530L, "000000000000000000e7110000000000e001120000000000"),
		getEntry(0x0011e548L, "000000000000000010e7110000000000e001120000000000"),
		getEntry(0x0011e560L, "000000000000000020e7110000000000e001120000000000"),
		getEntry(0x0011cae8L, "000000000000000070e71100000000003ad810000000000064d810000000000086c6100000000000"),
		getEntry(0x0011cb10L, "48000000000000000000000000000000a8e7110000000000d6cb100000000000b0cc1000000000006ac310000000000094ba100000000000acba1000000000005ec310000000000076c310000000000088c31000000000009ac3100000000000acc3100000000000c4c31000000000003800000000000000f0ffffffffffffffa8e7110000000000a6cc100000000000f0cc10000000000081c310000000000068bc10000000000080bc100000000000e0ffffffffffffffa8e71100000000009dcc100000000000eacc10000000000093c3100000000000d0bd100000000000e8bd100000000000d0ffffffffffffffa8e711000000000094cc100000000000e4cc100000000000a5c3100000000000e8b310000000000000b4100000000000000000000000000000000000000000000000000000000000b8ffffffffffffffb8ffffffffffffffa8e711000000000088cc100000000000dbcc10000000000072bb1000000000007ebb10000000000096bb100000000000"),
		getEntry(0x0011cd48L, "6000000000000000400000000000000030000000000000005000000000000000000000000000000000e811000000000090d8100000000000c8d91000000000005cbc10000000000068bc10000000000080bc100000000000aebe100000000000babe100000000000ccbe100000000000e4be100000000000f0ffffffffffffff00e81100000000009dd9100000000000f3d9100000000000c5be10000000000094ba100000000000acba100000000000e0ffffffffffffff00e8110000000000a6d9100000000000f9d9100000000000c4bd100000000000d0bd100000000000e8bd100000000000000000000000000000000000000000000000000000000000d0ffffffffffffff1000000000000000d0ffffffffffffff00e8110000000000afd9100000000000ffd9100000000000c6b4100000000000d2b4100000000000eab4100000000000000000000000000000000000000000000000000000000000c0ffffffffffffffc0ffffffffffffff00e8110000000000bbd910000000000008da100000000000dcb3100000000000e8b310000000000000b4100000000000000000000000000000000000000000000000000000000000b0ffffffffffffffb0ffffffffffffff00e8110000000000bbd910000000000008da10000000000072bb1000000000007ebb10000000000096bb100000000000000000000000000000000000000000000000000000000000a0ffffffffffffffe0ffffffffffffffa0ffffffffffffff00e8110000000000afd9100000000000ffd910000000000046b610000000000052b61000000000006ab6100000000000"),
		getEntry(0x0011d1c0L, "000000000000000078e81100000000004acb10000000000064cb100000000000c4bd100000000000d0bd100000000000e8bd100000000000"),
		getEntry(0x0011d1f8L, "1000000000000000000000000000000088e8110000000000ceca10000000000016cb1000000000005cbc10000000000068bc10000000000080bc100000000000000000000000000000000000000000000000000000000000f0fffffffffffffff0ffffffffffffff88e81100000000000dcb10000000000041cb10000000000072bb1000000000007ebb10000000000096bb100000000000"),
		getEntry(0x0011d2a0L, "0000000000000000b0e811000000000002ca1000000000001cca10000000000072bb1000000000007ebb10000000000096bb100000000000"),
		getEntry(0x0011d2d8L, "0000000000000000c0e811000000000048ca10000000000062ca10000000000088ba10000000000094ba100000000000acba100000000000"),
		getEntry(0x0011d310L, "20000000000000000000000000000000d0e811000000000012da100000000000a6da100000000000c6b4100000000000d2b4100000000000eab4100000000000c6b7100000000000d2b7100000000000eab71000000000001000000000000000f0ffffffffffffffd0e811000000000090da100000000000d1da10000000000046b610000000000052b61000000000006ab6100000000000000000000000000000000000000000000000000000000000e0ffffffffffffffe0ffffffffffffffd0e811000000000099da100000000000d7da100000000000dcb3100000000000e8b310000000000000b4100000000000"),
		getEntry(0x0011d568L, "1000000000000000000000000000000008e91100000000000ccf10000000000054cf10000000000046b610000000000052b61000000000006ab6100000000000000000000000000000000000000000000000000000000000f0fffffffffffffff0ffffffffffffff08e91100000000004bcf1000000000007fcf100000000000dcb3100000000000e8b310000000000000b4100000000000"),
		getEntry(0x0011d610L, "1000000000000000000000000000000030e911000000000050ce10000000000098ce100000000000c6b4100000000000d2b4100000000000eab4100000000000000000000000000000000000000000000000000000000000f0fffffffffffffff0ffffffffffffff30e91100000000008fce100000000000c3ce100000000000dcb3100000000000e8b310000000000000b4100000000000"),
		getEntry(0x0011d6b8L, "000000000000000058e911000000000090cb100000000000aacb100000000000dcb3100000000000e8b310000000000000b4100000000000"),
		getEntry(0x0011d6f0L, "000000000000000068e911000000000016e310000000000040e3100000000000b0df100000000000"),
		getEntry(0x0011d718L, "00000000000000000000000000000000a0e9110000000000"),
		getEntry(0x0011d738L, "000000000000000000000000000000000000000000000000c8e9110000000000"),
		getEntry(0x0011d760L, "000000000000000058ea11000000000082f0100000000000acf010000000000048ea100000000000"),
		getEntry(0x0011d788L, "2800000000000000000000000000000090ea110000000000d8f01000000000005ef110000000000056e410000000000062e41000000000007ae4100000000000a8e6100000000000b4e6100000000000cce6100000000000f0ffffffffffffff90ea1100000000004cf110000000000089f11000000000006ce310000000000078e310000000000090e310000000000040e51000000000004ce510000000000064e5100000000000000000000000000000000000000000000000000000000000d8ffffffffffffffd8ffffffffffffff90ea11000000000052f11000000000008ff11000000000006ce310000000000078e310000000000090e3100000000000"),
		getEntry(0x0011d940L, "0000000000000000c8ea110000000000e6ed10000000000010ee1000000000006ce310000000000078e310000000000090e310000000000040e51000000000004ce510000000000064e5100000000000"),
		getEntry(0x0011d990L, "10000000000000000000000000000000e0ea1100000000006aed100000000000b2ed10000000000056e410000000000062e41000000000007ae4100000000000000000000000000000000000000000000000000000000000f0fffffffffffffff0ffffffffffffffe0ea110000000000a9ed100000000000dded1000000000006ce310000000000078e310000000000090e3100000000000"),
		getEntry(0x0011da38L, "000000000000000008eb1100000000003aec10000000000054ec1000000000006ce310000000000078e310000000000090e3100000000000"),
		getEntry(0x0011da70L, "000000000000000018eb11000000000096fc100000000000c0fc100000000000fef8100000000000"),
		getEntry(0x0011da98L, "1000000000000000000000000000000050eb110000000000"),
		getEntry(0x0011dad8L, "1c000000000000001000000000000000000000000000000068eb1100000000000c00000000000000f0ffffffffffffff68eb110000000000"),
		getEntry(0x0011db40L, "0c00000000000000000000000000000090eb110000000000"),
		getEntry(0x0011ebc8L, "0000000000000000f0eb11000000000000000000000000000000000000000000e001120000000000"),
		getEntry(0x0011db60L, "000000000000000030ec110000000000341b1100000000005e1b1100000000004c1a110000000000"),
		getEntry(0x0011db88L, "300000000000000020000000000000001000000000000000000000000000000048ec110000000000ba231100000000006024110000000000f418110000000000f0ffffffffffffff0000000000000000f0fffffffffffffff0ffffffffffffff48ec11000000000047241100000000008b2411000000000066171100000000003f1a110000000000e0ffffffffffffff0000000000000000e0ffffffffffffff1000000000000000e0ffffffffffffff48ec11000000000053241100000000009424110000000000b017110000000000331a110000000000d0fffffffffffffff0ffffffffffffffd0ffffffffffffffd0ffffffffffffff48ec11000000000047241100000000008b24110000000000bb171100000000003f1a110000000000"),
		getEntry(0x0011dd58L, "2000000000000000000000000000000080ec1100000000009e241100000000002425110000000000661711000000000052181100000000001000000000000000f0ffffffffffffff80ec11000000000012251100000000004f25110000000000b017110000000000ea18110000000000e0fffffffffffffff0ffffffffffffffe0ffffffffffffffe0ffffffffffffff80ec11000000000018251100000000005525110000000000bb17110000000000de18110000000000"),
		getEntry(0x0011deb8L, "10000000000000000000000000000000b8ec1100000000003c221100000000008422110000000000b017110000000000c417110000000000f0fffffffffffffff0fffffffffffffff0fffffffffffffff0ffffffffffffffb8ec1100000000007b22110000000000af22110000000000bb171100000000004518110000000000"),
		getEntry(0x0011df48L, "0000000000000000e0ec110000000000a621110000000000d02111000000000066171100000000007217110000000000"),
		getEntry(0x0011df78L, "20000000000000000000000000000000f8ec1100000000005e25110000000000f22511000000000090161100000000001000000000000000f0fffffffffffffff8ec110000000000dc251100000000001d261100000000005d17110000000000e0ffffffffffffffe0ffffffffffffffe0fffffffffffffff8ec110000000000e52511000000000023261100000000005117110000000000"),
		getEntry(0x0011e118L, "1000000000000000000000000000000030ed110000000000a21f110000000000ea1f1100000000000216110000000000f0fffffffffffffff0fffffffffffffff0ffffffffffffff30ed110000000000e11f11000000000015201100000000008316110000000000"),
		getEntry(0x0011e190L, "1000000000000000000000000000000058ed110000000000e61e1100000000002e1f1100000000007415110000000000f0fffffffffffffff0fffffffffffffff0ffffffffffffff58ed110000000000251f110000000000591f110000000000f515110000000000"),
		getEntry(0x0011e208L, "000000000000000080ed110000000000601d1100000000007a1d1100000000005815110000000000"),
		getEntry(0x0011ec00L, "000000000000000090ed11000000000000000000000000000000000000000000e0011200000000003c15110000000000")
	);

	private static final Map<Long, String> vttMap = Map.ofEntries(
		getEntry(0x0011c2e0L, "e0c111000000000018c311000000000088c3110000000000a8c2110000000000"),
		getEntry(0x0011c4d0L, "28c411000000000098c4110000000000"),
		getEntry(0x0011c5f8L, "20c511000000000048c6110000000000a0c6110000000000e0c611000000000038c7110000000000d0c511000000000078c5110000000000"),
		getEntry(0x0011c7f8L, "78c7110000000000d0c7110000000000"),
		getEntry(0x0011c8a0L, "20c811000000000078c8110000000000"),
		getEntry(0x0011ca10L, "90c911000000000090c9110000000000c8c9110000000000e8c911000000000008ca110000000000"),
		getEntry(0x0011cae0L, "e0ca110000000000"),
		getEntry(0x0011cc88L, "28cb110000000000c8cc11000000000020cd11000000000098cb11000000000060cc110000000000"),
		getEntry(0x0011cfa0L, "78cd11000000000010d011000000000068d011000000000068ce110000000000c0ce11000000000018cf11000000000078cf110000000000a8d011000000000000d111000000000040d111000000000098d1110000000000"),
		getEntry(0x0011d290L, "10d211000000000068d2110000000000"),
		getEntry(0x0011d400L, "28d311000000000050d4110000000000a8d4110000000000e8d411000000000040d5110000000000d8d311000000000080d3110000000000"),
		getEntry(0x0011d600L, "80d5110000000000d8d5110000000000"),
		getEntry(0x0011d6a8L, "28d611000000000080d6110000000000"),
		getEntry(0x0011d730L, "30d7110000000000"),
		getEntry(0x0011d758L, "58d7110000000000"),
		getEntry(0x0011d888L, "a0d7110000000000c0d811000000000018d911000000000060d8110000000000"),
		getEntry(0x0011da28L, "a8d911000000000000da110000000000"),
		getEntry(0x0011dab0L, "b0da110000000000d8da110000000000"),
		getEntry(0x0011db10L, "f8da11000000000010db11000000000040db110000000000"),
		getEntry(0x0011db58L, "58db110000000000"),
		getEntry(0x0011dca8L, "b0db110000000000f0db11000000000040dc11000000000088dc110000000000f0dc11000000000038dd110000000000"),
		getEntry(0x0011de10L, "70dd11000000000050de11000000000098de110000000000a8dd110000000000f0dd110000000000"),
		getEntry(0x0011df38L, "d0de11000000000018df110000000000"),
		getEntry(0x0011e010L, "90df11000000000060e011000000000098e0110000000000c8e011000000000000e1110000000000f8df110000000000c0df110000000000"),
		getEntry(0x0011e180L, "30e111000000000068e1110000000000"),
		getEntry(0x0011e1f8L, "a8e1110000000000e0e1110000000000")
	);

	private static final Map<Long, String> relocationMap = Map.ofEntries(
		getEntry(0x0011e2c0L, "__cxa_pure_virtual"),
		getEntry(0x0011e2d0L, "__cxa_pure_virtual"),
		getEntry(0x0011e2e0L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e318L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e350L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0011e368L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e390L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e3a0L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e3b0L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e3e8L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e420L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e448L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e470L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e498L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0011e4b0L, "_ZTVN10__cxxabiv120__function_type_infoE"),
		getEntry(0x0011e4c0L, "_ZTVN10__cxxabiv129__pointer_to_member_type_infoE"),
		getEntry(0x0011e4e8L, "_ZTVN10__cxxabiv116__enum_type_infoE"),
		getEntry(0x0011e4f8L, "_ZTVN10__cxxabiv117__array_type_infoE"),
		getEntry(0x0011e508L, "_ZTVN10__cxxabiv120__function_type_infoE"),
		getEntry(0x0011e528L, "__cxa_pure_virtual"),
		getEntry(0x0011e540L, "__cxa_pure_virtual"),
		getEntry(0x0011e558L, "__cxa_pure_virtual"),
		getEntry(0x0011e570L, "__cxa_pure_virtual"),
		getEntry(0x0011e578L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e5d0L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0011e5e8L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e640L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e698L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e6f0L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e700L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e710L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e720L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e730L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e740L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e750L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e760L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e770L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e7a8L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e800L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e878L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e888L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e8b0L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e8c0L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e8d0L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e908L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e930L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e958L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011e968L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e9a0L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011e9c8L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011ea00L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011ea10L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011ea48L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011ea58L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011ea90L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011eac8L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0011eae0L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011eb08L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011eb18L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011eb50L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0011eb68L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011eb90L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011ebb8L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011ebe8L, "__cxa_pure_virtual"),
		getEntry(0x0011ebf0L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011ec20L, "__cxa_pure_virtual"),
		getEntry(0x0011ec30L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0011ec48L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011ec80L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011ecb8L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011ece0L, "_ZTVN10__cxxabiv120__si_class_type_infoE"),
		getEntry(0x0011ecf8L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011ed30L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011ed58L, "_ZTVN10__cxxabiv121__vmi_class_type_infoE"),
		getEntry(0x0011ed80L, "_ZTVN10__cxxabiv117__class_type_infoE"),
		getEntry(0x0011ed90L, "_ZTVN10__cxxabiv117__class_type_infoE")
	);

	private static final Long[] functionOffsets = new Long[]{
		0x001099a4L,
		0x001099ceL,
		0x00108fd6L,
		0x001099faL,
		0x00109a80L,
		0x001086f0L,
		0x00108d38L,
		0x00108cc2L,
		0x00108ca4L,
		0x00108c98L,
		0x00109a6eL,
		0x00109aabL,
		0x0010846cL,
		0x00108d32L,
		0x00108478L,
		0x00108cbcL,
		0x00108e1eL,
		0x00108986L,
		0x00109a74L,
		0x00109ab1L,
		0x00108d29L,
		0x00108cb3L,
		0x00108e12L,
		0x001092feL,
		0x00109328L,
		0x00108a02L,
		0x00108a6aL,
		0x00108992L,
		0x00109282L,
		0x001092caL,
		0x001086fcL,
		0x0010878cL,
		0x001087fcL,
		0x001092c1L,
		0x001092f5L,
		0x001087f3L,
		0x0010880bL,
		0x0010877fL,
		0x001201e0L,
		0x0010848aL,
		0x0010a872L,
		0x0010a89cL,
		0x0010a116L,
		0x0010a8c8L,
		0x0010a95cL,
		0x00109ba4L,
		0x00109bb0L,
		0x00109bc8L,
		0x00109e9cL,
		0x00109ea8L,
		0x00109ec0L,
		0x0010a946L,
		0x0010a987L,
		0x00109d20L,
		0x00109d2cL,
		0x00109d44L,
		0x0010a94fL,
		0x0010a98dL,
		0x00109abaL,
		0x00109ac6L,
		0x00109adeL,
		0x0010a54aL,
		0x0010a592L,
		0x0010a589L,
		0x0010a5bdL,
		0x0010a48eL,
		0x0010a4d6L,
		0x0010a4cdL,
		0x0010a501L,
		0x0010a308L,
		0x0010a322L,
		0x0010ab36L,
		0x0010ab60L,
		0x0010aad2L,
		0x0010b1e2L,
		0x0010b20cL,
		0x0010ae56L,
		0x0010acdaL,
		0x0010ad06L,
		0x0010ad32L,
		0x0010ad5eL,
		0x0010ad28L,
		0x0010ad54L,
		0x0010ad80L,
		0x0010ac40L,
		0x0010ac62L,
		0x0010ac8aL,
		0x0010acb2L,
		0x0010ac84L,
		0x0010acacL,
		0x0010acd4L,
		0x0010d83aL,
		0x0010d864L,
		0x0010c686L,
		0x0010cbd6L,
		0x0010ccb0L,
		0x0010c36aL,
		0x0010ba94L,
		0x0010baacL,
		0x0010c35eL,
		0x0010c376L,
		0x0010c388L,
		0x0010c39aL,
		0x0010c3acL,
		0x0010c3c4L,
		0x0010cca6L,
		0x0010ccf0L,
		0x0010c381L,
		0x0010bc68L,
		0x0010bc80L,
		0x0010cc9dL,
		0x0010cceaL,
		0x0010c393L,
		0x0010bdd0L,
		0x0010bde8L,
		0x0010cc94L,
		0x0010cce4L,
		0x0010c3a5L,
		0x0010b3e8L,
		0x0010b400L,
		0x0010cc88L,
		0x0010ccdbL,
		0x0010bb72L,
		0x0010bb7eL,
		0x0010bb96L,
		0x0010d890L,
		0x0010d9c8L,
		0x0010bc5cL,
		0x0010beaeL,
		0x0010bebaL,
		0x0010beccL,
		0x0010bee4L,
		0x0010d99dL,
		0x0010d9f3L,
		0x0010bec5L,
		0x0010d9a6L,
		0x0010d9f9L,
		0x0010bdc4L,
		0x0010d9afL,
		0x0010d9ffL,
		0x0010b4c6L,
		0x0010b4d2L,
		0x0010b4eaL,
		0x0010d9bbL,
		0x0010da08L,
		0x0010b3dcL,
		0x0010b646L,
		0x0010b652L,
		0x0010b66aL,
		0x0010cb4aL,
		0x0010cb64L,
		0x0010caceL,
		0x0010cb16L,
		0x0010cb0dL,
		0x0010cb41L,
		0x0010ca02L,
		0x0010ca1cL,
		0x0010ca48L,
		0x0010ca62L,
		0x0010ba88L,
		0x0010da12L,
		0x0010daa6L,
		0x0010b7c6L,
		0x0010b7d2L,
		0x0010b7eaL,
		0x0010da90L,
		0x0010dad1L,
		0x0010da99L,
		0x0010dad7L,
		0x0010cf0cL,
		0x0010cf54L,
		0x0010cf4bL,
		0x0010cf7fL,
		0x0010ce50L,
		0x0010ce98L,
		0x0010ce8fL,
		0x0010cec3L,
		0x0010cb90L,
		0x0010cbaaL,
		0x0010e316L,
		0x0010e340L,
		0x0010dfb0L,
		0x0010f082L,
		0x0010f0acL,
		0x0010ea48L,
		0x0010f0d8L,
		0x0010f15eL,
		0x0010e456L,
		0x0010e462L,
		0x0010e47aL,
		0x0010e6a8L,
		0x0010e6b4L,
		0x0010e6ccL,
		0x0010f14cL,
		0x0010f189L,
		0x0010e36cL,
		0x0010e378L,
		0x0010e390L,
		0x0010e540L,
		0x0010e54cL,
		0x0010e564L,
		0x0010f152L,
		0x0010f18fL,
		0x0010ede6L,
		0x0010ee10L,
		0x0010ed6aL,
		0x0010edb2L,
		0x0010eda9L,
		0x0010edddL,
		0x0010ec3aL,
		0x0010ec54L,
		0x0010fc96L,
		0x0010fcc0L,
		0x0010f8feL,
		0x00111b34L,
		0x00111b5eL,
		0x00111a4cL,
		0x001123baL,
		0x00112460L,
		0x001118f4L,
		0x00112447L,
		0x0011248bL,
		0x00111766L,
		0x00111a3fL,
		0x00112453L,
		0x00112494L,
		0x001117b0L,
		0x00111a33L,
		0x001117bbL,
		0x0011249eL,
		0x00112524L,
		0x00111852L,
		0x00112512L,
		0x0011254fL,
		0x001118eaL,
		0x00112518L,
		0x00112555L,
		0x001118deL,
		0x0011223cL,
		0x00112284L,
		0x001117c4L,
		0x0011227bL,
		0x001122afL,
		0x00111845L,
		0x001121a6L,
		0x001121d0L,
		0x00111772L,
		0x0011255eL,
		0x001125f2L,
		0x00111690L,
		0x001125dcL,
		0x0011261dL,
		0x0011175dL,
		0x001125e5L,
		0x00112623L,
		0x00111751L,
		0x00111fa2L,
		0x00111feaL,
		0x00111602L,
		0x00111fe1L,
		0x00112015L,
		0x00111683L,
		0x00111ee6L,
		0x00111f2eL,
		0x00111574L,
		0x00111f25L,
		0x00111f59L,
		0x001115f5L,
		0x00111d60L,
		0x00111d7aL,
		0x00111558L,
		0x0011153cL
		};

		private static final String returnString = "554889e548897df8905dc3";

		private static final String fDescriptors = "";

		public X86TypeInfoProgramBuilder() throws Exception {
			super("x86:LE:64:default", "gcc");
		}

		@Override
		protected Map<Long, String> getTypeInfoMap() {
			return typeMap;
		}

		@Override
		protected Map<Long, String> getTypeNameMap() {
			return nameMap;
		}

		@Override
		protected Map<Long, String> getVtableMap() {
			return vtableMap;
		}

		@Override
		protected Map<Long, String> getVttMap() {
			return vttMap;
		}

		@Override
		protected Map<Long, String> getRelocationMap() {
			return relocationMap;
		}

		@Override
		protected Long[] getFunctionOffsets() {
			return functionOffsets;
		}

		@Override
		protected String getReturnInstruction() {
			return returnString;
		}

		@Override
		protected String getFunctionDescriptors() {
			return fDescriptors;
		}

		@Override
		protected void setupMemory() {
			createMemory(".text", "00108360", 41777);
			createMemory(".data.rel.ro", "0011c1a0", 11264);
		}
	}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/factory/TypeInfoFactory.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.factory;

import java.util.Map;
import java.util.function.Function;

import ghidra.util.exception.AssertException;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressOutOfBoundsException;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemBuffer;
import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.*;

/**
 * @deprecated please use the methods provided by
 * {@link cppclassanalyzer.data.ProgramClassTypeInfoManager ClassTypeInfoManager}
 */
@Deprecated(since = "1.5", forRemoval = true)
public class TypeInfoFactory {

	private TypeInfoFactory() {}

	private static final Map<String, MethodPair> COPY_MAP =
		Map.ofEntries(
			Map.entry(
				ArrayTypeInfoModel.ID_STRING,
				new MethodPair(
					ArrayTypeInfoModel::getModel,
					ArrayTypeInfoModel::getDataType)),
			Map.entry(
				ClassTypeInfoModel.ID_STRING,
				new MethodPair(
					ClassTypeInfoModel::getModel,
					ClassTypeInfoModel::getDataType)),
			Map.entry(
				EnumTypeInfoModel.ID_STRING,
				new MethodPair(
					EnumTypeInfoModel::getModel,
					EnumTypeInfoModel::getDataType)),
			Map.entry(
				FunctionTypeInfoModel.ID_STRING,
				new MethodPair(
					FunctionTypeInfoModel::getModel,
					FunctionTypeInfoModel::getDataType)),
			Map.entry(
				FundamentalTypeInfoModel.ID_STRING,
				new MethodPair(
					FundamentalTypeInfoModel::getModel,
					FundamentalTypeInfoModel::getDataType)),
			Map.entry(
				PBaseTypeInfoModel.ID_STRING,
				new MethodPair(
					PBaseTypeInfoModel::getModel,
					PBaseTypeInfoModel::getDataType)),
			Map.entry(
				PointerToMemberTypeInfoModel.ID_STRING,
				new MethodPair(
					PointerToMemberTypeInfoModel::getModel,
					PointerToMemberTypeInfoModel::getDataType)),
			Map.entry(
				PointerTypeInfoModel.ID_STRING,
				new MethodPair(
					PointerTypeInfoModel::getModel,
					PointerTypeInfoModel::getDataType)),
			Map.entry(
				SiClassTypeInfoModel.ID_STRING,
				new MethodPair(
					SiClassTypeInfoModel::getModel,
					SiClassTypeInfoModel::getDataType)),
			Map.entry(
				VmiClassTypeInfoModel.ID_STRING,
				new MethodPair(
					VmiClassTypeInfoModel::getModel,
					VmiClassTypeInfoModel::getDataType)),
			Map.entry(
				TypeInfoModel.ID_STRING,
				new MethodPair(
					TypeInfoModel::getModel,
					TypeInfoModel::getDataType)),
			Map.entry(
				IosFailTypeInfoModel.ID_STRING,
				new MethodPair(
					IosFailTypeInfoModel::getModel,
					IosFailTypeInfoModel::getDataType)));

	/**
	 * Get the TypeInfo in the buffer
	 * @param buf the memory buffer containing the TypeInfo data
	 * @return the TypeInfo at the buffers address
	 */
	public static TypeInfo getTypeInfo(MemBuffer buf) {
		return getTypeInfo(buf.getMemory().getProgram(), buf.getAddress());
	}

	/**
	 * Get the TypeInfo at the address
	 * @param program the program containing the TypeInfo
	 * @param address the address of the TypeInfo
	 * @return the TypeInfo at the specified address in the specified program
	 * or null if none exists.
	 */
	public static TypeInfo getTypeInfo(Program program, Address address) {
			String baseTypeName = TypeInfoUtils.getIDString(program, address);
			if (!COPY_MAP.containsKey(baseTypeName)) {
				// invalid typeinfo
				return null;
			} try {
				return COPY_MAP.get(baseTypeName).modelGetter.getModel(program, address);
			} catch (InvalidDataTypeException e) {
				throw new AssertException(
					TypeInfoUtils.getErrorMessage(program, address, baseTypeName));
			}
	}

	/**
	 * Checks if a valid TypeInfo is located at the start of the buffer
	 * @param buf the memory buffer containing the TypeInfo data
	 * @return true if the buffer contains a valid TypeInfo
	 */
	public static boolean isTypeInfo(MemBuffer buf) {
		return buf != null ? isTypeInfo(buf.getMemory().getProgram(), buf.getAddress()) : false;
	}

	/**
	 * Checks if a valid TypeInfo is located at the address in the program.
	 * @param program the program containing the TypeInfo
	 * @param address the address of the TypeInfo
	 * @return true if the data is a valid TypeInfo
	 */
	public static boolean isTypeInfo(Program program, Address address) {
		try {
			return COPY_MAP.containsKey(TypeInfoUtils.getIDString(program, address));
		} catch (AddressOutOfBoundsException e) {
			return false;
		}
	}

	/**
	 * Invokes getDataType on the TypeInfo containing the specified typename
	 * @param program the program containing the TypeInfo
	 * @param typename the type_info class's typename
	 * @return the TypeInfo structure for the typename
	 * @see TypeInfoModel#getDataType()
	 */
	public static Structure getDataType(Program program, String typename) {
		if (COPY_MAP.containsKey(typename)) {
			final Function<DataTypeManager, DataType> getter =
				COPY_MAP.get(typename).dataTypeGetter;
			return (Structure) getter.apply(program.getDataTypeManager());
		}
		return null;
	}

	private interface ModelGetter {
		public TypeInfo getModel(Program program, Address address) throws InvalidDataTypeException;
	}

	private static final class MethodPair {

		final ModelGetter modelGetter;
		final Function<DataTypeManager, DataType> dataTypeGetter;

		MethodPair(ModelGetter modelGetter,
			Function<DataTypeManager, DataType> dataTypeGetter) {
				this.modelGetter = modelGetter;
				this.dataTypeGetter = dataTypeGetter;
		}
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/AbstractClassTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import java.util.Collections;
import java.util.Set;

import ghidra.app.util.NamespaceUtils;
import ghidra.app.util.SymbolPath;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.ClassTypeInfoUtils;
import ghidra.app.cmd.data.rtti.gcc.GccCppClassBuilder;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.app.cmd.data.rtti.gcc.VtableModel;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.BookmarkManager;
import ghidra.program.model.listing.BookmarkType;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.util.Msg;
import ghidra.util.exception.AssertException;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

import cppclassanalyzer.utils.CppClassAnalyzerUtils;

import static ghidra.app.cmd.data.rtti.GnuVtable.PURE_VIRTUAL_FUNCTION_NAME;

/**
 * Base Model for __class_type_info and its derivatives.
 */
public abstract class AbstractClassTypeInfoModel extends AbstractTypeInfoModel
		implements ClassTypeInfo {

	protected GnuVtable vtable = null;
	private GccCppClassBuilder builder;

	protected AbstractClassTypeInfoModel(Program program, Address address) {
		super(program, address);
		builder = new GccCppClassBuilder(this);
	}

	@Override
	public final Structure getClassDataType() {
		DataTypeManager dtm = program.getDataTypeManager();
		if (getTypeName().contains(TypeInfoModel.STRUCTURE_NAME)) {
			// this doesn't occur often to the string switch statement is ok
			switch (getTypeName()) {
				case ArrayTypeInfoModel.ID_STRING:
					return (Structure) ArrayTypeInfoModel.getDataType(dtm);
				case ClassTypeInfoModel.ID_STRING:
					return (Structure) ClassTypeInfoModel.getDataType(dtm);
				case EnumTypeInfoModel.ID_STRING:
					return (Structure) EnumTypeInfoModel.getDataType(dtm);
				case FunctionTypeInfoModel.ID_STRING:
					return (Structure) FunctionTypeInfoModel.getDataType(dtm);
				case FundamentalTypeInfoModel.ID_STRING:
					return (Structure) FundamentalTypeInfoModel.getDataType(dtm);
				case IosFailTypeInfoModel.ID_STRING:
					return (Structure) IosFailTypeInfoModel.getDataType(dtm);
				case PBaseTypeInfoModel.ID_STRING:
					return (Structure) PBaseTypeInfoModel.getDataType(dtm);
				case PointerToMemberTypeInfoModel.ID_STRING:
					return (Structure) PointerToMemberTypeInfoModel.getDataType(dtm);
				case PointerTypeInfoModel.ID_STRING:
					return (Structure) PointerTypeInfoModel.getDataType(dtm);
				case SiClassTypeInfoModel.ID_STRING:
					return (Structure) SiClassTypeInfoModel.getDataType(dtm);
				case TypeInfoModel.ID_STRING:
					return (Structure) TypeInfoModel.getDataType(dtm);
				case VmiClassTypeInfoModel.ID_STRING:
					return (Structure) VmiClassTypeInfoModel.getDataType(dtm);
				default:
					throw new AssertException("Unknown type_info derivative "+getTypeName());
			}
		}
		return builder.getDataType();
	}

	@Override
	public GnuVtable getVtable() {
		if (vtable == null) {
			return Vtable.NO_VTABLE;
		}
		return vtable;
	}

	@Override
	public GnuVtable findVtable(TaskMonitor monitor) throws CancelledException {
		if (vtable != null) {
			return vtable;
		}
		SymbolTable table = program.getSymbolTable();
		for (Symbol symbol : table.getSymbols(VtableModel.SYMBOL_NAME, getGhidraClass())) {
			GnuVtable tmpVtable = (GnuVtable) manager.getVtable(symbol.getAddress());
			if (Vtable.isValid(tmpVtable)) {
				vtable = tmpVtable;
				return vtable;
			}
			tmpVtable =
				VtableModel.getVtable(program, symbol.getAddress(), this);
			if (Vtable.isValid(tmpVtable)) {
				vtable = tmpVtable;
				return vtable;
			}
			BookmarkManager man = program.getBookmarkManager();
			man.setBookmark(
				symbol.getAddress(), BookmarkType.ERROR, null, "Vtable Validation Failed");
			String msg = String.format(
				"Symbol %s at %s is a valid vtable symbol but the data validation check failed",
				symbol.getName(), symbol.getAddress());
			Msg.warn(this, msg);
		}
		vtable = (GnuVtable) ClassTypeInfoUtils.findVtable(program, address, monitor);
		return vtable;
	}

	@Override
	public final boolean isAbstract() {
		return CppClassAnalyzerUtils.isAbstract(this, PURE_VIRTUAL_FUNCTION_NAME);
	}

	@Override
	public GhidraClass getGhidraClass() {
		if (!(namespace instanceof GhidraClass)) {
			Integer id = null;
			boolean success = false;
			try {
				if (program.getCurrentTransaction() == null) {
					id = program.startTransaction("creating GhidraClass for "+getName());
				}
				if (namespace.getSymbol().isDeleted()) {
					namespace = TypeInfoUtils.getNamespaceFromTypeName(program, typeName);
					namespace = NamespaceUtils.convertNamespaceToClass(namespace);
				} else {
					namespace = NamespaceUtils.convertNamespaceToClass(namespace);
				}
				success = true;
			} catch (InvalidInputException e) {
				Msg.error(this, e);
				return null;
			} finally {
				if (id != null) {
					program.endTransaction(id, success);
				}
			}
		} return (GhidraClass) namespace;
	}

	@Override
	public Set<ClassTypeInfo> getVirtualParents() {
		return Collections.emptySet();
	}

	@Override
	public SymbolPath getSymbolPath() {
		return new SymbolPath(getGhidraClass().getSymbol());
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/AbstractPBaseTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.Enum;
import ghidra.program.model.data.EnumDataType;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.data.Structure;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.DumbMemBufferImpl;
import ghidra.program.model.scalar.Scalar;

import static ghidra.app.cmd.data.rtti.gcc.GnuUtils.getCxxAbiCategoryPath;
import static ghidra.program.model.data.DataTypeConflictHandler.*;
import static ghidra.app.util.datatype.microsoft.MSDataTypeUtils.getAbsoluteAddress;

/**
 * Base Model for {@value PBaseTypeInfoModel#STRUCTURE_NAME} and its derivatives
 */
abstract class AbstractPBaseTypeInfoModel extends AbstractTypeInfoModel {

	private static final CategoryPath FLAGS_PATH = new CategoryPath(
		getCxxAbiCategoryPath(), PBaseTypeInfoModel.STRUCTURE_NAME);

	protected static final String SUPER_NAME = SUPER + PBaseTypeInfoModel.STRUCTURE_NAME;

	private static final int POINTEE_ORDINAL = 2;

	private DataType dataType = null;

	private enum Mask {
		CONSTANT,
		VOLATILE,
		RESTRICT,
		INCOMPLETE,
		INCOMPLETE_CLASS,
		TRANACTION_SAFE,
		NO_EXCEPT
	}

	public AbstractPBaseTypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	/**
	 * Gets the DataType for the __qualifier_masks
	 * @param dtm the datatype manager
	 * @return the __qualifier_masks DataType
	 */
	public static DataType getFlags(DataTypeManager dtm) {
		EnumDataType flags = new EnumDataType(
			FLAGS_PATH, "__qualifier_masks", dtm.getDataOrganization().getIntegerSize());

		// According to cxxabi.h
		flags.add("__const_mask", 1);
		flags.add("__volatile_mask", 2);
		flags.add("__restrict_mask", 4);
		flags.add("__incomplete_mask", 8);
		flags.add("__incomplete_class_mask", 16);
		flags.add("__transaction_safe_mask", 0x20);
		flags.add("__noexcept_mask", 0x40);
		DataType result = dtm.resolve(flags, KEEP_HANDLER);
		return result.getLength() <= 1 ? dtm.resolve(flags, REPLACE_HANDLER) : result;
	}

	protected static DataType getPBase(DataTypeManager dtm) {
		DataType existingDt = dtm.getDataType(
			getCxxAbiCategoryPath(), PBaseTypeInfoModel.STRUCTURE_NAME);
		if (existingDt != null && existingDt.getDescription().equals(PBaseTypeInfoModel.DESCRIPTION)) {
			return existingDt;
		}
		DataType superDt = TypeInfoModel.getDataType(dtm);
		StructureDataType struct = new StructureDataType(
			getCxxAbiCategoryPath(), PBaseTypeInfoModel.STRUCTURE_NAME, 0, dtm);
		struct.add(superDt, SUPER+TypeInfoModel.STRUCTURE_NAME, null);
		struct.add(getFlags(dtm), "__flags", null);
		struct.add(PointerDataType.getPointer(TypeInfoModel.getDataType(dtm), dtm), "__pointee", null);
		struct.setDescription(PBaseTypeInfoModel.DESCRIPTION);
		struct.setPackingEnabled(true);
		struct.repack();
		DataType result = dtm.resolve(struct, KEEP_HANDLER);
		return result.getLength() <= 1 ? dtm.resolve(struct, REPLACE_HANDLER) : result;
	}

	private Scalar getFlagsValue() {
		DataTypeComponent comp = ((Structure) getDataType()).getComponent(1);
		Enum flags = (Enum) comp.getDataType();
		DumbMemBufferImpl dumBuf = new DumbMemBufferImpl(
			program.getMemory(), address.add(comp.getOffset()));
		return (Scalar) flags.getValue(dumBuf, flags.getDefaultSettings(), flags.getLength());
	}

	private boolean testFlags(Mask mask) {
		switch(mask) {
			case CONSTANT:
				return getFlagsValue().testBit(0);
			case VOLATILE:
				return getFlagsValue().testBit(1);
			case RESTRICT:
				return getFlagsValue().testBit(2);
			case INCOMPLETE:
				return getFlagsValue().testBit(3);
			case INCOMPLETE_CLASS:
				return getFlagsValue().testBit(4);
			case TRANACTION_SAFE:
				return getFlagsValue().testBit(5);
			case NO_EXCEPT:
				return getFlagsValue().testBit(6);
			default:
				return false;
		}
	}

	/**
	 * Checks if the pointed to datatype is const
	 * @return true if the pointed to datatype is const
	 */
	public boolean isConst() {
		return testFlags(Mask.CONSTANT);
	}

	/**
	 * Checks if the pointed to datatype is volatile
	 * @return true if the pointed to datatype is volatile
	 */
	public boolean isVolatile() {
		return testFlags(Mask.VOLATILE);
	}

	/**
	 * Checks if the pointed to datatype is restrict
	 * @return true if the pointed to datatype is restrict
	 */
	public boolean isRestrict() {
		return testFlags(Mask.RESTRICT);
	}

	/**
	 * Checks if the pointed to datatype is incomplete
	 * @return true if the pointed to datatype is incomplete
	 */
	public boolean isIncomplete() {
		return testFlags(Mask.INCOMPLETE);
	}

	/**
	 * Checks if the pointed to datatype is an incomplete class
	 * @return true if the pointed to datatype is an incomplete class
	 */
	public boolean isIncompleteClass() {
		return testFlags(Mask.INCOMPLETE_CLASS);
	}

	/**
	 * Checks if the pointed to datatype is transaction_safe (synchronized)
	 * @return true if the pointed to datatype is transaction_safe (synchronized)
	 */
	public boolean isTransactionSafe() {
		return testFlags(Mask.TRANACTION_SAFE);
	}

	/**
	 * Checks if the pointed to datatype is specified as noexcept
	 * @return true if the pointed to datatype is specified as noexcept
	 */
	public boolean isNoExcept() {
		return testFlags(Mask.NO_EXCEPT);
	}

	/**
	 * Gets the TypeInfo base being pointed to
	 * @return the TypeInfo being pointed to
	 */
	public TypeInfo getPointee() {
		Structure struct = (Structure) getDataType();
		DataTypeComponent comp;
		if (this instanceof PBaseTypeInfoModel) {
			comp = struct.getComponent(POINTEE_ORDINAL);
		} else {
			Structure baseDt = (Structure) struct.getComponent(0).getDataType();
			comp = baseDt.getComponent(POINTEE_ORDINAL);
		}
		Address pointee = getAbsoluteAddress(program, address.add(comp.getOffset()));
		return manager.getTypeInfo(pointee);
	}

	@Override
	public DataType getRepresentedDataType() {
		if (dataType == null) {
			DataType pointeeType = parseDataType(getPointee().getTypeName());
			dataType = program.getDataTypeManager().getPointer(pointeeType);
		}
		return dataType;
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/AbstractSiClassTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import java.util.Set;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.gcc.GnuUtils;

import static ghidra.app.util.datatype.microsoft.MSDataTypeUtils.getAbsoluteAddress;

/**
 * Base Model for __si_class_type_info and its derivatives.
 */
abstract class AbstractSiClassTypeInfoModel extends AbstractClassTypeInfoModel {

	protected AbstractSiClassTypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	private static Address getBaseTypeAddress(Program program, Address address) {
		Address pointerAddress = address.add(program.getDefaultPointerSize() << 1);
		Address result = getAbsoluteAddress(program, pointerAddress);
		return result != null ? result : Address.NO_ADDRESS;
	}

	@Override
	public boolean hasParent() {
		return true;
	}

	@Override
	public ClassTypeInfo[] getParentModels() {
		Address baseAddress = getBaseTypeAddress(program, address);
		if (!baseAddress.equals(Address.NO_ADDRESS)
			&& !GnuUtils.isExternal(program, baseAddress)) {
				ClassTypeInfo parent = manager.getType(baseAddress);
				if (parent != null) {
					return new ClassTypeInfo[] { parent };
				}
		}
		return new ClassTypeInfo[] { manager.getExternalClassTypeInfo(baseAddress) };
	}

	@Override
	public Set<ClassTypeInfo> getVirtualParents() {
		ClassTypeInfo[] parents = getParentModels();
		return parents[0].getVirtualParents();
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/AbstractTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.app.util.demangler.DemangledDataType;
import ghidra.app.util.demangler.DemangledFunctionReference;
import ghidra.app.util.demangler.DemangledObject;
import cppclassanalyzer.data.manager.ItaniumAbiClassTypeInfoManager;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemBuffer;
import ghidra.program.model.mem.MemoryBufferImpl;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.Pointer;
import ghidra.program.model.data.Structure;
import ghidra.program.model.data.StructureDataType;

import static ghidra.app.util.demangler.DemanglerUtil.demangle;
import static ghidra.app.cmd.data.rtti.gcc.GnuUtils.getCxxAbiCategoryPath;
import static ghidra.program.model.data.DataTypeConflictHandler.KEEP_HANDLER;
import static ghidra.program.model.data.DataTypeConflictHandler.REPLACE_HANDLER;

/**
 * Base Model for type_info and its derivatives.
 */
abstract class AbstractTypeInfoModel implements TypeInfo {

	protected static final String DEFAULT_TYPENAME = "";

	protected static final int BASE_ORDINAL = 0;

	protected final Program program;
	protected final Address address;
	protected final ItaniumAbiClassTypeInfoManager manager;
	private DataType dataType = null;

	protected String typeName = DEFAULT_TYPENAME;
	protected Namespace namespace;
	private MemoryBufferImpl buf;

	protected static final String SUPER = "super_";
	protected static final CategoryPath STD_PATH = new CategoryPath(CategoryPath.ROOT, "std");

	private static final Pattern TYPE_PATTERN = Pattern.compile(".*_\\((.*)\\)");
	private static final Pattern FUNCTION_PATTERN = Pattern.compile("(.*)\\S*?\\((.*)\\)");

	protected AbstractTypeInfoModel(Program program, Address address) {
		this.manager = (ItaniumAbiClassTypeInfoManager) CppClassAnalyzerUtils.getManager(program);
		this.program = program;
		this.address = address;
		this.buf = new MemoryBufferImpl(program.getMemory(), address);
		this.typeName = TypeInfoUtils.getTypeName(program, address);
		this.namespace = TypeInfoUtils.getNamespaceFromTypeName(program, this);
	}

	protected static boolean isValid(Program program, Address address, String id) {
		if (!TypeInfoUtils.getIDString(program, address).equals(id)) {
			return false;
		}
		if (TypeInfoUtils.getTypeName(program, address).equals(DEFAULT_TYPENAME)) {
			return false;
		}
		return true;
	}

	@Override
	public final boolean equals(Object object) {
		if (!(object instanceof TypeInfo)) {
			return false;
		}
		return ((TypeInfo) object).getAddress().equals(address);
	}

	@Override
	public final int hashCode() {
		return typeName.hashCode();
	}

	@Override
	public Namespace getNamespace() {
		return namespace;
	}

	protected MemBuffer getBuffer() {
		return buf;
	}

	protected static DataType alignDataType(StructureDataType struct, DataTypeManager dtm) {
		struct.setPackingEnabled(true);
		struct.repack();
		DataType result = dtm.resolve(struct, KEEP_HANDLER);
		return result.getLength() <= 1 ? dtm.resolve(struct, REPLACE_HANDLER) : result;
	}

	@Override
	public final String getName() {
		return namespace.getName();
	}

	protected Structure getDataType(String dtName, String description) {
		return getDataType(program.getDataTypeManager(), dtName, description);
	}

	protected static Structure getDataType(DataTypeManager dtm, String name, String description) {
		DataType existingDt = dtm.getDataType(getCxxAbiCategoryPath(), name);
		if (existingDt != null && existingDt.getDescription().equals(description)) {
			return (Structure) existingDt;
		}
		StructureDataType struct = new StructureDataType(getCxxAbiCategoryPath(), name, 0, dtm);
		struct.add(TypeInfoModel.getDataType(dtm), "super_type_info", null);
		struct.setDescription(description);
		return (Structure) alignDataType(struct, dtm);
	}

	@Override
	public Address getAddress() {
		return address;
	}

	@Override
	public String getTypeName() {
		return typeName;
	}

	@Override
	public DataType getRepresentedDataType() {
		if (dataType == null) {
			dataType = parseDataType(typeName);
		}
		return dataType;
	}

	private static DemangledDataType getDemangledType(String demangled) {
		if (demangled.contains(DemangledDataType.UNSIGNED)) {
			demangled = demangled.replace(DemangledDataType.UNSIGNED+" ", "u");
		}
		if (demangled.contains(" ")) {
			int index = demangled.indexOf(" ");
			demangled = demangled.substring(0, index);
		}
		return new DemangledDataType(null, demangled, demangled);
	}

	protected DemangledFunctionReference getDemangledFunction(String signature) {
		DemangledFunctionReference method = new DemangledFunctionReference("_Z"+typeName, signature);
		Matcher matcher = FUNCTION_PATTERN.matcher(signature);
		if (matcher.matches()) {
			method.setReturnType(getDemangledType(matcher.group(1)));
			String[] parameters = matcher.group(2).split(",");
			for (String parameter : parameters) {
				if (parameter.equals("")) {
					parameter = DemangledDataType.VOID;
				}
				method.addParameter(getDemangledType(parameter));
			}
		}
		return method;
	}

	// TODO this needs to be retested or improved
	protected DataType parseDataType(String dataTypeName) {
		DemangledObject demangled = demangle("_Z1_"+dataTypeName);
		if (demangled != null) {
			Matcher matcher = TYPE_PATTERN.matcher(demangled.getSignature(false));
			if (matcher.matches()) {
				DataTypeManager dtm = program.getDataTypeManager();
				if (matcher.group(1).contains("(")) {
					// we have a demangled function
					DemangledFunctionReference method = getDemangledFunction(matcher.group(1));
					return ((Pointer) method.getDataType(dtm)).getDataType();
				}
				DemangledDataType dt = new DemangledDataType(null, matcher.group(1), matcher.group(1));
				return dt.getDataType(dtm);
			}
		} return null;
	}

	@Override
	public String toString() {
		return new StringBuilder()
				  .append(typeName != "" ? typeName : "Invalid type_info")
				  .append(" address: ")
				  .append(address.toString())
				  .toString();
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/ArrayTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.ArrayDataType;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.listing.Program;

/**
 * Model for the {@value #STRUCTURE_NAME} class.
 */
public final class ArrayTypeInfoModel extends AbstractTypeInfoModel {

	private static final String DESCRIPTION = "Model for Array Type Info";
	public static final String STRUCTURE_NAME = "__array_type_info";

	public static final String ID_STRING = "N10__cxxabiv117__array_type_infoE";
	private static final Pattern ARRAY_PATTERN = Pattern.compile(".*A(\\d*)_(.*)");

	private DataType dataType;
	private DataType typeInfoDataType;

	/**
	 * Gets a new ArrayTypeInfoModel
	 * @param program the program containing the {@value #STRUCTURE_NAME}
	 * @param address the address of the {@value #STRUCTURE_NAME}
	 * @return the new ArrayTypeInfoModel
	 * @throws InvalidDataTypeException if the data at the address
	 * is not a valid {@value #STRUCTURE_NAME}
	 */
	public static ArrayTypeInfoModel getModel(Program program, Address address)
		throws InvalidDataTypeException {
			if (isValid(program, address, ID_STRING)) {
				return new ArrayTypeInfoModel(program, address);
			}
			throw new InvalidDataTypeException(
				TypeInfoUtils.getErrorMessage(program, address, ID_STRING));
	}

	/**
	 * Constructs a new ArrayTypeInfoModel
	 * NOTE: This is only for pre-validated data
	 * @param program the program
	 * @param address the typeinfo address
	 */
	public ArrayTypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	/**
	 * Gets the __array_type_info datatype.
	 */
	@Override
	public DataType getDataType() {
		if (typeInfoDataType == null) {
			typeInfoDataType = getDataType(STRUCTURE_NAME, DESCRIPTION);
		}
		return typeInfoDataType;
	}


	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static DataType getDataType(DataTypeManager dtm) {
		return getDataType(dtm, STRUCTURE_NAME, DESCRIPTION);
	}

	@Override
	public String getIdentifier() {
		return ID_STRING;
	}

	@Override
	public DataType getRepresentedDataType() {
		if (dataType == null) {
			Matcher matcher = ARRAY_PATTERN.matcher(getTypeName());
			if (matcher.matches()) {
				int length = Integer.valueOf(matcher.group(1));
				DataType baseDt = parseDataType(matcher.group(2));
				dataType = new ArrayDataType(baseDt, length, baseDt.getLength());
			}
		}
		return dataType;
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/BaseClassTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import cppclassanalyzer.data.manager.ItaniumAbiClassTypeInfoManager;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressOverflowException;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.Pointer;
import ghidra.program.model.data.Structure;
import ghidra.program.model.mem.DumbMemBufferImpl;
import ghidra.program.model.mem.MemBuffer;
import ghidra.program.model.mem.MemoryBufferImpl;
import ghidra.util.Msg;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;

import static ghidra.program.model.data.DataTypeConflictHandler.KEEP_HANDLER;
import static ghidra.program.model.data.DataTypeConflictHandler.REPLACE_HANDLER;

import java.util.Arrays;
import java.util.Collections;
import java.util.Set;
import java.util.stream.Collectors;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.gcc.GnuUtils;

/**
 * Model for the {@value #STRUCTURE_NAME} helper class.
 */
public final class BaseClassTypeInfoModel {

	private static final String DESCRIPTION =
		"Helper data type for the __base_class_type_info array";
	static final String STRUCTURE_NAME = "__base_class_type_info";
	static final int FLAGS_ORDINAL = 1;

	private final ItaniumAbiClassTypeInfoManager manager;
	private MemoryBufferImpl buf;
	private DataTypeManager dtm;

	BaseClassTypeInfoModel(Program program, Address address) {
		this.manager = (ItaniumAbiClassTypeInfoManager) CppClassAnalyzerUtils.getManager(program);
		this.buf = new MemoryBufferImpl(program.getMemory(), address);
		this.dtm = program.getDataTypeManager();
	}

	/**
	 * Checks if this base class is inherited virtually
	 * @return true if this base class is inherited virtually
	 */
	public boolean isVirtual() {
		Structure struct = (Structure) getDataType();
		int offset = struct.getComponent(1).getOffset();
		MemBuffer tmpBuf = new DumbMemBufferImpl(buf.getMemory(), buf.getAddress().add(offset));
		return VmiOffsetFlagsModel.isVirtual(tmpBuf, dtm);
	}

	/**
	 * Checks if this base class is inherited publically
	 * @return true if this base class is inherited publically
	 */
	public boolean isPublic() {
		Structure struct = (Structure) getDataType();
		int offset = struct.getComponent(1).getOffset();
		MemBuffer tmpBuf = new DumbMemBufferImpl(buf.getMemory(), buf.getAddress().add(offset));
		return VmiOffsetFlagsModel.isPublic(tmpBuf, dtm);
	}

	/**
	 * Gets the value of this base class's offset
	 * @return the value of this base class's offset
	 */
	public int getOffset() {
		return (int) getFlags().getOffset();
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public DataType getDataType() {
		return getDataType(dtm);
	}

	/**
	 * Gets the address of this {@value #STRUCTURE_NAME}
	 * @return the address of this {@value #STRUCTURE_NAME}
	 */
	public Address getAddress() {
		return buf.getAddress();
	}

	VmiOffsetFlagsModel getFlags() {
		Structure struct = (Structure) getDataType();
		int offset = struct.getComponent(1).getOffset();
		return new VmiOffsetFlagsModel(manager.getProgram(), buf.getAddress().add(offset));
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static DataType getDataType(DataTypeManager dtm) {
		DataType superDt = ClassTypeInfoModel.getPointer(dtm);
		DataType existingDt = dtm.getDataType(superDt.getCategoryPath(), STRUCTURE_NAME);
		if (existingDt != null && existingDt.getDescription().equals(DESCRIPTION)) {
			return existingDt;
		}
		DataType flags = VmiOffsetFlagsModel.getDataType(dtm);
		StructureDataType struct = new StructureDataType(superDt.getCategoryPath(), STRUCTURE_NAME, 0, dtm);
		struct.add(superDt, superDt.getLength(), "super___class_type_info", null);
		struct.add(flags, flags.getLength(), "__offset_flags", null);
		struct.setPackingEnabled(true);
		struct.repack();
		struct.setDescription(DESCRIPTION);
		DataType result = dtm.resolve(struct, KEEP_HANDLER);
		return result.getLength() <= 1 ? dtm.resolve(struct, REPLACE_HANDLER) : result;
	}

	/**
	 * Gets the ClassTypeInfo model for this base class
	 * @return the ClassTypeInfo
	 */
	public ClassTypeInfo getClassModel() {
		Program program = manager.getProgram();
		Address classAddress = getClassAddress();
		if (!GnuUtils.isExternal(program, classAddress)) {
			return manager.getType(classAddress);
		}
		return manager.getExternalClassTypeInfo(classAddress);
	}

	/**
	 * Gets the base ClassTypeInfo's name
	 * @return the base ClassTypeInfo's name
	 * @see ClassTypeInfo#getName()
	 */
	public String getName() {
		return getClassModel().getName();
	}

	/**
	 * Gets the base ClassTypeInfo's address
	 * @return the base ClassTypeInfo's address
	 * @see ClassTypeInfo#getAddress()
	 */
	public Address getClassAddress() {
		Pointer pointer = ClassTypeInfoModel.getPointer(dtm);
		return (Address) pointer.getValue(buf, pointer.getDefaultSettings(), -1);
	}

	void advance() {
		try {
			this.buf.advance(getDataType().getLength());
		} catch (AddressOverflowException e) {
			Msg.error(this, e);
		}
	}

	public Set<BaseClassTypeInfoModel> getVirtualBases() {
		TypeInfo type = manager.getTypeInfo(getClassAddress(), false);
		if (!(type instanceof VmiClassTypeInfoModel)) {
			if (isVirtual()) {
				return Set.of(this);
			}
			return Collections.emptySet();
		}
		VmiClassTypeInfoModel vmi = (VmiClassTypeInfoModel) type;
		Set<BaseClassTypeInfoModel> result = Arrays.stream(vmi.getBases())
			.map(BaseClassTypeInfoModel::getVirtualBases)
			.flatMap(Set::stream)
			.filter(BaseClassTypeInfoModel::isVirtual)
			.collect(Collectors.toSet());
		if (isVirtual()) {
			result.add(this);
		}
		return result;
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/ClassTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import ghidra.program.model.data.Pointer;
import ghidra.program.model.data.DataType;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.PointerDataType;

/**
 * Model for the {@value #STRUCTURE_NAME} class.
 */
public final class ClassTypeInfoModel extends AbstractClassTypeInfoModel {

	public static final String STRUCTURE_NAME = "__class_type_info";
	private static final String DESCRIPTION = "Model for Class Type Info";

	public static final String ID_STRING = "N10__cxxabiv117__class_type_infoE";

	/**
	 * Gets a new ClassTypeInfoModel
	 * @param program the program containing the {@value #STRUCTURE_NAME}
	 * @param address the address of the {@value #STRUCTURE_NAME}
	 * @return the new ClassTypeInfoModel
	 * @throws InvalidDataTypeException if the data at the address
	 * is not a valid {@value #STRUCTURE_NAME}
	 */
	public static ClassTypeInfoModel getModel(Program program, Address address)
		throws InvalidDataTypeException {
			if (isValid(program, address, ID_STRING)) {
				return new ClassTypeInfoModel(program, address);
			}
			throw new InvalidDataTypeException(
				TypeInfoUtils.getErrorMessage(program, address, ID_STRING));
	}

	/**
	 * Constructs a new ClassTypeInfoModel
	 * NOTE: This is only for pre-validated data
	 * @param program the program
	 * @param address the typeinfo address
	 */
	public ClassTypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	/**
	 * Gets the __class_type_info datatype.
	 */
	@Override
	public DataType getDataType() {
		return getDataType(STRUCTURE_NAME, DESCRIPTION);
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static DataType getDataType(DataTypeManager dtm) {
		return getDataType(dtm, STRUCTURE_NAME, DESCRIPTION);
	}

	/**
	 * Gets a pointer to a __class_type_info datatype
	 * @param dtm the datatype manager
	 * @return {@value #STRUCTURE_NAME}*
	 */
	public static Pointer getPointer(DataTypeManager dtm) {
		return PointerDataType.getPointer(getDataType(dtm), dtm);
	}

	@Override
	public String getIdentifier() {
		return ID_STRING;
	}

	@Override
	public boolean hasParent() {
		return false;
	}

	@Override
	public ClassTypeInfo[] getParentModels() {
		return new ClassTypeInfo[0];
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/EnumTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.DataTypePath;
import ghidra.program.model.data.EnumDataType;
import ghidra.program.model.data.IntegerDataType;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.listing.Program;

import static ghidra.program.database.data.DataTypeUtilities.findDataType;

/**
 * Model for the {@value #STRUCTURE_NAME} class.
 */
public final class EnumTypeInfoModel extends AbstractTypeInfoModel {

	public static final String STRUCTURE_NAME = "__enum_type_info";
	public static final String ID_STRING = "N10__cxxabiv116__enum_type_infoE";
	private static final String DESCRIPTION = "Model for Enum Type Info";

	private DataType typeInfoDataType;

	/**
	 * Gets a new EnumTypeInfoModel
	 * @param program the program containing the {@value #STRUCTURE_NAME}
	 * @param address the address of the {@value #STRUCTURE_NAME}
	 * @return the new EnumTypeInfoModel
	 * @throws InvalidDataTypeException if the data at the address
	 * is not a valid {@value #STRUCTURE_NAME}
	 */
	public static EnumTypeInfoModel getModel(Program program, Address address)
		throws InvalidDataTypeException {
			if (isValid(program, address, ID_STRING)) {
				return new EnumTypeInfoModel(program, address);
			}
			throw new InvalidDataTypeException(
				TypeInfoUtils.getErrorMessage(program, address, ID_STRING));
	}

	/**
	 * Constructs a new EnumTypeInfoModel
	 * NOTE: This is only for pre-validated data
	 * @param program the program
	 * @param address the typeinfo address
	 */
	public EnumTypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	@Override
	public String getIdentifier() {
		return ID_STRING;
	}

	/**
	 * Gets the __enum_type_info datatype.
	 */
	@Override
	public DataType getDataType() {
		if (typeInfoDataType == null) {
			typeInfoDataType = getDataType(STRUCTURE_NAME, DESCRIPTION);
		}
		return typeInfoDataType;
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static DataType getDataType(DataTypeManager dtm) {
		return getDataType(dtm, STRUCTURE_NAME, DESCRIPTION);
	}

	@Override
	public DataType getRepresentedDataType() {
		// __enum_type_info does not provide any information regarding the type.
		DataTypeManager dtm = program.getDataTypeManager();
		DataType result = findDataType(dtm, getNamespace(), getName(), null);
		if (result == null) {
			int defaultLength = IntegerDataType.dataType.clone(dtm).getLength();
			DataTypePath path = TypeInfoUtils.getDataTypePath(this);
			result =
				new EnumDataType(path.getCategoryPath(), path.getDataTypeName(), defaultLength);
		}
		return result;
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/FunctionTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.app.util.demangler.DemangledFunctionReference;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.FunctionDefinitionDataType;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.Pointer;
import ghidra.program.model.listing.Program;


/**
 * Model for the {@value #STRUCTURE_NAME} class.
 */
public final class FunctionTypeInfoModel extends AbstractTypeInfoModel {

	public static final String STRUCTURE_NAME = "__function_type_info";
	public static final String ID_STRING = "N10__cxxabiv120__function_type_infoE";
	private static final String DESCRIPTION = "Model for Function Type Info";

	private DataType typeInfoDataType;

	/**
	 * Gets a new FunctionTypeInfoModel
	 * @param program the program containing the {@value #STRUCTURE_NAME}
	 * @param address the address of the {@value #STRUCTURE_NAME}
	 * @return the new FunctionTypeInfoModel
	 * @throws InvalidDataTypeException if the data at the address
	 * is not a valid {@value #STRUCTURE_NAME}
	 */
	public static FunctionTypeInfoModel getModel(Program program, Address address)
		throws InvalidDataTypeException {
			if (isValid(program, address, ID_STRING)) {
				return new FunctionTypeInfoModel(program, address);
			}
			throw new InvalidDataTypeException(
				TypeInfoUtils.getErrorMessage(program, address, ID_STRING));
	}

	/**
	 * Constructs a new FunctionTypeInfoModel
	 * NOTE: This is only for pre-validated data
	 * @param program the program
	 * @param address the typeinfo address
	 */
	public FunctionTypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	@Override
	public String getIdentifier() {
		return ID_STRING;
	}

	/**
	 * Gets the __function_type_info datatype.
	 */
	@Override
	public DataType getDataType() {
		if (typeInfoDataType == null) {
			typeInfoDataType = getDataType(STRUCTURE_NAME, DESCRIPTION);
		}
		return typeInfoDataType;
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static DataType getDataType(DataTypeManager dtm) {
		return getDataType(dtm, STRUCTURE_NAME, DESCRIPTION);
	}

	/**
	 * Gets the function signature of the Function this __function_type_info represents.
	 *
	 * @return the represented functions signature.
	 */
	public String getFunctionSignature() {
		FunctionDefinitionDataType dataType =
				(FunctionDefinitionDataType) ((Pointer) getRepresentedDataType()).getDataType();
		DemangledFunctionReference method = getDemangledFunction(dataType.getPrototypeString());
		return method.toSignature(getNamespace().getName(true));
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/FundamentalTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.listing.Program;


/**
 * Model for the {@value #STRUCTURE_NAME} class.
 */
public final class FundamentalTypeInfoModel extends AbstractTypeInfoModel {

	public static final String STRUCTURE_NAME = "__fundamental_type_info";
	public static final String ID_STRING = "N10__cxxabiv123__fundamental_type_infoE";
	private static final String DESCRIPTION = "Model for Fundamental Type Info";

	private DataType typeInfoDataType;

	/**
	 * Gets a new FundamentalTypeInfoModel
	 * @param program the program containing the {@value #STRUCTURE_NAME}
	 * @param address the address of the {@value #STRUCTURE_NAME}
	 * @return the new FundamentalTypeInfoModel
	 * @throws InvalidDataTypeException if the data at the address
	 * is not a valid {@value #STRUCTURE_NAME}
	 */
	public static FundamentalTypeInfoModel getModel(Program program, Address address)
		throws InvalidDataTypeException {
			if (isValid(program, address, ID_STRING)) {
				return new FundamentalTypeInfoModel(program, address);
			}
			throw new InvalidDataTypeException(
				TypeInfoUtils.getErrorMessage(program, address, ID_STRING));
	}

	/**
	 * Constructs a new FundamentalTypeInfoModel
	 * NOTE: This is only for pre-validated data
	 * @param program the program
	 * @param address the typeinfo address
	 */
	public FundamentalTypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	@Override
	public String getIdentifier() {
		return ID_STRING;
	}

	/**
	 * Gets the __fundamental_type_info datatype.
	 */
	@Override
	public DataType getDataType() {
		if (typeInfoDataType == null) {
			typeInfoDataType = getDataType(STRUCTURE_NAME, DESCRIPTION);
		}
		return typeInfoDataType;
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static DataType getDataType(DataTypeManager dtm) {
		return getDataType(dtm, STRUCTURE_NAME, DESCRIPTION);
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/IosFailTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;

/**
 * Model for the {@value #STRUCTURE_NAME} class.
 */
public final class IosFailTypeInfoModel extends AbstractSiClassTypeInfoModel {

	private static final String DESCRIPTION = "Model for IosFail Type Info";
	public static final String STRUCTURE_NAME = "__iosfail_type_info";

	public static final String ID_STRING = "St19__iosfail_type_info";

	private DataType typeInfoDataType;

	/**
	 * Gets a new IosFailTypeInfoModel
	 * @param program the program containing the {@value #STRUCTURE_NAME}
	 * @param address the address of the {@value #STRUCTURE_NAME}
	 * @return the new IosFailTypeInfoModel
	 * @throws InvalidDataTypeException if the data at the address
	 * is not a valid {@value #STRUCTURE_NAME}
	 */
	public static IosFailTypeInfoModel getModel(Program program, Address address)
		throws InvalidDataTypeException {
			if (isValid(program, address, ID_STRING)) {
				return new IosFailTypeInfoModel(program, address);
			}
			throw new InvalidDataTypeException(
				TypeInfoUtils.getErrorMessage(program, address, ID_STRING));
	}

	/**
	 * Constructs a new IosFailTypeInfoModel
	 * NOTE: This is only for pre-validated data
	 * @param program the program
	 * @param address the typeinfo address
	 */
	public IosFailTypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	/**
	 * Gets the __iosfail_type_info datatype.
	 */
	@Override
	public DataType getDataType() {
		if (typeInfoDataType == null) {
			typeInfoDataType = getDataType(program.getDataTypeManager());
		}
		return typeInfoDataType;
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static DataType getDataType(DataTypeManager dtm) {
		DataType existingDt = dtm.getDataType(STD_PATH, STRUCTURE_NAME);
		if (existingDt != null && existingDt.getDescription().equals(DESCRIPTION)) {
			return existingDt;
		}
		StructureDataType struct = new StructureDataType(STD_PATH, STRUCTURE_NAME, 0, dtm);
		struct.add(SiClassTypeInfoModel.getDataType(dtm), SUPER+SiClassTypeInfoModel.STRUCTURE_NAME, null);
		struct.setDescription(DESCRIPTION);
		return alignDataType(struct, dtm);
	}

	@Override
	public String getIdentifier() {
		return ID_STRING;
	}

	@Override
	public DataType getRepresentedDataType() {
		return getDataType();
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/PBaseTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;

/**
 * Model for the {@value #STRUCTURE_NAME} class.
 */
public final class PBaseTypeInfoModel extends AbstractPBaseTypeInfoModel {

	public static final String STRUCTURE_NAME = "__pbase_type_info";
	public static final String DESCRIPTION = "Model for Pointer Base Type Info";

	public static final String ID_STRING = "N10__cxxabiv117__pbase_type_infoE";

	private DataType typeInfoDataType;

	/**
	 * Gets a new PBaseTypeInfoModel
	 * @param program the program containing the {@value #STRUCTURE_NAME}
	 * @param address the address of the {@value #STRUCTURE_NAME}
	 * @return the new PBaseTypeInfoModel
	 * @throws InvalidDataTypeException if the data at the address
	 * is not a valid {@value #STRUCTURE_NAME}
	 */
	public static PBaseTypeInfoModel getModel(Program program, Address address)
		throws InvalidDataTypeException {
			if (isValid(program, address, ID_STRING)) {
				return new PBaseTypeInfoModel(program, address);
			}
			throw new InvalidDataTypeException(
				TypeInfoUtils.getErrorMessage(program, address, ID_STRING));
	}

	/**
	 * Constructs a new PBaseTypeInfoModel
	 * NOTE: This is only for pre-validated data
	 * @param program the program
	 * @param address the typeinfo address
	 */
	public PBaseTypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	@Override
	public String getIdentifier() {
		return ID_STRING;
	}

	/**
	 * Gets the __pbase_type_info datatype.
	 */
	@Override
	public DataType getDataType() {
		if (typeInfoDataType == null) {
			typeInfoDataType = getDataType(program.getDataTypeManager());
		}
		return typeInfoDataType;
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static DataType getDataType(DataTypeManager dtm) {
		return getPBase(dtm);
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/PointerToMemberTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.Structure;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;

import static ghidra.app.util.datatype.microsoft.MSDataTypeUtils.getAbsoluteAddress;

/**
 * Model for the {@value #STRUCTURE_NAME} class.
 */
public final class PointerToMemberTypeInfoModel extends AbstractPBaseTypeInfoModel {

	public static final String STRUCTURE_NAME = "__pointer_to_member_type_info";
	private static final String DESCRIPTION = "Model for Pointer To Member Type Info";
	public static final String ID_STRING = "N10__cxxabiv129__pointer_to_member_type_infoE";

	private static final int CONTEXT_ORDINAL = 1;
	private DataType typeInfoDataType;

	/**
	 * Gets a new PointerToMemberTypeInfoModel
	 * @param program the program containing the {@value #STRUCTURE_NAME}
	 * @param address the address of the {@value #STRUCTURE_NAME}
	 * @return the new PointerToMemberTypeInfoModel
	 * @throws InvalidDataTypeException if the data at the address
	 * is not a valid {@value #STRUCTURE_NAME}
	 */
	public static PointerToMemberTypeInfoModel getModel(Program program, Address address)
		throws InvalidDataTypeException {
			if (isValid(program, address, ID_STRING)) {
				return new PointerToMemberTypeInfoModel(program, address);
			}
			throw new InvalidDataTypeException(
				TypeInfoUtils.getErrorMessage(program, address, ID_STRING));
	}

	/**
	 * Constructs a new PointerToMemberTypeInfoModel
	 * NOTE: This is only for pre-validated data
	 * @param program the program
	 * @param address the typeinfo address
	 */
	public PointerToMemberTypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	@Override
	public String getIdentifier() {
		return ID_STRING;
	}

	/**
	 * Gets the __pointer_to_member_type_info datatype
	 */
	@Override
	public DataType getDataType() {
		if (typeInfoDataType == null) {
			typeInfoDataType = getDataType(program.getDataTypeManager());
		}
		return typeInfoDataType;
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static DataType getDataType(DataTypeManager dtm) {
		DataType superDt = getPBase(dtm);
		DataType existingDt = dtm.getDataType(superDt.getCategoryPath(), STRUCTURE_NAME);
		if (existingDt != null && existingDt.getDescription().equals(DESCRIPTION)) {
			return existingDt;
		}
		StructureDataType struct = new StructureDataType(superDt.getCategoryPath(), STRUCTURE_NAME, 0, dtm);
		struct.add(superDt, SUPER_NAME, null);
		struct.add(ClassTypeInfoModel.getPointer(dtm), "__context", null);
		struct.setDescription(DESCRIPTION);
		return alignDataType(struct, dtm);
	}

	/**
	 * Gets the ClassTypeInfo containing the member being pointed to.
	 * @return the ClassTypeInfo containing the member being pointed to.
	 */
	public ClassTypeInfo getContext() {
		Structure struct = (Structure) getDataType();
		DataTypeComponent comp = struct.getComponent(CONTEXT_ORDINAL);
		Address pointee = getAbsoluteAddress(program, address.add(comp.getOffset()));
		return manager.getType(pointee);
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/PointerTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;

import static ghidra.app.cmd.data.rtti.gcc.GnuUtils.getCxxAbiCategoryPath;

import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;

/**
 * Model for the {@value #STRUCTURE_NAME} class.
 */
public final class PointerTypeInfoModel extends AbstractPBaseTypeInfoModel {

	public static final String STRUCTURE_NAME = "__pointer_type_info";
	public static final String ID_STRING = "N10__cxxabiv119__pointer_type_infoE";
	private static final String DESCRIPTION = "Model for Pointer Type Info";
	private DataType typeInfoDataType;

	/**
	 * Gets a new PointerTypeInfoModel
	 * @param program the program containing the {@value #STRUCTURE_NAME}
	 * @param address the address of the {@value #STRUCTURE_NAME}
	 * @return the new PointerTypeInfoModel
	 * @throws InvalidDataTypeException if the data at the address
	 * is not a valid {@value #STRUCTURE_NAME}
	 */
	public static PointerTypeInfoModel getModel(Program program, Address address)
		throws InvalidDataTypeException {
			if (isValid(program, address, ID_STRING)) {
				return new PointerTypeInfoModel(program, address);
			}
			throw new InvalidDataTypeException(
				TypeInfoUtils.getErrorMessage(program, address, ID_STRING));
	}

	/**
	 * Constructs a new PointerTypeInfoModel
	 * NOTE: This is only for pre-validated data
	 * @param program the program
	 * @param address the typeinfo address
	 */
	public PointerTypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	@Override
	public String getIdentifier() {
		return ID_STRING;
	}

	/**
	 * Gets the __pointer_type_info datatype.
	 */
	@Override
	public DataType getDataType() {
		if (typeInfoDataType == null) {
			typeInfoDataType = getDataType(program.getDataTypeManager());
		}
		return typeInfoDataType;
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static DataType getDataType(DataTypeManager dtm) {
		DataType superDt = getPBase(dtm);
		DataType existingDt = dtm.getDataType(superDt.getCategoryPath(), STRUCTURE_NAME);
		if (existingDt != null && existingDt.getDescription().equals(DESCRIPTION)) {
			return existingDt;
		}
		StructureDataType struct = new StructureDataType(
			getCxxAbiCategoryPath(), STRUCTURE_NAME, 0, dtm);
		struct.add(superDt, SUPER_NAME, null);
		struct.setDescription(DESCRIPTION);
		return alignDataType(struct, dtm);
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/SiClassTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import ghidra.program.model.data.DataType;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.data.StructureDataType;

/**
 * Model for the {@value #STRUCTURE_NAME} class.
 */
public final class SiClassTypeInfoModel extends AbstractSiClassTypeInfoModel {

	public static final String STRUCTURE_NAME = "__si_class_type_info";
	private static final String DESCRIPTION = "Model for Single Inheritance Class Type Info";

	public static final String ID_STRING = "N10__cxxabiv120__si_class_type_infoE";
	private DataType typeInfoDataType;

	/**
	 * Gets a new SiClassTypeInfoModel
	 * @param program the program containing the {@value #STRUCTURE_NAME}
	 * @param address the address of the {@value #STRUCTURE_NAME}
	 * @return the new SiClassTypeInfoModel
	 * @throws InvalidDataTypeException if the data at the address
	 * is not a valid {@value #STRUCTURE_NAME}
	 */
	public static SiClassTypeInfoModel getModel(Program program, Address address)
		throws InvalidDataTypeException {
			if (isValid(program, address, ID_STRING)) {
				return new SiClassTypeInfoModel(program, address);
			}
			throw new InvalidDataTypeException(
				TypeInfoUtils.getErrorMessage(program, address, ID_STRING));
	}

	/**
	 * Constructs a new SiClassTypeInfoModel
	 * NOTE: This is only for pre-validated data
	 * @param program the program
	 * @param address the typeinfo address
	 */
	public SiClassTypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	@Override
	public String getIdentifier() {
		return ID_STRING;
	}

	/**
	 * Gets the __si_class_type_info datatype.
	 */
	@Override
	public DataType getDataType() {
		if (typeInfoDataType == null) {
			typeInfoDataType = getDataType(program.getDataTypeManager());
		}
		return typeInfoDataType;
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static DataType getDataType(DataTypeManager dtm) {
		DataType superDt = ClassTypeInfoModel.getDataType(dtm);
		DataType existingDt = dtm.getDataType(superDt.getCategoryPath(), STRUCTURE_NAME);
		if (existingDt != null && existingDt.getDescription().equals(DESCRIPTION)) {
			return existingDt;
		}
		StructureDataType struct = new StructureDataType(
			superDt.getCategoryPath(), STRUCTURE_NAME, 0, dtm);
		struct.add(superDt, SUPER+ClassTypeInfoModel.STRUCTURE_NAME, null);
		struct.add(PointerDataType.getPointer(superDt, dtm), "__base_type", null);
		struct.setDescription(DESCRIPTION);
		return alignDataType(struct, dtm);
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/TypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.StringDataType;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.data.VoidDataType;
import ghidra.program.model.listing.Program;

/**
 * Model for the {@value #STRUCTURE_NAME} class.
 */
public final class TypeInfoModel extends AbstractTypeInfoModel {

	public static final String STRUCTURE_NAME = "type_info";
	private static final String DESCRIPTION = "Model for the base Type Info";

	protected static final int NAME_ORDINAL = 1;

	/** The typename for type_info */
	public static final String ID_STRING = "St9type_info";

	/**
	 * Gets a new TypeInfoModel
	 * @param program the program containing the {@value #STRUCTURE_NAME}
	 * @param address the address of the {@value #STRUCTURE_NAME}
	 * @return the new TypeInfoModel
	 * @throws InvalidDataTypeException if the data at the address
	 * is not a valid {@value #STRUCTURE_NAME}
	 */
	public static TypeInfoModel getModel(Program program, Address address)
		throws InvalidDataTypeException {
			if (isValid(program, address, ID_STRING)) {
				return new TypeInfoModel(program, address);
			}
			throw new InvalidDataTypeException(
				TypeInfoUtils.getErrorMessage(program, address, ID_STRING));
	}

	/**
	 * Constructs a new TypeInfoModel
	 * NOTE: This is only for pre-validated data
	 * @param program the program
	 * @param address the typeinfo address
	 */

	public TypeInfoModel(Program program, Address address) {
		super(program, address);
	}

	@Override
	public DataType getDataType() {
		return getDataType(program.getDataTypeManager());
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static DataType getDataType(DataTypeManager dtm) {
		DataType existingDt = dtm.getDataType(STD_PATH, STRUCTURE_NAME);
		if (existingDt != null && existingDt.getDescription().equals(DESCRIPTION)) {
			return existingDt;
		}
		StructureDataType struct = new StructureDataType(STD_PATH, STRUCTURE_NAME, 0, dtm);
		struct.add(dtm.getPointer(VoidDataType.dataType), "_vptr", null);
		struct.add(dtm.getPointer(StringDataType.dataType), "__name", null);
		struct.setDescription(DESCRIPTION);
		return alignDataType(struct, dtm);
	}

	@Override
	public String getIdentifier() {
		return ID_STRING;
	}

	@Override
	public DataType getRepresentedDataType() {
		return getDataType();
	}

}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/VmiClassTypeInfoModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import java.util.*;

import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.mem.MemBuffer;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.mem.MemoryBufferImpl;
import ghidra.util.Msg;
import ghidra.util.datastruct.LongArrayList;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Program;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.GnuUtils;
import ghidra.app.cmd.data.rtti.gcc.TypeInfoUtils;

import static ghidra.program.model.data.DataTypeConflictHandler.*;
import static ghidra.app.cmd.data.rtti.gcc.GnuUtils.getCxxAbiCategoryPath;

/**
 * Model for the {@value #STRUCTURE_NAME} class.
 */
public final class VmiClassTypeInfoModel extends AbstractClassTypeInfoModel {

	public static final String STRUCTURE_NAME = "__vmi_class_type_info";
	private static final String DESCRIPTION =
		"Model for Virtual Multiple Inheritance Class Type Info";

	public static final String ID_STRING = "N10__cxxabiv121__vmi_class_type_infoE";

	private static final String FLAGS_NAME = "__flags";
	private static final String BASE_COUNT_NAME = "__base_count";
	private static final String ARRAY_NAME = "__base_info";

	public static final String DIAMOND_MASK_NAME = "__diamond_shaped_mask";
	public static final String NON_DIAMOND_MASK_NAME = "__non_diamond_repeat_mask";

	private static final int FLAGS_ORDINAL = 1;
	private static final int BASE_COUNT_ORDINAL = 2;

	protected static final CategoryPath SUB_PATH =
		new CategoryPath(getCxxAbiCategoryPath(), STRUCTURE_NAME);

	public static enum Flags {
		NON_DIAMOND,
		DIAMOND,
		NON_PUBLIC,
		PUBLIC,
		UNKNOWN
	}

	private final BaseClassTypeInfoHelper helper;
	private BaseClassTypeInfoModel[] bases;
	private Flags flags;

	public static VmiClassTypeInfoModel getModel(Program program, Address address)
		throws InvalidDataTypeException {
			if (isValid(program, address, ID_STRING)) {
				return new VmiClassTypeInfoModel(program, address);
			}
			throw new InvalidDataTypeException(
				TypeInfoUtils.getErrorMessage(program, address, ID_STRING));
	}

	/**
	 * Constructs a new VmiClassTypeInfoModel
	 * NOTE: This is only for pre-validated data
	 * @param program the program
	 * @param address the typeinfo address
	 */
	public VmiClassTypeInfoModel(Program program, Address address) {
		super(program, address);
		this.helper = new BaseClassTypeInfoHelper(program, address);
		this.bases = helper.getBases();
		this.flags = getFlags(getBuffer());
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 */
	@Override
	public Structure getDataType() {
		return getDataType(program.getDataTypeManager());
	}

	public Flags getFlags() {
		return flags;
	}

	/**
	 * Gets the {@value #STRUCTURE_NAME} datatype
	 * @param dtm the DataTypeManager
	 * @return the {@value #STRUCTURE_NAME} datatype
	 */
	public static Structure getDataType(DataTypeManager dtm) {
		DataType existingDt = dtm.getDataType(GnuUtils.getCxxAbiCategoryPath(), STRUCTURE_NAME);
		StructureDataType struct =
			new StructureDataType(GnuUtils.getCxxAbiCategoryPath(), STRUCTURE_NAME, 0, dtm);
		struct.add(ClassTypeInfoModel.getDataType(dtm),
			AbstractTypeInfoModel.SUPER + ClassTypeInfoModel.STRUCTURE_NAME, null);
		struct.add(getFlags(dtm, SUB_PATH), FLAGS_NAME, null);
		struct.add(IntegerDataType.dataType.clone(dtm), BASE_COUNT_NAME, null);
		DataType bdt = BaseClassTypeInfoModel.getDataType(dtm);
		ArrayDataType adt = new ArrayDataType(bdt, 0, bdt.getLength());
		struct.add(adt, ARRAY_NAME, null);
		struct.setDescription(DESCRIPTION);
		if (existingDt != null && existingDt.isEquivalent(struct)) {
			return (Structure) existingDt;
		}
		return (Structure) dtm.resolve(struct, REPLACE_HANDLER);
	}

	@Override
	public String getIdentifier() {
		return ID_STRING;
	}

	@Override
	public boolean hasParent() {
		return true;
	}

    private List<ClassTypeInfo> getParents() {
        List<ClassTypeInfo> parents = new ArrayList<>();
        for (BaseClassTypeInfoModel base : bases) {
            if (!base.isVirtual()) {
                parents.add(base.getClassModel());
            }
        }
        try {
            parents.addAll(getInheritableVirtualParents());
        } catch (NullPointerException e) {
            throw e;
        }
        return parents;
    }

	@Override
	public ClassTypeInfo[] getParentModels() {
		return getParents().toArray(ClassTypeInfo[]::new);
	}

	@Override
	public Set<ClassTypeInfo> getVirtualParents() {
		Set<ClassTypeInfo> result = new LinkedHashSet<>();
		for (BaseClassTypeInfoModel base : bases) {
			ClassTypeInfo parent = base.getClassModel();
			if (base.isVirtual()) {
				result.add(parent);
			}
			result.addAll(parent.getVirtualParents());
		}
		return result;
	}

	private Set<ClassTypeInfo> getInheritableVirtualParents() {
		Set<ClassTypeInfo> result = new LinkedHashSet<>();
		for (BaseClassTypeInfoModel base : bases) {
			ClassTypeInfo parent = base.getClassModel();
			if (base.isVirtual()) {
				result.add(parent);
			}
			result.addAll(parent.getVirtualParents());
		}
		return result;
	}

	/**
	 * Gets this {@value #STRUCTURE_NAME}'s {@value BaseClassTypeInfoModel#STRUCTURE_NAME} array
	 * @return the BaseClassTypeInfo[] representation of
	 * the {@value BaseClassTypeInfoModel#STRUCTURE_NAME} array.
	 */
	public BaseClassTypeInfoModel[] getBases() {
		return bases;
	}

	public static BaseClassTypeInfoModel[] getBases(Program program, Address address) {
		return new BaseClassTypeInfoHelper(program, address).getBases();
	}

	/**
	 * Gets a list of the offsets of each derived class within this class
	 * @return a list containing the offsets of each derived class within this class
	 */
	public List<Long> getOffsets() {
		LongArrayList result = new LongArrayList();
		for (BaseClassTypeInfoModel base : bases) {
			if(!base.isVirtual()) {
				result.add((long) base.getOffset());
			}
		}
		if (Vtable.isValid(findVtable())) {
			List<Long> offsets = new ArrayList<>(getVtable().getPrefixes().get(0).getOffsets());
			if (offsets.size() > 0) {
				offsets.sort(null);
				offsets.remove(0);
				result.addAll(offsets);
			}
		}
		return result;
	}

	private static DataType getFlags(DataTypeManager dtm, CategoryPath path) {
		DataType integer = IntegerDataType.dataType.clone(dtm);
		EnumDataType flags =
			new EnumDataType(path, "__flags_masks", integer.getLength(), dtm);

		// Populate the flags mask
		flags.add(NON_DIAMOND_MASK_NAME, 1);
		flags.add(DIAMOND_MASK_NAME, 2);
		flags.add("non_public_base_mask", 4);
		flags.add("public_base_mask", 8);
		flags.add("__flags_unknown_mask", 16);
		return dtm.resolve(flags, KEEP_HANDLER);
	}

	/**
	 * Gets the value of this datatypes's __flags_mask
	 * @param buf the buffer containing the {@value #STRUCTURE_NAME}
	 * @return the value of this datatypes's __flags_mask
	 */
	public Flags getFlags(MemBuffer buf) {
		try {
			DataTypeComponent comp = getDataType().getComponent(FLAGS_ORDINAL);
			int offset = comp.getOffset();
			int length = comp.getLength();
			switch(buf.getVarLengthInt(offset, length)) {
				case 1:
					return Flags.NON_DIAMOND;
				case 2:
					return Flags.DIAMOND;
				case 4:
					return Flags.NON_PUBLIC;
				case 8:
					return Flags.PUBLIC;
				case 16:
				default:
					return Flags.UNKNOWN;
			}
		} catch (MemoryAccessException e) {
			return Flags.UNKNOWN;
		}
	}

	/**
	 * Gets the DataType representation of the __base_class_type_info array
	 * @return the DataType representation of the __base_class_type_info array
	 */
	public DataType getBaseArrayDataType() {
		DataType base = BaseClassTypeInfoModel.getDataType(program.getDataTypeManager());
		return new ArrayDataType(base, helper.count, base.getLength(), program.getDataTypeManager());
	}

	public static DataType getBaseArrayDataType(Data data) {
		DataType dt = data.getDataType();
		DataTypeManager dtm = dt.getDataTypeManager();
		if (!dt.equals(getDataType(dtm))) {
			return null;
		}
		try {
			int baseCount = data.getComponent(BASE_COUNT_ORDINAL).getInt(0);
			dt = BaseClassTypeInfoModel.getDataType(dtm);
			return new ArrayDataType(dt, baseCount, dt.getLength(), dtm);
		} catch (MemoryAccessException e) {
			// shouldn't occur
			throw new RuntimeException(e);
		}
	}

	private static class BaseClassTypeInfoHelper {

		private final Program program;
		private final Address address;
		private final int count;

		BaseClassTypeInfoHelper(Program program, Address address) {
			this.program = program;
			this.address = getArrayAddress(address);
			this.count = getBaseCount(address);
		}

		private Address getArrayAddress(Address addr) {
			Structure dt = getDataType(program.getDataTypeManager());
			DataTypeComponent arrayComponent = dt.getDefinedComponents()[dt.getNumDefinedComponents()-1];
			return addr.add(arrayComponent.getOffset());
		}

		private int getBaseCount(Address addr) {
			DataTypeManager dtm = program.getDataTypeManager();
			DataTypeComponent comp = getDataType(dtm).getComponent(BASE_COUNT_ORDINAL);
			try {
				MemBuffer buf = new MemoryBufferImpl(program.getMemory(), addr);
				return buf.getVarLengthInt(comp.getOffset(), comp.getLength());
			} catch (MemoryAccessException e) {
				Msg.error(VmiClassTypeInfoModel.class, e);
				return 0;
			}
		}

		private BaseClassTypeInfoModel[] getBases() {
			BaseClassTypeInfoModel[] bases = new BaseClassTypeInfoModel[count];
			Address currentAddress = address;
			int size =
				BaseClassTypeInfoModel.getDataType(program.getDataTypeManager()).getLength();
			for (int i = 0; i < count; i++) {
				bases[i] = new BaseClassTypeInfoModel(program, currentAddress);
				currentAddress = currentAddress.add(size);
			}
			return bases;
		}
	}
}

```

`src/main/java/ghidra/app/cmd/data/rtti/gcc/typeinfo/VmiOffsetFlagsModel.java`:

```java
package ghidra.app.cmd.data.rtti.gcc.typeinfo;

import ghidra.program.model.mem.MemBuffer;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.mem.MemoryBufferImpl;
import ghidra.app.cmd.data.rtti.gcc.GnuUtils;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.AbstractIntegerDataType;
import ghidra.program.model.data.DataOrganization;
import ghidra.program.model.data.DataType;
import ghidra.program.model.scalar.Scalar;
import ghidra.program.model.data.EnumDataType;
import ghidra.program.model.data.Structure;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.Enum;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;

import static ghidra.program.model.data.DataTypeConflictHandler.KEEP_HANDLER;

/**
 * Model for the {@value #DATA_TYPE_NAME} in the __base_class_type_info helper class
 */
public final class VmiOffsetFlagsModel {

	private static final String DATA_TYPE_NAME = "__offset_flags";
	private static final String DESCRIPTION = "Model for the vmi offset flags";

	static final int VIRTUAL_MASK = 1;
	static final int PUBLIC_MASK = 2;

	private Program program;
	private Address address;

	VmiOffsetFlagsModel(Program program, Address address) {
		this.program = program;
		this.address = address;
	}

	/**
	 * Checks if the virtual bit is set
	 * @return true if the virtual bit is set
	 */
	public boolean isVirtual() {
		MemBuffer buf = new MemoryBufferImpl(program.getMemory(), address);
		return isVirtual(buf, program.getDataTypeManager());
	}

	/**
	 * Checks if the public bit is set
	 * @return true if the public bit is set
	 */
	public boolean isPublic() {
		MemBuffer buf = new MemoryBufferImpl(program.getMemory(), address);
		return isPublic(buf, program.getDataTypeManager());
	}

	/**
	 * Gets the base class offset
	 * @return the base class offset
	 */
	public long getOffset() {
		MemoryBufferImpl buf = new MemoryBufferImpl(program.getMemory(), address);
		DataTypeManager dtm = program.getDataTypeManager();
		Structure struct = (Structure) getDataType(dtm);
		DataTypeComponent comp;
		if (dtm.getDataOrganization().isBigEndian()) {
			comp = struct.getComponent(0);
		} else {
			comp = struct.getComponent(1);
		}
		try {
			return buf.getBigInteger(comp.getOffset(), comp.getLength(), true).longValue();
		} catch (MemoryAccessException e) {
			return 0;
		}
	}

	static boolean isVirtual(MemBuffer buf, DataTypeManager dtm) {
		Structure struct = (Structure) getDataType(dtm);
		DataTypeComponent flagsComponent;
		if (dtm.getDataOrganization().isBigEndian()) {
			flagsComponent = struct.getComponent(1);
		} else {
			flagsComponent = struct.getComponent(0);
		}
		Enum flags = (Enum) flagsComponent.getDataType();
		Scalar value = (Scalar) flags.getValue(buf, flagsComponent.getDefaultSettings(), flags.getLength());
		return value.testBit(0);
	}

	static boolean isPublic(MemBuffer buf, DataTypeManager dtm) {
		Structure struct = (Structure) getDataType(dtm);
		DataTypeComponent flagsComponent;
		if (dtm.getDataOrganization().isBigEndian()) {
			flagsComponent = struct.getComponent(1);
		} else {
			flagsComponent = struct.getComponent(0);
		}
		Enum flags = (Enum) flagsComponent.getDataType();
		Scalar value = (Scalar) flags.getValue(buf, flagsComponent.getDefaultSettings(), flags.getLength());
		return value.testBit(1);
	}

	static DataType getDataType(DataTypeManager dtm) {
		StructureDataType struct = new StructureDataType(VmiClassTypeInfoModel.SUB_PATH, DATA_TYPE_NAME, 0, dtm);
		if (dtm.getDataOrganization().isBigEndian()) {
			struct.add(getOffsetFlags(dtm), "__offset", null);
			struct.add(getFlags(dtm), "__flags", null);
		} else {
			struct.add(getFlags(dtm), "__flags", null);
			struct.add(getOffsetFlags(dtm), "__offset", null);
		}
		struct.setPackingEnabled(true);
		struct.setToDefaultAligned();
		struct.setDescription(DESCRIPTION);
		return dtm.resolve(struct, KEEP_HANDLER);
	}

	private static DataType getOffsetFlags(DataTypeManager dtm) {
		DataOrganization org = dtm.getDataOrganization();
		int size = GnuUtils.isLLP64(dtm) ? (org.getLongLongSize())
			: (org.getLongSize());
		return AbstractIntegerDataType.getSignedDataType(size - 1, dtm);
	}

	private static DataType getFlags(DataTypeManager dtm) {
		EnumDataType flags =
			new EnumDataType(VmiClassTypeInfoModel.SUB_PATH, "offset_flags", 1, dtm);
		flags.add("__virtual_mask", VIRTUAL_MASK);
		flags.add("__public_mask", PUBLIC_MASK);
		// the offset shift parameter is meaningless here
		return dtm.resolve(flags, KEEP_HANDLER);
	}
}

```

`src/main/java/ghidra/app/plugin/core/decompile/actions/AbstractNonPackageDecompilerAction.java`:

```java
package ghidra.app.plugin.core.decompile.actions;

public abstract class AbstractNonPackageDecompilerAction extends AbstractDecompilerAction {

	protected AbstractNonPackageDecompilerAction(String name) {
		super(name);
	}

}

```

`src/main/java/ghidra/app/plugin/prototype/GccRttiAnalyzer.java`:

```java
package ghidra.app.plugin.prototype;

import java.util.*;

import ghidra.util.task.CancelOnlyWrappingTaskMonitor;
import ghidra.util.task.TaskMonitor;

import ghidra.framework.options.Options;
import ghidra.app.util.importer.MessageLog;
import ghidra.docking.settings.SettingsDefinition;

import cppclassanalyzer.data.manager.ItaniumAbiClassTypeInfoManager;
import cppclassanalyzer.scanner.RttiScanner;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSet;
import ghidra.program.util.ProgramMemoryUtil;
import ghidra.program.model.mem.Memory;
import ghidra.program.model.reloc.Relocation;
import ghidra.program.model.symbol.*;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.*;
import ghidra.app.plugin.core.analysis.ReferenceAddressPair;
import ghidra.app.services.*;
import ghidra.util.Msg;
import ghidra.util.exception.CancelledException;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.*;
import ghidra.program.model.address.AddressSetView;
import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.cmd.data.rtti.gcc.*;

import static ghidra.app.cmd.data.rtti.GnuVtable.PURE_VIRTUAL_FUNCTION_NAME;
import static ghidra.app.util.datatype.microsoft.MSDataTypeUtils.getAbsoluteAddress;

public class GccRttiAnalyzer extends AbstractAnalyzer {

	public static final String ANALYZER_NAME = "GCC RTTI Analyzer";
	private static final String DESCRIPTION =
		"This analyzer finds and creates all of the RTTI metadata structures and their associated vtables.";

	private static final String OPTION_FUNDAMENTAL_NAME = "Find Fundamental Types";
	private static final boolean OPTION_DEFAULT_FUNDAMENTAL = false;
	private static final String OPTION_FUNDAMENTAL_DESCRIPTION =
		"Turn on to scan for __fundamental_type_info and its derivatives.";

	private static final String OPTION_BOOKMARKS_NAME = "Create Bookmarks";
	private static final boolean OPTION_DEFAULT_BOOKMARKS = true;
	private static final String OPTION_BOOKMARKS_DESCRIPTION =
		"Turn on to create bookmarks at located RTTI metadata";

	private boolean fundamentalOption;
	private boolean createBookmarks;

	// The only one excluded is BaseClassTypeInfoModel
	private static final List<String> CLASS_TYPESTRINGS = List.of(
		ClassTypeInfoModel.ID_STRING,
		SiClassTypeInfoModel.ID_STRING,
		VmiClassTypeInfoModel.ID_STRING
	);

	private Program program;
	private BookmarkManager bMan;
	private TaskMonitor monitor;
	private MessageLog log;
	private CancelOnlyWrappingTaskMonitor dummy;
	private Set<Relocation> relocations;
	private ItaniumAbiClassTypeInfoManager manager;
	private AddressSet set;

	// if a typename contains this, vftable components index >= 2 point to __cxa_pure_virtual
	private static final String PURE_VIRTUAL_CONTAINING_STRING = "abstract_base";

	/**
	 * Constructs an RttiAnalyzer.
	 */
	public GccRttiAnalyzer() {
		super(ANALYZER_NAME, DESCRIPTION, AnalyzerType.BYTE_ANALYZER);
		setSupportsOneTimeAnalysis();
		setPriority(AnalysisPriority.DATA_TYPE_PROPOGATION.before().before());
		setDefaultEnablement(true);
		setPrototype();
	}

	@Override
	public boolean canAnalyze(Program program) {
		if (CppClassAnalyzerUtils.getManager(program) != null) {
			return GnuUtils.isGnuCompiler(program);
		}
		return false;
	}

	@Override
	public boolean added(Program program, AddressSetView memory, TaskMonitor monitor, MessageLog log)
		throws CancelledException {
			this.program = program;
			this.bMan = program.getBookmarkManager();
			this.set = new AddressSet();
			this.monitor = monitor;
			this.dummy = new CancelOnlyWrappingTaskMonitor(monitor);
			this.log = log;
			this.manager =
				(ItaniumAbiClassTypeInfoManager) CppClassAnalyzerUtils.getManager(program);
			if (this.manager == null) {
				return false;
			}
			try {
				RttiScanner scanner = RttiScanner.getScanner(program);
				if (fundamentalOption) {
					for (Address addr : scanner.scanFundamentals(log, monitor)) {
						monitor.checkCanceled();
						if (addr == null) {
							String name = scanner.getClass().getName();
							Msg.warn(this, name + ".scanFundamentals returned a null address");
							continue;
						}
						TypeInfo type = manager.getTypeInfo(addr);
						applyTypeInfo(type);
					}
				}
				scanner.scan(log, monitor);
				monitor.initialize(manager.getTypeCount());
				monitor.setMessage("Creating ClassTypeInfo's");
				for (ClassTypeInfo type : manager.getTypes()) {
					monitor.checkCanceled();
					if (applyTypeInfo(type)) {
						this.set.add(type.getAddress());
					}
					monitor.incrementProgress(1);
				}
				createVtables();
				createVtts();
				return true;
			} catch (CancelledException e) {
				throw e;
			} catch (Exception e) {
				log.appendMsg("Ghidra-Cpp-Class-Analyzer", e.getMessage());
				log.appendException(e);
				return false;
			}
	}

	@Override
	public boolean removed(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
			throws CancelledException {
		relocations.clear();
		relocations = null;
		// this is the default result
		return false;
	}

	private void addReferences(AddressSet addresses) throws CancelledException {
		if (addresses.isEmpty()) {
			return;
		}
		Memory mem = program.getMemory();
		ReferenceManager refMan = program.getReferenceManager();
		List<ReferenceAddressPair> refList = new LinkedList<>();
		ProgramMemoryUtil.loadDirectReferenceList(
			program, program.getDefaultPointerSize(), addresses.getMinAddress(),
			addresses, refList, dummy);
		monitor.setProgress(monitor.getMaximum());
		for (ReferenceAddressPair ref : refList) {
			monitor.checkCanceled();
			if (CppClassAnalyzerUtils.isDataBlock(mem.getBlock(ref.getSource()))) {
				refMan.addMemoryReference(
					ref.getSource(), ref.getDestination(),
					RefType.DATA, SourceType.ANALYSIS, 0);
			}
		}
	}

	private boolean checkTableAddresses(Function[][] functionTables) {
		if (functionTables.length == 0 || functionTables[0].length < 3) {
			return false;
		}
		if (functionTables[0].length >= 3) {
			// sanity check. This is only possible for __cxa_pure_virtual
			if (functionTables[0][2] == null || functionTables[0][3] == null) {
				return false;
			}
			return functionTables[0][2].equals(functionTables[0][3]);
		}
		return false;
	}

	private static boolean isPureVirtualType(ClassTypeInfo type) {
		return type.getTypeName().contains(PURE_VIRTUAL_CONTAINING_STRING);
	}

	private Function getPureVirtualFunction() throws CancelledException {
		SymbolTable table = program.getSymbolTable();
		for (Symbol symbol : table.getSymbols(PURE_VIRTUAL_FUNCTION_NAME)) {
			if (symbol.getSymbolType() == SymbolType.FUNCTION) {
				return (Function) symbol.getObject();
			}
		}
		for (ClassTypeInfo type : manager.getTypes()) {
			monitor.checkCanceled();
			if (isPureVirtualType(type)) {
				try {
					Vtable vtable = type.findVtable(dummy);
					if (Vtable.isValid(vtable)) {
						Function[][] ftables = vtable.getFunctionTables();
						if (checkTableAddresses(ftables)) {
							return ftables[0][2];
						}
					}
				} catch (Exception e) {
				}
			}
		}
		return null;
	}

	private void findAndCreatePureVirtualFunction() throws Exception {
		monitor.setMessage("Locating "+PURE_VIRTUAL_FUNCTION_NAME);
		Function pureVirtual = getPureVirtualFunction();
		if (pureVirtual == null) {
			return;
		}
		pureVirtual.setName(PURE_VIRTUAL_FUNCTION_NAME, SourceType.IMPORTED);
		pureVirtual.setNoReturn(true);
		pureVirtual.setReturnType(VoidDataType.dataType, SourceType.IMPORTED);
		try {
			String cc = GenericCallingConvention.stdcall.getDeclarationName();
			pureVirtual.setCallingConvention(cc);
		} catch (Exception e) {
			// compiler spec doesn't have __stdcall
		}
	}

	private void createVtable(GnuVtable vtable) throws Exception {
		if (vtable == Vtable.NO_VTABLE) {
			return;
		}
		CreateVtableBackgroundCmd vtableCmd = new CreateVtableBackgroundCmd(vtable);
		vtableCmd.applyTo(program, dummy);
		markDataAsConstant(vtable.getAddress());
		if (createBookmarks) {
			bMan.setBookmark(
				vtable.getAddress(), BookmarkType.ANALYSIS,
				BookmarkType.ANALYSIS, "vtable located");
		}
		if (!vtable.getTypeInfo().isAbstract()) {
			for (Address tableAddress : vtable.getTableAddresses()) {
				markDataAsConstant(tableAddress);
			}
		}
	}

	public final void markDataAsConstant(Address address) {
		Data data = program.getListing().getDataAt(address);
		if (data == null) {
			return;
		}
		SettingsDefinition[] settings = data.getDataType().getSettingsDefinitions();
		for (SettingsDefinition setting : settings) {
			if (setting instanceof MutabilitySettingsDefinition) {
				MutabilitySettingsDefinition mutabilitySetting =
					(MutabilitySettingsDefinition) setting;
				mutabilitySetting.setChoice(data, MutabilitySettingsDefinition.CONSTANT);
			}
		}
	}

	private void createVtts() throws Exception {
		for (Vtable vtable : manager.getVtables()) {
			for (Address addr : vtable.getTableAddresses()) {
				set.add(addr);
			}
		}
		monitor.setMessage("Creating Vtable References");
		addReferences(set);
		set.clear();
		monitor.initialize(manager.getVtableCount());
		monitor.setMessage("Locating VTTs");
		for (Vtable vtable : manager.getVtables()) {
			monitor.checkCanceled();
			try {
				locateVTT((GnuVtable) vtable);
			} catch (Exception e) {
				log.appendException(e);
			}
			monitor.incrementProgress(1);
		}
	}

	private void locateVTT(GnuVtable vtable) throws Exception {
		ClassTypeInfo type = vtable.getTypeInfo();
		if (!CLASS_TYPESTRINGS.contains(type.getTypeName())) {
			VttModel vtt = VtableUtils.getVttModel(program, vtable);
			if (vtt.isValid()) {
				createVtt(type, vtt);
			}
		}
	}

	private void createVtt(ClassTypeInfo type, VttModel vtt) {
		CreateVttBackgroundCmd cmd =
			new CreateVttBackgroundCmd(vtt, type);
		cmd.applyTo(program, dummy);
		markDataAsConstant(vtt.getAddress());
		if (createBookmarks) {
			bMan.setBookmark(
				vtt.getAddress(), BookmarkType.ANALYSIS,
				BookmarkType.ANALYSIS, "vtt located");
			for (GnuVtable vtable : vtt.getConstructionVtableModels()) {
				bMan.setBookmark(
					vtable.getAddress(), BookmarkType.ANALYSIS,
					BookmarkType.ANALYSIS, "construction vtable located");
			}
		}
	}

	private void createVtables() throws Exception {
		findAndCreatePureVirtualFunction();
		monitor.setMessage("Creating ClassTypeInfo References");
		addReferences(set);
		set.clear();
		manager.findVtables(monitor, log);
		monitor.initialize(manager.getVtableCount());
		monitor.setMessage("Creating vtables");
		for (Vtable vtable : manager.getVtables()) {
			monitor.checkCanceled();
			try {
				createVtable((GnuVtable) vtable);
			} catch (Exception e) {
				log.appendMsg("Unable to create vtable for "+vtable.getTypeInfo().getFullName());
			}
			monitor.incrementProgress(1);
		}
	}

	private boolean applyTypeInfo(TypeInfo type) {
		if (type.getAddress() == null) {
			Msg.debug(this, "Attempted to create typeinfo with null address");
			return false;
		}
		CreateTypeInfoBackgroundCmd cmd = new CreateTypeInfoBackgroundCmd(type);
		if (!cmd.applyTo(program, dummy)) {
			return false;
		}
		markDataAsConstant(type.getAddress());
		if (createBookmarks) {
			Address typenameAddress = getAbsoluteAddress(
				program, type.getAddress().add(program.getDefaultPointerSize()));
			bMan.setBookmark(
				type.getAddress(), BookmarkType.ANALYSIS,
				BookmarkType.ANALYSIS, "typeinfo located");
			bMan.setBookmark(
					typenameAddress, BookmarkType.ANALYSIS,
					BookmarkType.ANALYSIS, "typeinfo-name located");
		}
		return true;
	}

	@Override
	public void optionsChanged(Options options, Program program) {
		super.optionsChanged(options, program);
		options.registerOption(OPTION_FUNDAMENTAL_NAME, OPTION_DEFAULT_FUNDAMENTAL, null,
			OPTION_FUNDAMENTAL_DESCRIPTION);
		options.registerOption(OPTION_BOOKMARKS_NAME, OPTION_DEFAULT_BOOKMARKS, null,
			OPTION_BOOKMARKS_DESCRIPTION);
		fundamentalOption =
			options.getBoolean(OPTION_FUNDAMENTAL_NAME, OPTION_DEFAULT_FUNDAMENTAL);
		createBookmarks =
			options.getBoolean(OPTION_BOOKMARKS_NAME, OPTION_DEFAULT_BOOKMARKS);
	}
}

```

`src/main/resources/images/cpp_logo.svg`:

```svg
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 16.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="306px" height="344.35px" viewBox="0 0 306 344.35" enable-background="new 0 0 306 344.35" xml:space="preserve">
<path fill="#00599C" d="M302.107,258.262c2.401-4.159,3.893-8.845,3.893-13.053V99.14c0-4.208-1.49-8.893-3.892-13.052L153,172.175
	L302.107,258.262z"/>
<path fill="#004482" d="M166.25,341.193l126.5-73.034c3.644-2.104,6.956-5.737,9.357-9.897L153,172.175L3.893,258.263
	c2.401,4.159,5.714,7.793,9.357,9.896l126.5,73.034C147.037,345.401,158.963,345.401,166.25,341.193z"/>
<path fill="#659AD2" d="M302.108,86.087c-2.402-4.16-5.715-7.793-9.358-9.897L166.25,3.156c-7.287-4.208-19.213-4.208-26.5,0
	L13.25,76.19C5.962,80.397,0,90.725,0,99.14v146.069c0,4.208,1.491,8.894,3.893,13.053L153,172.175L302.108,86.087z"/>
<g>
	<path fill="#FFFFFF" d="M153,274.175c-56.243,0-102-45.757-102-102s45.757-102,102-102c36.292,0,70.139,19.53,88.331,50.968
		l-44.143,25.544c-9.105-15.736-26.038-25.512-44.188-25.512c-28.122,0-51,22.878-51,51c0,28.121,22.878,51,51,51
		c18.152,0,35.085-9.776,44.191-25.515l44.143,25.543C223.142,254.644,189.294,274.175,153,274.175z"/>
</g>
<g>
	<polygon fill="#FFFFFF" points="255,166.508 243.666,166.508 243.666,155.175 232.334,155.175 232.334,166.508 221,166.508 
		221,177.841 232.334,177.841 232.334,189.175 243.666,189.175 243.666,177.841 255,177.841 	"/>
</g>
<g>
	<polygon fill="#FFFFFF" points="297.5,166.508 286.166,166.508 286.166,155.175 274.834,155.175 274.834,166.508 263.5,166.508 
		263.5,177.841 274.834,177.841 274.834,189.175 286.166,189.175 286.166,177.841 297.5,177.841 	"/>
</g>
</svg>

```

`src/test/java/ghidra/app/cmd/data/rtti/gcc/ClassBuilderTest.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import ghidra.app.cmd.data.rtti.ClassTypeInfo;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.app.util.NamespaceUtils;
import ghidra.app.util.SymbolPath;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.GhidraClass;
import ghidra.program.model.symbol.Namespace;

import org.junit.Test;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import generic.json.JSONParser;
import generic.json.JSONToken;
import resources.ResourceManager;

public final class ClassBuilderTest extends X86GccRttiTest {

    private static final String SERIALIZED_FILE = "cpp_classes.json";

    private static String getSerializedData() throws IOException {
        try (InputStream stream = ResourceManager.getResourceAsStream(SERIALIZED_FILE)) {
            InputStreamReader streamReader = new InputStreamReader(stream);
            BufferedReader reader = new BufferedReader(streamReader);
            return reader.lines().collect(Collectors.joining());
        }
    }

    @SuppressWarnings("unchecked")
    private static List<SerializedNamespace> parseData() throws Exception {
        String data = getSerializedData();
        JSONParser parser = new JSONParser();
        LinkedList<JSONToken> tokens = new LinkedList<>();
        switch (parser.parse(data.toCharArray(), tokens)) {
            case JSMN_ERROR_INVAL:
                throw new Exception("JSON contains invalid character");
            case JSMN_ERROR_NOMEM:
                throw new Exception("Not enough tokens");
            case JSMN_ERROR_PART:
                throw new Exception("Malformed or missing JSON data");
            case JSMN_SUCCESS:
                break;
        }
        Map<String, Object> namespaces =
            (Map<String, Object>) parser.convert(data.toCharArray(), tokens);
        return namespaces.entrySet()
                .stream()
                .map(SerializedNamespace::new)
                .collect(Collectors.toList());
    }

    @Test
    public void test() throws Exception {
        initialize();
        ProgramClassTypeInfoManager manager = getManager();
        List<SerializedNamespace> namespaces = parseData();
        runGccRttiAnalyzer(program);
        runClassAnalyzer(program);
        for (SerializedNamespace sns : namespaces) {
            for (SerializedClass clazz : sns.getClasses()) {
                Namespace ns = NamespaceUtils.getNonFunctionNamespace(program, clazz.getPath());
                assert ns instanceof GhidraClass;
                ClassTypeInfo type = manager.getType((GhidraClass) ns);
                clazz.assertEquivalent(type);
            }
        }
    }
	
	@Test
	public void vtableStructureTest() throws Exception {
		initialize();
		ProgramClassTypeInfoManager manager = getManager();
        runGccRttiAnalyzer(program);
        runClassAnalyzer(program);
		for (Vtable vtable : manager.getVtables()) {
            Function[][] table = vtable.getFunctionTables();
			if (table.length == 0 || table[0].length == 0) {
				continue;
			}
			ClassTypeInfo type = vtable.getTypeInfo();
			Pointer ptr = (Pointer) ClassTypeInfoUtils.getVptrDataType(program, type);
			Structure struct = (Structure) ptr.getDataType();
			assert struct.getNumComponents() > 0 : struct.getDataTypePath().toString() + " is empty";
		}
	}

    private static class SerializedNamespace {

        private final String name;
        private final List<SerializedClass> classes;

        @SuppressWarnings("unchecked")
        SerializedNamespace(Map.Entry<String, Object> data) {
            this.name = data.getKey();
            Map<String, Object> classData = (Map<String, Object>) data.getValue();
            SymbolPath path = new SymbolPath(name);
            this.classes = classData.entrySet()
                    .stream()
                    .map(e -> new SerializedClass(path, e))
                    .collect(Collectors.toUnmodifiableList());
        }

        List<SerializedClass> getClasses() {
            return classes;
        }
    }

    private static class SerializedClass {

        private final SymbolPath path;
        private final List<SerializedClassMember> members;

        @SuppressWarnings("unchecked")
        SerializedClass(SymbolPath parent, Map.Entry<String, Object> data) {
            this.path = new SymbolPath(parent, data.getKey());
            Object value = data.getValue();
            if (value == null) {
                this.members = Collections.emptyList();
            } else {
                Map<String, Object> classData = (Map<String, Object>) value;
                if (classData.containsKey("offsets")) {
                    Map<String, String> memberData =
                        (Map<String, String>) classData.get("offsets");
                    this.members = memberData.entrySet()
                            .stream()
                            .map(SerializedClassMember::new)
                            .collect(Collectors.toUnmodifiableList());
                } else {
                    this.members = Collections.emptyList();
                }
            }
        }

        SymbolPath getPath() {
            return path;
        }

        void assertEquivalent(ClassTypeInfo type) throws Exception {
            String name = type.getGhidraClass().getName(true);
            Structure struct = type.getClassDataType();
            for (SerializedClassMember member : members) {
                if (!member.getFieldName().startsWith("super_")) {
                    // only the super classes would be defined
                    continue;
                }
                DataTypeComponent comp = struct.getComponentAt(member.getOffset());
                assert comp != null
                        : String.format("%s is missing %s at offset %d\n%s",
                            name, member.getFieldName(), member.getOffset(), struct);
                String fieldName = comp.getFieldName();
                assert fieldName != null && fieldName.equals(member.getFieldName())
                        : String.format(
                            "%s at offset %d does not match the expected member %s in %s\n%s",
                            fieldName, member.getOffset(), member.getFieldName(), name, struct);
            }
        }

        @Override
        public String toString() {
            return path.toString();
        }
    }

    private static class SerializedClassMember {

        private final int offset;
        private final String name;

        SerializedClassMember(Map.Entry<String, String> data) {
            this.name = data.getKey();
            this.offset = Integer.parseInt(data.getValue());
        }

        String getFieldName() {
            return name;
        }

        int getOffset() {
            return offset;
        }

        @Override
        public String toString() {
            return name;
        }

    }

    
}

```

`src/test/java/ghidra/app/cmd/data/rtti/gcc/GenericGccRttiTest.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import ghidra.app.cmd.data.rtti.gcc.builder.AbstractTypeInfoProgramBuilder;
import ghidra.app.plugin.core.analysis.AutoAnalysisManager;
import ghidra.app.plugin.core.analysis.OneShotAnalysisCommand;
import ghidra.app.plugin.prototype.GccRttiAnalyzer;
import ghidra.app.services.Analyzer;
import ghidra.program.model.listing.Program;
import ghidra.test.AbstractGhidraHeadlessIntegrationTest;

import cppclassanalyzer.analysis.gcc.GccCppClassAnalyzer;
import cppclassanalyzer.data.ProgramClassTypeInfoManager;
import cppclassanalyzer.utils.CppClassAnalyzerUtils;

public abstract class GenericGccRttiTest extends AbstractGhidraHeadlessIntegrationTest {

	protected AbstractTypeInfoProgramBuilder builder;
	protected Program program;

	protected GenericGccRttiTest() {
	}

	protected abstract AbstractTypeInfoProgramBuilder getProgramBuilder() throws Exception;

	protected final Program getProgram() throws Exception {
		return builder.getProgram();
	}

	protected void initialize() throws Exception {
		builder = getProgramBuilder();
		builder.init();
		builder.startTransaction();
		program = builder.getProgram();
	}

	public final void tearDown() throws Exception {
		builder.endTransaction();
		builder.dispose();
	}

	protected final ProgramClassTypeInfoManager getManager() {
		return CppClassAnalyzerUtils.getManager(program);
	}

	protected final void runGccRttiAnalyzer(Program program) throws Exception {
		runAnalyzer(program, GccRttiAnalyzer.ANALYZER_NAME);
	}

	protected final void runClassAnalyzer(Program program) throws Exception {
		runAnalyzer(program, GccCppClassAnalyzer.ANALYZER_NAME);
	}

	private void runAnalyzer(Program program, String name) throws Exception {
		AutoAnalysisManager manager = AutoAnalysisManager.getAnalysisManager(program);
		Analyzer analyzer = manager.getAnalyzer(name);
		OneShotAnalysisCommand cmd = new OneShotAnalysisCommand(
			analyzer, program.getMemory(), manager.getMessageLog());
		cmd.applyTo(program);
	}
}

```

`src/test/java/ghidra/app/cmd/data/rtti/gcc/Ppc64GccRttiTest.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import ghidra.app.cmd.data.rtti.gcc.builder.Ppc64TypeInfoProgramBuilder;

public abstract class Ppc64GccRttiTest extends GenericGccRttiTest {

	protected Ppc64GccRttiTest() {
		super();
	}


	@Override
    protected Ppc64TypeInfoProgramBuilder getProgramBuilder() throws Exception {
        return new Ppc64TypeInfoProgramBuilder();
    }
}

```

`src/test/java/ghidra/app/cmd/data/rtti/gcc/Ppc64VtableModelTest.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import ghidra.app.cmd.data.rtti.gcc.builder.Ppc64TypeInfoProgramBuilder;

import org.junit.Test;

public final class Ppc64VtableModelTest extends VtableModelTest {

	@Override
    protected Ppc64TypeInfoProgramBuilder getProgramBuilder() throws Exception {
        return new Ppc64TypeInfoProgramBuilder();
    }

    @Test
    public void locationTest() throws Exception {
        doLocationTest();
    }

    @Test
    public void validationTest() throws Exception {
        doValidationTest();
    }
	
}

```

`src/test/java/ghidra/app/cmd/data/rtti/gcc/TypeInfoTest.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.function.Predicate;

import ghidra.app.cmd.data.rtti.TypeInfo;
import ghidra.app.cmd.data.rtti.gcc.typeinfo.FundamentalTypeInfoModel;

import org.junit.Test;

public class TypeInfoTest extends X86GccRttiTest {

	private static void validate(TypeInfo type) {
		assert type.getDataType() != null :
			String.format("%s of type %s at %s is not valid",
				type.getName(), type.getAddress(), type.getClass().getSimpleName());
	}

	@Test
	public void validationTest() throws Exception {
		initialize();
		builder.getTypeInfoStream()
			.filter(Predicate.not(FundamentalTypeInfoModel.class::isInstance))
			.forEach(TypeInfoTest::validate);
	}
}

```

`src/test/java/ghidra/app/cmd/data/rtti/gcc/VtableModelTest.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.program.model.address.Address;

import cppclassanalyzer.data.ProgramClassTypeInfoManager;

public abstract class VtableModelTest extends GenericGccRttiTest {

	protected final void doValidationTest() throws Exception {
		initialize();
		List<GnuVtable> vtables = builder.getVtableList();
		for (GnuVtable vtable : vtables) {
			assert Vtable.isValid(vtable) : vtable.getTypeInfo().getNamespace().getName(true);
		}
		ProgramClassTypeInfoManager manager = getManager();
		vtables.forEach(manager::resolve);
	}

	protected final void doLocationTest() throws Exception {
		initialize();
		runGccRttiAnalyzer(program);
		Set<Address> addresses = builder.getVtableStream()
			.map(Vtable::getAddress)
			.collect(Collectors.toSet());
		for (Vtable vtable : getManager().getVtables()) {
			assert addresses.remove(vtable.getAddress())
				: String.format("Vtable for %s was incorrectly located. It should not be at %s",
					vtable.getTypeInfo().getName(), vtable.getAddress());
		}
		assert addresses.isEmpty() : Integer.toString(addresses.size())
			+" vtables were not located";
	}
}

```

`src/test/java/ghidra/app/cmd/data/rtti/gcc/VttModelTest.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import java.util.Set;
import java.util.stream.Collectors;

import ghidra.app.cmd.data.rtti.GnuVtable;
import ghidra.app.cmd.data.rtti.Vtable;
import ghidra.program.model.address.Address;

import org.junit.Test;

public class VttModelTest extends X86GccRttiTest {

	@Test
	public void validationTest() throws Exception {
		initialize();
		for (VttModel vtt : builder.getVttList()) {
			assert vtt.isValid();
		}
	}

	@Test
	public void locationTest() throws Exception {
		initialize();
		runGccRttiAnalyzer(program);
		Set<Address> addresses = builder.getVttStream()
			.map(VttModel::getAddress)
			.collect(Collectors.toSet());
		for (Vtable vtable : getManager().getVtables()) {
			VttModel vtt = VtableUtils.getVttModel(program, (GnuVtable) vtable);
			if (vtt.isValid()) {
				assert addresses.remove(vtt.getAddress())
					: String.format("%s at %s is at the wrong address",
						vtt, vtt.getAddress());
			}
		}
		assert addresses.isEmpty() : Integer.toString(addresses.size())
			+ " vtts were not located";
	}
}

```

`src/test/java/ghidra/app/cmd/data/rtti/gcc/X86GccRttiTest.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import ghidra.app.cmd.data.rtti.gcc.builder.X86TypeInfoProgramBuilder;

public abstract class X86GccRttiTest extends GenericGccRttiTest {
	
	protected X86GccRttiTest() {
		super();
	}


	@Override
    protected X86TypeInfoProgramBuilder getProgramBuilder() throws Exception {
        return new X86TypeInfoProgramBuilder();
    }
}

```

`src/test/java/ghidra/app/cmd/data/rtti/gcc/X86VtableModelTest.java`:

```java
package ghidra.app.cmd.data.rtti.gcc;

import ghidra.app.cmd.data.rtti.gcc.builder.X86TypeInfoProgramBuilder;

import org.junit.Test;

public final class X86VtableModelTest extends VtableModelTest {

	@Override
    protected X86TypeInfoProgramBuilder getProgramBuilder() throws Exception {
        return new X86TypeInfoProgramBuilder();
    }

    @Test
    public void locationTest() throws Exception {
        doLocationTest();
    }

    @Test
    public void validationTest() throws Exception {
        doValidationTest();
    }
	
}

```

`src/test/resources/cpp_classes.json`:

```json
{
    "abstract_inheritance": {
        "F": {
            "size": "16",
            "offsets": {
                "f_data": "8"
            }
        },
        "G": {
            "size": "32",
            "offsets": {
                "g_data": "8",
                "super_F": "16"
            }
        },
        "H": {
            "size": "16",
            "offsets": {
                "h_data": "12",
                "super_F": "0"
            }
        },
        "I": {
            "size": "56",
            "offsets": {
                "i_data": "32",
                "super_G": "0",
                "super_H": "16"
            }
        }
    },
    "diamond": {
        "A": {
            "size": "16",
            "offsets": {
                "a_data": "8",
                "hidden_a_data": "12"
            }
        },
        "B": {
            "size": "32",
            "offsets": {
                "b_data": "8",
                "super_A": "16"
            }
        },
        "C": {
            "size": "32",
            "offsets": {
                "c_data": "8",
                "super_A": "16"
            }
        },
        "D": {
            "size": "48",
            "offsets": {
                "d_data": "28",
                "super_B": "0",
                "super_C": "16",
                "super_A": "32"
            }
        }
    },
    "large_inheritance": {
        "A": {
            "size": "16",
            "offsets": {
                "a_data": "8",
                "hidden_a_data": "12"
            }
        },
        "B": {
            "size": "32",
            "offsets": {
                "b_data": "8",
                "super_A": "16"
            }
        },
        "C": {
            "size": "32",
            "offsets": {
                "c_data": "8",
                "super_A": "16"
            }
        },
        "D": {
            "size": "48",
            "offsets": {
                "d_data": "28",
                "super_B": "0",
                "super_C": "16",
                "super_A": "32"
            }
        },
        "U": {
            "size": "16",
            "offsets": {
                "u_data": "8"
            }
        },
        "V": {
            "size": "88",
            "offsets": {
                "v_data": "64",
                "super_Z": "0",
                "super_Y": "16",
                "super_X": "32",
                "super_A": "48"
            }
        },
        "W": {
            "size": "112",
            "offsets": {
                "w_data": "44",
                "super_C": "96",
                "super_A": "64",
                "super_B": "48",
                "super_Z": "16",
                "super_Y": "0",
                "super_X": "32",
                "super_U": "80"
            }
        },
        "X": {
            "size": "16",
            "offsets": {
                "x_data": "8"
            }
        },
        "Y": {
            "size": "32",
            "offsets": {
                "y_data": "8",
                "super_U": "16"
            }
        },
        "Z": {
            "size": "16",
            "offsets": {
                "z_data": "8"
            }
        }
    },
    "non_diamond": {
        "A": {
            "size": "16",
            "offsets": {
                "a_data": "8",
                "hidden_a_data": "12"
            }
        },
        "B": {
            "size": "32",
            "offsets": {
                "b_data": "8",
                "super_A": "16"
            }
        },
        "C": {
            "size": "24",
            "offsets": {
                "c_data": "16",
                "super_A": "0"
            }
        },
        "D": {
            "size": "56",
            "offsets": {
                "d_data": "36",
                "super_A": "40",
                "super_B": "0"
            }
        }
    },
    "no_virtual_functions": {
        "A": {
            "size": "4",
            "offsets": {
                "a_data": "0"
            }
        },
        "B": {
            "size": "16",
            "offsets": {
                "b_data": "8",
                "super_A": "12"
            }
        },
        "C": {
            "size": "32",
            "offsets": {
                "c_data": "8",
                "super_A": "28",
                "super_B": "16"
            }
        },
        "D": {
            "size": "24",
            "offsets": {
                "d_data": "12",
                "super_A": "16",
                "super_B": "0"
            }
        }
    }
}

```

`src/test/resources/defaultTools/TestCodeBrowser.tool`:

```tool
<?xml version="1.0" encoding="UTF-8"?>
<!--
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-->
<TOOL_CONFIG CONFIG_NAME="NO_LONGER_USED">
    <SUPPORTED_DATA_TYPE CLASS_NAME="ghidra.program.model.listing.DataTypeArchive" />
    <SUPPORTED_DATA_TYPE CLASS_NAME="ghidra.program.model.listing.Program" />
    <ICON LOCATION="greenDragon24.png" />
    <TOOL TOOL_NAME="TestCodeBrowser" INSTANCE_NAME="">
        <OPTIONS />
        <PACKAGE NAME="Ghidra Core" />
        <ROOT_NODE X_POS="400" Y_POS="400" WIDTH="1200" HEIGHT="600" EX_STATE="0" FOCUSED_OWNER="CodeBrowserPlugin" FOCUSED_NAME="Listing" FOCUSED_TITLE="Listing: ">
            <SPLIT_NODE WIDTH="100" HEIGHT="100" DIVIDER_LOCATION="0" ORIENTATION="VERTICAL">
                <SPLIT_NODE WIDTH="1621" HEIGHT="816" DIVIDER_LOCATION="148" ORIENTATION="VERTICAL">
                    <COMPONENT_NODE TOP_INFO="0">
                        <COMPONENT_INFO NAME="Entropy" OWNER="EntropyPlugin" TITLE="Entropy" ACTIVE="false" GROUP="Header" INSTANCE_ID="3207819926581772885" />
                        <COMPONENT_INFO NAME="Overview" OWNER="OverviewPlugin" TITLE="Overview" ACTIVE="false" GROUP="Header" INSTANCE_ID="3207819926581772883" />
                    </COMPONENT_NODE>
                    <SPLIT_NODE WIDTH="1200" HEIGHT="491" DIVIDER_LOCATION="143" ORIENTATION="HORIZONTAL">
                        <SPLIT_NODE WIDTH="171" HEIGHT="491" DIVIDER_LOCATION="640" ORIENTATION="VERTICAL">
                            <SPLIT_NODE WIDTH="171" HEIGHT="312" DIVIDER_LOCATION="502" ORIENTATION="VERTICAL">
                                <COMPONENT_NODE TOP_INFO="0">
                                    <COMPONENT_INFO NAME="Program Tree" OWNER="ProgramTreePlugin" TITLE="Program Trees" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758150439853" />
                                </COMPONENT_NODE>
                                <COMPONENT_NODE TOP_INFO="0">
                                    <COMPONENT_INFO NAME="Symbol Tree" OWNER="SymbolTreePlugin" TITLE="Symbol Tree" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479669854049214" />
                                </COMPONENT_NODE>
                            </SPLIT_NODE>
                            <COMPONENT_NODE TOP_INFO="0">
                                <COMPONENT_INFO NAME="DataTypes Provider" OWNER="DataTypeManagerPlugin" TITLE="Data Type Manager" ACTIVE="true" GROUP="Default" INSTANCE_ID="3278479758607618989" />
                            </COMPONENT_NODE>
                        </SPLIT_NODE>
                        <SPLIT_NODE WIDTH="1025" HEIGHT="491" DIVIDER_LOCATION="785" ORIENTATION="VERTICAL">
                            <SPLIT_NODE WIDTH="1386" HEIGHT="638" DIVIDER_LOCATION="705" ORIENTATION="VERTICAL">
                                <SPLIT_NODE WIDTH="1025" HEIGHT="491" DIVIDER_LOCATION="679" ORIENTATION="HORIZONTAL">
                                    <COMPONENT_NODE TOP_INFO="0">
                                        <COMPONENT_INFO NAME="Listing" OWNER="CodeBrowserPlugin" TITLE="Listing: " ACTIVE="true" GROUP="Core" INSTANCE_ID="3278479758150439840" />
                                    </COMPONENT_NODE>
                                    <COMPONENT_NODE TOP_INFO="0">
                                        <COMPONENT_INFO NAME="Decompiler" OWNER="DecompilePlugin" TITLE="Decompiler" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479669854049215" />
                                        <COMPONENT_INFO NAME="Bytes" OWNER="ByteViewerPlugin" TITLE="Bytes: No Program" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758150439843" />
                                        <COMPONENT_INFO NAME="Data Window" OWNER="DataWindowPlugin" TITLE="Defined Data" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758607618999" />
                                        <COMPONENT_INFO NAME="Defined Strings" OWNER="ViewStringsPlugin" TITLE="Defined Strings" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758607618996" />
                                        <COMPONENT_INFO NAME="Equates Table" OWNER="EquateTablePlugin" TITLE="Equates Table" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758150439850" />
                                        <COMPONENT_INFO NAME="External Programs" OWNER="ReferencesPlugin" TITLE="External Programs" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758150439842" />
                                        <COMPONENT_INFO NAME="Functions Window" OWNER="FunctionWindowPlugin" TITLE="Functions" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758150439855" />
                                        <COMPONENT_INFO NAME="Relocation Table" OWNER="RelocationTablePlugin" TITLE="Relocation Table" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758607618994" />
                                    </COMPONENT_NODE>
                                </SPLIT_NODE>
                                <SPLIT_NODE WIDTH="1386" HEIGHT="189" DIVIDER_LOCATION="495" ORIENTATION="HORIZONTAL">
                                    <COMPONENT_NODE TOP_INFO="0">
                                        <COMPONENT_INFO NAME="Data Type Preview" OWNER="DataTypePreviewPlugin" TITLE="Data Type Preview" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758607618988" />
                                    </COMPONENT_NODE>
                                    <COMPONENT_NODE TOP_INFO="0">
                                        <COMPONENT_INFO NAME="Virtual Disassembler - Current Instruction" OWNER="DisassembledViewPlugin" TITLE="Disassembled View" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758150439848" />
                                    </COMPONENT_NODE>
                                </SPLIT_NODE>
                            </SPLIT_NODE>
                            <COMPONENT_NODE TOP_INFO="0">
                                <COMPONENT_INFO NAME="Console" OWNER="ConsolePlugin" TITLE="Console" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758150439849" />
                                <COMPONENT_INFO NAME="Bookmarks" OWNER="BookmarkPlugin" TITLE="Bookmarks" ACTIVE="false" GROUP="Core.Bookmarks" INSTANCE_ID="3278479758150439854" />
                            </COMPONENT_NODE>
                        </SPLIT_NODE>
                    </SPLIT_NODE>
                </SPLIT_NODE>
                <COMPONENT_NODE TOP_INFO="0">
                    <COMPONENT_INFO NAME="Function Call Trees" OWNER="CallTreePlugin" TITLE="Function Call Trees" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758150439851" />
                </COMPONENT_NODE>
            </SPLIT_NODE>
            <WINDOW_NODE X_POS="426" Y_POS="178" WIDTH="1033" HEIGHT="689">
                <COMPONENT_NODE TOP_INFO="0">
                    <COMPONENT_INFO NAME="Script Manager" OWNER="GhidraScriptMgrPlugin" TITLE="Script Manager" ACTIVE="false" GROUP="Script Group" INSTANCE_ID="3278479758150439846" />
                </COMPONENT_NODE>
            </WINDOW_NODE>
            <WINDOW_NODE X_POS="423" Y_POS="144" WIDTH="927" HEIGHT="370">
                <COMPONENT_NODE TOP_INFO="0">
                    <COMPONENT_INFO NAME="Memory Map" OWNER="MemoryMapPlugin" TITLE="Memory Map" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758150439852" />
                </COMPONENT_NODE>
            </WINDOW_NODE>
            <WINDOW_NODE X_POS="383" Y_POS="7" WIDTH="1020" HEIGHT="1038">
                <COMPONENT_NODE TOP_INFO="0">
                    <COMPONENT_INFO NAME="Function Graph" OWNER="FunctionGraphPlugin" TITLE="Function Graph" ACTIVE="false" GROUP="Function Graph" INSTANCE_ID="3278479758607618995" />
                </COMPONENT_NODE>
            </WINDOW_NODE>
            <WINDOW_NODE X_POS="550" Y_POS="206" WIDTH="655" HEIGHT="509">
                <COMPONENT_NODE TOP_INFO="0">
                    <COMPONENT_INFO NAME="Register Manager" OWNER="RegisterPlugin" TITLE="Register Manager" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758607618990" />
                </COMPONENT_NODE>
            </WINDOW_NODE>
            <WINDOW_NODE X_POS="287" Y_POS="186" WIDTH="1424" HEIGHT="666">
                <SPLIT_NODE WIDTH="1408" HEIGHT="559" DIVIDER_LOCATION="573" ORIENTATION="HORIZONTAL">
                    <COMPONENT_NODE TOP_INFO="0">
                        <COMPONENT_INFO NAME="Symbol Table" OWNER="SymbolTablePlugin" TITLE="Symbol Table" ACTIVE="false" GROUP="symbolTable" INSTANCE_ID="3278479758607618997" />
                    </COMPONENT_NODE>
                    <COMPONENT_NODE TOP_INFO="0">
                        <COMPONENT_INFO NAME="Symbol References" OWNER="SymbolTablePlugin" TITLE="Symbol References" ACTIVE="false" GROUP="symbolTable" INSTANCE_ID="3278479758607618998" />
                    </COMPONENT_NODE>
                </SPLIT_NODE>
            </WINDOW_NODE>
            <WINDOW_NODE X_POS="-1" Y_POS="-1" WIDTH="0" HEIGHT="0">
                <COMPONENT_NODE TOP_INFO="0">
                    <COMPONENT_INFO NAME="Checksum Generator" OWNER="ComputeChecksumsPlugin" TITLE="Checksum Generator" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758150439845" />
                </COMPONENT_NODE>
            </WINDOW_NODE>
            <WINDOW_NODE X_POS="-1" Y_POS="-1" WIDTH="0" HEIGHT="0">
                <COMPONENT_NODE TOP_INFO="0">
                    <COMPONENT_INFO NAME="Function Tags" OWNER="FunctionTagPlugin" TITLE="Function Tags" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758150439841" />
                </COMPONENT_NODE>
            </WINDOW_NODE>
            <WINDOW_NODE X_POS="-1" Y_POS="-1" WIDTH="0" HEIGHT="0">
                <COMPONENT_NODE TOP_INFO="0">
                    <COMPONENT_INFO NAME="Comment Window" OWNER="CommentWindowPlugin" TITLE="Comments" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758607618993" />
                </COMPONENT_NODE>
            </WINDOW_NODE>
            <WINDOW_NODE X_POS="-1" Y_POS="-1" WIDTH="0" HEIGHT="0">
                <COMPONENT_NODE TOP_INFO="0">
                    <COMPONENT_INFO NAME="Python" OWNER="InterpreterPanelPlugin" TITLE="Python" ACTIVE="false" GROUP="Default" INSTANCE_ID="3278479758607618992" />
                </COMPONENT_NODE>
            </WINDOW_NODE>
            <WINDOW_NODE X_POS="0" Y_POS="0" WIDTH="0" HEIGHT="0">
                <COMPONENT_NODE TOP_INFO="0">
                    <COMPONENT_INFO NAME="Function Call Graph" OWNER="FunctionCallGraphPlugin" TITLE="Function Call Graph" ACTIVE="false" GROUP="Function Call Graph" INSTANCE_ID="3278479758607618991" />
                </COMPONENT_NODE>
            </WINDOW_NODE>
        </ROOT_NODE>
        <PREFERENCES>
            <PREFERENCE_STATE NAME="docking.widgets.filechooser.DirectoryTableModel:Filename:Size:Modified:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="Filename" WIDTH="164" VISIBLE="true" />
                        <COLUMN NAME="Size" WIDTH="165" VISIBLE="true" />
                        <COLUMN NAME="Modified" WIDTH="164" VISIBLE="true" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="0" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="SymbolTablePlugin">
                <STATE NAME="SELECTION_NAVIGATION_SELECTED_STATE" TYPE="boolean" VALUE="true" />
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.datawindow.DataTableModel:Data:Location:Type:Size:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="ghidra.app.plugin.core.datawindow.DataTableModel$DataValueTableColumn" WIDTH="122" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.AddressTableColumn" WIDTH="98" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.datawindow.DataTableModel$TypeTableColumn" WIDTH="122" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.datawindow.DataTableModel$SizeTableColumn" WIDTH="78" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.OffcutReferenceCountToAddressTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.SymbolTypeTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.MemorySectionProgramLocationBasedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceCountToAddressTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionParameterCountTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionNameTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.NamespaceTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.SourceTypeTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.MemoryTypeProgramLocationBasedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.LabelTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ByteCountProgramLocationBasedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.BytesTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.PreviewTableColumn" WIDTH="75" VISIBLE="false" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="1" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.references.ExternalNamesTableModel:Name:Ghidra Program:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="Name" WIDTH="219" VISIBLE="true" />
                        <COLUMN NAME="Ghidra Program" WIDTH="218" VISIBLE="true" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="0" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.symtable.SymbolReferenceModel:From Location:Label:Subroutine:Access:From Preview:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="ghidra.util.table.field.ReferenceFromAddressTableColumn" WIDTH="119" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceFromLabelTableColumn" WIDTH="119" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.symtable.SymbolReferenceModel$SubroutineTableColumn" WIDTH="118" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.symtable.SymbolReferenceModel$AccessTableColumn" WIDTH="86" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceFromPreviewTableColumn" WIDTH="151" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceFromFunctionTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceTypeTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceFromBytesTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceToPreviewTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceToBytesTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceToAddressTableColumn" WIDTH="75" VISIBLE="false" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="0" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.symtable.SymbolTableModel:Name:Location:Symbol Type:Data Type:Namespace:Source:Reference Count:Offcut Ref Count:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="ghidra.app.plugin.core.symtable.SymbolTableModel$NameTableColumn" WIDTH="260" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.symtable.SymbolTableModel$LocationTableColumn" WIDTH="168" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.SymbolTypeTableColumn" WIDTH="166" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.symtable.SymbolTableModel$DataTypeTableColumn" WIDTH="174" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.symtable.SymbolTableModel$NamespaceTableColumn" WIDTH="152" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.symtable.SymbolTableModel$SourceTableColumn" WIDTH="170" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.symtable.SymbolTableModel$ReferenceCountTableColumn" WIDTH="148" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.symtable.SymbolTableModel$OffuctReferenceCountTableColumn" WIDTH="147" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.symtable.SymbolTableModel$PinnedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.app.plugin.core.symtable.SymbolTableModel$UserTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.OffcutReferenceCountToAddressTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.MemorySectionProgramLocationBasedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceCountToAddressTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.AddressTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionParameterCountTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionNameTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.NamespaceTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.SourceTypeTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.MemoryTypeProgramLocationBasedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.LabelTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ByteCountProgramLocationBasedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.BytesTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.PreviewTableColumn" WIDTH="75" VISIBLE="false" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="3" SORT_DIRECTION="descending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="KNOWN_EXTENSIONS">
                <ARRAY NAME="KNOWN_EXTENSIONS" TYPE="string" />
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.framework.plugintool.dialog.PluginInstallerTableModel:Installation Status:Status:Name:Description:Category:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="ghidra.framework.plugintool.dialog.PluginInstallerTableModel$PluginInstalledColumn" WIDTH="25" VISIBLE="true" />
                        <COLUMN NAME="ghidra.framework.plugintool.dialog.PluginInstallerTableModel$PluginStatusColumn" WIDTH="24" VISIBLE="true" />
                        <COLUMN NAME="ghidra.framework.plugintool.dialog.PluginInstallerTableModel$PluginNameColumn" WIDTH="211" VISIBLE="true" />
                        <COLUMN NAME="ghidra.framework.plugintool.dialog.PluginInstallerTableModel$PluginDescriptionColumn" WIDTH="211" VISIBLE="true" />
                        <COLUMN NAME="ghidra.framework.plugintool.dialog.PluginInstallerTableModel$PluginCategoryColumn" WIDTH="210" VISIBLE="true" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="2" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.datapreview.DataTypePreviewPlugin$MyTableModel:Name:Preview:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="Name" WIDTH="682" VISIBLE="true" />
                        <COLUMN NAME="Preview" WIDTH="681" VISIBLE="true" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="0" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.strings.ViewStringsTableModel:Location:String:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="ghidra.util.table.field.AddressTableColumn" WIDTH="210" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.strings.ViewStringsTableModel$DataValueColumn" WIDTH="210" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.OffcutReferenceCountToAddressTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.SymbolTypeTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.MemorySectionProgramLocationBasedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceCountToAddressTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionBodySizeTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionSignatureTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionParameterCountTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.NamespaceTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionNameTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.SourceTypeTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionPurgeTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.MemoryTypeProgramLocationBasedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.LabelTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ByteCountProgramLocationBasedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.BytesTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionCallingConventionTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.PreviewTableColumn" WIDTH="75" VISIBLE="false" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="0" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.equate.EquateReferenceTableModel:Ref Addr:Op Index:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="Ref Addr" WIDTH="82" VISIBLE="true" />
                        <COLUMN NAME="Op Index" WIDTH="82" VISIBLE="true" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="0" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.equate.EquateTableModel:Name:Value:# Refs:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="Name" WIDTH="88" VISIBLE="true" />
                        <COLUMN NAME="Value" WIDTH="88" VISIBLE="true" />
                        <COLUMN NAME="# Refs" WIDTH="88" VISIBLE="true" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="0" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="docking.widgets.table.GTableFilterPanel$SortedTableModelWrapper:Action Name:KeyBinding:Plugin Name:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="Action Name" WIDTH="359" VISIBLE="true" />
                        <COLUMN NAME="KeyBinding" WIDTH="180" VISIBLE="true" />
                        <COLUMN NAME="Plugin Name" WIDTH="179" VISIBLE="true" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="0" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.bookmark.BookmarkTableModel:Type:Category:Description:Location:Label:Preview:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="ghidra.app.plugin.core.bookmark.BookmarkTableModel$TypeTableColumn" WIDTH="189" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.bookmark.BookmarkTableModel$CategoryTableColumn" WIDTH="204" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.bookmark.BookmarkTableModel$DescriptionTableColumn" WIDTH="313" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.AddressTableColumn" WIDTH="204" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.LabelTableColumn" WIDTH="189" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.PreviewTableColumn" WIDTH="263" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.OffcutReferenceCountToAddressTableColumn" WIDTH="15" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.SymbolTypeTableColumn" WIDTH="15" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.MemorySectionProgramLocationBasedTableColumn" WIDTH="15" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceCountToAddressTableColumn" WIDTH="15" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionParameterCountTableColumn" WIDTH="15" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionNameTableColumn" WIDTH="15" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.NamespaceTableColumn" WIDTH="15" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.SourceTypeTableColumn" WIDTH="15" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.MemoryTypeProgramLocationBasedTableColumn" WIDTH="15" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ByteCountProgramLocationBasedTableColumn" WIDTH="15" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.BytesTableColumn" WIDTH="15" VISIBLE="false" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="0" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="docking.widgets.table.GTableFilterPanel$SortedTableModelWrapper:In Tool:Status:Filename:Description:Key Binding:Full Path:Category:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="In Tool" WIDTH="50" VISIBLE="true" />
                        <COLUMN NAME="Status" WIDTH="50" VISIBLE="true" />
                        <COLUMN NAME="Filename" WIDTH="147" VISIBLE="true" />
                        <COLUMN NAME="Description" WIDTH="245" VISIBLE="true" />
                        <COLUMN NAME="Key Binding" WIDTH="100" VISIBLE="true" />
                        <COLUMN NAME="Full Path" WIDTH="122" VISIBLE="true" />
                        <COLUMN NAME="Category" WIDTH="122" VISIBLE="true" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="2" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="docking.widgets.table.GTableFilterPanel$SortedTableModelWrapper:In::Name:Description:Category:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="In" WIDTH="30" VISIBLE="true" />
                        <COLUMN NAME="" WIDTH="24" VISIBLE="true" />
                        <COLUMN NAME="Name" WIDTH="209" VISIBLE="true" />
                        <COLUMN NAME="Description" WIDTH="277" VISIBLE="true" />
                        <COLUMN NAME="Category" WIDTH="141" VISIBLE="true" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="2" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.register.RegisterValuesPanel$RegisterValuesTableModel:Start Address:End Address:Value:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="Start Address" WIDTH="150" VISIBLE="true" />
                        <COLUMN NAME="End Address" WIDTH="150" VISIBLE="true" />
                        <COLUMN NAME="Value" WIDTH="150" VISIBLE="true" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="0" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.reloc.RelocationTableModel:Location:Type:Values:Original Bytes:Name:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="ghidra.util.table.field.AddressTableColumn" WIDTH="87" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.reloc.RelocationTableModel$RelocationTypeColumn" WIDTH="88" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.reloc.RelocationTableModel$RelocationValueColumn" WIDTH="87" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.reloc.RelocationTableModel$RelocationBytesColumn" WIDTH="88" VISIBLE="true" />
                        <COLUMN NAME="ghidra.app.plugin.core.reloc.RelocationTableModel$RelocationNameColumn" WIDTH="87" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.OffcutReferenceCountToAddressTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceCountToAddressTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionParameterCountTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionNameTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.BytesTableColumn" WIDTH="75" VISIBLE="false" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="0" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="docking.widgets.pathmanager.PathManagerModel:Use:Path:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="Use" WIDTH="50" VISIBLE="true" />
                        <COLUMN NAME="Path" WIDTH="294" VISIBLE="true" />
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.memory.MemoryMapModel:Name:Start:End:Length:R:W:X:Volatile:Type:Initialized:Source:Comment:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="Name" WIDTH="103" VISIBLE="true" />
                        <COLUMN NAME="Start" WIDTH="103" VISIBLE="true" />
                        <COLUMN NAME="End" WIDTH="103" VISIBLE="true" />
                        <COLUMN NAME="Length" WIDTH="103" VISIBLE="true" />
                        <COLUMN NAME="R" WIDTH="25" VISIBLE="true" />
                        <COLUMN NAME="W" WIDTH="25" VISIBLE="true" />
                        <COLUMN NAME="X" WIDTH="25" VISIBLE="true" />
                        <COLUMN NAME="Volatile" WIDTH="50" VISIBLE="true" />
                        <COLUMN NAME="Type" WIDTH="103" VISIBLE="true" />
                        <COLUMN NAME="Initialized" WIDTH="60" VISIBLE="true" />
                        <COLUMN NAME="Source" WIDTH="103" VISIBLE="true" />
                        <COLUMN NAME="Comment" WIDTH="102" VISIBLE="true" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="1" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
            <PREFERENCE_STATE NAME="ghidra.app.plugin.core.functionwindow.FunctionTableModel:Label:Location:Function Signature:">
                <XML NAME="COLUMN_DATA">
                    <Table_State>
                        <COLUMN NAME="ghidra.util.table.field.LabelTableColumn" WIDTH="148" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.AddressTableColumn" WIDTH="124" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionSignatureTableColumn" WIDTH="148" VISIBLE="true" />
                        <COLUMN NAME="ghidra.util.table.field.OffcutReferenceCountToAddressTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.SymbolTypeTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.MemorySectionProgramLocationBasedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ReferenceCountToAddressTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionBodySizeTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionParameterCountTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.NamespaceTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionNameTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.SourceTypeTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionPurgeTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.MemoryTypeProgramLocationBasedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.ByteCountProgramLocationBasedTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.BytesTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.FunctionCallingConventionTableColumn" WIDTH="75" VISIBLE="false" />
                        <COLUMN NAME="ghidra.util.table.field.PreviewTableColumn" WIDTH="75" VISIBLE="false" />
                        <TABLE_SORT_STATE>
                            <COLUMN_SORT_STATE COLUMN_MODEL_INDEX="1" SORT_DIRECTION="ascending" SORT_ORDER="1" />
                        </TABLE_SORT_STATE>
                    </Table_State>
                </XML>
            </PREFERENCE_STATE>
        </PREFERENCES>
    </TOOL>
</TOOL_CONFIG>


```